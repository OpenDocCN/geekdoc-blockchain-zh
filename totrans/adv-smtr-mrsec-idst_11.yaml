- en: Chapter 11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Secure File Storage in Cloud Computing Using a Modified Cryptography Algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Manya Smriti
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vellore Institute of Technology, India
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Shruti Varsha Venkatraman
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vellore Institute of Technology, India
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Aashish Raj
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vellore Institute of Technology, India
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Vaishnavi Raj Shukla
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vellore Institute of Technology, India
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Aswani Kumar Aswani Cherukuri
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[![Orcid Image](i/orcid.svg) https://orcid.org/0000-0001-8455-9108](https://orcid.org/0000-0001-8455-9108)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Vellore Institute of Technology, India
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ABSTRACT
  prefs: []
  type: TYPE_NORMAL
- en: This chapter investigates the security issues identified with the file cloud
    storage to ensure the security of client information in cloud information server.
    The authors have proposed a modified RSA algorithm with multiple keys and CRT
    to ensure confidentiality of data coupled with hashing through SHA-512 to maintain
    integrity. This work has made a secure data exchange app where files are encrypted
    using the RSA-CRT algorithm and hashed later. On successfully implementing the
    work, they observed that the proposed technique is more secure than the original
    RSA algorithm and RSA-CRT. Furthermore, it enhanced the algorithm performance
    for decryption because it employed the CRT for decryption; thus, the proposed
    technique proved to be faster than RSA with multi keys.
  prefs: []
  type: TYPE_NORMAL
- en: INTRODUCTION
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm of RSA is an asymmetric cryptography technique. This is working
    on two keys, i.e. public key and private key. The proposed model in our work takes
    four prime evaluating techniques and discovers extension to build up a far-off
    information reviewing strategy that can be utilized to check the uprightness of
    the redistributed information in numbers for modified RSA. Instead of sending
    one public key directly, send two public keys to the receiver. However, there
    is the problem of the speed, so that in RSA decryption used the Chinese remainder
    theorem to enhancement the speed of RSA decryption.
  prefs: []
  type: TYPE_NORMAL
- en: BACKGROUND
  prefs: []
  type: TYPE_NORMAL
- en: Literature Survey
  prefs: []
  type: TYPE_NORMAL
- en: Yang et al. (Yang & Jia, 2012) proposed a proficient and intrinsically secure
    dynamic reviewing convention. It secures the information protection against the
    reviewer by consolidating the cryptography strategy with the bi-linearity property
    of bi-linear paring instead of utilizing the veil method. In this manner, their
    multi-cloud clump reviewing convention does not require any extra coordinator.
    Their cluster reviewing convention can likewise bolster the clump examining for
    numerous proprietors. Moreover, their evaluating conspire brings about less correspondence
    cost and less calculation cost of the evaluator by moving the registering loads
    of evaluating from the inspector to the worker, which enormously im- proves the
    evaluating execution and can be applied to enormous scope distributed storage
    frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: Li et al. (Li et al., 2017) concentrated on the issue of the cloud information
    stockpiling and planned to give a methodology that could stay away from the cloud
    administrators arriving at client’ delicate information. Tending to this objective,
    they proposed a novel methodology entitled as Security-Aware Effective Distributed
    Storage (SA-EDS) model. In this model, they utilized their proposed calculations,
    including Alternative Data Distribution (AD2), Secure Efficient Data Distributions
    (SED2) and Efficient Data Conflation (ED- Con) calculations. Their exploratory
    assessments had demonstrated that their proposed plan could viably shield significant
    dangers from the cloud side. The calculation time was shorter than current dynamic
    methodologies. Future work would address making sure about information duplications
    so as to increment the degree of information accessibility since any of datacentre’s
    down will cause the disappointment of information recoveries.
  prefs: []
  type: TYPE_NORMAL
- en: Bindu et al. (Shwetha Bindu & Yadaiah, 2011), contemplated the issue of information
    security in cloud servers. To en- sure the accuracy of clients’ information in
    cloud information server, they proposed a viable and adaptable plan with unequivocal
    unique information support, including square change, delete, and join. They use
    erasure-correcting code in the record dissemination planning to give repetition
    equality vectors and assurance the information reliability. Their plan achieves
    the joining of capacity rightness protection and information defilement has been
    recognized during the capacity accuracy check over the circulated workers. Their
    plan is exceptionally productive and tough to Byzantine disappointment, noxious
    information alteration assault, and even worker intriguing assaults. They accept
    that information stockpiling security in Cloud Computing, a zone loaded with difficulties
    and of prevailing essentials, is still in its early stages to be distinguished.
    They imagine a few potential bearings for future examination on this territory.
    It permits Third Parity Auditor to review the cloud information stockpiling without
    requesting clients’ time, likelihood.
  prefs: []
  type: TYPE_NORMAL
- en: Sookhak (Sookhak, 2015) examines the issue of extra handling time in the current
    distributed computing.
  prefs: []
  type: TYPE_NORMAL
- en: It proposed a topical scientific classification based on the best in class information
    evaluating techniques to meet the necessities to distinguish the holes and remarkable
    issues in the zone of information stockpiling trustworthiness of distributed computing.
    The subjective examination is utilized to analyze the current strategies and feature
    the points of interest and impediments of them and open issues and difficulties
    of information inspecting plans in cloud and portable distributed computing condition
    that have not been tended to yet were distinguished and featured. The current
    information inspecting approaches were actualized in the genuine distributed computing
    condition, and the benchmark test was utilized to assess such strategies dependent
    on the calculation and correspondence cost on the customer and worker side. In
    addition, the effect of dynamic information update tasks was breaking down on
    the current information approaches in the genuine condition. It examined the impact
    of dynamic information update procedure for the enormous scope document size.
    At last, the effect of regular information refreshes was assessed for various
    size of the documents. Another far off information evaluating strategy was proposed
    based on mathematical mark procedure to satisfy the target of productive answer
    for checking the honesty of the redistributed information in distributed computing.
    The proposed conspire addresses the issue of extra calculation and correspondence
    cost for cloud information stockpiling framework. The D&CT information structure
    likewise enables their strategy to be pertinent for huge scope information with
    least preparing time on the customer. The proposed information examining plan
    is executed in the genuine condition by utilizing java and C++ language to address
    the target of assessing DRDA technique. The presentation of the DRDA plot was
    approved by utilizing the benchmark test in the copying condition and broke down
    the DRDA conspire by utilizing unmistakable boundaries, for example, length of
    mark, document size, and the likelihood of identification. The various situations
    likewise characterized to assess the proposed strategy.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, it broke down the quality of the security based on mathematic to approve
    and verify the security of the DRDA technique. The outcomes indicated that the
    D&CT information structure lessens the handling season of dynamic information
    update activities by diminishing the quantity of moving. Furthermore, the D&CT
    information structure significantly declines the preparing season of dynamic information
    update for enormous scope re-appropriated record in distributed computing.
  prefs: []
  type: TYPE_NORMAL
- en: Chambre et al. (Shimbre & Deshpande, 2015) talks about the record circulation
    and SHA-1 strategy. At the point when the document is conveyed, then information
    is likewise isolated into numerous work- ers. So here the need of information
    security emerges. Each square of record contains its own hash code, utilizing
    hash code which will improve client verification process; just approved individual
    can get to the information. Here, the information is encoded utilizing propelled
    encryption standard, so information is effectively and safely put away on cloud.
    Outsider reviewer is utilized for open inspecting. This paper talks about the
    treatment of some security issues like Fast mistake limitation, information honesty,
    information security. The proposed plan permits clients to review the information
    with lightweight correspondence and calculation cost. Examination shows that the
    proposed framework is profoundly effective against noxious information adjustment
    assault and worker plotting assault. Execution and broad security examination
    shows that proposed frameworks are provably secure and exceptionally productive.
    They show that their plan is profoundly productive for worker conspiring assault
    and vindictive information adjustment assault with least calculation overhead.
    Execution investigation and broad security shows that the proposed plot is provably
    secure and profoundly productive. Behl (Behl, 2011) investigated the security
    issues identified with the cloud. The paper likewise talks about the current security
    ways to deal with secure the cloud framework and applications and their disadvantages.
  prefs: []
  type: TYPE_NORMAL
- en: There are various security challenges in the haze of which, this paper has attempted
    to address the most widely recognized and basic ones. A protected cloud is unthinkable
    except if the virtual condition viz. foundation, VM, interfaces, organize transmissions
    are secure. Cloud condition request much over the customary security arrangements,
    which do not plan well to the virtualized situations, in view of the mind-boggling
    and dynamic nature of the distributed computing. As a venturing stone, cloud suppliers
    and clients should cooperate on characterizing the prerequisites and the points
    of interest. It is 220 2011 World Congress on Information and Communication Technologies
    certain that new virtualization-mindful security arrangements ought to be actualized
    to guarantee the pre-emptive security to the general framework. The cloud security
    arrangements ought to have the knowledge to act naturally safeguarding and be
    able to give constant checking, discovery and avoidance of known and obscure dangers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Usman et al. (Usman et al., 2017) scrambled mystery information in compacted
    video transfers is a moderately new examination region which is drawing in consideration
    of scientists. This is basically because of protection and security issues worried
    about the open mists. In this article, a made sure about conspire has been introduced
    which shrouds the mystery information in HEVC encoded video transfer, i.e., in
    packed area. The proposed plot comprises three significant stages: video encoding,
    information encryption, and unscrambling with/without interpreting. The proposed
    conspire attempts to keep up the first video transfer size after encryption with-
    out influencing the visual nature of video information. In this way, it creates
    a perfect stage for constant video applications. The mystery information is appropriated
    in encoded video transfer, so it is hard for programmers to remove whole mystery
    information. This is be- cause of the way that programmers do not have the foggiest
    idea about the specific areas and examples of the concealing plan, regardless
    of whether they take the mystery key. Another significant bit of leeway is that
    their proposed conspire completely bolsters the encoding and unraveling structure
    of the HEVC standard. The video transfer with encoded mystery information can
    undoubtedly be decoded without undermining or indicating extra concealed data.
    Test results have demonstrated that the proposed plot keeps up the visual quality
    with a slight trade-off on expanding the size of the encoded video transfer.'
  prefs: []
  type: TYPE_NORMAL
- en: Garg et al. (Garg & Sharma, 2014) discussed that at the point when an asset
    obliged cell phone stores its information on the cloud, there is consistently
    a major worry of whether the cloud specialist organization stores the documents
    accurately or not. Security is the principle worry in portable distributed computing.
    The proposed instrument gives a security component to making sure about the information
    in portable distributed computing with RSA calculation and hash work. This exploration
    paper has proposed an instrument to give classification and honesty to the information
    put away in portable cloud. The proposed plot utilizes RSA calculation with other
    encryption decoding procedures to make sure about the information in such a way
    that no spillage of information on cloud could be performed. In this plan, encryption
    is utilized to give security to the information while in communication. Since
    the scrambled record is put away on the cloud, so client can accept that his information
    is secure. In the plan record, just in scrambled structure is moved over the channel,
    which lessens the issue of data divulgence. No, third individual or gatecrasher
    can get the document since that individual do not knows the key of information
    proprietor. There is consistently an extension for development in each field of
    work, so here too. One of the suspicion made in all the models of security are
    that the TP An is nonpartisan. All the calculations and confirmations are offloaded
    to TP A, so there is a need to make TP A safer. Future work could be investigating
    the utilizations of other systems applied in secure capacity administrations of
    portable cloud condition. Some work should likewise be possible to diminish the
    overhead of versatile terminal.
  prefs: []
  type: TYPE_NORMAL
- en: Samir et al. proposed model in the paper takes 4 prime number in RSA and instead
    of using one public key, 2 public key is sent to the receiver. The problem of
    speed is sorted out by using RSA with Chinese Remainder Theorem. Chinese Remainder
    Theorem, CRT, is a theorem in mathematics that can be used in cryptography .Its
    application is computing, which is very important in regard to calculations of
    algorithmic and computations modular. The Chinese remainder theorem (CRT) determines
    a single integer from its remainders from a set of modulos. It has also got applications
    in digital signal processing. CRT allows for RSA algorithm implementation very
    efficiently. If the same message is encrypted using random key more than one time
    makes the ciphertext look different every time is used here. The comparison in
    the paper clearly states the all-time encryption and decryption of RSA-CRT is
    nearly half to that of RSA. For a 640 bit length plaintext, RSA-CRT to RSA time
    taken is 26:42\. The paper shows in-depth research about how it claims RSA-CRT
    an enhanced algorithm than RSA.
  prefs: []
  type: TYPE_NORMAL
- en: Pant et al. (Pant et al., 2015) discussed information and data security as a
    most significant issue of cloud processing and IT industry. In this paper they
    utilize some strategy to make sure about information in cloud or web. This paper
    examined security issues in distributed computing frameworks and how they can
    be forestalled, here they use cryptography and steganography strategy together
    to make sure about information. RSA calculation is safer than other calculation.
    They incorporate RSA calculation with other calculation to give greater security
    to information. In steganography, they get scrambled picture, which appears to
    be identical to a unique picture by the natural eye. In the event that they examination
    the picture double codes then the distinctions would be seen. Else they are incapable
    of recognizing the first picture. The methodology they have use in this paper
    will assist with making a solid structure for the security of information in distributed
    computing field or web.
  prefs: []
  type: TYPE_NORMAL
- en: Somani et al. (Somani et al., 2010) discussed that among the numerous IT powerhouses
    driven by pat- terns in distributed computing has not dicey. It gives nearly everybody
    has brought uplifting news. For ventures, cloud processing is deserving of thought
    and attempt to fabricate busi- ness frameworks as a path for organizations along
    these lines can without a doubt realize lower costs, higher benefits and more
    decision; for huge scope industry, After the monetary unrest will be the expense
    of framework for huge scope pressure appears to be likely; de- signers, when in
    the face of distributed computing, through the PaaS model can adequately improve
    their own limit, Therefore, the effect of cloud processing on the ISV is the biggest
    of the numerous jobs; for architects and engineers are concerned. There is the
    approach of cloud registering will undoubtedly birth various new openings. The
    mists will develop in size as before long as accessible transfer speed and the
    relating administration model develop enough, distributed computing will bring
    a progressive change in the Internet. Cloud register- ing reported a minimal effort
    supercomputing administrations to give the plausibility, while there are an enormous
    number of producers behind, there is no uncertainty that distributed computing
    has a splendid future.
  prefs: []
  type: TYPE_NORMAL
- en: Arora et al. (Arora et al., 2013) discussed in this paper, encryption calculations
    have been proposed to make cloud information secure, helpless and offered worry
    to security issues, challenges and furthermore examinations have been made between
    AES, DES, Blowfish and RSA calculations to locate the best security calculation,
    which must be utilized in distributed computing for making cloud information secure
    and not to be hacked by assailants. Encryption calculations assume a significant
    job in information security on cloud, and by examination of various boundaries
    utilized in calculations, it has been discovered that AES calculation utilizes
    least an ideal opportunity to execute cloud information. Blowfish calculation
    has least memory prerequisite. DES calculation expends least encryption time.
    RSA devours longest memory size and encryption time. By doing execution for all
    calculations in IDE apparatus and JDK 1.7, the ideal yield for the information
    on distributed computing has been accomplished. In the present time request of
    cloud is expanding, so the security of the cloud and client is on top concern.
    Henceforth, proposed calculations are useful for the present prerequisite. In
    future a few correlations with various methodologies and results to show the adequacy
    of the proposed structure can be given.
  prefs: []
  type: TYPE_NORMAL
- en: Ruj et al. (Ruj et al., 2012) discussed a security safeguarding access control
    plot that gives fine-grained get to control and confirms clients who store data
    in the cloud. The cloud anyway does not have the foggiest idea about the personality
    of the client who stores data, however just confirm the client’s accreditations.
    Key appropriation is done in a decentralized manner. One restriction is that the
    cloud knows the entrance strategy for each record put away in the cloud. In future,
    they might want to ensure the security of client traits as well. In this paper,
    they propose another security saving validated access control conspire to make
    sure about mists’ information. In the proposed plot, the cloud checks the validness
    of the client without realizing the client’s personality before putting away data.
    Likewise, their plan has the additional element of access control where just legitimate
    clients can unscramble the put away data. The plot forestalls replay assaults
    and supports creation, adjustment, also, perusing information put away in the
    cloud. In addition, their validation also gets to control plot is decentralized
    and vigorous, in contrast to others getting to control plans intended for mists
    brought together. The correspondence, calculation, and capacity overheads are
    tantamount to brought together methodologies.
  prefs: []
  type: TYPE_NORMAL
- en: Subashini et al. (Subashini & Kavitha, 2011) discussed in this paper, they examined
    the issues in security in in- formation capacity in cloud condition. This makes
    the information priceless regardless of whether an interloper gains admittance
    to this information. Even though this model will require some quantifiable exertion
    to be actualized continuously, it gives the essential answer for a situation like
    the cloud, indicating an antagonistic potential to turn into the cutting edge
    undertaking condition. Executing such a model during the prior periods of the
    development of the framework will be generally simpler as for actualizing it after
    part of information take exile in the cloud. This model in blend with their multi-level
    security model for making sure about information over transmission will give legitimate
    crossbars in the wires of malevolent clients.
  prefs: []
  type: TYPE_NORMAL
- en: Wang et al. (Wang et al., 2010) discussed cloud computing has been imagined
    as the next-gen of big business IT. As opposed to conventional venture IT arrangements,
    where the IT administrations are under appropriate physical, coherent, and faculty
    controls, distributed computing moves the application programming and databases
    to workers in enormous server farms on the Internet, where the administration
    of the information and administrations are not completely dependable. In this
    article they center around cloud information stockpiling security. They first
    present a organize engineering for viably portraying, creating, also, assessing
    secure in- formation stockpiling issues. Through inside and out investigation,
    some current information stockpiling security building squares are inspected.
    The advantages and disadvantages of their pragmatic ramifications in the setting
    of distributed computing are summed up. Further testing issues for open examining
    administrations that should be engaged on are talked about as well. They accept
    security in cloud computing, a region brimming with difficulties and of vital
    significance, is still in its outset presently yet will pull in colossal measures
    of research exertion for a long time to come.
  prefs: []
  type: TYPE_NORMAL
- en: Zhou et al. (Zhou et al., 2013) discussed in this paper, first it proposes RBE
    plot that accomplishes proficient client disavowal. At that point, they introduced
    a RBAC based distributed storage design which permits an association to store
    information safely in an open cloud, while keeping up the delicate data identified
    with the association’s structure in a private cloud. At that point, they have
    built up a safe distributed storage framework engineering and have indicated that
    the framework has a few unrivaled attributes, for example, steady size cipher
    text and decoding key. Their trials see that both encryption and decoding calculations
    are effective on the customer side, and decoding time at the cloud can be decreased
    by having different processors, which is normal in a cloud condition. They accept
    that the proposed framework can be valuable in business circumstances as it catches
    handy access arrangements dependent on jobs in an adaptable way. What’s more,
    it gives secure information stockpiling in the cloud authorizing these get to
    strategies.
  prefs: []
  type: TYPE_NORMAL
- en: Hardik et al. (Gandhi & Gupta, 2015) discussed that in the current scenario,
    everything is being transferred on the web and other communication medium. We
    need to make our data secure from all other attacker and unauthorized person.
    By the use of Magic Rectangle, we can have different ciphertext for the same character.
    This approach gives enhancement to the public key cryptosystem. This work prohibits
    any intruders from obtaining the plain text in a readable form. The security aspect
    is enhanced as there is no repetition of values in Magic rectangle. Even if the
    intruders found the initial values of MR, it is very difficult to trace the row/column.
    One of the issues in the proposed work is additional time needed for the construction
    of Magic rectangle initially.
  prefs: []
  type: TYPE_NORMAL
- en: Shinde et al. (Shinde & Fadewar, 2008) discussed in this paper talks about the
    RSA cryptography algorithm. After the author gave a brief list and notes on cryptographic
    goals, they then elaborated on the working of the RSA cryptographic algorithm.
    How the keys are generated, and how the encryption and decryption is done. CRT
    is then introduced with an elaborate functioning. The author then shows the steps
    to using RSA with CRT, how to use them together in the process of encryption and
    decryption. The proposed approach (RSA-CRT) is then analyzed on the basis of security
    and performance. An approach of implementing the said proposed approach is done
    in java, displaying the message, the sender’s and receiver’s public and private
    keys and the encryption and decryption. The paper then concludes that the encryption
    is more effective with CRT.
  prefs: []
  type: TYPE_NORMAL
- en: Lakshmi and Chandravathi (Lakshmi, 2020) discussed in this paper the author
    discussed that the private data is prone to numerous noxious attacks. Henceforth,
    the requirement for ensuring secret data has gotten a significant challenge over
    the Internet. Cryptographic techniques are the most ideal decision for giving
    protection from pernicious attacks. By applying different strategies, data can
    be secured. For making sure about data over the cloud is another significant test,
    which is still must be thought of. The Homomorphic Encryption is a promising technique
    for making sure about data in the cloud. In this paper the author proposed RSA
    calculation utilizing numerous public key sets with Homomorphic Encryption. The
    thought is to produce a critical pair from numerous keys utilizing RSA homomorphic
    encryption, which is halfway homomorphic in nature, rather than a solitary key
    pair. This strategy uses one key for encryption and the other for decryption.
    The excellence of this plan is that a solitary key pair is chosen from numerous
    key sets which communicate with different users. Different key age strategies
    use some numerical rationale for acquiring public key straightforwardly, when
    contrasted with RSA with single key. Thusly, the attacks for finding the private
    key are halted.
  prefs: []
  type: TYPE_NORMAL
- en: Kim et al. (Kim et al., 2020) discussed that private exponent in RSA is generated
    from public exponent which are pre-selected by using Euclid’s algorithm. It is
    nearly as same as modulus number in terms of bit size. So, reduction in private
    and public exponent is not easy in RSA during key generation. CRT method discussed
    in which exponent is reduced and a fast and more secure method was introduced
    to reduce exponent. The paper discussed about prime number generation mechanism
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: Balaji et al. (Balaji et al., 2018) discussed the limitations of Efficiencies
    in Cloud resource management which are largely determined by pre-set rules and
    are reactive. To overcome this, the authors adopted a cloud resource management
    done by a predictive method. AWS t2 micro instance was used to host a read-intensive
    application for on-off timesheets, and using historical data, simulation based
    workload patterns were made. Comparisons were made between the existing and proposed
    methods which showed that the proposed method had reduced the errors, decreased
    the waiting time for users, increased number of requests and improved utilization
    of resources.
  prefs: []
  type: TYPE_NORMAL
- en: Balaji et al. (Balaji et al., 2019) discussed in this paper that by assuming
    enterprise workloads are constant, resource provisioning becomes ineffective.
    By analyzing synthetic bursty workloads, the current research aims to address
    this challenge. The researchers used Hurst Exponent and Sample Entropy metrics
    to build resource provisioning models. NASA datasets were used to compare the
    performance of the proposed method with the baseline reactive approach and the
    index of dispersion method.
  prefs: []
  type: TYPE_NORMAL
- en: Narayanan et al. (Narayanan & Cherukuri, 2018) discussed that To acquire current
    information about a patient, along with tracking purpose, the Data Lake has to
    be moved to a Cloud for analyzing and analyzing the data would require moving
    the data to a Cloud. Based on this research, the authors recommend using Data
    Lake in Cloud as a cloud-based integration framework. The work presented here
    extends the information integration architecture through the design of using a
    mathematical model (Petri Net) to verify an architecture for Data Lake in Cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Balaji et al. (Balaji et al., 2014) discussed that using predefined limits,
    cloud service providers provide or de-provision resources based on average consumption.
    As a consequence, it does not fully address the diverse range of enterprise use
    cases. There have been few cases reported of resource management using predictive
    techniques, even though they could perform more effectively. To manage resources
    effectively in a cloud environment, it is crucial to establish a model that can
    predict how the system will perform under load. As the metric for monitoring resource
    utilization, they used Request rate to compare the performances of two such predictions
    models, Holt-Winter and ARIMA. Several selected ARIMA models were shown to perform
    better than the Holt-Winter model, which would subsequently be useful for managing
    resources on the cloud if data request rates followed a similar trend
  prefs: []
  type: TYPE_NORMAL
- en: PROBLEM DEFINITION
  prefs: []
  type: TYPE_NORMAL
- en: In Cloud Storage, we share data among many clients, server and people. Thus,
    the security of information present in the cloud is not guaranteed since it is
    easy for an intruder to access and demolish the first type of information. So,
    there is a requirement of some plainly key which help us to do cross breed encryption
    and protect the data. The algorithm of RSA is an asymmetric cryptography technique,
    this is working on two keys, i.e. public key and private key. The proposed model
    takes four prime numbers in RSA. Instead of sending one public key directly, send
    two public keys to the receiver. But there is the problem of the speed, so that
    in RSA decryption used the Chinese remainder theorem to enhance RSA decryption
    speed.
  prefs: []
  type: TYPE_NORMAL
- en: Contribution of the Work
  prefs: []
  type: TYPE_NORMAL
- en: 'Our work contributes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '1\. New approach of the RSA algorithm: Modified RSA with CRT and multiple keys:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IN ITSELF, the RSA algorithm is an asymmetric algorithm, which is deemed to
    be secure, but lacks in the speed component. Especially when the prime numbers
    used to generate keys are very large, the time it takes to compute all the necessary
    computations can be long as it has to ensure the security.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus with our proposed approach, we are implementing both security and speed.
    With CRT in the midst of this approach, it breaks down the main parts of the algorithm
    to increase the throughput rate up to 4 times. This is done by partitioning the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: DP; DQ; DR; DS < D and CP; CQ; CR; CS < C
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By doing this, CRT reduces the size of the numbers to less than half their original
    sizes, which would automatically speed up the algorithm, making it take lesser
    time to compute.
  prefs: []
  type: TYPE_NORMAL
- en: RSA with more than 2 prime numbers – RSA with multiple keys helps to ensure
    more security. In the normal RSA algorithm, there are 2 prime numbers present,
    which would be undergoing a few computations to generate a public key and a private
    keys, which in turn are used in the encryption and decryption process.
  prefs: []
  type: TYPE_NORMAL
- en: In RSA with multiple keys, the number of prime numbers are doubled. There are
    4 prime numbers, which in turn will be undergoing computations to generate 4 keys.
    With the doubling of the prime numbers, naturally, all the computation processes
    will be doubled as well. There will 2 public keys and 2 private keys generated.
  prefs: []
  type: TYPE_NORMAL
- en: Encryption and decryption which had one step each in the normal RSA, now in
    RSA with multiple keys has two steps each. Both sets of public and private keys
    are used in the encryption and decryption processes. Double the amount of encryption
    and decryption are done which increases the security.
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Hash to ensure authenticity and integrity of message:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hash algorithms, particularly the SHA-512, are known for ensuring the authenticity
    and integrity of the messages sent from person to person. We are using SHA-512
    for the same. We hash the message after it is read from the file and store the
    hash in the database for further use in the receiver’s end.
  prefs: []
  type: TYPE_NORMAL
- en: When the receiver is done with the decryption, and the message is uncovered,
    our pro- posed algorithm then hashes the decrypted message to compare with the
    other hash. If both the hashes match, then it implies that the message is authentic
    and has integrity. Otherwise, it shows a breach and that the message has lost
    its authenticity and integrity.
  prefs: []
  type: TYPE_NORMAL
- en: '3\. Generating prime numbers from the user’s password:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Normally, a function is used to generate random large prime numbers, which
    is in turn used for key generation. It does have its advantages. Nevertheless,
    we are proposing a new way of generating prime numbers: generating them from the
    user’s password. By using the password of the user who is trying to log in to
    the portal or interface, specific arithmetic operations are done on the user’s
    password.'
  prefs: []
  type: TYPE_NORMAL
- en: Taking the asci value of the password, operations such as multiplication, addition,
    multiplying the squares of the asci values, or adding the squares of the asci
    values are done. These operations will generate 4 prime numbers, and the same
    operation will not be done to generate all the numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Thus we generated a method for computing big prime numbers, and it isn’t needed
    to be saved in the database. And this approach is also unique. The password is
    only known to the user, so we need to keep the password secure, which is necessary
    for every application or website. We didn’t save the private key in the database
    so even if the database is attacked, the attacker will just get encrypted text
    in a binary form which is almost impossible to decrypt without knowing the segment
    size and the private key and both aren’t available anywhere, they are generated
    when only we decipher the text in the application and it makes this process very
    much efficient and secure.
  prefs: []
  type: TYPE_NORMAL
- en: '4\. Another level of security for the ciphertext:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Considering the normal RSA algorithm, the ciphertext is an integer which is
    sent to the receiver for decryption. In case, an attacker gets or finds the public
    key, they can crack the ciphertext to access the message being sent by attacks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our approach does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: a. Converts the message into its ASCII value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: b. Each ASCII value, which is a decimal number, is encrypted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: c. Each ciphertext is converted to its binary equivalent and appended as a long
    binary string and stored in the database to be used by the receiver for decryption.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the above steps in our approach, we can ensure that an attacker will find
    it extremely difficult to find out the number of bits that the binary string should
    be split into. With a binary string that is very long, figuring out its original
    form, whether it is an integer, an octal number, or a text would be incredibly
    hard. It would be a long process of trial error which would mostly end fruitless.
  prefs: []
  type: TYPE_NORMAL
- en: PROPOSED MODEL
  prefs: []
  type: TYPE_NORMAL
- en: Detailed Architecture
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1 shows that for the first time, if a user signup for the portal, a dynamic
    table is created in the database for the user which stores his/her password for
    the portal. A separate table each for storing the private key and public key of
    every user. All the password/keys of the user is stored by applying cryptographic
    hash function MD5 in database as storing plain text passwords in the database
    is no less than a sin.
  prefs: []
  type: TYPE_NORMAL
- en: When the user login successfully to the portal, he is redirected to his chatbox.(To
    do so, the contact’s stored in the database is extracted dynamically). All the
    previous exchanged files appears in the chatbox.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2 shows that when a file is sent, the file is uploaded in the database
    which serves as a Cloud to the user. Now, the file stored in the database is actually
    large binary values(as a result of RSA-CRT encryption). For implementing RSA-CRT,
    public key and private key is retrieved from the database. SHA-1 is used for ensuring
    integrity of the data. So the third party has no access to the data sent and received
    between two users. It acts as cloud since the user need not download the exchanged
    file, just by clicking on the file, he can view the current and previously exchanged
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Algorithm Architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Figure 1\. Storing the log in information and generation of public and private
    key in the database |'
  prefs: []
  type: TYPE_TB
- en: '| ![Figure978-1-7998-8367-8.ch011.f01](i/ch011.f01.png) |'
  prefs: []
  type: TYPE_TB
- en: '| Figure 2\. The sender sending a text file to a receiver, which is read, encrypted
    and decrypted by RSA-CRT with multiple keys and verified for authenticity and
    integrity using Hash. |'
  prefs: []
  type: TYPE_TB
- en: '| ![Figure978-1-7998-8367-8.ch011.f02](i/ch011.f02.png) |'
  prefs: []
  type: TYPE_TB
- en: 'Figure 3 shows algorithm flow in the sender’s side. The key generation process
    is initiated when the user/sender logs in to the interface. As the proposed approach
    is Modified RSA with CRT, the number of steps in the RSA key generation and encryption
    decryption is doubled. Four big prime numbers are generated. Let them be ‘p’,’q’,’r’
    and ‘s’. Components of the keys ie., ‘n’ and ‘z’ are calculated using the generated
    primes. Their Euler Totient value of the components are also computed. Another
    set of components of the keys are enumerated, namely: ’I and ’g’. Following that
    the main elements of the keys are then determined using the enumerated numbers.
    The keys are generated and determined in this order. The file uploaded by the
    sender is read by the algorithm, which then converts each character into its ASCII
    decimal equivalent. Along with that, the context on the file is hashed using SHA-512
    and saved in the database for verifying in the receiver’s end. Each ASCII decimal
    equivalent is encrypted using the Modified RSA steps and stored in an array. Each
    element of the cipher array is then converted to its binary equivalent with a
    common block size, and appended. This binary string is then saved in the database
    for the receivers to use for decryption.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4 shows algorithm flow in the receiver’s side: The algorithm in the
    receiver’s side first accesses the database for the binary string. The block size
    splits the string, and each block is stored in an array. Each binary element is
    converted to its decimal equivalent. Decryption is done for each decimal equivalent
    by the steps of Modified RSA. After each decryption, the computed values are again
    saved in an array. These values are then converted into their ASCII character
    equivalent. And they are appended as a string to put together the content. This
    string is hashed with SHA-512\. It is compared with the hash value already stored
    in the database to verify for authenticity and integrity. If the hashes are the
    same, the context is written to a file and made viewable to the receiver who can
    access it.'
  prefs: []
  type: TYPE_NORMAL
- en: Functionality
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5 shows a gist of application we have made, a secure data exchange app
    where files are encrypted using the RSA-CRT algorithm. For the first time, if
    a user signup for the portal, a dynamic table is created in the database for the
    user which stores his/her password for the portal. A separate table each for storing
    the private key and public key of every user. All the password/keys of the user
    is stored by applying cryptographic hash function MD5 in database as storing plain
    text passwords in the database is no less than a sin.
  prefs: []
  type: TYPE_NORMAL
- en: When the user login successfully to the portal, he is redirected to his chatbox.
    (To do so, the contact’s stored in the database is extracted dynamically). All
    the previous exchanged files appear in the chatbox.
  prefs: []
  type: TYPE_NORMAL
- en: Now when the user sends a file? What happens?
  prefs: []
  type: TYPE_NORMAL
- en: When a file is sent, the file is uploaded in the database which serves as a
    Cloud to the user. Now, the file stored in the database (which will be used further
    for retrieval purpose by the user) is actually large binary values (as a result
    of RSA-CRT encryption). For implementing RSA-CRT, public key and private key is
    retrieved from the database. SHA-1 is used for ensuring the integrity of the data
    (Fig 2). So the third party has no access to the data sent and received between
    two users. It acts as cloud since the user need not download the exchanged file,
    just by clicking on the file, he can view the current and previously exchanged
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '| Figure 3\. Flow of the algorithm in the sender’s side. This shows the key
    genera- tion and encryption of the RSA-CRT with multiple keys algorithm. |'
  prefs: []
  type: TYPE_TB
- en: '| ![Figure978-1-7998-8367-8.ch011.f03](i/ch011.f03.png) |'
  prefs: []
  type: TYPE_TB
- en: '| Figure 4\. Flow of the algorithm in the receiver’s side. This shows the decryption
    and verification using hash. |'
  prefs: []
  type: TYPE_TB
- en: '| ![Figure978-1-7998-8367-8.ch011.f04](i/ch011.f04.png) |'
  prefs: []
  type: TYPE_TB
- en: '| Figure 5\. Functions of the algorithm and chat platform. A user can chat
    privately, and send files which will be encrypted and decrypted using Modified
    RSA-CRT. |'
  prefs: []
  type: TYPE_TB
- en: '| ![Figure978-1-7998-8367-8.ch011.f05](i/ch011.f05.png) |'
  prefs: []
  type: TYPE_TB
- en: 'Overview of Algorithm in work:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The RSA decryption and signature operation can be speeded up using the CRT,
    where the modulus N (i.e. and Q) factors are assumed to be known. By CRT, the
    computation of M can be partitioned into four parts:'
  prefs: []
  type: TYPE_NORMAL
- en: mp = Cp^dp mod p mq = Cq^dq mod q mr = Cr^dr mod r ms = Cs^ds mod s Where
  prefs: []
  type: TYPE_NORMAL
- en: Cp = C1 mod p Cq = C1 mod q Cr = C1 mod r Cs = C1 mod s And
  prefs: []
  type: TYPE_NORMAL
- en: C1 = Ct mod (z). [using the first private key (t,z)]
  prefs: []
  type: TYPE_NORMAL
- en: This reduces computation time since dp, dq, dr, ds< D and Cp,Cq,Cr,Cs< C. In
    fact, their sizes are about half the original sizes. In the ideal case, as both
    the sizes of d and n are reduced, we can have a speedup of about 4 times. But
    the proposed technique increased the security.
  prefs: []
  type: TYPE_NORMAL
- en: Table 1\. Comparison between RSA, RSA-CRT, RSA by multi keys and proposed technique
    with results.
  prefs: []
  type: TYPE_NORMAL
- en: '| Size in bits | Enc & Dec time of RSA in ms | Enc & Dec time of RSA in ms
    | Enc & Dec time of RSA in ms | Enc & Dec time of RSA in ms |'
  prefs: []
  type: TYPE_TB
- en: '| 640 | 42 | 26 | 84 | 66 |'
  prefs: []
  type: TYPE_TB
- en: '| 1040 | 48 | 29 | 93 | 71 |'
  prefs: []
  type: TYPE_TB
- en: '| 1136 | 63 | 32 | 113 | 85 |'
  prefs: []
  type: TYPE_TB
- en: The proposed technique is more secure as compared to the original RSA algorithm
    and RSA-CRT. And it enhanced the performance of the algorithm in decryption because
    it used the CRT in decryption, thus the proposed technique faster than RSA by
    multi keys. It reduces the cost of computation. Although it takes a long time
    to perform it as compared to the original RSA.
  prefs: []
  type: TYPE_NORMAL
- en: RSA USING MULTI-KEY AND CHINESE REMAINDER THEOREM
  prefs: []
  type: TYPE_NORMAL
- en: Take a document from the cloud, which is to be sent to another person. The document
    will be chomped by a Hash function into a few lines and will have a referral pair
    of words such as “message digest”. Using our software, we will encrypt the message
    using our private key which gives the digital signature. RSA with multiple keys
    and CRT will then be used to encrypt the signature with the receiver’s public
    key. The receiver can decrypt the ciphertext to plain text using their private
    key and our public key to verify the signature.
  prefs: []
  type: TYPE_NORMAL
- en: The proposed algorithm is trying to modify the RSA cryptosystem by improving
    its speed by using the Chinese remainder theorem and its security by taking 4
    prime numbers instead of 2 and two public key pairs instead of one (Fig 3).
  prefs: []
  type: TYPE_NORMAL
- en: The procedure for generating the key:-
  prefs: []
  type: TYPE_NORMAL
- en: 1\. We generate four large prime numbers p, q, r and s
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2\. We calculate the value of (n, z)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: n = pq
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: z = rs.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 3\. We find the value of ϕ(n) and ϕ(z) ϕ(n)= (p − 1)(q − 1)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ϕ(z) = (r − 1)(s − 1).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 4\. We choose random integers e, g such that 1 < e <n and gcd(e, ϕ(n)) = 1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 < g < z and gcd(g, ϕ(z)) = 1.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 5\. We calculate the value of d and t such that ed = 1 mod (ϕ(n)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: tg = 1 mod (ϕ(z)).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 6\. We calculate the value of dp,dq,dr and ds dp = d mod (p − 1)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: dq = d mod (q − 1) dr = d mod (r − 1) ds = d mod (s − 1). NOW,
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The Public key KU =< (e, n),(g, z) >
  prefs: []
  type: TYPE_NORMAL
- en: 'The Private key KV =< t, z, dp, dq, dr, ds>. Encryption for Proposed Technique
    (Fig 3):'
  prefs: []
  type: TYPE_NORMAL
- en: 'For encryption of the message M, the following steps are as followed:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. We convert the message M in integer form, in the range [0 to n − 1].
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2\. We calculate ciphertext C1 using first public key i.e e by
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C1 = M^e mod (n)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 3\. We calculate Ciphertext C using second public key g and C1 by C = C1^g mod
    (z).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '4\. We send the ciphertext C to the receiver. Decryption for Proposed Technique
    (Fig 4):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For decryption of ciphertext C, we follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. First we find C1 using the first private key (t, z) C1 = Ct mod (z).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2\. We do following Calculations Cp = C1 mod p
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cq = C1 mod q Cr = C1 mod r Cs = C1 mod s
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '3\. Then we calculate:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: mp = Cp^dp mod p mq = Cq^dq mod q mr = Cr^dr mod r ms = Cs^ds mod s
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 4\. Now after combining mp, mq, mr and ms, we get back our original plaintext
    message M.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Experimental Results
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing the algorithm to the extent to which it was made, the following results
    were obtained:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sample values for variables when p,q,r,s are large values Sample values for
    variables when p,q,r,s are large values A look and feel of our experimental result:'
  prefs: []
  type: TYPE_NORMAL
- en: 'User logged in:'
  prefs: []
  type: TYPE_NORMAL
- en: Fig 6 shows the login user interface of our chat portal where the registered
    user can login.
  prefs: []
  type: TYPE_NORMAL
- en: Table 2\. Unveiling the algorithm behind - sample values for variables when
    p,q,r,s are small values
  prefs: []
  type: TYPE_NORMAL
- en: 5\. The original text file (help_enc txt before getting encrypted
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Figure 7 shows the text file the user wants to send using the chat portal.
  prefs: []
  type: TYPE_NORMAL
- en: 6\. Now uploading this file to the cloud
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7\. The encrypted file which is stored in database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Figure 9 shows the encrypted text stored in our database, ensuring secure data
    transmission of the text file uploaded by the user.
  prefs: []
  type: TYPE_NORMAL
- en: Table 3\. Sample values for variables when p,q,r,s are large values
  prefs: []
  type: TYPE_NORMAL
- en: '| VARIABLE | VALUES |'
  prefs: []
  type: TYPE_TB
- en: '| P | 5760005761 |'
  prefs: []
  type: TYPE_TB
- en: '| Q | 57600032951 |'
  prefs: []
  type: TYPE_TB
- en: '| R | 331776232243207 |'
  prefs: []
  type: TYPE_TB
- en: '| S | 331776351372017 |'
  prefs: []
  type: TYPE_TB
- en: '| N | 331776521631549830711 |'
  prefs: []
  type: TYPE_TB
- en: '| Z | 110075507805606161588078138519 |'
  prefs: []
  type: TYPE_TB
- en: '| Phin | 331776521568189792000 |'
  prefs: []
  type: TYPE_TB
- en: '| Phiz | 110075507805605498035494523296 |'
  prefs: []
  type: TYPE_TB
- en: '| E | 331776521568189791999 |'
  prefs: []
  type: TYPE_TB
- en: '| G | 110075507805605498035494523295 |'
  prefs: []
  type: TYPE_TB
- en: '| D | 331776521568189791999 |'
  prefs: []
  type: TYPE_TB
- en: '| T | 110075507805605498035494523295 |'
  prefs: []
  type: TYPE_TB
- en: Table 4\. Output of algorithm
  prefs: []
  type: TYPE_NORMAL
- en: '| 5760005761 =p 57600032951 =q 331776232243207 =r 331776351372017 =s |'
  prefs: []
  type: TYPE_TB
- en: '| 331776521631549830711 =n 110075507805606161588078138519 =z |'
  prefs: []
  type: TYPE_TB
- en: '| 331776521568189792000 =phin 110075507805605498035494523296 =phiz |'
  prefs: []
  type: TYPE_TB
- en: '| 331776521568189791999 =e 110075507805605498035494523295 =g |'
  prefs: []
  type: TYPE_TB
- en: '| 331776521568189791999 =d 110075507805605498035494523295 =t |'
  prefs: []
  type: TYPE_TB
- en: '| 001100011011110110011001011101011101110100010111011101000101110111010000100100100100001
    |'
  prefs: []
  type: TYPE_TB
- en: '| Heyyy!!! This work is made by Manya, Aashish, Shruti and Vaishnavi is the
    messages to be sent. Hashes are the same. Heyyy!!! This work is made by Manya,
    Aashish, Shruti and Vaishnavi |'
  prefs: []
  type: TYPE_TB
- en: '| Figure 6\. Login user interface |'
  prefs: []
  type: TYPE_TB
- en: '| ![Figure978-1-7998-8367-8.ch011.f06](i/ch011.f06.png) |'
  prefs: []
  type: TYPE_TB
- en: 8\. The decrypted text when the user try to open it from the cloud
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'User can easily retrieve the file:'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10 shows the decrypted text when the user at the other end(receiver)
    try to open the file from the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: 'Files stored in the db:'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11 shows files name stored in the database.
  prefs: []
  type: TYPE_NORMAL
- en: '| Figure 7\. Text file the user wants to send (before encryption). |'
  prefs: []
  type: TYPE_TB
- en: '| ![Figure978-1-7998-8367-8.ch011.f07](i/ch011.f07.png) |'
  prefs: []
  type: TYPE_TB
- en: '| Figure 8\. Uploading text file in the interface and cloud. |'
  prefs: []
  type: TYPE_TB
- en: '| ![Figure978-1-7998-8367-8.ch011.f08](i/ch011.f08.png) |'
  prefs: []
  type: TYPE_TB
- en: '| Figure 9\. Encrypted text of the text file uploaded by the user. |'
  prefs: []
  type: TYPE_TB
- en: '| ![Figure978-1-7998-8367-8.ch011.f09](i/ch011.f09.png) |'
  prefs: []
  type: TYPE_TB
- en: '| Figure 10\. Decrypted text file which the receiver will be able to view.
    |'
  prefs: []
  type: TYPE_TB
- en: '| ![Figure978-1-7998-8367-8.ch011.f10](i/ch011.f10.png) |'
  prefs: []
  type: TYPE_TB
- en: '| Figure 11\. The file which the sender uploaded is stored in the database.
    |'
  prefs: []
  type: TYPE_TB
- en: '| ![Figure978-1-7998-8367-8.ch011.f11](i/ch011.f11.png) |'
  prefs: []
  type: TYPE_TB
- en: ANALYSIS
  prefs: []
  type: TYPE_NORMAL
- en: 'Attacks of RSA that can be mitigated using RSA-CRT:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Mitigation of attacks on RSA-CRT: Low exponent attack d is the private exponent
    in RSA.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see it in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: • Given input, m, raise it to the d-th power modulo p and modulo q. The results
    interme- diate are then combined through addition and multiplication with some
    constant predefined to compute the final result.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Since the exponentiation modular is performed on half the bit size of n, the
    execution time is less than 4 times.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • In RSA,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decryption M=Cd mod n
  prefs: []
  type: TYPE_NORMAL
- en: Rely directly on size of d and n.
  prefs: []
  type: TYPE_NORMAL
- en: 'But in RSA-CRT:'
  prefs: []
  type: TYPE_NORMAL
- en: After combining mp, mq, mr and ms, we get back our original plaintext message
    M.
  prefs: []
  type: TYPE_NORMAL
- en: '| Figure 12\. Calculating mp, mq, mr and ms in RSA-CRT |'
  prefs: []
  type: TYPE_TB
- en: '| ![Figure978-1-7998-8367-8.ch011.f12](i/ch011.f12.png) |'
  prefs: []
  type: TYPE_TB
- en: Reduced size of both d and n is considered an important advantage in the Chinese
    Remainder Theorem.
  prefs: []
  type: TYPE_NORMAL
- en: Timing Attack
  prefs: []
  type: TYPE_NORMAL
- en: The timing attack can be mitigated by incorporating Montgomery Multiplication.
  prefs: []
  type: TYPE_NORMAL
- en: Montgomery multiplication is modular multiplication that allows computing such
    mul- tiplications faster. Instead of dividing the product and subtracting n multiple
    times, it adds multiples of n to cancel out the lower bits and then just discards
    the lower bits.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits of using Multi-Keys RSA-CRT over RSA
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Secure option for application needing faster communication:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5 files are encrypted and decrypted using RSA and RSA-CRT. The time taken for
    encryption and decryption is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: Table 5\. The results of comparison time RSA encryption and RSA-CRT 1024 bits
  prefs: []
  type: TYPE_NORMAL
- en: '| File | Enc of RSA in nano-sec | Enc of RSA-CRT in nano-sec |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 330,130 | 371,148 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 316,803 | 348,592 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | 330,131 | 358,845 |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | 344,485 | 375,250 |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | 351,661 | 382,426 |'
  prefs: []
  type: TYPE_TB
- en: Table 6\. The results of comparison time decryption RSA and RSA-CRT 1024 bits
  prefs: []
  type: TYPE_NORMAL
- en: '| File | Dec of RSA in nano-sec | Dec of RSA-CRT in nano-sec |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 103,534,963 | 29,710,330 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 102,998,756 | 29,400,697 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | 103,437,564 | 29,477,594 |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | 103,300,180 | 29,538,084 |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | 103,515,483 | 29,730,836 |'
  prefs: []
  type: TYPE_TB
- en: We can see that on average encryption of RSA-CRT is 367252.2(Table 4) while
    that of RSA is 334642\. Thus the RSA-CRT takes 33610.2 nanoseconds more than RSA
    while encrypting 1024 bit block. But while decryption, on average, decryption
    of RSA-CRT is 29,571,508.2 while that of RSA is 103,357,389\. Thus the RSA-CRT
    takes 73,785,800.8 nanoseconds less than RSA while decrypting 1024 bit block (Table
    5).
  prefs: []
  type: TYPE_NORMAL
- en: Seeing the overall mechanism of encryption and decryption RSA-CRT is 3 times
    faster than RSA by 73,752,270.6 nanoseconds while applying the mechanism. This
    proves that despite of computational overhead, RSA- CRT is faster than RSA.
  prefs: []
  type: TYPE_NORMAL
- en: Though the computational overhead is high, time taken by this mechanism is less.
    Thus it is a better option to be used in fast communication applications like
    transaction-oriented or business plans oriented. But more memory would have to
    be used as the number of variables in more with the modified approach. Therefore,
    the main limitations in this approach is the overhead time and the memory to be
    used for the same, which can be overcome with future research and improvements.
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Key Generation Overhead but is less vulnerable to attacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attacks like Fault Injection or Side-Channel Analysis can’t be mitigated using
    RSA but RSA- CRT can protect user’s data from these attacks. RSA-CRT prevent the
    attacker from obtain- ing the signature when a fault has been induced during the
    computation. Not only this, it makes other attacks(with big prime numbers) like
    factoring large number or common modu- lus highly infeasible to be done in the
    exchanging data’s lifetime.
  prefs: []
  type: TYPE_NORMAL
- en: Timing attacks on RSA- CRT is highly infeasible since in timing attack precise
    time of decryption the card takes can help an attacker find or discover the private
    decryption exponent
  prefs: []
  type: TYPE_NORMAL
- en: d. But in RSA-CRT, the decryption time is 3 times lesser than RSA (which is
    safe since it’s still in use).
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Multi-keys with RSA-CRT makes attacking highly in- feasible in the data’s
    lifetime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculating private keys (t,z,dp,dq,dr,ds) where
  prefs: []
  type: TYPE_NORMAL
- en: t is obtained by tg = 1 mod (φ(z)). (g is random integers such that gcd(g, φ(z))
    = 1). dp = d mod (p − 1)
  prefs: []
  type: TYPE_NORMAL
- en: dq = d mod (q − 1) dr = d mod (r − 1) ds = d mod (s − 1). Is highly infeasible
    in the data’s lifetime.
  prefs: []
  type: TYPE_NORMAL
- en: The private key calculation of RSA is just {d,n} which is comparatively more
    prone to be hacked in data’s lifetime.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Reduction in the value of d and n can still yield some promising result
    in RSA-CRT with multi-keys.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the field of cryptosystem, many algorithms uses functionality of modular
    computation. The size of the exponent decryption, d and the modulus, n is very
    important because the complexity of the decryption in RSA depends directly on
    it. The exponent decryption specifies the numbers of multiplication modular, there
    are necessary to perform the exponentiation. The modulus, n play an important
    role in determined the size of the in- intermediate results. A way to reduce the
    size of both d and n is by using the Chinese Remainder theorem since the exponentiation
    modular is performed on half the bit size of n.
  prefs: []
  type: TYPE_NORMAL
- en: CONCLUSION
  prefs: []
  type: TYPE_NORMAL
- en: We proposed a technique which is based on traditional RSA, but we improved it
    by using multiple keys for more security and applied the Chinese remainder theorem
    for faster computation. We implemented our proposed technique to store a file
    in the cloud, which is a chatting application focused more on security of text
    files. This work has made a secure data exchange app where files are encrypted
    using RSA-CRT algorithm and hashed later. We observed that the proposed technique
    is more secure as compared to the original RSA algorithm and RSA-CRT.
  prefs: []
  type: TYPE_NORMAL
- en: REFERENCES
  prefs: []
  type: TYPE_NORMAL
- en: 12Arora, R., Parashar, A., & Transforming, C. C. I. (2013). Secure user data
    in cloud computing using encryption algorithms. International Journal of Engineering
    Research and Applications , 3(4), 1922–1926.
  prefs: []
  type: TYPE_NORMAL
- en: 21Balaji, M., Kumar, C. A., & Rao, G. S. V. (2018). Predictive Cloud resource
    management framework for enterprise workloads. Journal of King Saud University-Computer
    and Information Sciences , 30(3), 404–415\. doi:10.1016/j.jksuci.2016.10.005
  prefs: []
  type: TYPE_NORMAL
- en: 22Balaji, M., Kumar, C. A., & Rao, G. S. V. (2019). Non-linear analysis of bursty
    workloads using dual metrics for better cloud resource management. Journal of
    Ambient Intelligence and Humanized Computing , 10(12), 4977–4992\. doi:10.1007/s12652-019-01183-8
  prefs: []
  type: TYPE_NORMAL
- en: 24Balaji, M., Rao, G. S. V., & Kumar, C. A. (2014). A comparitive study of predictive
    models for cloud infrastructure management. In 2014 14th IEEE/ACM International
    Symposium on Cluster, Cloud and Grid Computing (pp. 923-926). IEEE. 10.1109/CCGrid.2014.32
  prefs: []
  type: TYPE_NORMAL
- en: '6Behl, A. (2011). Emerging security challenges in cloud computing: An insight
    to cloud security challenges and their mitigation. 2011 World Congress on Information
    and Communication Technologies , 21, 217–222.'
  prefs: []
  type: TYPE_NORMAL
- en: 17Gandhi, , & Gupta, . (2015). A Research on Enhancing Public Key Cryptography
    by the Use of MRGA with RSA and N-Prime RSA. International Journal for Innovative
    Research in Science and Technology , 16, 72–79.
  prefs: []
  type: TYPE_NORMAL
- en: 8GargP.SharmaV. (2014). An efficient and secure data storage in Mobile Cloud
    Com- puting through RSA and Hash function. 2014 International Conference on Issues
    and Challenges in Intelligent Computing Techniques (ICICT), 334–339.
  prefs: []
  type: TYPE_NORMAL
- en: 20Kim, G.-C., Li, S.-C., & Hwang, H.-C. (2020). Fast rebalanced RSA signature
    scheme with typical prime generation. Theoretical Computer Science , 830-831,
    1–19\. doi:10.1016/j.tcs.2020.04.024
  prefs: []
  type: TYPE_NORMAL
- en: 19Lakshmi, B. (2020). The Dark Phase of Cultural Conflict in The Novel ‘Twilight
    in Delhi’. Academic Press.
  prefs: []
  type: TYPE_NORMAL
- en: 2Li, Y., Gai, K., Qiu, L., Qiu, M., & Zhao, H. (2017). Intelligent cryptogra-
    phy approach for secure distributed big data storage in cloud computing. Information
    Sciences , 387, 103–115\. doi:10.1016/j.ins.2016.09.005
  prefs: []
  type: TYPE_NORMAL
- en: 23Narayanan, M., & Cherukuri, A. K. (2018). Verification of cloud based information
    integration architecture using colored petri nets. International Journal of Computer
    Network and Information Security , 12(2), 1–11\. doi:10.5815/ijcnis.2018.02.01
  prefs: []
  type: TYPE_NORMAL
- en: 10PantV. K.PrakashJ.AsthanaA. (2015). Three-step data security model for cloud
    com- puting based on RSA and steganography. 2015 International Conference on Green
    Computing and Internet of Things (ICGCIoT), 490–494\. 10.1109/ICGCIoT.2015.7380514
  prefs: []
  type: TYPE_NORMAL
- en: 13RujS.StojmenovicM.NayakA. (2012). Privacy-preserving access control with authen-
    tication for securing data in clouds. IEEE/ACM International Symposium on Cluster,
    Cloud and Grid Computing, 556–563.
  prefs: []
  type: TYPE_NORMAL
- en: 5ShimbreN.DeshpandeP. (2015). Enhancing distributed data storage security for
    cloud computing using TPA and AES algorithm. International Conference on Computing
    Communication Control and Automation, 35–39\. 10.1109/ICCUBEA.2015.16
  prefs: []
  type: TYPE_NORMAL
- en: '18ShindeG. N.FadewarH. S. (2008). Faster RSA algorithm for decryption using
    Chinese re- mainder theorem. ICCES: International Conference on Computational
    & Experimental Engineering and Sciences, 255–262.'
  prefs: []
  type: TYPE_NORMAL
- en: 3Shwetha Bindu & Yadaiah. (2011). Secure Data Storage In Cloud Computing. International
    Journal of Research in Computer Science, 1(1), 63–73.
  prefs: []
  type: TYPE_NORMAL
- en: 11SomaniU.LakhaniK.MundraM. (2010). Implementing digital signature with RSA
    en- cryption algorithm to enhance the Data Security of cloud in Cloud Computing.
    2010 First International Conference On Parallel, Distributed and Grid Computing,
    211– 216.
  prefs: []
  type: TYPE_NORMAL
- en: 4Sookhak, M. (2015). Dynamic remote data auditing for securing big data storage
    in cloud computing (Doctoral dissertation). University of Malaya.
  prefs: []
  type: TYPE_NORMAL
- en: 14SubashiniS.KavithaV. (2011). A metadata-based storage model for securing data
    in a cloud environment. 2011 International Conference on Cyber-Enabled Distributed
    Computing and Knowledge Discovery, 429–434.
  prefs: []
  type: TYPE_NORMAL
- en: 7Usman, M., Jan, M. A., & He, X. (2017). Cryptography-based secure data storage
    and sharing using HEVC and public clouds. Information Sciences , 387, 90–102\.
    doi:10.1016/j.ins.2016.08.059
  prefs: []
  type: TYPE_NORMAL
- en: 15Wang, C., Ren, K., Lou, W., & Li, J. (2010). Toward publicly auditable secure
    cloud data storage services. IEEE Network , 24(4), 19–24\. doi:10.1109/MNET.2010.5510914
  prefs: []
  type: TYPE_NORMAL
- en: 1Yang, K., & Jia, X. (2012). An efficient and secure dynamic auditing protocol
    for data storage in cloud computing. IEEE Transactions on Parallel and Distributed
    Systems , 24(9), 1717–1726\. doi:10.1109/TPDS.2012.278
  prefs: []
  type: TYPE_NORMAL
- en: 16Zhou, L., Varadharajan, V., & Hitchens, M. (2013). Vijay Varadharajan, and
    Michael Hitchens. Achieving Secure Role-Based Access Control on Encrypted Data
    in Cloud Storage. IEEE Transactions on Information Forensics and Security , 8(12),
    1947–1960\. doi:10.1109/TIFS.2013.2286456
  prefs: []
  type: TYPE_NORMAL
