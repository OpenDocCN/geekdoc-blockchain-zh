- en: '[CHAPTER 11](toc.xhtml#c11)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Smart Contract and Other Useful Transactions](toc.xhtml#c11)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you learnt to verify and create transactions. You also
    learnt how to check their inputs and outputs and correctness before publishing
    and understood the different ways to publish a transaction. In this chapter, you
    will learn scripting in more detail. You will learn how simple but interesting
    use cases can be implemented using scripting language and other properties of
    Bitcoin transactions.
  prefs: []
  type: TYPE_NORMAL
- en: When we think about smart contract, we think about Ethereum, Cardano, Binance
    Smart Chain, etc. We ignore the network that pioneered in smart contract, which
    is Bitcoin. Bitcoin is the most secure cryptocurrency network. As smart contract
    and digital properties might be very valuable, securing them on Bitcoin network
    could be the best option if it is technically feasible.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will go deeper into scripting and build use cases for a
    few useful smart contracts using Bitcoin scripting language. We will also implement
    some other use cases that are not contracts between parties but are useful in
    solving real requirements.
  prefs: []
  type: TYPE_NORMAL
- en: '[Structure](toc.xhtml#s231a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Script opcodes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Digital property
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Document timestamping
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Time locked transactions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Time locked payment
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Payment with relative locktime
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Smart contract
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Solution to trust issue in payments
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple multi-signature payment
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Improved payment with relative locktime
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Payments involving escrow
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Payment involving secret identifier
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Collaborative transactions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Charity use case
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Subsidy use case
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Planned contribution within a group
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Objectives](toc.xhtml#s232a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The objective of this chapter is to help you understand the broader scope of
    Bitcoin scripting language. Additionally, it will help you learn to create transactions
    for different scenarios, including smart contract and other useful transactions
    that were not covered in the previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: '[Script opcodes](toc.xhtml#s233a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we used only a few opcodes that are used in standard
    P2PKH and m-of-n-multisig P2SH scripts. While these are sufficient for basic money
    transfers between individuals and groups, a more complex script might be needed.
    In this chapter, we will use a few more opcodes.
  prefs: []
  type: TYPE_NORMAL
- en: '[Digital property](toc.xhtml#s234a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Digital asset or digital property is the digital representation of an asset.
    The property can be represented as QR code or identifier or hash of specification
    or value. The asset ownership can be changed by the owner of the asset. It can
    also be lent or rented online. Using Bitcoin transaction and scripting language,
    we can implement some of those features. Timestamping is one of the important
    properties of digital asset management, which we will cover in this subtopic.
  prefs: []
  type: TYPE_NORMAL
- en: '[Document timestamping](toc.xhtml#s235a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Timestamping a document is necessary for it to be legally binding and for it
    to be part of a contract. Transactions in a block can be associated with the timestamp
    of the block, and it is immutable. If a transaction holds hash of the content
    of a document, then we can consider the document as timestamped. However, for
    this to be legally binding, governments need to recognize Bitcoin blockchain as
    both immutable and having the correct timestamp.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a short story written by my daughter, for which we are generating
    a hash and will add it to a transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Best Friend Lunch Party: One day two best friends, a monkey and a crocodile
    decided to have lunch together in a farm. The next day, they passed the river
    and reached the farm. After a heavy meal the monkey got up and started growling
    loudly. The frightened crocodile pleaded the monkey to stop. But the monkey said,
    ‘I have a habit of growling after every meal, I cannot help it’. The monkey was
    on the crocodile’s back while crossing the river back home. When they were halfway
    through the river, the crocodile took a dip in the water. When the monkey was
    frightened, the crocodile said, ‘I have a habit of taking a dip in the water after
    every meal, I cannot help it’. Monkey understood his mistake.'
  prefs: []
  type: TYPE_NORMAL
- en: 'SHA256 of this story:'
  prefs: []
  type: TYPE_NORMAL
- en: '`3365b392ee14def189190638a532f6042446b74c98f186e9b595f77e47817e05`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the code to get the hash of the preceding story:'
  prefs: []
  type: TYPE_NORMAL
- en: '`def contentHash(story: str):`'
  prefs: []
  type: TYPE_NORMAL
- en: '`content_h = hashlib.sha256(story.encode(‘ascii’)).digest()`'
  prefs: []
  type: TYPE_NORMAL
- en: '`return content_h`'
  prefs: []
  type: TYPE_NORMAL
- en: To add this to a transaction, we need to pay a small network fee, transfer bitcoins
    from one address to another, and use `**OP_RETURN**` to capture the above hash.
  prefs: []
  type: TYPE_NORMAL
- en: 'We generate the first block and send the newly mined bitcoins to an address
    as shown in *[figure 11.1](#fig11_1)*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-11.1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 11.1:** Generated Block hash'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the transactions included in the newly mined block:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-11.2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 11.2:** Transaction ID of coinbase transaction'
  prefs: []
  type: TYPE_NORMAL
- en: In *[Chapter 10, Create and Validate Transactions](c10.xhtml)* under the topic
    *Building P2PKH transaction*, we have created P2PKH transaction with two inputs
    and two outputs. We modify the code to also support `**OP_RETURN**` output.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the code that provides transaction structure to the transaction builder
    program:'
  prefs: []
  type: TYPE_NORMAL
- en: '`def createTransactionStruct():`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn = {}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘version’] = 1`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘input_count’] = 1`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘inputs’] = []`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0 = {}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0[‘prevtxn’] = ‘5efcf04e32f061b9c4894f5b3a59fb3d8c5c56a6e7340b89b3a1a9ebacca998f’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0[‘prevtxnindex’] = 0`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0[‘script_type’] = ‘P2PKH’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0[‘privkeys’] = [‘KwfxnwxpPG1RmhU8jaU8Ron4m1KZGymLAFNaMnSTonoZ7AQfnV53’]`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0[‘script_pubkey’] = ‘76a91481d7033c19dcec645cb3f86ce41678756850ba4d88ac’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0[‘hash_type’] = SIGHASH_ALL`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘inputs’].append(input0)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘out_count’] = 2`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘outputs’] = []`'
  prefs: []
  type: TYPE_NORMAL
- en: '`output0 = {}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`output0[‘satoshis’] = 4999900000`'
  prefs: []
  type: TYPE_NORMAL
- en: '`output0[‘script_type’] = ‘P2PKH’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`output0[‘address’] = ‘mxzmMmVycLDgAA48VtHDeh389eDAwiJqwQ’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘outputs’].append(output0)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`output1 = {}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`output1[‘satoshis’] = 0`'
  prefs: []
  type: TYPE_NORMAL
- en: '`output1[‘script_type’] = ‘OP_RETURN’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`output1[‘content_hash256’] = ‘3365b392ee14def189190638a532f6042446b74c98f186e9b595f77e47817e05’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘outputs’].append(output1)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘locktime’] = 0`'
  prefs: []
  type: TYPE_NORMAL
- en: '`return txn`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Program 11.1:** Transaction structure definition of document timestamping'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the value of OP_RETURN opcode:'
  prefs: []
  type: TYPE_NORMAL
- en: '`OP_RETURN = 0x6a`'
  prefs: []
  type: TYPE_NORMAL
- en: 'In *[Chapter 10, Create and Validate Transactions](c10.xhtml)* under topic
    ***Building transactions*** we have defined method `**createSignaturePreimage
    and createSignedTransaction**`. We add following lines to the method to handle
    OP_RETURN script type:'
  prefs: []
  type: TYPE_NORMAL
- en: '`if outp[‘script_type’] == ‘OP_RETURN’:`'
  prefs: []
  type: TYPE_NORMAL
- en: '`content_b = bytes.fromhex(outp[‘content_hash256’])`'
  prefs: []
  type: TYPE_NORMAL
- en: '`scriptPubkey_b = bytes([OP_RETURN]) \`'
  prefs: []
  type: TYPE_NORMAL
- en: '`+ getWithPushdata(content_b)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we did in *[Chapter 10, Create and Validate Transactions](c10.xhtml)*, we
    execute this program and get raw transaction hex code, as shown in *[figure 11.3](#fig11_3)*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-11.3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 11.3:** Hex code of transaction created for document stamping'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the output of the newly created transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-11.4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 11.4:** Output of transaction created for document timestamping'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to mine another 100 blocks so that the mined bitcoins we are using
    are ready for transfer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-11.5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 11.5:** Next 100 blocks are mined'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, publish the newly created transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-11.6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 11.6:** Publish transaction for document timestamping'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we mine a single block again to add the transaction to the newly mined
    block:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-11.7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 11.7:** Mine the next block to include published transaction'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following in the newly mined block. We can see that the block contains
    the newly added transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-11.8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 11.8:** Published transaction appears in the new block'
  prefs: []
  type: TYPE_NORMAL
- en: '[Time locked transactions](toc.xhtml#s236a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bitcoin allows you to lock a transaction for certain time or block height. It
    allows transactions to be locked in a fixed time or time relative to the funding
    transaction.
  prefs: []
  type: TYPE_NORMAL
- en: In the following subsections, we will cover a use case for both fixed and the
    relative timelock.
  prefs: []
  type: TYPE_NORMAL
- en: '[Time locked payment](toc.xhtml#s237a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can also create transactions that cannot be spent before given timestamp.
    This is done by setting the nLockTime field in a transaction. The nLockTime field
    can either be set to denote block height or to denote Unix epoch time. In the
    case of epoch time, it denotes mean time past instead of the block’s timestamp.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `**nLockTime**` field has the following rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '`**nLockTime**` < 500000000 denotes block-height'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise, it denotes median time past
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is recommended that `**nLockTime**` is not set to zero or past block height
    or past block-time.
  prefs: []
  type: TYPE_NORMAL
- en: '*Median time past = Medium of (Tn-1, Tn-2, Tn-3, Tn-4, … Tn-10, Tn-11)*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code provides transaction structure to the transaction builder
    program:'
  prefs: []
  type: TYPE_NORMAL
- en: '`def createTransactionStruct():`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn = {}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘version’] = 1`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘input_count’] = 1`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘inputs’] = []`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0 = {}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0[‘prevtxn’] = ‘5efcf04e32f061b9c4894f5b3a59fb3d8c5c56a6e7340b89b3a1a9ebacca998f’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0[‘prevtxnindex’] = 0`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0[‘script_type’] = ‘P2PKH’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0[‘privkeys’] = [‘KwfxnwxpPG1RmhU8jaU8Ron4m1KZGymLAFNaMnSTonoZ7AQfnV53’]`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0[‘script_pubkey’] = ‘76a91481d7033c19dcec645cb3f86ce41678756850ba4d88ac’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0[‘hash_type’] = SIGHASH_ALL`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘inputs’].append(input0)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘out_count’] = 1`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘outputs’] = []`'
  prefs: []
  type: TYPE_NORMAL
- en: '`output0 = {}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`output0[‘satoshis’] = 4999900000`'
  prefs: []
  type: TYPE_NORMAL
- en: '`output0[‘script_type’] = ‘P2PKH’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`output0[‘address’] = ‘mxzmMmVycLDgAA48VtHDeh389eDAwiJqwQ’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘outputs’].append(output0)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘locktime’] = 1624196667`'
  prefs: []
  type: TYPE_NORMAL
- en: '`return txn`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Program 11.2:** Transaction structure definition of time locked payment'
  prefs: []
  type: TYPE_NORMAL
- en: 'We get the following signed transaction for the preceding transaction structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-11.9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 11.9:** Create transaction for time locked payment'
  prefs: []
  type: TYPE_NORMAL
- en: To be able to publish the preceding transaction, the bitcoin in the newly created
    block needs to be available for spend. For this, we create another 100 blocks.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now try to publish the transaction, as shown in *[figure 11.10](#fig11_10)*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-11.10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 11.10:** Publishing the time locked transaction fails'
  prefs: []
  type: TYPE_NORMAL
- en: 'Publishing of the transaction fails as the block median timestamp is smaller
    than the locktime we have set:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-11.11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 11.11:** Current timestamp and last block timestamp'
  prefs: []
  type: TYPE_NORMAL
- en: 'The median timestamp is calculated by taking the median of the timestamp in
    a block for the last 11 blocks. To get the median timestamp value as a value greater
    than the locktime set in the transaction, we wait for a few minutes and create
    another 11 blocks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-11.12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 11.12:** Mine next eleven block to change median time past'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the median time of the last generated block is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-11.13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 11.13:** Get median time past'
  prefs: []
  type: TYPE_NORMAL
- en: 'This timestamp is greater than 1624196667:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-11.14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 11.14:** Median time past to date'
  prefs: []
  type: TYPE_NORMAL
- en: 'We again try publishing the transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-11.15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 11.15:** Publishing the transaction is now successful'
  prefs: []
  type: TYPE_NORMAL
- en: We can see that the transaction was not valid until the median timestamp of
    the latest block was not less than or equal to lock-time.
  prefs: []
  type: TYPE_NORMAL
- en: '[Payment with relative locktime](toc.xhtml#s238a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `**nLockTime**` field in a transaction is set for static block height or
    static epoch time. If the newly created transaction needs to wait for time or
    block count relative to block count or timestamp of depending block, then we use
    `**OP_CHECKSEQUENCEVERIFY**`.
  prefs: []
  type: TYPE_NORMAL
- en: The relative lock-time contract is implemented using the `**OP_CHECKSEQUENCEVERIFY**`
    opcode as a script, so we use P2SH with redeem script. The opcode requires that
    the sequence is set for the corresponding transaction input.
  prefs: []
  type: TYPE_NORMAL
- en: The relative locktime was a softfork, which required version number of transactions
    to be set as 2\. It also led to changes in the way `**nSequence**` is evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Prior to the softfork:'
  prefs: []
  type: TYPE_NORMAL
- en: If nSequence is 0xFFFFFFFE, it denotes that nLockTime is set.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If nSequence is 0xFFFFFFFF, it denotes that nLockTime is not set.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following illustration shows the way nSequence is evaluated post softfork:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-11.16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 11.16:** Illustration of nSequence evaluation'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listed here are the conditions based on which sequence value needs to be set:'
  prefs: []
  type: TYPE_NORMAL
- en: If nSequence > 0xEFFFFFFF, then it is not defined and so, the transaction can
    be included in any block.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If nSequence <= 0xEFFFFFFF, then bit-22 determines if 0-15 bits denote block
    height or timestamp.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If bit-22 is set, then 0-15 bits denote block height.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If bit-22 is not set, then 0-15 bits denotes medium time past.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is implemented in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`def getSequence(txn_struct: dict, i: int):`'
  prefs: []
  type: TYPE_NORMAL
- en: '`inp = txn_struct[‘inputs’][i]`'
  prefs: []
  type: TYPE_NORMAL
- en: '`if ‘sequence_type’ in inp:`'
  prefs: []
  type: TYPE_NORMAL
- en: '`if inp[‘sequence_type’] == ‘time’:`'
  prefs: []
  type: TYPE_NORMAL
- en: '`sequence = inp[‘sequence’] | (1 << 22)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`else:`'
  prefs: []
  type: TYPE_NORMAL
- en: '`sequence = inp[‘sequence’]`'
  prefs: []
  type: TYPE_NORMAL
- en: '`sequence_b = struct.pack(‘<L’, sequence)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`else:`'
  prefs: []
  type: TYPE_NORMAL
- en: '`if txn_struct[‘locktime’] > 0:`'
  prefs: []
  type: TYPE_NORMAL
- en: '`# sequence`'
  prefs: []
  type: TYPE_NORMAL
- en: '`sequence_b = bytes([0xfe, 0xff, 0xff, 0xff])`'
  prefs: []
  type: TYPE_NORMAL
- en: '`else:`'
  prefs: []
  type: TYPE_NORMAL
- en: '`# sequence`'
  prefs: []
  type: TYPE_NORMAL
- en: '`sequence_b = bytes([0xff, 0xff, 0xff, 0xff])`'
  prefs: []
  type: TYPE_NORMAL
- en: '`return sequence_b`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Program 11.3:** Method to calculate nSequence'
  prefs: []
  type: TYPE_NORMAL
- en: To implement a simple use case with relative lock-time, in our use case, a newly
    created transaction can only be mined 105 blocks after the funding transaction
    are confirmed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the redeem script for the transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '`# 105 OP_CHECKSEQUENCEVERIFY OP_DROP`'
  prefs: []
  type: TYPE_NORMAL
- en: '`# <Alice pubkey> CHECKSIG`'
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the opcodes we require in this transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '`OP_CHECKSEQUENCEVERIFY = 0xb2`'
  prefs: []
  type: TYPE_NORMAL
- en: '`OP_DROP = 0x75`'
  prefs: []
  type: TYPE_NORMAL
- en: '`OP_CHECKSIG = 0xac`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is used to generate redeem script hex code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`def createRedeemScript(pubkey_alice: str):`'
  prefs: []
  type: TYPE_NORMAL
- en: '`redeem_script_b = bytes([0x01,`'
  prefs: []
  type: TYPE_NORMAL
- en: '`105, # after 105 blocks`'
  prefs: []
  type: TYPE_NORMAL
- en: '`OP_CHECKSEQUENCEVERIFY, OP_DROP])`'
  prefs: []
  type: TYPE_NORMAL
- en: '`pubkey_b = bytes.fromhex(pubkey_alice)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`redeem_script_b += createVarInt(len(pubkey_b)) + pubkey_b`'
  prefs: []
  type: TYPE_NORMAL
- en: '`redeem_script_b += bytes([OP_CHECKSIG])`'
  prefs: []
  type: TYPE_NORMAL
- en: '`return redeem_script_b`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Program 11.4:** Method to create redeem script for relative lock-time'
  prefs: []
  type: TYPE_NORMAL
- en: 'We call the preceding method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`if __name__ == ‘__main__’:`'
  prefs: []
  type: TYPE_NORMAL
- en: '`pubkey_alice = ‘037fadaea6edf196bf70af16cefb2bd3c830e54c0a6e9a00bf7806b241933547f7’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`redeem_script_b = createRedeemScript(pubkey_alice)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`print(‘redeem script = %s’ % redeem_script_b.hex())`'
  prefs: []
  type: TYPE_NORMAL
- en: '`sh = hash160(redeem_script_b)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`address = sh2address(sh)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`print(‘P2SH address = %s’ % address)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'We execute it and get following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-11.17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 11.17:** Generate Redeem script for relative timelock'
  prefs: []
  type: TYPE_NORMAL
- en: 'We generate a block to pay to the contract indicated by the preceding redeem
    script and then get the transaction ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-11.18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 11.18:** Transaction ID for relative timelock funding transaction'
  prefs: []
  type: TYPE_NORMAL
- en: 'We now create a new transaction using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`def createTransactionStruct():`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn = {}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘version’] = 2`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘input_count’] = 1`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘inputs’] = []`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0 = {}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0[‘prevtxn’] = \`'
  prefs: []
  type: TYPE_NORMAL
- en: '`‘e6a31b5c7e39a31bb12c68055c1dd6dcb6554d1546a8621e889f1026e10264c8’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0[‘prevtxnindex’] = 0`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0[‘script_type’] = ‘P2SH_RelativeTimeLock’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0[‘privkeys’] = \`'
  prefs: []
  type: TYPE_NORMAL
- en: '`[‘L26JcHRhqEQv8V9DaAmE4bdszwqXS7tHznGYJPp7fxEoEQxxBPcQ’]`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0[‘redeem_script’] = ‘0169b27521037fadaea6edf196bf70af16cefb2bd3c830e54c0a6e9a00bf7806b241933547f7ac’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0[‘hash_type’] = SIGHASH_ALL`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0[‘sequence’] = 105`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0[‘sequence_type’] = ‘block’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘inputs’].append(input0)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘out_count’] = 2`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘outputs’] = []`'
  prefs: []
  type: TYPE_NORMAL
- en: '`output0 = {}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`output0[‘satoshis’] = 10*(10**8)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`output0[‘script_type’] = ‘P2PKH’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`output0[‘address’] = ‘mxzmMmVycLDgAA48VtHDeh389eDAwiJqwQ’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘outputs’].append(output0)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`output1 = {}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`output1[‘satoshis’] = 399999*(10**4)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`output1[‘script_type’] = ‘P2PKH’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`output1[‘address’] = ‘miSFmBeKXf5Wp7Luj46XTu3Yh57nAwhZAo’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘outputs’].append(output1)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘locktime’] = 0`'
  prefs: []
  type: TYPE_NORMAL
- en: '`return txn`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Program 11.5:** Method to create transaction for relative lock-time'
  prefs: []
  type: TYPE_NORMAL
- en: 'To claim the locked funds in the previous transaction, we provide `**scriptSig**`,
    which consists of the required signature along with redeem script. Here’s the
    code for `**scriptSig**`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`def createScriptSigForRelTimeLock(signgrp: list, script_b: bytes):`'
  prefs: []
  type: TYPE_NORMAL
- en: '`scriptSig_b = getWithPushdata(signgrp[0])`'
  prefs: []
  type: TYPE_NORMAL
- en: '`scriptSig_b += getWithPushdata(script_b)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`return scriptSig_b`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Program 11.6:** Method to create scriptSig for relative lock-time'
  prefs: []
  type: TYPE_NORMAL
- en: 'In *[Chapter 10, Create and Validate Transactions](c10.xhtml)* under topic
    ***Building transactions*** we have defined method `**createSignedInput**`. We
    add following lines to the method to handle *relative-timelock* script type:'
  prefs: []
  type: TYPE_NORMAL
- en: '`elif txn_input[‘script_type’] == ‘P2SH_RelativeTimeLock’:`'
  prefs: []
  type: TYPE_NORMAL
- en: '`scriptSig_b = createScriptSigForRelTimeLock(signgrp, script_b)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'We execute the code and get the signed raw transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-11.19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 11.19:** Create hex code for relative timelock transaction'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we publish the preceding transaction before 105 blocks are mined, we get
    the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-11.20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 11.20:** Publishing relative timelock transaction before the required
    block height'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have mined 105 blocks after the input transaction, we can publish the
    preceding transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-11.21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 11.21:** Publishing relative timelock transaction after the required
    block height'
  prefs: []
  type: TYPE_NORMAL
- en: '[Smart contract](toc.xhtml#s239a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Smart Contract* is a contract between two or more parties that is written
    in the form of an executable computer program. It executes only when the contract
    allows its execution, and on execution, smart contract follows the conditions
    defined in the contract.'
  prefs: []
  type: TYPE_NORMAL
- en: Bitcoin provides a primitive scripting language based on reverse polish notation.
    The script is not Turing complete, which means it cannot solve all computational
    problems. Since smart contracts are contracts modelled in a program, they can
    become more complex with loops and state variables that the Bitcoin script does
    not allow.
  prefs: []
  type: TYPE_NORMAL
- en: It has a large number of opcodes that can be used to create a variety of smart
    contracts. Even though there are large number of opcodes, not everything can be
    done by scripting.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, Bitcoin transaction itself imposes limitations on the scripts.
    And since Bitcoin transaction fee is calculated based on per vBytes and is reasonably
    high, a complicated and large redeem script can make a smart contract financially
    non-viable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some of the limitations of smart contract on Bitcoin:'
  prefs: []
  type: TYPE_NORMAL
- en: In a transaction, smart contract can only affect a single input.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A smart contract can only fund the transaction from a single UTXO that has a
    fixed value.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Transaction outputs cannot be modified based on smart contract.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Output scripts are standard and can only be one of the standard scripts such
    as P2SH, P2PKH, OP_RETURN, P2PK, or P2MS and standard segwit scripts, which we
    will cover in the next chapter.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Bitcoin script is not a Turing complete language, and it does not have options
    to:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Have nondeterministic operations such as loops
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Work as a state machine and perform operations based on its state.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Bitcoin script is limited to the opcode it provides.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scripting on Bitcoin is costly, and the complexity of a smart contract also
    depends on its financial viability.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Solution to trust issue in payments](toc.xhtml#s240a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We know that the simple method of payment is to transfer bitcoins to the recipient’s
    address. It would be done in your mobile wallet by scanning the QR code. This
    is great for small payments, but as the transaction fee has increased with increase
    in bitcoin price, making payments for low-priced goods is not financially viable.
  prefs: []
  type: TYPE_NORMAL
- en: For large value payments, we need to improve the security of payments. We will
    improve the security of payments in the following subtopics as we tackle one issue
    at a time.
  prefs: []
  type: TYPE_NORMAL
- en: '[Simple multi-signature payment](toc.xhtml#s241a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A 2-of-2-multisig between the buyer and seller is a way to secure payments when
    the trusted party needs to depend on the services provided by the non-trusted
    entity. As an example, consider a reputed business that needs to get a service
    from an unregulated small vendor.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the business locks funds in a 2-of-2-multisig address and only
    completes the payment once it has received the service from the small vendor.
    The locked funds act as the smart contract between the business and the vendor.
    This gives surety to the small vendor that they will get paid as there is no way
    the large business can take the money back.
  prefs: []
  type: TYPE_NORMAL
- en: '[Improved payment with relative locktime](toc.xhtml#s242a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The problem in the above payment use case is when the small vendor delays in
    providing the required service. They know that the funds are locked, so they can
    be bit careless about their job.
  prefs: []
  type: TYPE_NORMAL
- en: To solve this issue, there must be a way the business should be able to revoke.
    However, the business should not be able to revoke the payment at will. This can
    be achieved by relative lock-time so that both parties know that bitcoins are
    locked, but there is a time limit. If the vendor does not get service within time,
    it will get revoked.
  prefs: []
  type: TYPE_NORMAL
- en: 'The use case can be understood with the help of the following illustration.
    Here, Alice represents the trusted business, and Bob represents a small non-trusted
    vendor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-11.22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 11.22:** Improved payment with relative lock time'
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve this, we use the P2SH transaction with the following redeem script:'
  prefs: []
  type: TYPE_NORMAL
- en: '`#IF`'
  prefs: []
  type: TYPE_NORMAL
- en: '`# OP_2 <Alice’s pubkey> <Bob’s pubkey> OP_2 CHECKMULTISIG`'
  prefs: []
  type: TYPE_NORMAL
- en: '`#ELSE`'
  prefs: []
  type: TYPE_NORMAL
- en: '`# 105 CHECKSEQUENCEVERIFY DROP`'
  prefs: []
  type: TYPE_NORMAL
- en: '`# <Alice’s pubkey> CHECKSIG`'
  prefs: []
  type: TYPE_NORMAL
- en: '`#ENDIF`'
  prefs: []
  type: TYPE_NORMAL
- en: In a normal condition, i.e., when there is no dispute, both sides sign the transaction
    that pays Bob. If there is a dispute, Alice waits for the timeout and then creates
    a transaction signed by her own private key, which transfers the locked amount
    to her address.
  prefs: []
  type: TYPE_NORMAL
- en: One thing to remember is that a condition once valid is always valid. So, if
    Alice wants to give extra time to Bob, she can still do it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the required opcodes to create redeem script:'
  prefs: []
  type: TYPE_NORMAL
- en: '`OP_2 = 0x52`'
  prefs: []
  type: TYPE_NORMAL
- en: '`OP_IF = 0x63`'
  prefs: []
  type: TYPE_NORMAL
- en: '`OP_ELSE = 0x67`'
  prefs: []
  type: TYPE_NORMAL
- en: '`OP_ENDIF = 0x68`'
  prefs: []
  type: TYPE_NORMAL
- en: '`OP_CHECKSEQUENCEVERIFY = 0xb2`'
  prefs: []
  type: TYPE_NORMAL
- en: '`OP_DROP = 0x75`'
  prefs: []
  type: TYPE_NORMAL
- en: '`OP_CHECKMULTISIG = 0xae`'
  prefs: []
  type: TYPE_NORMAL
- en: '`OP_CHECKSIG = 0xac`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Redeem script is used to generate the contract address where contract amount
    is locked. The following code is used to generate redeem script:'
  prefs: []
  type: TYPE_NORMAL
- en: '`def createRedeemScript2_2_seqcheck(pubkey_l: list):`'
  prefs: []
  type: TYPE_NORMAL
- en: '`redeem_script_b = bytes([OP_IF, OP_2])`'
  prefs: []
  type: TYPE_NORMAL
- en: '`for pubkey in pubkey_l: # Alice + Bob`'
  prefs: []
  type: TYPE_NORMAL
- en: '`pubkey_b = bytes.fromhex(pubkey)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`redeem_script_b += createVarInt(len(pubkey_b)) + pubkey_b`'
  prefs: []
  type: TYPE_NORMAL
- en: '`redeem_script_b += bytes([OP_2, OP_CHECKMULTISIG])`'
  prefs: []
  type: TYPE_NORMAL
- en: '`redeem_script_b += bytes([OP_ELSE, 0x01,`'
  prefs: []
  type: TYPE_NORMAL
- en: '`105, # after 105 blocks`'
  prefs: []
  type: TYPE_NORMAL
- en: '`OP_CHECKSEQUENCEVERIFY, OP_DROP])`'
  prefs: []
  type: TYPE_NORMAL
- en: '`pubkey_b = bytes.fromhex(pubkey_l[0]) # Alice pubkey`'
  prefs: []
  type: TYPE_NORMAL
- en: '`redeem_script_b += createVarInt(len(pubkey_b)) + pubkey_b`'
  prefs: []
  type: TYPE_NORMAL
- en: '`redeem_script_b += bytes([OP_CHECKSIG, OP_ENDIF])`'
  prefs: []
  type: TYPE_NORMAL
- en: '`return redeem_script_b`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Program 11.7:** Redeem script for payment with relative lock-time'
  prefs: []
  type: TYPE_NORMAL
- en: 'We call the method using the following script:'
  prefs: []
  type: TYPE_NORMAL
- en: '`if __name__ == ‘__main__’:`'
  prefs: []
  type: TYPE_NORMAL
- en: '`pubkey_l = [‘037fadaea6edf196bf70af16cefb2bd3c830e54c0a6e9a00bf7806b241933547f7’,
    ‘02fcb1c7507db15576ab35cd7c9b1ea570141a8b81c9938dae0320392b0f7034d0’]`'
  prefs: []
  type: TYPE_NORMAL
- en: '`redeem_script_b = createRedeemScript2_2_seqcheck(pubkey_l)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`print(‘redeem script = %s’ % redeem_script_b.hex())`'
  prefs: []
  type: TYPE_NORMAL
- en: '`sh = hash160(redeem_script_b)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`address = sh2address(sh)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`print(‘P2SH address = %s’ % address)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'On calling the method, we get the following redeem script and address:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-11.23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 11.23:** Generate redeem script for payment with relative locktime'
  prefs: []
  type: TYPE_NORMAL
- en: 'We generate a block to pay to this address:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-11.24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 11.24:** Generate block that pays redeem script'
  prefs: []
  type: TYPE_NORMAL
- en: 'We get transaction ID from block hash:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-11.25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 11.25:** Get transaction-id from the generated block'
  prefs: []
  type: TYPE_NORMAL
- en: We generate another 100 blocks so that this transaction is available for payment.
    As you have learnt, there are two possible outcomes of this contract.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, `**OP_CHECKSEQUENCEVERIFY**` was a soft-fork that needed the
    transaction version to be equal to or greater than 2\. So, in the following transaction
    structure, we will use the version as 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '`def createTransactionStruct():`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn = {}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘version’] = 2`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘input_count’] = 1`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘inputs’] = []`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0 = {}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0[‘prevtxn’] = \`'
  prefs: []
  type: TYPE_NORMAL
- en: '`‘624d92839eb89104d0909df89f95785cb8bb77f0fec66c6c40cf3ad2804a3966’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0[‘prevtxnindex’] = 0`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0[‘script_type’] = ‘P2SH_Condition’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0[‘condition’] = True`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0[‘privkeys’] = \`'
  prefs: []
  type: TYPE_NORMAL
- en: '`[‘L26JcHRhqEQv8V9DaAmE4bdszwqXS7tHznGYJPp7fxEoEQxxBPcQ’,`'
  prefs: []
  type: TYPE_NORMAL
- en: '`‘KxR8HHyfAwFPidCw2vXThXqT4vSMNeufirHFapnfCfkzLaohtujG’]`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0[‘redeem_script’] = ‘635221037fadaea6edf196bf70af16cefb2bd3c830e54c0a6e9a00bf7806b241933547f72102fcb1c7507db15576ab35cd7c9b1ea570141a8b81c9938dae0320392b0f7034d052ae670169b27521037fadaea6edf196bf70af16cefb2bd3c830e54c0a6e9a00bf7806b241933547f7ac68’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0[‘hash_type’] = SIGHASH_ALL`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘inputs’].append(input0)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘out_count’] = 2`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘outputs’] = []`'
  prefs: []
  type: TYPE_NORMAL
- en: '`output0 = {}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`output0[‘satoshis’] = 10*(10**8)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`output0[‘script_type’] = ‘P2PKH’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`output0[‘address’] = ‘mxzmMmVycLDgAA48VtHDeh389eDAwiJqwQ’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘outputs’].append(output0)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`output1 = {}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`output1[‘satoshis’] = 399999*(10**4)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`output1[‘script_type’] = ‘P2PKH’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`output1[‘address’] = ‘miSFmBeKXf5Wp7Luj46XTu3Yh57nAwhZAo’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘outputs’].append(output1)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘locktime’] = 0 # block height`'
  prefs: []
  type: TYPE_NORMAL
- en: '`return txn`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Program 11.8:** Method to create transaction for True condition'
  prefs: []
  type: TYPE_NORMAL
- en: To the redeem script, we need to provide public keys of both Alice and Bob as
    in the normal multi-sig script. Here, we also need to provide `**OP_1**` or True
    to the script.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the `**scriptSig**` with included redeem script is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`#OP_0`'
  prefs: []
  type: TYPE_NORMAL
- en: '`#<Alice’s Signature>`'
  prefs: []
  type: TYPE_NORMAL
- en: '`#<Bob’s Signature>`'
  prefs: []
  type: TYPE_NORMAL
- en: '`#OP_1 (True)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`#IF`'
  prefs: []
  type: TYPE_NORMAL
- en: '`# OP_2 <Alice’s pubkey> <Bob’s pubkey> OP_2 CHECKMULTISIG`'
  prefs: []
  type: TYPE_NORMAL
- en: '`#ELSE`'
  prefs: []
  type: TYPE_NORMAL
- en: '`# 105 CHECKSEQUENCEVERIFY DROP`'
  prefs: []
  type: TYPE_NORMAL
- en: '`# <Alice’s pubkey> CHECKSIG`'
  prefs: []
  type: TYPE_NORMAL
- en: '`#ENDIF`'
  prefs: []
  type: TYPE_NORMAL
- en: 'We further add the following condition in the method `**createSignedInput**`
    to handle `**script_type**` *P2SH_Condition* for the preceding conditional scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: '`elif txn_input[‘script_type’] == ‘P2SH_Condition’:`'
  prefs: []
  type: TYPE_NORMAL
- en: '`scriptSig_b = createScriptSigForCond(signgrp,`'
  prefs: []
  type: TYPE_NORMAL
- en: '`script_b,`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn_input[‘condition’])`'
  prefs: []
  type: TYPE_NORMAL
- en: 'We also create `**scriptSig**` for custom condition, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`OP_FALSE = 0x00`'
  prefs: []
  type: TYPE_NORMAL
- en: '`OP_TRUE = 0x51`'
  prefs: []
  type: TYPE_NORMAL
- en: '`#########################`'
  prefs: []
  type: TYPE_NORMAL
- en: '`#True Case`'
  prefs: []
  type: TYPE_NORMAL
- en: '`#OP_0`'
  prefs: []
  type: TYPE_NORMAL
- en: '`#<Alice’s Signature>`'
  prefs: []
  type: TYPE_NORMAL
- en: '`#<Bob’s Signature>`'
  prefs: []
  type: TYPE_NORMAL
- en: '`#OP_TRUE (True)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`#########################`'
  prefs: []
  type: TYPE_NORMAL
- en: '`#False Case`'
  prefs: []
  type: TYPE_NORMAL
- en: '`#<Alice’s Signature>`'
  prefs: []
  type: TYPE_NORMAL
- en: '`#OP_FALSE (False)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`#########################`'
  prefs: []
  type: TYPE_NORMAL
- en: '`#Needs to be customized based on use case`'
  prefs: []
  type: TYPE_NORMAL
- en: '`def `**createScriptSigForCond**`(signgrp: `**list**`,`'
  prefs: []
  type: TYPE_NORMAL
- en: '`script_b: bytes,`'
  prefs: []
  type: TYPE_NORMAL
- en: '`cond: bool):`'
  prefs: []
  type: TYPE_NORMAL
- en: '`if cond:`'
  prefs: []
  type: TYPE_NORMAL
- en: '`scriptSig_b = bytes([OP_0])`'
  prefs: []
  type: TYPE_NORMAL
- en: '`for sign_b in signgrp:`'
  prefs: []
  type: TYPE_NORMAL
- en: '`scriptSig_b += getWithPushdata(sign_b)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`scriptSig_b += bytes([OP_TRUE])`'
  prefs: []
  type: TYPE_NORMAL
- en: '`scriptSig_b += getWithPushdata(script_b)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`else:`'
  prefs: []
  type: TYPE_NORMAL
- en: '`scriptSig_b = encodePushdata(len(signgrp[0])) + signgrp[0]`'
  prefs: []
  type: TYPE_NORMAL
- en: '`scriptSig_b += bytes([OP_FALSE])`'
  prefs: []
  type: TYPE_NORMAL
- en: '`scriptSig_b += encodePushdata(len(script_b)) + script_b`'
  prefs: []
  type: TYPE_NORMAL
- en: '`return scriptSig_b`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Program 11.9:** ScriptSig for condition handling'
  prefs: []
  type: TYPE_NORMAL
- en: 'On executing the code, we get the following signed raw transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-11.26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 11.26:** Create transaction hex code for payment with relative locktime'
  prefs: []
  type: TYPE_NORMAL
- en: 'We decode the preceding script and get the following decoded script:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-11.27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 11.27:** ScriptSig in the transaction for payment with relative lock'
  prefs: []
  type: TYPE_NORMAL
- en: 'We publish the transaction we just created as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-11.28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 11.28:** Transaction for payment with relative lock is published'
  prefs: []
  type: TYPE_NORMAL
- en: This shows how the script works in normal conditions. In the condition of dispute,
    the `**OP_ELSE**` condition gets executed, and we need to hold the transaction
    in the mempool till the `**OP_CHECKSEQUENCEVERIFY**` condition is met. If we publish
    the transaction before the due time, it gets rejected. For this, we need to additionally
    set sequence greater than 105.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we modify the transaction structure as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`#2-of-2-multisig with condition`'
  prefs: []
  type: TYPE_NORMAL
- en: '`def createTransactionStruct():`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn = {}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘version’] = 2`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘input_count’] = 1`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘inputs’] = []`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0 = {}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0[‘prevtxn’] = \`'
  prefs: []
  type: TYPE_NORMAL
- en: '`‘624d92839eb89104d0909df89f95785cb8bb77f0fec66c6c40cf3ad2804a3966’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0[‘prevtxnindex’] = 0`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0[‘script_type’] = ‘P2SH_Condition’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0[‘condition’] = False`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0[‘privkeys’] = \`'
  prefs: []
  type: TYPE_NORMAL
- en: '`[‘L26JcHRhqEQv8V9DaAmE4bdszwqXS7tHznGYJPp7fxEoEQxxBPcQ’]`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0[‘redeem_script’] = ‘635221037fadaea6edf196bf70af16cefb2bd3c830e54c0a6e9a00bf7806b241933547f72102fcb1c7507db15576ab35cd7c9b1ea570141a8b81c9938dae0320392b0f7034d052ae670169b27521037fadaea6edf196bf70af16cefb2bd3c830e54c0a6e9a00bf7806b241933547f7ac68’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0[‘hash_type’] = SIGHASH_ALL`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0[‘sequence’] = 110`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0[‘sequence_type’] = ‘block’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘inputs’].append(input0)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘out_count’] = 2`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘outputs’] = []`'
  prefs: []
  type: TYPE_NORMAL
- en: '`output0 = {}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`output0[‘satoshis’] = 10*(10**8)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`output0[‘script_type’] = ‘P2PKH’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`output0[‘address’] = ‘mxzmMmVycLDgAA48VtHDeh389eDAwiJqwQ’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘outputs’].append(output0)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`output1 = {}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`output1[‘satoshis’] = 399999*(10**4)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`output1[‘script_type’] = ‘P2PKH’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`output1[‘address’] = ‘miSFmBeKXf5Wp7Luj46XTu3Yh57nAwhZAo’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘outputs’].append(output1)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘locktime’] = 0 # block height`'
  prefs: []
  type: TYPE_NORMAL
- en: '`return txn`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Program 11.10:** Method to create transaction for False condition'
  prefs: []
  type: TYPE_NORMAL
- en: 'On executing the modified code, we get the following signed transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-11.29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 11.29:** Transaction for payment with relative lock is published'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we try to execute this script before 106 blocks are mined, we get the following
    error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-11.30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 11.30:** Payment with relative lock fails to publish before required
    block height'
  prefs: []
  type: TYPE_NORMAL
- en: 'But once 110 blocks are mined, we can publish it, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-11.31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 11.31:** Payment with relative lock published after the required block
    height'
  prefs: []
  type: TYPE_NORMAL
- en: You learnt how you can have conditional payments in the contract. Conditionals
    are an important part of a contract, and by learning this, we can think about
    more complex smart contracts.
  prefs: []
  type: TYPE_NORMAL
- en: '[Payments involving escrow](toc.xhtml#s243a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If both parties are not trustworthy, we need a trusted third party to resolve
    the dispute. This is like decentralized exchanges in which the buyers and seller
    gets into a trade, and when the payment is received by the seller, it releases
    bitcoin.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following flowchart shows the steps and conditions involved in the entire
    payment process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-11.32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 11.32:** Flow chart for payment involving escrow'
  prefs: []
  type: TYPE_NORMAL
- en: For programming this, we only need to have 2-of-3-multisig instead of 2-of-2-multisig
    with relative timeout, which we discussed in the previous subtopic.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the new redeem script will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`#IF`'
  prefs: []
  type: TYPE_NORMAL
- en: '`# OP_2 <Alice’s pubkey><Bob’s pubkey><escrow’s pubkey> OP_3 OP_CHECKMULTISIG`'
  prefs: []
  type: TYPE_NORMAL
- en: '`#ELSE`'
  prefs: []
  type: TYPE_NORMAL
- en: '`# 105 CHECKSEQUENCEVERIFY DROP`'
  prefs: []
  type: TYPE_NORMAL
- en: '`# <Alice’s pubkey> CHECKSIG`'
  prefs: []
  type: TYPE_NORMAL
- en: '`#ENDIF`'
  prefs: []
  type: TYPE_NORMAL
- en: We will have this as an assignment for the readers.
  prefs: []
  type: TYPE_NORMAL
- en: '[Payment involving secret identifier](toc.xhtml#s244a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Consider a case where a secret agent is on a mission in the enemy territory.
    Some items need to be transferred to them so that the mission can be carried out.
    If they receive that package, then the mission is carried out; otherwise, it is
    aborted. To carry out the mission, they need to be paid. So, they can only claim
    the payment when they have received the package.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, a contract needs to be created with a relative locktime and in
    successful condition, the agent needs to reveal the secret.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the redeem script for the contract:'
  prefs: []
  type: TYPE_NORMAL
- en: '`#IF`'
  prefs: []
  type: TYPE_NORMAL
- en: '`# OP_SHA256 <secret_hash> OP_EQUALVERIFY`'
  prefs: []
  type: TYPE_NORMAL
- en: '`# <Agent’s pubkey> CHECKSIG`'
  prefs: []
  type: TYPE_NORMAL
- en: '`#ELSE`'
  prefs: []
  type: TYPE_NORMAL
- en: '`# 105 CHECKSEQUENCEVERIFY DROP`'
  prefs: []
  type: TYPE_NORMAL
- en: '`# <Agency’s pubkey> CHECKSIG`'
  prefs: []
  type: TYPE_NORMAL
- en: '`#ENDIF`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the opcodes and their hex values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`OP_2 = 0x52`'
  prefs: []
  type: TYPE_NORMAL
- en: '`OP_IF = 0x63`'
  prefs: []
  type: TYPE_NORMAL
- en: '`OP_ELSE = 0x67`'
  prefs: []
  type: TYPE_NORMAL
- en: '`OP_ENDIF = 0x68`'
  prefs: []
  type: TYPE_NORMAL
- en: '`OP_CHECKSEQUENCEVERIFY = 0xb2`'
  prefs: []
  type: TYPE_NORMAL
- en: '`OP_EQUALVERIFY = 0x88`'
  prefs: []
  type: TYPE_NORMAL
- en: '`OP_DROP = 0x75`'
  prefs: []
  type: TYPE_NORMAL
- en: '`OP_SHA256 = 0xa8`'
  prefs: []
  type: TYPE_NORMAL
- en: '`OP_CHECKSIG = 0xac`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Program 11.11:** Opcodes used in redeem script for payment with secret'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the code to generate redeem-script:'
  prefs: []
  type: TYPE_NORMAL
- en: '`def createRedeemScriptWithSecretHash(pubkey_agency: str, pubkey_agent: str,
    secret_h: bytes):`'
  prefs: []
  type: TYPE_NORMAL
- en: '`redeem_script_b = bytes([OP_IF, OP_SHA256])`'
  prefs: []
  type: TYPE_NORMAL
- en: '`redeem_script_b += createVarInt(len(secret_h)) + secret_h`'
  prefs: []
  type: TYPE_NORMAL
- en: '`redeem_script_b += bytes([OP_EQUALVERIFY])`'
  prefs: []
  type: TYPE_NORMAL
- en: '`pubkey_b = bytes.fromhex(pubkey_agent)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`redeem_script_b += createVarInt(len(pubkey_b)) + pubkey_b`'
  prefs: []
  type: TYPE_NORMAL
- en: '`redeem_script_b += bytes([OP_CHECKSIG])`'
  prefs: []
  type: TYPE_NORMAL
- en: '`redeem_script_b += bytes([OP_ELSE, 0x01,`'
  prefs: []
  type: TYPE_NORMAL
- en: '`105, # after 105 blocks`'
  prefs: []
  type: TYPE_NORMAL
- en: '`OP_CHECKSEQUENCEVERIFY, OP_DROP])`'
  prefs: []
  type: TYPE_NORMAL
- en: '`pubkey_b = bytes.fromhex(pubkey_agency)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`redeem_script_b += createVarInt(len(pubkey_b)) + pubkey_b`'
  prefs: []
  type: TYPE_NORMAL
- en: '`redeem_script_b += bytes([OP_CHECKSIG, OP_ENDIF])`'
  prefs: []
  type: TYPE_NORMAL
- en: '`return redeem_script_b`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Program 11.12:** Method to create redeem script for payment with secret'
  prefs: []
  type: TYPE_NORMAL
- en: 'We call the method by passing public keys and secret, and generate address
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`if __name__ == ‘__main__’:`'
  prefs: []
  type: TYPE_NORMAL
- en: '`pubkey_agency = ‘037fadaea6edf196bf70af16cefb2bd3c830e54c0a6e9a00bf7806b241933547f7’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`pubkey_agent = ‘02fcb1c7507db15576ab35cd7c9b1ea570141a8b81c9938dae0320392b0f7034d0’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`secret = ‘She sells seashells on the seashore’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`secret_h = hashlib.sha256(secret.encode(‘utf-8’)).digest()`'
  prefs: []
  type: TYPE_NORMAL
- en: '`redeem_script_b = createRedeemScriptWithSecretHash(pubkey_agency, pubkey_agent,
    secret_h)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`print(‘redeem script = %s’ % redeem_script_b.hex())`'
  prefs: []
  type: TYPE_NORMAL
- en: '`sh = hash160(redeem_script_b)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`address = sh2address(sh)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`print(‘P2SH address = %s’ % address)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'On calling the method and then generating address for the redeem script, we
    get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-11.33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 11.33:** Redeem script for payment involving secret code'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, we generate a block to pay to the P2SH address
    and then get the transaction-id for the created coinbase transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-11.34.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 11.34:** Coinbase transaction-id for funding payment involving secret
    code'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the package reaches the agent, they can use the secret code to receive the
    payment. In that case, the True part of the condition in redeem script is executed.
    We create the transaction structure that provides secret as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`def createTransactionStruct():`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn = {}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘version’] = 1`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘input_count’] = 1`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘inputs’] = []`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0 = {}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0[‘prevtxn’] = \`'
  prefs: []
  type: TYPE_NORMAL
- en: '`‘5bdcb4a0ff46b4443cfa1ff8002a8ccff06e56a8100a259fbfbd4b0ab660d481’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0[‘prevtxnindex’] = 0`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0[‘script_type’] = ‘P2SH_WithSecret’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0[‘privkeys’] = \`'
  prefs: []
  type: TYPE_NORMAL
- en: '`[‘KxR8HHyfAwFPidCw2vXThXqT4vSMNeufirHFapnfCfkzLaohtujG’]`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0[‘redeem_script’] = ‘63a82009b5eb7277b9d5062d91fe20f141ad4dd81970fd0baa72d31ee346a7c48d5b8c882102fcb1c7507db15576ab35cd7c9b1ea570141a8b81c9938dae0320392b0f7034d0ac670169b27521037fadaea6edf196bf70af16cefb2bd3c830e54c0a6e9a00bf7806b241933547f7ac68’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0[‘secret’] = ‘She sells seashells on the seashore’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0[‘condition’] = True`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0[‘hash_type’] = SIGHASH_ALL`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘inputs’].append(input0)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘out_count’] = 2`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘outputs’] = []`'
  prefs: []
  type: TYPE_NORMAL
- en: '`output0 = {}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`output0[‘satoshis’] = 10*(10**8)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`output0[‘script_type’] = ‘P2PKH’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`output0[‘address’] = ‘mxzmMmVycLDgAA48VtHDeh389eDAwiJqwQ’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘outputs’].append(output0)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`output1 = {}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`output1[‘satoshis’] = 399999*(10**4)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`output1[‘script_type’] = ‘P2PKH’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`output1[‘address’] = ‘miSFmBeKXf5Wp7Luj46XTu3Yh57nAwhZAo’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘outputs’].append(output1)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘locktime’] = 0 # block height`'
  prefs: []
  type: TYPE_NORMAL
- en: '`return txn`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Program 11.13:** Method to create transaction for payment with secret'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is done by having the following `**scriptSig**`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`#<Agent’s signature>`'
  prefs: []
  type: TYPE_NORMAL
- en: '`#<secret>`'
  prefs: []
  type: TYPE_NORMAL
- en: '`#OP_1`'
  prefs: []
  type: TYPE_NORMAL
- en: '`#IF`'
  prefs: []
  type: TYPE_NORMAL
- en: '`# OP_SHA256 <secret_hash> OP_EQUALVERIFY`'
  prefs: []
  type: TYPE_NORMAL
- en: '`# <Agent’s pubkey> CHECKSIG`'
  prefs: []
  type: TYPE_NORMAL
- en: '`#ELSE`'
  prefs: []
  type: TYPE_NORMAL
- en: '`# 105 CHECKSEQUENCEVERIFY DROP`'
  prefs: []
  type: TYPE_NORMAL
- en: '`# <Agency’s pubkey> CHECKSIG`'
  prefs: []
  type: TYPE_NORMAL
- en: '`#ENDIF`'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is done in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`def createScriptSigWithSecret(signgrp: list, script_b: bytes, secret: str,
    cond: bool):`'
  prefs: []
  type: TYPE_NORMAL
- en: '`if cond:`'
  prefs: []
  type: TYPE_NORMAL
- en: '`scriptSig_b = getWithPushdata(signgrp[0])`'
  prefs: []
  type: TYPE_NORMAL
- en: '`secret_b = secret.encode(‘utf-8’)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`scriptSig_b += getWithPushdata(secret_b)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`scriptSig_b += bytes([OP_TRUE])`'
  prefs: []
  type: TYPE_NORMAL
- en: '`else:`'
  prefs: []
  type: TYPE_NORMAL
- en: '`scriptSig_b = getWithPushdata(signgrp[0])`'
  prefs: []
  type: TYPE_NORMAL
- en: '`scriptSig_b += bytes([OP_FALSE])`'
  prefs: []
  type: TYPE_NORMAL
- en: '`scriptSig_b += getWithPushdata(script_b)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`return scriptSig_b`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Program 11.14:** Method to prepare scriptSig for the secret identifier use
    case'
  prefs: []
  type: TYPE_NORMAL
- en: The scripts associated with each of the smart contracts discussed in this chapter
    may require separate handling of scriptSig. Each of these methods are added to
    `**createSignedInput**` method as a new condition.
  prefs: []
  type: TYPE_NORMAL
- en: 'To handle condition with secret discussed in this subtopic we further add the
    following condition in the method `**createSignedInput**` to handle `**script_type**`
    *P2SH_WithSecret* for the preceding conditional scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: '`elif txn_input[‘script_type’] == ‘P2SH_WithSecret’:`'
  prefs: []
  type: TYPE_NORMAL
- en: '`if txn_input[‘condition’]:`'
  prefs: []
  type: TYPE_NORMAL
- en: '`scriptSig_b = createScriptSigWithSecret(signgrp, script_b, txn_input[**‘secret’**],
    **True**)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`else:`'
  prefs: []
  type: TYPE_NORMAL
- en: '`scriptSig_b = createScriptSigWithSecret(signgrp, script_b, **‘’**, **False**)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'We execute the code and get signed raw transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-11.35.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 11.35:** Created transaction for payment involving secret code'
  prefs: []
  type: TYPE_NORMAL
- en: 'This gives us the following `**scriptSig**`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-11.36.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 11.36:** ScriptSig of transaction for funding payment involving secret
    code'
  prefs: []
  type: TYPE_NORMAL
- en: 'We publish it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-11.37.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 11.37:** Transaction for payment involving secret code is published'
  prefs: []
  type: TYPE_NORMAL
- en: '[Collaborative transactions](toc.xhtml#s245a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In some cases, there are multiple contributors of a single transaction. The
    contributors may not be aware of other parts of the transaction. So, they can
    only sign a portion of the transaction. This is done through different SIGHASH
    types.
  prefs: []
  type: TYPE_NORMAL
- en: In *[Chapter 10, Create and Validate Transactions](c10.xhtml),* under the topic
    ***Signature*** *v****erification*****,** you learnt about different SIGHASH types
    and their uses.
  prefs: []
  type: TYPE_NORMAL
- en: In a collaborative transaction, each party creates their transaction and sends
    it to a person or authority that has the responsibility to create and publish
    the final transaction.
  prefs: []
  type: TYPE_NORMAL
- en: 'For individual transactions, the following code contains the changes required
    to generate signature preimage:'
  prefs: []
  type: TYPE_NORMAL
- en: '`def createSignaturePreimage(txn_struct: dict,`'
  prefs: []
  type: TYPE_NORMAL
- en: '`script_b: bytes,`'
  prefs: []
  type: TYPE_NORMAL
- en: '`inp_index: int):`'
  prefs: []
  type: TYPE_NORMAL
- en: '`preimage_b = b’’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`preimage_b += struct.pack(‘<L’, txn_struct[‘version’])`'
  prefs: []
  type: TYPE_NORMAL
- en: '`hashtype = txn_struct[‘inputs’][inp_index][‘hash_type’]`'
  prefs: []
  type: TYPE_NORMAL
- en: '`if hashtype & SIGHASH_ANYONECANPAY:`'
  prefs: []
  type: TYPE_NORMAL
- en: '`preimage_b += createVarInt(1)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`inputs = [inp_index] # only current input is processed`'
  prefs: []
  type: TYPE_NORMAL
- en: '`else:`'
  prefs: []
  type: TYPE_NORMAL
- en: '`preimage_b += createVarInt(txn_struct[‘input_count’])`'
  prefs: []
  type: TYPE_NORMAL
- en: '`inputs = range(txn_struct[‘input_count’])`'
  prefs: []
  type: TYPE_NORMAL
- en: '`for i in inputs:`'
  prefs: []
  type: TYPE_NORMAL
- en: '`inp = txn_struct[‘inputs’][i]`'
  prefs: []
  type: TYPE_NORMAL
- en: '`preimage_b += bytes.fromhex(inp[‘prevtxn’])[::-1]`'
  prefs: []
  type: TYPE_NORMAL
- en: '`preimage_b += struct.pack(‘<L’, inp[‘prevtxnindex’])`'
  prefs: []
  type: TYPE_NORMAL
- en: '`if i == inp_index:`'
  prefs: []
  type: TYPE_NORMAL
- en: '`preimage_b += createVarInt(len(script_b))`'
  prefs: []
  type: TYPE_NORMAL
- en: '`preimage_b += script_b`'
  prefs: []
  type: TYPE_NORMAL
- en: '`else:`'
  prefs: []
  type: TYPE_NORMAL
- en: '`preimage_b += b’\x00’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`preimage_b += getSequence(txn_struct, i)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`# remove SIGHASH_ANYONECANPAY`'
  prefs: []
  type: TYPE_NORMAL
- en: '`if hashtype & 0x0F == SIGHASH_NONE:`'
  prefs: []
  type: TYPE_NORMAL
- en: '`preimage_b += createVarInt(0)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`else:`'
  prefs: []
  type: TYPE_NORMAL
- en: '`# remove SIGHASH_ANYONECANPAY`'
  prefs: []
  type: TYPE_NORMAL
- en: '`if hashtype & 0x0F == SIGHASH_SINGLE:`'
  prefs: []
  type: TYPE_NORMAL
- en: '`preimage_b += createVarInt(inp[‘input_index’] + 1)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`outputs = range(inp[‘input_index’] + 1)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`else:`'
  prefs: []
  type: TYPE_NORMAL
- en: '`preimage_b += createVarInt(txn_struct[‘out_count’])`'
  prefs: []
  type: TYPE_NORMAL
- en: '`outputs = range(txn_struct[‘out_count’])`'
  prefs: []
  type: TYPE_NORMAL
- en: '`for out in outputs:`'
  prefs: []
  type: TYPE_NORMAL
- en: '`outp = txn_struct[‘outputs’][out]`'
  prefs: []
  type: TYPE_NORMAL
- en: '`preimage_b += struct.pack(‘<Q’, outp[‘satoshis’])`'
  prefs: []
  type: TYPE_NORMAL
- en: '`if outp[‘script_type’] == ‘OP_RETURN’:`'
  prefs: []
  type: TYPE_NORMAL
- en: '`content_b = bytes.fromhex(outp[‘content_hash256’])`'
  prefs: []
  type: TYPE_NORMAL
- en: '`scriptPubkey_b = bytes([OP_RETURN]) \ + getWithPushdata(content_b)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`else:`'
  prefs: []
  type: TYPE_NORMAL
- en: '`scriptPubkey_b = \`'
  prefs: []
  type: TYPE_NORMAL
- en: '`getScriptPubkeyFromAddress(outp[‘address’])`'
  prefs: []
  type: TYPE_NORMAL
- en: '`preimage_b += createVarInt(len(scriptPubkey_b))`'
  prefs: []
  type: TYPE_NORMAL
- en: '`preimage_b += scriptPubkey_b`'
  prefs: []
  type: TYPE_NORMAL
- en: '`preimage_b += struct.pack(‘<L’, txn_struct[‘locktime’])`'
  prefs: []
  type: TYPE_NORMAL
- en: '`preimage_b += struct.pack(‘<L’, hashtype)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`return preimage_b`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Program 11.15:** Method to create signature preimage for all sighash types'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the createSignedInput method updated after accumulating all
    the conditions we had used in the preceding use cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '`def createSignedInput(txn_input: dict, signgrp, script_b: bytes):`'
  prefs: []
  type: TYPE_NORMAL
- en: '`prevtxn = txn_input[‘prevtxn’]`'
  prefs: []
  type: TYPE_NORMAL
- en: '`prevtx_rb = bytes.fromhex(prevtxn)[::-1]`'
  prefs: []
  type: TYPE_NORMAL
- en: '`prevtxnindex = txn_input[‘prevtxnindex’]`'
  prefs: []
  type: TYPE_NORMAL
- en: '`sgntxnin_b = prevtx_rb + struct.pack(‘<L’, prevtxnindex)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`if ‘input_txn’ in txn_input: #added`'
  prefs: []
  type: TYPE_NORMAL
- en: '`scriptSig = txn_input[‘scriptsig’]`'
  prefs: []
  type: TYPE_NORMAL
- en: '`scriptSig_b = bytes.fromhex(scriptSig)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`elif txn_input[‘script_type’] == ‘P2SH_Multisig’:`'
  prefs: []
  type: TYPE_NORMAL
- en: '`scriptSig_b = createScriptSigForMultiSig(signgrp, script_b)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`elif txn_input[‘script_type’] == ‘P2SH_RelativeTimeLock’:`'
  prefs: []
  type: TYPE_NORMAL
- en: '`scriptSig_b = createScriptSigForRelTimeLock(signgrp, script_b)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`elif txn_input[‘script_type’] == ‘P2SH_Condition’:`'
  prefs: []
  type: TYPE_NORMAL
- en: '`scriptSig_b = createScriptSigForCond(signgrp,`'
  prefs: []
  type: TYPE_NORMAL
- en: '`script_b,`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn_input[‘condition’])`'
  prefs: []
  type: TYPE_NORMAL
- en: '`elif txn_input[‘script_type’] == ‘P2SH_WithSecret’:`'
  prefs: []
  type: TYPE_NORMAL
- en: '`if txn_input[‘condition’]:`'
  prefs: []
  type: TYPE_NORMAL
- en: '`scriptSig_b = createScriptSigWithSecret(signgrp, script_b, txn_input[**‘secret’**],
    **True**)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`else:`'
  prefs: []
  type: TYPE_NORMAL
- en: '`scriptSig_b = createScriptSigWithSecret(signgrp, script_b, **‘’**, **False**)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`elif txn_input[‘script_type’] == ‘P2PKH’:`'
  prefs: []
  type: TYPE_NORMAL
- en: '`scriptSig_b = createScriptSigForP2PKH(txn_input, signgrp)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`sgntxnin_b += createVarInt(len(scriptSig_b)) + scriptSig_b`'
  prefs: []
  type: TYPE_NORMAL
- en: '`return sgntxnin_b`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Program 11.16:** Method to prepare inputs for signed transaction'
  prefs: []
  type: TYPE_NORMAL
- en: The transactions are generated by each individual and sent to someone to collate.
    Each transaction goes into a new field, `**input_txn**`, in the transaction structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need code to parse and populate transaction structure with previous the
    transaction-ID, the previous transaction output `**index**`, and `**scriptSig**`.
    The following method does this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`def updateTxnStructInput(txn_struct: dict, index: int):`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn_s = txn_struct[‘inputs’][index][‘input_txn’]`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn_b = bytes.fromhex(txn_s)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`with mmap.mmap(-1, len(txn_b)) as txn_m:`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn_m.write(txn_b)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn_m.seek(0)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`inp = getTransactionInfo(txn_m)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn_input = txn_struct[‘inputs’][index]`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn_input[‘prevtxn’] = inp[‘inputs’][0][‘prev_tx_hash’]`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn_input[‘prevtxnindex’] = inp[‘inputs’][0][‘prev_tx_out_index’]`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn_input[‘scriptsig’] = inp[‘inputs’][0][‘scriptsig’]`'
  prefs: []
  type: TYPE_NORMAL
- en: '`return txn_struct`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Program 11.17:** Update transaction structure from input transaction hex
    string'
  prefs: []
  type: TYPE_NORMAL
- en: '`The update structure is called within the following program:`'
  prefs: []
  type: TYPE_NORMAL
- en: '`def getSignaturesAndExecScripts(txn_struct: dict):`'
  prefs: []
  type: TYPE_NORMAL
- en: '`signgrp_l = []`'
  prefs: []
  type: TYPE_NORMAL
- en: '`script_l = []`'
  prefs: []
  type: TYPE_NORMAL
- en: '`for inp_index in range(txn_struct[‘input_count’]):`'
  prefs: []
  type: TYPE_NORMAL
- en: '`inp = txn_struct[‘inputs’][inp_index]`'
  prefs: []
  type: TYPE_NORMAL
- en: '`if ‘input_txn’ in inp:`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn_struct = updateTxnStructInput(txn_struct, inp_index)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`signgrp_l.append([])`'
  prefs: []
  type: TYPE_NORMAL
- en: '`script_l.append(b’’)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`else:`'
  prefs: []
  type: TYPE_NORMAL
- en: '`script_b = getExecutionScript(txn_struct, inp_index)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`preimage_b = createSignaturePreimage(txn_struct, script_b, inp_index)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`signgrp = []`'
  prefs: []
  type: TYPE_NORMAL
- en: '`for privkey in inp[‘privkeys’]:`'
  prefs: []
  type: TYPE_NORMAL
- en: '`hashtype = inp[‘hash_type’]`'
  prefs: []
  type: TYPE_NORMAL
- en: '`sign_b = signMessage(preimage_b, privkey, hashtype)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`signgrp.append(sign_b)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`signgrp_l.append(signgrp)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`script_l.append(script_b)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`return txn_struct, signgrp_l, script_l`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Program 11.18:** Modified method on signatures and scripts to also include
    modified transaction structure'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding method now returns the updated structure as well.
  prefs: []
  type: TYPE_NORMAL
- en: There are different conditions in which collaborative transactions may be required.
    Some of these are discussed here.
  prefs: []
  type: TYPE_NORMAL
- en: '[Charity use case](toc.xhtml#s246a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the case of charity, people donate money to the organization, and the organization
    then uses those funds and funds from its reserve to perform social service activities.
    Those funds are also used to pay salaries to the regular employees.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we are using `**SIGHASH_NONE|SIGHASH_ANYONECANPAY**` as donors
    do not know where the funds will be used and so, they cannot sign the outputs.
  prefs: []
  type: TYPE_NORMAL
- en: In this use case, the individuals donating will create a transaction without
    outputs and send it to the charitable trust. This transaction will include signature.
    Then, the charitable trust will add additional funds from its reserves and pay
    the vendor, which will provide food, clothing, etc. to the destitute children
    of the organization.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an illustration of charity:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-11.38.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 11.38:** Charity use case'
  prefs: []
  type: TYPE_NORMAL
- en: We write code in which Alice and Bob pay 50 ![](images/Bitcoin.jpg) each to
    the trust, and the trust pays 125 ![](images/Bitcoin.jpg) to the merchant after
    adding their 50![](images/Bitcoin.jpg) as additional contribution and pays back
    the rest to itself as change after deducting network fee.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Alice, we create code with the following transaction structure method:'
  prefs: []
  type: TYPE_NORMAL
- en: '`def createTransactionStruct():`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn = {}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘version’] = 1`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘input_count’] = 1`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘inputs’] = []`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0 = {}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0[‘prevtxn’] = ‘5efcf04e32f061b9c4894f5b3a59fb3d8c5c56a6e7340b89b3a1a9ebacca998f’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0[‘prevtxnindex’] = 0`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0[‘script_type’] = ‘P2PKH’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0[‘privkeys’] = [‘KwfxnwxpPG1RmhU8jaU8Ron4m1KZGymLAFNaMnSTonoZ7AQfnV53’]`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0[‘script_pubkey’] = ‘76a91481d7033c19dcec645cb3f86ce41678756850ba4d88ac’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0[‘hash_type’] = SIGHASH_ANYONECANPAY|SIGHASH_NONE`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘inputs’].append(input0)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘out_count’] = 0`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘locktime’] = 0`'
  prefs: []
  type: TYPE_NORMAL
- en: '`return txn`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Program 11.19:** Method to define transaction structure for Alice in charity
    use case'
  prefs: []
  type: TYPE_NORMAL
- en: 'On executing the program, we get the following transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-11.39.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 11.39:** Transaction hex code for Alice in charity use case'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the script in the transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-11.40.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 11.40:** ScriptSig for transaction created for Alice in charity use
    case'
  prefs: []
  type: TYPE_NORMAL
- en: In the case of sighash-type `**ANYONECANPAY**`, the spender is not aware of
    how many other transactions are going to get merged. So, the input index is 0
    even though it may fall in a different index in the final transaction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, we create a transaction for Bob by having the following fields in
    the transaction structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0[‘prevtxn’]=’7995c6e08aee1fb5ddb21c7b84ff949bdb2bd98183623606aa1732a61200c12f’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0[‘privkeys’] = [‘L26JcHRhqEQv8V9DaAmE4bdszwqXS7tHznGYJPp7fxEoEQxxBPcQ’]`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0[‘script_pubkey’] = ‘76a914db610ec1429ecb422044ee4ea92f11bc080fdb3d88ac’`'
  prefs: []
  type: TYPE_NORMAL
- en: 'On executing, we get the following raw transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-11.41.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 11.41:** Create a transaction for Bob in the charity use case'
  prefs: []
  type: TYPE_NORMAL
- en: Now, the charitable trust pays 125 ![](images/Bitcoin.jpg) to a merchant by
    contributing its own 25 ![](images/Bitcoin.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: Till now, the `**createTransactionStruct**` method consisted of previous transaction-ID
    and output indices. Now, to fund the final transaction, we already have two signed
    transactions from Alice and Bob. Consequently, this requires some modification
    to the existing code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The charitable trust pays 125 ![](images/Bitcoin.jpg) to merchant with address:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mnhWcUMqe9J1G4t3NMqNmLUqxfPTgwv7NK`'
  prefs: []
  type: TYPE_NORMAL
- en: 'And the change is paid to the following address:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mtRkMmpT6uhM9LXVPRk4ck9Gcaz9iuQgmZ`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the modified transaction structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '`def createTransactionStruct():`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn = {}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘version’] = 1`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘input_count’] = 3`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘inputs’] = []`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0 = {}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0[‘input_txn’] = ‘01000000018f99caaceba9a1b3890b34e7a6565c8c3dfb593a5b4f89c4b961f0324ef0fc5e000000006a47304402200a4ae1b5ddc7c49859001b9e2ff86bd4be57f44ce49571d6dc68e9942a86c990022054fa2e3446219e8dd6a4ba434d69bde460c7374228e6c529aaa95bb460e3ad2082210281238fc6d981efce6aa1b3ccb8556a1b115a40f8ab3315c003f415ceedc3defeffffffff0000000000’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0[‘hash_type’] = SIGHASH_ANYONECANPAY|SIGHASH_NONE`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘inputs’].append(input0)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input1 = {}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input1[‘input_txn’] = ‘01000000012fc10012a63217aa0636628381d92bdb9b94ff847b1cb2ddb51fee8ae0c69579000000006a4730440220152ecb49937c026ba62afd18604e916a515cb7727780b2e6b981cb0cb717a9940220197a071705e4f929b53e6aadefd477336765cb323ef77b86a3b6882669775d858221037fadaea6edf196bf70af16cefb2bd3c830e54c0a6e9a00bf7806b241933547f7ffffffff0000000000’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input1[‘hash_type’] = SIGHASH_ANYONECANPAY|SIGHASH_NONE`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘inputs’].append(input1)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input2 = {}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input2[‘prevtxn’] = ‘c83e8dc76b2139f84235d38907291ebe2470786b2d5977302a63aff1c5d99649’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input2[‘prevtxnindex’] = 0`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input2[‘script_type’] = ‘P2PKH’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input2[‘privkeys’] = [‘KxR8HHyfAwFPidCw2vXThXqT4vSMNeufirHFapnfCfkzLaohtujG’]`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input2[‘script_pubkey’] = ‘76a9142004e0ff6a6f08115d048fd9af177fae702f681a88ac’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input2[‘hash_type’] = SIGHASH_ALL`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘inputs’].append(input2)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘out_count’] = 2`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘outputs’] = []`'
  prefs: []
  type: TYPE_NORMAL
- en: '`output0 = {}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`output0[‘satoshis’] = 12500000000`'
  prefs: []
  type: TYPE_NORMAL
- en: '`output0[‘script_type’] = ‘P2PKH’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`output0[‘address’] = ‘mnhWcUMqe9J1G4t3NMqNmLUqxfPTgwv7NK’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘outputs’].append(output0)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`output1 = {}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`output1[‘satoshis’] = 2499900000`'
  prefs: []
  type: TYPE_NORMAL
- en: '`output1[‘script_type’] = ‘P2PKH’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`output1[‘address’] = ‘mtRkMmpT6uhM9LXVPRk4ck9Gcaz9iuQgmZ’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘outputs’].append(output1)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘locktime’] = 0`'
  prefs: []
  type: TYPE_NORMAL
- en: '`return txn`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Program 11.20:** Method to define combined transaction structure in charity
    use case'
  prefs: []
  type: TYPE_NORMAL
- en: 'We execute the preceding program to obtain the final transaction. On decoding
    the final transaction, we get the following `**scriptSig**` for corresponding
    inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Input 0:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-11.42.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 11.42:** ScriptSig of first input for transaction in the charity use
    case'
  prefs: []
  type: TYPE_NORMAL
- en: '**Input 1:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-11.43.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 11.43:** ScriptSig of second input for transaction in the charity
    use case'
  prefs: []
  type: TYPE_NORMAL
- en: '**Input 2:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-11.44.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 11.44:** ScriptSig of third input for transaction in the charity use
    case'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the transaction published successfully to the
    network:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-11.45.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 11.45:** Transaction in charity use case is successfully published'
  prefs: []
  type: TYPE_NORMAL
- en: '[Subsidy use case](toc.xhtml#s247a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This use case solves the requirement where a person or organization partially
    sponsors or subsidizes payment for another individual.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we use `**SIGHASH_SINGLE|SIGHASH_ANYONECANPAY**` as only one input
    and one output are known by an individual.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the individual receiving subsidy only pays discounted price for
    the service or product. However, the merchant or service provider receives full
    payment, as the rest of the amount is added by the sponsoring person or organization.
  prefs: []
  type: TYPE_NORMAL
- en: 'This use case has limited benefit as it is not useful for the following conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: Individual needs funds from multiple addresses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Individual needs to pay from a single address to multiple payees
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If more than one person is being subsidized, then everyone who is being subsidized
    also gets an index that relates to the index of the final transaction output where
    their transaction will be added.
  prefs: []
  type: TYPE_NORMAL
- en: We consider an example use case in which two students are selected for an educational
    trip. The school is sponsoring 25% of the cost of their trip. Since there is more
    than one beneficiary of the subsidy and one final transaction is created, one
    student gets index value as 0, and the other gets index value as 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the illustration of the use case where one person’s purchase
    is subsidized by another person:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-11.46.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 11.46:** Subsidy use case'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, Alice must prepare a transaction for index 0\. So, she does not
    need to make any changes to the code, except transaction structure. The following
    code is for transaction structure for Alice:'
  prefs: []
  type: TYPE_NORMAL
- en: '`def createTransactionStruct():`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn = {}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘version’] = 1`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘input_count’] = 1`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘inputs’] = []`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0 = {}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0[‘prevtxn’] = ‘5efcf04e32f061b9c4894f5b3a59fb3d8c5c56a6e7340b89b3a1a9ebacca998f’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0[‘prevtxnindex’] = 0`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0[‘script_type’] = ‘P2PKH’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0[‘privkeys’] = [‘KwfxnwxpPG1RmhU8jaU8Ron4m1KZGymLAFNaMnSTonoZ7AQfnV53’]`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0[‘script_pubkey’] = ‘76a91481d7033c19dcec645cb3f86ce41678756850ba4d88ac’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0[‘input_index’] = 0`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0[‘hash_type’] = SIGHASH_ANYONECANPAY|SIGHASH_SINGLE`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘inputs’].append(input0)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘out_count’] = 1`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘outputs’] = []`'
  prefs: []
  type: TYPE_NORMAL
- en: '`output0 = {}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`output0[‘satoshis’] = 6667000000`'
  prefs: []
  type: TYPE_NORMAL
- en: '`output0[‘script_type’] = ‘P2PKH’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`output0[‘address’] = ‘msV23rBcHAtQWSkWV9ph91DV65VduWi1Vt’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘outputs’].append(output0)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘locktime’] = 0`'
  prefs: []
  type: TYPE_NORMAL
- en: '`return txn`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Program 11.21:** Method to define transaction structure for Alice in the
    subsidy use case'
  prefs: []
  type: TYPE_NORMAL
- en: 'We execute it to get Alice a signed transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-11.47.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 11.47:** Created transaction for Alice in the subsidy use case'
  prefs: []
  type: TYPE_NORMAL
- en: In the case of Bob, since index is 1, Bob will need to have empty output at
    index 0\. This needs to be handled in the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the code for the transaction structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '`def createTransactionStruct():`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn = {}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘version’] = 1`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘input_count’] = 1`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘inputs’] = []`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0 = {}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0[‘prevtxn’] = ‘7995c6e08aee1fb5ddb21c7b84ff949bdb2bd98183623606aa1732a61200c12f’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0[‘prevtxnindex’] = 0`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0[‘script_type’] = ‘P2PKH’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0[‘privkeys’] = [‘L26JcHRhqEQv8V9DaAmE4bdszwqXS7tHznGYJPp7fxEoEQxxBPcQ’]`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0[‘script_pubkey’] = ‘76a914db610ec1429ecb422044ee4ea92f11bc080fdb3d88ac’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0[‘input_index’] = 1`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0[‘hash_type’] = SIGHASH_ANYONECANPAY|SIGHASH_SINGLE`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘inputs’].append(input0)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘out_count’] = 2`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘outputs’] = []`'
  prefs: []
  type: TYPE_NORMAL
- en: '`output0 = {}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`output0[‘script_type’] = ‘’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘outputs’].append(output0)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`output1 = {}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`output1[‘satoshis’] = 6667000000`'
  prefs: []
  type: TYPE_NORMAL
- en: '`output1[‘script_type’] = ‘P2PKH’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`output1[‘address’] = ‘mnhWcUMqe9J1G4t3NMqNmLUqxfPTgwv7NK’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘outputs’].append(output1)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘locktime’] = 0`'
  prefs: []
  type: TYPE_NORMAL
- en: '`return txn`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Program 11.22:** Method to define transaction structure for Bob in subsidy
    use case'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we have introduced new `**script_type**`. This needs to be handled
    when we create signature preimage and signed transaction.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code creates signature preimage:'
  prefs: []
  type: TYPE_NORMAL
- en: '`def createSignaturePreimage(txn_struct: dict,`'
  prefs: []
  type: TYPE_NORMAL
- en: '`script_b: bytes,`'
  prefs: []
  type: TYPE_NORMAL
- en: '`inp_index: int):`'
  prefs: []
  type: TYPE_NORMAL
- en: '`preimage_b = b’’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`preimage_b += struct.pack(‘<L’, txn_struct[‘version’])`'
  prefs: []
  type: TYPE_NORMAL
- en: '`hashtype = txn_struct[‘inputs’][inp_index][‘hash_type’]`'
  prefs: []
  type: TYPE_NORMAL
- en: '`if hashtype & SIGHASH_ANYONECANPAY:`'
  prefs: []
  type: TYPE_NORMAL
- en: '`preimage_b += createVarInt(1)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`inputs = [inp_index] # only current input is processed`'
  prefs: []
  type: TYPE_NORMAL
- en: '`else:`'
  prefs: []
  type: TYPE_NORMAL
- en: '`preimage_b += createVarInt(txn_struct[‘input_count’])`'
  prefs: []
  type: TYPE_NORMAL
- en: '`inputs = range(txn_struct[‘input_count’])`'
  prefs: []
  type: TYPE_NORMAL
- en: '`for i in inputs:`'
  prefs: []
  type: TYPE_NORMAL
- en: '`inp = txn_struct[‘inputs’][i]`'
  prefs: []
  type: TYPE_NORMAL
- en: '`preimage_b += bytes.fromhex(inp[‘prevtxn’])[::-1]`'
  prefs: []
  type: TYPE_NORMAL
- en: '`preimage_b += struct.pack(‘<L’, inp[‘prevtxnindex’])`'
  prefs: []
  type: TYPE_NORMAL
- en: '`if i == inp_index:`'
  prefs: []
  type: TYPE_NORMAL
- en: '`preimage_b += createVarInt(len(script_b))`'
  prefs: []
  type: TYPE_NORMAL
- en: '`preimage_b += script_b`'
  prefs: []
  type: TYPE_NORMAL
- en: '`else:`'
  prefs: []
  type: TYPE_NORMAL
- en: '`preimage_b += b’\x00’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`preimage_b += getSequence(txn_struct, i)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`# remove SIGHASH_ANYONECANPAY`'
  prefs: []
  type: TYPE_NORMAL
- en: '`if hashtype & 0x0F == SIGHASH_NONE:`'
  prefs: []
  type: TYPE_NORMAL
- en: '`preimage_b += createVarInt(0)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`else:`'
  prefs: []
  type: TYPE_NORMAL
- en: '`# remove SIGHASH_ANYONECANPAY`'
  prefs: []
  type: TYPE_NORMAL
- en: '`if hashtype & 0x0F == SIGHASH_SINGLE:`'
  prefs: []
  type: TYPE_NORMAL
- en: '`preimage_b += createVarInt(inp[‘input_index’] + 1)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`outputs = range(inp[‘input_index’] + 1)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`else:`'
  prefs: []
  type: TYPE_NORMAL
- en: '`preimage_b += createVarInt(txn_struct[‘out_count’])`'
  prefs: []
  type: TYPE_NORMAL
- en: '`outputs = range(txn_struct[‘out_count’])`'
  prefs: []
  type: TYPE_NORMAL
- en: '`for out in outputs:`'
  prefs: []
  type: TYPE_NORMAL
- en: '`outp = txn_struct[‘outputs’][out]`'
  prefs: []
  type: TYPE_NORMAL
- en: '`if outp[‘script_type’] == ‘’:`'
  prefs: []
  type: TYPE_NORMAL
- en: '`preimage_b += bytes([0xff])*8`'
  prefs: []
  type: TYPE_NORMAL
- en: '`preimage_b += bytes([0x00])`'
  prefs: []
  type: TYPE_NORMAL
- en: '`else:`'
  prefs: []
  type: TYPE_NORMAL
- en: '`preimage_b += struct.pack(‘<Q’, outp[‘satoshis’])`'
  prefs: []
  type: TYPE_NORMAL
- en: '`if outp[‘script_type’] == ‘OP_RETURN’:`'
  prefs: []
  type: TYPE_NORMAL
- en: '`content_b = bytes.fromhex(outp[‘content_hash256’])`'
  prefs: []
  type: TYPE_NORMAL
- en: '`scriptPubkey_b = bytes([OP_RETURN]) \ + getWithPushdata(content_b)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`else:`'
  prefs: []
  type: TYPE_NORMAL
- en: '`scriptPubkey_b = \ getScriptPubkeyFromAddress(outp[**‘address’**])`'
  prefs: []
  type: TYPE_NORMAL
- en: '`preimage_b += createVarInt(len(scriptPubkey_b))`'
  prefs: []
  type: TYPE_NORMAL
- en: '`preimage_b += scriptPubkey_b`'
  prefs: []
  type: TYPE_NORMAL
- en: '`preimage_b += struct.pack(‘<L’, txn_struct[‘locktime’])`'
  prefs: []
  type: TYPE_NORMAL
- en: '`preimage_b += struct.pack(‘<L’, hashtype)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`return preimage_b`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Program 11.23:** Method to create preimage with additional support for empty
    script type'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the code for creating signed transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '`def createSignedTransaction(txn_struct: dict,`'
  prefs: []
  type: TYPE_NORMAL
- en: '`signgrp_l: list,`'
  prefs: []
  type: TYPE_NORMAL
- en: '`script_l: list):`'
  prefs: []
  type: TYPE_NORMAL
- en: '`sgntxn_b = b’’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`sgntxn_b += struct.pack(‘<L’, txn_struct[‘version’])`'
  prefs: []
  type: TYPE_NORMAL
- en: '`sgntxn_b += createVarInt(txn_struct[‘input_count’])`'
  prefs: []
  type: TYPE_NORMAL
- en: '`for i in range(txn_struct[‘input_count’]):`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn_input = txn_struct[‘inputs’][i]`'
  prefs: []
  type: TYPE_NORMAL
- en: '`sgntxn_b += createSignedInput(txn_input, signgrp_l[i], script_l[i])`'
  prefs: []
  type: TYPE_NORMAL
- en: '`sgntxn_b += getSequence(txn_struct, i)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`sgntxn_b += createVarInt(txn_struct[‘out_count’])`'
  prefs: []
  type: TYPE_NORMAL
- en: '`for out in range(txn_struct[‘out_count’]):`'
  prefs: []
  type: TYPE_NORMAL
- en: '`outp = txn_struct[‘outputs’][out]`'
  prefs: []
  type: TYPE_NORMAL
- en: '`if outp[‘script_type’] == ‘’:`'
  prefs: []
  type: TYPE_NORMAL
- en: '`sgntxn_b += bytes([0xff])*8`'
  prefs: []
  type: TYPE_NORMAL
- en: '`sgntxn_b += bytes([0x00])`'
  prefs: []
  type: TYPE_NORMAL
- en: '`else:`'
  prefs: []
  type: TYPE_NORMAL
- en: '`sgntxn_b += struct.pack(‘<Q’, outp[‘satoshis’])`'
  prefs: []
  type: TYPE_NORMAL
- en: '`if outp[‘script_type’] == ‘OP_RETURN’:`'
  prefs: []
  type: TYPE_NORMAL
- en: '`content_b = bytes.fromhex(outp[‘content_hash256’])`'
  prefs: []
  type: TYPE_NORMAL
- en: '`scriptPubkey_b = bytes([OP_RETURN]) \ + getWithPushdata(content_b)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`else:`'
  prefs: []
  type: TYPE_NORMAL
- en: '`scriptPubkey_b = \ getScriptPubkeyFromAddress(outp[**‘address’**])`'
  prefs: []
  type: TYPE_NORMAL
- en: '`sgntxn_b += createVarInt(len(scriptPubkey_b))`'
  prefs: []
  type: TYPE_NORMAL
- en: '`sgntxn_b += scriptPubkey_b`'
  prefs: []
  type: TYPE_NORMAL
- en: '`sgntxn_b += struct.pack(‘<L’, txn_struct[‘locktime’])`'
  prefs: []
  type: TYPE_NORMAL
- en: '`return sgntxn_b`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Program 11.24:** Method to create signed transaction with additional support
    for empty script type'
  prefs: []
  type: TYPE_NORMAL
- en: 'We get the following signed transaction for Bob:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-11.48.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 11.48:** Created transaction for Bob in the subsidy use case'
  prefs: []
  type: TYPE_NORMAL
- en: Alice and Bob give the transaction they created to the College. The College
    includes those transactions in the final transaction and publishes it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the transaction structure of the final transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '`def createTransactionStruct():`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn = {}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘version’] = 1`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘input_count’] = 3`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘inputs’] = []`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0 = {}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0[‘input_txn’] = ‘01000000018f99caaceba9a1b3890b34e7a6565c8c3dfb593a5b4f89c4b961f0324ef0fc5e000000006b483045022100ff8125ed9e52def07818aa14607ab73ede3fdbc2c0aba0721b6645f9522bac050220419d776c4f291e255cc1dead6fd6543ddd39f2cb65274858c50564b92ae3449683210281238fc6d981efce6aa1b3ccb8556a1b115a40f8ab3315c003f415ceedc3defeffffffff01c058628d010000001976a9148343cfe3998d8a49bcfeea63dcbe12643a8e884788ac00000000’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0[‘hash_type’] = SIGHASH_ANYONECANPAY|SIGHASH_SINGLE`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘inputs’].append(input0)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input1 = {}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input1[‘input_txn’] = ‘01000000012fc10012a63217aa0636628381d92bdb9b94ff847b1cb2ddb51fee8ae0c69579000000006a47304402205a2a89a88e5de4f7198369b0eb01a327a5a737f5d7b80167780c8d492c353e480220497f122aa2fb3fcab3f41a2dcaea67d6f2a68d1b690b121e68eb78b4c19bcbab8321037fadaea6edf196bf70af16cefb2bd3c830e54c0a6e9a00bf7806b241933547f7ffffffff02ffffffffffffffff00c058628d010000001976a9144ec804774aba76cb4685b5152d6924d8ce5c87ae88ac00000000’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input1[‘hash_type’] = SIGHASH_ANYONECANPAY|SIGHASH_SINGLE`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘inputs’].append(input1)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input2 = {}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input2[‘prevtxn’] = ‘c83e8dc76b2139f84235d38907291ebe2470786b2d5977302a63aff1c5d99649’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input2[‘prevtxnindex’] = 0`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input2[‘script_type’] = ‘P2PKH’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input2[‘privkeys’] = [‘KxR8HHyfAwFPidCw2vXThXqT4vSMNeufirHFapnfCfkzLaohtujG’]`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input2[‘script_pubkey’] = ‘76a9142004e0ff6a6f08115d048fd9af177fae702f681a88ac’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input2[‘hash_type’] = SIGHASH_ALL`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘inputs’].append(input2)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘out_count’] = 3`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘outputs’] = []`'
  prefs: []
  type: TYPE_NORMAL
- en: '`output0 = {}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`output0[‘satoshis’] = 6667000000`'
  prefs: []
  type: TYPE_NORMAL
- en: '`output0[‘script_type’] = ‘P2PKH’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`output0[‘address’] = ‘msV23rBcHAtQWSkWV9ph91DV65VduWi1Vt’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘outputs’].append(output0)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`output1 = {}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`output1[‘satoshis’] = 6667000000`'
  prefs: []
  type: TYPE_NORMAL
- en: '`output1[‘script_type’] = ‘P2PKH’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`output1[‘address’] = ‘mnhWcUMqe9J1G4t3NMqNmLUqxfPTgwv7NK’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘outputs’].append(output1)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`output2 = {}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`output2[‘satoshis’] = 1665990000`'
  prefs: []
  type: TYPE_NORMAL
- en: '`output2[‘script_type’] = ‘P2PKH’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`output2[‘address’] = ‘mtRkMmpT6uhM9LXVPRk4ck9Gcaz9iuQgmZ’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘outputs’].append(output2)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘locktime’] = 0`'
  prefs: []
  type: TYPE_NORMAL
- en: '`return txn`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Program 11.25:** Method to define combined transaction structure in the charity
    use case'
  prefs: []
  type: TYPE_NORMAL
- en: 'We execute the code to create the final transaction, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-11.49.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 11.49:** Created transaction in the subsidy use case'
  prefs: []
  type: TYPE_NORMAL
- en: 'We publish this transaction using Bitcoin Core software, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-11.50.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 11.50:** Subsidy use case transaction published successfully'
  prefs: []
  type: TYPE_NORMAL
- en: '[Planned contribution within a group](toc.xhtml#s248a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unlike subsidy or charity, in this case, the involved participants are contributing
    for a known purpose, like buying a gift for a teacher. Everyone contributes their
    portion or fair share for buying the gift, and everyone knows how they are paying.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we are using `**SIGHASH_ALL|SIGHASH_ANYONECANPAY**` as donors
    know where the funds will be used and so, sign the outputs.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, one person will create a raw transaction message containing all
    inputs and outputs that everyone signs, and the final signed transaction is then
    published.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be understood from the following illustration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-11.51.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 11.51:** Planned group transaction'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding illustration, Alice, Bob, and Carol are buying a gift together
    for their teacher. Alice and Bob create a transaction of paying a merchant and
    give the transaction to Carol. Carol creates the final transaction using the transaction
    received from Alice and Bob and adds her contribution to the final transaction.
    Carol signs the final transaction before publishing it to the Bitcoin network.
    The following is the code for the transaction structure of Alice:'
  prefs: []
  type: TYPE_NORMAL
- en: '`def createTransactionStruct():`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn = {}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘version’] = 1`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘input_count’] = 1`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘inputs’] = []`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0 = {}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0[‘prevtxn’] = ‘5efcf04e32f061b9c4894f5b3a59fb3d8c5c56a6e7340b89b3a1a9ebacca998f’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0[‘prevtxnindex’] = 0`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0[‘script_type’] = ‘P2PKH’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0[‘privkeys’] = [‘KwfxnwxpPG1RmhU8jaU8Ron4m1KZGymLAFNaMnSTonoZ7AQfnV53’]`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0[‘script_pubkey’] = ‘76a91481d7033c19dcec645cb3f86ce41678756850ba4d88ac’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0[‘hash_type’] = SIGHASH_ANYONECANPAY|SIGHASH_ALL`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘inputs’].append(input0)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘out_count’] = 1`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘outputs’] = []`'
  prefs: []
  type: TYPE_NORMAL
- en: '`output0 = {}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`output0[‘satoshis’] = 14999990000`'
  prefs: []
  type: TYPE_NORMAL
- en: '`output0[‘script_type’] = ‘P2PKH’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`output0[‘address’] = ‘msV23rBcHAtQWSkWV9ph91DV65VduWi1Vt’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘outputs’].append(output0)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘locktime’] = 0`'
  prefs: []
  type: TYPE_NORMAL
- en: '`return txn`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Program 11.26:** Method to define transaction structure for Alice in planned
    group transaction'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alice creates the following transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-11.52.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 11.52:** Transaction hex code for Alice in planned group transaction'
  prefs: []
  type: TYPE_NORMAL
- en: 'We modify the following fields in the code for the transaction structure to
    make it for Bob:'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0[‘prevtxn’] = ‘7995c6e08aee1fb5ddb21c7b84ff949bdb2bd98183623606aa1732a61200c12f’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0[‘privkeys’] = [‘L26JcHRhqEQv8V9DaAmE4bdszwqXS7tHznGYJPp7fxEoEQxxBPcQ’]`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0[‘script_pubkey’] = ‘76a914db610ec1429ecb422044ee4ea92f11bc080fdb3d88ac’`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Program 11.34:** Updated field for Bob in method to define transaction structure
    in planned group transaction'
  prefs: []
  type: TYPE_NORMAL
- en: 'Bob creates the following transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-11.53.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 11.53:** Transaction hex code for Bob in planned group transaction'
  prefs: []
  type: TYPE_NORMAL
- en: 'Carol adds her own input and combines Alice’s and Bob’s transaction in the
    following transaction structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '`def createTransactionStruct():`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn = {}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘version’] = 1`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘input_count’] = 3`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘inputs’] = []`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0 = {}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0[‘input_txn’] = ‘01000000018f99caaceba9a1b3890b34e7a6565c8c3dfb593a5b4f89c4b961f0324ef0fc5e000000006a473044022073ecf25c06ffe90cb03951db885defb1a12aaf50f7b068a94dc6fa3f8dd69cf9022070f3b386c9ec95a24f475bb6b5add578591985320b4ab6424886612cd830b9c581210281238fc6d981efce6aa1b3ccb8556a1b115a40f8ab3315c003f415ceedc3defeffffffff01f0ae117e030000001976a9148343cfe3998d8a49bcfeea63dcbe12643a8e884788ac00000000’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input0[‘hash_type’] = SIGHASH_ANYONECANPAY|SIGHASH_ALL`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘inputs’].append(input0)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input1 = {}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input1[‘input_txn’] = ‘01000000012fc10012a63217aa0636628381d92bdb9b94ff847b1cb2ddb51fee8ae0c69579000000006a473044022002388c5d0d89d73697abead51ae87cb6d9421662ecb513d620e76b90118307ff02206fe1b65fb514bb1e47c279047fe226b9aedd7ced45902cb377bbb70d60e49fb58121037fadaea6edf196bf70af16cefb2bd3c830e54c0a6e9a00bf7806b241933547f7ffffffff01f0ae117e030000001976a9148343cfe3998d8a49bcfeea63dcbe12643a8e884788ac00000000’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input1[‘hash_type’] = SIGHASH_ANYONECANPAY|SIGHASH_ALL`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘inputs’].append(input1)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input2 = {}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input2[‘prevtxn’] = ‘c83e8dc76b2139f84235d38907291ebe2470786b2d5977302a63aff1c5d99649’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input2[‘prevtxnindex’] = 0`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input2[‘script_type’] = ‘P2PKH’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input2[‘privkeys’] = [‘KxR8HHyfAwFPidCw2vXThXqT4vSMNeufirHFapnfCfkzLaohtujG’]`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input2[‘script_pubkey’] = ‘76a9142004e0ff6a6f08115d048fd9af177fae702f681a88ac’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`input2[‘hash_type’] = SIGHASH_ALL`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘inputs’].append(input2)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘out_count’] = 1`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘outputs’] = []`'
  prefs: []
  type: TYPE_NORMAL
- en: '`output0 = {}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`output0[‘satoshis’] = 14999990000`'
  prefs: []
  type: TYPE_NORMAL
- en: '`output0[‘script_type’] = ‘P2PKH’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`output0[‘address’] = ‘msV23rBcHAtQWSkWV9ph91DV65VduWi1Vt’`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘outputs’].append(output0)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`txn[‘locktime’] = 0`'
  prefs: []
  type: TYPE_NORMAL
- en: '`return txn`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Program 11.27:** Method to define combined transaction structure in planned
    group transaction'
  prefs: []
  type: TYPE_NORMAL
- en: 'Carol creates the following transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-11.54.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 11.54:** Transaction hex code for Carol in planned group transaction'
  prefs: []
  type: TYPE_NORMAL
- en: 'And then she publishes the transaction as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-11.55.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 11.55:** Planned group transaction is published successfully'
  prefs: []
  type: TYPE_NORMAL
- en: With these collaborative transactions, you learnt how multiple individuals can
    collaborate to form a collated transaction.
  prefs: []
  type: TYPE_NORMAL
- en: '[Conclusion](toc.xhtml#s249a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learnt about the different ways in which we can use transaction
    and scripting. You also learnt how to timestamp a digital property and how to
    lock a transaction until a block height or time is reached. Further on in the
    chapter, you learnt how to ensure the security of payment, which can lead to building
    peer-to-peer exchange. Additionally, you learnt how to contribute to a transaction
    and collate contributed transactions into a final transaction.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, you will learn about an important softfork: segregated
    witness.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Points to remember](toc.xhtml#s250a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Digital asset or digital property is the digital representation of a property.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Digital property is unique and is linked to the owner’s Bitcoin address at any
    point.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Digital property can have marketable value and can be sold, auctioned, or mortgaged.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `**OP_RETURN**` opcode is used to store data in a transaction.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `**OP_RETURN**` opcode is non spendable and stays associated with the transaction
    only.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A transaction can be locked till the medium time past is less than the locktime
    or till block height is reached.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A transaction can also be locked based on relative locktime from funding transaction
    in terms of either block height or medium time past.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Relative locktime is a softfork and is used in a script.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Relative locktime modifies the method of evolution of the `**nSequence**` field.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Smart contract is a contract between two or more parties written in the form
    of an executable program.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bitcoin smart contract has certain limitations and cannot do everything that
    a few other smart contract platforms can do.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bitcoin smart contract provides enough flexibility to help overcome most of
    its limitations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Questions](toc.xhtml#s251a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Write a program to implement a collaborative use case in which Alice and Bob
    bet on their respective teams winning in a football match. If team A wins, Alice
    pays Bob 45 ![](images/Bitcoin.jpg). If team B wins, Bob pays Alice 45 ![](images/Bitcoin.jpg).
    Both lock 50 ![](images/Bitcoin.jpg) in a contract. To settle the bet, Carol takes
    his fees, which is 4.9999 ![](images/Bitcoin.jpg). The remaining 0.0001 ![](images/Bitcoin.jpg)
    are paid as fees to the network. Carol will provide the required condition to
    contract for transferring 95 ![](images/Bitcoin.jpg) to the winner, which is 45
    ![](images/Bitcoin.jpg) as winning amount and 50 ![](images/Bitcoin.jpg) as own
    money.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a program to implement peer-to-peer exchange involving escrow. The program
    needs to have 2-of-3-multisig with `**nLockTime**`. In the program, you need to
    implement the flow chart illustrated in *[figure 11.32](#fig11_32)*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a program to sell digital asset from one person to another such that the
    transfer of asset only happens if the receiver reveals the secret shared by the
    seller on the Bitcoin network. The following illustration describes the scenario:![](images/Figure-11.56.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Figure 11.56:** Scenario'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'True/False:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`OP_RETURN` opcode does not need a nValue. So, it does not cost anything to
    add them in a transaction.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Digital property is an asset that is owned by only one person at a time and
    can be transferred from one wallet address to another.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A condition in a contract that, once valid, cannot become invalid in the future.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Fill in the blanks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Medium time past is calculated by taking the median of the timestamps of the
    previous ________ blocks.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Sequence value must be ________ than or equal to `OP_CHECKSEQUENCEVERIFY` for
    a transaction to be valid.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: To collate multiple SIGHASH_SINGLE transactions into a single final transaction,
    each individual transaction needs to have outputs at the right ____________.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
