- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: '[Part II](contents.xhtml#rpart2)'
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[第二部分](contents.xhtml#rpart2)'
- en: '[Blockchain Overview](contents.xhtml#rpart2)'
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[区块链概述](contents.xhtml#rpart2)'
- en: </hgroup>
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: <hgroup>
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: '[4](contents.xhtml#rchapter4)'
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[第 4 章](contents.xhtml#rchapter4)'
- en: '[Python Basics](contents.xhtml#rchapter4)'
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[Python 基础知识](contents.xhtml#rchapter4)'
- en: </hgroup>
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '[4.1 Introduction](contents.xhtml#rsec4_1)'
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[4.1 简介](contents.xhtml#rsec4_1)'
- en: 'Python is a high-level programming language used for general-purpose programming,
    developed by Guido Van Rossum in 1991\. Python is specially designed to be highly
    readable as it uses frequent English keywords. Python is frequently used to create
    software and web applications on a server. Some of the important features of Python
    are described as follows:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Python 是一种用于通用编程的高级编程语言，由 Guido Van Rossum 在 1991 年开发。Python 特别设计为高度可读，因为它使用频繁的英语关键字。Python
    经常用于在服务器上创建软件和 Web 应用程序。Python 的一些重要特性如下：
- en: It supports concepts of object-oriented programming.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持面向对象编程的概念。
- en: It can be easily integrated with some other programming languages including
    C, C++, Java, Common Object Request Broker Architecture (CORBA), etc.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以很容易地与其他编程语言集成，包括 C、C++、Java、公共对象请求代理体系结构（CORBA）等。
- en: Python is scalable as it better supports large programs than shell scripting.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 是可伸缩的，因为它比 Shell 脚本更好地支持大型程序。
- en: Python relies highly on indentation, here whitespace is used to define scope.
    Due to its strong structuring constructs, it supports clear writing and logical
    application.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 高度依赖缩进，其中空格用于定义作用域。由于其强大的结构化构造，它支持清晰的编写和逻辑应用。
- en: Python can be easily connected to all major commercial databases.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 可以很容易地连接到所有主要的商业数据库。
- en: Python is portable as it runs on a wide variety of hardware platforms.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 是可移植的，因为它可以在多种硬件平台上运行。
- en: Python supports interactive mode which enables interactive testing and debugging
    of code.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 支持交互模式，可以进行代码的交互测试和调试。
- en: Python supports high-level dynamic data types and dynamic type checking.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 支持高级动态数据类型和动态类型检查。
- en: Python is a scripting language as it is suitable for embedding and for writing
    small unstructured scripts.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 是一种脚本语言，因为它适合嵌入和编写小型的非结构化脚本。
- en: 'Python programs are much shorter in length than equivalent C, C++ programs
    for the following reasons:'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 程序的长度比等效的 C、C++ 程序要短得多，原因如下：
- en: The complex operations can be expressed in a single statement with the support
    of high level data type in Python.
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复杂的操作可以在单个语句中用 Python 的高级数据类型来表达。
- en: Use of indentation rather than using beginning and ending brackets.
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用缩进而不是开始和结束括号。
- en: Declaration of variables and arguments is not important.
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量和参数的声明并不重要。
- en: '**Note:** Python is a compiled and interpreted programming language. The source
    code first gets compiled to a bytecode then that bytecode is interpreted as machine
    language on Python virtual machine to give actual output. The concept of bytecode
    achieves portability. However, to execute Python code, each time Python programs
    code is required.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意：** Python 是一种编译和解释的编程语言。源代码首先被编译成字节码，然后该字节码在 Python 虚拟机上解释为机器语言以生成实际输出。字节码的概念实现了可移植性。然而，要执行
    Python 代码，每次都需要 Python 程序代码。'
- en: After writing the program, save the program with .py in a text editor. Further,
    execute that file in Python interpreter. Nevertheless, typing commands in Python
    interpreter is a good way to play with Python features but it is not suggested
    for solving more complex problems.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 编写程序后，请在文本编辑器中将程序保存为 .py 文件。此外，将该文件在 Python 解释器中执行。然而，在 Python 解释器中键入命令是玩弄 Python
    特性的好方法，但不建议用于解决更复杂的问题。
- en: The rest of this chapter discusses various important features of Python language
    with examples starting with simple statements, expressions, data types to concepts
    of classes, objects, functions, file handling, etc. Let's start Python programming.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的其余部分讨论了 Python 语言的各种重要特性，从简单语句、表达式、数据类型到类、对象、函数、文件处理等概念的示例。让我们开始 Python 编程。
- en: '[4.2 Comments](contents.xhtml#rsec4_2)'
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[4.2 注释](contents.xhtml#rsec4_2)'
- en: Comments in Python are represented with a “#”. Everything written after “#”
    in a line is ignored. Notably, comments are not interpreted by Python language.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中的注释用“#”表示。在“#”之后的所有内容都将被忽略。值得注意的是，注释不会被 Python 语言解释。
- en: '![](../images/list4_1.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/list4_1.jpg)'
- en: 'Output: 5'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：5
- en: '[4.3 Multi-line Statement](contents.xhtml#rsec4_3)'
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[4.3 多行语句](contents.xhtml#rsec4_3)'
- en: 'To denote that line should continue, (multi-line statement) Python allows the
    use of line continuation character, i.e., Ḟor example:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了表示行应继续（多行语句），Python 允许使用行继续字符，即，例如：
- en: '![](../images/list4_2.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/list4_2.jpg)'
- en: '[4.4 Blocks and Indentation](contents.xhtml#rsec4_4)'
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[4.4 块和缩进](contents.xhtml#rsec4_4)'
- en: 'Python depicts blocks and nested blocks structure with indentation not by using
    beginning and end brackets. Advantages of using indentation include reducing need
    for coding standard, reducing inconsistency, and reducing work. The number of
    count spaces in indentation is variable but within a block each and every statement
    must be indented the equal amount. For example:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Python 用缩进而不是使用起始和结束括号来表示块和嵌套块结构。使用缩进的优点包括减少编码标准的需求，减少不一致性，并减少工作量。缩进的空格数是可变的，但在一个块内，每个语句都必须缩进相同的数量。例如：
- en: '![](../images/list4_3.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/list4_3.jpg)'
- en: 'The following code will generate an error:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将生成一个错误：
- en: '![](../images/list4_4.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/list4_4.jpg)'
- en: '[4.5 Creating Variables and Assigning Values](contents.xhtml#rsec4_5)'
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[4.5 创建变量并赋值](contents.xhtml#rsec4_5)'
- en: Variables are used to store values at a reserved memory location. After creating
    a variable, a space in memory is reserved. Unlike other programming languages,
    there is no need to declare variables explicitly. After assigning a value to a
    variable, use that variable in place of value. The equal sign is used to assign
    value to a variable. Python strings are expressed in single quotes or double quotes
    with same results. Print statement is used to display the value of a variable.
    For example, the statements
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 变量用来在保留的内存位置存储值。创建变量后，将保留内存中的空间。与其他编程语言不同，不需要显式声明变量。将值赋给变量后，使用该变量代替值。等号用于将值赋给变量。Python字符串用单引号或双引号表示，结果相同。打印语句用于显示变量的值。例如，以下语句
- en: '![](../images/list4_5.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/list4_5.jpg)'
- en: 'Output: 100'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：100
- en: hello
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你好
- en: h
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: h
- en: Variables can have a variable length and they can be arbitrarily long. A variable
    can have both letters and numbers, however, they can't start with a number.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 变量的长度可以变化，并且可以任意长。变量可以包含字母和数字，但不能以数字开头。
- en: '[4.6 Data Types](contents.xhtml#rsec4_6)'
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[4.6 数据类型](contents.xhtml#rsec4_6)'
- en: 'Variables can store data in different types. Numbers, strings, lists, tuple,
    dictionaries are the standard data types. Python number data types store numeric
    value. For example:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 变量可以存储不同类型的数据。数字、字符串、列表、元组、字典是标准数据类型。Python数字数据类型存储数值。例如：
- en: a=1, b=2.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: a=1, b=2.
- en: 'Python includes three different numeric types, i.e., int, float, complex. In
    contrast, a string is made of a sequence of characters. However, strings in Python
    are immutable, which implies it can''t be changed. Strings are declared with single
    or double character. For example: a=”abc”. Rest of the data types are discussed
    further in this chapter. type() function is used to get the data type of any variable.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Python包括三种不同的数值类型，即int、float、complex。相比之下，字符串由一系列字符组成。但是，Python中的字符串是不可变的，这意味着它不能被改变。字符串用单引号或双引号声明。例如：a=”abc”。本章将进一步讨论其余的数据类型。type()函数用于获取任何变量的数据类型。
- en: '![](../images/list4_6.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/list4_6.jpg)'
- en: 'Output: str'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：str
- en: int
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 整数
- en: float
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点
- en: list
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 列表
- en: '[4.7 Operators](contents.xhtml#rsec4_7)'
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[4.7 运算符](contents.xhtml#rsec4_7)'
- en: 'Similar to other programming languages, Python supports the following operator
    groups:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于其他编程语言，Python支持以下运算符组：
- en: Arithmetic operator
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算术运算符
- en: Comparison operator
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较运算符
- en: Assignment operator
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 赋值运算符
- en: Logical operator
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逻辑运算符
- en: Bitwise operator
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位运算符
- en: Membership operator
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成员运算符
- en: Identity operator
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 身份运算符
- en: '[4.7.1 Arithmetic operator](contents.xhtml#rsec4_7_1)'
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[4.7.1 算术运算符](contents.xhtml#rsec4_7_1)'
- en: 'This category includes mathematical operations, such as- addition(+), subtraction(-),
    division(/), modulus(%), and power(**). For example:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 此类别包括数学运算，如- 加法(+), 减法(-), 除法(/), 取模(%), 幂(**)。例如：
- en: '![](../images/list4_7.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/list4_7.jpg)'
- en: 'Output:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '14'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '14'
- en: '6'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '6'
- en: '40'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '40'
- en: '2.5'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '2.5'
- en: '2'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: '10000'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '10000'
- en: '[4.7.2 Comparison operator](contents.xhtml#rsec4_7_2)'
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[4.7.2 比较运算符](contents.xhtml#rsec4_7_2)'
- en: 'This operator is used to compare values and returns either true or false as
    per the condition. This category includes greater than(>), less than(<), equal
    to(==), not equal to(!=), greater than equal to(≥), and less than equal to(≤).
    For example:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 此运算符用于比较值，并根据条件返回真或假。此类别包括大于(>)、小于(<)、等于(==)、不等于(!=)、大于等于(≥)和小于等于(≤)。例如：
- en: '![](../images/list4_8.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/list4_8.jpg)'
- en: 'Output:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: a is not equal to b
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: a 不等于 b
- en: a is not equal to b
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: a 不等于 b
- en: a is not less than b
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: a 不小于 b
- en: a is greater than b
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: a 大于 b
- en: a is neither less than nor equal to b
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: a 既不小于也不等于 b
- en: b is neither greater than nor equal to b
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: b 既不大于也不等于 b
- en: '[4.7.3 Logical operator](contents.xhtml#rsec4_7_3)'
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[4.7.3 逻辑运算符](contents.xhtml#rsec4_7_3)'
- en: 'This category performs logical AND (and), logical OR(or), and logical NOT (not).
    For example:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 此类别执行逻辑 AND (and)、逻辑 OR (or) 和逻辑 NOT (not)。例如：
- en: '![](../images/list4_9.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/list4_9.jpg)'
- en: 'Output:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: 'False'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 假
- en: 'True'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 真
- en: 'False'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 假
- en: '[4.7.4 Python Bitwise operator](contents.xhtml#rsec4_7_4)'
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[4.7.4 Python 位运算符](contents.xhtml#rsec4_7_4)'
- en: It performs bit-by-bit operation. Bitwise operator includes Bitwise AND(&),
    Bitwise OR(∨), Bitwise NOT(¬), Bitwise XOR(⊕), Bitwise right shift(≫), and Bitwise
    left shift (≪).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 它执行按位操作。位运算符包括按位与(&)，按位或(∨)，按位非(¬)，按位异或(⊕)，按位右移(≫)和按位左移(≪)。
- en: '![](../images/list4_10.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/list4_10.jpg)'
- en: 'Output:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '0'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '14'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '14'
- en: −11
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: −11
- en: '14'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '14'
- en: '2'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: '40'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '40'
- en: '[4.7.5 Assignment operator](contents.xhtml#rsec4_7_5)'
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[4.7.5 赋值运算符](contents.xhtml#rsec4_7_5)'
- en: 'This operator is used to assign values to a variables. The available assignment
    operators are:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 此运算符用于将值分配给变量。可用的赋值运算符包括：
- en: '=: Assigns values from right side of operands to left side of operand'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '=: 将右侧操作数的值赋给左侧操作数'
- en: '+=: Adds the right operand with the left operand and assigns result to the
    left operand'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '+=: 将右操作数加到左操作数并将结果赋给左操作数'
- en: '-=: Subtracts the right operand from left operand and then assigns to the left
    operand'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '-=: 将右操作数从左操作数中减去，然后将结果赋给左操作数'
- en: '*=: Multiplies the right operand with the left operand and assigns to the left
    operand'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*=: 将右操作数乘以左操作数并赋给左操作数'
- en: :̄ Divides the left operand with right operand and then assigns the result to
    the left operand
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: :̄ 将左操作数除以右操作数，然后将结果赋给左操作数
- en: '%=: Takes modulus using left and right operands and assigns the result to the
    left operand'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '%=: 使用左右操作数取模，并将结果赋给左操作数'
- en: '**=: Performs exponential calculation on operators and assigns the value to
    the left operand'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**=: 对运算符执行指数运算，并将值赋给左操作数'
- en: '![](../images/list4_11a.jpg)![](../images/list4_11b.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/list4_11a.jpg)![](../images/list4_11b.jpg)'
- en: 'Output:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: Value of var3 is 31
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: var3 的值为 31
- en: Value of var3 is 52
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: var3 的值为 52
- en: Value of var3 is 1092
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: var3 的值为 1092
- en: Value of var3 is 52
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: var3 的值为 52
- en: Value of var3 is 2
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: var3 的值为 2
- en: Value of var3 is 2097152
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: var3 的值为 2097152
- en: '[4.7.6 Membership operator](contents.xhtml#rsec4_7_6)'
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[4.7.6 成员运算符](contents.xhtml#rsec4_7_6)'
- en: 'This operator is used to check for membership of an element in a sequence.
    There are two membership operators discussed below:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '-   这个运算符用于检查序列中元素的成员资格。下面讨论了两个成员运算符：'
- en: 'in: Results to true if element is present in the sequence otherwise false'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '-   in：如果元素存在于序列中，则结果为真，否则为假'
- en: 'not in: Results to true if element is not a member of the sequence, otherwise
    false'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '-   not in：如果元素不是序列的成员，则结果为真，否则为假。'
- en: 'For example:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '-   例如：'
- en: '![](../images/list4_12.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '-   ![](../images/list4_12.jpg)'
- en: 'Output:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '-   '
- en: a is not present in the given list
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '-   a 不在给定的列表中'
- en: b is not present in the given list
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '-   b 不在给定的列表中'
- en: '[4.7.7 Identity Operators](contents.xhtml#rsec4_7_7)'
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '-   [4.7.7 身份运算符](contents.xhtml#rsec4_7_7)'
- en: These operators are used to compare two memory locations, i.e., to check whether
    two values are located in same part of memory. There are two identical operators
    in Python.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '-   这些运算符用于比较两个内存位置，即检查两个值是否位于内存的同一部分。Python 中有两个相同的运算符。'
- en: 'is: Returns true if operands are identical'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '-   is：如果操作数相同，则返回真'
- en: 'is not: Returns true if operands are not identical'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '-   is not：如果操作数不相同，则返回真'
- en: '![](../images/list4_13.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '-   ![](../images/list4_13.jpg)'
- en: 'Output:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '-   输出：'
- en: a and b have same identity
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '-   a 和 b 有相同的标识'
- en: '[4.8 Input and Output in Python](contents.xhtml#rsec4_8)'
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '-   [4.8 Python 中的输入和输出](contents.xhtml#rsec4_8)'
- en: The built-in input() function is used to take user input from the keyboard.
    The parameters inside parentheses prompt for the keyboard input. The input function
    automatically identifies whether it is a string, number, or list that is entered
    by the user. However when an input is entered, first it is converted to a string.
    Even an integer value is converted integer using typecasting.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '-   内置的 input() 函数用于从键盘接受用户输入。括号内的参数提示键盘输入。input() 函数会自动识别用户输入的是字符串、数字还是列表。然而，当输入被输入时，首先将其转换为字符串。即使输入整数值，也会使用类型转换将其转换为整数。'
- en: '![](../images/list4_14.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '-   ![](../images/list4_14.jpg)'
- en: Suppose the user has entered abc as name.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '-   假设用户输入了 abc 作为名称。'
- en: 'Output: Hello abc'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '-   输出：Hello abc'
- en: The way to produce output is by using print() function by passing no or more
    expression separated by a comma. Print with no parameters, i.e., print() is to
    advance to next line. By default, Python print() function ends with a new line,
    i.e., print() function will go to next line automatically.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '-   生成输出的方式是使用 print() 函数，通过逗号分隔的零个或多个表达式。不带参数的 print()，即 print() 是为了换行。默认情况下，Python
    的 print() 函数以新行结束，即 print() 函数会自动进入下一行。'
- en: '![](../images/list4_15.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '-   ![](../images/list4_15.jpg)'
- en: 'Output:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '-   输出：'
- en: one
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '-   one'
- en: two
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '-   two'
- en: '[4.9 List](contents.xhtml#rsec4_9)'
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '-   [4.9 列表](contents.xhtml#rsec4_9)'
- en: Lists are a powerful feature of Python. They are the same as arrays. The list
    is a data type used to declare a sequence. Lists are declared with comma separated
    items in a square brackets. To access list items, index number is used. Notably,
    list might have items of different types. A list can have strings, integers, as
    well as objects. Also, lists can be altered even after declaration.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 列表是 Python 的一个强大特性。它们与数组相同。列表是用于声明序列的数据类型。列表用方括号内的逗号分隔的项目声明。要访问列表项，使用索引号。值得注意的是，列表可能包含不同类型的项目。列表可以包含字符串、整数以及对象。此外，列表在声明后也可以更改。
- en: '![](../images/list4_16.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/list4_16.jpg)'
- en: 'Output: Banana'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：香蕉
- en: '![](../images/list4_17.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/list4_17.jpg)'
- en: 'Output:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: 22, ‘Banana’, 5, 6
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 22、'香蕉'、5、6
- en: 22, ‘Banana’, 5
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 22、'香蕉'、5
- en: '5'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: '**Note:** Tuple is same as list with a difference that tuples are immutable,
    i.e., after declaration they can''t be changed.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意：** 元组与列表相同，唯一的区别在于元组是不可变的，即，在声明后它们不能被更改。'
- en: '[4.10 Dictionary](contents.xhtml#rsec4_10)'
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[4.10 字典](contents.xhtml#rsec4_10)'
- en: Python dictionaries has keys and values and is written with curly brackets.
    However, keys should be unique within a dictionary while values can be same. To
    access any item, use keys name inside square brackets.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Python 字典具有键和值，并用大括号编写。然而，字典中的键应该是唯一的，而值可以相同。要访问任何项，请在方括号内使用键名。
- en: '![](../images/list4_18.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/list4_18.jpg)'
- en: 'Output: 10'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：10
- en: '[4.11 Python Conditions and if-else](contents.xhtml#rsec4_11)'
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[4.11 Python 条件和 if-else](contents.xhtml#rsec4_11)'
- en: Python if-else statements are used with logical conditions, such as- equal,
    not equal, less than equal to, greater than equal to, greater than, and less than.
    If statement is specified using the if keyword.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的 if-else 语句与逻辑条件一起使用，如等于、不等于、小于等于、大于等于、大于和小于。如果语句使用 if 关键字指定。
- en: '![](../images/list4_19.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/list4_19.jpg)'
- en: 'Output: value of b is greater than a'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：b 的值大于 a
- en: '**Key point** Python uses indentation to define scope'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '**重点** Python 使用缩进来定义作用域'
- en: Further, elif keyword is used to check if previous condition is not true then
    try with this condition and else executes if any of the preceding conditions get
    false. greater than equal to, greater than, and less than. Elif statement is specified
    using elif keyword.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，elif 关键字用于检查前一个条件是否不成立，然后尝试此条件，如果任何前面的条件为假，则执行 else。大于等于、大于和小于。Elif 语句使用
    elif 关键字指定。
- en: '![](../images/list4_20.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/list4_20.jpg)'
- en: 'Output: value of b is greater than a'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：b 的值大于 a
- en: '[4.12 Loops](contents.xhtml#rsec4_12)'
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[4.12 循环](contents.xhtml#rsec4_12)'
- en: 'Generally, statements of any programming language are executed sequentially.
    However, there may be a situation when there is need to execute different paths.
    A block of loop allows to execute one or more than one statement multiple times.
    Python supports two loop commands:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，任何编程语言的语句都是按顺序执行的。但是，可能存在需要执行不同路径的情况。循环块允许多次执行一个或多个语句。Python 支持两个循环命令：
- en: While loop
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: While 循环
- en: For loop
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: For 循环
- en: '**While loop**: While loop is used to execute a statement or a block of statement
    until given conditions are satisfied. After the statements get false, the very
    first statement after while gets executed.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**While 循环**：While 循环用于执行语句或语句块，直到满足给定条件。在语句变为 false 后，while 之后的第一条语句将被执行。'
- en: '![](../images/list4_21.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/list4_21.jpg)'
- en: 'Output:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '0'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '1'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '2'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: '3'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: '4'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: Goodbye
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 再见
- en: While can be used with else statement as well
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: While 也可以与 else 语句一起使用
- en: '![](../images/list4_22.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/list4_22.jpg)'
- en: 'Output:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '0'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '1'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '2'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: '3'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: '4'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: Goodbye
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 再见
- en: '**For loop**: In Python the for loop is used for sequential traversal, e.g.,
    a list or an array.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**For 循环**：在 Python 中，for 循环用于顺序遍历，例如，列表或数组。'
- en: '![](../images/list4_23.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/list4_23.jpg)'
- en: 'Output:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: apple
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果
- en: mango
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 芒果
- en: banana
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 香蕉
- en: '![](../images/list4_24.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/list4_24.jpg)'
- en: 'Output:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: 0,1,2,3,4
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 0,1,2,3,4
- en: '[4.13 Functions in Python](contents.xhtml#rsec4_13)'
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[4.13 Python 中的函数](contents.xhtml#rsec4_13)'
- en: A function is a block of statements that take some input, perform some computation,
    and produces output. Basically, functions are used to ease repeatedly done tasks
    together. Functions are executed when called. There are some build-in functions
    in Python such as- print() and also one can create functions using def keyword.
    To call a function, use the name of that function followed by a parenthesis.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是一组语句块，接受一些输入，执行一些计算，并产生输出。基本上，函数用于将重复执行的任务组合在一起。函数在调用时执行。Python 中有一些内置函数，例如-
    print()，也可以使用 def 关键字创建函数。要调用函数，请使用该函数的名称，后跟括号。
- en: '![](../images/list4_25.jpg)![](../images/list4_26.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/list4_25.jpg)![](../images/list4_26.jpg)'
- en: 'Output:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: Odd
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 奇数
- en: Even
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 偶数
- en: '[4.14 Classes and Objects in Python](contents.xhtml#rsec4_14)'
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[4.14 Python 中的类和对象](contents.xhtml#rsec4_14)'
- en: As previously discussed, Python is an object-oriented language. A class is similar
    to an object constructor or like a blueprint for creating objects while object
    is a copy of class with actual values. Classes ease bundling of data and functionality
    together. Each class holds its own data members and member function which can
    be accessed using objects. Nevertheless, a class can have many objects. Attributes
    of a class are always public and are accessed using the dot (.) operator. To create
    a class keyword class is used.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面讨论的，Python 是一种面向对象的语言。类似于对象构造函数或创建对象的蓝图的类，而对象是带有实际值的类的副本。类易于将数据和功能捆绑在一起。每个类都保存其自己的数据成员和成员函数，可以使用对象访问。尽管如此，一个类可以有许多对象。类的属性始终是公共的，并且可以使用点
    (.) 运算符访问。要创建一个类，使用关键字 class。
- en: '![](../images/list4_27.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/list4_27.jpg)'
- en: 'output: 5'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：5
- en: '![](../images/list4_28a.jpg)![](../images/list4_28b.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/list4_28a.jpg)![](../images/list4_28b.jpg)'
- en: 'Output:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: animal
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 动物
- en: I am a animal
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我是一个动物
- en: I am a dog
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我是一只狗
- en: To create real-life applications, we need to understand a special function called
    init() which is an initialization method to create a new instance of the class.
    In particular, the init() method is used to assign values to object properties
    when the object is created.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建现实生活中的应用程序，我们需要了解一个特殊的函数，称为 `init()`，它是创建类的新实例的初始化方法。特别是，当对象被创建时，`init()`
    方法用于为对象属性赋值。
- en: '![](../images/list4_29.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/list4_29.jpg)'
- en: 'output:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: John
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 约翰
- en: '36'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '36'
- en: '[4.15 File Handling in Python](contents.xhtml#rsec4_15)'
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[Python 中的文件处理](contents.xhtml#rsec4_15)'
- en: A file has a location on disk with some stored information. Like Java and C++,
    Python also supports file handling and enables users to handle files by reading
    and writing them. Each line of code in the file includes a sequence of characters.
    Also, each line ends with a special terminator called end of line (EOL) which
    tells the interpreter that a new line has begun. Most of the file manipulations
    are done using a file object.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 文件在磁盘上有一个位置，并带有一些存储的信息。与 Java 和 C++ 一样，Python 也支持文件处理，并允许用户通过读取和写入来处理文件。文件中的每行代码都包含一系列字符。此外，每行都以特殊的终止符号结尾，称为行结束符（EOL），告诉解释器新的一行已经开始。大多数文件操作都使用文件对象完成。
- en: '[4.15.1 open() function](contents.xhtml#rsec4_15_1)'
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[4.15.1 open() 函数](contents.xhtml#rsec4_15_1)'
- en: 'Clearly before reading or writing a file, one must open it first. To open a
    file in order to read or write, open() function is used. The open() function creates
    a file object and takes two arguments, i.e., file name and mode. Syntax:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，在读取或写入文件之前，必须首先打开它。要打开文件以进行读取或写入，使用 `open()` 函数。`open()` 函数创建一个文件对象，并接受两个参数，即文件名和模式。语法：
- en: '*open(filename; mode)*'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '*open(filename; mode)*'
- en: 'mode field tells how the file can be opened. For example:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`mode` 字段指示文件如何被打开。例如：'
- en: 'r: Opens a file for reading only'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: r：只读方式打开文件
- en: 'rb: Opens a file for read-only purpose in binary format'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: rb：以二进制格式仅用于读取的方式打开文件
- en: 'w: opens a file for writing only'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: w：只写方式打开文件
- en: 'r+: Opens a file for both reading and writing in binary format'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: r+：以二进制格式同时用于读取和写入的方式打开文件
- en: 'wb: Opens a file for write only purpose in binary format'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: wb：以二进制格式仅用于写入的方式打开文件
- en: 'a: Opens file for append'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: a：以追加的方式打开文件
- en: 'a+: Opens a file for both appending and reading'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: a+：以追加和读取的方式打开文件
- en: If the file with specified name does not exist, it will throw an error of FileNotFoundError.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果指定名称的文件不存在，则会引发 FileNotFoundError 错误。
- en: '[4.15.2 close() function](contents.xhtml#rsec4_15_2)'
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[4.15.2 close() 函数](contents.xhtml#rsec4_15_2)'
- en: close() method closes the file object and refrains any further action on that
    file.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`close()` 方法关闭文件对象，并阻止对该文件的进一步操作。'
- en: 'Syntax:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 语法：
- en: fileObject.close()
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`fileObject.close()`'
- en: '![](../images/list4_30.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/list4_30.jpg)'
- en: 'output:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: 'Name of the file: foo.txt'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 文件名称：foo.txt
- en: '[4.15.3 read() function](contents.xhtml#rsec4_15_3)'
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[4.15.3 read() 函数](contents.xhtml#rsec4_15_3)'
- en: This function reads a string from an open file.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数从打开的文件中读取一个字符串。
- en: 'Syntax:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 语法：
- en: '*fileObject:read([count])*'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '*fileObject:read([count])*'
- en: The count parameter specifies the number of bytes to be read from the specified
    file. If the count parameter is missing, the file is read until the end of the
    file.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 计数参数指定从指定文件中读取的字节数。 如果缺少计数参数，则文件将读取直到文件的末尾。
- en: '![](../images/list4_31.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/list4_31.jpg)'
- en: 'output:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: The first 10 characters from the file named foo.txt.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 来自名为 foo.txt 的文件的前 10 个字符。
- en: '[4.16 write() function](contents.xhtml#rsec4_16)'
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[4.16 write() 函数](contents.xhtml#rsec4_16)'
- en: This function allows user to write strings to an open file. Notably, write function
    does not add implicitly a newline character, i.e., to end of string.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数允许用户将字符串写入打开的文件。 值得注意的是，write函数不会隐式添加换行符，即字符串的末尾。
- en: 'Syntax:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 语法：
- en: '*fileObject:write(string)*'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '*fileObject:write(string)*'
- en: '![](../images/list4_32.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/list4_32.jpg)'
- en: 'output:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: Python is a high level language
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: Python 是一种高级语言
- en: Python follows OOPS concepts
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: Python遵循OOPS概念
- en: Activity
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动
- en: Multiple Choice Questions
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多项选择题
- en: How do you insert comments in Python code?
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何在Python代码中插入注释？
- en: \ *This is a comment* \
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: \ *这是一个注释* \
- en: '#This is a comment'
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: ＃这是一个注释
- en: “This is a comment”
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: “这是一个注释”
- en: None of these
  id: totrans-259
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些都不是
- en: Which one is NOT a legal variable name?
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个不是合法的变量名？
- en: abc
  id: totrans-261
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: abc
- en: 10abc
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 10abc
- en: _abc
  id: totrans-263
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: _abc
- en: abc_abc
  id: totrans-264
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: abc_abc
- en: What is the value of the following Python Expression?
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下Python表达式的值是多少？
- en: '9.0'
  id: totrans-266
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '9.0'
- en: '9'
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '9'
- en: '4.0'
  id: totrans-268
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '4.0'
- en: '4'
  id: totrans-269
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '4'
- en: What is the output of the following code?
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码的输出是什么？
- en: x = 100
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: x = 100
- en: y = 50
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: y = 50
- en: print(x and y)
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 打印（x 和 y）
- en: 'True'
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真
- en: 'False'
  id: totrans-275
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假
- en: '100'
  id: totrans-276
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '100'
- en: '50'
  id: totrans-277
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '50'
- en: What is a correct syntax to output “hello world” in Python?
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是在Python中输出“hello world”的正确语法？
- en: print(“hello world”)
  id: totrans-279
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: print(“hello world”)
- en: echo(“hello word”)
  id: totrans-280
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: echo(“hello word”)
- en: put(“hello word”)
  id: totrans-281
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: put(“hello word”)
- en: None of these
  id: totrans-282
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些都不是
- en: What is the correct file extension for Python files?
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Python文件的正确文件扩展名是什么？
- en: .py
  id: totrans-284
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: .py
- en: .python
  id: totrans-285
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: .python
- en: .pyt
  id: totrans-286
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: .pyt
- en: None of these
  id: totrans-287
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些都不是
- en: What will be the output of the following code ?
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码的输出是什么？
- en: print type(type(int))
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 打印类型（类型（int））
- en: type ‘int’
  id: totrans-290
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类型‘int’
- en: type ‘type’
  id: totrans-291
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类型‘类型’
- en: error
  id: totrans-292
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误
- en: '0'
  id: totrans-293
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '0'
- en: Suppose listA is [31, 41, 5, 20, 5, 125, 1, 3], what is list1 after listA.pop(1)?
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设 listA 是 [31, 41, 5, 20, 5, 125, 1, 3]，那么 list1.pop(1) 后 list1 的值是什么？
- en: 31, 41, 5, 20, 5, 125, 1, 3
  id: totrans-295
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 31, 41, 5, 20, 5, 125, 1, 3
- en: 31, 41, 5, 20, 5, 125, 1
  id: totrans-296
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 31, 41, 5, 20, 5, 125, 1
- en: 31, 41, 5, 20, 5, 125, 1, 3, 3
  id: totrans-297
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 31, 41, 5, 20, 5, 125, 1, 3, 3
- en: None of these
  id: totrans-298
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些都不是
- en: What is the output of the following program?
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下程序的输出是什么？
- en: j = 0
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: j = 0
- en: 'while i ≤ 5:'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: while i ≤ 5：
- en: print j
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: print j
- en: j++
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: j++
- en: print j+1
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 打印 j+1
- en: 0 2 1 3 2 4
  id: totrans-305
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 0 2 1 3 2 4
- en: Error
  id: totrans-306
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误
- en: 5 4 3 2 1
  id: totrans-307
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 5 4 3 2 1
- en: None of these
  id: totrans-308
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些都不是
- en: What does <math alttext="" display="inline"><mo>¬</mo><mo>¬</mo><mo>¬</mo><mo>¬</mo><mo>¬</mo><mo>¬</mo></math>
    5 evaluate to?
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <math alttext="" display="inline"><mo>¬</mo><mo>¬</mo><mo>¬</mo><mo>¬</mo><mo>¬</mo><mo>¬</mo></math>
    5 的值是多少？
- en: '+5'
  id: totrans-310
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '+5'
- en: '-5'
  id: totrans-311
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '-5'
- en: '10'
  id: totrans-312
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '10'
- en: '11'
  id: totrans-313
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '11'
- en: 1\. b  2\. b  3\. a  4\. d  5\. d  6\. a  7\. b  8\. b  9\. b (there is no ++
    operator in Python)  10\. a
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. b  2\. b  3\. a  4\. d  5\. d  6\. a  7\. b  8\. b  9\. b（Python 中没有 ++
    运算符）  10\. a
- en: <hgroup>
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: '[5](contents.xhtml#rchapter5)'
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[5](contents.xhtml#rchapter5)'
- en: '[Cryptography Primitives](contents.xhtml#rchapter5)'
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[密码学原理](contents.xhtml#rchapter5)'
- en: </hgroup>
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '[5.1 Introduction](contents.xhtml#rsec5_1)'
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[5.1 介绍](contents.xhtml#rsec5_1)'
- en: Confidentiality, integrity, availability also referred to as CIA triad, is the
    model developed to define policies for achieving information security (Refer [Fig.
    5.1](07chap_05.xhtml#fig5_1)). Along with this non-repudiation and authentication
    are the other security attributes to be achieved by a Peer-to-peer (P2P) network.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 保密性、完整性、可用性也被称为CIA三元模型，是用于定义实现信息安全政策的模型（参见[图5.1](07chap_05.xhtml#fig5_1)）。除此之外，不可否认和身份验证是P2P网络需要实现的其他安全属性。
- en: 'Confidentiality: Confidentiality signifies that information, data, and resources
    are protected from any unauthorized parties. Data encryption, and passwords are
    the common method of ensuring confidentiality.tcolorbox'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保密性：保密性表示信息、数据和资源受到未经授权的各方的保护。数据加密和密码是确保保密性的常见方法。tcolorbox
- en: '**Key Points** Confidentiality is similar to the word privacy; however, they
    are not interchangeable. In fact, confidentiality is an extension of privacy that
    pertains to identifiable data.'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**要点** 保密性类似于隐私一词；但它们不能互换使用。事实上，保密性是隐私的延伸，涉及可识别数据。'
- en: 'Integrity: This attribute signifies the protection of information from unauthorized
    alteration. Integrity ensures accuracy and completeness of data. Access control
    mechanism, checksum, and hashing are some measures to ensure the integrity of
    data.'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完整性：此属性表示保护信息免受未经授权的更改。完整性确保数据的准确性和完整性。访问控制机制、校验和和哈希是确保数据完整性的一些措施。
- en: 'Availability: This attribute ensures access to information when needed by authorized
    parties. If a server/system remains available preventing service disruption and
    uninterrupted access, this signifies high availability. Disruption of service
    even for a short time can cause loss of revenue, customer disappointment, and
    organization repudiation damage. Among all availability attacks, DoS is the most
    frequently used by hackers. Proxy servers, firewalls, and routers are the countermeasures
    to ensure the availability of data.'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用性：此属性确保授权方在需要时能够访问信息。如果服务器/系统保持可用状态，防止服务中断并保持不间断访问，这表示高可用性。即使短时间的服务中断也可能导致收入损失、客户失望和组织声誉受损。在所有可用性攻击中，DoS是黑客最常使用的攻击方式。代理服务器、防火墙和路由器是确保数据可用性的对策。
- en: 'Non-repudiation: This attribute ensures that the sender of the data can''t
    later deny having sent the data and recipients can''t deny having received the
    data. In legal terms, repudiation signifies denial of something that is true.
    Digital signatures, timestamps, hash functions are some of the ways to obtain
    non-repudiation.'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可否认性：此属性确保数据的发送者不能否认后来发送了数据，接收者也不能否认收到了数据。在法律术语中，否认意味着否认某事是真实的。数字签名、时间戳、哈希函数是获得不可否认性的一些方法。
- en: 'Authentication: It is an act of identifying an individual. However, authentication
    does not claim about the access rights of the individual. In particular, authentication
    confirms the user''s identity.'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证：这是识别个人的行为。然而，认证并不涉及个人的访问权限。特别是，认证确认用户的身份。
- en: '![Figure 5.1](../images/fig5_1.jpg)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: '![图5.1](../images/fig5_1.jpg)'
- en: '**FIGURE 5.1**'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '**图5.1**'
- en: CIA triad of information security.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 信息安全的CIA三元素。
- en: Notably, cryptography plays a very important role in ensuring the attainment
    of these above-mentioned security attributes. Next, we will discuss the basic
    cryptographic primitives. We will start by discussing the details of cryptographic
    hash functions followed by discussing the concept of digital signatures.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，密码学在确保上述安全属性的实现中发挥着非常重要的作用。接下来，我们将讨论基本的密码原语。我们将首先讨论密码散列函数的细节，然后讨论数字签名的概念。
- en: '[5.2 Encryption/Decryption Process](contents.xhtml#rsec5_2)'
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[5.2 加密/解密过程](contents.xhtml#rsec5_2)'
- en: '[5.2.1 Encryption](contents.xhtml#rsec5_2_1)'
  id: totrans-332
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[5.2.1 加密](contents.xhtml#rsec5_2_1)'
- en: Encryption is the process of transforming original data into an unrecognisable
    form. Data is usually encrypted to save it from stealing. Encryption is performed
    by the sender.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 加密是将原始数据转换为不可识别形式的过程。数据通常是加密的，以免被窃取。加密由发送方执行。
- en: '[5.2.2 Decryption](contents.xhtml#rsec5_2_2)'
  id: totrans-334
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[5.2.2 解密](contents.xhtml#rsec5_2_2)'
- en: In contrast to encryption, decryption is the process of converting cipher text
    back to plain text. Decryption is done at the receiving side.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 与加密相反，解密是将密文转换回明文的过程。解密在接收方执行。
- en: '[5.2.3 Symmetric key encryption](contents.xhtml#rsec5_2_3)'
  id: totrans-336
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[5.2.3 对称密钥加密](contents.xhtml#rsec5_2_3)'
- en: This type of encryption uses the same cryptographic key for both encrypting
    plaintext and decrypting ciphertext.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的加密使用相同的密码密钥来加密明文和解密密文。
- en: '[5.2.4 Asymmetric key encryption](contents.xhtml#rsec5_2_4)'
  id: totrans-338
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[5.2.4 非对称密钥加密](contents.xhtml#rsec5_2_4)'
- en: This encryption process involves 2 pairs of keys. Here, both sender and receiver
    have a pair of public and private keys. The public key is used to encrypt plaintext
    whereas the private key is used for decryption purpose. To accomplish many cryptographic
    tasks public and private keys are used.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 此加密过程涉及2对密钥。在这里，发送方和接收方都有一对公钥和私钥。公钥用于加密明文，而私钥用于解密目的。为了完成许多密码任务，使用公钥和私钥。
- en: '[5.2.5 Public key](contents.xhtml#rsec5_2_5)'
  id: totrans-340
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[5.2.5 公钥](contents.xhtml#rsec5_2_5)'
- en: 'The public key is published for all other users to see. Public keys are generated
    using typical asymmetric algorithm to match them against the associated private
    key. The most popular algorithm used for creating public key are: RSA, ECC, and
    digital signature application (DSA). These mentioned algorithms are based on a
    heavy computation method to create random numeric combinations of different lengths
    to prevent them against brute force attack. The length of the key depicts strength
    of protection. The large key size assures more cryptographic security to prevent
    hackers from preventing them.'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 公钥是为所有其他用户公开的。公钥使用典型的非对称算法生成，以便与关联的私钥匹配。用于创建公钥的最流行算法有：RSA、ECC 和数字签名应用（DSA）。这些提到的算法基于重型计算方法，以创建不同长度的随机数字组合，以防止暴力破解攻击。密钥的长度决定了保护的强度。较大的密钥尺寸能够提供更多的密码安全，以防止黑客阻止它们。
- en: '[5.2.6 Private key](contents.xhtml#rsec5_2_6)'
  id: totrans-342
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[5.2.6 私钥](contents.xhtml#rsec5_2_6)'
- en: In contrast to public key, private key is a secret key that is only known to
    the owner of the key. Private keys are created using same algorithms that create
    public key.tcolorbox
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 与公钥相反，私钥是仅由密钥所有者知晓的秘密密钥。私钥是使用创建公钥的相同算法创建的。
- en: '**Key point** The private key is used for decryption, digitally signing, and
    authentication whereas a public key is used for encryption, verification of digital
    signatures, and authentication.'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键点** 私钥用于解密、数字签名和身份验证，而公钥用于加密、验证数字签名和身份验证。'
- en: '[5.3 Cryptographic Hash Functions](contents.xhtml#rsec5_3)'
  id: totrans-345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[5.3 密码哈希函数](contents.xhtml#rsec5_3)'
- en: A cryptographic hash function <math alttext="" display="inline"><mrow><mo stretchy="false">(</mo><mi>H</mi><mo
    stretchy="false">)</mo></mrow></math> takes an variable length input or message
    <math alttext="" display="inline"><mrow><mo stretchy="false">(</mo><mi>M</mi><mo
    stretchy="false">)</mo></mrow></math> and produces a fixed size output called
    hash values or message digest <math alttext="" display="inline"><mrow><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">)</mo></mrow></math>, i.e. as represented in [Fig. 5.2](07chap_05.xhtml#fig5_2)
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 密码哈希函数 <math alttext="" display="inline"><mrow><mo stretchy="false">(</mo><mi>H</mi><mo
    stretchy="false">)</mo></mrow></math> 接受可变长度的输入或消息 <math alttext="" display="inline"><mrow><mo
    stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo></mrow></math> 并产生固定大小的输出，称为哈希值或消息摘要
    <math alttext="" display="inline"><mrow><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">)</mo></mrow></math>，如在 [图 5.2](07chap_05.xhtml#fig5_2) 中所示。
- en: <math alttext="" display="block"><mrow><mtable columnalign="left"><mtr columnalign="left"><mtd
    columnalign="left"><mrow><mi>h</mi><mo>=</mo><mi>H</mi><mo stretchy="false">(</mo><mi>M</mi><mo
    stretchy="false">)</mo></mrow></mtd></mtr></mtable></mrow></math>(5.1)
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="" display="block"><mrow><mtable columnalign="left"><mtr columnalign="left"><mtd
    columnalign="left"><mrow><mi>h</mi><mo>=</mo><mi>H</mi><mo stretchy="false">(</mo><mi>M</mi><mo
    stretchy="false">)</mo></mrow></mtd></mtr></mtable></mrow></math>(5.1)
- en: Generally, the size of message digest is smaller than the actual input data.
    Therefore, the hash function is sometimes referred to as compression function.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，消息摘要的大小小于实际输入数据。因此，哈希函数有时被称为压缩函数。
- en: '![Figure 5.2](../images/fig5_2.jpg)'
  id: totrans-349
  prefs: []
  type: TYPE_IMG
  zh: '![图5.2](../images/fig5_2.jpg)'
- en: '**FIGURE 5.2**'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '**图5.2**'
- en: Block diagram of cryptographic hash function.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 密码哈希函数的块图。
- en: Key Points
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 要点
- en: A hash function follows the many-to-one property and thus faces collision.
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哈希函数遵循多对一的特性，因此可能会发生碰撞。
- en: In blockchain, the size of message digest is 256 bits.
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在区块链中，消息摘要的大小为256比特。
- en: Hash functions are efficiently computable as this calculations as these calculation
    does not need a significant amount of resources.
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哈希函数的计算效率很高，因为这些计算不需要大量资源。
- en: A good hash function produces evenly distributed output.
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个好的哈希函数会产生均匀分布的输出。
- en: Even a single bit change in M will change the complete hash code.
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使是对M的单比特变化也会改变完整的哈希码。
- en: '[5.3.1 Typical properties of a hash function](contents.xhtml#rsec5_3_1)'
  id: totrans-358
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[5.3.1 哈希函数的典型特性](contents.xhtml#rsec5_3_1)'
- en: It should be completely difficult to reverse a hash function, i.e., for a given
    hash value *h[1]*, it should be hard process to find input *M[1]* that exactly
    hashes to *h[1]*. This property is called irreversibility or pre-image resistance.
    Also, this type of hash function is called one-way function.
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于给定的哈希值*h[1]*，找到确切散列为*h[1]*的输入*M[1]*应该是一种困难的过程。这种属性称为不可逆性或前像抗性。此类哈希函数也称为单向函数。
- en: For a given input and its corresponding hash, it should be computationally difficult
    to find a different input having same hash, i.e., for a input *M[1]* having hash
    value *h[1]*, it should be hard to find any other input *M[2]* such that <math
    alttext="" display="inline"><mrow><mi>H</mi><mo stretchy="false">(</mo><msub><mi>M</mi><mn>1</mn></msub><mo
    stretchy="false">)</mo><mo>=</mo><mi>H</mi><mo stretchy="false">(</mo><msub><mi>M</mi><mn>2</mn></msub><mo
    stretchy="false">)</mo></mrow></math>. This property of hash functions is called
    second-image resistance.
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于给定的输入及其对应的哈希，要计算出具有相同哈希的不同输入应该是计算上困难的，即，对于具有哈希值*h[1]*的输入*M[1]*，很难找到任何其他输入*M[2]*，使得<math
    alttext="" display="inline"><mrow><mi>H</mi><mo stretchy="false">(</mo><msub><mi>M</mi><mn>1</mn></msub><mo
    stretchy="false">)</mo><mo>=</mo><mi>H</mi><mo stretchy="false">(</mo><msub><mi>M</mi><mn>2</mn></msub><mo
    stretchy="false">)</mo></mrow></math>成立。哈希函数的这种特性称为第二图像抗性。
- en: Another important property of hash functions is known as collision free property
    which states that if two messages are different, then there message digest will
    also be different, i.e., if two messages *M[1]*, *M[2]* are not equal (*M1 <math
    alttext="" display="inline"><mo>≠</mo></math> M2*), then <math alttext="" display="inline"><mrow><mi>H</mi><mo
    stretchy="false">(</mo><msub><mi>M</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>≠</mo><mi>H</mi><mo
    stretchy="false">(</mo><msub><mi>M</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow></math>.
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哈希函数的另一个重要属性是无碰撞性，它表明如果两个消息不同，那么它们的消息摘要也将不同，即，如果两个消息 *M[1]*、*M[2]* 不相等（*M1 <math
    alttext="" display="inline"><mo>≠</mo></math> M2*），那么 <math alttext="" display="inline"><mrow><mi>H</mi><mo
    stretchy="false">(</mo><msub><mi>M</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>≠</mo><mi>H</mi><mo
    stretchy="false">(</mo><msub><mi>M</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow></math>。
- en: Given two messages *M[1]*, *M[2]*, and a hash function *h*, it is difficult
    to find a value *k* such that <math alttext="" display="inline"><mrow><msub><mi>M</mi><mn>2</mn></msub><mo>=</mo><mi>h</mi><mo
    stretchy="false">(</mo><msub><mi>M</mi><mn>1</mn></msub><mi mathvariant="normal">‖</mi><mi>k</mi><mo
    stretchy="false">)</mo></mrow></math>. This property of hash functions is called
    puzzle friendliness.
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定两个消息 *M[1]*、*M[2]*，和一个哈希函数 *h*，要找到一个值 *k*，使得 <math alttext="" display="inline"><mrow><msub><mi>M</mi><mn>2</mn></msub><mo>=</mo><mi>h</mi><mo
    stretchy="false">(</mo><msub><mi>M</mi><mn>1</mn></msub><mi mathvariant="normal">‖</mi><mi>k</mi><mo
    stretchy="false">)</mo></mrow></math> 是困难的。哈希函数的这种属性称为难题友好性。
- en: '[5.3.2 Requirements of hash function:](contents.xhtml#rsec5_3_2)'
  id: totrans-363
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[5.3.2 哈希函数的要求:](contents.xhtml#rsec5_3_2)'
- en: '**One way:** Once hash is calculated it can''t be used to restore the original
    document. For example, like a human being fingerprint, one can''t retrieve the
    looks of a person from human fingerprint.'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单向性:** 一旦计算出哈希值，就不能用它来恢复原始文档。例如，就像人类的指纹一样，不能通过指纹来还原一个人的外貌。'
- en: '**Deterministic:** It states that if two similar documents are passed through
    a hash algorithm, it should always generate the same hash.'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**确定性:** 它表明，如果两个相似的文档通过同一个哈希算法，它们应始终生成相同的哈希值。'
- en: '**Avalanche effect:** It states that even changing one bit in the document,
    hash of the changed document should be significantly different from hash of the
    original document.'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**雪崩效应:** 它表明，即使在文档中改变一个比特，改变后的文档的哈希值应显著不同于原始文档的哈希值。'
- en: '**Must withstand collision:** It implies that the hash function should have
    collision resistance property.'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**必须经受住碰撞:** 这意味着哈希函数应具有碰撞抗性属性。'
- en: '[5.3.3 Applications of cryptographic hash functions](contents.xhtml#rsec5_3_3)'
  id: totrans-368
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[5.3.3 密码哈希函数的应用](contents.xhtml#rsec5_3_3)'
- en: 'Password storage: Whenever a user creates an account with user name, ID, and
    password, the ID provider does not store the password. Instead, the provider pass
    the password from a hashing algorithm and only stores hash of the password. Every
    time user attempts to log-in, the provider hashes the password entered by the
    user and compares it against the saved hash. The provider has a password file
    that has table of pairs in form [User ID1*h(P1*)] for a given user id (ID1) and
    password (P1). If the two hashes match, only then authorization is provided to
    the account otherwise not. The whole process has been depicted in [Fig. 5.3](07chap_05.xhtml#fig5_3).'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密码存储：每当用户使用用户名、ID 和密码创建帐户时，ID 提供者不会存储密码。相反，提供者通过哈希算法传递密码，并且仅存储密码的哈希值。每当用户尝试登录时，提供者对用户输入的密码进行哈希处理，并将其与保存的哈希值进行比较。提供者有一个密码文件，该文件包含以
    [用户 ID1*h(P1*)] 格式的对表，用于给定的用户 ID（ID1）和密码（P1）。如果两个哈希值匹配，则授权提供给该帐户，否则不提供。整个过程已在[图
    5.3](07chap_05.xhtml#fig5_3)中描述。
- en: '![Figure 5.3](../images/fig5_3.jpg)'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 5.3](../images/fig5_3.jpg)'
- en: '**FIGURE 5.3**'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**图 5.3**'
- en: Password storage using hash functions.
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用哈希函数进行密码存储。
- en: 'Data integrity check: One of the very popular applications of hash function
    is data integrity check. This way, hash functions can assure correctness of the
    data, i.e., user can detect any modifications, insertions, and deletions made
    to the original file.'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据完整性检查：哈希函数的一个非常流行的应用是数据完整性检查。通过这种方式，哈希函数可以保证数据的正确性，即用户可以检测到对原始文件进行的任何修改、插入和删除。
- en: '**Case 1:**'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**情况 1:**'
- en: The message <math alttext="" display="inline"><mrow><mo stretchy="false">(</mo><mi>M</mi><mo
    stretchy="false">)</mo></mrow></math> along with computed hash value of *M* is
    encrypted with symmetric encryption. Encryption ensures confidentiality of the
    message. To check integrity of the message, First, the decryption is applied to
    the received encrypted block and the message from the block is then extracted.
    Next, apply the same hash algorithm to the message M and the computed hash value
    is matched against the received hash value. The whole process has been shown in
    [Fig. 5.4](07chap_05.xhtml#fig5_4).
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 消息<math alttext="" display="inline"><mrow><mo stretchy="false">(</mo><mi>M</mi><mo
    stretchy="false">)</mo></mrow></math>与*M*的计算哈希值一起使用对称加密进行加密。加密确保了消息的机密性。为了检查消息的完整性，首先，对接收到的加密块应用解密，然后从块中提取消息。接下来，对消息*M*应用相同的哈希算法，计算得到的哈希值与接收到的哈希值进行匹配。整个过程已在[图
    5.4](07chap_05.xhtml#fig5_4)中显示。
- en: '![Figure 5.4](../images/fig5_4.jpg)'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 5.4](../images/fig5_4.jpg)'
- en: '**FIGURE 5.4**'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**图 5.4**'
- en: Data integrity check with message encryption.
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用消息加密进行数据完整性检查。
- en: '**Case 2:**'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**情况 2:**'
- en: In some cases, only the hash code is encrypted in order to reduce the burden
    for applications that don't demand confidentiality. To check the integrity of
    the message, decrypt the hash received with secret key and compute hash digest
    from the message and compare it with the received hash digest from the source.
    The whole process has been shown in [Fig. 5.5](07chap_05.xhtml#fig5_5).
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在某些情况下，仅对哈希代码进行加密，以减轻不需要机密性的应用程序的负担。要检查消息的完整性，请使用密钥解密收到的哈希，然后从消息计算哈希摘要，并将其与源中收到的哈希摘要进行比较。整个过程已在[图
    5.5](07chap_05.xhtml#fig5_5)中显示。
- en: '![Figure 5.5](../images/fig5_5.jpg)'
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 5.5](../images/fig5_5.jpg)'
- en: '**FIGURE 5.5**'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**图 5.5**'
- en: Data integrity check without message encryption.
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不进行消息加密的数据完整性检查。
- en: '[5.3.4 MD5 message-digest algorithm](contents.xhtml#rsec5_3_4)'
  id: totrans-384
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[5.3.4 MD5 消息摘要算法](contents.xhtml#rsec5_3_4)'
- en: Message-Digest algorithm 5 (MD5) is an extension of Message-Digest algorithm
    4 (MD4) and is developed by Ron Rivest in 1991\. However, MD5 is a little slower
    than MD4 but assures better security over MD4\. In particular, it is used to verify
    the integrity of the data. Also, it is used as DSA by compressing a large file
    in a secure way before encrypting the file with private key. This hashing algorithm
    takes input of arbitrary length and produces a 128-bit fingerprint as output.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 消息摘要算法 5（MD5）是消息摘要算法 4（MD4）的扩展，由 Ron Rivest 在 1991 年开发。但是，MD5 比 MD4 稍慢，但确保比
    MD4 更好的安全性。特别地，它用于验证数据的完整性。此外，在使用私钥加密文件之前，通过将大文件压缩到安全方式中使用作为 DSA。此哈希算法接受任意长度的输入，并生成
    128 位的指纹作为输出。
- en: 'The fundamentals of MD5 are based on Merkle Damgard schema. This algorithm
    process data in 512-bit block and each block is broken into 16 blocks, each of
    32 bit. The stepwise working of MD5 to produce 128-bit output is defined as follows:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: MD5 的基础是 Merkle-Damgard 结构。该算法以 512 位块处理数据，每个块被分成 16 个 32 位块。MD5 产生 128 位输出的逐步工作定义如下：
- en: '**Append padding bits:** Padding implies adding some extra bits to original
    message. Here, message is padded such that total bit length is 64 less than exact
    multiple of 512\. In order to pad the first bit is 1 and rest bits are 0\. For
    example, for a message of 1000 bits, 472 bits are padded (1000 + 472 = 1472 which
    is 64 bit less than multiple of 512.)'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**追加填充位：** 填充意味着向原始消息添加一些额外位。在这里，消息被填充以使总位长度比精确的 512 的倍数少 64 位。为了填充，第一个位是 1，其余位是
    0。例如，对于 1000 位的消息，填充了 472 位（1000 + 472 = 1472，比 512 的倍数少 64 位）。'
- en: '**Append length:** After padding, insert 64 bit at the end by calculating length
    of original message mod 264\. Hence, the resulting message is multiple of 512
    bits.'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**追加长度：** 在填充后，通过计算原始消息的长度 mod 264，在末尾插入 64 位。因此，结果消息是 512 位的倍数。'
- en: '**Dividing the message:** Divide the resulting message in 512 bit block.'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分割消息：** 将得到的消息分成 512 位的块。'
- en: '**Initialize MD buffer:** A four word buffer is initialized next. The four
    buffer namely (A, B, C, D) are 32-bit registers and its values are predefined.
    Notably, the final output in these buffer only.'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**初始化MD缓冲区：**接下来初始化一个四字缓冲区。这四个缓冲区分别为(A、B、C、D)，都是32位寄存器，并且其值是预定义的。值得注意的是，最终的输出只存在于这些缓冲区中。'
- en: '**Process message in 16 word block:** Each block of 512 bit is processed in
    4 rounds and for each round four functions F, G, H, I are used. Further, each
    round consists of 16 steps using some constants. Hence, a total of 64 operations
    are performed for each 512 bit and the output from this block is fed to the next
    block as value of A, B, C, D.'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在16字块中处理消息：**每个512位的块在4轮中处理，并且每轮都使用四个函数F、G、H、I。此外，每轮由16个步骤组成，使用一些常量。因此，每个512位的块会执行总共64次操作，此块的输出作为A、B、C、D的值被传递到下一个块中。'
- en: '[5.3.5 SHA-256](contents.xhtml#rsec5_3_5)'
  id: totrans-392
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[5.3.5 SHA-256](contents.xhtml#rsec5_3_5)'
- en: 'Blockchain bitcoin mining makes use of a special type of hash function called
    SHA-256 and this hash function generates 256-bit message digest. SHA stands for
    secure hashing algorithm. SHA-256 also operates similar to MD4, MD5 as SHA-1\.
    Computation of hash function begins by first preprocessing the message. For preprocessing:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链比特币挖掘利用了一种特殊类型的哈希函数，称为SHA-256，此哈希函数生成256位的消息摘要。SHA代表安全哈希算法。SHA-256的操作方式也类似于MD4、MD5和SHA-1\.
    哈希函数的计算首先从对消息进行预处理开始。预处理包括：
- en: 'First, the message is padded so that total message size becomes multiple of
    512 bits. For this follow:'
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，对消息进行填充，以使总消息大小成为512位的倍数。为此，请执行以下操作：
- en: Lets assume that message has length *l* in bits and *l*mod512 ≠ 0.
  id: totrans-395
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设消息的长度*l*以位为单位，且*l*mod512 ≠ 0。
- en: Append a bit with value 1 at the end of the message.
  id: totrans-396
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在消息的末尾附加一个值为1的位。
- en: Next, append k zero bits such that l+1+k ≡ 448mod512.
  id: totrans-397
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，附加k个零位，使得l+1+k ≡ 448mod512。
- en: After this append a 64-bit block having value *l* written in binary. This length
    is appended in order to avoid trivial collisions. To extract original message
    read last 64 bit (for calculating the length of message) and next start fetching
    bits from left to right till observed length.
  id: totrans-398
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在此之后附加一个值为*l*的64位块，该长度以二进制形式书写。为了避免平凡的冲突，会追加这个长度。要提取原始消息，请读取最后的64位（用于计算消息的长度），然后从左到右开始获取位。
- en: The resultant length of the message after padding should be multiple of 512
    bits.
  id: totrans-399
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 填充后消息的结果长度应为512位的倍数。
- en: For example, the given message is ‘abc’.
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，给定消息为‘abc’。
- en: It has length 24 (8*3).
  id: totrans-401
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的长度为24（8*3）。
- en: First it is padded with a one at the end of message.
  id: totrans-402
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，消息在末尾填充一个1。
- en: Next, 448-(24+1) zeros are appended, i.e., 423 zeros.
  id: totrans-403
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，附加448-(24+1)个零位，即，423个零位。
- en: 'Finally, 64 bit block having 24 written in binary is appended which results
    in:'
  id: totrans-404
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，附加一个以二进制写入的值为24的64位块，结果为：
- en: <math alttext="" display="block"><mrow><mn>011000101100010011000111</mn><munder><munder><mrow><mn>00.....0</mn></mrow><mo
    stretchy="true">︸</mo></munder><mrow><mn>423</mn><mtext>times</mtext></mrow></munder><munder><munder><mrow><mn>00.....011000</mn></mrow><mo
    stretchy="true">︸</mo></munder><mrow><mn>64</mn><mtext>bit</mtext></mrow></munder><mo>.</mo></mrow></math>
  id: totrans-405
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <math alttext="" display="block"><mrow><mn>011000101100010011000111</mn><munder><munder><mrow><mn>00.....0</mn></mrow><mo
    stretchy="true">︸</mo></munder><mrow><mn>423</mn><mtext>times</mtext></mrow></munder><munder><munder><mrow><mn>00.....011000</mn></mrow><mo
    stretchy="true">︸</mo></munder><mrow><mn>64</mn><mtext>bit</mtext></mrow></munder><mo>.</mo></mrow></math>
- en: Now, result has length 512 bits.
  id: totrans-406
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，结果的长度为512位。
- en: Next, parse the original message *M*, into *N* blocks of 512 bit each, i.e.,
    M1, M2,………., MN.
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，将原始消息*M*解析为512位的*N*个块，即，M1、M2、………、MN。
- en: After this, each 512-bit block is divided into 16 sub blocks <math alttext=""
    display="inline"><mrow><msubsup><mi>M</mi><mn>0</mn><mi>i</mi></msubsup></mrow></math>,
    <math alttext="" display="inline"><mrow><msubsup><mi>M</mi><mn>1</mn><mi>i</mi></msubsup></mrow></math>,…….,
    <math alttext="" display="inline"><mrow><msubsup><mi>M</mi><mrow><mn>15</mn></mrow><mi>i</mi></msubsup></mrow></math>
    with each having length of 32 bit.
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个512位块分成16个子块<math alttext="" display="inline"><mrow><msubsup><mi>M</mi><mn>0</mn><mi>i</mi></msubsup></mrow></math>,
    <math alttext="" display="inline"><mrow><msubsup><mi>M</mi><mn>1</mn><mi>i</mi></msubsup></mrow></math>,…….,
    <math alttext="" display="inline"><mrow><msubsup><mi>M</mi><mrow><mn>15</mn></mrow><mi>i</mi></msubsup></mrow></math>，每个子块的长度为32位。
- en: Each message block is processed one at a time. To process each block initialize
    with a fixed hash value, h0 of 256 bit also called the initialization vector (IV).
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个消息块逐个处理。为了处理每个块，初始化一个256位的固定哈希值，也称为初始化向量（IV），表示为 h0。
- en: 'Next, sequentially compute:'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，依次计算：
- en: <math alttext="" display="inline"><mrow><msup><mi>H</mi><mi>i</mi></msup><mo>=</mo><msup><mi>h</mi><mrow><mo
    stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msup><mo>+</mo><msubsup><mi>C</mi><mi>M</mi><mi>i</mi></msubsup><mo
    stretchy="false">(</mo><msup><mi>H</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo
    stretchy="false">)</mo></mrow></msup><mo stretchy="false">)</mo></mrow></math>
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <math alttext="" display="inline"><mrow><msup><mi>H</mi><mi>i</mi></msup><mo>=</mo><msup><mi>h</mi><mrow><mo
    stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msup><mo>+</mo><msubsup><mi>C</mi><mi>M</mi><mi>i</mi></msubsup><mo
    stretchy="false">(</mo><msup><mi>H</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo
    stretchy="false">)</mo></mrow></msup><mo stretchy="false">)</mo></mrow></math>
- en: where, C is compression function and + is addition modulo 2^(32).
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 其中，C 是压缩函数，+ 表示模 2^(32) 的加法。
- en: '[5.4 Digital Signatures](contents.xhtml#rsec5_4)'
  id: totrans-413
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[5.4 数字签名](contents.xhtml#rsec5_4)'
- en: The digital signature is another important fundamental behind secured blockchain
    architecture. It is a cryptographic method to validate the authenticity and integrity
    of data. Along with this, digital signatures prevent non-repudiation, i.e., the
    sender can't deny for the origin of the document. Digital signatures work similar
    to the physical signatures; however, they are electronic signatures. Nevertheless,
    the signing authority can only sign the document and anyone having a valid key
    can verify the signatures. Also, the signatures of one document cannot be transferred
    from one document to another.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 数字签名是安全区块链架构背后的另一个重要基础。它是一种验证数据真实性和完整性的加密方法。数字签名还防止了抵赖，即发送方无法否认文档的来源。数字签名的工作方式类似于物理签名；然而，它们是电子签名。然而，签署权限仅限于签署文档的权限，并且拥有有效密钥的任何人都可以验证签名。此外，一个文档的签名不能转移到另一个文档。
- en: Digital signatures are realized with the concept of asymmetric key cryptography
    (Public-key cryptography). Asymmetric key cryptography uses two different keys,
    i.e., a public key and a private key. The public key is known to the user only
    whereas the private key is known to everyone in the universe. For preserving the
    confidentiality of data, the data to be transferred is encrypted using the public
    key of the receiver whereas the private key is used at the destination node to
    decrypt the message.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 数字签名是通过非对称密钥加密（公钥密码术）的概念实现的。非对称密钥加密使用两把不同的密钥，即公钥和私钥。公钥只有用户知道，而私钥则为宇宙中所有人所知。为了保持数据的机密性，待传输的数据使用接收方的公钥加密，而在目标节点上使用私钥解密。
- en: '[5.4.1 Model of digital signature](contents.xhtml#rsec5_4_1)'
  id: totrans-416
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[5.4.1 数字签名模型](contents.xhtml#rsec5_4_1)'
- en: 'To generate digital signatures, the message is signed using the private key
    of the sender and at the destination side, signatures are verified using the public
    key of the sender. However, by integrating the concept of cryptographic hash with
    digital signatures, the size of digital signatures can be reduced. So, rather
    than signing the original message, the message digest is signed. The following
    steps are taken in generating the digital signatures:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成数字签名，使用发送者的私钥对消息进行签名，在目标端使用发送者的公钥验证签名。然而，通过将密码哈希的概念与数字签名集成，可以减小数字签名的大小。因此，与签署原始消息相比，签署消息摘要。生成数字签名的步骤如下所示：
- en: First, hash the message (*M*) to obtain message digest *h(M)*. Next, the generated
    hash is signed using the private key of the sender which results in digital signatures.
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，对消息(*M*)进行哈希处理以获取消息摘要*h(M)*。接下来，使用发送者的私钥对生成的哈希进行签名，结果是数字签名。
- en: Next, the message and the digital signature are transferred over the channel.
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，消息和数字签名通过通道传输。
- en: Receiver after receiving the particular digital signatures, decrypt it using
    the public key of the sender (This assures the **authenticity** of the sender).
    After applying the decryption algorithm, the receiver will get the message digest
    *h(M)*.
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接收者在收到特定数字签名后，使用发送者的公钥对其进行解密（这确保了发送者的**真实性**）。应用解密算法后，接收者将获得消息摘要*h(M)*。
- en: Simultaneously, from the original message received receiver, will compute the
    hash of it. Let's call this value *h’(M)*.
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同时，接收到原始消息的接收者将计算其哈希值。我们称此值为*h’(M)*。
- en: If *h(M)*=*h’(M)*, the **integrity** of the original document is preserved.
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果*h(M)*=*h’(M)*，则原始文档的**完整性**得以保留。
- en: As it is assumed that only signer of the document knows the private key, so
    no other can generate the signature of the signer. Hence, it ensures **non-repudiation**
    attribute.
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于只有文档签署者知道私钥，因此其他人无法生成签名者的签名。因此，它确保**不可否认**属性。
- en: The whole process of generating hash function has been depicted in [Fig. 5.6](07chap_05.xhtml#fig5_6).
    Therefore, by applying the hash function, the size of the signature can be reduced.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 5.6](07chap_05.xhtml#fig5_6)中描述了生成哈希函数的整个过程。因此，通过应用哈希函数，可以减小签名的大小。
- en: '![Figure 5.6](../images/fig5_6.jpg)'
  id: totrans-425
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.6](../images/fig5_6.jpg)'
- en: '**FIGURE 5.6**'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 5.6**'
- en: Digital signatures.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 数字签名。
- en: Key points
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 关键点
- en: A cryptographic key should be prevented from being guessed by others. However,
    it is assumed that the cryptographic algorithm is known to everyone.
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密码学密钥应防止他人猜测。但是，假设密码算法为所有人所知。
- en: The key should have sufficient length as a key with long length is difficult
    to guess as compared to short length key.
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密钥的长度应足够长，因为与短长度密钥相比，长长度密钥难以猜测。
- en: The key should be truly randomly generated with sufficient entropy.
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密钥应该以足够的熵真正随机生成。
- en: '[5.5 Zero-Knowledge Proof](contents.xhtml#rsec5_5)'
  id: totrans-432
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[5.5 零知识证明](contents.xhtml#rsec5_5)'
- en: Another concept that is associated with blockchain is zero-knowledge proof.
    It is a cryptographic method to prove to the verifier that prover knows a value
    without actually revealing any data except revealing the fact that prover knows
    the value. By simply, generating the final output, the prover is supposed to prove
    that they can compute something without telling the computational process whereas
    the verifier only knows the output.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 与区块链相关的另一个概念是零知识证明。这是一种加密方法，可以向验证者证明证明者知道一个值，而实际上不透露任何数据，除了透露证明者知道该值的事实。简单地说，通过生成最终输出，证明者应该证明他们可以计算某些东西，而不告诉计算过程，而验证者只知道输出。
- en: 'For example, A wants to prove B that he/she knows the key without disclosing
    secret key to B, and B verifies that A is actually having the key. Hence, they
    have the capability to revolutionize the way of data handling, collection, and
    the way data is transacted with. Zero-knowledge proof has 3 important properties:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，A 想向 B 证明他/她知道密钥而不向 B 泄露秘密密钥，并且 B 验证 A 实际拥有密钥。因此，它们有能力彻底改变数据处理、收集的方式，以及数据交易的方式。零知识证明具有
    3 个重要特性：
- en: 'Completeness: If the fact is true, the prover should convince the verifier
    for this fact and zero knowledge proof should return true.'
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完整性：如果事实是真的，证明者应该说服验证者这一事实，并且零知识证明应该返回真。
- en: 'Soundness: If the fact/statement is false, the prover can''t convince the verifier
    that prover''s statement is true.'
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明的准确性：如果事实/声明是错误的，证明者不能说服验证者证明证明者的陈述是正确的。
- en: 'Zero-knowledge/Privacy: If the information provided by prover is true, no verifier
    learns any other information expect the fact that information is true. In other
    words, the provider information should not reveal anything else to the verifier.'
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 零知识/隐私：如果证明者提供的信息是真实的，没有验证者会得知除了该信息是真实的这一事实以外的其他信息。换句话说，提供者的信息不应向验证者透露其他内容。
- en: To better understand zero knowledge proof, let's take the popular and classic
    example of zero knowledge proof that is of **two balls and colour-blind friend**
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解零知识证明，让我们来看一个广为流传且经典的零知识证明示例，即**两个球和色盲朋友**。
- en: 'Suppose A has two identical balls having different colours (say one red and
    one green) and your friend B is colour blind which means B can''t differentiate
    between the balls based on their colour. However, A has to prove to B that two
    balls are of different colours. Nevertheless, A doesn''t want to reveal which
    is red and which is green. This is how proof system for this problem will work:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 A 有两个相同的球，颜色不同（比如一个红色和一个绿色），而你的朋友 B 是色盲的，这意味着 B 无法根据球的颜色区分它们。但是，A 必须向 B 证明两个球的颜色不同。然而，A
    不想透露哪个是红色，哪个是绿色。这就是这个问题的证明系统的工作原理：
- en: A will give both balls to B and puts both balls behind his back.
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: A 将两个球都给了 B，并把两个球都藏在背后。
- en: B then takes out one of the two balls from behind his/her back and shows it.
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后 B 从背后拿出两个球中的一个并展示给别人看。
- en: B then puts back the ball behind his/her back again and then reveal just one
    of the two balls, simply by picking one of the two balls at random with equal
    chances.
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: B再次把球放回他/她的背后，然后随机选择其中一个球，只有一个球会被展示出来，而且概率相同。
- en: Next, B asks A ”Did I switch the ball?”.
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，B问A：“我交换了球吗？”
- en: Third and fourth steps are repeated till B assures that there are two different
    colored balls. Obviously, by balls color A can certainly tell whether or not B
    switched them. Moreover, A could guess right with probability not higher than
    50% that whether the ball his switched or not if balls are having same color and
    therefore indistinguishable. If A and B repeats this process multiple times A
    will be caught if he/she lies.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 第三步和第四步一直重复，直到B确信有两个不同颜色的球。显然，通过球的颜色，A可以确定B是否交换了它们。此外，如果球的颜色相同且因此无法区分，那么A可以以不超过50%的概率猜测球是否被交换。如果A和B多次重复此过程，A如果撒谎就会被抓住。
- en: Clearly, the above proof system is zero knowledge as B will never learn which
    is green and which is red ball.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，上述证明系统是零知识的，因为B永远不会知道哪个是绿球，哪个是红球。
- en: 'Over and above, zero-knowledge proof has two variants: interactive and non-interactive
    zero-knowledge proof. In interactive proofs, the prover and the verifier exchange
    more than one message to prove or verify the information. It demands verifier
    to constantly ask questions about the knowledge the prover possesses. Unfortunately,
    the interactive zero knowledge proof has limited transferability. In contrast,
    non-interactive proof system demands no interaction between prover and verifier
    except a common reference string between both parties.'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，零知识证明有两个变体：交互式零知识证明和非交互式零知识证明。在交互式证明中，证明者和验证者交换多个消息来证明或验证信息。它要求验证者不断询问证明者所拥有的知识。不幸的是，交互式零知识证明的可转移性有限。相比之下，非交互式证明系统要求证明者和验证者之间没有交互，除了双方之间共同的参考字符串。
- en: Keypoint
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 关键点
- en: '**Zero knowledge proof application in blockchain:** Both of the popular blockchain
    use cases, i.e., Bitcoin and Ethereum are based on public addresses to depict
    the true identity of the user which maintains anonymity in the network. Notably,
    due to the distributed nature of the blockchain, interactive zero knowledge proof
    is not an efficient solution. Moreover, a real world use case of zero knowledge
    proof is Zcash that enables native transactions to be fully encrypted while being
    verified by network consensus rule and Zcash is a non-interactive zero knowledge
    proof system.'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '**区块链中的零知识证明应用：** 两种流行的区块链用例，即比特币和以太坊，都是基于公共地址来表示用户的真实身份，从而在网络中保持匿名。值得注意的是，由于区块链的分布式特性，交互式零知识证明不是一个高效的解决方案。此外，零知识证明的现实世界用例是Zcash，它使本地交易完全加密，同时受到网络共识规则的验证，而Zcash是一种非交互式零知识证明系统。'
- en: '[5.6 Hash Tables](contents.xhtml#rsec5_6)'
  id: totrans-449
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[5.6 哈希表](contents.xhtml#rsec5_6)'
- en: It is a popular data structure that supports fast insertion and search operation
    irrespective of the size of the data. It is basically a method to identify a specific
    object from a group of similar objects. In particular, hash tables (also called
    hash map) store data in a format of array and each data value is associated with
    a unique index value. Hash tables make use of hash function to generate an index,
    i.e., location where a data element is to be inserted. The information in data
    structure has two main components, i.e., a unique key and a value. For instance,
    a key could be unique ID (key doesn't have to be an integer every time) and value
    is the phone number. The hash function will decide where to map the key and where
    to store corresponding value with it. The efficiency of mapping is dependent on
    the efficiency of hash function. Basically, the set from which we use input element
    is much larger than capacity of the hash table, so that collision can be avoided.
    Clearly, if the number of items in the table grows, collision rises as well. To
    measure how full the hash table is, the concept of load factor (*α*) is used which
    is defined as the fraction of number of used keys (*n*) and the total capacity
    of the table (*m*).
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种流行的数据结构，支持快速插入和搜索操作，无论数据的大小如何。它基本上是一种从一组相似对象中识别特定对象的方法。特别是，哈希表（也称为散列表）以数组格式存储数据，每个数据值与唯一的索引值相关联。哈希表利用哈希函数生成索引，即数据元素应插入的位置。数据结构中的信息有两个主要组成部分，即唯一键和值。例如，键可以是唯一ID（键不必每次都是整数），值是电话号码。哈希函数将决定将键映射到何处以及在何处存储相应的值。映射的效率取决于哈希函数的效率。基本上，我们使用输入元素的集合比哈希表的容量要大得多，以便避免冲突。显然，如果表中的项数增加，则冲突也会增加。为了衡量哈希表有多满，使用负载因子（*α*）的概念，它被定义为使用的键数（*n*）和表的总容量（*m*）的比例。
- en: <math alttext="" display="block"><mrow><mtable columnalign="left"><mtr columnalign="left"><mtd
    columnalign="left"><mrow><mi>α</mi><mo>=</mo><mfrac><mi>n</mi><mi>m</mi></mfrac></mrow></mtd></mtr></mtable></mrow></math>(5.2)
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="" display="block"><mrow><mtable columnalign="left"><mtr columnalign="left"><mtd
    columnalign="left"><mrow><mi>α</mi><mo>=</mo><mfrac><mi>n</mi><mi>m</mi></mfrac></mrow></mtd></mtr></mtable></mrow></math>(5.2)
- en: Notably, *n* can't exceed the total capacity of the table. If *α* approaches
    to maximum value, the chances of collision rises significantly.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，*n*不能超过表的总容量。如果*α*接近最大值，则冲突的可能性显著增加。
- en: 'In a linked list insertion operation is efficient whereas lookups still consume
    linear time. Additionally, in a sorted array lookup are efficient but insertions
    are insufficient. Notably, for *n* elements, linked list can search in <math alttext=""
    display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></math>
    whereas binary search takes <math alttext="" display="inline"><mrow><mi>O</mi><mo
    stretchy="false">(</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo
    stretchy="false">)</mo></mrow></math> and array consumes <math alttext="" display="inline"><mrow><mi>O</mi><mo
    stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></math> time
    for searching. In contrast to this, hash table allows insertion, deletion and
    searching very fast, i.e., <math alttext="" display="inline"><mrow><mi>O</mi><mo
    stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></math> time
    in average case (Refer to [Table 5.1](#tab5_1)). Lets take an example of hash
    table data structure as shown in [Fig. 5.7](07chap_05.xhtml#fig5_7) with hash
    function: <math alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo><mo>=</mo><mi>x</mi><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn></mrow></math>
    where *x* is the key. Suppose items are in (key, value) format and items are (1,999),
    (2, 9876), (45, 5434), (90, 9877). Therefore, the hash table organizes data so
    that any data can be looked up quickly for a given key. Nevertheless, there may
    be a case hen two or more data items collide and hashes to the same index. This
    is called the problem of collisions. For example, if we have to insert an item
    (55, 7767), this insertion will result in collision as at index 5 already there
    is an item. A function is referred to as good hash function that avoids collision.
    Collision resolution techniques are divided into two main parts, i.e., closed
    addressing and open addressing. In order to avoid the collision, closed addressing
    uses additional data structures whereas open addressing hashing stores all data
    inside the table. More formally, in case of collision resolution with open addressing,
    cells *h0(x), h1(x),……., hm-1(x)* are attempted in succession for the eq.,'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 在链表中，插入操作是高效的，而查找仍然需要线性时间。此外，在排序数组中，查找是高效的，但插入则不足够。值得注意的是，对于*n*个元素，链表可以在<math
    alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo
    stretchy="false">)</mo></mrow></math>时间内搜索，而二分查找需要<math alttext="" display="inline"><mrow><mi>O</mi><mo
    stretchy="false">(</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo
    stretchy="false">)</mo></mrow></math>时间，并且数组在搜索时消耗<math alttext="" display="inline"><mrow><mi>O</mi><mo
    stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></math>的时间。相比之下，哈希表允许快速插入、删除和搜索，即平均情况下的<math
    alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo
    stretchy="false">)</mo></mrow></math>时间（请参阅[表5.1](#tab5_1)）。让我们以哈希表数据结构为例，如[图5.7](07chap_05.xhtml#fig5_7)所示，其哈希函数为：<math
    alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo><mo>=</mo><mi>x</mi><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn></mrow></math>，其中*x*为键。假设项目以（键，值）格式排列，项目分别为（1，999）、（2，9876）、（45，5434）、（90，9877）。因此，哈希表组织数据以便可以快速查找给定键的任何数据。然而，可能会出现两个或更多数据项碰撞并散列到同一索引的情况。这称为碰撞问题。例如，如果我们要插入一个项目（55，7767），这个插入将导致碰撞，因为在索引5处已经有一个项目。良好的哈希函数避免碰撞。碰撞解决技术分为两个主要部分，即封闭寻址和开放寻址。为了避免碰撞，封闭寻址使用额外的数据结构，而开放寻址哈希将所有数据存储在表内。更正式地说，在使用开放寻址的碰撞解决方案时，连续尝试单元*h0(x),
    h1(x),……., hm-1(x)*。
- en: '**TABLE 5.1**'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 5.1**'
- en: Average and worst case complexity for hash tables.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希表的平均和最坏情况复杂度。
- en: '|  | Average complexity | Worst case complexity |'
  id: totrans-456
  prefs: []
  type: TYPE_TB
  zh: '|  | 平均复杂度 | 最坏情况复杂度 |'
- en: '| --- | --- | --- |'
  id: totrans-457
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Space | <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo
    stretchy="false">)</mo></mrow></math> | <math alttext="" display="inline"><mrow><mi>O</mi><mo
    stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></math> |'
  id: totrans-458
  prefs: []
  type: TYPE_TB
  zh: '| 空间 | <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo
    stretchy="false">)</mo></mrow></math> | <math alttext="" display="inline"><mrow><mi>O</mi><mo
    stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></math> |'
- en: '| Insertion | <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo
    stretchy="false">)</mo></mrow></math> | <math alttext="" display="inline"><mrow><mi>O</mi><mo
    stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></math> |'
  id: totrans-459
  prefs: []
  type: TYPE_TB
  zh: '| 插入 | <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo
    stretchy="false">)</mo></mrow></math> | <math alttext="" display="inline"><mrow><mi>O</mi><mo
    stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></math> |'
- en: '| Deletion | <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo
    stretchy="false">)</mo></mrow></math> | <math alttext="" display="inline"><mrow><mi>O</mi><mo
    stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></math> |'
  id: totrans-460
  prefs: []
  type: TYPE_TB
  zh: '| 删除 | <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo
    stretchy="false">)</mo></mrow></math> | <math alttext="" display="inline"><mrow><mi>O</mi><mo
    stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></math> |'
- en: '![Figure 5.7](../images/fig5_7.jpg)'
  id: totrans-461
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.7](../images/fig5_7.jpg)'
- en: '**FIGURE 5.7**'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 5.7**'
- en: Example of hash table.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希表的示例。
- en: <math alttext="" display="block"><mrow><mtable columnalign="left"><mtr columnalign="left"><mtd
    columnalign="left"><mrow><msub><mi>h</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo><mo>+</mo><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo
    stretchy="false">)</mo><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></mtd></mtr></mtable></mrow></math>(5.3)
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="" display="block"><mrow><mtable columnalign="left"><mtr columnalign="left"><mtd
    columnalign="left"><mrow><msub><mi>h</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo><mo>+</mo><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo
    stretchy="false">)</mo><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></mtd></mtr></mtable></mrow></math>(5.3)
- en: where, *f(0)=0* the function *f* is called collision resolution strategy, <math
    alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo></mrow></math> = primary hash function, *x* is the key
    and *m* is the table size. Next, we will discuss the popular collision resolution
    techniques. The categorization of collision resolution techniques has been represented
    in [Fig. 5.8](07chap_05.xhtml#fig5_8)
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，*f(0)=0* 函数 *f* 称为冲突解决策略，<math alttext="" display="inline"><mrow><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> = 主哈希函数，*x*
    为键，*m* 为表大小。接下来，我们将讨论流行的冲突解决技术。冲突解决技术的分类已在[图 5.8](07chap_05.xhtml#fig5_8)中表示。
- en: '![Figure 5.8](../images/fig5_8.jpg)'
  id: totrans-466
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.8](../images/fig5_8.jpg)'
- en: '**FIGURE 5.8**'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 5.8**'
- en: Categorization of collision resolution techniques.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 冲突解决技术的分类。
- en: '[5.6.1 Separate chaining](contents.xhtml#rsec5_6_1)'
  id: totrans-469
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[5.6.1 链接分离](contents.xhtml#rsec5_6_1)'
- en: One possible way to avoid collision is simply to store data with same index
    into a linked list at the corresponding index of the array. This method is referred
    to as separate chaining. Here, each array slot holds a pointer to linked list
    having values for all keys that hashes to same hash index as shown in [Fig. 5.9](07chap_05.xhtml#fig5_9).
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 避免冲突的一种可能方法是简单地将具有相同索引的数据存储到数组的相应索引处的链表中。这种方法称为链式存储。在这里，每个数组槽都保存一个指向链接列表的指针，该列表具有散列到相同散列索引的所有键的值，如[图
    5.9](07chap_05.xhtml#fig5_9)所示。
- en: '**Lookup:** Of course, this solution will end up in linear time, i.e., <math
    alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo
    stretchy="false">)</mo></mrow></math> for lookup in worst case. As in worst case,
    all the keys might have same index of the hash table so, in order to perform sequential
    search, time requirement is <math alttext="" display="inline"><mrow><mi>O</mi><mo
    stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></math>. Also,
    cache performance for this method is not good. Although with this method is easy
    to implement and hash table never gets fills.'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '**查找：** 当然，这种解决方案最终会以线性时间结束，即在最坏情况下查找的时间复杂度为<math alttext="" display="inline"><mrow><mi>O</mi><mo
    stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></math>。因为在最坏情况下，所有的键可能都具有哈希表的相同索引，因此为了执行顺序搜索，时间需求为<math
    alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo
    stretchy="false">)</mo></mrow></math>。此外，该方法的缓存性能不佳。尽管使用此方法易于实现且哈希表永远不会填满。'
- en: '**Deletion:** To delete, first keys need to be searched and then deleted. As
    worst case time complexity for searching is <math alttext="" display="inline"><mrow><mi>O</mi><mo
    stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></math>, so
    for deletion time taken is <math alttext="" display="inline"><mrow><mi>O</mi><mo
    stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></math>.'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '**删除：** 要删除，首先需要搜索键然后删除。因为搜索的最坏情况时间复杂度为<math alttext="" display="inline"><mrow><mi>O</mi><mo
    stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></math>，所以删除所需的时间为<math
    alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo
    stretchy="false">)</mo></mrow></math>。'
- en: '![Figure 5.9](../images/fig5_9.jpg)'
  id: totrans-473
  prefs: []
  type: TYPE_IMG
  zh: '![图5.9](../images/fig5_9.jpg)'
- en: '**FIGURE 5.9**'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: '**图5.9**'
- en: Each array slot containing pointer to linked list.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 每个数组槽包含指向链表的指针。
- en: '[5.6.2 Linear probing](contents.xhtml#rsec5_6_2)'
  id: totrans-476
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[5.6.2 线性探测](contents.xhtml#rsec5_6_2)'
- en: Linear probing is a popular method to handle collision. Probing simply implies
    finding the next empty cell where the key is to be placed in case of collision.
    This method comes under collision resolution with open addressing. To insert in
    case of collisions, the immediate next cells are tried until an empty cell is
    found. Therefore, the size of table should be equal to or greater than the total
    number of keys. Formally, for linear probing, *f* is a linear function and mostly
    it is <math alttext="" display="inline"><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo
    stretchy="false">)</mo><mo>=</mo><mi>i</mi></mrow></math> in the equation 5.3,
    i.e., <math alttext="" display="inline"><mrow><msub><mi>h</mi><mi>i</mi></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mi>i</mi><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    Clearly, the worst case complexity for searching is <math alttext="" display="inline"><mrow><mi>O</mi><mo
    stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow></math>.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 线性探测是处理冲突的常用方法。探测简单地意味着在发生冲突时找到下一个空单元格，将键放入其中。此方法属于使用开放地址法的冲突解决方法之一。在发生冲突时插入，会尝试直到找到一个空单元格为止。因此，表的大小应等于或大于键的总数。正式地，对于线性探测，*f*
    是线性函数，通常在方程式 5.3 中表示为 <math alttext="" display="inline"><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo
    stretchy="false">)</mo><mo>=</mo><mi>i</mi></mrow></math>，即，<math alttext="" display="inline"><mrow><msub><mi>h</mi><mi>i</mi></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mi>i</mi><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    显然，搜索的最坏情况复杂度为 <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo
    stretchy="false">)</mo></mrow></math>。
- en: 'However, linear probing faces the problem of clustering, i.e., if multiple
    consecutive items form a group then it will take a lot of time to find an empty
    slot for insertion or in case of searching an item. Let''s understand linear probing
    with an example, Say 3, 17, 14, 6, 21, 13, 7, 22 are the keys to be inserted in
    series and <math alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>2</mn><mi>x</mi><mo>+</mo><mn>3</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn></mrow></math>
    is the hash function for key *x*. Refer [Fig. 5.10](07chap_05.xhtml#fig5_10) Hash
    for each key is given by:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，线性探测面临聚类问题，即，如果多个连续项形成一个组，则查找一个空插槽以进行插入或搜索项将需要很长时间。让我们通过一个例子来理解线性探测，假设3、17、14、6、21、13、7、22是要依次插入的键，<math
    alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>2</mn><mi>x</mi><mo>+</mo><mn>3</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn></mrow></math>是键*x*的哈希函数。参见[图
    5.10](07chap_05.xhtml#fig5_10)，每个键的哈希值如下：
- en: '*h(3)*=9'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '*h(3)*=9'
- en: '*h(17)*=7'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '*h(17)*=7'
- en: '*h(9)*=1'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '*h(9)*=1'
- en: '*h(6)*=5'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '*h(6)*=5'
- en: '*h(21)*=5'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: '*h(21)*=5'
- en: '*h(13)*=9'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '*h(13)*=9'
- en: '*h(7)*=7'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '*h(7)*=7'
- en: '*h(22)*=7'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: '*h(22)*=7'
- en: '![Figure 5.10](../images/fig5_10.jpg)'
  id: totrans-487
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.10](../images/fig5_10.jpg)'
- en: '**FIGURE 5.10**'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 5.10**'
- en: Example of linear probing.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 线性探测的例子。
- en: '**Insert 3,17,14,6:** Insertion of these 4 elements doest not face any collision.
    So, they are inserted at their hash indexes calculated according to given hash
    function.'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '**插入 3,17,14,6：** 这4个元素的插入不会发生冲突。因此，它们被插入到根据给定哈希函数计算的哈希索引位置。'
- en: '**Insert 21**: As <math alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mn>21</mn><mo
    stretchy="false">)</mo></mrow></math> =5 and this location is already occupied
    by key 6\. So, lets try linear probing with the equation: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mi>i</mi></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mi>i</mi><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    where i=0 to m-1'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: '**插入 21**：由于<math alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mn>21</mn><mo
    stretchy="false">)</mo></mrow></math> =5，而此位置已经被键6占据。因此，让我们尝试使用线性探测方程：<math alttext=""
    display="inline"><mrow><msub><mi>h</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo><mo>+</mo><mi>i</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>，其中i=0到m-1'
- en: '**i=0**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>0</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>5</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>5</mn></mrow></math>
    which is occupied.'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: '**i=0**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>0</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>5</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>5</mn></mrow></math>
    这个位置已经被占据。'
- en: 'Next, **i=1**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>5</mn><mo>+</mo><mn>1</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>6</mn></mrow></math>
    and this location is free. So, 21 is inserted at location 6.'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: '接下来，**i=1**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>5</mn><mo>+</mo><mn>1</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>6</mn></mrow></math>
    这个位置是空闲的。因此，21 被插入到位置 6。'
- en: Similarly, 13, 7 and 22 are inserted.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，13、7 和 22 被插入。
- en: This example of insertion is presented in [Fig. 5.10](07chap_05.xhtml#fig5_10).
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 这个插入的例子见于[图 5.10](07chap_05.xhtml#fig5_10)。
- en: '[5.6.3 Quadratic probing](contents.xhtml#rsec5_6_3)'
  id: totrans-496
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[5.6.3 二次探测](contents.xhtml#rsec5_6_3)'
- en: This is another open addressing scheme to resolve collision in hash table. It
    works by taking hash value of the key and adding successive values of the quadratic
    polynomial. More formally, for quadratic probing, <math alttext="" display="inline"><mrow><mi>f</mi><mo
    stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>i</mi><mn>2</mn></msup></mrow></math>,
    i.e., <math alttext="" display="inline"><mrow><msub><mi>h</mi><mi>i</mi></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><msup><mi>i</mi><mn>2</mn></msup><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    where i=0 to m-1.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一种解决哈希表冲突的开放定址方案。它通过取密钥的哈希值并添加二次多项式的连续值来工作。更正式地说，对于二次探测，<math alttext=""
    display="inline"><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>i</mi><mn>2</mn></msup></mrow></math>，即，<math
    alttext="" display="inline"><mrow><msub><mi>h</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo><mo>+</mo><msup><mi>i</mi><mn>2</mn></msup><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    其中 i=0 到 m-1。
- en: 'This scheme has good memory caching as it preserves the locality of reference.
    Also, it avoids clustering problem as compared to linear probing. Let''s understand
    quadratic probing with an example. Refer [Fig. 5.11](07chap_05.xhtml#fig5_11).
    Again consider 3, 17, 14, 6, 21, 13, 7, 22 are the keys to be inserted in series
    and <math alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>2</mn><mi>x</mi><mo>+</mo><mn>3</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn></mrow></math>
    is the hash function for key *x*. Hash for each key is given by:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方案具有良好的内存缓存，因为它保留了引用的局部性。此外，与线性探测相比，它避免了聚类问题。让我们通过一个例子来了解二次探测。参考 [图 5.11](07chap_05.xhtml#fig5_11)。再次考虑
    3、17、14、6、21、13、7、22 是要按顺序插入的键，<math alttext="" display="inline"><mrow><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>2</mn><mi>x</mi><mo>+</mo><mn>3</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn></mrow></math>
    是键 *x* 的哈希函数。每个键的哈希值如下：
- en: '![Figure 5.11](../images/fig5_11.jpg)'
  id: totrans-499
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.11](../images/fig5_11.jpg)'
- en: '**FIGURE 5.11**'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 5.11**'
- en: Example of quadratic probing.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 二次探测的示例。
- en: '*h(3)*=9'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: '*h(3)*=9'
- en: '*h(17)*=7'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: '*h(17)*=7'
- en: '*h(9)*=1'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: '*h(9)*=1'
- en: '*h(6)*=5'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: '*h(6)*=5'
- en: '*h(21)*=5'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '*h(21)*=5'
- en: '*h(13)*=9'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: '*h(13)*=9'
- en: '*h(7)*=7'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: '*h(7)*=7'
- en: '*h(22)*=7'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: '*h(22)*=7'
- en: '**Insert 3,17,14,6:** Insertion of these 4 elements doest not face any collision.
    So, they are inserted at their hash indexes calculated according to the given
    hash function.'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: '**插入 3,17,14,6：** 插入这 4 个元素不会遇到任何冲突。所以，它们被插入到根据给定的哈希函数计算的它们的哈希索引。'
- en: '**Insert 21**: *h(21)* is 5 which is occupied by the key 6\. So, lets try quadratic
    probing with the equation: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mi>i</mi></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><msup><mi>i</mi><mn>2</mn></msup><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    where i=0 to m-1 **i=0**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> = <math
    alttext="" display="inline"><mrow><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo></mrow></math> +0)mod m ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> =(5)mod
    10 =5 which is occupied.'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: '**插入 21**：*h(21)* 是 5，被键值 6 占用。所以，让我们尝试使用二次探测方程： <math alttext="" display="inline"><mrow><msub><mi>h</mi><mi>i</mi></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><msup><mi>i</mi><mn>2</mn></msup><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>，其中
    i=0 至 m-1 **i=0**： <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> = <math
    alttext="" display="inline"><mrow><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo></mrow></math> +0)mod m ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> =(5)mod
    10 =5 被占用。'
- en: 'Next, **i=1**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> = <math
    alttext="" display="inline"><mrow><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo></mrow></math> +1²)mod m ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> =(5+1)mod
    10= 6 and this location is free. So, 21 is inserted at location 6.'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，**i=1**： <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> = <math
    alttext="" display="inline"><mrow><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo></mrow></math> +1²)mod m ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> =(5+1)mod
    10= 6，这个位置是空的。所以，21 被插入到位置 6。
- en: '**Insert 13**: <math alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mn>13</mn><mo
    stretchy="false">)</mo></mrow></math> =9 which is already occupied. So, lets try
    quadratic probing **i=0**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> = <math
    alttext="" display="inline"><mrow><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo></mrow></math> +0)mod m ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> =(9)mod
    10 =9 which is occupied.'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: '**插入 13**： <math alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mn>13</mn><mo
    stretchy="false">)</mo></mrow></math> =9，已被占用。所以，让我们尝试二次探测 **i=0**： <math alttext=""
    display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo></mrow></math> = <math alttext="" display="inline"><mrow><mo
    stretchy="false">(</mo><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math>
    +0)mod m ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> =(9)mod
    10 =9，已被占用。'
- en: '**i=1**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> = <math
    alttext="" display="inline"><mrow><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo></mrow></math> +1²)mod m ⟹ h1(x)=(9+1)mod 10= 0 and this
    location is free. So, 13 is inserted at location 0.'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: '**i=1**： <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> = <math
    alttext="" display="inline"><mrow><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo></mrow></math> +1²)mod m ⟹ h1(x)=(9+1)mod 10= 0，此位置为空。因此，13
    被插入到位置 0。'
- en: '**Insert 7**: As <math alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mn>7</mn><mo
    stretchy="false">)</mo></mrow></math> =7 is already occupied, so lets try quadratic
    probing. **i=0**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> = <math
    alttext="" display="inline"><mrow><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo></mrow></math> +0)mod m ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> =(7)mod
    10 =7 which is occupied.'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: '**插入 7**：由于 <math alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mn>7</mn><mo
    stretchy="false">)</mo></mrow></math> =7 已被占用，所以让我们尝试二次探测。 **i=0**： <math alttext=""
    display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo></mrow></math> = <math alttext="" display="inline"><mrow><mo
    stretchy="false">(</mo><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math>
    +0)mod m ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> =(7)mod
    10 =7，已被占用。'
- en: '**i=1**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> = <math
    alttext="" display="inline"><mrow><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo></mrow></math> +1²)mod m ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> =(7+1)mod
    10= 8 and this location is free. So, 7 is inserted at location 8.'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: '**i=1**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> = <math
    alttext="" display="inline"><mrow><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo></mrow></math> +1²)mod m ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> =(7+1)mod
    10= 8 这个位置是空的。所以，7 被插入到位置 8。'
- en: '**Insert 22**: <math alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mn>22</mn><mo
    stretchy="false">)</mo></mrow></math> =7 which is already occupied. So, lets try
    quadratic probing **i=0**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> =(
    <math alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo></mrow></math> +0)mod m ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> =(7)mod
    10 =7 which is occupied.'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: '**插入 22**: <math alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mn>22</mn><mo
    stretchy="false">)</mo></mrow></math> =7，这个位置已经被占用。所以，让我们尝试二次探测 **i=0**: <math
    alttext="" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo></mrow></math> =( <math alttext="" display="inline"><mrow><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> +0)mod
    m ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> =(7)mod
    10 =7 这个位置已经被占用。'
- en: '**i=1**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> =(
    <math alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo></mrow></math> +1²)mod m ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> =(7+1)mod
    10= 8 and this location is also not free. **i=2**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>2</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> =(
    <math alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo></mrow></math> +22)mod m ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>2</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> =(7+4)mod
    10= 1 and this location is also not free.'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: '**i=1**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> =(
    <math alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo></mrow></math> +1²)mod m ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> =(7+1)mod
    10= 8，而且这个位置也不是空的。 **i=2**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>2</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> =(
    <math alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo></mrow></math> +22)mod m ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>2</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> =(7+4)mod
    10= 1，而且这个位置也不是空的。'
- en: '**i=3**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>3</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> =(
    <math alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo></mrow></math> +22)mod m ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>3</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> =(7+9)mod
    10= 6 and this location is free. So, 22 is inserted at location 6.'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: '**i=3**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>3</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> =(
    <math alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo></mrow></math> +22)mod m ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>3</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> =(7+9)mod
    10= 6，而且这个位置是空的。因此，22 被插入到位置 6。'
- en: '[5.6.4 Double hashing](contents.xhtml#rsec5_6_4)'
  id: totrans-520
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[5.6.4 双重哈希](contents.xhtml#rsec5_6_4)'
- en: 'This technique applies a second hash function to the given key in case of collision,
    i.e., <math alttext="" display="inline"><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo
    stretchy="false">)</mo><mo>=</mo><mi>i</mi><mo>*</mo><msub><mi>h</mi><mn>2</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> and
    <math alttext="" display="inline"><mrow><mi>i</mi><mo>=</mo><mn>0</mn><mi>t</mi><mi>o</mi><mi>m</mi><mo>−</mo><mn>1</mn></mrow></math>
    where, h2(x) is another hash function. The second hash function provides an offset
    value to resolve collision. This technique also comes under a double hashing technique.
    Notably, a good second hash function makes sure that all cells are equally probed.
    Unfortunately, the computational cost of double hashing is high as compared to
    other probing schemes. Let''s understand quadratic probing with an example as
    represented in [Fig. 5.12](07chap_05.xhtml#fig5_12). Again consider 3, 17, 14,
    6, 21, 13, 7, 22 are the keys to be inserted in series and <math alttext="" display="inline"><mrow><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>2</mn><mi>x</mi><mo>+</mo><mn>3</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn></mrow></math>
    is the hash function for key *x*. Assume other hash function <math alttext=""
    display="inline"><mrow><mi>h</mi><mtext>′</mtext><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>3</mn><mi>k</mi><mo>+</mo><mn>1</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn></mrow></math>
    Hash for each key is given by:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术在冲突的情况下对给定的键应用第二个哈希函数，即，<math alttext="" display="inline"><mrow><mi>f</mi><mo
    stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo>=</mo><mi>i</mi><mo>*</mo><msub><mi>h</mi><mn>2</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> 和 <math
    alttext="" display="inline"><mrow><mi>i</mi><mo>=</mo><mn>0</mn><mi>t</mi><mi>o</mi><mi>m</mi><mo>−</mo><mn>1</mn></mrow></math>
    其中，h2(x) 是另一个哈希函数。第二个哈希函数提供了一个偏移值来解决冲突。这种技术也被称为双重哈希技术。值得注意的是，一个良好的第二个哈希函数确保所有单元都被均匀探查。不幸的是，与其他探查方案相比，双重哈希的计算成本较高。让我们通过一个示例来理解二次探查，如[图
    5.12](07chap_05.xhtml#fig5_12)所示。再次考虑要插入的键为3、17、14、6、21、13、7、22，并且<math alttext=""
    display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo
    stretchy="false">(</mo><mn>2</mn><mi>x</mi><mo>+</mo><mn>3</mn><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn></mrow></math>
    是键 *x* 的哈希函数。假设另一个哈希函数为<math alttext="" display="inline"><mrow><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>3</mn><mi>k</mi><mo>+</mo><mn>1</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn></mrow></math>，每个键的哈希值如下：
- en: '*h(3)*=9'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: '*h(3)*=9'
- en: '*h(17)*=7'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: '*h(17)*=7'
- en: '*h(9)*=1'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: '*h(9)*=1'
- en: '*h(6)*=5'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: '*h(6)*=5'
- en: '*h(21)*=5'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: '*h(21)*=5'
- en: '*h(13)*=9'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: '*h(13)*=9'
- en: '*h(7)*=7'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: '*h(7)*=7'
- en: '*h(22)*=7'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: '*h(22)*=7'
- en: '![Figure 5.12](../images/fig5_12.jpg)'
  id: totrans-530
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.12](../images/fig5_12.jpg)'
- en: '**FIGURE 5.12**'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 5.12**'
- en: Example of double hashing.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 双重哈希的示例。
- en: '**Insert 3,17,14,6:** Insertion of these 4 element doest not face any collision.
    So, they are inserted at their hash indexes calculated according to given hash
    function.'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: '**插入 3,17,14,6:** 这4个元素的插入没有发生任何碰撞。因此，它们被插入到根据给定哈希函数计算的哈希索引处。'
- en: '**Insert 21**: <math alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mn>21</mn><mo
    stretchy="false">)</mo></mrow></math> is 5 which is occupied by the key 6\. So,
    lets apply double hashing with the equation: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mi>i</mi></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mi>i</mi><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    where i=0 to m-1\. **i=0**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>0</mn><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>5</mn><mo>+</mo><mn>0</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>5</mn></mrow></math>
    which is occupied.'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: '**插入 21**: <math alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mn>21</mn><mo
    stretchy="false">)</mo></mrow></math> 是 5，已被关键字 6 占据。因此，让我们应用双重哈希，并使用等式：<math
    alttext="" display="inline"><mrow><msub><mi>h</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo><mo>+</mo><mi>i</mi><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    其中 i=0 到 m-1。**i=0**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>0</mn><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>5</mn><mo>+</mo><mn>0</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>5</mn></mrow></math>
    已被占据。'
- en: '**i=1**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>5</mn><mo>+</mo><mn>1</mn><mo>*</mo><mn>4</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>9</mn><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>9</mn></mrow></math>
    and which is also not free <math alttext="" display="inline"><mrow><mo stretchy="false">[</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mn>21</mn><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>3</mn><mo>*</mo><mn>21</mn><mo>+</mo><mn>1</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>4</mn><mo
    stretchy="false">]</mo></mrow></math>'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: '**i=1**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>5</mn><mo>+</mo><mn>1</mn><mo>*</mo><mn>4</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>9</mn><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>9</mn></mrow></math>
    并且也不是自由的 <math alttext="" display="inline"><mrow><mo stretchy="false">[</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mn>21</mn><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>3</mn><mo>*</mo><mn>21</mn><mo>+</mo><mn>1</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>4</mn><mo
    stretchy="false">]</mo></mrow></math>'
- en: '**i=2**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>2</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>2</mn><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>5</mn><mo>+</mo><mn>2</mn><mo>*</mo><mn>4</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>13</mn><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>3</mn></mrow></math>
    and which is free. So, key 21 is inserted at location 3.'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: '**i=2**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>2</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>2</mn><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>5</mn><mo>+</mo><mn>2</mn><mo>*</mo><mn>4</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>13</mn><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>3</mn></mrow></math>
    并且是免费的。 因此，在位置3插入了关键字21。'
- en: '**Insert 13**: <math alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mn>13</mn><mo
    stretchy="false">)</mo></mrow></math> is 9 which is occupied by the key 3\. So,
    lets apply double hashing with the equation: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mi>i</mi></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mi>i</mi><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    where i=0 to m-1\. **i=0**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>0</mn><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>9</mn><mo>+</mo><mn>0</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>9</mn></mrow></math>
    which is occupied.'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: '**插入 13**：<math alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mn>13</mn><mo
    stretchy="false">)</mo></mrow></math> 是 9，由键值 3 占用。因此，让我们应用双重散列的方程式：<math alttext=""
    display="inline"><mrow><msub><mi>h</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo><mo>+</mo><mi>i</mi><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    其中 i=0 到 m-1。**i=0**：<math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>0</mn><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>9</mn><mo>+</mo><mn>0</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>9</mn></mrow></math>
    被占用。'
- en: '**i=1**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>.
    Notably, <math alttext="" display="inline"><mrow><mo stretchy="false">[</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mn>13</mn><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>13</mn><mo>*</mo><mn>3</mn><mo>+</mo><mn>1</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>0</mn><mo
    stretchy="false">]</mo></mrow></math>. So, this will always result in hash index
    9 which is not free. This signifies choice of second hash function is not goo.
    So, we can''t insert 13 in this hash table.'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: '**i=1**：<math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>。值得注意的是，<math
    alttext="" display="inline"><mrow><mo stretchy="false">[</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mn>13</mn><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>13</mn><mo>*</mo><mn>3</mn><mo>+</mo><mn>1</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>0</mn><mo
    stretchy="false">]</mo></mrow></math>。因此，这将始终导致哈希索引 9，该索引已被占用。这表明第二个哈希函数的选择不好。因此，我们不能在此哈希表中插入
    13。'
- en: '**Insert 7**: <math alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mn>7</mn><mo
    stretchy="false">)</mo></mrow></math> is 7 which is occupied by the key 17\. So,
    lets apply double hashing with the equation: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mi>i</mi></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mi>i</mi><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    where i=0 to m-1.'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: '**插入 7**：<math alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mn>7</mn><mo
    stretchy="false">)</mo></mrow></math> 是 7，被关键字 17 占据。因此，让我们应用双重散列，其方程为：<math alttext=""
    display="inline"><mrow><msub><mi>h</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo><mo>+</mo><mi>i</mi><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    其中 i=0 到 m-1。'
- en: '**i=0**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>0</mn><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>7</mn><mo>+</mo><mn>2</mn><mo>*</mo><mn>0</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>7</mn></mrow></math>
    which is occupied.'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: '**i=0**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>0</mn><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>7</mn><mo>+</mo><mn>2</mn><mo>*</mo><mn>0</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>7</mn></mrow></math>
    被占用。'
- en: '**i=1**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>7</mn><mo>+</mo><mn>2</mn><mo>*</mo><mn>1</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>9</mn><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>9</mn></mrow></math>
    which is also not free. Notably, <math alttext="" display="inline"><mrow><mo stretchy="false">[</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mn>7</mn><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>7</mn><mo>*</mo><mn>3</mn><mo>+</mo><mn>1</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>2</mn><mo
    stretchy="false">]</mo></mrow></math>.'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: '**i=1**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>7</mn><mo>+</mo><mn>2</mn><mo>*</mo><mn>1</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>9</mn><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>9</mn></mrow></math>
    也不是免费的。值得注意的是，<math alttext="" display="inline"><mrow><mo stretchy="false">[</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mn>7</mn><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>7</mn><mo>*</mo><mn>3</mn><mo>+</mo><mn>1</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>2</mn><mo
    stretchy="false">]</mo></mrow></math>。'
- en: '**i=2**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>2</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>2</mn><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>2</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>7</mn><mo>+</mo><mn>2</mn><mo>*</mo><mn>2</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>11</mn><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>1</mn></mrow></math>
    which is also not free.'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: '**i=2**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>2</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>2</mn><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>2</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>7</mn><mo>+</mo><mn>2</mn><mo>*</mo><mn>2</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>11</mn><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>1</mn></mrow></math>
    也不是自由的。'
- en: '**i=3**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>3</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>3</mn><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>3</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>7</mn><mo>+</mo><mn>2</mn><mo>*</mo><mn>3</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>13</mn><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>3</mn></mrow></math>
    which is also not free.'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: '**i=3**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>3</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>3</mn><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>3</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>7</mn><mo>+</mo><mn>2</mn><mo>*</mo><mn>3</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>13</mn><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>3</mn></mrow></math>
    也不是自由的。'
- en: '**i=4**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>4</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>4</mn><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>4</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>7</mn><mo>+</mo><mn>2</mn><mo>*</mo><mn>4</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>15</mn><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>5</mn></mrow></math>
    which is also not free.'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: '**i=4**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>4</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>4</mn><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>4</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>7</mn><mo>+</mo><mn>2</mn><mo>*</mo><mn>4</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>15</mn><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>5</mn></mrow></math>
    也不是免费的。'
- en: '**i=5**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>5</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>5</mn><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>5</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>7</mn><mo>+</mo><mn>2</mn><mo>*</mo><mn>5</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>17</mn><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>7</mn></mrow></math>
    which is also not free.'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: '**i=5**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>5</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>5</mn><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>5</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>7</mn><mo>+</mo><mn>2</mn><mo>*</mo><mn>5</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>17</mn><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>7</mn></mrow></math>
    也不是免费的。'
- en: '**i=6**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>6</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>6</mn><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>6</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>7</mn><mo>+</mo><mn>2</mn><mo>*</mo><mn>6</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>19</mn><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>9</mn></mrow></math>
    which is also not free.'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
- en: '**i=7**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>7</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>7</mn><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>7</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> =(7+2*7)mod
    10= 21mod10=1 which is also not free.'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: '**i=8**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>8</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>8</mn><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>8</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>7</mn><mo>+</mo><mn>2</mn><mo>*</mo><mn>8</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>23</mn><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>3</mn></mrow></math>
    which is also not free.'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
- en: '**i=9**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>9</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> = <math
    alttext="" display="inline"><mrow><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo><mo>+</mo><mn>9</mn><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>9</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>7</mn><mo>+</mo><mn>2</mn><mo>*</mo><mn>9</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>25</mn><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>5</mn></mrow></math>
    which is also not free.'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
- en: Now, we cant increase value of i to 1 as i could range from 0to 9.So, value
    of i can't go beyond 9\. We have checked all possible value of i from 0 to 9\.
    So, we can't insert 7 in this hash table.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
- en: '**Insert 22**: *h(22)* is 7 which is occupied by the key 17\. So, lets apply
    double hashing with the equation: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mi>i</mi></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mi>i</mi><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    where i=0 to m-1.'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: '**插入 22**：*h(22)* 是 7，被键 17 占用。因此，让我们应用双重哈希，其方程为：<math alttext="" display="inline"><mrow><msub><mi>h</mi><mi>i</mi></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mi>i</mi><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>，其中
    i=0 至 m-1。'
- en: '**i=0**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>0</mn><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>7</mn><mo>+</mo><mn>7</mn><mo>*</mo><mn>0</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>7</mn></mrow></math>
    which is occupied.'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: '**i=0**：<math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>0</mn><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>7</mn><mo>+</mo><mn>7</mn><mo>*</mo><mn>0</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>7</mn></mrow></math>，已被占用。'
- en: '**i=1**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> =(
    <math alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo><mo>+</mo><mn>1</mn><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>7</mn><mo>+</mo><mn>7</mn><mo>*</mo><mn>1</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>14</mn><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>4</mn></mrow></math>
    which is free. Notably, [ <math alttext="" display="inline"><mrow><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mn>7</mn><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>22</mn><mo>*</mo><mn>3</mn><mo>+</mo><mn>1</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>7</mn></mrow></math>].'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
- en: '[5.7 RSA](contents.xhtml#rsec5_7)'
  id: totrans-554
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Introduced in 1978, RSA (Rivest, Shamir, Adleman) is the first widely adopted
    cryptosystems. RSA follows the idea of public-key encryption which is based on
    two components, i.e., public key, and private key. Everyone on the network has
    its own public and private key pair. The public key is known to everybody on the
    network and it is used to encrypt the message and also to verify signatures. In
    contrast, a private key is only known to the receiver and is used to decrypt the
    sent message and also to create signatures. Applications of RSA include both digital
    signatures and public key encryption. In RSA, the public key of the receiver is
    used to encrypt the message whereas the private key of the receiver is used to
    decrypt the message as shown in [Fig. 5.13](07chap_05.xhtml#fig5_13). Encryption
    is a process of transforming the original message into an unrecognizable form
    called ciphertext whereas decryption is a process of converting encrypted message
    back to the original message. The process of RSA involves 3 steps, i.e., key generation,
    encryption, and decryption.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
- en: '[5.7.1 Steps for key generation:](contents.xhtml#rsec5_7_1)'
  id: totrans-556
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Select the variables *p* and *q* where both *p* and *q* both are large prime
    numbers and p≠q. The whole security of RSA is dependent on the difficulty of factoring
    large prime numbers. A poor choice of *p* and *q* can make RSA less secure and
    vulnerable to different attacks.
  id: totrans-557
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compute <math alttext="" display="inline"><mrow><mi>n</mi><mo>=</mo><mi>p</mi><mo>*</mo><mi>q</mi></mrow></math>,
    *n* is a part of the public key and should be large so that it is difficult to
    extract *p* and *q* from it.
  id: totrans-558
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compute *ϕ*(n)=(p-1)(q-1). *ϕ*(n) is called as Euler's totient function.
  id: totrans-559
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, public key *e* is generated such that gcd(*ϕ*(n), e)=1 or *e* should be
    co-prime to *ϕ*(n); 1¡e¡*ϕ*(n).
  id: totrans-560
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, create the private key *d* such that d≡e-1mod*ϕ*(n).
  id: totrans-561
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both <math alttext="" display="inline"><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>,</mo><mi>e</mi><mo
    stretchy="false">)</mo></mrow></math> are part of RSA public key and is publically
    available and private key consist of <math alttext="" display="inline"><mrow><mo
    stretchy="false">(</mo><mi>n</mi><mo>,</mo><mi>d</mi><mo stretchy="false">)</mo></mrow></math>.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
- en: '[5.7.2 Encryption](contents.xhtml#rsec5_7_2)'
  id: totrans-563
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Lets assume a sender has to sent a plaintext message *M* to a receiver having
    public key <math alttext="" display="inline"><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>,</mo><mi>e</mi><mo
    stretchy="false">)</mo></mrow></math>. To encrypt message use:'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
- en: Cipher text= <math alttext="" display="inline"><mrow><msup><mi>M</mi><mi>e</mi></msup><mi>m</mi><mi>o</mi><mi>d</mi><mi>n</mi></mrow></math>.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
- en: '[5.7.3 Decryption](contents.xhtml#rsec5_7_3)'
  id: totrans-566
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To decrypt, receiver uses its private key as:'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
- en: Plaintext= <math alttext="" display="inline"><mrow><msup><mi>C</mi><mi>d</mi></msup><mi>m</mi><mi>o</mi><mi>d</mi><mi>n</mi></mrow></math>
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.13](../images/fig5_13.jpg)'
  id: totrans-569
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 5.13**'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
- en: RSA algorithm structure.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
- en: '[5.7.4 RSA example](contents.xhtml#rsec5_7_4)'
  id: totrans-572
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Key generation**'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
- en: Assume *p*=17, *q*=11.
  id: totrans-574
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compute *n*; *n*= 17*11=187.
  id: totrans-575
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compute *ϕ*(n); *ϕ*(n)=(17-1)*(11-1)=160.
  id: totrans-576
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choose *e* such that gcd(*ϕ*(n), e)=1; choose *e*=7.
  id: totrans-577
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compute *d* such that d≡e-1mod*ϕ*(n); d*e≡1mod160 and d¡160 ⟹ d=23 as 23*7=10*160+1.
  id: totrans-578
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Therefore, public key=(7, 187)
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
- en: private key= (23, 187).tcolorbox
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
- en: '**Key point** Public key cryptosystem follows asymmetric property as the person
    who encrypts message or verifies the signature on the message can''t decrypt or
    sign signatures on the message.'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
- en: '[5.8 Elliptic Curve Cryptography](contents.xhtml#rsec5_8)'
  id: totrans-582
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another way to perform public key cryptography is with elliptic curves. ECC
    is one of the most powerful concepts of cryptography. ECC is used for authentication,
    while secure web browsing over SSL/TLS. Popular cryptocurrency such as- Bitcoin
    and Etherem use the concept of elliptic curve. ECC is applicable for key generation,
    digital signatures and encryption/decryption services. Notably, ECC requires smaller
    key sizes as compared to RSA to provide equivalent security. Clearly, smaller
    key size are easy to manage and work with. A 256 bit ECC is equivalent to 3072-bit
    key size RSA algorithm. As ECC achieves equivalent security to RSA, with lower
    computing power and battery usage ECC has been popularly used for mobile applications.
    The key generation algorithm of the ECC uses the properties of elliptic curve
    equation which is discussed as follows:'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
- en: An elliptic curve is defined as a set of points that satisfies a cubic mathematical
    equation (Refer [Fig. 5.14](07chap_05.xhtml#fig5_14)), i.e.,
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="" display="block"><mrow><mtable columnalign="left"><mtr columnalign="left"><mtd
    columnalign="left"><mrow><msup><mi>y</mi><mn>2</mn></msup><mo>=</mo><msup><mi>x</mi><mn>3</mn></msup><mo>+</mo><mi>a</mi><mi>x</mi><mo>+</mo><mi>b</mi></mrow></mtd></mtr></mtable></mrow></math>(5.4)
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
- en: where <math alttext="" display="inline"><mrow><mn>4</mn><msup><mi>a</mi><mn>3</mn></msup><mo>+</mo><mn>27</mn><msup><mi>b</mi><mn>2</mn></msup><mo>≠</mo><mn>0</mn></mrow></math>
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
- en: To plot such a curve we need to compute <math alttext="" display="inline"><mrow><mi>y</mi><mo>=</mo><mo>±</mo><msqrt><mrow><msup><mi>x</mi><mn>3</mn></msup><mo>+</mo><mi>a</mi><mi>x</mi><mo>+</mo><mi>b</mi></mrow></msqrt></mrow></math>
    for combination of every *a* and *b*.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.14](../images/fig5_14.jpg)'
  id: totrans-588
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 5.14**'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
- en: An illustration of elliptic curve.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
- en: '**Properties of elliptic curve**'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
- en: Depending on values of a and b, elliptic curve takes different shapes on the
    plane
  id: totrans-592
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All elliptic curves are symmetric around x-axis. For example, if we take <math
    alttext="" display="inline"><mrow><mi>a</mi><mo>=</mo><mn>27</mn></mrow></math>
    and <math alttext="" display="inline"><mrow><mi>b</mi><mo>=</mo><mn>2</mn></mrow></math>,
    then for <math alttext="" display="inline"><mrow><mi>x</mi><mo>=</mo><mn>2</mn></mrow></math>,
    <math alttext="" display="inline"><mrow><mi>y</mi><mo>=</mo><mo>±</mo><mn>8</mn></mrow></math>,
    i.e., <math alttext="" display="inline"><mrow><mo stretchy="false">(</mo><mn>2</mn><mo>,</mo><mo>−</mo><mn>8</mn><mo
    stretchy="false">)</mo></mrow></math> and <math alttext="" display="inline"><mrow><mo
    stretchy="false">(</mo><mn>2</mn><mo>,</mo><mn>8</mn><mo stretchy="false">)</mo></mrow></math>
    are the resulting points.
  id: totrans-593
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any non vertical line intersects the curve in atmost three points.
  id: totrans-594
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The points on an elliptic curve form a group. The group operation applicable
    for points on elliptic curve is called addition law. To add a point P the on curve
    with another point Q, use the rule:'
  id: totrans-595
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First, join P and Q with a straight line.
  id: totrans-596
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Call this point -R where this straight line intersects with the curve.
  id: totrans-597
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The mirror image of this point with respect to x-coordinate defines the addition
    of points P and Q and is denoted by R in [Fig. 5.15](07chap_05.xhtml#fig5_15).
  id: totrans-598
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 5.15](../images/fig5_15.jpg)'
  id: totrans-599
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 5.15**'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
- en: Addition of points on elliptic curve.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
- en: Key point
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
- en: A trapdoor function *f* is defined as a function that is easy to calculate but
    whose inverse <math alttext="" display="inline"><mrow><msup><mi>f</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow></math>
    is difficult to compute.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
- en: Activity
  id: totrans-604
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Multiple Choice Questions
  id: totrans-605
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Which encryption/decryption key is only known to parties exchanging secret messages?
  id: totrans-606
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Public key
  id: totrans-607
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Private key
  id: totrans-608
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Security token
  id: totrans-609
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: e-signatures
  id: totrans-610
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which is not a function of private key?
  id: totrans-611
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Encrypting text
  id: totrans-612
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Authentication
  id: totrans-613
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Decrypting text
  id: totrans-614
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: None of these
  id: totrans-615
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What is cipher?
  id: totrans-616
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Algorithm for encryption
  id: totrans-617
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Decrypted message
  id: totrans-618
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Encrypted message
  id: totrans-619
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Secret key
  id: totrans-620
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Cryptographic hash function converts a arbitrary block into a ………?
  id: totrans-621
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Variable size string
  id: totrans-622
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Fixed size string
  id: totrans-623
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Both fixed and variable size string
  id: totrans-624
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Can't say
  id: totrans-625
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which among the following is the component of CIA triad?
  id: totrans-626
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Confidentiality
  id: totrans-627
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Integrity
  id: totrans-628
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Authentication
  id: totrans-629
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Availability
  id: totrans-630
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What are thr requirements of a hash function?
  id: totrans-631
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One-way
  id: totrans-632
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Avalanche effect
  id: totrans-633
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Deterministic
  id: totrans-634
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: All of the above
  id: totrans-635
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Cryptanalysis is ……
  id: totrans-636
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To decrease the speed of encryption
  id: totrans-637
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: To increase the speed of encryption
  id: totrans-638
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: To generate ciphertext
  id: totrans-639
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: To find insecurities in cryptographic algorithm
  id: totrans-640
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Digital signature is based on …..?
  id: totrans-641
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Public key encryption
  id: totrans-642
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Private key encryption
  id: totrans-643
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Blockchain technology
  id: totrans-644
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: None of the above
  id: totrans-645
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the properties of zero knowledge proof?
  id: totrans-646
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Completeness
  id: totrans-647
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Soundness
  id: totrans-648
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Zero knowledge
  id: totrans-649
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: None of the above
  id: totrans-650
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which among of the following is collision rsolution technique?
  id: totrans-651
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Quadratic probing
  id: totrans-652
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: ECC
  id: totrans-653
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: DSA
  id: totrans-654
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: All of the above
  id: totrans-655
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 1\. b  2\. a  3\. c  4\. b  5\. c  6\. d  7\. d  8\. a  9\. a, b, c  10\. a
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
- en: <hgroup>
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
- en: '[6](contents.xhtml#rchapter6)'
  id: totrans-658
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Blockchain Technology and Technical Foundations](contents.xhtml#rchapter6)'
  id: totrans-659
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: </hgroup>
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
- en: '[6.1 Fundamentals of Blockchain](contents.xhtml#rsec6_1)'
  id: totrans-661
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Blockchain is a growing list of blocks that combines cryptography with distributed
    computing in order to provide decentralized, transparent, and strong consistency
    support. In particular, blockchain technology is replacing the existing transaction
    management system [[112](bib.xhtml#ch00-bib-112)]. Notably, the traditional way
    of writing something in a shared document is that user1 will send the document
    to user2 and user2, after receiving the document update the document with its
    own content and send it back to user1\. However, this method does not allow both
    parties to write on the document simultaneously. As a solution, with Google Docs
    provided by Microsoft Word both of user1 and user2 can write simultaneously. Nevertheless,
    this Google doc platform is centralized and involves a third party. Mostly, the
    traditional distributed databases are centralized, have high complexity, and they
    rely on trusted database company.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
- en: Centralized architecture has a central co-ordination system and every node on
    the network is connected to this system. Any information sharing in the network
    has to involve this central coordination system. Nevertheless, there are some
    disadvantages with a centralized system.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
- en: 'Single point of failure: What if the system or the server crashes. Unfortunately,
    in case of a crash of this central system, all nodes on the network get disconnected
    to the network and all operations get terminated. This situation may lead to the
    loss of entire information. Therefore, complete dependency on a single server
    is not efficient.'
  id: totrans-664
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Bottleneck: Bottlenecks are common in case of increased traffic.'
  id: totrans-665
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Single point of attack: As there is a single central authority, there are chances
    of a single point of attack. Therefore, this type of architecture can easily suffer
    a denial-of-service attack.'
  id: totrans-666
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Delay: As a centralized server is mostly located at a far location from users,
    so time to access data increases.'
  id: totrans-667
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Higher privacy risk: As centralized architectures involve a trusted third party,
    so the user is unaware of how the information of users is secured with the third
    party. The trusted third party may share the private information of users with
    other parties.'
  id: totrans-668
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Over and above, there are other architectures to support information sharing,
    i.e., distributed and decentralized architectures:'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
- en: In a decentralized architecture, rather than having a single co-coordinator,
    multiple co-coordinators are present and nodes of the network are connected to
    any of these coordinators. So, in case of one co-ordinator node failure, nodes
    of the network can connect to any other co-ordinator to share information. Decentralization
    supports fault tolerance as decentralized systems are less likely to crash accidentally.
    Moreover, due to the presence of multiple coordinators, there is no chance of
    a single point of attack. On the other hand, in a distributed architecture, all
    nodes of the network participate in the computations and there is no single authority
    in charge. All nodes of the network co-ordinator with each other and collectively
    involves in the information sharing process. A decentralized system is actually
    part of the distributed system. In a decentralized and distributed network, both
    user1 and user2 has their own local copy of the document and both of the users
    can simultaneously write on the document.
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
- en: Blockchain is a platform that provides support for decentralized and distributed
    architecture where nodes of the network can share information among themselves.
    In contrast to a client-server model, blockchain implements a digital P2P network.
    In a blockchain network, there are multiple nodes connected via the Internet and
    each node maintains a local copy of global sheet. However, these local copies
    should be updated always as per the global information. In particular, this local
    copy of data is called a public ledger. A popular example of the public ledger
    is the banking transactions and the first popular use case of blockchain is the
    Bitcoin network. Blockchain bitcoin is referred to as decentralized system for
    exchanging cryptocurrency and it also shares distributed ledger. Many other blockchain
    cryptocurrency platforms were introduced including Ethereum leveraging the same
    public model as Bitcoin, whereas platforms such as- Hyperledger, Ripple are some
    permissioned blockchain. Although the distributed applications of blockchain are
    used in many other sectors including healthcare, IoT, smart grid, etc. Blockchain
    provides a decentralized common platform for multiple parties who don't trust
    each other and are involved in information sharing or rational decision-making
    process. This technology provides an effective way of storing transactions in
    a secure, transparent, and highly resistant way. The blockchain network makes
    sure regarding ensuring consistency and maintaining synchronization of the document.
    Anything stored on the blockchain has transparent nature and anyone modifying
    it is accountable for their actions. Moreover, the decentralized nature of this
    network ensures that a single node on the network can't append invalid blocks
    to the chain. Before a transaction is added to the blockchain network, it is validated
    by all the participants on the blockchain network. Before adding a new block to
    the blockchain network, it is always linked to the previous block with cryptographic
    hash of the immediately previous block. Therefore, cryptographic linking ensures
    the integrity of the network. As every block is cryptographically linked to the
    previous block hash that is why the name blockchain is defendable. If any block
    is altered, attackers need to modify all subsequent blocks which are quite difficult.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
- en: According to Wikipedia, A blockchain is a continuously growing list of records
    called blocks, which are linked using cryptography [[8](bib.xhtml#ch00-bib-8)].
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
- en: Blockchain technology is primarily based on the fundamentals of cryptography
    and distributed ledger technology. In particular, blockchain uses the concept
    of hash functions, ECC, digital signatures and Elliptic Curve Digital Signature
    Algorithm (ECDSA) to maintain integrity, confidentiality, and non-repudiation
    of the system. A distributed ledger is a kind of database that is shared and synchronized
    among nodes of the decentralized network. Moreover, each record in distributed
    ledger is timestamped in order to achieve the integrity of the document. However,
    a consensus mechanism is used by network participants to achieve mutual agreements
    on a single state of the network in a distributed environment. Clearly, the consensus
    mechanism minimizes the risk of fraudulent transactions.
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
- en: Blockchain mining is a process of validating transactions before it is added
    to the network and miners are the entity that is responsible for validating and
    generating a new block in the network. Some special nodes with some special characteristics
    (different for every blockchain network) are only regarded as a miner. Further,
    the mined block is broadcasted in the network to be verified by other nodes before
    final inclusion in the network. Whenever a new Bitcoin transaction is made it
    is first placed in a transaction pool. Rather than validating a single transaction,
    miners collect a certain number of transactions from the transaction pool to form
    a candidate block. Hence, a candidate block is referred to as a block that has
    been created by a miner but it is not added to the network. It may so happen that
    multiple miners can mine a block with exactly same or some different transactions
    simultaneously or in a near identical time. However, when two blocks get mined
    simultaneously, there is a possibility that only one miner's blocks get more number
    of blocks on top of it. If multiple valid blocks to the existing chain appear,
    in that case, only the longest subbranch is accepted and continued further; and
    the blocks that are not accepted are called orphaned blocks and that path is called
    forks. In other words, orphan blocks are those blocks which do not have any link
    to main branch due to missing predecessor. Additionally, if there are two different
    chains of the same length then accept the chain which has been broadcasted by
    more number of miners. Transactions from these blocks which are not validated
    are sent back to the transaction pool. In such cases, efforts of miners go useless
    as mined blocked becomes unrecorded.
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
- en: '[6.1.1 Characteristics of blockchain technology](contents.xhtml#rsec6_1_1)'
  id: totrans-675
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Decentralization: Blockchain technology does not depend on a centralized system
    or any governing authority to perform all transactions. Instead, the network is
    controlled by nodes of the network making it decentralized. Every node on the
    network has its copy of shared ledger which is updated. Moreover, it solves the
    problem of a single point of failure.'
  id: totrans-676
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Better security: Cybersecurity is defined as a capability to prevent and recover
    from cyber-attacks. Blockchain technology provides better security as there is
    not any chance of system failure. The use of a cryptography system by blockchain
    provides protection for users. Another reason for the popularity of blockchain
    technology is basically its capability to deal with the threat of an individual''s
    privacy. All transactions are verified and it is quite hard to modify these transactions.'
  id: totrans-677
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Immutability: Immutable ledger is the main advantage of the blockchain system.
    Immutability implies data on the network can''t be changed or altered. Blockchain
    stores permanent records of transactions. After a block is verified and added
    to the network, it can''t be modified or deleted. Moreover, the lack of centralization
    promotes scalability and robustness. Centralized architecture can be tampered
    and requires trust in a third party to maintain integrity.'
  id: totrans-678
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Anonymity: Blockchain provides anonymity as nodes are known by their public
    keys on the network. Therefore, the identities of the nodes are kept private.'
  id: totrans-679
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Transparency: Any node on the network can audit transactions and every node
    has access to same universal ledger. Every state of data and every updating state
    is visible to node of the network.'
  id: totrans-680
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Redundancy: As copy of distributed ledger is stored with every full node on
    the network, hence redundancy is inherent for blockchain.'
  id: totrans-681
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Efficiency: All transactions are automatically executed via pre set procedures.
    Hence, blockchain technology reduces cost of labor along with improving efficiency.'
  id: totrans-682
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[6.1.2 What constitutes a block of blockchain?](contents.xhtml#rsec6_1_2)'
  id: totrans-683
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first block in a blockchain is called genesis block and this block doesn''t
    have ant previous block. All network participants should have the same genesis
    block in order to attain the correctness of the blockchain network. The previous
    hash value for a genesis block is zero. The structure of blockchain comprises
    of strings of blocks, each holding transactions of data and metadata. Data inside
    a block contains transactions generated by participants of the network and blocks
    hold the transaction in a secure way so that they can''t be tampered. A transaction
    is an atomic event or the smallest building block allowed by a particular protocol.
    For instance, in Bitcoin blockchain transactions are user''s payments. On the
    other hand, the metadata contains information regarding block including parent
    block hash, timestamp, etc. This informative metadata is used by miners or the
    other nodes of the network to verify a block or to append a block to the blockchain.
    The structure of chained block is represented by [Fig. 6.1](08chap_06.xhtml#fig6_1).
    Metadata of the block is stored in block header ad consists of the following field:'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
- en: 'Version: The version number is used to track protocol upgrades used by blockchain
    nodes.'
  id: totrans-685
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Timestamp: It specifies the creation time of the block.'
  id: totrans-686
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Nonce: It is a random number used to solve the Proof-of-Work (PoW) cryptographic
    puzzle as shown in Eq. 6.1.2.'
  id: totrans-687
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <math alttext="" display="block"><mrow><mtable columnalign="left"><mtr columnalign="left"><mtd
    columnalign="left"><mrow><mi>S</mi><mi>H</mi><mi>A</mi><mo>−</mo><mn>256</mn><mo
    stretchy="false">(</mo><mi>S</mi><mi>H</mi><mi>A</mi><mo>−</mo><mn>256</mn><mo
    stretchy="false">(</mo><mi>P</mi><mi>r</mi><mi>e</mi><mi>v</mi><mi>i</mi><mi>o</mi><mi>u</mi><mi>s</mi><mi>b</mi><mi>l</mi><mi>o</mi><mi>c</mi><mi>k</mi><mi>h</mi><mi>a</mi><mi>s</mi><mi>h</mi><mo>|</mo><mo>|</mo><mi>T</mi><msub><mi>x</mi><mn>1</mn></msub></mrow></mtd></mtr><mtr
    columnalign="left"><mtd columnalign="left"><mrow><mo>|</mo><mo>|</mo><mi>T</mi><msub><mi>x</mi><mn>2</mn></msub><mo>|</mo><mo>|</mo><mn>.......</mn><mo>|</mo><mo>|</mo><mi>T</mi><msub><mi>x</mi><mi>n</mi></msub><mo>|</mo><mo>|</mo><mi>n</mi><mi>o</mi><mi>n</mi><mi>c</mi><mi>e</mi><mo
    stretchy="false">)</mo><mo stretchy="false">)</mo><mo><</mo><mi>D</mi><mi>i</mi><mi>f</mi><mi>f</mi><mi>i</mi><mi>c</mi><mi>u</mi><mi>l</mi><mi>t</mi><mi>y</mi></mrow></mtd></mtr></mtable></mrow></math>(6.1)
  id: totrans-688
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Difficulty/Target: This is used by PoW algorithm to solve mining process. For
    a block to be added in the blockchain network, it has to generate a valid hash
    and difficulty value is used in achieving this task.'
  id: totrans-689
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Previous block hash: As mentioned earlier, every nnt block of blockchain stores
    hash of previous block, i.e., (n-1)nt block. In order to compute hash of (n-1)th
    block, all header field of (n-1)nt block are collectively hashed twice.'
  id: totrans-690
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Merkle tree: It contains the value of root of merkle tree which is explained
    in detail later in next chapter. It is basically a tree structure where the nodes
    at leaf level contain the hash of the document and every intermediate node contains
    the hash of left and a right child. As it is presented in [Fig. 6.2](08chap_06.xhtml#fig6_2),
    there are 8 transactions, i.e., t1, t2,…………,t8\. Leaf nodes of the Merkle tree
    contain the direct hash of these transactions and then level 1 has intermediate
    nodes with hash value of its left and right child (,i.e., obtained hashes are
    again paired to calculate the hash for next level). This hash will be recursively
    calculated until a single root hash is obtained.'
  id: totrans-691
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 6.1](../images/fig6_1.jpg)'
  id: totrans-692
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 6.1**'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
- en: Structure of chained blocks.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
- en: '**Key point** Mandatory fields are transactions, Merkle root hash, and hash
    of the previous block which are used by every blockchain network, rest other are
    specific to particular blockchain application.'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2](../images/fig6_2.jpg)'
  id: totrans-696
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 6.2**'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
- en: Structure of Merkle Tree.
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
- en: In addition to this, Merkle hash tree is used in membership verification. Notably,
    to verify membership of any given transaction, the verifier does not need to possess
    a complete Merle tree, rather only (log n) piece of data is enough where n is
    the total number of nodes in the tree. As every node has access to block header,
    so the root value of Merle hash tree can be downloaded from there. Suppose, user
    A has root node of Merkle tree for a block and user B wants to prove user A that
    transaction t4 is in the block. (Refer to [Fig. 6.2](08chap_06.xhtml#fig6_2).
    To accomplish this, user 2 has to provide user 1 some siblings of the nodes in
    the tree path from t4 to the root, so that user A can recompute root hash of the
    tree and match it against the one downloaded from the block. For example, To verify
    the presence of transaction t4 in the block user 2 has to actually provide user1
    c, a’ and b” along with hash of transaction t4\. With knowing c and a, b’ can
    be computed and b’ when combined with a’ can compute a” and finally root hash
    can be computed with a” and b”. Infact, user 2 can actually prove the presence
    of t4 in the block without even revealing its content by just proving hash of
    t4.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, even in the presence of a large number of blocks in Merkle tree,
    membership of any element can be proved in relatively short time. With having
    only hash values of top level nodes, it is easy to traverse down to any leaf node
    in order to check whether it is tampered or not.tcolorbox
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
- en: '**Key point** With merkle tree membership of any transaction can be verified
    in O(log n) time and space complexity.'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
- en: '[6.1.3 Bitcoin basics](contents.xhtml#rsec6_1_3)'
  id: totrans-702
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Bitcoin is regarded as the first fully functional digital currency. It completely
    executes a P2P banking system without any central financial organization [[160](bib.xhtml#ch00-bib-160)].
    The bitcoin blockchain network is a network where users can send or receive cryptocurrency
    among themselves. It comes under the public blockchain and anyone in the world
    can be a part of the Bitcoin network. Here, transaction is a transfer of cryptocurrency
    from one node of the network to another network. Every registered node on the
    blockchain network has a pair of public and private keys held in the Bitcoin wallet
    of that person. Over and above, the Bitcoin wallet address never carries the name
    or identity of the person. Basically, a wallet address is the mathematical correspondence
    of the public key used by the user. Therefore, using the Bitcoin address maintains
    the anonymity of the network. Notably, the user can have more than one address.
    Suppose, user A wants to transfer some Bitcoins to user B. Anyone having user
    B walled address can transfer Bitcoin to his account however, to release money
    only public key of user B is required. To accomplish this, user A will create
    a transaction specifying the amount of money user A wants to transfer and user
    B address. Next, the user will sign the transaction and broadcast this transaction
    in the network. To create digital signatures, take the hash of the transaction
    and apply encryption using senders private key. Anyone in the network or specifically
    a miner can validate this transaction's integrity, authentication, and non-repudiation
    using user A public key. Notably, when a user sends Bitcoin to another address,
    wallet of that user creates a transaction output having an address of another
    user to whom money is being transferred and this transaction is recorded on blockchain
    network with Bitcoin address of the sender as the transaction input. In another
    way, an input is a reference to the output of a previous transaction. In the case
    of multiple transactions, all the total coin value is added up and it can be used
    by the output of the new transactions. For example, in [Fig. 6.3](08chap_06.xhtml#fig6_3),
    Payer B creates a transaction Y by signing its own coins received from transaction
    1 using his/her private key and adding its own public key and address of payee
    C. Anybody on the network can use B's public key to validate the transaction and
    to ensure B is spending the right coins. However, for any transaction to be accepted
    by the rest of the network, transaction blocks need to be validated and miners
    validating the nodes must include PoW in the block. Here, miners are special nodes
    with good computational power and resources. Notably, the block size in a Bitcoin
    network can't exceed 1 MB to achieve fast propagation.
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3](../images/fig6_3.jpg)'
  id: totrans-704
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 6.3**'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
- en: Illustration of Bitcoin transaction.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
- en: PoW is a cryptographic difficult hash generated by miners. Particularly, it
    is a Bitcoin consensus algorithm. The concept of PoW and mining makes a transaction
    computationally impractical to modify. In PoW, basically, miners have to find
    a nonce value so that the hash of the block has a certain hash value. The first
    miner to solve the puzzle gets a reward in the form of incentives from the network.
    All the other nodes in the network validate the blocks mined by miners. For a
    block to be added in the Bitcoin network, more than 51% of the network nodes should
    approve the blocks. Hence the only way to attack the blockchain network is when
    51% of the hash power is with attackers. This detailing of this algorithm is explained
    in the coming section.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
- en: Another reason for the popularity of Bitcoin is its ability to solve the problem
    of double-spending. Double spending is a problem when the same Bitcoins are used
    for more than one transaction. For example, user A has 100 Bitcoins and user A
    tries to send the same amount of 100 Bitcoins to both user B and user C simultaneously.
    The property of timestamping and distributed ledger ensures double-spending of
    Bitcoins. tcolorbox
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
- en: '**Key point** Bitcoin addresses are random numbers and it may be possible that
    two different users end up in creating same address and it results in a collision.
    In such a situation, both original and colliding owner of address could spend
    Bitcoins sent to that address.'
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
- en: '**Multi-signature transactions:** It is a type of transaction that is signed
    by multiple users and it transfers funds from a multi-signature address. This
    kind of transaction is used if more than one person is appointed to look after
    possession of Bitcoins. In order to append such Bitcoins, each one of the persons
    or majority of them has to sign the transactions. It implies that more than one
    private key is used to create digital signatures.'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
- en: '[6.2 Types of Blockchain](contents.xhtml#rsec6_2)'
  id: totrans-711
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The foremost application of blockchain is to execute secure transactions. However,
    depending on user''s requirement there are multiple ways in which blockchain network
    is implemented:'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
- en: 'Public blockchain: A public blockchain network is a permissionless system where
    any node with access to the Internet can participate to be a part of the network.
    Here any user of the network can access records, verify, validate transactions,
    and perform mining tasks. The more the number of participants in the public blockchain
    network, the more it will be secure as the blocks are then verified and validated
    by more participants of the network. Bitcoin, Ethereum, Litcoin, Steller, dash
    are examples of the public blockchain.'
  id: totrans-713
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Private blockchain: In contrast, a private blockchain is owned by an organization
    or enterprises where participants are restricted and only authenticated users
    are allowed. Actually, private blockchains are the restrictive version of public
    blockchain. Private blockchains are used with the private organization for storing
    sensitive information. A new user can''t join the network without having an invitation
    from the network. The invitation procedure involves use of conditions to be satisfied
    before a new user can join. Private blockchain is fast than public blockchain.
    Notably, private blockchain possesses centralization as compared to public blockchain.
    Hyperledger, multichain, Corda are the popular examples of private blockchain.
    High customizability, better access controls, better scalability are some of the
    advantages of the private blockchain [[47](bib.xhtml#ch00-bib-47)].'
  id: totrans-714
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consortium blockchain: This types of blockchain is regarded as semi-private
    systems. Clearly, it is not a public network but a permissioned network. However,
    rather a single organization governing, multiple organization governs the network.
    This type is beneficial for cases where multiple organization operates in the
    same industry. Here, only a few selected nodes have the right to oversee consensus
    mechanisms and to authorize transactions. Compared to a public blockchain, consortium
    blockchain provides faster speed. Also, this blockchain type does not face scalability
    problems. Quorum is a popular example under this category.'
  id: totrans-715
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The difference in above discussed blockchain type in tabular form is discussed
    in [Table 6.1](#tab6_1).
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
- en: '**TABLE 6.1**'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
- en: Differences in blockchain type.
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
- en: '| Blockchain type |'
  id: totrans-719
  prefs: []
  type: TYPE_TB
- en: '| --- |'
  id: totrans-720
  prefs: []
  type: TYPE_TB
- en: '| Characteristic | Public | Private | Consortium |'
  id: totrans-721
  prefs: []
  type: TYPE_TB
- en: '| Permissionless | Yes | No | No |'
  id: totrans-722
  prefs: []
  type: TYPE_TB
- en: '| Read rights | Anyone | Invited users only | Depends |'
  id: totrans-723
  prefs: []
  type: TYPE_TB
- en: '| Write rights | Anyone | Approved participants | Approved participants |'
  id: totrans-724
  prefs: []
  type: TYPE_TB
- en: '| Ownership | Nobody | Single entity | Multiple entities |'
  id: totrans-725
  prefs: []
  type: TYPE_TB
- en: '| Transaction speed | Slow | Fast | Fast |'
  id: totrans-726
  prefs: []
  type: TYPE_TB
- en: '| Centralized | No | Yes | Partially |'
  id: totrans-727
  prefs: []
  type: TYPE_TB
- en: '[6.3 Blockchain Applications](contents.xhtml#rsec6_3)'
  id: totrans-728
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Due to its distributed, immutable, and trustworthy nature for all transactions,
    blockchain technology has various applications. Not only the financial sector,
    but blockchain technology also has the potential to revolutionize commerce, industry,
    education sector, etc. Authors of [[182](bib.xhtml#ch00-bib-182)], suggested that
    the growth of blockchain applications can be divided into three phases, i.e.,
    blockchain 1.0, blockchain 2.0, and blockchain 3.0\. Blockchain 1.0 covers the
    usage of cryptocurrency as a P2P payment system. Blockchain 2.0 includes smart
    contracts, smart property, and decentralized applications with simple cash transactions.
    Blockchain 3.0 covers applications beyond finance and cryptocurrency, such as-
    healthcare, governance, agriculture, and smart grid, etc.[[49](bib.xhtml#ch00-bib-49)].
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
- en: 'Education: One of the worth mentioning application of blockchain is in the
    education sector. Similar to financial, educational sector has leveraged blockchain
    to keep student''s data safe for the coming years. As blockchain keeps track of
    information efficiently, library information services in colleges and schools
    can implement blockchain. Some universities and institutes have used blockchain
    to support degree management and evaluations for course learning outcomes. Another
    use is to reward students for their success and achievements based on transparent
    records stored on the blockchain network. For example, the University of Nicosia
    is the first place where blockchain is used to manage certificates of students
    from massive open online course (MOOC) platform [[170](bib.xhtml#ch00-bib-170)].
    In addition to this, blockchain technology helps in reducing student''s fraud
    degrees. With blockchain, all degrees and certificates are stored digitally on
    the blockchain network without requiring any intermediary to verify them. Also,
    ride sharing applications can use to organize carpooling services. This will surely
    reduce the burden on public transport.'
  id: totrans-730
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Healthcare: Mostly, existing healthcare systems are maintained by a central
    authority. Therefore, all the data generated by patients can be accessed by these
    third parties without the patient''s consent which leads to privacy concerns.
    To address this problem, recently blockchain technology has been extensively used
    in healthcare networks for various applications, such as- data management, data
    sharing, data storing, data analyzing, and access management systems. The foremost
    use case in health sector is for improved and secured medical record management
    [[208](bib.xhtml#ch00-bib-208)]. With blockchain, the information measured by
    IoT sensors, such as- temperature, blood pressure, heart care, and pulse rate
    is shared securely and transparently over the blockchain network. The patient
    can now control and check what and how much information is to be shared with the
    doctor or any other healthcare officer. Another use case is to verify the claimed
    transaction for health care financing task. Literature supports many work that
    integrates blockchain with healthcare system, such as [[102](bib.xhtml#ch00-bib-102)],
    [[97](bib.xhtml#ch00-bib-97)].'
  id: totrans-731
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Voting system: In a democratic country, maintain security in an election system
    is a matter of national security. Nowadays, electronic voting machines are used
    by the government to achieve the voting mechanism successfully. Notably, these
    e-voting systems are based on a centralized network where everything is handled
    by a trusted third-party. However, such kind of system is a concern of physical
    security, privacy, and lack of transparency. Importantly, one of the main concerns
    for such systems is the prevention of database manipulation. By leveraging the
    fundamentals of blockchain and smart contract a secure e-voting system for transparent
    democracy can be created. The usage of SHA-256 hash function and linkage to the
    previous block with the help of cryptography prevents any kind of modifications
    to the database. Moreover, the digital signature usage ensures reliability to
    the system. Additionally, the concept of anonymity supported by blockchain ensures
    that voters can submit their votes without any fear of identity leakage.'
  id: totrans-732
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Smart grid: To design a smart infrastructure for IoT based smart cities an
    intelligent and automated electricity distribution system is required. In this
    context, the smart grid has revolutionized the energy sector in many ways. A smart
    grid aims to construct an automated power infrastructure that can minimize energy
    waste. Although in the existing literature smart grid utilities are served by
    a central third party who balances users’ electricity load and payments. This
    central authority stores all the information related to electricity generation,
    consumption, and transfer. Nevertheless, because of more time consumption, single
    point of failure, and the increasing number of distributed resources, centralized
    management is not effective. With blockchain, different electric utilities exchange
    energy and make payments without a third party. All involved transactions are
    stored on publically distributed ledger after verification by all network participants.
    All records and energy transactions are stored by every network participant which
    ensures trust and transparency on the network. Simultaneously, because of resistance
    to a single point of failure, DDoS attacks are minimized by integrating blockchain
    with smart grid [[124](bib.xhtml#ch00-bib-124)]. Moreover, the elimination of
    third-party reduces transaction costs. Over and above the interconnection among
    network participants realizes P2P information sharing that achieves automatic
    scheduling. Also, automatic delivery of electricity bills can be implemented with
    blockchain. Hence, blockchain enables self participation, secure payments, transparency
    in allocation and generation of electricity, flexible demand response management,
    P2P energy trading, and real-time pricing data [[125](bib.xhtml#ch00-bib-125)].'
  id: totrans-733
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Intelligent transport system: Another potential use case of blockchain technology
    is in developing an intelligent transport system (ITS) or autonomous driving cars.
    With the rapid growth in automobile industry, computing techniques, and devices,
    there is popularity in the growth of ITS. However, information collected by different
    sensing units, Road-side unit (RSU''s) and Base station (BS''s) of ITS is generally
    stored on cloud-based platforms and thus faces security and privacy risks due
    to centralization. ITS needs to secure and authenticate data to make real-time
    decisions. Blockchain provides trustworthy data as the entire network contributes
    to data verification and validation. With its decentralized properties, blockchain
    can promote trusted communication among vehicles and RSU''s in autonomous transportation
    systems. Also, the distributed data verification mechanism ensures an immutable
    and traceable distributed ledger that heps building a secure financial system
    in ITS for P2P money transfer. For electric vehicles (EV''s) energy trading between
    EV''s and charging stations, blockchain provides secure payment handling and transaction
    management [[155](bib.xhtml#ch00-bib-155)]. Similarly, toll payments can be enabled
    with blockchain for standardized collection. Also, ride-sharing services can leverage
    blockchain to make secure payments and to display transparent information [[98](bib.xhtml#ch00-bib-98)].
    Moreover, insurance contracts can be stored on the blockchain network and smart
    contracts can be deployed for taking actions to claim money and to detect any
    kind of contract violation. Additionally, with the smart contract facility, custom
    clearance can be fast and more effective which reduces processing times at checkpoints
    [[99](bib.xhtml#ch00-bib-99)].'
  id: totrans-734
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[6.4 Smart Contracts](contents.xhtml#rsec6_4)'
  id: totrans-735
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Smart contracts are automatic and irreversible applications implemented in a
    distributed environment. Nobody except the developer having full access to the
    code can edit or modify the execution behavior of smart contracts. Smart contracts
    manage digital documents efficiently as they are self-executing and self-verifying
    [[95](bib.xhtml#ch00-bib-95)]. It is actually a piece of code developed to set
    up an agreement between more than one party, having conditions to be met before
    execution. Every party must fulfill their commitment as per their agreement. For
    example, a smart contract for payment on a specific date and time which implies
    on the arrival of a specified date and time the predefined condition is satisfied
    and the payment is transferred to the receivers account automatically. Therefore,
    eliminating the need for a trusted third party. When placed on a blockchain environment,
    it leverages properties (such as- irreversibility, tamperproof, transparency,
    etc.) of blockchain technology. The bytecode of a smart contract is visible to
    everybody on the blockchain network. It is worth noticing that one smart contract
    may needs outcome from another smart contract. Not only payment transactions,
    smart contracts are also used to execute many different processes, such as insurance,
    supply chain management, mortgage loans, real-estate, voting, etc. With the popularity
    of IoT technology, smart contracts are used to enable M2M interaction.
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
- en: 'Currently, the biggest platform for the smart contract is Ethereum. Solidity
    is an object-oriented, high-level language specifically designed for implementing
    smart contracts. Solidity is inspired by common languages such as- C++, Python,
    and javascript having features including inheritance, libraries, etc. The compiler
    of solidity converts the code into EVM bytecode. The fundamental steps for executing
    a smart contract are:'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
- en: After the finalization of contractual terms, programming code is developed specifying
    predefined conditions and outcomes.
  id: totrans-738
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploy the smart contract to the blockchain network and replicate it among all
    participants of the network.
  id: totrans-739
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the terms and conditions are satisfied, the contract is executed and the
    outcome is triggered.
  id: totrans-740
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notably, the Bitcoin network was the first one to use the concept of smart contract
    for the blockchain in a way that one node can transfer coins to another node following
    some rules. Additionally, the network participants will only validate transactions
    if some predefined conditions are met. In contrast, Ethereum replaces Bitcoin's
    restrictive language with a language that enables developers to write their own
    code of programs. It implies, with Ethereum developers can write their own program.
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
- en: '[6.5 Issues with Blockchain](contents.xhtml#rsec6_5)'
  id: totrans-742
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Blockchain technology has the potential to disrupt a wide range of industries
    but it faces its own set of challenges as shown in [Fig. 6.4](08chap_06.xhtml#fig6_4).
    However, over time literature introduces many improvements to eliminate these
    challenges.
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
- en: '**Storage**: The foremost problem of blockchain is data storage as every full
    node on the network has a copy of the distributed ledger. Clearly, this increasing
    repository of data is difficult to handle. In this context, mechanism such as-
    sidechains or chilchains should be encouraged in research [[32](bib.xhtml#ch00-bib-32)].'
  id: totrans-744
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scalability**: Another problem is the increasing size of public blockchain
    network. With the increase in the number of transactions, the size of blockchain
    becomes large. For example, the current size of Bitcoin blockchain is approximate
    269 GB [[9](bib.xhtml#ch00-bib-9)]. It is important to store all transactions
    occurring on the network for validation purposes. Therefore, the problem of scalability
    prevails in blockchain. Also, consensus protocol effects scalability of the network.
    Additionally, with the increase in network size more resources will be required,
    therefore system''s capacity scale will be reduced. Due to high scalability transaction
    execution in blockchain can become slow. Sharding is a new method to improve scalability
    and to increase transactional throughput. It is a method of partitioning that
    groups subset of participants into smaller networks who are only responsible for
    transactions meant for their shards. This way each shard will have its unique
    set of smart contracts that will be easily executed.'
  id: totrans-745
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**High computation**: The majority of blockchain available in market consumes
    lots of energy as they are based on Bitcoin infrastructure and uses PoW as a consensus
    algorithm. This protocol involves complex mathematical puzzles and demands high
    computation power for verification. However, this computationally intensive task
    is important to generate new blocks in blockchain. Also, this algorithm involves
    consumption of high energy resources. Solving mathematical puzzles consume energy
    equivalent to yearly electricity consumption of Denmark in 2020 [[10](bib.xhtml#ch00-bib-10)].
    Hence, blockchain can prove costly to the environment. In order to solve energy
    challenges faced by PoW many other consensus algorithms including Proof-of-stake
    (PoS), Proof-of-identity (PoI) has been introduced.'
  id: totrans-746
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lack of standards**: As per a research in [[11](bib.xhtml#ch00-bib-11)],
    one of the reasons blockchain technology is not adopted widely is the lack of
    trust among users. Lack of standards can create disputes among users. Also, lack
    of standardization leads to interoperability issues among large number of nodes
    in blockchain network. There are multiple blockchain projects in the market with
    having different protocols, privacy measures, consensus algorithm, and coding
    languages. Additionally, the lack of uniformity caused by these different projects
    creates consistency issues for security solutions. Moreover, there are many types
    pf blockchain network including public, private, and consortium each having their
    own advantages and disadvantages. Therefore, blockchain of different types can''t
    communicate because of interoperability issues. Standardization of blockchain
    can help in reducing costs and the problem of interoperability. In this context,
    there is a project in the market named [[12](bib.xhtml#ch00-bib-12)] that relies
    on smart bridge architecture to support universal interoperability.'
  id: totrans-747
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Latency**: Transaction validation is another property of distributed consensus.
    The total number of transactions in a block and generation time between blocks
    has a significant effect on confirmation time of transaction. This introduces
    delay or latency in blockchain network while verification and validation of block
    because of large data size and increasing network size. Hence, transactions per
    second are slow for the blockchain network. One solution to solve this problem
    is to use edge computing for mobile blockchain network, especially with the PoW
    consensus mechanism. However, this solution faces difficult to distribute the
    limited edge computing resources among various miners across the different networks.
    Bitcoin-NG [[77](bib.xhtml#ch00-bib-77)], Litecoin [[13](bib.xhtml#ch00-bib-13)],
    Ghost [[176](bib.xhtml#ch00-bib-176)] are some of the variants of Bitcoin network
    designed to improve latency of the network.'
  id: totrans-748
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Privacy leakage**: Another worth mentioning issue of blockchain is privacy
    leakage. Privacy in blockchain implies that one is able to execute transactions
    without leakage of identity information. As compared, privacy is not supported
    in Bitcoin by default as key characteristic of Bitcoin is transparent. All the
    transactions happening on the network can be checked, tracked, and audited by
    anybody on the network. It is concluded by the authors of [[139](bib.xhtml#ch00-bib-139)],
    that blockchain does not achieve transaction privacy as the value of transaction
    against each public key are publically visible. In addition to this, lightweight
    client has privacy concern as full node has all information about the interested
    wallet address of lightweight client.'
  id: totrans-749
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To increase data privacy, data of blockchain network can be encrypted. For example,
    the model presented [[122](bib.xhtml#ch00-bib-122)] stores transaction in an encrypted
    form. The compiler present in this model translates code written in encrypted
    form. Similarly, the Enigma project presented in [[1](bib.xhtml#ch00-bib-1)] divided
    data into chunks that are distributed in the network so that no node has access
    to data. Another solution to provide data privacy is to store private and sensitive
    data outside the chain, this mechanism is referred to as off-chain solution. Such
    kind of system is more suitable for highly sensitive data, such as healthcare
    or military application.
  id: totrans-750
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Security threats**: Along with privacy concerns, another challenge is security
    threats faced by blockchain network. There are many security attacks that can
    be launched in a blockchain system including sybil attack, routing attack, DoS
    attack, eclipse attack to name a few. Readers can refer to [[148](bib.xhtml#ch00-bib-148)],
    [[133](bib.xhtml#ch00-bib-133)] read further in details about these attacks. However,
    the most popular attack is majority or 51% attack. In the Bitcoin network, any
    network participants having more than 51% computing power can discover nonce power
    faster than others which implies that node has power to decide which block is
    permissible. Mostly the consensus algorithms that are centralized among limited
    users is prone to majority attack. This attack happens if a BC node controls more
    than 51% of the hashing(mining) power. To solve security issues in blockchain,
    data analytics on blockchain data is required with latest machine learning technologies
    [[185](bib.xhtml#ch00-bib-185)], [[63](bib.xhtml#ch00-bib-63)], [[14](bib.xhtml#ch00-bib-14)].'
  id: totrans-751
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Anonymity concerns**: Anonymity implies non-identifiability of the sender.
    Nowadays, user authentication with maintaining user anonymity is another requirement
    among users [[39](bib.xhtml#ch00-bib-39)]. By design, blockchain supports anonymity
    as there is no direct link between wallet address and identity of person. Instead
    of using true identity, blockchain is pseudonymous and mostly public key is pseudonym
    for the blockchain network. Unfortunately, this untraceable property motivates
    people for illegal web purchases. However, using public address protects anonymity
    to some extent. Once a person transacts with another person, it reveals its public
    address. As blockchain has the entire history of each wallet, with having public
    address all previous activity, wallet balance etc. can be checked. Additionally,
    any party can intercept a transaction to find out IP address of origin. Clearly,
    this public ledger eases correlating wallet address to identifiable names by simply
    analyzing the transactions. One way to solve this issue is to use Virtual Private
    Network (VPN) technology which uses someone else''s Internet connection. Also,
    using a new Bitcoin address for each transaction can also help a little. For example,
    Monero is another cryptocurrency that uses a different secret address every time
    for a new transaction. Another trending technique for prevention is onion routing
    that obscures IP addresses the node comes online. In this context, Tor [[15](bib.xhtml#ch00-bib-15)]
    is the open-source platform to implement onion routing. This software also helps
    hiding IP address of the node.'
  id: totrans-752
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 6.4](../images/fig6_4.jpg)'
  id: totrans-753
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 6.4**'
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
- en: Issues with blockchain technology.
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
- en: '[6.5.1 IPFS: A solution to decentralized data stoge problem](contents.xhtml#rsec6_5_1)'
  id: totrans-756
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As discussed above, storing large files on the blockchain is challenging. In
    context of storage capacity, it is worth to mention Inter Planetary File System
    (IPFS) [[16](bib.xhtml#ch00-bib-16)]. IPFS network is suitable for sharing big
    files that demand large bandwidth to upload/download over the Internet. IPFS is
    a decentralized P2P distributed file system to store shared files. IPFS is an
    efficient way to store as it eliminates duplication of data. In a P2P connected
    IPFS, if one node gets collapsed, the rest of other nodes can serve the demanded
    files. This distributed file system connects all computing devices under same
    file system. IPFS is basically a replacement of Hypertext Transfer Protocol (HTTP)
    used to access content on the Internet. In IPFS, the files on the network are
    hosted on a decentralized server which implies rather than storing the content
    on a single system, the content is hosted on multiple nodes scattered around the
    Internet. IPFS saves around 60% of the network bandwidth. Unlike HTTP that downloads
    a single file from a single machine. IPFS downloads a file in multiple pieces
    simultaneously from multiple decentralized machines.
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
- en: Rather than referring to files by names as they are stored on IPFS, this system
    refers to files by their cryptographic hash value. The cryptographic hash of the
    file is served as an address as well. This hash signifies a root object and all
    other objects that can be found in the path. In particular, the concept of content
    addressing is used at HTTP layer which implies rather than referring files by
    location (the location-based reference model supports centralization), it is addressed
    by any representation of content itself. To store files, IPFS relies on a distributed
    hash table (DHT). DHT is dictionary like interface to data that is on nodes that
    are distributed across the network. Nodes on the network use a mechanism called
    bitswamp to exchange data between nodes.
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
- en: When a new file is added to the IPFS network, IPFS generates a multihash address
    of the file using its content and node ID. To access a particular file, IPFS interrogates
    network for file having matching hash. After computing the cryptographic hash
    of the file, ask the peer of the network having content matched to that hash.
    Next, the content is downloaded directly from the node having the required data.
    Hence any node on the IPFS network having the hash of the content can look for
    a specific file via its content ID and node matching that IP will serve it.
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
- en: The IPFS model can be integrated with blockchain model, such as Bitcoin and
    Ethereum as both of these systems have similar structures. Rather than storing
    with actual values on the blockchain, IPFS simply stores hashes of files on blockchain.
    Further, using these hashes actual location of files can be found.
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
- en: '[Fig. 6.5](08chap_06.xhtml#fig6_5) presents a data sharing mode using IPFS
    as discussed by authors of [[152](bib.xhtml#ch00-bib-152)]. At first, owner of
    the file uploads it on IPFS including metadata of the file. Secondly, the hash
    of the file is generated by IPFS and returned back to owner. At third step, owner
    looks for nodes in the smart contract that provide encryption/decryption services.
    Next, the owner divides the IPFS hash into *k* pieces, encrypts them, and finally
    store them on the blockchain network.'
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.5](../images/fig6_5.jpg)'
  id: totrans-762
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 6.5**'
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
- en: Data sharing on IPFS.
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
- en: '[6.6 Python Implementation of Blockchain](contents.xhtml#rsec6_6)'
  id: totrans-765
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have used the Scientific Python Development Environment (Spyder) included
    with anaconda to implement blockchain. It enables editing, debugging, and interactive
    testing. Along with this, we have used Flash and Postman application to successfully
    create a blockchain network. Flask is a web framework for building a web application
    and it works with no dependencies to external libraries. To install flask use
    command: <math alttext="" display="inline"><mrow><mi>p</mi><mi>i</mi><mi>p</mi><mi>i</mi><mi>n</mi><mi>s</mi><mi>t</mi><mi>a</mi><mi>l</mi><mi>l</mi><mi>F</mi><mi>l</mi><mi>a</mi><mi>s</mi><mi>k</mi><mo>=</mo><mo>=</mo><mn>0.12.2</mn></mrow></math>
    Postman is an HTTP client that is used to test application program interface (API''s)
    by sending requests to web server and then getting a response back. It provides
    an easy and user-friendly interface and allows anyone to join blockchain network
    online using servers.'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/list6_1.jpg)![](../images/list6_2a.jpg)![](../images/list6_2b.jpg)![](../images/list6_3.jpg)![](../images/list6_4.jpg)'
  id: totrans-767
  prefs: []
  type: TYPE_IMG
- en: Next, we will make function to check whether a block is valid or not. To check
    block validity, two main points need to be checked that are
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
- en: Every block's proof should have 4 leading zeros in the cryptographic hash.
  id: totrans-769
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Previous hash field should have exactly same value as previous hash of the block.
  id: totrans-770
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../images/list6_5.jpg)![](../images/list6_6.jpg)'
  id: totrans-771
  prefs: []
  type: TYPE_IMG
- en: The blockchain class has been created. Also, we will use flask to create a web
    application to be able to interact with the blockchain.
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
- en: First, we will create flask based web application by creating an object of flask
    class. Actually we will interact with the blockchain through flask.
  id: totrans-773
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we will create an instance of blockchain class.
  id: totrans-774
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we will make a get request to mine a block by solving PoW problem.
  id: totrans-775
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we will again make a get request to get a blockchain.
  id: totrans-776
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../images/list6_7.jpg)![](../images/list6_8.jpg)'
  id: totrans-777
  prefs: []
  type: TYPE_IMG
- en: Now, we will mine a new block by making a new request with flask based application.
    For this, route decorator will be used to inform flask what Uniform Resource Locator
    (URL) should trigger our function to mine a block. With URL, we have to specify
    other arguments which is method of request. It could be GET or POST. GET will
    get some information and POST will create something, for example, transaction.
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/list6_9.jpg)'
  id: totrans-779
  prefs: []
  type: TYPE_IMG
- en: Now, we will create second GET request to display full blockchain in user interface
    postman application.
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/list6_10.jpg)'
  id: totrans-781
  prefs: []
  type: TYPE_IMG
- en: Finally, now we will run the blockchain application from our flask application.
    We will use postman to make request of mining block and get chain requests to
    check the actual state of the chain. To achieve this, from app object of flask
    class, we will call run method which takes two arguments, i.e., host and the port.
    From flask documentation, we can check this application is running on http://127.0.0.1.5000/.
    This URL will be entered in postman. Also, it is specified in documentation, that
    to make server publically available set host=0.0.0.0 and port as 5000.
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/list6_11.jpg)'
  id: totrans-783
  prefs: []
  type: TYPE_IMG
- en: After writing the code, execute the code on the editor. From [Fig 6.6](08chap_06.xhtml#fig6_6)
    it can be seen that application is successfully running on http:\ \0.0.0.0\. Now,
    we will use postman application to make GET request. In postman application, we
    have to enter the request URL and selecting the type of request as GET as shown
    in [Fig. 6.7](08chap_06.xhtml#fig6_7). To mine block we have to use mine_block
    request and to get blockchain state, we have to use get_chain request.
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.6](../images/fig6_6.jpg)'
  id: totrans-785
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 6.6**'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
- en: Blockchain application.
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.7](../images/fig6_7.jpg)'
  id: totrans-788
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 6.7**'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
- en: Blockchain application illustration with postman.
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
- en: First we will use get_chain request and it can be seen that there is only one
    block in network, i.e., genesis block as we have not mined any block. Refer to
    [Fig. 6.8](08chap_06.xhtml#fig6_8). This genesis block has index 1, previous_hash=0
    and proof as 1 as coded.
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.8](../images/fig6_8.jpg)'
  id: totrans-792
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 6.8**'
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
- en: Blockchain application illustration with postman.
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will mine the first block of the network with index 2 as presented in
    [Fig. 6.9](08chap_06.xhtml#fig6_9). This block has proof value of 533 which implies
    that cryptography hash of the encoded string of <math alttext="" display="inline"><mrow><msup><mrow><mn>533</mn></mrow><mn>2</mn></msup><mo>−</mo><msup><mn>1</mn><mn>2</mn></msup></mrow></math>
    starts with four leading zeros.
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.9](../images/fig6_9.jpg)'
  id: totrans-796
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 6.9**'
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
- en: Blockchain block mining illustration with postman.
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
- en: After mining first bock, lets check the status of blockchain with get_chain
    request. Refer [Fig. 6.10](08chap_06.xhtml#fig6_10).
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.10](../images/fig6_10.jpg)'
  id: totrans-800
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 6.10**'
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
- en: Blockchain get_chain illustration with postman.
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
- en: Activity
  id: totrans-803
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Multiple Choice Questions
  id: totrans-804
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What is full form for P2P?
  id: totrans-805
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Product-to-product
  id: totrans-806
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Peer-to-peer
  id: totrans-807
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Pear-to-product
  id: totrans-808
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Product-to-peer
  id: totrans-809
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following defines a miner?
  id: totrans-810
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A type of blockchain
  id: totrans-811
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A person who encrypts the text
  id: totrans-812
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A computer to store data
  id: totrans-813
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A person who validates blockchain transactions and stores them on global ledger
  id: totrans-814
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which term is used to define a blockchain split?
  id: totrans-815
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fork
  id: totrans-816
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Mining
  id: totrans-817
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Nonce
  id: totrans-818
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Genesis
  id: totrans-819
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What is usage of nonce?
  id: totrans-820
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To act as hashing function
  id: totrans-821
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: To prevent double spending
  id: totrans-822
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: To prevent 51% attack
  id: totrans-823
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: None of the above
  id: totrans-824
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What is genesis block?
  id: totrans-825
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The very first block of blockchain
  id: totrans-826
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The largest size block of blockchain
  id: totrans-827
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The smallest size block of blockchain
  id: totrans-828
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The block with having maximum number of transaction
  id: totrans-829
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What empowers Ethereum virtual machine?
  id: totrans-830
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bitcoin
  id: totrans-831
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: CoinDesk
  id: totrans-832
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Ether
  id: totrans-833
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Gas
  id: totrans-834
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What is PoW?
  id: totrans-835
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A transaction verification protocol
  id: totrans-836
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A hashing algorithm
  id: totrans-837
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: An encryption algorithm
  id: totrans-838
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A certificate needed to install blockchain
  id: totrans-839
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which among the following is used to store Bitcoin?
  id: totrans-840
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pocket
  id: totrans-841
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Box
  id: totrans-842
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Wallet
  id: totrans-843
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Bank
  id: totrans-844
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following constitute a block?
  id: totrans-845
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A hash pointer
  id: totrans-846
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Nonce value
  id: totrans-847
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Transactions
  id: totrans-848
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: All of these
  id: totrans-849
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Where is Bitcoin's central server located?
  id: totrans-850
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: India
  id: totrans-851
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Washington
  id: totrans-852
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: London
  id: totrans-853
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: None of these
  id: totrans-854
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following industry can use blockchain technology?
  id: totrans-855
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Healthcare
  id: totrans-856
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Smart grid
  id: totrans-857
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: P2P money exchange
  id: totrans-858
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: All of these
  id: totrans-859
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 1\. b  2\. d  3\. a  4\. b  5\. a  6\. d  7\. a  8\. c  9\. d  10\. d  11\.
    d
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
- en: <hgroup>
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
- en: '[7](contents.xhtml#rchapter7)'
  id: totrans-862
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Verification and Validation Methods Used by Blockchain](contents.xhtml#rchapter7)'
  id: totrans-863
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: </hgroup>
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
- en: '[7.1 Consensus Mechanism](contents.xhtml#rsec7_1)'
  id: totrans-865
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Blockchain operates as a self-regulating system without involving any centralized
    authority. Due to decentralized and distributed nature, blockchain faces the byzantine
    general problem [[129](bib.xhtml#ch00-bib-129)]. It is a problem of consensus
    making in a decentralized environment where communication channels cannot be trusted.
    Therefore, the blockchain network should work with reliability even in the presence
    of dishonest nodes. Moreover, in the absence of central authority, someone has
    to ensure validity and verification of blocks. The consensus mechanism is a process
    to reach a common agreement in a decentralized framework. The consensus mechanism
    makes sure that all nodes agree on a single state of shared block otherwise network
    has to face Byzantine general problem [[48](bib.xhtml#ch00-bib-48)]. It ensures
    reliability, correct operation, and fault tolerance even in the presence of faulty
    nodes. A consensus has to be deterministic, synchronized, and energy sufficient.
    [Fig. 7.1](09chap_07.xhtml#fig7_1) presents some of the requirements of the efficient
    consensus algorithm. However, achieving consensus in a distributed and decentralized
    environment is difficult.tcolorbox
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
- en: '**Key point** Consensus algorithm for public blockchain has low scalability
    but it achieves low latency and high throughput whereas private blockchain consensus
    algorithm has high scalability.'
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1](../images/fig7_1.jpg)'
  id: totrans-868
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 7.1**'
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
- en: Characteristics of a consensus algorithm.
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
- en: Next, different consensus algorithms are discussed. The tabular comparison between
    these discussed consensus is discussed in [Tables 7.1](#tab7_1) and [7.2](#tab7_2).
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
- en: '**TABLE 7.1**'
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
- en: Comparison of different consensus algorithms.
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 7.1](../images/tab7_1.jpg)'
  id: totrans-874
  prefs: []
  type: TYPE_IMG
- en: '**TABLE 7.2**'
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
- en: Comparison of different consensus algorithms.
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 7.2](../images/tab7_2.jpg)'
  id: totrans-877
  prefs: []
  type: TYPE_IMG
- en: '[7.1.1 Proof-of-Work](contents.xhtml#rsec7_1_1)'
  id: totrans-878
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is the first and most popular consensus algorithm used by blockchain network
    to achieve Byzantine fault tolerance. Originally, Proof-of-Work (PoW) was designed
    for public blockchain but in many existing research, PoW has been used by private
    and consortium networks. The foundation of PoW is a belief that if a node is capable
    enough to perform difficult cryptography calculations, then it is unlikely that
    the node will attack the network. The benefit of proof related consensus algorithm
    is that there is no requirement to wait for approval from other network members
    to mine the block. To add a block to the blockchain network, each miner tries
    to find a particular nonce value to generate the SHA hash of the block specified
    in the block header. To solve this kind of cryptographic puzzle, the value of
    nonce is incremented after every round in order to achieve a hash value equal
    to or lower than the target value defined for that block. In particular, block
    hash should have certain zeros at the beginning also called difficulty of the
    system. After mining, miners will broadcast the block to the network. If majority
    of the network members will accept the block only then it will be successfully
    appended to the blockchain. If a miner or group of miners controls 51% of the
    hashing power then it leads to 51% attack. Clearly, with PoW mechanism, an abundance
    of energy gets wasted as multiple miners compete to mine a block simultaneously
    and at last only one block gets accepted by the network.
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
- en: '[7.1.2 Proof-of-Stake](contents.xhtml#rsec7_1_2)'
  id: totrans-880
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Proof-of-Stake (PoS) was specially designed to solve the issue of high energy
    consumption by PoW. PoS demands less energy over PoW as fewer CPU computations
    are involved while mining blocks. Rather than relying on external investment like
    PoW, PoS only uses internal investment (that is cryptocurrency). Although like
    PoW, PoS is also designed for permissionless blockchain. However, in PoS, miners
    are referred to as validators and blocks are forged not mined. It is based on
    the foundation that a node on a network with more participation and cryptocoins
    is less likely to attack the network. To become validators, nodes have to deposit
    some cryptocoins as stake. The probability that a stakeholder can append a new
    block to the chain is proportional to the amount of stake in his/her account.
    PoS provides security to the network due to the fact that members’ stakes are
    at risk. Unfortunately, with this approach rich gets richer as validators receive
    incentives for validating a transaction which increases the possibility of the
    same node getting selected as validator again and again. Moreover, a node only
    with sufficient amount of stakes can attack the system by investing stakes in
    comparison to PoW that involves the investment of electricity, CPU computations
    and timing. Clearly, to launch 51% attack, validators have to control atleast
    51% of total digital currency existing in the network which makes the PoS attack
    more costly. Obviously, not successful attacks would result in large financial
    losses. The first use case of PoS is PPCoin where participants with oldest and
    more number of coins posses more possibility to mine the block (this is also called
    coin age based selection). Here, stake is the number of coins multiplied by holding
    period [[119](bib.xhtml#ch00-bib-119)].
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
- en: '[7.1.3 Delegated Proof-of-Stake](contents.xhtml#rsec7_1_3)'
  id: totrans-882
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is also an alternative to PoW as PoW demands lots of external resources.
    In contrast, Delegated Proof-of-Stake (DPoS) demands fewer resources and is more
    eco-friendly by design. A DPoS is based on a voting system where stakeholders
    vote for a few delegates (witnesses) who will be responsible for securing the
    network on their behalf. Here miners are referred to as witnesses and they have
    the responsibility to successfully create a new block. The voting power of a node
    is proportional to the number of cryptocoins each user holds. The witnesses are
    elected based on reputation which is decided by the number of stakes each witness
    is holding [[130](bib.xhtml#ch00-bib-130)]. The top *m* witnesses with more number
    of votes participate in the decision making of blockchain network. The value *m*
    is chosen such that atleast 50% of the voters deduce that there is enough decentralization
    [[17](bib.xhtml#ch00-bib-17)]. For validating a block, witnesses get some benefits.
    The elected witnesses validate blocks one by one. In case a witness fails to validate
    in a fixed time, then the block is assigned to the next witness in the queue and
    a new witness is selected to replace the careless one. For 51% attack to be launched,
    the attacker has to control 51% of the selected witnesses. Notably, more participation
    of stakeholders in selecting witnesses, harder it becomes for an attacker to launch
    attack.
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
- en: '[7.1.4 Practical Byzantine Fault Tolerance](contents.xhtml#rsec7_1_4)'
  id: totrans-884
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Byzantine fault tolerance is described as the capability of a distributed system
    to reach an agreement even in the presence of an attacker node in the network
    sending out misleading information. Practical Byzantine Fault Tolerance (PBFT)
    was designed to optimize BFT for implementation in blockchain network. Practical
    Byzantine Fault Tolerance (PBFT) [[59](bib.xhtml#ch00-bib-59)] was designed to
    solve the Byzantine Generals problem [[129](bib.xhtml#ch00-bib-129)] for the asynchronous
    environment. It is based on assumption that less than 30% of total nodes are malicious
    in network. In other words, a minimum of <math alttext="" display="inline"><mrow><mn>3</mn><mi>f</mi><mo>+</mo><mn>1</mn></mrow></math>
    nodes needs to work, where *f* is the number of faulty replicas. PBFT-based blockchain
    can tolerate atmost 33% of malicious nodes. The process of PBFT consists of 3
    phases which includes.
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
- en: 'Pre-prepare: For each request, a leader node broadcasts pre-prepare message
    to ask for value that other nodes of the network wants to commit.'
  id: totrans-886
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Prepare: Nodes broadcast a prepare message that specifies the value they are
    about to commit.'
  id: totrans-887
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Commit: Leader node confirms the request if <math alttext="" display="inline"><mrow><mn>2</mn><mi>f</mi><mo>+</mo><mn>1</mn></mrow></math>
    nodes agree in the previous phase.'
  id: totrans-888
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, with an priori list of participants, consensus can be reached with
    low transaction latency and low network communication overhead in PBFT. Moreover,
    limited scalability does not make it suitable for IoT applications [[107](bib.xhtml#ch00-bib-107)].
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
- en: '[7.1.5 Proof-of-Authority](contents.xhtml#rsec7_1_5)'
  id: totrans-890
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Proof-of-Authority (PoA) [[18](bib.xhtml#ch00-bib-18)] is an optimized variant
    of the PoS model where authorities on the network stake their identities for fair
    operation of the network. Parity [[19](bib.xhtml#ch00-bib-19)] and Geth [[20](bib.xhtml#ch00-bib-20)]
    have implemented PoA. PoA assumes that authorities are honest and trusted. By
    staking identities, validators do not wish to get associated with a negative reputation.
    Instead of appointing one authority, a set of authorities is used to reach an
    agreement about state of the network and the final decision has to be validated
    by the authorities. The authorities rely on mining rotation approach [[36](bib.xhtml#ch00-bib-36)]
    when a block is created. It is based on the assumption that with *N* authorities,
    atleast <math alttext="" display="inline"><mrow><mfrac><mi>N</mi><mn>2</mn></mfrac><mo>+</mo><mn>1</mn></mrow></math>
    should be trustworthy nodes. The PoA algorithm is designed for both permissioned
    and permitionless networks. However, the authors of [[68](bib.xhtml#ch00-bib-68)]
    demonstrated that PoA is not applicable for permissioned blockchain because it
    faces consistency issues. Unlike PBFT, PoA involves few exchange of messages in
    the network which improves better performance. However, the usage of a centralized
    authority limits the usage of PoA in some applications.
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
- en: '[7.1.6 Proof-of-Capacity](contents.xhtml#rsec7_1_6)'
  id: totrans-892
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unlike PoW, in order to add a new block in Proof-of-Capacity (PoC) storage has
    to be dedicated instead of computation with CPU's and GPU's [[75](bib.xhtml#ch00-bib-75)].
    With this consensus, a huge amount of energy can be saved. PoC is also referred
    to as condensed proof of work because all computations are performed once in advance
    by the verifier even before the mining begins and the results of this work (plot
    files) are cached on hard disk. The process of plotting creates a nonce value
    by using the shabal hashing mechanism. The mining process only needs to read the
    plot file. If the storage medium contains a quick solution to a recently generated
    block puzzle, the account of the verifier is incentivized. However, the size of
    the hard drive determines the time taken to create unique plot files. Unlike PoS,
    everyone on the network has a fair chance of mining because storage medium is
    easily available at cheaper prices.
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
- en: '[7.1.7 Proof-of-Burn](contents.xhtml#rsec7_1_7)'
  id: totrans-894
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Proof-of-Burn (PoB) [[21](bib.xhtml#ch00-bib-21)] was designed to solve the
    problem of high energy consumption in PoW and to reduce dependency on hardware
    resources. In PoB, miners invest coins to an eater address that is a unspendable
    address (at this address the coins become useless and inaccessible). The eater
    address does not have any private key assigned to it which implies that only coins
    can be sent to this address, but coins sent to the eater address can't be used
    or spent again. By burning or investing coins, a miners represents his/her readiness
    to bear short-term losses. While burning coins, a transaction is executed for
    the eater address and with this transaction, a burn hash is calculated. Burn hashes
    are computed by multiplying a multiplier with a internal hash. If the value of
    the burn hash is smaller than some predefined value, then the block from PoB is
    generated. The more a miner burns cryptocurrency, the higher is the probability
    of mining. After successfully mining a block, miners are rewarded. However, this
    scheme is costly from an individual miner perspective.
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
- en: '[7.1.8 Proof-of-Luck](contents.xhtml#rsec7_1_8)'
  id: totrans-896
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Proof-of-Luck (PoL) [[142](bib.xhtml#ch00-bib-142)]uses a Trusted Execution
    Environment (TEE) for correct processing of critical operations. The idea behind
    PoL is that every node on the network requests a random number (luck value) from
    TEE. The higher the luck value, the higher are the chances to get selected as
    a miner node. Similar to PoW, nodes on the network receive transaction and miner
    nodes compete to commit pending transactions in a block having the luck value
    generated by the TEE. Next, nodes broadcast the generated block to the network
    and the lucky block gets added to the network. Here, an assumption is made that
    less than half of nodes are faulty. PoL also requires the installation of a specialized
    hardware such as- SGX.
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
- en: '[7.2 Simplified Payment Verification](contents.xhtml#rsec7_2)'
  id: totrans-898
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Notably, the blockchain network generates the bulk of data which makes it difficult
    for resource-constrained devices to store all the data on their devices. This
    problem is specifically faced by mobile devices. The increasing size of the blockchain
    is clearly a concern for memory-constrained devices IoT devices and Bitcoin mobile
    users. As reported by [[22](bib.xhtml#ch00-bib-22)], the total size of the Bitcoin
    blockchain is 270.11 GB by the end of March 2020 and clearly, this data will rise
    in the coming years.
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
- en: To address this issue, blockchain supports two types of clients in a blockchain
    network, i.e., lightweight client and full client. A full node is a node of blockchain
    network which follows all rules of blockchain whereas a lightweight node is the
    one referencing trusted full nodes. Lightweight clients are also referred to as
    thin clients. In contrast to a full client, a lightweight client does not need
    to download the entire blockchain network. Nevertheless, the lightweight client
    downloads block header of all the blocks. Clearly, it results in less space and
    bandwidth consumption as no actual transactions are getting downloaded. However,
    these nodes take part in simple network operation including confirming balance,
    receiving transaction history, checking the existence of a transaction in a block,
    verification of block difficulty and downloading block headers, and to perform
    such operations these clients are dependent on the full client. These clients
    refer to one or more full client for validation, verification of transactions,
    and mining tasks. Moreover, these clients do not receive all transactions that
    are broadcasted in the network. Rather they receive some filtered transactions
    in which they are interested in from the connected full client. Over and above,
    a lightweight client can only execute limited verification compared to a full
    client. If a lightweight node wants to verify the inclusion of a transaction in
    any block, it will request access to Merkle bunch from the full node. Next, the
    lightweight node will calculate the Merkle hash value with the received hash value
    from the full node and compares it with the Merkle hash value that is downloaded
    from the block header. This whole process of confirming inclusion of a particular
    transaction to the blockchain without actually downloading the entire blockchain
    is referred to as Simplified payment verification (SPV). SPV process is however
    associated with security and privacy issues. Notably, any attacker can cheat lightweight
    node with fake transactions. Although this problem can be solved by connecting
    to different full nodes and ensuring that everybody agrees on same chain of blocks.tcolorbox
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
- en: '**Key point** To solve scalability problem, Satoshi has described the process
    of reclaiming disk space that mentions eliminating unnecessary old transactions
    from the blocks. However, before discarding a spend transaction to save disc space,
    make sure that the transaction in a coin is buried under enough blocks. To achieve
    this without disturbing block hash, only the Merkle root hash is included in the
    block.'
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
- en: '[7.3 Block Validation](contents.xhtml#rsec7_3)'
  id: totrans-902
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Even after the mining process, nodes of the network validates the block before
    it is added to the main blockchain. The following points should be checked before
    inclusion of block in a blockchain:'
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
- en: 'Syntactic structure: It is a foremost validation that makes sure that block
    should be in a syntactic structure defined for that blockchain network.'
  id: totrans-904
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Timestamp validation: Blocks are considered valid if timestamp value is greater
    than the median timestamp of immediate previous 11 blocks and less than 2+ network
    adjusted time where network adjusted time is the median of timestamp values returned
    by all connected peers to the validator node.'
  id: totrans-905
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Transaction: There should be at least one transaction present in that block.'
  id: totrans-906
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Merkle hash: Merkle hash is computed from transactions in the received block
    and is matched against Merkle hash present in the block header. Hashes are actually
    considered to be the central security element of a blockchain network.'
  id: totrans-907
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Previous hash: Verify that the current block should contain the hash of immediate
    previous block.'
  id: totrans-908
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Target: Hash of the bock should have value less than the target hash value.'
  id: totrans-909
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[7.4 Transaction Validation](contents.xhtml#rsec7_4)'
  id: totrans-910
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Transaction broadcasted in the network needs to be validated to ensure that
    coin is spent by the authorised owner and not by any randomized user. Transaction
    validation rules are mentioned as follows:'
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
- en: 'Empty: This property ensures that neither of the input and output transactions
    is empty.'
  id: totrans-912
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Structure: The defined syntactic structure of the transaction is correct.'
  id: totrans-913
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Size: The total size of the transaction should be less than or equal to the
    maximum block size.'
  id: totrans-914
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Range: The output value of each transaction must be in the legal money range.'
  id: totrans-915
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Insufficient coins: Transaction should be rejected if the total sum of input
    values is less than the sum of output values.'
  id: totrans-916
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Low transaction fees: Reject the transaction if transaction fees is too low
    than the defined transaction fees.'
  id: totrans-917
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Public key: Verify that public key accepts for each input.'
  id: totrans-918
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Double spending: For every input, if there exist referenced output in any transaction
    in the pool, the transaction will be rejected.'
  id: totrans-919
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'No output transaction: For every input, if there does not exist any referenced
    output, reject this transaction.'
  id: totrans-920
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Orphan transaction: For every input, probe the main branch and transaction
    pool to search the referenced output. If output transaction does not exist for
    any input, that transaction is an orphan transaction.'
  id: totrans-921
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Activity
  id: totrans-922
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Multiple Choice Questions
  id: totrans-923
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What is the purpose of consensus algorithm?
  id: totrans-924
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To make sure all node agree on single state
  id: totrans-925
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: To solve Byzantine general problem
  id: totrans-926
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: To ensure fault tolerance in presence of faulty nodes
  id: totrans-927
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: All of these
  id: totrans-928
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What is biggest challenge of PoW?
  id: totrans-929
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: High computational power required
  id: totrans-930
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A single miner can't perform mining
  id: totrans-931
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A miner can't mine a single block at one time
  id: totrans-932
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: None of these
  id: totrans-933
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: PoS stands for?
  id: totrans-934
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Proof-of-Stake
  id: totrans-935
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Proof-of-Standard
  id: totrans-936
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Proof-of-source
  id: totrans-937
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Proof of-secondary
  id: totrans-938
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: PPCoin cryptocurrency uses which consensus algorithm?
  id: totrans-939
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: PoW
  id: totrans-940
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: PoA
  id: totrans-941
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: PoB
  id: totrans-942
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: PoS
  id: totrans-943
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: How DPoS algorithm selects a miner?
  id: totrans-944
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Voting system
  id: totrans-945
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The person with more electricity power
  id: totrans-946
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The person with more computers
  id: totrans-947
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: None of these
  id: totrans-948
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the disadvantage of PBFT consensus algorithm?
  id: totrans-949
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Limited reliability
  id: totrans-950
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Limited scalability
  id: totrans-951
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: High computational power required
  id: totrans-952
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: No fault tolerance
  id: totrans-953
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In PoB miners invest coins to an ether address.
  id: totrans-954
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True'
  id: totrans-955
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'False'
  id: totrans-956
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Parity uses which consensus algorithm?
  id: totrans-957
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: PoB
  id: totrans-958
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: PoA
  id: totrans-959
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: PoW
  id: totrans-960
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: PoS
  id: totrans-961
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 1\. d  2\. a  3\. a  4\. d  5\. a  6\. b  7\. a  8\. b
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
- en: <hgroup>
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
- en: '[8](contents.xhtml#rchapter8)'
  id: totrans-964
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Data Structures for Blockchain](contents.xhtml#rchapter8)'
  id: totrans-965
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: </hgroup>
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
- en: '[8.1 Data Structures for Blockchain](contents.xhtml#rsec8_1)'
  id: totrans-967
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section will discuss the important data structures used by blockchain.
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
- en: 'Hash pointers: A pointer in data structures is used to pint address of value
    stored in memory. The process of fetching the value stored at any memory location
    is called dereferencing the pointer (Refer [Fig. 8.1](10chap_08.xhtml#fig8_1)).
    Additionally, a hash pointer is a type of pointer that points to address of hash
    value in order to make it tamper proof. Particularly, rather than just consisting
    of address of immediate previous block, it also has the hash of data in the previous
    block. Notably, hash pointers are used to construct a linked list called blockchain.
    In blockchain, hash pointer points to the hash of data stored in the immediate
    previous block. Hence, any modification in the chain would be detected with the
    hash pointers. Suppose an malicious person tampers with a block of blockchain,
    lets say block 10\. With change in content of block 10, hash of this block also
    got changed (collision free property of hash). To bluff others, he also has to
    change hash pointers of next block, i.e., block 11\. Furthermore hash pointer
    of block 12 also has to change and so on and so forth. Refer [Fig. 8.2](10chap_08.xhtml#fig8_2)
    for illustration of hash pointer chain.'
  id: totrans-969
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 8.1](../images/fig8_1.jpg)'
  id: totrans-970
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**FIGURE 8.1**'
  id: totrans-971
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Illustration of hash pointer.
  id: totrans-972
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.2](../images/fig8_2.jpg)'
  id: totrans-973
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**FIGURE 8.2**'
  id: totrans-974
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Illustration of hash pointer chain.
  id: totrans-975
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Key point** Hash pointers can be used in any pointer based data structures
    that is without any cycles. If cycles are present in data structures then we won''t
    be able to make all the hashes match up. Clearly, in a structure with cycles,
    there is no end that we can start with and compute back from.'
  id: totrans-976
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Linked list: Linked list is one of the most popular data structures. Particularly,
    it is a sequence of blocks containing some information that is linked to immediate
    next block through a pointer. The pointer in each block contains the address of
    next block. The last block has a null pointer which implies it is not pointing
    to anything. A blockchain is basically a linked list containing data and a hash
    pointer pointing to previous block.'
  id: totrans-977
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Merkle tree: Another important data structure constructed using hash pointer
    is a binary tree. In particular, this binary tree linked with hash pointer is
    referred to as Merkle tree. This is the main foundation of blockchain concepts.
    Merkle tree also called hash tree is named after Ralph Merkle [[140](bib.xhtml#ch00-bib-140)].
    It is basically a tree structure where the nodes at leaf level contain the hash
    of the document and every intermediate node contains the hash of left and a right
    child. As it is presented in [Fig. 8.3](10chap_08.xhtml#fig8_3), there are 8 transactions,
    i.e., t1, t2,…………,t8\. Leaf nodes of the Merkle tree contain the direct hash of
    these transactions and then level 1 has intermediate nodes with hash value of
    its left and right child (,i.e., obtained hashes are again paired to calculate
    the hash for next level). This hash will be recursively calculated till a single
    root hash is obtained. It implies that any change in the transaction will be reflected
    in the hash value at every level including root hash value including root hash
    value. So, with a single hash value, i.e., root hash the transactions, the transactions
    can be collectively stored without fear of alteration in a block. Therefore, the
    Merkle hash tree makes sure that data stored on the blockchain remains undamaged
    and unaltered. In other words, Merkle hash preserves the integrity of the document.'
  id: totrans-978
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 8.3](../images/fig8_3.jpg)'
  id: totrans-979
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**FIGURE 8.3**'
  id: totrans-980
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Structure of Merkle tree.
  id: totrans-981
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Key point** To compute Merkle hash, Bitcoin uses SHA-256 hash.'
  id: totrans-982
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Tries: Tries is a ordered tree data structure to maintain set of strings. If
    two strings have a common prefix then they will have same ancestor in trie. Trie
    is an ideal data structure for storing dictionary. Also, it is used for encoding
    and decoding. Notably this is not similar to a binary tree whereas it is a N-Ary
    tree. Infact, tries support better searching than binary search tree and hash
    tables. Hash tables does not support prefix based search. Moreover, with tries
    it is easy to print all words in alphabetical order.'
  id: totrans-983
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A trie stores key-value pair where key is the path in the tree to reach its
    corresponding value. With tries, there is no restriction on number of children
    a node can have. However, all nodes descendants have a common prefix. In particular,
    each node can have up to 26 children. Each node's children are ordered alphabetically.
    It can thought of as a node that has a array of 26 size sitting inside. However,
    a better option is to have a linked list at each node to save space.
  id: totrans-984
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Unfortunately, tries require large memory for storing strings as for each node
    there are further many pointers. Also, a trie prooves inefficient if there is
    long key and o other key shares a common prefix. A standard trie take <math alttext=""
    display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>W</mi><mo stretchy="false">)</mo></mrow></math>
    space, where *W* is the total size of strings in a set. Insertion, deletion, and
    search operation of a trie takes <math alttext="" display="inline"><mrow><mi>O</mi><mo
    stretchy="false">(</mo><mi>l</mi><mo>*</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></math>
    where, *l* is average length of word and *n* is total number of words whereas
    the worst case runtime complexity for creating a trie is <math alttext="" display="inline"><mrow><mi>O</mi><mo
    stretchy="false">(</mo><mi>m</mi><mo>*</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></math>
    where, *m* is the longest word in the string and n is the total number number
    of words. For example, the trie data structure for set of string S=bear, bell,
    bid, bull, buy, sell, stock, stop is represented in [Fig. 8.4](10chap_08.xhtml#fig8_4).
  id: totrans-985
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.4](../images/fig8_4.jpg)'
  id: totrans-986
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**FIGURE 8.4**'
  id: totrans-987
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Illustration of trie data structure.
  id: totrans-988
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Patricia tree: Patricia stands for practical algorithm to retrieve information
    coded in alphanumeric. It is also based on fundamental that nodes with same prefix
    shares the same path (it is also called prefix tree). However, it requires low
    memory than trie data structure. It is actually a compact representation of a
    trie in which nodes having single child is merged with its parents. In other words,
    Patricia tree is similar to radix tree with the value of radix equal to 2\. In
    particular, Ethereum blockchain is based on Merkle-Patricia tree, which is a tree
    having root node that contains the hash value of whole data structures. [Fig.
    8.5](10chap_08.xhtml#fig8_5) represents the patricia tree for string S= bear,
    bell, bid, bull, buy, sell, stock, stop.'
  id: totrans-989
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 8.5](../images/fig8_5.jpg)'
  id: totrans-990
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**FIGURE 8.5**'
  id: totrans-991
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Illustration of patricia tree data structure.
  id: totrans-992
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Merkle Patricia trie: This data structure is a combination of Merkle tree and
    Patricia tree. Merkle tree is used to maintain data integrity whereas patricia
    tree in particular enables fast searching of information. These Merkle patricia
    also shows some form of verification and tamperproofing. Ethereum blockchain cryptocurrency
    uses Merkle patricia tree to store transaction and world state. Notably, Ethereum
    is quite different to Bitcoin as it uses smart contracts which keeps on updating
    everytime. Additionally, Ethereum rather than using one Merkle tree, it uses 3
    different Merkle tree to attain global state and to impose extra ability to query
    data within blockchain which are described as:'
  id: totrans-993
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'stateRoot: which specifies the state of the block.'
  id: totrans-994
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'transactionRoot: which specifies transaction hash in the block.'
  id: totrans-995
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'receiptRoot: which specify the amount of gas used in a block.'
  id: totrans-996
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In Ethereum all information of state is stored in key value pair. Keys are
    mainly string values that refers to search index. For example, account address
    is the key and balance is the value corresponding to the key. Merkle Patricia
    tree introduces 4 types of nodes which are described as follows:'
  id: totrans-997
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Empty node: These are simply blank nodes.'
  id: totrans-998
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Leaf node: It is the end node that signifies end of path in a tree. Leaf node
    will not have any further child and it always contains some value corresponding
    to a key. It is made up of two items, first corresponding to a suffix and second
    to any value.'
  id: totrans-999
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Branch node: It is a node having more than one branch. It is a 17 item structure
    where first 16 items are hexadecimal value (0—F) and 17 th items corresponds to
    a terminator node.'
  id: totrans-1000
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Extension node: It is a type of branch node but with one child. It is an optimized
    version of the branch node. It is a two item node where first portion signifies
    key part with size greater than one node and shared by atleast two different keys.
    Second part corresponds to a pointer to branch node.'
  id: totrans-1001
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Notably, to differentiate between leaf node and extension node, there is a concept
    of nibble. A nibble is added to the beginning of the key to differentiate both
    parity (even/odd length key) and terminator status (node is leaf or extension
    node). The lower significant bit signifies parity while next lowest tells terminator
    status. Moreover, if key length is even, an extra nibble is added to attain overall
    evenness. [Fig. 8.6](10chap_08.xhtml#fig8_6) shows illustration of Merkle Patricia
    tree.
  id: totrans-1002
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.6](../images/fig8_6.jpg)'
  id: totrans-1003
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**FIGURE 8.6**'
  id: totrans-1004
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Illustration of Merkle Patricia tree data structure.
  id: totrans-1005
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Binary heap: Binary heap comes under the category of a binary tree. Particularly,
    binary heap is a complete binary tree which implies each level except possibly
    the lowest one are completely filled and the lowest level is always filled from
    the left. Moreover, a binary heap is categorized as either a max-heap or a min
    heap as per the ordering property. In a max-heap, the key value stored in each
    node must be greater than equal to the key value in the node''s children. In contrast,
    in a min-heap, the key value stored in each node must be less than or equal to
    key value in the node''s children. Examples of min-heap and max-heap data structure
    is represented in [Figs. 8.7](10chap_08.xhtml#fig8_7) and [8.8](10chap_08.xhtml#fig8_8).
    Ethereum blockchain uses binary heap data structure to solve the block-gas-limit
    and iteration problem of Ethereum. Ethereum gas is the price for executing certain
    operations in Ethereum blockchain. For instance, all Ethereum transactions are
    paid by the sender of the transaction. In such cases, intentionally an attacker
    can consume more gas by running arbitrary smart contracts for an incoming transaction.
    Besides, when users of Ethereum network insert data in a smart contract, it can
    result in too much gas cost to iterate through. In particular, if a developer
    relies on array data structure, an attacker can fill the array to the mark where
    iterating via it can result in more gas cost than it should be used for a single
    transaction to execute. Clearly, a binary heap resolves this issue as this data
    structure does not demand iteration via all elements of the tree, rather it only
    iterates through tree''s height. Moreover, the self-balancing property of max
    heap preserves degenerating a tree which leads to *O(log n)* cost even for the
    worst case (for a total of *n* elements).'
  id: totrans-1006
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 8.7](../images/fig8_7.jpg)'
  id: totrans-1007
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**FIGURE 8.7**'
  id: totrans-1008
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Example of max-heap.
  id: totrans-1009
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.8](../images/fig8_8.jpg)'
  id: totrans-1010
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**FIGURE 8.8**'
  id: totrans-1011
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Example of min-heap.
  id: totrans-1012
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Activity
  id: totrans-1013
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Multiple Choice Questions
  id: totrans-1014
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Which of the following data structure is used in blockchain?
  id: totrans-1015
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Merkle hash tree
  id: totrans-1016
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Tries
  id: totrans-1017
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Binary tree
  id: totrans-1018
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: All of the above
  id: totrans-1019
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the main purpose of using hash pointers for connectivity in blockchain?
  id: totrans-1020
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To prevent modifications in block
  id: totrans-1021
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: To encrypt block
  id: totrans-1022
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: To decrypt block
  id: totrans-1023
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: To find nonce value of block
  id: totrans-1024
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which hashing algorithm is used by Bitcoin to compute Merkle hash?
  id: totrans-1025
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: MD4
  id: totrans-1026
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: MD5
  id: totrans-1027
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: SHA-256
  id: totrans-1028
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: All of these
  id: totrans-1029
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the total space taken by trie data structure with *w* as total size
    of string in a set?
  id: totrans-1030
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*O(w)*'
  id: totrans-1031
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '*O(w2)*'
  id: totrans-1032
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '*O(log w)*'
  id: totrans-1033
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: None of these
  id: totrans-1034
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What is other name for Patricia tree?
  id: totrans-1035
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Prefix tree
  id: totrans-1036
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Suffix tree
  id: totrans-1037
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Max heap
  id: totrans-1038
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Binary heap
  id: totrans-1039
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the main purpose of using merkle patricia tree?
  id: totrans-1040
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To prevent modifications in block
  id: totrans-1041
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: To encrypt block
  id: totrans-1042
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: To decrypt block
  id: totrans-1043
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: To find nonce value of block
  id: totrans-1044
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following node is a type of Merkle patricia tree?
  id: totrans-1045
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Leaf node
  id: totrans-1046
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Branch node
  id: totrans-1047
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Extension node
  id: totrans-1048
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: All of these
  id: totrans-1049
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Why does Ethereum uses binary heap data structure?
  id: totrans-1050
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To solve block gas limit and iteration problem
  id: totrans-1051
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: To solve PoS problem
  id: totrans-1052
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: To authenticate nodes on network
  id: totrans-1053
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: To generate more ethers
  id: totrans-1054
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Hash pointers can be used with any data structures with cycles?
  id: totrans-1055
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True'
  id: totrans-1056
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'False'
  id: totrans-1057
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the main purpose of using Merkle hash tree?
  id: totrans-1058
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To preserve integrity of block
  id: totrans-1059
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: To decrypt a block
  id: totrans-1060
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: To encrypt a block
  id: totrans-1061
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: To find nonce value
  id: totrans-1062
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 1\. d  2\. a  3\. c  4\. a  5\. a  6\. a  7\. d  8\. a  9\. b  10\. a
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
