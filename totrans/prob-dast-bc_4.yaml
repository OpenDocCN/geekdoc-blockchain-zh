- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: '[Part II](contents.xhtml#rpart2)'
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[第二部分](contents.xhtml#rpart2)'
- en: '[Blockchain Overview](contents.xhtml#rpart2)'
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[区块链概述](contents.xhtml#rpart2)'
- en: </hgroup>
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: <hgroup>
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: '[4](contents.xhtml#rchapter4)'
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[第 4 章](contents.xhtml#rchapter4)'
- en: '[Python Basics](contents.xhtml#rchapter4)'
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[Python 基础知识](contents.xhtml#rchapter4)'
- en: </hgroup>
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '[4.1 Introduction](contents.xhtml#rsec4_1)'
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[4.1 简介](contents.xhtml#rsec4_1)'
- en: 'Python is a high-level programming language used for general-purpose programming,
    developed by Guido Van Rossum in 1991\. Python is specially designed to be highly
    readable as it uses frequent English keywords. Python is frequently used to create
    software and web applications on a server. Some of the important features of Python
    are described as follows:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Python 是一种用于通用编程的高级编程语言，由 Guido Van Rossum 在 1991 年开发。Python 特别设计为高度可读，因为它使用频繁的英语关键字。Python
    经常用于在服务器上创建软件和 Web 应用程序。Python 的一些重要特性如下：
- en: It supports concepts of object-oriented programming.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持面向对象编程的概念。
- en: It can be easily integrated with some other programming languages including
    C, C++, Java, Common Object Request Broker Architecture (CORBA), etc.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以很容易地与其他编程语言集成，包括 C、C++、Java、公共对象请求代理体系结构（CORBA）等。
- en: Python is scalable as it better supports large programs than shell scripting.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 是可伸缩的，因为它比 Shell 脚本更好地支持大型程序。
- en: Python relies highly on indentation, here whitespace is used to define scope.
    Due to its strong structuring constructs, it supports clear writing and logical
    application.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 高度依赖缩进，其中空格用于定义作用域。由于其强大的结构化构造，它支持清晰的编写和逻辑应用。
- en: Python can be easily connected to all major commercial databases.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 可以很容易地连接到所有主要的商业数据库。
- en: Python is portable as it runs on a wide variety of hardware platforms.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 是可移植的，因为它可以在多种硬件平台上运行。
- en: Python supports interactive mode which enables interactive testing and debugging
    of code.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 支持交互模式，可以进行代码的交互测试和调试。
- en: Python supports high-level dynamic data types and dynamic type checking.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 支持高级动态数据类型和动态类型检查。
- en: Python is a scripting language as it is suitable for embedding and for writing
    small unstructured scripts.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 是一种脚本语言，因为它适合嵌入和编写小型的非结构化脚本。
- en: 'Python programs are much shorter in length than equivalent C, C++ programs
    for the following reasons:'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 程序的长度比等效的 C、C++ 程序要短得多，原因如下：
- en: The complex operations can be expressed in a single statement with the support
    of high level data type in Python.
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复杂的操作可以在单个语句中用 Python 的高级数据类型来表达。
- en: Use of indentation rather than using beginning and ending brackets.
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用缩进而不是开始和结束括号。
- en: Declaration of variables and arguments is not important.
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量和参数的声明并不重要。
- en: '**Note:** Python is a compiled and interpreted programming language. The source
    code first gets compiled to a bytecode then that bytecode is interpreted as machine
    language on Python virtual machine to give actual output. The concept of bytecode
    achieves portability. However, to execute Python code, each time Python programs
    code is required.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意：** Python 是一种编译和解释的编程语言。源代码首先被编译成字节码，然后该字节码在 Python 虚拟机上解释为机器语言以生成实际输出。字节码的概念实现了可移植性。然而，要执行
    Python 代码，每次都需要 Python 程序代码。'
- en: After writing the program, save the program with .py in a text editor. Further,
    execute that file in Python interpreter. Nevertheless, typing commands in Python
    interpreter is a good way to play with Python features but it is not suggested
    for solving more complex problems.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 编写程序后，请在文本编辑器中将程序保存为 .py 文件。此外，将该文件在 Python 解释器中执行。然而，在 Python 解释器中键入命令是玩弄 Python
    特性的好方法，但不建议用于解决更复杂的问题。
- en: The rest of this chapter discusses various important features of Python language
    with examples starting with simple statements, expressions, data types to concepts
    of classes, objects, functions, file handling, etc. Let's start Python programming.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的其余部分讨论了 Python 语言的各种重要特性，从简单语句、表达式、数据类型到类、对象、函数、文件处理等概念的示例。让我们开始 Python 编程。
- en: '[4.2 Comments](contents.xhtml#rsec4_2)'
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[4.2 注释](contents.xhtml#rsec4_2)'
- en: Comments in Python are represented with a “#”. Everything written after “#”
    in a line is ignored. Notably, comments are not interpreted by Python language.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中的注释用“#”表示。在“#”之后的所有内容都将被忽略。值得注意的是，注释不会被 Python 语言解释。
- en: '![](../images/list4_1.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/list4_1.jpg)'
- en: 'Output: 5'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：5
- en: '[4.3 Multi-line Statement](contents.xhtml#rsec4_3)'
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[4.3 多行语句](contents.xhtml#rsec4_3)'
- en: 'To denote that line should continue, (multi-line statement) Python allows the
    use of line continuation character, i.e., Ḟor example:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了表示行应继续（多行语句），Python 允许使用行继续字符，即，例如：
- en: '![](../images/list4_2.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/list4_2.jpg)'
- en: '[4.4 Blocks and Indentation](contents.xhtml#rsec4_4)'
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[4.4 块和缩进](contents.xhtml#rsec4_4)'
- en: 'Python depicts blocks and nested blocks structure with indentation not by using
    beginning and end brackets. Advantages of using indentation include reducing need
    for coding standard, reducing inconsistency, and reducing work. The number of
    count spaces in indentation is variable but within a block each and every statement
    must be indented the equal amount. For example:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Python 用缩进而不是使用起始和结束括号来表示块和嵌套块结构。使用缩进的优点包括减少编码标准的需求，减少不一致性，并减少工作量。缩进的空格数是可变的，但在一个块内，每个语句都必须缩进相同的数量。例如：
- en: '![](../images/list4_3.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/list4_3.jpg)'
- en: 'The following code will generate an error:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将生成一个错误：
- en: '![](../images/list4_4.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/list4_4.jpg)'
- en: '[4.5 Creating Variables and Assigning Values](contents.xhtml#rsec4_5)'
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[4.5 创建变量并赋值](contents.xhtml#rsec4_5)'
- en: Variables are used to store values at a reserved memory location. After creating
    a variable, a space in memory is reserved. Unlike other programming languages,
    there is no need to declare variables explicitly. After assigning a value to a
    variable, use that variable in place of value. The equal sign is used to assign
    value to a variable. Python strings are expressed in single quotes or double quotes
    with same results. Print statement is used to display the value of a variable.
    For example, the statements
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 变量用来在保留的内存位置存储值。创建变量后，将保留内存中的空间。与其他编程语言不同，不需要显式声明变量。将值赋给变量后，使用该变量代替值。等号用于将值赋给变量。Python字符串用单引号或双引号表示，结果相同。打印语句用于显示变量的值。例如，以下语句
- en: '![](../images/list4_5.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/list4_5.jpg)'
- en: 'Output: 100'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：100
- en: hello
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你好
- en: h
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: h
- en: Variables can have a variable length and they can be arbitrarily long. A variable
    can have both letters and numbers, however, they can't start with a number.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 变量的长度可以变化，并且可以任意长。变量可以包含字母和数字，但不能以数字开头。
- en: '[4.6 Data Types](contents.xhtml#rsec4_6)'
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[4.6 数据类型](contents.xhtml#rsec4_6)'
- en: 'Variables can store data in different types. Numbers, strings, lists, tuple,
    dictionaries are the standard data types. Python number data types store numeric
    value. For example:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 变量可以存储不同类型的数据。数字、字符串、列表、元组、字典是标准数据类型。Python数字数据类型存储数值。例如：
- en: a=1, b=2.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: a=1, b=2.
- en: 'Python includes three different numeric types, i.e., int, float, complex. In
    contrast, a string is made of a sequence of characters. However, strings in Python
    are immutable, which implies it can''t be changed. Strings are declared with single
    or double character. For example: a=”abc”. Rest of the data types are discussed
    further in this chapter. type() function is used to get the data type of any variable.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Python包括三种不同的数值类型，即int、float、complex。相比之下，字符串由一系列字符组成。但是，Python中的字符串是不可变的，这意味着它不能被改变。字符串用单引号或双引号声明。例如：a=”abc”。本章将进一步讨论其余的数据类型。type()函数用于获取任何变量的数据类型。
- en: '![](../images/list4_6.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/list4_6.jpg)'
- en: 'Output: str'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：str
- en: int
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 整数
- en: float
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点
- en: list
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 列表
- en: '[4.7 Operators](contents.xhtml#rsec4_7)'
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[4.7 运算符](contents.xhtml#rsec4_7)'
- en: 'Similar to other programming languages, Python supports the following operator
    groups:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于其他编程语言，Python支持以下运算符组：
- en: Arithmetic operator
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算术运算符
- en: Comparison operator
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较运算符
- en: Assignment operator
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 赋值运算符
- en: Logical operator
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逻辑运算符
- en: Bitwise operator
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位运算符
- en: Membership operator
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成员运算符
- en: Identity operator
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 身份运算符
- en: '[4.7.1 Arithmetic operator](contents.xhtml#rsec4_7_1)'
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[4.7.1 算术运算符](contents.xhtml#rsec4_7_1)'
- en: 'This category includes mathematical operations, such as- addition(+), subtraction(-),
    division(/), modulus(%), and power(**). For example:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 此类别包括数学运算，如- 加法(+), 减法(-), 除法(/), 取模(%), 幂(**)。例如：
- en: '![](../images/list4_7.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/list4_7.jpg)'
- en: 'Output:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '14'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '14'
- en: '6'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '6'
- en: '40'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '40'
- en: '2.5'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '2.5'
- en: '2'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: '10000'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '10000'
- en: '[4.7.2 Comparison operator](contents.xhtml#rsec4_7_2)'
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[4.7.2 比较运算符](contents.xhtml#rsec4_7_2)'
- en: 'This operator is used to compare values and returns either true or false as
    per the condition. This category includes greater than(>), less than(<), equal
    to(==), not equal to(!=), greater than equal to(≥), and less than equal to(≤).
    For example:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 此运算符用于比较值，并根据条件返回真或假。此类别包括大于(>)、小于(<)、等于(==)、不等于(!=)、大于等于(≥)和小于等于(≤)。例如：
- en: '![](../images/list4_8.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/list4_8.jpg)'
- en: 'Output:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: a is not equal to b
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: a 不等于 b
- en: a is not equal to b
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: a 不等于 b
- en: a is not less than b
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: a 不小于 b
- en: a is greater than b
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: a 大于 b
- en: a is neither less than nor equal to b
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: a 既不小于也不等于 b
- en: b is neither greater than nor equal to b
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: b 既不大于也不等于 b
- en: '[4.7.3 Logical operator](contents.xhtml#rsec4_7_3)'
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[4.7.3 逻辑运算符](contents.xhtml#rsec4_7_3)'
- en: 'This category performs logical AND (and), logical OR(or), and logical NOT (not).
    For example:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 此类别执行逻辑 AND (and)、逻辑 OR (or) 和逻辑 NOT (not)。例如：
- en: '![](../images/list4_9.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/list4_9.jpg)'
- en: 'Output:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: 'False'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 假
- en: 'True'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 真
- en: 'False'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 假
- en: '[4.7.4 Python Bitwise operator](contents.xhtml#rsec4_7_4)'
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[4.7.4 Python 位运算符](contents.xhtml#rsec4_7_4)'
- en: It performs bit-by-bit operation. Bitwise operator includes Bitwise AND(&),
    Bitwise OR(∨), Bitwise NOT(¬), Bitwise XOR(⊕), Bitwise right shift(≫), and Bitwise
    left shift (≪).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 它执行按位操作。位运算符包括按位与(&)，按位或(∨)，按位非(¬)，按位异或(⊕)，按位右移(≫)和按位左移(≪)。
- en: '![](../images/list4_10.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/list4_10.jpg)'
- en: 'Output:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '0'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '14'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '14'
- en: −11
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: −11
- en: '14'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '14'
- en: '2'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: '40'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '40'
- en: '[4.7.5 Assignment operator](contents.xhtml#rsec4_7_5)'
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[4.7.5 赋值运算符](contents.xhtml#rsec4_7_5)'
- en: 'This operator is used to assign values to a variables. The available assignment
    operators are:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 此运算符用于将值分配给变量。可用的赋值运算符包括：
- en: '=: Assigns values from right side of operands to left side of operand'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '=: 将右侧操作数的值赋给左侧操作数'
- en: '+=: Adds the right operand with the left operand and assigns result to the
    left operand'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '+=: 将右操作数加到左操作数并将结果赋给左操作数'
- en: '-=: Subtracts the right operand from left operand and then assigns to the left
    operand'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '-=: 将右操作数从左操作数中减去，然后将结果赋给左操作数'
- en: '*=: Multiplies the right operand with the left operand and assigns to the left
    operand'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*=: 将右操作数乘以左操作数并赋给左操作数'
- en: :̄ Divides the left operand with right operand and then assigns the result to
    the left operand
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: :̄ 将左操作数除以右操作数，然后将结果赋给左操作数
- en: '%=: Takes modulus using left and right operands and assigns the result to the
    left operand'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '%=: 使用左右操作数取模，并将结果赋给左操作数'
- en: '**=: Performs exponential calculation on operators and assigns the value to
    the left operand'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**=: 对运算符执行指数运算，并将值赋给左操作数'
- en: '![](../images/list4_11a.jpg)![](../images/list4_11b.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/list4_11a.jpg)![](../images/list4_11b.jpg)'
- en: 'Output:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: Value of var3 is 31
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: var3 的值为 31
- en: Value of var3 is 52
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: var3 的值为 52
- en: Value of var3 is 1092
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: var3 的值为 1092
- en: Value of var3 is 52
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: var3 的值为 52
- en: Value of var3 is 2
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: var3 的值为 2
- en: Value of var3 is 2097152
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: var3 的值为 2097152
- en: '[4.7.6 Membership operator](contents.xhtml#rsec4_7_6)'
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[4.7.6 成员运算符](contents.xhtml#rsec4_7_6)'
- en: 'This operator is used to check for membership of an element in a sequence.
    There are two membership operators discussed below:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '-   这个运算符用于检查序列中元素的成员资格。下面讨论了两个成员运算符：'
- en: 'in: Results to true if element is present in the sequence otherwise false'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '-   in：如果元素存在于序列中，则结果为真，否则为假'
- en: 'not in: Results to true if element is not a member of the sequence, otherwise
    false'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '-   not in：如果元素不是序列的成员，则结果为真，否则为假。'
- en: 'For example:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '-   例如：'
- en: '![](../images/list4_12.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '-   ![](../images/list4_12.jpg)'
- en: 'Output:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '-   '
- en: a is not present in the given list
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '-   a 不在给定的列表中'
- en: b is not present in the given list
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '-   b 不在给定的列表中'
- en: '[4.7.7 Identity Operators](contents.xhtml#rsec4_7_7)'
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '-   [4.7.7 身份运算符](contents.xhtml#rsec4_7_7)'
- en: These operators are used to compare two memory locations, i.e., to check whether
    two values are located in same part of memory. There are two identical operators
    in Python.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '-   这些运算符用于比较两个内存位置，即检查两个值是否位于内存的同一部分。Python 中有两个相同的运算符。'
- en: 'is: Returns true if operands are identical'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '-   is：如果操作数相同，则返回真'
- en: 'is not: Returns true if operands are not identical'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '-   is not：如果操作数不相同，则返回真'
- en: '![](../images/list4_13.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '-   ![](../images/list4_13.jpg)'
- en: 'Output:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '-   输出：'
- en: a and b have same identity
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '-   a 和 b 有相同的标识'
- en: '[4.8 Input and Output in Python](contents.xhtml#rsec4_8)'
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '-   [4.8 Python 中的输入和输出](contents.xhtml#rsec4_8)'
- en: The built-in input() function is used to take user input from the keyboard.
    The parameters inside parentheses prompt for the keyboard input. The input function
    automatically identifies whether it is a string, number, or list that is entered
    by the user. However when an input is entered, first it is converted to a string.
    Even an integer value is converted integer using typecasting.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '-   内置的 input() 函数用于从键盘接受用户输入。括号内的参数提示键盘输入。input() 函数会自动识别用户输入的是字符串、数字还是列表。然而，当输入被输入时，首先将其转换为字符串。即使输入整数值，也会使用类型转换将其转换为整数。'
- en: '![](../images/list4_14.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '-   ![](../images/list4_14.jpg)'
- en: Suppose the user has entered abc as name.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '-   假设用户输入了 abc 作为名称。'
- en: 'Output: Hello abc'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '-   输出：Hello abc'
- en: The way to produce output is by using print() function by passing no or more
    expression separated by a comma. Print with no parameters, i.e., print() is to
    advance to next line. By default, Python print() function ends with a new line,
    i.e., print() function will go to next line automatically.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '-   生成输出的方式是使用 print() 函数，通过逗号分隔的零个或多个表达式。不带参数的 print()，即 print() 是为了换行。默认情况下，Python
    的 print() 函数以新行结束，即 print() 函数会自动进入下一行。'
- en: '![](../images/list4_15.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '-   ![](../images/list4_15.jpg)'
- en: 'Output:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '-   输出：'
- en: one
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '-   one'
- en: two
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '-   two'
- en: '[4.9 List](contents.xhtml#rsec4_9)'
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '-   [4.9 列表](contents.xhtml#rsec4_9)'
- en: Lists are a powerful feature of Python. They are the same as arrays. The list
    is a data type used to declare a sequence. Lists are declared with comma separated
    items in a square brackets. To access list items, index number is used. Notably,
    list might have items of different types. A list can have strings, integers, as
    well as objects. Also, lists can be altered even after declaration.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 列表是 Python 的一个强大特性。它们与数组相同。列表是用于声明序列的数据类型。列表用方括号内的逗号分隔的项目声明。要访问列表项，使用索引号。值得注意的是，列表可能包含不同类型的项目。列表可以包含字符串、整数以及对象。此外，列表在声明后也可以更改。
- en: '![](../images/list4_16.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/list4_16.jpg)'
- en: 'Output: Banana'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：香蕉
- en: '![](../images/list4_17.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/list4_17.jpg)'
- en: 'Output:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: 22, ‘Banana’, 5, 6
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 22、'香蕉'、5、6
- en: 22, ‘Banana’, 5
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 22、'香蕉'、5
- en: '5'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: '**Note:** Tuple is same as list with a difference that tuples are immutable,
    i.e., after declaration they can''t be changed.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意：** 元组与列表相同，唯一的区别在于元组是不可变的，即，在声明后它们不能被更改。'
- en: '[4.10 Dictionary](contents.xhtml#rsec4_10)'
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[4.10 字典](contents.xhtml#rsec4_10)'
- en: Python dictionaries has keys and values and is written with curly brackets.
    However, keys should be unique within a dictionary while values can be same. To
    access any item, use keys name inside square brackets.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Python 字典具有键和值，并用大括号编写。然而，字典中的键应该是唯一的，而值可以相同。要访问任何项，请在方括号内使用键名。
- en: '![](../images/list4_18.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/list4_18.jpg)'
- en: 'Output: 10'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：10
- en: '[4.11 Python Conditions and if-else](contents.xhtml#rsec4_11)'
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[4.11 Python 条件和 if-else](contents.xhtml#rsec4_11)'
- en: Python if-else statements are used with logical conditions, such as- equal,
    not equal, less than equal to, greater than equal to, greater than, and less than.
    If statement is specified using the if keyword.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的 if-else 语句与逻辑条件一起使用，如等于、不等于、小于等于、大于等于、大于和小于。如果语句使用 if 关键字指定。
- en: '![](../images/list4_19.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/list4_19.jpg)'
- en: 'Output: value of b is greater than a'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：b 的值大于 a
- en: '**Key point** Python uses indentation to define scope'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '**重点** Python 使用缩进来定义作用域'
- en: Further, elif keyword is used to check if previous condition is not true then
    try with this condition and else executes if any of the preceding conditions get
    false. greater than equal to, greater than, and less than. Elif statement is specified
    using elif keyword.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，elif 关键字用于检查前一个条件是否不成立，然后尝试此条件，如果任何前面的条件为假，则执行 else。大于等于、大于和小于。Elif 语句使用
    elif 关键字指定。
- en: '![](../images/list4_20.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/list4_20.jpg)'
- en: 'Output: value of b is greater than a'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：b 的值大于 a
- en: '[4.12 Loops](contents.xhtml#rsec4_12)'
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[4.12 循环](contents.xhtml#rsec4_12)'
- en: 'Generally, statements of any programming language are executed sequentially.
    However, there may be a situation when there is need to execute different paths.
    A block of loop allows to execute one or more than one statement multiple times.
    Python supports two loop commands:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，任何编程语言的语句都是按顺序执行的。但是，可能存在需要执行不同路径的情况。循环块允许多次执行一个或多个语句。Python 支持两个循环命令：
- en: While loop
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: While 循环
- en: For loop
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: For 循环
- en: '**While loop**: While loop is used to execute a statement or a block of statement
    until given conditions are satisfied. After the statements get false, the very
    first statement after while gets executed.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**While 循环**：While 循环用于执行语句或语句块，直到满足给定条件。在语句变为 false 后，while 之后的第一条语句将被执行。'
- en: '![](../images/list4_21.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/list4_21.jpg)'
- en: 'Output:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '0'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '1'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '2'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: '3'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: '4'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: Goodbye
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 再见
- en: While can be used with else statement as well
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: While 也可以与 else 语句一起使用
- en: '![](../images/list4_22.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/list4_22.jpg)'
- en: 'Output:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '0'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '1'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '2'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: '3'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: '4'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: Goodbye
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 再见
- en: '**For loop**: In Python the for loop is used for sequential traversal, e.g.,
    a list or an array.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**For 循环**：在 Python 中，for 循环用于顺序遍历，例如，列表或数组。'
- en: '![](../images/list4_23.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/list4_23.jpg)'
- en: 'Output:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: apple
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果
- en: mango
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 芒果
- en: banana
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 香蕉
- en: '![](../images/list4_24.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/list4_24.jpg)'
- en: 'Output:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: 0,1,2,3,4
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 0,1,2,3,4
- en: '[4.13 Functions in Python](contents.xhtml#rsec4_13)'
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[4.13 Python 中的函数](contents.xhtml#rsec4_13)'
- en: A function is a block of statements that take some input, perform some computation,
    and produces output. Basically, functions are used to ease repeatedly done tasks
    together. Functions are executed when called. There are some build-in functions
    in Python such as- print() and also one can create functions using def keyword.
    To call a function, use the name of that function followed by a parenthesis.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是一组语句块，接受一些输入，执行一些计算，并产生输出。基本上，函数用于将重复执行的任务组合在一起。函数在调用时执行。Python 中有一些内置函数，例如-
    print()，也可以使用 def 关键字创建函数。要调用函数，请使用该函数的名称，后跟括号。
- en: '![](../images/list4_25.jpg)![](../images/list4_26.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/list4_25.jpg)![](../images/list4_26.jpg)'
- en: 'Output:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: Odd
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 奇数
- en: Even
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 偶数
- en: '[4.14 Classes and Objects in Python](contents.xhtml#rsec4_14)'
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[4.14 Python 中的类和对象](contents.xhtml#rsec4_14)'
- en: As previously discussed, Python is an object-oriented language. A class is similar
    to an object constructor or like a blueprint for creating objects while object
    is a copy of class with actual values. Classes ease bundling of data and functionality
    together. Each class holds its own data members and member function which can
    be accessed using objects. Nevertheless, a class can have many objects. Attributes
    of a class are always public and are accessed using the dot (.) operator. To create
    a class keyword class is used.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面讨论的，Python 是一种面向对象的语言。类似于对象构造函数或创建对象的蓝图的类，而对象是带有实际值的类的副本。类易于将数据和功能捆绑在一起。每个类都保存其自己的数据成员和成员函数，可以使用对象访问。尽管如此，一个类可以有许多对象。类的属性始终是公共的，并且可以使用点
    (.) 运算符访问。要创建一个类，使用关键字 class。
- en: '![](../images/list4_27.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/list4_27.jpg)'
- en: 'output: 5'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：5
- en: '![](../images/list4_28a.jpg)![](../images/list4_28b.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/list4_28a.jpg)![](../images/list4_28b.jpg)'
- en: 'Output:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: animal
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 动物
- en: I am a animal
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我是一个动物
- en: I am a dog
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我是一只狗
- en: To create real-life applications, we need to understand a special function called
    init() which is an initialization method to create a new instance of the class.
    In particular, the init() method is used to assign values to object properties
    when the object is created.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建现实生活中的应用程序，我们需要了解一个特殊的函数，称为 `init()`，它是创建类的新实例的初始化方法。特别是，当对象被创建时，`init()`
    方法用于为对象属性赋值。
- en: '![](../images/list4_29.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/list4_29.jpg)'
- en: 'output:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: John
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 约翰
- en: '36'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '36'
- en: '[4.15 File Handling in Python](contents.xhtml#rsec4_15)'
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[Python 中的文件处理](contents.xhtml#rsec4_15)'
- en: A file has a location on disk with some stored information. Like Java and C++,
    Python also supports file handling and enables users to handle files by reading
    and writing them. Each line of code in the file includes a sequence of characters.
    Also, each line ends with a special terminator called end of line (EOL) which
    tells the interpreter that a new line has begun. Most of the file manipulations
    are done using a file object.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 文件在磁盘上有一个位置，并带有一些存储的信息。与 Java 和 C++ 一样，Python 也支持文件处理，并允许用户通过读取和写入来处理文件。文件中的每行代码都包含一系列字符。此外，每行都以特殊的终止符号结尾，称为行结束符（EOL），告诉解释器新的一行已经开始。大多数文件操作都使用文件对象完成。
- en: '[4.15.1 open() function](contents.xhtml#rsec4_15_1)'
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[4.15.1 open() 函数](contents.xhtml#rsec4_15_1)'
- en: 'Clearly before reading or writing a file, one must open it first. To open a
    file in order to read or write, open() function is used. The open() function creates
    a file object and takes two arguments, i.e., file name and mode. Syntax:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，在读取或写入文件之前，必须首先打开它。要打开文件以进行读取或写入，使用 `open()` 函数。`open()` 函数创建一个文件对象，并接受两个参数，即文件名和模式。语法：
- en: '*open(filename; mode)*'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '*open(filename; mode)*'
- en: 'mode field tells how the file can be opened. For example:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`mode` 字段指示文件如何被打开。例如：'
- en: 'r: Opens a file for reading only'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: r：只读方式打开文件
- en: 'rb: Opens a file for read-only purpose in binary format'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: rb：以二进制格式仅用于读取的方式打开文件
- en: 'w: opens a file for writing only'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: w：只写方式打开文件
- en: 'r+: Opens a file for both reading and writing in binary format'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: r+：以二进制格式同时用于读取和写入的方式打开文件
- en: 'wb: Opens a file for write only purpose in binary format'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: wb：以二进制格式仅用于写入的方式打开文件
- en: 'a: Opens file for append'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: a：以追加的方式打开文件
- en: 'a+: Opens a file for both appending and reading'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: a+：以追加和读取的方式打开文件
- en: If the file with specified name does not exist, it will throw an error of FileNotFoundError.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果指定名称的文件不存在，则会引发 FileNotFoundError 错误。
- en: '[4.15.2 close() function](contents.xhtml#rsec4_15_2)'
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[4.15.2 close() 函数](contents.xhtml#rsec4_15_2)'
- en: close() method closes the file object and refrains any further action on that
    file.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`close()` 方法关闭文件对象，并阻止对该文件的进一步操作。'
- en: 'Syntax:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 语法：
- en: fileObject.close()
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`fileObject.close()`'
- en: '![](../images/list4_30.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/list4_30.jpg)'
- en: 'output:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: 'Name of the file: foo.txt'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 文件名称：foo.txt
- en: '[4.15.3 read() function](contents.xhtml#rsec4_15_3)'
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[4.15.3 read() 函数](contents.xhtml#rsec4_15_3)'
- en: This function reads a string from an open file.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数从打开的文件中读取一个字符串。
- en: 'Syntax:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 语法：
- en: '*fileObject:read([count])*'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '*fileObject:read([count])*'
- en: The count parameter specifies the number of bytes to be read from the specified
    file. If the count parameter is missing, the file is read until the end of the
    file.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 计数参数指定从指定文件中读取的字节数。 如果缺少计数参数，则文件将读取直到文件的末尾。
- en: '![](../images/list4_31.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/list4_31.jpg)'
- en: 'output:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: The first 10 characters from the file named foo.txt.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 来自名为 foo.txt 的文件的前 10 个字符。
- en: '[4.16 write() function](contents.xhtml#rsec4_16)'
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[4.16 write() 函数](contents.xhtml#rsec4_16)'
- en: This function allows user to write strings to an open file. Notably, write function
    does not add implicitly a newline character, i.e., to end of string.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数允许用户将字符串写入打开的文件。 值得注意的是，write函数不会隐式添加换行符，即字符串的末尾。
- en: 'Syntax:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 语法：
- en: '*fileObject:write(string)*'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '*fileObject:write(string)*'
- en: '![](../images/list4_32.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/list4_32.jpg)'
- en: 'output:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: Python is a high level language
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: Python 是一种高级语言
- en: Python follows OOPS concepts
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: Python遵循OOPS概念
- en: Activity
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动
- en: Multiple Choice Questions
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多项选择题
- en: How do you insert comments in Python code?
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何在Python代码中插入注释？
- en: \ *This is a comment* \
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: \ *这是一个注释* \
- en: '#This is a comment'
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: ＃这是一个注释
- en: “This is a comment”
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: “这是一个注释”
- en: None of these
  id: totrans-259
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些都不是
- en: Which one is NOT a legal variable name?
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个不是合法的变量名？
- en: abc
  id: totrans-261
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: abc
- en: 10abc
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 10abc
- en: _abc
  id: totrans-263
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: _abc
- en: abc_abc
  id: totrans-264
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: abc_abc
- en: What is the value of the following Python Expression?
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下Python表达式的值是多少？
- en: '9.0'
  id: totrans-266
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '9.0'
- en: '9'
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '9'
- en: '4.0'
  id: totrans-268
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '4.0'
- en: '4'
  id: totrans-269
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '4'
- en: What is the output of the following code?
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码的输出是什么？
- en: x = 100
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: x = 100
- en: y = 50
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: y = 50
- en: print(x and y)
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 打印（x 和 y）
- en: 'True'
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真
- en: 'False'
  id: totrans-275
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假
- en: '100'
  id: totrans-276
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '100'
- en: '50'
  id: totrans-277
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '50'
- en: What is a correct syntax to output “hello world” in Python?
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是在Python中输出“hello world”的正确语法？
- en: print(“hello world”)
  id: totrans-279
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: print(“hello world”)
- en: echo(“hello word”)
  id: totrans-280
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: echo(“hello word”)
- en: put(“hello word”)
  id: totrans-281
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: put(“hello word”)
- en: None of these
  id: totrans-282
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些都不是
- en: What is the correct file extension for Python files?
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Python文件的正确文件扩展名是什么？
- en: .py
  id: totrans-284
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: .py
- en: .python
  id: totrans-285
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: .python
- en: .pyt
  id: totrans-286
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: .pyt
- en: None of these
  id: totrans-287
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些都不是
- en: What will be the output of the following code ?
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码的输出是什么？
- en: print type(type(int))
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 打印类型（类型（int））
- en: type ‘int’
  id: totrans-290
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类型‘int’
- en: type ‘type’
  id: totrans-291
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类型‘类型’
- en: error
  id: totrans-292
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误
- en: '0'
  id: totrans-293
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '0'
- en: Suppose listA is [31, 41, 5, 20, 5, 125, 1, 3], what is list1 after listA.pop(1)?
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设 listA 是 [31, 41, 5, 20, 5, 125, 1, 3]，那么 list1.pop(1) 后 list1 的值是什么？
- en: 31, 41, 5, 20, 5, 125, 1, 3
  id: totrans-295
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 31, 41, 5, 20, 5, 125, 1, 3
- en: 31, 41, 5, 20, 5, 125, 1
  id: totrans-296
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 31, 41, 5, 20, 5, 125, 1
- en: 31, 41, 5, 20, 5, 125, 1, 3, 3
  id: totrans-297
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 31, 41, 5, 20, 5, 125, 1, 3, 3
- en: None of these
  id: totrans-298
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些都不是
- en: What is the output of the following program?
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下程序的输出是什么？
- en: j = 0
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: j = 0
- en: 'while i ≤ 5:'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: while i ≤ 5：
- en: print j
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: print j
- en: j++
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: j++
- en: print j+1
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 打印 j+1
- en: 0 2 1 3 2 4
  id: totrans-305
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 0 2 1 3 2 4
- en: Error
  id: totrans-306
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误
- en: 5 4 3 2 1
  id: totrans-307
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 5 4 3 2 1
- en: None of these
  id: totrans-308
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些都不是
- en: What does <math alttext="" display="inline"><mo>¬</mo><mo>¬</mo><mo>¬</mo><mo>¬</mo><mo>¬</mo><mo>¬</mo></math>
    5 evaluate to?
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <math alttext="" display="inline"><mo>¬</mo><mo>¬</mo><mo>¬</mo><mo>¬</mo><mo>¬</mo><mo>¬</mo></math>
    5 的值是多少？
- en: '+5'
  id: totrans-310
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '+5'
- en: '-5'
  id: totrans-311
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '-5'
- en: '10'
  id: totrans-312
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '10'
- en: '11'
  id: totrans-313
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '11'
- en: 1\. b  2\. b  3\. a  4\. d  5\. d  6\. a  7\. b  8\. b  9\. b (there is no ++
    operator in Python)  10\. a
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. b  2\. b  3\. a  4\. d  5\. d  6\. a  7\. b  8\. b  9\. b（Python 中没有 ++
    运算符）  10\. a
- en: <hgroup>
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: '[5](contents.xhtml#rchapter5)'
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[5](contents.xhtml#rchapter5)'
- en: '[Cryptography Primitives](contents.xhtml#rchapter5)'
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[密码学原理](contents.xhtml#rchapter5)'
- en: </hgroup>
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '[5.1 Introduction](contents.xhtml#rsec5_1)'
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[5.1 介绍](contents.xhtml#rsec5_1)'
- en: Confidentiality, integrity, availability also referred to as CIA triad, is the
    model developed to define policies for achieving information security (Refer [Fig.
    5.1](07chap_05.xhtml#fig5_1)). Along with this non-repudiation and authentication
    are the other security attributes to be achieved by a Peer-to-peer (P2P) network.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 保密性、完整性、可用性也被称为CIA三元模型，是用于定义实现信息安全政策的模型（参见[图5.1](07chap_05.xhtml#fig5_1)）。除此之外，不可否认和身份验证是P2P网络需要实现的其他安全属性。
- en: 'Confidentiality: Confidentiality signifies that information, data, and resources
    are protected from any unauthorized parties. Data encryption, and passwords are
    the common method of ensuring confidentiality.tcolorbox'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保密性：保密性表示信息、数据和资源受到未经授权的各方的保护。数据加密和密码是确保保密性的常见方法。tcolorbox
- en: '**Key Points** Confidentiality is similar to the word privacy; however, they
    are not interchangeable. In fact, confidentiality is an extension of privacy that
    pertains to identifiable data.'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**要点** 保密性类似于隐私一词；但它们不能互换使用。事实上，保密性是隐私的延伸，涉及可识别数据。'
- en: 'Integrity: This attribute signifies the protection of information from unauthorized
    alteration. Integrity ensures accuracy and completeness of data. Access control
    mechanism, checksum, and hashing are some measures to ensure the integrity of
    data.'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完整性：此属性表示保护信息免受未经授权的更改。完整性确保数据的准确性和完整性。访问控制机制、校验和和哈希是确保数据完整性的一些措施。
- en: 'Availability: This attribute ensures access to information when needed by authorized
    parties. If a server/system remains available preventing service disruption and
    uninterrupted access, this signifies high availability. Disruption of service
    even for a short time can cause loss of revenue, customer disappointment, and
    organization repudiation damage. Among all availability attacks, DoS is the most
    frequently used by hackers. Proxy servers, firewalls, and routers are the countermeasures
    to ensure the availability of data.'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用性：此属性确保授权方在需要时能够访问信息。如果服务器/系统保持可用状态，防止服务中断并保持不间断访问，这表示高可用性。即使短时间的服务中断也可能导致收入损失、客户失望和组织声誉受损。在所有可用性攻击中，DoS是黑客最常使用的攻击方式。代理服务器、防火墙和路由器是确保数据可用性的对策。
- en: 'Non-repudiation: This attribute ensures that the sender of the data can''t
    later deny having sent the data and recipients can''t deny having received the
    data. In legal terms, repudiation signifies denial of something that is true.
    Digital signatures, timestamps, hash functions are some of the ways to obtain
    non-repudiation.'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可否认性：此属性确保数据的发送者不能否认后来发送了数据，接收者也不能否认收到了数据。在法律术语中，否认意味着否认某事是真实的。数字签名、时间戳、哈希函数是获得不可否认性的一些方法。
- en: 'Authentication: It is an act of identifying an individual. However, authentication
    does not claim about the access rights of the individual. In particular, authentication
    confirms the user''s identity.'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证：这是识别个人的行为。然而，认证并不涉及个人的访问权限。特别是，认证确认用户的身份。
- en: '![Figure 5.1](../images/fig5_1.jpg)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: '![图5.1](../images/fig5_1.jpg)'
- en: '**FIGURE 5.1**'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '**图5.1**'
- en: CIA triad of information security.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 信息安全的CIA三元素。
- en: Notably, cryptography plays a very important role in ensuring the attainment
    of these above-mentioned security attributes. Next, we will discuss the basic
    cryptographic primitives. We will start by discussing the details of cryptographic
    hash functions followed by discussing the concept of digital signatures.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，密码学在确保上述安全属性的实现中发挥着非常重要的作用。接下来，我们将讨论基本的密码原语。我们将首先讨论密码散列函数的细节，然后讨论数字签名的概念。
- en: '[5.2 Encryption/Decryption Process](contents.xhtml#rsec5_2)'
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[5.2 加密/解密过程](contents.xhtml#rsec5_2)'
- en: '[5.2.1 Encryption](contents.xhtml#rsec5_2_1)'
  id: totrans-332
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[5.2.1 加密](contents.xhtml#rsec5_2_1)'
- en: Encryption is the process of transforming original data into an unrecognisable
    form. Data is usually encrypted to save it from stealing. Encryption is performed
    by the sender.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 加密是将原始数据转换为不可识别形式的过程。数据通常是加密的，以免被窃取。加密由发送方执行。
- en: '[5.2.2 Decryption](contents.xhtml#rsec5_2_2)'
  id: totrans-334
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[5.2.2 解密](contents.xhtml#rsec5_2_2)'
- en: In contrast to encryption, decryption is the process of converting cipher text
    back to plain text. Decryption is done at the receiving side.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 与加密相反，解密是将密文转换回明文的过程。解密在接收方执行。
- en: '[5.2.3 Symmetric key encryption](contents.xhtml#rsec5_2_3)'
  id: totrans-336
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[5.2.3 对称密钥加密](contents.xhtml#rsec5_2_3)'
- en: This type of encryption uses the same cryptographic key for both encrypting
    plaintext and decrypting ciphertext.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的加密使用相同的密码密钥来加密明文和解密密文。
- en: '[5.2.4 Asymmetric key encryption](contents.xhtml#rsec5_2_4)'
  id: totrans-338
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[5.2.4 非对称密钥加密](contents.xhtml#rsec5_2_4)'
- en: This encryption process involves 2 pairs of keys. Here, both sender and receiver
    have a pair of public and private keys. The public key is used to encrypt plaintext
    whereas the private key is used for decryption purpose. To accomplish many cryptographic
    tasks public and private keys are used.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 此加密过程涉及2对密钥。在这里，发送方和接收方都有一对公钥和私钥。公钥用于加密明文，而私钥用于解密目的。为了完成许多密码任务，使用公钥和私钥。
- en: '[5.2.5 Public key](contents.xhtml#rsec5_2_5)'
  id: totrans-340
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[5.2.5 公钥](contents.xhtml#rsec5_2_5)'
- en: 'The public key is published for all other users to see. Public keys are generated
    using typical asymmetric algorithm to match them against the associated private
    key. The most popular algorithm used for creating public key are: RSA, ECC, and
    digital signature application (DSA). These mentioned algorithms are based on a
    heavy computation method to create random numeric combinations of different lengths
    to prevent them against brute force attack. The length of the key depicts strength
    of protection. The large key size assures more cryptographic security to prevent
    hackers from preventing them.'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 公钥是为所有其他用户公开的。公钥使用典型的非对称算法生成，以便与关联的私钥匹配。用于创建公钥的最流行算法有：RSA、ECC 和数字签名应用（DSA）。这些提到的算法基于重型计算方法，以创建不同长度的随机数字组合，以防止暴力破解攻击。密钥的长度决定了保护的强度。较大的密钥尺寸能够提供更多的密码安全，以防止黑客阻止它们。
- en: '[5.2.6 Private key](contents.xhtml#rsec5_2_6)'
  id: totrans-342
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[5.2.6 私钥](contents.xhtml#rsec5_2_6)'
- en: In contrast to public key, private key is a secret key that is only known to
    the owner of the key. Private keys are created using same algorithms that create
    public key.tcolorbox
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 与公钥相反，私钥是仅由密钥所有者知晓的秘密密钥。私钥是使用创建公钥的相同算法创建的。
- en: '**Key point** The private key is used for decryption, digitally signing, and
    authentication whereas a public key is used for encryption, verification of digital
    signatures, and authentication.'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键点** 私钥用于解密、数字签名和身份验证，而公钥用于加密、验证数字签名和身份验证。'
- en: '[5.3 Cryptographic Hash Functions](contents.xhtml#rsec5_3)'
  id: totrans-345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[5.3 密码哈希函数](contents.xhtml#rsec5_3)'
- en: A cryptographic hash function <math alttext="" display="inline"><mrow><mo stretchy="false">(</mo><mi>H</mi><mo
    stretchy="false">)</mo></mrow></math> takes an variable length input or message
    <math alttext="" display="inline"><mrow><mo stretchy="false">(</mo><mi>M</mi><mo
    stretchy="false">)</mo></mrow></math> and produces a fixed size output called
    hash values or message digest <math alttext="" display="inline"><mrow><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">)</mo></mrow></math>, i.e. as represented in [Fig. 5.2](07chap_05.xhtml#fig5_2)
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 密码哈希函数 <math alttext="" display="inline"><mrow><mo stretchy="false">(</mo><mi>H</mi><mo
    stretchy="false">)</mo></mrow></math> 接受可变长度的输入或消息 <math alttext="" display="inline"><mrow><mo
    stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo></mrow></math> 并产生固定大小的输出，称为哈希值或消息摘要
    <math alttext="" display="inline"><mrow><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">)</mo></mrow></math>，如在 [图 5.2](07chap_05.xhtml#fig5_2) 中所示。
- en: <math alttext="" display="block"><mrow><mtable columnalign="left"><mtr columnalign="left"><mtd
    columnalign="left"><mrow><mi>h</mi><mo>=</mo><mi>H</mi><mo stretchy="false">(</mo><mi>M</mi><mo
    stretchy="false">)</mo></mrow></mtd></mtr></mtable></mrow></math>(5.1)
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="" display="block"><mrow><mtable columnalign="left"><mtr columnalign="left"><mtd
    columnalign="left"><mrow><mi>h</mi><mo>=</mo><mi>H</mi><mo stretchy="false">(</mo><mi>M</mi><mo
    stretchy="false">)</mo></mrow></mtd></mtr></mtable></mrow></math>(5.1)
- en: Generally, the size of message digest is smaller than the actual input data.
    Therefore, the hash function is sometimes referred to as compression function.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，消息摘要的大小小于实际输入数据。因此，哈希函数有时被称为压缩函数。
- en: '![Figure 5.2](../images/fig5_2.jpg)'
  id: totrans-349
  prefs: []
  type: TYPE_IMG
  zh: '![图5.2](../images/fig5_2.jpg)'
- en: '**FIGURE 5.2**'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '**图5.2**'
- en: Block diagram of cryptographic hash function.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 密码哈希函数的块图。
- en: Key Points
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 要点
- en: A hash function follows the many-to-one property and thus faces collision.
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哈希函数遵循多对一的特性，因此可能会发生碰撞。
- en: In blockchain, the size of message digest is 256 bits.
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在区块链中，消息摘要的大小为256比特。
- en: Hash functions are efficiently computable as this calculations as these calculation
    does not need a significant amount of resources.
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哈希函数的计算效率很高，因为这些计算不需要大量资源。
- en: A good hash function produces evenly distributed output.
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个好的哈希函数会产生均匀分布的输出。
- en: Even a single bit change in M will change the complete hash code.
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使是对M的单比特变化也会改变完整的哈希码。
- en: '[5.3.1 Typical properties of a hash function](contents.xhtml#rsec5_3_1)'
  id: totrans-358
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[5.3.1 哈希函数的典型特性](contents.xhtml#rsec5_3_1)'
- en: It should be completely difficult to reverse a hash function, i.e., for a given
    hash value *h[1]*, it should be hard process to find input *M[1]* that exactly
    hashes to *h[1]*. This property is called irreversibility or pre-image resistance.
    Also, this type of hash function is called one-way function.
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于给定的哈希值*h[1]*，找到确切散列为*h[1]*的输入*M[1]*应该是一种困难的过程。这种属性称为不可逆性或前像抗性。此类哈希函数也称为单向函数。
- en: For a given input and its corresponding hash, it should be computationally difficult
    to find a different input having same hash, i.e., for a input *M[1]* having hash
    value *h[1]*, it should be hard to find any other input *M[2]* such that <math
    alttext="" display="inline"><mrow><mi>H</mi><mo stretchy="false">(</mo><msub><mi>M</mi><mn>1</mn></msub><mo
    stretchy="false">)</mo><mo>=</mo><mi>H</mi><mo stretchy="false">(</mo><msub><mi>M</mi><mn>2</mn></msub><mo
    stretchy="false">)</mo></mrow></math>. This property of hash functions is called
    second-image resistance.
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于给定的输入及其对应的哈希，要计算出具有相同哈希的不同输入应该是计算上困难的，即，对于具有哈希值*h[1]*的输入*M[1]*，很难找到任何其他输入*M[2]*，使得<math
    alttext="" display="inline"><mrow><mi>H</mi><mo stretchy="false">(</mo><msub><mi>M</mi><mn>1</mn></msub><mo
    stretchy="false">)</mo><mo>=</mo><mi>H</mi><mo stretchy="false">(</mo><msub><mi>M</mi><mn>2</mn></msub><mo
    stretchy="false">)</mo></mrow></math>成立。哈希函数的这种特性称为第二图像抗性。
- en: Another important property of hash functions is known as collision free property
    which states that if two messages are different, then there message digest will
    also be different, i.e., if two messages *M[1]*, *M[2]* are not equal (*M1 <math
    alttext="" display="inline"><mo>≠</mo></math> M2*), then <math alttext="" display="inline"><mrow><mi>H</mi><mo
    stretchy="false">(</mo><msub><mi>M</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>≠</mo><mi>H</mi><mo
    stretchy="false">(</mo><msub><mi>M</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow></math>.
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哈希函数的另一个重要属性是无碰撞性，它表明如果两个消息不同，那么它们的消息摘要也将不同，即，如果两个消息 *M[1]*、*M[2]* 不相等（*M1 <math
    alttext="" display="inline"><mo>≠</mo></math> M2*），那么 <math alttext="" display="inline"><mrow><mi>H</mi><mo
    stretchy="false">(</mo><msub><mi>M</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>≠</mo><mi>H</mi><mo
    stretchy="false">(</mo><msub><mi>M</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow></math>。
- en: Given two messages *M[1]*, *M[2]*, and a hash function *h*, it is difficult
    to find a value *k* such that <math alttext="" display="inline"><mrow><msub><mi>M</mi><mn>2</mn></msub><mo>=</mo><mi>h</mi><mo
    stretchy="false">(</mo><msub><mi>M</mi><mn>1</mn></msub><mi mathvariant="normal">‖</mi><mi>k</mi><mo
    stretchy="false">)</mo></mrow></math>. This property of hash functions is called
    puzzle friendliness.
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定两个消息 *M[1]*、*M[2]*，和一个哈希函数 *h*，要找到一个值 *k*，使得 <math alttext="" display="inline"><mrow><msub><mi>M</mi><mn>2</mn></msub><mo>=</mo><mi>h</mi><mo
    stretchy="false">(</mo><msub><mi>M</mi><mn>1</mn></msub><mi mathvariant="normal">‖</mi><mi>k</mi><mo
    stretchy="false">)</mo></mrow></math> 是困难的。哈希函数的这种属性称为难题友好性。
- en: '[5.3.2 Requirements of hash function:](contents.xhtml#rsec5_3_2)'
  id: totrans-363
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[5.3.2 哈希函数的要求:](contents.xhtml#rsec5_3_2)'
- en: '**One way:** Once hash is calculated it can''t be used to restore the original
    document. For example, like a human being fingerprint, one can''t retrieve the
    looks of a person from human fingerprint.'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单向性:** 一旦计算出哈希值，就不能用它来恢复原始文档。例如，就像人类的指纹一样，不能通过指纹来还原一个人的外貌。'
- en: '**Deterministic:** It states that if two similar documents are passed through
    a hash algorithm, it should always generate the same hash.'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**确定性:** 它表明，如果两个相似的文档通过同一个哈希算法，它们应始终生成相同的哈希值。'
- en: '**Avalanche effect:** It states that even changing one bit in the document,
    hash of the changed document should be significantly different from hash of the
    original document.'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**雪崩效应:** 它表明，即使在文档中改变一个比特，改变后的文档的哈希值应显著不同于原始文档的哈希值。'
- en: '**Must withstand collision:** It implies that the hash function should have
    collision resistance property.'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**必须经受住碰撞:** 这意味着哈希函数应具有碰撞抗性属性。'
- en: '[5.3.3 Applications of cryptographic hash functions](contents.xhtml#rsec5_3_3)'
  id: totrans-368
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[5.3.3 密码哈希函数的应用](contents.xhtml#rsec5_3_3)'
- en: 'Password storage: Whenever a user creates an account with user name, ID, and
    password, the ID provider does not store the password. Instead, the provider pass
    the password from a hashing algorithm and only stores hash of the password. Every
    time user attempts to log-in, the provider hashes the password entered by the
    user and compares it against the saved hash. The provider has a password file
    that has table of pairs in form [User ID1*h(P1*)] for a given user id (ID1) and
    password (P1). If the two hashes match, only then authorization is provided to
    the account otherwise not. The whole process has been depicted in [Fig. 5.3](07chap_05.xhtml#fig5_3).'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密码存储：每当用户使用用户名、ID 和密码创建帐户时，ID 提供者不会存储密码。相反，提供者通过哈希算法传递密码，并且仅存储密码的哈希值。每当用户尝试登录时，提供者对用户输入的密码进行哈希处理，并将其与保存的哈希值进行比较。提供者有一个密码文件，该文件包含以
    [用户 ID1*h(P1*)] 格式的对表，用于给定的用户 ID（ID1）和密码（P1）。如果两个哈希值匹配，则授权提供给该帐户，否则不提供。整个过程已在[图
    5.3](07chap_05.xhtml#fig5_3)中描述。
- en: '![Figure 5.3](../images/fig5_3.jpg)'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 5.3](../images/fig5_3.jpg)'
- en: '**FIGURE 5.3**'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**图 5.3**'
- en: Password storage using hash functions.
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用哈希函数进行密码存储。
- en: 'Data integrity check: One of the very popular applications of hash function
    is data integrity check. This way, hash functions can assure correctness of the
    data, i.e., user can detect any modifications, insertions, and deletions made
    to the original file.'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据完整性检查：哈希函数的一个非常流行的应用是数据完整性检查。通过这种方式，哈希函数可以保证数据的正确性，即用户可以检测到对原始文件进行的任何修改、插入和删除。
- en: '**Case 1:**'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**情况 1:**'
- en: The message <math alttext="" display="inline"><mrow><mo stretchy="false">(</mo><mi>M</mi><mo
    stretchy="false">)</mo></mrow></math> along with computed hash value of *M* is
    encrypted with symmetric encryption. Encryption ensures confidentiality of the
    message. To check integrity of the message, First, the decryption is applied to
    the received encrypted block and the message from the block is then extracted.
    Next, apply the same hash algorithm to the message M and the computed hash value
    is matched against the received hash value. The whole process has been shown in
    [Fig. 5.4](07chap_05.xhtml#fig5_4).
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 消息<math alttext="" display="inline"><mrow><mo stretchy="false">(</mo><mi>M</mi><mo
    stretchy="false">)</mo></mrow></math>与*M*的计算哈希值一起使用对称加密进行加密。加密确保了消息的机密性。为了检查消息的完整性，首先，对接收到的加密块应用解密，然后从块中提取消息。接下来，对消息*M*应用相同的哈希算法，计算得到的哈希值与接收到的哈希值进行匹配。整个过程已在[图
    5.4](07chap_05.xhtml#fig5_4)中显示。
- en: '![Figure 5.4](../images/fig5_4.jpg)'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 5.4](../images/fig5_4.jpg)'
- en: '**FIGURE 5.4**'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**图 5.4**'
- en: Data integrity check with message encryption.
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用消息加密进行数据完整性检查。
- en: '**Case 2:**'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**情况 2:**'
- en: In some cases, only the hash code is encrypted in order to reduce the burden
    for applications that don't demand confidentiality. To check the integrity of
    the message, decrypt the hash received with secret key and compute hash digest
    from the message and compare it with the received hash digest from the source.
    The whole process has been shown in [Fig. 5.5](07chap_05.xhtml#fig5_5).
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在某些情况下，仅对哈希代码进行加密，以减轻不需要机密性的应用程序的负担。要检查消息的完整性，请使用密钥解密收到的哈希，然后从消息计算哈希摘要，并将其与源中收到的哈希摘要进行比较。整个过程已在[图
    5.5](07chap_05.xhtml#fig5_5)中显示。
- en: '![Figure 5.5](../images/fig5_5.jpg)'
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 5.5](../images/fig5_5.jpg)'
- en: '**FIGURE 5.5**'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**图 5.5**'
- en: Data integrity check without message encryption.
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不进行消息加密的数据完整性检查。
- en: '[5.3.4 MD5 message-digest algorithm](contents.xhtml#rsec5_3_4)'
  id: totrans-384
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[5.3.4 MD5 消息摘要算法](contents.xhtml#rsec5_3_4)'
- en: Message-Digest algorithm 5 (MD5) is an extension of Message-Digest algorithm
    4 (MD4) and is developed by Ron Rivest in 1991\. However, MD5 is a little slower
    than MD4 but assures better security over MD4\. In particular, it is used to verify
    the integrity of the data. Also, it is used as DSA by compressing a large file
    in a secure way before encrypting the file with private key. This hashing algorithm
    takes input of arbitrary length and produces a 128-bit fingerprint as output.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 消息摘要算法 5（MD5）是消息摘要算法 4（MD4）的扩展，由 Ron Rivest 在 1991 年开发。但是，MD5 比 MD4 稍慢，但确保比
    MD4 更好的安全性。特别地，它用于验证数据的完整性。此外，在使用私钥加密文件之前，通过将大文件压缩到安全方式中使用作为 DSA。此哈希算法接受任意长度的输入，并生成
    128 位的指纹作为输出。
- en: 'The fundamentals of MD5 are based on Merkle Damgard schema. This algorithm
    process data in 512-bit block and each block is broken into 16 blocks, each of
    32 bit. The stepwise working of MD5 to produce 128-bit output is defined as follows:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: MD5 的基础是 Merkle-Damgard 结构。该算法以 512 位块处理数据，每个块被分成 16 个 32 位块。MD5 产生 128 位输出的逐步工作定义如下：
- en: '**Append padding bits:** Padding implies adding some extra bits to original
    message. Here, message is padded such that total bit length is 64 less than exact
    multiple of 512\. In order to pad the first bit is 1 and rest bits are 0\. For
    example, for a message of 1000 bits, 472 bits are padded (1000 + 472 = 1472 which
    is 64 bit less than multiple of 512.)'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**追加填充位：** 填充意味着向原始消息添加一些额外位。在这里，消息被填充以使总位长度比精确的 512 的倍数少 64 位。为了填充，第一个位是 1，其余位是
    0。例如，对于 1000 位的消息，填充了 472 位（1000 + 472 = 1472，比 512 的倍数少 64 位）。'
- en: '**Append length:** After padding, insert 64 bit at the end by calculating length
    of original message mod 264\. Hence, the resulting message is multiple of 512
    bits.'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**追加长度：** 在填充后，通过计算原始消息的长度 mod 264，在末尾插入 64 位。因此，结果消息是 512 位的倍数。'
- en: '**Dividing the message:** Divide the resulting message in 512 bit block.'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分割消息：** 将得到的消息分成 512 位的块。'
- en: '**Initialize MD buffer:** A four word buffer is initialized next. The four
    buffer namely (A, B, C, D) are 32-bit registers and its values are predefined.
    Notably, the final output in these buffer only.'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**初始化MD缓冲区：**接下来初始化一个四字缓冲区。这四个缓冲区分别为(A、B、C、D)，都是32位寄存器，并且其值是预定义的。值得注意的是，最终的输出只存在于这些缓冲区中。'
- en: '**Process message in 16 word block:** Each block of 512 bit is processed in
    4 rounds and for each round four functions F, G, H, I are used. Further, each
    round consists of 16 steps using some constants. Hence, a total of 64 operations
    are performed for each 512 bit and the output from this block is fed to the next
    block as value of A, B, C, D.'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在16字块中处理消息：**每个512位的块在4轮中处理，并且每轮都使用四个函数F、G、H、I。此外，每轮由16个步骤组成，使用一些常量。因此，每个512位的块会执行总共64次操作，此块的输出作为A、B、C、D的值被传递到下一个块中。'
- en: '[5.3.5 SHA-256](contents.xhtml#rsec5_3_5)'
  id: totrans-392
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[5.3.5 SHA-256](contents.xhtml#rsec5_3_5)'
- en: 'Blockchain bitcoin mining makes use of a special type of hash function called
    SHA-256 and this hash function generates 256-bit message digest. SHA stands for
    secure hashing algorithm. SHA-256 also operates similar to MD4, MD5 as SHA-1\.
    Computation of hash function begins by first preprocessing the message. For preprocessing:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链比特币挖掘利用了一种特殊类型的哈希函数，称为SHA-256，此哈希函数生成256位的消息摘要。SHA代表安全哈希算法。SHA-256的操作方式也类似于MD4、MD5和SHA-1\.
    哈希函数的计算首先从对消息进行预处理开始。预处理包括：
- en: 'First, the message is padded so that total message size becomes multiple of
    512 bits. For this follow:'
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，对消息进行填充，以使总消息大小成为512位的倍数。为此，请执行以下操作：
- en: Lets assume that message has length *l* in bits and *l*mod512 ≠ 0.
  id: totrans-395
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设消息的长度*l*以位为单位，且*l*mod512 ≠ 0。
- en: Append a bit with value 1 at the end of the message.
  id: totrans-396
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在消息的末尾附加一个值为1的位。
- en: Next, append k zero bits such that l+1+k ≡ 448mod512.
  id: totrans-397
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，附加k个零位，使得l+1+k ≡ 448mod512。
- en: After this append a 64-bit block having value *l* written in binary. This length
    is appended in order to avoid trivial collisions. To extract original message
    read last 64 bit (for calculating the length of message) and next start fetching
    bits from left to right till observed length.
  id: totrans-398
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在此之后附加一个值为*l*的64位块，该长度以二进制形式书写。为了避免平凡的冲突，会追加这个长度。要提取原始消息，请读取最后的64位（用于计算消息的长度），然后从左到右开始获取位。
- en: The resultant length of the message after padding should be multiple of 512
    bits.
  id: totrans-399
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 填充后消息的结果长度应为512位的倍数。
- en: For example, the given message is ‘abc’.
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，给定消息为‘abc’。
- en: It has length 24 (8*3).
  id: totrans-401
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的长度为24（8*3）。
- en: First it is padded with a one at the end of message.
  id: totrans-402
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，消息在末尾填充一个1。
- en: Next, 448-(24+1) zeros are appended, i.e., 423 zeros.
  id: totrans-403
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，附加448-(24+1)个零位，即，423个零位。
- en: 'Finally, 64 bit block having 24 written in binary is appended which results
    in:'
  id: totrans-404
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，附加一个以二进制写入的值为24的64位块，结果为：
- en: <math alttext="" display="block"><mrow><mn>011000101100010011000111</mn><munder><munder><mrow><mn>00.....0</mn></mrow><mo
    stretchy="true">︸</mo></munder><mrow><mn>423</mn><mtext>times</mtext></mrow></munder><munder><munder><mrow><mn>00.....011000</mn></mrow><mo
    stretchy="true">︸</mo></munder><mrow><mn>64</mn><mtext>bit</mtext></mrow></munder><mo>.</mo></mrow></math>
  id: totrans-405
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <math alttext="" display="block"><mrow><mn>011000101100010011000111</mn><munder><munder><mrow><mn>00.....0</mn></mrow><mo
    stretchy="true">︸</mo></munder><mrow><mn>423</mn><mtext>times</mtext></mrow></munder><munder><munder><mrow><mn>00.....011000</mn></mrow><mo
    stretchy="true">︸</mo></munder><mrow><mn>64</mn><mtext>bit</mtext></mrow></munder><mo>.</mo></mrow></math>
- en: Now, result has length 512 bits.
  id: totrans-406
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，结果的长度为512位。
- en: Next, parse the original message *M*, into *N* blocks of 512 bit each, i.e.,
    M1, M2,………., MN.
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，将原始消息*M*解析为512位的*N*个块，即，M1、M2、………、MN。
- en: After this, each 512-bit block is divided into 16 sub blocks <math alttext=""
    display="inline"><mrow><msubsup><mi>M</mi><mn>0</mn><mi>i</mi></msubsup></mrow></math>,
    <math alttext="" display="inline"><mrow><msubsup><mi>M</mi><mn>1</mn><mi>i</mi></msubsup></mrow></math>,…….,
    <math alttext="" display="inline"><mrow><msubsup><mi>M</mi><mrow><mn>15</mn></mrow><mi>i</mi></msubsup></mrow></math>
    with each having length of 32 bit.
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个512位块分成16个子块<math alttext="" display="inline"><mrow><msubsup><mi>M</mi><mn>0</mn><mi>i</mi></msubsup></mrow></math>,
    <math alttext="" display="inline"><mrow><msubsup><mi>M</mi><mn>1</mn><mi>i</mi></msubsup></mrow></math>,…….,
    <math alttext="" display="inline"><mrow><msubsup><mi>M</mi><mrow><mn>15</mn></mrow><mi>i</mi></msubsup></mrow></math>，每个子块的长度为32位。
- en: Each message block is processed one at a time. To process each block initialize
    with a fixed hash value, h0 of 256 bit also called the initialization vector (IV).
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个消息块逐个处理。为了处理每个块，初始化一个256位的固定哈希值，也称为初始化向量（IV），表示为 h0。
- en: 'Next, sequentially compute:'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，依次计算：
- en: <math alttext="" display="inline"><mrow><msup><mi>H</mi><mi>i</mi></msup><mo>=</mo><msup><mi>h</mi><mrow><mo
    stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msup><mo>+</mo><msubsup><mi>C</mi><mi>M</mi><mi>i</mi></msubsup><mo
    stretchy="false">(</mo><msup><mi>H</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo
    stretchy="false">)</mo></mrow></msup><mo stretchy="false">)</mo></mrow></math>
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <math alttext="" display="inline"><mrow><msup><mi>H</mi><mi>i</mi></msup><mo>=</mo><msup><mi>h</mi><mrow><mo
    stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msup><mo>+</mo><msubsup><mi>C</mi><mi>M</mi><mi>i</mi></msubsup><mo
    stretchy="false">(</mo><msup><mi>H</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo
    stretchy="false">)</mo></mrow></msup><mo stretchy="false">)</mo></mrow></math>
- en: where, C is compression function and + is addition modulo 2^(32).
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 其中，C 是压缩函数，+ 表示模 2^(32) 的加法。
- en: '[5.4 Digital Signatures](contents.xhtml#rsec5_4)'
  id: totrans-413
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[5.4 数字签名](contents.xhtml#rsec5_4)'
- en: The digital signature is another important fundamental behind secured blockchain
    architecture. It is a cryptographic method to validate the authenticity and integrity
    of data. Along with this, digital signatures prevent non-repudiation, i.e., the
    sender can't deny for the origin of the document. Digital signatures work similar
    to the physical signatures; however, they are electronic signatures. Nevertheless,
    the signing authority can only sign the document and anyone having a valid key
    can verify the signatures. Also, the signatures of one document cannot be transferred
    from one document to another.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 数字签名是安全区块链架构背后的另一个重要基础。它是一种验证数据真实性和完整性的加密方法。数字签名还防止了抵赖，即发送方无法否认文档的来源。数字签名的工作方式类似于物理签名；然而，它们是电子签名。然而，签署权限仅限于签署文档的权限，并且拥有有效密钥的任何人都可以验证签名。此外，一个文档的签名不能转移到另一个文档。
- en: Digital signatures are realized with the concept of asymmetric key cryptography
    (Public-key cryptography). Asymmetric key cryptography uses two different keys,
    i.e., a public key and a private key. The public key is known to the user only
    whereas the private key is known to everyone in the universe. For preserving the
    confidentiality of data, the data to be transferred is encrypted using the public
    key of the receiver whereas the private key is used at the destination node to
    decrypt the message.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 数字签名是通过非对称密钥加密（公钥密码术）的概念实现的。非对称密钥加密使用两把不同的密钥，即公钥和私钥。公钥只有用户知道，而私钥则为宇宙中所有人所知。为了保持数据的机密性，待传输的数据使用接收方的公钥加密，而在目标节点上使用私钥解密。
- en: '[5.4.1 Model of digital signature](contents.xhtml#rsec5_4_1)'
  id: totrans-416
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[5.4.1 数字签名模型](contents.xhtml#rsec5_4_1)'
- en: 'To generate digital signatures, the message is signed using the private key
    of the sender and at the destination side, signatures are verified using the public
    key of the sender. However, by integrating the concept of cryptographic hash with
    digital signatures, the size of digital signatures can be reduced. So, rather
    than signing the original message, the message digest is signed. The following
    steps are taken in generating the digital signatures:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成数字签名，使用发送者的私钥对消息进行签名，在目标端使用发送者的公钥验证签名。然而，通过将密码哈希的概念与数字签名集成，可以减小数字签名的大小。因此，与签署原始消息相比，签署消息摘要。生成数字签名的步骤如下所示：
- en: First, hash the message (*M*) to obtain message digest *h(M)*. Next, the generated
    hash is signed using the private key of the sender which results in digital signatures.
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，对消息(*M*)进行哈希处理以获取消息摘要*h(M)*。接下来，使用发送者的私钥对生成的哈希进行签名，结果是数字签名。
- en: Next, the message and the digital signature are transferred over the channel.
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，消息和数字签名通过通道传输。
- en: Receiver after receiving the particular digital signatures, decrypt it using
    the public key of the sender (This assures the **authenticity** of the sender).
    After applying the decryption algorithm, the receiver will get the message digest
    *h(M)*.
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接收者在收到特定数字签名后，使用发送者的公钥对其进行解密（这确保了发送者的**真实性**）。应用解密算法后，接收者将获得消息摘要*h(M)*。
- en: Simultaneously, from the original message received receiver, will compute the
    hash of it. Let's call this value *h’(M)*.
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同时，接收到原始消息的接收者将计算其哈希值。我们称此值为*h’(M)*。
- en: If *h(M)*=*h’(M)*, the **integrity** of the original document is preserved.
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果*h(M)*=*h’(M)*，则原始文档的**完整性**得以保留。
- en: As it is assumed that only signer of the document knows the private key, so
    no other can generate the signature of the signer. Hence, it ensures **non-repudiation**
    attribute.
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于只有文档签署者知道私钥，因此其他人无法生成签名者的签名。因此，它确保**不可否认**属性。
- en: The whole process of generating hash function has been depicted in [Fig. 5.6](07chap_05.xhtml#fig5_6).
    Therefore, by applying the hash function, the size of the signature can be reduced.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 5.6](07chap_05.xhtml#fig5_6)中描述了生成哈希函数的整个过程。因此，通过应用哈希函数，可以减小签名的大小。
- en: '![Figure 5.6](../images/fig5_6.jpg)'
  id: totrans-425
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.6](../images/fig5_6.jpg)'
- en: '**FIGURE 5.6**'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 5.6**'
- en: Digital signatures.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 数字签名。
- en: Key points
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 关键点
- en: A cryptographic key should be prevented from being guessed by others. However,
    it is assumed that the cryptographic algorithm is known to everyone.
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密码学密钥应防止他人猜测。但是，假设密码算法为所有人所知。
- en: The key should have sufficient length as a key with long length is difficult
    to guess as compared to short length key.
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密钥的长度应足够长，因为与短长度密钥相比，长长度密钥难以猜测。
- en: The key should be truly randomly generated with sufficient entropy.
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密钥应该以足够的熵真正随机生成。
- en: '[5.5 Zero-Knowledge Proof](contents.xhtml#rsec5_5)'
  id: totrans-432
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[5.5 零知识证明](contents.xhtml#rsec5_5)'
- en: Another concept that is associated with blockchain is zero-knowledge proof.
    It is a cryptographic method to prove to the verifier that prover knows a value
    without actually revealing any data except revealing the fact that prover knows
    the value. By simply, generating the final output, the prover is supposed to prove
    that they can compute something without telling the computational process whereas
    the verifier only knows the output.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 与区块链相关的另一个概念是零知识证明。这是一种加密方法，可以向验证者证明证明者知道一个值，而实际上不透露任何数据，除了透露证明者知道该值的事实。简单地说，通过生成最终输出，证明者应该证明他们可以计算某些东西，而不告诉计算过程，而验证者只知道输出。
- en: 'For example, A wants to prove B that he/she knows the key without disclosing
    secret key to B, and B verifies that A is actually having the key. Hence, they
    have the capability to revolutionize the way of data handling, collection, and
    the way data is transacted with. Zero-knowledge proof has 3 important properties:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，A 想向 B 证明他/她知道密钥而不向 B 泄露秘密密钥，并且 B 验证 A 实际拥有密钥。因此，它们有能力彻底改变数据处理、收集的方式，以及数据交易的方式。零知识证明具有
    3 个重要特性：
- en: 'Completeness: If the fact is true, the prover should convince the verifier
    for this fact and zero knowledge proof should return true.'
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完整性：如果事实是真的，证明者应该说服验证者这一事实，并且零知识证明应该返回真。
- en: 'Soundness: If the fact/statement is false, the prover can''t convince the verifier
    that prover''s statement is true.'
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明的准确性：如果事实/声明是错误的，证明者不能说服验证者证明证明者的陈述是正确的。
- en: 'Zero-knowledge/Privacy: If the information provided by prover is true, no verifier
    learns any other information expect the fact that information is true. In other
    words, the provider information should not reveal anything else to the verifier.'
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 零知识/隐私：如果证明者提供的信息是真实的，没有验证者会得知除了该信息是真实的这一事实以外的其他信息。换句话说，提供者的信息不应向验证者透露其他内容。
- en: To better understand zero knowledge proof, let's take the popular and classic
    example of zero knowledge proof that is of **two balls and colour-blind friend**
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解零知识证明，让我们来看一个广为流传且经典的零知识证明示例，即**两个球和色盲朋友**。
- en: 'Suppose A has two identical balls having different colours (say one red and
    one green) and your friend B is colour blind which means B can''t differentiate
    between the balls based on their colour. However, A has to prove to B that two
    balls are of different colours. Nevertheless, A doesn''t want to reveal which
    is red and which is green. This is how proof system for this problem will work:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 A 有两个相同的球，颜色不同（比如一个红色和一个绿色），而你的朋友 B 是色盲的，这意味着 B 无法根据球的颜色区分它们。但是，A 必须向 B 证明两个球的颜色不同。然而，A
    不想透露哪个是红色，哪个是绿色。这就是这个问题的证明系统的工作原理：
- en: A will give both balls to B and puts both balls behind his back.
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: A 将两个球都给了 B，并把两个球都藏在背后。
- en: B then takes out one of the two balls from behind his/her back and shows it.
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后 B 从背后拿出两个球中的一个并展示给别人看。
- en: B then puts back the ball behind his/her back again and then reveal just one
    of the two balls, simply by picking one of the two balls at random with equal
    chances.
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: B再次把球放回他/她的背后，然后随机选择其中一个球，只有一个球会被展示出来，而且概率相同。
- en: Next, B asks A ”Did I switch the ball?”.
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，B问A：“我交换了球吗？”
- en: Third and fourth steps are repeated till B assures that there are two different
    colored balls. Obviously, by balls color A can certainly tell whether or not B
    switched them. Moreover, A could guess right with probability not higher than
    50% that whether the ball his switched or not if balls are having same color and
    therefore indistinguishable. If A and B repeats this process multiple times A
    will be caught if he/she lies.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 第三步和第四步一直重复，直到B确信有两个不同颜色的球。显然，通过球的颜色，A可以确定B是否交换了它们。此外，如果球的颜色相同且因此无法区分，那么A可以以不超过50%的概率猜测球是否被交换。如果A和B多次重复此过程，A如果撒谎就会被抓住。
- en: Clearly, the above proof system is zero knowledge as B will never learn which
    is green and which is red ball.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，上述证明系统是零知识的，因为B永远不会知道哪个是绿球，哪个是红球。
- en: 'Over and above, zero-knowledge proof has two variants: interactive and non-interactive
    zero-knowledge proof. In interactive proofs, the prover and the verifier exchange
    more than one message to prove or verify the information. It demands verifier
    to constantly ask questions about the knowledge the prover possesses. Unfortunately,
    the interactive zero knowledge proof has limited transferability. In contrast,
    non-interactive proof system demands no interaction between prover and verifier
    except a common reference string between both parties.'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，零知识证明有两个变体：交互式零知识证明和非交互式零知识证明。在交互式证明中，证明者和验证者交换多个消息来证明或验证信息。它要求验证者不断询问证明者所拥有的知识。不幸的是，交互式零知识证明的可转移性有限。相比之下，非交互式证明系统要求证明者和验证者之间没有交互，除了双方之间共同的参考字符串。
- en: Keypoint
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 关键点
- en: '**Zero knowledge proof application in blockchain:** Both of the popular blockchain
    use cases, i.e., Bitcoin and Ethereum are based on public addresses to depict
    the true identity of the user which maintains anonymity in the network. Notably,
    due to the distributed nature of the blockchain, interactive zero knowledge proof
    is not an efficient solution. Moreover, a real world use case of zero knowledge
    proof is Zcash that enables native transactions to be fully encrypted while being
    verified by network consensus rule and Zcash is a non-interactive zero knowledge
    proof system.'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '**区块链中的零知识证明应用：** 两种流行的区块链用例，即比特币和以太坊，都是基于公共地址来表示用户的真实身份，从而在网络中保持匿名。值得注意的是，由于区块链的分布式特性，交互式零知识证明不是一个高效的解决方案。此外，零知识证明的现实世界用例是Zcash，它使本地交易完全加密，同时受到网络共识规则的验证，而Zcash是一种非交互式零知识证明系统。'
- en: '[5.6 Hash Tables](contents.xhtml#rsec5_6)'
  id: totrans-449
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[5.6 哈希表](contents.xhtml#rsec5_6)'
- en: It is a popular data structure that supports fast insertion and search operation
    irrespective of the size of the data. It is basically a method to identify a specific
    object from a group of similar objects. In particular, hash tables (also called
    hash map) store data in a format of array and each data value is associated with
    a unique index value. Hash tables make use of hash function to generate an index,
    i.e., location where a data element is to be inserted. The information in data
    structure has two main components, i.e., a unique key and a value. For instance,
    a key could be unique ID (key doesn't have to be an integer every time) and value
    is the phone number. The hash function will decide where to map the key and where
    to store corresponding value with it. The efficiency of mapping is dependent on
    the efficiency of hash function. Basically, the set from which we use input element
    is much larger than capacity of the hash table, so that collision can be avoided.
    Clearly, if the number of items in the table grows, collision rises as well. To
    measure how full the hash table is, the concept of load factor (*α*) is used which
    is defined as the fraction of number of used keys (*n*) and the total capacity
    of the table (*m*).
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种流行的数据结构，支持快速插入和搜索操作，无论数据的大小如何。它基本上是一种从一组相似对象中识别特定对象的方法。特别是，哈希表（也称为散列表）以数组格式存储数据，每个数据值与唯一的索引值相关联。哈希表利用哈希函数生成索引，即数据元素应插入的位置。数据结构中的信息有两个主要组成部分，即唯一键和值。例如，键可以是唯一ID（键不必每次都是整数），值是电话号码。哈希函数将决定将键映射到何处以及在何处存储相应的值。映射的效率取决于哈希函数的效率。基本上，我们使用输入元素的集合比哈希表的容量要大得多，以便避免冲突。显然，如果表中的项数增加，则冲突也会增加。为了衡量哈希表有多满，使用负载因子（*α*）的概念，它被定义为使用的键数（*n*）和表的总容量（*m*）的比例。
- en: <math alttext="" display="block"><mrow><mtable columnalign="left"><mtr columnalign="left"><mtd
    columnalign="left"><mrow><mi>α</mi><mo>=</mo><mfrac><mi>n</mi><mi>m</mi></mfrac></mrow></mtd></mtr></mtable></mrow></math>(5.2)
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="" display="block"><mrow><mtable columnalign="left"><mtr columnalign="left"><mtd
    columnalign="left"><mrow><mi>α</mi><mo>=</mo><mfrac><mi>n</mi><mi>m</mi></mfrac></mrow></mtd></mtr></mtable></mrow></math>(5.2)
- en: Notably, *n* can't exceed the total capacity of the table. If *α* approaches
    to maximum value, the chances of collision rises significantly.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，*n*不能超过表的总容量。如果*α*接近最大值，则冲突的可能性显著增加。
- en: 'In a linked list insertion operation is efficient whereas lookups still consume
    linear time. Additionally, in a sorted array lookup are efficient but insertions
    are insufficient. Notably, for *n* elements, linked list can search in <math alttext=""
    display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></math>
    whereas binary search takes <math alttext="" display="inline"><mrow><mi>O</mi><mo
    stretchy="false">(</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo
    stretchy="false">)</mo></mrow></math> and array consumes <math alttext="" display="inline"><mrow><mi>O</mi><mo
    stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></math> time
    for searching. In contrast to this, hash table allows insertion, deletion and
    searching very fast, i.e., <math alttext="" display="inline"><mrow><mi>O</mi><mo
    stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></math> time
    in average case (Refer to [Table 5.1](#tab5_1)). Lets take an example of hash
    table data structure as shown in [Fig. 5.7](07chap_05.xhtml#fig5_7) with hash
    function: <math alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo><mo>=</mo><mi>x</mi><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn></mrow></math>
    where *x* is the key. Suppose items are in (key, value) format and items are (1,999),
    (2, 9876), (45, 5434), (90, 9877). Therefore, the hash table organizes data so
    that any data can be looked up quickly for a given key. Nevertheless, there may
    be a case hen two or more data items collide and hashes to the same index. This
    is called the problem of collisions. For example, if we have to insert an item
    (55, 7767), this insertion will result in collision as at index 5 already there
    is an item. A function is referred to as good hash function that avoids collision.
    Collision resolution techniques are divided into two main parts, i.e., closed
    addressing and open addressing. In order to avoid the collision, closed addressing
    uses additional data structures whereas open addressing hashing stores all data
    inside the table. More formally, in case of collision resolution with open addressing,
    cells *h0(x), h1(x),……., hm-1(x)* are attempted in succession for the eq.,'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 在链表中，插入操作是高效的，而查找仍然需要线性时间。此外，在排序数组中，查找是高效的，但插入则不足够。值得注意的是，对于*n*个元素，链表可以在<math
    alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo
    stretchy="false">)</mo></mrow></math>时间内搜索，而二分查找需要<math alttext="" display="inline"><mrow><mi>O</mi><mo
    stretchy="false">(</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo
    stretchy="false">)</mo></mrow></math>时间，并且数组在搜索时消耗<math alttext="" display="inline"><mrow><mi>O</mi><mo
    stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></math>的时间。相比之下，哈希表允许快速插入、删除和搜索，即平均情况下的<math
    alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo
    stretchy="false">)</mo></mrow></math>时间（请参阅[表5.1](#tab5_1)）。让我们以哈希表数据结构为例，如[图5.7](07chap_05.xhtml#fig5_7)所示，其哈希函数为：<math
    alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo><mo>=</mo><mi>x</mi><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn></mrow></math>，其中*x*为键。假设项目以（键，值）格式排列，项目分别为（1，999）、（2，9876）、（45，5434）、（90，9877）。因此，哈希表组织数据以便可以快速查找给定键的任何数据。然而，可能会出现两个或更多数据项碰撞并散列到同一索引的情况。这称为碰撞问题。例如，如果我们要插入一个项目（55，7767），这个插入将导致碰撞，因为在索引5处已经有一个项目。良好的哈希函数避免碰撞。碰撞解决技术分为两个主要部分，即封闭寻址和开放寻址。为了避免碰撞，封闭寻址使用额外的数据结构，而开放寻址哈希将所有数据存储在表内。更正式地说，在使用开放寻址的碰撞解决方案时，连续尝试单元*h0(x),
    h1(x),……., hm-1(x)*。
- en: '**TABLE 5.1**'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 5.1**'
- en: Average and worst case complexity for hash tables.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希表的平均和最坏情况复杂度。
- en: '|  | Average complexity | Worst case complexity |'
  id: totrans-456
  prefs: []
  type: TYPE_TB
  zh: '|  | 平均复杂度 | 最坏情况复杂度 |'
- en: '| --- | --- | --- |'
  id: totrans-457
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Space | <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo
    stretchy="false">)</mo></mrow></math> | <math alttext="" display="inline"><mrow><mi>O</mi><mo
    stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></math> |'
  id: totrans-458
  prefs: []
  type: TYPE_TB
  zh: '| 空间 | <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo
    stretchy="false">)</mo></mrow></math> | <math alttext="" display="inline"><mrow><mi>O</mi><mo
    stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></math> |'
- en: '| Insertion | <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo
    stretchy="false">)</mo></mrow></math> | <math alttext="" display="inline"><mrow><mi>O</mi><mo
    stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></math> |'
  id: totrans-459
  prefs: []
  type: TYPE_TB
  zh: '| 插入 | <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo
    stretchy="false">)</mo></mrow></math> | <math alttext="" display="inline"><mrow><mi>O</mi><mo
    stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></math> |'
- en: '| Deletion | <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo
    stretchy="false">)</mo></mrow></math> | <math alttext="" display="inline"><mrow><mi>O</mi><mo
    stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></math> |'
  id: totrans-460
  prefs: []
  type: TYPE_TB
  zh: '| 删除 | <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo
    stretchy="false">)</mo></mrow></math> | <math alttext="" display="inline"><mrow><mi>O</mi><mo
    stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></math> |'
- en: '![Figure 5.7](../images/fig5_7.jpg)'
  id: totrans-461
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.7](../images/fig5_7.jpg)'
- en: '**FIGURE 5.7**'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 5.7**'
- en: Example of hash table.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希表的示例。
- en: <math alttext="" display="block"><mrow><mtable columnalign="left"><mtr columnalign="left"><mtd
    columnalign="left"><mrow><msub><mi>h</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo><mo>+</mo><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo
    stretchy="false">)</mo><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></mtd></mtr></mtable></mrow></math>(5.3)
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="" display="block"><mrow><mtable columnalign="left"><mtr columnalign="left"><mtd
    columnalign="left"><mrow><msub><mi>h</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo><mo>+</mo><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo
    stretchy="false">)</mo><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></mtd></mtr></mtable></mrow></math>(5.3)
- en: where, *f(0)=0* the function *f* is called collision resolution strategy, <math
    alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo></mrow></math> = primary hash function, *x* is the key
    and *m* is the table size. Next, we will discuss the popular collision resolution
    techniques. The categorization of collision resolution techniques has been represented
    in [Fig. 5.8](07chap_05.xhtml#fig5_8)
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，*f(0)=0* 函数 *f* 称为冲突解决策略，<math alttext="" display="inline"><mrow><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> = 主哈希函数，*x*
    为键，*m* 为表大小。接下来，我们将讨论流行的冲突解决技术。冲突解决技术的分类已在[图 5.8](07chap_05.xhtml#fig5_8)中表示。
- en: '![Figure 5.8](../images/fig5_8.jpg)'
  id: totrans-466
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.8](../images/fig5_8.jpg)'
- en: '**FIGURE 5.8**'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 5.8**'
- en: Categorization of collision resolution techniques.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 冲突解决技术的分类。
- en: '[5.6.1 Separate chaining](contents.xhtml#rsec5_6_1)'
  id: totrans-469
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[5.6.1 链接分离](contents.xhtml#rsec5_6_1)'
- en: One possible way to avoid collision is simply to store data with same index
    into a linked list at the corresponding index of the array. This method is referred
    to as separate chaining. Here, each array slot holds a pointer to linked list
    having values for all keys that hashes to same hash index as shown in [Fig. 5.9](07chap_05.xhtml#fig5_9).
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 避免冲突的一种可能方法是简单地将具有相同索引的数据存储到数组的相应索引处的链表中。这种方法称为链式存储。在这里，每个数组槽都保存一个指向链接列表的指针，该列表具有散列到相同散列索引的所有键的值，如[图
    5.9](07chap_05.xhtml#fig5_9)所示。
- en: '**Lookup:** Of course, this solution will end up in linear time, i.e., <math
    alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo
    stretchy="false">)</mo></mrow></math> for lookup in worst case. As in worst case,
    all the keys might have same index of the hash table so, in order to perform sequential
    search, time requirement is <math alttext="" display="inline"><mrow><mi>O</mi><mo
    stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></math>. Also,
    cache performance for this method is not good. Although with this method is easy
    to implement and hash table never gets fills.'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '**查找：** 当然，这种解决方案最终会以线性时间结束，即在最坏情况下查找的时间复杂度为<math alttext="" display="inline"><mrow><mi>O</mi><mo
    stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></math>。因为在最坏情况下，所有的键可能都具有哈希表的相同索引，因此为了执行顺序搜索，时间需求为<math
    alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo
    stretchy="false">)</mo></mrow></math>。此外，该方法的缓存性能不佳。尽管使用此方法易于实现且哈希表永远不会填满。'
- en: '**Deletion:** To delete, first keys need to be searched and then deleted. As
    worst case time complexity for searching is <math alttext="" display="inline"><mrow><mi>O</mi><mo
    stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></math>, so
    for deletion time taken is <math alttext="" display="inline"><mrow><mi>O</mi><mo
    stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></math>.'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '**删除：** 要删除，首先需要搜索键然后删除。因为搜索的最坏情况时间复杂度为<math alttext="" display="inline"><mrow><mi>O</mi><mo
    stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></math>，所以删除所需的时间为<math
    alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo
    stretchy="false">)</mo></mrow></math>。'
- en: '![Figure 5.9](../images/fig5_9.jpg)'
  id: totrans-473
  prefs: []
  type: TYPE_IMG
  zh: '![图5.9](../images/fig5_9.jpg)'
- en: '**FIGURE 5.9**'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: '**图5.9**'
- en: Each array slot containing pointer to linked list.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 每个数组槽包含指向链表的指针。
- en: '[5.6.2 Linear probing](contents.xhtml#rsec5_6_2)'
  id: totrans-476
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[5.6.2 线性探测](contents.xhtml#rsec5_6_2)'
- en: Linear probing is a popular method to handle collision. Probing simply implies
    finding the next empty cell where the key is to be placed in case of collision.
    This method comes under collision resolution with open addressing. To insert in
    case of collisions, the immediate next cells are tried until an empty cell is
    found. Therefore, the size of table should be equal to or greater than the total
    number of keys. Formally, for linear probing, *f* is a linear function and mostly
    it is <math alttext="" display="inline"><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo
    stretchy="false">)</mo><mo>=</mo><mi>i</mi></mrow></math> in the equation 5.3,
    i.e., <math alttext="" display="inline"><mrow><msub><mi>h</mi><mi>i</mi></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mi>i</mi><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    Clearly, the worst case complexity for searching is <math alttext="" display="inline"><mrow><mi>O</mi><mo
    stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow></math>.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 线性探测是处理冲突的常用方法。探测简单地意味着在发生冲突时找到下一个空单元格，将键放入其中。此方法属于使用开放地址法的冲突解决方法之一。在发生冲突时插入，会尝试直到找到一个空单元格为止。因此，表的大小应等于或大于键的总数。正式地，对于线性探测，*f*
    是线性函数，通常在方程式 5.3 中表示为 <math alttext="" display="inline"><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo
    stretchy="false">)</mo><mo>=</mo><mi>i</mi></mrow></math>，即，<math alttext="" display="inline"><mrow><msub><mi>h</mi><mi>i</mi></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mi>i</mi><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    显然，搜索的最坏情况复杂度为 <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo
    stretchy="false">)</mo></mrow></math>。
- en: 'However, linear probing faces the problem of clustering, i.e., if multiple
    consecutive items form a group then it will take a lot of time to find an empty
    slot for insertion or in case of searching an item. Let''s understand linear probing
    with an example, Say 3, 17, 14, 6, 21, 13, 7, 22 are the keys to be inserted in
    series and <math alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>2</mn><mi>x</mi><mo>+</mo><mn>3</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn></mrow></math>
    is the hash function for key *x*. Refer [Fig. 5.10](07chap_05.xhtml#fig5_10) Hash
    for each key is given by:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，线性探测面临聚类问题，即，如果多个连续项形成一个组，则查找一个空插槽以进行插入或搜索项将需要很长时间。让我们通过一个例子来理解线性探测，假设3、17、14、6、21、13、7、22是要依次插入的键，<math
    alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>2</mn><mi>x</mi><mo>+</mo><mn>3</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn></mrow></math>是键*x*的哈希函数。参见[图
    5.10](07chap_05.xhtml#fig5_10)，每个键的哈希值如下：
- en: '*h(3)*=9'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '*h(3)*=9'
- en: '*h(17)*=7'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '*h(17)*=7'
- en: '*h(9)*=1'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '*h(9)*=1'
- en: '*h(6)*=5'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '*h(6)*=5'
- en: '*h(21)*=5'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: '*h(21)*=5'
- en: '*h(13)*=9'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '*h(13)*=9'
- en: '*h(7)*=7'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '*h(7)*=7'
- en: '*h(22)*=7'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: '*h(22)*=7'
- en: '![Figure 5.10](../images/fig5_10.jpg)'
  id: totrans-487
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.10](../images/fig5_10.jpg)'
- en: '**FIGURE 5.10**'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 5.10**'
- en: Example of linear probing.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 线性探测的例子。
- en: '**Insert 3,17,14,6:** Insertion of these 4 elements doest not face any collision.
    So, they are inserted at their hash indexes calculated according to given hash
    function.'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '**插入 3,17,14,6：** 这4个元素的插入不会发生冲突。因此，它们被插入到根据给定哈希函数计算的哈希索引位置。'
- en: '**Insert 21**: As <math alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mn>21</mn><mo
    stretchy="false">)</mo></mrow></math> =5 and this location is already occupied
    by key 6\. So, lets try linear probing with the equation: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mi>i</mi></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mi>i</mi><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    where i=0 to m-1'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: '**插入 21**：由于<math alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mn>21</mn><mo
    stretchy="false">)</mo></mrow></math> =5，而此位置已经被键6占据。因此，让我们尝试使用线性探测方程：<math alttext=""
    display="inline"><mrow><msub><mi>h</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo><mo>+</mo><mi>i</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>，其中i=0到m-1'
- en: '**i=0**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>0</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>5</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>5</mn></mrow></math>
    which is occupied.'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: '**i=0**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>0</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>5</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>5</mn></mrow></math>
    这个位置已经被占据。'
- en: 'Next, **i=1**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>5</mn><mo>+</mo><mn>1</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>6</mn></mrow></math>
    and this location is free. So, 21 is inserted at location 6.'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: '接下来，**i=1**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>5</mn><mo>+</mo><mn>1</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>6</mn></mrow></math>
    这个位置是空闲的。因此，21 被插入到位置 6。'
- en: Similarly, 13, 7 and 22 are inserted.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，13、7 和 22 被插入。
- en: This example of insertion is presented in [Fig. 5.10](07chap_05.xhtml#fig5_10).
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 这个插入的例子见于[图 5.10](07chap_05.xhtml#fig5_10)。
- en: '[5.6.3 Quadratic probing](contents.xhtml#rsec5_6_3)'
  id: totrans-496
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[5.6.3 二次探测](contents.xhtml#rsec5_6_3)'
- en: This is another open addressing scheme to resolve collision in hash table. It
    works by taking hash value of the key and adding successive values of the quadratic
    polynomial. More formally, for quadratic probing, <math alttext="" display="inline"><mrow><mi>f</mi><mo
    stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>i</mi><mn>2</mn></msup></mrow></math>,
    i.e., <math alttext="" display="inline"><mrow><msub><mi>h</mi><mi>i</mi></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><msup><mi>i</mi><mn>2</mn></msup><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    where i=0 to m-1.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一种解决哈希表冲突的开放定址方案。它通过取密钥的哈希值并添加二次多项式的连续值来工作。更正式地说，对于二次探测，<math alttext=""
    display="inline"><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>i</mi><mn>2</mn></msup></mrow></math>，即，<math
    alttext="" display="inline"><mrow><msub><mi>h</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo><mo>+</mo><msup><mi>i</mi><mn>2</mn></msup><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    其中 i=0 到 m-1。
- en: 'This scheme has good memory caching as it preserves the locality of reference.
    Also, it avoids clustering problem as compared to linear probing. Let''s understand
    quadratic probing with an example. Refer [Fig. 5.11](07chap_05.xhtml#fig5_11).
    Again consider 3, 17, 14, 6, 21, 13, 7, 22 are the keys to be inserted in series
    and <math alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>2</mn><mi>x</mi><mo>+</mo><mn>3</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn></mrow></math>
    is the hash function for key *x*. Hash for each key is given by:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方案具有良好的内存缓存，因为它保留了引用的局部性。此外，与线性探测相比，它避免了聚类问题。让我们通过一个例子来了解二次探测。参考 [图 5.11](07chap_05.xhtml#fig5_11)。再次考虑
    3、17、14、6、21、13、7、22 是要按顺序插入的键，<math alttext="" display="inline"><mrow><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>2</mn><mi>x</mi><mo>+</mo><mn>3</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn></mrow></math>
    是键 *x* 的哈希函数。每个键的哈希值如下：
- en: '![Figure 5.11](../images/fig5_11.jpg)'
  id: totrans-499
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.11](../images/fig5_11.jpg)'
- en: '**FIGURE 5.11**'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 5.11**'
- en: Example of quadratic probing.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 二次探测的示例。
- en: '*h(3)*=9'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: '*h(3)*=9'
- en: '*h(17)*=7'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: '*h(17)*=7'
- en: '*h(9)*=1'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: '*h(9)*=1'
- en: '*h(6)*=5'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: '*h(6)*=5'
- en: '*h(21)*=5'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '*h(21)*=5'
- en: '*h(13)*=9'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: '*h(13)*=9'
- en: '*h(7)*=7'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: '*h(7)*=7'
- en: '*h(22)*=7'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: '*h(22)*=7'
- en: '**Insert 3,17,14,6:** Insertion of these 4 elements doest not face any collision.
    So, they are inserted at their hash indexes calculated according to the given
    hash function.'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: '**插入 3,17,14,6：** 插入这 4 个元素不会遇到任何冲突。所以，它们被插入到根据给定的哈希函数计算的它们的哈希索引。'
- en: '**Insert 21**: *h(21)* is 5 which is occupied by the key 6\. So, lets try quadratic
    probing with the equation: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mi>i</mi></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><msup><mi>i</mi><mn>2</mn></msup><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    where i=0 to m-1 **i=0**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> = <math
    alttext="" display="inline"><mrow><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo></mrow></math> +0)mod m ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> =(5)mod
    10 =5 which is occupied.'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: '**插入 21**：*h(21)* 是 5，被键值 6 占用。所以，让我们尝试使用二次探测方程： <math alttext="" display="inline"><mrow><msub><mi>h</mi><mi>i</mi></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><msup><mi>i</mi><mn>2</mn></msup><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>，其中
    i=0 至 m-1 **i=0**： <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> = <math
    alttext="" display="inline"><mrow><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo></mrow></math> +0)mod m ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> =(5)mod
    10 =5 被占用。'
- en: 'Next, **i=1**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> = <math
    alttext="" display="inline"><mrow><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo></mrow></math> +1²)mod m ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> =(5+1)mod
    10= 6 and this location is free. So, 21 is inserted at location 6.'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，**i=1**： <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> = <math
    alttext="" display="inline"><mrow><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo></mrow></math> +1²)mod m ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> =(5+1)mod
    10= 6，这个位置是空的。所以，21 被插入到位置 6。
- en: '**Insert 13**: <math alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mn>13</mn><mo
    stretchy="false">)</mo></mrow></math> =9 which is already occupied. So, lets try
    quadratic probing **i=0**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> = <math
    alttext="" display="inline"><mrow><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo></mrow></math> +0)mod m ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> =(9)mod
    10 =9 which is occupied.'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: '**插入 13**： <math alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mn>13</mn><mo
    stretchy="false">)</mo></mrow></math> =9，已被占用。所以，让我们尝试二次探测 **i=0**： <math alttext=""
    display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo></mrow></math> = <math alttext="" display="inline"><mrow><mo
    stretchy="false">(</mo><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math>
    +0)mod m ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> =(9)mod
    10 =9，已被占用。'
- en: '**i=1**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> = <math
    alttext="" display="inline"><mrow><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo></mrow></math> +1²)mod m ⟹ h1(x)=(9+1)mod 10= 0 and this
    location is free. So, 13 is inserted at location 0.'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: '**i=1**： <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> = <math
    alttext="" display="inline"><mrow><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo></mrow></math> +1²)mod m ⟹ h1(x)=(9+1)mod 10= 0，此位置为空。因此，13
    被插入到位置 0。'
- en: '**Insert 7**: As <math alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mn>7</mn><mo
    stretchy="false">)</mo></mrow></math> =7 is already occupied, so lets try quadratic
    probing. **i=0**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> = <math
    alttext="" display="inline"><mrow><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo></mrow></math> +0)mod m ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> =(7)mod
    10 =7 which is occupied.'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: '**插入 7**：由于 <math alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mn>7</mn><mo
    stretchy="false">)</mo></mrow></math> =7 已被占用，所以让我们尝试二次探测。 **i=0**： <math alttext=""
    display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo></mrow></math> = <math alttext="" display="inline"><mrow><mo
    stretchy="false">(</mo><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math>
    +0)mod m ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> =(7)mod
    10 =7，已被占用。'
- en: '**i=1**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> = <math
    alttext="" display="inline"><mrow><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo></mrow></math> +1²)mod m ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> =(7+1)mod
    10= 8 and this location is free. So, 7 is inserted at location 8.'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: '**i=1**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> = <math
    alttext="" display="inline"><mrow><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo></mrow></math> +1²)mod m ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> =(7+1)mod
    10= 8 这个位置是空的。所以，7 被插入到位置 8。'
- en: '**Insert 22**: <math alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mn>22</mn><mo
    stretchy="false">)</mo></mrow></math> =7 which is already occupied. So, lets try
    quadratic probing **i=0**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> =(
    <math alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo></mrow></math> +0)mod m ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> =(7)mod
    10 =7 which is occupied.'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: '**插入 22**: <math alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mn>22</mn><mo
    stretchy="false">)</mo></mrow></math> =7，这个位置已经被占用。所以，让我们尝试二次探测 **i=0**: <math
    alttext="" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo></mrow></math> =( <math alttext="" display="inline"><mrow><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> +0)mod
    m ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> =(7)mod
    10 =7 这个位置已经被占用。'
- en: '**i=1**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> =(
    <math alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo></mrow></math> +1²)mod m ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> =(7+1)mod
    10= 8 and this location is also not free. **i=2**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>2</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> =(
    <math alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo></mrow></math> +22)mod m ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>2</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> =(7+4)mod
    10= 1 and this location is also not free.'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: '**i=1**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> =(
    <math alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo></mrow></math> +1²)mod m ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> =(7+1)mod
    10= 8，而且这个位置也不是空的。 **i=2**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>2</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> =(
    <math alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo></mrow></math> +22)mod m ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>2</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> =(7+4)mod
    10= 1，而且这个位置也不是空的。'
- en: '**i=3**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>3</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> =(
    <math alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo></mrow></math> +22)mod m ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>3</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> =(7+9)mod
    10= 6 and this location is free. So, 22 is inserted at location 6.'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: '**i=3**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>3</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> =(
    <math alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo></mrow></math> +22)mod m ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>3</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> =(7+9)mod
    10= 6，而且这个位置是空的。因此，22 被插入到位置 6。'
- en: '[5.6.4 Double hashing](contents.xhtml#rsec5_6_4)'
  id: totrans-520
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[5.6.4 双重哈希](contents.xhtml#rsec5_6_4)'
- en: 'This technique applies a second hash function to the given key in case of collision,
    i.e., <math alttext="" display="inline"><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo
    stretchy="false">)</mo><mo>=</mo><mi>i</mi><mo>*</mo><msub><mi>h</mi><mn>2</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> and
    <math alttext="" display="inline"><mrow><mi>i</mi><mo>=</mo><mn>0</mn><mi>t</mi><mi>o</mi><mi>m</mi><mo>−</mo><mn>1</mn></mrow></math>
    where, h2(x) is another hash function. The second hash function provides an offset
    value to resolve collision. This technique also comes under a double hashing technique.
    Notably, a good second hash function makes sure that all cells are equally probed.
    Unfortunately, the computational cost of double hashing is high as compared to
    other probing schemes. Let''s understand quadratic probing with an example as
    represented in [Fig. 5.12](07chap_05.xhtml#fig5_12). Again consider 3, 17, 14,
    6, 21, 13, 7, 22 are the keys to be inserted in series and <math alttext="" display="inline"><mrow><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>2</mn><mi>x</mi><mo>+</mo><mn>3</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn></mrow></math>
    is the hash function for key *x*. Assume other hash function <math alttext=""
    display="inline"><mrow><mi>h</mi><mtext>′</mtext><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>3</mn><mi>k</mi><mo>+</mo><mn>1</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn></mrow></math>
    Hash for each key is given by:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术在冲突的情况下对给定的键应用第二个哈希函数，即，<math alttext="" display="inline"><mrow><mi>f</mi><mo
    stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo>=</mo><mi>i</mi><mo>*</mo><msub><mi>h</mi><mn>2</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> 和 <math
    alttext="" display="inline"><mrow><mi>i</mi><mo>=</mo><mn>0</mn><mi>t</mi><mi>o</mi><mi>m</mi><mo>−</mo><mn>1</mn></mrow></math>
    其中，h2(x) 是另一个哈希函数。第二个哈希函数提供了一个偏移值来解决冲突。这种技术也被称为双重哈希技术。值得注意的是，一个良好的第二个哈希函数确保所有单元都被均匀探查。不幸的是，与其他探查方案相比，双重哈希的计算成本较高。让我们通过一个示例来理解二次探查，如[图
    5.12](07chap_05.xhtml#fig5_12)所示。再次考虑要插入的键为3、17、14、6、21、13、7、22，并且<math alttext=""
    display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo
    stretchy="false">(</mo><mn>2</mn><mi>x</mi><mo>+</mo><mn>3</mn><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn></mrow></math>
    是键 *x* 的哈希函数。假设另一个哈希函数为<math alttext="" display="inline"><mrow><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>3</mn><mi>k</mi><mo>+</mo><mn>1</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn></mrow></math>，每个键的哈希值如下：
- en: '*h(3)*=9'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: '*h(3)*=9'
- en: '*h(17)*=7'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: '*h(17)*=7'
- en: '*h(9)*=1'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: '*h(9)*=1'
- en: '*h(6)*=5'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: '*h(6)*=5'
- en: '*h(21)*=5'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: '*h(21)*=5'
- en: '*h(13)*=9'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: '*h(13)*=9'
- en: '*h(7)*=7'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: '*h(7)*=7'
- en: '*h(22)*=7'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: '*h(22)*=7'
- en: '![Figure 5.12](../images/fig5_12.jpg)'
  id: totrans-530
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.12](../images/fig5_12.jpg)'
- en: '**FIGURE 5.12**'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 5.12**'
- en: Example of double hashing.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 双重哈希的示例。
- en: '**Insert 3,17,14,6:** Insertion of these 4 element doest not face any collision.
    So, they are inserted at their hash indexes calculated according to given hash
    function.'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: '**插入 3,17,14,6:** 这4个元素的插入没有发生任何碰撞。因此，它们被插入到根据给定哈希函数计算的哈希索引处。'
- en: '**Insert 21**: <math alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mn>21</mn><mo
    stretchy="false">)</mo></mrow></math> is 5 which is occupied by the key 6\. So,
    lets apply double hashing with the equation: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mi>i</mi></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mi>i</mi><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    where i=0 to m-1\. **i=0**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>0</mn><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>5</mn><mo>+</mo><mn>0</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>5</mn></mrow></math>
    which is occupied.'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: '**插入 21**: <math alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mn>21</mn><mo
    stretchy="false">)</mo></mrow></math> 是 5，已被关键字 6 占据。因此，让我们应用双重哈希，并使用等式：<math
    alttext="" display="inline"><mrow><msub><mi>h</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo><mo>+</mo><mi>i</mi><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    其中 i=0 到 m-1。**i=0**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>0</mn><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>5</mn><mo>+</mo><mn>0</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>5</mn></mrow></math>
    已被占据。'
- en: '**i=1**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>5</mn><mo>+</mo><mn>1</mn><mo>*</mo><mn>4</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>9</mn><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>9</mn></mrow></math>
    and which is also not free <math alttext="" display="inline"><mrow><mo stretchy="false">[</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mn>21</mn><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>3</mn><mo>*</mo><mn>21</mn><mo>+</mo><mn>1</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>4</mn><mo
    stretchy="false">]</mo></mrow></math>'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: '**i=1**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>5</mn><mo>+</mo><mn>1</mn><mo>*</mo><mn>4</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>9</mn><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>9</mn></mrow></math>
    并且也不是自由的 <math alttext="" display="inline"><mrow><mo stretchy="false">[</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mn>21</mn><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>3</mn><mo>*</mo><mn>21</mn><mo>+</mo><mn>1</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>4</mn><mo
    stretchy="false">]</mo></mrow></math>'
- en: '**i=2**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>2</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>2</mn><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>5</mn><mo>+</mo><mn>2</mn><mo>*</mo><mn>4</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>13</mn><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>3</mn></mrow></math>
    and which is free. So, key 21 is inserted at location 3.'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: '**i=2**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>2</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>2</mn><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>5</mn><mo>+</mo><mn>2</mn><mo>*</mo><mn>4</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>13</mn><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>3</mn></mrow></math>
    并且是免费的。 因此，在位置3插入了关键字21。'
- en: '**Insert 13**: <math alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mn>13</mn><mo
    stretchy="false">)</mo></mrow></math> is 9 which is occupied by the key 3\. So,
    lets apply double hashing with the equation: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mi>i</mi></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mi>i</mi><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    where i=0 to m-1\. **i=0**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>0</mn><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>9</mn><mo>+</mo><mn>0</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>9</mn></mrow></math>
    which is occupied.'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: '**插入 13**：<math alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mn>13</mn><mo
    stretchy="false">)</mo></mrow></math> 是 9，由键值 3 占用。因此，让我们应用双重散列的方程式：<math alttext=""
    display="inline"><mrow><msub><mi>h</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo><mo>+</mo><mi>i</mi><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    其中 i=0 到 m-1。**i=0**：<math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>0</mn><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>9</mn><mo>+</mo><mn>0</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>9</mn></mrow></math>
    被占用。'
- en: '**i=1**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>.
    Notably, <math alttext="" display="inline"><mrow><mo stretchy="false">[</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mn>13</mn><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>13</mn><mo>*</mo><mn>3</mn><mo>+</mo><mn>1</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>0</mn><mo
    stretchy="false">]</mo></mrow></math>. So, this will always result in hash index
    9 which is not free. This signifies choice of second hash function is not goo.
    So, we can''t insert 13 in this hash table.'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: '**i=1**：<math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>。值得注意的是，<math
    alttext="" display="inline"><mrow><mo stretchy="false">[</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mn>13</mn><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>13</mn><mo>*</mo><mn>3</mn><mo>+</mo><mn>1</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>0</mn><mo
    stretchy="false">]</mo></mrow></math>。因此，这将始终导致哈希索引 9，该索引已被占用。这表明第二个哈希函数的选择不好。因此，我们不能在此哈希表中插入
    13。'
- en: '**Insert 7**: <math alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mn>7</mn><mo
    stretchy="false">)</mo></mrow></math> is 7 which is occupied by the key 17\. So,
    lets apply double hashing with the equation: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mi>i</mi></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mi>i</mi><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    where i=0 to m-1.'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: '**插入 7**：<math alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mn>7</mn><mo
    stretchy="false">)</mo></mrow></math> 是 7，被关键字 17 占据。因此，让我们应用双重散列，其方程为：<math alttext=""
    display="inline"><mrow><msub><mi>h</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo><mo>+</mo><mi>i</mi><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    其中 i=0 到 m-1。'
- en: '**i=0**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>0</mn><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>7</mn><mo>+</mo><mn>2</mn><mo>*</mo><mn>0</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>7</mn></mrow></math>
    which is occupied.'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: '**i=0**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>0</mn><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>7</mn><mo>+</mo><mn>2</mn><mo>*</mo><mn>0</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>7</mn></mrow></math>
    被占用。'
- en: '**i=1**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>7</mn><mo>+</mo><mn>2</mn><mo>*</mo><mn>1</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>9</mn><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>9</mn></mrow></math>
    which is also not free. Notably, <math alttext="" display="inline"><mrow><mo stretchy="false">[</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mn>7</mn><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>7</mn><mo>*</mo><mn>3</mn><mo>+</mo><mn>1</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>2</mn><mo
    stretchy="false">]</mo></mrow></math>.'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: '**i=1**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>7</mn><mo>+</mo><mn>2</mn><mo>*</mo><mn>1</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>9</mn><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>9</mn></mrow></math>
    也不是免费的。值得注意的是，<math alttext="" display="inline"><mrow><mo stretchy="false">[</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mn>7</mn><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>7</mn><mo>*</mo><mn>3</mn><mo>+</mo><mn>1</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>2</mn><mo
    stretchy="false">]</mo></mrow></math>。'
- en: '**i=2**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>2</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>2</mn><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>2</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>7</mn><mo>+</mo><mn>2</mn><mo>*</mo><mn>2</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>11</mn><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>1</mn></mrow></math>
    which is also not free.'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: '**i=2**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>2</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>2</mn><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>2</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>7</mn><mo>+</mo><mn>2</mn><mo>*</mo><mn>2</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>11</mn><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>1</mn></mrow></math>
    也不是自由的。'
- en: '**i=3**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>3</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>3</mn><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>3</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>7</mn><mo>+</mo><mn>2</mn><mo>*</mo><mn>3</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>13</mn><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>3</mn></mrow></math>
    which is also not free.'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: '**i=3**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>3</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>3</mn><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>3</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>7</mn><mo>+</mo><mn>2</mn><mo>*</mo><mn>3</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>13</mn><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>3</mn></mrow></math>
    也不是自由的。'
- en: '**i=4**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>4</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>4</mn><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>4</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>7</mn><mo>+</mo><mn>2</mn><mo>*</mo><mn>4</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>15</mn><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>5</mn></mrow></math>
    which is also not free.'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: '**i=4**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>4</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>4</mn><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>4</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>7</mn><mo>+</mo><mn>2</mn><mo>*</mo><mn>4</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>15</mn><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>5</mn></mrow></math>
    也不是免费的。'
- en: '**i=5**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>5</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>5</mn><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>5</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>7</mn><mo>+</mo><mn>2</mn><mo>*</mo><mn>5</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>17</mn><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>7</mn></mrow></math>
    which is also not free.'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: '**i=5**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>5</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>5</mn><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>5</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>7</mn><mo>+</mo><mn>2</mn><mo>*</mo><mn>5</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>17</mn><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>7</mn></mrow></math>
    也不是免费的。'
- en: '**i=6**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>6</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>6</mn><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>6</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>7</mn><mo>+</mo><mn>2</mn><mo>*</mo><mn>6</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>19</mn><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>9</mn></mrow></math>
    which is also not free.'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: '**i=6**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>6</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>6</mn><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>6</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>7</mn><mo>+</mo><mn>2</mn><mo>*</mo><mn>6</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>19</mn><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>9</mn></mrow></math>
    which is also not free.'
- en: '**i=7**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>7</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>7</mn><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>7</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> =(7+2*7)mod
    10= 21mod10=1 which is also not free.'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: '**i=7**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>7</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>7</mn><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>7</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> =(7+2*7)mod
    10= 21mod10=1 which is also not free.'
- en: '**i=8**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>8</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>8</mn><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>8</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>7</mn><mo>+</mo><mn>2</mn><mo>*</mo><mn>8</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>23</mn><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>3</mn></mrow></math>
    which is also not free.'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: '**i=8**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>8</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>8</mn><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>8</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>7</mn><mo>+</mo><mn>2</mn><mo>*</mo><mn>8</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>23</mn><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>3</mn></mrow></math>
    which is also not free.'
- en: '**i=9**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>9</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> = <math
    alttext="" display="inline"><mrow><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo><mo>+</mo><mn>9</mn><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>9</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>7</mn><mo>+</mo><mn>2</mn><mo>*</mo><mn>9</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>25</mn><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>5</mn></mrow></math>
    which is also not free.'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: '**i=9**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>9</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> = <math
    alttext="" display="inline"><mrow><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo><mo>+</mo><mn>9</mn><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>9</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>7</mn><mo>+</mo><mn>2</mn><mo>*</mo><mn>9</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>25</mn><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>5</mn></mrow></math>
    which is also not free.'
- en: Now, we cant increase value of i to 1 as i could range from 0to 9.So, value
    of i can't go beyond 9\. We have checked all possible value of i from 0 to 9\.
    So, we can't insert 7 in this hash table.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们不能将 i 的值增加到 1，因为 i 的范围是从 0 到 9。因此，i 的值不能超过 9。我们已经检查了 i 从 0 到 9 的所有可能的值。因此，我们不能在这个哈希表中插入
    7。
- en: '**Insert 22**: *h(22)* is 7 which is occupied by the key 17\. So, lets apply
    double hashing with the equation: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mi>i</mi></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mi>i</mi><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    where i=0 to m-1.'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: '**插入 22**：*h(22)* 是 7，被键 17 占用。因此，让我们应用双重哈希，其方程为：<math alttext="" display="inline"><mrow><msub><mi>h</mi><mi>i</mi></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mi>i</mi><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>，其中
    i=0 至 m-1。'
- en: '**i=0**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>0</mn><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>7</mn><mo>+</mo><mn>7</mn><mo>*</mo><mn>0</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>7</mn></mrow></math>
    which is occupied.'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: '**i=0**：<math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>0</mn><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>7</mn><mo>+</mo><mn>7</mn><mo>*</mo><mn>0</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>7</mn></mrow></math>，已被占用。'
- en: '**i=1**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> =(
    <math alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo><mo>+</mo><mn>1</mn><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>7</mn><mo>+</mo><mn>7</mn><mo>*</mo><mn>1</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>14</mn><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>4</mn></mrow></math>
    which is free. Notably, [ <math alttext="" display="inline"><mrow><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mn>7</mn><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>22</mn><mo>*</mo><mn>3</mn><mo>+</mo><mn>1</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>7</mn></mrow></math>].'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: '**i=1**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> =（<math
    alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo><mo>+</mo><mn>1</mn><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>7</mn><mo>+</mo><mn>7</mn><mo>*</mo><mn>1</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>14</mn><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>4</mn></mrow></math>
    ，这是自由的。值得注意的是，[ <math alttext="" display="inline"><mrow><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mn>7</mn><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>22</mn><mo>*</mo><mn>3</mn><mo>+</mo><mn>1</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>7</mn></mrow></math>].'
- en: '[5.7 RSA](contents.xhtml#rsec5_7)'
  id: totrans-554
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[5.7 RSA](contents.xhtml#rsec5_7)'
- en: Introduced in 1978, RSA (Rivest, Shamir, Adleman) is the first widely adopted
    cryptosystems. RSA follows the idea of public-key encryption which is based on
    two components, i.e., public key, and private key. Everyone on the network has
    its own public and private key pair. The public key is known to everybody on the
    network and it is used to encrypt the message and also to verify signatures. In
    contrast, a private key is only known to the receiver and is used to decrypt the
    sent message and also to create signatures. Applications of RSA include both digital
    signatures and public key encryption. In RSA, the public key of the receiver is
    used to encrypt the message whereas the private key of the receiver is used to
    decrypt the message as shown in [Fig. 5.13](07chap_05.xhtml#fig5_13). Encryption
    is a process of transforming the original message into an unrecognizable form
    called ciphertext whereas decryption is a process of converting encrypted message
    back to the original message. The process of RSA involves 3 steps, i.e., key generation,
    encryption, and decryption.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: RSA（Rivest, Shamir, Adleman）于 1978 年推出，是第一个广泛采用的密码系统。RSA 遵循基于两个组件的公钥加密思想，即公钥和私钥。网络上的每个人都有自己的公钥和私钥对。公钥为网络上的所有人所知，用于加密消息并验证签名。相反，私钥只有接收者知道，用于解密发送的消息并创建签名。RSA
    的应用包括数字签名和公钥加密。在 RSA 中，接收者的公钥用于加密消息，而接收者的私钥用于解密消息，如 [图 5.13](07chap_05.xhtml#fig5_13)
    所示。加密是将原始消息转换为称为密文的不可识别形式的过程，而解密是将加密消息转换回原始消息的过程。RSA 的过程包括 3 个步骤，即密钥生成、加密和解密。
- en: '[5.7.1 Steps for key generation:](contents.xhtml#rsec5_7_1)'
  id: totrans-556
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[5.7.1 密钥生成步骤：](contents.xhtml#rsec5_7_1)'
- en: Select the variables *p* and *q* where both *p* and *q* both are large prime
    numbers and p≠q. The whole security of RSA is dependent on the difficulty of factoring
    large prime numbers. A poor choice of *p* and *q* can make RSA less secure and
    vulnerable to different attacks.
  id: totrans-557
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择变量 *p* 和 *q*，其中 *p* 和 *q* 都是大素数且 p≠q。RSA 的整个安全性取决于大素数的因数分解的难度。选择 *p* 和 *q*
    不当会使 RSA 不够安全，并且容易受到不同攻击的影响。
- en: Compute <math alttext="" display="inline"><mrow><mi>n</mi><mo>=</mo><mi>p</mi><mo>*</mo><mi>q</mi></mrow></math>,
    *n* is a part of the public key and should be large so that it is difficult to
    extract *p* and *q* from it.
  id: totrans-558
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算 <math alttext="" display="inline"><mrow><mi>n</mi><mo>=</mo><mi>p</mi><mo>*</mo><mi>q</mi></mrow></math>，*n*
    是公钥的一部分，并且应该足够大，以至于从中提取 *p* 和 *q* 是困难的。
- en: Compute *ϕ*(n)=(p-1)(q-1). *ϕ*(n) is called as Euler's totient function.
  id: totrans-559
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算 *ϕ*(n)=(p-1)(q-1)。*ϕ*(n)被称为欧拉函数。
- en: Next, public key *e* is generated such that gcd(*ϕ*(n), e)=1 or *e* should be
    co-prime to *ϕ*(n); 1¡e¡*ϕ*(n).
  id: totrans-560
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，生成公钥 *e*，使得 gcd(*ϕ*(n), e)=1 或者 *e* 应该与 *ϕ*(n) 互质；1¡e¡*ϕ*(n)。
- en: Finally, create the private key *d* such that d≡e-1mod*ϕ*(n).
  id: totrans-561
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，创建私钥 *d*，使得 d≡e-1mod*ϕ*(n)。
- en: Both <math alttext="" display="inline"><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>,</mo><mi>e</mi><mo
    stretchy="false">)</mo></mrow></math> are part of RSA public key and is publically
    available and private key consist of <math alttext="" display="inline"><mrow><mo
    stretchy="false">(</mo><mi>n</mi><mo>,</mo><mi>d</mi><mo stretchy="false">)</mo></mrow></math>.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="" display="inline"><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>,</mo><mi>e</mi><mo
    stretchy="false">)</mo></mrow></math> 都是RSA公钥的一部分，是公开可用的，而私钥包括 <math alttext=""
    display="inline"><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>,</mo><mi>d</mi><mo
    stretchy="false">)</mo></mrow></math>。
- en: '[5.7.2 Encryption](contents.xhtml#rsec5_7_2)'
  id: totrans-563
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[5.7.2 加密](contents.xhtml#rsec5_7_2)'
- en: 'Lets assume a sender has to sent a plaintext message *M* to a receiver having
    public key <math alttext="" display="inline"><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>,</mo><mi>e</mi><mo
    stretchy="false">)</mo></mrow></math>. To encrypt message use:'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 假设发送者必须将明文消息 *M* 发送给具有公钥 <math alttext="" display="inline"><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>,</mo><mi>e</mi><mo
    stretchy="false">)</mo></mrow></math> 的接收者。要加密消息，请使用：
- en: Cipher text= <math alttext="" display="inline"><mrow><msup><mi>M</mi><mi>e</mi></msup><mi>m</mi><mi>o</mi><mi>d</mi><mi>n</mi></mrow></math>.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 密文= <math alttext="" display="inline"><mrow><msup><mi>M</mi><mi>e</mi></msup><mi>m</mi><mi>o</mi><mi>d</mi><mi>n</mi></mrow></math>。
- en: '[5.7.3 Decryption](contents.xhtml#rsec5_7_3)'
  id: totrans-566
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[5.7.3 解密](contents.xhtml#rsec5_7_3)'
- en: 'To decrypt, receiver uses its private key as:'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 解密时，接收者使用其私钥如下：
- en: Plaintext= <math alttext="" display="inline"><mrow><msup><mi>C</mi><mi>d</mi></msup><mi>m</mi><mi>o</mi><mi>d</mi><mi>n</mi></mrow></math>
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 明文= <math alttext="" display="inline"><mrow><msup><mi>C</mi><mi>d</mi></msup><mi>m</mi><mi>o</mi><mi>d</mi><mi>n</mi></mrow></math>
- en: '![Figure 5.13](../images/fig5_13.jpg)'
  id: totrans-569
  prefs: []
  type: TYPE_IMG
  zh: '![图5.13](../images/fig5_13.jpg)'
- en: '**FIGURE 5.13**'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: '**图5.13**'
- en: RSA algorithm structure.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: RSA算法结构。
- en: '[5.7.4 RSA example](contents.xhtml#rsec5_7_4)'
  id: totrans-572
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[5.7.4 RSA示例](contents.xhtml#rsec5_7_4)'
- en: '**Key generation**'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: '**密钥生成**'
- en: Assume *p*=17, *q*=11.
  id: totrans-574
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设 *p*=17，*q*=11。
- en: Compute *n*; *n*= 17*11=187.
  id: totrans-575
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算 *n*；*n*= 17*11=187。
- en: Compute *ϕ*(n); *ϕ*(n)=(17-1)*(11-1)=160.
  id: totrans-576
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算 *ϕ*(n)；*ϕ*(n)=(17-1)*(11-1)=160。
- en: Choose *e* such that gcd(*ϕ*(n), e)=1; choose *e*=7.
  id: totrans-577
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择 *e* 使得 gcd(*ϕ*(n), e)=1；选择 *e*=7。
- en: Compute *d* such that d≡e-1mod*ϕ*(n); d*e≡1mod160 and d¡160 ⟹ d=23 as 23*7=10*160+1.
  id: totrans-578
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算 *d* 使得 d≡e-1mod*ϕ*(n)；d*e≡1mod160 且 d¡160 ⟹ d=23 因为 23*7=10*160+1。
- en: Therefore, public key=(7, 187)
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，公钥=(7, 187)
- en: private key= (23, 187).tcolorbox
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: private key= (23, 187).tcolorbox
- en: '**Key point** Public key cryptosystem follows asymmetric property as the person
    who encrypts message or verifies the signature on the message can''t decrypt or
    sign signatures on the message.'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键点** 公钥密码系统遵循非对称属性，因为加密消息的人或验证消息上的签名的人不能解密消息或对消息上的签名进行签名。'
- en: '[5.8 Elliptic Curve Cryptography](contents.xhtml#rsec5_8)'
  id: totrans-582
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[5.8 椭圆曲线加密](contents.xhtml#rsec5_8)'
- en: 'Another way to perform public key cryptography is with elliptic curves. ECC
    is one of the most powerful concepts of cryptography. ECC is used for authentication,
    while secure web browsing over SSL/TLS. Popular cryptocurrency such as- Bitcoin
    and Etherem use the concept of elliptic curve. ECC is applicable for key generation,
    digital signatures and encryption/decryption services. Notably, ECC requires smaller
    key sizes as compared to RSA to provide equivalent security. Clearly, smaller
    key size are easy to manage and work with. A 256 bit ECC is equivalent to 3072-bit
    key size RSA algorithm. As ECC achieves equivalent security to RSA, with lower
    computing power and battery usage ECC has been popularly used for mobile applications.
    The key generation algorithm of the ECC uses the properties of elliptic curve
    equation which is discussed as follows:'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 通过椭圆曲线进行公钥密码学是另一种方法。ECC 是密码学中最强大的概念之一。ECC 用于身份验证，以及 SSL/TLS 上的安全网页浏览。流行的加密货币，如比特币和以太坊，使用椭圆曲线的概念。ECC
    适用于密钥生成、数字签名和加密/解密服务。值得注意的是，与 RSA 相比，ECC 需要更小的密钥大小以提供相同的安全性。显然，更小的密钥大小更易于管理和使用。256
    位 ECC 相当于 3072 位 RSA 算法的密钥大小。由于 ECC 实现了与 RSA 相当的安全性，并且需要更低的计算能力和电池使用量，因此 ECC 已广泛用于移动应用程序。ECC
    的密钥生成算法使用了椭圆曲线方程的性质，如下所述：
- en: An elliptic curve is defined as a set of points that satisfies a cubic mathematical
    equation (Refer [Fig. 5.14](07chap_05.xhtml#fig5_14)), i.e.,
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 椭圆曲线被定义为满足立方数学方程的一组点（参见[图 5.14](07chap_05.xhtml#fig5_14)），即，
- en: <math alttext="" display="block"><mrow><mtable columnalign="left"><mtr columnalign="left"><mtd
    columnalign="left"><mrow><msup><mi>y</mi><mn>2</mn></msup><mo>=</mo><msup><mi>x</mi><mn>3</mn></msup><mo>+</mo><mi>a</mi><mi>x</mi><mo>+</mo><mi>b</mi></mrow></mtd></mtr></mtable></mrow></math>(5.4)
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="" display="block"><mrow><mtable columnalign="left"><mtr columnalign="left"><mtd
    columnalign="left"><mrow><msup><mi>y</mi><mn>2</mn></msup><mo>=</mo><msup><mi>x</mi><mn>3</mn></msup><mo>+</mo><mi>a</mi><mi>x</mi><mo>+</mo><mi>b</mi></mrow></mtd></mtr></mtable></mrow></math>(5.4)
- en: where <math alttext="" display="inline"><mrow><mn>4</mn><msup><mi>a</mi><mn>3</mn></msup><mo>+</mo><mn>27</mn><msup><mi>b</mi><mn>2</mn></msup><mo>≠</mo><mn>0</mn></mrow></math>
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 <math alttext="" display="inline"><mrow><mn>4</mn><msup><mi>a</mi><mn>3</mn></msup><mo>+</mo><mn>27</mn><msup><mi>b</mi><mn>2</mn></msup><mo>≠</mo><mn>0</mn></mrow></math>
- en: To plot such a curve we need to compute <math alttext="" display="inline"><mrow><mi>y</mi><mo>=</mo><mo>±</mo><msqrt><mrow><msup><mi>x</mi><mn>3</mn></msup><mo>+</mo><mi>a</mi><mi>x</mi><mo>+</mo><mi>b</mi></mrow></msqrt></mrow></math>
    for combination of every *a* and *b*.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 要绘制这样的曲线，我们需要计算每个*a*和*b*的组合 <math alttext="" display="inline"><mrow><mi>y</mi><mo>=</mo><mo>±</mo><msqrt><mrow><msup><mi>x</mi><mn>3</mn></msup><mo>+</mo><mi>a</mi><mi>x</mi><mo>+</mo><mi>b</mi></mrow></msqrt></mrow></math>。
- en: '![Figure 5.14](../images/fig5_14.jpg)'
  id: totrans-588
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.14](../images/fig5_14.jpg)'
- en: '**FIGURE 5.14**'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 5.14**'
- en: An illustration of elliptic curve.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 椭圆曲线的示意图。
- en: '**Properties of elliptic curve**'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: '**椭圆曲线的性质**'
- en: Depending on values of a and b, elliptic curve takes different shapes on the
    plane
  id: totrans-592
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据a和b的值不同，椭圆曲线在平面上呈现不同的形状
- en: All elliptic curves are symmetric around x-axis. For example, if we take <math
    alttext="" display="inline"><mrow><mi>a</mi><mo>=</mo><mn>27</mn></mrow></math>
    and <math alttext="" display="inline"><mrow><mi>b</mi><mo>=</mo><mn>2</mn></mrow></math>,
    then for <math alttext="" display="inline"><mrow><mi>x</mi><mo>=</mo><mn>2</mn></mrow></math>,
    <math alttext="" display="inline"><mrow><mi>y</mi><mo>=</mo><mo>±</mo><mn>8</mn></mrow></math>,
    i.e., <math alttext="" display="inline"><mrow><mo stretchy="false">(</mo><mn>2</mn><mo>,</mo><mo>−</mo><mn>8</mn><mo
    stretchy="false">)</mo></mrow></math> and <math alttext="" display="inline"><mrow><mo
    stretchy="false">(</mo><mn>2</mn><mo>,</mo><mn>8</mn><mo stretchy="false">)</mo></mrow></math>
    are the resulting points.
  id: totrans-593
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有椭圆曲线都关于x轴对称。例如，如果我们取<math alttext="" display="inline"><mrow><mi>a</mi><mo>=</mo><mn>27</mn></mrow></math>和<math
    alttext="" display="inline"><mrow><mi>b</mi><mo>=</mo><mn>2</mn></mrow></math>，那么对于<math
    alttext="" display="inline"><mrow><mi>x</mi><mo>=</mo><mn>2</mn></mrow></math>，<math
    alttext="" display="inline"><mrow><mi>y</mi><mo>=</mo><mo>±</mo><mn>8</mn></mrow></math>，即，<math
    alttext="" display="inline"><mrow><mo stretchy="false">(</mo><mn>2</mn><mo>,</mo><mo>−</mo><mn>8</mn><mo
    stretchy="false">)</mo></mrow></math>和<math alttext="" display="inline"><mrow><mo
    stretchy="false">(</mo><mn>2</mn><mo>,</mo><mn>8</mn><mo stretchy="false">)</mo></mrow></math>是结果点。
- en: Any non vertical line intersects the curve in atmost three points.
  id: totrans-594
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何非垂直线在曲线上最多交于三点。
- en: 'The points on an elliptic curve form a group. The group operation applicable
    for points on elliptic curve is called addition law. To add a point P the on curve
    with another point Q, use the rule:'
  id: totrans-595
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 椭圆曲线上的点形成一个群。适用于椭圆曲线上的点的群操作称为加法法则。要将曲线上的点P与另一个点Q相加，请使用以下规则：
- en: First, join P and Q with a straight line.
  id: totrans-596
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，用一条直线连接P和Q。
- en: Call this point -R where this straight line intersects with the curve.
  id: totrans-597
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 称此点为-R，其中这条直线与曲线相交。
- en: The mirror image of this point with respect to x-coordinate defines the addition
    of points P and Q and is denoted by R in [Fig. 5.15](07chap_05.xhtml#fig5_15).
  id: totrans-598
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相对于x坐标的此点的镜像定义了点P和Q的加法，并在[图5.15](07chap_05.xhtml#fig5_15)中用R表示。
- en: '![Figure 5.15](../images/fig5_15.jpg)'
  id: totrans-599
  prefs: []
  type: TYPE_IMG
  zh: '![图5.15](../images/fig5_15.jpg)'
- en: '**FIGURE 5.15**'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: '**图5.15**'
- en: Addition of points on elliptic curve.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 椭圆曲线上的点的加法。
- en: Key point
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 关键点
- en: A trapdoor function *f* is defined as a function that is easy to calculate but
    whose inverse <math alttext="" display="inline"><mrow><msup><mi>f</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow></math>
    is difficult to compute.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 陷阱门函数*f*被定义为一个易于计算但其逆<mrow><msup><mi>f</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow>难以计算的函数。
- en: Activity
  id: totrans-604
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动
- en: Multiple Choice Questions
  id: totrans-605
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多项选择题
- en: Which encryption/decryption key is only known to parties exchanging secret messages?
  id: totrans-606
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个加密/解密密钥只有交换秘密消息的各方知道？
- en: Public key
  id: totrans-607
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 公钥
- en: Private key
  id: totrans-608
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 私钥
- en: Security token
  id: totrans-609
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安全令牌
- en: e-signatures
  id: totrans-610
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 电子签名
- en: Which is not a function of private key?
  id: totrans-611
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个不是私钥的功能？
- en: Encrypting text
  id: totrans-612
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加密文本
- en: Authentication
  id: totrans-613
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 认证
- en: Decrypting text
  id: totrans-614
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解密文本
- en: None of these
  id: totrans-615
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以上皆非
- en: What is cipher?
  id: totrans-616
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 密码是什么？
- en: Algorithm for encryption
  id: totrans-617
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加密算法
- en: Decrypted message
  id: totrans-618
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解密消息
- en: Encrypted message
  id: totrans-619
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加密消息
- en: Secret key
  id: totrans-620
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 密钥
- en: Cryptographic hash function converts a arbitrary block into a ………?
  id: totrans-621
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 密码哈希函数将任意块转换为……？
- en: Variable size string
  id: totrans-622
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可变大小的字符串
- en: Fixed size string
  id: totrans-623
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 固定大小的字符串
- en: Both fixed and variable size string
  id: totrans-624
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 固定大小和可变大小的字符串都是
- en: Can't say
  id: totrans-625
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不能确定
- en: Which among the following is the component of CIA triad?
  id: totrans-626
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个是CIA三位一体的组成部分？
- en: Confidentiality
  id: totrans-627
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 机密性
- en: Integrity
  id: totrans-628
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完整性
- en: Authentication
  id: totrans-629
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 身份验证
- en: Availability
  id: totrans-630
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可用性
- en: What are thr requirements of a hash function?
  id: totrans-631
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哈希函数的要求是什么？
- en: One-way
  id: totrans-632
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单向的
- en: Avalanche effect
  id: totrans-633
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 雪崩效应
- en: Deterministic
  id: totrans-634
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定性的
- en: All of the above
  id: totrans-635
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以上所有
- en: Cryptanalysis is ……
  id: totrans-636
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 密码分析是……
- en: To decrease the speed of encryption
  id: totrans-637
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了降低加密速度
- en: To increase the speed of encryption
  id: totrans-638
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了增加加密速度
- en: To generate ciphertext
  id: totrans-639
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成密文
- en: To find insecurities in cryptographic algorithm
  id: totrans-640
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了找到加密算法中的不安全性
- en: Digital signature is based on …..?
  id: totrans-641
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数字签名是基于……？
- en: Public key encryption
  id: totrans-642
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 公钥加密
- en: Private key encryption
  id: totrans-643
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 私钥加密
- en: Blockchain technology
  id: totrans-644
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 区块链技术
- en: None of the above
  id: totrans-645
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以上都不是
- en: What are the properties of zero knowledge proof?
  id: totrans-646
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 零知识证明的特性是什么？
- en: Completeness
  id: totrans-647
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完备性
- en: Soundness
  id: totrans-648
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明
- en: Zero knowledge
  id: totrans-649
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 零知识
- en: None of the above
  id: totrans-650
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以上都不是
- en: Which among of the following is collision rsolution technique?
  id: totrans-651
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪种是冲突解决技术？
- en: Quadratic probing
  id: totrans-652
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 二次探测
- en: ECC
  id: totrans-653
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: ECC
- en: DSA
  id: totrans-654
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: DSA
- en: All of the above
  id: totrans-655
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以上所有
- en: 1\. b  2\. a  3\. c  4\. b  5\. c  6\. d  7\. d  8\. a  9\. a, b, c  10\. a
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. b  2\. a  3\. c  4\. b  5\. c  6\. d  7\. d  8\. a  9\. a, b, c  10\. a
- en: <hgroup>
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: '[6](contents.xhtml#rchapter6)'
  id: totrans-658
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[6](contents.xhtml#rchapter6)'
- en: '[Blockchain Technology and Technical Foundations](contents.xhtml#rchapter6)'
  id: totrans-659
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[区块链技术与技术基础](contents.xhtml#rchapter6)'
- en: </hgroup>
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '[6.1 Fundamentals of Blockchain](contents.xhtml#rsec6_1)'
  id: totrans-661
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[6.1 区块链基础](contents.xhtml#rsec6_1)'
- en: Blockchain is a growing list of blocks that combines cryptography with distributed
    computing in order to provide decentralized, transparent, and strong consistency
    support. In particular, blockchain technology is replacing the existing transaction
    management system [[112](bib.xhtml#ch00-bib-112)]. Notably, the traditional way
    of writing something in a shared document is that user1 will send the document
    to user2 and user2, after receiving the document update the document with its
    own content and send it back to user1\. However, this method does not allow both
    parties to write on the document simultaneously. As a solution, with Google Docs
    provided by Microsoft Word both of user1 and user2 can write simultaneously. Nevertheless,
    this Google doc platform is centralized and involves a third party. Mostly, the
    traditional distributed databases are centralized, have high complexity, and they
    rely on trusted database company.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链是一个不断增长的区块列表，结合了密码学和分布式计算，以提供去中心化、透明和强一致性支持。特别是，区块链技术正在取代现有的交易管理系统[[112](bib.xhtml#ch00-bib-112)]。值得注意的是，在共享文档中传统的写作方式是用户1将文档发送给用户2，用户2在接收到文档后用自己的内容更新文档，并将其发送回用户1。然而，这种方法不允许双方同时在文档上写作。作为解决方案，通过由微软Word提供的Google
    Docs，用户1和用户2都可以同时进行写作。尽管如此，这个Google文档平台是集中化的，涉及第三方。大多数传统的分布式数据库都是集中化的，复杂性很高，并且依赖于可信的数据库公司。
- en: Centralized architecture has a central co-ordination system and every node on
    the network is connected to this system. Any information sharing in the network
    has to involve this central coordination system. Nevertheless, there are some
    disadvantages with a centralized system.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 集中式架构具有一个中央协调系统，网络上的每个节点都连接到这个系统。网络中任何信息共享都必须涉及这个中央协调系统。尽管如此，集中式系统也有一些缺点。
- en: 'Single point of failure: What if the system or the server crashes. Unfortunately,
    in case of a crash of this central system, all nodes on the network get disconnected
    to the network and all operations get terminated. This situation may lead to the
    loss of entire information. Therefore, complete dependency on a single server
    is not efficient.'
  id: totrans-664
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '单点故障: 如果系统或服务器崩溃怎么办。不幸的是，在中央系统崩溃的情况下，网络上的所有节点都会断开连接，所有操作都会终止。这种情况可能导致整个信息的丢失。因此，完全依赖单个服务器是不高效的。'
- en: 'Bottleneck: Bottlenecks are common in case of increased traffic.'
  id: totrans-665
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '瓶颈: 在交通量增加的情况下，瓶颈很常见。'
- en: 'Single point of attack: As there is a single central authority, there are chances
    of a single point of attack. Therefore, this type of architecture can easily suffer
    a denial-of-service attack.'
  id: totrans-666
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '单一攻击点: 由于存在单一中央权威，存在着单一攻击点的可能性。因此，这种类型的架构很容易遭受到拒绝服务攻击。'
- en: 'Delay: As a centralized server is mostly located at a far location from users,
    so time to access data increases.'
  id: totrans-667
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '延迟: 由于集中式服务器通常位于用户远处的位置，因此访问数据的时间增加了。'
- en: 'Higher privacy risk: As centralized architectures involve a trusted third party,
    so the user is unaware of how the information of users is secured with the third
    party. The trusted third party may share the private information of users with
    other parties.'
  id: totrans-668
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更高的隐私风险：由于集中式架构涉及到一个可信赖的第三方，因此用户不知道用户信息如何与第三方安全保护。可信赖的第三方可能会与其他方分享用户的私人信息。
- en: 'Over and above, there are other architectures to support information sharing,
    i.e., distributed and decentralized architectures:'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，还有其他架构支持信息共享，即分布式和分散式架构：
- en: In a decentralized architecture, rather than having a single co-coordinator,
    multiple co-coordinators are present and nodes of the network are connected to
    any of these coordinators. So, in case of one co-ordinator node failure, nodes
    of the network can connect to any other co-ordinator to share information. Decentralization
    supports fault tolerance as decentralized systems are less likely to crash accidentally.
    Moreover, due to the presence of multiple coordinators, there is no chance of
    a single point of attack. On the other hand, in a distributed architecture, all
    nodes of the network participate in the computations and there is no single authority
    in charge. All nodes of the network co-ordinator with each other and collectively
    involves in the information sharing process. A decentralized system is actually
    part of the distributed system. In a decentralized and distributed network, both
    user1 and user2 has their own local copy of the document and both of the users
    can simultaneously write on the document.
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 在分散式架构中，与单一的协调者不同，存在多个协调者，网络节点连接到任何一个协调者。因此，如果一个协调者节点发生故障，网络节点可以连接到任何其他协调者共享信息。分散化支持容错性，因为分散系统不太可能意外崩溃。而且，由于存在多个协调者，不存在单一攻击点的可能。另一方面，在分布式架构中，网络的所有节点参与计算，没有单一的权威机构。网络的所有节点相互协调，并共同参与信息共享过程。分散式系统实际上是分布式系统的一部分。在分散和分布式网络中，用户1和用户2都有自己的文档的本地副本，并且两个用户都可以同时编辑文档。
- en: Blockchain is a platform that provides support for decentralized and distributed
    architecture where nodes of the network can share information among themselves.
    In contrast to a client-server model, blockchain implements a digital P2P network.
    In a blockchain network, there are multiple nodes connected via the Internet and
    each node maintains a local copy of global sheet. However, these local copies
    should be updated always as per the global information. In particular, this local
    copy of data is called a public ledger. A popular example of the public ledger
    is the banking transactions and the first popular use case of blockchain is the
    Bitcoin network. Blockchain bitcoin is referred to as decentralized system for
    exchanging cryptocurrency and it also shares distributed ledger. Many other blockchain
    cryptocurrency platforms were introduced including Ethereum leveraging the same
    public model as Bitcoin, whereas platforms such as- Hyperledger, Ripple are some
    permissioned blockchain. Although the distributed applications of blockchain are
    used in many other sectors including healthcare, IoT, smart grid, etc. Blockchain
    provides a decentralized common platform for multiple parties who don't trust
    each other and are involved in information sharing or rational decision-making
    process. This technology provides an effective way of storing transactions in
    a secure, transparent, and highly resistant way. The blockchain network makes
    sure regarding ensuring consistency and maintaining synchronization of the document.
    Anything stored on the blockchain has transparent nature and anyone modifying
    it is accountable for their actions. Moreover, the decentralized nature of this
    network ensures that a single node on the network can't append invalid blocks
    to the chain. Before a transaction is added to the blockchain network, it is validated
    by all the participants on the blockchain network. Before adding a new block to
    the blockchain network, it is always linked to the previous block with cryptographic
    hash of the immediately previous block. Therefore, cryptographic linking ensures
    the integrity of the network. As every block is cryptographically linked to the
    previous block hash that is why the name blockchain is defendable. If any block
    is altered, attackers need to modify all subsequent blocks which are quite difficult.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链是一个平台，为去中心化和分布式架构提供支持，网络节点可以在彼此之间共享信息。与客户端-服务器模型相反，区块链实现了数字P2P网络。在区块链网络中，通过互联网连接着多个节点，每个节点维护着全局表的本地副本。然而，这些本地副本应始终根据全局信息进行更新。具体来说，这些数据的本地副本称为公共账本。公共账本的一个常见例子是银行交易，而区块链的第一个流行用例是比特币网络。区块链比特币被称为去中心化的加密货币交换系统，它还共享分布式账本。许多其他区块链加密货币平台也相继推出，包括以比特币相同的公共模型为基础的以太坊，而像超级账本、瑞波这样的平台则属于一些许可的区块链。尽管区块链的分布式应用在许多其他领域中得到应用，包括医疗保健、物联网、智能电网等。区块链为不信任彼此且涉及信息共享或理性决策过程的多个参与方提供了一个去中心化的共同平台。这项技术提供了一种安全、透明且高度抗攻击的存储交易的有效方式。区块链网络确保了文档的一致性和同步性。存储在区块链上的任何内容都具有透明的特性，对其进行修改的任何人都要对其行为负责。此外，该网络的去中心化性质确保网络上的单个节点无法向链中追加无效的区块。在将交易添加到区块链网络之前，它需要由区块链网络上的所有参与者进行验证。在将新区块添加到区块链网络之前，它始终与前一个区块通过立即前一个区块的密码哈希进行链接。因此，密码链接确保了网络的完整性。由于每个区块都与前一个区块的哈希密码链接，所以区块链这个名字是可被捍卫的。如果任何一个区块被修改，攻击者需要修改所有后续的区块，这是相当困难的。
- en: According to Wikipedia, A blockchain is a continuously growing list of records
    called blocks, which are linked using cryptography [[8](bib.xhtml#ch00-bib-8)].
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 根据维基百科，区块链是一个不断增长的记录列表，称为区块，它们使用加密技术链接在一起。
- en: Blockchain technology is primarily based on the fundamentals of cryptography
    and distributed ledger technology. In particular, blockchain uses the concept
    of hash functions, ECC, digital signatures and Elliptic Curve Digital Signature
    Algorithm (ECDSA) to maintain integrity, confidentiality, and non-repudiation
    of the system. A distributed ledger is a kind of database that is shared and synchronized
    among nodes of the decentralized network. Moreover, each record in distributed
    ledger is timestamped in order to achieve the integrity of the document. However,
    a consensus mechanism is used by network participants to achieve mutual agreements
    on a single state of the network in a distributed environment. Clearly, the consensus
    mechanism minimizes the risk of fraudulent transactions.
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链技术主要基于加密学和分布式账本技术的基础。具体而言，区块链利用哈希函数、ECC、数字签名和椭圆曲线数字签名算法（ECDSA）的概念来维护系统的完整性、机密性和不可否认性。分布式账本是一种数据库，它在去中心化网络的节点之间共享和同步。此外，分布式账本中的每一条记录都有时间戳，以实现文档的完整性。然而，在分布式环境中，网络参与者使用共识机制来就网络的单一状态达成共识协议。显然，共识机制能够降低欺诈交易的风险。
- en: Blockchain mining is a process of validating transactions before it is added
    to the network and miners are the entity that is responsible for validating and
    generating a new block in the network. Some special nodes with some special characteristics
    (different for every blockchain network) are only regarded as a miner. Further,
    the mined block is broadcasted in the network to be verified by other nodes before
    final inclusion in the network. Whenever a new Bitcoin transaction is made it
    is first placed in a transaction pool. Rather than validating a single transaction,
    miners collect a certain number of transactions from the transaction pool to form
    a candidate block. Hence, a candidate block is referred to as a block that has
    been created by a miner but it is not added to the network. It may so happen that
    multiple miners can mine a block with exactly same or some different transactions
    simultaneously or in a near identical time. However, when two blocks get mined
    simultaneously, there is a possibility that only one miner's blocks get more number
    of blocks on top of it. If multiple valid blocks to the existing chain appear,
    in that case, only the longest subbranch is accepted and continued further; and
    the blocks that are not accepted are called orphaned blocks and that path is called
    forks. In other words, orphan blocks are those blocks which do not have any link
    to main branch due to missing predecessor. Additionally, if there are two different
    chains of the same length then accept the chain which has been broadcasted by
    more number of miners. Transactions from these blocks which are not validated
    are sent back to the transaction pool. In such cases, efforts of miners go useless
    as mined blocked becomes unrecorded.
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链挖矿是在交易被添加到网络之前验证交易的过程，矿工是负责验证并在网络中生成新区块的实体。一些具有一些特殊特性（每个区块链网络都不同）的特殊节点才被视为矿工。此后，挖出的区块在网络中广播，以便其他节点在最终纳入网络之前对其进行验证。每当进行新的比特币交易时，它首先被放置在一个交易池中。矿工不是验证单个交易，而是从交易池中收集一定数量的交易来形成候选区块。因此，候选区块是指由矿工创建但尚未添加到网络中的区块。可能会出现多个矿工同时或几乎在相同的时间内挖掘出具有完全相同或部分不同交易的区块的情况。然而，当两个区块同时被挖出时，有可能只有一个矿工的区块上面有更多的区块。如果出现多个有效区块到现有链的情况，那么只接受最长的子分支并继续进行；而未被接受的区块称为孤立区块，该路径称为分叉。换句话说，孤立区块是由于缺少前任而没有与主分支相关联的区块。此外，如果有两条长度相同的不同链，则接受被更多数量的矿工广播的链。这些未经验证的区块中的交易被送回到交易池。在这种情况下，矿工的努力变得无用，因为已挖出的区块变得未记录。
- en: '[6.1.1 Characteristics of blockchain technology](contents.xhtml#rsec6_1_1)'
  id: totrans-675
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[6.1.1 区块链技术的特性](contents.xhtml#rsec6_1_1)'
- en: 'Decentralization: Blockchain technology does not depend on a centralized system
    or any governing authority to perform all transactions. Instead, the network is
    controlled by nodes of the network making it decentralized. Every node on the
    network has its copy of shared ledger which is updated. Moreover, it solves the
    problem of a single point of failure.'
  id: totrans-676
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 去中心化：区块链技术不依赖于集中式系统或任何治理机构来执行所有交易。相反，网络由网络节点控制，使其去中心化。网络上的每个节点都有其更新的共享账本副本。此外，它解决了单点故障的问题。
- en: 'Better security: Cybersecurity is defined as a capability to prevent and recover
    from cyber-attacks. Blockchain technology provides better security as there is
    not any chance of system failure. The use of a cryptography system by blockchain
    provides protection for users. Another reason for the popularity of blockchain
    technology is basically its capability to deal with the threat of an individual''s
    privacy. All transactions are verified and it is quite hard to modify these transactions.'
  id: totrans-677
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更好的安全性：网络安全被定义为防止和从网络攻击中恢复的能力。区块链技术提供了更好的安全性，因为不存在任何系统失败的机会。区块链采用的加密系统为用户提供了保护。区块链技术受欢迎的另一个原因基本上是其处理个人隐私威胁的能力。所有交易都经过验证，修改这些交易是相当困难的。
- en: 'Immutability: Immutable ledger is the main advantage of the blockchain system.
    Immutability implies data on the network can''t be changed or altered. Blockchain
    stores permanent records of transactions. After a block is verified and added
    to the network, it can''t be modified or deleted. Moreover, the lack of centralization
    promotes scalability and robustness. Centralized architecture can be tampered
    and requires trust in a third party to maintain integrity.'
  id: totrans-678
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可变性：不可变账本是区块链系统的主要优势。不可变性意味着网络上的数据无法更改或更改。区块链存储交易的永久记录。一旦区块被验证并添加到网络中，就无法修改或删除。此外，去中心化的特性促进了可伸缩性和鲁棒性。集中化架构可能受到篡改，并需要对第三方的信任来维护完整性。
- en: 'Anonymity: Blockchain provides anonymity as nodes are known by their public
    keys on the network. Therefore, the identities of the nodes are kept private.'
  id: totrans-679
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 匿名性：区块链提供了匿名性，因为节点在网络上是以其公钥而非身份来识别的。因此，节点的身份被保持私密。
- en: 'Transparency: Any node on the network can audit transactions and every node
    has access to same universal ledger. Every state of data and every updating state
    is visible to node of the network.'
  id: totrans-680
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 透明度：网络上的任何节点都可以审计交易，每个节点都可以访问相同的通用账本。网络中的每个数据状态和每个更新状态对节点都是可见的。
- en: 'Redundancy: As copy of distributed ledger is stored with every full node on
    the network, hence redundancy is inherent for blockchain.'
  id: totrans-681
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 冗余性：由于分布式账本的副本存储在网络上的每个完整节点上，因此区块链具有固有的冗余性。
- en: 'Efficiency: All transactions are automatically executed via pre set procedures.
    Hence, blockchain technology reduces cost of labor along with improving efficiency.'
  id: totrans-682
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 效率：所有交易都通过预设的程序自动执行。因此，区块链技术降低了劳动成本，并提高了效率。
- en: '[6.1.2 What constitutes a block of blockchain?](contents.xhtml#rsec6_1_2)'
  id: totrans-683
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[6.1.2 什么构成了区块链的一个区块？](contents.xhtml#rsec6_1_2)'
- en: 'The first block in a blockchain is called genesis block and this block doesn''t
    have ant previous block. All network participants should have the same genesis
    block in order to attain the correctness of the blockchain network. The previous
    hash value for a genesis block is zero. The structure of blockchain comprises
    of strings of blocks, each holding transactions of data and metadata. Data inside
    a block contains transactions generated by participants of the network and blocks
    hold the transaction in a secure way so that they can''t be tampered. A transaction
    is an atomic event or the smallest building block allowed by a particular protocol.
    For instance, in Bitcoin blockchain transactions are user''s payments. On the
    other hand, the metadata contains information regarding block including parent
    block hash, timestamp, etc. This informative metadata is used by miners or the
    other nodes of the network to verify a block or to append a block to the blockchain.
    The structure of chained block is represented by [Fig. 6.1](08chap_06.xhtml#fig6_1).
    Metadata of the block is stored in block header ad consists of the following field:'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链中的第一个区块称为创世区块，该区块没有任何前一个区块。为了确保区块链网络的正确性，所有网络参与者都应该有相同的创世区块。创世区块的前一哈希值为零。区块链的结构包括一系列区块，每个区块包含数据和元数据的交易。区块中的数据包含网络参与者生成的交易，而区块以安全的方式保存交易，以防篡改。交易是由特定协议允许的原子事件或最小的构建块。例如，在比特币区块链中，交易是用户的支付。另一方面，元数据包含有关区块的信息，包括父区块哈希值、时间戳等。这些信息性的元数据由矿工或网络的其他节点用于验证一个区块或将一个区块附加到区块链上。链式区块的结构由[图6.1](08chap_06.xhtml#fig6_1)表示。区块的元数据存储在区块头中，包括以下字段：
- en: 'Version: The version number is used to track protocol upgrades used by blockchain
    nodes.'
  id: totrans-685
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本：版本号用于跟踪区块链节点使用的协议升级。
- en: 'Timestamp: It specifies the creation time of the block.'
  id: totrans-686
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间戳：它指定了区块的创建时间。
- en: 'Nonce: It is a random number used to solve the Proof-of-Work (PoW) cryptographic
    puzzle as shown in Eq. 6.1.2.'
  id: totrans-687
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随机数：它是一个随机数，用于解决工作量证明（PoW）密码难题，如式6.1.2所示。
- en: <math alttext="" display="block"><mrow><mtable columnalign="left"><mtr columnalign="left"><mtd
    columnalign="left"><mrow><mi>S</mi><mi>H</mi><mi>A</mi><mo>−</mo><mn>256</mn><mo
    stretchy="false">(</mo><mi>S</mi><mi>H</mi><mi>A</mi><mo>−</mo><mn>256</mn><mo
    stretchy="false">(</mo><mi>P</mi><mi>r</mi><mi>e</mi><mi>v</mi><mi>i</mi><mi>o</mi><mi>u</mi><mi>s</mi><mi>b</mi><mi>l</mi><mi>o</mi><mi>c</mi><mi>k</mi><mi>h</mi><mi>a</mi><mi>s</mi><mi>h</mi><mo>|</mo><mo>|</mo><mi>T</mi><msub><mi>x</mi><mn>1</mn></msub></mrow></mtd></mtr><mtr
    columnalign="left"><mtd columnalign="left"><mrow><mo>|</mo><mo>|</mo><mi>T</mi><msub><mi>x</mi><mn>2</mn></msub><mo>|</mo><mo>|</mo><mn>.......</mn><mo>|</mo><mo>|</mo><mi>T</mi><msub><mi>x</mi><mi>n</mi></msub><mo>|</mo><mo>|</mo><mi>n</mi><mi>o</mi><mi>n</mi><mi>c</mi><mi>e</mi><mo
    stretchy="false">)</mo><mo stretchy="false">)</mo><mo><</mo><mi>D</mi><mi>i</mi><mi>f</mi><mi>f</mi><mi>i</mi><mi>c</mi><mi>u</mi><mi>l</mi><mi>t</mi><mi>y</mi></mrow></mtd></mtr></mtable></mrow></math>(6.1)
  id: totrans-688
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <math alttext="" display="block"><mrow><mtable columnalign="left"><mtr columnalign="left"><mtd
    columnalign="left"><mrow><mi>S</mi><mi>H</mi><mi>A</mi><mo>−</mo><mn>256</mn><mo
    stretchy="false">(</mo><mi>S</mi><mi>H</mi><mi>A</mi><mo>−</mo><mn>256</mn><mo
    stretchy="false">(</mo><mi>P</mi><mi>r</mi><mi>e</mi><mi>v</mi><mi>i</mi><mi>o</mi><mi>u</mi><mi>s</mi><mi>b</mi><mi>l</mi><mi>o</mi><mi>c</mi><mi>k</mi><mi>h</mi><mi>a</mi><mi>s</mi><mi>h</mi><mo>|</mo><mo>|</mo><mi>T</mi><msub><mi>x</mi><mn>1</mn></msub></mrow></mtd></mtr><mtr
    columnalign="left"><mtd columnalign="left"><mrow><mo>|</mo><mo>|</mo><mi>T</mi><msub><mi>x</mi><mn>2</mn></msub><mo>|</mo><mo>|</mo><mn>.......</mn><mo>|</mo><mo>|</mo><mi>T</mi><msub><mi>x</mi><mi>n</mi></msub><mo>|</mo><mo>|</mo><mi>n</mi><mi>o</mi><mi>n</mi><mi>c</mi><mi>e</mi><mo
    stretchy="false">)</mo><mo stretchy="false">)</mo><mo><</mo><mi>D</mi><mi>i</mi><mi>f</mi><mi>f</mi><mi>i</mi><mi>c</mi><mi>u</mi><mi>l</mi><mi>t</mi><mi>y</mi></mrow></mtd></mtr></mtable></mrow></math>(6.1)
- en: 'Difficulty/Target: This is used by PoW algorithm to solve mining process. For
    a block to be added in the blockchain network, it has to generate a valid hash
    and difficulty value is used in achieving this task.'
  id: totrans-689
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 难度/目标值：这是 PoW 算法用于解决挖矿过程的。要将一个区块添加到区块链网络中，它必须生成一个有效的哈希值，难度值用于完成这个任务。
- en: 'Previous block hash: As mentioned earlier, every nnt block of blockchain stores
    hash of previous block, i.e., (n-1)nt block. In order to compute hash of (n-1)th
    block, all header field of (n-1)nt block are collectively hashed twice.'
  id: totrans-690
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上一个区块的哈希值：如前所述，区块链的每个第 n 个区块都存储前一个区块，即第 (n-1) 个区块的哈希值。为了计算第 (n-1) 个区块的哈希值，需要将第
    (n-1) 个区块的所有头部字段集体哈希两次。
- en: 'Merkle tree: It contains the value of root of merkle tree which is explained
    in detail later in next chapter. It is basically a tree structure where the nodes
    at leaf level contain the hash of the document and every intermediate node contains
    the hash of left and a right child. As it is presented in [Fig. 6.2](08chap_06.xhtml#fig6_2),
    there are 8 transactions, i.e., t1, t2,…………,t8\. Leaf nodes of the Merkle tree
    contain the direct hash of these transactions and then level 1 has intermediate
    nodes with hash value of its left and right child (,i.e., obtained hashes are
    again paired to calculate the hash for next level). This hash will be recursively
    calculated until a single root hash is obtained.'
  id: totrans-691
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Merkle 树：它包含 Merkle 树根的值，稍后在下一章节详细解释。它基本上是一个树形结构，其中叶节点包含文档的哈希值，每个中间节点包含左右子节点的哈希值。正如在
    [图 6.2](08chap_06.xhtml#fig6_2) 中所示，有 8 个交易，即 t1、t2、……、t8。Merkle 树的叶节点包含这些交易的直接哈希值，然后第
    1 层具有中间节点，其左右子节点的哈希值（即，获取的哈希值再次成对计算以计算下一级别的哈希）。此哈希将递归计算，直到获得单个根哈希。
- en: '![Figure 6.1](../images/fig6_1.jpg)'
  id: totrans-692
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.1](../images/fig6_1.jpg)'
- en: '**FIGURE 6.1**'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 6.1**'
- en: Structure of chained blocks.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链的结构。
- en: '**Key point** Mandatory fields are transactions, Merkle root hash, and hash
    of the previous block which are used by every blockchain network, rest other are
    specific to particular blockchain application.'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键点** 强制字段是交易、Merkle 根哈希和上一个区块的哈希，每个区块链网络都使用这些字段，其余字段特定于特定的区块链应用程序。'
- en: '![Figure 6.2](../images/fig6_2.jpg)'
  id: totrans-696
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.2](../images/fig6_2.jpg)'
- en: '**FIGURE 6.2**'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 6.2**'
- en: Structure of Merkle Tree.
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: Merkle 树的结构。
- en: In addition to this, Merkle hash tree is used in membership verification. Notably,
    to verify membership of any given transaction, the verifier does not need to possess
    a complete Merle tree, rather only (log n) piece of data is enough where n is
    the total number of nodes in the tree. As every node has access to block header,
    so the root value of Merle hash tree can be downloaded from there. Suppose, user
    A has root node of Merkle tree for a block and user B wants to prove user A that
    transaction t4 is in the block. (Refer to [Fig. 6.2](08chap_06.xhtml#fig6_2).
    To accomplish this, user 2 has to provide user 1 some siblings of the nodes in
    the tree path from t4 to the root, so that user A can recompute root hash of the
    tree and match it against the one downloaded from the block. For example, To verify
    the presence of transaction t4 in the block user 2 has to actually provide user1
    c, a’ and b” along with hash of transaction t4\. With knowing c and a, b’ can
    be computed and b’ when combined with a’ can compute a” and finally root hash
    can be computed with a” and b”. Infact, user 2 can actually prove the presence
    of t4 in the block without even revealing its content by just proving hash of
    t4.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，Merkle 哈希树还用于成员身份验证。值得注意的是，为了验证任何给定交易的成员身份，验证者不需要拥有完整的 Merle 树，而仅仅(log
    n)个数据就足够了，其中 n 是树中节点的总数。由于每个节点都可以访问区块头，所以 Merle 哈希树的根值可以从那里下载。假设用户 A 拥有块的 Merkle
    树根节点，而用户 B 想要向用户 A 证明交易 t4 在块中。（参见 [图 6.2](08chap_06.xhtml#fig6_2)）。为了实现这一点，用户
    2 必须向用户 1 提供树路径中与 t4 相关的节点的一些兄弟节点，以便用户 A 可以重新计算树的根哈希，并将其与从块中下载的哈希进行匹配。例如，为了验证交易
    t4 是否存在于块中，用户 2 实际上必须向用户 1 提供 c、a' 和 b''，以及交易 t4 的哈希值。知道 c 和 a 后，可以计算出 b'，而 b'
    与 a' 结合后可以计算出 a''，最终可以使用 a'' 和 b'' 计算出根哈希。事实上，用户 2 甚至可以仅通过证明 t4 的哈希值而无需透露其内容就证明
    t4 存在于块中。
- en: Therefore, even in the presence of a large number of blocks in Merkle tree,
    membership of any element can be proved in relatively short time. With having
    only hash values of top level nodes, it is easy to traverse down to any leaf node
    in order to check whether it is tampered or not.tcolorbox
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，即使在 Merkle 树中有大量的区块的情况下，任何元素的成员身份也可以在相对较短的时间内证明。只需拥有顶级节点的哈希值，就可以轻松地遍历到任何叶节点，以检查它是否被篡改。
- en: '**Key point** With merkle tree membership of any transaction can be verified
    in O(log n) time and space complexity.'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键点** 使用 Merkle 树，任何交易的成员身份都可以在 O(log n) 的时间和空间复杂度内进行验证。'
- en: '[6.1.3 Bitcoin basics](contents.xhtml#rsec6_1_3)'
  id: totrans-702
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[6.1.3 比特币基础知识](contents.xhtml#rsec6_1_3)'
- en: Bitcoin is regarded as the first fully functional digital currency. It completely
    executes a P2P banking system without any central financial organization [[160](bib.xhtml#ch00-bib-160)].
    The bitcoin blockchain network is a network where users can send or receive cryptocurrency
    among themselves. It comes under the public blockchain and anyone in the world
    can be a part of the Bitcoin network. Here, transaction is a transfer of cryptocurrency
    from one node of the network to another network. Every registered node on the
    blockchain network has a pair of public and private keys held in the Bitcoin wallet
    of that person. Over and above, the Bitcoin wallet address never carries the name
    or identity of the person. Basically, a wallet address is the mathematical correspondence
    of the public key used by the user. Therefore, using the Bitcoin address maintains
    the anonymity of the network. Notably, the user can have more than one address.
    Suppose, user A wants to transfer some Bitcoins to user B. Anyone having user
    B walled address can transfer Bitcoin to his account however, to release money
    only public key of user B is required. To accomplish this, user A will create
    a transaction specifying the amount of money user A wants to transfer and user
    B address. Next, the user will sign the transaction and broadcast this transaction
    in the network. To create digital signatures, take the hash of the transaction
    and apply encryption using senders private key. Anyone in the network or specifically
    a miner can validate this transaction's integrity, authentication, and non-repudiation
    using user A public key. Notably, when a user sends Bitcoin to another address,
    wallet of that user creates a transaction output having an address of another
    user to whom money is being transferred and this transaction is recorded on blockchain
    network with Bitcoin address of the sender as the transaction input. In another
    way, an input is a reference to the output of a previous transaction. In the case
    of multiple transactions, all the total coin value is added up and it can be used
    by the output of the new transactions. For example, in [Fig. 6.3](08chap_06.xhtml#fig6_3),
    Payer B creates a transaction Y by signing its own coins received from transaction
    1 using his/her private key and adding its own public key and address of payee
    C. Anybody on the network can use B's public key to validate the transaction and
    to ensure B is spending the right coins. However, for any transaction to be accepted
    by the rest of the network, transaction blocks need to be validated and miners
    validating the nodes must include PoW in the block. Here, miners are special nodes
    with good computational power and resources. Notably, the block size in a Bitcoin
    network can't exceed 1 MB to achieve fast propagation.
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币被视为第一个完全功能的数字货币。它完全执行了一个无需任何中央金融机构的P2P银行系统 [[160](bib.xhtml#ch00-bib-160)]。比特币区块链网络是一个用户之间可以发送或接收加密货币的网络。它属于公共区块链，世界上的任何人都可以成为比特币网络的一部分。在这里，交易是网络中一个节点向另一个节点转移加密货币。区块链网络上的每个注册节点都有一对公钥和私钥，保存在该人的比特币钱包中。此外，比特币钱包地址从不带有人的姓名或身份。基本上，钱包地址是用户使用的公钥的数学对应。因此，使用比特币地址可以维护网络的匿名性。值得注意的是，用户可以拥有多个地址。假设用户A想向用户B转移一些比特币。拥有用户B的钱包地址的任何人都可以将比特币转入其账户，但是，仅需要用户B的公钥才能释放资金。为了实现这一点，用户A将创建一个指定用户A想要转移的金额和用户B地址的交易。接下来，用户将签署交易并在网络中广播此交易。要创建数字签名，取交易的哈希并使用发送方的私钥进行加密。网络中的任何人或特定的矿工都可以使用用户A的公钥验证此交易的完整性、认证性和不可否认性。值得注意的是，当用户向另一个地址发送比特币时，该用户的钱包创建一个交易输出，其中包含要转账的另一个用户的地址，并且此交易记录在区块链网络上，发送者的比特币地址作为交易输入。另一种方式，在多个交易的情况下，所有总硬币价值将被加起来，并且可以由新交易的输出使用。例如，在
    [图6.3](08chap_06.xhtml#fig6_3)中，支付者B通过使用自己从交易1收到的硬币签署了一个交易Y，并添加了自己的公钥和受益者C的地址。网络上的任何人都可以使用B的公钥来验证交易，并确保B花费了正确的硬币。然而，要使网络的其余部分接受任何交易，需要验证交易块，并且验证节点的矿工必须在块中包含PoW。在这里，矿工是具有良好的计算能力和资源的特殊节点。值得注意的是，在比特币网络中，区块大小不能超过1
    MB，以实现快速传播。
- en: '![Figure 6.3](../images/fig6_3.jpg)'
  id: totrans-704
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.3](../images/fig6_3.jpg)'
- en: '**FIGURE 6.3**'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 6.3**'
- en: Illustration of Bitcoin transaction.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币交易的图示。
- en: PoW is a cryptographic difficult hash generated by miners. Particularly, it
    is a Bitcoin consensus algorithm. The concept of PoW and mining makes a transaction
    computationally impractical to modify. In PoW, basically, miners have to find
    a nonce value so that the hash of the block has a certain hash value. The first
    miner to solve the puzzle gets a reward in the form of incentives from the network.
    All the other nodes in the network validate the blocks mined by miners. For a
    block to be added in the Bitcoin network, more than 51% of the network nodes should
    approve the blocks. Hence the only way to attack the blockchain network is when
    51% of the hash power is with attackers. This detailing of this algorithm is explained
    in the coming section.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: PoW是由矿工生成的密码学难题哈希。特别是，它是比特币共识算法。 PoW和挖矿的概念使得修改交易在计算上变得不切实际。在PoW中，基本上，矿工必须找到一个随机值，使得区块的哈希具有特定的哈希值。第一个解决难题的矿工从网络中获得奖励的激励。网络中的所有其他节点验证矿工挖掘的区块。要将区块添加到比特币网络中，超过51%的网络节点应批准该区块。因此，攻击区块链网络的唯一方法是当攻击者控制51%的哈希算力时。该算法的详细信息在接下来的部分中解释。
- en: Another reason for the popularity of Bitcoin is its ability to solve the problem
    of double-spending. Double spending is a problem when the same Bitcoins are used
    for more than one transaction. For example, user A has 100 Bitcoins and user A
    tries to send the same amount of 100 Bitcoins to both user B and user C simultaneously.
    The property of timestamping and distributed ledger ensures double-spending of
    Bitcoins. tcolorbox
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币另一个受欢迎的原因是它解决了双重支付的问题。双重支付是指同一比特币被用于多笔交易的问题。例如，用户A有100个比特币，用户A试图将相同数量的100个比特币同时发送给用户B和用户C。时间戳和分布式分类账的属性确保了比特币的双重支付。tcolorbox
- en: '**Key point** Bitcoin addresses are random numbers and it may be possible that
    two different users end up in creating same address and it results in a collision.
    In such a situation, both original and colliding owner of address could spend
    Bitcoins sent to that address.'
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: '**要点** 比特币地址是随机数，可能会出现两个不同的用户最终创建相同的地址并导致冲突的情况。在这种情况下，地址的原始拥有者和冲突的拥有者都可以花费发送到该地址的比特币。'
- en: '**Multi-signature transactions:** It is a type of transaction that is signed
    by multiple users and it transfers funds from a multi-signature address. This
    kind of transaction is used if more than one person is appointed to look after
    possession of Bitcoins. In order to append such Bitcoins, each one of the persons
    or majority of them has to sign the transactions. It implies that more than one
    private key is used to create digital signatures.'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: '**多重签名交易：** 这是一种由多个用户签名的交易类型，它从多重签名地址转移资金。如果有多个人被指定来监管比特币的所有权，则使用这种类型的交易。为了附加这样的比特币，每个人或他们中的大多数人都必须签署交易。这意味着使用多个私钥创建数字签名。'
- en: '[6.2 Types of Blockchain](contents.xhtml#rsec6_2)'
  id: totrans-711
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[6.2 区块链的类型](contents.xhtml#rsec6_2)'
- en: 'The foremost application of blockchain is to execute secure transactions. However,
    depending on user''s requirement there are multiple ways in which blockchain network
    is implemented:'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链的主要应用是执行安全交易。然而，根据用户的需求，区块链网络可以以多种方式实现：
- en: 'Public blockchain: A public blockchain network is a permissionless system where
    any node with access to the Internet can participate to be a part of the network.
    Here any user of the network can access records, verify, validate transactions,
    and perform mining tasks. The more the number of participants in the public blockchain
    network, the more it will be secure as the blocks are then verified and validated
    by more participants of the network. Bitcoin, Ethereum, Litcoin, Steller, dash
    are examples of the public blockchain.'
  id: totrans-713
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公共区块链：公共区块链网络是一个无需许可的系统，任何具有互联网访问权限的节点都可以参与网络。在这里，网络的任何用户都可以访问记录、验证、验证交易并执行挖矿任务。公共区块链网络中的参与者越多，它就越安全，因为块会由更多的网络参与者验证和验证。比特币、以太坊、莱特币、恒星、达世币都是公共区块链的例子。
- en: 'Private blockchain: In contrast, a private blockchain is owned by an organization
    or enterprises where participants are restricted and only authenticated users
    are allowed. Actually, private blockchains are the restrictive version of public
    blockchain. Private blockchains are used with the private organization for storing
    sensitive information. A new user can''t join the network without having an invitation
    from the network. The invitation procedure involves use of conditions to be satisfied
    before a new user can join. Private blockchain is fast than public blockchain.
    Notably, private blockchain possesses centralization as compared to public blockchain.
    Hyperledger, multichain, Corda are the popular examples of private blockchain.
    High customizability, better access controls, better scalability are some of the
    advantages of the private blockchain [[47](bib.xhtml#ch00-bib-47)].'
  id: totrans-714
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 私有区块链：相反，私有区块链由组织或企业拥有，参与者受限，只允许经过身份验证的用户。实际上，私有区块链是公共区块链的限制版本。私有区块链用于私有组织存储敏感信息。新用户无法在没有网络邀请的情况下加入网络。邀请程序涉及使用条件，新用户必须满足条件才能加入。与公共区块链相比，私有区块链更快。值得注意的是，私有区块链相对于公共区块链具有集中化特性。Hyperledger、multichain、Corda是私有区块链的流行示例。高度可定制性、更好的访问控制、更好的可扩展性是私有区块链的一些优点[[47](bib.xhtml#ch00-bib-47)]。
- en: 'Consortium blockchain: This types of blockchain is regarded as semi-private
    systems. Clearly, it is not a public network but a permissioned network. However,
    rather a single organization governing, multiple organization governs the network.
    This type is beneficial for cases where multiple organization operates in the
    same industry. Here, only a few selected nodes have the right to oversee consensus
    mechanisms and to authorize transactions. Compared to a public blockchain, consortium
    blockchain provides faster speed. Also, this blockchain type does not face scalability
    problems. Quorum is a popular example under this category.'
  id: totrans-715
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 联盟区块链：这种类型的区块链被视为半私有系统。显然，它不是一个公共网络，而是一个受许可的网络。然而，不是单一组织进行管理，而是多个组织共同管理网络。这种类型对于多个组织在同一行业运营的情况非常有益。在这里，只有少数被选中的节点有权监督共识机制并授权交易。与公共区块链相比，联盟区块链提供更快的速度。此外，这种区块链类型不会面临可扩展性问题。Quorum是这一类别下的一个流行例子。
- en: The difference in above discussed blockchain type in tabular form is discussed
    in [Table 6.1](#tab6_1).
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 上述讨论的区块链类型在表格形式中的差异在[表6.1](#tab6_1)中讨论。
- en: '**TABLE 6.1**'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: '**表格 6.1**'
- en: Differences in blockchain type.
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链类型的差异。
- en: '| Blockchain type |'
  id: totrans-719
  prefs: []
  type: TYPE_TB
  zh: '| 区块链类型 |'
- en: '| --- |'
  id: totrans-720
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| Characteristic | Public | Private | Consortium |'
  id: totrans-721
  prefs: []
  type: TYPE_TB
  zh: '| 特征 | 公共 | 私人 | 联盟 |'
- en: '| Permissionless | Yes | No | No |'
  id: totrans-722
  prefs: []
  type: TYPE_TB
  zh: '| 无需许可 | 是 | 否 | 否 |'
- en: '| Read rights | Anyone | Invited users only | Depends |'
  id: totrans-723
  prefs: []
  type: TYPE_TB
  zh: '| 阅读权限 | 任何人 | 仅邀请用户 | 取决 |'
- en: '| Write rights | Anyone | Approved participants | Approved participants |'
  id: totrans-724
  prefs: []
  type: TYPE_TB
  zh: '| 写入权限 | 任何人 | 已批准参与者 | 已批准参与者 |'
- en: '| Ownership | Nobody | Single entity | Multiple entities |'
  id: totrans-725
  prefs: []
  type: TYPE_TB
  zh: '| 所有权 | 无 | 单一实体 | 多个实体 |'
- en: '| Transaction speed | Slow | Fast | Fast |'
  id: totrans-726
  prefs: []
  type: TYPE_TB
  zh: '| 交易速度 | 慢 | 快 | 快 |'
- en: '| Centralized | No | Yes | Partially |'
  id: totrans-727
  prefs: []
  type: TYPE_TB
  zh: '| 中心化 | 否 | 是 | 部分 |'
- en: '[6.3 Blockchain Applications](contents.xhtml#rsec6_3)'
  id: totrans-728
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[6.3 区块链应用](contents.xhtml#rsec6_3)'
- en: Due to its distributed, immutable, and trustworthy nature for all transactions,
    blockchain technology has various applications. Not only the financial sector,
    but blockchain technology also has the potential to revolutionize commerce, industry,
    education sector, etc. Authors of [[182](bib.xhtml#ch00-bib-182)], suggested that
    the growth of blockchain applications can be divided into three phases, i.e.,
    blockchain 1.0, blockchain 2.0, and blockchain 3.0\. Blockchain 1.0 covers the
    usage of cryptocurrency as a P2P payment system. Blockchain 2.0 includes smart
    contracts, smart property, and decentralized applications with simple cash transactions.
    Blockchain 3.0 covers applications beyond finance and cryptocurrency, such as-
    healthcare, governance, agriculture, and smart grid, etc.[[49](bib.xhtml#ch00-bib-49)].
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其分布式、不可变和可信任的特性，区块链技术对所有交易都有各种应用。不仅金融部门，区块链技术还有潜力革新商业、工业、教育部门等领域。[[182](bib.xhtml#ch00-bib-182)]的作者建议，区块链应用的增长可以分为三个阶段，即区块链
    1.0、区块链 2.0 和区块链 3.0。区块链 1.0 包括使用加密货币作为点对点支付系统。区块链 2.0 包括智能合约、智能财产和简单现金交易的去中心化应用程序。区块链
    3.0 则涵盖超越金融和加密货币的应用，如医疗保健、治理、农业和智能电网等[[49](bib.xhtml#ch00-bib-49)]。
- en: 'Education: One of the worth mentioning application of blockchain is in the
    education sector. Similar to financial, educational sector has leveraged blockchain
    to keep student''s data safe for the coming years. As blockchain keeps track of
    information efficiently, library information services in colleges and schools
    can implement blockchain. Some universities and institutes have used blockchain
    to support degree management and evaluations for course learning outcomes. Another
    use is to reward students for their success and achievements based on transparent
    records stored on the blockchain network. For example, the University of Nicosia
    is the first place where blockchain is used to manage certificates of students
    from massive open online course (MOOC) platform [[170](bib.xhtml#ch00-bib-170)].
    In addition to this, blockchain technology helps in reducing student''s fraud
    degrees. With blockchain, all degrees and certificates are stored digitally on
    the blockchain network without requiring any intermediary to verify them. Also,
    ride sharing applications can use to organize carpooling services. This will surely
    reduce the burden on public transport.'
  id: totrans-730
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 教育：区块链的一个值得一提的应用领域是教育部门。与金融类似，教育部门已经利用区块链来确保学生数据在未来几年内的安全性。由于区块链能够高效地跟踪信息，大学和学校的图书馆信息服务可以实施区块链技术。一些大学和研究机构已经利用区块链来支持课程学习成果的学位管理和评估。另一个用途是基于区块链网络上存储的透明记录奖励学生的成功和成就。例如，尼科西亚大学是第一个使用区块链管理来自大规模在线开放课程（MOOC）平台的学生证书的地方[[170](bib.xhtml#ch00-bib-170)]。除此之外，区块链技术有助于减少学生的欺诈学位。使用区块链，所有学位和证书都以数字方式存储在区块链网络上，无需任何中介来验证它们。此外，拼车服务也可以使用区块链来组织拼车服务，这肯定会减轻公共交通的负担。
- en: 'Healthcare: Mostly, existing healthcare systems are maintained by a central
    authority. Therefore, all the data generated by patients can be accessed by these
    third parties without the patient''s consent which leads to privacy concerns.
    To address this problem, recently blockchain technology has been extensively used
    in healthcare networks for various applications, such as- data management, data
    sharing, data storing, data analyzing, and access management systems. The foremost
    use case in health sector is for improved and secured medical record management
    [[208](bib.xhtml#ch00-bib-208)]. With blockchain, the information measured by
    IoT sensors, such as- temperature, blood pressure, heart care, and pulse rate
    is shared securely and transparently over the blockchain network. The patient
    can now control and check what and how much information is to be shared with the
    doctor or any other healthcare officer. Another use case is to verify the claimed
    transaction for health care financing task. Literature supports many work that
    integrates blockchain with healthcare system, such as [[102](bib.xhtml#ch00-bib-102)],
    [[97](bib.xhtml#ch00-bib-97)].'
  id: totrans-731
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 健康医疗：大多数情况下，现有的医疗系统由中央机构维护。因此，患者生成的所有数据可以被这些第三方访问，而无需患者的同意，这引发了隐私问题。为解决这一问题，近年来区块链技术在医疗网络中得到广泛应用，用于各种应用，如数据管理、数据共享、数据存储、数据分析和访问管理系统。在健康领域中的首要用例是改进和确保医疗记录管理[[208](bib.xhtml#ch00-bib-208)]。通过区块链，由物联网传感器测量的信息，如体温、血压、心率和脉搏率，可以在区块链网络上安全透明地共享。患者现在可以控制和检查要与医生或其他医疗人员共享的信息内容和数量。另一个用例是验证针对医疗保健融资任务的声称交易。文献支持许多将区块链与医疗系统集成的工作，例如[[102](bib.xhtml#ch00-bib-102)]，[[97](bib.xhtml#ch00-bib-97)]。
- en: 'Voting system: In a democratic country, maintain security in an election system
    is a matter of national security. Nowadays, electronic voting machines are used
    by the government to achieve the voting mechanism successfully. Notably, these
    e-voting systems are based on a centralized network where everything is handled
    by a trusted third-party. However, such kind of system is a concern of physical
    security, privacy, and lack of transparency. Importantly, one of the main concerns
    for such systems is the prevention of database manipulation. By leveraging the
    fundamentals of blockchain and smart contract a secure e-voting system for transparent
    democracy can be created. The usage of SHA-256 hash function and linkage to the
    previous block with the help of cryptography prevents any kind of modifications
    to the database. Moreover, the digital signature usage ensures reliability to
    the system. Additionally, the concept of anonymity supported by blockchain ensures
    that voters can submit their votes without any fear of identity leakage.'
  id: totrans-732
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 投票系统：在一个民主国家中，维护选举系统的安全是国家安全的重要问题。如今，政府采用电子投票机来成功实现投票机制。值得注意的是，这些电子投票系统是基于一个中心化网络的，一切都由可信赖的第三方处理。然而，这种系统存在着物理安全、隐私和缺乏透明性的问题。重要的是，这类系统的主要关注点之一是防止数据库篡改。通过利用区块链和智能合约的基础知识，可以创建一个透明民主的安全电子投票系统。利用SHA-256哈希函数和利用密码学将当前块链接到前一个块可以防止对数据库进行任何修改。此外，数字签名的使用确保了系统的可靠性。此外，区块链支持的匿名概念确保选民可以提交他们的选票，而无需担心身份泄露。
- en: 'Smart grid: To design a smart infrastructure for IoT based smart cities an
    intelligent and automated electricity distribution system is required. In this
    context, the smart grid has revolutionized the energy sector in many ways. A smart
    grid aims to construct an automated power infrastructure that can minimize energy
    waste. Although in the existing literature smart grid utilities are served by
    a central third party who balances users’ electricity load and payments. This
    central authority stores all the information related to electricity generation,
    consumption, and transfer. Nevertheless, because of more time consumption, single
    point of failure, and the increasing number of distributed resources, centralized
    management is not effective. With blockchain, different electric utilities exchange
    energy and make payments without a third party. All involved transactions are
    stored on publically distributed ledger after verification by all network participants.
    All records and energy transactions are stored by every network participant which
    ensures trust and transparency on the network. Simultaneously, because of resistance
    to a single point of failure, DDoS attacks are minimized by integrating blockchain
    with smart grid [[124](bib.xhtml#ch00-bib-124)]. Moreover, the elimination of
    third-party reduces transaction costs. Over and above the interconnection among
    network participants realizes P2P information sharing that achieves automatic
    scheduling. Also, automatic delivery of electricity bills can be implemented with
    blockchain. Hence, blockchain enables self participation, secure payments, transparency
    in allocation and generation of electricity, flexible demand response management,
    P2P energy trading, and real-time pricing data [[125](bib.xhtml#ch00-bib-125)].'
  id: totrans-733
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 智能电网：为了设计一个智能城市物联网基础设施，需要一个智能化和自动化的电力分配系统。在这个背景下，智能电网在许多方面革命了能源行业。智能电网旨在建立一个能够最小化能源浪费的自动化电力基础设施。尽管在现有文献中，智能电网实用程序由一个中央第三方提供服务，该第三方平衡用户的电力负载和付款。这个中央管理机构存储了与电力生成、消耗和转移相关的所有信息。然而，由于时间消耗更多、单点故障增多以及分布式资源数量增加，集中式管理不再有效。通过区块链，不同的电力实用程序可以在没有第三方的情况下交换能源并进行支付。所有涉及的交易在经过所有网络参与者的验证后都存储在公开分布式账本上。每个网络参与者都存储所有记录和能源交易，从而确保网络上的信任和透明度。与此同时，由于对单点故障的抵抗力，通过将区块链与智能电网集成，可以最小化DDoS攻击。此外，消除第三方可以降低交易成本。此外，网络参与者之间的互连实现了P2P信息共享，实现了自动调度。此外，可以利用区块链实现电费的自动交付。因此，区块链实现了自我参与、安全支付、电力分配和生成的透明度、灵活的需求响应管理、P2P能源交易和实时定价数据。
- en: 'Intelligent transport system: Another potential use case of blockchain technology
    is in developing an intelligent transport system (ITS) or autonomous driving cars.
    With the rapid growth in automobile industry, computing techniques, and devices,
    there is popularity in the growth of ITS. However, information collected by different
    sensing units, Road-side unit (RSU''s) and Base station (BS''s) of ITS is generally
    stored on cloud-based platforms and thus faces security and privacy risks due
    to centralization. ITS needs to secure and authenticate data to make real-time
    decisions. Blockchain provides trustworthy data as the entire network contributes
    to data verification and validation. With its decentralized properties, blockchain
    can promote trusted communication among vehicles and RSU''s in autonomous transportation
    systems. Also, the distributed data verification mechanism ensures an immutable
    and traceable distributed ledger that heps building a secure financial system
    in ITS for P2P money transfer. For electric vehicles (EV''s) energy trading between
    EV''s and charging stations, blockchain provides secure payment handling and transaction
    management [[155](bib.xhtml#ch00-bib-155)]. Similarly, toll payments can be enabled
    with blockchain for standardized collection. Also, ride-sharing services can leverage
    blockchain to make secure payments and to display transparent information [[98](bib.xhtml#ch00-bib-98)].
    Moreover, insurance contracts can be stored on the blockchain network and smart
    contracts can be deployed for taking actions to claim money and to detect any
    kind of contract violation. Additionally, with the smart contract facility, custom
    clearance can be fast and more effective which reduces processing times at checkpoints
    [[99](bib.xhtml#ch00-bib-99)].'
  id: totrans-734
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 区块链技术的另一个潜在应用场景是发展智能交通系统（ITS）或自动驾驶汽车。随着汽车工业、计算技术和设备的快速增长，ITS的发展越来越受欢迎。然而，ITS的不同传感单元、路侧单元（RSU）和基站（BS）采集的信息通常存储在基于云的平台上，因此面临着由于集中化而带来的安全和隐私风险。ITS需要保护和验证数据以做出实时决策。区块链提供可信赖的数据，整个网络共同贡献于数据验证和验证。通过其去中心化特性，区块链可以促进自动运输系统中车辆和RSU之间的信任通信。此外，分布式数据验证机制确保了不可变和可追溯的分布式分类账，有助于建立ITS的P2P资金转移安全财务系统。对于电动汽车（EV）和充电站之间的能源交易，区块链提供了安全的支付处理和交易管理[[155](bib.xhtml#ch00-bib-155)]。同样，收费支付可以通过区块链实现标准化的收费。此外，拼车服务可以利用区块链进行安全支付和显示透明信息[[98](bib.xhtml#ch00-bib-98)]。此外，保险合同可以存储在区块链网络上，并可以部署智能合同来采取行动来要求资金并检测任何合同违约。此外，借助智能合同功能，海关清关可以更快速和更有效，从而减少了在检查点的处理时间[[99](bib.xhtml#ch00-bib-99)]。
- en: '[6.4 Smart Contracts](contents.xhtml#rsec6_4)'
  id: totrans-735
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[6.4 智能合同](contents.xhtml#rsec6_4)'
- en: Smart contracts are automatic and irreversible applications implemented in a
    distributed environment. Nobody except the developer having full access to the
    code can edit or modify the execution behavior of smart contracts. Smart contracts
    manage digital documents efficiently as they are self-executing and self-verifying
    [[95](bib.xhtml#ch00-bib-95)]. It is actually a piece of code developed to set
    up an agreement between more than one party, having conditions to be met before
    execution. Every party must fulfill their commitment as per their agreement. For
    example, a smart contract for payment on a specific date and time which implies
    on the arrival of a specified date and time the predefined condition is satisfied
    and the payment is transferred to the receivers account automatically. Therefore,
    eliminating the need for a trusted third party. When placed on a blockchain environment,
    it leverages properties (such as- irreversibility, tamperproof, transparency,
    etc.) of blockchain technology. The bytecode of a smart contract is visible to
    everybody on the blockchain network. It is worth noticing that one smart contract
    may needs outcome from another smart contract. Not only payment transactions,
    smart contracts are also used to execute many different processes, such as insurance,
    supply chain management, mortgage loans, real-estate, voting, etc. With the popularity
    of IoT technology, smart contracts are used to enable M2M interaction.
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约是在分布式环境中实现的自动且不可逆转的应用程序。除了完全访问代码的开发者外，没有其他人可以编辑或修改智能合约的执行行为。智能合约能够高效管理数字文档，因为它们是自执行和自验证的[[95](bib.xhtml#ch00-bib-95)]。实际上，智能合约是一段代码，用于建立多方之间的协议，在执行之前有一些条件需要满足。每个参与方必须根据协议履行自己的承诺。例如，一个针对特定日期和时间付款的智能合约，意味着在特定日期和时间到达时，预定义的条件得到满足，付款会自动转账到接收者的账户。因此，消除了对可信第三方的需求。当部署在区块链环境中时，它利用了区块链技术的属性（如-
    不可逆性、防篡改、透明性等）。智能合约的字节码对区块链网络上的所有人都是可见的。值得注意的是，一个智能合约可能需要另一个智能合约的结果。智能合约不仅用于支付交易，还用于执行许多不同的流程，例如保险、供应链管理、抵押贷款、房地产、投票等。随着物联网技术的普及，智能合约被用于实现机器对机器的交互。
- en: 'Currently, the biggest platform for the smart contract is Ethereum. Solidity
    is an object-oriented, high-level language specifically designed for implementing
    smart contracts. Solidity is inspired by common languages such as- C++, Python,
    and javascript having features including inheritance, libraries, etc. The compiler
    of solidity converts the code into EVM bytecode. The fundamental steps for executing
    a smart contract are:'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，智能合约的最大平台是以太坊。Solidity是一种面向对象的高级语言，专门用于实现智能合约。Solidity受到常见语言的启发，如C++、Python和javascript，具有继承、库等功能。Solidity的编译器将代码转换为EVM字节码。执行智能合约的基本步骤为：
- en: After the finalization of contractual terms, programming code is developed specifying
    predefined conditions and outcomes.
  id: totrans-738
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合同条款最终确定后，会编写编程代码，指定预定义的条件和结果。
- en: Deploy the smart contract to the blockchain network and replicate it among all
    participants of the network.
  id: totrans-739
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将智能合约部署到区块链网络，并在网络的所有参与者之间复制它。
- en: Once the terms and conditions are satisfied, the contract is executed and the
    outcome is triggered.
  id: totrans-740
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦条款和条件得到满足，合同就会执行，结果就会触发。
- en: Notably, the Bitcoin network was the first one to use the concept of smart contract
    for the blockchain in a way that one node can transfer coins to another node following
    some rules. Additionally, the network participants will only validate transactions
    if some predefined conditions are met. In contrast, Ethereum replaces Bitcoin's
    restrictive language with a language that enables developers to write their own
    code of programs. It implies, with Ethereum developers can write their own program.
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，比特币网络是第一个在区块链中使用智能合约概念的网络，以一种方式使得一个节点可以按照一些规则将硬币转移到另一个节点。此外，只有在满足一些预定义条件时，网络参与者才会验证交易。相比之下，以太坊用一种允许开发人员编写自己程序代码的语言取代了比特币的限制性语言。这意味着，使用以太坊，开发人员可以编写自己的程序。
- en: '[6.5 Issues with Blockchain](contents.xhtml#rsec6_5)'
  id: totrans-742
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[6.5 区块链问题](contents.xhtml#rsec6_5)'
- en: Blockchain technology has the potential to disrupt a wide range of industries
    but it faces its own set of challenges as shown in [Fig. 6.4](08chap_06.xhtml#fig6_4).
    However, over time literature introduces many improvements to eliminate these
    challenges.
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链技术有潜力颠覆广泛的行业，但它面临着一系列挑战，如[图 6.4](08chap_06.xhtml#fig6_4)所示。然而，随着时间的推移，文献介绍了许多改进措施来消除这些挑战。
- en: '**Storage**: The foremost problem of blockchain is data storage as every full
    node on the network has a copy of the distributed ledger. Clearly, this increasing
    repository of data is difficult to handle. In this context, mechanism such as-
    sidechains or chilchains should be encouraged in research [[32](bib.xhtml#ch00-bib-32)].'
  id: totrans-744
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存储**：区块链的首要问题是数据存储，因为网络上的每个完整节点都有分布式账本的副本。显然，这个不断增加的数据存储库很难处理。在这种情况下，应该鼓励研究机制，如侧链或子链[[32](bib.xhtml#ch00-bib-32)]。'
- en: '**Scalability**: Another problem is the increasing size of public blockchain
    network. With the increase in the number of transactions, the size of blockchain
    becomes large. For example, the current size of Bitcoin blockchain is approximate
    269 GB [[9](bib.xhtml#ch00-bib-9)]. It is important to store all transactions
    occurring on the network for validation purposes. Therefore, the problem of scalability
    prevails in blockchain. Also, consensus protocol effects scalability of the network.
    Additionally, with the increase in network size more resources will be required,
    therefore system''s capacity scale will be reduced. Due to high scalability transaction
    execution in blockchain can become slow. Sharding is a new method to improve scalability
    and to increase transactional throughput. It is a method of partitioning that
    groups subset of participants into smaller networks who are only responsible for
    transactions meant for their shards. This way each shard will have its unique
    set of smart contracts that will be easily executed.'
  id: totrans-745
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：另一个问题是公共区块链网络规模的增长。随着交易数量的增加，区块链的大小也变得更大。例如，比特币区块链当前的大小约为269 GB [[9](bib.xhtml#ch00-bib-9)]。将网络上发生的所有交易存储起来以进行验证是很重要的。因此，区块链中存在着可扩展性问题。此外，共识协议也影响着网络的可扩展性。另外，随着网络规模的增加，将需要更多的资源，因此系统的容量规模将会降低。由于高可扩展性，区块链中的交易执行可能变得缓慢。分片是一种改善可扩展性和增加事务吞吐量的新方法。它是一种分区方法，将参与者的子集分组成较小的网络，只负责处理其分片的交易。这样，每个分片都将有其独特的智能合约集，将易于执行。'
- en: '**High computation**: The majority of blockchain available in market consumes
    lots of energy as they are based on Bitcoin infrastructure and uses PoW as a consensus
    algorithm. This protocol involves complex mathematical puzzles and demands high
    computation power for verification. However, this computationally intensive task
    is important to generate new blocks in blockchain. Also, this algorithm involves
    consumption of high energy resources. Solving mathematical puzzles consume energy
    equivalent to yearly electricity consumption of Denmark in 2020 [[10](bib.xhtml#ch00-bib-10)].
    Hence, blockchain can prove costly to the environment. In order to solve energy
    challenges faced by PoW many other consensus algorithms including Proof-of-stake
    (PoS), Proof-of-identity (PoI) has been introduced.'
  id: totrans-746
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高计算量**：市场上大多数区块链消耗大量能源，因为它们基于比特币基础设施并使用PoW作为共识算法。该协议涉及复杂的数学难题，并需要高计算能力进行验证。然而，这种计算密集型任务对于在区块链中生成新的区块至关重要。此外，该算法涉及消耗大量能源资源。解决数学难题消耗的能量相当于2020年丹麦的年电力消耗量
    [[10](bib.xhtml#ch00-bib-10)]。因此，区块链可能对环境造成昂贵的代价。为了解决PoW所面临的能源挑战，已经引入了许多其他共识算法，包括股权证明（PoS）、身份证明（PoI）等。'
- en: '**Lack of standards**: As per a research in [[11](bib.xhtml#ch00-bib-11)],
    one of the reasons blockchain technology is not adopted widely is the lack of
    trust among users. Lack of standards can create disputes among users. Also, lack
    of standardization leads to interoperability issues among large number of nodes
    in blockchain network. There are multiple blockchain projects in the market with
    having different protocols, privacy measures, consensus algorithm, and coding
    languages. Additionally, the lack of uniformity caused by these different projects
    creates consistency issues for security solutions. Moreover, there are many types
    pf blockchain network including public, private, and consortium each having their
    own advantages and disadvantages. Therefore, blockchain of different types can''t
    communicate because of interoperability issues. Standardization of blockchain
    can help in reducing costs and the problem of interoperability. In this context,
    there is a project in the market named [[12](bib.xhtml#ch00-bib-12)] that relies
    on smart bridge architecture to support universal interoperability.'
  id: totrans-747
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缺乏标准**：根据[[11](bib.xhtml#ch00-bib-11)]的研究，区块链技术没有被广泛采用的一个原因是用户之间缺乏信任。缺乏标准可能会在用户之间产生争议。此外，缺乏标准化会导致区块链网络中大量节点之间的互操作性问题。市场上有多个区块链项目，具有不同的协议、隐私措施、共识算法和编码语言。此外，这些不同项目导致的不统一性也给安全解决方案带来了一致性问题。此外，区块链网络包括公共、私有和财团等多种类型，每种类型都有其优缺点。因此，不同类型的区块链由于互操作性问题而无法通信。区块链的标准化可以帮助降低成本和互操作性问题。在这方面，市场上有一个名为[[12](bib.xhtml#ch00-bib-12)]的项目，它依赖智能桥接架构来支持通用互操作性。'
- en: '**Latency**: Transaction validation is another property of distributed consensus.
    The total number of transactions in a block and generation time between blocks
    has a significant effect on confirmation time of transaction. This introduces
    delay or latency in blockchain network while verification and validation of block
    because of large data size and increasing network size. Hence, transactions per
    second are slow for the blockchain network. One solution to solve this problem
    is to use edge computing for mobile blockchain network, especially with the PoW
    consensus mechanism. However, this solution faces difficult to distribute the
    limited edge computing resources among various miners across the different networks.
    Bitcoin-NG [[77](bib.xhtml#ch00-bib-77)], Litecoin [[13](bib.xhtml#ch00-bib-13)],
    Ghost [[176](bib.xhtml#ch00-bib-176)] are some of the variants of Bitcoin network
    designed to improve latency of the network.'
  id: totrans-748
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**延迟**：交易验证是分布式共识的另一个属性。一个区块中的交易总数以及区块之间的生成时间对交易的确认时间有显著影响。这在区块链网络中引入了延迟或延迟，因为验证和验证块时的数据量大且网络规模不断增大。因此，区块链网络的每秒交易数较慢。解决这个问题的一种方法是在移动区块链网络中使用边缘计算，特别是采用PoW共识机制。然而，这种解决方案面临着将有限的边缘计算资源分配给不同网络中的各个矿工的困难。比特币-NG《[77](bib.xhtml#ch00-bib-77)》，莱特币《[13](bib.xhtml#ch00-bib-13)》，幽灵《[176](bib.xhtml#ch00-bib-176)》是一些旨在改善网络延迟的比特币网络的变体。'
- en: '**Privacy leakage**: Another worth mentioning issue of blockchain is privacy
    leakage. Privacy in blockchain implies that one is able to execute transactions
    without leakage of identity information. As compared, privacy is not supported
    in Bitcoin by default as key characteristic of Bitcoin is transparent. All the
    transactions happening on the network can be checked, tracked, and audited by
    anybody on the network. It is concluded by the authors of [[139](bib.xhtml#ch00-bib-139)],
    that blockchain does not achieve transaction privacy as the value of transaction
    against each public key are publically visible. In addition to this, lightweight
    client has privacy concern as full node has all information about the interested
    wallet address of lightweight client.'
  id: totrans-749
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隐私泄露**：区块链另一个值得一提的问题是隐私泄露。在区块链中，隐私意味着可以在不泄露身份信息的情况下执行交易。相比之下，比特币默认不支持隐私，因为比特币的关键特性是透明的。网络上发生的所有交易都可以被任何人检查、追踪和审核。《[139](bib.xhtml#ch00-bib-139)》的作者总结道，区块链无法实现交易隐私，因为每个公钥对应的交易价值都是公开可见的。除此之外，轻量级客户端存在隐私问题，因为全节点拥有轻量级客户端感兴趣的钱包地址的所有信息。'
- en: To increase data privacy, data of blockchain network can be encrypted. For example,
    the model presented [[122](bib.xhtml#ch00-bib-122)] stores transaction in an encrypted
    form. The compiler present in this model translates code written in encrypted
    form. Similarly, the Enigma project presented in [[1](bib.xhtml#ch00-bib-1)] divided
    data into chunks that are distributed in the network so that no node has access
    to data. Another solution to provide data privacy is to store private and sensitive
    data outside the chain, this mechanism is referred to as off-chain solution. Such
    kind of system is more suitable for highly sensitive data, such as healthcare
    or military application.
  id: totrans-750
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了增强数据隐私，区块链网络的数据可以进行加密。例如，[[122](bib.xhtml#ch00-bib-122)]所提出的模型以加密形式存储交易信息。该模型中的编译器将加密形式的代码翻译成可识别的形式。同样，Enigma项目在[[1](bib.xhtml#ch00-bib-1)]中将数据分成分布在网络中的片段，以确保没有节点可以访问数据。提供数据隐私的另一解决方案是将私人和敏感数据存储在链外，这种机制被称为链外解决方案。这种系统更适合于高度敏感的数据，例如医疗保健或军事应用。
- en: '**Security threats**: Along with privacy concerns, another challenge is security
    threats faced by blockchain network. There are many security attacks that can
    be launched in a blockchain system including sybil attack, routing attack, DoS
    attack, eclipse attack to name a few. Readers can refer to [[148](bib.xhtml#ch00-bib-148)],
    [[133](bib.xhtml#ch00-bib-133)] read further in details about these attacks. However,
    the most popular attack is majority or 51% attack. In the Bitcoin network, any
    network participants having more than 51% computing power can discover nonce power
    faster than others which implies that node has power to decide which block is
    permissible. Mostly the consensus algorithms that are centralized among limited
    users is prone to majority attack. This attack happens if a BC node controls more
    than 51% of the hashing(mining) power. To solve security issues in blockchain,
    data analytics on blockchain data is required with latest machine learning technologies
    [[185](bib.xhtml#ch00-bib-185)], [[63](bib.xhtml#ch00-bib-63)], [[14](bib.xhtml#ch00-bib-14)].'
  id: totrans-751
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全威胁**：除了隐私问题外，另一个挑战是区块链网络面临的安全威胁。区块链系统中可以发动许多安全攻击，包括肖比尔攻击、路由攻击、DoS攻击、日食攻击等。读者可以参考[[148](bib.xhtml#ch00-bib-148)]，[[133](bib.xhtml#ch00-bib-133)]等进一步了解这些攻击的详细信息。然而，最流行的攻击是多数派或51%攻击。在比特币网络中，任何拥有超过51%的计算能力的网络参与者可以比其他人更快地发现随机数，这意味着节点有权决定哪个区块是可接受的。大多数在有限用户之间集中的共识算法容易受到多数攻击。如果区块链节点控制了超过51%的散列（挖矿）功率，就会发生这种攻击。要解决区块链中的安全问题，需要使用最新的机器学习技术对区块链数据进行数据分析[[185](bib.xhtml#ch00-bib-185)]，[[63](bib.xhtml#ch00-bib-63)]，[[14](bib.xhtml#ch00-bib-14)]。'
- en: '**Anonymity concerns**: Anonymity implies non-identifiability of the sender.
    Nowadays, user authentication with maintaining user anonymity is another requirement
    among users [[39](bib.xhtml#ch00-bib-39)]. By design, blockchain supports anonymity
    as there is no direct link between wallet address and identity of person. Instead
    of using true identity, blockchain is pseudonymous and mostly public key is pseudonym
    for the blockchain network. Unfortunately, this untraceable property motivates
    people for illegal web purchases. However, using public address protects anonymity
    to some extent. Once a person transacts with another person, it reveals its public
    address. As blockchain has the entire history of each wallet, with having public
    address all previous activity, wallet balance etc. can be checked. Additionally,
    any party can intercept a transaction to find out IP address of origin. Clearly,
    this public ledger eases correlating wallet address to identifiable names by simply
    analyzing the transactions. One way to solve this issue is to use Virtual Private
    Network (VPN) technology which uses someone else''s Internet connection. Also,
    using a new Bitcoin address for each transaction can also help a little. For example,
    Monero is another cryptocurrency that uses a different secret address every time
    for a new transaction. Another trending technique for prevention is onion routing
    that obscures IP addresses the node comes online. In this context, Tor [[15](bib.xhtml#ch00-bib-15)]
    is the open-source platform to implement onion routing. This software also helps
    hiding IP address of the node.'
  id: totrans-752
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**匿名性问题**：匿名性意味着发送者不可识别性。如今，用户在保持用户匿名的同时进行用户身份验证也是用户的另一个要求[[39](bib.xhtml#ch00-bib-39)]。按设计，区块链支持匿名性，因为钱包地址与个人身份之间没有直接链接。区块链不使用真实身份，而是使用伪名，而公钥大多是区块链网络的伪名。不幸的是，这种不可追踪的特性激励人们进行非法网络购买。然而，使用公共地址在一定程度上可以保护匿名性。一旦一个人与另一个人进行交易，它就会公开其公共地址。由于区块链记录了每个钱包的整个历史记录，因此通过公共地址可以检查所有以前的活动、钱包余额等。此外，任何一方都可以拦截交易以查找原始IP地址。显然，这个公共分类账通过简单分析交易来轻松地将钱包地址与可识别的名称进行关联。解决这个问题的一种方法是使用虚拟专用网络（VPN）技术，该技术使用其他人的互联网连接。另外，对于每一笔交易使用一个新的比特币地址也可能有所帮助。例如，Monero是另一种加密货币，每次新交易都使用不同的秘密地址。另一种流行的预防技术是洋葱路由，它模糊了节点上线的IP地址。在这方面，Tor[[15](bib.xhtml#ch00-bib-15)]是实现洋葱路由的开源平台。该软件还有助于隐藏节点的IP地址。'
- en: '![Figure 6.4](../images/fig6_4.jpg)'
  id: totrans-753
  prefs: []
  type: TYPE_IMG
  zh: '![图6.4](../images/fig6_4.jpg)'
- en: '**FIGURE 6.4**'
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: '**图6.4**'
- en: Issues with blockchain technology.
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链技术存在的问题。
- en: '[6.5.1 IPFS: A solution to decentralized data stoge problem](contents.xhtml#rsec6_5_1)'
  id: totrans-756
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[6.5.1 IPFS：去中心化数据存储问题的解决方案](contents.xhtml#rsec6_5_1)'
- en: As discussed above, storing large files on the blockchain is challenging. In
    context of storage capacity, it is worth to mention Inter Planetary File System
    (IPFS) [[16](bib.xhtml#ch00-bib-16)]. IPFS network is suitable for sharing big
    files that demand large bandwidth to upload/download over the Internet. IPFS is
    a decentralized P2P distributed file system to store shared files. IPFS is an
    efficient way to store as it eliminates duplication of data. In a P2P connected
    IPFS, if one node gets collapsed, the rest of other nodes can serve the demanded
    files. This distributed file system connects all computing devices under same
    file system. IPFS is basically a replacement of Hypertext Transfer Protocol (HTTP)
    used to access content on the Internet. In IPFS, the files on the network are
    hosted on a decentralized server which implies rather than storing the content
    on a single system, the content is hosted on multiple nodes scattered around the
    Internet. IPFS saves around 60% of the network bandwidth. Unlike HTTP that downloads
    a single file from a single machine. IPFS downloads a file in multiple pieces
    simultaneously from multiple decentralized machines.
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 正如上文所讨论的，将大文件存储在区块链上是具有挑战性的。在存储容量的背景下，值得一提的是星际文件系统（Inter Planetary File System，IPFS）[[16](bib.xhtml#ch00-bib-16)]。IPFS
    网络适用于共享需要大带宽上传/下载的大文件。IPFS 是一个去中心化的 P2P 分布式文件系统，用于存储共享文件。IPFS 是一种高效的存储方式，因为它消除了数据的重复。在一个
    P2P 连接的 IPFS 中，如果一个节点崩溃了，其他节点仍然可以提供所需的文件。这个分布式文件系统将所有计算设备连接到同一个文件系统下。IPFS 基本上是超文本传输协议（HTTP）的替代品，用于访问互联网上的内容。在
    IPFS 中，网络上的文件托管在一个去中心化的服务器上，这意味着内容不是存储在单个系统上，而是托管在互联网上分散的多个节点上。IPFS 节约了约 60% 的网络带宽。与从单台机器下载单个文件的
    HTTP 不同，IPFS 同时从多个分散的机器上下载文件的多个部分。
- en: Rather than referring to files by names as they are stored on IPFS, this system
    refers to files by their cryptographic hash value. The cryptographic hash of the
    file is served as an address as well. This hash signifies a root object and all
    other objects that can be found in the path. In particular, the concept of content
    addressing is used at HTTP layer which implies rather than referring files by
    location (the location-based reference model supports centralization), it is addressed
    by any representation of content itself. To store files, IPFS relies on a distributed
    hash table (DHT). DHT is dictionary like interface to data that is on nodes that
    are distributed across the network. Nodes on the network use a mechanism called
    bitswamp to exchange data between nodes.
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 与将文件按其在 IPFS 上存储的名称命名不同，该系统通过它们的加密哈希值来引用文件。文件的加密哈希也被用作地址。这个哈希表示一个根对象和路径中可以找到的所有其他对象。特别是，在
    HTTP 层使用内容寻址的概念，这意味着不是通过位置引用文件（基于位置的引用模型支持集中化），而是通过内容本身的任何表示来寻址。IPFS 依赖于分布式哈希表（DHT）来存储文件。DHT
    是一个类似字典的接口，用于存储在网络上分布的节点上的数据。网络上的节点使用一种称为 bitswamp 的机制来在节点之间交换数据。
- en: When a new file is added to the IPFS network, IPFS generates a multihash address
    of the file using its content and node ID. To access a particular file, IPFS interrogates
    network for file having matching hash. After computing the cryptographic hash
    of the file, ask the peer of the network having content matched to that hash.
    Next, the content is downloaded directly from the node having the required data.
    Hence any node on the IPFS network having the hash of the content can look for
    a specific file via its content ID and node matching that IP will serve it.
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 当新文件添加到 IPFS 网络时，IPFS 使用其内容和节点 ID 生成文件的多哈希地址。要访问特定文件，IPFS 会查询具有匹配哈希的文件的网络。计算文件的加密哈希后，向网络的节点询问内容与该哈希匹配的对等节点。接下来，直接从具有所需数据的节点下载内容。因此，IPFS
    网络上的任何节点都可以通过其内容 ID 和匹配该 IP 的节点查找特定文件。
- en: The IPFS model can be integrated with blockchain model, such as Bitcoin and
    Ethereum as both of these systems have similar structures. Rather than storing
    with actual values on the blockchain, IPFS simply stores hashes of files on blockchain.
    Further, using these hashes actual location of files can be found.
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: IPFS 模型可以与区块链模型集成，例如比特币和以太坊，因为这两个系统具有相似的结构。IPFS 不是将实际值存储在区块链上，而是简单地将文件的哈希存储在区块链上。此外，使用这些哈希可以找到文件的实际位置。
- en: '[Fig. 6.5](08chap_06.xhtml#fig6_5) presents a data sharing mode using IPFS
    as discussed by authors of [[152](bib.xhtml#ch00-bib-152)]. At first, owner of
    the file uploads it on IPFS including metadata of the file. Secondly, the hash
    of the file is generated by IPFS and returned back to owner. At third step, owner
    looks for nodes in the smart contract that provide encryption/decryption services.
    Next, the owner divides the IPFS hash into *k* pieces, encrypts them, and finally
    store them on the blockchain network.'
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6.5](08chap_06.xhtml#fig6_5) 展示了作者讨论的一种使用 IPFS 的数据共享模式[[152](bib.xhtml#ch00-bib-152)]。首先，文件的所有者将其上传到
    IPFS，包括文件的元数据。其次，IPFS 生成文件的哈希并返回给所有者。第三步，所有者在智能合约中查找提供加密/解密服务的节点。接下来，所有者将 IPFS
    哈希分成 *k* 个部分，对其进行加密，最后将其存储在区块链网络上。'
- en: '![Figure 6.5](../images/fig6_5.jpg)'
  id: totrans-762
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.5](../images/fig6_5.jpg)'
- en: '**FIGURE 6.5**'
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 6.5**'
- en: Data sharing on IPFS.
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 在 IPFS 上的数据共享。
- en: '[6.6 Python Implementation of Blockchain](contents.xhtml#rsec6_6)'
  id: totrans-765
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[6.6 区块链的 Python 实现](contents.xhtml#rsec6_6)'
- en: 'We have used the Scientific Python Development Environment (Spyder) included
    with anaconda to implement blockchain. It enables editing, debugging, and interactive
    testing. Along with this, we have used Flash and Postman application to successfully
    create a blockchain network. Flask is a web framework for building a web application
    and it works with no dependencies to external libraries. To install flask use
    command: <math alttext="" display="inline"><mrow><mi>p</mi><mi>i</mi><mi>p</mi><mi>i</mi><mi>n</mi><mi>s</mi><mi>t</mi><mi>a</mi><mi>l</mi><mi>l</mi><mi>F</mi><mi>l</mi><mi>a</mi><mi>s</mi><mi>k</mi><mo>=</mo><mo>=</mo><mn>0.12.2</mn></mrow></math>
    Postman is an HTTP client that is used to test application program interface (API''s)
    by sending requests to web server and then getting a response back. It provides
    an easy and user-friendly interface and allows anyone to join blockchain network
    online using servers.'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了包括在 anaconda 中的 Scientific Python Development Environment (Spyder) 来实现区块链。它能够进行编辑、调试和交互式测试。除此之外，我们还使用了
    Flash 和 Postman 应用程序成功地创建了一个区块链网络。Flask 是一个用于构建 web 应用程序的 web 框架，它可以在没有外部库依赖的情况下工作。要安装
    flask，请使用以下命令：<math alttext="" display="inline"><mrow><mi>p</mi><mi>i</mi><mi>p</mi><mi>i</mi><mi>n</mi><mi>s</mi><mi>t</mi><mi>a</mi><mi>l</mi><mi>l</mi><mi>F</mi><mi>l</mi><mi>a</mi><mi>s</mi><mi>k</mi><mo>=</mo><mo>=</mo><mn>0.12.2</mn></mrow></math>
    Postman 是一个 HTTP 客户端，用于通过向 web 服务器发送请求然后收到响应来测试应用程序接口（API）。它提供了一个简单易用的界面，允许任何人通过服务器在线加入区块链网络。
- en: '![](../images/list6_1.jpg)![](../images/list6_2a.jpg)![](../images/list6_2b.jpg)![](../images/list6_3.jpg)![](../images/list6_4.jpg)'
  id: totrans-767
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/list6_1.jpg)![](../images/list6_2a.jpg)![](../images/list6_2b.jpg)![](../images/list6_3.jpg)![](../images/list6_4.jpg)'
- en: Next, we will make function to check whether a block is valid or not. To check
    block validity, two main points need to be checked that are
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个函数来检查区块是否有效。为了检查区块的有效性，需要检查两个主要点，即
- en: Every block's proof should have 4 leading zeros in the cryptographic hash.
  id: totrans-769
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个区块的证明应在加密哈希中具有 4 个前导零。
- en: Previous hash field should have exactly same value as previous hash of the block.
  id: totrans-770
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Previous hash 字段的值应该与区块的上一个哈希值完全相同。
- en: '![](../images/list6_5.jpg)![](../images/list6_6.jpg)'
  id: totrans-771
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/list6_5.jpg)![](../images/list6_6.jpg)'
- en: The blockchain class has been created. Also, we will use flask to create a web
    application to be able to interact with the blockchain.
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 已创建 blockchain 类。此外，我们将使用 flask 创建一个 web 应用程序，以便与区块链进行交互。
- en: First, we will create flask based web application by creating an object of flask
    class. Actually we will interact with the blockchain through flask.
  id: totrans-773
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们将通过创建一个 flask 类对象来创建基于 flask 的 web 应用程序。实际上，我们将通过 flask 与区块链进行交互。
- en: Next, we will create an instance of blockchain class.
  id: totrans-774
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个 blockchain 类的实例。
- en: Then, we will make a get request to mine a block by solving PoW problem.
  id: totrans-775
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们将发出 GET 请求来通过解决 PoW 问题来挖掘一个区块。
- en: Next, we will again make a get request to get a blockchain.
  id: totrans-776
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们将再次进行 GET 请求以获得区块链。
- en: '![](../images/list6_7.jpg)![](../images/list6_8.jpg)'
  id: totrans-777
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/list6_7.jpg)![](../images/list6_8.jpg)'
- en: Now, we will mine a new block by making a new request with flask based application.
    For this, route decorator will be used to inform flask what Uniform Resource Locator
    (URL) should trigger our function to mine a block. With URL, we have to specify
    other arguments which is method of request. It could be GET or POST. GET will
    get some information and POST will create something, for example, transaction.
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将通过基于 flask 的应用程序发出新请求来挖掘新区块。为此，路由装饰器将用于告知 flask 哪个统一资源定位器（URL）应该触发我们的函数以挖掘区块。在
    URL 中，我们必须指定其他参数，即请求的方法。它可以是 GET 或 POST。GET 将获取一些信息，POST 将创建某些内容，例如，交易。
- en: '![](../images/list6_9.jpg)'
  id: totrans-779
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/list6_9.jpg)'
- en: Now, we will create second GET request to display full blockchain in user interface
    postman application.
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建第二个 GET 请求，以在用户界面 postman 应用程序中显示完整的区块链。
- en: '![](../images/list6_10.jpg)'
  id: totrans-781
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/list6_10.jpg)'
- en: Finally, now we will run the blockchain application from our flask application.
    We will use postman to make request of mining block and get chain requests to
    check the actual state of the chain. To achieve this, from app object of flask
    class, we will call run method which takes two arguments, i.e., host and the port.
    From flask documentation, we can check this application is running on http://127.0.0.1.5000/.
    This URL will be entered in postman. Also, it is specified in documentation, that
    to make server publically available set host=0.0.0.0 and port as 5000.
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，现在我们将从我们的 flask 应用程序运行区块链应用程序。我们将使用 postman 发出挖掘区块和获取链请求以检查链的实际状态。为了实现这一点，从
    flask 类的 app 对象中，我们将调用 run 方法，该方法接受两个参数，即主机和端口。从 flask 文档中，我们可以检查此应用程序正在 http://127.0.0.1.5000/
    上运行。此 URL 将输入 postman 中。此外，文档中指定，要使服务器公开可用，请设置 host=0.0.0.0 并将端口设置为 5000。
- en: '![](../images/list6_11.jpg)'
  id: totrans-783
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/list6_11.jpg)'
- en: After writing the code, execute the code on the editor. From [Fig 6.6](08chap_06.xhtml#fig6_6)
    it can be seen that application is successfully running on http:\ \0.0.0.0\. Now,
    we will use postman application to make GET request. In postman application, we
    have to enter the request URL and selecting the type of request as GET as shown
    in [Fig. 6.7](08chap_06.xhtml#fig6_7). To mine block we have to use mine_block
    request and to get blockchain state, we have to use get_chain request.
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 编写完代码后，在编辑器上执行代码。从[图 6.6](08chap_06.xhtml#fig6_6)可以看出，应用程序成功在 http:\ \0.0.0.0\
    上运行。现在，我们将使用 postman 应用程序发出 GET 请求。在 postman 应用程序中，我们必须输入请求 URL，并选择请求类型为 GET，如[图
    6.7](08chap_06.xhtml#fig6_7)所示。要挖掘区块，我们必须使用 mine_block 请求，并且要获取区块链状态，我们必须使用 get_chain
    请求。
- en: '![Figure 6.6](../images/fig6_6.jpg)'
  id: totrans-785
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.6](../images/fig6_6.jpg)'
- en: '**FIGURE 6.6**'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 6.6**'
- en: Blockchain application.
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链应用程序。
- en: '![Figure 6.7](../images/fig6_7.jpg)'
  id: totrans-788
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.7](../images/fig6_7.jpg)'
- en: '**FIGURE 6.7**'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 6.7**'
- en: Blockchain application illustration with postman.
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 postman 的区块链应用程序说明。
- en: First we will use get_chain request and it can be seen that there is only one
    block in network, i.e., genesis block as we have not mined any block. Refer to
    [Fig. 6.8](08chap_06.xhtml#fig6_8). This genesis block has index 1, previous_hash=0
    and proof as 1 as coded.
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将使用 get_chain 请求，可以看到网络中只有一个区块，即创世区块，因为我们还没有挖掘任何区块。参见 [图 6.8](08chap_06.xhtml#fig6_8)。这个创世区块的索引为
    1，previous_hash=0，proof 为 1。
- en: '![Figure 6.8](../images/fig6_8.jpg)'
  id: totrans-792
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.8](../images/fig6_8.jpg)'
- en: '**FIGURE 6.8**'
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 6.8**'
- en: Blockchain application illustration with postman.
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 postman 的区块链应用示例。
- en: Now, we will mine the first block of the network with index 2 as presented in
    [Fig. 6.9](08chap_06.xhtml#fig6_9). This block has proof value of 533 which implies
    that cryptography hash of the encoded string of <math alttext="" display="inline"><mrow><msup><mrow><mn>533</mn></mrow><mn>2</mn></msup><mo>−</mo><msup><mn>1</mn><mn>2</mn></msup></mrow></math>
    starts with four leading zeros.
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将挖掘网络的第一个区块，索引为 2，如 [图 6.9](08chap_06.xhtml#fig6_9) 所示。该区块的证明值为 533，这意味着编码字符串
    <math alttext="" display="inline"><mrow><msup><mrow><mn>533</mn></mrow><mn>2</mn></msup><mo>−</mo><msup><mn>1</mn><mn>2</mn></msup></mrow></math>
    的密码学哈希以四个前导零开始。
- en: '![Figure 6.9](../images/fig6_9.jpg)'
  id: totrans-796
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.9](../images/fig6_9.jpg)'
- en: '**FIGURE 6.9**'
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 6.9**'
- en: Blockchain block mining illustration with postman.
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 postman 的区块链块挖掘示例。
- en: After mining first bock, lets check the status of blockchain with get_chain
    request. Refer [Fig. 6.10](08chap_06.xhtml#fig6_10).
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: 在挖出第一个区块后，让我们通过 get_chain 请求来检查区块链的状态。参见 [图 6.10](08chap_06.xhtml#fig6_10)。
- en: '![Figure 6.10](../images/fig6_10.jpg)'
  id: totrans-800
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.10](../images/fig6_10.jpg)'
- en: '**FIGURE 6.10**'
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 6.10**'
- en: Blockchain get_chain illustration with postman.
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 postman 的区块链 get_chain 示例。
- en: Activity
  id: totrans-803
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动
- en: Multiple Choice Questions
  id: totrans-804
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多项选择题
- en: What is full form for P2P?
  id: totrans-805
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: P2P 的全称是什么？
- en: Product-to-product
  id: totrans-806
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 产品对产品
- en: Peer-to-peer
  id: totrans-807
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点对点
- en: Pear-to-product
  id: totrans-808
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 梨对产品
- en: Product-to-peer
  id: totrans-809
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 产品对对等
- en: Which of the following defines a miner?
  id: totrans-810
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪项定义了矿工？
- en: A type of blockchain
  id: totrans-811
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一种区块链类型
- en: A person who encrypts the text
  id: totrans-812
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加密文本的人员
- en: A computer to store data
  id: totrans-813
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于存储数据的计算机
- en: A person who validates blockchain transactions and stores them on global ledger
  id: totrans-814
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证区块链交易并将其存储在全球总账上的人员
- en: Which term is used to define a blockchain split?
  id: totrans-815
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于定义区块链分裂的术语是什么？
- en: Fork
  id: totrans-816
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分叉
- en: Mining
  id: totrans-817
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 挖矿
- en: Nonce
  id: totrans-818
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随机数
- en: Genesis
  id: totrans-819
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创世
- en: What is usage of nonce?
  id: totrans-820
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Nonce 的用途是什么？
- en: To act as hashing function
  id: totrans-821
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为哈希函数的功能
- en: To prevent double spending
  id: totrans-822
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 防止双重支付
- en: To prevent 51% attack
  id: totrans-823
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 防止 51% 攻击
- en: None of the above
  id: totrans-824
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以上都不是
- en: What is genesis block?
  id: totrans-825
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创世区块是什么？
- en: The very first block of blockchain
  id: totrans-826
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 区块链的第一个区块
- en: The largest size block of blockchain
  id: totrans-827
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 区块链的最大块大小
- en: The smallest size block of blockchain
  id: totrans-828
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 区块链的最小块大小
- en: The block with having maximum number of transaction
  id: totrans-829
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含最大交易数量的区块
- en: What empowers Ethereum virtual machine?
  id: totrans-830
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么赋予以太坊虚拟机权力？
- en: Bitcoin
  id: totrans-831
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 比特币
- en: CoinDesk
  id: totrans-832
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: CoinDesk
- en: Ether
  id: totrans-833
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以太币
- en: Gas
  id: totrans-834
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Gas
- en: What is PoW?
  id: totrans-835
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是 PoW？
- en: A transaction verification protocol
  id: totrans-836
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个交易验证协议
- en: A hashing algorithm
  id: totrans-837
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个哈希算法
- en: An encryption algorithm
  id: totrans-838
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一种加密算法
- en: A certificate needed to install blockchain
  id: totrans-839
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装区块链所需的证书
- en: Which among the following is used to store Bitcoin?
  id: totrans-840
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个用于存储比特币？
- en: Pocket
  id: totrans-841
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 背袋
- en: Box
  id: totrans-842
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 盒子
- en: Wallet
  id: totrans-843
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 钱包
- en: Bank
  id: totrans-844
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 银行
- en: Which of the following constitute a block?
  id: totrans-845
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪些构成一个区块？
- en: A hash pointer
  id: totrans-846
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个哈希指针
- en: Nonce value
  id: totrans-847
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随机数值
- en: Transactions
  id: totrans-848
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 交易
- en: All of these
  id: totrans-849
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有这些
- en: Where is Bitcoin's central server located?
  id: totrans-850
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 比特币的中央服务器在哪里？
- en: India
  id: totrans-851
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 印度
- en: Washington
  id: totrans-852
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 华盛顿
- en: London
  id: totrans-853
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 伦敦
- en: None of these
  id: totrans-854
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些中的任何一个
- en: Which of the following industry can use blockchain technology?
  id: totrans-855
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个行业可以使用区块链技术？
- en: Healthcare
  id: totrans-856
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 医疗保健
- en: Smart grid
  id: totrans-857
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 智能电网
- en: P2P money exchange
  id: totrans-858
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: P2P货币交换
- en: All of these
  id: totrans-859
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有这些
- en: 1\. b  2\. d  3\. a  4\. b  5\. a  6\. d  7\. a  8\. c  9\. d  10\. d  11\.
    d
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. b  2\. d  3\. a  4\. b  5\. a  6\. d  7\. a  8\. c  9\. d  10\. d  11\.
    d
- en: <hgroup>
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: '[7](contents.xhtml#rchapter7)'
  id: totrans-862
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[7](contents.xhtml#rchapter7)'
- en: '[Verification and Validation Methods Used by Blockchain](contents.xhtml#rchapter7)'
  id: totrans-863
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[区块链使用的验证和验证方法](contents.xhtml#rchapter7)'
- en: </hgroup>
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '[7.1 Consensus Mechanism](contents.xhtml#rsec7_1)'
  id: totrans-865
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[7.1 共识机制](contents.xhtml#rsec7_1)'
- en: Blockchain operates as a self-regulating system without involving any centralized
    authority. Due to decentralized and distributed nature, blockchain faces the byzantine
    general problem [[129](bib.xhtml#ch00-bib-129)]. It is a problem of consensus
    making in a decentralized environment where communication channels cannot be trusted.
    Therefore, the blockchain network should work with reliability even in the presence
    of dishonest nodes. Moreover, in the absence of central authority, someone has
    to ensure validity and verification of blocks. The consensus mechanism is a process
    to reach a common agreement in a decentralized framework. The consensus mechanism
    makes sure that all nodes agree on a single state of shared block otherwise network
    has to face Byzantine general problem [[48](bib.xhtml#ch00-bib-48)]. It ensures
    reliability, correct operation, and fault tolerance even in the presence of faulty
    nodes. A consensus has to be deterministic, synchronized, and energy sufficient.
    [Fig. 7.1](09chap_07.xhtml#fig7_1) presents some of the requirements of the efficient
    consensus algorithm. However, achieving consensus in a distributed and decentralized
    environment is difficult.tcolorbox
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链作为一个自我调节的系统运行，不涉及任何中央权威。由于去中心化和分布式的特性，区块链面临拜占庭将军问题[[129](bib.xhtml#ch00-bib-129)]。这是一个在去中心化环境中做出共识的问题，其中通信渠道不能被信任。因此，区块链网络应该在存在不诚实节点的情况下保持可靠。此外，在没有中央权威的情况下，必须有人确保块的有效性和验证。共识机制是在分散框架中达成共识的过程。共识机制确保所有节点就共享块的单一状态达成一致，否则网络将面临拜占庭将军问题[[48](bib.xhtml#ch00-bib-48)]。它确保可靠性、正确操作和容错性，即使存在故障节点。共识必须是确定性的、同步的和能源充足的。[图7.1](09chap_07.xhtml#fig7_1)展示了高效共识算法的一些要求。然而，在分布式和去中心化的环境中达成共识是困难的。
- en: '**Key point** Consensus algorithm for public blockchain has low scalability
    but it achieves low latency and high throughput whereas private blockchain consensus
    algorithm has high scalability.'
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: '**要点** 公共区块链的共识算法具有低可扩展性，但实现低延迟和高吞吐量，而私有区块链共识算法具有高可扩展性。'
- en: '![Figure 7.1](../images/fig7_1.jpg)'
  id: totrans-868
  prefs: []
  type: TYPE_IMG
  zh: '![图7.1](../images/fig7_1.jpg)'
- en: '**FIGURE 7.1**'
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: '**图7.1**'
- en: Characteristics of a consensus algorithm.
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: 共识算法的特点。
- en: Next, different consensus algorithms are discussed. The tabular comparison between
    these discussed consensus is discussed in [Tables 7.1](#tab7_1) and [7.2](#tab7_2).
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来讨论了不同的共识算法。这些讨论的共识之间的表格比较在[表7.1](#tab7_1)和[7.2](#tab7_2)中进行了讨论。
- en: '**TABLE 7.1**'
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: '**表7.1**'
- en: Comparison of different consensus algorithms.
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: 不同共识算法的比较。
- en: '![Table 7.1](../images/tab7_1.jpg)'
  id: totrans-874
  prefs: []
  type: TYPE_IMG
  zh: '![表7.1](../images/tab7_1.jpg)'
- en: '**TABLE 7.2**'
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: '**表7.2**'
- en: Comparison of different consensus algorithms.
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: 不同共识算法的比较。
- en: '![Table 7.2](../images/tab7_2.jpg)'
  id: totrans-877
  prefs: []
  type: TYPE_IMG
  zh: '![表7.2](../images/tab7_2.jpg)'
- en: '[7.1.1 Proof-of-Work](contents.xhtml#rsec7_1_1)'
  id: totrans-878
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[7.1.1 工作证明](contents.xhtml#rsec7_1_1)'
- en: It is the first and most popular consensus algorithm used by blockchain network
    to achieve Byzantine fault tolerance. Originally, Proof-of-Work (PoW) was designed
    for public blockchain but in many existing research, PoW has been used by private
    and consortium networks. The foundation of PoW is a belief that if a node is capable
    enough to perform difficult cryptography calculations, then it is unlikely that
    the node will attack the network. The benefit of proof related consensus algorithm
    is that there is no requirement to wait for approval from other network members
    to mine the block. To add a block to the blockchain network, each miner tries
    to find a particular nonce value to generate the SHA hash of the block specified
    in the block header. To solve this kind of cryptographic puzzle, the value of
    nonce is incremented after every round in order to achieve a hash value equal
    to or lower than the target value defined for that block. In particular, block
    hash should have certain zeros at the beginning also called difficulty of the
    system. After mining, miners will broadcast the block to the network. If majority
    of the network members will accept the block only then it will be successfully
    appended to the blockchain. If a miner or group of miners controls 51% of the
    hashing power then it leads to 51% attack. Clearly, with PoW mechanism, an abundance
    of energy gets wasted as multiple miners compete to mine a block simultaneously
    and at last only one block gets accepted by the network.
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: 这是区块链网络用来实现拜占庭容错的第一个也是最流行的共识算法。最初，工作量证明（PoW）是为公共区块链设计的，但在许多现有的研究中，PoW已被私有和联盟网络使用。PoW的基础是一个信念，即如果一个节点足够能够执行困难的密码学计算，那么该节点不太可能对网络发起攻击。与证明相关的共识算法的好处在于，无需等待其他网络成员的批准即可挖掘区块。为了将一个区块添加到区块链网络中，每个矿工都会尝试找到一个特定的随机值，以生成区块头中指定的SHA哈希。为了解决这种密码难题，随机值在每一轮后递增，以实现哈希值等于或低于为该区块定义的目标值。特别是，区块哈希应该在开头有一定数量的零，也称为系统的难度。挖矿后，矿工将向网络广播该区块。只有当大多数网络成员接受该区块时，它才会成功附加到区块链上。如果一个矿工或一组矿工控制了51%的哈希算力，那么就会导致51%攻击。显然，通过PoW机制，大量能量被浪费，因为多个矿工同时竞争挖掘一个区块，最终只有一个区块被网络接受。
- en: '[7.1.2 Proof-of-Stake](contents.xhtml#rsec7_1_2)'
  id: totrans-880
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[7.1.2 权益证明](contents.xhtml#rsec7_1_2)'
- en: Proof-of-Stake (PoS) was specially designed to solve the issue of high energy
    consumption by PoW. PoS demands less energy over PoW as fewer CPU computations
    are involved while mining blocks. Rather than relying on external investment like
    PoW, PoS only uses internal investment (that is cryptocurrency). Although like
    PoW, PoS is also designed for permissionless blockchain. However, in PoS, miners
    are referred to as validators and blocks are forged not mined. It is based on
    the foundation that a node on a network with more participation and cryptocoins
    is less likely to attack the network. To become validators, nodes have to deposit
    some cryptocoins as stake. The probability that a stakeholder can append a new
    block to the chain is proportional to the amount of stake in his/her account.
    PoS provides security to the network due to the fact that members’ stakes are
    at risk. Unfortunately, with this approach rich gets richer as validators receive
    incentives for validating a transaction which increases the possibility of the
    same node getting selected as validator again and again. Moreover, a node only
    with sufficient amount of stakes can attack the system by investing stakes in
    comparison to PoW that involves the investment of electricity, CPU computations
    and timing. Clearly, to launch 51% attack, validators have to control atleast
    51% of total digital currency existing in the network which makes the PoS attack
    more costly. Obviously, not successful attacks would result in large financial
    losses. The first use case of PoS is PPCoin where participants with oldest and
    more number of coins posses more possibility to mine the block (this is also called
    coin age based selection). Here, stake is the number of coins multiplied by holding
    period [[119](bib.xhtml#ch00-bib-119)].
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: 股权证明（PoS）是专门设计用来解决PoW高能耗问题的。与PoW相比，PoS在挖矿时涉及的CPU计算较少，因此能耗更低。PoS不像PoW那样依赖外部投资，而是仅使用内部投资（即加密货币）。尽管与PoW类似，PoS也是为无需许可的区块链设计的。然而，在PoS中，矿工被称为验证者，而不是矿工，并且区块是被铸造而不是被挖掘出来的。它基于这样一个基础：网络上参与度和加密货币更多的节点更不可能攻击网络。要成为验证者，节点必须抵押一些加密货币作为赌注。持有者可以将新区块附加到链上的概率与其账户中的赌注数量成比例。PoS通过成员的赌注处于风险之中来为网络提供安全性。不幸的是，这种方法导致富者越富，因为验证者为验证交易而获得激励，这增加了同一节点再次被选择为验证者的可能性。此外，只有具有足够赌注的节点才能通过投资赌注攻击系统，而PoW则需要投资电力、CPU计算和时间。显然，要发动51%攻击，验证者必须控制至少51%的网络中存在的总数字货币，这使得PoS攻击更加昂贵。显然，不成功的攻击将导致巨额财务损失。PoS的第一个用例是PPCoin，其中拥有最老和最多硬币的参与者具有更大的挖矿可能性（这也称为基于硬币年龄的选择）。在这里，赌注是硬币数量乘以持有期[[119](bib.xhtml#ch00-bib-119)]。
- en: '[7.1.3 Delegated Proof-of-Stake](contents.xhtml#rsec7_1_3)'
  id: totrans-882
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[7.1.3 委托股权证明](contents.xhtml#rsec7_1_3)'
- en: This is also an alternative to PoW as PoW demands lots of external resources.
    In contrast, Delegated Proof-of-Stake (DPoS) demands fewer resources and is more
    eco-friendly by design. A DPoS is based on a voting system where stakeholders
    vote for a few delegates (witnesses) who will be responsible for securing the
    network on their behalf. Here miners are referred to as witnesses and they have
    the responsibility to successfully create a new block. The voting power of a node
    is proportional to the number of cryptocoins each user holds. The witnesses are
    elected based on reputation which is decided by the number of stakes each witness
    is holding [[130](bib.xhtml#ch00-bib-130)]. The top *m* witnesses with more number
    of votes participate in the decision making of blockchain network. The value *m*
    is chosen such that atleast 50% of the voters deduce that there is enough decentralization
    [[17](bib.xhtml#ch00-bib-17)]. For validating a block, witnesses get some benefits.
    The elected witnesses validate blocks one by one. In case a witness fails to validate
    in a fixed time, then the block is assigned to the next witness in the queue and
    a new witness is selected to replace the careless one. For 51% attack to be launched,
    the attacker has to control 51% of the selected witnesses. Notably, more participation
    of stakeholders in selecting witnesses, harder it becomes for an attacker to launch
    attack.
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是对 PoW 的一种替代方案，因为 PoW 需要大量外部资源。相比之下，委托权益证明（DPoS）需要较少的资源，并且在设计上更加环保。DPoS 基于一个投票系统，利益相关者投票选出少数代表（见证人），他们将代表他们负责保护网络。在这里，矿工被称为见证人，他们有责任成功创建一个新的区块。节点的投票权与每个用户持有的加密货币数量成正比。见证人根据声誉选举产生，声誉由每个见证人持有的股份数量决定
    [[130](bib.xhtml#ch00-bib-130)]。投票数最多的 *m* 个见证人参与区块链网络的决策制定。选取值 *m* 使至少有 50% 的投票人得出有足够的去中心化
    [[17](bib.xhtml#ch00-bib-17)]。为了验证一个区块，见证人会得到一些好处。选举产生的见证人逐一验证区块。如果一个见证人在固定时间内未能验证通过，那么该区块将被分配给队列中的下一个见证人，同时选取一个新的见证人来替换不负责任的人。要发动
    51% 攻击，攻击者必须控制选取的 51% 见证人。值得注意的是，利益相关者在选取见证人方面的更多参与，对于攻击者发动攻击变得越来越困难。
- en: '[7.1.4 Practical Byzantine Fault Tolerance](contents.xhtml#rsec7_1_4)'
  id: totrans-884
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[7.1.4 实用拜占庭容错](contents.xhtml#rsec7_1_4)'
- en: Byzantine fault tolerance is described as the capability of a distributed system
    to reach an agreement even in the presence of an attacker node in the network
    sending out misleading information. Practical Byzantine Fault Tolerance (PBFT)
    was designed to optimize BFT for implementation in blockchain network. Practical
    Byzantine Fault Tolerance (PBFT) [[59](bib.xhtml#ch00-bib-59)] was designed to
    solve the Byzantine Generals problem [[129](bib.xhtml#ch00-bib-129)] for the asynchronous
    environment. It is based on assumption that less than 30% of total nodes are malicious
    in network. In other words, a minimum of <math alttext="" display="inline"><mrow><mn>3</mn><mi>f</mi><mo>+</mo><mn>1</mn></mrow></math>
    nodes needs to work, where *f* is the number of faulty replicas. PBFT-based blockchain
    can tolerate atmost 33% of malicious nodes. The process of PBFT consists of 3
    phases which includes.
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: 拜占庭容错被描述为分布式系统在网络中存在攻击者节点发送误导信息的情况下仍能达成一致的能力。实用拜占庭容错（PBFT）旨在优化拜占庭容错，以便在区块链网络中实现。实用拜占庭容错（PBFT）[[59](bib.xhtml#ch00-bib-59)]旨在解决异步环境中的拜占庭将军问题[[129](bib.xhtml#ch00-bib-129)]。它基于这样一个假设，即网络中不到总节点数的30%是恶意的。换句话说，至少需要<math
    alttext="" display="inline"><mrow><mn>3</mn><mi>f</mi><mo>+</mo><mn>1</mn></mrow></math>个节点协作，其中
    *f* 是故障副本的数量。基于 PBFT 的区块链最多可以容忍33%的恶意节点。PBFT 的过程包括3个阶段，其中包括。
- en: 'Pre-prepare: For each request, a leader node broadcasts pre-prepare message
    to ask for value that other nodes of the network wants to commit.'
  id: totrans-886
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预准备：对于每个请求，领导节点广播预准备消息，询问网络中其他节点想要提交的值。
- en: 'Prepare: Nodes broadcast a prepare message that specifies the value they are
    about to commit.'
  id: totrans-887
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备：节点广播准备消息，指定它们即将提交的值。
- en: 'Commit: Leader node confirms the request if <math alttext="" display="inline"><mrow><mn>2</mn><mi>f</mi><mo>+</mo><mn>1</mn></mrow></math>
    nodes agree in the previous phase.'
  id: totrans-888
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提交：如果前一阶段有<math alttext="" display="inline"><mrow><mn>2</mn><mi>f</mi><mo>+</mo><mn>1</mn></mrow></math>个节点同意，则领导节点确认请求。
- en: However, with an priori list of participants, consensus can be reached with
    low transaction latency and low network communication overhead in PBFT. Moreover,
    limited scalability does not make it suitable for IoT applications [[107](bib.xhtml#ch00-bib-107)].
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在 PBFT 中，如果有事先列出参与者的先验列表，就可以在低事务延迟和低网络通信开销的情况下达成共识。此外，有限的可伸缩性使其不适用于物联网应用[[107](bib.xhtml#ch00-bib-107)]。
- en: '[7.1.5 Proof-of-Authority](contents.xhtml#rsec7_1_5)'
  id: totrans-890
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[7.1.5 权威证明](contents.xhtml#rsec7_1_5)'
- en: Proof-of-Authority (PoA) [[18](bib.xhtml#ch00-bib-18)] is an optimized variant
    of the PoS model where authorities on the network stake their identities for fair
    operation of the network. Parity [[19](bib.xhtml#ch00-bib-19)] and Geth [[20](bib.xhtml#ch00-bib-20)]
    have implemented PoA. PoA assumes that authorities are honest and trusted. By
    staking identities, validators do not wish to get associated with a negative reputation.
    Instead of appointing one authority, a set of authorities is used to reach an
    agreement about state of the network and the final decision has to be validated
    by the authorities. The authorities rely on mining rotation approach [[36](bib.xhtml#ch00-bib-36)]
    when a block is created. It is based on the assumption that with *N* authorities,
    atleast <math alttext="" display="inline"><mrow><mfrac><mi>N</mi><mn>2</mn></mfrac><mo>+</mo><mn>1</mn></mrow></math>
    should be trustworthy nodes. The PoA algorithm is designed for both permissioned
    and permitionless networks. However, the authors of [[68](bib.xhtml#ch00-bib-68)]
    demonstrated that PoA is not applicable for permissioned blockchain because it
    faces consistency issues. Unlike PBFT, PoA involves few exchange of messages in
    the network which improves better performance. However, the usage of a centralized
    authority limits the usage of PoA in some applications.
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: 权威证明（PoA）[[18](bib.xhtml#ch00-bib-18)] 是 PoS 模型的优化变体，网络上的权威方为了公平运作网络而抵押其身份。
    Parity [[19](bib.xhtml#ch00-bib-19)] 和 Geth [[20](bib.xhtml#ch00-bib-20)] 已经实现了
    PoA。 PoA 假设权威是诚实和可信任的。通过抵押身份，验证者不希望与负面声誉联系在一起。与指定一个权威不同，一组权威被用来就网络状态达成一致，并且最终决定必须得到权威的验证。当一个区块被创建时，权威依赖于挖矿轮换方法[[36](bib.xhtml#ch00-bib-36)]。这是基于这样一个假设：对于
    *N* 个权威，至少应有 <math alttext="" display="inline"><mrow><mfrac><mi>N</mi><mn>2</mn></mfrac><mo>+</mo><mn>1</mn></mrow></math>
    个可信节点。PoA 算法设计用于受许可和无许可网络。然而，[[68](bib.xhtml#ch00-bib-68)] 的作者表明，PoA 不适用于受许可的区块链，因为它面临一致性问题。与
    PBFT 不同，PoA 在网络中涉及少量的消息交换，这提高了性能。然而，使用集中式权威限制了 PoA 在一些应用中的使用。
- en: '[7.1.6 Proof-of-Capacity](contents.xhtml#rsec7_1_6)'
  id: totrans-892
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[7.1.6 容量证明](contents.xhtml#rsec7_1_6)'
- en: Unlike PoW, in order to add a new block in Proof-of-Capacity (PoC) storage has
    to be dedicated instead of computation with CPU's and GPU's [[75](bib.xhtml#ch00-bib-75)].
    With this consensus, a huge amount of energy can be saved. PoC is also referred
    to as condensed proof of work because all computations are performed once in advance
    by the verifier even before the mining begins and the results of this work (plot
    files) are cached on hard disk. The process of plotting creates a nonce value
    by using the shabal hashing mechanism. The mining process only needs to read the
    plot file. If the storage medium contains a quick solution to a recently generated
    block puzzle, the account of the verifier is incentivized. However, the size of
    the hard drive determines the time taken to create unique plot files. Unlike PoS,
    everyone on the network has a fair chance of mining because storage medium is
    easily available at cheaper prices.
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: 不同于 PoW，在容量证明（PoC）中为了添加新区块必须专用存储空间，而不是使用 CPU 和 GPU 进行计算 [[75](bib.xhtml#ch00-bib-75)]。通过这种共识机制，可以节省大量能源。PoC
    也被称为紧缩型工作证明，因为验证者在挖矿开始之前就已经预先执行了所有计算，并将这些工作的结果（绘图文件）缓存在硬盘上。绘图的过程通过使用 shabal 哈希机制创建一个随机值。挖矿过程只需要读取绘图文件。如果存储介质包含对最近生成的区块难题的快速解决方案，验证者的账户将获得激励。然而，硬盘的大小决定了创建唯一绘图文件所需的时间。与
    PoS 不同，因为存储介质价格便宜且易得，网络上的每个人都有公平的挖矿机会。
- en: '[7.1.7 Proof-of-Burn](contents.xhtml#rsec7_1_7)'
  id: totrans-894
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[7.1.7 烧币证明](contents.xhtml#rsec7_1_7)'
- en: Proof-of-Burn (PoB) [[21](bib.xhtml#ch00-bib-21)] was designed to solve the
    problem of high energy consumption in PoW and to reduce dependency on hardware
    resources. In PoB, miners invest coins to an eater address that is a unspendable
    address (at this address the coins become useless and inaccessible). The eater
    address does not have any private key assigned to it which implies that only coins
    can be sent to this address, but coins sent to the eater address can't be used
    or spent again. By burning or investing coins, a miners represents his/her readiness
    to bear short-term losses. While burning coins, a transaction is executed for
    the eater address and with this transaction, a burn hash is calculated. Burn hashes
    are computed by multiplying a multiplier with a internal hash. If the value of
    the burn hash is smaller than some predefined value, then the block from PoB is
    generated. The more a miner burns cryptocurrency, the higher is the probability
    of mining. After successfully mining a block, miners are rewarded. However, this
    scheme is costly from an individual miner perspective.
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: Proof-of-Burn（PoB）[[21](bib.xhtml#ch00-bib-21)]旨在解决PoW中高能耗的问题，并减少对硬件资源的依赖。在PoB中，矿工将硬币投资到一个不可花费地址（在这个地址上，硬币变得无用和不可访问）。该不可花费地址没有分配任何私钥，这意味着只能向该地址发送硬币，但发送到该地址的硬币不能再次使用或花费。通过烧毁或投资硬币，矿工表示愿意承担短期损失。在燃烧硬币时，会执行一个交易给不可花费地址，并通过此交易计算出一个燃烧哈希。燃烧哈希是通过将乘数与内部哈希相乘来计算的。如果燃烧哈希的值小于某个预定义值，则从PoB生成区块。矿工烧毁加密货币越多，挖矿的概率就越高。成功挖出一个区块后，矿工会受到奖励。然而，从个人矿工的角度来看，这个方案是昂贵的。
- en: '[7.1.8 Proof-of-Luck](contents.xhtml#rsec7_1_8)'
  id: totrans-896
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[7.1.8 幸运证明](contents.xhtml#rsec7_1_8)'
- en: Proof-of-Luck (PoL) [[142](bib.xhtml#ch00-bib-142)]uses a Trusted Execution
    Environment (TEE) for correct processing of critical operations. The idea behind
    PoL is that every node on the network requests a random number (luck value) from
    TEE. The higher the luck value, the higher are the chances to get selected as
    a miner node. Similar to PoW, nodes on the network receive transaction and miner
    nodes compete to commit pending transactions in a block having the luck value
    generated by the TEE. Next, nodes broadcast the generated block to the network
    and the lucky block gets added to the network. Here, an assumption is made that
    less than half of nodes are faulty. PoL also requires the installation of a specialized
    hardware such as- SGX.
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运证明（PoL）[[142](bib.xhtml#ch00-bib-142)] 使用可信执行环境（TEE）来正确处理关键操作。 PoL背后的理念是网络上的每个节点都向TEE请求一个随机数（幸运值）。
    幸运值越高，被选为矿工节点的机会就越大。 与PoW类似，网络上的节点接收交易，矿工节点竞争在由TEE生成的幸运值的区块中提交待处理的交易。 接下来，节点将生成的区块广播到网络，幸运区块被添加到网络中。
    在这里，假设少于一半的节点是有故障的。 PoL还需要安装专用硬件，如SGX。
- en: '[7.2 Simplified Payment Verification](contents.xhtml#rsec7_2)'
  id: totrans-898
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[7.2 简化支付验证](contents.xhtml#rsec7_2)'
- en: Notably, the blockchain network generates the bulk of data which makes it difficult
    for resource-constrained devices to store all the data on their devices. This
    problem is specifically faced by mobile devices. The increasing size of the blockchain
    is clearly a concern for memory-constrained devices IoT devices and Bitcoin mobile
    users. As reported by [[22](bib.xhtml#ch00-bib-22)], the total size of the Bitcoin
    blockchain is 270.11 GB by the end of March 2020 and clearly, this data will rise
    in the coming years.
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，区块链网络生成了大量数据，这使得资源受限的设备难以在其设备上存储所有数据。这个问题特别困扰移动设备。区块链的不断增长显然对内存受限的设备、物联网设备和比特币移动用户构成了问题。根据[[22](bib.xhtml#ch00-bib-22)]的报道，到2020年3月底，比特币区块链的总大小为270.11
    GB，显然，这个数据在未来几年将会增长。
- en: To address this issue, blockchain supports two types of clients in a blockchain
    network, i.e., lightweight client and full client. A full node is a node of blockchain
    network which follows all rules of blockchain whereas a lightweight node is the
    one referencing trusted full nodes. Lightweight clients are also referred to as
    thin clients. In contrast to a full client, a lightweight client does not need
    to download the entire blockchain network. Nevertheless, the lightweight client
    downloads block header of all the blocks. Clearly, it results in less space and
    bandwidth consumption as no actual transactions are getting downloaded. However,
    these nodes take part in simple network operation including confirming balance,
    receiving transaction history, checking the existence of a transaction in a block,
    verification of block difficulty and downloading block headers, and to perform
    such operations these clients are dependent on the full client. These clients
    refer to one or more full client for validation, verification of transactions,
    and mining tasks. Moreover, these clients do not receive all transactions that
    are broadcasted in the network. Rather they receive some filtered transactions
    in which they are interested in from the connected full client. Over and above,
    a lightweight client can only execute limited verification compared to a full
    client. If a lightweight node wants to verify the inclusion of a transaction in
    any block, it will request access to Merkle bunch from the full node. Next, the
    lightweight node will calculate the Merkle hash value with the received hash value
    from the full node and compares it with the Merkle hash value that is downloaded
    from the block header. This whole process of confirming inclusion of a particular
    transaction to the blockchain without actually downloading the entire blockchain
    is referred to as Simplified payment verification (SPV). SPV process is however
    associated with security and privacy issues. Notably, any attacker can cheat lightweight
    node with fake transactions. Although this problem can be solved by connecting
    to different full nodes and ensuring that everybody agrees on same chain of blocks.tcolorbox
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决这个问题，区块链支持区块链网络中的两种客户端，即轻量级客户端和完整客户端。完整节点是遵循区块链的所有规则的区块链网络节点，而轻量级节点是引用可信任的完整节点的节点。轻量级客户端也称为瘦客户端。与完整客户端相比，轻量级客户端不需要下载整个区块链网络。尽管如此，轻量级客户端会下载所有块的块头。显然，由于没有实际交易被下载，这导致了更少的空间和带宽消耗。然而，这些节点参与简单的网络操作，包括确认余额、接收交易历史、检查交易是否存在于块中、验证块难度以及下载块头等操作，而要执行这些操作，这些客户端依赖于完整客户端。这些客户端参考一个或多个完整客户端进行验证、交易验证和挖矿任务。此外，这些客户端不会接收网络中广播的所有交易。相反，它们从连接的完整客户端接收一些它们感兴趣的经过筛选的交易。此外，与完整客户端相比，轻量级客户端只能执行有限的验证。如果轻量级节点想要验证某个交易是否包含在任何块中，它将请求从完整节点获取
    Merkle 树。接下来，轻量级节点将使用从完整节点接收的哈希值计算 Merkle 哈希值，并将其与从块头下载的 Merkle 哈希值进行比较。这个确认特定交易被包含在区块链中的整个过程，而不需要实际下载整个区块链，被称为简化支付验证（SPV）。然而，SPV
    过程与安全和隐私问题有关。值得注意的是，任何攻击者都可以通过虚假交易欺骗轻量级节点。尽管这个问题可以通过连接到不同的完整节点并确保每个人都同意相同的区块链链解决。
- en: '**Key point** To solve scalability problem, Satoshi has described the process
    of reclaiming disk space that mentions eliminating unnecessary old transactions
    from the blocks. However, before discarding a spend transaction to save disc space,
    make sure that the transaction in a coin is buried under enough blocks. To achieve
    this without disturbing block hash, only the Merkle root hash is included in the
    block.'
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键点** 为了解决可伸缩性问题，中本聪描述了回收磁盘空间的过程，提到了从区块中消除不必要的旧交易。然而，在丢弃用于保存磁盘空间的支出交易之前，请确保硬币中的交易已被足够多的区块所埋藏。为了在不干扰区块哈希的情况下实现这一点，只有默克尔根哈希被包含在区块中。'
- en: '[7.3 Block Validation](contents.xhtml#rsec7_3)'
  id: totrans-902
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[7.3 区块验证](contents.xhtml#rsec7_3)'
- en: 'Even after the mining process, nodes of the network validates the block before
    it is added to the main blockchain. The following points should be checked before
    inclusion of block in a blockchain:'
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在挖矿过程之后，网络节点也会在将其添加到主区块链之前验证区块。在将区块包含在区块链中之前，应检查以下几点：
- en: 'Syntactic structure: It is a foremost validation that makes sure that block
    should be in a syntactic structure defined for that blockchain network.'
  id: totrans-904
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语法结构：这是一项首要的验证，确保区块应该符合该区块链网络定义的语法结构。
- en: 'Timestamp validation: Blocks are considered valid if timestamp value is greater
    than the median timestamp of immediate previous 11 blocks and less than 2+ network
    adjusted time where network adjusted time is the median of timestamp values returned
    by all connected peers to the validator node.'
  id: totrans-905
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间戳验证：如果时间戳值大于直接前 11 个区块的中间时间戳值且小于网络调整时间的 2+，则区块被视为有效。网络调整时间是由所有连接的对验证节点返回的时间戳值的中位数。
- en: 'Transaction: There should be at least one transaction present in that block.'
  id: totrans-906
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交易：该区块中应该至少存在一笔交易。
- en: 'Merkle hash: Merkle hash is computed from transactions in the received block
    and is matched against Merkle hash present in the block header. Hashes are actually
    considered to be the central security element of a blockchain network.'
  id: totrans-907
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默克尔哈希：默克尔哈希是从接收到的区块中的交易计算出来的，并与区块头中的默克尔哈希匹配。哈希实际上被认为是区块链网络的核心安全元素。
- en: 'Previous hash: Verify that the current block should contain the hash of immediate
    previous block.'
  id: totrans-908
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前一个哈希：验证当前区块应该包含直接前一个区块的哈希。
- en: 'Target: Hash of the bock should have value less than the target hash value.'
  id: totrans-909
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标：区块的哈希值应该小于目标哈希值。
- en: '[7.4 Transaction Validation](contents.xhtml#rsec7_4)'
  id: totrans-910
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[7.4 交易验证](contents.xhtml#rsec7_4)'
- en: 'Transaction broadcasted in the network needs to be validated to ensure that
    coin is spent by the authorised owner and not by any randomized user. Transaction
    validation rules are mentioned as follows:'
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络中广播的交易需要进行验证，以确保硬币是由授权所有者而不是任意用户花费的。交易验证规则如下所示：
- en: 'Empty: This property ensures that neither of the input and output transactions
    is empty.'
  id: totrans-912
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空：此属性确保输入和输出交易中没有一个为空。
- en: 'Structure: The defined syntactic structure of the transaction is correct.'
  id: totrans-913
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构：交易的定义的语法结构是正确的。
- en: 'Size: The total size of the transaction should be less than or equal to the
    maximum block size.'
  id: totrans-914
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大小：交易的总大小应小于或等于最大区块大小。
- en: 'Range: The output value of each transaction must be in the legal money range.'
  id: totrans-915
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 范围：每个交易的输出值必须在合法货币范围内。
- en: 'Insufficient coins: Transaction should be rejected if the total sum of input
    values is less than the sum of output values.'
  id: totrans-916
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 货币不足：如果输入价值的总和小于输出价值的总和，则应拒绝交易。
- en: 'Low transaction fees: Reject the transaction if transaction fees is too low
    than the defined transaction fees.'
  id: totrans-917
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 低交易费用：如果交易费用低于定义的交易费用，则拒绝交易。
- en: 'Public key: Verify that public key accepts for each input.'
  id: totrans-918
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公钥：验证每个输入是否接受公钥。
- en: 'Double spending: For every input, if there exist referenced output in any transaction
    in the pool, the transaction will be rejected.'
  id: totrans-919
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 双重花费：对于每个输入，如果交易池中任何交易存在引用的输出，则该交易将被拒绝。
- en: 'No output transaction: For every input, if there does not exist any referenced
    output, reject this transaction.'
  id: totrans-920
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有输出交易：对于每个输入，如果不存在任何被引用的输出，则拒绝该交易。
- en: 'Orphan transaction: For every input, probe the main branch and transaction
    pool to search the referenced output. If output transaction does not exist for
    any input, that transaction is an orphan transaction.'
  id: totrans-921
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 孤立交易：对于每个输入，探查主分支和交易池以搜索引用的输出。如果任何输入没有输出交易存在，则该交易是孤立交易。
- en: Activity
  id: totrans-922
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动
- en: Multiple Choice Questions
  id: totrans-923
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多项选择题
- en: What is the purpose of consensus algorithm?
  id: totrans-924
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 共识算法的目的是什么？
- en: To make sure all node agree on single state
  id: totrans-925
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保所有节点对单一状态达成一致
- en: To solve Byzantine general problem
  id: totrans-926
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解决拜占庭将军问题
- en: To ensure fault tolerance in presence of faulty nodes
  id: totrans-927
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在存在故障节点的情况下容错性
- en: All of these
  id: totrans-928
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以上所有
- en: What is biggest challenge of PoW?
  id: totrans-929
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PoW 的最大挑战是什么？
- en: High computational power required
  id: totrans-930
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要高计算能力
- en: A single miner can't perform mining
  id: totrans-931
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单个矿工无法进行挖矿
- en: A miner can't mine a single block at one time
  id: totrans-932
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 矿工不能一次挖掘一个单一区块
- en: None of these
  id: totrans-933
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以上都不是
- en: PoS stands for?
  id: totrans-934
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PoS 代表什么？
- en: Proof-of-Stake
  id: totrans-935
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 股权证明
- en: Proof-of-Standard
  id: totrans-936
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 标准证明
- en: Proof-of-source
  id: totrans-937
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 来源证明
- en: Proof of-secondary
  id: totrans-938
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 次级证明
- en: PPCoin cryptocurrency uses which consensus algorithm?
  id: totrans-939
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PPCoin 加密货币使用哪种共识算法？
- en: PoW
  id: totrans-940
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: PoW
- en: PoA
  id: totrans-941
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: PoA
- en: PoB
  id: totrans-942
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: PoB
- en: PoS
  id: totrans-943
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: PoS
- en: How DPoS algorithm selects a miner?
  id: totrans-944
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DPoS 算法如何选择矿工？
- en: Voting system
  id: totrans-945
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 投票系统
- en: The person with more electricity power
  id: totrans-946
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拥有更多电力的人
- en: The person with more computers
  id: totrans-947
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拥有更多计算机的人
- en: None of these
  id: totrans-948
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以上都不是
- en: What is the disadvantage of PBFT consensus algorithm?
  id: totrans-949
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PBFT 共识算法的缺点是什么？
- en: Limited reliability
  id: totrans-950
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可靠性有限
- en: Limited scalability
  id: totrans-951
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有限的可扩展性
- en: High computational power required
  id: totrans-952
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要高计算能力
- en: No fault tolerance
  id: totrans-953
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 没有容错性
- en: In PoB miners invest coins to an ether address.
  id: totrans-954
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 PoB 中，矿工将硬币投资到一个以太地址。
- en: 'True'
  id: totrans-955
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真
- en: 'False'
  id: totrans-956
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假
- en: Parity uses which consensus algorithm?
  id: totrans-957
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Parity 使用哪种共识算法？
- en: PoB
  id: totrans-958
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: PoB
- en: PoA
  id: totrans-959
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: PoA
- en: PoW
  id: totrans-960
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: PoW
- en: PoS
  id: totrans-961
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: PoS
- en: 1\. d  2\. a  3\. a  4\. d  5\. a  6\. b  7\. a  8\. b
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. d  2\. a  3\. a  4\. d  5\. a  6\. b  7\. a  8\. b
- en: <hgroup>
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: '[8](contents.xhtml#rchapter8)'
  id: totrans-964
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[8](contents.xhtml#rchapter8)'
- en: '[Data Structures for Blockchain](contents.xhtml#rchapter8)'
  id: totrans-965
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[区块链数据结构](contents.xhtml#rchapter8)'
- en: </hgroup>
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '[8.1 Data Structures for Blockchain](contents.xhtml#rsec8_1)'
  id: totrans-967
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[8.1 区块链数据结构](contents.xhtml#rsec8_1)'
- en: This section will discuss the important data structures used by blockchain.
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将讨论区块链使用的重要数据结构。
- en: 'Hash pointers: A pointer in data structures is used to pint address of value
    stored in memory. The process of fetching the value stored at any memory location
    is called dereferencing the pointer (Refer [Fig. 8.1](10chap_08.xhtml#fig8_1)).
    Additionally, a hash pointer is a type of pointer that points to address of hash
    value in order to make it tamper proof. Particularly, rather than just consisting
    of address of immediate previous block, it also has the hash of data in the previous
    block. Notably, hash pointers are used to construct a linked list called blockchain.
    In blockchain, hash pointer points to the hash of data stored in the immediate
    previous block. Hence, any modification in the chain would be detected with the
    hash pointers. Suppose an malicious person tampers with a block of blockchain,
    lets say block 10\. With change in content of block 10, hash of this block also
    got changed (collision free property of hash). To bluff others, he also has to
    change hash pointers of next block, i.e., block 11\. Furthermore hash pointer
    of block 12 also has to change and so on and so forth. Refer [Fig. 8.2](10chap_08.xhtml#fig8_2)
    for illustration of hash pointer chain.'
  id: totrans-969
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哈希指针：在数据结构中，指针用于指向存储在内存中的值的地址。获取存储在任何内存位置的值的过程称为解引用指针（参见 [图 8.1](10chap_08.xhtml#fig8_1)）。此外，哈希指针是一种指针类型，用于指向哈希值的地址，以使其防篡改。特别地，它不仅包含上一个块的地址，还包含上一个块中数据的哈希值。值得注意的是，哈希指针用于构造称为区块链的链表。在区块链中，哈希指针指向存储在上一个块中的数据的哈希。因此，对链中的任何修改都将通过哈希指针检测到。假设一个恶意人篡改了区块链的一个块，比如块
    10。随着块 10 内容的更改，此块的哈希值也会更改（哈希的无冲突属性）。为了欺骗其他人，他还必须更改下一个块的哈希指针，即块 11。此外，块 12 的哈希指针也必须更改，依此类推。请参阅
    [图 8.2](10chap_08.xhtml#fig8_2) 了解哈希指针链的示意图。
- en: '![Figure 8.1](../images/fig8_1.jpg)'
  id: totrans-970
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 8.1](../images/fig8_1.jpg)'
- en: '**FIGURE 8.1**'
  id: totrans-971
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**图 8.1**'
- en: Illustration of hash pointer.
  id: totrans-972
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 哈希指针的示意图。
- en: '![Figure 8.2](../images/fig8_2.jpg)'
  id: totrans-973
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 8.2](../images/fig8_2.jpg)'
- en: '**FIGURE 8.2**'
  id: totrans-974
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**图 8.2**'
- en: Illustration of hash pointer chain.
  id: totrans-975
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 哈希指针链的示意图。
- en: '**Key point** Hash pointers can be used in any pointer based data structures
    that is without any cycles. If cycles are present in data structures then we won''t
    be able to make all the hashes match up. Clearly, in a structure with cycles,
    there is no end that we can start with and compute back from.'
  id: totrans-976
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**关键点** 哈希指针可以用于任何基于指针的数据结构，而没有任何循环。如果数据结构中存在循环，则无法使所有哈希匹配起来。显然，在一个带有循环的结构中，我们没有可以从中开始并向后计算的结尾。'
- en: 'Linked list: Linked list is one of the most popular data structures. Particularly,
    it is a sequence of blocks containing some information that is linked to immediate
    next block through a pointer. The pointer in each block contains the address of
    next block. The last block has a null pointer which implies it is not pointing
    to anything. A blockchain is basically a linked list containing data and a hash
    pointer pointing to previous block.'
  id: totrans-977
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链表：链表是最流行的数据结构之一。特别是，它是一系列包含一些信息的块，通过指针链接到下一个块。每个块中的指针包含下一个块的地址。最后一个块有一个空指针，意味着它不指向任何内容。区块链基本上是包含数据和指向前一个块的哈希指针的链表。
- en: 'Merkle tree: Another important data structure constructed using hash pointer
    is a binary tree. In particular, this binary tree linked with hash pointer is
    referred to as Merkle tree. This is the main foundation of blockchain concepts.
    Merkle tree also called hash tree is named after Ralph Merkle [[140](bib.xhtml#ch00-bib-140)].
    It is basically a tree structure where the nodes at leaf level contain the hash
    of the document and every intermediate node contains the hash of left and a right
    child. As it is presented in [Fig. 8.3](10chap_08.xhtml#fig8_3), there are 8 transactions,
    i.e., t1, t2,…………,t8\. Leaf nodes of the Merkle tree contain the direct hash of
    these transactions and then level 1 has intermediate nodes with hash value of
    its left and right child (,i.e., obtained hashes are again paired to calculate
    the hash for next level). This hash will be recursively calculated till a single
    root hash is obtained. It implies that any change in the transaction will be reflected
    in the hash value at every level including root hash value including root hash
    value. So, with a single hash value, i.e., root hash the transactions, the transactions
    can be collectively stored without fear of alteration in a block. Therefore, the
    Merkle hash tree makes sure that data stored on the blockchain remains undamaged
    and unaltered. In other words, Merkle hash preserves the integrity of the document.'
  id: totrans-978
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默克尔树：另一个使用哈希指针构造的重要数据结构是二叉树。特别是，这个带有哈希指针的二叉树称为默克尔树。这是区块链概念的主要基础。默克尔树也称为哈希树，以拉尔夫·默克尔[[140](bib.xhtml#ch00-bib-140)]的名字命名。它基本上是一种树结构，叶子节点包含文档的哈希，每个中间节点包含其左右子节点的哈希。正如在[图
    8.3](10chap_08.xhtml#fig8_3)中所示，有 8 个交易，即，t1，t2，…………，t8。默克尔树的叶子节点包含这些交易的直接哈希，然后第
    1 级有包含其左右子节点哈希值的中间节点（即，获得的哈希再次配对以计算下一级的哈希）。这个哈希将递归地计算，直到获得单个根哈希。这意味着任何交易的更改都将反映在每个级别的哈希值中，包括根哈希值。因此，通过单个哈希值，即根哈希，可以在一个块中集体存储交易而不用担心更改。因此，默克尔哈希树确保了存储在区块链上的数据保持完整和未更改。换句话说，默克尔哈希保持文档的完整性。
- en: '![Figure 8.3](../images/fig8_3.jpg)'
  id: totrans-979
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 8.3](../images/fig8_3.jpg)'
- en: '**FIGURE 8.3**'
  id: totrans-980
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**图 8.3**'
- en: Structure of Merkle tree.
  id: totrans-981
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 默克尔树的结构。
- en: '**Key point** To compute Merkle hash, Bitcoin uses SHA-256 hash.'
  id: totrans-982
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**要点** 计算默克尔哈希，比特币使用 SHA-256 哈希。'
- en: 'Tries: Tries is a ordered tree data structure to maintain set of strings. If
    two strings have a common prefix then they will have same ancestor in trie. Trie
    is an ideal data structure for storing dictionary. Also, it is used for encoding
    and decoding. Notably this is not similar to a binary tree whereas it is a N-Ary
    tree. Infact, tries support better searching than binary search tree and hash
    tables. Hash tables does not support prefix based search. Moreover, with tries
    it is easy to print all words in alphabetical order.'
  id: totrans-983
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字典树：字典树是一种有序树数据结构，用于维护一组字符串。如果两个字符串有一个共同的前缀，则它们在字典树中将有相同的祖先。字典树是存储词典的理想数据结构。此外，它还用于编码和解码。值得注意的是，字典树与二叉树不同，而是一种
    N 叉树。实际上，字典树支持比二叉搜索树和哈希表更好的搜索。哈希表不支持基于前缀的搜索。此外，使用字典树可以轻松按字母顺序打印所有单词。
- en: A trie stores key-value pair where key is the path in the tree to reach its
    corresponding value. With tries, there is no restriction on number of children
    a node can have. However, all nodes descendants have a common prefix. In particular,
    each node can have up to 26 children. Each node's children are ordered alphabetically.
    It can thought of as a node that has a array of 26 size sitting inside. However,
    a better option is to have a linked list at each node to save space.
  id: totrans-984
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Trie（字典树）存储键-值对，其中键是树中达到其对应值的路径。使用字典树时，节点可以有任意数量的子节点。然而，所有节点的后代都有一个共同的前缀。特别是，每个节点最多可以有
    26 个子节点。每个节点的子节点按字母顺序排序。可以将其视为每个节点内置一个大小为 26 的数组。然而，更好的选择是在每个节点上使用链表来节省空间。
- en: Unfortunately, tries require large memory for storing strings as for each node
    there are further many pointers. Also, a trie prooves inefficient if there is
    long key and o other key shares a common prefix. A standard trie take <math alttext=""
    display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>W</mi><mo stretchy="false">)</mo></mrow></math>
    space, where *W* is the total size of strings in a set. Insertion, deletion, and
    search operation of a trie takes <math alttext="" display="inline"><mrow><mi>O</mi><mo
    stretchy="false">(</mo><mi>l</mi><mo>*</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></math>
    where, *l* is average length of word and *n* is total number of words whereas
    the worst case runtime complexity for creating a trie is <math alttext="" display="inline"><mrow><mi>O</mi><mo
    stretchy="false">(</mo><mi>m</mi><mo>*</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></math>
    where, *m* is the longest word in the string and n is the total number number
    of words. For example, the trie data structure for set of string S=bear, bell,
    bid, bull, buy, sell, stock, stop is represented in [Fig. 8.4](10chap_08.xhtml#fig8_4).
  id: totrans-985
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不幸的是，trie 对于存储字符串需要大量内存，因为对于每个节点都有更多的指针。此外，如果有长键并且没有其他键共享公共前缀，则 trie 会变得低效。标准
    trie 占用 <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>W</mi><mo
    stretchy="false">)</mo></mrow></math> 空间，其中 *W* 是集合中字符串的总大小。trie 的插入、删除和搜索操作的时间复杂度为
    <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mo>*</mo><mi>n</mi><mo
    stretchy="false">)</mo></mrow></math>，其中 *l* 是单词的平均长度，*n* 是单词的总数，而创建 trie 的最坏情况运行时复杂度为
    <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>*</mo><mi>n</mi><mo
    stretchy="false">)</mo></mrow></math>，其中 *m* 是字符串中最长的单词，*n* 是单词的总数。例如，字符串集合 S=bear，bell，bid，bull，buy，sell，stock，stop
    的 trie 数据结构在 [图 8.4](10chap_08.xhtml#fig8_4) 中表示。
- en: '![Figure 8.4](../images/fig8_4.jpg)'
  id: totrans-986
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 8.4](../images/fig8_4.jpg)'
- en: '**FIGURE 8.4**'
  id: totrans-987
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**图 8.4**'
- en: Illustration of trie data structure.
  id: totrans-988
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: trie 数据结构的说明。
- en: 'Patricia tree: Patricia stands for practical algorithm to retrieve information
    coded in alphanumeric. It is also based on fundamental that nodes with same prefix
    shares the same path (it is also called prefix tree). However, it requires low
    memory than trie data structure. It is actually a compact representation of a
    trie in which nodes having single child is merged with its parents. In other words,
    Patricia tree is similar to radix tree with the value of radix equal to 2\. In
    particular, Ethereum blockchain is based on Merkle-Patricia tree, which is a tree
    having root node that contains the hash value of whole data structures. [Fig.
    8.5](10chap_08.xhtml#fig8_5) represents the patricia tree for string S= bear,
    bell, bid, bull, buy, sell, stock, stop.'
  id: totrans-989
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Patricia 树：Patricia 代表实用的字母数字编码信息检索算法。它也基于节点具有相同前缀共享相同路径的基本原理（也称为前缀树）。然而，它需要比
    trie 数据结构更低的内存。实际上，它是 trie 的一种紧凑表示，在这种表示中，具有单个子节点的节点与其父节点合并。换句话说，Patricia 树类似于基数树，其基数值等于
    2。特别是，以太坊区块链基于 Merkle-Patricia 树，它是具有包含整个数据结构的哈希值的根节点的树。[图 8.5](10chap_08.xhtml#fig8_5)
    表示了字符串 S = bear，bell，bid，bull，buy，sell，stock，stop 的 Patricia 树。
- en: '![Figure 8.5](../images/fig8_5.jpg)'
  id: totrans-990
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 8.5](../images/fig8_5.jpg)'
- en: '**FIGURE 8.5**'
  id: totrans-991
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**图 8.5**'
- en: Illustration of patricia tree data structure.
  id: totrans-992
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Patricia 树数据结构的示例。
- en: 'Merkle Patricia trie: This data structure is a combination of Merkle tree and
    Patricia tree. Merkle tree is used to maintain data integrity whereas patricia
    tree in particular enables fast searching of information. These Merkle patricia
    also shows some form of verification and tamperproofing. Ethereum blockchain cryptocurrency
    uses Merkle patricia tree to store transaction and world state. Notably, Ethereum
    is quite different to Bitcoin as it uses smart contracts which keeps on updating
    everytime. Additionally, Ethereum rather than using one Merkle tree, it uses 3
    different Merkle tree to attain global state and to impose extra ability to query
    data within blockchain which are described as:'
  id: totrans-993
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Merkle Patricia trie：这种数据结构是 Merkle 树和 Patricia 树的组合。Merkle 树用于维护数据完整性，而 Patricia
    树特别是用于快速搜索信息。这些 Merkle Patricia 还展示了某种形式的验证和防篡改。以太坊区块链加密货币使用 Merkle Patricia 树来存储交易和世界状态。值得注意的是，以太坊与比特币非常不同，因为它使用智能合约，每次都在更新。此外，以太坊不是使用一个
    Merkle 树，而是使用 3 个不同的 Merkle 树来获得全局状态，并对区块链中的数据进行额外查询的能力，这些能力描述如下：
- en: 'stateRoot: which specifies the state of the block.'
  id: totrans-994
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: stateRoot：指定了区块的状态。
- en: 'transactionRoot: which specifies transaction hash in the block.'
  id: totrans-995
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: transactionRoot：指定了区块中的交易哈希。
- en: 'receiptRoot: which specify the amount of gas used in a block.'
  id: totrans-996
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: receiptRoot：指定了区块中使用的燃气量。
- en: 'In Ethereum all information of state is stored in key value pair. Keys are
    mainly string values that refers to search index. For example, account address
    is the key and balance is the value corresponding to the key. Merkle Patricia
    tree introduces 4 types of nodes which are described as follows:'
  id: totrans-997
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在以太坊中，所有状态信息都以键值对的形式存储。键主要是指向搜索索引的字符串值。例如，帐户地址是键，余额是对应于该键的值。Merkle Patricia
    树引入了 4 种类型的节点，描述如下：
- en: 'Empty node: These are simply blank nodes.'
  id: totrans-998
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空节点：这些只是空白节点。
- en: 'Leaf node: It is the end node that signifies end of path in a tree. Leaf node
    will not have any further child and it always contains some value corresponding
    to a key. It is made up of two items, first corresponding to a suffix and second
    to any value.'
  id: totrans-999
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 叶节点：它是树中路径结束的节点。叶节点不会有进一步的子节点，并且它总是包含与某个键对应的某些值。它由两个项目组成，第一个对应于后缀，第二个对应于任何值。
- en: 'Branch node: It is a node having more than one branch. It is a 17 item structure
    where first 16 items are hexadecimal value (0—F) and 17 th items corresponds to
    a terminator node.'
  id: totrans-1000
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分支节点：它是一个具有多个分支的节点。它是一个 17 项结构，其中前 16 项是十六进制值（0—F），第 17 项对应于终止节点。
- en: 'Extension node: It is a type of branch node but with one child. It is an optimized
    version of the branch node. It is a two item node where first portion signifies
    key part with size greater than one node and shared by atleast two different keys.
    Second part corresponds to a pointer to branch node.'
  id: totrans-1001
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展节点：它是一种分支节点，但只有一个子节点。这是分支节点的优化版本。它是一个两项节点，第一个部分表示键部分，大小大于一个节点，并且至少被两个不同的键共享。第二部分对应于指向分支节点的指针。
- en: Notably, to differentiate between leaf node and extension node, there is a concept
    of nibble. A nibble is added to the beginning of the key to differentiate both
    parity (even/odd length key) and terminator status (node is leaf or extension
    node). The lower significant bit signifies parity while next lowest tells terminator
    status. Moreover, if key length is even, an extra nibble is added to attain overall
    evenness. [Fig. 8.6](10chap_08.xhtml#fig8_6) shows illustration of Merkle Patricia
    tree.
  id: totrans-1002
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 值得注意的是，为了区分叶节点和扩展节点，有一个叫做 nibble 的概念。一个 nibble 被添加到键的开头，以区分奇偶性（偶数/奇数长度的键）和终止符状态（节点是叶节点还是扩展节点）。较低有效位表示奇偶性，而次低位表示终止符状态。此外，如果键的长度是偶数，则添加一个额外的
    nibble 以实现整体偶数长度。[图 8.6](10chap_08.xhtml#fig8_6)显示了 Merkle Patricia 树的示例。
- en: '![Figure 8.6](../images/fig8_6.jpg)'
  id: totrans-1003
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 8.6](../images/fig8_6.jpg)'
- en: '**FIGURE 8.6**'
  id: totrans-1004
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**图 8.6**'
- en: Illustration of Merkle Patricia tree data structure.
  id: totrans-1005
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Merkle Patricia 树数据结构的示例。
- en: 'Binary heap: Binary heap comes under the category of a binary tree. Particularly,
    binary heap is a complete binary tree which implies each level except possibly
    the lowest one are completely filled and the lowest level is always filled from
    the left. Moreover, a binary heap is categorized as either a max-heap or a min
    heap as per the ordering property. In a max-heap, the key value stored in each
    node must be greater than equal to the key value in the node''s children. In contrast,
    in a min-heap, the key value stored in each node must be less than or equal to
    key value in the node''s children. Examples of min-heap and max-heap data structure
    is represented in [Figs. 8.7](10chap_08.xhtml#fig8_7) and [8.8](10chap_08.xhtml#fig8_8).
    Ethereum blockchain uses binary heap data structure to solve the block-gas-limit
    and iteration problem of Ethereum. Ethereum gas is the price for executing certain
    operations in Ethereum blockchain. For instance, all Ethereum transactions are
    paid by the sender of the transaction. In such cases, intentionally an attacker
    can consume more gas by running arbitrary smart contracts for an incoming transaction.
    Besides, when users of Ethereum network insert data in a smart contract, it can
    result in too much gas cost to iterate through. In particular, if a developer
    relies on array data structure, an attacker can fill the array to the mark where
    iterating via it can result in more gas cost than it should be used for a single
    transaction to execute. Clearly, a binary heap resolves this issue as this data
    structure does not demand iteration via all elements of the tree, rather it only
    iterates through tree''s height. Moreover, the self-balancing property of max
    heap preserves degenerating a tree which leads to *O(log n)* cost even for the
    worst case (for a total of *n* elements).'
  id: totrans-1006
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二叉堆：二叉堆属于二叉树的一种。特别地，二叉堆是一个完全二叉树，这意味着除了可能是最低层的每一层都是完全填充的，而最低层始终从左边填充。此外，二叉堆根据排序属性被归类为最大堆或最小堆。在最大堆中，每个节点中存储的键值必须大于等于节点子节点中存储的键值。相反，在最小堆中，每个节点中存储的键值必须小于或等于节点子节点中存储的键值。最小堆和最大堆数据结构的示例分别在[Figs.
    8.7](10chap_08.xhtml#fig8_7)和[8.8](10chap_08.xhtml#fig8_8)中表示。以太坊区块链使用二叉堆数据结构来解决以太坊的区块燃气限制和迭代问题。以太坊燃气是在以太坊区块链中执行某些操作的价格。例如，所有以太坊交易都由交易发送者支付。在这种情况下，攻击者可以通过运行任意智能合约来消耗更多的燃气。此外，当以太坊网络的用户在智能合约中插入数据时，通过迭代可能导致过多的燃气成本。特别地，如果开发人员依赖于数组数据结构，攻击者可以填充数组直到通过它进行迭代的成本比单个交易应该用于执行的成本更高。显然，二叉堆解决了这个问题，因为这种数据结构不要求迭代整个树的所有元素，而只需迭代树的高度。此外，最大堆的自平衡属性保留了使树退化的树，这导致即使在最坏的情况下（对于总共的*n*个元素）也需要*O(log
    n)*的成本。
- en: '![Figure 8.7](../images/fig8_7.jpg)'
  id: totrans-1007
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图8.7](../images/fig8_7.jpg)'
- en: '**FIGURE 8.7**'
  id: totrans-1008
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**图8.7**'
- en: Example of max-heap.
  id: totrans-1009
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最大堆的示例。
- en: '![Figure 8.8](../images/fig8_8.jpg)'
  id: totrans-1010
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图8.8](../images/fig8_8.jpg)'
- en: '**FIGURE 8.8**'
  id: totrans-1011
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**图8.8**'
- en: Example of min-heap.
  id: totrans-1012
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最小堆的示例。
- en: Activity
  id: totrans-1013
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动
- en: Multiple Choice Questions
  id: totrans-1014
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多项选择题
- en: Which of the following data structure is used in blockchain?
  id: totrans-1015
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 区块链中使用以下哪种数据结构？
- en: Merkle hash tree
  id: totrans-1016
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默克尔哈希树
- en: Tries
  id: totrans-1017
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Trie
- en: Binary tree
  id: totrans-1018
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 二叉树
- en: All of the above
  id: totrans-1019
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以上所有
- en: What is the main purpose of using hash pointers for connectivity in blockchain?
  id: totrans-1020
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在区块链中使用哈希指针进行连接性的主要目的是什么？
- en: To prevent modifications in block
  id: totrans-1021
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 防止区块中的修改
- en: To encrypt block
  id: totrans-1022
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加密区块
- en: To decrypt block
  id: totrans-1023
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解密区块
- en: To find nonce value of block
  id: totrans-1024
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 寻找区块的随机数值
- en: Which hashing algorithm is used by Bitcoin to compute Merkle hash?
  id: totrans-1025
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 比特币用于计算默克尔哈希的哈希算法是什么？
- en: MD4
  id: totrans-1026
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: MD4
- en: MD5
  id: totrans-1027
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: MD5
- en: SHA-256
  id: totrans-1028
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: SHA-256
- en: All of these
  id: totrans-1029
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有这些
- en: What is the total space taken by trie data structure with *w* as total size
    of string in a set?
  id: totrans-1030
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 *w* 是集合中字符串的总大小，则 trie 数据结构的总空间占用是多少？
- en: '*O(w)*'
  id: totrans-1031
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*O(w)*'
- en: '*O(w2)*'
  id: totrans-1032
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*O(w2)*'
- en: '*O(log w)*'
  id: totrans-1033
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*O(log w)*'
- en: None of these
  id: totrans-1034
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以上都不是
- en: What is other name for Patricia tree?
  id: totrans-1035
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Patricia 树的另一个名称是什么？
- en: Prefix tree
  id: totrans-1036
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前缀树
- en: Suffix tree
  id: totrans-1037
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 后缀树
- en: Max heap
  id: totrans-1038
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最大堆
- en: Binary heap
  id: totrans-1039
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 二进制堆
- en: What is the main purpose of using merkle patricia tree?
  id: totrans-1040
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用默克尔帕特里夏树的主要目的是什么？
- en: To prevent modifications in block
  id: totrans-1041
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 防止区块中的修改
- en: To encrypt block
  id: totrans-1042
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加密区块
- en: To decrypt block
  id: totrans-1043
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解密区块
- en: To find nonce value of block
  id: totrans-1044
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 寻找区块的随机数值
- en: Which of the following node is a type of Merkle patricia tree?
  id: totrans-1045
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪种节点是默克尔帕特里夏树的一种类型？
- en: Leaf node
  id: totrans-1046
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 叶子节点
- en: Branch node
  id: totrans-1047
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分支节点
- en: Extension node
  id: totrans-1048
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扩展节点
- en: All of these
  id: totrans-1049
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有这些
- en: Why does Ethereum uses binary heap data structure?
  id: totrans-1050
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以太坊为什么使用二进制堆数据结构？
- en: To solve block gas limit and iteration problem
  id: totrans-1051
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解决区块气体限制和迭代问题
- en: To solve PoS problem
  id: totrans-1052
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解决 PoS 问题
- en: To authenticate nodes on network
  id: totrans-1053
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在网络上验证节点
- en: To generate more ethers
  id: totrans-1054
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成更多以太币
- en: Hash pointers can be used with any data structures with cycles?
  id: totrans-1055
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哈希指针可以与具有循环的任何数据结构一起使用？
- en: 'True'
  id: totrans-1056
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正确
- en: 'False'
  id: totrans-1057
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误
- en: What is the main purpose of using Merkle hash tree?
  id: totrans-1058
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用默克尔哈希树的主要目的是什么？
- en: To preserve integrity of block
  id: totrans-1059
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保护区块的完整性
- en: To decrypt a block
  id: totrans-1060
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解密区块
- en: To encrypt a block
  id: totrans-1061
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加密一个区块
- en: To find nonce value
  id: totrans-1062
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 寻找随机数值
- en: 1\. d  2\. a  3\. c  4\. a  5\. a  6\. a  7\. d  8\. a  9\. b  10\. a
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. d  2\. a  3\. c  4\. a  5\. a  6\. a  7\. d  8\. a  9\. b  10\. a
