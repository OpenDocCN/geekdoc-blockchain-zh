- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '[Part II](contents.xhtml#rpart2)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Blockchain Overview](contents.xhtml#rpart2)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '[4](contents.xhtml#rchapter4)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Python Basics](contents.xhtml#rchapter4)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '[4.1 Introduction](contents.xhtml#rsec4_1)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python is a high-level programming language used for general-purpose programming,
    developed by Guido Van Rossum in 1991\. Python is specially designed to be highly
    readable as it uses frequent English keywords. Python is frequently used to create
    software and web applications on a server. Some of the important features of Python
    are described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It supports concepts of object-oriented programming.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can be easily integrated with some other programming languages including
    C, C++, Java, Common Object Request Broker Architecture (CORBA), etc.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python is scalable as it better supports large programs than shell scripting.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python relies highly on indentation, here whitespace is used to define scope.
    Due to its strong structuring constructs, it supports clear writing and logical
    application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python can be easily connected to all major commercial databases.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python is portable as it runs on a wide variety of hardware platforms.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python supports interactive mode which enables interactive testing and debugging
    of code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python supports high-level dynamic data types and dynamic type checking.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python is a scripting language as it is suitable for embedding and for writing
    small unstructured scripts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Python programs are much shorter in length than equivalent C, C++ programs
    for the following reasons:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The complex operations can be expressed in a single statement with the support
    of high level data type in Python.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Use of indentation rather than using beginning and ending brackets.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Declaration of variables and arguments is not important.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Note:** Python is a compiled and interpreted programming language. The source
    code first gets compiled to a bytecode then that bytecode is interpreted as machine
    language on Python virtual machine to give actual output. The concept of bytecode
    achieves portability. However, to execute Python code, each time Python programs
    code is required.'
  prefs: []
  type: TYPE_NORMAL
- en: After writing the program, save the program with .py in a text editor. Further,
    execute that file in Python interpreter. Nevertheless, typing commands in Python
    interpreter is a good way to play with Python features but it is not suggested
    for solving more complex problems.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of this chapter discusses various important features of Python language
    with examples starting with simple statements, expressions, data types to concepts
    of classes, objects, functions, file handling, etc. Let's start Python programming.
  prefs: []
  type: TYPE_NORMAL
- en: '[4.2 Comments](contents.xhtml#rsec4_2)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Comments in Python are represented with a “#”. Everything written after “#”
    in a line is ignored. Notably, comments are not interpreted by Python language.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/list4_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Output: 5'
  prefs: []
  type: TYPE_NORMAL
- en: '[4.3 Multi-line Statement](contents.xhtml#rsec4_3)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To denote that line should continue, (multi-line statement) Python allows the
    use of line continuation character, i.e., Ḟor example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/list4_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[4.4 Blocks and Indentation](contents.xhtml#rsec4_4)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python depicts blocks and nested blocks structure with indentation not by using
    beginning and end brackets. Advantages of using indentation include reducing need
    for coding standard, reducing inconsistency, and reducing work. The number of
    count spaces in indentation is variable but within a block each and every statement
    must be indented the equal amount. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/list4_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following code will generate an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/list4_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[4.5 Creating Variables and Assigning Values](contents.xhtml#rsec4_5)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Variables are used to store values at a reserved memory location. After creating
    a variable, a space in memory is reserved. Unlike other programming languages,
    there is no need to declare variables explicitly. After assigning a value to a
    variable, use that variable in place of value. The equal sign is used to assign
    value to a variable. Python strings are expressed in single quotes or double quotes
    with same results. Print statement is used to display the value of a variable.
    For example, the statements
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/list4_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Output: 100'
  prefs: []
  type: TYPE_NORMAL
- en: hello
  prefs: []
  type: TYPE_NORMAL
- en: h
  prefs: []
  type: TYPE_NORMAL
- en: Variables can have a variable length and they can be arbitrarily long. A variable
    can have both letters and numbers, however, they can't start with a number.
  prefs: []
  type: TYPE_NORMAL
- en: '[4.6 Data Types](contents.xhtml#rsec4_6)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Variables can store data in different types. Numbers, strings, lists, tuple,
    dictionaries are the standard data types. Python number data types store numeric
    value. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: a=1, b=2.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python includes three different numeric types, i.e., int, float, complex. In
    contrast, a string is made of a sequence of characters. However, strings in Python
    are immutable, which implies it can''t be changed. Strings are declared with single
    or double character. For example: a=”abc”. Rest of the data types are discussed
    further in this chapter. type() function is used to get the data type of any variable.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/list4_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Output: str'
  prefs: []
  type: TYPE_NORMAL
- en: int
  prefs: []
  type: TYPE_NORMAL
- en: float
  prefs: []
  type: TYPE_NORMAL
- en: list
  prefs: []
  type: TYPE_NORMAL
- en: '[4.7 Operators](contents.xhtml#rsec4_7)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Similar to other programming languages, Python supports the following operator
    groups:'
  prefs: []
  type: TYPE_NORMAL
- en: Arithmetic operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparison operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assignment operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logical operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bitwise operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Membership operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identity operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[4.7.1 Arithmetic operator](contents.xhtml#rsec4_7_1)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This category includes mathematical operations, such as- addition(+), subtraction(-),
    division(/), modulus(%), and power(**). For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/list4_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '14'
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  prefs: []
  type: TYPE_NORMAL
- en: '40'
  prefs: []
  type: TYPE_NORMAL
- en: '2.5'
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: '10000'
  prefs: []
  type: TYPE_NORMAL
- en: '[4.7.2 Comparison operator](contents.xhtml#rsec4_7_2)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This operator is used to compare values and returns either true or false as
    per the condition. This category includes greater than(>), less than(<), equal
    to(==), not equal to(!=), greater than equal to(≥), and less than equal to(≤).
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/list4_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: a is not equal to b
  prefs: []
  type: TYPE_NORMAL
- en: a is not equal to b
  prefs: []
  type: TYPE_NORMAL
- en: a is not less than b
  prefs: []
  type: TYPE_NORMAL
- en: a is greater than b
  prefs: []
  type: TYPE_NORMAL
- en: a is neither less than nor equal to b
  prefs: []
  type: TYPE_NORMAL
- en: b is neither greater than nor equal to b
  prefs: []
  type: TYPE_NORMAL
- en: '[4.7.3 Logical operator](contents.xhtml#rsec4_7_3)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This category performs logical AND (and), logical OR(or), and logical NOT (not).
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/list4_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: 'False'
  prefs: []
  type: TYPE_NORMAL
- en: 'True'
  prefs: []
  type: TYPE_NORMAL
- en: 'False'
  prefs: []
  type: TYPE_NORMAL
- en: '[4.7.4 Python Bitwise operator](contents.xhtml#rsec4_7_4)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It performs bit-by-bit operation. Bitwise operator includes Bitwise AND(&),
    Bitwise OR(∨), Bitwise NOT(¬), Bitwise XOR(⊕), Bitwise right shift(≫), and Bitwise
    left shift (≪).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/list4_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: '14'
  prefs: []
  type: TYPE_NORMAL
- en: −11
  prefs: []
  type: TYPE_NORMAL
- en: '14'
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: '40'
  prefs: []
  type: TYPE_NORMAL
- en: '[4.7.5 Assignment operator](contents.xhtml#rsec4_7_5)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This operator is used to assign values to a variables. The available assignment
    operators are:'
  prefs: []
  type: TYPE_NORMAL
- en: '=: Assigns values from right side of operands to left side of operand'
  prefs: []
  type: TYPE_NORMAL
- en: '+=: Adds the right operand with the left operand and assigns result to the
    left operand'
  prefs: []
  type: TYPE_NORMAL
- en: '-=: Subtracts the right operand from left operand and then assigns to the left
    operand'
  prefs: []
  type: TYPE_NORMAL
- en: '*=: Multiplies the right operand with the left operand and assigns to the left
    operand'
  prefs: []
  type: TYPE_NORMAL
- en: :̄ Divides the left operand with right operand and then assigns the result to
    the left operand
  prefs: []
  type: TYPE_NORMAL
- en: '%=: Takes modulus using left and right operands and assigns the result to the
    left operand'
  prefs: []
  type: TYPE_NORMAL
- en: '**=: Performs exponential calculation on operators and assigns the value to
    the left operand'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/list4_11a.jpg)![](../images/list4_11b.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: Value of var3 is 31
  prefs: []
  type: TYPE_NORMAL
- en: Value of var3 is 52
  prefs: []
  type: TYPE_NORMAL
- en: Value of var3 is 1092
  prefs: []
  type: TYPE_NORMAL
- en: Value of var3 is 52
  prefs: []
  type: TYPE_NORMAL
- en: Value of var3 is 2
  prefs: []
  type: TYPE_NORMAL
- en: Value of var3 is 2097152
  prefs: []
  type: TYPE_NORMAL
- en: '[4.7.6 Membership operator](contents.xhtml#rsec4_7_6)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This operator is used to check for membership of an element in a sequence.
    There are two membership operators discussed below:'
  prefs: []
  type: TYPE_NORMAL
- en: 'in: Results to true if element is present in the sequence otherwise false'
  prefs: []
  type: TYPE_NORMAL
- en: 'not in: Results to true if element is not a member of the sequence, otherwise
    false'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/list4_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: a is not present in the given list
  prefs: []
  type: TYPE_NORMAL
- en: b is not present in the given list
  prefs: []
  type: TYPE_NORMAL
- en: '[4.7.7 Identity Operators](contents.xhtml#rsec4_7_7)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These operators are used to compare two memory locations, i.e., to check whether
    two values are located in same part of memory. There are two identical operators
    in Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'is: Returns true if operands are identical'
  prefs: []
  type: TYPE_NORMAL
- en: 'is not: Returns true if operands are not identical'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/list4_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: a and b have same identity
  prefs: []
  type: TYPE_NORMAL
- en: '[4.8 Input and Output in Python](contents.xhtml#rsec4_8)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The built-in input() function is used to take user input from the keyboard.
    The parameters inside parentheses prompt for the keyboard input. The input function
    automatically identifies whether it is a string, number, or list that is entered
    by the user. However when an input is entered, first it is converted to a string.
    Even an integer value is converted integer using typecasting.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/list4_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Suppose the user has entered abc as name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Output: Hello abc'
  prefs: []
  type: TYPE_NORMAL
- en: The way to produce output is by using print() function by passing no or more
    expression separated by a comma. Print with no parameters, i.e., print() is to
    advance to next line. By default, Python print() function ends with a new line,
    i.e., print() function will go to next line automatically.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/list4_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: one
  prefs: []
  type: TYPE_NORMAL
- en: two
  prefs: []
  type: TYPE_NORMAL
- en: '[4.9 List](contents.xhtml#rsec4_9)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Lists are a powerful feature of Python. They are the same as arrays. The list
    is a data type used to declare a sequence. Lists are declared with comma separated
    items in a square brackets. To access list items, index number is used. Notably,
    list might have items of different types. A list can have strings, integers, as
    well as objects. Also, lists can be altered even after declaration.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/list4_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Output: Banana'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/list4_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: 22, ‘Banana’, 5, 6
  prefs: []
  type: TYPE_NORMAL
- en: 22, ‘Banana’, 5
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: '**Note:** Tuple is same as list with a difference that tuples are immutable,
    i.e., after declaration they can''t be changed.'
  prefs: []
  type: TYPE_NORMAL
- en: '[4.10 Dictionary](contents.xhtml#rsec4_10)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python dictionaries has keys and values and is written with curly brackets.
    However, keys should be unique within a dictionary while values can be same. To
    access any item, use keys name inside square brackets.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/list4_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Output: 10'
  prefs: []
  type: TYPE_NORMAL
- en: '[4.11 Python Conditions and if-else](contents.xhtml#rsec4_11)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python if-else statements are used with logical conditions, such as- equal,
    not equal, less than equal to, greater than equal to, greater than, and less than.
    If statement is specified using the if keyword.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/list4_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Output: value of b is greater than a'
  prefs: []
  type: TYPE_NORMAL
- en: '**Key point** Python uses indentation to define scope'
  prefs: []
  type: TYPE_NORMAL
- en: Further, elif keyword is used to check if previous condition is not true then
    try with this condition and else executes if any of the preceding conditions get
    false. greater than equal to, greater than, and less than. Elif statement is specified
    using elif keyword.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/list4_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Output: value of b is greater than a'
  prefs: []
  type: TYPE_NORMAL
- en: '[4.12 Loops](contents.xhtml#rsec4_12)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Generally, statements of any programming language are executed sequentially.
    However, there may be a situation when there is need to execute different paths.
    A block of loop allows to execute one or more than one statement multiple times.
    Python supports two loop commands:'
  prefs: []
  type: TYPE_NORMAL
- en: While loop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For loop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**While loop**: While loop is used to execute a statement or a block of statement
    until given conditions are satisfied. After the statements get false, the very
    first statement after while gets executed.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/list4_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: Goodbye
  prefs: []
  type: TYPE_NORMAL
- en: While can be used with else statement as well
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/list4_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: Goodbye
  prefs: []
  type: TYPE_NORMAL
- en: '**For loop**: In Python the for loop is used for sequential traversal, e.g.,
    a list or an array.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/list4_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: apple
  prefs: []
  type: TYPE_NORMAL
- en: mango
  prefs: []
  type: TYPE_NORMAL
- en: banana
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/list4_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: 0,1,2,3,4
  prefs: []
  type: TYPE_NORMAL
- en: '[4.13 Functions in Python](contents.xhtml#rsec4_13)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A function is a block of statements that take some input, perform some computation,
    and produces output. Basically, functions are used to ease repeatedly done tasks
    together. Functions are executed when called. There are some build-in functions
    in Python such as- print() and also one can create functions using def keyword.
    To call a function, use the name of that function followed by a parenthesis.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/list4_25.jpg)![](../images/list4_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: Odd
  prefs: []
  type: TYPE_NORMAL
- en: Even
  prefs: []
  type: TYPE_NORMAL
- en: '[4.14 Classes and Objects in Python](contents.xhtml#rsec4_14)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As previously discussed, Python is an object-oriented language. A class is similar
    to an object constructor or like a blueprint for creating objects while object
    is a copy of class with actual values. Classes ease bundling of data and functionality
    together. Each class holds its own data members and member function which can
    be accessed using objects. Nevertheless, a class can have many objects. Attributes
    of a class are always public and are accessed using the dot (.) operator. To create
    a class keyword class is used.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/list4_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'output: 5'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/list4_28a.jpg)![](../images/list4_28b.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: animal
  prefs: []
  type: TYPE_NORMAL
- en: I am a animal
  prefs: []
  type: TYPE_NORMAL
- en: I am a dog
  prefs: []
  type: TYPE_NORMAL
- en: To create real-life applications, we need to understand a special function called
    init() which is an initialization method to create a new instance of the class.
    In particular, the init() method is used to assign values to object properties
    when the object is created.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/list4_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'output:'
  prefs: []
  type: TYPE_NORMAL
- en: John
  prefs: []
  type: TYPE_NORMAL
- en: '36'
  prefs: []
  type: TYPE_NORMAL
- en: '[4.15 File Handling in Python](contents.xhtml#rsec4_15)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A file has a location on disk with some stored information. Like Java and C++,
    Python also supports file handling and enables users to handle files by reading
    and writing them. Each line of code in the file includes a sequence of characters.
    Also, each line ends with a special terminator called end of line (EOL) which
    tells the interpreter that a new line has begun. Most of the file manipulations
    are done using a file object.
  prefs: []
  type: TYPE_NORMAL
- en: '[4.15.1 open() function](contents.xhtml#rsec4_15_1)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Clearly before reading or writing a file, one must open it first. To open a
    file in order to read or write, open() function is used. The open() function creates
    a file object and takes two arguments, i.e., file name and mode. Syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '*open(filename; mode)*'
  prefs: []
  type: TYPE_NORMAL
- en: 'mode field tells how the file can be opened. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'r: Opens a file for reading only'
  prefs: []
  type: TYPE_NORMAL
- en: 'rb: Opens a file for read-only purpose in binary format'
  prefs: []
  type: TYPE_NORMAL
- en: 'w: opens a file for writing only'
  prefs: []
  type: TYPE_NORMAL
- en: 'r+: Opens a file for both reading and writing in binary format'
  prefs: []
  type: TYPE_NORMAL
- en: 'wb: Opens a file for write only purpose in binary format'
  prefs: []
  type: TYPE_NORMAL
- en: 'a: Opens file for append'
  prefs: []
  type: TYPE_NORMAL
- en: 'a+: Opens a file for both appending and reading'
  prefs: []
  type: TYPE_NORMAL
- en: If the file with specified name does not exist, it will throw an error of FileNotFoundError.
  prefs: []
  type: TYPE_NORMAL
- en: '[4.15.2 close() function](contents.xhtml#rsec4_15_2)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: close() method closes the file object and refrains any further action on that
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: fileObject.close()
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/list4_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'output:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Name of the file: foo.txt'
  prefs: []
  type: TYPE_NORMAL
- en: '[4.15.3 read() function](contents.xhtml#rsec4_15_3)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This function reads a string from an open file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '*fileObject:read([count])*'
  prefs: []
  type: TYPE_NORMAL
- en: The count parameter specifies the number of bytes to be read from the specified
    file. If the count parameter is missing, the file is read until the end of the
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/list4_31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'output:'
  prefs: []
  type: TYPE_NORMAL
- en: The first 10 characters from the file named foo.txt.
  prefs: []
  type: TYPE_NORMAL
- en: '[4.16 write() function](contents.xhtml#rsec4_16)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This function allows user to write strings to an open file. Notably, write function
    does not add implicitly a newline character, i.e., to end of string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '*fileObject:write(string)*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/list4_32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'output:'
  prefs: []
  type: TYPE_NORMAL
- en: Python is a high level language
  prefs: []
  type: TYPE_NORMAL
- en: Python follows OOPS concepts
  prefs: []
  type: TYPE_NORMAL
- en: Activity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Multiple Choice Questions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: How do you insert comments in Python code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: \ *This is a comment* \
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '#This is a comment'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: “This is a comment”
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: None of these
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which one is NOT a legal variable name?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: abc
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 10abc
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: _abc
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: abc_abc
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the value of the following Python Expression?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '9.0'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '9'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '4.0'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '4'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the output of the following code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: x = 100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: y = 50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: print(x and y)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'True'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'False'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '100'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '50'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a correct syntax to output “hello world” in Python?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: print(“hello world”)
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: echo(“hello word”)
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: put(“hello word”)
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: None of these
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the correct file extension for Python files?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: .py
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: .python
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: .pyt
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: None of these
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What will be the output of the following code ?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: print type(type(int))
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: type ‘int’
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: type ‘type’
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: error
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '0'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Suppose listA is [31, 41, 5, 20, 5, 125, 1, 3], what is list1 after listA.pop(1)?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 31, 41, 5, 20, 5, 125, 1, 3
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 31, 41, 5, 20, 5, 125, 1
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 31, 41, 5, 20, 5, 125, 1, 3, 3
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: None of these
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the output of the following program?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: j = 0
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'while i ≤ 5:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: print j
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: j++
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: print j+1
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 0 2 1 3 2 4
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Error
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 5 4 3 2 1
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: None of these
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What does <math alttext="" display="inline"><mo>¬</mo><mo>¬</mo><mo>¬</mo><mo>¬</mo><mo>¬</mo><mo>¬</mo></math>
    5 evaluate to?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '+5'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '-5'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '10'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '11'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 1\. b  2\. b  3\. a  4\. d  5\. d  6\. a  7\. b  8\. b  9\. b (there is no ++
    operator in Python)  10\. a
  prefs: []
  type: TYPE_NORMAL
- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '[5](contents.xhtml#rchapter5)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Cryptography Primitives](contents.xhtml#rchapter5)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '[5.1 Introduction](contents.xhtml#rsec5_1)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Confidentiality, integrity, availability also referred to as CIA triad, is the
    model developed to define policies for achieving information security (Refer [Fig.
    5.1](07chap_05.xhtml#fig5_1)). Along with this non-repudiation and authentication
    are the other security attributes to be achieved by a Peer-to-peer (P2P) network.
  prefs: []
  type: TYPE_NORMAL
- en: 'Confidentiality: Confidentiality signifies that information, data, and resources
    are protected from any unauthorized parties. Data encryption, and passwords are
    the common method of ensuring confidentiality.tcolorbox'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Key Points** Confidentiality is similar to the word privacy; however, they
    are not interchangeable. In fact, confidentiality is an extension of privacy that
    pertains to identifiable data.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Integrity: This attribute signifies the protection of information from unauthorized
    alteration. Integrity ensures accuracy and completeness of data. Access control
    mechanism, checksum, and hashing are some measures to ensure the integrity of
    data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Availability: This attribute ensures access to information when needed by authorized
    parties. If a server/system remains available preventing service disruption and
    uninterrupted access, this signifies high availability. Disruption of service
    even for a short time can cause loss of revenue, customer disappointment, and
    organization repudiation damage. Among all availability attacks, DoS is the most
    frequently used by hackers. Proxy servers, firewalls, and routers are the countermeasures
    to ensure the availability of data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Non-repudiation: This attribute ensures that the sender of the data can''t
    later deny having sent the data and recipients can''t deny having received the
    data. In legal terms, repudiation signifies denial of something that is true.
    Digital signatures, timestamps, hash functions are some of the ways to obtain
    non-repudiation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Authentication: It is an act of identifying an individual. However, authentication
    does not claim about the access rights of the individual. In particular, authentication
    confirms the user''s identity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 5.1](../images/fig5_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 5.1**'
  prefs: []
  type: TYPE_NORMAL
- en: CIA triad of information security.
  prefs: []
  type: TYPE_NORMAL
- en: Notably, cryptography plays a very important role in ensuring the attainment
    of these above-mentioned security attributes. Next, we will discuss the basic
    cryptographic primitives. We will start by discussing the details of cryptographic
    hash functions followed by discussing the concept of digital signatures.
  prefs: []
  type: TYPE_NORMAL
- en: '[5.2 Encryption/Decryption Process](contents.xhtml#rsec5_2)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[5.2.1 Encryption](contents.xhtml#rsec5_2_1)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Encryption is the process of transforming original data into an unrecognisable
    form. Data is usually encrypted to save it from stealing. Encryption is performed
    by the sender.
  prefs: []
  type: TYPE_NORMAL
- en: '[5.2.2 Decryption](contents.xhtml#rsec5_2_2)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In contrast to encryption, decryption is the process of converting cipher text
    back to plain text. Decryption is done at the receiving side.
  prefs: []
  type: TYPE_NORMAL
- en: '[5.2.3 Symmetric key encryption](contents.xhtml#rsec5_2_3)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This type of encryption uses the same cryptographic key for both encrypting
    plaintext and decrypting ciphertext.
  prefs: []
  type: TYPE_NORMAL
- en: '[5.2.4 Asymmetric key encryption](contents.xhtml#rsec5_2_4)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This encryption process involves 2 pairs of keys. Here, both sender and receiver
    have a pair of public and private keys. The public key is used to encrypt plaintext
    whereas the private key is used for decryption purpose. To accomplish many cryptographic
    tasks public and private keys are used.
  prefs: []
  type: TYPE_NORMAL
- en: '[5.2.5 Public key](contents.xhtml#rsec5_2_5)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The public key is published for all other users to see. Public keys are generated
    using typical asymmetric algorithm to match them against the associated private
    key. The most popular algorithm used for creating public key are: RSA, ECC, and
    digital signature application (DSA). These mentioned algorithms are based on a
    heavy computation method to create random numeric combinations of different lengths
    to prevent them against brute force attack. The length of the key depicts strength
    of protection. The large key size assures more cryptographic security to prevent
    hackers from preventing them.'
  prefs: []
  type: TYPE_NORMAL
- en: '[5.2.6 Private key](contents.xhtml#rsec5_2_6)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In contrast to public key, private key is a secret key that is only known to
    the owner of the key. Private keys are created using same algorithms that create
    public key.tcolorbox
  prefs: []
  type: TYPE_NORMAL
- en: '**Key point** The private key is used for decryption, digitally signing, and
    authentication whereas a public key is used for encryption, verification of digital
    signatures, and authentication.'
  prefs: []
  type: TYPE_NORMAL
- en: '[5.3 Cryptographic Hash Functions](contents.xhtml#rsec5_3)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A cryptographic hash function <math alttext="" display="inline"><mrow><mo stretchy="false">(</mo><mi>H</mi><mo
    stretchy="false">)</mo></mrow></math> takes an variable length input or message
    <math alttext="" display="inline"><mrow><mo stretchy="false">(</mo><mi>M</mi><mo
    stretchy="false">)</mo></mrow></math> and produces a fixed size output called
    hash values or message digest <math alttext="" display="inline"><mrow><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">)</mo></mrow></math>, i.e. as represented in [Fig. 5.2](07chap_05.xhtml#fig5_2)
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="" display="block"><mrow><mtable columnalign="left"><mtr columnalign="left"><mtd
    columnalign="left"><mrow><mi>h</mi><mo>=</mo><mi>H</mi><mo stretchy="false">(</mo><mi>M</mi><mo
    stretchy="false">)</mo></mrow></mtd></mtr></mtable></mrow></math>(5.1)
  prefs: []
  type: TYPE_NORMAL
- en: Generally, the size of message digest is smaller than the actual input data.
    Therefore, the hash function is sometimes referred to as compression function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2](../images/fig5_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 5.2**'
  prefs: []
  type: TYPE_NORMAL
- en: Block diagram of cryptographic hash function.
  prefs: []
  type: TYPE_NORMAL
- en: Key Points
  prefs: []
  type: TYPE_NORMAL
- en: A hash function follows the many-to-one property and thus faces collision.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In blockchain, the size of message digest is 256 bits.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hash functions are efficiently computable as this calculations as these calculation
    does not need a significant amount of resources.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A good hash function produces evenly distributed output.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even a single bit change in M will change the complete hash code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[5.3.1 Typical properties of a hash function](contents.xhtml#rsec5_3_1)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It should be completely difficult to reverse a hash function, i.e., for a given
    hash value *h[1]*, it should be hard process to find input *M[1]* that exactly
    hashes to *h[1]*. This property is called irreversibility or pre-image resistance.
    Also, this type of hash function is called one-way function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a given input and its corresponding hash, it should be computationally difficult
    to find a different input having same hash, i.e., for a input *M[1]* having hash
    value *h[1]*, it should be hard to find any other input *M[2]* such that <math
    alttext="" display="inline"><mrow><mi>H</mi><mo stretchy="false">(</mo><msub><mi>M</mi><mn>1</mn></msub><mo
    stretchy="false">)</mo><mo>=</mo><mi>H</mi><mo stretchy="false">(</mo><msub><mi>M</mi><mn>2</mn></msub><mo
    stretchy="false">)</mo></mrow></math>. This property of hash functions is called
    second-image resistance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another important property of hash functions is known as collision free property
    which states that if two messages are different, then there message digest will
    also be different, i.e., if two messages *M[1]*, *M[2]* are not equal (*M1 <math
    alttext="" display="inline"><mo>≠</mo></math> M2*), then <math alttext="" display="inline"><mrow><mi>H</mi><mo
    stretchy="false">(</mo><msub><mi>M</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>≠</mo><mi>H</mi><mo
    stretchy="false">(</mo><msub><mi>M</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow></math>.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Given two messages *M[1]*, *M[2]*, and a hash function *h*, it is difficult
    to find a value *k* such that <math alttext="" display="inline"><mrow><msub><mi>M</mi><mn>2</mn></msub><mo>=</mo><mi>h</mi><mo
    stretchy="false">(</mo><msub><mi>M</mi><mn>1</mn></msub><mi mathvariant="normal">‖</mi><mi>k</mi><mo
    stretchy="false">)</mo></mrow></math>. This property of hash functions is called
    puzzle friendliness.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[5.3.2 Requirements of hash function:](contents.xhtml#rsec5_3_2)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**One way:** Once hash is calculated it can''t be used to restore the original
    document. For example, like a human being fingerprint, one can''t retrieve the
    looks of a person from human fingerprint.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deterministic:** It states that if two similar documents are passed through
    a hash algorithm, it should always generate the same hash.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Avalanche effect:** It states that even changing one bit in the document,
    hash of the changed document should be significantly different from hash of the
    original document.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Must withstand collision:** It implies that the hash function should have
    collision resistance property.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[5.3.3 Applications of cryptographic hash functions](contents.xhtml#rsec5_3_3)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Password storage: Whenever a user creates an account with user name, ID, and
    password, the ID provider does not store the password. Instead, the provider pass
    the password from a hashing algorithm and only stores hash of the password. Every
    time user attempts to log-in, the provider hashes the password entered by the
    user and compares it against the saved hash. The provider has a password file
    that has table of pairs in form [User ID1*h(P1*)] for a given user id (ID1) and
    password (P1). If the two hashes match, only then authorization is provided to
    the account otherwise not. The whole process has been depicted in [Fig. 5.3](07chap_05.xhtml#fig5_3).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 5.3](../images/fig5_3.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**FIGURE 5.3**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Password storage using hash functions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Data integrity check: One of the very popular applications of hash function
    is data integrity check. This way, hash functions can assure correctness of the
    data, i.e., user can detect any modifications, insertions, and deletions made
    to the original file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Case 1:**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The message <math alttext="" display="inline"><mrow><mo stretchy="false">(</mo><mi>M</mi><mo
    stretchy="false">)</mo></mrow></math> along with computed hash value of *M* is
    encrypted with symmetric encryption. Encryption ensures confidentiality of the
    message. To check integrity of the message, First, the decryption is applied to
    the received encrypted block and the message from the block is then extracted.
    Next, apply the same hash algorithm to the message M and the computed hash value
    is matched against the received hash value. The whole process has been shown in
    [Fig. 5.4](07chap_05.xhtml#fig5_4).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 5.4](../images/fig5_4.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**FIGURE 5.4**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Data integrity check with message encryption.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Case 2:**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In some cases, only the hash code is encrypted in order to reduce the burden
    for applications that don't demand confidentiality. To check the integrity of
    the message, decrypt the hash received with secret key and compute hash digest
    from the message and compare it with the received hash digest from the source.
    The whole process has been shown in [Fig. 5.5](07chap_05.xhtml#fig5_5).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 5.5](../images/fig5_5.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**FIGURE 5.5**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Data integrity check without message encryption.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[5.3.4 MD5 message-digest algorithm](contents.xhtml#rsec5_3_4)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Message-Digest algorithm 5 (MD5) is an extension of Message-Digest algorithm
    4 (MD4) and is developed by Ron Rivest in 1991\. However, MD5 is a little slower
    than MD4 but assures better security over MD4\. In particular, it is used to verify
    the integrity of the data. Also, it is used as DSA by compressing a large file
    in a secure way before encrypting the file with private key. This hashing algorithm
    takes input of arbitrary length and produces a 128-bit fingerprint as output.
  prefs: []
  type: TYPE_NORMAL
- en: 'The fundamentals of MD5 are based on Merkle Damgard schema. This algorithm
    process data in 512-bit block and each block is broken into 16 blocks, each of
    32 bit. The stepwise working of MD5 to produce 128-bit output is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Append padding bits:** Padding implies adding some extra bits to original
    message. Here, message is padded such that total bit length is 64 less than exact
    multiple of 512\. In order to pad the first bit is 1 and rest bits are 0\. For
    example, for a message of 1000 bits, 472 bits are padded (1000 + 472 = 1472 which
    is 64 bit less than multiple of 512.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Append length:** After padding, insert 64 bit at the end by calculating length
    of original message mod 264\. Hence, the resulting message is multiple of 512
    bits.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dividing the message:** Divide the resulting message in 512 bit block.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Initialize MD buffer:** A four word buffer is initialized next. The four
    buffer namely (A, B, C, D) are 32-bit registers and its values are predefined.
    Notably, the final output in these buffer only.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Process message in 16 word block:** Each block of 512 bit is processed in
    4 rounds and for each round four functions F, G, H, I are used. Further, each
    round consists of 16 steps using some constants. Hence, a total of 64 operations
    are performed for each 512 bit and the output from this block is fed to the next
    block as value of A, B, C, D.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[5.3.5 SHA-256](contents.xhtml#rsec5_3_5)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Blockchain bitcoin mining makes use of a special type of hash function called
    SHA-256 and this hash function generates 256-bit message digest. SHA stands for
    secure hashing algorithm. SHA-256 also operates similar to MD4, MD5 as SHA-1\.
    Computation of hash function begins by first preprocessing the message. For preprocessing:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the message is padded so that total message size becomes multiple of
    512 bits. For this follow:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lets assume that message has length *l* in bits and *l*mod512 ≠ 0.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Append a bit with value 1 at the end of the message.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, append k zero bits such that l+1+k ≡ 448mod512.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: After this append a 64-bit block having value *l* written in binary. This length
    is appended in order to avoid trivial collisions. To extract original message
    read last 64 bit (for calculating the length of message) and next start fetching
    bits from left to right till observed length.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The resultant length of the message after padding should be multiple of 512
    bits.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, the given message is ‘abc’.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It has length 24 (8*3).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: First it is padded with a one at the end of message.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, 448-(24+1) zeros are appended, i.e., 423 zeros.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, 64 bit block having 24 written in binary is appended which results
    in:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <math alttext="" display="block"><mrow><mn>011000101100010011000111</mn><munder><munder><mrow><mn>00.....0</mn></mrow><mo
    stretchy="true">︸</mo></munder><mrow><mn>423</mn><mtext>times</mtext></mrow></munder><munder><munder><mrow><mn>00.....011000</mn></mrow><mo
    stretchy="true">︸</mo></munder><mrow><mn>64</mn><mtext>bit</mtext></mrow></munder><mo>.</mo></mrow></math>
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, result has length 512 bits.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, parse the original message *M*, into *N* blocks of 512 bit each, i.e.,
    M1, M2,………., MN.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After this, each 512-bit block is divided into 16 sub blocks <math alttext=""
    display="inline"><mrow><msubsup><mi>M</mi><mn>0</mn><mi>i</mi></msubsup></mrow></math>,
    <math alttext="" display="inline"><mrow><msubsup><mi>M</mi><mn>1</mn><mi>i</mi></msubsup></mrow></math>,…….,
    <math alttext="" display="inline"><mrow><msubsup><mi>M</mi><mrow><mn>15</mn></mrow><mi>i</mi></msubsup></mrow></math>
    with each having length of 32 bit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each message block is processed one at a time. To process each block initialize
    with a fixed hash value, h0 of 256 bit also called the initialization vector (IV).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, sequentially compute:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <math alttext="" display="inline"><mrow><msup><mi>H</mi><mi>i</mi></msup><mo>=</mo><msup><mi>h</mi><mrow><mo
    stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msup><mo>+</mo><msubsup><mi>C</mi><mi>M</mi><mi>i</mi></msubsup><mo
    stretchy="false">(</mo><msup><mi>H</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo
    stretchy="false">)</mo></mrow></msup><mo stretchy="false">)</mo></mrow></math>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: where, C is compression function and + is addition modulo 2^(32).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[5.4 Digital Signatures](contents.xhtml#rsec5_4)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The digital signature is another important fundamental behind secured blockchain
    architecture. It is a cryptographic method to validate the authenticity and integrity
    of data. Along with this, digital signatures prevent non-repudiation, i.e., the
    sender can't deny for the origin of the document. Digital signatures work similar
    to the physical signatures; however, they are electronic signatures. Nevertheless,
    the signing authority can only sign the document and anyone having a valid key
    can verify the signatures. Also, the signatures of one document cannot be transferred
    from one document to another.
  prefs: []
  type: TYPE_NORMAL
- en: Digital signatures are realized with the concept of asymmetric key cryptography
    (Public-key cryptography). Asymmetric key cryptography uses two different keys,
    i.e., a public key and a private key. The public key is known to the user only
    whereas the private key is known to everyone in the universe. For preserving the
    confidentiality of data, the data to be transferred is encrypted using the public
    key of the receiver whereas the private key is used at the destination node to
    decrypt the message.
  prefs: []
  type: TYPE_NORMAL
- en: '[5.4.1 Model of digital signature](contents.xhtml#rsec5_4_1)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To generate digital signatures, the message is signed using the private key
    of the sender and at the destination side, signatures are verified using the public
    key of the sender. However, by integrating the concept of cryptographic hash with
    digital signatures, the size of digital signatures can be reduced. So, rather
    than signing the original message, the message digest is signed. The following
    steps are taken in generating the digital signatures:'
  prefs: []
  type: TYPE_NORMAL
- en: First, hash the message (*M*) to obtain message digest *h(M)*. Next, the generated
    hash is signed using the private key of the sender which results in digital signatures.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, the message and the digital signature are transferred over the channel.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Receiver after receiving the particular digital signatures, decrypt it using
    the public key of the sender (This assures the **authenticity** of the sender).
    After applying the decryption algorithm, the receiver will get the message digest
    *h(M)*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simultaneously, from the original message received receiver, will compute the
    hash of it. Let's call this value *h’(M)*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If *h(M)*=*h’(M)*, the **integrity** of the original document is preserved.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As it is assumed that only signer of the document knows the private key, so
    no other can generate the signature of the signer. Hence, it ensures **non-repudiation**
    attribute.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The whole process of generating hash function has been depicted in [Fig. 5.6](07chap_05.xhtml#fig5_6).
    Therefore, by applying the hash function, the size of the signature can be reduced.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6](../images/fig5_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 5.6**'
  prefs: []
  type: TYPE_NORMAL
- en: Digital signatures.
  prefs: []
  type: TYPE_NORMAL
- en: Key points
  prefs: []
  type: TYPE_NORMAL
- en: A cryptographic key should be prevented from being guessed by others. However,
    it is assumed that the cryptographic algorithm is known to everyone.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The key should have sufficient length as a key with long length is difficult
    to guess as compared to short length key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The key should be truly randomly generated with sufficient entropy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[5.5 Zero-Knowledge Proof](contents.xhtml#rsec5_5)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another concept that is associated with blockchain is zero-knowledge proof.
    It is a cryptographic method to prove to the verifier that prover knows a value
    without actually revealing any data except revealing the fact that prover knows
    the value. By simply, generating the final output, the prover is supposed to prove
    that they can compute something without telling the computational process whereas
    the verifier only knows the output.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, A wants to prove B that he/she knows the key without disclosing
    secret key to B, and B verifies that A is actually having the key. Hence, they
    have the capability to revolutionize the way of data handling, collection, and
    the way data is transacted with. Zero-knowledge proof has 3 important properties:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Completeness: If the fact is true, the prover should convince the verifier
    for this fact and zero knowledge proof should return true.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Soundness: If the fact/statement is false, the prover can''t convince the verifier
    that prover''s statement is true.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Zero-knowledge/Privacy: If the information provided by prover is true, no verifier
    learns any other information expect the fact that information is true. In other
    words, the provider information should not reveal anything else to the verifier.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To better understand zero knowledge proof, let's take the popular and classic
    example of zero knowledge proof that is of **two balls and colour-blind friend**
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose A has two identical balls having different colours (say one red and
    one green) and your friend B is colour blind which means B can''t differentiate
    between the balls based on their colour. However, A has to prove to B that two
    balls are of different colours. Nevertheless, A doesn''t want to reveal which
    is red and which is green. This is how proof system for this problem will work:'
  prefs: []
  type: TYPE_NORMAL
- en: A will give both balls to B and puts both balls behind his back.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: B then takes out one of the two balls from behind his/her back and shows it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: B then puts back the ball behind his/her back again and then reveal just one
    of the two balls, simply by picking one of the two balls at random with equal
    chances.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, B asks A ”Did I switch the ball?”.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Third and fourth steps are repeated till B assures that there are two different
    colored balls. Obviously, by balls color A can certainly tell whether or not B
    switched them. Moreover, A could guess right with probability not higher than
    50% that whether the ball his switched or not if balls are having same color and
    therefore indistinguishable. If A and B repeats this process multiple times A
    will be caught if he/she lies.
  prefs: []
  type: TYPE_NORMAL
- en: Clearly, the above proof system is zero knowledge as B will never learn which
    is green and which is red ball.
  prefs: []
  type: TYPE_NORMAL
- en: 'Over and above, zero-knowledge proof has two variants: interactive and non-interactive
    zero-knowledge proof. In interactive proofs, the prover and the verifier exchange
    more than one message to prove or verify the information. It demands verifier
    to constantly ask questions about the knowledge the prover possesses. Unfortunately,
    the interactive zero knowledge proof has limited transferability. In contrast,
    non-interactive proof system demands no interaction between prover and verifier
    except a common reference string between both parties.'
  prefs: []
  type: TYPE_NORMAL
- en: Keypoint
  prefs: []
  type: TYPE_NORMAL
- en: '**Zero knowledge proof application in blockchain:** Both of the popular blockchain
    use cases, i.e., Bitcoin and Ethereum are based on public addresses to depict
    the true identity of the user which maintains anonymity in the network. Notably,
    due to the distributed nature of the blockchain, interactive zero knowledge proof
    is not an efficient solution. Moreover, a real world use case of zero knowledge
    proof is Zcash that enables native transactions to be fully encrypted while being
    verified by network consensus rule and Zcash is a non-interactive zero knowledge
    proof system.'
  prefs: []
  type: TYPE_NORMAL
- en: '[5.6 Hash Tables](contents.xhtml#rsec5_6)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is a popular data structure that supports fast insertion and search operation
    irrespective of the size of the data. It is basically a method to identify a specific
    object from a group of similar objects. In particular, hash tables (also called
    hash map) store data in a format of array and each data value is associated with
    a unique index value. Hash tables make use of hash function to generate an index,
    i.e., location where a data element is to be inserted. The information in data
    structure has two main components, i.e., a unique key and a value. For instance,
    a key could be unique ID (key doesn't have to be an integer every time) and value
    is the phone number. The hash function will decide where to map the key and where
    to store corresponding value with it. The efficiency of mapping is dependent on
    the efficiency of hash function. Basically, the set from which we use input element
    is much larger than capacity of the hash table, so that collision can be avoided.
    Clearly, if the number of items in the table grows, collision rises as well. To
    measure how full the hash table is, the concept of load factor (*α*) is used which
    is defined as the fraction of number of used keys (*n*) and the total capacity
    of the table (*m*).
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="" display="block"><mrow><mtable columnalign="left"><mtr columnalign="left"><mtd
    columnalign="left"><mrow><mi>α</mi><mo>=</mo><mfrac><mi>n</mi><mi>m</mi></mfrac></mrow></mtd></mtr></mtable></mrow></math>(5.2)
  prefs: []
  type: TYPE_NORMAL
- en: Notably, *n* can't exceed the total capacity of the table. If *α* approaches
    to maximum value, the chances of collision rises significantly.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a linked list insertion operation is efficient whereas lookups still consume
    linear time. Additionally, in a sorted array lookup are efficient but insertions
    are insufficient. Notably, for *n* elements, linked list can search in <math alttext=""
    display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></math>
    whereas binary search takes <math alttext="" display="inline"><mrow><mi>O</mi><mo
    stretchy="false">(</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo
    stretchy="false">)</mo></mrow></math> and array consumes <math alttext="" display="inline"><mrow><mi>O</mi><mo
    stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></math> time
    for searching. In contrast to this, hash table allows insertion, deletion and
    searching very fast, i.e., <math alttext="" display="inline"><mrow><mi>O</mi><mo
    stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></math> time
    in average case (Refer to [Table 5.1](#tab5_1)). Lets take an example of hash
    table data structure as shown in [Fig. 5.7](07chap_05.xhtml#fig5_7) with hash
    function: <math alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo><mo>=</mo><mi>x</mi><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn></mrow></math>
    where *x* is the key. Suppose items are in (key, value) format and items are (1,999),
    (2, 9876), (45, 5434), (90, 9877). Therefore, the hash table organizes data so
    that any data can be looked up quickly for a given key. Nevertheless, there may
    be a case hen two or more data items collide and hashes to the same index. This
    is called the problem of collisions. For example, if we have to insert an item
    (55, 7767), this insertion will result in collision as at index 5 already there
    is an item. A function is referred to as good hash function that avoids collision.
    Collision resolution techniques are divided into two main parts, i.e., closed
    addressing and open addressing. In order to avoid the collision, closed addressing
    uses additional data structures whereas open addressing hashing stores all data
    inside the table. More formally, in case of collision resolution with open addressing,
    cells *h0(x), h1(x),……., hm-1(x)* are attempted in succession for the eq.,'
  prefs: []
  type: TYPE_NORMAL
- en: '**TABLE 5.1**'
  prefs: []
  type: TYPE_NORMAL
- en: Average and worst case complexity for hash tables.
  prefs: []
  type: TYPE_NORMAL
- en: '|  | Average complexity | Worst case complexity |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Space | <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo
    stretchy="false">)</mo></mrow></math> | <math alttext="" display="inline"><mrow><mi>O</mi><mo
    stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></math> |'
  prefs: []
  type: TYPE_TB
- en: '| Insertion | <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo
    stretchy="false">)</mo></mrow></math> | <math alttext="" display="inline"><mrow><mi>O</mi><mo
    stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></math> |'
  prefs: []
  type: TYPE_TB
- en: '| Deletion | <math alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo
    stretchy="false">)</mo></mrow></math> | <math alttext="" display="inline"><mrow><mi>O</mi><mo
    stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></math> |'
  prefs: []
  type: TYPE_TB
- en: '![Figure 5.7](../images/fig5_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 5.7**'
  prefs: []
  type: TYPE_NORMAL
- en: Example of hash table.
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="" display="block"><mrow><mtable columnalign="left"><mtr columnalign="left"><mtd
    columnalign="left"><mrow><msub><mi>h</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo><mo>+</mo><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo
    stretchy="false">)</mo><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></mtd></mtr></mtable></mrow></math>(5.3)
  prefs: []
  type: TYPE_NORMAL
- en: where, *f(0)=0* the function *f* is called collision resolution strategy, <math
    alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo></mrow></math> = primary hash function, *x* is the key
    and *m* is the table size. Next, we will discuss the popular collision resolution
    techniques. The categorization of collision resolution techniques has been represented
    in [Fig. 5.8](07chap_05.xhtml#fig5_8)
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.8](../images/fig5_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 5.8**'
  prefs: []
  type: TYPE_NORMAL
- en: Categorization of collision resolution techniques.
  prefs: []
  type: TYPE_NORMAL
- en: '[5.6.1 Separate chaining](contents.xhtml#rsec5_6_1)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One possible way to avoid collision is simply to store data with same index
    into a linked list at the corresponding index of the array. This method is referred
    to as separate chaining. Here, each array slot holds a pointer to linked list
    having values for all keys that hashes to same hash index as shown in [Fig. 5.9](07chap_05.xhtml#fig5_9).
  prefs: []
  type: TYPE_NORMAL
- en: '**Lookup:** Of course, this solution will end up in linear time, i.e., <math
    alttext="" display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo
    stretchy="false">)</mo></mrow></math> for lookup in worst case. As in worst case,
    all the keys might have same index of the hash table so, in order to perform sequential
    search, time requirement is <math alttext="" display="inline"><mrow><mi>O</mi><mo
    stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></math>. Also,
    cache performance for this method is not good. Although with this method is easy
    to implement and hash table never gets fills.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Deletion:** To delete, first keys need to be searched and then deleted. As
    worst case time complexity for searching is <math alttext="" display="inline"><mrow><mi>O</mi><mo
    stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></math>, so
    for deletion time taken is <math alttext="" display="inline"><mrow><mi>O</mi><mo
    stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></math>.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.9](../images/fig5_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 5.9**'
  prefs: []
  type: TYPE_NORMAL
- en: Each array slot containing pointer to linked list.
  prefs: []
  type: TYPE_NORMAL
- en: '[5.6.2 Linear probing](contents.xhtml#rsec5_6_2)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Linear probing is a popular method to handle collision. Probing simply implies
    finding the next empty cell where the key is to be placed in case of collision.
    This method comes under collision resolution with open addressing. To insert in
    case of collisions, the immediate next cells are tried until an empty cell is
    found. Therefore, the size of table should be equal to or greater than the total
    number of keys. Formally, for linear probing, *f* is a linear function and mostly
    it is <math alttext="" display="inline"><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo
    stretchy="false">)</mo><mo>=</mo><mi>i</mi></mrow></math> in the equation 5.3,
    i.e., <math alttext="" display="inline"><mrow><msub><mi>h</mi><mi>i</mi></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mi>i</mi><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    Clearly, the worst case complexity for searching is <math alttext="" display="inline"><mrow><mi>O</mi><mo
    stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow></math>.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, linear probing faces the problem of clustering, i.e., if multiple
    consecutive items form a group then it will take a lot of time to find an empty
    slot for insertion or in case of searching an item. Let''s understand linear probing
    with an example, Say 3, 17, 14, 6, 21, 13, 7, 22 are the keys to be inserted in
    series and <math alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>2</mn><mi>x</mi><mo>+</mo><mn>3</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn></mrow></math>
    is the hash function for key *x*. Refer [Fig. 5.10](07chap_05.xhtml#fig5_10) Hash
    for each key is given by:'
  prefs: []
  type: TYPE_NORMAL
- en: '*h(3)*=9'
  prefs: []
  type: TYPE_NORMAL
- en: '*h(17)*=7'
  prefs: []
  type: TYPE_NORMAL
- en: '*h(9)*=1'
  prefs: []
  type: TYPE_NORMAL
- en: '*h(6)*=5'
  prefs: []
  type: TYPE_NORMAL
- en: '*h(21)*=5'
  prefs: []
  type: TYPE_NORMAL
- en: '*h(13)*=9'
  prefs: []
  type: TYPE_NORMAL
- en: '*h(7)*=7'
  prefs: []
  type: TYPE_NORMAL
- en: '*h(22)*=7'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.10](../images/fig5_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 5.10**'
  prefs: []
  type: TYPE_NORMAL
- en: Example of linear probing.
  prefs: []
  type: TYPE_NORMAL
- en: '**Insert 3,17,14,6:** Insertion of these 4 elements doest not face any collision.
    So, they are inserted at their hash indexes calculated according to given hash
    function.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Insert 21**: As <math alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mn>21</mn><mo
    stretchy="false">)</mo></mrow></math> =5 and this location is already occupied
    by key 6\. So, lets try linear probing with the equation: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mi>i</mi></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mi>i</mi><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    where i=0 to m-1'
  prefs: []
  type: TYPE_NORMAL
- en: '**i=0**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>0</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>5</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>5</mn></mrow></math>
    which is occupied.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, **i=1**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>5</mn><mo>+</mo><mn>1</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>6</mn></mrow></math>
    and this location is free. So, 21 is inserted at location 6.'
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, 13, 7 and 22 are inserted.
  prefs: []
  type: TYPE_NORMAL
- en: This example of insertion is presented in [Fig. 5.10](07chap_05.xhtml#fig5_10).
  prefs: []
  type: TYPE_NORMAL
- en: '[5.6.3 Quadratic probing](contents.xhtml#rsec5_6_3)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is another open addressing scheme to resolve collision in hash table. It
    works by taking hash value of the key and adding successive values of the quadratic
    polynomial. More formally, for quadratic probing, <math alttext="" display="inline"><mrow><mi>f</mi><mo
    stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>i</mi><mn>2</mn></msup></mrow></math>,
    i.e., <math alttext="" display="inline"><mrow><msub><mi>h</mi><mi>i</mi></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><msup><mi>i</mi><mn>2</mn></msup><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    where i=0 to m-1.
  prefs: []
  type: TYPE_NORMAL
- en: 'This scheme has good memory caching as it preserves the locality of reference.
    Also, it avoids clustering problem as compared to linear probing. Let''s understand
    quadratic probing with an example. Refer [Fig. 5.11](07chap_05.xhtml#fig5_11).
    Again consider 3, 17, 14, 6, 21, 13, 7, 22 are the keys to be inserted in series
    and <math alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>2</mn><mi>x</mi><mo>+</mo><mn>3</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn></mrow></math>
    is the hash function for key *x*. Hash for each key is given by:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.11](../images/fig5_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 5.11**'
  prefs: []
  type: TYPE_NORMAL
- en: Example of quadratic probing.
  prefs: []
  type: TYPE_NORMAL
- en: '*h(3)*=9'
  prefs: []
  type: TYPE_NORMAL
- en: '*h(17)*=7'
  prefs: []
  type: TYPE_NORMAL
- en: '*h(9)*=1'
  prefs: []
  type: TYPE_NORMAL
- en: '*h(6)*=5'
  prefs: []
  type: TYPE_NORMAL
- en: '*h(21)*=5'
  prefs: []
  type: TYPE_NORMAL
- en: '*h(13)*=9'
  prefs: []
  type: TYPE_NORMAL
- en: '*h(7)*=7'
  prefs: []
  type: TYPE_NORMAL
- en: '*h(22)*=7'
  prefs: []
  type: TYPE_NORMAL
- en: '**Insert 3,17,14,6:** Insertion of these 4 elements doest not face any collision.
    So, they are inserted at their hash indexes calculated according to the given
    hash function.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Insert 21**: *h(21)* is 5 which is occupied by the key 6\. So, lets try quadratic
    probing with the equation: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mi>i</mi></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><msup><mi>i</mi><mn>2</mn></msup><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    where i=0 to m-1 **i=0**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> = <math
    alttext="" display="inline"><mrow><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo></mrow></math> +0)mod m ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> =(5)mod
    10 =5 which is occupied.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, **i=1**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> = <math
    alttext="" display="inline"><mrow><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo></mrow></math> +1²)mod m ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> =(5+1)mod
    10= 6 and this location is free. So, 21 is inserted at location 6.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Insert 13**: <math alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mn>13</mn><mo
    stretchy="false">)</mo></mrow></math> =9 which is already occupied. So, lets try
    quadratic probing **i=0**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> = <math
    alttext="" display="inline"><mrow><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo></mrow></math> +0)mod m ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> =(9)mod
    10 =9 which is occupied.'
  prefs: []
  type: TYPE_NORMAL
- en: '**i=1**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> = <math
    alttext="" display="inline"><mrow><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo></mrow></math> +1²)mod m ⟹ h1(x)=(9+1)mod 10= 0 and this
    location is free. So, 13 is inserted at location 0.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Insert 7**: As <math alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mn>7</mn><mo
    stretchy="false">)</mo></mrow></math> =7 is already occupied, so lets try quadratic
    probing. **i=0**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> = <math
    alttext="" display="inline"><mrow><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo></mrow></math> +0)mod m ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> =(7)mod
    10 =7 which is occupied.'
  prefs: []
  type: TYPE_NORMAL
- en: '**i=1**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> = <math
    alttext="" display="inline"><mrow><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo></mrow></math> +1²)mod m ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> =(7+1)mod
    10= 8 and this location is free. So, 7 is inserted at location 8.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Insert 22**: <math alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mn>22</mn><mo
    stretchy="false">)</mo></mrow></math> =7 which is already occupied. So, lets try
    quadratic probing **i=0**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> =(
    <math alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo></mrow></math> +0)mod m ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> =(7)mod
    10 =7 which is occupied.'
  prefs: []
  type: TYPE_NORMAL
- en: '**i=1**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> =(
    <math alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo></mrow></math> +1²)mod m ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> =(7+1)mod
    10= 8 and this location is also not free. **i=2**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>2</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> =(
    <math alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo></mrow></math> +22)mod m ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>2</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> =(7+4)mod
    10= 1 and this location is also not free.'
  prefs: []
  type: TYPE_NORMAL
- en: '**i=3**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>3</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> =(
    <math alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo></mrow></math> +22)mod m ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>3</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> =(7+9)mod
    10= 6 and this location is free. So, 22 is inserted at location 6.'
  prefs: []
  type: TYPE_NORMAL
- en: '[5.6.4 Double hashing](contents.xhtml#rsec5_6_4)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This technique applies a second hash function to the given key in case of collision,
    i.e., <math alttext="" display="inline"><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo
    stretchy="false">)</mo><mo>=</mo><mi>i</mi><mo>*</mo><msub><mi>h</mi><mn>2</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> and
    <math alttext="" display="inline"><mrow><mi>i</mi><mo>=</mo><mn>0</mn><mi>t</mi><mi>o</mi><mi>m</mi><mo>−</mo><mn>1</mn></mrow></math>
    where, h2(x) is another hash function. The second hash function provides an offset
    value to resolve collision. This technique also comes under a double hashing technique.
    Notably, a good second hash function makes sure that all cells are equally probed.
    Unfortunately, the computational cost of double hashing is high as compared to
    other probing schemes. Let''s understand quadratic probing with an example as
    represented in [Fig. 5.12](07chap_05.xhtml#fig5_12). Again consider 3, 17, 14,
    6, 21, 13, 7, 22 are the keys to be inserted in series and <math alttext="" display="inline"><mrow><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>2</mn><mi>x</mi><mo>+</mo><mn>3</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn></mrow></math>
    is the hash function for key *x*. Assume other hash function <math alttext=""
    display="inline"><mrow><mi>h</mi><mtext>′</mtext><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>3</mn><mi>k</mi><mo>+</mo><mn>1</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn></mrow></math>
    Hash for each key is given by:'
  prefs: []
  type: TYPE_NORMAL
- en: '*h(3)*=9'
  prefs: []
  type: TYPE_NORMAL
- en: '*h(17)*=7'
  prefs: []
  type: TYPE_NORMAL
- en: '*h(9)*=1'
  prefs: []
  type: TYPE_NORMAL
- en: '*h(6)*=5'
  prefs: []
  type: TYPE_NORMAL
- en: '*h(21)*=5'
  prefs: []
  type: TYPE_NORMAL
- en: '*h(13)*=9'
  prefs: []
  type: TYPE_NORMAL
- en: '*h(7)*=7'
  prefs: []
  type: TYPE_NORMAL
- en: '*h(22)*=7'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.12](../images/fig5_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 5.12**'
  prefs: []
  type: TYPE_NORMAL
- en: Example of double hashing.
  prefs: []
  type: TYPE_NORMAL
- en: '**Insert 3,17,14,6:** Insertion of these 4 element doest not face any collision.
    So, they are inserted at their hash indexes calculated according to given hash
    function.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Insert 21**: <math alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mn>21</mn><mo
    stretchy="false">)</mo></mrow></math> is 5 which is occupied by the key 6\. So,
    lets apply double hashing with the equation: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mi>i</mi></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mi>i</mi><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    where i=0 to m-1\. **i=0**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>0</mn><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>5</mn><mo>+</mo><mn>0</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>5</mn></mrow></math>
    which is occupied.'
  prefs: []
  type: TYPE_NORMAL
- en: '**i=1**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>5</mn><mo>+</mo><mn>1</mn><mo>*</mo><mn>4</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>9</mn><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>9</mn></mrow></math>
    and which is also not free <math alttext="" display="inline"><mrow><mo stretchy="false">[</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mn>21</mn><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>3</mn><mo>*</mo><mn>21</mn><mo>+</mo><mn>1</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>4</mn><mo
    stretchy="false">]</mo></mrow></math>'
  prefs: []
  type: TYPE_NORMAL
- en: '**i=2**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>2</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>2</mn><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>5</mn><mo>+</mo><mn>2</mn><mo>*</mo><mn>4</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>13</mn><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>3</mn></mrow></math>
    and which is free. So, key 21 is inserted at location 3.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Insert 13**: <math alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mn>13</mn><mo
    stretchy="false">)</mo></mrow></math> is 9 which is occupied by the key 3\. So,
    lets apply double hashing with the equation: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mi>i</mi></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mi>i</mi><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    where i=0 to m-1\. **i=0**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>0</mn><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>9</mn><mo>+</mo><mn>0</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>9</mn></mrow></math>
    which is occupied.'
  prefs: []
  type: TYPE_NORMAL
- en: '**i=1**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>.
    Notably, <math alttext="" display="inline"><mrow><mo stretchy="false">[</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mn>13</mn><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>13</mn><mo>*</mo><mn>3</mn><mo>+</mo><mn>1</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>0</mn><mo
    stretchy="false">]</mo></mrow></math>. So, this will always result in hash index
    9 which is not free. This signifies choice of second hash function is not goo.
    So, we can''t insert 13 in this hash table.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Insert 7**: <math alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mn>7</mn><mo
    stretchy="false">)</mo></mrow></math> is 7 which is occupied by the key 17\. So,
    lets apply double hashing with the equation: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mi>i</mi></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mi>i</mi><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    where i=0 to m-1.'
  prefs: []
  type: TYPE_NORMAL
- en: '**i=0**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>0</mn><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>7</mn><mo>+</mo><mn>2</mn><mo>*</mo><mn>0</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>7</mn></mrow></math>
    which is occupied.'
  prefs: []
  type: TYPE_NORMAL
- en: '**i=1**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>7</mn><mo>+</mo><mn>2</mn><mo>*</mo><mn>1</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>9</mn><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>9</mn></mrow></math>
    which is also not free. Notably, <math alttext="" display="inline"><mrow><mo stretchy="false">[</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mn>7</mn><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>7</mn><mo>*</mo><mn>3</mn><mo>+</mo><mn>1</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>2</mn><mo
    stretchy="false">]</mo></mrow></math>.'
  prefs: []
  type: TYPE_NORMAL
- en: '**i=2**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>2</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>2</mn><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>2</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>7</mn><mo>+</mo><mn>2</mn><mo>*</mo><mn>2</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>11</mn><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>1</mn></mrow></math>
    which is also not free.'
  prefs: []
  type: TYPE_NORMAL
- en: '**i=3**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>3</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>3</mn><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>3</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>7</mn><mo>+</mo><mn>2</mn><mo>*</mo><mn>3</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>13</mn><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>3</mn></mrow></math>
    which is also not free.'
  prefs: []
  type: TYPE_NORMAL
- en: '**i=4**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>4</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>4</mn><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>4</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>7</mn><mo>+</mo><mn>2</mn><mo>*</mo><mn>4</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>15</mn><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>5</mn></mrow></math>
    which is also not free.'
  prefs: []
  type: TYPE_NORMAL
- en: '**i=5**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>5</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>5</mn><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>5</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>7</mn><mo>+</mo><mn>2</mn><mo>*</mo><mn>5</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>17</mn><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>7</mn></mrow></math>
    which is also not free.'
  prefs: []
  type: TYPE_NORMAL
- en: '**i=6**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>6</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>6</mn><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>6</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>7</mn><mo>+</mo><mn>2</mn><mo>*</mo><mn>6</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>19</mn><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>9</mn></mrow></math>
    which is also not free.'
  prefs: []
  type: TYPE_NORMAL
- en: '**i=7**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>7</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>7</mn><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>7</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> =(7+2*7)mod
    10= 21mod10=1 which is also not free.'
  prefs: []
  type: TYPE_NORMAL
- en: '**i=8**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>8</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>8</mn><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>8</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>7</mn><mo>+</mo><mn>2</mn><mo>*</mo><mn>8</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>23</mn><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>3</mn></mrow></math>
    which is also not free.'
  prefs: []
  type: TYPE_NORMAL
- en: '**i=9**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>9</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> = <math
    alttext="" display="inline"><mrow><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo><mo>+</mo><mn>9</mn><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>9</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>7</mn><mo>+</mo><mn>2</mn><mo>*</mo><mn>9</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>25</mn><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>5</mn></mrow></math>
    which is also not free.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, we cant increase value of i to 1 as i could range from 0to 9.So, value
    of i can't go beyond 9\. We have checked all possible value of i from 0 to 9\.
    So, we can't insert 7 in this hash table.
  prefs: []
  type: TYPE_NORMAL
- en: '**Insert 22**: *h(22)* is 7 which is occupied by the key 17\. So, lets apply
    double hashing with the equation: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mi>i</mi></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mi>i</mi><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    where i=0 to m-1.'
  prefs: []
  type: TYPE_NORMAL
- en: '**i=0**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>0</mn><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>0</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>7</mn><mo>+</mo><mn>7</mn><mo>*</mo><mn>0</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>7</mn></mrow></math>
    which is occupied.'
  prefs: []
  type: TYPE_NORMAL
- en: '**i=1**: <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> =(
    <math alttext="" display="inline"><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo
    stretchy="false">)</mo><mo>+</mo><mn>1</mn><mo>*</mo><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>m</mi></mrow></math>
    ⟹ <math alttext="" display="inline"><mrow><msub><mi>h</mi><mn>1</mn></msub><mo
    stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>7</mn><mo>+</mo><mn>7</mn><mo>*</mo><mn>1</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>14</mn><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>4</mn></mrow></math>
    which is free. Notably, [ <math alttext="" display="inline"><mrow><mi>h</mi><mtext>′</mtext><mo
    stretchy="false">(</mo><mn>7</mn><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>22</mn><mo>*</mo><mn>3</mn><mo>+</mo><mn>1</mn><mo
    stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>10</mn><mo>=</mo><mn>7</mn></mrow></math>].'
  prefs: []
  type: TYPE_NORMAL
- en: '[5.7 RSA](contents.xhtml#rsec5_7)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Introduced in 1978, RSA (Rivest, Shamir, Adleman) is the first widely adopted
    cryptosystems. RSA follows the idea of public-key encryption which is based on
    two components, i.e., public key, and private key. Everyone on the network has
    its own public and private key pair. The public key is known to everybody on the
    network and it is used to encrypt the message and also to verify signatures. In
    contrast, a private key is only known to the receiver and is used to decrypt the
    sent message and also to create signatures. Applications of RSA include both digital
    signatures and public key encryption. In RSA, the public key of the receiver is
    used to encrypt the message whereas the private key of the receiver is used to
    decrypt the message as shown in [Fig. 5.13](07chap_05.xhtml#fig5_13). Encryption
    is a process of transforming the original message into an unrecognizable form
    called ciphertext whereas decryption is a process of converting encrypted message
    back to the original message. The process of RSA involves 3 steps, i.e., key generation,
    encryption, and decryption.
  prefs: []
  type: TYPE_NORMAL
- en: '[5.7.1 Steps for key generation:](contents.xhtml#rsec5_7_1)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Select the variables *p* and *q* where both *p* and *q* both are large prime
    numbers and p≠q. The whole security of RSA is dependent on the difficulty of factoring
    large prime numbers. A poor choice of *p* and *q* can make RSA less secure and
    vulnerable to different attacks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compute <math alttext="" display="inline"><mrow><mi>n</mi><mo>=</mo><mi>p</mi><mo>*</mo><mi>q</mi></mrow></math>,
    *n* is a part of the public key and should be large so that it is difficult to
    extract *p* and *q* from it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compute *ϕ*(n)=(p-1)(q-1). *ϕ*(n) is called as Euler's totient function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, public key *e* is generated such that gcd(*ϕ*(n), e)=1 or *e* should be
    co-prime to *ϕ*(n); 1¡e¡*ϕ*(n).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, create the private key *d* such that d≡e-1mod*ϕ*(n).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both <math alttext="" display="inline"><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>,</mo><mi>e</mi><mo
    stretchy="false">)</mo></mrow></math> are part of RSA public key and is publically
    available and private key consist of <math alttext="" display="inline"><mrow><mo
    stretchy="false">(</mo><mi>n</mi><mo>,</mo><mi>d</mi><mo stretchy="false">)</mo></mrow></math>.
  prefs: []
  type: TYPE_NORMAL
- en: '[5.7.2 Encryption](contents.xhtml#rsec5_7_2)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Lets assume a sender has to sent a plaintext message *M* to a receiver having
    public key <math alttext="" display="inline"><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>,</mo><mi>e</mi><mo
    stretchy="false">)</mo></mrow></math>. To encrypt message use:'
  prefs: []
  type: TYPE_NORMAL
- en: Cipher text= <math alttext="" display="inline"><mrow><msup><mi>M</mi><mi>e</mi></msup><mi>m</mi><mi>o</mi><mi>d</mi><mi>n</mi></mrow></math>.
  prefs: []
  type: TYPE_NORMAL
- en: '[5.7.3 Decryption](contents.xhtml#rsec5_7_3)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To decrypt, receiver uses its private key as:'
  prefs: []
  type: TYPE_NORMAL
- en: Plaintext= <math alttext="" display="inline"><mrow><msup><mi>C</mi><mi>d</mi></msup><mi>m</mi><mi>o</mi><mi>d</mi><mi>n</mi></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.13](../images/fig5_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 5.13**'
  prefs: []
  type: TYPE_NORMAL
- en: RSA algorithm structure.
  prefs: []
  type: TYPE_NORMAL
- en: '[5.7.4 RSA example](contents.xhtml#rsec5_7_4)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Key generation**'
  prefs: []
  type: TYPE_NORMAL
- en: Assume *p*=17, *q*=11.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compute *n*; *n*= 17*11=187.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compute *ϕ*(n); *ϕ*(n)=(17-1)*(11-1)=160.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choose *e* such that gcd(*ϕ*(n), e)=1; choose *e*=7.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compute *d* such that d≡e-1mod*ϕ*(n); d*e≡1mod160 and d¡160 ⟹ d=23 as 23*7=10*160+1.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Therefore, public key=(7, 187)
  prefs: []
  type: TYPE_NORMAL
- en: private key= (23, 187).tcolorbox
  prefs: []
  type: TYPE_NORMAL
- en: '**Key point** Public key cryptosystem follows asymmetric property as the person
    who encrypts message or verifies the signature on the message can''t decrypt or
    sign signatures on the message.'
  prefs: []
  type: TYPE_NORMAL
- en: '[5.8 Elliptic Curve Cryptography](contents.xhtml#rsec5_8)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another way to perform public key cryptography is with elliptic curves. ECC
    is one of the most powerful concepts of cryptography. ECC is used for authentication,
    while secure web browsing over SSL/TLS. Popular cryptocurrency such as- Bitcoin
    and Etherem use the concept of elliptic curve. ECC is applicable for key generation,
    digital signatures and encryption/decryption services. Notably, ECC requires smaller
    key sizes as compared to RSA to provide equivalent security. Clearly, smaller
    key size are easy to manage and work with. A 256 bit ECC is equivalent to 3072-bit
    key size RSA algorithm. As ECC achieves equivalent security to RSA, with lower
    computing power and battery usage ECC has been popularly used for mobile applications.
    The key generation algorithm of the ECC uses the properties of elliptic curve
    equation which is discussed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: An elliptic curve is defined as a set of points that satisfies a cubic mathematical
    equation (Refer [Fig. 5.14](07chap_05.xhtml#fig5_14)), i.e.,
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="" display="block"><mrow><mtable columnalign="left"><mtr columnalign="left"><mtd
    columnalign="left"><mrow><msup><mi>y</mi><mn>2</mn></msup><mo>=</mo><msup><mi>x</mi><mn>3</mn></msup><mo>+</mo><mi>a</mi><mi>x</mi><mo>+</mo><mi>b</mi></mrow></mtd></mtr></mtable></mrow></math>(5.4)
  prefs: []
  type: TYPE_NORMAL
- en: where <math alttext="" display="inline"><mrow><mn>4</mn><msup><mi>a</mi><mn>3</mn></msup><mo>+</mo><mn>27</mn><msup><mi>b</mi><mn>2</mn></msup><mo>≠</mo><mn>0</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: To plot such a curve we need to compute <math alttext="" display="inline"><mrow><mi>y</mi><mo>=</mo><mo>±</mo><msqrt><mrow><msup><mi>x</mi><mn>3</mn></msup><mo>+</mo><mi>a</mi><mi>x</mi><mo>+</mo><mi>b</mi></mrow></msqrt></mrow></math>
    for combination of every *a* and *b*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.14](../images/fig5_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 5.14**'
  prefs: []
  type: TYPE_NORMAL
- en: An illustration of elliptic curve.
  prefs: []
  type: TYPE_NORMAL
- en: '**Properties of elliptic curve**'
  prefs: []
  type: TYPE_NORMAL
- en: Depending on values of a and b, elliptic curve takes different shapes on the
    plane
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All elliptic curves are symmetric around x-axis. For example, if we take <math
    alttext="" display="inline"><mrow><mi>a</mi><mo>=</mo><mn>27</mn></mrow></math>
    and <math alttext="" display="inline"><mrow><mi>b</mi><mo>=</mo><mn>2</mn></mrow></math>,
    then for <math alttext="" display="inline"><mrow><mi>x</mi><mo>=</mo><mn>2</mn></mrow></math>,
    <math alttext="" display="inline"><mrow><mi>y</mi><mo>=</mo><mo>±</mo><mn>8</mn></mrow></math>,
    i.e., <math alttext="" display="inline"><mrow><mo stretchy="false">(</mo><mn>2</mn><mo>,</mo><mo>−</mo><mn>8</mn><mo
    stretchy="false">)</mo></mrow></math> and <math alttext="" display="inline"><mrow><mo
    stretchy="false">(</mo><mn>2</mn><mo>,</mo><mn>8</mn><mo stretchy="false">)</mo></mrow></math>
    are the resulting points.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any non vertical line intersects the curve in atmost three points.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The points on an elliptic curve form a group. The group operation applicable
    for points on elliptic curve is called addition law. To add a point P the on curve
    with another point Q, use the rule:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First, join P and Q with a straight line.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Call this point -R where this straight line intersects with the curve.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The mirror image of this point with respect to x-coordinate defines the addition
    of points P and Q and is denoted by R in [Fig. 5.15](07chap_05.xhtml#fig5_15).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 5.15](../images/fig5_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 5.15**'
  prefs: []
  type: TYPE_NORMAL
- en: Addition of points on elliptic curve.
  prefs: []
  type: TYPE_NORMAL
- en: Key point
  prefs: []
  type: TYPE_NORMAL
- en: A trapdoor function *f* is defined as a function that is easy to calculate but
    whose inverse <math alttext="" display="inline"><mrow><msup><mi>f</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow></math>
    is difficult to compute.
  prefs: []
  type: TYPE_NORMAL
- en: Activity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Multiple Choice Questions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Which encryption/decryption key is only known to parties exchanging secret messages?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Public key
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Private key
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Security token
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: e-signatures
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which is not a function of private key?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Encrypting text
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Authentication
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Decrypting text
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: None of these
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What is cipher?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Algorithm for encryption
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Decrypted message
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Encrypted message
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Secret key
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Cryptographic hash function converts a arbitrary block into a ………?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Variable size string
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Fixed size string
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Both fixed and variable size string
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Can't say
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which among the following is the component of CIA triad?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Confidentiality
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Integrity
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Authentication
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Availability
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What are thr requirements of a hash function?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One-way
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Avalanche effect
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Deterministic
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: All of the above
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Cryptanalysis is ……
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To decrease the speed of encryption
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: To increase the speed of encryption
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: To generate ciphertext
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: To find insecurities in cryptographic algorithm
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Digital signature is based on …..?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Public key encryption
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Private key encryption
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Blockchain technology
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: None of the above
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the properties of zero knowledge proof?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Completeness
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Soundness
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Zero knowledge
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: None of the above
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which among of the following is collision rsolution technique?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Quadratic probing
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: ECC
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: DSA
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: All of the above
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 1\. b  2\. a  3\. c  4\. b  5\. c  6\. d  7\. d  8\. a  9\. a, b, c  10\. a
  prefs: []
  type: TYPE_NORMAL
- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '[6](contents.xhtml#rchapter6)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Blockchain Technology and Technical Foundations](contents.xhtml#rchapter6)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '[6.1 Fundamentals of Blockchain](contents.xhtml#rsec6_1)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Blockchain is a growing list of blocks that combines cryptography with distributed
    computing in order to provide decentralized, transparent, and strong consistency
    support. In particular, blockchain technology is replacing the existing transaction
    management system [[112](bib.xhtml#ch00-bib-112)]. Notably, the traditional way
    of writing something in a shared document is that user1 will send the document
    to user2 and user2, after receiving the document update the document with its
    own content and send it back to user1\. However, this method does not allow both
    parties to write on the document simultaneously. As a solution, with Google Docs
    provided by Microsoft Word both of user1 and user2 can write simultaneously. Nevertheless,
    this Google doc platform is centralized and involves a third party. Mostly, the
    traditional distributed databases are centralized, have high complexity, and they
    rely on trusted database company.
  prefs: []
  type: TYPE_NORMAL
- en: Centralized architecture has a central co-ordination system and every node on
    the network is connected to this system. Any information sharing in the network
    has to involve this central coordination system. Nevertheless, there are some
    disadvantages with a centralized system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Single point of failure: What if the system or the server crashes. Unfortunately,
    in case of a crash of this central system, all nodes on the network get disconnected
    to the network and all operations get terminated. This situation may lead to the
    loss of entire information. Therefore, complete dependency on a single server
    is not efficient.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Bottleneck: Bottlenecks are common in case of increased traffic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Single point of attack: As there is a single central authority, there are chances
    of a single point of attack. Therefore, this type of architecture can easily suffer
    a denial-of-service attack.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Delay: As a centralized server is mostly located at a far location from users,
    so time to access data increases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Higher privacy risk: As centralized architectures involve a trusted third party,
    so the user is unaware of how the information of users is secured with the third
    party. The trusted third party may share the private information of users with
    other parties.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Over and above, there are other architectures to support information sharing,
    i.e., distributed and decentralized architectures:'
  prefs: []
  type: TYPE_NORMAL
- en: In a decentralized architecture, rather than having a single co-coordinator,
    multiple co-coordinators are present and nodes of the network are connected to
    any of these coordinators. So, in case of one co-ordinator node failure, nodes
    of the network can connect to any other co-ordinator to share information. Decentralization
    supports fault tolerance as decentralized systems are less likely to crash accidentally.
    Moreover, due to the presence of multiple coordinators, there is no chance of
    a single point of attack. On the other hand, in a distributed architecture, all
    nodes of the network participate in the computations and there is no single authority
    in charge. All nodes of the network co-ordinator with each other and collectively
    involves in the information sharing process. A decentralized system is actually
    part of the distributed system. In a decentralized and distributed network, both
    user1 and user2 has their own local copy of the document and both of the users
    can simultaneously write on the document.
  prefs: []
  type: TYPE_NORMAL
- en: Blockchain is a platform that provides support for decentralized and distributed
    architecture where nodes of the network can share information among themselves.
    In contrast to a client-server model, blockchain implements a digital P2P network.
    In a blockchain network, there are multiple nodes connected via the Internet and
    each node maintains a local copy of global sheet. However, these local copies
    should be updated always as per the global information. In particular, this local
    copy of data is called a public ledger. A popular example of the public ledger
    is the banking transactions and the first popular use case of blockchain is the
    Bitcoin network. Blockchain bitcoin is referred to as decentralized system for
    exchanging cryptocurrency and it also shares distributed ledger. Many other blockchain
    cryptocurrency platforms were introduced including Ethereum leveraging the same
    public model as Bitcoin, whereas platforms such as- Hyperledger, Ripple are some
    permissioned blockchain. Although the distributed applications of blockchain are
    used in many other sectors including healthcare, IoT, smart grid, etc. Blockchain
    provides a decentralized common platform for multiple parties who don't trust
    each other and are involved in information sharing or rational decision-making
    process. This technology provides an effective way of storing transactions in
    a secure, transparent, and highly resistant way. The blockchain network makes
    sure regarding ensuring consistency and maintaining synchronization of the document.
    Anything stored on the blockchain has transparent nature and anyone modifying
    it is accountable for their actions. Moreover, the decentralized nature of this
    network ensures that a single node on the network can't append invalid blocks
    to the chain. Before a transaction is added to the blockchain network, it is validated
    by all the participants on the blockchain network. Before adding a new block to
    the blockchain network, it is always linked to the previous block with cryptographic
    hash of the immediately previous block. Therefore, cryptographic linking ensures
    the integrity of the network. As every block is cryptographically linked to the
    previous block hash that is why the name blockchain is defendable. If any block
    is altered, attackers need to modify all subsequent blocks which are quite difficult.
  prefs: []
  type: TYPE_NORMAL
- en: According to Wikipedia, A blockchain is a continuously growing list of records
    called blocks, which are linked using cryptography [[8](bib.xhtml#ch00-bib-8)].
  prefs: []
  type: TYPE_NORMAL
- en: Blockchain technology is primarily based on the fundamentals of cryptography
    and distributed ledger technology. In particular, blockchain uses the concept
    of hash functions, ECC, digital signatures and Elliptic Curve Digital Signature
    Algorithm (ECDSA) to maintain integrity, confidentiality, and non-repudiation
    of the system. A distributed ledger is a kind of database that is shared and synchronized
    among nodes of the decentralized network. Moreover, each record in distributed
    ledger is timestamped in order to achieve the integrity of the document. However,
    a consensus mechanism is used by network participants to achieve mutual agreements
    on a single state of the network in a distributed environment. Clearly, the consensus
    mechanism minimizes the risk of fraudulent transactions.
  prefs: []
  type: TYPE_NORMAL
- en: Blockchain mining is a process of validating transactions before it is added
    to the network and miners are the entity that is responsible for validating and
    generating a new block in the network. Some special nodes with some special characteristics
    (different for every blockchain network) are only regarded as a miner. Further,
    the mined block is broadcasted in the network to be verified by other nodes before
    final inclusion in the network. Whenever a new Bitcoin transaction is made it
    is first placed in a transaction pool. Rather than validating a single transaction,
    miners collect a certain number of transactions from the transaction pool to form
    a candidate block. Hence, a candidate block is referred to as a block that has
    been created by a miner but it is not added to the network. It may so happen that
    multiple miners can mine a block with exactly same or some different transactions
    simultaneously or in a near identical time. However, when two blocks get mined
    simultaneously, there is a possibility that only one miner's blocks get more number
    of blocks on top of it. If multiple valid blocks to the existing chain appear,
    in that case, only the longest subbranch is accepted and continued further; and
    the blocks that are not accepted are called orphaned blocks and that path is called
    forks. In other words, orphan blocks are those blocks which do not have any link
    to main branch due to missing predecessor. Additionally, if there are two different
    chains of the same length then accept the chain which has been broadcasted by
    more number of miners. Transactions from these blocks which are not validated
    are sent back to the transaction pool. In such cases, efforts of miners go useless
    as mined blocked becomes unrecorded.
  prefs: []
  type: TYPE_NORMAL
- en: '[6.1.1 Characteristics of blockchain technology](contents.xhtml#rsec6_1_1)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Decentralization: Blockchain technology does not depend on a centralized system
    or any governing authority to perform all transactions. Instead, the network is
    controlled by nodes of the network making it decentralized. Every node on the
    network has its copy of shared ledger which is updated. Moreover, it solves the
    problem of a single point of failure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Better security: Cybersecurity is defined as a capability to prevent and recover
    from cyber-attacks. Blockchain technology provides better security as there is
    not any chance of system failure. The use of a cryptography system by blockchain
    provides protection for users. Another reason for the popularity of blockchain
    technology is basically its capability to deal with the threat of an individual''s
    privacy. All transactions are verified and it is quite hard to modify these transactions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Immutability: Immutable ledger is the main advantage of the blockchain system.
    Immutability implies data on the network can''t be changed or altered. Blockchain
    stores permanent records of transactions. After a block is verified and added
    to the network, it can''t be modified or deleted. Moreover, the lack of centralization
    promotes scalability and robustness. Centralized architecture can be tampered
    and requires trust in a third party to maintain integrity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Anonymity: Blockchain provides anonymity as nodes are known by their public
    keys on the network. Therefore, the identities of the nodes are kept private.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Transparency: Any node on the network can audit transactions and every node
    has access to same universal ledger. Every state of data and every updating state
    is visible to node of the network.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Redundancy: As copy of distributed ledger is stored with every full node on
    the network, hence redundancy is inherent for blockchain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Efficiency: All transactions are automatically executed via pre set procedures.
    Hence, blockchain technology reduces cost of labor along with improving efficiency.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[6.1.2 What constitutes a block of blockchain?](contents.xhtml#rsec6_1_2)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first block in a blockchain is called genesis block and this block doesn''t
    have ant previous block. All network participants should have the same genesis
    block in order to attain the correctness of the blockchain network. The previous
    hash value for a genesis block is zero. The structure of blockchain comprises
    of strings of blocks, each holding transactions of data and metadata. Data inside
    a block contains transactions generated by participants of the network and blocks
    hold the transaction in a secure way so that they can''t be tampered. A transaction
    is an atomic event or the smallest building block allowed by a particular protocol.
    For instance, in Bitcoin blockchain transactions are user''s payments. On the
    other hand, the metadata contains information regarding block including parent
    block hash, timestamp, etc. This informative metadata is used by miners or the
    other nodes of the network to verify a block or to append a block to the blockchain.
    The structure of chained block is represented by [Fig. 6.1](08chap_06.xhtml#fig6_1).
    Metadata of the block is stored in block header ad consists of the following field:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Version: The version number is used to track protocol upgrades used by blockchain
    nodes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Timestamp: It specifies the creation time of the block.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Nonce: It is a random number used to solve the Proof-of-Work (PoW) cryptographic
    puzzle as shown in Eq. 6.1.2.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <math alttext="" display="block"><mrow><mtable columnalign="left"><mtr columnalign="left"><mtd
    columnalign="left"><mrow><mi>S</mi><mi>H</mi><mi>A</mi><mo>−</mo><mn>256</mn><mo
    stretchy="false">(</mo><mi>S</mi><mi>H</mi><mi>A</mi><mo>−</mo><mn>256</mn><mo
    stretchy="false">(</mo><mi>P</mi><mi>r</mi><mi>e</mi><mi>v</mi><mi>i</mi><mi>o</mi><mi>u</mi><mi>s</mi><mi>b</mi><mi>l</mi><mi>o</mi><mi>c</mi><mi>k</mi><mi>h</mi><mi>a</mi><mi>s</mi><mi>h</mi><mo>|</mo><mo>|</mo><mi>T</mi><msub><mi>x</mi><mn>1</mn></msub></mrow></mtd></mtr><mtr
    columnalign="left"><mtd columnalign="left"><mrow><mo>|</mo><mo>|</mo><mi>T</mi><msub><mi>x</mi><mn>2</mn></msub><mo>|</mo><mo>|</mo><mn>.......</mn><mo>|</mo><mo>|</mo><mi>T</mi><msub><mi>x</mi><mi>n</mi></msub><mo>|</mo><mo>|</mo><mi>n</mi><mi>o</mi><mi>n</mi><mi>c</mi><mi>e</mi><mo
    stretchy="false">)</mo><mo stretchy="false">)</mo><mo><</mo><mi>D</mi><mi>i</mi><mi>f</mi><mi>f</mi><mi>i</mi><mi>c</mi><mi>u</mi><mi>l</mi><mi>t</mi><mi>y</mi></mrow></mtd></mtr></mtable></mrow></math>(6.1)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Difficulty/Target: This is used by PoW algorithm to solve mining process. For
    a block to be added in the blockchain network, it has to generate a valid hash
    and difficulty value is used in achieving this task.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Previous block hash: As mentioned earlier, every nnt block of blockchain stores
    hash of previous block, i.e., (n-1)nt block. In order to compute hash of (n-1)th
    block, all header field of (n-1)nt block are collectively hashed twice.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Merkle tree: It contains the value of root of merkle tree which is explained
    in detail later in next chapter. It is basically a tree structure where the nodes
    at leaf level contain the hash of the document and every intermediate node contains
    the hash of left and a right child. As it is presented in [Fig. 6.2](08chap_06.xhtml#fig6_2),
    there are 8 transactions, i.e., t1, t2,…………,t8\. Leaf nodes of the Merkle tree
    contain the direct hash of these transactions and then level 1 has intermediate
    nodes with hash value of its left and right child (,i.e., obtained hashes are
    again paired to calculate the hash for next level). This hash will be recursively
    calculated until a single root hash is obtained.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 6.1](../images/fig6_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 6.1**'
  prefs: []
  type: TYPE_NORMAL
- en: Structure of chained blocks.
  prefs: []
  type: TYPE_NORMAL
- en: '**Key point** Mandatory fields are transactions, Merkle root hash, and hash
    of the previous block which are used by every blockchain network, rest other are
    specific to particular blockchain application.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2](../images/fig6_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 6.2**'
  prefs: []
  type: TYPE_NORMAL
- en: Structure of Merkle Tree.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to this, Merkle hash tree is used in membership verification. Notably,
    to verify membership of any given transaction, the verifier does not need to possess
    a complete Merle tree, rather only (log n) piece of data is enough where n is
    the total number of nodes in the tree. As every node has access to block header,
    so the root value of Merle hash tree can be downloaded from there. Suppose, user
    A has root node of Merkle tree for a block and user B wants to prove user A that
    transaction t4 is in the block. (Refer to [Fig. 6.2](08chap_06.xhtml#fig6_2).
    To accomplish this, user 2 has to provide user 1 some siblings of the nodes in
    the tree path from t4 to the root, so that user A can recompute root hash of the
    tree and match it against the one downloaded from the block. For example, To verify
    the presence of transaction t4 in the block user 2 has to actually provide user1
    c, a’ and b” along with hash of transaction t4\. With knowing c and a, b’ can
    be computed and b’ when combined with a’ can compute a” and finally root hash
    can be computed with a” and b”. Infact, user 2 can actually prove the presence
    of t4 in the block without even revealing its content by just proving hash of
    t4.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, even in the presence of a large number of blocks in Merkle tree,
    membership of any element can be proved in relatively short time. With having
    only hash values of top level nodes, it is easy to traverse down to any leaf node
    in order to check whether it is tampered or not.tcolorbox
  prefs: []
  type: TYPE_NORMAL
- en: '**Key point** With merkle tree membership of any transaction can be verified
    in O(log n) time and space complexity.'
  prefs: []
  type: TYPE_NORMAL
- en: '[6.1.3 Bitcoin basics](contents.xhtml#rsec6_1_3)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Bitcoin is regarded as the first fully functional digital currency. It completely
    executes a P2P banking system without any central financial organization [[160](bib.xhtml#ch00-bib-160)].
    The bitcoin blockchain network is a network where users can send or receive cryptocurrency
    among themselves. It comes under the public blockchain and anyone in the world
    can be a part of the Bitcoin network. Here, transaction is a transfer of cryptocurrency
    from one node of the network to another network. Every registered node on the
    blockchain network has a pair of public and private keys held in the Bitcoin wallet
    of that person. Over and above, the Bitcoin wallet address never carries the name
    or identity of the person. Basically, a wallet address is the mathematical correspondence
    of the public key used by the user. Therefore, using the Bitcoin address maintains
    the anonymity of the network. Notably, the user can have more than one address.
    Suppose, user A wants to transfer some Bitcoins to user B. Anyone having user
    B walled address can transfer Bitcoin to his account however, to release money
    only public key of user B is required. To accomplish this, user A will create
    a transaction specifying the amount of money user A wants to transfer and user
    B address. Next, the user will sign the transaction and broadcast this transaction
    in the network. To create digital signatures, take the hash of the transaction
    and apply encryption using senders private key. Anyone in the network or specifically
    a miner can validate this transaction's integrity, authentication, and non-repudiation
    using user A public key. Notably, when a user sends Bitcoin to another address,
    wallet of that user creates a transaction output having an address of another
    user to whom money is being transferred and this transaction is recorded on blockchain
    network with Bitcoin address of the sender as the transaction input. In another
    way, an input is a reference to the output of a previous transaction. In the case
    of multiple transactions, all the total coin value is added up and it can be used
    by the output of the new transactions. For example, in [Fig. 6.3](08chap_06.xhtml#fig6_3),
    Payer B creates a transaction Y by signing its own coins received from transaction
    1 using his/her private key and adding its own public key and address of payee
    C. Anybody on the network can use B's public key to validate the transaction and
    to ensure B is spending the right coins. However, for any transaction to be accepted
    by the rest of the network, transaction blocks need to be validated and miners
    validating the nodes must include PoW in the block. Here, miners are special nodes
    with good computational power and resources. Notably, the block size in a Bitcoin
    network can't exceed 1 MB to achieve fast propagation.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3](../images/fig6_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 6.3**'
  prefs: []
  type: TYPE_NORMAL
- en: Illustration of Bitcoin transaction.
  prefs: []
  type: TYPE_NORMAL
- en: PoW is a cryptographic difficult hash generated by miners. Particularly, it
    is a Bitcoin consensus algorithm. The concept of PoW and mining makes a transaction
    computationally impractical to modify. In PoW, basically, miners have to find
    a nonce value so that the hash of the block has a certain hash value. The first
    miner to solve the puzzle gets a reward in the form of incentives from the network.
    All the other nodes in the network validate the blocks mined by miners. For a
    block to be added in the Bitcoin network, more than 51% of the network nodes should
    approve the blocks. Hence the only way to attack the blockchain network is when
    51% of the hash power is with attackers. This detailing of this algorithm is explained
    in the coming section.
  prefs: []
  type: TYPE_NORMAL
- en: Another reason for the popularity of Bitcoin is its ability to solve the problem
    of double-spending. Double spending is a problem when the same Bitcoins are used
    for more than one transaction. For example, user A has 100 Bitcoins and user A
    tries to send the same amount of 100 Bitcoins to both user B and user C simultaneously.
    The property of timestamping and distributed ledger ensures double-spending of
    Bitcoins. tcolorbox
  prefs: []
  type: TYPE_NORMAL
- en: '**Key point** Bitcoin addresses are random numbers and it may be possible that
    two different users end up in creating same address and it results in a collision.
    In such a situation, both original and colliding owner of address could spend
    Bitcoins sent to that address.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Multi-signature transactions:** It is a type of transaction that is signed
    by multiple users and it transfers funds from a multi-signature address. This
    kind of transaction is used if more than one person is appointed to look after
    possession of Bitcoins. In order to append such Bitcoins, each one of the persons
    or majority of them has to sign the transactions. It implies that more than one
    private key is used to create digital signatures.'
  prefs: []
  type: TYPE_NORMAL
- en: '[6.2 Types of Blockchain](contents.xhtml#rsec6_2)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The foremost application of blockchain is to execute secure transactions. However,
    depending on user''s requirement there are multiple ways in which blockchain network
    is implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Public blockchain: A public blockchain network is a permissionless system where
    any node with access to the Internet can participate to be a part of the network.
    Here any user of the network can access records, verify, validate transactions,
    and perform mining tasks. The more the number of participants in the public blockchain
    network, the more it will be secure as the blocks are then verified and validated
    by more participants of the network. Bitcoin, Ethereum, Litcoin, Steller, dash
    are examples of the public blockchain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Private blockchain: In contrast, a private blockchain is owned by an organization
    or enterprises where participants are restricted and only authenticated users
    are allowed. Actually, private blockchains are the restrictive version of public
    blockchain. Private blockchains are used with the private organization for storing
    sensitive information. A new user can''t join the network without having an invitation
    from the network. The invitation procedure involves use of conditions to be satisfied
    before a new user can join. Private blockchain is fast than public blockchain.
    Notably, private blockchain possesses centralization as compared to public blockchain.
    Hyperledger, multichain, Corda are the popular examples of private blockchain.
    High customizability, better access controls, better scalability are some of the
    advantages of the private blockchain [[47](bib.xhtml#ch00-bib-47)].'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consortium blockchain: This types of blockchain is regarded as semi-private
    systems. Clearly, it is not a public network but a permissioned network. However,
    rather a single organization governing, multiple organization governs the network.
    This type is beneficial for cases where multiple organization operates in the
    same industry. Here, only a few selected nodes have the right to oversee consensus
    mechanisms and to authorize transactions. Compared to a public blockchain, consortium
    blockchain provides faster speed. Also, this blockchain type does not face scalability
    problems. Quorum is a popular example under this category.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The difference in above discussed blockchain type in tabular form is discussed
    in [Table 6.1](#tab6_1).
  prefs: []
  type: TYPE_NORMAL
- en: '**TABLE 6.1**'
  prefs: []
  type: TYPE_NORMAL
- en: Differences in blockchain type.
  prefs: []
  type: TYPE_NORMAL
- en: '| Blockchain type |'
  prefs: []
  type: TYPE_TB
- en: '| --- |'
  prefs: []
  type: TYPE_TB
- en: '| Characteristic | Public | Private | Consortium |'
  prefs: []
  type: TYPE_TB
- en: '| Permissionless | Yes | No | No |'
  prefs: []
  type: TYPE_TB
- en: '| Read rights | Anyone | Invited users only | Depends |'
  prefs: []
  type: TYPE_TB
- en: '| Write rights | Anyone | Approved participants | Approved participants |'
  prefs: []
  type: TYPE_TB
- en: '| Ownership | Nobody | Single entity | Multiple entities |'
  prefs: []
  type: TYPE_TB
- en: '| Transaction speed | Slow | Fast | Fast |'
  prefs: []
  type: TYPE_TB
- en: '| Centralized | No | Yes | Partially |'
  prefs: []
  type: TYPE_TB
- en: '[6.3 Blockchain Applications](contents.xhtml#rsec6_3)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Due to its distributed, immutable, and trustworthy nature for all transactions,
    blockchain technology has various applications. Not only the financial sector,
    but blockchain technology also has the potential to revolutionize commerce, industry,
    education sector, etc. Authors of [[182](bib.xhtml#ch00-bib-182)], suggested that
    the growth of blockchain applications can be divided into three phases, i.e.,
    blockchain 1.0, blockchain 2.0, and blockchain 3.0\. Blockchain 1.0 covers the
    usage of cryptocurrency as a P2P payment system. Blockchain 2.0 includes smart
    contracts, smart property, and decentralized applications with simple cash transactions.
    Blockchain 3.0 covers applications beyond finance and cryptocurrency, such as-
    healthcare, governance, agriculture, and smart grid, etc.[[49](bib.xhtml#ch00-bib-49)].
  prefs: []
  type: TYPE_NORMAL
- en: 'Education: One of the worth mentioning application of blockchain is in the
    education sector. Similar to financial, educational sector has leveraged blockchain
    to keep student''s data safe for the coming years. As blockchain keeps track of
    information efficiently, library information services in colleges and schools
    can implement blockchain. Some universities and institutes have used blockchain
    to support degree management and evaluations for course learning outcomes. Another
    use is to reward students for their success and achievements based on transparent
    records stored on the blockchain network. For example, the University of Nicosia
    is the first place where blockchain is used to manage certificates of students
    from massive open online course (MOOC) platform [[170](bib.xhtml#ch00-bib-170)].
    In addition to this, blockchain technology helps in reducing student''s fraud
    degrees. With blockchain, all degrees and certificates are stored digitally on
    the blockchain network without requiring any intermediary to verify them. Also,
    ride sharing applications can use to organize carpooling services. This will surely
    reduce the burden on public transport.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Healthcare: Mostly, existing healthcare systems are maintained by a central
    authority. Therefore, all the data generated by patients can be accessed by these
    third parties without the patient''s consent which leads to privacy concerns.
    To address this problem, recently blockchain technology has been extensively used
    in healthcare networks for various applications, such as- data management, data
    sharing, data storing, data analyzing, and access management systems. The foremost
    use case in health sector is for improved and secured medical record management
    [[208](bib.xhtml#ch00-bib-208)]. With blockchain, the information measured by
    IoT sensors, such as- temperature, blood pressure, heart care, and pulse rate
    is shared securely and transparently over the blockchain network. The patient
    can now control and check what and how much information is to be shared with the
    doctor or any other healthcare officer. Another use case is to verify the claimed
    transaction for health care financing task. Literature supports many work that
    integrates blockchain with healthcare system, such as [[102](bib.xhtml#ch00-bib-102)],
    [[97](bib.xhtml#ch00-bib-97)].'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Voting system: In a democratic country, maintain security in an election system
    is a matter of national security. Nowadays, electronic voting machines are used
    by the government to achieve the voting mechanism successfully. Notably, these
    e-voting systems are based on a centralized network where everything is handled
    by a trusted third-party. However, such kind of system is a concern of physical
    security, privacy, and lack of transparency. Importantly, one of the main concerns
    for such systems is the prevention of database manipulation. By leveraging the
    fundamentals of blockchain and smart contract a secure e-voting system for transparent
    democracy can be created. The usage of SHA-256 hash function and linkage to the
    previous block with the help of cryptography prevents any kind of modifications
    to the database. Moreover, the digital signature usage ensures reliability to
    the system. Additionally, the concept of anonymity supported by blockchain ensures
    that voters can submit their votes without any fear of identity leakage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Smart grid: To design a smart infrastructure for IoT based smart cities an
    intelligent and automated electricity distribution system is required. In this
    context, the smart grid has revolutionized the energy sector in many ways. A smart
    grid aims to construct an automated power infrastructure that can minimize energy
    waste. Although in the existing literature smart grid utilities are served by
    a central third party who balances users’ electricity load and payments. This
    central authority stores all the information related to electricity generation,
    consumption, and transfer. Nevertheless, because of more time consumption, single
    point of failure, and the increasing number of distributed resources, centralized
    management is not effective. With blockchain, different electric utilities exchange
    energy and make payments without a third party. All involved transactions are
    stored on publically distributed ledger after verification by all network participants.
    All records and energy transactions are stored by every network participant which
    ensures trust and transparency on the network. Simultaneously, because of resistance
    to a single point of failure, DDoS attacks are minimized by integrating blockchain
    with smart grid [[124](bib.xhtml#ch00-bib-124)]. Moreover, the elimination of
    third-party reduces transaction costs. Over and above the interconnection among
    network participants realizes P2P information sharing that achieves automatic
    scheduling. Also, automatic delivery of electricity bills can be implemented with
    blockchain. Hence, blockchain enables self participation, secure payments, transparency
    in allocation and generation of electricity, flexible demand response management,
    P2P energy trading, and real-time pricing data [[125](bib.xhtml#ch00-bib-125)].'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Intelligent transport system: Another potential use case of blockchain technology
    is in developing an intelligent transport system (ITS) or autonomous driving cars.
    With the rapid growth in automobile industry, computing techniques, and devices,
    there is popularity in the growth of ITS. However, information collected by different
    sensing units, Road-side unit (RSU''s) and Base station (BS''s) of ITS is generally
    stored on cloud-based platforms and thus faces security and privacy risks due
    to centralization. ITS needs to secure and authenticate data to make real-time
    decisions. Blockchain provides trustworthy data as the entire network contributes
    to data verification and validation. With its decentralized properties, blockchain
    can promote trusted communication among vehicles and RSU''s in autonomous transportation
    systems. Also, the distributed data verification mechanism ensures an immutable
    and traceable distributed ledger that heps building a secure financial system
    in ITS for P2P money transfer. For electric vehicles (EV''s) energy trading between
    EV''s and charging stations, blockchain provides secure payment handling and transaction
    management [[155](bib.xhtml#ch00-bib-155)]. Similarly, toll payments can be enabled
    with blockchain for standardized collection. Also, ride-sharing services can leverage
    blockchain to make secure payments and to display transparent information [[98](bib.xhtml#ch00-bib-98)].
    Moreover, insurance contracts can be stored on the blockchain network and smart
    contracts can be deployed for taking actions to claim money and to detect any
    kind of contract violation. Additionally, with the smart contract facility, custom
    clearance can be fast and more effective which reduces processing times at checkpoints
    [[99](bib.xhtml#ch00-bib-99)].'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[6.4 Smart Contracts](contents.xhtml#rsec6_4)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Smart contracts are automatic and irreversible applications implemented in a
    distributed environment. Nobody except the developer having full access to the
    code can edit or modify the execution behavior of smart contracts. Smart contracts
    manage digital documents efficiently as they are self-executing and self-verifying
    [[95](bib.xhtml#ch00-bib-95)]. It is actually a piece of code developed to set
    up an agreement between more than one party, having conditions to be met before
    execution. Every party must fulfill their commitment as per their agreement. For
    example, a smart contract for payment on a specific date and time which implies
    on the arrival of a specified date and time the predefined condition is satisfied
    and the payment is transferred to the receivers account automatically. Therefore,
    eliminating the need for a trusted third party. When placed on a blockchain environment,
    it leverages properties (such as- irreversibility, tamperproof, transparency,
    etc.) of blockchain technology. The bytecode of a smart contract is visible to
    everybody on the blockchain network. It is worth noticing that one smart contract
    may needs outcome from another smart contract. Not only payment transactions,
    smart contracts are also used to execute many different processes, such as insurance,
    supply chain management, mortgage loans, real-estate, voting, etc. With the popularity
    of IoT technology, smart contracts are used to enable M2M interaction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Currently, the biggest platform for the smart contract is Ethereum. Solidity
    is an object-oriented, high-level language specifically designed for implementing
    smart contracts. Solidity is inspired by common languages such as- C++, Python,
    and javascript having features including inheritance, libraries, etc. The compiler
    of solidity converts the code into EVM bytecode. The fundamental steps for executing
    a smart contract are:'
  prefs: []
  type: TYPE_NORMAL
- en: After the finalization of contractual terms, programming code is developed specifying
    predefined conditions and outcomes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploy the smart contract to the blockchain network and replicate it among all
    participants of the network.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the terms and conditions are satisfied, the contract is executed and the
    outcome is triggered.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notably, the Bitcoin network was the first one to use the concept of smart contract
    for the blockchain in a way that one node can transfer coins to another node following
    some rules. Additionally, the network participants will only validate transactions
    if some predefined conditions are met. In contrast, Ethereum replaces Bitcoin's
    restrictive language with a language that enables developers to write their own
    code of programs. It implies, with Ethereum developers can write their own program.
  prefs: []
  type: TYPE_NORMAL
- en: '[6.5 Issues with Blockchain](contents.xhtml#rsec6_5)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Blockchain technology has the potential to disrupt a wide range of industries
    but it faces its own set of challenges as shown in [Fig. 6.4](08chap_06.xhtml#fig6_4).
    However, over time literature introduces many improvements to eliminate these
    challenges.
  prefs: []
  type: TYPE_NORMAL
- en: '**Storage**: The foremost problem of blockchain is data storage as every full
    node on the network has a copy of the distributed ledger. Clearly, this increasing
    repository of data is difficult to handle. In this context, mechanism such as-
    sidechains or chilchains should be encouraged in research [[32](bib.xhtml#ch00-bib-32)].'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scalability**: Another problem is the increasing size of public blockchain
    network. With the increase in the number of transactions, the size of blockchain
    becomes large. For example, the current size of Bitcoin blockchain is approximate
    269 GB [[9](bib.xhtml#ch00-bib-9)]. It is important to store all transactions
    occurring on the network for validation purposes. Therefore, the problem of scalability
    prevails in blockchain. Also, consensus protocol effects scalability of the network.
    Additionally, with the increase in network size more resources will be required,
    therefore system''s capacity scale will be reduced. Due to high scalability transaction
    execution in blockchain can become slow. Sharding is a new method to improve scalability
    and to increase transactional throughput. It is a method of partitioning that
    groups subset of participants into smaller networks who are only responsible for
    transactions meant for their shards. This way each shard will have its unique
    set of smart contracts that will be easily executed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**High computation**: The majority of blockchain available in market consumes
    lots of energy as they are based on Bitcoin infrastructure and uses PoW as a consensus
    algorithm. This protocol involves complex mathematical puzzles and demands high
    computation power for verification. However, this computationally intensive task
    is important to generate new blocks in blockchain. Also, this algorithm involves
    consumption of high energy resources. Solving mathematical puzzles consume energy
    equivalent to yearly electricity consumption of Denmark in 2020 [[10](bib.xhtml#ch00-bib-10)].
    Hence, blockchain can prove costly to the environment. In order to solve energy
    challenges faced by PoW many other consensus algorithms including Proof-of-stake
    (PoS), Proof-of-identity (PoI) has been introduced.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lack of standards**: As per a research in [[11](bib.xhtml#ch00-bib-11)],
    one of the reasons blockchain technology is not adopted widely is the lack of
    trust among users. Lack of standards can create disputes among users. Also, lack
    of standardization leads to interoperability issues among large number of nodes
    in blockchain network. There are multiple blockchain projects in the market with
    having different protocols, privacy measures, consensus algorithm, and coding
    languages. Additionally, the lack of uniformity caused by these different projects
    creates consistency issues for security solutions. Moreover, there are many types
    pf blockchain network including public, private, and consortium each having their
    own advantages and disadvantages. Therefore, blockchain of different types can''t
    communicate because of interoperability issues. Standardization of blockchain
    can help in reducing costs and the problem of interoperability. In this context,
    there is a project in the market named [[12](bib.xhtml#ch00-bib-12)] that relies
    on smart bridge architecture to support universal interoperability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Latency**: Transaction validation is another property of distributed consensus.
    The total number of transactions in a block and generation time between blocks
    has a significant effect on confirmation time of transaction. This introduces
    delay or latency in blockchain network while verification and validation of block
    because of large data size and increasing network size. Hence, transactions per
    second are slow for the blockchain network. One solution to solve this problem
    is to use edge computing for mobile blockchain network, especially with the PoW
    consensus mechanism. However, this solution faces difficult to distribute the
    limited edge computing resources among various miners across the different networks.
    Bitcoin-NG [[77](bib.xhtml#ch00-bib-77)], Litecoin [[13](bib.xhtml#ch00-bib-13)],
    Ghost [[176](bib.xhtml#ch00-bib-176)] are some of the variants of Bitcoin network
    designed to improve latency of the network.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Privacy leakage**: Another worth mentioning issue of blockchain is privacy
    leakage. Privacy in blockchain implies that one is able to execute transactions
    without leakage of identity information. As compared, privacy is not supported
    in Bitcoin by default as key characteristic of Bitcoin is transparent. All the
    transactions happening on the network can be checked, tracked, and audited by
    anybody on the network. It is concluded by the authors of [[139](bib.xhtml#ch00-bib-139)],
    that blockchain does not achieve transaction privacy as the value of transaction
    against each public key are publically visible. In addition to this, lightweight
    client has privacy concern as full node has all information about the interested
    wallet address of lightweight client.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To increase data privacy, data of blockchain network can be encrypted. For example,
    the model presented [[122](bib.xhtml#ch00-bib-122)] stores transaction in an encrypted
    form. The compiler present in this model translates code written in encrypted
    form. Similarly, the Enigma project presented in [[1](bib.xhtml#ch00-bib-1)] divided
    data into chunks that are distributed in the network so that no node has access
    to data. Another solution to provide data privacy is to store private and sensitive
    data outside the chain, this mechanism is referred to as off-chain solution. Such
    kind of system is more suitable for highly sensitive data, such as healthcare
    or military application.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Security threats**: Along with privacy concerns, another challenge is security
    threats faced by blockchain network. There are many security attacks that can
    be launched in a blockchain system including sybil attack, routing attack, DoS
    attack, eclipse attack to name a few. Readers can refer to [[148](bib.xhtml#ch00-bib-148)],
    [[133](bib.xhtml#ch00-bib-133)] read further in details about these attacks. However,
    the most popular attack is majority or 51% attack. In the Bitcoin network, any
    network participants having more than 51% computing power can discover nonce power
    faster than others which implies that node has power to decide which block is
    permissible. Mostly the consensus algorithms that are centralized among limited
    users is prone to majority attack. This attack happens if a BC node controls more
    than 51% of the hashing(mining) power. To solve security issues in blockchain,
    data analytics on blockchain data is required with latest machine learning technologies
    [[185](bib.xhtml#ch00-bib-185)], [[63](bib.xhtml#ch00-bib-63)], [[14](bib.xhtml#ch00-bib-14)].'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Anonymity concerns**: Anonymity implies non-identifiability of the sender.
    Nowadays, user authentication with maintaining user anonymity is another requirement
    among users [[39](bib.xhtml#ch00-bib-39)]. By design, blockchain supports anonymity
    as there is no direct link between wallet address and identity of person. Instead
    of using true identity, blockchain is pseudonymous and mostly public key is pseudonym
    for the blockchain network. Unfortunately, this untraceable property motivates
    people for illegal web purchases. However, using public address protects anonymity
    to some extent. Once a person transacts with another person, it reveals its public
    address. As blockchain has the entire history of each wallet, with having public
    address all previous activity, wallet balance etc. can be checked. Additionally,
    any party can intercept a transaction to find out IP address of origin. Clearly,
    this public ledger eases correlating wallet address to identifiable names by simply
    analyzing the transactions. One way to solve this issue is to use Virtual Private
    Network (VPN) technology which uses someone else''s Internet connection. Also,
    using a new Bitcoin address for each transaction can also help a little. For example,
    Monero is another cryptocurrency that uses a different secret address every time
    for a new transaction. Another trending technique for prevention is onion routing
    that obscures IP addresses the node comes online. In this context, Tor [[15](bib.xhtml#ch00-bib-15)]
    is the open-source platform to implement onion routing. This software also helps
    hiding IP address of the node.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 6.4](../images/fig6_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 6.4**'
  prefs: []
  type: TYPE_NORMAL
- en: Issues with blockchain technology.
  prefs: []
  type: TYPE_NORMAL
- en: '[6.5.1 IPFS: A solution to decentralized data stoge problem](contents.xhtml#rsec6_5_1)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As discussed above, storing large files on the blockchain is challenging. In
    context of storage capacity, it is worth to mention Inter Planetary File System
    (IPFS) [[16](bib.xhtml#ch00-bib-16)]. IPFS network is suitable for sharing big
    files that demand large bandwidth to upload/download over the Internet. IPFS is
    a decentralized P2P distributed file system to store shared files. IPFS is an
    efficient way to store as it eliminates duplication of data. In a P2P connected
    IPFS, if one node gets collapsed, the rest of other nodes can serve the demanded
    files. This distributed file system connects all computing devices under same
    file system. IPFS is basically a replacement of Hypertext Transfer Protocol (HTTP)
    used to access content on the Internet. In IPFS, the files on the network are
    hosted on a decentralized server which implies rather than storing the content
    on a single system, the content is hosted on multiple nodes scattered around the
    Internet. IPFS saves around 60% of the network bandwidth. Unlike HTTP that downloads
    a single file from a single machine. IPFS downloads a file in multiple pieces
    simultaneously from multiple decentralized machines.
  prefs: []
  type: TYPE_NORMAL
- en: Rather than referring to files by names as they are stored on IPFS, this system
    refers to files by their cryptographic hash value. The cryptographic hash of the
    file is served as an address as well. This hash signifies a root object and all
    other objects that can be found in the path. In particular, the concept of content
    addressing is used at HTTP layer which implies rather than referring files by
    location (the location-based reference model supports centralization), it is addressed
    by any representation of content itself. To store files, IPFS relies on a distributed
    hash table (DHT). DHT is dictionary like interface to data that is on nodes that
    are distributed across the network. Nodes on the network use a mechanism called
    bitswamp to exchange data between nodes.
  prefs: []
  type: TYPE_NORMAL
- en: When a new file is added to the IPFS network, IPFS generates a multihash address
    of the file using its content and node ID. To access a particular file, IPFS interrogates
    network for file having matching hash. After computing the cryptographic hash
    of the file, ask the peer of the network having content matched to that hash.
    Next, the content is downloaded directly from the node having the required data.
    Hence any node on the IPFS network having the hash of the content can look for
    a specific file via its content ID and node matching that IP will serve it.
  prefs: []
  type: TYPE_NORMAL
- en: The IPFS model can be integrated with blockchain model, such as Bitcoin and
    Ethereum as both of these systems have similar structures. Rather than storing
    with actual values on the blockchain, IPFS simply stores hashes of files on blockchain.
    Further, using these hashes actual location of files can be found.
  prefs: []
  type: TYPE_NORMAL
- en: '[Fig. 6.5](08chap_06.xhtml#fig6_5) presents a data sharing mode using IPFS
    as discussed by authors of [[152](bib.xhtml#ch00-bib-152)]. At first, owner of
    the file uploads it on IPFS including metadata of the file. Secondly, the hash
    of the file is generated by IPFS and returned back to owner. At third step, owner
    looks for nodes in the smart contract that provide encryption/decryption services.
    Next, the owner divides the IPFS hash into *k* pieces, encrypts them, and finally
    store them on the blockchain network.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.5](../images/fig6_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 6.5**'
  prefs: []
  type: TYPE_NORMAL
- en: Data sharing on IPFS.
  prefs: []
  type: TYPE_NORMAL
- en: '[6.6 Python Implementation of Blockchain](contents.xhtml#rsec6_6)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have used the Scientific Python Development Environment (Spyder) included
    with anaconda to implement blockchain. It enables editing, debugging, and interactive
    testing. Along with this, we have used Flash and Postman application to successfully
    create a blockchain network. Flask is a web framework for building a web application
    and it works with no dependencies to external libraries. To install flask use
    command: <math alttext="" display="inline"><mrow><mi>p</mi><mi>i</mi><mi>p</mi><mi>i</mi><mi>n</mi><mi>s</mi><mi>t</mi><mi>a</mi><mi>l</mi><mi>l</mi><mi>F</mi><mi>l</mi><mi>a</mi><mi>s</mi><mi>k</mi><mo>=</mo><mo>=</mo><mn>0.12.2</mn></mrow></math>
    Postman is an HTTP client that is used to test application program interface (API''s)
    by sending requests to web server and then getting a response back. It provides
    an easy and user-friendly interface and allows anyone to join blockchain network
    online using servers.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/list6_1.jpg)![](../images/list6_2a.jpg)![](../images/list6_2b.jpg)![](../images/list6_3.jpg)![](../images/list6_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, we will make function to check whether a block is valid or not. To check
    block validity, two main points need to be checked that are
  prefs: []
  type: TYPE_NORMAL
- en: Every block's proof should have 4 leading zeros in the cryptographic hash.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Previous hash field should have exactly same value as previous hash of the block.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../images/list6_5.jpg)![](../images/list6_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The blockchain class has been created. Also, we will use flask to create a web
    application to be able to interact with the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: First, we will create flask based web application by creating an object of flask
    class. Actually we will interact with the blockchain through flask.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we will create an instance of blockchain class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we will make a get request to mine a block by solving PoW problem.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we will again make a get request to get a blockchain.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../images/list6_7.jpg)![](../images/list6_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, we will mine a new block by making a new request with flask based application.
    For this, route decorator will be used to inform flask what Uniform Resource Locator
    (URL) should trigger our function to mine a block. With URL, we have to specify
    other arguments which is method of request. It could be GET or POST. GET will
    get some information and POST will create something, for example, transaction.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/list6_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, we will create second GET request to display full blockchain in user interface
    postman application.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/list6_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, now we will run the blockchain application from our flask application.
    We will use postman to make request of mining block and get chain requests to
    check the actual state of the chain. To achieve this, from app object of flask
    class, we will call run method which takes two arguments, i.e., host and the port.
    From flask documentation, we can check this application is running on http://127.0.0.1.5000/.
    This URL will be entered in postman. Also, it is specified in documentation, that
    to make server publically available set host=0.0.0.0 and port as 5000.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/list6_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After writing the code, execute the code on the editor. From [Fig 6.6](08chap_06.xhtml#fig6_6)
    it can be seen that application is successfully running on http:\ \0.0.0.0\. Now,
    we will use postman application to make GET request. In postman application, we
    have to enter the request URL and selecting the type of request as GET as shown
    in [Fig. 6.7](08chap_06.xhtml#fig6_7). To mine block we have to use mine_block
    request and to get blockchain state, we have to use get_chain request.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.6](../images/fig6_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 6.6**'
  prefs: []
  type: TYPE_NORMAL
- en: Blockchain application.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.7](../images/fig6_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 6.7**'
  prefs: []
  type: TYPE_NORMAL
- en: Blockchain application illustration with postman.
  prefs: []
  type: TYPE_NORMAL
- en: First we will use get_chain request and it can be seen that there is only one
    block in network, i.e., genesis block as we have not mined any block. Refer to
    [Fig. 6.8](08chap_06.xhtml#fig6_8). This genesis block has index 1, previous_hash=0
    and proof as 1 as coded.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.8](../images/fig6_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 6.8**'
  prefs: []
  type: TYPE_NORMAL
- en: Blockchain application illustration with postman.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will mine the first block of the network with index 2 as presented in
    [Fig. 6.9](08chap_06.xhtml#fig6_9). This block has proof value of 533 which implies
    that cryptography hash of the encoded string of <math alttext="" display="inline"><mrow><msup><mrow><mn>533</mn></mrow><mn>2</mn></msup><mo>−</mo><msup><mn>1</mn><mn>2</mn></msup></mrow></math>
    starts with four leading zeros.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.9](../images/fig6_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 6.9**'
  prefs: []
  type: TYPE_NORMAL
- en: Blockchain block mining illustration with postman.
  prefs: []
  type: TYPE_NORMAL
- en: After mining first bock, lets check the status of blockchain with get_chain
    request. Refer [Fig. 6.10](08chap_06.xhtml#fig6_10).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.10](../images/fig6_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 6.10**'
  prefs: []
  type: TYPE_NORMAL
- en: Blockchain get_chain illustration with postman.
  prefs: []
  type: TYPE_NORMAL
- en: Activity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Multiple Choice Questions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What is full form for P2P?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Product-to-product
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Peer-to-peer
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Pear-to-product
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Product-to-peer
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following defines a miner?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A type of blockchain
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A person who encrypts the text
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A computer to store data
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A person who validates blockchain transactions and stores them on global ledger
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which term is used to define a blockchain split?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fork
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Mining
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Nonce
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Genesis
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What is usage of nonce?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To act as hashing function
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: To prevent double spending
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: To prevent 51% attack
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: None of the above
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What is genesis block?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The very first block of blockchain
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The largest size block of blockchain
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The smallest size block of blockchain
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The block with having maximum number of transaction
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What empowers Ethereum virtual machine?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bitcoin
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: CoinDesk
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Ether
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Gas
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What is PoW?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A transaction verification protocol
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A hashing algorithm
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: An encryption algorithm
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A certificate needed to install blockchain
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which among the following is used to store Bitcoin?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pocket
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Box
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Wallet
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Bank
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following constitute a block?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A hash pointer
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Nonce value
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Transactions
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: All of these
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Where is Bitcoin's central server located?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: India
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Washington
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: London
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: None of these
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following industry can use blockchain technology?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Healthcare
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Smart grid
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: P2P money exchange
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: All of these
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 1\. b  2\. d  3\. a  4\. b  5\. a  6\. d  7\. a  8\. c  9\. d  10\. d  11\.
    d
  prefs: []
  type: TYPE_NORMAL
- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '[7](contents.xhtml#rchapter7)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Verification and Validation Methods Used by Blockchain](contents.xhtml#rchapter7)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '[7.1 Consensus Mechanism](contents.xhtml#rsec7_1)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Blockchain operates as a self-regulating system without involving any centralized
    authority. Due to decentralized and distributed nature, blockchain faces the byzantine
    general problem [[129](bib.xhtml#ch00-bib-129)]. It is a problem of consensus
    making in a decentralized environment where communication channels cannot be trusted.
    Therefore, the blockchain network should work with reliability even in the presence
    of dishonest nodes. Moreover, in the absence of central authority, someone has
    to ensure validity and verification of blocks. The consensus mechanism is a process
    to reach a common agreement in a decentralized framework. The consensus mechanism
    makes sure that all nodes agree on a single state of shared block otherwise network
    has to face Byzantine general problem [[48](bib.xhtml#ch00-bib-48)]. It ensures
    reliability, correct operation, and fault tolerance even in the presence of faulty
    nodes. A consensus has to be deterministic, synchronized, and energy sufficient.
    [Fig. 7.1](09chap_07.xhtml#fig7_1) presents some of the requirements of the efficient
    consensus algorithm. However, achieving consensus in a distributed and decentralized
    environment is difficult.tcolorbox
  prefs: []
  type: TYPE_NORMAL
- en: '**Key point** Consensus algorithm for public blockchain has low scalability
    but it achieves low latency and high throughput whereas private blockchain consensus
    algorithm has high scalability.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1](../images/fig7_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 7.1**'
  prefs: []
  type: TYPE_NORMAL
- en: Characteristics of a consensus algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Next, different consensus algorithms are discussed. The tabular comparison between
    these discussed consensus is discussed in [Tables 7.1](#tab7_1) and [7.2](#tab7_2).
  prefs: []
  type: TYPE_NORMAL
- en: '**TABLE 7.1**'
  prefs: []
  type: TYPE_NORMAL
- en: Comparison of different consensus algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 7.1](../images/tab7_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TABLE 7.2**'
  prefs: []
  type: TYPE_NORMAL
- en: Comparison of different consensus algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 7.2](../images/tab7_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[7.1.1 Proof-of-Work](contents.xhtml#rsec7_1_1)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is the first and most popular consensus algorithm used by blockchain network
    to achieve Byzantine fault tolerance. Originally, Proof-of-Work (PoW) was designed
    for public blockchain but in many existing research, PoW has been used by private
    and consortium networks. The foundation of PoW is a belief that if a node is capable
    enough to perform difficult cryptography calculations, then it is unlikely that
    the node will attack the network. The benefit of proof related consensus algorithm
    is that there is no requirement to wait for approval from other network members
    to mine the block. To add a block to the blockchain network, each miner tries
    to find a particular nonce value to generate the SHA hash of the block specified
    in the block header. To solve this kind of cryptographic puzzle, the value of
    nonce is incremented after every round in order to achieve a hash value equal
    to or lower than the target value defined for that block. In particular, block
    hash should have certain zeros at the beginning also called difficulty of the
    system. After mining, miners will broadcast the block to the network. If majority
    of the network members will accept the block only then it will be successfully
    appended to the blockchain. If a miner or group of miners controls 51% of the
    hashing power then it leads to 51% attack. Clearly, with PoW mechanism, an abundance
    of energy gets wasted as multiple miners compete to mine a block simultaneously
    and at last only one block gets accepted by the network.
  prefs: []
  type: TYPE_NORMAL
- en: '[7.1.2 Proof-of-Stake](contents.xhtml#rsec7_1_2)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Proof-of-Stake (PoS) was specially designed to solve the issue of high energy
    consumption by PoW. PoS demands less energy over PoW as fewer CPU computations
    are involved while mining blocks. Rather than relying on external investment like
    PoW, PoS only uses internal investment (that is cryptocurrency). Although like
    PoW, PoS is also designed for permissionless blockchain. However, in PoS, miners
    are referred to as validators and blocks are forged not mined. It is based on
    the foundation that a node on a network with more participation and cryptocoins
    is less likely to attack the network. To become validators, nodes have to deposit
    some cryptocoins as stake. The probability that a stakeholder can append a new
    block to the chain is proportional to the amount of stake in his/her account.
    PoS provides security to the network due to the fact that members’ stakes are
    at risk. Unfortunately, with this approach rich gets richer as validators receive
    incentives for validating a transaction which increases the possibility of the
    same node getting selected as validator again and again. Moreover, a node only
    with sufficient amount of stakes can attack the system by investing stakes in
    comparison to PoW that involves the investment of electricity, CPU computations
    and timing. Clearly, to launch 51% attack, validators have to control atleast
    51% of total digital currency existing in the network which makes the PoS attack
    more costly. Obviously, not successful attacks would result in large financial
    losses. The first use case of PoS is PPCoin where participants with oldest and
    more number of coins posses more possibility to mine the block (this is also called
    coin age based selection). Here, stake is the number of coins multiplied by holding
    period [[119](bib.xhtml#ch00-bib-119)].
  prefs: []
  type: TYPE_NORMAL
- en: '[7.1.3 Delegated Proof-of-Stake](contents.xhtml#rsec7_1_3)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is also an alternative to PoW as PoW demands lots of external resources.
    In contrast, Delegated Proof-of-Stake (DPoS) demands fewer resources and is more
    eco-friendly by design. A DPoS is based on a voting system where stakeholders
    vote for a few delegates (witnesses) who will be responsible for securing the
    network on their behalf. Here miners are referred to as witnesses and they have
    the responsibility to successfully create a new block. The voting power of a node
    is proportional to the number of cryptocoins each user holds. The witnesses are
    elected based on reputation which is decided by the number of stakes each witness
    is holding [[130](bib.xhtml#ch00-bib-130)]. The top *m* witnesses with more number
    of votes participate in the decision making of blockchain network. The value *m*
    is chosen such that atleast 50% of the voters deduce that there is enough decentralization
    [[17](bib.xhtml#ch00-bib-17)]. For validating a block, witnesses get some benefits.
    The elected witnesses validate blocks one by one. In case a witness fails to validate
    in a fixed time, then the block is assigned to the next witness in the queue and
    a new witness is selected to replace the careless one. For 51% attack to be launched,
    the attacker has to control 51% of the selected witnesses. Notably, more participation
    of stakeholders in selecting witnesses, harder it becomes for an attacker to launch
    attack.
  prefs: []
  type: TYPE_NORMAL
- en: '[7.1.4 Practical Byzantine Fault Tolerance](contents.xhtml#rsec7_1_4)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Byzantine fault tolerance is described as the capability of a distributed system
    to reach an agreement even in the presence of an attacker node in the network
    sending out misleading information. Practical Byzantine Fault Tolerance (PBFT)
    was designed to optimize BFT for implementation in blockchain network. Practical
    Byzantine Fault Tolerance (PBFT) [[59](bib.xhtml#ch00-bib-59)] was designed to
    solve the Byzantine Generals problem [[129](bib.xhtml#ch00-bib-129)] for the asynchronous
    environment. It is based on assumption that less than 30% of total nodes are malicious
    in network. In other words, a minimum of <math alttext="" display="inline"><mrow><mn>3</mn><mi>f</mi><mo>+</mo><mn>1</mn></mrow></math>
    nodes needs to work, where *f* is the number of faulty replicas. PBFT-based blockchain
    can tolerate atmost 33% of malicious nodes. The process of PBFT consists of 3
    phases which includes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pre-prepare: For each request, a leader node broadcasts pre-prepare message
    to ask for value that other nodes of the network wants to commit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Prepare: Nodes broadcast a prepare message that specifies the value they are
    about to commit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Commit: Leader node confirms the request if <math alttext="" display="inline"><mrow><mn>2</mn><mi>f</mi><mo>+</mo><mn>1</mn></mrow></math>
    nodes agree in the previous phase.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, with an priori list of participants, consensus can be reached with
    low transaction latency and low network communication overhead in PBFT. Moreover,
    limited scalability does not make it suitable for IoT applications [[107](bib.xhtml#ch00-bib-107)].
  prefs: []
  type: TYPE_NORMAL
- en: '[7.1.5 Proof-of-Authority](contents.xhtml#rsec7_1_5)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Proof-of-Authority (PoA) [[18](bib.xhtml#ch00-bib-18)] is an optimized variant
    of the PoS model where authorities on the network stake their identities for fair
    operation of the network. Parity [[19](bib.xhtml#ch00-bib-19)] and Geth [[20](bib.xhtml#ch00-bib-20)]
    have implemented PoA. PoA assumes that authorities are honest and trusted. By
    staking identities, validators do not wish to get associated with a negative reputation.
    Instead of appointing one authority, a set of authorities is used to reach an
    agreement about state of the network and the final decision has to be validated
    by the authorities. The authorities rely on mining rotation approach [[36](bib.xhtml#ch00-bib-36)]
    when a block is created. It is based on the assumption that with *N* authorities,
    atleast <math alttext="" display="inline"><mrow><mfrac><mi>N</mi><mn>2</mn></mfrac><mo>+</mo><mn>1</mn></mrow></math>
    should be trustworthy nodes. The PoA algorithm is designed for both permissioned
    and permitionless networks. However, the authors of [[68](bib.xhtml#ch00-bib-68)]
    demonstrated that PoA is not applicable for permissioned blockchain because it
    faces consistency issues. Unlike PBFT, PoA involves few exchange of messages in
    the network which improves better performance. However, the usage of a centralized
    authority limits the usage of PoA in some applications.
  prefs: []
  type: TYPE_NORMAL
- en: '[7.1.6 Proof-of-Capacity](contents.xhtml#rsec7_1_6)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unlike PoW, in order to add a new block in Proof-of-Capacity (PoC) storage has
    to be dedicated instead of computation with CPU's and GPU's [[75](bib.xhtml#ch00-bib-75)].
    With this consensus, a huge amount of energy can be saved. PoC is also referred
    to as condensed proof of work because all computations are performed once in advance
    by the verifier even before the mining begins and the results of this work (plot
    files) are cached on hard disk. The process of plotting creates a nonce value
    by using the shabal hashing mechanism. The mining process only needs to read the
    plot file. If the storage medium contains a quick solution to a recently generated
    block puzzle, the account of the verifier is incentivized. However, the size of
    the hard drive determines the time taken to create unique plot files. Unlike PoS,
    everyone on the network has a fair chance of mining because storage medium is
    easily available at cheaper prices.
  prefs: []
  type: TYPE_NORMAL
- en: '[7.1.7 Proof-of-Burn](contents.xhtml#rsec7_1_7)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Proof-of-Burn (PoB) [[21](bib.xhtml#ch00-bib-21)] was designed to solve the
    problem of high energy consumption in PoW and to reduce dependency on hardware
    resources. In PoB, miners invest coins to an eater address that is a unspendable
    address (at this address the coins become useless and inaccessible). The eater
    address does not have any private key assigned to it which implies that only coins
    can be sent to this address, but coins sent to the eater address can't be used
    or spent again. By burning or investing coins, a miners represents his/her readiness
    to bear short-term losses. While burning coins, a transaction is executed for
    the eater address and with this transaction, a burn hash is calculated. Burn hashes
    are computed by multiplying a multiplier with a internal hash. If the value of
    the burn hash is smaller than some predefined value, then the block from PoB is
    generated. The more a miner burns cryptocurrency, the higher is the probability
    of mining. After successfully mining a block, miners are rewarded. However, this
    scheme is costly from an individual miner perspective.
  prefs: []
  type: TYPE_NORMAL
- en: '[7.1.8 Proof-of-Luck](contents.xhtml#rsec7_1_8)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Proof-of-Luck (PoL) [[142](bib.xhtml#ch00-bib-142)]uses a Trusted Execution
    Environment (TEE) for correct processing of critical operations. The idea behind
    PoL is that every node on the network requests a random number (luck value) from
    TEE. The higher the luck value, the higher are the chances to get selected as
    a miner node. Similar to PoW, nodes on the network receive transaction and miner
    nodes compete to commit pending transactions in a block having the luck value
    generated by the TEE. Next, nodes broadcast the generated block to the network
    and the lucky block gets added to the network. Here, an assumption is made that
    less than half of nodes are faulty. PoL also requires the installation of a specialized
    hardware such as- SGX.
  prefs: []
  type: TYPE_NORMAL
- en: '[7.2 Simplified Payment Verification](contents.xhtml#rsec7_2)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Notably, the blockchain network generates the bulk of data which makes it difficult
    for resource-constrained devices to store all the data on their devices. This
    problem is specifically faced by mobile devices. The increasing size of the blockchain
    is clearly a concern for memory-constrained devices IoT devices and Bitcoin mobile
    users. As reported by [[22](bib.xhtml#ch00-bib-22)], the total size of the Bitcoin
    blockchain is 270.11 GB by the end of March 2020 and clearly, this data will rise
    in the coming years.
  prefs: []
  type: TYPE_NORMAL
- en: To address this issue, blockchain supports two types of clients in a blockchain
    network, i.e., lightweight client and full client. A full node is a node of blockchain
    network which follows all rules of blockchain whereas a lightweight node is the
    one referencing trusted full nodes. Lightweight clients are also referred to as
    thin clients. In contrast to a full client, a lightweight client does not need
    to download the entire blockchain network. Nevertheless, the lightweight client
    downloads block header of all the blocks. Clearly, it results in less space and
    bandwidth consumption as no actual transactions are getting downloaded. However,
    these nodes take part in simple network operation including confirming balance,
    receiving transaction history, checking the existence of a transaction in a block,
    verification of block difficulty and downloading block headers, and to perform
    such operations these clients are dependent on the full client. These clients
    refer to one or more full client for validation, verification of transactions,
    and mining tasks. Moreover, these clients do not receive all transactions that
    are broadcasted in the network. Rather they receive some filtered transactions
    in which they are interested in from the connected full client. Over and above,
    a lightweight client can only execute limited verification compared to a full
    client. If a lightweight node wants to verify the inclusion of a transaction in
    any block, it will request access to Merkle bunch from the full node. Next, the
    lightweight node will calculate the Merkle hash value with the received hash value
    from the full node and compares it with the Merkle hash value that is downloaded
    from the block header. This whole process of confirming inclusion of a particular
    transaction to the blockchain without actually downloading the entire blockchain
    is referred to as Simplified payment verification (SPV). SPV process is however
    associated with security and privacy issues. Notably, any attacker can cheat lightweight
    node with fake transactions. Although this problem can be solved by connecting
    to different full nodes and ensuring that everybody agrees on same chain of blocks.tcolorbox
  prefs: []
  type: TYPE_NORMAL
- en: '**Key point** To solve scalability problem, Satoshi has described the process
    of reclaiming disk space that mentions eliminating unnecessary old transactions
    from the blocks. However, before discarding a spend transaction to save disc space,
    make sure that the transaction in a coin is buried under enough blocks. To achieve
    this without disturbing block hash, only the Merkle root hash is included in the
    block.'
  prefs: []
  type: TYPE_NORMAL
- en: '[7.3 Block Validation](contents.xhtml#rsec7_3)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Even after the mining process, nodes of the network validates the block before
    it is added to the main blockchain. The following points should be checked before
    inclusion of block in a blockchain:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Syntactic structure: It is a foremost validation that makes sure that block
    should be in a syntactic structure defined for that blockchain network.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Timestamp validation: Blocks are considered valid if timestamp value is greater
    than the median timestamp of immediate previous 11 blocks and less than 2+ network
    adjusted time where network adjusted time is the median of timestamp values returned
    by all connected peers to the validator node.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Transaction: There should be at least one transaction present in that block.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Merkle hash: Merkle hash is computed from transactions in the received block
    and is matched against Merkle hash present in the block header. Hashes are actually
    considered to be the central security element of a blockchain network.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Previous hash: Verify that the current block should contain the hash of immediate
    previous block.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Target: Hash of the bock should have value less than the target hash value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[7.4 Transaction Validation](contents.xhtml#rsec7_4)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Transaction broadcasted in the network needs to be validated to ensure that
    coin is spent by the authorised owner and not by any randomized user. Transaction
    validation rules are mentioned as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Empty: This property ensures that neither of the input and output transactions
    is empty.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Structure: The defined syntactic structure of the transaction is correct.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Size: The total size of the transaction should be less than or equal to the
    maximum block size.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Range: The output value of each transaction must be in the legal money range.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Insufficient coins: Transaction should be rejected if the total sum of input
    values is less than the sum of output values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Low transaction fees: Reject the transaction if transaction fees is too low
    than the defined transaction fees.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Public key: Verify that public key accepts for each input.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Double spending: For every input, if there exist referenced output in any transaction
    in the pool, the transaction will be rejected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'No output transaction: For every input, if there does not exist any referenced
    output, reject this transaction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Orphan transaction: For every input, probe the main branch and transaction
    pool to search the referenced output. If output transaction does not exist for
    any input, that transaction is an orphan transaction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Activity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Multiple Choice Questions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What is the purpose of consensus algorithm?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To make sure all node agree on single state
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: To solve Byzantine general problem
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: To ensure fault tolerance in presence of faulty nodes
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: All of these
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What is biggest challenge of PoW?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: High computational power required
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A single miner can't perform mining
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A miner can't mine a single block at one time
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: None of these
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: PoS stands for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Proof-of-Stake
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Proof-of-Standard
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Proof-of-source
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Proof of-secondary
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: PPCoin cryptocurrency uses which consensus algorithm?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: PoW
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: PoA
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: PoB
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: PoS
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: How DPoS algorithm selects a miner?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Voting system
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The person with more electricity power
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The person with more computers
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: None of these
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the disadvantage of PBFT consensus algorithm?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Limited reliability
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Limited scalability
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: High computational power required
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: No fault tolerance
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In PoB miners invest coins to an ether address.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'False'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Parity uses which consensus algorithm?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: PoB
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: PoA
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: PoW
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: PoS
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 1\. d  2\. a  3\. a  4\. d  5\. a  6\. b  7\. a  8\. b
  prefs: []
  type: TYPE_NORMAL
- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '[8](contents.xhtml#rchapter8)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Data Structures for Blockchain](contents.xhtml#rchapter8)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '[8.1 Data Structures for Blockchain](contents.xhtml#rsec8_1)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section will discuss the important data structures used by blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hash pointers: A pointer in data structures is used to pint address of value
    stored in memory. The process of fetching the value stored at any memory location
    is called dereferencing the pointer (Refer [Fig. 8.1](10chap_08.xhtml#fig8_1)).
    Additionally, a hash pointer is a type of pointer that points to address of hash
    value in order to make it tamper proof. Particularly, rather than just consisting
    of address of immediate previous block, it also has the hash of data in the previous
    block. Notably, hash pointers are used to construct a linked list called blockchain.
    In blockchain, hash pointer points to the hash of data stored in the immediate
    previous block. Hence, any modification in the chain would be detected with the
    hash pointers. Suppose an malicious person tampers with a block of blockchain,
    lets say block 10\. With change in content of block 10, hash of this block also
    got changed (collision free property of hash). To bluff others, he also has to
    change hash pointers of next block, i.e., block 11\. Furthermore hash pointer
    of block 12 also has to change and so on and so forth. Refer [Fig. 8.2](10chap_08.xhtml#fig8_2)
    for illustration of hash pointer chain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 8.1](../images/fig8_1.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**FIGURE 8.1**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Illustration of hash pointer.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.2](../images/fig8_2.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**FIGURE 8.2**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Illustration of hash pointer chain.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Key point** Hash pointers can be used in any pointer based data structures
    that is without any cycles. If cycles are present in data structures then we won''t
    be able to make all the hashes match up. Clearly, in a structure with cycles,
    there is no end that we can start with and compute back from.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Linked list: Linked list is one of the most popular data structures. Particularly,
    it is a sequence of blocks containing some information that is linked to immediate
    next block through a pointer. The pointer in each block contains the address of
    next block. The last block has a null pointer which implies it is not pointing
    to anything. A blockchain is basically a linked list containing data and a hash
    pointer pointing to previous block.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Merkle tree: Another important data structure constructed using hash pointer
    is a binary tree. In particular, this binary tree linked with hash pointer is
    referred to as Merkle tree. This is the main foundation of blockchain concepts.
    Merkle tree also called hash tree is named after Ralph Merkle [[140](bib.xhtml#ch00-bib-140)].
    It is basically a tree structure where the nodes at leaf level contain the hash
    of the document and every intermediate node contains the hash of left and a right
    child. As it is presented in [Fig. 8.3](10chap_08.xhtml#fig8_3), there are 8 transactions,
    i.e., t1, t2,…………,t8\. Leaf nodes of the Merkle tree contain the direct hash of
    these transactions and then level 1 has intermediate nodes with hash value of
    its left and right child (,i.e., obtained hashes are again paired to calculate
    the hash for next level). This hash will be recursively calculated till a single
    root hash is obtained. It implies that any change in the transaction will be reflected
    in the hash value at every level including root hash value including root hash
    value. So, with a single hash value, i.e., root hash the transactions, the transactions
    can be collectively stored without fear of alteration in a block. Therefore, the
    Merkle hash tree makes sure that data stored on the blockchain remains undamaged
    and unaltered. In other words, Merkle hash preserves the integrity of the document.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 8.3](../images/fig8_3.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**FIGURE 8.3**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Structure of Merkle tree.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Key point** To compute Merkle hash, Bitcoin uses SHA-256 hash.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Tries: Tries is a ordered tree data structure to maintain set of strings. If
    two strings have a common prefix then they will have same ancestor in trie. Trie
    is an ideal data structure for storing dictionary. Also, it is used for encoding
    and decoding. Notably this is not similar to a binary tree whereas it is a N-Ary
    tree. Infact, tries support better searching than binary search tree and hash
    tables. Hash tables does not support prefix based search. Moreover, with tries
    it is easy to print all words in alphabetical order.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A trie stores key-value pair where key is the path in the tree to reach its
    corresponding value. With tries, there is no restriction on number of children
    a node can have. However, all nodes descendants have a common prefix. In particular,
    each node can have up to 26 children. Each node's children are ordered alphabetically.
    It can thought of as a node that has a array of 26 size sitting inside. However,
    a better option is to have a linked list at each node to save space.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Unfortunately, tries require large memory for storing strings as for each node
    there are further many pointers. Also, a trie prooves inefficient if there is
    long key and o other key shares a common prefix. A standard trie take <math alttext=""
    display="inline"><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>W</mi><mo stretchy="false">)</mo></mrow></math>
    space, where *W* is the total size of strings in a set. Insertion, deletion, and
    search operation of a trie takes <math alttext="" display="inline"><mrow><mi>O</mi><mo
    stretchy="false">(</mo><mi>l</mi><mo>*</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></math>
    where, *l* is average length of word and *n* is total number of words whereas
    the worst case runtime complexity for creating a trie is <math alttext="" display="inline"><mrow><mi>O</mi><mo
    stretchy="false">(</mo><mi>m</mi><mo>*</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></math>
    where, *m* is the longest word in the string and n is the total number number
    of words. For example, the trie data structure for set of string S=bear, bell,
    bid, bull, buy, sell, stock, stop is represented in [Fig. 8.4](10chap_08.xhtml#fig8_4).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.4](../images/fig8_4.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**FIGURE 8.4**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Illustration of trie data structure.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Patricia tree: Patricia stands for practical algorithm to retrieve information
    coded in alphanumeric. It is also based on fundamental that nodes with same prefix
    shares the same path (it is also called prefix tree). However, it requires low
    memory than trie data structure. It is actually a compact representation of a
    trie in which nodes having single child is merged with its parents. In other words,
    Patricia tree is similar to radix tree with the value of radix equal to 2\. In
    particular, Ethereum blockchain is based on Merkle-Patricia tree, which is a tree
    having root node that contains the hash value of whole data structures. [Fig.
    8.5](10chap_08.xhtml#fig8_5) represents the patricia tree for string S= bear,
    bell, bid, bull, buy, sell, stock, stop.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 8.5](../images/fig8_5.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**FIGURE 8.5**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Illustration of patricia tree data structure.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Merkle Patricia trie: This data structure is a combination of Merkle tree and
    Patricia tree. Merkle tree is used to maintain data integrity whereas patricia
    tree in particular enables fast searching of information. These Merkle patricia
    also shows some form of verification and tamperproofing. Ethereum blockchain cryptocurrency
    uses Merkle patricia tree to store transaction and world state. Notably, Ethereum
    is quite different to Bitcoin as it uses smart contracts which keeps on updating
    everytime. Additionally, Ethereum rather than using one Merkle tree, it uses 3
    different Merkle tree to attain global state and to impose extra ability to query
    data within blockchain which are described as:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'stateRoot: which specifies the state of the block.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'transactionRoot: which specifies transaction hash in the block.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'receiptRoot: which specify the amount of gas used in a block.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In Ethereum all information of state is stored in key value pair. Keys are
    mainly string values that refers to search index. For example, account address
    is the key and balance is the value corresponding to the key. Merkle Patricia
    tree introduces 4 types of nodes which are described as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Empty node: These are simply blank nodes.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Leaf node: It is the end node that signifies end of path in a tree. Leaf node
    will not have any further child and it always contains some value corresponding
    to a key. It is made up of two items, first corresponding to a suffix and second
    to any value.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Branch node: It is a node having more than one branch. It is a 17 item structure
    where first 16 items are hexadecimal value (0—F) and 17 th items corresponds to
    a terminator node.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Extension node: It is a type of branch node but with one child. It is an optimized
    version of the branch node. It is a two item node where first portion signifies
    key part with size greater than one node and shared by atleast two different keys.
    Second part corresponds to a pointer to branch node.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Notably, to differentiate between leaf node and extension node, there is a concept
    of nibble. A nibble is added to the beginning of the key to differentiate both
    parity (even/odd length key) and terminator status (node is leaf or extension
    node). The lower significant bit signifies parity while next lowest tells terminator
    status. Moreover, if key length is even, an extra nibble is added to attain overall
    evenness. [Fig. 8.6](10chap_08.xhtml#fig8_6) shows illustration of Merkle Patricia
    tree.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.6](../images/fig8_6.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**FIGURE 8.6**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Illustration of Merkle Patricia tree data structure.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Binary heap: Binary heap comes under the category of a binary tree. Particularly,
    binary heap is a complete binary tree which implies each level except possibly
    the lowest one are completely filled and the lowest level is always filled from
    the left. Moreover, a binary heap is categorized as either a max-heap or a min
    heap as per the ordering property. In a max-heap, the key value stored in each
    node must be greater than equal to the key value in the node''s children. In contrast,
    in a min-heap, the key value stored in each node must be less than or equal to
    key value in the node''s children. Examples of min-heap and max-heap data structure
    is represented in [Figs. 8.7](10chap_08.xhtml#fig8_7) and [8.8](10chap_08.xhtml#fig8_8).
    Ethereum blockchain uses binary heap data structure to solve the block-gas-limit
    and iteration problem of Ethereum. Ethereum gas is the price for executing certain
    operations in Ethereum blockchain. For instance, all Ethereum transactions are
    paid by the sender of the transaction. In such cases, intentionally an attacker
    can consume more gas by running arbitrary smart contracts for an incoming transaction.
    Besides, when users of Ethereum network insert data in a smart contract, it can
    result in too much gas cost to iterate through. In particular, if a developer
    relies on array data structure, an attacker can fill the array to the mark where
    iterating via it can result in more gas cost than it should be used for a single
    transaction to execute. Clearly, a binary heap resolves this issue as this data
    structure does not demand iteration via all elements of the tree, rather it only
    iterates through tree''s height. Moreover, the self-balancing property of max
    heap preserves degenerating a tree which leads to *O(log n)* cost even for the
    worst case (for a total of *n* elements).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 8.7](../images/fig8_7.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**FIGURE 8.7**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Example of max-heap.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.8](../images/fig8_8.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**FIGURE 8.8**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Example of min-heap.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Activity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Multiple Choice Questions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Which of the following data structure is used in blockchain?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Merkle hash tree
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Tries
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Binary tree
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: All of the above
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the main purpose of using hash pointers for connectivity in blockchain?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To prevent modifications in block
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: To encrypt block
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: To decrypt block
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: To find nonce value of block
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which hashing algorithm is used by Bitcoin to compute Merkle hash?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: MD4
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: MD5
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: SHA-256
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: All of these
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the total space taken by trie data structure with *w* as total size
    of string in a set?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*O(w)*'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '*O(w2)*'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '*O(log w)*'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: None of these
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What is other name for Patricia tree?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Prefix tree
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Suffix tree
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Max heap
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Binary heap
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the main purpose of using merkle patricia tree?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To prevent modifications in block
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: To encrypt block
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: To decrypt block
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: To find nonce value of block
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following node is a type of Merkle patricia tree?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Leaf node
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Branch node
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Extension node
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: All of these
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Why does Ethereum uses binary heap data structure?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To solve block gas limit and iteration problem
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: To solve PoS problem
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: To authenticate nodes on network
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: To generate more ethers
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Hash pointers can be used with any data structures with cycles?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'False'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the main purpose of using Merkle hash tree?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To preserve integrity of block
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: To decrypt a block
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: To encrypt a block
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: To find nonce value
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 1\. d  2\. a  3\. c  4\. a  5\. a  6\. a  7\. d  8\. a  9\. b  10\. a
  prefs: []
  type: TYPE_NORMAL
