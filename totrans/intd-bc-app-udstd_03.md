© 作者（或作者），在 Springer Nature 的 APress Media, LLC 独家许可下 2022J. T. George 介绍区块链应用[`doi.org/10.1007/978-1-4842-7480-4_3`](https://doi.org/10.1007/978-1-4842-7480-4_3)

# 3. 比特币

约瑟夫·塔奇尔·乔治^(1  )(1)意大利罗马

在上一章中，您看到了区块链技术如何在不需要中央机构的情况下，并借助所讨论的技术和算法，建立参与者之间的信任，并证明了分布式账本的*不可变性*。区块链非常适合作为数字货币的理想模型，其中不需要中介和银行、保险公司等中央组织。事实上，区块链的诞生和传播归功于比特币。

2008 年，一名名为中本聪（或一组人）的人发布了一篇名为《比特币中的点对点电子现金系统》的研究论文。这篇论文描述了一个允许网络交易直接从一方发送到另一方而无需经过任何中介/银行组织的点对点现金系统。它对比特币进行了详细解释。

加密货币这个术语描述了所有使用密码学保护数字交易的系统、网络和媒体，与那些通过共同信任实体管理交易的系统相比。

本章介绍了*比特币协议*。它详细分析了组成它的主要部分——公钥和私钥、比特币地址和区块。该章节还说明了网络和共识机制，包括工作证明。

## 3.1 比特币的历史

几乎所有比特币技术部分都诞生于 1980 年代和 1990 年代的学术出版物。“我们需要强调的是，我们的目标不是为了减少中本聪的工作和成功，而只是为了强调真正的直觉飞跃是什么。事实上，通过追踪比特币中存在的初始思想，我们可以专注于它们如何以特定和复杂的方式将底层组件组合在一起。”^(1)

比特币的历史同时也是一个案例研究，它证明了学术界、外部科学家、工程师和专业人士之间的关系，并展示了这些团队如何相互获取知识。许多专业人士已经研究了比特币，并发表了大量的研究论文。

请注意，账本思想是比特币的初始起点。如果你理解了账本，你就会理解系统的结构及其通信。账本是所有交易发生的地方。它是公开的，并被系统中的所有方和组件信任（见图 3-1）。![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig1_HTML.jpg](img/520777_1_En_3_Fig1_HTML.jpg)

图 3-1

**比特币的主要思想**

为了支持数字货币，账本必须具有这些基本属性：

+   **仅追加：**只能向账本中添加新的交易。不可能放弃、修改或重新排序现有的账本。

+   **不可变性：**账本中的信息无法更改。

+   **防止双重花费：**不可能花费相同的货币安全超过一次。

### 3.1.1 连接时间戳和 Merkle 树

比特币账本的数据架构是从 Stuart Haber 和 Scott Stornetta（1990 年和 1997 年）的几篇文章中取得的，经过适当的修改。

我们都知道，自从中本聪在比特币论文中声明过，Haber 和 Stornetta 的论文处理了文档的时间戳问题。请注意，当涉及商业合同、专利和其他文件时，可以确定文档是在特定时间点生成的。我们理解他们对文档的概念是相当通用的，它可以包括不同类型的数据。

他们随意提到银行交易可能是一个应用场景，但请注意，这并不是他们的目标。每个文档的发起者确认生成的时间并签署文档、其日期和时间。

这个最初的文档是由创建者批准/签署的，因此文档形成了一个指向过去的长链。第三方用户无法编辑时间戳消息，因为它是由其发起者批准的，而且创建者或发起者不能编辑消息而不改变整个后续消息链。

Haber 和 Stornetta 在他们的文章中还提到了一些想法，使这种数据结构更快、更有效和更准确：

+   文档之间的链可以通过使用哈希而不是签名来创建；请注意，这些哈希更容易、更快速地计算，并且在数据标识符方面更强大。我们称这样的链接为 *指针*。

+   与其单独为文档加时间戳，如果一次生成了许多文档，这可能效率低下，不如将文档合并成批或块，使用相同的时间戳在文档中。

+   每个区块中的文档应该由一个称为 *默克尔树* 的哈希指针二叉树绑定。乔希·贝纳洛先生和迈克尔·德·马尔先生在哈伯的文章发表后立即在 1991 年独立提出了这些想法。

注意，默克尔树是以拉尔夫·默克尔命名的，他在他的 1980 年文件中提出了非对称加密逻辑。

无论如何，比特币都从 Haber 和 Stornetta 的工作中借鉴了数据结构，并通过添加 PoW 方案重新设计了其安全特性。

### 3.1.2 分布式共识

互联网货币或货币交易需要一个共同的权威机构。

在分布式账本的情况下，您会发现会自动出现分叉，这意味着一些节点将得出结论认为区块 A 是最新的区块，而所有其他节点都会得出结论认为是区块 B。^(2)

在这种情况下，您需要了解这是因为对手试图中断账本交易还是因为网络延迟，偶尔会导致来自不同节点的几乎同时产生的区块，不知道相互之间的区块。链接的时间戳不足以纠正分叉，这是由 Mike 在 1997-1998 年提出的。

在可能出现错误的情况下达成共识的问题称为 *拜占庭将军问题*。它在第二章中非正式地讨论过。拜占庭故障包括自然故障和恶意行为。

这个想法最初在 Leslie Lamport 与 Robert & Marshall 1982 年的一篇文章中讨论过。1999 年，Miguel Castro & Barbara Liskov 的一份文件提出了 PBFT 算法，这使您能够以出色的性能解决拜占庭将军问题。（请注意，PBFT 代表实用拜占庭容错。）

复制算法可以处理拜占庭缺陷。拜占庭容错算法在不久的将来将变得越来越重要，因为恶意攻击和软件缺陷在网络世界中变得非常普遍，这可能导致有缺陷的节点促使任意行为。

但是在以前的算法中，它们需要一个特殊的同步系统，并且速度很慢。本书描述的算法非常实用，因为它在异步环境中快速运行。

中本聪在他最初的论文中没有引用同一篇文章，也没有使用他的措辞。然而，他运用了一些概念，将自己的协议称为共识协议，并考虑了形式上的入侵者的故障，以及加入和退出基础设施的节点。

当被问及比特币与拜占庭将军问题之间的联系时，中本聪在一个邮件列表上声称，工作证明（PoW）链解决了这个问题。

几乎所有的失败系统都假设系统中大多数节点都是值得信赖和诚实的（例如，超过一半或三分之二）。开放的点对点网络中的节点可以随时加入和退出。

因此，蚁人攻击可以用来绕过系统的同意或质量保证。约翰·杜塞尔（John Douceur）在 2002 年定义了蚁人攻击，并提出了一种称为工作证明（Proof of Work）的密码学突破来对抗它。

## 3.2 工作证明

本节介绍了工作证明的第一个阶段，以便您更好地理解它。辛西娅·德沃克（Cynthia Dwork）和莫尼·纳奥尔（Moni Naor）在 1992 年创建了第一个提议，标题为“工作证明”。当时他们的目的是阻止垃圾邮件。

例如，哈希现金是一种在各种系统中作为防止服务拒绝的措施而被采用的工作证明方法。

哈希现金邮票是一个需要发送者计算可参数化时间的工作证明。收件人可以快速检查他或她收到的哈希现金邮票。

虽然哈希现金的设计是为了对发送电子邮件进行处罚，以防止大量的电子邮件垃圾邮件，但现在它可能被引入到任何互联网服务中，以对可能滥用服务器资源的客户施加计算成本。

但是，一个想要传输一百万封电子邮件的垃圾邮件发送者可能需要数周时间来使用类似的方法。

偶尔，需要工作证明实例（也称为*难题*）来识别电子邮件和收件人。

否则，垃圾邮件发送者可能向同一收件人发送多条消息（或向多个收件人发送相同消息），但只需支付向一个接收者发送一条消息的费用。第二个关键特性是接收者的计算成本应尽可能低；无论计算多么复杂，谜题的答案都应易于检查。

Dwork 和 Naor 的建议引发了整个探索领域。当时的密码朋克研究社区的博士后 Adam Back 分别在 1997 年设计了一个名为 hashcash 的类似概念。

*密码朋克*是反政府和反中心化机构的活动人士，他们使用加密来带来社会和政治变革。

Hashcash 不过是一个工作量证明算法；它被用作防止不同系统中的垃圾邮件和拒绝服务攻击的措施。

它基于与哈希函数相关的简单原理：唯一识别具有给定输出的哈希的输入的方法是测试各种输入，直到提供所需数据为止。因此，唯一识别将哈希在一个任意系列的输出中的输入的方法是尝试不同的输入，一个接一个地哈希。

### 3.2.1 中本聪的天才

了解构成比特币设计要素的所有前任将使人欣赏到中本聪真正伟大的发现。

工作量证明（Proof-of-Work，PoW）用于保护账本的主人或分类账。工作量证明的解决由矿工完成。

每个矿工解决的挑战形式略有不同；因此成功的几率与矿工拥有的世界处理能力的比例成正比。解决问题的矿工可以向分类账捐赠一个新的交易块，该交易块将根据时间戳添加到分类账中。

贡献一个区块的探矿者将以最近产出的币单位作为酬劳，来维护分类帐。如果一个探矿者贡献了一个无效的区块或交易，那么它很可能会被贡献给连续区块的大多数其他探矿者所淘汰，使错误区块的区块奖励无效。

矿工们以这种方式相互保险，这要归功于货币激励。

与用于构建计算机系统的复杂方法不同，中本聪的天才体现在比特币的个别组件之一。

没有人考虑鼓励结点保持真实。没有人考虑使用同意算法来避免双重成本。

为了消除重复消费并确保货币具有价值，比特币需要一个安全的分类帐。矿工必须以某种方式获得奖励。矿工的力量，反过来，用于保护分类帐。否则，拥有超过全球 51% 的挖掘能力的敌人可能会比网络的其余部分更快地生成区块，执行双重支出计算或交易，并通过避开计算机系统完全重写历史。

因此，比特币的推出在这三个组件上有一个很好的平衡依赖。

## 3.3 密钥和地址

要拥有自己的比特币，也就是说，要花费它们，需要：

+   一组数字密钥，包括私钥和公钥

+   一个比特币地址

+   一个数字签名

椭圆曲线数字签名方法是支撑比特币私钥和公钥的加密算法。它用于确保只有合法所有者才能花钱。

### 3.3.1 私钥

在比特币的背景下，私钥是一个秘密数字，允许您花费比特币。每个比特币钱包都带有一个或多个保存在钱包文件中的私钥。

它也被用来生成数字签名。

私钥只是随机生成的一个数字。它是一个带符号的 256 位（32 字节）整数。然而，并非所有的 256 位无符号数都是比特币私钥。事实上，比特币使用的标准 secp256k1 限制了有效私钥的数量。

Secp256k1 在高效加密标准中有所描述，对应于比特币公钥加密（SEC）中使用的椭圆曲线的参数。

请记住，私钥用于生成公钥。

### 3.3.2 公钥

论点是公钥可用于验证签名的真实性（即使用正确的私钥生成）。一般来说，公钥是通过将私钥与椭圆曲线相乘来创建的。比特币在 secp256k1 常数中定义，并使用常数椭圆曲线和一组数学常数。

从一个私钥 << privkey >> 开始，并将其乘以曲线上的预定义点称为*生成点* G，可以在曲线上产生一个不同的点，对应于公钥 << pubKey >>。通常，一个公钥可以通过点的坐标来定义：«privkey»*G=«pubKey» = (x,y)（见图 3-2）。

图 3-2

椭圆曲线加密函数的示例，用于计算公钥

生成点 G 被描述为 secp256k1 的一部分，并且对于比特币中的所有密钥都是相同的。

私钥 << privKey >> 乘以 G 将产生相同的公钥 << pubKey >>。<<privKey >> 和 << pubKey >> 之间的连接是恒定的。但是它只能在单个方向上计算，从 << privKey >> 到 << pubKey >>。

椭圆曲线上点的（x；y）坐标可用于描述公钥。十六进制是存储数据的最常用格式。

因此，公钥有两种格式：

+   未压缩的公钥

+   压缩的公钥

请注意，未压缩的公钥是旧格式。通常不再使用这种格式，而是使用压缩格式。比特币最初同时使用 x 和 y 坐标存储公钥。在这种未压缩格式中，坐标被简单地串在一起，并添加前缀 04 表示它是未压缩的公钥，如图 3-3 所示。![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig3_HTML.jpg](img/520777_1_En_3_Fig3_HTML.jpg)

图 3-3

未压缩的公钥

使用压缩的公钥，椭圆曲线在 X 轴上是对称的，如图 3-4 所示。![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig4_HTML.png](img/520777_1_En_3_Fig4_HTML.png)

图 3-4

椭圆曲线的对称性

因此，在压缩的公钥格式中（参见图 3-5），您只保存完整的 x 坐标，以及指示 y 是偶数还是奇数的前缀。![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig5_HTML.jpg](img/520777_1_En_3_Fig5_HTML.jpg)

图 3-5

压缩的公钥

这种格式在区块链上节省了大量空间。

### 3.3.3 比特币地址

比特币地址，或简称地址，是一个由 26-35 个字母数字字符组成的标识符，以数字 1、3 或 bc1 开头，代表比特币支付的可能目的地。比特币（加密货币，BTC）的交易可以通过地址进行，有点类似发送电子邮件。但与电子邮件地址不同的是，人们有不同的比特币地址，同时每笔交易都应使用唯一地址。

一个人可以创建无限数量的地址，增加支付的匿名性。一个地址由三个元素组成：

+   一个公钥哈希

+   一个前缀

+   校验和

让我们详细分析这三个组件。

公钥哈希只是应用于公钥的双重哈希。特别是，它是通过 SHA-256 和 RIPEMD160 获得的哈希，因此：<< PublicKeyHash >> = RIPEMD160 (SHA-256 (<< publicKey >>))

有时它被称为 HASH160 (<< publickey >>)，因为它比写 RIPEMD160 (SHA256 (<< publickey >>)) 更简单。

前缀表示要创建的区块类型。

最常用的是：

+   00：用于 P2PKH 锁定脚本（稍后您将学到它是什么）

+   05：用于 P2SH 锁定脚本

最后，通过对公钥哈希执行两次 SHA-256 哈希并取前四个字节来获得校验和。因此，您需要将这些元素按顺序放置以获得一个队列（请参见图 3-6 和 3-7）：

1.  1.

    前缀

1.  2.

    HASH160(«公钥»)

1.  3.

    校验和

![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig6_HTML.jpg](img/520777_1_En_3_Fig6_HTML.jpg)

图 3-6

组成比特币地址的元素

然后应用 Base58 函数，最终将提供比特币地址，如图 3-7 所示。![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig7_HTML.jpg](img/520777_1_En_3_Fig7_HTML.jpg)

图 3-7

比特币地址

Base58 是一个转换器，您可以使用它将大数字表示为更短且更直观的格式，从而产生文本字母数字字符。显然，这些操作是在应用程序级别实现的，用户无需执行所有这些步骤。

### 3.3.4 数字签名

*数字签名*是一种数学手段，用于证明您知道与公钥相关联的私钥，而不会泄露有效的私钥。在进行交易时，您必须首先解锁要使用的余额（正如您将在下一节中看到的 UTXO）。这可以通过证明您“拥有”该余额并知道存放余额的地址的私钥来实现。因此，要在不提供私钥的情况下解锁余额，您使用数字签名。通过这种方式，您表明您拥有私钥，而不将其交给网络。然后，这些将用于交易以证明您拥有要消费的余额。

是什么阻止有人利用交易的数字签名来解锁您地址上的其他退出？每个交易都有自己的数字签名。

换句话说，你不仅需要使用私钥，还需要使用私钥和交易数据来构建数字签名。因此，任何数字签名都与其所使用的交易相关联。因此，如果有人试图在新交易中使用交易的数字签名，它将与数字签名中的交易数据发生冲突，并将被比特币网络的节点拒绝。

因此，数字签名还将防止破坏其所使用的交易。数字签名由两部分组成：

+   一个随机部分

+   由一部分组成的签名

    +   一个私钥

    +   您正在创建数字签名的数据

对于随机部分，让*n*为第二个椭圆曲线的点 G 的标准 secp256k1 的阶。您生成一个介于 2 [1; n - 1]之间的随机数，并将此随机数命名为。

然后，您将此随机数乘以椭圆曲线的点 G（生成点）。这与您用于公钥并由标准 secp256k1 指示的 G 相同。为简洁起见，您使用变量 k 表示随机数。

k G = (xr; yr)

此数字签名的随机部分是您获得的曲线上的点（参见图 3-8）。但您只取 xr 坐标。![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig8_HTML.jpg](img/520777_1_En_3_Fig8_HTML.jpg)

图 3-8

从曲线上获得的随机数，从中取 X 坐标

为简洁起见，您可以将 r 称为从中获得的 randomPart 值

*r = randomPart = xr mod n*

对于签名部分，您需要获取用于随机部分的私钥。

*r * privKey*

然后，您需要包含要创建签名的数据。

在比特币中，这由包含您要解锁的余额（UTXO）的交易的哈希表示。您定义 h（msg）= SHA-256（<<transaction >>）并获得：

*[r * privKey] + h(msg)*

交易哈希的包含将签名绑定到交易（因此不能在不同的交易中使用）。最后，您将此除以初始随机数 k：

*s = sign = k-1 (r privKey + h(msg)) (mod n)*

您已获得数字签名的基本部分。数字签名由 r 和 s 组成。

如果有人要求您证明您知道某个公钥的私钥，则可以向他们提供签名数字（r; s）作为证据。

#### 3.3.4.1 验证数字签名

要验证数字签名是否使用正确的私钥进行了签名，您提供此数字签名的人必须同时使用两侧（r; s）以在椭圆曲线上找到两个新点并检查签名。

从这里开始，仅在严格需要除法变量时才使用乘法运算符，否则假定隐式乘法操作。

首先，让我们来看看数字签名所附的数据。在这种情况下，应用于交易的是 SHA-256 哈希。

您将此值除以 s（数字签名的核心部分），然后乘以 G（生成点），如下所示：

*u1 = (x1; y1) = (h(msg) s-1 mod n) G*

然后找到 1 点（参见图 3-9）。![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig9_HTML.jpg](img/520777_1_En_3_Fig9_HTML.jpg)

图 3-9

1 点的图形表示示例

然后将 r 除以 s 并乘以 < < publickey > >：

*u2 = (x2; y2) = (r s-1 mod n) pubKey*

然后你有了 2 点（见图 3-10）。![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig10_HTML.jpg](img/520777_1_En_3_Fig10_HTML.jpg)

图 3-10

2 点的图形表示示例

最后，将这两个点相加，你就得到了椭圆曲线上的第三个点。（见图 3-11。）

*Rv = (xv; yv) = u1 + u2*![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig11_HTML.jpg](img/520777_1_En_3_Fig11_HTML.jpg)

图 3-11

1 点和 2 点之间求和的图形表示示例

如果在椭圆曲线上获得的点 Rv = (xv; yv) 的值 c = xv mod n 等于 r，即 c == 初始 r，则证明数字签名是用连接的私钥进行的。

#### 3.3.4.2 理解 ECDSA 签名/验证数学

ECDSA 签名具有简单的描述：

需要注意，签名过程通过椭圆曲线的变换使用私钥 privKey 对随机点 R 进行编码（仅从 X 坐标表示）（您可以参考 r = randomPart = xr mod n）。接着对消息的哈希值 h(msg) 进行编码，这表示签名者理解私钥 privKey。签名（random Part, sign）可能会因 ECDLP 问题的复杂性而泄漏私钥。

验证签名通过使用公钥 pubKey 和消息哈希 h(msg) 对证明数进行编码。然后恢复用来创建签名的原始点 R，称为 Rv。然后将从签名中取回的 Rv 的 X 坐标（xv mod n）与签名的 r = randomPart 值进行比较。

那么，所报告的签名和验证方案是如何工作的呢？让我们考虑验证，然后推导出 Rv 的方程。接着我们将方程写成扩展形式。

*Rv = (xv; yv) = h(msg) s^-1 (modn) G + r s^-1 (modn) pubKey*

用 privKey G 替换 pubKey：

*Rv = (xv; yv) = h(msg) s^-1 (modn) G + r s^-1 (modn) privKey G*

强调 G 和 s^-1 (modn)，得到：

*Rv = (xv; yv) = (h(msg) + r privKey) s^-1 (modn) G*

我们知道：

*s^-1 (modn) = (k^-1 (h(msg) + r privKey))^-1 (modn)*

因此：

*s^-1 (modn) = k (h(msg) + r privKey)^-1 (modn)*

我们将其代入 Rv 的方程中：

*Rv = (h(msg) + r privKey) k (h(msg) + r privKey)^-1 (modn) G = k*

最后一步是将点 Rv 与点 R 进行比较。这由 privKey 进行编码。该算法比较了 Rv 的 X 坐标与 R 的 X 坐标（其中 R = (xr; yr) 且 r = randomPart = xr mod n）。更确切地说，如果给定 c = xv mod n，则 c == r 时签名预计是有效的。

图 3-12 在高层次上说明了比特币交易中数字签名的工作原理。![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig12_HTML.jpg](img/520777_1_En_3_Fig12_HTML.jpg)

图 3-12

交易与数字签名

## 3.4 交易

交易是比特币区块链的最基本组成部分。交易被验证并发送出去。许多交易组合成一个区块。此外，通过数字数据链接形成区块链。

为了选择下一个要放入链中的区块，区块经过共识程序。选择的区块经过验证后添加到现有链中。

矿工是执行验证和共识过程的特殊对等节点。重要的是要注意，它们是运行区块链协议特定软件的独特或强大的机器。让我们来看看单个比特币交易的具体内容。

### 3.4.1 未花费的交易输出（UTXO）

未花费的交易输出（UTXO）是比特币网络中的一个基本概念。UTXO 是与某个用户关联的一组比特币。只有在一笔交易中完全使用时，它们才能被用于交易。用户可以与零、一个或多个 UTXO 关联。显然，一旦用户使用了 UTXO 完成一笔交易，它就不能被另一个用户使用。与用户关联的 UTXO 的总和是用户的总余额。

换句话说，比特币以未花费的比特币金额（UTXO）的形式存储与用户的交易和余额相关的数据，这些金额已经发送到用户，可以从该用户支出。

网络中所有 UTXO 的集合构成了比特币区块链的状态。比特币交易由输入和输出组成。

交易以一个或多个 UTXO 作为输入，并根据发送方发起的请求生成一个或多个 UTXO 以输出交易请求指定的金额。因此，未花费的交易输出是用户接收并以后可以花费的交易的结果。

例如，假设约翰有一个价值十比特币的 UTXO 和另一个价值五比特币的 UTXO，并且他想向萨拉发送八比特币，而萨拉的投资组合中没有 UTXO。约翰可以创建一个交易，指定要向萨拉花费的金额，并将十比特币 UTXO 输入为交易输入。

因此，交易将如下所示：

+   **输入：**10 比特币马里奥 UTXO

+   **输出：**

    +   与萨拉关联的 8 比特币 UTXO

    +   与马里奥关联的 2 比特币 UTXO（交易的其余部分）

因此，一旦交易被记录，马里奥将在他的钱包中拥有一个 5 比特币 UTXO 和一个 2 比特币 UTXO，总余额为 7 比特币。萨拉将拥有一个 8 比特币 UTXO，总余额为 8 比特币。UTXO 的解剖非常简单。（见图 3-13。）

脚本有两种：锁定脚本和解锁脚本。鉴于该术语的定义，以及解锁所有权是转移 UTXO 的第一步，输入值包含短语*解锁脚本*。另一方面，输出值将作为锁定过程的结果为*锁定脚本*。术语“脚本”意味着“堆栈结构”，但我们将重点放在方法上而不是定义上。

交易输出 UTXO 具有以下结构（见图 3-13）。![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig13_HTML.jpg](img/520777_1_En_3_Fig13_HTML.jpg)

图 3-13

UTXO 结构

### 3.4.2 输入和输出（I&O）

这就是“列举”交易收入来源（输入）和支出（输出）的概念，而不是通过放置输入和产出作为输出来转移资金的概念。也就是说，当你支付金额时，你首先解释你想要花费的 UTXO 的收入来源，然后是你想要投资的输出项目的数量。让我们首先看一下输出的结构。（见图 3-14。）![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig14_HTML.jpg](img/520777_1_En_3_Fig14_HTML.jpg)

图 3-14

输入和输出

![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig15_HTML.jpg](img/520777_1_En_3_Fig15_HTML.jpg)

图 3-15

UTXO 描述

当创建用于转移资金的交易时，交易输入必须指定将要发行的 UTXO。简单地说，交易的输入是指向 UTXO 的指针。它们定义了一个特定的 UTXO，这与交易的哈希和交易输出的索引号有关。交易输入还包含了满足 UTXO 给出的输出条件以输出 UTXO 的解锁脚本（参见图 3-15 和 3-16）。解锁脚本通常是一个签名，用于验证区块脚本中识别的比特币地址是否属于所有者。

因此，UTXO 输入到交易的结构如图 3-16 所示。![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig16_HTML.jpg](img/520777_1_En_3_Fig16_HTML.jpg)

图 3-16

UTXO 描述

这种交易输入和输出的结构导致了交易链接设计，如图 3-17 所示。![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig17_HTML.jpg](img/520777_1_En_3_Fig17_HTML.jpg)

图 3-17

比特币交易的输入和输出

### 3.4.3 公钥哈希付款（P2PKH）

给出了交易发生的高层描述后，本节涵盖了其技术和结构细节，以了解其实现方式。

P2PKH（支付到公钥哈希）是完成比特币交易或向某人发送货币的脚本模板。它是最常用的脚本，用于锁定某人公钥的输出。它确保只有 UTXO 的受益者，或者拥有私钥并因此拥有与地址 Bitcoin 受益者的 UTXO 相关的公钥的人，才能花费它。

为了更好地理解，让我们首先分析交易过程的输出部分，忽略输入部分的细节。然后我们将解决交易过程的输入方面，深入探讨它如何将这两个部分结合起来。

### 3.4.4 查看输出方面

假设马里奥想要向莎拉发送 `20 比特币`。因此，莎拉将不得不生成与之关联的公钥/私钥对。然后莎拉将提供她的比特币地址（参见“比特币地址”部分）给马里奥。

地址可以以任何方式传输，包括以一种阻止发送者和接收者之间通信的单向方式传输，还可以以不同格式进一步编码，例如包含 Bitcoin: URI 的 QR 代码。

接着，交易的支付者马里奥将收到莎拉的比特币地址，并可以将其指定为交易的受益方/接收方。这将用于创建交易的 UTXO 阻塞脚本，以便只有莎拉，或者谁能证明拥有与莎拉提供的比特币地址相关联的公钥的私钥的人，才能花费它。

然后马里奥将传输交易。一旦交易经过验证，添加到区块并达成共识，它将成为比特币区块链的一部分。

网络因此将其分类为未花费的交易输出（UTXO），并且 Sara 的钱包软件将其显示为可花费的余额。换句话说，Sara 现在在她的钱包里有来自 Mario 的 20 比特币 UTXO。

因此，在每个 UTXO 中都有 PubKey 脚本，该脚本阻止了 UTXO 被受益人或拥有私钥的人使用。然后在交易验证过程中使用。结构如图 3-18 所示。![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig18_HTML.jpg](img/520777_1_En_3_Fig18_HTML.jpg)

图 3-18

PubKey 脚本结构

以 OP 开头的字段表示一个操作，而其他字段表示一个值。

+   OP_DUP：执行复制操作；用于复制脚本 Sig 中的公钥（稍后将看到的），然后将哈希函数应用于比较所得结果与此 ScriptPubKey 中的 pubKeyHash。

+   OP_HASH160：首先对复制的 scriptSig 中的公钥应用 SHA-256 哈希函数，然后应用 RIPEMD160。

+   PubKeyHash：公钥哈希；来自解码发送者提供的比特币地址。

+   OP_EQUALVERIFY：验证两个公钥哈希（在 scriptSig 中的完整公钥和此 PubKey 脚本中的公钥哈希）是否相同的操作。如果它们相同，则返回 True，如果它们不同，则返回 False。

+   OP_CHECKSIG：因此，此操作在脚本上执行。检查签名<sig>是否与公钥<pub-Key>匹配。如果签名与公钥结合在一起并且使用了生成签名所需的所有数据，则 OP_CHECKSIG 返回 True。

要花费此 UTXO，需要解决脚本。为了解决此脚本，然后使用 UTXO 进行交易，您必须证明您拥有与发送 UTXO 的比特币地址相关联的私钥和公钥。

### 3.4.5 查看输入端

让我们从花费者的角度来看一下创建交易的过程是如何工作的。假设萨拉想要向法比奥发送 20 比特币。一旦法比奥提供了比特币地址给她，萨拉将作为交易的受益者输入，并附上金额。

法比奥提供的比特币地址也将用于 PubKey 脚本，因此将允许他将交易的输出专门用于相对私钥的所有者。

然后萨拉将填写交易输入，在每个 UTXO 中，她必须定位并解锁图 3-19 中显示的信息。![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig19_HTML.jpg](img/520777_1_En_3_Fig19_HTML.jpg)

图 3-19

脚本结构 Sig

### 3.4.6 验证过程

所使用的语言，脚本，是基于栈的，并允许有限的操作以避免在代码中引起问题的循环执行。由于它们的低复杂性和可预测的导致时间，这些语言被视为不完全的图灵语言。栈是一种类似于一叠纸牌的数据结构。

有两个可用的程序：push 和 pop。Push 将一张卡放在牌堆的顶部，而 pop 则将其移除。在这种情况下，卡片是数据。任何想要向某人发送钱的人都必须证明他们实际拥有那个币。输入的 scriptSig 和引用输出的 scriptPubKey 被结合并进行评估。

首先，将 Sig 脚本中输入的数据添加到交易输入的栈中（因此，首先是 sig，然后是 pubKey）。

该脚本从栈中提取公钥，与 scriptSig 的 pubKey 相符，并将其应用于它，首先进行 SHA-256 哈希，然后进行 RIPEMD160。然后将结果与 PubKey 脚本的公钥哈希进行比较。如果成功，就继续验证数字签名，否则交易被拒绝。

因此，如果对于公钥是共同的签名，并且已使用所有必须签名的数据生成了，则交易有效。

您可以通过图 3-20 到 3-26 中的图表更详细地了解这些操作。![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig20_HTML.jpg](img/520777_1_En_3_Fig20_HTML.jpg)

图 3-20

交易验证过程，第 1 步

![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig21_HTML.jpg](img/520777_1_En_3_Fig21_HTML.jpg)

图 3-21

交易验证过程，第 2 步

![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig22_HTML.jpg](img/520777_1_En_3_Fig22_HTML.jpg)

图 3-22

交易验证过程，第 3 步

![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig23_HTML.jpg](img/520777_1_En_3_Fig23_HTML.jpg)

图 3-23

交易验证过程，第 4 步

![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig24_HTML.jpg](img/520777_1_En_3_Fig24_HTML.jpg)

图 3-24

交易验证过程，第 5 步

![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig25_HTML.jpg](img/520777_1_En_3_Fig25_HTML.jpg)

图 3-25

交易验证过程，第 6 步

![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig26_HTML.jpg](img/520777_1_En_3_Fig26_HTML.jpg)

图 3-26

交易验证过程，第 7 步

因此，如果 False 不是在 scriptsig 和 scriptPubKey 评估后堆栈的顶部，则交易有效。

实际上，交易的完整验证过程除了对接收它的每个节点都是独立的之外，还包括其他步骤和检查，稍后您将看到。

### 3.4.7 交易结构

在了解操作并分析基本组件之后，您现在将学习交易的结构。 (参见图 3-27)。![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig27_HTML.jpg](img/520777_1_En_3_Fig27_HTML.jpg)

图 3-27

交易结构

锁定时间变量是一个令人着迷的变量。它定义了交易何时首次可以添加到区块链中。在大多数交易中，它设置为 0 以表示即时执行。

如果区块时间大于零但小于 400 毫秒，则视为区块高度，意味着交易在达到区块高度之前不会包含在区块链中。如果超过 400 毫秒，则被解释为*UNIX 时间戳*，并且在所需时间之前交易不会包含在区块链中。锁定时间与预日期支票相同。

### 3.4.8 交易费用

通过为每笔交易收取适度的费用，交易费用既作为激励，以便在下一个区块中包含交易，又作为防范“垃圾邮件”交易或其他形式的系统滥用的威慑手段。

挖掘区块并将交易存储在区块链中的矿工会收取交易费用。而且，与比特币交易金额不同，交易费用是根据交易的字节大小计算的。

+   请注意，比特币区块的尺寸限制为 1MB（1,000,000 字节）。

+   交易数据占据区块的空间。

当矿工填满一个交易区块时，他们会希望最大化他们能够征税的金额。他们通过选择给他们最多佣金的交易来实现这一点，以及占据区块空间。因此，在处理交易费用的价值时，重要的指标是每字节的佣金。矿工根据各种因素优先处理交易，并且在某些情况下，他们甚至可能免费处理交易。

由于交易费用影响处理优先级，具有佣金的交易更有可能被包括在下一个提取的区块中，但是具有不足或没有佣金的交易可能会被推迟。

在大多数情况下不需要交易成本，没有交易成本的交易可能会在以后完成；但是，包括交易费用鼓励优先处理。交易数据结构中还缺少一个收费字段。

费用是作为输入和输出之和之间的差额隐含的。

几乎没有丢失比特币的风险，因为大多数钱包会自动计算和记录交易费用。然而，如果交易是通过编程方式或通过命令行创建的，则必须手动输入和记录费用。

所有支出扣除所有输入后剩余的额外金额是矿工收取的佣金。

因此，如果你不想丢失比特币，重要的是也要为你的钱包指定交易的 UTXO 变化。

## 3.5 交易流程

一旦进行新交易，它会被转发到比特币网络附近的节点，以便在整个网络中传播。

接收交易的每个比特币节点在将其发送到其邻居之前都会首先验证它。只有合法的交易才会在网络上传播，而无效的交易会被首次遇到它们的节点丢弃。

如果传输的交易是真实的，该节点将其转发给与其连接的其他节点，并且将成功消息同步发送回发送者。如果交易无效，节点将拒绝它并向发送者发送同步拒绝消息。

因此，无效的交易将被拒绝，而有效的交易将通过网络传播，并形成*交易池*。交易池是等待确认并添加到新区块中的验证交易的集合。

因此，它作为新交易的临时存储区。

为了生成一个新的块，矿工从交易池中选择交易。这个新块被称为*候选块*。然后，每个矿工尝试通过挖矿过程将他们的候选块添加到区块链中。

当一个 UTXO 被花费时，我们说交易 A 是交易 B 的子交易。交易 A 依赖于父交易（B）的输出 UTXO。交易在通过网络广播时，并不总是按相同顺序到达。

子交易可能会在父交易之前到达。在这种情况下，首次查看子交易的节点可能会注意到它属于一个未知的父交易。节点不会拒绝子交易，而是将其放入临时池，直到父交易到达，然后将子交易传递给所有其他节点。

孤立交易池，也称为孤立交易池，是一个没有父级的交易池。所有引用父级 UTXO 的孤儿都从池中释放，并在其父级到达时递归重新验证，使完整的交易链能够包含在交易池中，准备被拉入一个块。

孤立池的拘留机制确保仅因其父级迟到而拒绝否则可接受的交易，并且归属链最终按正确顺序重建，与到达顺序无关。交易链可以任意长。每个节点都会检查收到的每个交易是否符合一长串标准。以下是基本的验证标准：

+   交易的语法和数据格式必须准确。

+   输入或输出列表中不能有空的。

+   最大块大小小于以字节为单位的交易大小。

+   对于每个输入，所引用的输出必须存在且不能被花费（以防止双重支付）。

+   如果交易池中的任何其他交易中的引用输出存在于任何输入中，则必须取消交易（以防止双重支付）。

+   要发现每个输入的引用输出交易，需要扫描主分支和交易池。请注意，如果任何输入的输出交易不存在，则该交易将被孤立。如果交易匹配尚未在交易池中，将其添加到孤立交易池中。

必须将每个输入的解锁脚本与相应的输出阻止脚本进行比较。这是由接收到交易的每个节点执行的最重要的验证规则。列表可能会根据更新的协议而变化。（见图 3-28。）![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig28_HTML.jpg](img/520777_1_En_3_Fig28_HTML.jpg)

图 3-28

交易的生命周期

## 3.6 区块

区块链的数据结构是一个具有交易区块反向链接的有序列表。区块链可以保存为简单的数据库或平面文件。区块链元数据由比特币核心客户端存储在 Google 的 LevelDB 数据库中。^(4)

区块“向后”连接，每个区块都引用链中它之前的区块。

每个区块在区块链中都由区块头中使用 SHA-256 密码哈希技术创建的哈希来标识。此外，每个区块都在区块头中使用前一个区块的哈希字段来引用父区块，即上一个区块。

换句话说，每个区块的头部包含其父区块的哈希。连接每个区块与其父区块的哈希序列，称为*创世区块*生成了一条链，延伸至第一个创建的区块。

一个区块只有一个父区块，尽管它可以随时有多个子区块。每个子区块都指向同一个区块作为其父区块，并且前一个区块的“哈希”字段包含相同的哈希值（父区块）。在区块链分叉期间，这是一种短暂的条件，其中多个挖矿者几乎同时挖出许多区块，会出现更多的子区块。

最终，“分叉”被纠正，只有一个子区块成为区块链的一部分。即使一个区块可以有多个子区块，但它只能有一个父区块。这是由于一个区块的单一字段前置区块哈希引用其单一父区块，因此会发生这种情况。

前一个区块的哈希值位于区块和影响头部，随后是当前区块的哈希值。

请记住，随着父节点的标识发生变化，子节点的标识也会发生变化。如果父节点以任何方式被修改，父节点的哈希值就会发生变化。因此，修改后的父节点哈希值需要改变子节点指针前置区块哈希。这将改变子区块的哈希值，从而改变侄子区块的前置区块哈希字段和侄子自身的哈希值，依此类推，直到链中的最后一个区块被添加。

由于级联效应，一个有许多后续生成的区块不能被修改，否则会导致所有后续的区块都要重新计算。

由于进行这种重新计算需要大量的计算机功率，一长串区块的存在导致了区块链的深层历史，这是比特币的一个重要安全元素。前六个区块被视为对第七个区块的确认。

随着你对区块链技术的了解越来越多，你会发现区块变得越来越不可能改变。最后，一个区块是一个存储上传到区块链的交易集合的数据结构。

### 3.6.1 区块的结构

区块由带有元数据或模型的头部组成，后跟占据其大部分空间的一系列交易。一个区块的平均大小设置为 1MB。区块头长 80 字节，但平均交易长度至少为 250 字节。 (参见图 3-29。)![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig29_HTML.jpg](img/520777_1_En_3_Fig29_HTML.jpg)

图 3-29

区块的结构

### 3.6.2 区块头

区块头中有三组区块元数据：

+   将此区块连接到区块链前一个区块的上一个区块哈希的引用。

+   “target”，“once”和“timestamp”这些术语都指的是比特币挖矿。

+   市场根是默克尔树的根，用于有效而安全地总结区块交易。

默克尔树是一种生长在默克尔的树。有了默克尔树，一个节点只需下载少量区块头（每个区块 80 字节），就能检测到交易是否包含在一个区块中。它通过从完整节点恢复一个小型的默克尔路径来实现这一点，而无需存储或扩展绝大多数区块链，后者可能达到数千兆字节的大小。

SPV 节点（简化支付验证）是不保留完整区块链的节点，它们使用默克尔路径来验证交易，而不必下载完整的区块。 SPV 节点经常使用默克尔树。 SPV 节点仅下载区块头，不保存完整的交易或下载所有区块。

它们使用身份验证或默克尔路径来检查交易是否包含在一个区块中，而不必下载所有区块的交易。 区块头的详细结构在图表中显示，见图 3-30。![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig30_HTML.jpg](img/520777_1_En_3_Fig30_HTML.jpg)

图 3-30

区块头的详细信息

图 3-31 展示了比特币区块链的区块结构的图形示例。![../images/520777_1_En_3_Chapter/520777_1_En_3_Fig31_HTML.jpg](img/520777_1_En_3_Fig31_HTML.jpg)

图 3-31

比特币区块链结构

区块哈希也不包含在区块的结构数据中，无论是在网络上传播还是在区块链中存储时，正如你所看到的。

相反，当网络接收到一个区块时，每个节点都会计算区块哈希。区块高度，或者在区块链中的位置，是识别区块的第二种方式。因此，一个区块可以通过查看其哈希或查看其高度来识别。

放置在区块链中第一个区块“上方”的每个连续区块都比前一个位置“高”，就像箱子一样堆叠在一起。

需要认识到，区块高度并不像区块哈希一样是一个唯一的标识符。区块高度可能并不总是表示一个单独的区块。正如你将看到的，两个或更多的具有相同区块高度的区块可能争夺区块链中的同一位置。区块的数据结构不包括区块的高度；它不会保存在区块中。

当一个区块被比特币网络接收时，每个节点动态确定其在区块链中的位置（高度）。

## 3.7 中本聪共识

此外，所有传统支付系统都依赖于与管理交易和分类帐的中央权威的信任。

比特币没有中央权威，但每个完整节点都有区块链的副本，包括您可以依赖的公共分类帐记录。区块链不是由中央权威建立的，而是由每个网络节点独立工作建立的。使用网络上提供的信息，网络的每个节点都可以得出相同的结论并组装相同的分类帐副本。

通过*紧急共识*的分散技术是中本聪的关键发明。

共识正在形成，因为它并不明确达成。没有选举表明同意。相反，共识是数百个独立节点在简单的规则和法规下异步交互的结果。

在网络中运行的四个独立过程的相互作用导致了比特币的去中心化共识：

+   每个完整节点独立验证每个交易，使用一套彻底的标准。

+   交易由挖矿节点自主分组到新的区块中，并通过工作证明算法进行验证计算。

+   每个节点在将新区块添加到区块链之前都会独立验证新区块。

+   每个节点独立选择更长的工作证明链（即，被证明具有比较短链更高的计算能力）。

### 3.7.1 矿工

有些节点是特殊节点，称为挖矿节点或*矿工节点*。他们负责创建和注册新的区块到账本。这些节点相互竞争，以添加新的区块到区块链。

他们相互竞争，因为谁成功赢得区块并将其添加到链中，谁就会收到比特币奖励，作为对贡献到比特币网络共识的激励。

为了形成新的区块，矿工从交易池中选择交易，从而获得一个待注册到账本的候选区块。为了选择交易，矿工应用一个属性度量交易，给予具有更老的输入 UTXO 和更高金额的交易更高的优先级，而对最新的和金额较小的交易给予较低的优先级。换句话说，给定一个交易 Tx。让 N 是其输入中的 UTXO 编号，并对于输入中的每个 UTXO i。我们如下定义 TX 的优先级：

![../images/520777_1_En_3_Chapter/520777_1_En_3_Figa_HTML.gif](img/520777_1_En_3_Figa_HTML.gif)

同时，他们将会给予那些每千字节佣金成本更高的交易更高的权重，而不是给予低字节交易佣金的交易。

比特币区块的平均大小设置为 1MB。因此，矿工将尝试选择一系列交易，这些交易在尊重优先级（老化和价值）和最大区块大小的情况下，将允许您获得更高的收入。

因此，交易佣金通常是根据交易的大小来评估的。

### 3.7.2 Coinbase 交易

添加到区块的第一笔交易是一种独特的交易，不同于常规交易。这被称为 Coinbase 交易。

它是允许挖掘出区块的矿工收到的交易：

+   因为参与并添加新区块到共识过程中的激励。

+   它添加到区块的所有交易的佣金总和。

显然，这笔交易的受益地址是挖掘出区块的矿工的地址。每笔交易的输入总值与输出总值之间的差异用于计算总佣金。也就是说：

+   将 N 视为输入总数，I 视为每个输入的索引，Vi 视为输入 i 的金额。

+   让 M 为输出的总数，或者每个输出的索引，V 为输出的金额。那么：

![$$ \mathrm{Commission}i\mathrm{Total}i=\sum \limits_{\mathrm{i}=1}^{\mathrm{N}}{V}_i-\sum \limits_{0=1}^{\mathrm{M}}{V}_0 $$](img/520777_1_En_3_Chapter_TeX_Equ2.png)(3.2)

相反，矿工奖励是从 50 比特币计算的，并且每 210,000 个块减半一次。这意味着比特币在每个区块的构建过程中以一定速率减少。每十分钟形成一个新的区块，其中包含从头开始创建的新比特币。每 210,000 个块，或大约每四年，货币发行速率减少 50%。在网络运行的前四年中，每个区块都包含 50 个新比特币。^(5)

奖励是基于区块高度的，每个区块的起始值为 50 比特币，并且每 210,000 个区块减半一次。适当的奖励是 25 比特币，因为该区块的高度为 277,316。

可以在比特币核心客户端的 GetBlockValue 函数中观察到这种计算，如 3-1 中所示。**int64_t** GetBlockValue(**int** nHeight, **int64_t** nFees){    **int64_t** nSubsidy = 50 * COIN;    **int** halvings = nHeight / Params().SubsidyHalvingInterval();        **if** (halvings >= 64)        **return** nFees;    *// 每 210,000 个块，或大约每 4 年，补贴减半.*    nSubsidy >>= halvings;    **return** nSubsidy + nFees;}[3-1] 

GetBlockValue 函数

### 3.7.3 开发区块头

在计算交易池和 Coinbase 交易的交易后，矿工继续构建区块头以生成候选区块。然后将采取以下步骤：

1.  1.

    指示区块的版本号，解释了区块的结构。

1.  2.

    将之前接受的区块的哈希作为区块的父块添加。

1.  3.

    将 Merkle 树的根值添加到等式中。因此，计算每个交易的 SHA-256 哈希后，这些哈希会两两合并以形成树的每个层级，直到所有交易都被总结在树的“根”节点中。因此，Merkle 树的根存储在单个 32 字节值中的所有交易。

1.  4.

    添加了以 Unix Epoch 格式的时间戳，指的是区块创建的现在。

1.  5.

    定义了将其作为合法区块所需的测试难度，通过填写难度目标。

1.  6.

    最后一个字段是 nonce，初始化为 0。

现在，区块头已经完整，所有其他字段都已填写，并且挖矿操作可以开始。现在的目标是发现一个 nonce 值，将难度目标转换为较低的区块头的哈希值。

### 3.7.4 难度目标

目标用于挖矿。它是区块哈希值必须减少到的数字（以十六进制表示），以便将其添加到账本中。

每 2016 个区块（约两周）调整一次目标，以确保平均每十分钟提取一个区块。

工作量证明的复杂性由一个移动平均数确定，该移动平均数旨在调整每小时的平均区块数，以适应硬件速度的增加和随时间的变化的节点执行的可变兴趣。如果它们生成得太快，则难度会增加。

每个网络节点都独立计算目标，但遵循比特币协议规则。

规则规定，每 2016 个区块，所有节点都会自动重新定位工作量证明的难度。重新定位难度计算将剩余的 2016 个区块的时间与期望的 20160 分钟（基于十分钟的期望区块时间计算，等于两周）的时间进行比较。

然后计算了实际周期与时间周期之间的期望比率，并根据难度进行调整。如果网络发现区块生成速度比每十分钟快，则难度会上升。如果区块发现速度比计划慢，则难度会降低。

让 RecentBlockTime 表示指示查找最新的 2016 个区块所需时间的变量。计算*难度目标*的方程式如下：![$$ \mathrm{NewDifficultyTarget}=\mathrm{OldTarget}\ast \left(\frac{\mathrm{RecentBlockTime}}{20160}\right) $$](img/520777_1_En_3_Chapter_TeX_Equ3.png)(3.3)

每个周期的调整必须小于 4 倍因子，以避免难度目标的显著波动。

如果所需的难度调整超过 4 倍因子，则限制为最大允许值。

所有剩余的修改将在下一个周期内进行。因为每个节点都遵循相同的共识规则，而且所有区块都是相同的，它们最终都将到达相同的难度值。

如果节点错误地计算目标（或对其进行虚假陈述），然后基于该值生成区块，则由于不符合目标的要求，网络的其余部分将拒绝它，并且投入到挖掘该区块中的所有工作都将丧失。

### 3.7.5 工作量证明

一旦矿工节点创建了候选区块，该区块必须由节点的硬件平台提取出来。它必须解决工作量证明算法，以使区块有效。在比特币挖矿过程中，使用了 SHA-256 哈希函数。

简单地说，*挖矿* 是通过修改“nonce 参数重复多次，直到生成的哈希不匹配特定目标”来散列区块头的过程。 “哈希函数的结果无法预测，也无法生成生成特定哈希值的模式。”哈希函数具有这个属性，这意味着达到与特定目标匹配的哈希结果的唯一方法是重复输入，直到随机产生所需的哈希结果为止。^(6)

因此，我们必须理解矿工计算此区块头的哈希以确定它是否小于当前目标。如果哈希值不小于目标值，则矿工会增加 nonce（通常增加一），然后重试。“矿工必须尝试数百万次才能发现一个导致在比特币网络当前难度水平下区块头的哈希值低到足够的 nonce。”

此外，尽管在早期年份使用简单的家用计算机挖掘区块是可能的，但今天必须利用专门的昂贵硬件，并通过加入挖矿池与其他用户共享处理能力。当一个挖矿节点解决问题时，它会将区块发送给所有邻居，以便在网络中传播，被验证，并最终添加到分类帐中。

### 3.7.6 验证新区块

达成区块链共识的第三步是独立验证，由接收到新区块的每个节点执行。

随着新解决的区块在网络上传播，每个节点都会运行一系列测试以确保其有效，然后将其转发给其对等节点。只有合法的区块才会因此在网络上传播。独立验证还确保了诚实的矿工将他们的区块放在区块链上并获利。

那些不诚实行事的人会被拒绝他们的区块，不仅失去奖励，还失去了找到工作证明解决方案的努力，并因此承担了电费而没有获得补偿。

当节点接收到新区块时，它通过将其与必须满足的大量要求进行比较来验证它；否则，该区块将被淘汰。

这些是可以总结的最重要的特征列表：

+   区块的结构和语法是正确的。

+   目标值是准确的。

+   重要的是要意识到，区块头哈希值比目标难度（工作证明检查）要容易。

+   区块的时间戳比未来两小时小（保持时间故障）。

+   区块大小遵循协议的标准。

+   初始交易是使用 coinbase 进行的。

+   其中包含的交易是有效的（使用交易流程中概述的验证标准重新检查交易）。

因此，独立验证确保了矿工不能作弊。矿工必须基于所有节点观察到的共享协议或一组规则构建完整的区块，并使用适当的工作量证明解决方案进行提取。他们会用大量的电来做这件事，如果他们作弊，所有的电力和努力都会被浪费。因此，不依赖于验证是分散式共识的关键部分。

### 区块链分叉

区块链的不同副本并不总是恒定的，因为它是一种分散的数据架构。区块可能在不同的节点上以不同的时间到达，从而给节点带来了对区块链不同的视角。为了解决这个问题，每个节点选择最有效的工作量证明区块链，也称为最高链或具有最大累积难度的链，并尽可能扩展它。

一个节点可以通过总结每个区块中记录的难度来计算用于形成链的工作量证明的总量。

全球比特币网络最终通过在所有节点选择具有最长累积难度链的链路来收敛到一个连贯的状态。

节点管理三组区块：

+   第一个是链接到主区块链的。

+   在已知链中没有已知父级的区块。

+   构成主区块链分支（次要链）的区块（孤块）。

当任何标准验证失败时，无效的区块将被移除或拒绝，并且它们不会被包含在链中。你必须意识到，在任何给定时间，主链都是具有最大或最高累积难度的区块链。

除非存在两条相等长度的链，其中一条具有更多有效证明，否则通常是拥有最多区块的链。当发现新区块时，节点会尝试将其合并到当前的区块链中。

节点会检查前一个区块的哈希字段，其中包含新区块父区块的地址。然后节点将在当前区块链中搜索该父区块。父区块是最近示例中“主”链的顶部，这意味着此新区块扩展了主链。

此外，新区块偶尔可能会扩展不是主链的链。在这种情况下，节点将新区块连接到次级链，使其能够比较次级链的难度与主链的难度。

如果次级链的累积难度高于主链，则节点会回退到次级链，使次级链成为新的父链，而原来的主链则成为次级链。

如果收到一个良好的锁定，但在当前链中找不到父块，则该块被称为*孤儿*。孤儿块被放置在孤儿块池中，并将一直留在那里，直到其父块到达。

孤儿块可以从孤儿池中检索出来，并在其父块到达或被接收并连接到现有链后连接到父块。请记住，孤儿块通常在短时间内收到两个以相反顺序挖掘的块时发生。通过选择难度最高的链，所有节点最终达成网络级共识。

临时链修改最终通过使用新的工作证明来扩展现有的一条链解决。挖掘节点利用其挖掘能力来“投票”以提取下一个区块。当他们提取新块以扩展链时，新块将代表他们的投票。

## 3.8 总结

当你思考“区块链”这个术语时，脑海中应该浮现的主要概念是比特币，这是你在本章学到的内容。我解释了比特币的技术方面，比特币区块链的区块结构，以及区块链中交易的流程，并举了例子。要开发区块链应用程序，你必须理解这些基本概念。

下一章重点介绍以太坊，这是一个基于区块链的软件平台，主要用于支持比特币之后市值排名第二的世界上第二大加密货币。
