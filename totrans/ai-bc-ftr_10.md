© 作者（根据 Springer Nature Switzerland AG 2021 授予的独家许可）Y. Maleh 等人（编）未来网络安全应用的人工智能和区块链大数据研究 90[`doi.org/10.1007/978-3-030-74575-2_8`](https://doi.org/10.1007/978-3-030-74575-2_8)

# IFIFDroid：Android 恶意软件检测中的重要特征识别框架

Takia Islam^(1，2，3  )，Sheikh Shah Mohammad Motiur Rahman^(2，3  ) 和 Md. Ismail Jabiullah^(1  )（1）达福德国际大学计算机科学与工程系，孟加拉国达卡（2）达福德国际大学软件工程系，孟加拉国达卡（3）未来研究实验室，孟加拉国达卡 Takia Islam（通讯作者）邮箱：takia35-1014@diu.edu.bdSheikh Shah Mohammad Motiur Rahman（通讯作者）邮箱：motiur.swe@diu.edu.bdMd. Ismail Jabiullah 邮箱：drismail.cse@diu.edu.bd

## 摘要

Android 恶意软件由于基于安卓操作系统的智能手机日益增长的趋势，已经急剧增长。它已成为攻击者现如今的主要吸引点。因此，Android 恶意软件检测已成为研究人员和学者关注的主要领域，他们致力于网络安全领域的研究。尽管已经有大量的研究工作，但改进防恶意软件工具仍然是一个主要关注点。此外，在开发反恶意软件框架期间，Android 恶意软件的特征起着重要作用。在这项研究中，提出了一种名为 IFIFDroid 的重要特征识别和选择技术，并进行了评估，该技术基于包装方法。然而，所提出的方法可以减少特征数量，有助于机器学习（ML）技术从更少的特征中学习但表现更好。发现 IFIFDroid 可以根据各个 ML 算法的能力对特征进行排名，并且相对于现有的包装方法提供更好的结果。IFIFDroid 证明了仍然有改进特征选择方案的方法，并且通过 ML 算法的训练来最小化功耗、执行时间提供了强有力的基础。尽管如果有更少的特征可以适应而不损失准确性，那么它也会减少处理资源。

关键词 Android 恶意软件检测特征排名方案 Android 恶意软件分析静态分析

## 1 引言

移动设备的使用量日益增长，对终端用户的基本需求也越来越受到关注。一份报告提到，安卓是一个由谷歌开发的基于 Linux 内核的操作系统（OS），在 2016 年占据了总移动操作系统的 82% 的领先地位 [1]。除此之外，安卓在移动市场占据着 85% 的份额，并且在 2017 年成为智能手机平台的首选 [2, 3]，而根据 StatCounter 的数据，2020 年 8 月，全球移动操作系统市场份额达到了 74% [4]。此外，谷歌商店包含了大约 300 万款应用，下载量超过 650 亿次 [5]。然而，由于安卓设备的广泛流行，它们成为了攻击者的目标。在某些情况下，安卓设备允许从未知来源安装第三方应用程序，这也是遭受攻击的可能风险之一。2016 年，攻击者对安卓的攻击率占总攻击的 40% [1]。2017 年，有一项报告称他们发现了仅仅在安卓操作系统上存在 316 个弱点 [6]。从文献和各种报告中可以清楚地看出，安卓操作系统的普及度不仅对用户有吸引力，也对攻击者有吸引力。攻击者通过向用户传播恶意软件来攻击安卓设备。由于安卓恶意软件传播的高峰趋势，信息安全研究人员对检测和预防安卓设备中的恶意软件表示了巨大的关注。

为了在设备上执行特定任务，例如发送短信，每个应用程序在安装过程中都必须向用户请求权限。然而，大多数用户倾向于盲目地授予外来应用程序权限，从而削弱了验证系统的目的。因此，恶意应用程序在实践中很难受到安卓权限系统的限制。安卓恶意软件检测技术可以分为三类：静态检测、动态检测和混合检测，这些都是从最新技术中发现的。静态检测是对未运行安卓应用程序的代码进行分析。这可以获得高系统覆盖率，但面临着诸如代码混淆和动态代码加载等多种对策。作为替代方案，动态检测包含了运行代码对安卓应用程序进行分析。这些可以证明通过静态分析难以探索的妥协，但动态披露的计算资源和时间成本几乎很高。混合检测是连接静态检测和动态检测的方法，以获得检测效果和效率的平衡。

机器学习概念广泛应用于检测 Android 恶意软件，甚至基于静态、动态或混合分析方法。基于逆向工程的恶意软件检测方法意味着对一般静态检测技术的分类。该方法基于恶意应用程序的语义特征来逆向实现。要决定待检测样本是否是恶意应用程序，它需要与已识别的恶意应用程序的特定属性配对。

Android 恶意应用程序可以执行类似的恶意行为，称之为 APIs [7–9]。已经发现世界知名研究人员已经进行了大量研究，但使用了不同的特征集，其中不同的特征对不同机器学习技术的学习基础产生了影响。因此，在本研究中考虑了以下研究问题：

+   如何从安卓应用程序中识别出对每种特定的机器学习技术都很重要的特征集？

+   特征集对任何特定机器学习算法有多大影响？

+   如何制定一个统一的框架来识别特征集中的特征，在每个训练阶段都会随机选择训练集，因此其排名会发生变化？

然而，这项研究项目的主要贡献是提出了一个统一的框架，在应用机器学习技术进行训练之前识别重要的特征集。该框架将帮助研究人员或反恶意软件系统开发人员获得最小的特征集和最大的检测准确度。贡献还包括以下内容：

+   已经发现可以通过最小化特征集来使任何模型达到最大准确度，并且只需最少的特征进行训练。

+   为了生成或生成一个具有机器学习算法的模型，需要更多的执行时间和处理能力。因此，也可以声称由于特征集少了，学习所需的时间和能力也会减少。

本章的结构如下所示。背景和相关工作在第二部分中进行了广泛描述。第三部分详细描述了所提出的框架和研究方法。在第四部分中描述了评估参数和实施和评估过程中使用的机器学习（ML）技术。在第五部分中描述了所提出方法的实验结果和讨论，评估了所提出框架的效果。最后，在第六部分中总结了本章，并展望了未来的方向。

## 2 背景研究

在本章中，将讨论和广泛辩论背景研究和相关工作。

Alzaylaee [9] 提出了一个基于深度学习算法 DL-Droid 的框架。他们考虑了动态和静态特征来开发他们的方法。他们对超过 30,000 个安卓应用进行了实验。他们还使用了 InfoGain 特征排序算法来选择重要特征。他们的方法表现优于动态和静态特征的组合（准确率达到 99.6%），而仅使用动态特征的准确率为 97.8%。据称，他们使用有状态输入生成进行了动态分析。

Tehari 提出了基于熵（PDME）和 FalDroid 算法的四种恶意软件检测方法，使用汉明距离来找到样本之间的相似性。他们考虑了在三个数据集上对不同类型特征的实验，例如 API、意图和权限特征。他们的实验基于包括 Drebin、Contagio 和 Genome 在内的三个数据集，这些数据集包含良性和恶意的安卓应用。实验结果确保了他们提出的算法的验证准确率超过 90%，在某些情况下，准确率高达 99%以上 [10]。

Ma 提出了一种基于机器学习算法的 Android 恶意软件检测的组合方法，并构建了三个检测模型，分别关注 API 调用、API 频率和 API 序列。他们通过大量检查比较了检测模型的准确性和稳定性，实验结果表明，高准确性和清晰度率达到了 98.98% [11]。

Amin 提出了一种使用定制学习模型的反恶意软件系统，该系统基于端到端的深度学习架构。在该系统上，从安卓恶意软件的应用属性中提取了操作码。他们选择使用独立的深度学习模型，利用像循环神经网络、长短期记忆网络及其双向变体等序列专家进行安卓静态恶意软件分析。超过 180 万个安卓应用的大量数据集显示，他们的报告准确率达到了 0.999，F1 分数达到了 0.996，可以带来更好的恶意软件检测器设计 [12]。

McLaughlin 使用深度卷积神经网络（CNN）技术提出了另一种安卓恶意软件检测工具。他们从反向工程中提取原始操作码序列，并在研究过程中将其计算为特征。他们在特征提取过程中进行了静态分析。尽管他们的主要目标是快速扫描大量文件，但他们声称他们的模型在大数据上具有更好的准确性 [13]。

Li 介绍了一种称为显著权限识别（SigPID）的恶意软件检测系统，该系统依靠权限使用分析来抵御 Android 恶意软件数量的迅速增长。他们提出了三个级别的权限数据，以识别最重要的权限。最后，他们的评估发现，他们的评估认为只有 22 个权限是重要的，并且与另一种方法的性能进行了比较，该方法仅检查了所有权限。提到他们实现了超过 90%的精确度、召回率、准确度和 F-度量，并且分析时间比使用所有权限的时间少 4-32 倍[2]。

Karbab 提出了一种基于序列分类和深度学习技术的自动 Android 恶意软件检测的家族归因框架 MalDozer。基于深度学习技术，他们选择了各种恶意软件数据集，范围从 1000 到 33000 个恶意应用程序，以及由 MalDozer 提供的 38000 个良性应用程序。该解决方案提到，MalDozer 能够在多个数据集的所有评估中准确检测到恶意软件，并且将它们归因于其真实家族，F1-Score 为 96-99％[14]。

Kim 提出了一种新颖的 Android 恶意软件检测框架，并使用各种特征。这些特征是通过存在性提取方法明确解释的，用于成功的恶意软件检测特征表示。作为恶意软件检测模型，他们采用了多模态深度学习技术。此外，为了评估性能，他们执行了基于 41260 个样本的多个实验，然后将其模型的准确性与其他深度神经网络模型进行了比较。他们还在他们的特征表示方法和几个特征的效率在模型更新中的有用性之间的各个方面对他们的方法进行了评估[15]。

Ren 基于深度学习算法，提出了两种 Android 恶意软件检测的端到端方法，这些方法具有连续学习活动的优势。他们声称，他们提出的方法具有连续学习活动的好处，并且通过与一些现有检测方法进行比较来进行评估。用于评估他们的性能的数据集包含 8000 个良性应用程序和同样数量的恶意应用程序，共计 16000 个应用程序。他们的检测有效性达到了 93.4 和 95.8％[16]。

Wu 介绍了一种名为多视图信息集成技术（MVIIDroid）的 Android 恶意应用程序检测结构化名称。另一方面，他们的方法提取了应用程序的多个组件，将它们转换为嵌入式特征向量，并训练多核学习模型作为分类器。为了描述他们的表示的有效性，他们对 6820 个良性应用程序和 6820 个恶意软件的两个 Android 恶意软件数据集进行了评估。除了将恶意软件与良性应用程序分开，他们还必须实现更高的分类性能 [17]。

Hou 将 Android 应用程序、相关 API 以及它们丰富的连接描述为结构化的异构信息网络（HIN）。它不仅仅使用应用程序编程接口（API）调用，而且检测到 Android 恶意软件，并进一步检查显示它们之间的几个连接，并创建更高级的语义，需要攻击者付出更多的努力来规避检测。他们展示了他们的实验结果，证明了他们开发的系统 HinDroid 优于其他替代 Android 恶意软件检测技术 [18]。

由 Arora 提出的创新检测模型 PermPair 建立并对恶意软件进行图形对比。除了从应用程序的清单文件中提取具有权限对的标准样本外。他们主要分析可能危险的权限对。他们提到，他们实施了一种高效的边缘消除算法，从常规图中减少了 41%，并从恶意软件图中删除了 7%的无用边缘。此外，检测时间减少了 28%，并显示最小的空间利用率 [19]。

Xu 进行了对 DroidEvolver 的检测，该检测评估了六年内开发的 34,722 个恶意应用程序和 33,294 个良性应用程序的数据集。基于使用在线学习技术，它随着特征集和伪标签的演变而进行必要的轻量级更新。DroidEvolver 获得了高的检测特征度量（95.27%），在未来五年中，每年平均下降 1.06%，用于对 57,539 个新提出的应用程序进行分类。DroidEvolver 的性能能力比 MAMADROID 高出 28.58 倍，并与最先进的额外时间恶意软件检测方法 MAMADROID 进行了比较。最后，DroidEvolver 的 F 度量平均高出 2.19 倍 [20]。

王提出了一个基于深度自动编码器（DAE）的混合模型，其中使用了卷积神经网络（CNN）。他们重新创建了 Android 应用程序的高维特征，并采用多个 CNN 来检测 Android 恶意软件。他们分析了 13000 个恶意应用程序和 10000 个良性应用程序。与 SVM 相比，使用 CNN-S 模型的准确率提高了 5%，而使用 DAE-CNN 模型的训练时间减少了 83%[21]。

Rana 评估了四种基于树的机器学习算法，用于检测 Android 恶意软件，并结合了基于子字符串的特征选择方法用于分类器。对于研究，他们包含了 5560 个恶意样本，其中使用了包含 11120 个应用程序的 DREBIN 数据集。基于机器学习算法，他们建立了自己的执行结果，而随机森林分类器表现出色，超过了以前报道的最佳解决方案。这为构建高效的 Android 恶意软件检测工具提供了坚实的基础[22]。

Rahman 使用堆叠概念 StackDroid 执行了一个多级架构，并评估了能够将错误率最小化的模型。他们使用了堆叠泛化过程。他们使用了机器学习算法和用于最终预测器的极端梯度提升在第 2 级中使用。它提到，在 DREBIN 数据集上的 97%的检测准确率，并提供了开发 Android 恶意软件扫描器的积极基础，他们获得了 99%的 AUC（曲线下面积），1.67%的 FPR（误报率）[23]。

Russel 确定了攻击者用来转移恶意软件注意力的模式。他们提出了 Python 脚本，从一个混淆的安卓恶意软件数据集中提取了应用程序（App）组件的模式。基于应用程序组件模式，他们启动了一个矩阵形式，该矩阵形式在一个逗号分隔值（CSV）文件中聚集。这将导致检测混淆的恶意软件的主要基础[24]。

一项基于仿真的研究提出了关于混淆的安卓恶意软件中权限的调查。基于 Python 脚本从名为 Android PRAGuard 数据集的混淆恶意软件数据集中提取权限模式。实验结果表明，已经找到了矩阵形式的模式，并保存在一个逗号分隔值（CSV）文件中，这将导致检测混淆恶意软件的基本依据[25]。

Islam 对单字、双字和三字的有效性进行了分类，采用了堆叠泛化，并且单字提供了超过 97%的准确率，这是对双字和三字的最高检测率。它提到它们被用作最终预测器和元估计器 eXtreme Gradient Boosting（XGBoost）。他们从这个实验中证明了使用 n-gram 技术来开发 Android 恶意软件检测的积极基础已经确定[26]。

刘提出了用于 IoT 设备的基于学习的 Android 恶意软件检测方法（TLAMD）测试框架。所提出的框架采用了机器学习技术。它可以对系统进行黑盒测试，评估框架可以为 IoT Android 应用程序开发对抗性样本，利润率接近 100% [27]。

Millar 还建立了三个贡献，并在实验中针对四种流行的真实混淆技术展现了强大的抵抗力。他们提出了 DANdroid，一种使用深度学习判别对抗网络（DAN）的创新型 Android 恶意软件检测方法。它将混淆和非混淆应用程序分为两种恶意或良性。他们提到使用了三种特征集，如原始操作码、权限和 API 调用，在多视图深度学习架构中结合起来提高了这种混淆鲁棒性。他们对包含 68,880 个混淆和非混淆的恶意和良性样本的数据集进行了实验，多视图 DAN 模型获得了 0.973 的 F 分数，并与最先进技术进行了积极对比，尽管暴露于经过选择的混淆方法的测试中，无论是单独还是组合 [28]。表 1

文献中使用的特征

| S/L | 参考 | 使用的特征 |
| --- | --- | --- |
| 1 | [28] | 原始操作码、权限和 API 调用 |
| 2 | [29] | 应用程序在事件级别的行为 |
| 3 | [30] | 静态特征、动态特征和混合特征 |
| 4 | [31] | API 调用图嵌入 |
| 5 | [32] | URL 特征挖掘 |
| 6 | [33] | 基于内容的特征、运行时 API 序列 |
| 7 | [34] | 系统调用序列 |
| 8 | [35] | 清单属性、API 调用、操作码序列 |
| 9 | [36] | 讨论了静态分析的各种特征，包括操作码 |
| 10 | [37] | 权限、API 调用、意图、网络流量、Java 类和进程间通信 |
| 11 | [38] | 调用图 |
| 12 | [39] | 网络流和 API 调用 |
| 13 | [40] | 来自 App 的 smali 代码的 n-gram 特征 |
| 14 | [41] | 权限、API 调用、网络地址等 |
| 15 | [42] | 静态特征、API 包调用特征和动态特征 |
| 16 | [43] | 危险权限和组件 |
| 17 | [44] | 操作码序列 |
| 18 | [45] | 系统调用 |
| 19 | [46] | 讨论了权限、意图、uses-feature、应用程序和 API，包括内核级特征 |
| 20 | [47] | 权限请求和 API 调用 |

EveDroid，一个可扩展的、事件感知的安卓恶意软件检测系统，利用了几种情况下的行为模式，根据雷的观察有效地检测最近的恶意软件。他们的事件还可以反映应用程序可能的运行活动。另一方面，他们还提到使用事件组来描述应用程序在事件级别上的行为，这可以捕获比 API 级别更高级的语义，并且他们的方法直接使用 API 调用作为特征。性能基于一个数据集，其中有 14,956 个良性应用程序和 28,848 个恶意安卓应用程序[29]。

文献中使用的特征在表 1 中列出，证明这些特征对安卓恶意软件检测具有显著影响。

## 3 IFIFDroid: 提议的方法

提议的框架或提议的方法将在本节中详细逐步描述。

### 3.1 数据集描述

有很多公开数据集[52–59]可供在研究工作中进行实验或实验。‘DREBIN’ 数据集是其中最常用的数据集之一，它在验证或测试提议的框架时使用。该数据集包括 123,453 个真实的安卓应用程序，包括 5,560 个恶意应用程序，涵盖了 179 个恶意软件家族。从安卓恶意软件分析的早期阶段开始，这个数据集就成为研究不同类型恶意软件的强大基础，因为这些恶意软件样本是从 2010 年 8 月到 2012 年 10 月收集的[7, 8]。

### 3.2 测试床设置

测试床设置是关于一个实验环境的描述，其中包括一个英特尔(R)酷睿(TM) i5-6500 CPU @ 3.20 GHz 的处理器，64 位 PC，内存为 16 GB。操作系统是 Linux Mint 18.3 Sylvia。在这项研究中使用了 Scikit-learn、NumPy、panda 等包，它们是 Python 的包，Python 是编程语言。

### 3.3 预处理

已经提到数据集中数据数量不平衡，只有 5560 个是恶意软件。因此，有必要使其平衡，使恶意应用程序和良性应用程序数量相等。在此阶段，使用以下公式进行平衡操作：![$$ f(dataset)= \sigma {\left\{ \begin{array}{ll} \frac{n}{,}&amp;{} \text {if } count(malware) = count(benign)\\ 0, &amp;{} \text {otherwise} \end{array}\right. } $$](img/507793_1_En_8_Chapter_TeX_Equ1.png)预处理后，根据相同数量的恶意软件和良性软件选择了最终数据集。其中 (图 1),![$$\begin{aligned} \sigma = 选择, \qquad \qquad \qquad \\ 0...\mathrm{n} = \text {所有样本,} \qquad \qquad \\ \text {计数 }= \text { 计算样本数.} \end{aligned}$$](img/507793_1_En_8_Chapter_TeX_Equ2.png)![../images/507793_1_En_8_Chapter/507793_1_En_8_Fig1_HTML.png](img/507793_1_En_8_Fig1_HTML.png)

图 1

提议的框架

### 3.4 特征提取

在这个阶段使用 Androguard 反向工程工具对 APK 文件进行了反向工程以提取特征[60]。根据数据集，有两个主要部分可以从中提取特征：一个是 Manifest.xml（所有权限都在那里列出）文件，另一个是 classes.dex（执行代码的主要来源）文件。根据所使用的数据集，从这些来源中提取了总共八个特征集，如下图 2 所示：

**硬件组件（HC）：** Android HC 还支持 VideoCamera、GPS、3D 加速计、指南针，并为位置和地图相关功能提供丰富的 API，用户可以灵活地访问、控制和处理免费的 Google 地图。硬件组件在移动系统中实现基于位置的移动服务的低成本。

**请求的权限（RP）：** 请求用户许可的 Android 权限列表。Android 权限在用户允许安装应用程序的安全机制中起着重要作用。每个恶意应用程序都必须运行 Android 6.0 来请求危险权限，以便访问重要信息。例如：请求相机访问权限，这是一个与硬件相关的权限，例如 Google Play 商店假定用户应用程序需要底层硬件功能，并将应用程序从不提供该功能的设备中过滤掉。![../images/507793_1_En_8_Chapter/507793_1_En_8_Fig2_HTML.png](img/507793_1_En_8_Fig2_HTML.png)

图 2

反向工程过程

**应用组件（AC）：** Android 应用程序有一个应用组件，它是基本的构建块。每个组件都是系统或用户进入应用程序的入口点。应用组件有 4 种类型，如服务、活动、广播接收器和内容提供者。

**过滤的意图（FI）：** 意图是用户可以用来请求另一个应用组件执行操作的消息对象，在 Android 中进行进程间和进程内通信时，执行意图。重新启动 Android 手机后，使用 BOOT_COMPLETED 的恶意应用程序或恶意活动的数量。

**受限 API 调用（RAC）：** 在应用程序安装期间，RAC 是依赖于 Android 允许的权限执行的。诸如 root 漏洞利用之类的恶意活动通过在 manifest.xml 文件中未请求权限来指示。

**已使用权限（UP）：** 无论应用程序是否针对恶意活动，都可以从 UP 和 RAC 初步识别。Android 可以定义与预装系统权限不同的新权限，并用于调整其访问权限。

**可疑的 API 调用（SAC）：** 可疑的 API 调用意味着 getDeviceId()、Cipher.getInstance()、Runtime.exec() 等，这些调用允许获取与恶意 API 调用相关的设备的敏感信息，其中一些用于混淆。

**网络地址（NA）：** 网络地址经常被恶意软件用于执行外部命令或传递数据，它最小化了任何人可以通过网络传输的个人或敏感数据的数量。

### 3.5 特征排序

在这个阶段，从特征的排名列表中选择一个高排名的特征集来训练和测试一个机器学习模型。选择的高排名特征集的数量，例如 1、2、3、4、5、6、7 和 8 个特征集，是依次选择的。首先，通过 CART 算法计算特征排名，并根据训练机器学习技术期间每个特征的系数值计算。然后，对每个特征进行 100 次计分，以获得更稳定的评分，从而得到平均分数。

### 3.6 功能性能检查

在这个阶段，将评估选定特征与相应机器学习技术的性能。注意到这里也是机器学习技术为每次模拟提供不同结果的地方，因为测试训练是随机的。为了使其合理，已经应用了 100 次循环，从中计算出每个特征集的平均准确性。

### 3.7 基于性能的最终选择

从功能性能来看，可以很容易地选择在训练该模型期间哪些特征对机器学习技术产生了更大的影响，这将为开发反恶意软件工具奠定坚实的基础。

已经提到，对于特征排名和训练，应用并评估了相同的 ML 技术。

## 4 评估参数和使用的机器学习技术

### 4.1 评估矩阵

本研究中进行了二元分类，将数据标记为恶意软件或良性，并在此研究中进行了负面或正面标签的二元分类。这种分类的决策已由一个结构表示。混淆矩阵就是这个结构，通过它可以评估分类器的决策[48] Townsend。它由 4 个属性组成：真正例（TP）、真负例（TN）、假正例（FP）和假负例（FN）。真正例（TP）意味着将良性应用正确地识别为良性。将恶意软件识别为良性被定义为假正例（FP）。将恶意软件正确识别为恶意软件称为真负例（TN）。假负例（FN）意味着将良性的标识为恶意软件 Davis[49]。F1 分数、精确度、召回率、ROC 曲线、精确度-召回率曲线、混淆矩阵、假阳率和 AUC Sokolova 和 Boyd[50, 51] 在本研究中用于评估 IFIFDroid 的有效性。

**ROC 曲线：**一条具有两个绘图的曲线，其中 False Positive Rate 在 x 轴上，True Positive Rate 在 y 轴上。将恶意软件的比例或将负值错误分类为良性或正值的分数称为 False Positive Rate - FPR。而 True Positive Rate - TPR 是 FPR 的相反。

**精确度-召回率曲线：**一条具有两个绘图的曲线，其中召回率在 x 轴上，精确度在 y 轴上。召回率与 TPR 完全相同。正确识别真值为真的速率被称为精确度。

**准确度：**根据总数据量正确识别数据的比率称为准确度，定义如下.![$$\begin{aligned} \text {Accuracy} = (\mathrm{TP} + \mathrm{TN}) / (\mathrm{TP} + \mathrm{TN} + \mathrm{FP} + \mathrm{FN}) \end{aligned}$$](img/507793_1_En_8_Chapter_TeX_Equ3.png)

### 4.2 机器学习算法

机器学习可以被定义为使机器获得现代信息、未使用的能力、重新组织当前信息的思考过程。它被广泛应用，并指的是从大型数据集中推断模式或基于通过分析可用已知数据所学到的内容创建新记录的预测能力的常用方法。机器学习技术通常可以分为两类：有监督学习和无监督学习。以下是本研究中使用的一些机器学习算法：

+   极端随机树 - Extra Tree（ET）

+   随机森林（RF）

+   决策树（DT）

+   Ada 提升（ADA）

+   梯度提升（GB）

这些算法有不同的类别，包括：机器学习、集成（装袋分类器）和提升树，这些在本研究中被使用。

## 5 实验结果分析与讨论

在本节中，将描述和简要评估提出方法的实施和评估结果。为了清晰地表示，特征被标记为表 2。表 2

特征集的表示

| S/L | 特征集名称 | 简称 | 设置格式 |
| --- | --- | --- | --- |
| 1 | 硬件组件 | HC | {HC[1], HC[2],............, HC[n]} |
| 2 | 请求的权限 | RP | {RP[1], RP[2],............., RP[n]} |
| 3 | 应用组件 | AC | {AC[1], AC[2],............., AC[n]} |
| 4 | 过滤的意图 | FI | {FI[1], FI[2],................, FI[n]} |
| 5 | 限制的 API 调用 | RAC | {RAC[1], RAC[2],........., RAC[n]} |
| 6 | 已使用权限 | UP | {UP[1], UP[2],.............., UP[n]} |
| 7 | 可疑的 API 调用 | SAC | {SAC[1], SAC[2],..........., SAC[n]} |
| 8 | 网络地址 | NA | {NA[1], NA[2],............., NA[n]} |

表 2 表示了所有特征集的简称及特征集的构造。例如，硬件组件可能是一组多个组件，如 {GPS，相机，......，触摸屏}。该数据集中对此集合的表示为 {1，0，......，1}，其中 1 表示这些组件在应用程序中被使用，如果未使用则标记为 0。

图 3

所有已实施的机器学习技术的特征集平均排名的比较

对于所有算法的比较发现，从总共 8 个特征集中选取的 7 个特征集提供了最大的准确性。不同机器学习技术的最有影响的特征数和准确性分别在图 3 和 4 中描述。

图 4

所有已实施的机器学习技术基于特征排序的准确性比较

表 3

每种机器学习技术的特征排序

| 特征集 | ET | RF | DT | GB | ADA | 平均排名 |
| --- | --- | --- | --- | --- | --- | --- |
| RP | 1 | 1 | 1 | 1 | 1 | 1 |
| NA | 2 | 2 | 2 | 2 | 4 | 2.4 |
| HC | 4 | 6 | 5 | 5 | 7 | 5.4 |
| AC | 5 | 3 | 3 | 4 | 5 | 4 |
| SAC | 3 | 5 | 4 | 3 | 2 | 3.4 |
| RAC | 7 | 7 | 7 | 6 | 3 | 6 |
| UP | 8 | 8 | 8 | 8 | 8 | 8 |
| FI | 6 | 4 | 6 | 7 | 6 | 5.8 |

据表 3 表明，对于所有分类器，UP 的平均影响较低。另一方面，RP 也是一组权限，作为检测安卓恶意软件的特征集，位于第一位置。此外，RAC 仅在 ADA 提升算法排名中获得第三位置，而 SAC 则在每种算法中的排名波动较大。总之，RP、NA、SAC、AC、HC、FI 和 RAC 的特征集是最有影响力和排名最高的。最后，已实施传统包装法以验证提出的模型，并发现提出的方法可以提高检测的准确性，而不是传统包装法。还发现，与传统包装法相比，准确性差异并不大。但是，该模型表明可以改进传统的包装法。提出的方法与传统包装法的总体比较已在表 4 中列出。

提出方法与包装法的性能比较

| 机器学习技术 | 包装法 - 准确性 | 提出的方法 - 准确性 |
| --- | --- | --- |
| ET | 92.87% | 93%，使用 7 个特征集 |
| RF | 92.15% | 92.73%，使用 7 个特征集 |
| DT | 90.12% | 90.49%，使用 6 个特征集 |
| GB | 88.43% | 88.73%，使用 7 个特征集 |
| ADA | 84.56% | 84.68%，使用 7 个特征集 |

## 结论

提出了一种名为 IFIFDroid 的特征选择框架，并通过多种算法（如决策树、随机森林、极端随机树和梯度树提升）由机器学习方法执行，在 DREBIN 数据集上执行静态分析以检测 Android 上的恶意软件。然而，已经对 Android 恶意软件应用程序进行了静态分析，考虑了包括权限、API 调用、意图过滤器、应用组件和系统调用特征在内的特征。在本文中，只考虑了八种类型的特征集。然而，还有更多的特征集将通过 IFIFDroid 进行检查和评估。还有一个重要的要点要提到，与现有的包装方法相比，准确性的差异仍然不显著，并且在未来，通过更改一些参数来提高特征排序、选择然后检测的准确性，框架将得到改进。
