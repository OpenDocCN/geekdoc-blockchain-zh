["```\npragma solidity ^0.4.0;\ncontract Ballot {\n\n    struct Voter {\n        bool voted;\n        uint weight;\n        uint8 vote;\n        address delegate;\n    }\n    struct Proposal {\n        uint voteCount;\n    }\n    enum Stage {Init,Reg, Vote, Done}\n    Stage public stage = Stage.Init;\n\n    address president;\n    mapping(address => Voter) voters;\n    Proposal[] proposals;\n\n    event votingCompleted();\n\n    uint startTime;\n    //modifiers\n   modifier validStage(Stage reqStage)\n    { require(stage == reqStage);\n      _;\n    }\n\n    /// new ballot with $(_numProposals) different\nproposals.\n    function Ballot(uint8 _numProposals) public {\n        president = msg.sender;\n        voters[president].weight = 5;\n        proposals.length = _numProposals;\n        stage = Stage.Reg;\n        startTime = now;\n    }\n    /// $(toVoter) is given the right to vote on ballot.\n    /// only call by $(president).\nfunction register(address toVoter) public validStage\nStage.Reg) {\n        //if (stage != Stage.Reg) {return;}\n        if (msg.sender != president || voters[toVoter].\nvoted) return;\n        voters[toVoter].weight = 1;\n        voters[toVoter].voted = false;\n        if (now > (startTime+ 30 seconds)) {stage =\nStage.Vote; }\n    }\n\n    /// give a single vote to proposal $(toProposal).\n    function vote(uint8 toProposal) public\nvalidStage(Stage.Vote) {\n        // if (stage != Stage.Vote) {return;}\n        Voter storage sender = voters[msg.sender];\n        if (sender.voted || toProposal >= proposals.\nlength) return;\n        sender.voted = true;\n        sender.vote = toProposal;\n        proposals[toProposal].voteCount += sender.\nweight;\n        if (now > (startTime+ 30 seconds)) {stage =\nStage.Done; votingCompleted();}\n    }\n\n    function winner() public validStage(Stage.Done)\nconstant returns (uint8 _winner) {\n        //if(stage != Stage.Done) {return;}\n        uint256 winningVoteCount = 0;\n        for (uint8 prop = 0; prop < proposals.length;\nprop++)\n            if (proposals[prop].voteCount > winningVote\nCount){ \n                winningVoteCount = proposals[prop].\nvoteCount;\n                _winner = prop;\n            }\n        assert  (winningVoteCount > 0);\n    }\n}\n\n```", "```\npragma solidity 0.4.24;\ncontract Election {\n    struct Candidate {\n        uint id;\n        string name;\n        uint voteCount;\n    }\n    bool curr = true;\n    mapping(address => bool) public voters;\n    mapping(uint => Candidate) public candidates;\nuint public candidatesCount; \n    event voted (\n        uint indexed _candidateId\n    );\n\n    constructor () public {\n        addCandidate(\"Candidate 1\");\n        addCandidate(\"Candidate 2\");\n        addCandidate(\"Candidate 3\");\n        addCandidate(\"Candidate 4\");\n        addCandidate(\"Candidate 5\");\n        addCandidate(\"Candidate 6\");\n        addCandidate(\"Candidate 7\");\n        addCandidate(\"Candidate 8\");\n    }\n    function add (string memory _name) private {\n        candidateCount ++;\n        candidates[candidateCount] =\nCandidate(candidateCount, _name, 0);\n    }\n\n    function end () public {\n        curr = false;\n    }\n\n    function vote (uint _candidateId) public {\n        require(!voters[msg.sender],\"Already voted\"); require(_candidateId > 0 && _candidateId <=\ncandidatesCount,\"Invalid candidate\");\n        require(curr,\"Election ended\");\n\n        voters[msg.sender] = true;\n\n        candidates[_candidateId].voteCount ++;\n\n        emit voted(_candidateId);\n    }\n}\n\n```", "```\nfrom flask import Flask, render_template, flash,\nrequest, session, redirect, url_for\nfrom wtforms import Form, TextField, TextAreaField,\nvalidators, StringField, SubmitField\nimport requests;\nimport json;\n\nbackend_addr = \"https: //election-backend.net/\"\n\napp = Flask(__name__)\napp.secret_key = 'helloworld'\n\n@app.route(\"/\", methods=['GET', 'POST'])\ndef home():\n    return redirect(url_for('verify'))\n\n@app.route(\"/results\", methods=['GET'])\ndef results():\n    try:\n        req = requests.get(backend_addr+'results')\n        if(req.status_code!=200):\n            return render_template('confirm.\nhtml',message=req.text),req.status_code\n        result = eval(req.text)\n        print(result)\n        result.sort(reverse=True,key=lambda x: x[2])\n        return render_template('results.html',result=result)\n    except:\n        return render_template('confirm.html',\nmessage=\"Error processing\"),500\n\n@app.route(\"/verify\", methods=['GET', 'POST'])\ndef verify():\n    try:\n        req = requests.get(backend_addr+'isended')\n        if(not eval(req.text)):\n            if request.method == 'POST':\n                aid = request.form['aid']\nbio = request.form['biometric'] \n                req\n= requests.get(backend_addr+'number_of_users')\n                number_of_accounts = int(req.text)\n                if(bio == 'yes' and aid.isdigit() and\nint(aid)<=number_of_accounts):\n                    session['verified'] = True\n                    session['aid'] = int(aid)\n                    return redirect(url_for('vote'))\n                return render_template('verification.html')\n            else:\n                return render_template('confirm.html',\nmessage=\"Election ended\",code=400),400\n    except:\n        return render_template('confirm.html',\nmessage=\"Error processing\"),500\n\n@app.route(\"/vote\", methods=['GET', 'POST'])\ndef vote():\n        req = requests.get(backend_addr+'isended')\n        if(not eval(req.text)):\n            if('verified' in session):\n                req\n= requests.get(backend_addr+'candidates_list')\n                candidates = eval(req.text) print(candidates) candidates1 = candidates[:int(len\n(candidates)/2)]\n                candidates2 = candidates[int(len\n(candidates)/2):]\n                if  request.method == 'POST':\n                    aid = session['aid']\n                    session.pop('verified')\n                    session.pop('aid')\n                    candidate = request.form['candidate']\n                    cid = candidates.index(candidate)+1\n                    print(cid)\n                    req = requests.post(backend_\naddr,json.dumps({'aadhaarID':aid,'candidateID':cid}))\n                    print(req)\n                    return render_template('confirm.\nhtml',message=req.text,code=req.status_code),req.\nstatus_code\n                return\nrender_template('vote.html',candidates1=candidates1,\ncandidates2=candidates2),200\n            else:\n                return redirect(url_for('verify'))\n        else:\n            return render_template('confirm.\nhtml',message=\"Election ended\",code=400),400\n\nif __name__ == '__main__':\n    app.run(host=\"0.0.0.0\", port=80, debug = True)\n\n```"]