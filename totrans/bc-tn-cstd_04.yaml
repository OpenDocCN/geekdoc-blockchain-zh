- en: © The Author(s), under exclusive license to APress Media, LLC, part of Springer
    Nature 2023B. Wu, B. WuBlockchain for Teens[https://doi.org/10.1007/978-1-4842-8808-5_4](https://doi.org/10.1007/978-1-4842-8808-5_4)
  prefs: []
  type: TYPE_NORMAL
- en: '4. Ethereum: A Gateway to Cryptocurrency'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Brian Wu^([1](#Aff3)  ) and Bridget Wu^([1](#Aff3))(1)Livingston, NJ, USA
  prefs: []
  type: TYPE_NORMAL
- en: Alan Turing, a mathematician, logician, and computer scientist, is widely considered
    to be the father of computer science. In the 1930s, he invented the Universal
    Turing Machine. Assuming enough memory is available, the Turing Machine could
    calculate anything using only two symbols (0 or 1) arranged in a potentially infinite
    one-dimensional sequence. This is the basis for the first computer. Turing-completeness,
    therefore, refers to any computation problem that can be solved and implemented
    in a Turing-complete environment, no matter how complex.
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum, the second-largest cryptocurrency after Bitcoin, is considered a distributed
    Turing machine. It introduced a built-in Turing-complete programming language—smart
    contract, which can be used for creating various decentralized applications (also
    called Dapps).
  prefs: []
  type: TYPE_NORMAL
- en: The previous chapter introduced Bitcoin as the first embodiment of blockchain
    technology and the world’s most popular cryptocurrency.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll continue exploring the Ethereum blockchain, built as
    a Turing-complete blockchain. The chapter begins with the history of Ethereum.
    From there, we cover many Ethereum basic concepts and elementary operations, including
    Ether, Gas, and Ethereum Account. Then, for a deeper and more comprehensive understanding
    of Ethereum, we explore a big-picture overview of the Ethereum Virtual Machine
    (EVM). We will also see the important Ethereum clients and node implementations.
    Finally, we discuss how Ethereum works and explores the internal Ethereum architecture.
  prefs: []
  type: TYPE_NORMAL
- en: One of this chapter’s goals is to help you acquire the necessary technical background
    to understand Ethereum mechanics and get you ready to develop your first decentralized
    application in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter is organized around a few major topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The history of Ethereum
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting to know Ethereum
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How Ethereum works
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The History of Ethereum
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Vitalik Buterin is a Russian-Canadian writer and programmer who has been involved
    in Bitcoin and crypto since 2011 just two years after Bitcoin was created. Vitalik
    became a writer, earning 5 Bitcoins for every post for the Bitcoin Magazine website.
    Soon, he became the co-founder of *Bitcoin Magazine*. Having improved his understanding
    of Bitcoin, Buterin became a Bitcoin expert and realized the limited functionality
    of Bitcoin. In 2013, for six months, Vitalik traveled around the world to learn,
    meet, and speak with Bitcoin developers. He recognized that he could build a new,
    potentially better version of blockchain by iterating on the Bitcoin.
  prefs: []
  type: TYPE_NORMAL
- en: Whitepaper Released (November 2013)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In November 2013, Vitalik, just 19 years old, published a white paper entitled
    *Ethereum: A Next-Generation Smart Contract and Decentralized Application Platform*,
    exploring the general idea of Ethereum.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The white paper explaining the concept of Ethereum that includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It provides a built-in Turing-complete programming language that can be used
    to create a “smart contract”—simply a self-executing program that runs on the
    blockchain.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It establishes peer-to-peer transactions in the blockchain. The platform can
    create and build a smart contract and decentralized application, allowing anyone
    to define, create, and exchange types of value: cryptocurrencies, shares, and
    many other assets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Yellow Paper Released (April 2014)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In April 2014, Dr. Gavin Wood published the Ethereum yellow paper, giving a
    technical definition of the Ethereum protocol—Ethereum: a secure decentralized
    generalized transaction ledger, which describes a technical definition of the
    Ethereum protocol.'
  prefs: []
  type: TYPE_NORMAL
- en: The Birth of Ethereum (July 2014)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ethereum was publicly announced at the North American Bitcoin Conference in
    Miami in January 2014\. Ethereum Foundation, as a nonprofit organization, was
    formed on July 6th, 2014, in Zug, Switzerland. Ethereum’s founding members were
    Vitalik Buterin, Gavin Wood, Charles Hoskinson, Anthony Di Iorio, Mihai Alise,
    and Joe Lubin.
  prefs: []
  type: TYPE_NORMAL
- en: Launching the Ether Sale (July–September 2014)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On July 20th, 2014, the Ethereum Foundation launched a 42-day crowdfunding campaign.
    On September 2nd, 2014, the public crowd sale ended. Ethereum foundation raised
    31,591 Bitcoin, that’s about $18 million at the time of the sale’s close.
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum Released (June 2015)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: During 2014 and 2015, many proofs-of-concept were developed. “Olympic” was the
    ninth and last prototype. On June 30, 2015, Ethereum went live, and the first
    “genesis block” was created.
  prefs: []
  type: TYPE_NORMAL
- en: DAO Attack (July 2016)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In May 2016, a Decentralised Anonymous Organisation (DAO) was created on the
    Ethereum blockchain by developers. The DAO uses a smart contract to self-govern
    and automate decisions without a typical centralized management structure. Anyone
    has the right to participate and vote regardless of their location. The first
    DAO crowd sale is very successful. It raised a record 12.7M Ether (worth around
    $150 million at the time) to fund the project.
  prefs: []
  type: TYPE_NORMAL
- en: However, on June 17, 2016, a hacker exploited some vulnerabilities in the smart
    contract of the DAO. The hacker was able to invoke the DAO smart contract to give
    the Ether back multiple times before the smart contract could update its balance.
    The hackers managed to steal more than 3.6 million ETH (worth around $50 million
    at the time).
  prefs: []
  type: TYPE_NORMAL
- en: Because of the huge amount of funds lost among DAO investors, the Ethereum community
    decided to reverse the attack to refund the lost money, which lead to Ethereum
    forked into two blockchains. One is the current Ethereum blockchain. The token
    owners were given an exchange rate of 1 ETH to 100 DAO tokens, the same rate as
    the initial offering. The lost funds of the DAO investors were recovered. In September
    2016, digital exchange currencies de-listed the DAO token. In the meantime, part
    of the Ethereum community did not agree with the hard fork and decided to continue
    to maintain the old blockchain, which is now known as Ethereum Classic.
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum 2.0 (The Merge)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In recent years, the Ethereum community started to migrate from Ethereum 1.0
    to Ethereum 2.0, also known as Eth2, The Merge, or Serenity. Ethereum 1.0 was
    created based on a proof-of-work blockchain. Compared to Ethereum 1.0, 2.0 has
    several major advantages. Table [4-1](#Tab1) shows these differences.Table 4-1
  prefs: []
  type: TYPE_NORMAL
- en: Comparing Ethereum 1.0 and 2.0
  prefs: []
  type: TYPE_NORMAL
- en: '|   | Ethereum 1.0 | Ethereum 2.0 |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Consensus | Uses proof-of-work (PoW) consensus. | Uses proof-of-stake (PoS)
    consensus. |'
  prefs: []
  type: TYPE_TB
- en: '| Speed | The network can process around 15 transactions per second (15 TPS);
    it often causes network congestion and delay. | The ETH 2.0 network will scale
    up to a potential 100,000 TPS, compared to Visa, 30,000 TPS. |'
  prefs: []
  type: TYPE_TB
- en: '| Energy | Proof-of-Work requires miners to consume large amounts of computing
    power to solve a complex mathematical puzzle. | Ethereum 2.0 use PoS Consensus
    by staking its tokens as a collateral asset to check and validate the transactions
    and add block. It requires minimum hardware power, which can reduce 99% fewer
    resources than the proof of work consensus. |'
  prefs: []
  type: TYPE_TB
- en: '| Security | Some powerful group of miners could control more than 50% of the
    network’s activities which could lead to vulnerabilities like a 51% attack. |
    In Ethereum 2.0, it is more decentralized. The network requires around 16,384
    validators. The user just needs to stake 32 ethers to participate in validating
    the Ethereum network. Even with less ether, users can join a mining pool that
    enables everyone to stake together and share the rewards. There are no miners
    controlling the blockchain. |'
  prefs: []
  type: TYPE_TB
- en: '| Gas fee (transaction fees) | As the network can only handle a limited number
    of transactions per second, leading to high transaction fees known as “gas,” and
    slow transactions. Typically, avg gas fee per transaction is around $12\. With
    demand rising sharply, the gas fee could be much higher, such as $100. | The Ethereum
    2.0 uses PoS consensus to process transactions that require a nearly zero gas
    fee. So, it just charges some basic fee to avoid malicious activities on the Network.
    | There are three phases to launching Ethereum 2.0, it will take several years
    to completely roll out Ethereum 2.0 as Figure [4-1](#Fig1) shows.![](../images/535492_1_En_4_Chapter/535492_1_En_4_Fig1_HTML.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: An illustration of three phases of Ethereum 2.0 depicts Ethereum 1.0 to Ethereum
    2.0 from phase 0 of beacon chain, to phase 1 of merge, and lastly phase 2 of shard
    chain.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4-1
  prefs: []
  type: TYPE_NORMAL
- en: Three phases of Ethereum 2.0
  prefs: []
  type: TYPE_NORMAL
- en: Phase 0 – Beacon Chain
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Phase 0 started with the official launch of Beacon Chain in December 2020\.
    Beacon Chain builds based PoS in the Ethereum network and manages the registry
    of validators.
  prefs: []
  type: TYPE_NORMAL
- en: Phase 1 – Merge
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Ethereum main net merged with the Beacon Chain in this phase. It officially
    ends the POW consensus on the network and starts with PoS. On September 15, 2022,
    Ethereum switched from the original proof-of-work mechanism to proof-of-stake,
    called “the merge.” The merge reduced Ethereum’s energy consumption by ~99.95%.
  prefs: []
  type: TYPE_NORMAL
- en: Users who staked Ethereum on the Beacon Chain can become validators.
  prefs: []
  type: TYPE_NORMAL
- en: Transactions and Dapps will continue to run the same behavior as before.
  prefs: []
  type: TYPE_NORMAL
- en: Phase 2 – Shard Chain
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this phase, Shard Chains will introduce to the network. At the same time,
    the Ethereum main network will be split into 64 shards. Each shard can run a fully
    functional smart contract. The network allows each shard to communicate with each
    other.
  prefs: []
  type: TYPE_NORMAL
- en: Getting to Know Ethereum
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the Bitcoin network, Bitcoin is digital gold, designed as a medium of exchange
    and a way to store value. Bitcoin provides a payment way for people who can transfer
    value from one to another using a decentralized way without a central bank. On
    the other hand, the Ethereum network is built as a Turing-complete blockchain.
    The network was built in a Turing-complete programming language called Solidity,
    which can run in the Ethereum Virtual Machine (EVM). Users can create and run
    decentralized applications (Dapps) in EVM. EVM is where all Ethereum accounts
    and smart contracts live. As the native currency in the Ethereum blockchain, Ether
    was used internally by Dapp in the Ethereum network to process transactions. For
    example, when a smart contract executes a transaction, Dapp must pay a gas fee
    (Ether) for the miner to perform mining work.
  prefs: []
  type: TYPE_NORMAL
- en: Ether (Unit)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each blockchain has its own native currency. Similar to Bitcoin, the native
    currency is called Ether (ETH) in the Ethereum blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: Ether acts as the “fuel,” to pay for the execution of smart contracts on the
    EVM. When miners solve the computational puzzle, they will get Ether as a currency
    reward. Ether can also be used for payments and users can send ether to other
    users as payment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like the US dollar, which come in seven denominations: $1, $2, $5, $10, $20,
    $50, and $100, Ether is broken into denominations. The smallest denomination unit
    of ether is called Wei, named after a digital money and cryptography pioneer,
    Wei Dai. Wei created Crypto++ cryptographic library and invented B-money. Other
    units include a Gwei, Mwei, Kwei, microether, and milliether. They are known by
    other names as well. For example, a milliether is also called Finney, named after
    another digital money pioneer, Harold Thomas Finney II, who in 2004 implemented
    the world’s first reusable proofs of work system (RPOW) before Bitcoin. In January
    2009, Finney was the recipient of the Bitcoin network’s first transaction. Table
    [4-2](#Tab2) lists the named denominations of Ether and other units:Table 4-2'
  prefs: []
  type: TYPE_NORMAL
- en: Ether denominations and unit name
  prefs: []
  type: TYPE_NORMAL
- en: '| Unit Name | Value (in Wei) | Ether |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Wei | 1 wei | 10^(-18) ETH |'
  prefs: []
  type: TYPE_TB
- en: '| Kilowei (Babbage) | 1,000 wei | 10^(-15) ETH |'
  prefs: []
  type: TYPE_TB
- en: '| Mwei (Lovelace) | 10⁶ wei | 10^(-12) ETH |'
  prefs: []
  type: TYPE_TB
- en: '| Gwei (Shannon) | 10⁹ wei | 10^(-9) ETH |'
  prefs: []
  type: TYPE_TB
- en: '| Microether (Szabo) | 10^(12) wei | 10^(-6) ETH |'
  prefs: []
  type: TYPE_TB
- en: '| Millether (Finny) | 10^(15) wei | 0.001 ETH |'
  prefs: []
  type: TYPE_TB
- en: '| Ether | 10^(18) wei | 1 ETH |'
  prefs: []
  type: TYPE_TB
- en: Gas, Gas Price, and Gas Limit
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Like Bitcoin, Ethereum currently uses a proof-of-work (PoW) consensus mechanism.
    It required miners to compute and solve complex mathematical puzzles, verify transactions,
    and create a block of transactions to be added to the blockchain. A miner is rewarded
    with Ether (ETH). When users submit transactions, they need to pay Ether for the
    miner to execute such work.
  prefs: []
  type: TYPE_NORMAL
- en: According to coinwarz.com, assume you use a machine with a hash rate of 750.00
    MH/s (Megahashes per second) and 1350 power consumption in watts. You need about
    $20,000\. Assume the cost of electricity is $0.10 per kWh (depending on your location,
    the average is $0.14/kWh in the United States). It will take up to around 103
    days to mine one Ether. The current ether price is around $1100, it will take
    a while to become profitable. Figure [4-2](#Fig2) shows the result of the Ethereum
    mining calculator.![](../images/535492_1_En_4_Chapter/535492_1_En_4_Fig2_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: 3 radial gauge of mining revenue, mining fees, and electricity costs along with
    values for Ethereum mining hashrate, power consumption, electricity costs, pool
    fees, and E T H mined per hour and day.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4-2
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum mining calculator
  prefs: []
  type: TYPE_NORMAL
- en: Gas refers to such fees required to execute a transaction on Ethereum successfully,
    that is, the fees that need to be paid to miners for processing transactions.
  prefs: []
  type: TYPE_NORMAL
- en: One of the commonly used Ether units is Gwei. It is used to specify Ethereum
    gas prices and pay for transaction fees. For example, one Gwei is the same as
    0.000000001 ETH. If a transaction cost is 0.000000050 ETH, we can say that the
    cost was 50 Gwei.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the current Ethereum blockchain, the standard transaction fee is 21,000
    Gwei. The gas fee can be calculated using the following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: Total Fee = Gas unit (limits) * (Base fee + Tip)
  prefs: []
  type: TYPE_NORMAL
- en: '**Gas units (limits)** – This refers to the maximum amount of gas you want
    to spend to execute a transaction.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Base fee** – It refers to a minimum amount of gas fee that requires a user
    transaction to be included in a block. The base fee amount is automatically dynamic
    and calculated by Ethereum based on market demand at any given time.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Tips** – Also known as a priority fee, a miner tip. It is an optional fee,
    determined by the user and directly paid to miners. The priority fee helps your
    transaction can be picked and processed faster by the miner.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a real Ethereum blockchain transaction as an example (see Figure
    [4-3](#Fig3), the data is from etherscan.io) and calculate the cost of an Ethereum
    transaction today.![](../images/535492_1_En_4_Chapter/535492_1_En_4_Fig3_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: An image represents the E T H transaction cost consisting of status, block,
    timestamp, value, transaction fees, gas price, gas limit, and gas fees.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4-3
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum transaction cost (etherscan.io)
  prefs: []
  type: TYPE_NORMAL
- en: From the preceding example, a transaction’s gas limit is 201,027 units, the
    base fee is 33.529 Gwei, and the priority fee is 1.101 Gwei; the total transaction
    fees to execute the transaction would be 0.006961 ETH (201,027* (33.529 + 1.101)
    = 2,310,000 Gwei). In the current market, one Ether is around $1100 so this transaction
    fee is about 0.006961* 1100 = $7.65.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that if you pay less than the required transaction fee,
    the transaction will be reverted, and you won’t receive your gas fee back because
    the miners have done the amount of mining work to process your transaction. They
    would collect the fee for their work even if the transaction failed. On the other
    hand, if you pay more gas fees, the extra gas fee will return to you once the
    transaction is complete. In the preceding example, there is field “usage by Txn”
    indicated that only 40.21% gas fee was used, the remaining fee will return to
    the user (500,000 - 201,027 = 298,973).
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum Account
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Each Ethereum account has an Ethereum address. Ethereum has two types of accounts:
    Externally Owned Account (EOA) and Contract Account.'
  prefs: []
  type: TYPE_NORMAL
- en: Externally Owned Account (EOA)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: An Externally Owned Account is controlled by a public/private key pair owned
    by a user. In Chapter [2](535492_1_En_2_Chapter.xhtml), we have learned how the
    Ethereum address is derived from the public key using Keccak-256 hashes. Each
    Ethereum addresses are 42 hex string characters starting with 0x, representing
    a hexadecimal format. There is no cost to create an Ethereum account. The Externally
    Owned Account can be used for fund (Ether) transfer or send transactions to smart
    contracts. You need the private key to access your fund or send funds to other
    people.
  prefs: []
  type: TYPE_NORMAL
- en: Contract Account (CA)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A contract account is controlled by code executed by the Ethereum Virtual Machine.
    These codes are typically referred to as the smart contract code. Creating a contract
    account is costly because it will use network storage. A contract account can
    do Ether transfers and create Smart Contract accounts.
  prefs: []
  type: TYPE_NORMAL
- en: Figure [4-4](#Fig4) highlights the USDT token smart contract creator address,
    which is a contract account:![](../images/535492_1_En_4_Chapter/535492_1_En_4_Fig4_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: A screenshot of the U S D T contract account with many fields. On left, contract
    overview lists values of balance, ether value, and token. On the right, more info
    lists status of My name tag, contract creator, and token tracker. On top right
    is 4 pop-up buttons.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4-4
  prefs: []
  type: TYPE_NORMAL
- en: USDT Contract account (etherscan.io)
  prefs: []
  type: TYPE_NORMAL
- en: 'All accounts have four common fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Nonce** – Each address has a nonce, which represents the transaction count
    of an account. Different account addresses can have the same nonce. The number
    used in nonce is unique to prevent double-spending situations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Balance** – It is the Ether owned by this account.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Storage hash** – Sometimes it is called storageRoot. Each Ethereum contract
    account has its own storage trie (ordered tree data structure) where the contract
    data is present. StorageRoot is a Merkle Patricia trie of the current contact
    state as a mapping between 32-byte integers. A 256-bit hash value is calculated
    based on these contract data. The hash value will change anytime when its state
    charges. It could be used to verify the past state. Storage hash is only for contract
    accounts. Figure [4-5](#Fig5) represents Ethereum account storageRoot.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../images/535492_1_En_4_Chapter/535492_1_En_4_Fig5_HTML.png)'
  prefs: []
  type: TYPE_IMG
- en: Account storage trie has circular diagram with of root node divided into 2 blocks
    and those 2 blocks divided into 2 blocks. Root node leads to storageRoot.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4-5
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum account storageRoot
  prefs: []
  type: TYPE_NORMAL
- en: '**Code hash** – It refers to your contract’s code under this account on the
    EVM. It’s immutable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../images/535492_1_En_4_Chapter/535492_1_En_4_Fig6_HTML.png)'
  prefs: []
  type: TYPE_IMG
- en: A rectangular block of Ethereum account has blocks of account address 1 to n.
    Account address 1 leads to account state that has 4 text circles for nonce, balance,
    storage hash, and code hash. Storage and code hash leads to E V M account and
    code respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4-6
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum account structure
  prefs: []
  type: TYPE_NORMAL
- en: Smart Contract
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A contract is a written and oral arrangement between two or more parties to
    do certain things.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are just a few examples in our everyday life:'
  prefs: []
  type: TYPE_NORMAL
- en: '**House rental contract** – A lease agreement between a landlord who rents
    a property to a tenant in exchange for monthly payments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Landscaping contract** – An obligation between the landscaper and the client.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Software license agreements** – An agreement between the software company
    and customers to offer the right to use software legally.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Personal loan** – A written agreement between a lender that lends money to
    a borrower in exchange for a refund plus interest.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An effective contract will describe the formal requirements in detail, the responsibilities
    each party must follow, when and how contract items ought to be performed, and
    what happens when these rules are not followed. As a result, contracts act as
    a reliable document for each party expected to meet as planned.
  prefs: []
  type: TYPE_NORMAL
- en: Smart contracts are very similar, but the contracts are implemented for these
    detailed agreements by using computer code. They can’t be changed once created
    in a decentralized blockchain network. When the conditions are met, smart contracts
    will be executed automatically instead of by a third party. Since blockchain is
    decentralized, immutable, and transparent, everyone in the network can publicly
    verify the smart contract transaction result.
  prefs: []
  type: TYPE_NORMAL
- en: Nick Szabo was the first person to describe smart contracts. He published a
    paper *The Idea of Smart Contracts* in 1997\. He imagined converting contracts
    into code to achieve self-enforcing contracts that removed the need for trust
    among the parties. To illustrate his concept, Nick used a vending machine to explain
    how smart contracts work. When you insert the correct amount of money into the
    machine, you get the desired product. The software instructions inside the vending
    machine guarantee that the contract will be fulfilled as intended. Today, this
    idea has now spread all over the world.
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum is the most popular smart contract platform. Anyone can create smart
    contracts in the blockchain. The code is transparent and publicly verifiable.
    Everyone can see what kind of implementation logic is for smart contracts. Here
    is an example of SHIBA INU from etherscan.io.![](../images/535492_1_En_4_Chapter/535492_1_En_4_Fig7_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: A screenshot of the ethereum S H I B A I N U contract depicts a token application
    of the overview field select contract, and profile summary. At the top right there
    are 4 drop down icons.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4-7
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum SHIBA INU contract example
  prefs: []
  type: TYPE_NORMAL
- en: In Ethereum, smart contracts are written in a variety of programming languages,
    including Solidity and Vyper. Solidity is the most popular Smart contract language
    used in Ethereum as we will explore more in a later section.
  prefs: []
  type: TYPE_NORMAL
- en: Each network computer node stores a copy of all existing smart contract codes
    and their current state alongside transaction data. A user is typically required
    to pay a gas fee to execute the function of the smart contract and include the
    transaction in a new block.
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum Virtual Machine (EVM)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A “Virtual Machine” or “VM” is a simulated computer system you can use to run
    software on a physical computer. Virtual machines are essentially establishing
    an isolate level between a simulated computer system and the running operation
    system like Windows, macOS, or Linux. For instance, using “Parallels Desktop for
    Mac,” you can run Windows on your Apple Mac computer, as shown in Figure [4-8](#Fig8).![](../images/535492_1_En_4_Chapter/535492_1_En_4_Fig8_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: An image of a laptop showing windows running on a Mac laptop. Menu bar is in
    the top left corner and status bar is in the top right corner. 15 icons are present
    in the bottom row.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4-8
  prefs: []
  type: TYPE_NORMAL
- en: VM example – Window runs on Mac
  prefs: []
  type: TYPE_NORMAL
- en: The Ethereum Virtual Machine (EVM) is a Turing-complete virtual machine that
    allows EVM Byte Code runs on an isolated and sandboxed runtime environment. Bytecode
    is compiled from a high-level smart contract programming language such as Solidity.
  prefs: []
  type: TYPE_NORMAL
- en: On Ethereum, smart contracts are typically written in a high-level programming
    language called Solidity. Solidity compiler compiles smart contract into low-level
    binary machine code (Bytecode). A user just needs to send an Ethereum transaction
    containing these Bytecodes, and this transaction doesn’t need to specify any recipient.
    Once the contract transaction is committed to the blockchain, a new Ethereum account
    is created. The contract account stores the contract balance, the contract nonce,
    the code, and the data. The contract account storage hash is effectively a hash
    of the smart contract’s data. The creation of a contract address is determined
    based on the sender’s EOA address and nonce. RLP encoded nonce and EOA address
    data and hashed with keccak-256 algorithm. RLP (Recursive Length Prefix) is the
    way of encoding arbitrarily nested arrays of binary data. When you call a smart
    contract function, you interact with this contract address, and the contract storage
    Opcode will instruct EVM to execute the operation. The contract deployment process
    is illustrated in Figure [4-9](#Fig9).![](../images/535492_1_En_4_Chapter/535492_1_En_4_Fig9_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: A flow chart from a human figure flows through E O A, smart contract, bytecode
    and O P C O D E, contract address, and block diagram of E V M.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4-9
  prefs: []
  type: TYPE_NORMAL
- en: Smart contract deployment
  prefs: []
  type: TYPE_NORMAL
- en: Once the contract is compiled, the compiler will generate Abi, Bytecode, and
    Opcode. ABI (Application Binary Interface) is a JSON (JavaScript Object Notation)
    file that describes the deployed contract and its functions. It allows us to call
    contract functions externally. Bytecode and Opcode (operation code) are compact
    binary representations. They are stored on the blockchain and associated with
    a contract address.
  prefs: []
  type: TYPE_NORMAL
- en: EVM runtime environment will interpret Bytecode to correspond to a series of
    Opcode as a set of instructions and execute the Opcode when the user calls smart
    contracts. Figure [4-10](#Fig10) shows compiled contract Bytecode and Opcode example.![](../images/535492_1_En_4_Chapter/535492_1_En_4_Fig10_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: The bytecode and opcodes. They begin with object and opcodes respectively. The
    codes consist of numbers and alphabets.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4-10
  prefs: []
  type: TYPE_NORMAL
- en: Solidity compiled Bytecode and Opcode example
  prefs: []
  type: TYPE_NORMAL
- en: You can find the Opcodes reference for each Bytecode from Ethereum’s official
    website ([https://ethereum.org/en/developers/docs/evm/opcodes/](https://ethereum.org/en/developers/docs/evm/opcodes/)).
    There are around 148 unique Opcodes, which enable EVM to compute almost any task
    to make it a Turing-complete machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Opcodes can be divided into the following categories:'
  prefs: []
  type: TYPE_NORMAL
- en: Arithmetic operations, comparison, and bitwise logic operations (ADD, SUB, GT,
    LT, AND, OR, etc.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Execution context inquiries (CALL, DELEGATECALL, CALLCODE, etc.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stack, memory, and storage access (POP, PUSH, UP, SWAP, LOAD, STORE, MSSTORE
    8, M SIZE, etc.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Control flow operations (STOP, RETURN, REVERT, etc.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging, calling, and other operators (LOG0, LOG1, LOG2, etc.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s use the preceding Bytecode example to simulate EVM interpreter. We will
    focus on the first 16 bytes of the contract Bytecode: 6080604052348015\. Based
    on Opcode reference, we can translate Bytecode to Opcode, as shown in Table [4-3](#Tab3).Table
    4-3'
  prefs: []
  type: TYPE_NORMAL
- en: Bytecode to Opcode conversion (6080604052348015)
  prefs: []
  type: TYPE_NORMAL
- en: '| Bytecode | Opcode | Reference(Opcode, Name) | Description | Gas |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 60 80 | PUSH1 0x80 | 0x60 = PUSH1, | Duplicate 1st stack item | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| 60 40 | PUSH1 0x40 | 0x60 = PUSH1 | Duplicate 1st stack item | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| 52 | MSTORE | 0x52 = MSTORE | Save word to memory | 3* |'
  prefs: []
  type: TYPE_TB
- en: '| 34 | CALLVALUE | 0x34 = CALLVALUE | Get deposited value by the instruction
    | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| 80 | DUP1 | 0x80 = DUP1 | Duplicate 1st stack item | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| 15 | ISZERO | 0x15 = ISZERO | Simple NOT operator | 3 |'
  prefs: []
  type: TYPE_TB
- en: 'The EVM is a simple stack-based execution machine that will execute Opcode
    instructions. Stack (sometimes called a “push-down stack”) is a linear collection
    of items where the new element is inserted into the last position (referred to
    as the “top”), and the removal of existing items always takes place at the top
    position. It is also called Last In First Out (LIFO). In the preceding interpreted
    Opcode example, we will expect EVM will execute standard stack operations sequentially:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/535492_1_En_4_Chapter/535492_1_En_4_Figa_HTML.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A flow diagram of bytecode to opcode conversion in a text-form with step-by-step
    process.
  prefs: []
  type: TYPE_NORMAL
- en: EVM stack has a depth of *1024* items, each item contains a 256-bit (32 bytes)
    word or 32 chunks where each chunk is 8-bit (1 byte) size. The reason for 256
    bits is mainly to apply the Keccak-256 cryptographic hash function to any number
    of inputs and convert it to a unique 256 bits hash. In EVM, contract can store
    and read data in the above items. The EVM has three places where it can store
    items—storage, memory, and stack.
  prefs: []
  type: TYPE_NORMAL
- en: Memory is the location to hold temporary values for the short term. It will
    be erased between smart contract function calls.
  prefs: []
  type: TYPE_NORMAL
- en: When reading data from memory, EVM will use MLOAD. To write 32 bytes (256-bit)
    of data, Opcode MSTORE will be used. When writing 1 byte (8-bit) of data, EVM
    will use MSTORE8\. Figure [4-11](#Fig11) represents how EVM uses Opcode to read
    and write contract memory.![](../images/535492_1_En_4_Chapter/535492_1_En_4_Fig11_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: A block diagram consists of stacked blocks of memory with push and pop. It has
    the label E V M stack. Inward and outward arrows label M S T O R E and M L O A
    D respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4-11
  prefs: []
  type: TYPE_NORMAL
- en: Opcode read and write contract memory
  prefs: []
  type: TYPE_NORMAL
- en: Storage is where you save data permanently. When a smart contract running in
    EVM uses permanent storage, these data will be part of the Ethereum state. You
    can consider storage as an array in which each array item is 256 bits (32 bytes).
    There are no fees for externally reading the storage value. However, it is very
    expensive to write data into storage, Opcode is SSTORE and the current cost per
    one 32-byte word is 20,000 Gas. Let’s look at how much it costs.
  prefs: []
  type: TYPE_NORMAL
- en: First, convert gas (Gwei) to ETH - 20,000 * 0.000000001 ETH = 0.00002 ETH,
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, calculate cost: $1100*0.00002 = $0.022.'
  prefs: []
  type: TYPE_NORMAL
- en: Writing to storage is more than 6000x the cost compared to writing to memory.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous table (Table [4-3](#Tab3)), we list the first few steps of Opcode
    instruction with gas cost, and every Opcode has its own base gas cost. All Ethereum
    contract executions are run publicly. Attackers could create a contract to perform
    massive, expensive operations (DDoS – Distributed Denial of Service attack) to
    slow down the Ethereum network. By including gas cost in each EVM Opcode execution,
    the Ethereum network can prevent such attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum Nodes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On the Internet, any system or device connected to the network is also called
    a node. The same goes for a blockchain network. When a node is connected to the
    Ethereum network, it will download a copy of the blockchain data and participate
    in the network, communicating with other nodes. Based on etherscan.io data, around
    4,131,021 nodes are connected to the Ethereum network.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three types of nodes: full nodes, archive nodes, and light nodes.
    Each type of node consumes data differently.'
  prefs: []
  type: TYPE_NORMAL
- en: Full Node
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Full nodes will store all the recent blockchain data, run their own EVM environment,
    and can operate EVM instructions. They can be helpful when participating in blockchain
    transaction validation and maintaining the current state of the blockchain. When
    transactions in a new block do not comply with the rules defined in the Ethereum
    specifications, they will be discarded. For example, if Alice sends 50 ETH to
    Bob, but Alice’s account doesn’t have enough ether or pays a very little gas fee
    when a full node verifies transactions, it will mark this transaction as invalid
    and revert it. A full node can directly deploy a smart contract and interact with
    any smart contract in the network.
  prefs: []
  type: TYPE_NORMAL
- en: A full node stores a limited number of most recent blocks. The default is 128
    (or 64 if you use the fast sync option). Each Ethereum block is typically around
    80KB in size or around 4 MB in ten minutes. The 128 blocks are about a recent
    one week of trace data. When you query historical block data that is not accessible
    from a full node, you will generally get the “Missing trie node” error. The error
    means you need an archive node.
  prefs: []
  type: TYPE_NORMAL
- en: When a full node is the first time connected to the network, syncing full node
    data can be very time-consuming, it may take weeks to sync! After that node needs
    to stay online for block data upgrade and maintenance. Otherwise, it has to repeat
    the full synchronization process. It typically takes 13 seconds to create a new
    block. When new data arrives, a full node could delete old blockchain data to
    conserve disk space.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hardware requirements to run a full node with fast sync:'
  prefs: []
  type: TYPE_NORMAL
- en: Fast CPU with 4+ cores
  prefs: []
  type: TYPE_NORMAL
- en: 16 GB+ RAM
  prefs: []
  type: TYPE_NORMAL
- en: Fast SSD with at least 500 GB of free space
  prefs: []
  type: TYPE_NORMAL
- en: 25+ MBit/s bandwidth
  prefs: []
  type: TYPE_NORMAL
- en: Archive Node
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Archive nodes run with a special configuration called “archive mode.” Archive
    nodes will store all the blockchain data since the genesis block. It also builds
    an archive of historical states.
  prefs: []
  type: TYPE_NORMAL
- en: Current archive Ethereum blockchain sizes are ~12 TB.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, in most cases, we don’t need archive node data. A full node can provide
    most data, such as check account balances, transfer funds, etc. But sometimes,
    you may need to check last year’s account balance, assets you owned, or transactions.
    The full node prunes data periodically and only stores the most recent 128 blocks
    of data (about 25 minutes). The node has to resync to get earlier data, which
    would be too slow to extract. The archive node has all data locally, which can
    quickly get past data.
  prefs: []
  type: TYPE_NORMAL
- en: Archive node data are often used for blockchain services such as block explorers,
    data analysis, etc. Syncing full archive node data will be much longer than full
    node syncing. It may take at least one month.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the hardware requirements to run a full archive node:'
  prefs: []
  type: TYPE_NORMAL
- en: Fast CPU with 4+ cores.
  prefs: []
  type: TYPE_NORMAL
- en: 16 GB+ of RAM.
  prefs: []
  type: TYPE_NORMAL
- en: Fast SSD drive with at least 6 TB+ of space.
  prefs: []
  type: TYPE_NORMAL
- en: 25 MBit/s+ bandwidth.
  prefs: []
  type: TYPE_NORMAL
- en: Light Node
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Light nodes only download the minimum block headers information and use it to
    verify the data validity by checking the state roots in the block headers. Light
    nodes are designed to interact with full nodes as intermediaries and rely on full
    nodes to perform blockchain operations, from requesting account balance to smart
    contract interaction. So, light nodes don’t need to keep running online and store
    large amounts of Gigabytes of data locally. Light nodes can be very useful for
    running on low memory and computational devices, like mobile, IoT devices, and
    laptops.
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum Clients
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we just learned, Light Clients are mostly implemented on mobile devices.
    Although setting up a full node or archive node will take a long time to sync,
    there are multiple benefits to running your own node:'
  prefs: []
  type: TYPE_NORMAL
- en: '1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Your node can be a network validator to verify all the transactions and blocks.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can verify your application client transaction data by yourself, without
    the need for a third party to verify a transaction—“Don’t Trust. Verify.”
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '3.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will have a consistent view of the current network state and not need to
    rely on other public nodes or services where data could be delayed or untrusted.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '4.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You have more data privacy. When you use third-party software or tool to submit
    a transaction, these services could read your IP address along with your account
    information. IP addresses will reveal your current location.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To sync and communicate to the Ethereum network, you need to install Ethereum
    client software. The most used Ethereum clients are Geth. etherscan.io show that
    90.3% of Ethereum node install Geth as an Ethereum client to join the network
    and establish a p2p communication channel with other nodes. Diagram [4-12](#Fig12)
    shows overall Ethereum client usage.![](../images/535492_1_En_4_Chapter/535492_1_En_4_Fig12_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: A pie chart consists of overall ETM client usage. The most used ETM clients
    are Geth at 90.3%. 8 other clients are estimated.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4-12
  prefs: []
  type: TYPE_NORMAL
- en: Overall Ethereum client usage
  prefs: []
  type: TYPE_NORMAL
- en: Geth (Go Ethereum) is an open source command line interface (cli) for running
    an Ethereum node written in Google’s programming language Go.
  prefs: []
  type: TYPE_NORMAL
- en: The Ethereum community built and maintained Go Ethereum.
  prefs: []
  type: TYPE_NORMAL
- en: Using Geth allows the node to perform transactions, mining, transfer ether between
    accounts, and deploy and interact with smart contracts on the Ethereum blockchain.
    Geth can be directly downloaded from Geth’s official website—[https://geth.ethereum.org/downloads/](https://geth.ethereum.org/downloads/).
    The site provides a standard installation guide.
  prefs: []
  type: TYPE_NORMAL
- en: Once installed Geth, you can run Geth in sync mode to become a full, light,
    archive node.
  prefs: []
  type: TYPE_NORMAL
- en: 'Geth command to sync full node:'
  prefs: []
  type: TYPE_NORMAL
- en: geth --syncmode full
  prefs: []
  type: TYPE_NORMAL
- en: When sync mode is a full mode, Geth will download all blocks and replay all
    transactions from the genesis block. The state for full nodes will keep the last
    128 blocks in memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Geth command to sync light node:'
  prefs: []
  type: TYPE_NORMAL
- en: geth --syncmode light
  prefs: []
  type: TYPE_NORMAL
- en: When sync mode is a light mode, Geth will download the most recent 2,300 blocks
    and replay related transactions. As a result, the sync process for light mode
    is much faster than in full mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'Geth command to sync archive node:'
  prefs: []
  type: TYPE_NORMAL
- en: syncmode full --gcmode archive
  prefs: []
  type: TYPE_NORMAL
- en: Geth will download all blocks and replay all transactions from the genesis block
    and write all intermediate states to the archive disk.
  prefs: []
  type: TYPE_NORMAL
- en: There are many other Ethereum clients that are available in the Ethereum community.
    These clients are developed by different teams and implemented in different programming
    languages. All of these clients are actively used in the industry. Table [4-4](#Tab4)
    summarizes the different client’s usage.Table 4-4
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum clients
  prefs: []
  type: TYPE_NORMAL
- en: '| Client | Programing language | Disk size (fast sync) | Disk size (full archive)
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Geth | Go | 400 GB+ | 6 TB+ |'
  prefs: []
  type: TYPE_TB
- en: '| OpenEthereum | Rust | 280 GB+ | 6 TB+ |'
  prefs: []
  type: TYPE_TB
- en: '| Besu | Java | 750 GB+ | 5 TB+ |'
  prefs: []
  type: TYPE_TB
- en: '| Nethermind | C#, .NET | 200 GB+ | 5 TB+ |'
  prefs: []
  type: TYPE_TB
- en: Geth has a JavaScript console built using the GoJa JS Virtual Machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Geth has a built-in JavaScript console and supports all standard web3 JSON-RPC
    APIs, called web3\. js, which is compatible with ECMAScript 5.1\. You can use
    JSON-RPC APIs to interact with your node. Geth supports multiple ways to let client
    applications send raw JSON objects to the node. One of the most widely used protocols
    is called JSON-RPC over HTTP. JSON stands for JavaScript Object Notation. It is
    an open standard file format that transmits data between a server and web application.
    The data are in key/value pairs separated by a comma in the JSON file. Here is
    an example:{    ''name'': ''Alice'',    ''gender'': ''Female'',    ''account'':
    12345}RPC stands for “Remote Procedure Call” and is used for other remote system
    processes. When client applications use JSON-RPC over HTTP to send JSON data to
    Geth, Geth will execute specific tasks provided by Web3 API in the blockchain.
    Web3 is run on top of the RPC layer, as shown in Figure [4-13](#Fig13).![](../images/535492_1_En_4_Chapter/535492_1_En_4_Fig13_HTML.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: A schema depicts the interrelation between the client app, Ethereum client,
    full node E V M, and Ethereum blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4-13
  prefs: []
  type: TYPE_NORMAL
- en: Call Ethereum client via JSON-RPC
  prefs: []
  type: TYPE_NORMAL
- en: Geth Console
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To start Geth JavaScript console, you can run the command—Geth attach with IPC.
    IPC (Inter-Process Communication) provides unrestricted access to all Web3 APIs.
    You can use IPC to connect when the Geth console is running on the same machine
    as the Geth node.
  prefs: []
  type: TYPE_NORMAL
- en: 'They opened the console from the running Geth instance, the result will look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/535492_1_En_4_Chapter/535492_1_En_4_Figb_HTML.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A code for Geth JavaScript console. It contains the labels instance, coinbase,
    at block, datadir, modules, and exit
  prefs: []
  type: TYPE_NORMAL
- en: To get support for web3 APIs including eth,personal, admin, and miner, Geth
    console provide web3 command. Let’s take a look at eth related API. Type eth in
    Geth console. It will show all supported eth commands.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/535492_1_En_4_Chapter/535492_1_En_4_Figc_HTML.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A list of eth commands which starts with eth..
  prefs: []
  type: TYPE_NORMAL
- en: To list all of your current accounts in the network, simply run the following:eth.accounts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The listed account output should be similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/535492_1_En_4_Chapter/535492_1_En_4_Figd_HTML.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A text represents eth. account outputs in the console. It consists of numbers
    and letters.
  prefs: []
  type: TYPE_NORMAL
- en: To check the account balance, covert wei to ether, run the following command:eth.getBalance('0x88437244acbb6276de36175740a8d686a9531ba7')
    to get weiOr, we can directly convert to ether:web3.fromWei(eth.getBalance('0x88437244acbb6276de36175740a8d686a9531ba7'),'ether')![](../images/535492_1_En_4_Chapter/535492_1_En_4_Fige_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: An image consists of a code to get the account balance it starts from eth. get
    a balance and directly convert to the web3.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the latest block number of the blockchain, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/535492_1_En_4_Chapter/535492_1_En_4_Figf_HTML.jpg)'
  prefs: []
  type: TYPE_IMG
- en: An image consists of a command to get the block number of the blockchain run
    command>eth. block number and displays 518560.
  prefs: []
  type: TYPE_NORMAL
- en: Then, you can display a matching block summary information by calling:eth.getBlock
    (blockNumber)![](../images/535492_1_En_4_Chapter/535492_1_En_4_Figg_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: An image of eth console of eth.getBlock opens a new window of eth. The command
    will appear in the console.
  prefs: []
  type: TYPE_NORMAL
- en: To exit the Geth console, just simply run exit or press CTRL-C.
  prefs: []
  type: TYPE_NORMAL
- en: Geth JSON-RPC via Command
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: cURL stands for “Client URL” and is a command-line tool for transferring data
    using various supported protocols (HTTP, IMAP, SCP, SFTP, SMTP, LDAP, FILE, and
    many others). The curl syntax iscurl [options] [URL...]For example, you can open
    a window or mac terminal, type the below curl command, you will see HTTP response
    from the remote server:curl -k www.apress.com/usTo start Geth in http mode, you
    can use the --http flag as follows:geth –http
  prefs: []
  type: TYPE_NORMAL
- en: The default port is 8545\. Once the Geth node starts, we can run the curl command
    to query some useful blockchain information.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the web3 client version, run the following curl command:curl -X POST
    -H ''Content-Type: application/json'' \--data ''{''jsonrpc'':''2.0'',''method'':''web3_clientVersion'',''params'':[],''id'':11}''
    \http://localhost:8545'
  prefs: []
  type: TYPE_NORMAL
- en: Here id - 11 is blockchain Id. The response result shows that web3_clientVersion
    is Geth/v1.10.17-stable-25c9b49f/linux-amd64/gol.18
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/535492_1_En_4_Chapter/535492_1_En_4_Figh_HTML.jpg)'
  prefs: []
  type: TYPE_IMG
- en: An image of a code to get a web3 client that runs the curl command in a console
    and web3_clientVersion is in the console. The code has numbers and letters.
  prefs: []
  type: TYPE_NORMAL
- en: 'To check account balance, we saw in the previous Geth console example, running
    the following curl command:curl -X POST \-H ''Content-Type: application/json''
    \--data ''{''jsonrpc'':''2.0'',''method'':''eth_getBalance'',''params'':[''0x88437244acbb6276de36175740a8d686a9531ba7'',''latest''],''id'':11}''
    \http://localhost:8545![](../images/535492_1_En_4_Chapter/535492_1_En_4_Figi_HTML.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: An image of a code to check balance. It has texts in numbers and letters.
  prefs: []
  type: TYPE_NORMAL
- en: We get hex result - 0x56bbc5d759fba6400
  prefs: []
  type: TYPE_NORMAL
- en: By converting Hex value to decimal ([www.binaryhexconverter.com/hex-to-decimal-converter](http://www.binaryhexconverter.com/hex-to-decimal-converter)),
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/535492_1_En_4_Chapter/535492_1_En_4_Figj_HTML.png)'
  prefs: []
  type: TYPE_IMG
- en: An image of a hex value and a decimal value box. At the bottom left there is
    the convert icon.
  prefs: []
  type: TYPE_NORMAL
- en: And then, we convert Wei to Ether and divide the decimal number by 10^(18).
    The final result is 99.996902986 Ether, which is matched to the previous result
    we run in Geth console.
  prefs: []
  type: TYPE_NORMAL
- en: Geth Folder Structure
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Once Geth installed, it stores the default Geth local data directory based
    on operating systems:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Mac: ~/Library/Ethereum'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Linux: ~/.ethereum'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Windows: %LOCALAPPDATA%\Ethereum'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is structured as shown in Figure [4-14](#Fig14).![](../images/535492_1_En_4_Chapter/535492_1_En_4_Fig14_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: The structure of Geth folder consists of chain data, ancient, ethash, light
    chain data, node keys, nodes, Keystore, and geth.ipc.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4-14
  prefs: []
  type: TYPE_NORMAL
- en: Geth folder structure
  prefs: []
  type: TYPE_NORMAL
- en: '**chaindata** – Directory of the downloaded blocks data and EVM state data.'
  prefs: []
  type: TYPE_NORMAL
- en: '**ancient** – When chaindata passes approximately 100k blocks, the past blocks
    are moved to the ancient directory.'
  prefs: []
  type: TYPE_NORMAL
- en: '**ethash** – Ethash is Ethereum’s Proof of Work hashing algorithm, the files
    under this location are part of the Ethereum mining computation. It can be regenerated
    and deleted safely.'
  prefs: []
  type: TYPE_NORMAL
- en: '**lightchaindata**– Contain a light version of the blockchain, just the receipts
    (not data) and content.'
  prefs: []
  type: TYPE_NORMAL
- en: '**nodekey** – File of public key used for other public peer nodes to connect
    or add a peer node to network.'
  prefs: []
  type: TYPE_NORMAL
- en: '**nodes** – Contains peer connection data, used to establish network at the
    start.'
  prefs: []
  type: TYPE_NORMAL
- en: '**keystore** – Stores account information, the account key can be found in
    the keystore folder.'
  prefs: []
  type: TYPE_NORMAL
- en: '**geth.ipc** – File for inter-process-communication as used by Geth connection.'
  prefs: []
  type: TYPE_NORMAL
- en: By default, the Geth uses Google LevelDB as the underlying database implementation
    to store blockchain data, for example, 000002.ldb and 000011.ldb under chaindata
    folder in the Figure [4-14](#Fig14) folder structure. LevelDB is an open source
    on-disk key-value storage.![](../images/535492_1_En_4_Chapter/535492_1_En_4_Fig15_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: A flow diagram of E V M, flows from world state n to transaction and lastly
    world state n plus 1.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4-15
  prefs: []
  type: TYPE_NORMAL
- en: The state of Ethereum changing through a transaction
  prefs: []
  type: TYPE_NORMAL
- en: As we know from Chapter [2](535492_1_En_2_Chapter.xhtml), “Cryptography,” every
    Ethereum account is defined by a private key and public key pair. The account’s
    address is derived from the public key by taking the last 20 bytes. When we use
    Geth to generate a new account, the new account address with the private key pair
    is encoded in a JSON text file as a keyfile. Since it contains your account’s
    private key, the file content is always encrypted. This keyfile can be used to
    access your Ethereum account and transfer fund. So, you need to back up your keyfiles
    regularly and make sure this file is secure and not accessible by others.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use Geth console to generate a new account address by running command
    personal.newAccount() and enter a passphrase:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/535492_1_En_4_Chapter/535492_1_En_4_Figk_HTML.jpg)'
  prefs: []
  type: TYPE_IMG
- en: An image consists of the Geth console generating a new account address and running
    commands personally. new account() and enter a passphrase are written.
  prefs: []
  type: TYPE_NORMAL
- en: The account address 0x0b1400031bea2def60a9d8f28fa373ab95d641f6 is generated.
    Now check keystore directory, there is a new JSON text keyfile generated for this
    account:└── keystore    ├── UTC--2022-06-28T04-14-13.945107969Z--0b1400031bea2def60a9d8f28fa373ab95d641f6
  prefs: []
  type: TYPE_NORMAL
- en: 'The content of this keyfile is encrypted, as displayed in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/535492_1_En_4_Chapter/535492_1_En_4_Figl_HTML.png)'
  prefs: []
  type: TYPE_IMG
- en: A code to generate the account address in the console and new JSON text for
    that account and address, new versions, and OS is displayed in the console.
  prefs: []
  type: TYPE_NORMAL
- en: We have now learned Ethereum client—Geth and clarified how remote clients (command
    line or web app) can call the Ethereum client via web3j API and interact with
    the Ethereum blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum Network
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Typically, when people are discussing the Ethereum network and ETH prices, they
    are talking about the Ethereum mainnet. The mainnet is the primary public Ethereum
    production blockchain. When we deploy a smart contract to mainnet, we have to
    pay gas fees, and these gas fees cost real money. Since the nodes connected in
    Ethereum run a protocol, there are many other similar controlled public environments
    that run the similar or same protocol to simulate the mainnet environments. Contract
    developers can run and test smart contracts in these production-like environments
    to ensure that the result is working as expected. These public networks we call
    Ethereum testnet.
  prefs: []
  type: TYPE_NORMAL
- en: In testnet, you don’t spend real money when testing your smart contracts. Ethereum
    testnet provides free ethers you can use to pay for gas fees. These ethers can
    only use in testnet, not for any other environments, and they have no value in
    the real world. As the best practice, you should test your smart contract code
    in the testnet before deploying it to the mainnet.
  prefs: []
  type: TYPE_NORMAL
- en: Many testnets use a proof-of-authority consensus mechanism. A smart number of
    nodes are chosen as a validator to do consensus work and create new blocks. Testnets
    do not incentivize proof-of-work mining. There are a few Ethereum test networks
    available. You can choose your own favorite testnet. Since the Ethereum 2.0 merged
    on Sep 15, 2022, few public proof-of-work and proof-of-authority testnets became
    proof-of-stake. Some popular testnet will soon be deprecated, like Ropsten, Rinkeby,
    and Kovan. We will not discuss these testnets here. Goerli testnet is a proof-of-authority
    testnet. It merged to proof-of-stake and is expected to be maintained long-term
    as a proof-of-stake testnet.
  prefs: []
  type: TYPE_NORMAL
- en: The Görli test network was established in March 2019\. It is a Proof-of-Authority
    testnet using the Clique consensus mechanism for Ethereum, originally proposed
    by Chainsafe and Afri Schoedon. You can use the official Goerli Testnet Faucet
    ([https://goerli-faucet.slock.it/](https://goerli-faucet.slock.it/)) to acquire
    free ETH. In a later section, we will use Goerli Testnet to get some ether to
    our wallet.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have covered most of the basic Ethereum fundamentals. In the next section,
    we will go over how Ethereum works.
  prefs: []
  type: TYPE_NORMAL
- en: How Ethereum Works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we learned earlier, there is a multi-phased upgrade that aims to switch from
    a current proof-of-work (PoW) consensus mechanism to a proof-of-stake (PoS) model.
    In PoW, the miner verified transactions and added transactions to a new block.
    The new block is broadcast to the entire network, and validators will verify and
    eventually commit to the Ethereum network. The process typically takes at a constant
    rate of between 10 and 20 seconds. In ETH 2.0 PoS, the network could speed up
    to 100,000 transactions per second capacity.
  prefs: []
  type: TYPE_NORMAL
- en: In Ethereum, a transaction is initiated and securely signed by a user’s EOA
    account. For example, Alice wants to send one Ether to bob. Alice will initiate
    a transaction for this transfer. Next, the Ethereum network transmits the transaction.
    Once the transfer completes, Bob’s account will be debited one Ether and Alice’s
    must be credited. Ethereum is a singleton world state machine. Transactions are
    the only things that can trigger a change and update the state of Ethereum. Figure
    [4-15](#Fig15) depicts the changing state of Ethereum in a transaction.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three types of transactions in Ethereum:'
  prefs: []
  type: TYPE_NORMAL
- en: '1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Transactions that transfer funds between two EOAs (e.g., Alice sends one Ether
    to Bob).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Transactions that deploy a contract.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '3.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Transactions that interact and execute a deployed contract function (e.g., update
    a total token supply).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The Structure of a Transaction
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The blockchain requires a gas fee for miner mining and verifying when a user
    submits a transaction.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s use Geth console to submit one transaction by transfer 0.05 Ether and
    then, get the transaction receipt from the returning transaction hash as shown
    in Figure [4-16](#Fig16).![](../images/535492_1_En_4_Chapter/535492_1_En_4_Fig16_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: A code to submit a transaction and to get a receipt. The code contains alphanumeric
    letters.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4-16
  prefs: []
  type: TYPE_NORMAL
- en: Submit a transaction and get a transaction receipt
  prefs: []
  type: TYPE_NORMAL
- en: 'From logs of Geth, we can see that transaction is submitted, a transaction
    hash, and a nonce is generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/535492_1_En_4_Chapter/535492_1_En_4_Figm_HTML.png)'
  prefs: []
  type: TYPE_IMG
- en: An image of the submitted Geth transaction and the transaction hash is generated
    with text and letters.
  prefs: []
  type: TYPE_NORMAL
- en: Figure [4-17](#Fig17) shows an example of the transaction detail from etherscan.io.![](../images/535492_1_En_4_Chapter/535492_1_En_4_Fig17_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: A screenshot of overview tab that lists transaction details like transaction
    hash, status, block, from and to, and value. State and comments tab are present.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4-17
  prefs: []
  type: TYPE_NORMAL
- en: Submit a transaction and get a transaction receipt
  prefs: []
  type: TYPE_NORMAL
- en: 'A transaction detail contains the following data:'
  prefs: []
  type: TYPE_NORMAL
- en: '**From** – The sender’s Ethereum address.'
  prefs: []
  type: TYPE_NORMAL
- en: '**To** – The receiver’s Ethereum address.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Nonce** – The sequence number of a transaction. The Nonce is issued by the
    originating EOA, which initiates the transaction. It is a unique number and prevents
    to replay of the same transaction.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Gas Price** – The required transaction fee in the price of gas (in Gwei)
    that the transaction creator pays.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Gas Limit** – Maximum limit of gas that would be consumed for the transaction.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Value** – The amount of ether to send to the recipient.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data** – Transaction input binary payload data that is only used for sending
    a message call and executing functions of the contract.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Signature** – v, r, s. It is the identification of the sender. The sender
    uses EOA to sign the transaction via its private key. It uses a cryptographic
    ECDSA digital signature. v, r, and s are the values for the transaction’s signature.'
  prefs: []
  type: TYPE_NORMAL
- en: Take your time to read this long list. You don’t need to memorize each one of
    the fields. We describe each field to help you to understand what they mean. These
    terms may quite often appear when you work on more in Ethereum.
  prefs: []
  type: TYPE_NORMAL
- en: Transaction Receipt
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Figure [4-16](#Fig16), we see the transaction receipt output after running
    web3.eth.getTransactionReceipt(transactionHash). When the transaction receipt
    becomes available, it means that the transaction is added to a block. When a transaction
    is a pending status, the receipt returns null.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the fields that the transaction receipt contains:'
  prefs: []
  type: TYPE_NORMAL
- en: '**BlockHash** – Hash of the block where this transaction was in.'
  prefs: []
  type: TYPE_NORMAL
- en: '**BlockNumber** – This transaction block number.'
  prefs: []
  type: TYPE_NORMAL
- en: '**TransactionHash** – String, 32 Bytes—hash of the transaction.'
  prefs: []
  type: TYPE_NORMAL
- en: '**TransactionIndex** – The transactions index position in the block.'
  prefs: []
  type: TYPE_NORMAL
- en: '**From** – The sender’s Ethereum address.'
  prefs: []
  type: TYPE_NORMAL
- en: '**To** – The receiver’s Ethereum address. Null when it’s a contract creation
    transaction.'
  prefs: []
  type: TYPE_NORMAL
- en: '**CumulativeGasUsed** – The total amount of gas used by this transaction and
    all previous transactions in the same block.'
  prefs: []
  type: TYPE_NORMAL
- en: '**GasUsed** – The total amount of gas used by this specific transaction.'
  prefs: []
  type: TYPE_NORMAL
- en: '**ContractAddress** – The contract address is associated with this transaction.
    If the transaction was a contract creation, otherwise null.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Logs** – Log information for this transaction.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Status** – “0x0” indicates transaction failure, “0x1” indicates transaction
    succeeded.'
  prefs: []
  type: TYPE_NORMAL
- en: Block
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we learned from Chapter [1](535492_1_En_1_Chapter.xhtml), each block has
    header and body. Block body contains a list of transactions. This is true for
    both Bitcoin and Ethereum. Ethereum block structure is shown in Figure [4-18](#Fig18).![](../images/535492_1_En_4_Chapter/535492_1_En_4_Fig18_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: '2 blocks of block header and block body. Block body contains 2 more blocks
    in it: transactions and uncle blocks headers.'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4-18
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum block structure
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum block body also contains “ommer” blocks, usually called “uncle” blocks.
    Uncle blocks are created to help reward miners when multiple block solutions are
    found.
  prefs: []
  type: TYPE_NORMAL
- en: When there are multiple miners who solve a cryptographic puzzle and propose
    a new block for a chain, only one of the blocks will be accepted in the network.
    Since other miners did the same work, the network will reward them. Those stabled
    blocks will be attached to the new accepted block. We call it uncle block, as
    shown in Figure [4-19](#Fig19).![](../images/535492_1_En_4_Chapter/535492_1_En_4_Fig19_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: A flow diagram of 3 layers of cubes labeled 1, 2, and 3 from the top. Cube 1
    leads to 2 cubes in second layer that are labeled 2 A and 2 B for Alice and Bob
    labeled respectively. There is a tick for 2 A and cross for 2 B. Cube 2 B goes
    to cube 3 through uncle for block 3.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4-19
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum uncle block
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in Figure [4-19](#Fig19), there are two blocks that were proposed
    by miner Alice and miner Bob. Alice’s block (A) is eventually accepted and added
    as a new block #2\. Bob’s block (B) is ultimately rejected. Then, a miner in the
    network created a block (#3) using Bob’s block (B) and specified that Alice’s
    block is the parent block and Bob’s block is an uncle/ommer block. This way, Alice
    will get the full reward, but Bob still gets a partial reward.'
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned later, each block body contains the list of transactions, here
    is an example of a block from etherscan.io. We can see there are 374 transactions
    in this block as shown in Figure [4-20](#Fig20).![](../images/535492_1_En_4_Chapter/535492_1_En_4_Fig20_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: 'A screenshot of a table of transactions with column headers: T x n hash, method,
    block, age, from, to, value, and t x n fee. There are 374 transactions in this
    block.'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4-20
  prefs: []
  type: TYPE_NORMAL
- en: 'A block: a list of transactions'
  prefs: []
  type: TYPE_NORMAL
- en: The block number is 15039689\. Let’s take a look at other block detail as in
    Figure [4-21](#Fig21).![](../images/535492_1_En_4_Chapter/535492_1_En_4_Fig21_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: An image of the ETM block in detail presents the overview and comments. An overview
    is a list of details of transactions, timestamps, difficulty, size, gas limit,
    and fees.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4-21
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum block detail
  prefs: []
  type: TYPE_NORMAL
- en: 'The Block Header contains some key information about an Ethereum block. Each
    block header has the following important fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Block number** – Also called block height. The length of the blockchain ancestor
    blocks. The first block (genesis block) has the number zero. This number represents
    the height of the chain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Difficulty** – Indicating how hard for hashing or staking effort to mine
    a block.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Total difficulty** – Indicating how hard it was to chain up to a specified
    block by an integer value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Timestamp** – A UNIX timestamp for when the block was mined.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Nonce** – Please check the Ethereum Account section.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Parent hash** – Also called previous hash. The hash came from the previous
    block (or the parent block). Each block contains a previous hash. By the way,
    we can link back to the first block in the chain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Beneficiary** – Also called “Mined by.” It is the beneficiary miner address
    that receives a mining reward.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Gas price** – Please check the Gas, Gas Price, and Gas Limit section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Gas limit** – Please check the Gas, Gas Price, and Gas Limit section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Size** – The block size in bytes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hash** – A unique Keccak hash of the block.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Extra data** – A field containing additional data from a block. When miners
    are creating a block, they can add anything in this field.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**State root**: Hash of the root node of a specialized kind of Merkle tree
    that stores the entire network state, also known as world state. It contains the
    Keccak hash of all account balances, contract storage, contract code, and account
    nonces. If any piece of the data changes, the entire state root value will also
    change.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Transactions root**: Hash of the root node of the transactions trie that
    stores all transactions in this block body.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Receipt root**: Hash of the root node of the transactions receipt trie that
    stores all transactions receipt in this block.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At this stage, we have deep dive into how Ethereum works, and especially we
    are anatomizing Ethereum block, transaction, account, and state. The relation
    between these Ethereum block structures. Let’s summarize what we have learned
    and link it all together, as shown in the Ethereum architecture diagram (Figure
    [4-22](#Fig22)).![](../images/535492_1_En_4_Chapter/535492_1_En_4_Fig22_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: A schema of ETM architecture consists of header and body in a separate block.
    The trie of world state, transaction, receipt points to their respective layers
    in the header block. Table for account state, transaction, and transaction receipt
    leads to their respective trio. Account storage trio leads to account state table.
    Body block leads to table of transaction receipt.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4-22
  prefs: []
  type: TYPE_NORMAL
- en: 'Ethereum architecture: block, state, transactions'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now described most of the important concepts about Ethereum.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main purpose of this chapter was to introduce the key concepts of Ethereum.
    We’ve started to learn about the history of Ethereum as well as the key components
    and elements behind Ethereum, including accounts, contracts, and gas. So, now
    you know the fundamentals of how Ethereum account works. We went over Ethereum
    node and Ethereum clients—geth technologies with some examples. We delve into
    the Ethereum architecture, understand how the Ethereum Virtual Machine (EVM) works,
    how smart contract Opcode is executed within the EVM, the structure of the block,
    state, and transactions in EVM. At this stage, you should be ready to go for the
    next chapter and start with developing your first smart contracts and end-to-end
    decentralized applications. We will show you how to build it step-by-step. Stay
    tuned.
  prefs: []
  type: TYPE_NORMAL
