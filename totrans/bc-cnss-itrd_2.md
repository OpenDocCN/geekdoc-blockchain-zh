不足够，我们需要使用一些能够发送消息给

多个节点或一组节点同时。在这种情况下，我们使用广播

协议。

113

© 伊姆兰·巴希尔 2022

伊姆兰·巴希尔, *区块链共识*，[`doi.org/10.1007/978-1-4842-8179-6_3`](https://doi.org/10.1007/978-1-4842-8179-6_3#DOI)

![](img/index-133_1.png)

第三章 分布式一致性

广播协议允许进程同时向所有进程发送消息

分布式系统中的进程，包括它自己。

在本部分中，我们将看一下广播抽象。可能会有多个发送者

和接收者参与。广播抽象确保进程就

他们传递的消息。

可以通过图 3-1\.](#p133)的可视化来解释广播抽象

***图 3-1\.** 一个节点广播消息 m 和三个节点都接收它*

请注意，发送和接收以及广播和之间存在区别

传递。发送和接收是在点对点链路的上下文中使用的，而

广播和传递在广播抽象中使用，其中消息被广播

给多个/所有节点。

第一章讨论的点对点链路与发送和接收原语相关，其中一个节点发送消息，接收节点接收它

使用广播和传递原语的广播抽象描述了一种情况

一个节点向网络中的多个/所有节点发送消息，节点接收

它们，但是，在这里，广播算法可以在接收后存储和缓冲消息，然后将消息传递给后续进程。这取决于广播算法（也称为中间件）。例如，在总体顺序广播中，消息可能被接收

在每个进程上运行广播算法，但可以在满足条件的情况下被缓冲

见面来将消息传递给应用程序。

图 3-2 阐](#p134)明了这个概念。

114

![](img/index-134_1.png)

第三章 分布式一致性

***图 3-2\.** 发送和接收以及广播和传递*

通信发生在一个节点组内，其中节点数量

可能是静态的或动态的。 一个进程发送它，组中的所有节点都同意

并将其传递。如果单个处理器或部分处理器出现故障，其余

节点继续工作。广播消息面向所有进程。

广播抽象允许开发容错应用程序。

这是我描述的几种类型。

**尽力而为广播**

在这个抽象中，只有在发送方进程不失败的情况下才能保证可靠性。这是最弱的可靠广播形式。最好的尽力而为有三个属性

广播有。

**有效性**

如果消息 m 由正确的进程 p 广播，则消息 m 最终

每个正确处理过程都传递。这是一种活力性质。

**无重复**

每条消息只传递一次。

115

![](img/index-135_1.png)

第三章 分布式共识

**没有创建**

如果一个进程传递了一个来自发送者进程 p 的消息 m，则 m 之前已经

发送进程 p 的广播。换句话说，消息不会凭空产生。

图 3-3 描述了一个示例最佳努力广播的执行。

***图 3-3\.** 尽力广播–一个示例场景*

在图 3-3 中，注意到进程 p 已经广播了消息，但然后崩溃了，根据系统属性，此时消息传递不被保证。请注意

过程 q 未能传递消息，因为我们的过程 p 不再正确。

然而，进程 R 传递了。如果发送者失败，该抽象中没有传递保证，如 图 3-3 所示。如果一些进程可能传递消息，而一些不传递，就会导致不一致。可以想象，该抽象可能不会

在一些更严格的情况下可能会很有用。我们需要比这更健壮的协议。

为了解决这些限制，使用了可靠的广播抽象。

**可靠的广播**

可靠的广播抽象引入了一个名为

协议达成。 **没有复制** 和 **没有创建** 的属性与尽力广播抽象保持一致。 **有效性** 属性略有削弱。形式上，有效性和协议达成属性可以如下表述。

**有效性**

如果正确的进程 p 广播了一个消息 m，那么 p 最终会传递 m。

116

第三章 分布式共识

**协议达成**

如果一个消息 m 被正确的进程传递，那么每个正确的进程都传递 m。

**备注**

如果发送进程在广播时崩溃并且无法发送到

所有进程，协议达成属性确保没有一个进程传递它。可能某些进程已经收到了消息，但是可靠的广播确保

不进行协议达成，没有一个进程会传递它。换句话说，如果发送进程崩溃，可靠的广播确保所有正确的节点要么

最终传递消息或都不传递消息。

如果发送进程失败，此属性确保所有正确的节点都会收到

消息，或者没有一个正确的节点收到消息。这个属性通过

通过正确的进程重新传输任何丢失的消息，从而最终

传递消息。

这个解决方案似乎足够合理，但在某些情况下可能存在

广播进程可能已经能够将消息传递给自身，但是在

它可能会发送给其他进程。这意味着所有正确的进程将同意不会

以便传递消息，因为它们没有收到消息，但是原始的广播者

传递它。这种情况可能会导致安全问题。

为了解决这个限制，引入了统一可靠的广播，提供了更强大的

保证，被使用。

**一致可靠广播**

在统一可靠广播中，虽然所有其他属性（如有效性，无重复，无创建）与尽力广播保持一致，但在我们在可靠广播抽象中看到的一致性属性下，引入了一个更强的一致性概念。它被引入是为了确保即使在发送进程可能会失败的情景中，也能确保一致性。这被称为一致性协议。

失败。该属性称为统一协议属性。

**一致协议**

如果一个消息 m 由一个进程 p 传递，那么每个正确的进程最终都会传递 m。 p 可以是一个正确的或一个失败的进程。

117

第三章 分布式一致性

在之前讨论的所有抽象中，有一个关键的元素缺失

在许多分布式服务中需要。例如，想象一个在线

聊天应用程序。如果用户发送了一条消息说“英格兰赢得了板球比赛”，而

另一个用户回复“祝贺”，第三个用户说“但我想让爱尔兰获胜”

赢得，消息应出现的期望序列

聊天应用程序是

• **用户 1**：英格兰赢得了板球比赛

• **用户 2**：祝贺

• **用户 3**：但我想让爱尔兰赢

但是，如果消息传递没有设置顺序，它可能会出现

即使用户 1 的信息先发送，但在应用程序（对终端用户）中，消息可能会出现这样：

• **用户 2**：祝贺

• **用户 3**：但我想让爱尔兰赢

• **用户 1**：英格兰赢得了板球比赛

现在这不是期望的顺序；没带有“祝贺”的信息

用于赢球录像会令人困惑。这是在分布式一致性中解决的问题。

通过对广播抽象施加顺序保证。

**注意** 我们在第一章讨论了因果关系和发生前关系；如果需要，可以查看该章节。

如果需要提醒，可以参考该章节。

现在我们将讨论四种保证按顺序传送消息的抽象

具有不同程度的严格性：FIFO 可靠广播，因果可靠广播，

全顺序可靠广播和 FIFO 全顺序广播。

**FIFO 可靠广播**

这种抽象在可靠广播上强加了先进先出（FIFO）传递顺序。

这意味着广播的消息以发送时的相同方式传送

发送进程。

118

第三章 分布式一致性

在这个抽象中，所有属性与可靠广播保持一致；然而

为 FIFO 传递引入了一个新属性。

**FIFO 传递**

如果一个进程已经分别广播了两条消息 m1 和 m2，那么任何正确的

进程在 m1 之前没有传递 m2。换句话说，如果 m1 是由

相同的过程，那么除非它先传递了 m1，否则没有正确的过程会传递 m2。

这个保证只有在 m1 和 m2 由同一个广播的进程传递

进程；如果两个不同的进程广播了消息，那么就没有保证

它们将被传递。

在实践中，TCP 是 FIFO 传递的一个例子。如果你需要在你的使用中使用 FIFO 传递

在这种情况下，你可以简单地使用 TCP。

**因果可靠广播**

这种抽象对可靠广播施加了因果传递顺序。这意味着，如果一个消息广播比另一个消息的广播早发生，那么每个进程

传递这两个消息的顺序相同。在可能发生两个消息的情况下

可以同时广播，那么一个进程可以以任意顺序传递它们。

**总序可靠广播或原子**

**可靠广播**

这种抽象通常被称为**总序广播**或**原子广播**。总序广播具有四个属性，如下所述。

**有效性**

如果一个正确的进程 p 广播了一个消息 m，那么一些正确的进程最终

传递 m。

**协议**

如果一个消息 m 被正确的进程 p 传递，则所有正确的进程最终都会传递 m。

119

第三章 分布式共识

**完整性**

对于任何消息 m，每个进程最多传递一次，只有当 m 先前是

广播。在文献中，这种性质有时被分为两个独立的性质：**无重复**，即没有消息被传递超过一次， **无创建**，它规定传递的消息必须由发送者进程广播。换句话说，

没有消息是凭空创建的。

**总序**

在这个属性中，如果消息 m1 在一个进程中在消息 m2 之前被传递，那么在所有进程中消息 m1 在消息 m2 之前被传递。

**FIFO 总序广播**

这种抽象结合了 FIFO 广播和总序广播。

可以使用一个称为顺序器的单个领导者实现总序。

方法和使用 Lamport 时钟，但这些都不是容错方法。

如果领导者崩溃了，那么就没有序列了，在 Lamport 时钟的情况下

如果任何节点故障，则无法保证完全顺序？引入故障

容错性在自动选择新领导者的总序广播中的问题就是

这是通过一致性协议进行研究和解决的。一致性协议，在 a

基本层面上，解决在故障发生时选择新领导者的问题。

这是一致性协议背后的关键动机。我们将更多地了解这一点，

以后在本章中将详细说明总序广播及其与状态机复制、容错性和共识协议的关系。

到目前为止，我们讨论过的抽象可以与更小的一组一起工作

进程。想象一个分布式系统分布在多个大陆上并且

有 1000 多个节点参与。迄今为止，所述的抽象是否可以

足够高效以承受与 1000 多个相关的通信复杂性

分布式系统中异构和分散节点？答案是否定的，并且在

为了满足这种要求，发展了概率协议。另外，想象一下

一个节点 responsible for sending messages to 1000 个节点的情景。即使

如果我们设法利用一些硬件支持或一些

另一种方法，当单个发送方节点

收到来自 1000 个节点的确认。这个问题被称为**确认膨胀**。

问题是我们如何避免这样的问题。

120

![](img/index-140_1.png)

第三章分布式一致性

想象另一种情况，使用可靠的链接一个节点已经向所有节点发送了消息

个别节点，但在传输到一些节点时，一些消息被丢弃。

在这一点上，发送过程失败，因此没有进行重新传输。

因此，那些未收到消息的节点现在永远不会收到消息

因为发送方进程已经崩溃。在这种情况下，我们如何提高可靠性？

我们可以设计一种方案，如果一个节点首次接收到消息，则它

通过可靠渠道再次将其广播到其他节点。这样，即使一些节点崩溃，所有正确的节点也将收到所有消息。这被称为**急切可靠** **广播**。急切可靠广播是可靠的；然而，对于 n 个节点，可能会产生 *O*(*n*)步和 *O*(*n*)2 条消息。

图 3-4 展示了急切可靠协议。

***图 3-4\.** 急切可靠广播*

也有其他算法，我们可以称之为*受自然启发*的算法。例如，考虑传染病如何传播或者谣言如何传播。一

人传染了一些其他人，然后那些人传染了其他人，并且迅速传染率增加。现在想象一下，如果一个广播协议是根据这样的原则设计的，那么

它可以非常有效地在整个网络中传播信息（消息）

很快。由于这些协议基本上是随机化的协议，它们不能保证

所有节点都会收到一条消息，但通常有很高的概率

所有节点最终都会收到所有消息。概率协议或八卦协议是

在对等网络中通常使用。已经有许多协议

基于这种传播的设计。

图 3-5 展示了八卦协议的工作原理。这里的想法是，当一个节点首次接收到消息时，它会将其转发给一些随机选择的其他节点。

这种技术对向许多节点广播消息很有用，消息

最终以很高的概率到达所有节点。

121

![](img/index-141_1.png)

第三章分布式一致性

***图 3-5\.** 八卦协议*

可以定义一个概率广播抽象作为具有两个抽象之一

属性。

**概率有效性**

如果正确的进程 p 广播了消息 m，那么每个正确的进程最终

以 1 的概率交付。

**诚信**

任何消息最多被传递一次，并且传递的消息之前已经被送达

进程广播 - 换句话说，没有重复消息，没有消息创建

出现无中生有。

**广播与共识之间的关系**

尽力广播是最弱的广播模型。通过添加其他属性

和要求，我们可以实现更强大的广播模型，如图所示 3-6。

122

![](img/index-142_1.png)

第三章 分布式一致性

***图 3-6.** 广播关系 - 从最弱到最强 - 和共识* *等价性*

有了这个，我们就完成了广播协议的讨论。现在让我们继续

到一致性抽象，这是最基本的问题之一

分布式计算。

首先，我将解释什么是一致，然后我们将基于这个基本的

想法并提出共识问题。

**协议**

在分布式系统中，进程之间的一致性是一个基本的

要求。有许多情况下，进程需要就

分布式系统实现其目标。例如，在广播抽象中

进程之间需要就消息的传递达成一致。

有各种各样的一致性问题，我们将涵盖最突出的

然后在一致性上更加关注。

我们已经涵盖了可靠广播和全序广播。在这一部分中

我将简要解释一些可靠广播和全序

广播；然后，我们将探讨拜占庭协议和共识。

**可靠广播**

可靠广播确保了即使发件进程失败也能保证可靠性。换句话说，无论发件者是否正确，可靠性都得到了保证。

123

第三章 分布式一致性

**全序广播**

全序广播保证可靠性和所有传递的相同顺序

节点。使用单一领导者方法可以实现全序广播

一个节点被指定为领导者。所有消息都经过这个领导者进行

信息的公共顺序。消息首先发送给领导者，然后

使用 FIFO 广播机制广播它们。但是，在这种情况下，问题

是，如果领导者崩溃，就无法传递任何消息。然后的问题

如何在确保算法的安全性的同时更换失败的领导者。

如果建立公共传递顺序的选举领导者失败，节点

必须选择新领导者。现在的问题变成了选择一个新的诚实的领导者，并且

同意新领导者的选择。再次，现在节点必须达成一致，并且

问题现在成为选择新领导者而不是关于

传递顺序。在任何一种情况下，节点都必须运行一些协议达成一致。

此外，早些时候，我们发现拉姆波特时钟，使用软件事件计数器

和进程标识符，可以实现一个总顺序。结合 FIFO 链接和

时间戳在总顺序中的使用，Lamport 时钟实现总顺序具有直观意义，但在实际操作中可能具有挑战性。例如，如果某个节点宕机，则整个协议都会停止。

单一领导者（顺序管理/有序者方法和 Lamport 时钟）都不是

容错。我们很快将看到我们可以做些什么。总顺序广播和

共识是不同的问题，但彼此相关。如果你解决共识问题，

然后你就能解决总顺序，反之亦然。

总顺序广播也被称为原子广播，因为它确保要么

消息会被发送到所有进程，或者根本不被发送。总顺序广播的原子性（一切或者什么都不）是使其成为原子广播协议的关键，因此得名

原子广播。

**拜占庭协议问题**

拜占庭协议问题可以以三种不同方式定义：拜占庭

将军问题、交互一致性问题和共识问题。

124

第三章分布式共识

**基本的拜占庭将军问题或 BGP**

有一个指定的进程称为源进程，其有一个初始值。问题的目标是与其他进程就源进程的初始值达成共识

源进程。需要满足三个条件：

• **一致性**：所有诚实的进程就同一个值达成一致。

• **有效性**：如果源进程是诚实的，那么决定（协商一致的）

诚实过程产生的价值与发送方进程的初始值相同

源进程。

• **终止**：每个诚实的进程最终都必须做出决定。

一个值。

这个问题本质上是一个广播原语，在其中指定的

进程以一个初始值（输入）开始，而其他进程则没有输入

（初始值）。当算法终止时，所有进程都就（输出）相同的值达成一致。

拜占庭将军问题（BGP）的解决方案的关键是

发送方进程可靠地将其输入发送到所有进程，以便所有进程输出（决定）相同的值。

**交互一致性问题**

在这个交互一致性问题中，每个进程都有一个初始值，而所有正确的进程必须就一组值（向量）达成共识，其中每个进程都有一个相应的

值。要求列在下面：

• **一致性**：所有诚实的进程就同一个值数组达成一致

（向量）。

• **有效性**：如果一个正确的进程决定一个向量 V 和一个进程

P1 是正确的，并且从向量中取得值 V1，然后 V1

对应于向量 V 中的 P1。

• **终止**：每个正确的进程最终都会做出决定。

**共识问题**

在共识问题中，每个进程都有一个初始值，而且所有正确的进程

就同一个值达成一致：

125

![](img/index-145_1.png)

第三章分布式共识

• **协议**: 所有进程均同意相同的值；没有两个进程

决定不同的值。

• **有效性**: 决定的值必须是进程提出的值。

• **完整性:** 进程最多只能决定一次。

• **终止**: 每个诚实的进程最终都会决定一个值。

有效性和一致性是安全性属性，而终止是活性

属性。

图 3-7 股示了共识在视觉上的外观。在图中并没有太多内容，但它能在视觉上展示，并有助于建立共识的心智模型

外观。

***图 3-7。** 共识 – 在视觉上的外观*

根据系统的不同，共识问题存在许多变种

模型和故障模型。

上述共识问题称为统一共识，其中

协议属性是严格的，不允许崩溃的进程做出不同的决策。

126

第三章 分布式共识

共识的另一个变体是**非统一共识**。在非统一

共识，协议的一致性属性被*削弱*，以允许崩溃的进程决定不同的值。

我们可以将**统一共识**的*一致性*属性写为

• **协议**: 没有两个诚实的进程决定不同的值。

现在，如果我们在弱化

协议，我们实现了**拜占庭容错共识**。在这种情况下，有效性属性变得

• **有效性**: 诚实进程的决定值必须是提议的

诚实进程的价值。

第一种变体，其中有效性属性较弱，协议也较弱

可归类为**崩溃容错共识**。

满足所有这些安全性和活性属性的算法称为正确的

算法。在无故障同步共识中解决共识问题并不难，

系统；然而，在容易发生故障的系统中，问题变得更加困难。

失效和异步使解决共识成为一个复杂的问题。

**二进制共识**是一种简单的共识类型，其中输入受限，并且

结果，决策值受限于单个位，即零或一。**多值** **共识**是一种共识类型，其目标是就多个值达成一致，即随时间变化的一系列值。

尽管二进制共识在第一

实例，二进制共识问题的解决方案导致了多值共识的解决方案。

共识；因此，这是一个重要的研究领域。

共识属性的定义可能会稍有不同，取决于

应用中。例如，在区块链共识协议中，通常验证

属性的定义与已建立的定义不同，并且可能会接受较弱的解决

变体。例如，在 Tendermint 共识中，有效性属性仅陈述，根据协议

*“决定值是有效的，即满足预定义的谓词 denoted valid( )”*。这可能是一个特定的应用条件。例如，在区块链环境中，它可能

要求添加到比特币区块链的新块必须具有有效的块

通过节点验证检查传递的头。在其他变化中，valid( )谓词

要求和条件“如果所有诚实的进程提出相同的值，那么所有的

决定相同的值”可以结合起来。这是有效性谓词的组合

和传统的有效条件。有许多变种和不同的定义。有的

127

第三章 分散式共识

严格的，有的不是那么严格，这取决于应用程序。我们将涵盖

区块链共识和相关共识协议，并将在本书中贯穿始终

在共识算法和重新定义这些要求的背景下

讨论中的故障模型。

如果一个共识协议能够容忍恶性故障，那么它就是 **崩溃容错（CFT）** 的。如果一个共识协议能够容忍任意故障，则它是 **拜占庭容错（BFT）** 的。为了实现崩溃容忍，其底层

分布式网络必须满足条件 N >= 2F+1，其中 N 是节点的数量

网络中的节点，F 是有故障的节点的数量。如果网络满足此

条件，那么它才能继续正确工作并实现共识。

如果需要容忍拜占庭故障，则条件变为 N>=3F+1\.

我们将在后面讨论不可能性结果时更正式地介绍这个问题。

章。但请将这些条件记住作为较低的严格下限。

共识问题也适用于分布式计算中的其他问题。

类似于总排序广播，领导者选举问题和可终止的可靠

广播需要就共同值达成一致。这些问题可以被认为是

共识变体。

**系统模型**

为了研究共识和协议问题，并制定解决方案，有一些

我们对分布式系统行为的基本假设。我们

在第 [1](https://doi.org/10.1007/978-1-4842-8179-6_1) 章，我们学到了许多关于节点和网络行为的抽象。

在这里，我们总结了这些假设，并继续讨论共识

更详细地描述系统模型的原因有两个：首先

总结我们在本章中学到的有关节点和行为的知识

网络，并且将此知识放入研究共识和

协议问题。详细研究，可以参考第 [1\.](https://doi.org/10.1007/978-1-4842-8179-6_1) 章

**分布式系统**

分布式系统是一组使用消息传递进行通信的进程。

共识算法是基于对定时和假设所进行的

分布式系统的同步行为。这些假设包括

计时模型或同步假设，我们将在下一节中描述。

128

[3 章分布式一致性](https://doi.org/10.1007/978-1-4842-8179-6_5)

**计时模型/同步**

同步假设捕捉了有关分布式系统的时间假设。

处理器和通信的相对速度也会考虑进来。那里

有几种同步模型。我们简要描述如下：

• 同步系统，在其中对发送消息的时间有一个已知的上限

处理器和通信延迟总是成立。

• 异步系统，其中对

时间没有限制处理器或通信

延迟。这是一个有用的概念，因为用这种

假设也自动具有同步和

其他更有利的模型。换句话说，一个程序

在异步模型中证明是正确的，就会自动正确

一个同步模型。

• 部分同步可以用几种方式定义：

• 存在一个未知的上限，总是成立。

• 存在一个已知的上限，终究在

一些 GST 之后。

• 有保证的同步期，长达

足够的，以便能够做出决策，以及一个算法能够

终止。

• 存在一个未知的上限，最终在

一些 GST 之后。

• 弱同步引入了实用拜占庭错误

容错（PBFT）假设网络延迟不会增加

无限地比超时时间长。

• 一个系统最初可以是异步的，但是同步

在 GST 之后。

通常，在实践中，关于时序的部分同步假设是必需的

分布式系统的行为。这个选择在区块链协议中尤为重要，因为大多数共识协议都是为最终同步/部分同步设计的

同步模型，例如，区块链的 PBFT。当然，一些是设计

129

[3 章分布式一致性](https://doi.org/10.1007/978-1-4842-8179-6_5)

对于异步模型，比如 HoneyBadger。我们将涵盖区块链共识

在第[5 章](https://doi.org/10.1007/978-1-4842-8179-6_5)中，并贯穿本书始终。现在，我将专注于一般分布式一致性问题以及传统观点。

还要注意，与拜占庭错误的异步消息传递模型

根据今天基于互联网的典型分布式系统的情况。 

尤其是在比特币或以太坊等公共区块链平台上。 

**处理器故障**

故障模型使我们能够做出关于哪些故障可能发生以及如何

我们能够应对它们。故障模型描述了在何种条件下会发生故障

可能发生也可能不发生。有各种类别，比如崩溃故障，其中进程

可以发生崩溃停止或崩溃失败，或忽略故障，在其中处理器可以不发送或

接收一条消息。

另一种忽略故障类型称为动态忽略故障。在这个模型中，一个

系统在每轮中可能会丢失最大数量的消息。但是，通道

丢失的消息可能会从一轮到另一轮发生变化。

定时失败是那些进程不遵循同步性的情况

假设。进程可能表现出拜占庭行为，其中进程可以

表现任意或恶意。在拜占庭模型中，已损坏的处理器可能会

会略过消息，尝试主动破坏整个系统。我们在此定义了一个敌手模型，做了一些关于敌手的假设，敌手可以

对分布式系统产生不良影响并损坏处理器。

在经过身份验证的拜占庭失败中，可以确定

通过标识消息并检测伪造消息，通常通过数字签名。

在假设下发生的故障被称为经过身份验证的拜占庭故障。

消息可以经过身份验证或非经过身份验证。经过身份验证的消息

通常使用数字签名来允许检测伪造和消息篡改。

与经过身份验证的比较容易解决一致性问题

接收者可以检测消息伪造并拒绝未签名的消息或重复消息。

不正确签名的消息或来自未经身份验证的进程的消息。对

另一方面，处理非经过身份验证的消息的分布式系统很困难

处理，因为无法验证消息的真实性。非经过身份验证的消息也称为口头消息或未签名的消息。尽管困难，130

第三章分布式一致性

解决一致性或协议问题的常见假设。

然而，数字签名在区块链系统中是无处不在的，而模型是在

区块链共识工作的方式几乎总是经过身份验证的拜占庭。

**通道可靠性**

常常假定通道是可靠的。可靠通道保证如果

正确的进程 p 向正确的进程 q 发送了消息 m，那么 q 最终将

收到 m。实际上，通常是提供可靠性的 TCP/IP 协议。

丢失通道是捕捉通道概念的另一种假设，通道中

消息可能会丢失。这可能是由于网络条件差，延迟，否认-

例如：服务攻击，一般的黑客攻击，网络缓慢，网络配置错误，噪音，缓冲区溢出，网络拥堵和物理断开连接。

也许还有许多其他原因，但我只描述了最常见的原因。

公平丢失通道有两种变体。有一个上限值 k

一种是在一种变体中确定丢失的消息数量，另一种是公平丢失通道，

没有这样的上限。第一种变体更容易处理，算法可以重新传输消息 k+1 次，确保至少接收一份副本。在

后一种变体——公平丢失通道，如果发送者不断重新发送消息，

最终它被交付，前提是发送方和接收方都是正确的。我们在第[1](https://doi.org/10.1007/978-1-4842-8179-6_1)章中对此进行了更详细的讨论。

**历史**

多年来，在分布式计算中一直在研究共识问题。实现

第一次由 Lamport 等人在他们的论文“SIFT:设计

以及飞机控制的容错计算机的分析。”

首次提出了同步设置下的拜占庭容错协议

由 Lamport 等人在他们的重要论文“在存在的条件下达成一致”中首次提出

故障。”

即使有单个进程崩溃失败也不可能达成协议的不可能性

Fischer, Lynch 和 Paterson 证明的。这一发现臭名昭著，被称为 FLP

不可能的结果。

Ben-Or 提出了使用随机化的异步拜占庭容错。

规避 FLP。此外，DLS 88 提出了关于 BFT 的部分同步性。

131

第三章 分布式一致性

**两将军问题**

两位将军悖论或两位将军问题是由格雷等人在

1978 年。在这个思想实验中，两位将军共同目标是夺取

一座山。条件是，如果这两位将军同时行动，同时攻击山丘，那么成功是有保证的。如果其中一位将军单独进攻，那么他们将输掉这场战斗。还假设这两位将军分别扎营于一定距离之外，他们只能通过信使（奔跑者）进行交流。

然而，这些信使并不可靠，可能会丢失或被抓。如果一个将军

发送消息给另一位将军以发起攻击，例如，“在 0400 小时攻击”，然后

可能这条消息没有传递到另一位将军手中。假设这条消息

如果这封信没有送到第二将军手中。在这种情况下，无法区分第一将军是发送了一封信还是信使在去找第二将军的路上被抓了

第二位将军。发送消息的将军不能假设他的消息

如果没有从第二个接收到明确的确认，他就无法通过。

通常情况下，他无法确定。现在的问题是我们能想出什么协议

达成一致意见计划进攻。这种情况很棘手，因为没有

将军之间没有共同的知识，唯一的了解方式是通过信使，

它是不可靠的。

两位将军都有两个选择。他们可以无视任何

从另一位将军那里收到确认, 或者等到收到回应

来自另一位将军的确认中收到（确认）。在第一种情况下，风险是将军在没有得到对方的回应的情况下前进，可能最终独自一人

在攻击中被击败。在后一种情况下，将军在收到响应之前不会行动。在这种情况下，等待回应的第一将军是安全的，因为只有在收到回应时才会发起攻击。所以现在变成了第二位将军的

责任来决定是否攻击并且独自一人或者等待一个确认

从第一将军那里接到了确认。其中一个解决方案是如果将军们发送了很多消息，那么至少有一种可能性会到达，但也有可能会

注意到，也许如果将军们发送很多信使，那么至少有一种可能性会到达，但也有可能会

如果所有军队单位同时攻击，那么所有部队可能都会

被捕获，没有消息穿过。例如，如果将军 1 发送很多消息

**拜占庭将军问题**

双将军问题被描述在图 3-8\.

拜占庭将军问题是由 Lamport 在 1982 年提出的。在这个思想

![](img/index-152_1.png)

第三章分布式一致性

***图 3-8\.** 双将军问题*

在 Figure 3-8, two 将军必须就攻击时间达成一致意见；否则，不会赢。

问题是没有一个将军能确定另一个的承诺

其他将军。如果将军 1 即使没有收到被确认也攻击

将军 2，那么将军 1 如果所有信使都丢失，就冒着独自攻击的风险。这是因为将军 2 对攻击一无所知。如果将军 1 发起攻击

将军是否收到他们的消息，因此产生了悖论！

![](img/index-153_1.png)

只有在从将军 2 那里收到积极的确认时，将军 1 才是安全的。

将军 2 面临着与将军 1 相同的境地，因为现在他正在等待将军 1 的确认。将军 2 可能认为自己是安全的，因为他知道将军 1 会

132

互的状态是通过消息。

互的状态都是通过消息传递的。

从分布式系统的角度看，这个实验描绘了一个情景，即两个

对将军 2，所有信使都丢失，那么将军 2 不知道有关攻击，

实验中，描绘了一个设想的场景，其中三个或更多个军队单位是

驻扎在城市周围，部队的集体目标是占领城市。每一个

由将军领导，并且它们通过信使进行通信。这个城市只能

进程没有共同知识，唯一的方式是他们可以找到关于的

这里的要求是达成一致协议攻击，以便所有军队可以攻击

同时攻击并且结果占领这座城市。

133

如果将军 1 继续进行攻击，那么战斗就失败了。

第三章分布式一致性

这种设置可能面临的问题

• 消息可能会丢失，也就是说，信使可能会被捕获或丢失。

• 任何将军都可能是叛徒，可以发送误导性的消息给

其他将军，可以扣留消息，也可以不发送消息

所有将军，可以在将消息传递给之前篡改消息

其他将军，或者发送矛盾的消息，都是为了

风清水静的过程之间达成一致。

-   忠诚的将军也不知道谁是叛徒，但叛徒

可以勾结在一起。

在这种情况下是否可以达成一致。

什么协议可以解决这个问题，如果有的话。图 3-9 显示了这个问题。

***图 3-9\.** 拜占庭将军问题 - 显示每个军队单位收到*

*误导，正确，或者根本没有消息*

134

第三章 分布式一致性

结果表明这个问题是不可能解决的。已经证明了这个问题

只能在少于三分之一的将军是叛徒时才能解决这个问题。例如，如果有 3t + 1 个将军，最多只有 t 个可以恶意。这是拜占庭容错的已经证明的下限。我们将在本节稍后更正式地看到这一点

“不可能结果”中我们将讨论 FLP，CFT 下界和 BFT 下界。

在分布式系统中，我们可以有一个类似的情况，将军代表进程

（节点），叛徒代表拜占庭过程，忠诚的将军代表正确的

过程，使者代表通信链路，丢失消息是被捕捉

使者，并且使者抵达将军的时间没限制代表异步性。

我想你现在明白了！

**复制**

在本节中，我们将讨论复制。复制用于在多个节点中保持数据的完全副本。这种技术有几个优点。一个关键的优势

是容错。存储系统中最简单的复制之一就是 RAID。

例如，在 RAID-1 中，有两个磁盘，它们是彼此的精确副本（镜像）。如果一个不可用，那么副本可用，从而实现了容错和高可用性。在分布式系统中，复制被用于各种原因，与 RAID 不同的是，它不仅仅在服务器内的两个磁盘之间，而是在多个节点之间。

此外，如果数据保持不变，那么复制就很容易。您只需进行一次性

将数据复制一份并存储在另一个磁盘或节点上。挑战在于数据不断变化时如何保持复制一致性。

有几个优点：

-   由于容错性而具有高可用性，例如，如果一个副本

下降时，另一个可用于为客户提供服务的。

-   由于每个副本节点都是独立的

节点，并且客户可以发送请求到不同的节点（或者可以是

通过负载均衡器来管理路由请求到繁忙程度较低的副本 –

负载平衡）。负载可以分布在不同的副本之间

以实现更高的性能。

-   数据一致性意味着相同的数据副本可以在各处使用

所有节点，这有助于整个系统的完整性。

135

第三章 分布式一致性

• 较好的性能，通过负载平衡实现，其中

较不繁忙的节点可以处理请求，以防其他节点

接近或容量已满。有几种技术可以实现这一点

超出了本书的范围；然而，通常会使用负载均衡器

通常用于将来自客户端的请求路由，通常是轮询

与副本相同的方式。这样，负载就分散到多个

代之以单一节点承受所有请求，因此

由于 CPU 负载而变得不太响应。

• 数据局部性，在地理上分布的情况下

网络，对于一个客户端本地的节点可以为请求提供服务

而不是只有一种情景下可能只有一个节点

远程数据中心和所有客户端要么地理位置接近，要么

远程向单个服务器发送请求的客户端。那些

物理位置更接近的服务器将更快地收到它们的响应，因为

与位于城市或大陆的客户端相比

分开。例如，在文件下载服务中，一个镜像，例如

例，位于爱尔兰的可提供下载服务

比可能在澳大利亚的服务器更快地处理请求。

仅仅网络延迟就使得这样的设置容易受到

性能损失。

也存在一些缺点：

• 高成本，需要多个副本节点，设置可能会

昂贵。

• 在副本之间维持数据一致性很困难。

复制可以通过两种方法实现。一种是状态传输，其中

一个状态从一个节点发送到另一个副本。另一种方法是状态机

复制。每个副本都是以确定性方式运行命令的状态机

与其他副本相同的顺序，使得副本之间的状态保持一致。通常，在这种情况下，主服务器接收命令，然后将其广播到

其他应用这些命令的副本。

实现复制的两种常见技术。我们将它们定义为

如下所示。

136

第三章 分布式一致性

**主动复制**

在这种方案中，客户端命令通过一个排序协议进行排序，并转发

以确定性方式执行这些命令的副本。这里的直觉是，如果所有命令在所有副本上以相同的顺序应用，那么每个副本将产生

相同的状态更新。这样，所有副本都会保持一致。这里的关键挑战是开发一种命令排序方案，并确保所有节点

以相同的顺序执行相同的命令。另外，每个副本起始于相同的

状态，是原始状态机的副本。主动复制也被称为**状态** **机复制**。

**被动复制**

在被动复制方法中，有一个副本被指定为主要副本。

此主要副本负责执行命令并发送（广播）

更新到每个副本，包括它自己。然后所有副本都应用状态更新。

按接收顺序。与主动复制不同，处理不需要

确定性的，并且任何异常情况通常由指定的主副本解决

并产生确定性的状态更新。这种方法也被称为**主备份**

**复制**。简而言之，在系统中只有状态机的一个副本由主副本保留，其余的副本只维护状态。

**优缺点**

采用这两种方法都有利有弊。主动复制可能会导致浪费

如果操作量比较大，这也会耗费大量的网络带宽。此外，在被动复制中，

由于有一个主副本，如果它出现故障，系统的性能和可用性会受到影响。

在被动方法中，客户端的写入请求由主服务器预处理并

转换为状态更新命令，并以相同顺序应用于所有副本。

每个副本都是主动复制中状态机的副本，而被动复制

复制，只有主副本是状态机的单一副本。

137

第三章 分布式共识

请注意，即使在主动和被动复制之间有区别，在

在基本层面上，它们两者都是使状态机

容错。

现在让我们看一下主备份复制是如何工作的。我假设有一个故障停止

模型。

**主备份复制**

主备份复制是最常见的复制方案。有

一个被指定为主服务器的正确副本

具有最低标识符的进程被指定为主副本。客户端发送

请求转发到指定的主服务器，主服务器将请求转发到所有备份服务器。

主服务器只在收到所有备份的响应后才向客户端回复。

当客户端发出写入请求时，主服务器将请求发送到所有副本，并在收到来自备份的响应后，将更新提交给自己（交付给

本身）。

算法的工作原理如下：

1\. 客户端向主服务器发送写入请求。

2\. 主服务器将请求广播到备份副本。

3\. 备份副本向主服务器发送确认（响应）。

主副本。

4\. 主服务器等待收到所有备份的响应

副本。

5\. 一旦收到所有响应，它将请求提交给自己。

这被称为提交点。

6\. 然后，主服务器将响应发送回客户端。

在读操作的情况下

1\. 客户端发送请求到主服务器。

2\. 主服务器回复。

图 3-10 描绘](#p158)述了这个概念。

138

![](img/index-158_1.png)

第三章 分布式共识

***图 3-10\.** 主备份复制*

故障是如何处理的？如果主服务器出现故障，其中一个备份服务器将接管。

现在，这看起来像一个适合实现容错的协议，但如果

主服务器失败？主服务器故障可能导致停机，因为恢复可能需要时间。另外，

从主服务器读取可能会产生不正确的结果，因为在一些情况下

客户端在提交点之前向主服务器进行读取请求，主服务器

将不会产生结果，即使所有副本都已经传递了更新。

一种解决方案可能是将读取视作更新来处理，但这种技术相对

低效。此外，主服务器正在做所有的工作，即发送到其他副本，接收响应，提交，然后回复给客户端。此外，主服务器必须

等待直到所有副本都接收到响应才能回复给客户端。与主备份副本解决方案相比，更好的解决方案是链式

复制。这里的核心思想是备份服务器之一将回复读取请求，而另一个将处理更新命令。

**链式复制**

链式复制将副本组织成一个带有头部和尾部的链。头部是

服务器编号最大，而尾部是编号最低的。

写请求或更新命令被发送到头部，头部使用

可靠的 FIFO 链路到链上下一个副本，然后下一个副本将其转发到下一个，直到更新到达最后一个（尾部）服务器。尾部服务器然后响应给客户端。头部副本对来自客户端的请求进行排序。

139

![](img/index-159_1.png)

第三章分布式共识

对于读取请求（查询），客户端将其直接发送到尾部，并由尾部回复。

当尾部失败时，只需重新选择前一个副本作为新的尾部，就可以轻松恢复。

如果头部失败，则其后继者成为新的头部，并通知客户端。图 3-11

显示链式复制的工作原理。

***图 3-11\.** 链式复制*

链式复制提供高可用性、高吞吐量和强大的

一致性。它可以容忍高达*n* – 1 的故障。

**状态机复制**

状态机方法是由 Leslie Lamport 在他的开创性论文中提出的

“时间、时钟和分布式系统中事件排序”1978 年的文章。这是一个 de

分布式系统中实现容错的事实标准。

首先让我们定义什么是状态机。状态机执行一系列

命令。它存储系统的状态。这个存储状态会转移到下一个

通过状态转换功能的状态。命令执行结果的状态和输出仅由输入确定

是确定性的，结果状态和输出仅由输入决定

机器执行的命令之一。

列表 3-1 des 中的简单算法描述了状态机节点。

140

![](img/index-160_1.png)

第三章分布式共识

***列表 3-1\.*** 状态机

状态 := 初始

日志 := 最后的命令

当（真）{

在接收到命令的事件上

{

附加到日志(command)

输出：= statetransition（命令，状态）

给客户发送输出

}

}

在这个伪代码中，状态机从初始状态开始。当一个命令

当从客户端接收到命令时，将其附加到日志中。之后，它通过转换函数执行该命令并更新状态并产生输出。这

输出作为响应发送给客户端。

图 3-12 说明了这个概念

*** 图 3-12. **状态机副本*

状态机复制的关键思想是，如果系统建模为

作为状态机，那么只需实现一个操作的一致

对操作的顺序达成一致。如果相同的命令应用于所有节点

141

第三章 分布式一致性

相同的顺序，那么将所有副本保持一致的一般方法是实现一个共同的全局

命令的顺序。

为了在操作的顺序上达成一致，我们可以使用协议

诸如拜占庭协议或可靠广播协议。我们

在本章的前面我们讨论了总序广播抽象。我们也可以

使用诸如 Paxos 或 PBFT 等共识算法来实现这一点。请记住，在

总序传播，每个进程以相同的顺序传递相同的消息。这

属性立即解决了我们在操作顺序上达成一致的问题

操作，这是状态机复制的核心见解。总序

广播确保来自不同客户端的命令以相同的顺序传递。

如果命令以相同的顺序交付，它们将以相同的顺序被执行

和作为状态机是确定性的，所有副本最终将处于相同的状态。

每个副本都是一个状态机，它将其状态转换为下一个

由于执行输入命令的结果。每个副本上的状态

以(key, value)对的形式维护。命令的输出从当前状态转移到下一个状态。确定性非常重要，因为这确保了每个

命令执行产生相同的输出。每个副本都从相同的初始状态开始

状态。总序广播在全局中将相同的命令传递给每个副本

顺序，这导致每个副本执行相同的命令序列和

转移到相同的状态。这在每个副本中实现了相同的状态。

这个原理也用在区块链中，通过某些共识机制实现了总序

事务和块的顺序，并且每个节点

执行并以与其他副本相同的顺序存储这些事务

由工作证明获胜者，领导者提出。我们将在第[5 章](https://doi.org/10.1007/978-1-4842-8179-6_5)中详细探讨这一点。

传统协议，如实用拜占庭容错（PBFT）和 RAFT 协议

状态机复制协议。

通常用于实现提高系统性能和容错性。

系统性能可以提高，因为多个副本托管数据副本，并且

由于多个副本而增加了可用资源。由于多个副本，容错性提高。

事实上，即使有些副本不可用，数据在每个副本上都被复制，系统仍将继续运行并响应客户端的查询和更新。

现在让我们正式看一下 SMR 的属性。

142

第三章分布式一致性

**相同的初始状态**

复制品始终从相同的初始状态开始。可能只是一个空数据库。

**确定性操作**

所有正确的复制品对相同的输出和状态进行确定性处理

输入和状态。

**协调性**

所有正确的复制品以相同的顺序处理相同的命令。

协调性质要求使用类似于 total 的协议

order broadcast or some consensus algorithms.

还有两个安全性和活跃性属性，我们将其描述如下。

**安全性**

所有正确的复制品执行相同的命令。这是**协议**的属性。实现一致是有两种通用方法的。我们可以使用 total

广播或共识协议。总序广播协议只需运行一次

每个状态机复制一次，而共识机制实例化为

命令序列的每个时间段。

**活跃性**

所有正确的命令最终由正确的副本执行。这也被称为**完成**属性。

安全性确保一致性，而活跃性确保可用性和进度。

图 3-13 demons 将演示 SMR 通常的工作方式。

143

![](img/index-163_1.png)

第三章分布式一致性

***图 3-13。** 状态机复制*

在图 3-13 中，我们可以看到流程如何工作：

1.客户端将命令 x = 5 提交给副本 1。

2.副本 1 将此命令发送给副本 2 和副本 3。

3.所有副本将命令追加到它们的日志中。

4.所有副本上的状态机执行命令。

5.副本 1 将回复/结果返回给客户端。

副本的复制日志确保状态机命令按照确定的全局顺序执行

每个复制品的同一顺序中执行。一致性机制（在左上角

图像的角落）确保命令顺序达成一致

并将其作为这样的记录写入日志。这涉及就命令序列达成一致意见。如果有其他复制体，

命令序列。如果有其他复制品的命令序列达成一致意见。如果这种复制系统

大多数副本是正常的。

共识和状态机复制在某种意义上相关，即分布式

共识建立状态机命令的全局公共顺序，而

状态机根据确定的全局顺序执行这些命令

通过共识（协议）算法来决定，因此每个节点（状态机）都达到了

相同的状态。

144

第三章 分布式一致性

一个崩溃容错的状态机复制至少需要 2f+1 个副本，而一个 BFT SMR

需要 3f+1 个副本，其中 f 是失败的副本数量。

状态机复制实现了副本之间的一致性。有各种各样的

副本一致性模型。我们将在这里简要探讨它们。

**线性一致性**

一个状态机复制协议可以实现的另一个更强的属性

称为线性一致性。线性一致性也称为原子一致性，它意味着命令执行看起来就像在状态机的单个副本上执行一样，即使

如果有多个副本。线性一致性的关键要求是读取的状态始终是最新的，永远不会读取过时的数据。

一致性模型可以让开发人员了解复制的行为

存储系统。与复制系统交互时，应用程序开发人员

体验与与单一系统交互相同的行为。这种透明度

允许开发人员使用相同的单一服务器约定来编写应用程序逻辑。如果一个复制系统具有这种透明度，那么它被称为是线性的。

在文献中，线性一致性也被称为强一致性、原子一致性或

立即一致性。

**顺序一致性**

在这种一致性类型中，所有节点看到的命令顺序与其他节点相同。

线性一致性和顺序一致性是**强一致性**的两种类别。

**最终一致性**

在最终一致性模型下，最终保证每个副本

如果没有更多的更新，那么最终会处于相同的状态。然而，这意味着

没有时间保证，因为更新可能永远不会停止。因此，这并不完全是一个

可靠的模型。另一个更强的方案称为强最终一致性

具有两个属性。首先，应用于一个诚实副本的更新最终应用于每个非故障的副本。其次，无论更新的顺序如何

已经处理，如果两个副本处理了相同的更新集，它们最终会

在相同的状态。第一个属性称为最终交付，而第二个

属性被命名为收敛。

145

第三章 分布式一致性

有几个优点。它允许副本无需

网络连接，直到恢复连接，并最终副本收敛到相同状态。最终一致性可以使用更弱的广播模型，

而不是总体顺序广播。

最终一致性有几种类别，比如最后写入获胜。这种技术

这里是要应用具有最近时间戳的更新，并且丢弃任何其他更新

使用较低的时间戳向相同的键（更新相同的数据）写入。这意味着

我们接受一些数据丢失，以换取所有副本最终收敛到相同状态的。

**使用较弱的广播抽象的状态机复制**

SMR 利用总顺序广播来实现全局命令顺序

系统。在这里，问题是我们是否可以使用更弱的广播类型

用于构建状态机复制的抽象。答案是肯定的；但是，一种特性

叫做“可交换性”，还需要满足其他一些特性。更新是

如果两个更新的顺序不重要，那么是可交换的，比如在算术中

A + B = B + A, A 和 B 的顺序不重要；它将得到相同的结果。

同样，我们说命令 x 和 y 是可交换的，如果在状态机的每个状态*s*中，执行 x 然后执行 y 或先执行 y 再执行 x 都导致相同的状态更新，并且 x 和 y 在执行时返回相同的响应。在这里，我们说 x 和 y 是可交换的。

这里的关键见解是，如果复制状态更新是可交换的，那么复制品

可以以任何顺序处理命令，但最终达到相同状态。而

当然，你必须在协议中构建可交换的机制。表 3-1 展示了不同广播和相关特性以及对状态的假设

更新.1

1 该表格取自 Martin Kleppmann 博士的分布式计算的精彩演讲。

146

第三章 分布式一致性

***表 3-1**。广播和构建复制的要求*

**类型**

**关键特性**

**状态更新要求**

**广播**

总顺序

所有消息以相同的顺序传递在确定性

所有复制品

因果性

按照循序传递消息，但

决定性，并发更新

广播

同时的消息可能以可交换性传递

任何顺序

可靠的

没有顺序保证没有重复的

决定性，所有更新

广播

消息

可交换性

最大努力

尽力而为，没有交付保证

确定性的，可交换的，

广播

幂等，并容忍信息

丢失

现在让我们探讨一些分布式计算中的基本结果

支撑分布式协议和算法的基础。

**基本结果**

在分布式计算中，有许多基本结果已经报道

由研究人员。这些基本结果为

分布式计算范例立足的地方。其中最有趣的是不可能性

结果。

**不可能性结果**

不可能性结果为我们提供了问题是否可解的理解

或者最小的资源来做到这一点。如果一个问题是解不出来的，那么

这些结果清楚地说明了为什么特定问题是不可能解决的。如果

如果证明了不可能性结果，那么对此不需要进一步的研究，而

研究人员可以将注意力集中在其他问题上或规避这些结果

某种程度上。这些结果向我们展示了除非满足条件，否则某些问题是不可解的

提供的资源。换句话说，它们表明某些问题无法

如果资源不足，则计算可能并且也可以。有些问题是根本无法解决的

147

第三章分布式共识

有的问题只有在给定足够的资源时才能解决。最低

解决问题所需的可用资源被称为**下限结果**。

为了证明有些问题无法解决，定义一个

系统模型和允许算法的类。一些问题在下面是可解的

一个模型中但在其他模型中不会。例如，在异步条件下共识是无法解决的

网络假设但在同步和部分同步中是可以解决的

网络。

在分布计算中最基本的问题之一是有多少节点/

所需的过程只是为了容忍崩溃和拜占庭故障。

**最小进程数**

已经证明解决问题需要一定数量的最小过程

一致性。如果没有故障，那么一致性（协议）在两方面都可以实现

同步和异步模型。共识在异步中是不可能的

系统，但在崩溃故障模型下的同步系统和拜占庭故障

模型，可以实现共识。然而，故障率有一个下限

过程。只有少于处理器三分之一的情况下才能得到共识

拜占庭。

Lamport 表明，当故障节点不超过三分之一时，那么诚实节点

总是可以达成共识。

**崩溃故障**

要实现崩溃容错，紧密的下限是 N => 2F + 1，其中 F 是故障节点的数量。这意味着如果

其中一个崩溃故障以实现崩溃容错。如果 n <=

在故障容忍设置中的 2f。

**拜占庭故障**

为了实现拜占庭容错，紧密的下限是 N >= 3F + 1，其中 F 是故障节点的数量。这意味着如果有一个最小的四个节点是必需的

随意发生崩溃以实现拜占庭容错。

如果 n<=3f，那么没有算法可以解决共识问题，其中 n 是节点，f 是

拜占庭节点。有一个对故障个数的严格下限为 3F+1

处理器。

148

第三章分布式共识

**最小连接性**

容忍失败的最小网络连接至少为 2f+1。

**最小轮数**

所需的最小轮数是 f+1，其中 f 可能会失败。这是因为一个

轮次多于故障数量应该有一个无故障轮次，因此

允许共识。

**FLP 不可能性**

FLP 不可能性结果表明，解决共识是不可能的

在最多一个模型中以确定性地消息传递异步系统中没有算法可以解决共识。要么会有

进程可能以崩溃的方式失败。换句话说，在一个包含 n 个节点的系统中，

无限的延迟，没有算法可以解决共识。要么会有

执行中未达成一致或将有一个执行不会

不会终止（无限执行）。

FLP 不可能性结果的关键问题是，在一个

异步系统中，无法区分崩溃的进程和

进程仅仅是慢或者在一个慢速链接上发送了消息，只是需要一些时间才能到达接收者。

FLP 是分布式计算中最基本的不可解结果之一。

FLP 是以作者迈克尔·J·费舍尔、南希·A·林奇和

迈克尔·S·帕特森在 1982 年在他们的论文“分布式计算的不可能性”中报告了这个结果。

具有一个故障进程的分布式一致性。

如果全局状态 C 的配置是单一值状态，那么从 C 开始的所有执行结果都是输出

相同的值，也就是说，只有一个可能的输出。如果配置为 0-valent，那么决策结果为 0，如果配置为 1-valent，那么决策结果为 1。全局状态 C 的配置如果有两个从 C 开始的执行结果输出不同的值，那么 C 是双值状态。

我们可以在图 3-14.中可视化这一点

149

![](img/index-169_1.png)

第三章 分布式共识

***图 3-14.** 单一值状态和双值状态的配置*

FLP 的关键思想是双向配置总是可以过渡到一个

一些双值状态的配置。因为存在一个初始的双值状态配置，所以可以得出有一个不终止的执行，导致只有双值状态的配置。

对此可以通过一个场景来理解。假设你有两组不同的

节点，例如集合 A 和集合 B，每个集合都有五个节点。在没有故障的五节点网络中，每个集合中的大多数（即五分之三）都将导致一致性。假设在集合 A 中五个节点有一个建议值为 1 {11111}，那么我们知道在一个

在诚实的环境中所有节点的决策将是值 1。同样在 B 集合中，如果

初始值是在所有节点上均为 0 {00000}，那么在无故障的环境中所有节点都将同意值 0。我们可以说在 A 集合和 B 集合中，配置即全局状态分别是 1-valent 和 0-valent。然而，想象一下现在不是所有节点

是 0 或 1，但是一些是 0，另一些有值为 1。想象一下，在 A 集合中，三个节点

是 1，另外两个值为 0，即 {11100}。同样在 B 集合中，两个节点是 1，另外三个节点持有值为 0，即 {11000}。请注意，这些集合现在只有一个节点的不同值，A 集合中为值 1，B 集合中为值 0，即两个集合中间的中间节点（第三个元素）。由于五个节点中三个节点表示的大多数，所以在 A 集合中已经达成了 1 的决议，而在 B 集合中由于同样的大多数达成了 0 的决议。我们称这两个集合为配置或者全局状态。所以现在我们有两个配置，

其中一个达成了 1 的一致性，另一个达成了 0 的一致性。到目前为止一切顺利，但是现在想象一下，如果一个

节点出现故障，而且正是这个中间节点是这两个集合的唯一区别。

如果中间节点同时从 A 和 B 集合中失败，它们各自变为 {1100}，其中

意味着这两个集合现在无法从彼此中辨别，暗示着它们两者都

取决于第三个节点的可用性，可以达成相同的 0 或 1 的共识

元素（中间节点）。这也意味着这些集合中的一个可以达成共识

决定，0 或 1，取决于第 3 个节点的可用性。

150

第三章分布式一致性

现在想象一下，所有节点的默认值都是 0，现在通过一个失败的（被移除的）

节点，集合 A {11100}如果中间节点出现故障，则最终达成 0 的共识，

如果没有节点故障，它将达成 1 的共识。这是一个模棱两可的情况，称为双价配置，其中如果中间节点持有值 1，则达成共识 0

是不可用的，但如果没有节点故障，它将达成 1 的共识。现在的情况是集合（节点）可以达成 0 或 1 的共识，结果是不可预测的。

证明了这种双价初始配置的模棱两可情况可以

即使只有单个故障，始终存在，并且其次总是可能导致另一种模棱两可的情况。换句话说，在任何情况下都可以始终存在一个初始双价配置

转换到另一个双价配置，因此在异步情况下不可能达成一致。

收敛到单价（0 价或 1 价）是可能的。

有两个观察结果导致 FLP 的不可能性。首先，有

在任何一致性算法中始终存在至少一个双价初始配置

在故障存在的情况下工作。其次，双价配置总是能够转换到另一个双价配置。

FLP 结果得出结论，在异步系统中，首先存在一个全局状态

（配置）在算法无法决定的地方，并且总会有一个场景

在系统无法得出结论的情况下。换句话说，总是有一个可接受的运行

总是在不确定状态下保持不太可能达成共识。

异步状态机复制也容易出现 FLP 不可能性

限制。区块链网络也受到 FLP 不可能性的影响。比特币，

以太坊，以及其他区块链网络如果没有引入一定程度的同步就不可能构建

引入同步的某种程度来规避 FLP 的不可能性。

已经提出了许多努力来绕过 FLP 的不可能性。

这种规避围绕着使用 oracle。这个想法是使一个 oracle

可用于分布式系统以帮助解决问题。**Oracle**可以定义为处理（节点）可以查询以获取一些信息的服务或黑匣子

帮助它们决定行动的。接下来，我们介绍一些常见的

提供足够信息给分布式算法以解决问题的 oracle，

否则可能无法解决的限制问题。我们可以使用 oracle 来促进解决共识

分布式系统中的问题。

围绕 FLP 不可能性的规避的关键思想基于

牺牲了异步和确定性。当然，正如我们所学到的，确定性

协议不可能在异步性下即使一个进程崩溃; 因此

诀窍是略微牺牲异步性或确定性，刚好足够达到达成决定并终止的地步。

151

第三章 分布式一致性

现在我们讨论一些技术：

• 随机神谕

• 失败探测器

• 同步假设

• 混合模型

**同步假设**

在同步假设下，在模型中引入了关于时间的假设。

记住，在本章和第一章中我们讨论了部分同步。

部分同步是一种通过规避 FLP 进行共识解决的技术

不可能性。在部分同步模型下，异步性在一定程度上被牺牲以

引入一些时间假设，允许解决共识问题。同样，在最终同步模型下，假设系统最终

全局稳定时间（GST）之后同步。另一个时间

假设是弱同步性，假设延迟保持在某个特定值以下

阈值并且不会永远增长。这种时间假设允许共识算法通过假设某种时间概念（同步）来决定和终止。

**随机神谕**

随机神谕允许开发随机算法。这就是

确定性在一定程度上为了以概率的方式达成一致而牺牲。

这种方法的优势在于对时间没有任何假设，

但是缺点是随机算法效率不太高。在随机化

共识算法，其中安全性或存活性属性被改变为

非确定性概率版本。例如，存活性属性变为

• **存活性**：每个正确的进程最终都会做出决策的概率很高

概率。

这解决了 FLP 不可能性，FLP 不可能性意味着

在共识中存在一些不终止的执行。如果

终止被赋予概率，可以“规避”共识的不可能性：

• **协议**：所有正确的进程最终会就一个值达成一致

概率 1。

152

第三章 分布式一致性

通常，存活性属性是以概率的形式而不是安全性的形势进行

协议，有效性和完整性的属性。通常不建议为了存活性（终止）属性而牺牲安全性属性。

随机算法中的核心技术是所谓的“硬币翻转”。

投币或硬币翻转可以分为两种类型。

本地硬币是指处理器状态从当前状态向前推进到

接下来，根据算法的概率分布选择，这通常实现为一个随机位生成器，它以 0 或 1（正面或反面）的形式返回

相等的概率。

共享硬币或全局硬币算法利用这些本地硬币来构建全局

硬币。这里的要求是为所有诚实的进程提供相同的硬币价值，并且

达成一致。

本地硬币算法在指数数量的通信步骤中终止，

而共享硬币算法在恒定数量的步骤中终止。

牺牲确定性和使用随机化有利有弊。

关键优势之一是不需要时间假设。然而，

不利的一面是回合数明显较高，并且密码学

引入随机化可能需要计算代价很高。

拜占庭共识的随机算法最早出现在本-奥尔和

拉宾在 1983 年的作品中首次出现，我们将在第[6](https://doi.org/10.1007/978-1-4842-8179-6_6)章讨论。

**混合模型**

在绕过 FLP 不可能性的混合模型方法中，引入了一种组合

随机化和故障检测器的使用。

虫洞是在比较强的属性下的系统模型中的扩展

到系统的其他部分。通常，这是一种安全的、防篡改的、失败静默的受信任硬件，它为进程提供了正确执行一些关键步骤的方式

协议。文献中已经介绍了各种虫洞，如

证明追加式只读存储器，迫使副本承诺对可验证的序列

的操作。受信任的及时计算基地（TTCB）是第一个虫洞

用于通过虫洞支持共识。

153

第三章分布式一致性

**故障检测器**

故障检测器背后的这种直觉是，如果我们可以得到一些关于

一个进程的失败，那么我们可以绕过 FLP 不可能性。记住 FLP

不可能性结果表明，不可能区分已崩溃的

过程和一个非常缓慢的过程。没有办法找出来，所以如果我们可以

得到一个提示，有些进程已经失败了，那么处理将更容易

情况。在这种情况下，非同步性在某种程度上受到牺牲，因为故障检测器

基于心跳和超时假设的工作。故障检测器被添加为一个

到异步系统的扩展。

可以定义故障检测器为每个进程的分布式神谕，给予

关于（嫌疑）一个进程是否存活或已崩溃的提示。在某种程度上，故障

检测器封装了超时和部分同步假设作为一个独立模块。

定义故障检测器的两类属性：

• **完整性**意味着故障检测器最终会检测到

有缺陷的过程。这是一个活力性质。

• **准确性**意味着故障检测器不会怀疑正确

过程失败了。这是一个安全性质。

基于前两个属性，已经有了八种故障检测器类别。

切拉和托耶格在他们开创性的论文“不可靠故障检测器”中提出了

用于可靠分布式系统。”也可以通过引入一个弱不可靠的故障检测器来解决共识问题。这项工作也是由 Chandra 和 Toueg 提出的。

故障检测器准确怀疑故障或活动性的能力取决于

对系统模型实现故障检测器通常使用心跳

通过心跳消息在进程之间交换，并且如果

这些消息有一段时间没有被一些进程接收，那么故障可能会被

被怀疑。另一种方法是实现基于

最坏情况下的消息往返时间。如果一个进程没有收到

在预期的时间范围内，如果超时发生，则进程被怀疑失败。在此之后，如果从被怀疑的进程接收到消息，则超时值会增加，进程就不再被怀疑失败。一种使用心跳的故障检测器

机制显示在图 3-15\.

154

![](img/index-174_1.png)

第三章分布式共识

***图 3-15\.** 使用心跳的故障检测器*

在图 3-15 中，进程 P1 向进程 P2 发送常规的心跳消息“Alive”。

故障检测器中有两个参数：心跳间隔 H 和超时

值 T 的超时机制。如果 P2 没有从 P1 接收到任何心跳消息，则怀疑 P1 进程。

P1 超过 T 的时间段。在图中，消息 4 没有在

超时值 T；因此，P2 现在怀疑 P1 发生故障，超时了。如果 P2 开始收到任何消息（无论是心跳还是任何其他协议、应用消息）来自

P1，然后 P2 就不再怀疑 P1 进程。这在第 5 条消息之后的信息中表示在

图表。当 P2 接收到来自 P1 的消息时，计时器 T 会重新开始（重置）。

故障检测器只在同步和部分同步情况下才实用

系统模型中。在异步系统中，故障检测器无法实现完整性

并同时准确。但是，我们也可以单独实现完整性

立即（并幼稚地）怀疑所有进程都已崩溃。之后，如果有一些

进程失败，然后怀疑将为真，满足完整性属性。

同样，可以通过不怀疑任何进程而实现准确性

当然是相当无用的，但可能达到准确性。换句话说，在同步系统中可能存在完美的故障检测器，而在异步系统中没有完美的故障检测器

在异步系统中是不可能的。在某种程度上，我们包含了部分同步和

故障检测器中的超时以实现系统中的故障检测能力。

故障检测器的另一个优点是所有的超时机制都是本地化的

在故障检测器模块内部，并且程序可以自由执行其他任务。在没有故障检测器模块的情况下，程序最终会无限等待

长时间等待来自崩溃进程的预期传入消息。我们可以理解这一点

进行对比。例如，阻塞接收操作“*等待来自消息 m 的*”

155

第三章 分布式共识

*进程 p”* 变为 *(等待来自进程 p 的消息) 或 (怀疑 p 发生故障)*。现在您可以看到阻塞程序变成了非阻塞程序，并且现在没有无限

等待；如果怀疑 p，则将其添加到怀疑列表，并且程序

持续其操作，无论是什么。

现在让我们看看强和弱完备性以及准确性的属性。

**强完备性**

此属性要求最终每个崩溃的进程都将被永久怀疑

由每个正确的进程。

**弱完备性**

此属性要求最终每个崩溃的进程都将被永久怀疑

一些正确的进程。

**强准确性**

此属性表示一个进程在任何正确的进程之前都不会被怀疑，直到它崩溃（在崩溃之前）。

**弱准确性**

此属性描述没有一个正确的进程会被任何正确的进程怀疑

进程。

**最终强准确性**

此属性表明经过一段时间，正确的进程不再怀疑任何正确的进程。

**最终弱准确性**

这个属性意味着经过一段时间，不会再怀疑任何一个正确的进程

任何正确的进程。

156

![](img/index-176_1.png)

第三章 分布式共识

我们可以在图 3-16\.（#p176）中显示的图表中可视化强和弱完备性。

***图 3-16\.* 强完备性 vs 弱完备性*

现在我们讨论八种故障检测器类。有四种故障

提供强完备性的检测器。前两个故障检测器在

同步系统，即，完美检测器 P 和强检测器 S。其余两个在部分同步模型下工作，即，最终完美检测器（钻石 P）和

最终强检测器（钻石 S）。

现在我们描述这些类，首先是强完备性。

**完美故障检测器 P**

这种类型的故障检测器满足强完备性和强准确性

属性。P 不能在异步系统中实现。这是因为强

在异步系统中无法为 P 实现完整性和准确性。

**强故障检测器 S**

此故障检测器具有弱准确性和强完备性。

**最终完美故障检测器 - 钻石 P**

这类 FDs 满足强完备性和最终强准确性。

157

第三章 分布式共识

**最终强故障检测器 - 钻石 S**

这类 FDs 满足强完备性和最终弱准确性。

还有四类故障检测器提供弱完备性。

检测器 Q 和弱检测器 W 在同步模型下工作。另外两个检测器，

最终检测器 Q（钻石 Q）和最终弱检测器（钻石 W）工作

在部分同步假设下。

我们现在描述如下。

**弱故障检测器 W**

此类型满足弱完备性和弱准确性属性。

**最终弱故障检测器（钻石 W）**

此类型满足弱完备性和最终弱准确性属性。

**检测器 Q 或 V**

此类型满足弱完备性和强准确性。

**最终检测器 Q（钻石 Q）或钻石 V**

此类型满足弱完备性和最终强准确性。

图 3-17 显示了这一切的摘要。

158

![](img/index-178_1.png)

第三章 分布式一致性

***图 3-17.** 故障检测器类*

故障检测器的属性基本上围绕着如何的想法

快速正确地故障检测器检测到故障，同时避免错误的阳性。完美的故障检测器将始终正确地检测到失败的进程，而弱故障

检测器可能只能准确地检测到很少或几乎没有故障。

**领导者选举故障检测器**

有时，我们不关心进程是否已失败，而只是一个单个进程是否正确。在这种故障检测方法中，不是怀疑其他进程，而是认为一个单个进程是领导者。该故障检测器可以看作是一种称为 Omega *Ω* 故障检测器的领导者选举算法。最初，领导者选举者可能是不可靠的，并可能选举出一个故障进程或导致不同的进程信任不同的领导者。我们可以将此 FD 定义为最终每个

非故障进程选出相同的非故障领导进程。

159

第三章 分布式一致性

正如我们之前看到的，在其他故障检测器中有一个称为 *suspect*

包含一组故障检测器怀疑为故障的进程 ID；

但是，在领导者选举 *Ω* 中，有一个包含选定领导者的单个进程 ID 的 *trust* 组件。

**使用故障检测器解决共识**

如果我们拥有完美的故障检测器，我们可以轻松解决同步和

和异步模型。但在异步系统中，P 不能

由于对该模型的准确性和完整性要求太强，无法实现。

如果我们能够在异步系统中实现 P 来解决共识问题

这将违反 FLP 不可能性。因此，我们知道不存在这样的完美 FD

可以解决纯异步系统中的共识。我们必须牺牲一点

比特异步，并寻找可以解决共识问题的更弱的故障检测器类。

在异步情况下。

此时也会产生一个问题：什么是最弱的故障检测器可以解决

一致性？*W*（最终弱）是最弱的故障检测器，足以在异步情况下以大多数正确进程解决共识问题。

**仲裁**

仲裁可以被定义为大多数进程的任何集合。该概念与

对一组对象进行投票。仲裁系统对确保

一致性、可用性、效率和容错性在复制系统中。

一个决议也可以被视为一组最小数量的进程（投票）

在分布式系统中决定一个操作需要一个基于“决议”的少数正确进程。

方法确保在分布式系统中的一致性。我们刚学到在

在“复制”部分中，复制允许构建容错一致性

分布式系统。在这里，我们关心的问题是需要多少复本

最终决定提交更新或中止。

数学上，决议规定了以下定义：

一个决议是 *π* = {1, 2, 3，. . . *n* } 的非空子集。

160

第三章 分布式共识

决议系统被定义为一组 *Q* 的非空子集合 *π*，其满足以下属性：

**决议交集**：∀ *A*，*B* ∈ *Q*：*A* ∩ *B* ≠ *ϕ*

这意味着任意两个决议必须在一个或多个进程处相交。这

也被称为抽屉原理。此外，这也被称为**一致性**

属性。

必须始终有至少一个未失败的决议可用。这是

**决议可用性** 属性。

决议系统通常用于进程，在广播之后

等待它收到来自所有属于一个

决议。通过这种方式，我们可以解决一个问题的一致性要求。决议

通常用于实现崩溃和拜占庭容错。在共识算法中，例如，需要一定大小的决议来保证安全性和活跃性。在

在其他话语中，基于决议的算法仅在拥有决议的情况下才能满足安全性和活跃性，只有如果一个决议是

可以确保有足够的正确进程。

**崩溃容错决议**

为了在 N 个 crash-stop 进程中实现崩溃容错，设置了决议 Q

 *n* 

至少

1

 2  + 进程。 

例如，如果 n = 7，则 7

1

 2 + = ⌊3.5⌋ + 1 = 3 + 1 = 4

这意味着在一个有七个节点的网络中，至少要有四个节点（四个决议

节点）必须非故障且可用以实现崩溃容错。

例如，如果你有 n 个复本，其中 f 可能是 crash-stop，哪个决议 Q

需要多大的尺寸才能实现活跃性？

为了活跃性，必须有一个非故障的决议 Q 可用，其中 Q <= n – f。

为了安全起见，必须有任意两个决议至少相交于一个或多个

进程。

Lamport 在 1978 年使用了分布式系统的“阿米巴”名义下的决议。

161

第三章 分布式共识

**拜占庭决议**

拜占庭失败难以处理。想象一下如果有 N 个节点，其中

f 个节点变为拜占庭。现在这些 f 个节点可以任意行事，而且

可能会出现他们可以赞成一个值并反对它。他们能够制造

有目的地向不同的节点传递不同的状态。这种情况可能导致

正确节点的发散状态并且也可能导致死锁。

可以容忍 f 个错误的拜占庭决议有超过（ *n* + *f*）/2 进程。

两个拜占庭人数中总是至少有一个正确进程的交集

故障-容忍法定人数。如果 *N* > 3 *f*，那么在拜占庭设置中保证进度。换句话说，拜占庭容错需要 *f* < *n*/3。

例如:

*n* = 7，*f* =1

( *n* + *f* )

/ 2

( + ) / =

7 1 2 4

*上限* ( + + / ) =

7 1 1 2

4

每个拜占庭法定人数包含大于 *n* − *f*/2 个诚实流程。 7 − 1/2 = > 3，所以至少有一个正确的流程在两个拜占庭法定人数的交集中。

**读和写法定人数**

基于法定人数的协议基本上依赖于投票来确定读取或

写操作可以执行或不能执行。有读法定人数和写法定人数。A

读法定人数是在读操作上达成一致所需的最小副本数量

读操作。类似地，写法定人数是需要的最小副本数量

实现对写操作的协议。

**我们现在在哪里**

基于超过 40 年的研究，关于经典分布式共识和

现代区块链时代的协议，我们可以把共识分为两大家族。

162

第三章 分布式共识

**经典共识**

经典共识或传统的分布式共识一直是研究的课题

现在已经超过 40 年的时间。从 SIFT 项目和 Lamport 的以及许多其他

研究人员的贡献，现在我们有了一大堆应对经典分布式共识的作品。像 Paxos、PBFT 和 RAFT 这样的协议现在成为了一种规范。

在各种实际系统中的实施。

**中本聪和后中本聪共识**

另一方面，我们有一类协议，我们可以称之为中本聪

共识家族，因为这个家族是由中本聪首次引入的，

与比特币。

从区块链的角度来看，传统的和中本聪风格的协议都是

使用。几乎所有的有许可的区块链都使用 PBFT 经典算法的变种。

另一方面，像以太坊和比特币这样的无许可公共区块链使

采用中本聪风格（PoW）共识算法。还有其他类别，如

证明权益证明和其他变种，但它们都是在 2008 年比特币工作量证明引入之后引入的。

我们将在第[4](https://doi.org/10.1007/978-1-4842-8179-6_4)章中详细介绍中本聪和后中本聪风格的算法。

**总结**

在这一章中，我们介绍了协议，广播，复制和

共识：

• 共识是分布式计算中的基本问题。

• 共识和原子广播是等价的问题。如果你

解决一个就解决了另一个。

• 有几种广播原语，如尽力广播，

可靠广播，热切的可靠广播和完全顺序广播

对于提供保证的交货具有不同程度的严格性。

• 还有概率广播协议，它传递消息

以一定的概率受到受欢迎的启发，来自传播八卦

在公共之间。

163

第三章 分布式共识

• 复制和状态机复制是提供的技术

分布式系统中的容错性。

• 团体系统对于确保一致性很重要，

复制系统中的可用性、效率和容错性。

• 过去半个世纪的研究产生了两种主要类别的

共识，即，经典的许可共识和中本聪

非许可共识。

• 在最近的许多不可能结果中已经被证明了

研究人员数十年的研究。诸如 FLP 不可能性等结果，

最少数量的进程和网络链接

已被提出和证明。这些基础性结果允许

研究人员可以专注于其他问题，因为如果某事有

已被证明不可能，花时间和精力是没有价值的

继续努力解决它。

• 其他研究包括提供手段的故障检测器

检测分布式系统中的故障，并允许进程做出响应

从而取得进展。增强分布式系统

使用诸如故障检测器、同步假设等

随机协议和混合协议是规避的手段

FLP 不可能性结果。

在下一章中，我们将介绍区块链，并描述其是什么以及我们如何

看到它是在我们迄今在这本书中学到的知识中。

**参考文献**

1\. Chandra, T.D.和 Toueg, S., 1996. 用于不可靠故障检测器的

可靠的分布式系统。ACM 杂志(JACM)，43(2)，

页码 225-267\.

2\. 事件排序首次引入于“实现

可靠的分布式多处理系统” - Lamport, L., 1978\.

可靠的分布式多处理系统的实现。

*计算机网络(1976)*, *2*(2)，页码 95-114\.

164

第三章 分布式共识

3\. Pease, M., Shostak, R.和 Lamport, L., 1980. 达成协议

在存在故障的情况下。ACM 杂志(JACM)，27(2)，

页码 228-234\.

4\. Kshemkalyani, A.D.和 Singhal, M., 2011. 分布式计算：

原则、算法和系统。剑桥大学出版社。

5\. 解决共识所需的最弱故障检测器是什么？这

问题在 Chandra, T.D., Hadzilacos, V.中得到了回答，

和 Toueg, S., 1996. 解决的最弱故障检测器

共识。ACM 杂志(JACM)，43(4)，页码 685-722\.

6\. Wormhole 是由 Neves, N.F., Correia, M.和引入的

Verissimo, P., 2005. 使用虫洞解决矢量共识。

IEEE 并行与分布式系统交易，16(12)，

页码 1120-1131\.

7\. 一个优秀的调查是 Correia, M., Veronese, G.S., Neves, N.F.,

和 Verissimo, P., 2011. 非同步的拜占庭共识

传递消息系统：一项调查。国际杂志

临界计算机系统，2(2)，页码 141-161\.

165

**第四章**

**区块链**

在本章中，我们将学习什么是区块链及其各个元素，并了解

通过分布式计算的视角来解释区块链。此外，我们将提出正式的

区块链的定义和属性。此外，我们还将介绍比特币和以太坊。最后，我将介绍一些区块链的使用案例。

区块链之所以令人着迷，是因为它涉及许多学科，包括

分布式计算、网络、密码学、经济学、博弈论等。

编程语言和计算机科学。

区块链对许多不同领域的人都很有吸引力，包括但不限于

仅限于前面提到的主题。几乎每个领域都有使用案例，

区块链已经吸引了公众的想象力，事实上，许多学者和

行业专业人士。

区块链于 2008 年随着比特币的出现而兴起，这是一个点对点的去中心化的

电子现金方案，不需要任何可信任的第三方提供信任

与货币相关的担保。

**什么是区块链**

互联网上有很多关于区块链的定义，还有许多不同的书籍。

尽管所有这些定义都是正确的，有些是很不错的，但我会试图用自己的话来定义区块链。

首先，我们将从外行的角度定义它，然后从纯技术的角度

立场。

**外行的定义**

区块链是一个共享的记录保留系统，每个参与者都保留一份副本

按时间顺序记录。只有参与者

集体同意这样做时才能添加新的记录。

167

© Imran Bashir 2022

I. Bashir，*区块链共识*，[`doi.org/10.1007/978-1-4842-8179-6_4`](https://doi.org/10.1007/978-1-4842-8179-6_4#DOI)

第四章 区块链

**技术定义**

区块链是一个点对点的、密码学安全的、只追加的、不可变的

防篡改、共享的分布式分类账，由按时间顺序排列和公开

可验证的交易。用户只能在

通过网络上的对等方达成共识来管理区块链。

**背景**

区块链的起源可以追溯到早期为数字

文档的时间戳。此外，长期存在的问题是创建安全的

具有匿名性和追责制的电子现金已经

激发了区块链的发展。

一些为区块链发展做出贡献的关键想法是

如下所描述。

要创建实用的数字现金，需要解决两个根本性问题：

• 追责制以防止双重支付

• 匿名性以保护用户的隐私

问题是如何解决追责和双重支付问题。这些方案

以下所描述的试图解决这些问题，并设法实现这些

属性；然而，可用性很难，而且他们依赖于可信任的第三方。

**数字现金创建尝试**

在过去有几次尝试创建数字现金。例如，大卫·乔姆

发明了盲签名并使用秘密共享机制来创建数字现金。

盲签名使签名不会透露正在签名的内容，这提供了

匿名性和秘密共享允许检测双重支付。

B-money 是另一种电子现金方案，由魏戴于 1998 年发明。

这个原始的想法提及了许多被认为是直接先驱的想法。

比特币。这是一个新颖的想法；然而，它需要可信的服务器。它也引入

在无法追踪的匿名实体之间合作可以考虑的可能解决方案

一种交换媒介和执行合同的方法。每个服务器的想法

存入特殊帐户的一定数量并将其用于惩罚和

168

![](img/index-187_1.png)

第四章区块链

奖励与今天我们所知的股权证明概念非常接近。同样，通过解决以前未解决的计算问题的想法就是我们今天所知的

工作证明。

另一个电子现金提议是**BitGold**，由尼克·萨博提出。比特金

可视为比特币的直接前身。Bitgold 提议强调没有

依赖于可信第三方和通过解决“挑战字符串”来进行工作证明。

另一方面，密码学和计算机的进步和发展

技术通常导致了几项进步和创新应用。其中一些

区块链相关的这些进步是数字文档的时间戳、电子邮件

垃圾邮件保护和可重复使用的工作证明。

时间戳数字文档以创建有序链的工作技术

通过时间戳服务对文档（哈希）进行了首次提议，由哈伯提出

Stornetta。这个想法与区块链中的块链有密切关系。然而，时间戳服务是集中的，需要受信任。

源于比特币中使用的基于哈希函数的工作证明的起源可以在此找到

在 Dwork 和 Naor 之前的工作中，使用工作证明阻止电子邮件垃圾邮件。亚当

后发明了用于电子邮件垃圾邮件控制的 Hashcash 工作证明方案。此外，

Hal Finney 推出了可重复使用的令牌货币的工作证明，使用 Hashcash

铸造新的 PoW 代币。

为比特币的发展做出贡献的另一项技术是密码学。

密码原语和工具，例如哈希函数、默克尔树和公共

密钥密码学在比特币的发展中发挥了至关重要的作用。我们涵盖了

在[第二章中详述密码学。](https://doi.org/10.1007/978-1-4842-8179-6_2)

图 4-1 说明了不同技术的融合。

***图 4-1：** 导致比特币的技术*

169

第四章区块链

**第一个区块链？**

比特币被推出时，区块链被引入为基本操作层

用于比特币加密货币。至今仍在运作，这是第一个公共区块链。

很快，创新开始，许多不同的区块链出现—一些是为了

具体用途，一些用于加密货币，还有一些用于企业用例。在下一节中，我们将看到不同类型的区块链。

**区块链的益处**

预见到区块链技术的多种益处，并且已经进行了

自比特币发明以来，已经完成了许多成就。特别是随着以太坊的出现，

一个可编程平台可用于实施任何逻辑的智能合同，

这导致了提高的效用，并为进一步采纳铺平了道路。今天，一个

最受关注的区块链应用之一，去中心化金融，或 DeFi

简称，被视为当前金融系统的重大颠覆者。非同质化代币（NFT）是另一个获得了爆炸性流行的应用。NFTs 上

区块链使资产代币化成为可能。目前，DeFi 生态系统的价值已经锁定了近 600 亿美元。这巨大的投资证明了

区块链现在已经成为我们经济的一部分。您可以在[https://](https://defipulse.com/)

[defipulse.com/.](https://defipulse.com/)

现在我列出区块链的一些最显着的优势：

• 成本节约

• 由于流程简化、透明度和单一数据

共享平台，具有安全保证，这

区块链可以造成成本节约。此外，也没有必要

创建单独的安全基础设施；用户可以使用已经

现有的安全区块链网络带有入门级计算机

运行区块链软件客户端。

• 透明度

• 由于所有交易都是公开的，任何人都可以验证

交易，区块链引入了透明度。

170

第四章 区块链

• 可审计性

• 由于记录的不可变历史，区块链提供了

审计目的的自然平台。

• 速度和效率

• 由于参与交易的所有各方都是同一方的一部分

网络，多方之间的交易处理速度

各方增加。不过，请注意，每笔交易

在公共区块链上的交易速度相当低，例如，三到

在比特币中是七次；但是，在联合企业区块链中，它要多得多

更好，并且与各方直接交互，它

提高了交易的总体效率。

• 安全

• 区块链基于确保的加密协议

区块链的完整性和真实性，从而提供了

安全的交易平台。

不同行业有许多用例：

• 供应链

• 政府

• 医药/健康

• 金融

• 物联网-物联网

• 交易

• 身份

• 保险

接下来，我们将讨论不同类型的区块链。

171

第四章 区块链

**区块链的类型**

有几种类型的区块链。最初随比特币引入的原始区块链

是公共区块链：

• 公共或无许可区块链

• 有权限的区块链

• 私有区块链

• 联合或企业区块链

• 特定应用区块链

• 异构多链

一个**公共区块链**，顾名思义，是一种**无许可区块链**。参与网络没有限制。唯一需要的是下载

一个软件客户端并运行它以成为网络的一部分。通常，这些类型

区块链用于加密货币，比如比特币和以太坊

有两种**许可区块链**。**私有区块链**只由一个组织控制，通常在组织内部运行。而

另一方面，**财团区块链**或**企业区块链**是多个组织参与区块链治理的许可区块链

企业通常为特定企业用例使用财团链

我们还可以进一步对利益相关者可能已经为之开发的链进行分类

单一用途。我们可以称其为**特定应用区块链**。例如，一种专门用于单一加密货币的区块链。在某种程度上，比特币就是

特定应用区块链，只有一个应用，比特币加密货币

同样，假设一个组织为特定目的运行了一个私有区块链

例如审计功能。在这种情况下，它也可以被归类为特定应用区块链，因为它只用于单一特定目的

然而，在实践中，区块链作为一个通用平台，保证

一致、安全、防篡改且有序的记录账本，使其适用于各种各样的应用。此外，根据设计，多个应用程序可以

在单个区块链上运行。例如，以太坊可以运行称为

在其上运行智能合约，使其成为一种通用区块链平台。区块链

已为特定单一用例开发的区块链可称为特定应用区块链，或简称 ASBC。

172

第四章 区块链

区块链也是多个组织可以共享数据的平台

以防数据的完整性。然而，这种共享可以

只有有一个标准的区块链，但有很多不同的区块链

自以太坊出现以来，不断出现了新类型的区块链。这种多样性导致了一个问题

其中一个区块链运行不同协议，无法与另一个区块链共享其数据

区块链。这种脱节造成了每个区块链都是一个孤立的情况。为了

解决这个问题，想要加入财团网络的组织必须要么

使用专门针对该区块链的软件客户端或者想出一个复杂的

互操作性机制。这个问题已经得到了很好的理解，并且已经做了很多工作

新的互操作性协议正在进行中。此外，还出现了新类型的区块链

如**异构多链**和基于分片的方法，也在不断出现

一个主要例子是波卡，一个复制的分片状态机，其中异构的

链之间可以通过所谓的中继链进行通信。另一个努力是以太坊 2.0，其中分片链作为提供可扩展性和跨片

互操作性。Cardano 是另一个正在提供可扩展性的区块链

不同区块链之间的互操作性。有了所有这些平台和工作进度

在实现这些想法的过程中，我们可以设想在接下来的八到十年内，

这些区块链和其他区块链将像今天的互联网一样运行

不同链之间无缝数据共享。促成这种级别的自然互操作性的链，催生了多个互操作的通用企业链和 ASBCs 的生态系统，被称为**异构多链**。

现在让我们澄清一个模糊之处。你可能听过“分布式分类帐”这个术语

有时用于表示区块链。虽然两个术语，区块链和

分布式分类帐可以互换使用，但存在差异。分布式分类帐是一个概括性术语，描述具有分布式特性的分类帐。区块链属于

在这个类别下。区块链是一个分布式分类帐，但并非所有分布式分类帐都是区块链。例如，一些分布式分类帐不使用由块组成

在它们的区块链构建中的交易。相反，他们单独处理交易记录并以此方式存储。然而，通常在大多数分布式分类帐中，

块被用作承载一批交易和其他几个元素的容器，例如区块头，其中也包含几个组件。这样使用块来捆绑

这些交易使它们成为区块链。

173

第四章 区块链

**区块链是一个分布式系统**

区块链是一个分布式系统。因此，它应该在分布式计算的光环中进行定义和推理。此外，这种正式描述可以更好地推理。

我们在第[1](https://doi.org/10.1007/978-1-4842-8179-6_1)章讨论了 CAP 定理。因此，我们可以通过 CAP 定理分析区块链，以确定它是什么类型的系统。

**CAP 和无许可区块链**

无许可区块链是 AP（可用性和分区容忍）区块链

因为一致性在一定程度上为可用性而牺牲。我们可以争辩说

最终一致性得以实现，但一致性（协议）为了可用性而牺牲

可用性，我们可以说无许可或公共区块链是 AP 系统。

例如，以太坊和比特币都是 AP 系统。这是由于共识证明

工作（PoW）类型的概率共识。

**CAP 和许可区块链**

许可区块链是 CP（一致性和分区容忍）系统，因为

可用性被用来牺牲一致性。这是因为几乎所有

许可区块链使用传统的 BFT 协议，如果一定数量的节点达到阈值

是有问题的，那么整个系统就会停滞，直到故障得到解决，然后系统才会继续运行。例如，在一个五节点网络中，如果有三个节点宕机，那么

除非其他节点恢复在线，否则系统不会进展。同样，在

在将节点划分为两个和三个子集的情况下，系统不会产生

进展，除非分区得到修复。这是由于传统 BFT 的使用

算法，例如 PBFT。来自客户端的请求只有在

如果有大多数诚实的节点。换句话说，如果在拜占庭容错的情况下，系统降到低于 3f+1 以下，系统立即退化为非功能性。

我们可以在图 4-2 中将这两个概念可视化。

174

![](img/index-193_1.png)

第四章 区块链

***图 4-2\.** CAP 定理与区块链*

接下来，我们描述区块链分类账抽象，这是区块链的一个抽象视图

区块链。

**区块链分类账抽象**

区块链抽象，有时被称为分类账抽象，可以用下列方式来定义

帮助它执行的操作以及几个属性。

总的来说，区块链网络中的进程可以执行三种操作

执行：

Get(), append(), verify()

调用 get()时，它返回当前规范状态的一个副本

区块链（分类账）。

当调用 append()时，它创建并附加一个新的记录*r*到区块链。

调用 verify()时，它验证并返回记录*r*或区块链*b*的有效状态。

175

第四章 区块链

**属性**

与区块链相关的有几个属性，这些属性被描述为

如下所示。

**一致性**

• 所有副本都持有相同的最新数据副本。在

公共区块链，通常是最终一致性，在

在许可制区块链中，它是强一致性。

• 形式上，如果记录*r*在另一个进程*p*之前首先被看到

记录*r2*，然后每个诚实的进程在*r2*之前看到了*r*。

**容错**

• 区块链是容错的分布式系统。区块链

网络可以经受拜占庭或崩溃故障，直到达到一个阈值。

• 在 BFT-based 区块链中（通常是通过 PBFT 变体实现

在区块链中) ，下限为 3F + 1，其中 F 是数字

的故障。

• 在基于 CFT 的区块链中（通常使用 RAFT 实现
