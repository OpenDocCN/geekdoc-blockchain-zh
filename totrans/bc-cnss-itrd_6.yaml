- en: message complexity, whereas HotStuff organizes nodes in a star topology. This
    setting
  prefs: []
  type: TYPE_NORMAL
- en: enables the leader to send or collect messages directly to or from all other
    nodes,
  prefs: []
  type: TYPE_NORMAL
- en: which results in reduced message complexity. In simpler words, it uses a “one-to-all”
  prefs: []
  type: TYPE_NORMAL
- en: communication pattern.
  prefs: []
  type: TYPE_NORMAL
- en: If a leader is responsible for all this processing, the problem of high load
    on a single
  prefs: []
  type: TYPE_NORMAL
- en: leader can arise, which can slow down the network.
  prefs: []
  type: TYPE_NORMAL
- en: Now think of a scenario where the leader gets corrupted or compromised. The
  prefs: []
  type: TYPE_NORMAL
- en: standard BFT tolerance guarantees address such situations. If a leader proposes
    a
  prefs: []
  type: TYPE_NORMAL
- en: malicious block and is suspected faulty, it will be rejected by other correct
    nodes, and the protocol will choose a new leader. This scenario can temporarily
    slow down the network
  prefs: []
  type: TYPE_NORMAL
- en: until a new honest leader takes over. If majority of the network is honest,
    a correct leader will eventually take over and propose a valid block. Also, for
    added security, the leader usually is frequently rotated between validators every
    few rounds, which can offset any
  prefs: []
  type: TYPE_NORMAL
- en: malicious attacks targeting the leader. This property ensures fairness, which
    helps to
  prefs: []
  type: TYPE_NORMAL
- en: achieve chain quality.
  prefs: []
  type: TYPE_NORMAL
- en: PBFT consists of a normal and view change mode, where a view change triggers
  prefs: []
  type: TYPE_NORMAL
- en: when a leader is suspected faulty. This approach provides a liveness guarantee
    but
  prefs: []
  type: TYPE_NORMAL
- en: increases communication complexity. HotStuff handles this by combining the view
  prefs: []
  type: TYPE_NORMAL
- en: change process with the normal mode. In PBFT, nodes wait for 2F+1 messages before
    the
  prefs: []
  type: TYPE_NORMAL
- en: '355'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 8 BloCkChain age protoCols
  prefs: []
  type: TYPE_NORMAL
- en: view change occurs, but in HotStuff, the view change can occur directly without
    invoking
  prefs: []
  type: TYPE_NORMAL
- en: a separate subprotocol. Instead, checking the threshold of the messages to change
    the
  prefs: []
  type: TYPE_NORMAL
- en: view becomes part of the normal view.
  prefs: []
  type: TYPE_NORMAL
- en: '**How It Works**'
  prefs: []
  type: TYPE_NORMAL
- en: 'HotStuff is composed of four phases: prepare, pre-commit, commit, and decide
    phases.'
  prefs: []
  type: TYPE_NORMAL
- en: A quorum certificate (QC) is a data structure that represents a collection of
  prefs: []
  type: TYPE_NORMAL
- en: signatures produced by *n* – *f* nodes to indicate that a required threshold
    of messages has been achieved. In other words, a collection of votes from *n*
    − *f* nodes is a QC.
  prefs: []
  type: TYPE_NORMAL
- en: '**Prepare**'
  prefs: []
  type: TYPE_NORMAL
- en: Once a new leader has accumulated new view messages from N – F nodes, the protocol
  prefs: []
  type: TYPE_NORMAL
- en: starts with a new leader. The leader processes these messages to determine the
    latest
  prefs: []
  type: TYPE_NORMAL
- en: branch in which the highest quorum certificate of PREPARE messages is present.
  prefs: []
  type: TYPE_NORMAL
- en: '**Pre-commit**'
  prefs: []
  type: TYPE_NORMAL
- en: As soon as a leader accumulates N – F prepare votes, it creates a quorum certificate
  prefs: []
  type: TYPE_NORMAL
- en: called “prepare quorum certificate.” The leader broadcasts this certificate
    to other
  prefs: []
  type: TYPE_NORMAL
- en: nodes as a PRE-COMMIT message. When a node receives the PRE-COMMIT message,
  prefs: []
  type: TYPE_NORMAL
- en: it responds with a pre-commit vote. The quorum certificate indicates that the
    required
  prefs: []
  type: TYPE_NORMAL
- en: threshold of nodes has confirmed the request.
  prefs: []
  type: TYPE_NORMAL
- en: '**Commit**'
  prefs: []
  type: TYPE_NORMAL
- en: When the leader has accumulated N – F pre-commit votes, it creates a PRE-COMMIT
  prefs: []
  type: TYPE_NORMAL
- en: quorum certificate and broadcasts it to other nodes as the COMMIT message. When
  prefs: []
  type: TYPE_NORMAL
- en: nodes receive this COMMIT message, they respond with their commit vote. At this
    stage,
  prefs: []
  type: TYPE_NORMAL
- en: nodes lock the PRE-COMMIT quorum certificate to ensure the safety of the algorithm
  prefs: []
  type: TYPE_NORMAL
- en: even if a view change occurs.
  prefs: []
  type: TYPE_NORMAL
- en: '**Decide**'
  prefs: []
  type: TYPE_NORMAL
- en: When the leader receives N – F commit votes, it creates a COMMIT quorum certificate.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the leader broadcasts this COMMIT quorum certificate to other nodes in
    the
  prefs: []
  type: TYPE_NORMAL
- en: DECIDE message. When nodes receive this DECIDE message, they execute the request
  prefs: []
  type: TYPE_NORMAL
- en: '356'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-371_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 8 BloCkChain age protoCols
  prefs: []
  type: TYPE_NORMAL
- en: because this message contains an already committed certificate/value. The new
    view
  prefs: []
  type: TYPE_NORMAL
- en: starts once the state transition occurs due to the DECIDE message acceptance
    and
  prefs: []
  type: TYPE_NORMAL
- en: execution.
  prefs: []
  type: TYPE_NORMAL
- en: We can visualize this protocol in Figure [8-5](#p371).
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 8-5\.** HotStuff protocol*'
  prefs: []
  type: TYPE_NORMAL
- en: 'More precisely, HotStuff steps are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: • A new primary acquires new view messages from n-f nodes with
  prefs: []
  type: TYPE_NORMAL
- en: the highest prepare quorum certificate that each validator receives.
  prefs: []
  type: TYPE_NORMAL
- en: The primary looks at these messages and finds the prepare QC with
  prefs: []
  type: TYPE_NORMAL
- en: the highest view (round number). The leader then broadcasts the
  prefs: []
  type: TYPE_NORMAL
- en: proposal in a prepare message.
  prefs: []
  type: TYPE_NORMAL
- en: • When other nodes receive this prepare message from the leader, they
  prefs: []
  type: TYPE_NORMAL
- en: check if the prepare proposal extends the highest prepare QC branch
  prefs: []
  type: TYPE_NORMAL
- en: and has the higher view number associated than what they have
  prefs: []
  type: TYPE_NORMAL
- en: currently locked.
  prefs: []
  type: TYPE_NORMAL
- en: '357'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 8 BloCkChain age protoCols
  prefs: []
  type: TYPE_NORMAL
- en: • Other nodes reply to the leader with an acknowledgment.
  prefs: []
  type: TYPE_NORMAL
- en: • The leader collects the acknowledgments from *n* − *f* prepare votes.
  prefs: []
  type: TYPE_NORMAL
- en: • When n-f votes are acquired by the leader, it combines them into a
  prefs: []
  type: TYPE_NORMAL
- en: prepare QC and broadcasts this QC in a pre-commit message.
  prefs: []
  type: TYPE_NORMAL
- en: • Other replicas reply to the leader with a pre-commit vote. When
  prefs: []
  type: TYPE_NORMAL
- en: the leader has received n-f pre-commit votes from other nodes, the
  prefs: []
  type: TYPE_NORMAL
- en: primary combines them into a pre-commit QC and broadcasts them
  prefs: []
  type: TYPE_NORMAL
- en: in a commit message.
  prefs: []
  type: TYPE_NORMAL
- en: • Replicas reply to the leader with commit votes and replicas lock on
  prefs: []
  type: TYPE_NORMAL
- en: the pre-commit QC. When the leader receives n-f commit votes from
  prefs: []
  type: TYPE_NORMAL
- en: the replicas, it combines them into a commit QC and broadcasts the
  prefs: []
  type: TYPE_NORMAL
- en: decide message.
  prefs: []
  type: TYPE_NORMAL
- en: • When the nodes receive a decide message, they execute the
  prefs: []
  type: TYPE_NORMAL
- en: operations/commands and start the next view.
  prefs: []
  type: TYPE_NORMAL
- en: • This operation repeats.
  prefs: []
  type: TYPE_NORMAL
- en: There are other optimizations such as pipelining which allows for further
  prefs: []
  type: TYPE_NORMAL
- en: performance improvements. As all the phases are fundamentally identical, it’s
    easy
  prefs: []
  type: TYPE_NORMAL
- en: to pipeline HotStuff, which improves performance. Pipelining allows the protocol
    to
  prefs: []
  type: TYPE_NORMAL
- en: commit a client’s request in each phase. In a view, a leader in each phase proposes
    a new client request. This way, a leader can concurrently process pre-commit,
    commit, and
  prefs: []
  type: TYPE_NORMAL
- en: decide messages for previous client requests passed on to the last leader via
    the commit
  prefs: []
  type: TYPE_NORMAL
- en: certificate.
  prefs: []
  type: TYPE_NORMAL
- en: '**Safety and Liveness**'
  prefs: []
  type: TYPE_NORMAL
- en: HotStuff guarantees liveness by using the pacemaker, which ensures progress
    after
  prefs: []
  type: TYPE_NORMAL
- en: GST within a bounded time interval by advancing views. This component encapsulates
  prefs: []
  type: TYPE_NORMAL
- en: view synchronization logic to ensure liveness. It keeps enough honest nodes
    in the
  prefs: []
  type: TYPE_NORMAL
- en: same view for sufficiently long periods to ensure progress. This property is
    achieved by
  prefs: []
  type: TYPE_NORMAL
- en: progressively increasing the time until progress is made.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever a node times out in a view, it broadcasts a timeout message and advances
  prefs: []
  type: TYPE_NORMAL
- en: to the following when a quorum certificate of 2 *f* + 1 timeout messages is
    received.
  prefs: []
  type: TYPE_NORMAL
- en: This certificate is also sent to the next leader, who takes the protocol further.
    Does this 358
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 8 BloCkChain age protoCols
  prefs: []
  type: TYPE_NORMAL
- en: timeout detection sound familiar? It sounds familiar because pacemaker abstraction
    is
  prefs: []
  type: TYPE_NORMAL
- en: basically a failure detector that we discussed before in Chapt[er 3](https://doi.org/10.1007/978-1-4842-8179-6_3).
    Moreover, voting and relevant commit rules ensure safety in HotStuff.
  prefs: []
  type: TYPE_NORMAL
- en: HotStuff is a simple yet powerful protocol that combines several innovations
    to
  prefs: []
  type: TYPE_NORMAL
- en: produce a better protocol than its predecessors.
  prefs: []
  type: TYPE_NORMAL
- en: '**Polkadot**'
  prefs: []
  type: TYPE_NORMAL
- en: Polkadot is a modern blockchain protocol that connects a network of purpose-built
  prefs: []
  type: TYPE_NORMAL
- en: blockchains and allows them to operate together. It is a heterogenous multichain
  prefs: []
  type: TYPE_NORMAL
- en: ecosystem with shared consensus and shared state.
  prefs: []
  type: TYPE_NORMAL
- en: Polkadot has a central main chain, called a relay chain. This relay chain manages
  prefs: []
  type: TYPE_NORMAL
- en: the Parachains – the heterogenous shards that are connected to the relay chain.
    A relay
  prefs: []
  type: TYPE_NORMAL
- en: chain holds the states of all Parachains. All these Parachains can communicate
    with each
  prefs: []
  type: TYPE_NORMAL
- en: other and share the security, which leads to a better and more robust ecosystem.
    As the
  prefs: []
  type: TYPE_NORMAL
- en: Parachains are heterogenous, they can serve different purposes; a chain can
    be a specific chain for smart contracts, another for gaming, another could be
    for providing some
  prefs: []
  type: TYPE_NORMAL
- en: public services, and so on and so forth. The relay chain is secured by a nominated
    proof
  prefs: []
  type: TYPE_NORMAL
- en: of stake.
  prefs: []
  type: TYPE_NORMAL
- en: The validators on the relay chain produce blocks and communicate with Parachains
  prefs: []
  type: TYPE_NORMAL
- en: and finalize blocks. On-chain governance decides what the ideal number of validators
  prefs: []
  type: TYPE_NORMAL
- en: should be.
  prefs: []
  type: TYPE_NORMAL
- en: A depiction of the Polkadot chain with Parachains is shown in Figure [8-6](#p374).
  prefs: []
  type: TYPE_NORMAL
- en: '359'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-374_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 8 BloCkChain age protoCols
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 8-6\.** A simple depiction of Polkadot*'
  prefs: []
  type: TYPE_NORMAL
- en: Polkadot aims to be able to communicate with other blockchains as well. For
    its
  prefs: []
  type: TYPE_NORMAL
- en: purposes, bridges are used, which connect Parachains to external blockchains,
    such as
  prefs: []
  type: TYPE_NORMAL
- en: Bitcoin and Ethereum.
  prefs: []
  type: TYPE_NORMAL
- en: There are several components in Polkadot. The **relay chain** is the main chain
  prefs: []
  type: TYPE_NORMAL
- en: responsible for managing Parachains, cross-chain interoperability, and interchain
  prefs: []
  type: TYPE_NORMAL
- en: messaging, consensus, and security.
  prefs: []
  type: TYPE_NORMAL
- en: It consists of nodes and roles. Nodes can be light clients, full nodes, archive
    nodes, or sentry nodes. Light clients consist of only the runtime and state. Full
    nodes are pruned at configurable intervals. Archive nodes keep the entire history
    of blocks, and sentry nodes protect validators and thwart DDoS attacks to provide
    security to the relay chain. There
  prefs: []
  type: TYPE_NORMAL
- en: 'are several roles that nodes can perform: validator, nominator, collator, and
    fisherman.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Validators** are the highest level in charge in the system. They are block
    producers, and to become block producers, they need to provide a sufficient bond
    deposit. They produce'
  prefs: []
  type: TYPE_NORMAL
- en: and finalize blocks and communicate with Parachains. **Nominators** are stakeholders
  prefs: []
  type: TYPE_NORMAL
- en: and contribute to the validators’ security bond. They place trust in a validator
    to “be
  prefs: []
  type: TYPE_NORMAL
- en: good” and produce blocks. **Collators** are responsible for transaction execution.
    They create unsealed but valid blocks to validators that propose. **Fishermen**
    are used to detect malicious behavior. Fishermen are rewarded for providing proof
    of misbehavior
  prefs: []
  type: TYPE_NORMAL
- en: of participants. **Parachains** are heterogenous blockchains connected to the
    relay
  prefs: []
  type: TYPE_NORMAL
- en: '360'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 8 BloCkChain age protoCols
  prefs: []
  type: TYPE_NORMAL
- en: chain. These are fundamentally the execution core of Polkadot. Parachains can
    be with
  prefs: []
  type: TYPE_NORMAL
- en: their own runtime called application-specific blockchains. Another component
    called
  prefs: []
  type: TYPE_NORMAL
- en: '**Parathread** is a blockchain that works within the Polkadot host and connects
    to the relay chain. They can be thought of as pay-as-you-go chains. A Parathread
    can become'
  prefs: []
  type: TYPE_NORMAL
- en: a Parachain via an auction mechanism. **Bridges** are used to connect Parachains
    with
  prefs: []
  type: TYPE_NORMAL
- en: external blockchain networks like Bitcoin and Ethereum.
  prefs: []
  type: TYPE_NORMAL
- en: '**Consensus in Polkadot**'
  prefs: []
  type: TYPE_NORMAL
- en: Consensus in Polkadot is achieved through a combination of various mechanisms.
    For
  prefs: []
  type: TYPE_NORMAL
- en: governance and accounting, a nominated proof of stake is used. For block production,
  prefs: []
  type: TYPE_NORMAL
- en: BABE is used. GRANDPA is the finality gadget. In the network, validators have
    their own
  prefs: []
  type: TYPE_NORMAL
- en: clocks, and a partially synchronous network is assumed.
  prefs: []
  type: TYPE_NORMAL
- en: Finality is usually probabilistic as we saw in traditional Nakamoto PoW consensus.
  prefs: []
  type: TYPE_NORMAL
- en: In most permissioned networks and some public networks, it tends to be deterministic,
  prefs: []
  type: TYPE_NORMAL
- en: that is, provable finality, for example, PBFT and Tendermint.
  prefs: []
  type: TYPE_NORMAL
- en: In Polkadot, due to the reason that it is a multichain heterogenous architecture,
  prefs: []
  type: TYPE_NORMAL
- en: there could be some situations where, due to some conflicts between chains,
    some rogue
  prefs: []
  type: TYPE_NORMAL
- en: blocks are added. These rogue blocks will need to be removed after conflict
    resolution; in such situations, deterministic finality is not suitable due to
    its irreversible property. On the other hand, PoW is too slow, energy consuming,
    and probabilistic. The solution for
  prefs: []
  type: TYPE_NORMAL
- en: this is to keep producing blocks as fast as possible but postpone finality for
    later as soon as it is suitable to finalize. This way, block production can continue
    and is revertible, but finality decision can be made separately and provably at
    a later stage.
  prefs: []
  type: TYPE_NORMAL
- en: This notion of provable finality is quite useful in a multichain heterogenous
    network
  prefs: []
  type: TYPE_NORMAL
- en: because it allows us to prove to other parties that are not involved in consensus
    that a
  prefs: []
  type: TYPE_NORMAL
- en: block is final. Also, provable finality makes it easier to make bridges to other
    blockchains.
  prefs: []
  type: TYPE_NORMAL
- en: This hybrid approach works by allowing validators to produce blocks even if
    only
  prefs: []
  type: TYPE_NORMAL
- en: one validator is online and correct, but the finalization of the blocks is offloaded
    to a separate component called a finality gadget. Under normal conditions, block
    finalization
  prefs: []
  type: TYPE_NORMAL
- en: is also quite fast, but in case of issues such as state conflicts, the finalization
    can be postponed until more scrutiny checks are performed on the blocks. In case
    of severe
  prefs: []
  type: TYPE_NORMAL
- en: attacks or huge network partitions, block production will continue; however,
    as a
  prefs: []
  type: TYPE_NORMAL
- en: fallback mechanism, Polkadot will fall back to the probabilistic finalization
    mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: This way, liveness is guaranteed even under extreme scenarios, as long as at
    least one
  prefs: []
  type: TYPE_NORMAL
- en: '361'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-376_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 8 BloCkChain age protoCols
  prefs: []
  type: TYPE_NORMAL
- en: validator is correct and alive. The blocks are produced by BABE, whereas they
    are
  prefs: []
  type: TYPE_NORMAL
- en: finalized by GRANDPA. GRANDPA finalizes a chain of blocks instead of block-by-block
  prefs: []
  type: TYPE_NORMAL
- en: finalization which improves efficiency. As finalization is a separate process,
    block
  prefs: []
  type: TYPE_NORMAL
- en: production can continue at whatever speed the network allows for, but finality
    doesn’t
  prefs: []
  type: TYPE_NORMAL
- en: impact the block production speed and is done later.
  prefs: []
  type: TYPE_NORMAL
- en: There can be some forks before a “best” chain is finalized by GRANDPA. We can
  prefs: []
  type: TYPE_NORMAL
- en: visualize this in Figure [8-7](#p376).
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 8-7\.** BABE producing and GRANDPA finalizing*'
  prefs: []
  type: TYPE_NORMAL
- en: The diagram shows on the right side three produced blocks by BABE in three forks;
  prefs: []
  type: TYPE_NORMAL
- en: GRANDPA resolves these forks and finalizes the chain. Now let’s see how blocks
    are
  prefs: []
  type: TYPE_NORMAL
- en: produced by BABE.
  prefs: []
  type: TYPE_NORMAL
- en: '**BABE – Blind Assignment for Blockchain Extension**'
  prefs: []
  type: TYPE_NORMAL
- en: BABE is a proof of stake protocol for block production where validators are
    randomly
  prefs: []
  type: TYPE_NORMAL
- en: selected based on their staked amount to produce blocks. It does not depend
    on any
  prefs: []
  type: TYPE_NORMAL
- en: central clock.
  prefs: []
  type: TYPE_NORMAL
- en: Time is divided into periods spanning n seconds called slots, where a block
    is
  prefs: []
  type: TYPE_NORMAL
- en: expected to be produced. An epoch is a sequence of slots. At each slot, validators
    run a
  prefs: []
  type: TYPE_NORMAL
- en: VRF, which, based on randomness generated from previous epochs, decides whether
    to
  prefs: []
  type: TYPE_NORMAL
- en: produce a block or not. We can visualize this in Figur[e 8-8\.](#p377)
  prefs: []
  type: TYPE_NORMAL
- en: '362'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-377_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 8 BloCkChain age protoCols
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 8-8\.** Slots and epochs*'
  prefs: []
  type: TYPE_NORMAL
- en: Validators use public key cryptography. There are two types of key pairs. A
    private
  prefs: []
  type: TYPE_NORMAL
- en: key from the first key pair is used for block signing. The second pair is used
    for a
  prefs: []
  type: TYPE_NORMAL
- en: verifiable random function (VRF), also called the lottery key pair. A private
    key from the latter pair is used as an input to the verifiable random function.
    Block signing provides usual nonrepudiation, integrity, and data origin authentication
    guarantees, verifying that the validator has indeed produced this block. In the
    VRF, the private key generates the
  prefs: []
  type: TYPE_NORMAL
- en: randomness, but the public key proves to other nodes that the randomness generated
    is
  prefs: []
  type: TYPE_NORMAL
- en: indeed reliable and that the validator did not cheat.
  prefs: []
  type: TYPE_NORMAL
- en: Each validator has an almost equal chance of being selected. A slot leader election
  prefs: []
  type: TYPE_NORMAL
- en: is done like PoW, where, if the result of VRF is lower than a predetermined
    threshold,
  prefs: []
  type: TYPE_NORMAL
- en: then the validator wins the right to produce the block. Also, the proof generated
    from the VRF enables other participants to verify that the validator is following
    the rules and not cheating; in other words, it proves that the randomness generated
    is reliable. If the value produced from the VRF is higher than or equal to the
    target, then the validator simply
  prefs: []
  type: TYPE_NORMAL
- en: collects blocks from other validators.
  prefs: []
  type: TYPE_NORMAL
- en: Here are the phases of the BABE protocol.
  prefs: []
  type: TYPE_NORMAL
- en: '**Genesis Phase**'
  prefs: []
  type: TYPE_NORMAL
- en: In this phase, the unique genesis block is created manually. A genesis block
    contains a
  prefs: []
  type: TYPE_NORMAL
- en: random number that is used during the first two epochs for the slot leader selection.
  prefs: []
  type: TYPE_NORMAL
- en: '**Normal Phase**'
  prefs: []
  type: TYPE_NORMAL
- en: Each validator divides its time into so-called slots after receiving the genesis
    block.
  prefs: []
  type: TYPE_NORMAL
- en: Validators determine the current slot number according to the relative time
    algorithm,
  prefs: []
  type: TYPE_NORMAL
- en: which we’ll explain shortly. Each validator during normal operation is expected
    to
  prefs: []
  type: TYPE_NORMAL
- en: produce a block, whereas other nonvalidator nodes simply receive the produced
    blocks
  prefs: []
  type: TYPE_NORMAL
- en: and synchronize. It is expected that each validator has a set of chains in the
    current
  prefs: []
  type: TYPE_NORMAL
- en: slot/epoch and has the best chain selected in the previous slot by using the
    best chain
  prefs: []
  type: TYPE_NORMAL
- en: selection mechanism, which we’ll explain shortly.
  prefs: []
  type: TYPE_NORMAL
- en: '363'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 8 BloCkChain age protoCols
  prefs: []
  type: TYPE_NORMAL
- en: The slot leader selection is based on the output of the VRF. If the output of
    the VRF
  prefs: []
  type: TYPE_NORMAL
- en: is below a certain threshold, then the validator becomes the slot leader. If
    not, then it simply collects the blocks from the leader.
  prefs: []
  type: TYPE_NORMAL
- en: The block generated by the leader is added to the best chain selected in the
    current
  prefs: []
  type: TYPE_NORMAL
- en: slot. The produced block must at least contain the slot number, the hash of
    the previous
  prefs: []
  type: TYPE_NORMAL
- en: block, the VRF output, VRF proof, transactions, and the digital signature. Once
    the
  prefs: []
  type: TYPE_NORMAL
- en: chain is updated with the new block, the block is broadcast. When another non-leader
  prefs: []
  type: TYPE_NORMAL
- en: validator receives the block, it checks if the signature is valid. It also verifies
    if a valid leader has produced the block by checking the VRF output using the
    VRF verification
  prefs: []
  type: TYPE_NORMAL
- en: algorithm. It checks that if the output of the VRF is lower than the threshold,
    then
  prefs: []
  type: TYPE_NORMAL
- en: the leader is valid. It further checks if there is a valid chain with the required
    header available in which this received block is expected to be added, and if
    the transactions in the block are valid.
  prefs: []
  type: TYPE_NORMAL
- en: If all is valid, then the validator adds the block to the chain. When the slot
    ends,
  prefs: []
  type: TYPE_NORMAL
- en: the validator finally selects the best chain using the best chain selection
    algorithm,
  prefs: []
  type: TYPE_NORMAL
- en: which eliminates all chains that do not include the finalized block by the finality
    gadget GRANDPA.
  prefs: []
  type: TYPE_NORMAL
- en: '**Epoch Update**'
  prefs: []
  type: TYPE_NORMAL
- en: A new epoch starts every n number of slots. A validator must obtain the new
    epoch
  prefs: []
  type: TYPE_NORMAL
- en: randomness and active validator set for the new epoch before beginning the new
    epoch.
  prefs: []
  type: TYPE_NORMAL
- en: The new validator set for the new epoch is included in the relay chain to enable
    block
  prefs: []
  type: TYPE_NORMAL
- en: production. A new validator must wait for two epochs before the protocol can
    select
  prefs: []
  type: TYPE_NORMAL
- en: it. Adding a validator two epochs later ensures that VRF keys of the new validators
    are
  prefs: []
  type: TYPE_NORMAL
- en: added to the chain before the randomness of the future epoch in which they are
    going
  prefs: []
  type: TYPE_NORMAL
- en: to be active is revealed. A new randomness for the epoch is calculated based
    on the
  prefs: []
  type: TYPE_NORMAL
- en: previous two epochs by concatenating all the VRF outputs of blocks in those
    epochs.
  prefs: []
  type: TYPE_NORMAL
- en: The diagram in Figur[e 8-9 illus](#p379)trates this slot leader election process.
  prefs: []
  type: TYPE_NORMAL
- en: '364'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-379_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 8 BloCkChain age protoCols
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 8-9\.** Slot leader election via VRF and block production in slots
    and epochs* The best chain selection algorithm simply removes all chains that
    do not contain a'
  prefs: []
  type: TYPE_NORMAL
- en: finalized block by GRANDPA. In case GRANDPA does not finalize any block, the
    protocol
  prefs: []
  type: TYPE_NORMAL
- en: falls back to probabilistic finality, and the finalized block is chosen as the
    one which is several blocks (a number) before the last block. This works almost
    like a chain depth
  prefs: []
  type: TYPE_NORMAL
- en: rule in PoW.
  prefs: []
  type: TYPE_NORMAL
- en: Time is managed in BABE using the **relative time algorithm**. It is critical
    for the
  prefs: []
  type: TYPE_NORMAL
- en: security of the BABE that all parties are aware of the current slot number.
    BABE does not use a time source managed by NTP as clearly a central source of
    time cannot be trusted.
  prefs: []
  type: TYPE_NORMAL
- en: Validators realize a notion of logical time by using block arrival times as
    a reference
  prefs: []
  type: TYPE_NORMAL
- en: without relying on an external source of time. When a validator receives the
    genesis
  prefs: []
  type: TYPE_NORMAL
- en: block, it records the arrival time as a reference point of the beginning of
    the first slot. As the beginning time of each slot is expected to be different
    on each node, an assumption
  prefs: []
  type: TYPE_NORMAL
- en: is made that this difference is reasonably limited. Each validator updates its
    clock by
  prefs: []
  type: TYPE_NORMAL
- en: calculating the median of the arrival times of the blocks in the epoch. Although
    the
  prefs: []
  type: TYPE_NORMAL
- en: mechanics are different, the fundamental concept appears to be similar to the
    logical
  prefs: []
  type: TYPE_NORMAL
- en: clocks we discussed in Chapter [1](https://doi.org/10.1007/978-1-4842-8179-6_1).
    Temporary clock adjustment until the next epoch is also possible for validators
    that went offline and joined the network again.
  prefs: []
  type: TYPE_NORMAL
- en: '**Safety and Liveness**'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four security properties that BABE satisfies: chain growth, existential
    chain'
  prefs: []
  type: TYPE_NORMAL
- en: quality, chain density, and common prefix.
  prefs: []
  type: TYPE_NORMAL
- en: '365'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 8 BloCkChain age protoCols
  prefs: []
  type: TYPE_NORMAL
- en: '**Chain Growth**'
  prefs: []
  type: TYPE_NORMAL
- en: This property guarantees a minimum growth between slots. In other words, it’s
    a liveness
  prefs: []
  type: TYPE_NORMAL
- en: property, and chain growth is guaranteed as long as a supermajority of honest
    validators
  prefs: []
  type: TYPE_NORMAL
- en: is available. Malicious validators cannot stop the progress of the best chain.
  prefs: []
  type: TYPE_NORMAL
- en: '**Chain Quality**'
  prefs: []
  type: TYPE_NORMAL
- en: This property ensures that at least one honest block is contributed to any best
    chain
  prefs: []
  type: TYPE_NORMAL
- en: owned by an honest party in every x number of slots. The protocol guarantees
    that
  prefs: []
  type: TYPE_NORMAL
- en: even in the worst case, there will be at least one honest block included in
    the best chain during an epoch. This ensures that the randomness is not biased.
  prefs: []
  type: TYPE_NORMAL
- en: '**Chain Density**'
  prefs: []
  type: TYPE_NORMAL
- en: This property ensures that any sufficiently long portion of blocks in the best
    chain
  prefs: []
  type: TYPE_NORMAL
- en: contains more than half of the blocks produced by honest validators. This property
    is
  prefs: []
  type: TYPE_NORMAL
- en: implied by chain growth and chain quality.
  prefs: []
  type: TYPE_NORMAL
- en: '**Common Prefix**'
  prefs: []
  type: TYPE_NORMAL
- en: This property ensures that any blocks before the last block in the best chain
    of an honest validator cannot be changed and are final. Again, this property is
    satisfied due to the
  prefs: []
  type: TYPE_NORMAL
- en: assumption of super honest majority of honest validators. It is rare for a malicious
  prefs: []
  type: TYPE_NORMAL
- en: validator to be elected in a slot, and only mostly honest validators will be
    elected;
  prefs: []
  type: TYPE_NORMAL
- en: therefore, malicious validators are in such a minority that they cannot create
    another
  prefs: []
  type: TYPE_NORMAL
- en: “best” chain which do not contain a finalized block.
  prefs: []
  type: TYPE_NORMAL
- en: '**GRANDPA – GHOST-Based Recursive Ancestor Deriving**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Prefix Agreement**'
  prefs: []
  type: TYPE_NORMAL
- en: It is a gadget that finalizes the blocks separately after they have been produced
    by
  prefs: []
  type: TYPE_NORMAL
- en: BABE. It is essentially a Byzantine agreement protocol that agrees on a chain
    out of many forks. The difference here is that usually in BFT protocols, a decision
    is made on a single block, whereas GRANDPA decides on a chain of blocks (a fork)
    and decides what the
  prefs: []
  type: TYPE_NORMAL
- en: final chain is. It’s a finalization mechanism that resolves forks.
  prefs: []
  type: TYPE_NORMAL
- en: '366'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 8 BloCkChain age protoCols
  prefs: []
  type: TYPE_NORMAL
- en: GRANDPA assumes a partially synchronous network. It works in rounds with each
  prefs: []
  type: TYPE_NORMAL
- en: round having 3f+1 eligible voters out of which 2f+1 voters are assumed honest.
    In other
  prefs: []
  type: TYPE_NORMAL
- en: words, it requires that two-thirds of the validator set is honest and agrees
    on a prefix
  prefs: []
  type: TYPE_NORMAL
- en: of the canonical chain, which ultimately becomes finalized. In each round, a
    primary
  prefs: []
  type: TYPE_NORMAL
- en: is pseudorandomly elected, which is agreed upon by the participants. Moreover,
    all
  prefs: []
  type: TYPE_NORMAL
- en: participants agree on the voter set. Primary selection can also be based on
    rotation
  prefs: []
  type: TYPE_NORMAL
- en: between voters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The protocol works in two phases: pre-vote and pre-commit. The pre-vote allows'
  prefs: []
  type: TYPE_NORMAL
- en: validators to estimate what can be finalized, that is, validators pre-vote on
    a best chain.
  prefs: []
  type: TYPE_NORMAL
- en: For the pre-commit, validators use the two-thirds GHOST rule to pre-votes collected
    and
  prefs: []
  type: TYPE_NORMAL
- en: pre-commit. Finally, the pre-commits are finalized.
  prefs: []
  type: TYPE_NORMAL
- en: GRANDPA consists of two protocols. The first protocol works under partial
  prefs: []
  type: TYPE_NORMAL
- en: synchrony and tolerates one-third Byzantine faults. The second protocol works
    in a fully
  prefs: []
  type: TYPE_NORMAL
- en: asynchronous environment and can tolerate one-fifth Byzantine faults.
  prefs: []
  type: TYPE_NORMAL
- en: '**GRANDPA Protocol Steps**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In each round, a participant is selected as a leader (primary), and other participants
    are also aware who the primary is:'
  prefs: []
  type: TYPE_NORMAL
- en: • The new round starts.
  prefs: []
  type: TYPE_NORMAL
- en: • The primary broadcasts the highest block that it thinks might be final
  prefs: []
  type: TYPE_NORMAL
- en: from the previous round.
  prefs: []
  type: TYPE_NORMAL
- en: • Validators wait for a certain network delay, then each validator
  prefs: []
  type: TYPE_NORMAL
- en: broadcasts a “pre-vote” message for the highest block that it believes
  prefs: []
  type: TYPE_NORMAL
- en: should be finalized. If validators receive a block from the primary
  prefs: []
  type: TYPE_NORMAL
- en: with the better best chain, then the validators use that best chain. If
  prefs: []
  type: TYPE_NORMAL
- en: the supermajority of the validators is correct, this block is expected to
  prefs: []
  type: TYPE_NORMAL
- en: extend the chain that the primary has broadcast.
  prefs: []
  type: TYPE_NORMAL
- en: • Each validator looking at the pre-votes determines the highest block
  prefs: []
  type: TYPE_NORMAL
- en: that could be finalized. If the pre-votes extend the last finalized chain,
  prefs: []
  type: TYPE_NORMAL
- en: each validator will cast a pre-commit to that chain.
  prefs: []
  type: TYPE_NORMAL
- en: • Each validator waits for sufficient pre-commits to compose a commit
  prefs: []
  type: TYPE_NORMAL
- en: message on the newly finalized chain.
  prefs: []
  type: TYPE_NORMAL
- en: '367'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 8 BloCkChain age protoCols
  prefs: []
  type: TYPE_NORMAL
- en: The protocol penalizes misbehavior by slashing where a percentage of the stake
  prefs: []
  type: TYPE_NORMAL
- en: is deducted for malicious behavior or even just irresponsible behavior, for
    example, a
  prefs: []
  type: TYPE_NORMAL
- en: long-running inactive node. An increase in penalties is proportional to the
    number of
  prefs: []
  type: TYPE_NORMAL
- en: participants.
  prefs: []
  type: TYPE_NORMAL
- en: '**Safety**'
  prefs: []
  type: TYPE_NORMAL
- en: The protocol ensures that all votes are descendants of some block that could
    have been
  prefs: []
  type: TYPE_NORMAL
- en: finalized in the previous round. Nodes estimate the finalization possibility
    of a block based on pre-votes and pre-commits. Before a new round starts, nodes
    ensure by acquiring
  prefs: []
  type: TYPE_NORMAL
- en: enough pre-commits that no block with this round’s estimate can be finalized
    on a
  prefs: []
  type: TYPE_NORMAL
- en: different chain or later on the same chain. In the next round, it also ensures
    that it only prevotes and pre-commits on the blocks that are descended from the
    last round’s estimate.
  prefs: []
  type: TYPE_NORMAL
- en: '**Liveness**'
  prefs: []
  type: TYPE_NORMAL
- en: The protocols select a validator in rotation to become the primary. The primary
    starts
  prefs: []
  type: TYPE_NORMAL
- en: the round by broadcasting their estimate of block finalization from the last
    round.
  prefs: []
  type: TYPE_NORMAL
- en: Validators pre-vote for the best chain, including the primary’s proposed block
    if (1) the block is at least the validator’s estimate and (2) the validator has
    acquired >2/3 pre-votes for the block and its descendants in the last round.
  prefs: []
  type: TYPE_NORMAL
- en: The key insight here is that if the primary’s proposed block has not been finalized,
    it
  prefs: []
  type: TYPE_NORMAL
- en: is finalized to make progress. For example, suppose the proposed block by the
    primary
  prefs: []
  type: TYPE_NORMAL
- en: has not been finalized, and all validators have agreed on the best chain with
    the last
  prefs: []
  type: TYPE_NORMAL
- en: finalized block. In that case, progress is made by finalizing the latest agreed
    final chain.
  prefs: []
  type: TYPE_NORMAL
- en: If GRANDPA cannot conclude, then BABE provides its probabilistic finality as
    a fallback
  prefs: []
  type: TYPE_NORMAL
- en: mechanism, ensuring progress.
  prefs: []
  type: TYPE_NORMAL
- en: GRANDPA and BABE are one of the latest heterogenous multichain protocols. There
  prefs: []
  type: TYPE_NORMAL
- en: are other protocols in this family such as Casper FFG used in the Ethereum consensus
  prefs: []
  type: TYPE_NORMAL
- en: layer (Ethereum 2, beacon chain).
  prefs: []
  type: TYPE_NORMAL
- en: '**Ethereum 2**'
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum 2, also called Serenity or Eth2, is the final version of Ethereum.
    Currently,
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum is based on proof of work and is known as Eth1\. It is now called the
    execution
  prefs: []
  type: TYPE_NORMAL
- en: layer, and the previous terminology of Eth1 and Eth2 is no longer valid. Eth2
    is now
  prefs: []
  type: TYPE_NORMAL
- en: '368'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-383_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 8 BloCkChain age protoCols
  prefs: []
  type: TYPE_NORMAL
- en: called the consensus layer. As per the original plan, the existing PoW chain
    will
  prefs: []
  type: TYPE_NORMAL
- en: eventually be deprecated, and users and apps will migrate to the new PoS chain
    Eth2\.
  prefs: []
  type: TYPE_NORMAL
- en: However, this process is expected to take years, and an alternative better proposal
    is
  prefs: []
  type: TYPE_NORMAL
- en: to continue improving the existing PoW chain and make it a shard of Ethereum
    2\. This
  prefs: []
  type: TYPE_NORMAL
- en: change will ease the transition to proof of stake and allow scaling up using
    rollups
  prefs: []
  type: TYPE_NORMAL
- en: instead of sharded execution. The beacon chain is already available; “the merge”
    phase
  prefs: []
  type: TYPE_NORMAL
- en: where the Ethereum mainnet merges with the beacon chain is expected in 2022\.
    After
  prefs: []
  type: TYPE_NORMAL
- en: the merge, the beacon chain will become executable with proof of stake and EVM
  prefs: []
  type: TYPE_NORMAL
- en: capabilities. Old Ethereum 1 (Eth1) will become the execution layer with execution
  prefs: []
  type: TYPE_NORMAL
- en: clients, for example, “geth” from Eth1\. Ethereum 2 (consensus) clients such
    as prysm and
  prefs: []
  type: TYPE_NORMAL
- en: lighthouse will continue operating on the beacon chain. Eventually, the shard
    chains
  prefs: []
  type: TYPE_NORMAL
- en: that expand Ethereum capacity and support execution are planned for 2023\. Ethereum
  prefs: []
  type: TYPE_NORMAL
- en: 2.0 “consensus” with Ethereum 1 “execution” as shard 0, along with other upgrades
  prefs: []
  type: TYPE_NORMAL
- en: based on their road map, can be visualized in Figure [8-10\.](#p383)
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 8-10\.** Ethereum upgrades, showing the merge and subsequent upgrades*'
  prefs: []
  type: TYPE_NORMAL
- en: In short, Eth1 is now called the execution layer, which handles transactions
    and
  prefs: []
  type: TYPE_NORMAL
- en: executions, whereas Eth2 is now called the consensus layer, which manages proof
  prefs: []
  type: TYPE_NORMAL
- en: of stake consensus. As part of the consensus layer, the “Ethereum 2” proof of
    stake
  prefs: []
  type: TYPE_NORMAL
- en: consensus protocol is proposed, which we discuss next.
  prefs: []
  type: TYPE_NORMAL
- en: '369'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 8 BloCkChain age protoCols
  prefs: []
  type: TYPE_NORMAL
- en: '**Casper**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Casper is a proof of stake protocol which is built to replace the current PoW
    algorithm in Ethereum. There are two protocols in this family:'
  prefs: []
  type: TYPE_NORMAL
- en: • Casper the Friendly Finality Gadget (FFG)
  prefs: []
  type: TYPE_NORMAL
- en: • Casper the Friendly GHOST
  prefs: []
  type: TYPE_NORMAL
- en: Casper FFG is a PoS BFT–style hybrid protocol that adds a PoS overlay to the
    current
  prefs: []
  type: TYPE_NORMAL
- en: PoW, whereas Casper the Friendly GHOST is purely a PoS protocol. Casper FFG
    provides
  prefs: []
  type: TYPE_NORMAL
- en: a transition phase before being replaced with Casper CBC, a pure PoS protocol.
    We’ll
  prefs: []
  type: TYPE_NORMAL
- en: discuss Casper FFG as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '**Casper FFG**'
  prefs: []
  type: TYPE_NORMAL
- en: Casper can be seen as an improved PBFT with proof of stake for public blockchains.
  prefs: []
  type: TYPE_NORMAL
- en: 'Casper the Friendly Finality Gadget introduces some novel features:'
  prefs: []
  type: TYPE_NORMAL
- en: • Accountability
  prefs: []
  type: TYPE_NORMAL
- en: • Dynamic validators
  prefs: []
  type: TYPE_NORMAL
- en: • Defenses
  prefs: []
  type: TYPE_NORMAL
- en: • Modular overlay
  prefs: []
  type: TYPE_NORMAL
- en: Casper FFG is an overlay mechanism on top of a block proposing mechanism. Its
  prefs: []
  type: TYPE_NORMAL
- en: sole purpose is consensus, not block production.
  prefs: []
  type: TYPE_NORMAL
- en: Accountability allows to detect rule violations and identify the validators
    who
  prefs: []
  type: TYPE_NORMAL
- en: violated the rule. This enables the protocol to penalize the violating validator,
    which
  prefs: []
  type: TYPE_NORMAL
- en: serves as a defense against malicious behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Casper FFG also introduces a safe way to change (i.e., add/remove) participants’
  prefs: []
  type: TYPE_NORMAL
- en: validator set.
  prefs: []
  type: TYPE_NORMAL
- en: The protocol also introduces a defense mechanism to protect against network
  prefs: []
  type: TYPE_NORMAL
- en: partitions and long-range attacks. Even if more than one-third of validators
    go offline,
  prefs: []
  type: TYPE_NORMAL
- en: the protocol provides a defense against such scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Casper FFG is an overlay, which makes it easier to add on top of an existing
    PoW
  prefs: []
  type: TYPE_NORMAL
- en: chain. As it is an overlay, it is expected that the underlying chain has its
    own fork choice rule. In the Ethereum beacon chain, it is an overlay on top of
    the fork choice rule called LMD GHOST (Latest Message Driven Greedy Heaviest-Observed
    Sub-Tree).
  prefs: []
  type: TYPE_NORMAL
- en: '370'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-385_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 8 BloCkChain age protoCols
  prefs: []
  type: TYPE_NORMAL
- en: The LMD GHOST fork choice rule is based on GHOST. The LMD GHOST choice rule
  prefs: []
  type: TYPE_NORMAL
- en: selects the correct chain from multiple forks. The honest chain is the one that
    has the
  prefs: []
  type: TYPE_NORMAL
- en: most attestations from the validators and stake (i.e., weight). Forks occur
    due to network partitions, Byzantine behavior, and other faults. We can see LMD
    GHOST in action in
  prefs: []
  type: TYPE_NORMAL
- en: Figur[e 8-11\.](#p385)
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 8-11\.** LMD GHOST fork choice rule*'
  prefs: []
  type: TYPE_NORMAL
- en: In Figur[e 8-11](#p385)
  prefs: []
  type: TYPE_NORMAL
- en: • The number in the block represents the weight by stake in blocks.
  prefs: []
  type: TYPE_NORMAL
- en: • The hexagon represents attestations from validators carrying
  prefs: []
  type: TYPE_NORMAL
- en: weight 1\.
  prefs: []
  type: TYPE_NORMAL
- en: • The canonical chain is the one with shaded blocks (weight +
  prefs: []
  type: TYPE_NORMAL
- en: attestations).
  prefs: []
  type: TYPE_NORMAL
- en: Usually, when proof of work or some other blockchain production mechanism
  prefs: []
  type: TYPE_NORMAL
- en: produces blocks, they are produced one after another, in a sequential and linear
    chain
  prefs: []
  type: TYPE_NORMAL
- en: of blocks, where each parent has exactly one child. But it can happen due to
    network
  prefs: []
  type: TYPE_NORMAL
- en: latency and faulty/Byzantine nodes that the proposal mechanism produces multiple
  prefs: []
  type: TYPE_NORMAL
- en: '371'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-386_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 8 BloCkChain age protoCols
  prefs: []
  type: TYPE_NORMAL
- en: child blocks of a parent block. Casper is responsible for choosing a single
    child from each parent block, thus choosing a single canonical chain from the
    block tree.
  prefs: []
  type: TYPE_NORMAL
- en: Casper however does not deal with the entire block tree due to efficiency concerns;
  prefs: []
  type: TYPE_NORMAL
- en: instead, it considers a subtree of checkpoints forming the checkpoint tree.
  prefs: []
  type: TYPE_NORMAL
- en: New blocks are appended to the block tree structure. A subtree of a tree called
    the
  prefs: []
  type: TYPE_NORMAL
- en: checkpoint tree is where the decision is required. This structure is shown in
    Figure [8-12](#p386).
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 8-12\.** Checkpoint tree showing heights, votes, checkpoints, and*'
  prefs: []
  type: TYPE_NORMAL
- en: '*canonical chain*'
  prefs: []
  type: TYPE_NORMAL
- en: The genesis block is a checkpoint, and every 100th block is a checkpoint. The
  prefs: []
  type: TYPE_NORMAL
- en: distance from one checkpoint to another is called an epoch. In other words,
    validators
  prefs: []
  type: TYPE_NORMAL
- en: finalize checkpoints every 100 blocks. Each validator that joins the network
    deposits
  prefs: []
  type: TYPE_NORMAL
- en: their owned deposit. This deposit is subject to increase and decrease due to
    penalty
  prefs: []
  type: TYPE_NORMAL
- en: and reward mechanism. Validators broadcast votes. A vote weight is proportional
    to a
  prefs: []
  type: TYPE_NORMAL
- en: validator’s stake. A validator can lose the entire deposit if it deviates from
    the protocol, that is, violates any rules. This is to achieve safety.
  prefs: []
  type: TYPE_NORMAL
- en: '372'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 8 BloCkChain age protoCols
  prefs: []
  type: TYPE_NORMAL
- en: 'A vote message has some attributes, which we describe as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '• **s**: Hash of a justified source checkpoint'
  prefs: []
  type: TYPE_NORMAL
- en: '• **t**: Hash of the target checkpoint to be justified'
  prefs: []
  type: TYPE_NORMAL
- en: '• **h(s)**: Height of the source checkpoint'
  prefs: []
  type: TYPE_NORMAL
- en: '• **h(t)**: Height of the target checkpoint'
  prefs: []
  type: TYPE_NORMAL
- en: '• **S**: Signature on the complete vote message from the sender'
  prefs: []
  type: TYPE_NORMAL
- en: Validators create the vote message, sign it, and broadcast to the network.
  prefs: []
  type: TYPE_NORMAL
- en: The hash of a checkpoint is used to identify the corresponding checkpoint. The
  prefs: []
  type: TYPE_NORMAL
- en: vote is valid only if s is an ancestor of t in the checkpoint tree and the public
    key of the validator is in the validator set. When more than two-thirds of validators
    vote on a chain from a source to a target, this chain or link becomes the supermajority
    link. For example, *cp*′ as a source and *cp* as a target, then *cp*′ → *cp* is
    the majority link. A checkpoint is justified if it is the genesis block or if
    it is the checkpoint in a supermajority link where the last checkpoint is justified.
    Precisely, we can say a checkpoint *cp* is justified if there is a supermajority
    link *cp*′ → *cp* where *cp*′ is justified. A checkpoint *cp* is considered final
    if it is justified and there exists a supermajority link *cp* → *cp*′ where *cp*′
    is a direct child of checkpoint *cp*.
  prefs: []
  type: TYPE_NORMAL
- en: Justified checkpoints are not considered final as there can exist conflicting
    justified
  prefs: []
  type: TYPE_NORMAL
- en: checkpoints. To finalize a checkpoint *cp*, a second round of confirmation is
    required where a direct child *cp*′ of *cp* with a supermajority link *cp* → *cp*′
    is justified.
  prefs: []
  type: TYPE_NORMAL
- en: '**Protocol steps**'
  prefs: []
  type: TYPE_NORMAL
- en: • Token holders deposit a stake in the network.
  prefs: []
  type: TYPE_NORMAL
- en: • During a consensus epoch
  prefs: []
  type: TYPE_NORMAL
- en: • Identify valid checkpoints.
  prefs: []
  type: TYPE_NORMAL
- en: • Add them to the checkpoint tree.
  prefs: []
  type: TYPE_NORMAL
- en: • Broadcast a vote for a checkpoint pair (source, target).
  prefs: []
  type: TYPE_NORMAL
- en: • Evaluate received votes’ validity, check against slashing rules and
  prefs: []
  type: TYPE_NORMAL
- en: the deposited stake of the vote signer.
  prefs: []
  type: TYPE_NORMAL
- en: '373'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 8 BloCkChain age protoCols
  prefs: []
  type: TYPE_NORMAL
- en: • If the checkpoint pair has more than two-thirds of total deposited
  prefs: []
  type: TYPE_NORMAL
- en: stakes, then the checkpoint is considered validated.
  prefs: []
  type: TYPE_NORMAL
- en: • The checkpoint pair is justified and finalized.
  prefs: []
  type: TYPE_NORMAL
- en: • Repeat the process.
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, the process works in three steps. First, votes are casted for a
    checkpoint;
  prefs: []
  type: TYPE_NORMAL
- en: if >2/3 votes are acquired, then the checkpoint is in a justified state. Finally,
    the chain is finalized to form the canonical chain. Justification does not mean
    finalized; there
  prefs: []
  type: TYPE_NORMAL
- en: can be multiple justified chains in the block tree. Finality occurs when two
    consecutive
  prefs: []
  type: TYPE_NORMAL
- en: checkpoints receive 2/3 votes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Safety and liveness**'
  prefs: []
  type: TYPE_NORMAL
- en: Any validator who violates these conditions will be penalized by slashing their
  prefs: []
  type: TYPE_NORMAL
- en: 'deposit. These are known as minimum slashing conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: • A validator must not publish two distinct votes for the same target
  prefs: []
  type: TYPE_NORMAL
- en: checkpoint height.
  prefs: []
  type: TYPE_NORMAL
- en: • A validator must not vote again within the source to target span of its
  prefs: []
  type: TYPE_NORMAL
- en: other existing vote.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two safety and liveness requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: • Accountable safety
  prefs: []
  type: TYPE_NORMAL
- en: • Plausible liveness
  prefs: []
  type: TYPE_NORMAL
- en: Accountable safety is a little different from the traditional safety requirement
  prefs: []
  type: TYPE_NORMAL
- en: in consensus protocols. Safety simply means that two conflicting checkpoints
    can
  prefs: []
  type: TYPE_NORMAL
- en: never be finalized unless more than one-third of validators deviate from the
    protocol.
  prefs: []
  type: TYPE_NORMAL
- en: Accountability means that misbehaving validators can be identified and penalized.
  prefs: []
  type: TYPE_NORMAL
- en: Plausible liveness means that as long as there exist children that extend the
    finalized
  prefs: []
  type: TYPE_NORMAL
- en: chain, supermajority links can always be added to produce new finalized checkpoints.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter discussed the blockchain age protocols that emerged after Bitcoin.
    There
  prefs: []
  type: TYPE_NORMAL
- en: are several types of blockchain consensus protocols; some are based on voting,
    some
  prefs: []
  type: TYPE_NORMAL
- en: are proof of work, and another class is proof of stake protocols. All these
    protocols have some safety and liveness properties that ensure that the protocol
    is correct and works
  prefs: []
  type: TYPE_NORMAL
- en: '374'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 8 BloCkChain age protoCols
  prefs: []
  type: TYPE_NORMAL
- en: correctly in a given environment. We discussed several of these points in this
    chapter. A concluding comparison of these protocols is presented in the last chapter,
    Chapt[er 10\.](https://doi.org/10.1007/978-1-4842-8179-6_10)
  prefs: []
  type: TYPE_NORMAL
- en: We also discussed protocols such as ETHASH, proof of stake, its different types,
    and
  prefs: []
  type: TYPE_NORMAL
- en: BFT variations, including HotStuff and Tendermint, in detail. Modern protocols
    such
  prefs: []
  type: TYPE_NORMAL
- en: as Casper FFG, Solana’s proof of history, and Polkadot’s GRANDPA and BABE were
    also
  prefs: []
  type: TYPE_NORMAL
- en: introduced. It is impossible to cover all protocols in this chapter, but at
    least adequate information is given to build a good understanding of different
    types of algorithms
  prefs: []
  type: TYPE_NORMAL
- en: used in the blockchain. Some more protocols that we did not cover, such as PoET,
  prefs: []
  type: TYPE_NORMAL
- en: HoneyBadger BFT, and Snow, will be briefly presented in the last chapter.
  prefs: []
  type: TYPE_NORMAL
- en: This area is a very active field of research, and many researchers in academia
    and
  prefs: []
  type: TYPE_NORMAL
- en: industry are very much interested in this area. As such, only further evolution
    and
  prefs: []
  type: TYPE_NORMAL
- en: advancement is expected in this space.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss another exciting topic, quantum consensus,
    a
  prefs: []
  type: TYPE_NORMAL
- en: subject that has emerged recently with the advent of quantum computing.
  prefs: []
  type: TYPE_NORMAL
- en: '**Bibliography**'
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Peer coin paper: [www.peercoin.net/whitepapers/peercoin-](https://www.peercoin.net/whitepapers/peercoin-paper.pdf)'
  prefs: []
  type: TYPE_NORMAL
- en: '[paper.pdf](https://www.peercoin.net/whitepapers/peercoin-paper.pdf)'
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Xiao, Y., Zhang, N., Lou, W., and Hou, Y.T., 2020\. A survey of
  prefs: []
  type: TYPE_NORMAL
- en: distributed consensus protocols for blockchain networks. IEEE
  prefs: []
  type: TYPE_NORMAL
- en: Communications Surveys & Tutorials, 22(2), pp. 1432–1465\.
  prefs: []
  type: TYPE_NORMAL
- en: '3\. Bashir, I., 2020\. Mastering Blockchain: A deep dive into'
  prefs: []
  type: TYPE_NORMAL
- en: distributed ledgers, consensus protocols, smart contracts, DApps,
  prefs: []
  type: TYPE_NORMAL
- en: cryptocurrencies, Ethereum, and more. Packt Publishing Ltd.
  prefs: []
  type: TYPE_NORMAL
- en: '4\. “Hidden lock problem[”: http://muratbuffalo.blogspot.](http://muratbuffalo.blogspot.com/2019/12/hotstuff-bft-consensus-in-lens-of.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[com/2019/12/hotstuff-bft-consensus-in-lens-of.html](http://muratbuffalo.blogspot.com/2019/12/hotstuff-bft-consensus-in-lens-of.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '5\. Web3 Foundation Consensus Tutorial – Bill Laboon: [https://](https://youtu.be/1CuTSluL7v4)'
  prefs: []
  type: TYPE_NORMAL
- en: '[youtu.be/1CuTSluL7v4](https://youtu.be/1CuTSluL7v4)'
  prefs: []
  type: TYPE_NORMAL
- en: 6\. [https://polkadot.network/blog/polkadot-consensus-](https://polkadot.network/blog/polkadot-consensus-part-2-grandpa/)
  prefs: []
  type: TYPE_NORMAL
- en: '[part-2-grandpa/](https://polkadot.network/blog/polkadot-consensus-part-2-grandpa/)'
  prefs: []
  type: TYPE_NORMAL
- en: '375'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 8 BloCkChain age protoCols
  prefs: []
  type: TYPE_NORMAL
- en: 7\. Buterin, V. and Griffith, V., 2017\. Casper the friendly finality
  prefs: []
  type: TYPE_NORMAL
- en: gadget. arXiv preprint arXiv:1710.09437\.
  prefs: []
  type: TYPE_NORMAL
- en: 8\. “Replace communication with local computation” – Liskov, B.,
  prefs: []
  type: TYPE_NORMAL
- en: 1993\. Practical uses of synchronized clocks in distributed systems.
  prefs: []
  type: TYPE_NORMAL
- en: Distributed Computing, 6(4), pp. 211–219\.
  prefs: []
  type: TYPE_NORMAL
- en: 9\. Buterin, V., Hernandez, D., Kamphefner, T., Pham, K., Qiao, Z.,
  prefs: []
  type: TYPE_NORMAL
- en: Ryan, D., Sin, J., Wang, Y., and Zhang, Y.X., 2020\. Combining
  prefs: []
  type: TYPE_NORMAL
- en: GHOST and casper. arXiv preprint arXiv:2003.03052\.
  prefs: []
  type: TYPE_NORMAL
- en: '10\. Solana whitepaper: Solana: A new architecture for a high'
  prefs: []
  type: TYPE_NORMAL
- en: 'performance blockchain v0.8.13: [https://solana.com/solana-](https://solana.com/solana-whitepaper.pdf)'
  prefs: []
  type: TYPE_NORMAL
- en: '[whitepaper.pdf](https://solana.com/solana-whitepaper.pdf)'
  prefs: []
  type: TYPE_NORMAL
- en: 11\. Burdges, J., Cevallos, A., Czaban, P., Habermeier, R., Hosseini, S.,
  prefs: []
  type: TYPE_NORMAL
- en: Lama, F., Alper, H.K., Luo, X., Shirazi, F., Stewart, A., and Wood, G.,
  prefs: []
  type: TYPE_NORMAL
- en: 2020\. Overview of polkadot and its design considerations. arXiv
  prefs: []
  type: TYPE_NORMAL
- en: preprint arXiv:2005.13456\.
  prefs: []
  type: TYPE_NORMAL
- en: 12\. Yin, M., Malkhi, D., Reiter, M.K., Gueta, G.G., and Abraham, I.,
  prefs: []
  type: TYPE_NORMAL
- en: '2018\. HotStuff: BFT consensus in the lens of blockchain. arXiv'
  prefs: []
  type: TYPE_NORMAL
- en: preprint arXiv:1803.05069\.
  prefs: []
  type: TYPE_NORMAL
- en: 13\. Buterin, V., Hernandez, D., Kamphefner, T., Pham, K., Qiao, Z.,
  prefs: []
  type: TYPE_NORMAL
- en: Ryan, D., Sin, J., Wang, Y., and Zhang, Y.X., 2020\. Combining
  prefs: []
  type: TYPE_NORMAL
- en: GHOST and casper. arXiv preprint arXiv:2003.03052\.
  prefs: []
  type: TYPE_NORMAL
- en: '14\. Stewart, A. and Kokoris-Kogia, E., 2020\. GRANDPA: a Byzantine'
  prefs: []
  type: TYPE_NORMAL
- en: finality gadget. arXiv preprint arXiv:2007.01560\.
  prefs: []
  type: TYPE_NORMAL
- en: '15\. Buchman, E., 2016\. Tendermint: Byzantine fault tolerance in the'
  prefs: []
  type: TYPE_NORMAL
- en: age of blockchains (Doctoral dissertation, University of Guelph).
  prefs: []
  type: TYPE_NORMAL
- en: '376'
  prefs: []
  type: TYPE_NORMAL
- en: '**CHAPTER 9**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Quantum Consensus**'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter covers quantum consensus. Before we explain what quantum consensus
  prefs: []
  type: TYPE_NORMAL
- en: is, a basic introduction to quantum computing and its advantages is given to
    build an
  prefs: []
  type: TYPE_NORMAL
- en: understanding about how quantum computer works. Moreover, topics like quantum
  prefs: []
  type: TYPE_NORMAL
- en: networks, quantum Internet, quantum cryptography, and quantum blockchains are
  prefs: []
  type: TYPE_NORMAL
- en: also covered. Then we discuss quantum consensus and explain what it is, how
    quantum
  prefs: []
  type: TYPE_NORMAL
- en: computing impacts classical consensus in classical and quantum networks, and
  prefs: []
  type: TYPE_NORMAL
- en: how quantum computing can enhance existing distributed consensus protocols.
    We
  prefs: []
  type: TYPE_NORMAL
- en: survey what has been done so far in the research community and some open research
  prefs: []
  type: TYPE_NORMAL
- en: problems.
  prefs: []
  type: TYPE_NORMAL
- en: '**Introduction**'
  prefs: []
  type: TYPE_NORMAL
- en: The roots of the idea to combine quantum mechanics and information theory can
  prefs: []
  type: TYPE_NORMAL
- en: be traced back to as early as the 1970s. In 1979, Paul Benioff proposed a theoretical
  prefs: []
  type: TYPE_NORMAL
- en: foundation of quantum computing. In 1982, Richard Feynman gave a lecture in
    which
  prefs: []
  type: TYPE_NORMAL
- en: he argued that classical computers cannot possibly perform calculations that
    describe
  prefs: []
  type: TYPE_NORMAL
- en: quantum phenomena. Classical computers are inherently limited, and to simulate
  prefs: []
  type: TYPE_NORMAL
- en: quantum phenomena, the computing device must also be based on quantum principles,
  prefs: []
  type: TYPE_NORMAL
- en: thus allowing quantum mechanical simulations and calculations which otherwise
  prefs: []
  type: TYPE_NORMAL
- en: are not possible in the classical computing world. This was received well, and
    many
  prefs: []
  type: TYPE_NORMAL
- en: researchers started working on this.
  prefs: []
  type: TYPE_NORMAL
- en: In 1985, David Deutsch proposed a universal quantum computer and indicated
  prefs: []
  type: TYPE_NORMAL
- en: that it might perform simultaneous operations using quantum superposition. He
    also
  prefs: []
  type: TYPE_NORMAL
- en: suggested the “Deutsch algorithm,” which could determine if a quantum coin is
    biased
  prefs: []
  type: TYPE_NORMAL
- en: with a single toss. After this, an interest sparked again but soon waned. However,
  prefs: []
  type: TYPE_NORMAL
- en: quantum computing came into the limelight when Peter Shor, in 1994, described
    a
  prefs: []
  type: TYPE_NORMAL
- en: quantum algorithm that could factorize large numbers quickly. This event sparked
    a
  prefs: []
  type: TYPE_NORMAL
- en: '377'
  prefs: []
  type: TYPE_NORMAL
- en: © Imran Bashir 2022
  prefs: []
  type: TYPE_NORMAL
- en: I. Bashir, *Blockchain Consensus*, [https://doi.org/10.1007/978-1-4842-8179-6_9](https://doi.org/10.1007/978-1-4842-8179-6_9#DOI)
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9 Quantum Consensus
  prefs: []
  type: TYPE_NORMAL
- en: lot of interest because primarily Internet security is based on RSA, which uses
    prime
  prefs: []
  type: TYPE_NORMAL
- en: factorization as a hard problem for its security. More precisely, it is computationally
  prefs: []
  type: TYPE_NORMAL
- en: infeasible to factor large prime numbers on classical computers, which gives
    RSA its
  prefs: []
  type: TYPE_NORMAL
- en: security. However, this can be done efficiently with quantum computers, thus
    breaking
  prefs: []
  type: TYPE_NORMAL
- en: RSA, hence the security on the Internet. Of course, we can imagine, this was
    big news.
  prefs: []
  type: TYPE_NORMAL
- en: In 1996, Grover introduced his quantum search algorithm, which further renewed
    the
  prefs: []
  type: TYPE_NORMAL
- en: researchers’ interest in quantum computing. Almost 28 years later, we are at
    the stage
  prefs: []
  type: TYPE_NORMAL
- en: where some companies have claimed quantum supremacy. Many researchers from
  prefs: []
  type: TYPE_NORMAL
- en: academia and industry are working on quantum computing, and it now appears that
  prefs: []
  type: TYPE_NORMAL
- en: quantum computing is at a stage where classical computing was in the 1960s.
    It will
  prefs: []
  type: TYPE_NORMAL
- en: become mainstream in a decade or so in most large organizations, if not everywhere.
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps, quantum computers may not become a household reality soon. Still, one
    thing
  prefs: []
  type: TYPE_NORMAL
- en: is clear; quantum computing is evolving rapidly and will start to impact (good
    or bad)
  prefs: []
  type: TYPE_NORMAL
- en: quite soon on our daily lives.
  prefs: []
  type: TYPE_NORMAL
- en: Quantum computers use ideas from various fields, including computer science,
  prefs: []
  type: TYPE_NORMAL
- en: engineering, quantum mechanics, physics, mathematics, and information theory.
  prefs: []
  type: TYPE_NORMAL
- en: Several subjects have emerged from this, such as quantum information science
    and
  prefs: []
  type: TYPE_NORMAL
- en: technology (QIST), a merger of quantum mechanics and information technology.
  prefs: []
  type: TYPE_NORMAL
- en: Quantum information science (QIS) is a subject at the intersection of computer
  prefs: []
  type: TYPE_NORMAL
- en: science, information theory, and quantum mechanics. QIS changes how we
  prefs: []
  type: TYPE_NORMAL
- en: fundamentally think about information processing and results in novel ways to
    solve
  prefs: []
  type: TYPE_NORMAL
- en: previously unsolvable computationally complex problems. A quantum computer stores
  prefs: []
  type: TYPE_NORMAL
- en: and processes data fundamentally differently from classical computing, where
    0s and 1s
  prefs: []
  type: TYPE_NORMAL
- en: are used to encode data. This difference in how the information is processed
    in quantum
  prefs: []
  type: TYPE_NORMAL
- en: computers opens the door to achieving significant speedup to solve complex problems.
  prefs: []
  type: TYPE_NORMAL
- en: '**What Is a Quantum Computer?**'
  prefs: []
  type: TYPE_NORMAL
- en: A quantum computer is a device that makes use of properties of quantum mechanics
  prefs: []
  type: TYPE_NORMAL
- en: to perform computations. Classical computers mimic calculations that humans
    can
  prefs: []
  type: TYPE_NORMAL
- en: perform and are good at solving general day-to-day problems. However, many problems
  prefs: []
  type: TYPE_NORMAL
- en: are still unsolvable on classical computers, called “intractable problems.”
    These
  prefs: []
  type: TYPE_NORMAL
- en: problems include modelling of natural phenomena such as atomic particle behavior
    and
  prefs: []
  type: TYPE_NORMAL
- en: '378'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9 Quantum Consensus
  prefs: []
  type: TYPE_NORMAL
- en: modelling climate change and many others. A simple example of a complex problem
  prefs: []
  type: TYPE_NORMAL
- en: could be when you organize ten people around a table for dinner. It turns out
    that there
  prefs: []
  type: TYPE_NORMAL
- en: are 3,628,800[1](#p393) ways to solve this. A brute-force way is to calculate
    factorial.
  prefs: []
  type: TYPE_NORMAL
- en: Another problem is the travelling salesman problem, which is an NP hard problem.
  prefs: []
  type: TYPE_NORMAL
- en: This problem aims to find the shortest route for a round trip among multiple
    cities.
  prefs: []
  type: TYPE_NORMAL
- en: We can solve many complex problems on classical computers, and we have
  prefs: []
  type: TYPE_NORMAL
- en: supercomputers available that can solve problems very fast, such as everyday
    math,
  prefs: []
  type: TYPE_NORMAL
- en: algebra problems, etc. However, the intractable problems are not solvable on
    even
  prefs: []
  type: TYPE_NORMAL
- en: modern supercomputers. This is where quantum computers come in. Especially in
  prefs: []
  type: TYPE_NORMAL
- en: combinatorial optimization problems where even supercomputers fail, quantum
  prefs: []
  type: TYPE_NORMAL
- en: computers provide a way to solve them.
  prefs: []
  type: TYPE_NORMAL
- en: Optimization problems are problems which try to find the best solution from
    all
  prefs: []
  type: TYPE_NORMAL
- en: feasible solutions. Quantum computers are good at solving these types of problems
  prefs: []
  type: TYPE_NORMAL
- en: where a large state space is explored.
  prefs: []
  type: TYPE_NORMAL
- en: Efficiently simulating molecules can help in new drug discovery. This problem
    of
  prefs: []
  type: TYPE_NORMAL
- en: simulation of molecules is difficult because all variations in the way atoms
    behave with
  prefs: []
  type: TYPE_NORMAL
- en: each other and even a small change in the way a single atom is positioned impact
    all
  prefs: []
  type: TYPE_NORMAL
- en: other atoms. Such problems where exponentially many variations exist are expected
    to
  prefs: []
  type: TYPE_NORMAL
- en: be solvable on quantum computers. Also, this information cannot be held on a
    classical
  prefs: []
  type: TYPE_NORMAL
- en: computer, as we don’t have such amount of space available.
  prefs: []
  type: TYPE_NORMAL
- en: For example, a caffeine molecule is composed of 24 atoms, but representing that
  prefs: []
  type: TYPE_NORMAL
- en: requires 10^48 bits, which makes this problem intractable on a classical computer;
  prefs: []
  type: TYPE_NORMAL
- en: however, a quantum computer can handle this information in 160 qubits.
  prefs: []
  type: TYPE_NORMAL
- en: Route optimization of delivery companies is an exciting application where the
    aim
  prefs: []
  type: TYPE_NORMAL
- en: is to find optimized routes in order to minimize fuel usage while still able
    to deliver a greater number of packages.
  prefs: []
  type: TYPE_NORMAL
- en: Quantum computing applications are vast, including but not limited to
  prefs: []
  type: TYPE_NORMAL
- en: cryptography, machine learning, data analysis, computational biology, simulating
  prefs: []
  type: TYPE_NORMAL
- en: chemistry, and quantum simulation.
  prefs: []
  type: TYPE_NORMAL
- en: An application in chemistry helps to discover new materials and compounds, new
  prefs: []
  type: TYPE_NORMAL
- en: drugs, and improvements in fertilizer production, which leads to better agriculture.
    In
  prefs: []
  type: TYPE_NORMAL
- en: cybersecurity, better and secure key generation and distribution mechanisms
    and novel
  prefs: []
  type: TYPE_NORMAL
- en: 1 [www.ibm.com/quantum-computing/what-is-quantum-computing/](http://www.ibm.com/quantum-computing/what-is-quantum-computing/)
  prefs: []
  type: TYPE_NORMAL
- en: '379'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9 Quantum Consensus
  prefs: []
  type: TYPE_NORMAL
- en: cryptology (cryptography and cryptanalysis) can be realized. Optimization problems
  prefs: []
  type: TYPE_NORMAL
- en: such as efficient route discovery, risk management in financial investments,
    and a
  prefs: []
  type: TYPE_NORMAL
- en: lot more are expected to be solvable by Quantum computers.
  prefs: []
  type: TYPE_NORMAL
- en: Quantum computing has many applications and thus the excitement and race
  prefs: []
  type: TYPE_NORMAL
- en: to achieve quantum supremacy. Quantum supremacy or quantum advantage is the
  prefs: []
  type: TYPE_NORMAL
- en: empirical demonstration of solving a problem that no classical computer can
    solve in a
  prefs: []
  type: TYPE_NORMAL
- en: reasonable amount of time.
  prefs: []
  type: TYPE_NORMAL
- en: There are several building blocks which are necessary to understand the quantum
  prefs: []
  type: TYPE_NORMAL
- en: 'computing world. We describe them as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: • Qubit
  prefs: []
  type: TYPE_NORMAL
- en: • Superposition
  prefs: []
  type: TYPE_NORMAL
- en: • Entanglement
  prefs: []
  type: TYPE_NORMAL
- en: • Teleportation
  prefs: []
  type: TYPE_NORMAL
- en: '**Qubit**'
  prefs: []
  type: TYPE_NORMAL
- en: A classical computer works based on two distinct states, 0 and 1\. Classical
    computers use transistors to create the absence or presence of an electric signal
    which represents 0 or 1, respectively. Fundamentally, it is all transistors, even
    in most modern supercomputers.
  prefs: []
  type: TYPE_NORMAL
- en: With qubits in quantum computers, this fundamental paradigm shifts, which leads
  prefs: []
  type: TYPE_NORMAL
- en: to extraordinary speeds at which quantum computers can operate. A qubit is the
    state
  prefs: []
  type: TYPE_NORMAL
- en: of physical atomic particles, for example, a spin on an electron. A qubit can
    be in a
  prefs: []
  type: TYPE_NORMAL
- en: superposition of two states 0 and 1 simultaneously. The speedup rises exponentially
    as
  prefs: []
  type: TYPE_NORMAL
- en: more qubits are added. Eight bits together in a classical computer are called
    a byte. In
  prefs: []
  type: TYPE_NORMAL
- en: the quantum computing world, eight qubits together are called a qubyte.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine 4 bits in a classical computer. These bits can have 16 possible states
    and
  prefs: []
  type: TYPE_NORMAL
- en: can only be input sequentially. However, in a quantum computer, 4 qubits can
    be in
  prefs: []
  type: TYPE_NORMAL
- en: a superposition of all 16 possible states and thus be input simultaneously Instead
    of
  prefs: []
  type: TYPE_NORMAL
- en: the classical version, where 4 bits do have 16 possible states but can only
    be input
  prefs: []
  type: TYPE_NORMAL
- en: sequentially. This phenomenon is called quantum parallelism and is the key to
    speeding
  prefs: []
  type: TYPE_NORMAL
- en: up certain types of problems that are intractable on classical computers.
  prefs: []
  type: TYPE_NORMAL
- en: There are many ways to build a qubit physically. These techniques include trapped
  prefs: []
  type: TYPE_NORMAL
- en: ions, photons, neutral atom, NMR, and several others.
  prefs: []
  type: TYPE_NORMAL
- en: '380'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9 Quantum Consensus
  prefs: []
  type: TYPE_NORMAL
- en: Dirac notation is used to represent qubits. Qubits are represented as ∣0⟩ and
  prefs: []
  type: TYPE_NORMAL
- en: ∣1⟩,as compared to classical 0 and 1\. The difference is that a qubit can be
    in a linear
  prefs: []
  type: TYPE_NORMAL
- en: combination of states called superpositions. A qubit can be a superposition
    of,
  prefs: []
  type: TYPE_NORMAL
- en: for example, an electron with spin-up or spin-down or a photon with +45-degree
  prefs: []
  type: TYPE_NORMAL
- en: polarization or –45-degree polarization and many other ways.
  prefs: []
  type: TYPE_NORMAL
- en: Dirac notation is used to represent quantum states and their superpositions.
    Dirac
  prefs: []
  type: TYPE_NORMAL
- en: notation has the form ∣0⟩ + ∣ 1⟩ where 0 and 1 are states.
  prefs: []
  type: TYPE_NORMAL
- en: A qubit can be in a quantum state ∣ *ψ*⟩ = *α* ∣ 0⟩ + *β* ∣ 1⟩ where *α*, *β*
    ∈ *C* (complex amplitudes) and | *α*|2 + | *β*|2 = 1\. This means that the state
    of a single qubit is represented by ∣ *ψ*⟩ = *α* ∣ 0⟩ + *β* ∣ 1⟩, and the probability
    condition is | *α*|2 + | *β*|2 = 1\. This probability condition means that the
    values that *α*, *β* can take are limited, and in any case, both must add to one.
    *C* represents complex numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Other than Dirac notation, we can also use vector representations. A single
    vector
  prefs: []
  type: TYPE_NORMAL
- en: 'can represent the state containing amplitudes *α* and *β*:'
  prefs: []
  type: TYPE_NORMAL
- en: '|ψ 〉 = α'
  prefs: []
  type: TYPE_NORMAL
- en: '[ β]'
  prefs: []
  type: TYPE_NORMAL
- en: and
  prefs: []
  type: TYPE_NORMAL
- en: ∣0⟩ = [1 0 ] and ∣1⟩ = [0 1 ]
  prefs: []
  type: TYPE_NORMAL
- en: A qubit can be visualized using a Bloch sphere, as shown in Figur[e 9-1\.](#p396)
  prefs: []
  type: TYPE_NORMAL
- en: '381'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-396_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 9 Quantum Consensus
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 9-1\.** The Bloch sphere – a convenient way to visualize qubits*'
  prefs: []
  type: TYPE_NORMAL
- en: We can describe a single qubit as a point on the surface of the Bloch sphere.
    The
  prefs: []
  type: TYPE_NORMAL
- en: North pole represents state ∣0⟩, and the South pole represents state ∣1⟩. Qubit
    angles are *θ* the latitude and *ϕ* the longitude. When a single gate operation
    is performed on the qubit, the state *ψ* (the qubit) rotates to another point
    on the Bloch sphere.
  prefs: []
  type: TYPE_NORMAL
- en: '**Superposition**'
  prefs: []
  type: TYPE_NORMAL
- en: Superposition is a fundamental principle of quantum mechanics. Superposition
    means
  prefs: []
  type: TYPE_NORMAL
- en: that quantum states can be added together to get another valid quantum state.
    This is
  prefs: []
  type: TYPE_NORMAL
- en: analogous to classical mechanics, where waves can be added together. Added quantum
  prefs: []
  type: TYPE_NORMAL
- en: states are so-called “superposed.” Superposition is the key to extraordinary
    speedup as it allows many computation paths to be explored simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: '**Entanglement**'
  prefs: []
  type: TYPE_NORMAL
- en: Entanglement is an incredibly strong correlation that exists between particles,
    which
  prefs: []
  type: TYPE_NORMAL
- en: allows two or more particles to inseparably link with each other. It allows
    any two
  prefs: []
  type: TYPE_NORMAL
- en: quantum particles to exist in a shared state. Any action on one particle instantly
    affects the other particle even at massive distances. Entanglement is usually
    performed by
  prefs: []
  type: TYPE_NORMAL
- en: '382'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9 Quantum Consensus
  prefs: []
  type: TYPE_NORMAL
- en: bringing two qubits close together, performing an operation to entangle them,
    and, once
  prefs: []
  type: TYPE_NORMAL
- en: entangled, moving them apart again. They will remain entangled even if one of
    them is
  prefs: []
  type: TYPE_NORMAL
- en: on earth and the other is moved to outer space at a vast distance.
  prefs: []
  type: TYPE_NORMAL
- en: There are two features of entanglement which makes it particularly suitable
    for a
  prefs: []
  type: TYPE_NORMAL
- en: 'large range of applications: maximal coordination and monogamy.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Maximal Coordination**'
  prefs: []
  type: TYPE_NORMAL
- en: When two qubits at different nodes in a network entangle, that is, the quantum
    state
  prefs: []
  type: TYPE_NORMAL
- en: of two particles become inseparably connected, they provide stronger correlation
    and
  prefs: []
  type: TYPE_NORMAL
- en: coordination properties, which are nonexistent in classical networks. This property
  prefs: []
  type: TYPE_NORMAL
- en: is called maximal coordination. For example, for any measurement on the first
    qubit,
  prefs: []
  type: TYPE_NORMAL
- en: if the same measurement is made on the second qubit, instantaneously, the same
  prefs: []
  type: TYPE_NORMAL
- en: answer is shown, even though that answer is random and was not predetermined.
  prefs: []
  type: TYPE_NORMAL
- en: More precisely, they will always yield a zero or one at random, but both will
    produce
  prefs: []
  type: TYPE_NORMAL
- en: the same output always. This feature makes entanglement suitable for tasks requiring
  prefs: []
  type: TYPE_NORMAL
- en: coordination, for example, clock synchronization, leader election, and consensus.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine clock synchronization in a distributed network without physical transfer;
    it can
  prefs: []
  type: TYPE_NORMAL
- en: make distributed networks extraordinarily fast. (Remember replacing communication
  prefs: []
  type: TYPE_NORMAL
- en: with local computation from the last chapter.) Also, state transfer/awareness
    during
  prefs: []
  type: TYPE_NORMAL
- en: consensus immediately makes consensus faster. The fundamental idea here is that
  prefs: []
  type: TYPE_NORMAL
- en: when entangled, it is possible to change the state globally (full state) by
    only performing operations (changing parameters) in one qubit. This feature has
    far-reaching
  prefs: []
  type: TYPE_NORMAL
- en: implications; imagine being able to do immediate state transfer to all nodes
    in the
  prefs: []
  type: TYPE_NORMAL
- en: network. This can result in extraordinary speedup in consensus algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Monogamy**'
  prefs: []
  type: TYPE_NORMAL
- en: Quantum entanglement is not shareable. If two qubits are entangled, then a third
    qubit
  prefs: []
  type: TYPE_NORMAL
- en: from anywhere in the universe can never entangle with either of them. This property
    is
  prefs: []
  type: TYPE_NORMAL
- en: called monogamy of entanglement. This property can enable applications in privacy,
  prefs: []
  type: TYPE_NORMAL
- en: cryptographic key generation, and identification.
  prefs: []
  type: TYPE_NORMAL
- en: '383'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-398_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 9 Quantum Consensus
  prefs: []
  type: TYPE_NORMAL
- en: '**Quantum Gates**'
  prefs: []
  type: TYPE_NORMAL
- en: Just like classical computing in the quantum world, we use gate operations for
    data
  prefs: []
  type: TYPE_NORMAL
- en: processing. We are used to Boolean gates used in the classical world, such as
    NOT, AND,
  prefs: []
  type: TYPE_NORMAL
- en: OR, XOR, NAND, and NOR. In the quantum world, we apply some operator to an input
  prefs: []
  type: TYPE_NORMAL
- en: state which transforms into an output state. This operator is called a quantum
    gate.
  prefs: []
  type: TYPE_NORMAL
- en: Quantum gates operate on a single qubit or multiple qubits. A rule here is that
    each gate must have the same number of inputs as outputs. This is what makes the
    gate reversible
  prefs: []
  type: TYPE_NORMAL
- en: and consequently the quantum computers reversible. There are single qubit gates
    which
  prefs: []
  type: TYPE_NORMAL
- en: make rotations on a Bloch sphere. Then there are two qubit gates which combine
    single
  prefs: []
  type: TYPE_NORMAL
- en: gates to create more complex functions, which leads to building quantum computers.
  prefs: []
  type: TYPE_NORMAL
- en: There are many quantum gates; some common ones are introduced as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '**Hadamard**'
  prefs: []
  type: TYPE_NORMAL
- en: This gate transforms a basis state into an even superposition of the two basis
    states.
  prefs: []
  type: TYPE_NORMAL
- en: Fundamentally, it allows us to create superpositions. It operates on one qubit
    and is
  prefs: []
  type: TYPE_NORMAL
- en: denoted by the symbol shown in Figur[e 9-2\.](#p398)
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 9-2\.** Quantum gates*'
  prefs: []
  type: TYPE_NORMAL
- en: '384'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9 Quantum Consensus
  prefs: []
  type: TYPE_NORMAL
- en: '**T**'
  prefs: []
  type: TYPE_NORMAL
- en: The T gate induces a pi/4 phase between contributing basis states. The symbol
    shown in
  prefs: []
  type: TYPE_NORMAL
- en: Figur[e 9-2 r](#p398)epresents the T gate. Relative phase rotation is by 45
    degrees in T gate.
  prefs: []
  type: TYPE_NORMAL
- en: '**CNOT**'
  prefs: []
  type: TYPE_NORMAL
- en: This gate is called the controlled NOT. It is the same as the classical XOR
    gate, but
  prefs: []
  type: TYPE_NORMAL
- en: with the property of reversibility. It works with two qubits. The first qubit
    serves as the control qubit, and the second qubit acts as the target qubit. It
    changes the state of the target qubit only if the first qubit is in a specific
    state. This gate can be used to create an entangled state in a two or more qubit
    system.
  prefs: []
  type: TYPE_NORMAL
- en: '**Toffoli (CCNOT)**'
  prefs: []
  type: TYPE_NORMAL
- en: This is the controlled-controlled NOT gate. It operates on three qubits. It
    switches the
  prefs: []
  type: TYPE_NORMAL
- en: third bit of a three-bit state where the first two bits are 1, that is, it switches
    ∣110⟩ to ∣111⟩
  prefs: []
  type: TYPE_NORMAL
- en: and vice versa. It is represented by the symbol shown in Figur[e 9-2](#p398).
    In other words, if the first two bits are 1, the third bit inverts.
  prefs: []
  type: TYPE_NORMAL
- en: '**Z**'
  prefs: []
  type: TYPE_NORMAL
- en: It is a phase shift gate. It maps 1 to –1 and keeps 0 as 0\. In other words,
    the amplitude of
  prefs: []
  type: TYPE_NORMAL
- en: ∣1⟩ is negated. Fundamentally, it rotates the phase by 180 degrees. It is represented
    in the circuit with the symbol Z in a box, as shown in Figure [9-2](#p398).
  prefs: []
  type: TYPE_NORMAL
- en: '**NOT**'
  prefs: []
  type: TYPE_NORMAL
- en: This gate switches ∣1⟩ to ∣1⟩ and vice versa. It is an analogue of the classical
    NOT gate.
  prefs: []
  type: TYPE_NORMAL
- en: '**Swap Gate**'
  prefs: []
  type: TYPE_NORMAL
- en: The swap gate swaps two qubits. It can be visualized in Figur[e 9-2\. Of co](#p398)urse,
    there are many quantum gates, but we have introduced those which are commonly
    used and will
  prefs: []
  type: TYPE_NORMAL
- en: help us to understand the algorithms later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: All these gates can be visualized in Figure [9-2](#p398).
  prefs: []
  type: TYPE_NORMAL
- en: '385'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-400_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](index-400_2.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 9 Quantum Consensus
  prefs: []
  type: TYPE_NORMAL
- en: '**Measurement**'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to gates, another important element is measurements. A measurement
    takes
  prefs: []
  type: TYPE_NORMAL
- en: a quantum state and collapses it into one of the basis states. We can visualize
    this in
  prefs: []
  type: TYPE_NORMAL
- en: Figur[e 9-3\.](#p400)
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 9-3\.** Measurement*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Quantum Circuits**'
  prefs: []
  type: TYPE_NORMAL
- en: Using quantum gates, we build quantum circuits. A quantum circuit is basically
    a
  prefs: []
  type: TYPE_NORMAL
- en: sequence of quantum operations applied to qubits. It is composed of quantum
    gates
  prefs: []
  type: TYPE_NORMAL
- en: (operators), quantum registers containing qubits providing input, quantum wires
  prefs: []
  type: TYPE_NORMAL
- en: representing a sequence of operations over time, and measurements. Time runs
    from left
  prefs: []
  type: TYPE_NORMAL
- en: to right in quantum circuits. Figur[e 9-4 sho](#p400)ws how a quantum circuit
    looks like.
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 9-4\.** A quantum circuit*'
  prefs: []
  type: TYPE_NORMAL
- en: Quantum gates are represented as boxes. On the left side, we have quantum
  prefs: []
  type: TYPE_NORMAL
- en: registers. Quantum wires represent a qubit, that is, a photon or an electron.
    Each gate
  prefs: []
  type: TYPE_NORMAL
- en: introduces a change in the qubit, for example, a change in the spin of an electron.
  prefs: []
  type: TYPE_NORMAL
- en: '386'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-401_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 9 Quantum Consensus
  prefs: []
  type: TYPE_NORMAL
- en: Quantum circuits implement quantum algorithms. In other words, quantum
  prefs: []
  type: TYPE_NORMAL
- en: algorithms are described by quantum circuits. There are many standard quantum
  prefs: []
  type: TYPE_NORMAL
- en: circuits. We describe some commonly used as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '**Teleportation Circuit**'
  prefs: []
  type: TYPE_NORMAL
- en: Can we transfer a quantum state from one quantum device to another? Yes, we
    can; for
  prefs: []
  type: TYPE_NORMAL
- en: this purpose, teleportation is used, which uses entanglement to move a quantum
    state
  prefs: []
  type: TYPE_NORMAL
- en: from one quantum device to another.
  prefs: []
  type: TYPE_NORMAL
- en: In Figur[e 9-5, a t](#p401)eleportation circuit is shown, which can transport
    a quantum state from one party to another.
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 9-5\.** Teleportation circuit*'
  prefs: []
  type: TYPE_NORMAL
- en: Some applications of teleportation are state transportation between quantum
  prefs: []
  type: TYPE_NORMAL
- en: systems. This can be valuable in quantum distributed systems where state transfer
  prefs: []
  type: TYPE_NORMAL
- en: between nodes can enable applications like quantum state machine replication.
  prefs: []
  type: TYPE_NORMAL
- en: '**GHZ Circuit**'
  prefs: []
  type: TYPE_NORMAL
- en: The Greenberger-Horne-Zeilinger (GHZ) state is an entangled state of three or
    more
  prefs: []
  type: TYPE_NORMAL
- en: qubits. If three or more particles get into an entangled state, it’s called
    a multipartite entanglement.
  prefs: []
  type: TYPE_NORMAL
- en: Figur[e 9-6 vis](#p402)ualizes this circuit.
  prefs: []
  type: TYPE_NORMAL
- en: '387'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-402_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](index-402_2.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 9 Quantum Consensus
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 9-6\.** GHZ circuit*'
  prefs: []
  type: TYPE_NORMAL
- en: GHZ states have been shown to be useful in quantum cryptography and quantum
  prefs: []
  type: TYPE_NORMAL
- en: Byzantine agreement (consensus) algorithms, as we’ll explore later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '**W State Circuit**'
  prefs: []
  type: TYPE_NORMAL
- en: The W state circuit is another way to achieve entanglement of three particles.
    The
  prefs: []
  type: TYPE_NORMAL
- en: difference with GHZ is that in the W state if one qubit is lost out of three,
    then the
  prefs: []
  type: TYPE_NORMAL
- en: remaining two will remain entangled. GHZ however does not have this property.
    The
  prefs: []
  type: TYPE_NORMAL
- en: circuit is shown in Figure [9-7](#p402).
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 9-7\.** W state circuit*'
  prefs: []
  type: TYPE_NORMAL
- en: The W state circuit has application in leader election algorithms, as we’ll
    see later in
  prefs: []
  type: TYPE_NORMAL
- en: this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '**Quantum Algorithms**'
  prefs: []
  type: TYPE_NORMAL
- en: As we know, algorithms are set of instructions to solve a problem. Quantum algorithms
  prefs: []
  type: TYPE_NORMAL
- en: are the same in this regard; however, they run on quantum devices and contain
    at least
  prefs: []
  type: TYPE_NORMAL
- en: one quantum operation, for example, superpositions or entanglement operations.
    In
  prefs: []
  type: TYPE_NORMAL
- en: '388'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9 Quantum Consensus
  prefs: []
  type: TYPE_NORMAL
- en: other words, a quantum algorithm is the same as the classical algorithm in the
    sense
  prefs: []
  type: TYPE_NORMAL
- en: that it is a set of instructions to solve a problem, but it has instructions
    for creating superpositions and entanglements.
  prefs: []
  type: TYPE_NORMAL
- en: Famous quantum algorithms include the Deutsch-Jozsa blackbox solution
  prefs: []
  type: TYPE_NORMAL
- en: algorithm, Shor’s discrete log problem and factorization algorithm, and Grover’s
    search
  prefs: []
  type: TYPE_NORMAL
- en: algorithm. There is a catalogue maintained at the quantum algorithm zoo –
  prefs: []
  type: TYPE_NORMAL
- en: '[https://quantumalgorithmzoo.org.](https://quantumalgorithmzoo.org)'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are primarily three classes of quantum algorithms: quantum search'
  prefs: []
  type: TYPE_NORMAL
- en: algorithms, quantum Fourier transform–based algorithms, and quantum simulation
  prefs: []
  type: TYPE_NORMAL
- en: algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Quantum Computational Complexity**'
  prefs: []
  type: TYPE_NORMAL
- en: In computer science, we are used to analyze algorithms to understand the resources
  prefs: []
  type: TYPE_NORMAL
- en: required to run an algorithm. The analysis looks at algorithms from two angles,
    the time
  prefs: []
  type: TYPE_NORMAL
- en: complexity of how many steps the algorithm will take to run and how much memory
    or
  prefs: []
  type: TYPE_NORMAL
- en: “work space” it will consume. This is usually referred to as time and space
    complexity,
  prefs: []
  type: TYPE_NORMAL
- en: respectively.
  prefs: []
  type: TYPE_NORMAL
- en: To describe and classify the time and space complexity of algorithms, the big
    *O*
  prefs: []
  type: TYPE_NORMAL
- en: notation is used. Particularly, this classification is based on the study of
    how the time to run or space requirements of algorithms grow as the input size
    grows. A chart is
  prefs: []
  type: TYPE_NORMAL
- en: presented in Figur[e 9-8, whic](#p404)h gives a visual indication of how the
    problem class behaves from a complexity point of view.
  prefs: []
  type: TYPE_NORMAL
- en: '389'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-404_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 9 Quantum Consensus
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 9-8\.** Big-O complexity chart*'
  prefs: []
  type: TYPE_NORMAL
- en: Common Big-O complexity orders are described in Table [9-1](#p404).
  prefs: []
  type: TYPE_NORMAL
- en: '***Table 9-1\.** Big-O complexity orders*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Name**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Big-O Notation**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Examples**'
  prefs: []
  type: TYPE_NORMAL
- en: Constant time
  prefs: []
  type: TYPE_NORMAL
- en: '*O* (1)'
  prefs: []
  type: TYPE_NORMAL
- en: Find if a number is odd or even
  prefs: []
  type: TYPE_NORMAL
- en: Logarithmic
  prefs: []
  type: TYPE_NORMAL
- en: '*O* ( *log n*)'
  prefs: []
  type: TYPE_NORMAL
- en: Binary search
  prefs: []
  type: TYPE_NORMAL
- en: sublinear (square root)
  prefs: []
  type: TYPE_NORMAL
- en: '*O* (√ *n*)'
  prefs: []
  type: TYPE_NORMAL
- en: Linear
  prefs: []
  type: TYPE_NORMAL
- en: '*O*( *n*)'
  prefs: []
  type: TYPE_NORMAL
- en: Linear search
  prefs: []
  type: TYPE_NORMAL
- en: Quadratic
  prefs: []
  type: TYPE_NORMAL
- en: '*O*( *n* 2)'
  prefs: []
  type: TYPE_NORMAL
- en: Insertion sort
  prefs: []
  type: TYPE_NORMAL
- en: Cubic
  prefs: []
  type: TYPE_NORMAL
- en: '*O*( *n* 3)'
  prefs: []
  type: TYPE_NORMAL
- en: simple multiplication of *n* × *n* matrices
  prefs: []
  type: TYPE_NORMAL
- en: exponential
  prefs: []
  type: TYPE_NORMAL
- en: '*O*(2 *n*)'
  prefs: []
  type: TYPE_NORMAL
- en: recursive Fibonacci
  prefs: []
  type: TYPE_NORMAL
- en: Algorithms are methods which contain a specific set of instructions to solve
  prefs: []
  type: TYPE_NORMAL
- en: computational problems. Computation complexity is the study of categorization
  prefs: []
  type: TYPE_NORMAL
- en: of different problems into suitable classes. Naturally, a need here arises to
    formally
  prefs: []
  type: TYPE_NORMAL
- en: '390'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9 Quantum Consensus
  prefs: []
  type: TYPE_NORMAL
- en: categorize the algorithms into different categories based on the computational
    resources
  prefs: []
  type: TYPE_NORMAL
- en: required to solve a problem. For this purpose, complexity classes are considered.
  prefs: []
  type: TYPE_NORMAL
- en: With quantum computing, new complexity classes have also emerged. Quantum
  prefs: []
  type: TYPE_NORMAL
- en: computers can solve NP hard problems, which classical computers cannot.
  prefs: []
  type: TYPE_NORMAL
- en: Several complexity classes exist; we describe them as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '**P – Polynomial**'
  prefs: []
  type: TYPE_NORMAL
- en: A polynomial time class categorizes problems which are solvable in polynomial
    time,
  prefs: []
  type: TYPE_NORMAL
- en: that is, a reasonable amount of time.
  prefs: []
  type: TYPE_NORMAL
- en: '**NP – Nondeterministic Polynomial**'
  prefs: []
  type: TYPE_NORMAL
- en: An NP class means that the solution to the problem can be checked quicker, that
    is, in
  prefs: []
  type: TYPE_NORMAL
- en: polynomial time. One example of P is multiplication, whereas factorization is
    NP. For
  prefs: []
  type: TYPE_NORMAL
- en: example, the multiplication of two numbers is in class P, whereas factoring
    (finding
  prefs: []
  type: TYPE_NORMAL
- en: which two numbers were multiplied) is in class NP. However, if the solution
    is there, then it’s quick to verify the solution; hence, it is in the NP class.
  prefs: []
  type: TYPE_NORMAL
- en: NP-complete problems are those if they are in NP and all NP problems are
  prefs: []
  type: TYPE_NORMAL
- en: “polynomial time” reducible to the NP problem under consideration. NP hard problems
  prefs: []
  type: TYPE_NORMAL
- en: are those if we know that any NP problems are reducible to the possibly NP problem
  prefs: []
  type: TYPE_NORMAL
- en: under consideration, but we do not know if the problem is in NP. In other words,
    NP-
  prefs: []
  type: TYPE_NORMAL
- en: complete are those if any NP problem can be reduced to these problems, and NP
    hard
  prefs: []
  type: TYPE_NORMAL
- en: means they’re reducible to NP but don’t know if they are in NP. One famous example
    of
  prefs: []
  type: TYPE_NORMAL
- en: an NP-complete problem is the travelling salesman problem.
  prefs: []
  type: TYPE_NORMAL
- en: '**BPP – Bounded Error Probabilistic Polynomial Time**'
  prefs: []
  type: TYPE_NORMAL
- en: This class contains P. These problems are solvable in polynomial time with probability
  prefs: []
  type: TYPE_NORMAL
- en: ½. Problems in BPP are either solvable deterministically in polynomial time
    or
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: probabilistically correctly more than one-thirds of the time.
  prefs: []
  type: TYPE_NORMAL
- en: '391'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-406_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 9 Quantum Consensus
  prefs: []
  type: TYPE_NORMAL
- en: '**BQP – Bounded Error Quantum Polynomial Time**'
  prefs: []
  type: TYPE_NORMAL
- en: This new class emerged with quantum computing. A problem is in BQP if it is
    solvable
  prefs: []
  type: TYPE_NORMAL
- en: correctly on a quantum computer in polynomial time with probability > ½, that
    is, high probability. In other words, this class includes problems that are thought
    to be hard for classical computers, but easy for quantum computers.
  prefs: []
  type: TYPE_NORMAL
- en: Figur[e 9-9 sho](#p406)ws complexity classes.
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 9-9\.** Complexity classes*'
  prefs: []
  type: TYPE_NORMAL
- en: '**PSPACE – Polynomial Space**'
  prefs: []
  type: TYPE_NORMAL
- en: This class is concerned with memory utilization, instead of time. Problems in
    PSPACE
  prefs: []
  type: TYPE_NORMAL
- en: require a polynomial size of memory.
  prefs: []
  type: TYPE_NORMAL
- en: There is also a concept of hypercomputation that has come to limelight with
  prefs: []
  type: TYPE_NORMAL
- en: quantum computing. The idea of hypercomputation is that it can even solve problems
  prefs: []
  type: TYPE_NORMAL
- en: which are Turing incomplete, for example, the halting problem. It has, however,
    been
  prefs: []
  type: TYPE_NORMAL
- en: shown that a quantum computer could be much faster than a classical one, but
    it cannot
  prefs: []
  type: TYPE_NORMAL
- en: solve every problem that a classical computer cannot. The idea is that even
    on quantum
  prefs: []
  type: TYPE_NORMAL
- en: computers, Turing-incomplete problems cannot be solved. However, research continues
  prefs: []
  type: TYPE_NORMAL
- en: in this regard to study infinite state superposition and infinite state Turing
    machines
  prefs: []
  type: TYPE_NORMAL
- en: which can lead to building hypercomputers.
  prefs: []
  type: TYPE_NORMAL
- en: With this we complete our discussion on complexity.
  prefs: []
  type: TYPE_NORMAL
- en: '392'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9 Quantum Consensus
  prefs: []
  type: TYPE_NORMAL
- en: '**Other Quantum Systems**'
  prefs: []
  type: TYPE_NORMAL
- en: As quantum computing evolves, new systems utilizing quantum properties will
    emerge.
  prefs: []
  type: TYPE_NORMAL
- en: We discuss them as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '**Quantum Networks**'
  prefs: []
  type: TYPE_NORMAL
- en: Quantum networks are like classical networks with the same routing strategies
    and
  prefs: []
  type: TYPE_NORMAL
- en: topologies. The key difference is that nodes can implement quantum computations
    and
  prefs: []
  type: TYPE_NORMAL
- en: relevant quantum processes. Channels between quantum devices in a quantum network
  prefs: []
  type: TYPE_NORMAL
- en: can be quantum or classical.
  prefs: []
  type: TYPE_NORMAL
- en: '**Quantum Internet**'
  prefs: []
  type: TYPE_NORMAL
- en: Just as the ARPANET from 1969 with just four nodes became the Internet of today
    with
  prefs: []
  type: TYPE_NORMAL
- en: billions of entities[2 on it](#p407), it is expected that small experimental
    scale quantum networks will become a quantum Internet of tomorrow.
  prefs: []
  type: TYPE_NORMAL
- en: It is envisioned that a quantum network infrastructure will be developed to
  prefs: []
  type: TYPE_NORMAL
- en: interconnect remote quantum devices and enable quantum communication between
  prefs: []
  type: TYPE_NORMAL
- en: them. The quantum Internet is governed by laws of quantum mechanics. It transfers
  prefs: []
  type: TYPE_NORMAL
- en: qubits and distributes entangled quantum states. As the number of nodes grows
    in the
  prefs: []
  type: TYPE_NORMAL
- en: quantum Internet, so does the quantum power. This is so because, as the number
    of
  prefs: []
  type: TYPE_NORMAL
- en: qubits scales linearly with the number of quantum devices on the network, the
    quantum
  prefs: []
  type: TYPE_NORMAL
- en: Internet could enable an exponential quantum speedup, resulting in a “virtual
    quantum
  prefs: []
  type: TYPE_NORMAL
- en: computer” capable of solving previously impossible problems.
  prefs: []
  type: TYPE_NORMAL
- en: Traditional operations present in classical networks such as long-term data
    storage,
  prefs: []
  type: TYPE_NORMAL
- en: 'data duplication (copying), and straightforward state reading are no longer
    applicable in quantum networks:'
  prefs: []
  type: TYPE_NORMAL
- en: • Long-term data storage is not possible because decoherence in the
  prefs: []
  type: TYPE_NORMAL
- en: quantum world rapidly corrupts information, making it very difficult
  prefs: []
  type: TYPE_NORMAL
- en: to rely on quantum memories/storage.
  prefs: []
  type: TYPE_NORMAL
- en: 2 As almost everything can connect to the Internet now, the term “entities”
    is used which includes users, things, devices, etc.
  prefs: []
  type: TYPE_NORMAL
- en: '393'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9 Quantum Consensus
  prefs: []
  type: TYPE_NORMAL
- en: • Data copying is not possible in the quantum world due to the
  prefs: []
  type: TYPE_NORMAL
- en: no-cloning theorem which prohibits copying an unknown qubit.
  prefs: []
  type: TYPE_NORMAL
- en: This means that usual mechanisms to improve resilience on the
  prefs: []
  type: TYPE_NORMAL
- en: network, such as retransmission, are no longer applicable. However,
  prefs: []
  type: TYPE_NORMAL
- en: note that the no-cloning theorem is a valuable property for secure
  prefs: []
  type: TYPE_NORMAL
- en: communications.
  prefs: []
  type: TYPE_NORMAL
- en: • Reading quantum states is challenging because when measured, any
  prefs: []
  type: TYPE_NORMAL
- en: qubit immediately collapses to a classical single state of 0 or 1\.
  prefs: []
  type: TYPE_NORMAL
- en: Due to uncertainty associated with reading quantum states and the
  prefs: []
  type: TYPE_NORMAL
- en: no-cloning theorem, direct transmission of qubits is only limited to
  prefs: []
  type: TYPE_NORMAL
- en: very specific scenarios with short distances.
  prefs: []
  type: TYPE_NORMAL
- en: However, quantum teleportation can be used to transmit qubits. Quantum
  prefs: []
  type: TYPE_NORMAL
- en: teleportation is realized using a quantum feature called entanglement, which
    we
  prefs: []
  type: TYPE_NORMAL
- en: discussed earlier. Using entanglement, instantaneous transfer of the quantum
    state
  prefs: []
  type: TYPE_NORMAL
- en: encoded in a qubit at a sender to a qubit stored at a receiver is possible.
    The surprising thing is that this transfer occurs without physical transfer of
    the qubit at the sender.
  prefs: []
  type: TYPE_NORMAL
- en: Entanglement is the core enabler of the quantum Internet.
  prefs: []
  type: TYPE_NORMAL
- en: A quantum Internet enables several exotic applications such as blind computing,
  prefs: []
  type: TYPE_NORMAL
- en: secure communications, and noiseless communications.
  prefs: []
  type: TYPE_NORMAL
- en: '**Quantum Distributed Systems – Distributed**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Quantum Computing**'
  prefs: []
  type: TYPE_NORMAL
- en: With the availability of the quantum Internet, it is not difficult to envisage
    that quantum nodes will also engage in communication with each other to cooperate
    and collectively
  prefs: []
  type: TYPE_NORMAL
- en: solve some problem using the distributed computing approach. This development
  prefs: []
  type: TYPE_NORMAL
- en: will inevitably lead to the emergence of distributed quantum systems or distributed
  prefs: []
  type: TYPE_NORMAL
- en: quantum computing.
  prefs: []
  type: TYPE_NORMAL
- en: We can think of a layered approach where at the lowest layer we have a network
    layer
  prefs: []
  type: TYPE_NORMAL
- en: composed of classical and quantum links. Then we have a layer of quantum computers
  prefs: []
  type: TYPE_NORMAL
- en: running on the next layer. Next up are local and remote operations, which include
    local
  prefs: []
  type: TYPE_NORMAL
- en: quantum operations and remote operations on qubits. By combining all operations
    and
  prefs: []
  type: TYPE_NORMAL
- en: computing layers underneath, a virtual quantum computer can be imagined, which
  prefs: []
  type: TYPE_NORMAL
- en: combines all the qubits and results in a scalable virtual quantum computer.
    A controller
  prefs: []
  type: TYPE_NORMAL
- en: '394'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-409_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 9 Quantum Consensus
  prefs: []
  type: TYPE_NORMAL
- en: or distributed quantum compiler is then required to translate quantum algorithms
    into
  prefs: []
  type: TYPE_NORMAL
- en: a sequence of local and remote operations. Finally, we have a layer on top which
    runs
  prefs: []
  type: TYPE_NORMAL
- en: quantum algorithms. This layered approach can be visualized in Figure [9-10\.](#p409)
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 9-10\.** An abstract quantum blockchain ecosystem*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Quantum Blockchain**'
  prefs: []
  type: TYPE_NORMAL
- en: Inevitably with the quantum Internet and quantum distributed systems, we can
    envisage
  prefs: []
  type: TYPE_NORMAL
- en: a quantum blockchain that utilizes quantum computers as nodes and the underlying
  prefs: []
  type: TYPE_NORMAL
- en: quantum Internet as the communication layer.
  prefs: []
  type: TYPE_NORMAL
- en: There are two facets of blockchains in the quantum world. The first one is the
  prefs: []
  type: TYPE_NORMAL
- en: pure quantum blockchains running on top of the quantum Internet. Some work has
  prefs: []
  type: TYPE_NORMAL
- en: been done in this regard, and an innovative proposal by Rajan and Visser is
    to encode
  prefs: []
  type: TYPE_NORMAL
- en: blockchains into a temporal GHZ state.
  prefs: []
  type: TYPE_NORMAL
- en: The other aspect is the existence of classical blockchains in the post-quantum
    world.
  prefs: []
  type: TYPE_NORMAL
- en: Quantum computers can impact the security of blockchains and consensus adversely
  prefs: []
  type: TYPE_NORMAL
- en: due to the ability to break classical cryptography. More on this later in this
    chapter in the last section.
  prefs: []
  type: TYPE_NORMAL
- en: '395'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9 Quantum Consensus
  prefs: []
  type: TYPE_NORMAL
- en: A quantum blockchain can comprise several elements. The quantum blockchain
  prefs: []
  type: TYPE_NORMAL
- en: can have both classical and quantum channels and devices. It can exist as a
    quantum
  prefs: []
  type: TYPE_NORMAL
- en: algorithm, among others, in the “distributed quantum algorithm” layer in the
    distributed
  prefs: []
  type: TYPE_NORMAL
- en: quantum computing ecosystem discussed in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: We elaborated a layered approach in the previous section. We can envisage
  prefs: []
  type: TYPE_NORMAL
- en: blockchains and other algorithms running on the top layer. This whole layer
    approach
  prefs: []
  type: TYPE_NORMAL
- en: represents quantum Internet–based distributed quantum computing ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: Another element could be a quantum transaction coordinator responsible for
  prefs: []
  type: TYPE_NORMAL
- en: transaction ordering and dissemination. On the other hand, by using blind computing,
  prefs: []
  type: TYPE_NORMAL
- en: quantum blockchains can immediately realize the unparalleled privacy which will
  prefs: []
  type: TYPE_NORMAL
- en: enable quantum scale blockchain applications that require privacy, for example,
    finance,
  prefs: []
  type: TYPE_NORMAL
- en: health, and government-related applications.
  prefs: []
  type: TYPE_NORMAL
- en: '**Quantum Cryptography**'
  prefs: []
  type: TYPE_NORMAL
- en: Quantum cryptography is indeed the most talked-about aspect of quantum computing,
  prefs: []
  type: TYPE_NORMAL
- en: especially from the point of view of the impact that it can have on existing
    cryptography.
  prefs: []
  type: TYPE_NORMAL
- en: There are two dimensions here; one is quantum cryptography, and the other is
    post-
  prefs: []
  type: TYPE_NORMAL
- en: quantum cryptography. Quantum cryptography refers to cryptography primitives
    or
  prefs: []
  type: TYPE_NORMAL
- en: techniques that are based on properties of quantum mechanics. For example, quantum
  prefs: []
  type: TYPE_NORMAL
- en: key distribution, quantum coin flipping, and quantum commitment. Using quantum
  prefs: []
  type: TYPE_NORMAL
- en: properties, a new type of unconditionally secure mechanisms can be developed,
    which
  prefs: []
  type: TYPE_NORMAL
- en: have no counterpart in the classical world. Quantum key distribution (QKD) protocols,
  prefs: []
  type: TYPE_NORMAL
- en: such as BB84, were proposed by Bennett and Brassard in 1984, which allow two
    parties
  prefs: []
  type: TYPE_NORMAL
- en: to construct private keys securely using qubits. The benefit of this quantum
    scheme is
  prefs: []
  type: TYPE_NORMAL
- en: that due to superposition any adversary trying to eavesdrop will inevitably
    be detected.
  prefs: []
  type: TYPE_NORMAL
- en: The other dimension of the study of quantum cryptography is the impact of
  prefs: []
  type: TYPE_NORMAL
- en: quantum computers on classical cryptography. We know that using Shor’s algorithm,
    the
  prefs: []
  type: TYPE_NORMAL
- en: discrete log problem can be solved, and integer factorization can be sped up,
    which can
  prefs: []
  type: TYPE_NORMAL
- en: result in breaking commonly used public key cryptography schemes, such as RSA
    and
  prefs: []
  type: TYPE_NORMAL
- en: elliptic curve cryptography. Not so much impact is expected on symmetric cryptography
  prefs: []
  type: TYPE_NORMAL
- en: because simply key lengths can be increased to ensure that exhaustive searches
    *O*( *n*) in the classic world and *O*( *n* ) using quantum techniques made possible
    by Grover’s algorithm or similar no longer are effective.
  prefs: []
  type: TYPE_NORMAL
- en: '396'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9 Quantum Consensus
  prefs: []
  type: TYPE_NORMAL
- en: Several approaches have been studied for post-quantum cryptography, including
  prefs: []
  type: TYPE_NORMAL
- en: lattice-based cryptography, code-based cryptography, multivariate cryptography,
    hash-
  prefs: []
  type: TYPE_NORMAL
- en: based cryptography, and isogeny-based cryptography.
  prefs: []
  type: TYPE_NORMAL
- en: As blockchain consensus mechanisms use cryptography, which is known to be
  prefs: []
  type: TYPE_NORMAL
- en: impacted by quantum computing, it is essential that the blocks produced today
    are
  prefs: []
  type: TYPE_NORMAL
- en: quantum resistant so that when quantum computers can do so, they cannot rewrite
    the
  prefs: []
  type: TYPE_NORMAL
- en: entire history of a blockchain. For example, Bitcoin uses the digital signature
    scheme
  prefs: []
  type: TYPE_NORMAL
- en: ECDSA, which quantum computers can break. If quantum technology becomes capable
  prefs: []
  type: TYPE_NORMAL
- en: of breaking ECDSA even in ten years, they can still move funds around due to
    broken
  prefs: []
  type: TYPE_NORMAL
- en: ECDSA. Therefore, there is a need to address this issue and apply some quantum
  prefs: []
  type: TYPE_NORMAL
- en: resistance to already produced and future blocks. If quantum technology becomes
  prefs: []
  type: TYPE_NORMAL
- en: capable of breaking ECDSA in future, an adversary cannot rewrite the block history.
  prefs: []
  type: TYPE_NORMAL
- en: Bitcoin generally is not quantum safe, and Lamport signatures have been proposed
  prefs: []
  type: TYPE_NORMAL
- en: to alleviate this issue. Note that Bitcoin is secure for the foreseeable future,
    and the
  prefs: []
  type: TYPE_NORMAL
- en: quantum computer required to break ECC is still decades away. To break the 256-bit
  prefs: []
  type: TYPE_NORMAL
- en: ECC encryption within one hour, 317 × 106 physic[al qubits3](#p411) are required.
    However, currently the most qubits we have today are only 127 on IBM’s 127-qubit
    Eagle processor.
  prefs: []
  type: TYPE_NORMAL
- en: So breaking elliptic curve cryptography is not going to be a reality any time
    soon.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have discussed what quantum computing is and what effect it can have
  prefs: []
  type: TYPE_NORMAL
- en: on classical computing. We also covered some applications of quantum computing
  prefs: []
  type: TYPE_NORMAL
- en: 'and relevant technical details such as gates and circuits. One thing is clear:
    quantum'
  prefs: []
  type: TYPE_NORMAL
- en: computing is going to revolutionize the world soon, and a tremendous effort
    is already
  prefs: []
  type: TYPE_NORMAL
- en: being put into making the technology grow and become mainstream.
  prefs: []
  type: TYPE_NORMAL
- en: With all this revolutionary advancement in quantum computing, a natural question
  prefs: []
  type: TYPE_NORMAL
- en: arises whether it is possible to harness this power and apply it to solve distributed
  prefs: []
  type: TYPE_NORMAL
- en: computing problems, especially the consensus problem. Can we make consensus
    faster,
  prefs: []
  type: TYPE_NORMAL
- en: can we circumvent FLP in some novel way, or does FLP even apply in the quantum
  prefs: []
  type: TYPE_NORMAL
- en: world? Is there a quantum solution for the Byzantine generals problem? How can
  prefs: []
  type: TYPE_NORMAL
- en: quantum computing help in distributed systems? Can it increase its efficiency?
    Can
  prefs: []
  type: TYPE_NORMAL
- en: quantum consensus tolerate any number of dishonest parties, and no usual lower
  prefs: []
  type: TYPE_NORMAL
- en: bounds apply? Can blockchains benefit from this advancement and improve blockchain
  prefs: []
  type: TYPE_NORMAL
- en: consensus and other aspects of blockchains, such as cryptography, security,
    efficiency,
  prefs: []
  type: TYPE_NORMAL
- en: and scalability? We answer these questions in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 3 [https://doi.org/10.1116/5.0073075](https://doi.org/10.1116/5.0073075)
  prefs: []
  type: TYPE_NORMAL
- en: '397'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9 Quantum Consensus
  prefs: []
  type: TYPE_NORMAL
- en: '**Quantum Consensus**'
  prefs: []
  type: TYPE_NORMAL
- en: Quantum consensus drives a quantum network with some qubits to a symmetric state.
  prefs: []
  type: TYPE_NORMAL
- en: Also, with the advent of quantum computing, the problems from the classical
    computing
  prefs: []
  type: TYPE_NORMAL
- en: world are being studied through the lens of quantum computing to see if there
    are any
  prefs: []
  type: TYPE_NORMAL
- en: improvements that can be made to the existing algorithms from the classical
    world by
  prefs: []
  type: TYPE_NORMAL
- en: harnessing the quantum power. One such problem is distributed consensus from
    the
  prefs: []
  type: TYPE_NORMAL
- en: classical computing/networking world, which we have studied throughout this
    book.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll study the agreement/consensus in quantum distributed systems and the impact
    of
  prefs: []
  type: TYPE_NORMAL
- en: quantum computing on classical distributed systems, especially consensus. It
    has been
  prefs: []
  type: TYPE_NORMAL
- en: shown that the classical distributed consensus problem when studied under a
    quantum
  prefs: []
  type: TYPE_NORMAL
- en: framework results in enhancing the classical results and can also solve problems
    which
  prefs: []
  type: TYPE_NORMAL
- en: are otherwise unsolvable in classical networks.
  prefs: []
  type: TYPE_NORMAL
- en: Also, in quantum networks, reaching an agreement is required in many cases;
    thus,
  prefs: []
  type: TYPE_NORMAL
- en: pure quantum consensus for quantum networks and quantum Internet is also an
    area of
  prefs: []
  type: TYPE_NORMAL
- en: interest.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll focus more on enhancement of classical results rather
    than
  prefs: []
  type: TYPE_NORMAL
- en: pure quantum consensus where a quantum network with some qubits is brought to
  prefs: []
  type: TYPE_NORMAL
- en: consensus, that is, in a symmetric state. Classical result enhancement is more
    relevant to our study of consensus in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Quantum consensus algorithms are a very active area of research. There are four
  prefs: []
  type: TYPE_NORMAL
- en: 'categories that have emerged in this context:'
  prefs: []
  type: TYPE_NORMAL
- en: • Symmetric state consensus
  prefs: []
  type: TYPE_NORMAL
- en: • Entanglement-based consensus
  prefs: []
  type: TYPE_NORMAL
- en: • Measurement-based consensus
  prefs: []
  type: TYPE_NORMAL
- en: • Quantum key distribution (QKD)–based consensus
  prefs: []
  type: TYPE_NORMAL
- en: Symmetric state consensus refers to the convergence of arbitrary states of quantum
  prefs: []
  type: TYPE_NORMAL
- en: nodes in a quantum network to a consensus symmetric state.
  prefs: []
  type: TYPE_NORMAL
- en: Entanglement-based consensus is more relevant to the classical consensus
  prefs: []
  type: TYPE_NORMAL
- en: problem. This is so because classical consensus has been investigated through
    the lens
  prefs: []
  type: TYPE_NORMAL
- en: of quantum computing. The key idea here is that quantum properties can enhance
    the
  prefs: []
  type: TYPE_NORMAL
- en: classical consensus and can solve problems which were understood to be unsolvable
    in
  prefs: []
  type: TYPE_NORMAL
- en: the classical consensus world.
  prefs: []
  type: TYPE_NORMAL
- en: '398'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9 Quantum Consensus
  prefs: []
  type: TYPE_NORMAL
- en: Measurement-based consensus works on the premise that when a measurement is
  prefs: []
  type: TYPE_NORMAL
- en: made on a quantum state, it collapses to a classical state, 0 or 1\. Such a
    mechanism can
  prefs: []
  type: TYPE_NORMAL
- en: be useful in quantum hybrid networks with quantum nodes but classical channels.
    The
  prefs: []
  type: TYPE_NORMAL
- en: quantum state is kept in quantum computers, whereas the classical channels are
    used
  prefs: []
  type: TYPE_NORMAL
- en: for communication to reach consensus. The aim is to allow convergence of quantum
  prefs: []
  type: TYPE_NORMAL
- en: nodes to a common state in a hybrid quantum–classical network.
  prefs: []
  type: TYPE_NORMAL
- en: QKD-based consensus has been proposed to solve the Byzantine agreement
  prefs: []
  type: TYPE_NORMAL
- en: problem between multiple nodes without entanglement. The unconditional security
  prefs: []
  type: TYPE_NORMAL
- en: property of QKD is fundamental to this type of consensus.
  prefs: []
  type: TYPE_NORMAL
- en: Participants in a classical distributed system, including permissioned blockchains,
  prefs: []
  type: TYPE_NORMAL
- en: are inherently slow to achieve consensus due to high time complexity incurred
    by the
  prefs: []
  type: TYPE_NORMAL
- en: use of classical protocols like PBFT, three-phase commit, or Paxos. Usually,
    the time
  prefs: []
  type: TYPE_NORMAL
- en: complexity of these consensus algorithms is *O*( *n* 2), that is, quadratic.
    Is it possible to significantly reduce time complexity of classical distributed/blockchain
    consensus by
  prefs: []
  type: TYPE_NORMAL
- en: using quantum computing? The short answer is yes. Ben-Or and Hassidim proposed
    a
  prefs: []
  type: TYPE_NORMAL
- en: fast quantum Byzantine agreement which resolves consensus in *O*(1) time complexity.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we introduce some consensus and agreement algorithms that
  prefs: []
  type: TYPE_NORMAL
- en: have been introduced in the literature, which due to quantum properties significantly
  prefs: []
  type: TYPE_NORMAL
- en: improve classical results or provide novel algorithms for consensus and relevant
  prefs: []
  type: TYPE_NORMAL
- en: problems in the quantum world.
  prefs: []
  type: TYPE_NORMAL
- en: '**Fast Quantum Byzantine Agreement**'
  prefs: []
  type: TYPE_NORMAL
- en: Michael Ben-Or and Avinatan Hassidim introduced the fast quantum Byzantine
  prefs: []
  type: TYPE_NORMAL
- en: agreement protocol which reaches an agreement in *O*(1) expected communication
  prefs: []
  type: TYPE_NORMAL
- en: 'rounds. There are two results presented in the paper:'
  prefs: []
  type: TYPE_NORMAL
- en: • A quantum protocol for synchronous consensus which tolerates
  prefs: []
  type: TYPE_NORMAL
- en: t<n/3 faults and acts in an expected constant number of rounds. The
  prefs: []
  type: TYPE_NORMAL
- en: adversary is fail-stop, adaptive, full information, and computationally
  prefs: []
  type: TYPE_NORMAL
- en: unbounded.
  prefs: []
  type: TYPE_NORMAL
- en: • A quantum protocol for a synchronous Byzantine agreement
  prefs: []
  type: TYPE_NORMAL
- en: tolerating t < n/3 faulty actors in an expected constant number of
  prefs: []
  type: TYPE_NORMAL
- en: rounds. The adversary model is an adaptive, full information, and
  prefs: []
  type: TYPE_NORMAL
- en: computationally unbounded adversary.
  prefs: []
  type: TYPE_NORMAL
- en: '399'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9 Quantum Consensus
  prefs: []
  type: TYPE_NORMAL
- en: The system model comprises of *n* nodes, and each pair of nodes is connected
  prefs: []
  type: TYPE_NORMAL
- en: through a separate two-way quantum channel. The protocol works in rounds, and
    each
  prefs: []
  type: TYPE_NORMAL
- en: round has two phases. In the first phase, all processors send and receive messages,
  prefs: []
  type: TYPE_NORMAL
- en: and the second phase is the computation phase where nodes do local computation
    to
  prefs: []
  type: TYPE_NORMAL
- en: process received messages and decide what messages to send.
  prefs: []
  type: TYPE_NORMAL
- en: 'The protocol satisfies the following conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: '• **Agreement**: All nonfaulty processors decide on the same value with'
  prefs: []
  type: TYPE_NORMAL
- en: probability 1\.
  prefs: []
  type: TYPE_NORMAL
- en: '• **Validity**: The decided value is the input value of all processors.'
  prefs: []
  type: TYPE_NORMAL
- en: '• **Termination**: All nonfaulty processes decide on a value with'
  prefs: []
  type: TYPE_NORMAL
- en: probability 1\.
  prefs: []
  type: TYPE_NORMAL
- en: Remember we discussed coin flip randomized protocols earlier in Chapter [6](https://doi.org/10.1007/978-1-4842-8179-6_6).
  prefs: []
  type: TYPE_NORMAL
- en: Especially, we discussed Ben-Or’s algorithm where coin flipping was used to
    achieve
  prefs: []
  type: TYPE_NORMAL
- en: an agreement. Fundamentally, the agreement problem is reduced to weak global
    coin
  prefs: []
  type: TYPE_NORMAL
- en: flipping.
  prefs: []
  type: TYPE_NORMAL
- en: The idea in the quantum world is that instead of obtaining a weak global coin
    by
  prefs: []
  type: TYPE_NORMAL
- en: classical means, we use quantum techniques to obtain a weak global coin. With
    this
  prefs: []
  type: TYPE_NORMAL
- en: quantum technique, it is possible to tolerate Byzantine failures under synchrony
    if *n* > 3 *t* in *O*(1) expected rounds. Consensus however is still impossible
    if *n* < 3 *t*, but there’s an improvement of achieving *O*(1) rounds.
  prefs: []
  type: TYPE_NORMAL
- en: In an asynchronous model, a quantum algorithm exists if >3 *t*; however, it
    is
  prefs: []
  type: TYPE_NORMAL
- en: impossible if *n* < 3 *t*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The protocol for fail-stop faults works as described in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: ( *C* represents a coin, *L* represents a leader, and the state is GHZ.)
  prefs: []
  type: TYPE_NORMAL
- en: GHZ state is
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: '| *GHZ* 〉 ='
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 〉
  prefs: []
  type: TYPE_NORMAL
- en: 000 +
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 〉
  prefs: []
  type: TYPE_NORMAL
- en: '111'
  prefs: []
  type: TYPE_NORMAL
- en: √ 2
  prefs: []
  type: TYPE_NORMAL
- en: √ 2
  prefs: []
  type: TYPE_NORMAL
- en: 'Each process *Pi* runs:'
  prefs: []
  type: TYPE_NORMAL
- en: Round 1
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Generate the state | *C* 〉 =
  prefs: []
  type: TYPE_NORMAL
- en: '| ,'
  prefs: []
  type: TYPE_NORMAL
- en: 0 ,
  prefs: []
  type: TYPE_NORMAL
- en: 0 … 〉
  prefs: []
  type: TYPE_NORMAL
- en: 0 +
  prefs: []
  type: TYPE_NORMAL
- en: '| ,'
  prefs: []
  type: TYPE_NORMAL
- en: 1 ,
  prefs: []
  type: TYPE_NORMAL
- en: 1 … 〉
  prefs: []
  type: TYPE_NORMAL
- en: '*i*'
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: √
  prefs: []
  type: TYPE_NORMAL
- en: on *n* qubit.
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: √ 2
  prefs: []
  type: TYPE_NORMAL
- en: a. Send the *k th* qubit to the *k th* player while keeping one part to yourself.
  prefs: []
  type: TYPE_NORMAL
- en: '400'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9 Quantum Consensus
  prefs: []
  type: TYPE_NORMAL
- en: 3/
  prefs: []
  type: TYPE_NORMAL
- en: '*n* 2'
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Generate the state | *L* 〉 =
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 3 2 ∑
  prefs: []
  type: TYPE_NORMAL
- en: … 〉
  prefs: []
  type: TYPE_NORMAL
- en: '*i*'
  prefs: []
  type: TYPE_NORMAL
- en: '*a*, *a*, *a*'
  prefs: []
  type: TYPE_NORMAL
- en: /
  prefs: []
  type: TYPE_NORMAL
- en: '*n*'
  prefs: []
  type: TYPE_NORMAL
- en: on *n* qubits, an equal
  prefs: []
  type: TYPE_NORMAL
- en: '*a*=1'
  prefs: []
  type: TYPE_NORMAL
- en: superposition of the numbers from 1 to *n* 3/2\.
  prefs: []
  type: TYPE_NORMAL
- en: a. Distribute *n* qubits among all processes.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Receive the quantum message from all processes.
  prefs: []
  type: TYPE_NORMAL
- en: Round 2
  prefs: []
  type: TYPE_NORMAL
- en: 4\. Measure all *Lj* qubits received in round 1\.
  prefs: []
  type: TYPE_NORMAL
- en: 5\. Select the process which has the highest leader value as the leader
  prefs: []
  type: TYPE_NORMAL
- en: of the round.
  prefs: []
  type: TYPE_NORMAL
- en: 6\. Measure the leader’s coin in the standard base.
  prefs: []
  type: TYPE_NORMAL
- en: 7\. Obtain the measurement outcome of the leader’s coin which
  prefs: []
  type: TYPE_NORMAL
- en: serves as the global coin.
  prefs: []
  type: TYPE_NORMAL
- en: Using this algorithm, a weak global coin is obtained. The probability for either
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: common outcome is at least if 3 *t* < *n*. The protocol works for crash faults.
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: Another protocol for Byzantine faults is presented in the paper, which can tolerate
    up
  prefs: []
  type: TYPE_NORMAL
- en: to *t n*
  prefs: []
  type: TYPE_NORMAL
- en: < faulty nodes under an asynchronous environment.
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: '**How to Refute FLP Impossibility**'
  prefs: []
  type: TYPE_NORMAL
- en: An interesting claim is made in [by Louie Helm] that distributed consensus can
    be
  prefs: []
  type: TYPE_NORMAL
- en: achieved under asynchrony even in the presence of faults, which appears to contradict
  prefs: []
  type: TYPE_NORMAL
- en: FLP impossibility.
  prefs: []
  type: TYPE_NORMAL
- en: Helm proposed a protocol for solving consensus using quantum techniques. At
    a
  prefs: []
  type: TYPE_NORMAL
- en: 'high level, the protocol works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: • Entangled qubits are distributed to all nodes.
  prefs: []
  type: TYPE_NORMAL
- en: • Each node measures its qubit(s).
  prefs: []
  type: TYPE_NORMAL
- en: • Finally, due to measurement, the superposed quantum state will
  prefs: []
  type: TYPE_NORMAL
- en: collapse, which leads to consensus.
  prefs: []
  type: TYPE_NORMAL
- en: '401'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9 Quantum Consensus
  prefs: []
  type: TYPE_NORMAL
- en: This is so because the quantum entanglement here guarantees that entangled qubits
  prefs: []
  type: TYPE_NORMAL
- en: collapse to the same state. This means that all nodes will end up with the same
    state,
  prefs: []
  type: TYPE_NORMAL
- en: which means an agreement.
  prefs: []
  type: TYPE_NORMAL
- en: The GHZ state is used to realize this scheme. The key assumption made here is
    that
  prefs: []
  type: TYPE_NORMAL
- en: each node receives a qubit during the setup phase and then later measures it,
    which
  prefs: []
  type: TYPE_NORMAL
- en: results in the same collapsed state at all nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The algorithm works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Prepare the GHZ state via entanglement of a set of n qubits.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Distribute a single qubit from the set of superposed qubits to each
  prefs: []
  type: TYPE_NORMAL
- en: node in the network. This step distributes a shared state between
  prefs: []
  type: TYPE_NORMAL
- en: all nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Each node measures their qubit. Note there is no decision yet at
  prefs: []
  type: TYPE_NORMAL
- en: this stage.
  prefs: []
  type: TYPE_NORMAL
- en: 4\. If qubit measurement is ∣0⟩, choose 0\. Choose 1 if qubit
  prefs: []
  type: TYPE_NORMAL
- en: measurement is ∣1⟩. This is where the quantum benefit is realized.
  prefs: []
  type: TYPE_NORMAL
- en: When the measurement is made on a node, its quantum state will
  prefs: []
  type: TYPE_NORMAL
- en: collapse to either ∣0⟩ or ∣1⟩, with equal probability. Also, with the
  prefs: []
  type: TYPE_NORMAL
- en: first measurement on a node, the state of all other nodes will also
  prefs: []
  type: TYPE_NORMAL
- en: collapse simultaneously and instantaneously to the exact same
  prefs: []
  type: TYPE_NORMAL
- en: value as the first node that did the measurement. This is possible
  prefs: []
  type: TYPE_NORMAL
- en: because of entanglement and thus strong correlation between
  prefs: []
  type: TYPE_NORMAL
- en: qubits. Now as all nodes have the exact same value, this scheme
  prefs: []
  type: TYPE_NORMAL
- en: achieves consensus.
  prefs: []
  type: TYPE_NORMAL
- en: An agreement is provided simply because measuring any single full entangled
    qubit
  prefs: []
  type: TYPE_NORMAL
- en: in the GHZ state causes all other qubits in the same GHZ state to collapse to
    the same
  prefs: []
  type: TYPE_NORMAL
- en: basis state. Validity is achieved because when the measurement is made on the
    first
  prefs: []
  type: TYPE_NORMAL
- en: node, it’s effectively proposing either a ∣0⟩ or ∣1⟩.
  prefs: []
  type: TYPE_NORMAL
- en: This protocol can tolerate network delays because even if a qubit arrives late
    on a
  prefs: []
  type: TYPE_NORMAL
- en: quantum node, the other nodes will keep working without any impact. When the
    late
  prefs: []
  type: TYPE_NORMAL
- en: qubit arrives at any time, it will already contain the agreed-upon value, again
    due to
  prefs: []
  type: TYPE_NORMAL
- en: entanglement. The fundamental reason why FLP can be refuted using this algorithm
    is
  prefs: []
  type: TYPE_NORMAL
- en: because it requires one-way broadcast, and no classical response is required.
    Even if a
  prefs: []
  type: TYPE_NORMAL
- en: single process does not measure its qubit, it will not impact the overall outcome
    of the
  prefs: []
  type: TYPE_NORMAL
- en: computation, that is, even if that single measurement is not available, the
    other correct 402
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9 Quantum Consensus
  prefs: []
  type: TYPE_NORMAL
- en: nodes will continue to operate even if one qubit is missing. This algorithm
    will work if
  prefs: []
  type: TYPE_NORMAL
- en: the distribution of the original GHZ state completes successfully. Once that’s
    complete,
  prefs: []
  type: TYPE_NORMAL
- en: missing measurements won’t impact the protocol from there onward. In case of
  prefs: []
  type: TYPE_NORMAL
- en: Byzantine faults, the algorithm is also resilient. Any malicious party cannot
    tamper with the value the algorithm will eventually choose. This is so because
    any measurement does
  prefs: []
  type: TYPE_NORMAL
- en: not impact the correlation of other qubits in the system. This means that any
    adversary
  prefs: []
  type: TYPE_NORMAL
- en: measuring the qubits cannot impact the final chosen value. Due to the quantum
    nature,
  prefs: []
  type: TYPE_NORMAL
- en: the qubit will always end up as 0 or 1\. This always means that the decision
    will eventually be made regardless of Byzantine faults. This achieves termination.
  prefs: []
  type: TYPE_NORMAL
- en: '**Enhanced Distributed Consensus**'
  prefs: []
  type: TYPE_NORMAL
- en: Seet and Griffin proposed how quantum computing can speed up an agreement on
    a
  prefs: []
  type: TYPE_NORMAL
- en: distributed network. They proposed a novel quantum consensus mechanism. The
    work
  prefs: []
  type: TYPE_NORMAL
- en: presented in the paper focuses on the scalability and speed of distributed consensus.
  prefs: []
  type: TYPE_NORMAL
- en: By removing the need for multicast replies, the consensus speed and scalability
  prefs: []
  type: TYPE_NORMAL
- en: is accomplished. Moreover, using quantum properties, it is ensured that only
    a single
  prefs: []
  type: TYPE_NORMAL
- en: multicast is required. The key idea for achieving consensus is to aggregate
    the wave
  prefs: []
  type: TYPE_NORMAL
- en: function of the received qubits (from other nodes) and local qubits of a quantum
    node.
  prefs: []
  type: TYPE_NORMAL
- en: 'The scheme works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: –
  prefs: []
  type: TYPE_NORMAL
- en: The network is composed of quantum computers, communication
  prefs: []
  type: TYPE_NORMAL
- en: channels, and classical computers. The channels can be quantum to
  prefs: []
  type: TYPE_NORMAL
- en: quantum, classical-quantum, and between classical computers.
  prefs: []
  type: TYPE_NORMAL
- en: –
  prefs: []
  type: TYPE_NORMAL
- en: Each quantum computer is connected with a classical computer for
  prefs: []
  type: TYPE_NORMAL
- en: storage and data retrieval.
  prefs: []
  type: TYPE_NORMAL
- en: –
  prefs: []
  type: TYPE_NORMAL
- en: A quantum computer creates an entangled qubit of each qubit.
  prefs: []
  type: TYPE_NORMAL
- en: –
  prefs: []
  type: TYPE_NORMAL
- en: Send the duplicates to other nodes in the system.
  prefs: []
  type: TYPE_NORMAL
- en: –
  prefs: []
  type: TYPE_NORMAL
- en: Consensus to be determined via the sum of each qubit wave function.
  prefs: []
  type: TYPE_NORMAL
- en: –
  prefs: []
  type: TYPE_NORMAL
- en: The qubits can be measured directly from within the quantum
  prefs: []
  type: TYPE_NORMAL
- en: computer to calculate the wave function of each qubit. The idea
  prefs: []
  type: TYPE_NORMAL
- en: revolves around the assumption that the wave function of each qubit
  prefs: []
  type: TYPE_NORMAL
- en: should be similar to each other. Here, the expectation is that the
  prefs: []
  type: TYPE_NORMAL
- en: values obtained should be consistent with each other.
  prefs: []
  type: TYPE_NORMAL
- en: '403'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9 Quantum Consensus
  prefs: []
  type: TYPE_NORMAL
- en: –
  prefs: []
  type: TYPE_NORMAL
- en: Relying on the superposition, these wavelengths of qubits are a scalar
  prefs: []
  type: TYPE_NORMAL
- en: multiple, that is, *nψ*, where *n* is the number of nodes participating in
  prefs: []
  type: TYPE_NORMAL
- en: consensus.
  prefs: []
  type: TYPE_NORMAL
- en: –
  prefs: []
  type: TYPE_NORMAL
- en: The technique here is to determine the difference between an ideal
  prefs: []
  type: TYPE_NORMAL
- en: and actual system state wave function.
  prefs: []
  type: TYPE_NORMAL
- en: –
  prefs: []
  type: TYPE_NORMAL
- en: If all quantum nodes participating in the consensus have a consistent
  prefs: []
  type: TYPE_NORMAL
- en: state, then a randomly selected result would be consistent with any
  prefs: []
  type: TYPE_NORMAL
- en: other node’s state. This can be compared against the actual system
  prefs: []
  type: TYPE_NORMAL
- en: state wave function.
  prefs: []
  type: TYPE_NORMAL
- en: –
  prefs: []
  type: TYPE_NORMAL
- en: If the same state exists on all quantum nodes, each individual node’s
  prefs: []
  type: TYPE_NORMAL
- en: wave function is a scalar multiple of the system’s state wave function.
  prefs: []
  type: TYPE_NORMAL
- en: The wave function then outputs zero.
  prefs: []
  type: TYPE_NORMAL
- en: –
  prefs: []
  type: TYPE_NORMAL
- en: In case of any different state on a node, then that node’s wave func-
  prefs: []
  type: TYPE_NORMAL
- en: tion will not be a scalar multiple of the entire system’s state function.
  prefs: []
  type: TYPE_NORMAL
- en: So, the difference between the system state wave function and the
  prefs: []
  type: TYPE_NORMAL
- en: node’s state wave function is not zero, indicating the discrepancy.
  prefs: []
  type: TYPE_NORMAL
- en: The difference increases as the discrepancy between the node’s state
  prefs: []
  type: TYPE_NORMAL
- en: and system state grows. The level of fault tolerance can be deter-
  prefs: []
  type: TYPE_NORMAL
- en: mined if the difference does not fall below a certain threshold. This
  prefs: []
  type: TYPE_NORMAL
- en: could be a percentage of the total system, in line with classical BFT
  prefs: []
  type: TYPE_NORMAL
- en: where roughly 33% of the nodes can be faulty in a network. It is
  prefs: []
  type: TYPE_NORMAL
- en: possible to apply similar thresholds here too, though not proven.
  prefs: []
  type: TYPE_NORMAL
- en: –
  prefs: []
  type: TYPE_NORMAL
- en: The consensus algorithm multiplies a randomly chosen wave func-
  prefs: []
  type: TYPE_NORMAL
- en: tion with the number of nodes in the system.
  prefs: []
  type: TYPE_NORMAL
- en: –
  prefs: []
  type: TYPE_NORMAL
- en: It subtracts the sum of wave functions of each qubit in the system.
  prefs: []
  type: TYPE_NORMAL
- en: –
  prefs: []
  type: TYPE_NORMAL
- en: If all wave functions are the same, then the expected result is zero,
  prefs: []
  type: TYPE_NORMAL
- en: indicating a coherent system. Otherwise, the system is not coherent.
  prefs: []
  type: TYPE_NORMAL
- en: The larger the difference, the more incoherent the system is.
  prefs: []
  type: TYPE_NORMAL
- en: In the paper, this algorithm is expanded to a multiqubit system. Also, several
  prefs: []
  type: TYPE_NORMAL
- en: improvements over the classical model are achieved such as reducing the time
  prefs: []
  type: TYPE_NORMAL
- en: complexity of state verification by half. This is achieved by utilizing entanglement
  prefs: []
  type: TYPE_NORMAL
- en: where the verifier only needs to receive the entangled qubit, after which verification
  prefs: []
  type: TYPE_NORMAL
- en: '404'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9 Quantum Consensus
  prefs: []
  type: TYPE_NORMAL
- en: can be done locally, by comparing the state of all qubits. This contrasts with
    a classical high complexity request-response style of message passing, which increases
    time and
  prefs: []
  type: TYPE_NORMAL
- en: communication complexity. With quantum properties, this complexity is reduced,
    and
  prefs: []
  type: TYPE_NORMAL
- en: consensus can be reached in half the time as compared to the classical consensus.
    Such
  prefs: []
  type: TYPE_NORMAL
- en: efficiency gains can be utilized in blockchains to increase scalability. Moreover,
    any
  prefs: []
  type: TYPE_NORMAL
- en: attempt of manipulation of the original and the sent state in isolation is immediately
  prefs: []
  type: TYPE_NORMAL
- en: detectable due to entanglement, thus resulting in increased security of the
    system.
  prefs: []
  type: TYPE_NORMAL
- en: The paper also proposes several scalability, privacy, and performance enhancements
  prefs: []
  type: TYPE_NORMAL
- en: addressing the blockchain trilemma.
  prefs: []
  type: TYPE_NORMAL
- en: '**Quantum Leader Election and Consensus**'
  prefs: []
  type: TYPE_NORMAL
- en: Ellie D’Hondt and Prakash Panangaden presented a quantum solution for a totally
  prefs: []
  type: TYPE_NORMAL
- en: correct leader election in quantum networks, which is considered difficult in
    the
  prefs: []
  type: TYPE_NORMAL
- en: classical world.
  prefs: []
  type: TYPE_NORMAL
- en: For electing a leader using quantum properties, the use of the W state is proposed.
    In
  prefs: []
  type: TYPE_NORMAL
- en: an anonymous network, if quantum nodes share the W state the leader election
    problem
  prefs: []
  type: TYPE_NORMAL
- en: can be solved trivially.
  prefs: []
  type: TYPE_NORMAL
- en: Remember we discussed the W state earlier. For example, the entangled W state
    of
  prefs: []
  type: TYPE_NORMAL
- en: three qubits is
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: '| *W* 〉 ='
  prefs: []
  type: TYPE_NORMAL
- en: ( 〉+
  prefs: []
  type: TYPE_NORMAL
- en: 001 |
  prefs: []
  type: TYPE_NORMAL
- en: 〉+
  prefs: []
  type: TYPE_NORMAL
- en: 010 |
  prefs: []
  type: TYPE_NORMAL
- en: 〉
  prefs: []
  type: TYPE_NORMAL
- en: 100 )
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: This is used as a symmetry breaking quantum resource. The quantum leader
  prefs: []
  type: TYPE_NORMAL
- en: election algorithm for each process *i* then simply is
  prefs: []
  type: TYPE_NORMAL
- en: 1\. q = ith qubit from the entangled W-state i.e., from a
  prefs: []
  type: TYPE_NORMAL
- en: quantum process i
  prefs: []
  type: TYPE_NORMAL
- en: 2\. initialize b = 0 and result = wait
  prefs: []
  type: TYPE_NORMAL
- en: 3\. b = measurement of q
  prefs: []
  type: TYPE_NORMAL
- en: 4\. if b = 1 then result = leader, else result = follower
  prefs: []
  type: TYPE_NORMAL
- en: '405'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9 Quantum Consensus
  prefs: []
  type: TYPE_NORMAL
- en: This protocol has time complexity of *O*(1), that is, constant, and there is
    no message passing required. This is in complete contrast with the classical world
    where multiround
  prefs: []
  type: TYPE_NORMAL
- en: protocols with higher complexity are usually common. This quantum protocol works
    in
  prefs: []
  type: TYPE_NORMAL
- en: asynchronous networks too.
  prefs: []
  type: TYPE_NORMAL
- en: Also, a simple algorithm for consensus is presented. Leader election was based
    on
  prefs: []
  type: TYPE_NORMAL
- en: symmetry breaking; however, this algorithm is dependent on symmetry preservation.
  prefs: []
  type: TYPE_NORMAL
- en: The idea is that to achieve totally correct anonymous quantum distributed consensus
  prefs: []
  type: TYPE_NORMAL
- en: where each process has one qubit initially, the processors are required to be
    entangled in a GHZ state. It is shown that not only is it necessary but also a
    sufficient condition.
  prefs: []
  type: TYPE_NORMAL
- en: The core idea of the protocol is to share the GHZ entangled state between all
    nodes
  prefs: []
  type: TYPE_NORMAL
- en: participating in the consensus. This allows to create symmetry in one step.
  prefs: []
  type: TYPE_NORMAL
- en: The GHZ state for three qubits is given as
  prefs: []
  type: TYPE_NORMAL
- en: (| 〉+
  prefs: []
  type: TYPE_NORMAL
- en: 000 |
  prefs: []
  type: TYPE_NORMAL
- en: 〉
  prefs: []
  type: TYPE_NORMAL
- en: 111 )
  prefs: []
  type: TYPE_NORMAL
- en: '| *GHZ* 〉 ='
  prefs: []
  type: TYPE_NORMAL
- en: √ 2
  prefs: []
  type: TYPE_NORMAL
- en: Each process *i* runs
  prefs: []
  type: TYPE_NORMAL
- en: q = ith qubit of GHZ state among n processes
  prefs: []
  type: TYPE_NORMAL
- en: result= wait
  prefs: []
  type: TYPE_NORMAL
- en: result = measure q
  prefs: []
  type: TYPE_NORMAL
- en: Again, this protocol has time complexity of *O*(1), and no message passing is
    needed.
  prefs: []
  type: TYPE_NORMAL
- en: This protocol works under different communication topologies and under asynchrony.
  prefs: []
  type: TYPE_NORMAL
- en: The result in the paper shows that GHZ for consensus is necessary and sufficient.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, W is necessary and sufficient for leader election.
  prefs: []
  type: TYPE_NORMAL
- en: '**Other Algorithms**'
  prefs: []
  type: TYPE_NORMAL
- en: There is a wide range of quantum consensus algorithms and relevant proposals.
    It’s not
  prefs: []
  type: TYPE_NORMAL
- en: possible to cover them all here in detail; however, this section summarizes
    some of the
  prefs: []
  type: TYPE_NORMAL
- en: prominent results.
  prefs: []
  type: TYPE_NORMAL
- en: Luca Mazzarella, Alain Sarlette, and Francesco Ticozzi in “Consensus for Quantum
  prefs: []
  type: TYPE_NORMAL
- en: 'Networks: From Symmetry to Gossip Iterations” extend the classical distributed'
  prefs: []
  type: TYPE_NORMAL
- en: computing problem to networks of quantum systems. They proposed a general
  prefs: []
  type: TYPE_NORMAL
- en: framework to study the consensus problem in the quantum world. Also, a quantum
  prefs: []
  type: TYPE_NORMAL
- en: gossip–style algorithm is presented in the paper.
  prefs: []
  type: TYPE_NORMAL
- en: '406'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9 Quantum Consensus
  prefs: []
  type: TYPE_NORMAL
- en: “Reaching Agreement in Quantum Hybrid Networks” is proposed by Guodong Shi,
  prefs: []
  type: TYPE_NORMAL
- en: Bo Li, Zibo Miao, Peter M. Dower, and Matthew R. James. The problem considered
    in
  prefs: []
  type: TYPE_NORMAL
- en: the paper is to drive a quantum hybrid network composed of quantum nodes holding
  prefs: []
  type: TYPE_NORMAL
- en: qubits to a common state, thus achieving consensus. The key idea is that quantum
    nodes
  prefs: []
  type: TYPE_NORMAL
- en: measure the qubits, and the results of the measurement are exchanged through
    classical
  prefs: []
  type: TYPE_NORMAL
- en: communication links.
  prefs: []
  type: TYPE_NORMAL
- en: It has been shown that the classical Byzantine generals problem is unsolvable
    even if
  prefs: []
  type: TYPE_NORMAL
- en: pairwise quantum channels are used. However, a variation of the Byzantine agreement
  prefs: []
  type: TYPE_NORMAL
- en: problem called the **detectable Byzantine agreement** (DBA) can be solved by
    using
  prefs: []
  type: TYPE_NORMAL
- en: quantum properties. The DBA protocol ensures that either all generals agree
    on an order
  prefs: []
  type: TYPE_NORMAL
- en: or all abort, that is, the agreement property, and if all generals are loyal,
    they agree on an order, that is, validity.
  prefs: []
  type: TYPE_NORMAL
- en: “Multi-party Quantum Byzantine Agreement Without Entanglement” is proposed
  prefs: []
  type: TYPE_NORMAL
- en: by Xin Sun, Piotr Kulicki, and Mirek Sopek. Usually, an entanglement property
    is used in
  prefs: []
  type: TYPE_NORMAL
- en: the quantum consensus algorithm. But this algorithm is different where entanglement
    is
  prefs: []
  type: TYPE_NORMAL
- en: not used. Instead, the protocol relies on quantum key distribution and its unconditional
  prefs: []
  type: TYPE_NORMAL
- en: security. The protocol relies on sequences of correlated numbers shared between
  prefs: []
  type: TYPE_NORMAL
- en: semihonest quantum key distributors.
  prefs: []
  type: TYPE_NORMAL
- en: There are other proposals where a concept of the quantum blockchain using
  prefs: []
  type: TYPE_NORMAL
- en: temporal GHZ is introduced.
  prefs: []
  type: TYPE_NORMAL
- en: There are quite a few innovative results regarding quantum consensus, and
  prefs: []
  type: TYPE_NORMAL
- en: researchers are presenting more and more developments. We introduced some of
    these
  prefs: []
  type: TYPE_NORMAL
- en: results earlier. The quantum algorithms that can enhance classical distributed
    consensus
  prefs: []
  type: TYPE_NORMAL
- en: results are of particular importance as they can impact classical distributed
    systems in
  prefs: []
  type: TYPE_NORMAL
- en: the near future. Other pure quantum results are also fascinating but will be
    fully useful only in the future when quantum Internet and relevant quantum ecosystems
    become a
  prefs: []
  type: TYPE_NORMAL
- en: reality.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs: []
  type: TYPE_NORMAL
- en: As quantum computing is a vast and deep subject, we have not covered everything.
    Still,
  prefs: []
  type: TYPE_NORMAL
- en: this chapter should give us a good understanding of quantum computing and how
    it can
  prefs: []
  type: TYPE_NORMAL
- en: benefit distributed systems and consensus. Moore’s law has almost come to an
    end, so
  prefs: []
  type: TYPE_NORMAL
- en: with quantum computing, we can reinvigorate it. In computer science, more complexity
  prefs: []
  type: TYPE_NORMAL
- en: '407'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9 Quantum Consensus
  prefs: []
  type: TYPE_NORMAL
- en: classes are emerging due to quantum computing. For physicists, the interest
    is to
  prefs: []
  type: TYPE_NORMAL
- en: understand more about quantum theory.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter gives us an intuition to think more deeply and prepare ourselves
  prefs: []
  type: TYPE_NORMAL
- en: for further research and exploration. The main point to remember is that largely
  prefs: []
  type: TYPE_NORMAL
- en: quantum consensus mechanisms exploit the quantum properties of superposition
    and
  prefs: []
  type: TYPE_NORMAL
- en: entanglement.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we conclude all ideas presented in this book and some exotic
  prefs: []
  type: TYPE_NORMAL
- en: ideas and future research directions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Bibliography**'
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Rohde, P.P., 2021\. The Quantum Internet: The Second Quantum'
  prefs: []
  type: TYPE_NORMAL
- en: Revolution. Cambridge University Press.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Cuomo, D., Caleffi, M., and Cacciapuoti, A.S., 2020\. Towards
  prefs: []
  type: TYPE_NORMAL
- en: a distributed quantum computing ecosystem. *IET Quantum*
  prefs: []
  type: TYPE_NORMAL
- en: '*Communication*, *1*(1), pp. 3–8\.'
  prefs: []
  type: TYPE_NORMAL
- en: 3\. LaPierre, R., 2021\. Quantum Gates. In *Introduction to Quantum*
  prefs: []
  type: TYPE_NORMAL
- en: '*Computing* (pp. 101–125). Springer, Cham.'
  prefs: []
  type: TYPE_NORMAL
- en: 4\. National Academies of Sciences, Engineering, and Medicine,
  prefs: []
  type: TYPE_NORMAL
- en: '2019\. *Quantum computing: progress and prospects*. National'
  prefs: []
  type: TYPE_NORMAL
- en: Academies Press.
  prefs: []
  type: TYPE_NORMAL
- en: '5\. Marcozzi, M. and Mostarda, L., 2021\. Quantum Consensus: an'
  prefs: []
  type: TYPE_NORMAL
- en: overview. *arXiv preprint arXiv:2101.04192*.
  prefs: []
  type: TYPE_NORMAL
- en: 6\. SEET, Jorden and GRIFFIN, Paul. Quantum consensus. (2019).
  prefs: []
  type: TYPE_NORMAL
- en: 2019 IEEE Asia-Pacific Conference on Computer Science and Data
  prefs: []
  type: TYPE_NORMAL
- en: 'Engineering (CSDE) 2019: December 9–11, Melbourne, Australia:'
  prefs: []
  type: TYPE_NORMAL
- en: Proceedings. 1-8\. Research Collection School Of Computing and
  prefs: []
  type: TYPE_NORMAL
- en: Information Systems.
  prefs: []
  type: TYPE_NORMAL
- en: 7\. Ben-Or, M. and Hassidim, A., 2005, May. Fast quantum Byzantine
  prefs: []
  type: TYPE_NORMAL
- en: agreement. In *Proceedings of the thirty-seventh annual ACM*
  prefs: []
  type: TYPE_NORMAL
- en: '*symposium on Theory of computing* (pp. 481–485).'
  prefs: []
  type: TYPE_NORMAL
- en: '408'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9 Quantum Consensus
  prefs: []
  type: TYPE_NORMAL
- en: '8\. Quantum algorithm: [https://en.wikipedia.org/wiki/Quantum_](https://en.wikipedia.org/wiki/Quantum_algorithm)'
  prefs: []
  type: TYPE_NORMAL
- en: '[algorithm](https://en.wikipedia.org/wiki/Quantum_algorithm)'
  prefs: []
  type: TYPE_NORMAL
- en: 9\. Rajan, D. and Visser, M., 2019\. Quantum blockchain using
  prefs: []
  type: TYPE_NORMAL
- en: entanglement in time. *Quantum Reports*, *1*(1), pp. 3–11\.
  prefs: []
  type: TYPE_NORMAL
- en: '10\. Stinson, D.R., & Paterson, M.B. (2018). Cryptography: Theory'
  prefs: []
  type: TYPE_NORMAL
- en: and Practice (4th ed.). Chapman and Hall/CRC. [https://doi.](https://doi.org/10.1201/9781315282497)
  prefs: []
  type: TYPE_NORMAL
- en: '[org/10.1201/9781315282497](https://doi.org/10.1201/9781315282497)'
  prefs: []
  type: TYPE_NORMAL
- en: 11\. Helm, L.K., 2008, August. Quantum distributed consensus. In
  prefs: []
  type: TYPE_NORMAL
- en: '*PODC* (p. 445).'
  prefs: []
  type: TYPE_NORMAL
- en: '12\. Scalability trilemma[: https://vitalik.ca/general/2021/04/07/](https://vitalik.ca/general/2021/04/07/sharding.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[sharding.html](https://vitalik.ca/general/2021/04/07/sharding.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 13\. Lamport, L., 1979\. Constructing digital signatures from a one way
  prefs: []
  type: TYPE_NORMAL
- en: function. (Lamport signatures).
  prefs: []
  type: TYPE_NORMAL
- en: 14\. Pinski, Sebastian. (2011). Adiabatic Quantum Computing.
  prefs: []
  type: TYPE_NORMAL
- en: 15\. Mohr, A., 2014\. Quantum computing in complexity theory and
  prefs: []
  type: TYPE_NORMAL
- en: theory of computation. *Carbondale, IL*, *194*.
  prefs: []
  type: TYPE_NORMAL
- en: 16\. Sun, X., Kulicki, P., and Sopek, M., 2020\. Multi-party quantum
  prefs: []
  type: TYPE_NORMAL
- en: Byzantine agreement without entanglement. *Entropy*, *22*(10),
  prefs: []
  type: TYPE_NORMAL
- en: p. 1152\.
  prefs: []
  type: TYPE_NORMAL
- en: 17\. Fitzi, M., Gisin, N., and Maurer, U., 2001\. Quantum solution to the
  prefs: []
  type: TYPE_NORMAL
- en: Byzantine agreement problem. *Physical Review Letters*, *87*(21),
  prefs: []
  type: TYPE_NORMAL
- en: p. 217901\.
  prefs: []
  type: TYPE_NORMAL
- en: 18\. Webber, M., Elfving, V., Weidt, S., and Hensinger, W.K., 2022\.
  prefs: []
  type: TYPE_NORMAL
- en: The impact of hardware specifications on reaching quantum
  prefs: []
  type: TYPE_NORMAL
- en: advantage in the fault tolerant regime. *AVS Quantum Science*, *4*(1),
  prefs: []
  type: TYPE_NORMAL
- en: p. 013801\.
  prefs: []
  type: TYPE_NORMAL
- en: '409'
  prefs: []
  type: TYPE_NORMAL
- en: '**CHAPTER 10**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Conclusion**'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations on making this far! We’ve come a long way with a lot of information
  prefs: []
  type: TYPE_NORMAL
- en: under our belt. In this chapter, we summarize some important topics. We will
    also look
  prefs: []
  type: TYPE_NORMAL
- en: at some latest research and ideas and touch upon some more consensus protocols.
    An
  prefs: []
  type: TYPE_NORMAL
- en: important aspect in consensus protocol research is formal design and verification
    of
  prefs: []
  type: TYPE_NORMAL
- en: the algorithms. We briefly explain this important area in this chapter. Also,
    we compare
  prefs: []
  type: TYPE_NORMAL
- en: some of the most common consensus protocols from different angles and introduce
  prefs: []
  type: TYPE_NORMAL
- en: some important research directions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Introduction**'
  prefs: []
  type: TYPE_NORMAL
- en: Consensus protocols are the backbone of distributed systems and especially
  prefs: []
  type: TYPE_NORMAL
- en: blockchains. Throughout this book, we discussed several protocols and relevant
  prefs: []
  type: TYPE_NORMAL
- en: topics. Currently, a blockchain is the most common candidate for implementing
  prefs: []
  type: TYPE_NORMAL
- en: consensus protocols. In fact, they are at the core of the blockchain. With the
    blockchain, novel schemes are being introduced which address various problems
    including
  prefs: []
  type: TYPE_NORMAL
- en: node scalability, transaction throughput, consensus efficiency, fault tolerance,
  prefs: []
  type: TYPE_NORMAL
- en: interoperability, and various security aspects.
  prefs: []
  type: TYPE_NORMAL
- en: Distributed consensus is used almost everywhere between networked devices,
  prefs: []
  type: TYPE_NORMAL
- en: not only in classical distributed systems that we are used to. This includes
    the Internet of Things, multiagent systems, distributed real-time systems, embedded
    systems,
  prefs: []
  type: TYPE_NORMAL
- en: and lightweight devices. With the evolution of the blockchain, blockchain consensus
  prefs: []
  type: TYPE_NORMAL
- en: adoption is expected to grow in all these systems too.
  prefs: []
  type: TYPE_NORMAL
- en: '**Other Protocols**'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we briefly introduce protocols that we did not cover before.
    As it is a vast area, a brief introduction only is given.
  prefs: []
  type: TYPE_NORMAL
- en: '411'
  prefs: []
  type: TYPE_NORMAL
- en: © Imran Bashir 2022
  prefs: []
  type: TYPE_NORMAL
- en: I. Bashir, *Blockchain Consensus*, [https://doi.org/10.1007/978-1-4842-8179-6_10](https://doi.org/10.1007/978-1-4842-8179-6_10#DOI)
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 10 ConClusion
  prefs: []
  type: TYPE_NORMAL
- en: '**PoET**'
  prefs: []
  type: TYPE_NORMAL
- en: The proof of elapsed time algorithm was introduced by Intel in 2016\. Remember
    we
  prefs: []
  type: TYPE_NORMAL
- en: discussed earlier in Chapt[er 5 th](https://doi.org/10.1007/978-1-4842-8179-6_5)at
    a key purpose that PoW fulfills is the passage of some time until the network
    can converge to a canonical chain. Also, the leader, the miner
  prefs: []
  type: TYPE_NORMAL
- en: whose block is accepted, wins the right to do so by solving PoW. PoET is fundamentally
  prefs: []
  type: TYPE_NORMAL
- en: a leader election algorithm which utilizes trusted hardware to ensure that a
    certain time has elapsed before the next leader is selected for block proposal.
    The fundamental idea
  prefs: []
  type: TYPE_NORMAL
- en: in PoET is to provide a mechanism of leader election by waiting randomly to
    be elected
  prefs: []
  type: TYPE_NORMAL
- en: as a leader for proposing new blocks.
  prefs: []
  type: TYPE_NORMAL
- en: PoET in fact emulates the passage of time that would be consumed by PoW mining.
  prefs: []
  type: TYPE_NORMAL
- en: The core idea is that every node randomly waits for some time before producing
    a block.
  prefs: []
  type: TYPE_NORMAL
- en: The random waiting process runs inside a Trusted execution environment (TEE)
    to
  prefs: []
  type: TYPE_NORMAL
- en: ensure that true time has indeed passed. For this purpose, Intel SGX or ARM
    TrustZone
  prefs: []
  type: TYPE_NORMAL
- en: can be used. As TEEs provide confidentiality and integrity, the network in turn
    trusts
  prefs: []
  type: TYPE_NORMAL
- en: the block producers. PoET tolerates up to 50% faulty TEE nodes. However, there
    is a
  prefs: []
  type: TYPE_NORMAL
- en: possibility of Sybil attacks where an actor can run many TEE nodes, which can
    result in
  prefs: []
  type: TYPE_NORMAL
- en: shortening the random waiting time. This can result in the creation of a malicious
    chain
  prefs: []
  type: TYPE_NORMAL
- en: if more than 50% of TEEs become malicious. Another limitation is the stale chip
    problem
  prefs: []
  type: TYPE_NORMAL
- en: highlighted by Ittay Eyal. This limitation results in hardware wastage, which
    results
  prefs: []
  type: TYPE_NORMAL
- en: in resource wastage. The stale chip problem stems from the idea that it is financially
  prefs: []
  type: TYPE_NORMAL
- en: beneficial for malicious actors to collect many old SGX chips, which increases
    their odds of becoming the producer of the next block. For example, adversarial
    actors can collect
  prefs: []
  type: TYPE_NORMAL
- en: many old SGX chips to build mining rigs. It serves only one purpose, that is,
    mining,
  prefs: []
  type: TYPE_NORMAL
- en: instead of buying modern CPUs with SGX, which will help in PoET consensus and
    be
  prefs: []
  type: TYPE_NORMAL
- en: useful for general computation. Instead, they can choose to collect as many
    old SGX-
  prefs: []
  type: TYPE_NORMAL
- en: enabled chips as they can and increase their chances of winning the mining lottery.
    Also, old SGX-enabled CPUs are cheap and can increase the use of old, inefficient
    CPUs. It is
  prefs: []
  type: TYPE_NORMAL
- en: like Bitcoin miners racing to get as many fast ASICs as possible to increase
    their chances of becoming elected miners. However, it results in hardware wastage.
    There is also the
  prefs: []
  type: TYPE_NORMAL
- en: possibility of hacking the chip's hardware. If an SGX chip is compromised, the
    malicious
  prefs: []
  type: TYPE_NORMAL
- en: node can win the mining round every time, resulting in complete system compromise
  prefs: []
  type: TYPE_NORMAL
- en: and undeserved incentivization of miners. This problem is called the broken
    chip
  prefs: []
  type: TYPE_NORMAL
- en: problem.
  prefs: []
  type: TYPE_NORMAL
- en: '412'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 10 ConClusion
  prefs: []
  type: TYPE_NORMAL
- en: '**Proof of Authority**'
  prefs: []
  type: TYPE_NORMAL
- en: We can think of PoA as a specific kind of proof of stake where the validators
    stake
  prefs: []
  type: TYPE_NORMAL
- en: with their identity instead of economic tokens. The identity of a validator
    depicts the
  prefs: []
  type: TYPE_NORMAL
- en: authority associated with the validator. A usual process of earning authority
    involves
  prefs: []
  type: TYPE_NORMAL
- en: identity verification, reputation building, and a publicly scrutinized assessment
    process.
  prefs: []
  type: TYPE_NORMAL
- en: The resultant group becomes a highly trusted set of validators to participate
    in the
  prefs: []
  type: TYPE_NORMAL
- en: consensus protocol and produce blocks. Any violation by a validator of the rules
    of the
  prefs: []
  type: TYPE_NORMAL
- en: protocol or inability to justify the earned right to produce blocks results
    in the removal of the dishonest validator by other validators and users on the
    network. It’s used in Rinkeby and Kovan Ethereum test nets. PoA provides good
    security as we have trusted validators
  prefs: []
  type: TYPE_NORMAL
- en: in the network, but the network is somewhat centralized. The resilience against
    collusion and other security threats depends on the consensus algorithm used by
    the validators. If
  prefs: []
  type: TYPE_NORMAL
- en: it’s a BFT variant, then usual BFT guarantees of 33% fault tolerance apply.
  prefs: []
  type: TYPE_NORMAL
- en: '**HoneyBadger BFT**'
  prefs: []
  type: TYPE_NORMAL
- en: HoneyBadger BFT (HBBFT) is a leaderless and randomized consensus protocol that
  prefs: []
  type: TYPE_NORMAL
- en: works under asynchrony. It is the first practical asynchronous Byzantine consensus
  prefs: []
  type: TYPE_NORMAL
- en: protocol. Generally, in distributed system theory, randomized algorithms are
    thought
  prefs: []
  type: TYPE_NORMAL
- en: to be impractical. The HoneyBadger protocol authors claim to refute this belief.
    The
  prefs: []
  type: TYPE_NORMAL
- en: approach taken to build this protocol is to improve efficiency by fine-tuning
    existing
  prefs: []
  type: TYPE_NORMAL
- en: primitives and introducing new encryption techniques. These techniques result
    in
  prefs: []
  type: TYPE_NORMAL
- en: removing bottlenecks in the protocol.
  prefs: []
  type: TYPE_NORMAL
- en: The first limitation to address is the leader bottleneck, for example, in PBFT
    and
  prefs: []
  type: TYPE_NORMAL
- en: other variants there’s a standard reliable broadcast mechanism used to disseminate
  prefs: []
  type: TYPE_NORMAL
- en: information from the leader to other nodes. This results in significant bandwidth
  prefs: []
  type: TYPE_NORMAL
- en: consumption, for example, on the order of *O*( *nB*) where *b* is the blocks.
    To address this limitation, erasure coding can be used which allows the leader
    to send only erasure
  prefs: []
  type: TYPE_NORMAL
- en: codes to the nodes. Then each node sends the erasure code stripe received to
    other
  prefs: []
  type: TYPE_NORMAL
- en: nodes. This way, there is less load on the leader. Then all nodes simply reconstruct
    the
  prefs: []
  type: TYPE_NORMAL
- en: message. This reduces the leader bandwidth to *O*( *n*). Transactions are processed
    in batches in HBBFT, which increases the throughput.
  prefs: []
  type: TYPE_NORMAL
- en: '413'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 10 ConClusion
  prefs: []
  type: TYPE_NORMAL
- en: It is fundamentally an atomic broadcast protocol based on the multivalue Byzantine
  prefs: []
  type: TYPE_NORMAL
- en: agreement and agreement on common subset. HoneyBadger uses several techniques
  prefs: []
  type: TYPE_NORMAL
- en: developed previously, including erasure-coded reliable broadcast and common
    coin–
  prefs: []
  type: TYPE_NORMAL
- en: based asynchronous Byzantine agreement. It also uses a threshold public key
    encryption
  prefs: []
  type: TYPE_NORMAL
- en: (signatures) to provide common coins for the randomized ABA protocol.
  prefs: []
  type: TYPE_NORMAL
- en: HBBFT implements the total order using the asynchronous common subset
  prefs: []
  type: TYPE_NORMAL
- en: (ACS). ACS is implemented using two other protocols, reliable broadcast (RBC)
    and
  prefs: []
  type: TYPE_NORMAL
- en: asynchronous binary Byzantine agreement (ABA).
  prefs: []
  type: TYPE_NORMAL
- en: Reliable broadcast was introduced in 1987 by Bracha, commonly known as Bracha’s
  prefs: []
  type: TYPE_NORMAL
- en: broadcast. This protocol tolerates *f* Byzantine faulty nodes where *n* = 3
    *f* + 1\. It provides two guarantees, when a designated node (leader, broadcaster)
    broadcasts a message to
  prefs: []
  type: TYPE_NORMAL
- en: all nodes. If any honest node delivers a message m broadcast by the broadcaster,
    then all correct nodes deliver m. Secondly, if the broadcasting node is correct,
    then every honest node delivers the message broadcast by the broadcaster node.
    Due to the message being
  prefs: []
  type: TYPE_NORMAL
- en: echoed from all nodes to all, the communication complexity of this protocol
    becomes
  prefs: []
  type: TYPE_NORMAL
- en: '*O*( *n* 2 *m*), which is ok for smaller size networks, but in the blockchain
    world with 1000s of nodes, it is impractical.'
  prefs: []
  type: TYPE_NORMAL
- en: The agreement on a common subset protocol for multiparty computation (ACS for
  prefs: []
  type: TYPE_NORMAL
- en: MPC) was proposed by Ben-Or. ACS was used as a consensus primitive for multiparty
  prefs: []
  type: TYPE_NORMAL
- en: computation under an asynchronous network. Multiparty computation (MPC) aims
    to
  prefs: []
  type: TYPE_NORMAL
- en: create a mechanism to compute a function jointly over their inputs, while the
    inputs are
  prefs: []
  type: TYPE_NORMAL
- en: kept private. ACS achieves an agreement on a common subset of at least *n* –
    *f* correct inputs. ACS uses RBC and ABA which enables a single bit agreement
    between parties.
  prefs: []
  type: TYPE_NORMAL
- en: Due to the communication complexity of RBC, HBBFT implements a different
  prefs: []
  type: TYPE_NORMAL
- en: bandwidth-efficient broadcast mechanism called AVID by Cachin et.al., which
    uses
  prefs: []
  type: TYPE_NORMAL
- en: erasure coding and cross checksums to reduce the communication complexity to
    *O*( *nm*).
  prefs: []
  type: TYPE_NORMAL
- en: Here, the message m is erasure coded into different slices, and then each slice
    is hashed to produce a cross checksum. The broadcaster sends a slice and cross
    checksum to a
  prefs: []
  type: TYPE_NORMAL
- en: node, and that node then echoes these to all other nodes. Once all slices reach
    all nodes, each node reconstructs the original message from these slices. This
    way, less bandwidth
  prefs: []
  type: TYPE_NORMAL
- en: is consumed.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, HBBFT solves consensus under asynchrony by using the asynchronous
  prefs: []
  type: TYPE_NORMAL
- en: common subset protocol (ACS) and reliable broadcast (RBC), where each node proposes
  prefs: []
  type: TYPE_NORMAL
- en: its value, and finally an asynchronous binary agreement protocol (ABA) runs,
    which
  prefs: []
  type: TYPE_NORMAL
- en: decides on each proposal.
  prefs: []
  type: TYPE_NORMAL
- en: '414'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 10 ConClusion
  prefs: []
  type: TYPE_NORMAL
- en: '**Avalanche**'
  prefs: []
  type: TYPE_NORMAL
- en: This new paradigm of consensus protocols achieves an agreement through random
  prefs: []
  type: TYPE_NORMAL
- en: network sampling. The Avalanche family of protocols allow for a more relaxed
    form of
  prefs: []
  type: TYPE_NORMAL
- en: agreement as compared to a deterministic agreement. However, it provides stronger
  prefs: []
  type: TYPE_NORMAL
- en: safety than PoW and enjoys the node scalability of the Nakamoto consensus. We
    can
  prefs: []
  type: TYPE_NORMAL
- en: think of it as a probabilistic version of the traditional quorum-based protocol
    but
  prefs: []
  type: TYPE_NORMAL
- en: without explicit intersections in voting. The key idea is to combine the best
    of Nakamoto family with the best of classical family.
  prefs: []
  type: TYPE_NORMAL
- en: The safety of these protocols is probabilistic but with negligible failure possibility.
  prefs: []
  type: TYPE_NORMAL
- en: In terms of liveness, these protocols terminate with high probability. For liveness,
    these protocols rely on synchrony. The protocol achieves safety through metastability.
    Safety
  prefs: []
  type: TYPE_NORMAL
- en: provided by the protocol is probabilistic where an adjustable system chosen
    security
  prefs: []
  type: TYPE_NORMAL
- en: parameter makes the possibility of consensus failure negligibly small. The protocol
  prefs: []
  type: TYPE_NORMAL
- en: 'guarantees safety and liveness properties, with high probability:'
  prefs: []
  type: TYPE_NORMAL
- en: • **Safety:** No two correct nodes accept conflicting transactions.
  prefs: []
  type: TYPE_NORMAL
- en: • **Liveness:** Every correct node will eventually accept any transaction
  prefs: []
  type: TYPE_NORMAL
- en: by an honest client.
  prefs: []
  type: TYPE_NORMAL
- en: This family has several protocols that build up the complete Avalanche protocol.
  prefs: []
  type: TYPE_NORMAL
- en: The protocol is built gradually, starting from the so-called slush protocol,
    which provides metastability, snowflake, the BFT protocol, Snowball, which affirms
    the state by adding
  prefs: []
  type: TYPE_NORMAL
- en: confidence to the decision; and, finally, Avalanche, which adds the DAG structure
    to
  prefs: []
  type: TYPE_NORMAL
- en: improve efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: With these innovations, the protocol provides quick finality, low latency, high
  prefs: []
  type: TYPE_NORMAL
- en: throughput, and scalability.
  prefs: []
  type: TYPE_NORMAL
- en: '**DAG-Based Consensus Protocols**'
  prefs: []
  type: TYPE_NORMAL
- en: Usually, a blockchain is a linear structure; however, another class of algorithms
    has been proposed with nonlinear blockchain structures. The primary aim is efficiency,
    and these
  prefs: []
  type: TYPE_NORMAL
- en: protocols are based on the premise that instead of relying on a limited and
    slow, linearly growing chain, the ledger should be able to expand in all directions,
    like a DAG, which can result in improved performance, high scalability, and fast
    transaction confirmation. DAGs require less communication, computation, and storage,
    thus increasing the performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two types of DAG-based ledgers: block-based DAG and transaction-based
    DAG.'
  prefs: []
  type: TYPE_NORMAL
- en: '415'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 10 ConClusion
  prefs: []
  type: TYPE_NORMAL
- en: '**Block-Based DAG**'
  prefs: []
  type: TYPE_NORMAL
- en: Every vertex of a blockDAG contains a block. Each block can be a child of multiple
  prefs: []
  type: TYPE_NORMAL
- en: blocks, instead of only one parent in linear designs, SPECTRE, PHANTOM, and
  prefs: []
  type: TYPE_NORMAL
- en: Meshcash.
  prefs: []
  type: TYPE_NORMAL
- en: '**Transaction-Based DAG**'
  prefs: []
  type: TYPE_NORMAL
- en: Each vertex of a transaction-based DAG contains a transaction. IOTA Tangle,
    Byteball,
  prefs: []
  type: TYPE_NORMAL
- en: Graphchain, and Avalanche are some examples of a transaction-based DAG.
  prefs: []
  type: TYPE_NORMAL
- en: Hashgraph is a permissioned graph–based blockchain with a BFT-type consensus
  prefs: []
  type: TYPE_NORMAL
- en: protocol.
  prefs: []
  type: TYPE_NORMAL
- en: '**Ebb-and-Flow Protocols**'
  prefs: []
  type: TYPE_NORMAL
- en: This work is a response to a liveness issue found in Gasper. Gasper is a PoS-based
  prefs: []
  type: TYPE_NORMAL
- en: consensus mechanism proposed for Ethereum’s beacon chain. It is a combination
    of
  prefs: []
  type: TYPE_NORMAL
- en: Casper FFG, the finality gadget, and LMD GHOST, the fork choice rule. In this
    work,
  prefs: []
  type: TYPE_NORMAL
- en: “snap-and-chat” protocols are proposed that are provably secure.
  prefs: []
  type: TYPE_NORMAL
- en: Nakamoto-style protocols provide liveness under network partitions and dynamic
  prefs: []
  type: TYPE_NORMAL
- en: network participation, but they sacrifice safety over liveness. BFT protocols,
    on the
  prefs: []
  type: TYPE_NORMAL
- en: other hand, provide safety (finality) under network partitions and low participation
  prefs: []
  type: TYPE_NORMAL
- en: (participants less than <3 *f* +1) but sacrifice liveness. It has been shown
    that it is impossible for a protocol to be both live under dynamic participation
    and safe under
  prefs: []
  type: TYPE_NORMAL
- en: network partitions. This work answers the question of whether there exists a
    consensus
  prefs: []
  type: TYPE_NORMAL
- en: mechanism that guarantees both availability and safety. The key idea is exquisite
    and
  prefs: []
  type: TYPE_NORMAL
- en: proposes to create two ledgers instead of one. Remember, no protocol can ensure
    safety
  prefs: []
  type: TYPE_NORMAL
- en: and liveness under network partitions and dynamic partitions with a single ledger.
    In
  prefs: []
  type: TYPE_NORMAL
- en: other words, longest chain–style mechanisms favor liveness over safety and provide
  prefs: []
  type: TYPE_NORMAL
- en: dynamic availability under different participation levels; however, BFT protocols
    favor
  prefs: []
  type: TYPE_NORMAL
- en: safety over liveness and provide finality. This problem is called the availability-finality
    dilemma, as a single ledger cannot provide both properties. Therefore, the proposal
    is to create two ledgers. The first is an “available full ledger” that is always
    live but safe only without network partitions, similar to “longest chain–type
    PoW protocol.” The other
  prefs: []
  type: TYPE_NORMAL
- en: ledger, called the “finalized prefix ledger,” is always safe but not live in
    low participation scenarios. This concept is the same as traditional BFT–style
    protocols, for example,
  prefs: []
  type: TYPE_NORMAL
- en: '416'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 10 ConClusion
  prefs: []
  type: TYPE_NORMAL
- en: PBFT, which stalls unless a threshold of participants is available. As the finalized
    prefix ledger is the prefix of the available full ledger, both ledgers eventually
    converge as a
  prefs: []
  type: TYPE_NORMAL
- en: single authentic chain of history. In other words, the finalized prefix ledger
    is safe under network partitions and if less than one-third of participants are
    faulty.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, the available full ledger is live under dynamic (low) participation
    and
  prefs: []
  type: TYPE_NORMAL
- en: if <50% of active players are Byzantine. This technique of combining BFT-style
    with
  prefs: []
  type: TYPE_NORMAL
- en: Nakamoto-style protocols and creating so-called nested ledgers has been named
    the
  prefs: []
  type: TYPE_NORMAL
- en: “Ebb-and-Flow” property. The so-called “snap-and-chat” protocols are developed
    to
  prefs: []
  type: TYPE_NORMAL
- en: achieve the “Ebb-and-Flow” property. The finalized ledger is always the prefix
    of the
  prefs: []
  type: TYPE_NORMAL
- en: available ledger, thus creating a combined proper single chain. At a high level,
    this
  prefs: []
  type: TYPE_NORMAL
- en: mechanism works by ordering transactions into a chain of blocks by using some
    longest
  prefs: []
  type: TYPE_NORMAL
- en: chain–type protocol, for example, PoW. Next, snapshots of prefixes from this
    blockchain
  prefs: []
  type: TYPE_NORMAL
- en: feed into a partially synchronous BFT-style protocol for example, PBFT, which
    produces
  prefs: []
  type: TYPE_NORMAL
- en: a chain containing multiple chains of blocks. Next, any duplicates or invalid
    transactions are removed, which creates a finalized prefix ledger. This finalized
    prefix ledger is added before the output of the PoW-style protocol, and any duplicates
    or invalid transactions
  prefs: []
  type: TYPE_NORMAL
- en: are removed. This process finally creates an available single ledger.
  prefs: []
  type: TYPE_NORMAL
- en: There is a myriad of consensus protocols that exist, but we cannot cover all
    of them.
  prefs: []
  type: TYPE_NORMAL
- en: However, we did explore quite a few covering different types and classes including
  prefs: []
  type: TYPE_NORMAL
- en: randomized, deterministic, CFT, BFT, and Nakamoto-style protocols.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now turn our attention to formal verification which allows us to ensure
    the
  prefs: []
  type: TYPE_NORMAL
- en: correctness of all these different consensus protocols.
  prefs: []
  type: TYPE_NORMAL
- en: '**Formal Verification**'
  prefs: []
  type: TYPE_NORMAL
- en: With all the activity in blockchain consensus research, we can now appreciate
    that it
  prefs: []
  type: TYPE_NORMAL
- en: is such an active area of research. Many new protocols have been proposed to
    solve
  prefs: []
  type: TYPE_NORMAL
- en: consensus problems in innovative ways. For example, some address efficiency,
    some
  prefs: []
  type: TYPE_NORMAL
- en: look at scalability problems, some try to reduce message complexity, some modify
    the
  prefs: []
  type: TYPE_NORMAL
- en: existing classical protocols to make them suitable for the blockchain, some
    try to speed
  prefs: []
  type: TYPE_NORMAL
- en: up the consensus mechanism, and many other improvements and novelties are claimed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, a question arises: How do we ensure that these consensus protocols are
    correct'
  prefs: []
  type: TYPE_NORMAL
- en: and perform as we intend them to? For this purpose, usually researchers write
    research
  prefs: []
  type: TYPE_NORMAL
- en: papers with proofs and arguments about the correctness of the protocols. Moreover,
  prefs: []
  type: TYPE_NORMAL
- en: formal methods are used to ensure protocol correctness.
  prefs: []
  type: TYPE_NORMAL
- en: '417'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 10 ConClusion
  prefs: []
  type: TYPE_NORMAL
- en: Formal methods are techniques used to model systems as mathematical objects.
    In
  prefs: []
  type: TYPE_NORMAL
- en: other words, these are mathematically rigorous methods used to specify, design,
    and
  prefs: []
  type: TYPE_NORMAL
- en: verify software or hardware systems. Such techniques include writing specifications
  prefs: []
  type: TYPE_NORMAL
- en: in a formal logic and verifying them using model checking and formal proofs.
    Formal
  prefs: []
  type: TYPE_NORMAL
- en: methods are divided into two broad domains called formal specification and formal
  prefs: []
  type: TYPE_NORMAL
- en: verification. The first domain deals with writing precise and concrete specifications,
    and the latter concerns the development of proofs to prove the correctness of
    a specification.
  prefs: []
  type: TYPE_NORMAL
- en: A formal specification is a well-defined mathematical logic statement, whereas
  prefs: []
  type: TYPE_NORMAL
- en: verification is the process of checking the specification by logic deductions,
    which
  prefs: []
  type: TYPE_NORMAL
- en: is done mechanically. In other words, the specification is formally defined
    and then
  prefs: []
  type: TYPE_NORMAL
- en: verified using a model checker or a theorem prover.
  prefs: []
  type: TYPE_NORMAL
- en: The reason why formal methods provide value is that they can symbolically check
  prefs: []
  type: TYPE_NORMAL
- en: the entire state space of a design and ascertain the correctness of the design.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generally, formal verification comprises three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: • Create a formal model of the system to be checked.
  prefs: []
  type: TYPE_NORMAL
- en: • Write a formal specification of the properties desired to be satisfied
  prefs: []
  type: TYPE_NORMAL
- en: by our model.
  prefs: []
  type: TYPE_NORMAL
- en: • Mechanically check the model to ensure that the model satisfies the
  prefs: []
  type: TYPE_NORMAL
- en: specification.
  prefs: []
  type: TYPE_NORMAL
- en: 'Two categories of techniques are commonly used for verification: state exploration–'
  prefs: []
  type: TYPE_NORMAL
- en: based approaches and proof-based approaches. State exploration–based methods
    are
  prefs: []
  type: TYPE_NORMAL
- en: automatic but are inefficient and difficult to scale. For example, a usual problem
    is state explosion, where the number of states to check grows so exponentially
    large that the
  prefs: []
  type: TYPE_NORMAL
- en: model does not fit in a computer's memory. This is the reason the model must
    be finite,
  prefs: []
  type: TYPE_NORMAL
- en: so that it can be efficiently verified. On the other hand, proof-based approaches
    (i.e.,
  prefs: []
  type: TYPE_NORMAL
- en: theorem proving) are more precise and less memory consuming but require human
  prefs: []
  type: TYPE_NORMAL
- en: interaction and more in-depth knowledge of the proofs and relevant techniques.
    Proof-
  prefs: []
  type: TYPE_NORMAL
- en: based techniques are the most elegant way of reasoning about properties of a
    system
  prefs: []
  type: TYPE_NORMAL
- en: without any limit on the size of the spec. This is in contrast with model checking
    where
  prefs: []
  type: TYPE_NORMAL
- en: there must be a limit on the size of the model. With proof-based techniques,
    you can
  prefs: []
  type: TYPE_NORMAL
- en: reason about the system states and prove that with any input the system will
    always
  prefs: []
  type: TYPE_NORMAL
- en: work as intended. Proof assistants such as Isabelle are used to help with reasoning
    about systems by allowing automated theorem proving.
  prefs: []
  type: TYPE_NORMAL
- en: '418'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-432_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 10 ConClusion
  prefs: []
  type: TYPE_NORMAL
- en: A model checking mechanism consists of a formal specification language and
  prefs: []
  type: TYPE_NORMAL
- en: a model checker. Model checking verifies systems formally using automated tools.
  prefs: []
  type: TYPE_NORMAL
- en: This approach is gaining popularity among blockchain researchers to check formal
  prefs: []
  type: TYPE_NORMAL
- en: specifications of a consensus protocol and ensure its correctness. The automated
  prefs: []
  type: TYPE_NORMAL
- en: checker checks for the conditions to be satisfied and then confirms if the conditions
    are satisfied; otherwise, it produces counter examples (i.e., exceptions).
  prefs: []
  type: TYPE_NORMAL
- en: Figur[e 10-1 illus](#p432)trates the model checking mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 10-1\.** Model checking*'
  prefs: []
  type: TYPE_NORMAL
- en: TLA+ (temporal logic for actions) is a specification language designed by Leslie
  prefs: []
  type: TYPE_NORMAL
- en: Lamport for describing and reasoning about concurrent systems. TLC is a model
    checker
  prefs: []
  type: TYPE_NORMAL
- en: for design specifications written in TLA+. Another model checker is SPIN which
    checks
  prefs: []
  type: TYPE_NORMAL
- en: specifications written in the Promela specification language.
  prefs: []
  type: TYPE_NORMAL
- en: '419'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 10 ConClusion
  prefs: []
  type: TYPE_NORMAL
- en: A distributed blockchain consensus algorithm is usually evaluated against two
  prefs: []
  type: TYPE_NORMAL
- en: 'classes of correctness properties: safety and liveness. Safety generally means
    “nothing'
  prefs: []
  type: TYPE_NORMAL
- en: bad will happen,” whereas liveness suggests “something good will eventually
    occur.”
  prefs: []
  type: TYPE_NORMAL
- en: Both these properties have some subproperties, depending on the requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, for consensus mechanisms, we have agreement, integrity, and validity
  prefs: []
  type: TYPE_NORMAL
- en: conditions under the safety property, and termination is required for liveness.
  prefs: []
  type: TYPE_NORMAL
- en: Consensus algorithms are mostly model checked under a system model by specifying
  prefs: []
  type: TYPE_NORMAL
- en: how many nodes are in the system and what timing assumptions are made about
    the
  prefs: []
  type: TYPE_NORMAL
- en: system. The model is then run to explore each state of the system and check
    if there is an execution that doesn’t terminate. Usually, this is done under a
    four-node model, based
  prefs: []
  type: TYPE_NORMAL
- en: on the formula of 3f+1, which we’ve seen before.
  prefs: []
  type: TYPE_NORMAL
- en: A program is correct if, in all possible executions, the program behaves correctly
  prefs: []
  type: TYPE_NORMAL
- en: according to the specification.
  prefs: []
  type: TYPE_NORMAL
- en: '**Impossibility Results**'
  prefs: []
  type: TYPE_NORMAL
- en: Unsolvability results in distributed systems show that certain problems cannot
    be
  prefs: []
  type: TYPE_NORMAL
- en: solved. Lower bound results show that certain problems cannot be solved if resources
  prefs: []
  type: TYPE_NORMAL
- en: are insufficient; in other words, these lower bound results show that certain
    problems
  prefs: []
  type: TYPE_NORMAL
- en: are only solvable if a certain threshold of sufficient resources is available,
    that is,
  prefs: []
  type: TYPE_NORMAL
- en: minimum resources required to solve a problem.
  prefs: []
  type: TYPE_NORMAL
- en: Table [10-1](#p434) summarizes the core impossibility results related to the
    consensus problem.
  prefs: []
  type: TYPE_NORMAL
- en: '420'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 10 ConClusion
  prefs: []
  type: TYPE_NORMAL
- en: '***Table 10-1\.** Consensus problem impossibility results*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Crash Faults**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Byzantine Faults**'
  prefs: []
  type: TYPE_NORMAL
- en: synchronous
  prefs: []
  type: TYPE_NORMAL
- en: Consensus possible if *f* < *n*
  prefs: []
  type: TYPE_NORMAL
- en: '*f* ≥ *n*/3 impossible'
  prefs: []
  type: TYPE_NORMAL
- en: at least *f* + 1 rounds required where
  prefs: []
  type: TYPE_NORMAL
- en: '>2 *f* network connectivity'
  prefs: []
  type: TYPE_NORMAL
- en: '*f* < *n*'
  prefs: []
  type: TYPE_NORMAL
- en: minimum
  prefs: []
  type: TYPE_NORMAL
- en: '*f* network connectivity'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*f* < *n*/2 possible'
  prefs: []
  type: TYPE_NORMAL
- en: '*f* + 1 rounds'
  prefs: []
  type: TYPE_NORMAL
- en: asynchronous
  prefs: []
  type: TYPE_NORMAL
- en: Deterministic consensus impossible
  prefs: []
  type: TYPE_NORMAL
- en: Deterministic consensus
  prefs: []
  type: TYPE_NORMAL
- en: impossible
  prefs: []
  type: TYPE_NORMAL
- en: partially
  prefs: []
  type: TYPE_NORMAL
- en: impossible if *n* ≤ 2 *f*
  prefs: []
  type: TYPE_NORMAL
- en: impossible if *n* ≤ 3 *f*
  prefs: []
  type: TYPE_NORMAL
- en: synchronous
  prefs: []
  type: TYPE_NORMAL
- en: '>2 *f* network connectivity'
  prefs: []
  type: TYPE_NORMAL
- en: '*f* + 1 rounds'
  prefs: []
  type: TYPE_NORMAL
- en: The results in Table [10-1](#p434) are standard impossibility results. However,
    there are many others.
  prefs: []
  type: TYPE_NORMAL
- en: With the innovative research on blockchains, some new results have emerged.
  prefs: []
  type: TYPE_NORMAL
- en: Andrew Lewis-Pye and Tim Roughgarden announced a fascinating new impossibility
  prefs: []
  type: TYPE_NORMAL
- en: result similar to the CAP theorem where we can simultaneously choose only two
    of
  prefs: []
  type: TYPE_NORMAL
- en: three properties. It states that no blockchain protocol can operate in the unconstrained
  prefs: []
  type: TYPE_NORMAL
- en: environment (e.g., PoW), is live under a synchronous environment with significant
    and
  prefs: []
  type: TYPE_NORMAL
- en: sharp dynamic changes in network resources (e.g., participant numbers), and
    satisfies
  prefs: []
  type: TYPE_NORMAL
- en: probabilistic finality (consistency) in the partially synchronous environment.
    We can
  prefs: []
  type: TYPE_NORMAL
- en: only choose two properties simultaneously out of the three properties stated
    earlier.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in an unsized environment such as Bitcoin, imagine a node stops
  prefs: []
  type: TYPE_NORMAL
- en: receiving any new blocks. Now the node cannot differentiate between whether
    the other
  prefs: []
  type: TYPE_NORMAL
- en: nodes have lost their resources and cannot produce blocks anymore and if the
    block
  prefs: []
  type: TYPE_NORMAL
- en: messages are delayed. Now if the node stops producing blocks and other nodes
    are low
  prefs: []
  type: TYPE_NORMAL
- en: on resources and not producing blocks, it violates the liveness property, because
    this
  prefs: []
  type: TYPE_NORMAL
- en: node must keep producing blocks even if others don’t. However, if it keeps producing
  prefs: []
  type: TYPE_NORMAL
- en: blocks but the block messages are just delayed, then it is violating the consistency
  prefs: []
  type: TYPE_NORMAL
- en: property, because there could be other conflicting blocks which are just delayed.
  prefs: []
  type: TYPE_NORMAL
- en: '421'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 10 ConClusion
  prefs: []
  type: TYPE_NORMAL
- en: '**Complexity and Performance**'
  prefs: []
  type: TYPE_NORMAL
- en: A consensus algorithm can be evaluated from a communication complexity point
    of
  prefs: []
  type: TYPE_NORMAL
- en: view. This involves calculations such as if the protocol is running in normal
    mode (no
  prefs: []
  type: TYPE_NORMAL
- en: failures), then how many messages are required to be exchanged to reach consensus.
  prefs: []
  type: TYPE_NORMAL
- en: Also, in case of leader failure when a view change occurs, how many messages
    are
  prefs: []
  type: TYPE_NORMAL
- en: exchanged? Such metrics can help to understand how the algorithm behaves practically,
  prefs: []
  type: TYPE_NORMAL
- en: which helps to estimate the efficiency of the algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Message delays can be defined as the number of messages required by an algorithm
  prefs: []
  type: TYPE_NORMAL
- en: that cannot be sent before the previous message is received. In other words,
    it’s a
  prefs: []
  type: TYPE_NORMAL
- en: message which is sent only after the previous one has been received. An algorithm
  prefs: []
  type: TYPE_NORMAL
- en: requires n message delay; if some execution contains a chain of n messages,
    each of
  prefs: []
  type: TYPE_NORMAL
- en: which cannot be sent before receiving the previous one.
  prefs: []
  type: TYPE_NORMAL
- en: To evaluate the cost associated with an algorithm, we can think of different
  prefs: []
  type: TYPE_NORMAL
- en: 'complexity traits. There are three costs associated with a consensus algorithm:
    message'
  prefs: []
  type: TYPE_NORMAL
- en: complexity, communication complexity, and time complexity.
  prefs: []
  type: TYPE_NORMAL
- en: '**Message Complexity**'
  prefs: []
  type: TYPE_NORMAL
- en: Message complexity denotes the total number of messages that are required to
    be
  prefs: []
  type: TYPE_NORMAL
- en: exchanged by the algorithm to reach consensus. For example, imagine an algorithm
  prefs: []
  type: TYPE_NORMAL
- en: where all processes broadcast to all other nodes. This means that *n*( *n* −
    1) messages will be received. This means this algorithm has *O*( *n* 2) message
    complexity.
  prefs: []
  type: TYPE_NORMAL
- en: '**Communication Complexity (Bit Complexity)**'
  prefs: []
  type: TYPE_NORMAL
- en: Communication complexity is concerned with the total number of bits required
    to be
  prefs: []
  type: TYPE_NORMAL
- en: exchanged by the algorithm. Think of the same algorithm we imagined about in
    the
  prefs: []
  type: TYPE_NORMAL
- en: context of message complexity. If each message contains t bits, the algorithm
    exchanges
  prefs: []
  type: TYPE_NORMAL
- en: '*tn*( *n* − 1) bits, which means that the communication complexity is *o*(
    *tn* 2) bits, that is, all to all.'
  prefs: []
  type: TYPE_NORMAL
- en: '422'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 10 ConClusion
  prefs: []
  type: TYPE_NORMAL
- en: '**Time Complexity**'
  prefs: []
  type: TYPE_NORMAL
- en: Time complexity is concerned with the amount of time needed to complete the
  prefs: []
  type: TYPE_NORMAL
- en: execution of the algorithm. The time taken to execute the algorithm also depends
    on
  prefs: []
  type: TYPE_NORMAL
- en: the time it takes to deliver the messages in the protocol. The time to deliver
    messages
  prefs: []
  type: TYPE_NORMAL
- en: is quite large as compared to the local computation on the message. Time can
    be then
  prefs: []
  type: TYPE_NORMAL
- en: thought of as the number of consecutive message delays. The same algorithm from
    the
  prefs: []
  type: TYPE_NORMAL
- en: previous example running on a faultless network has *O*(1) time complexity.
  prefs: []
  type: TYPE_NORMAL
- en: '**Space Complexity**'
  prefs: []
  type: TYPE_NORMAL
- en: Space complexity deals with the total amount of space required for the algorithm
    to run.
  prefs: []
  type: TYPE_NORMAL
- en: Space complexity is mostly relevant in a shared memory framework.
  prefs: []
  type: TYPE_NORMAL
- en: In message-passing distributed systems, such as blockchains, mostly message
  prefs: []
  type: TYPE_NORMAL
- en: complexity is considered. Bit complexity is not so much relevant; however, if
    the size
  prefs: []
  type: TYPE_NORMAL
- en: of the messages is big, then this can become another complexity measure to take
    into
  prefs: []
  type: TYPE_NORMAL
- en: consideration.
  prefs: []
  type: TYPE_NORMAL
- en: Table [10-2](#p436) summarizes the complexity results of some common BFT protocols.
  prefs: []
  type: TYPE_NORMAL
- en: '***Table 10-2\.** Message complexity orders*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Protocol**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Normal Mode**'
  prefs: []
  type: TYPE_NORMAL
- en: '**View Change**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Message Delays**'
  prefs: []
  type: TYPE_NORMAL
- en: paxos
  prefs: []
  type: TYPE_NORMAL
- en: '*O*( *n*)'
  prefs: []
  type: TYPE_NORMAL
- en: '*O*( *n* 2)'
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: pBFt
  prefs: []
  type: TYPE_NORMAL
- en: '*O*( *n* 2)'
  prefs: []
  type: TYPE_NORMAL
- en: '*O*( *n* 3)'
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: tendermint
  prefs: []
  type: TYPE_NORMAL
- en: '*O*( *n* 2)'
  prefs: []
  type: TYPE_NORMAL
- en: '*O*( *n* 2)'
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: hotstuff
  prefs: []
  type: TYPE_NORMAL
- en: '*O*( *n*)'
  prefs: []
  type: TYPE_NORMAL
- en: '*O*( *n*)'
  prefs: []
  type: TYPE_NORMAL
- en: '10'
  prefs: []
  type: TYPE_NORMAL
- en: Dls
  prefs: []
  type: TYPE_NORMAL
- en: '*O*( *n* 2)'
  prefs: []
  type: TYPE_NORMAL
- en: '*O*( *n* 4)'
  prefs: []
  type: TYPE_NORMAL
- en: '*O*( *n*) rounds'
  prefs: []
  type: TYPE_NORMAL
- en: honeyBadger
  prefs: []
  type: TYPE_NORMAL
- en: '*O*( *n*)'
  prefs: []
  type: TYPE_NORMAL
- en: −
  prefs: []
  type: TYPE_NORMAL
- en: −
  prefs: []
  type: TYPE_NORMAL
- en: poW
  prefs: []
  type: TYPE_NORMAL
- en: '*O*( *n*)'
  prefs: []
  type: TYPE_NORMAL
- en: −
  prefs: []
  type: TYPE_NORMAL
- en: −
  prefs: []
  type: TYPE_NORMAL
- en: With these costs in mind, we can think of several bottlenecks in blockchain
  prefs: []
  type: TYPE_NORMAL
- en: consensus protocols that result in poor performance. For example, the choice
    of all-to-
  prefs: []
  type: TYPE_NORMAL
- en: all messages will inevitably result in more complexity.
  prefs: []
  type: TYPE_NORMAL
- en: '423'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 10 ConClusion
  prefs: []
  type: TYPE_NORMAL
- en: Several techniques such as erasure coding can be used to reduce message
  prefs: []
  type: TYPE_NORMAL
- en: complexity. Another technique called star topology (one to all – all to one),
    instead of
  prefs: []
  type: TYPE_NORMAL
- en: mesh topology (all-to-all communication), can also reduce message complexity.
    Both
  prefs: []
  type: TYPE_NORMAL
- en: these techniques are used in HoneyBadger and HotStuff, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Another class of algorithms that aims to improve performance and scalability
    of
  prefs: []
  type: TYPE_NORMAL
- en: the consensus algorithms is to allow multiple nodes to act as leaders in parallel,
    that is, parallel leaders. Under this paradigm, multiple leaders can propose concurrently,
    which
  prefs: []
  type: TYPE_NORMAL
- en: results in alleviating the CPU and bandwidth costs by distributing load evenly
    across
  prefs: []
  type: TYPE_NORMAL
- en: all leaders. There are several algorithms in this category like HoneyBadger,
    Hashgraph,
  prefs: []
  type: TYPE_NORMAL
- en: and RedBelly. However, it is possible that request duplication might occur with
    parallel
  prefs: []
  type: TYPE_NORMAL
- en: leaders, which has been addressed in the Mir-BFT protocol.
  prefs: []
  type: TYPE_NORMAL
- en: Sharding is another technique that improves consensus performance. It allows
  prefs: []
  type: TYPE_NORMAL
- en: breaking up the system state and validators into smaller sections. Each shard
    is
  prefs: []
  type: TYPE_NORMAL
- en: responsible for a small subset of the entire state, and only a smaller subset
    of the global validator set is required to achieve consensus on that part of the
    state. This way, in
  prefs: []
  type: TYPE_NORMAL
- en: parallel many shards exist, and by allowing consensus to run on smaller parts,
    great
  prefs: []
  type: TYPE_NORMAL
- en: efficiency is achieved. To achieve a final state, some cross-shard communication
    and
  prefs: []
  type: TYPE_NORMAL
- en: consolidation mechanism is also required.
  prefs: []
  type: TYPE_NORMAL
- en: Another technique to improve throughput is to offload data from the main chain
  prefs: []
  type: TYPE_NORMAL
- en: to layer 2\. Some techniques are developed in this regard, such as payment channels,
  prefs: []
  type: TYPE_NORMAL
- en: lightning network for Bitcoin, commit chains, and Plasma. Techniques such as
    zero
  prefs: []
  type: TYPE_NORMAL
- en: knowledge are used to provide evidence of off-chain execution. Prism and Bitcoin-NG
  prefs: []
  type: TYPE_NORMAL
- en: are some of the techniques to improve consensus performance.
  prefs: []
  type: TYPE_NORMAL
- en: DAG-based consensus discussed earlier aims to improve performance by
  prefs: []
  type: TYPE_NORMAL
- en: introducing graph-based structures that allow for non-interdependent commands
    to be
  prefs: []
  type: TYPE_NORMAL
- en: committed in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: Parallel execution of commands/smart contracts are also a technique that is
  prefs: []
  type: TYPE_NORMAL
- en: proposed to improve performance. Parallel smart contracts (called Sealevel)
    are
  prefs: []
  type: TYPE_NORMAL
- en: supported in the Solana blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: '**Comparison of Protocols**'
  prefs: []
  type: TYPE_NORMAL
- en: We can compare consensus algorithms from different perspectives. Ta[ble 10-3](#p438)
  prefs: []
  type: TYPE_NORMAL
- en: summarizes the results.
  prefs: []
  type: TYPE_NORMAL
- en: '424'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 10 ConClusion
  prefs: []
  type: TYPE_NORMAL
- en: '***Table 10-3\.** Comparison of the main consensus algorithms*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Property**'
  prefs: []
  type: TYPE_NORMAL
- en: '**POW**'
  prefs: []
  type: TYPE_NORMAL
- en: '**POS**'
  prefs: []
  type: TYPE_NORMAL
- en: '**POA**'
  prefs: []
  type: TYPE_NORMAL
- en: '**RAFT**'
  prefs: []
  type: TYPE_NORMAL
- en: '**PBFT**'
  prefs: []
  type: TYPE_NORMAL
- en: safety
  prefs: []
  type: TYPE_NORMAL
- en: probabilistic
  prefs: []
  type: TYPE_NORMAL
- en: probabilistic Deterministic
  prefs: []
  type: TYPE_NORMAL
- en: Deterministic
  prefs: []
  type: TYPE_NORMAL
- en: Deterministic
  prefs: []
  type: TYPE_NORMAL
- en: adversary
  prefs: []
  type: TYPE_NORMAL
- en: Computational
  prefs: []
  type: TYPE_NORMAL
- en: stake
  prefs: []
  type: TYPE_NORMAL
- en: Collusion/
  prefs: []
  type: TYPE_NORMAL
- en: Collusion/
  prefs: []
  type: TYPE_NORMAL
- en: Collusion/
  prefs: []
  type: TYPE_NORMAL
- en: power control
  prefs: []
  type: TYPE_NORMAL
- en: amount
  prefs: []
  type: TYPE_NORMAL
- en: Byzantine
  prefs: []
  type: TYPE_NORMAL
- en: crash
  prefs: []
  type: TYPE_NORMAL
- en: Byzantine
  prefs: []
  type: TYPE_NORMAL
- en: Method
  prefs: []
  type: TYPE_NORMAL
- en: Math puzzle
  prefs: []
  type: TYPE_NORMAL
- en: Value
  prefs: []
  type: TYPE_NORMAL
- en: authority
  prefs: []
  type: TYPE_NORMAL
- en: leader-
  prefs: []
  type: TYPE_NORMAL
- en: primary
  prefs: []
  type: TYPE_NORMAL
- en: solving
  prefs: []
  type: TYPE_NORMAL
- en: deposit
  prefs: []
  type: TYPE_NORMAL
- en: follower
  prefs: []
  type: TYPE_NORMAL
- en: backup
  prefs: []
  type: TYPE_NORMAL
- en: network
  prefs: []
  type: TYPE_NORMAL
- en: synchronous
  prefs: []
  type: TYPE_NORMAL
- en: synchronous synchronous
  prefs: []
  type: TYPE_NORMAL
- en: partially
  prefs: []
  type: TYPE_NORMAL
- en: partially
  prefs: []
  type: TYPE_NORMAL
- en: model
  prefs: []
  type: TYPE_NORMAL
- en: synchronous
  prefs: []
  type: TYPE_NORMAL
- en: synchronous
  prefs: []
  type: TYPE_NORMAL
- en: incentive
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes'
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes'
  prefs: []
  type: TYPE_NORMAL
- en: 'no'
  prefs: []
  type: TYPE_NORMAL
- en: 'no'
  prefs: []
  type: TYPE_NORMAL
- en: 'no'
  prefs: []
  type: TYPE_NORMAL
- en: access
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: permissioned
  prefs: []
  type: TYPE_NORMAL
- en: permissioned permissioned
  prefs: []
  type: TYPE_NORMAL
- en: control
  prefs: []
  type: TYPE_NORMAL
- en: Block
  prefs: []
  type: TYPE_NORMAL
- en: Block header
  prefs: []
  type: TYPE_NORMAL
- en: staking rules identify check
  prefs: []
  type: TYPE_NORMAL
- en: seal check
  prefs: []
  type: TYPE_NORMAL
- en: seal check
  prefs: []
  type: TYPE_NORMAL
- en: validation
  prefs: []
  type: TYPE_NORMAL
- en: check/poW valid
  prefs: []
  type: TYPE_NORMAL
- en: Finality
  prefs: []
  type: TYPE_NORMAL
- en: probabilistic
  prefs: []
  type: TYPE_NORMAL
- en: economic
  prefs: []
  type: TYPE_NORMAL
- en: Deterministic
  prefs: []
  type: TYPE_NORMAL
- en: immediate
  prefs: []
  type: TYPE_NORMAL
- en: immediate
  prefs: []
  type: TYPE_NORMAL
- en: '>50% validator'
  prefs: []
  type: TYPE_NORMAL
- en: agreement
  prefs: []
  type: TYPE_NORMAL
- en: Misbehavior Cpu/memory
  prefs: []
  type: TYPE_NORMAL
- en: stake
  prefs: []
  type: TYPE_NORMAL
- en: BFt
  prefs: []
  type: TYPE_NORMAL
- en: CFt
  prefs: []
  type: TYPE_NORMAL
- en: BFt
  prefs: []
  type: TYPE_NORMAL
- en: control
  prefs: []
  type: TYPE_NORMAL
- en: resources
  prefs: []
  type: TYPE_NORMAL
- en: penalty
  prefs: []
  type: TYPE_NORMAL
- en: election type lottery
  prefs: []
  type: TYPE_NORMAL
- en: lottery
  prefs: []
  type: TYPE_NORMAL
- en: Voting
  prefs: []
  type: TYPE_NORMAL
- en: Voting
  prefs: []
  type: TYPE_NORMAL
- en: Voting
  prefs: []
  type: TYPE_NORMAL
- en: liveness
  prefs: []
  type: TYPE_NORMAL
- en: probabilistic
  prefs: []
  type: TYPE_NORMAL
- en: probabilistic Deterministic
  prefs: []
  type: TYPE_NORMAL
- en: Deterministic
  prefs: []
  type: TYPE_NORMAL
- en: Deterministic
  prefs: []
  type: TYPE_NORMAL
- en: Cap
  prefs: []
  type: TYPE_NORMAL
- en: a over C
  prefs: []
  type: TYPE_NORMAL
- en: a over C
  prefs: []
  type: TYPE_NORMAL
- en: a over C
  prefs: []
  type: TYPE_NORMAL
- en: p over C
  prefs: []
  type: TYPE_NORMAL
- en: p over C
  prefs: []
  type: TYPE_NORMAL
- en: transaction
  prefs: []
  type: TYPE_NORMAL
- en: 10s
  prefs: []
  type: TYPE_NORMAL
- en: 100s
  prefs: []
  type: TYPE_NORMAL
- en: 10s
  prefs: []
  type: TYPE_NORMAL
- en: 1000s
  prefs: []
  type: TYPE_NORMAL
- en: 1000s
  prefs: []
  type: TYPE_NORMAL
- en: capacity
  prefs: []
  type: TYPE_NORMAL
- en: Fault
  prefs: []
  type: TYPE_NORMAL
- en: BFt
  prefs: []
  type: TYPE_NORMAL
- en: BFt
  prefs: []
  type: TYPE_NORMAL
- en: BFt
  prefs: []
  type: TYPE_NORMAL
- en: CFt
  prefs: []
  type: TYPE_NORMAL
- en: BFt
  prefs: []
  type: TYPE_NORMAL
- en: tolerance
  prefs: []
  type: TYPE_NORMAL
- en: Forking
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes'
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes'
  prefs: []
  type: TYPE_NORMAL
- en: 'no'
  prefs: []
  type: TYPE_NORMAL
- en: 'no'
  prefs: []
  type: TYPE_NORMAL
- en: 'no'
  prefs: []
  type: TYPE_NORMAL
- en: special
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes'
  prefs: []
  type: TYPE_NORMAL
- en: 'no'
  prefs: []
  type: TYPE_NORMAL
- en: 'no'
  prefs: []
  type: TYPE_NORMAL
- en: 'no'
  prefs: []
  type: TYPE_NORMAL
- en: 'no'
  prefs: []
  type: TYPE_NORMAL
- en: hardware
  prefs: []
  type: TYPE_NORMAL
- en: ( *continued*)
  prefs: []
  type: TYPE_NORMAL
- en: '425'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 10 ConClusion
  prefs: []
  type: TYPE_NORMAL
- en: '***Table 10-3\.*** ( *continued*)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Property**'
  prefs: []
  type: TYPE_NORMAL
- en: '**POW**'
  prefs: []
  type: TYPE_NORMAL
- en: '**POS**'
  prefs: []
  type: TYPE_NORMAL
- en: '**POA**'
  prefs: []
  type: TYPE_NORMAL
- en: '**RAFT**'
  prefs: []
  type: TYPE_NORMAL
- en: '**PBFT**'
  prefs: []
  type: TYPE_NORMAL
- en: example
  prefs: []
  type: TYPE_NORMAL
- en: Bitcoin
  prefs: []
  type: TYPE_NORMAL
- en: tezos
  prefs: []
  type: TYPE_NORMAL
- en: rinkeby
  prefs: []
  type: TYPE_NORMAL
- en: GoQuorum
  prefs: []
  type: TYPE_NORMAL
- en: sawtooth
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes'
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes'
  prefs: []
  type: TYPE_NORMAL
- en: 'no'
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes'
  prefs: []
  type: TYPE_NORMAL
- en: 'no'
  prefs: []
  type: TYPE_NORMAL
- en: membership
  prefs: []
  type: TYPE_NORMAL
- en: 'Notes:'
  prefs: []
  type: TYPE_NORMAL
- en: • PoA is assumed to be BFT based.
  prefs: []
  type: TYPE_NORMAL
- en: • While only a single example is given, there are many, for example,
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum uses PoW too.
  prefs: []
  type: TYPE_NORMAL
- en: • PBFT and RAFT both are state machine replication protocols with a
  prefs: []
  type: TYPE_NORMAL
- en: leader-follower architecture, also called a primary backup. Usually,
  prefs: []
  type: TYPE_NORMAL
- en: for PBFT a primary backup is used in the literature; however, for
  prefs: []
  type: TYPE_NORMAL
- en: RAFT leader-follower terms are used. Fundamentally, they serve the
  prefs: []
  type: TYPE_NORMAL
- en: same purpose.
  prefs: []
  type: TYPE_NORMAL
- en: '**Network Model**'
  prefs: []
  type: TYPE_NORMAL
- en: We can model a blockchain network in several ways, as shown in the following.
  prefs: []
  type: TYPE_NORMAL
- en: Fundamentally, the networks are either synchronous, asynchronous, or partially
  prefs: []
  type: TYPE_NORMAL
- en: synchronous. However, in literature several terms are used and as such explained
    as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '**Synchronous**'
  prefs: []
  type: TYPE_NORMAL
- en: All messages are delivered within delta *Δ* time.
  prefs: []
  type: TYPE_NORMAL
- en: '**Eventual Synchrony**'
  prefs: []
  type: TYPE_NORMAL
- en: After an unknown global stabilization time (GST), all messages are delivered
    within
  prefs: []
  type: TYPE_NORMAL
- en: delta *Δ* time.
  prefs: []
  type: TYPE_NORMAL
- en: '**Partial Synchrony**'
  prefs: []
  type: TYPE_NORMAL
- en: A protocol does not know what delta *Δ* is.
  prefs: []
  type: TYPE_NORMAL
- en: '426'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 10 ConClusion
  prefs: []
  type: TYPE_NORMAL
- en: '**Weak Synchrony**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Δ* varies with time. In practice, the *Δ* increases systematically until liveness
    is achieved.'
  prefs: []
  type: TYPE_NORMAL
- en: However, the delays are not expected to grow exponentially.
  prefs: []
  type: TYPE_NORMAL
- en: '**Asynchronous**'
  prefs: []
  type: TYPE_NORMAL
- en: All messages are eventually delivered but have no fixed upper bound on message
  prefs: []
  type: TYPE_NORMAL
- en: delivery time. The message delivery delay is finite, but no time bound is assumed
    on it.
  prefs: []
  type: TYPE_NORMAL
- en: Adversaries are primarily of two types, a static adversary and an adaptive adversary.
  prefs: []
  type: TYPE_NORMAL
- en: A static adversary performs corruption before the protocol executes, whereas
    an
  prefs: []
  type: TYPE_NORMAL
- en: adaptive adversary can cause corruption anytime during the execution of the
    protocol.
  prefs: []
  type: TYPE_NORMAL
- en: There are two crash models, a crash failure model and a Byzantine failure model.
  prefs: []
  type: TYPE_NORMAL
- en: Round-based algorithms have a send step, receive step, and compute step, which
    make
  prefs: []
  type: TYPE_NORMAL
- en: one round.
  prefs: []
  type: TYPE_NORMAL
- en: We can think of several aspects of consensus protocols that we can use to study,
  prefs: []
  type: TYPE_NORMAL
- en: 'evaluate, or classify them:'
  prefs: []
  type: TYPE_NORMAL
- en: '• **Fault tolerance/resilience level**: BFT or CFT.'
  prefs: []
  type: TYPE_NORMAL
- en: '• **Time complexity**: How long the protocol takes to run and how many'
  prefs: []
  type: TYPE_NORMAL
- en: message delays.
  prefs: []
  type: TYPE_NORMAL
- en: '• **Message complexity**: What is the message complexity of the protocol'
  prefs: []
  type: TYPE_NORMAL
- en: in terms of the number of messages exchanged?
  prefs: []
  type: TYPE_NORMAL
- en: '• **Trusted setup**: Does the protocol need any setup like PKI or no'
  prefs: []
  type: TYPE_NORMAL
- en: dealer is required?
  prefs: []
  type: TYPE_NORMAL
- en: • What is the adversary strength assumed in the model? Is it bounded
  prefs: []
  type: TYPE_NORMAL
- en: or unbounded? What is the adversary corruption model? Is it static or
  prefs: []
  type: TYPE_NORMAL
- en: adaptive?
  prefs: []
  type: TYPE_NORMAL
- en: • What is the network model? Synchronous, asynchronous, or partially
  prefs: []
  type: TYPE_NORMAL
- en: synchronous and its variations.
  prefs: []
  type: TYPE_NORMAL
- en: • Is the protocol probabilistic or deterministic?
  prefs: []
  type: TYPE_NORMAL
- en: • Does it use any cryptography?
  prefs: []
  type: TYPE_NORMAL
- en: '427'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 10 ConClusion
  prefs: []
  type: TYPE_NORMAL
- en: '• **Computational assumptions**: Information-theoretic security or'
  prefs: []
  type: TYPE_NORMAL
- en: computational security.
  prefs: []
  type: TYPE_NORMAL
- en: '• **Membership**: Dynamic or fixed, permissioned, or public.'
  prefs: []
  type: TYPE_NORMAL
- en: Such questions are useful to ask when analyzing a consensus protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just two more points to remember about consensus algorithms are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Consensus algorithms aim to reach consensus on a single value,
  prefs: []
  type: TYPE_NORMAL
- en: whereas SMR uses a consensus algorithm to decide on a sequence
  prefs: []
  type: TYPE_NORMAL
- en: of operations for replication.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Remember that PoW is not a consensus algorithm. It is a Sybil
  prefs: []
  type: TYPE_NORMAL
- en: resistance mechanism; the consensus is reached via the choice
  prefs: []
  type: TYPE_NORMAL
- en: of longest chain. Similarly, PoS is not a consensus algorithm. It is
  prefs: []
  type: TYPE_NORMAL
- en: also a Sybil resistance mechanism, but decision on the canonical
  prefs: []
  type: TYPE_NORMAL
- en: truth (choice of fork) is made by a BFT-style algorithm. We can
  prefs: []
  type: TYPE_NORMAL
- en: think of it as a coupled mechanism where PoS is a Sybil control
  prefs: []
  type: TYPE_NORMAL
- en: mechanism, whereas fork selection and finalization are done via
  prefs: []
  type: TYPE_NORMAL
- en: a BFT-style algorithm. Similarly, PoH in Solana is a sequencing of
  prefs: []
  type: TYPE_NORMAL
- en: events mechanism (an event orderer) which also allows for leader
  prefs: []
  type: TYPE_NORMAL
- en: selection in a trustless manner; however, the decision on the final
  prefs: []
  type: TYPE_NORMAL
- en: chain is made by voting on forks by a BFT-style algorithm called
  prefs: []
  type: TYPE_NORMAL
- en: TowerBFT.
  prefs: []
  type: TYPE_NORMAL
- en: '**Research Directions**'
  prefs: []
  type: TYPE_NORMAL
- en: Blockchain consensus is a very ripe area for research. Even though tremendous
    progress
  prefs: []
  type: TYPE_NORMAL
- en: has been made, still there are a few open research problems which should be
    addressed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of these problems are listed as follows, with possible direction of research:'
  prefs: []
  type: TYPE_NORMAL
- en: • Most blockchain protocols, especially permissioned blockchain
  prefs: []
  type: TYPE_NORMAL
- en: protocols, are based on PBFT. However, the world is evolving, and
  prefs: []
  type: TYPE_NORMAL
- en: since 1999, when PBFT was introduced, a lot has changed. There
  prefs: []
  type: TYPE_NORMAL
- en: have been attempts to use PBFT in blockchains by modifying it to
  prefs: []
  type: TYPE_NORMAL
- en: blockchain needs, and it does work, but efficiency and scalability are
  prefs: []
  type: TYPE_NORMAL
- en: still issues that need to be addressed. The future of the blockchain is
  prefs: []
  type: TYPE_NORMAL
- en: multichain and heterogeneous. Also, there will be all sorts of different
  prefs: []
  type: TYPE_NORMAL
- en: '428'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 10 ConClusion
  prefs: []
  type: TYPE_NORMAL
- en: devices ranging from computers to lightweight resource-constrained
  prefs: []
  type: TYPE_NORMAL
- en: IoT systems or mobile devices. Such a heterogeneous network
  prefs: []
  type: TYPE_NORMAL
- en: requires another consensus mechanism that can withstand millions
  prefs: []
  type: TYPE_NORMAL
- en: of heterogeneous devices with an asynchronous network. Cross-
  prefs: []
  type: TYPE_NORMAL
- en: chain transactions and consensus are another aspect that needs
  prefs: []
  type: TYPE_NORMAL
- en: further research. Some research on asynchronous BFT protocols has
  prefs: []
  type: TYPE_NORMAL
- en: resulted in HoneyBadger BFT and BEAT, and, of course, we can do
  prefs: []
  type: TYPE_NORMAL
- en: more. Similarly, Casper FFG, Casper CBC, GRANDPA, and BABE are
  prefs: []
  type: TYPE_NORMAL
- en: the steps in the right direction for a multichain heterogeneous future.
  prefs: []
  type: TYPE_NORMAL
- en: However, significant work still needs to be done.
  prefs: []
  type: TYPE_NORMAL
- en: • As the blockchain technology evolves, so do the adversaries. There
  prefs: []
  type: TYPE_NORMAL
- en: is a possibility of novel attack techniques, which, due to possible
  prefs: []
  type: TYPE_NORMAL
- en: economic incentives on blockchains, can manifest sooner rather than
  prefs: []
  type: TYPE_NORMAL
- en: later. This is so because concerned parties are willing to invest with
  prefs: []
  type: TYPE_NORMAL
- en: the hope that new novel techniques for hacking blockchain networks
  prefs: []
  type: TYPE_NORMAL
- en: will result in immediate revenue.
  prefs: []
  type: TYPE_NORMAL
- en: • The use of quantum computing to enhance the classical results is
  prefs: []
  type: TYPE_NORMAL
- en: an interesting topic. For example, a quantum computer can run in
  prefs: []
  type: TYPE_NORMAL
- en: parallel with a classical distributed network or a blockchain. The
  prefs: []
  type: TYPE_NORMAL
- en: quantum computer can elect a leader using the W state–based
  prefs: []
  type: TYPE_NORMAL
- en: quantum leader election algorithm (discussed in Chapt[er 9](https://doi.org/10.1007/978-1-4842-8179-6_9))
    and pass the result on to the classical blockchain/distributed network.
  prefs: []
  type: TYPE_NORMAL
- en: Such techniques can improve the security and efficiency of existing
  prefs: []
  type: TYPE_NORMAL
- en: classical networks.
  prefs: []
  type: TYPE_NORMAL
- en: • Classical permissioned network–related results cannot be directly
  prefs: []
  type: TYPE_NORMAL
- en: applied to the permissionless settings; therefore, a need to modify
  prefs: []
  type: TYPE_NORMAL
- en: those protocols to suit the blockchain world is needed. Some work is
  prefs: []
  type: TYPE_NORMAL
- en: already done, for example, Casper FFG is inspired by PBFT.
  prefs: []
  type: TYPE_NORMAL
- en: • Scalability and privacy of consensus protocols is an area of extreme
  prefs: []
  type: TYPE_NORMAL
- en: 'importance. Privacy has two facets in the blockchain world:'
  prefs: []
  type: TYPE_NORMAL
- en: transaction value confidentiality and hiding users’ identities
  prefs: []
  type: TYPE_NORMAL
- en: participating on the network. Scalability is concerned with node
  prefs: []
  type: TYPE_NORMAL
- en: scalability as well as transaction throughput.
  prefs: []
  type: TYPE_NORMAL
- en: '429'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 10 ConClusion
  prefs: []
  type: TYPE_NORMAL
- en: • Mechanism design is a branch of microeconomics and built on the
  prefs: []
  type: TYPE_NORMAL
- en: concept of game theory that studies how to design protocols that
  prefs: []
  type: TYPE_NORMAL
- en: use incentivization to encourage rational actors to behave correctly.
  prefs: []
  type: TYPE_NORMAL
- en: It is also called reverse game theory. It starts with an outcome and
  prefs: []
  type: TYPE_NORMAL
- en: studies how entities in the system can work collaboratively to achieve
  prefs: []
  type: TYPE_NORMAL
- en: a desired goal. As blockchains are cryptoeconomic incentive systems,
  prefs: []
  type: TYPE_NORMAL
- en: much can be learned from the field of mechanism design. We can
  prefs: []
  type: TYPE_NORMAL
- en: apply techniques and methods from the field of mechanism design to
  prefs: []
  type: TYPE_NORMAL
- en: develop novel blockchain protocols that are robust.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs: []
  type: TYPE_NORMAL
- en: In this last chapter, we summarized what we learned throughout this book. We
    also
  prefs: []
  type: TYPE_NORMAL
- en: covered the algorithms that we did not before, especially new consensus protocols
  prefs: []
  type: TYPE_NORMAL
- en: such as Avalanche and Ebb-and-Flow protocols. We also touched upon some research
  prefs: []
  type: TYPE_NORMAL
- en: directions which require further work. We have come a long way from the Byzantine
  prefs: []
  type: TYPE_NORMAL
- en: generals problem to Nakamoto consensus and now multichain consensus protocols.
  prefs: []
  type: TYPE_NORMAL
- en: This is such a ripe area for research that we’ll only see more progress in it
    with more
  prefs: []
  type: TYPE_NORMAL
- en: innovative ideas in the future.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we have explored the foundations of a blockchain and distributed
  prefs: []
  type: TYPE_NORMAL
- en: consensus. We learned what impact quantum computing can have on distributed
  prefs: []
  type: TYPE_NORMAL
- en: consensus and how an agreement could be achieved in quantum networks. Blockchain
  prefs: []
  type: TYPE_NORMAL
- en: consensus is possibly the strongest area for research in the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: Thank you for staying with me in this wonderful journey. You are now capable
    of
  prefs: []
  type: TYPE_NORMAL
- en: applying the knowledge from this book as a blockchain researcher and continuing
    your
  prefs: []
  type: TYPE_NORMAL
- en: learning and research in the field of blockchain consensus.
  prefs: []
  type: TYPE_NORMAL
- en: '**Bibliography**'
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Decentralized thoughts: [https://decentralizedthoughts.](https://decentralizedthoughts.github.io)'
  prefs: []
  type: TYPE_NORMAL
- en: '[github.io](https://decentralizedthoughts.github.io)'
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Xiao, Y., Zhang, N., Lou, W., and Hou, Y.T., 2020\. A survey of
  prefs: []
  type: TYPE_NORMAL
- en: distributed consensus protocols for blockchain networks. *IEEE*
  prefs: []
  type: TYPE_NORMAL
- en: '*Communications Surveys & Tutorials*, *22*(2), pp. 1432–1465\.'
  prefs: []
  type: TYPE_NORMAL
- en: '430'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 10 ConClusion
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Miller, A., Xia, Y., Croman, K., Shi, E., and Song, D., 2016, October.
  prefs: []
  type: TYPE_NORMAL
- en: The honeybadger of BFT protocols. In *Proceedings of the 2016*
  prefs: []
  type: TYPE_NORMAL
- en: '*ACM SIGSAC conference on computer and communications*'
  prefs: []
  type: TYPE_NORMAL
- en: '*security* (pp. 31–42).'
  prefs: []
  type: TYPE_NORMAL
- en: 4\. Lewis-Pye, A. and Roughgarden, T., 2020\. Resource pools and the
  prefs: []
  type: TYPE_NORMAL
- en: cap theorem. *arXiv preprint arXiv:2006.10698*.
  prefs: []
  type: TYPE_NORMAL
- en: '5\. Neu, J., Tas, E.N., and Tse, D., 2021, May. Ebb-and-flow protocols:'
  prefs: []
  type: TYPE_NORMAL
- en: A resolution of the availability-finality dilemma. In *2021 IEEE*
  prefs: []
  type: TYPE_NORMAL
- en: '*Symposium on Security and Privacy (SP)* (pp. 446–465). IEEE.'
  prefs: []
  type: TYPE_NORMAL
- en: '6\. Tim Roughgarden Lectures on foundations of blockchains:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://youtu.be/EfsSV7ni2ZM](https://youtu.be/EfsSV7ni2ZM)'
  prefs: []
  type: TYPE_NORMAL
- en: '7\. Fokkink, W., 2018\. *Distributed algorithms: an intuitive approach*.'
  prefs: []
  type: TYPE_NORMAL
- en: MIT Press.
  prefs: []
  type: TYPE_NORMAL
- en: '8\. More on mechanism design and blockchains her[e: https://](https://medium.com/blockchannel/a-crash-course-in-mechanism-design-for-cryptoeconomic-applications-a9f06ab6a976)'
  prefs: []
  type: TYPE_NORMAL
- en: '[medium.com/blockchannel/a-crash-course-in-mechanism-](https://medium.com/blockchannel/a-crash-course-in-mechanism-design-for-cryptoeconomic-applications-a9f06ab6a976)'
  prefs: []
  type: TYPE_NORMAL
- en: '[design-for-cryptoeconomic-applications-a9f06ab6a976](https://medium.com/blockchannel/a-crash-course-in-mechanism-design-for-cryptoeconomic-applications-a9f06ab6a976)'
  prefs: []
  type: TYPE_NORMAL
- en: '431'
  prefs: []
  type: TYPE_NORMAL
- en: '**Index**'
  prefs: []
  type: TYPE_NORMAL
- en: '**A**'
  prefs: []
  type: TYPE_NORMAL
- en: '**B**'
  prefs: []
  type: TYPE_NORMAL
- en: Account state, 197, 200, 201
  prefs: []
  type: TYPE_NORMAL
- en: Ben-Or algorithms, 400
  prefs: []
  type: TYPE_NORMAL
- en: ACID consistency model, 262
  prefs: []
  type: TYPE_NORMAL
- en: asynchronous rounds, 278
  prefs: []
  type: TYPE_NORMAL
- en: Ack implosion, 120
  prefs: []
  type: TYPE_NORMAL
- en: benign faults/crash faults, 279–283
  prefs: []
  type: TYPE_NORMAL
- en: Adaptive adversary, 37, 427
  prefs: []
  type: TYPE_NORMAL
- en: binary consensus, 278
  prefs: []
  type: TYPE_NORMAL
- en: Advanced Encryption Standard (AES), 77
  prefs: []
  type: TYPE_NORMAL
- en: definition, 278, 284
  prefs: []
  type: TYPE_NORMAL
- en: Adversary model
  prefs: []
  type: TYPE_NORMAL
- en: failure detectors,
  prefs: []
  type: TYPE_NORMAL
- en: definition, 36
  prefs: []
  type: TYPE_NORMAL
- en: consensus, 284–286
  prefs: []
  type: TYPE_NORMAL
- en: types
  prefs: []
  type: TYPE_NORMAL
- en: Bernoulli trial, 229
  prefs: []
  type: TYPE_NORMAL
- en: dynamic, 37
  prefs: []
  type: TYPE_NORMAL
- en: Binary consensus, 127, 278
  prefs: []
  type: TYPE_NORMAL
- en: passive, 37
  prefs: []
  type: TYPE_NORMAL
- en: Bitcoin
  prefs: []
  type: TYPE_NORMAL
- en: static, 37
  prefs: []
  type: TYPE_NORMAL
- en: address and accounts, 185, 186
  prefs: []
  type: TYPE_NORMAL
- en: threshold, 36
  prefs: []
  type: TYPE_NORMAL
- en: blocks, 190
  prefs: []
  type: TYPE_NORMAL
- en: Aggregate signatures, 94, 99–101
  prefs: []
  type: TYPE_NORMAL
- en: cryptography, 169, 184–188
  prefs: []
  type: TYPE_NORMAL
- en: Agreement
  prefs: []
  type: TYPE_NORMAL
- en: digital cash, 181
  prefs: []
  type: TYPE_NORMAL
- en: byzantine agreement problem, 124
  prefs: []
  type: TYPE_NORMAL
- en: digital timestamping, 181
  prefs: []
  type: TYPE_NORMAL
- en: problems, 123
  prefs: []
  type: TYPE_NORMAL
- en: electronic cash system, 181
  prefs: []
  type: TYPE_NORMAL
- en: reliable broadcast, 123
  prefs: []
  type: TYPE_NORMAL
- en: hash functions, 169
  prefs: []
  type: TYPE_NORMAL
- en: total order broadcast, 124
  prefs: []
  type: TYPE_NORMAL
- en: mining, 191
  prefs: []
  type: TYPE_NORMAL
- en: Agreement property, 117, 126, 127, 143,
  prefs: []
  type: TYPE_NORMAL
- en: node, 181–184
  prefs: []
  type: TYPE_NORMAL
- en: 250, 407
  prefs: []
  type: TYPE_NORMAL
- en: platform, 191
  prefs: []
  type: TYPE_NORMAL
- en: Apache ZooKeeper, 305
  prefs: []
  type: TYPE_NORMAL
- en: pseudonym, 181
  prefs: []
  type: TYPE_NORMAL
- en: Application-specific blockchains, 172, 361
  prefs: []
  type: TYPE_NORMAL
- en: public blockchain, 172
  prefs: []
  type: TYPE_NORMAL
- en: Application-specific validity, 210, 211
  prefs: []
  type: TYPE_NORMAL
- en: techniques, 169
  prefs: []
  type: TYPE_NORMAL
- en: Archive nodes, 194, 360
  prefs: []
  type: TYPE_NORMAL
- en: transactions, 186, 187
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous binary agreement protocol
  prefs: []
  type: TYPE_NORMAL
- en: UTXO, 186
  prefs: []
  type: TYPE_NORMAL
- en: (ABA), 414
  prefs: []
  type: TYPE_NORMAL
- en: Bitcoin address generation
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous common subset
  prefs: []
  type: TYPE_NORMAL
- en: process, 185, 186
  prefs: []
  type: TYPE_NORMAL
- en: (ACS), 414
  prefs: []
  type: TYPE_NORMAL
- en: Bitcoin cryptocurrency, 170, 172
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous distributed systems, 7, 32
  prefs: []
  type: TYPE_NORMAL
- en: Bitcoin network, 181, 182, 187, 217, 236,
  prefs: []
  type: TYPE_NORMAL
- en: Atomic clocks, 41–43, 343
  prefs: []
  type: TYPE_NORMAL
- en: 247, 253
  prefs: []
  type: TYPE_NORMAL
- en: Avalanche, 102, 415, 430
  prefs: []
  type: TYPE_NORMAL
- en: Bitcoin node architecture, 181–184
  prefs: []
  type: TYPE_NORMAL
- en: '433'
  prefs: []
  type: TYPE_NORMAL
- en: © Imran Bashir 2022
  prefs: []
  type: TYPE_NORMAL
- en: I. Bashir, *Blockchain Consensus*, [https://doi.org/10.1007/978-1-4842-8179-6](https://doi.org/10.1007/978-1-4842-8179-6#DOI)
  prefs: []
  type: TYPE_NORMAL
- en: INDEX
  prefs: []
  type: TYPE_NORMAL
- en: Bitcoin P2PKH script execution, 189
  prefs: []
  type: TYPE_NORMAL
- en: consortium chains, 207
  prefs: []
  type: TYPE_NORMAL
- en: Bitcoin script, 189
  prefs: []
  type: TYPE_NORMAL
- en: data integrity and consistency, 207
  prefs: []
  type: TYPE_NORMAL
- en: components, 188
  prefs: []
  type: TYPE_NORMAL
- en: distributed systems, 208
  prefs: []
  type: TYPE_NORMAL
- en: non-Turing complete, 188
  prefs: []
  type: TYPE_NORMAL
- en: PoW, 207
  prefs: []
  type: TYPE_NORMAL
- en: opcodes, 188
  prefs: []
  type: TYPE_NORMAL
- en: properties ( *see* Nakamoto consensus;
  prefs: []
  type: TYPE_NORMAL
- en: P2PKH, 189
  prefs: []
  type: TYPE_NORMAL
- en: Traditional BFT consensus)
  prefs: []
  type: TYPE_NORMAL
- en: transferring payments, 189
  prefs: []
  type: TYPE_NORMAL
- en: public blockchain system model, 213
  prefs: []
  type: TYPE_NORMAL
- en: unlocking + locking, 189
  prefs: []
  type: TYPE_NORMAL
- en: traditional perspective, 207
  prefs: []
  type: TYPE_NORMAL
- en: Bitcoin transaction life cycle, 186, 187
  prefs: []
  type: TYPE_NORMAL
- en: Blockchain ledger abstraction, 175, 203
  prefs: []
  type: TYPE_NORMAL
- en: Bitcoin transaction UTXO model, 186
  prefs: []
  type: TYPE_NORMAL
- en: Blockchain properties
  prefs: []
  type: TYPE_NORMAL
- en: Bitgold, 169
  prefs: []
  type: TYPE_NORMAL
- en: append only, 177
  prefs: []
  type: TYPE_NORMAL
- en: Blind Assignment for Blockchain
  prefs: []
  type: TYPE_NORMAL
- en: consistency, 176
  prefs: []
  type: TYPE_NORMAL
- en: Extension (BABE), 362
  prefs: []
  type: TYPE_NORMAL
- en: fault-tolerant, 176
  prefs: []
  type: TYPE_NORMAL
- en: Blind signatures, 168
  prefs: []
  type: TYPE_NORMAL
- en: finality, 176
  prefs: []
  type: TYPE_NORMAL
- en: Block-based DAG, 416
  prefs: []
  type: TYPE_NORMAL
- en: immutability, 177
  prefs: []
  type: TYPE_NORMAL
- en: Blockchain
  prefs: []
  type: TYPE_NORMAL
- en: internet growth, 178
  prefs: []
  type: TYPE_NORMAL
- en: benefits, 170, 171
  prefs: []
  type: TYPE_NORMAL
- en: order, 177
  prefs: []
  type: TYPE_NORMAL
- en: Bitcoin, 170
  prefs: []
  type: TYPE_NORMAL
- en: programmability, 178
  prefs: []
  type: TYPE_NORMAL
- en: definition, 167, 168
  prefs: []
  type: TYPE_NORMAL
- en: state machine replication
  prefs: []
  type: TYPE_NORMAL
- en: digital timestamping, 169
  prefs: []
  type: TYPE_NORMAL
- en: protocol, 178
  prefs: []
  type: TYPE_NORMAL
- en: distributed ledger, 173
  prefs: []
  type: TYPE_NORMAL
- en: tamper resistant/proof, 177
  prefs: []
  type: TYPE_NORMAL
- en: fundamental issues, 168
  prefs: []
  type: TYPE_NORMAL
- en: termination guarantee, 177
  prefs: []
  type: TYPE_NORMAL
- en: generic platform, 172
  prefs: []
  type: TYPE_NORMAL
- en: validity, 177
  prefs: []
  type: TYPE_NORMAL
- en: origins, 168, 203
  prefs: []
  type: TYPE_NORMAL
- en: verifiable, 178
  prefs: []
  type: TYPE_NORMAL
- en: platforms ( *see* Bitcoin; Ethereum)
  prefs: []
  type: TYPE_NORMAL
- en: Block ciphers
  prefs: []
  type: TYPE_NORMAL
- en: shared data platforms, 173
  prefs: []
  type: TYPE_NORMAL
- en: CBC, 75
  prefs: []
  type: TYPE_NORMAL
- en: structure, 179–181
  prefs: []
  type: TYPE_NORMAL
- en: cryptographic hash mode, 77
  prefs: []
  type: TYPE_NORMAL
- en: types, 172, 173
  prefs: []
  type: TYPE_NORMAL
- en: CTR mode, 76
  prefs: []
  type: TYPE_NORMAL
- en: working mechanism, 178, 179
  prefs: []
  type: TYPE_NORMAL
- en: definition, 73
  prefs: []
  type: TYPE_NORMAL
- en: Blockchain age protocols
  prefs: []
  type: TYPE_NORMAL
- en: DES, 74
  prefs: []
  type: TYPE_NORMAL
- en: consensus algorithm, 332
  prefs: []
  type: TYPE_NORMAL
- en: ECB, 74
  prefs: []
  type: TYPE_NORMAL
- en: consensus protocols, 331
  prefs: []
  type: TYPE_NORMAL
- en: keystream generation mode, 76
  prefs: []
  type: TYPE_NORMAL
- en: traditional, 331
  prefs: []
  type: TYPE_NORMAL
- en: MAC, 77
  prefs: []
  type: TYPE_NORMAL
- en: Blockchain consensus, 210, 428–430
  prefs: []
  type: TYPE_NORMAL
- en: Block validation, 240–241, 247, 250
  prefs: []
  type: TYPE_NORMAL
- en: algorithms, 207, 208
  prefs: []
  type: TYPE_NORMAL
- en: B-money, 168, 204
  prefs: []
  type: TYPE_NORMAL
- en: BFT protocols, 208
  prefs: []
  type: TYPE_NORMAL
- en: Boneh-Lynn-Shacham (BLS), 99
  prefs: []
  type: TYPE_NORMAL
- en: consortium blockchain system
  prefs: []
  type: TYPE_NORMAL
- en: Bridges, 361
  prefs: []
  type: TYPE_NORMAL
- en: model, 214
  prefs: []
  type: TYPE_NORMAL
- en: Broadcast primitives
  prefs: []
  type: TYPE_NORMAL
- en: '434'
  prefs: []
  type: TYPE_NORMAL
- en: INDEX
  prefs: []
  type: TYPE_NORMAL
- en: best-effort broadcast, 115, 116
  prefs: []
  type: TYPE_NORMAL
- en: Casper, 341, 368, 370
  prefs: []
  type: TYPE_NORMAL
- en: broadcast and consensus, relationship,
  prefs: []
  type: TYPE_NORMAL
- en: Centralized algorithms, 13
  prefs: []
  type: TYPE_NORMAL
- en: 122, 123
  prefs: []
  type: TYPE_NORMAL
- en: Centralized system, 10–12, 217
  prefs: []
  type: TYPE_NORMAL
- en: communication, 115
  prefs: []
  type: TYPE_NORMAL
- en: Chain replication, 139, 140
  prefs: []
  type: TYPE_NORMAL
- en: FIFO, 118
  prefs: []
  type: TYPE_NORMAL
- en: Chainwork value, 243
  prefs: []
  type: TYPE_NORMAL
- en: FIFO total order broadcast, 120–122
  prefs: []
  type: TYPE_NORMAL
- en: Chandra-Toueg consensus protocol, 284
  prefs: []
  type: TYPE_NORMAL
- en: protocols, 114
  prefs: []
  type: TYPE_NORMAL
- en: Chandy-Lamport snapshot algorithm, 17
  prefs: []
  type: TYPE_NORMAL
- en: reliable broadcast abstraction,
  prefs: []
  type: TYPE_NORMAL
- en: Checkpointing, 18, 315, 323
  prefs: []
  type: TYPE_NORMAL
- en: 116, 117
  prefs: []
  type: TYPE_NORMAL
- en: Cipher block chaining (CBC), 75, 77
  prefs: []
  type: TYPE_NORMAL
- en: total order broadcast/atomic
  prefs: []
  type: TYPE_NORMAL
- en: Ciphertext, 69, 71, 73, 78, 87
  prefs: []
  type: TYPE_NORMAL
- en: broadcast, 119
  prefs: []
  type: TYPE_NORMAL
- en: Classical computers, 377, 378, 380,
  prefs: []
  type: TYPE_NORMAL
- en: uniform reliable, 117, 118
  prefs: []
  type: TYPE_NORMAL
- en: 392, 403
  prefs: []
  type: TYPE_NORMAL
- en: web server and backend database, 113
  prefs: []
  type: TYPE_NORMAL
- en: Classical consensus
  prefs: []
  type: TYPE_NORMAL
- en: Byzantine agreement problem
  prefs: []
  type: TYPE_NORMAL
- en: blockchain, 327
  prefs: []
  type: TYPE_NORMAL
- en: BGP, 125
  prefs: []
  type: TYPE_NORMAL
- en: traditional distributed consensus, 163
  prefs: []
  type: TYPE_NORMAL
- en: consensus problem, 125, 126, 128
  prefs: []
  type: TYPE_NORMAL
- en: viewstamped replication
  prefs: []
  type: TYPE_NORMAL
- en: interactive consistency problem, 125
  prefs: []
  type: TYPE_NORMAL
- en: approach, 291
  prefs: []
  type: TYPE_NORMAL
- en: Byzantine fault tolerant (BFT), 37, 59, 128,
  prefs: []
  type: TYPE_NORMAL
- en: Cloud break, 342
  prefs: []
  type: TYPE_NORMAL
- en: 131, 208, 216, 291, 323
  prefs: []
  type: TYPE_NORMAL
- en: Collators, 360
  prefs: []
  type: TYPE_NORMAL
- en: Byzantine fork, 246
  prefs: []
  type: TYPE_NORMAL
- en: Commutativity, 146, 147
  prefs: []
  type: TYPE_NORMAL
- en: Byzantine Generals Problem (BGP), 125,
  prefs: []
  type: TYPE_NORMAL
- en: Completion property, 143
  prefs: []
  type: TYPE_NORMAL
- en: 133, 134
  prefs: []
  type: TYPE_NORMAL
- en: Complexity and performance
  prefs: []
  type: TYPE_NORMAL
- en: agreement, 250
  prefs: []
  type: TYPE_NORMAL
- en: communication, 422
  prefs: []
  type: TYPE_NORMAL
- en: attack time, 249
  prefs: []
  type: TYPE_NORMAL
- en: message complexity, 422
  prefs: []
  type: TYPE_NORMAL
- en: logic, 249
  prefs: []
  type: TYPE_NORMAL
- en: message delays, 422
  prefs: []
  type: TYPE_NORMAL
- en: mathematical puzzle, 249
  prefs: []
  type: TYPE_NORMAL
- en: space, 423, 424
  prefs: []
  type: TYPE_NORMAL
- en: termination, 251
  prefs: []
  type: TYPE_NORMAL
- en: time, 423
  prefs: []
  type: TYPE_NORMAL
- en: validity, 250
  prefs: []
  type: TYPE_NORMAL
- en: Concurrency, 3, 9, 10, 51, 55
  prefs: []
  type: TYPE_NORMAL
- en: Concurrent algorithms, 13
  prefs: []
  type: TYPE_NORMAL
- en: Confidentiality, 8, 28, 67, 71, 74, 178, 412
  prefs: []
  type: TYPE_NORMAL
- en: '**C**'
  prefs: []
  type: TYPE_NORMAL
- en: Consensus, 2, 209
  prefs: []
  type: TYPE_NORMAL
- en: Capability protocols, 195
  prefs: []
  type: TYPE_NORMAL
- en: algorithms, 425, 426
  prefs: []
  type: TYPE_NORMAL
- en: CAP theorem
  prefs: []
  type: TYPE_NORMAL
- en: definition, 113, 163, 259
  prefs: []
  type: TYPE_NORMAL
- en: availability, 61
  prefs: []
  type: TYPE_NORMAL
- en: distributed system ( *see* Distributed
  prefs: []
  type: TYPE_NORMAL
- en: blockchain, 175
  prefs: []
  type: TYPE_NORMAL
- en: computing)
  prefs: []
  type: TYPE_NORMAL
- en: consistency, 61
  prefs: []
  type: TYPE_NORMAL
- en: fault-tolerant, 261
  prefs: []
  type: TYPE_NORMAL
- en: definition, 61
  prefs: []
  type: TYPE_NORMAL
- en: formal verification, 417, 418
  prefs: []
  type: TYPE_NORMAL
- en: partition tolerance, 61–63
  prefs: []
  type: TYPE_NORMAL
- en: history, 131
  prefs: []
  type: TYPE_NORMAL
- en: '435'
  prefs: []
  type: TYPE_NORMAL
- en: INDEX
  prefs: []
  type: TYPE_NORMAL
- en: Consensus ( *Cont*.)
  prefs: []
  type: TYPE_NORMAL
- en: Detectable byzantine agreement
  prefs: []
  type: TYPE_NORMAL
- en: impossibility results, 421
  prefs: []
  type: TYPE_NORMAL
- en: (DBA), 407
  prefs: []
  type: TYPE_NORMAL
- en: network model, 426–428
  prefs: []
  type: TYPE_NORMAL
- en: Deutsch algorithm, 377
  prefs: []
  type: TYPE_NORMAL
- en: protocols, 261
  prefs: []
  type: TYPE_NORMAL
- en: Diffie-Hellman key exchange, 82
  prefs: []
  type: TYPE_NORMAL
- en: Consistency property, 61, 161, 421
  prefs: []
  type: TYPE_NORMAL
- en: Digital cash creation, 168, 169
  prefs: []
  type: TYPE_NORMAL
- en: Consortium/enterprise blockchains, 172
  prefs: []
  type: TYPE_NORMAL
- en: Digital clocks, 39
  prefs: []
  type: TYPE_NORMAL
- en: Consortium blockchain system
  prefs: []
  type: TYPE_NORMAL
- en: Digital signatures, 68, 85
  prefs: []
  type: TYPE_NORMAL
- en: model, 214
  prefs: []
  type: TYPE_NORMAL
- en: aggregate, 99, 100
  prefs: []
  type: TYPE_NORMAL
- en: Contract accounts (CAs), 196
  prefs: []
  type: TYPE_NORMAL
- en: definition, 94
  prefs: []
  type: TYPE_NORMAL
- en: Contract creation, 197
  prefs: []
  type: TYPE_NORMAL
- en: EDSA, 96, 97
  prefs: []
  type: TYPE_NORMAL
- en: Counter (CTR) mode, 76
  prefs: []
  type: TYPE_NORMAL
- en: multisignatures, 97, 98
  prefs: []
  type: TYPE_NORMAL
- en: CPU-bound PoW, 255
  prefs: []
  type: TYPE_NORMAL
- en: nonreusability, 95
  prefs: []
  type: TYPE_NORMAL
- en: Crash fault–tolerant (CFT), 37, 64, 127,
  prefs: []
  type: TYPE_NORMAL
- en: ring, 100
  prefs: []
  type: TYPE_NORMAL
- en: 145, 161, 179
  prefs: []
  type: TYPE_NORMAL
- en: threshold, 98, 99
  prefs: []
  type: TYPE_NORMAL
- en: Cryptoeconomics/Cryptonomics, 236
  prefs: []
  type: TYPE_NORMAL
- en: unforgeability, 94
  prefs: []
  type: TYPE_NORMAL
- en: Cryptographically secure pseudorandom
  prefs: []
  type: TYPE_NORMAL
- en: Digital timestamping, 169
  prefs: []
  type: TYPE_NORMAL
- en: number generator (CSPRNG/
  prefs: []
  type: TYPE_NORMAL
- en: Direct acyclic graph (DAG), 201
  prefs: []
  type: TYPE_NORMAL
- en: CPRNG), 72
  prefs: []
  type: TYPE_NORMAL
- en: Distributed computing, 236
  prefs: []
  type: TYPE_NORMAL
- en: Cryptographic primitives, 64, 68, 70, 107,
  prefs: []
  type: TYPE_NORMAL
- en: byzantine failure, 148
  prefs: []
  type: TYPE_NORMAL
- en: 109, 169, 284
  prefs: []
  type: TYPE_NORMAL
- en: CFT, 148
  prefs: []
  type: TYPE_NORMAL
- en: Cryptography, 169
  prefs: []
  type: TYPE_NORMAL
- en: consensus solving, using failure
  prefs: []
  type: TYPE_NORMAL
- en: basic mathematics, 79, 80
  prefs: []
  type: TYPE_NORMAL
- en: detector, 160
  prefs: []
  type: TYPE_NORMAL
- en: Bitcoin blockchain security, 184
  prefs: []
  type: TYPE_NORMAL
- en: FLP impossibility result
  prefs: []
  type: TYPE_NORMAL
- en: definition, 67
  prefs: []
  type: TYPE_NORMAL
- en: definition, 149
  prefs: []
  type: TYPE_NORMAL
- en: entity authentication, 67
  prefs: []
  type: TYPE_NORMAL
- en: failure detectors, 154–157, 159
  prefs: []
  type: TYPE_NORMAL
- en: primitives, 70
  prefs: []
  type: TYPE_NORMAL
- en: hybrid models, 153
  prefs: []
  type: TYPE_NORMAL
- en: public/private key, 184, 185
  prefs: []
  type: TYPE_NORMAL
- en: leader elector failure detectors, 159
  prefs: []
  type: TYPE_NORMAL
- en: symmetric, 70
  prefs: []
  type: TYPE_NORMAL
- en: random oracles, 152, 153
  prefs: []
  type: TYPE_NORMAL
- en: typical model, 68, 69
  prefs: []
  type: TYPE_NORMAL
- en: synchrony assumption, 152
  prefs: []
  type: TYPE_NORMAL
- en: values, 149
  prefs: []
  type: TYPE_NORMAL
- en: '**D**'
  prefs: []
  type: TYPE_NORMAL
- en: impossibility results, 147
  prefs: []
  type: TYPE_NORMAL
- en: minimum number of process, 148
  prefs: []
  type: TYPE_NORMAL
- en: DAG-based ledgers, 415
  prefs: []
  type: TYPE_NORMAL
- en: Distributed consensus, 208, 411
  prefs: []
  type: TYPE_NORMAL
- en: Dagger-Hashimoto algorithm, 339
  prefs: []
  type: TYPE_NORMAL
- en: Distributed ledger, 173
  prefs: []
  type: TYPE_NORMAL
- en: Data Encryption Standard (DES), 74
  prefs: []
  type: TYPE_NORMAL
- en: Distributed systems
  prefs: []
  type: TYPE_NORMAL
- en: Data sharding, 21
  prefs: []
  type: TYPE_NORMAL
- en: algorithms, 12
  prefs: []
  type: TYPE_NORMAL
- en: Decentralized applications
  prefs: []
  type: TYPE_NORMAL
- en: centralized *vs*. decentralized *vs*.
  prefs: []
  type: TYPE_NORMAL
- en: (DApps), 192
  prefs: []
  type: TYPE_NORMAL
- en: distributed, 10, 12
  prefs: []
  type: TYPE_NORMAL
- en: '436'
  prefs: []
  type: TYPE_NORMAL
- en: INDEX
  prefs: []
  type: TYPE_NORMAL
- en: challenges
  prefs: []
  type: TYPE_NORMAL
- en: Dominant strategy, 234
  prefs: []
  type: TYPE_NORMAL
- en: concurrency, 9
  prefs: []
  type: TYPE_NORMAL
- en: Double SHA-256 hash
  prefs: []
  type: TYPE_NORMAL
- en: distribution transparency, 8
  prefs: []
  type: TYPE_NORMAL
- en: function, 222
  prefs: []
  type: TYPE_NORMAL
- en: fault tolerance, 7
  prefs: []
  type: TYPE_NORMAL
- en: Dueling proposers, 302
  prefs: []
  type: TYPE_NORMAL
- en: global state, 9
  prefs: []
  type: TYPE_NORMAL
- en: heterogeneity, 8
  prefs: []
  type: TYPE_NORMAL
- en: '**E**'
  prefs: []
  type: TYPE_NORMAL
- en: security, 8
  prefs: []
  type: TYPE_NORMAL
- en: timing/synchronization, 9
  prefs: []
  type: TYPE_NORMAL
- en: Eager reliable broadcast, 121
  prefs: []
  type: TYPE_NORMAL
- en: cryptography, 63
  prefs: []
  type: TYPE_NORMAL
- en: Electronic codebook (ECB), 74
  prefs: []
  type: TYPE_NORMAL
- en: definition, 1–3, 64
  prefs: []
  type: TYPE_NORMAL
- en: Elliptic curve cryptography (ECC)
  prefs: []
  type: TYPE_NORMAL
- en: elements, 14–18
  prefs: []
  type: TYPE_NORMAL
- en: definition, 88, 89
  prefs: []
  type: TYPE_NORMAL
- en: fundamental properties, 2
  prefs: []
  type: TYPE_NORMAL
- en: ECDLP, 92
  prefs: []
  type: TYPE_NORMAL
- en: inherently distributed, 6
  prefs: []
  type: TYPE_NORMAL
- en: point addition, 89, 90
  prefs: []
  type: TYPE_NORMAL
- en: parallel *vs.* distributed *vs.*
  prefs: []
  type: TYPE_NORMAL
- en: point doubling, 91
  prefs: []
  type: TYPE_NORMAL
- en: concurrency, 10
  prefs: []
  type: TYPE_NORMAL
- en: scalar point multiplication, 92
  prefs: []
  type: TYPE_NORMAL
- en: performance, 5
  prefs: []
  type: TYPE_NORMAL
- en: Elliptic curve discrete logarithm
  prefs: []
  type: TYPE_NORMAL
- en: physical architecture *vs*. abstract
  prefs: []
  type: TYPE_NORMAL
- en: problem (ECDLP), 92
  prefs: []
  type: TYPE_NORMAL
- en: system, 26
  prefs: []
  type: TYPE_NORMAL
- en: Elliptic Curve Integrated Encryption
  prefs: []
  type: TYPE_NORMAL
- en: processes/computers/nodes, 3
  prefs: []
  type: TYPE_NORMAL
- en: Scheme (ECIES), 195
  prefs: []
  type: TYPE_NORMAL
- en: reliability, 4
  prefs: []
  type: TYPE_NORMAL
- en: Entanglement-based consensus, 398
  prefs: []
  type: TYPE_NORMAL
- en: resource sharing, 6
  prefs: []
  type: TYPE_NORMAL
- en: Ethash, 339, 375
  prefs: []
  type: TYPE_NORMAL
- en: software architecture models
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum
  prefs: []
  type: TYPE_NORMAL
- en: client-server, 19, 20
  prefs: []
  type: TYPE_NORMAL
- en: accounts and addresses, 196, 197
  prefs: []
  type: TYPE_NORMAL
- en: multiserver, 20–23
  prefs: []
  type: TYPE_NORMAL
- en: blockchain and blocks
  prefs: []
  type: TYPE_NORMAL
- en: peer to peer, 24
  prefs: []
  type: TYPE_NORMAL
- en: account storage trie, 201
  prefs: []
  type: TYPE_NORMAL
- en: proxy server, 24
  prefs: []
  type: TYPE_NORMAL
- en: header and transactions, 199
  prefs: []
  type: TYPE_NORMAL
- en: throughput, 6
  prefs: []
  type: TYPE_NORMAL
- en: Merkle Patricia trie, 200
  prefs: []
  type: TYPE_NORMAL
- en: time/clocks/order, 37, 38
  prefs: []
  type: TYPE_NORMAL
- en: transaction receipts trie, 200
  prefs: []
  type: TYPE_NORMAL
- en: topologies, 14
  prefs: []
  type: TYPE_NORMAL
- en: transaction trie, 200
  prefs: []
  type: TYPE_NORMAL
- en: types, 19
  prefs: []
  type: TYPE_NORMAL
- en: virtual machine, 201
  prefs: []
  type: TYPE_NORMAL
- en: Distributed transaction
  prefs: []
  type: TYPE_NORMAL
- en: world state trie, 200
  prefs: []
  type: TYPE_NORMAL
- en: ACID properties, 262, 263
  prefs: []
  type: TYPE_NORMAL
- en: blockchain platform, 192
  prefs: []
  type: TYPE_NORMAL
- en: BASE model, 263
  prefs: []
  type: TYPE_NORMAL
- en: cryptography, 196
  prefs: []
  type: TYPE_NORMAL
- en: definition, 262
  prefs: []
  type: TYPE_NORMAL
- en: EVM, 202
  prefs: []
  type: TYPE_NORMAL
- en: 2PC, 263–265
  prefs: []
  type: TYPE_NORMAL
- en: metered executions, 192
  prefs: []
  type: TYPE_NORMAL
- en: three-phase commit, 266, 267
  prefs: []
  type: TYPE_NORMAL
- en: mining, 201, 202
  prefs: []
  type: TYPE_NORMAL
- en: DLS algorithm, 261
  prefs: []
  type: TYPE_NORMAL
- en: PoW-based, 202
  prefs: []
  type: TYPE_NORMAL
- en: Domain name system (DNS), 63
  prefs: []
  type: TYPE_NORMAL
- en: smart contracts, 192, 202, 203
  prefs: []
  type: TYPE_NORMAL
- en: '437'
  prefs: []
  type: TYPE_NORMAL
- en: INDEX
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum ( *cont*.)
  prefs: []
  type: TYPE_NORMAL
- en: '**G**'
  prefs: []
  type: TYPE_NORMAL
- en: transactions, 197, 198
  prefs: []
  type: TYPE_NORMAL
- en: Game theory
  prefs: []
  type: TYPE_NORMAL
- en: Web 2 model, 192
  prefs: []
  type: TYPE_NORMAL
- en: Bitcoin network, 235
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum 2
  prefs: []
  type: TYPE_NORMAL
- en: definition, 232
  prefs: []
  type: TYPE_NORMAL
- en: Casper, 370–374
  prefs: []
  type: TYPE_NORMAL
- en: distributed computing, 236
  prefs: []
  type: TYPE_NORMAL
- en: definition, 368
  prefs: []
  type: TYPE_NORMAL
- en: fields, 232
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum network
  prefs: []
  type: TYPE_NORMAL
- en: incentive mechanisms, 235
  prefs: []
  type: TYPE_NORMAL
- en: blockchain protocol, 193
  prefs: []
  type: TYPE_NORMAL
- en: Nash equilibrium, 235
  prefs: []
  type: TYPE_NORMAL
- en: DEVP2P/wire protocol, 195
  prefs: []
  type: TYPE_NORMAL
- en: prisoner’s dilemma, 233–235
  prefs: []
  type: TYPE_NORMAL
- en: high-level visualization, 192, 193
  prefs: []
  type: TYPE_NORMAL
- en: schelling point, 237
  prefs: []
  type: TYPE_NORMAL
- en: loosely coupled nodes, 192
  prefs: []
  type: TYPE_NORMAL
- en: strategic situations, 233
  prefs: []
  type: TYPE_NORMAL
- en: node discovery protocol, 195
  prefs: []
  type: TYPE_NORMAL
- en: Gas fee, 202
  prefs: []
  type: TYPE_NORMAL
- en: node types, 194
  prefs: []
  type: TYPE_NORMAL
- en: Global stabilization time (GST), 34,
  prefs: []
  type: TYPE_NORMAL
- en: secure transport channel, 195
  prefs: []
  type: TYPE_NORMAL
- en: 152, 426
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum node architecture, 194
  prefs: []
  type: TYPE_NORMAL
- en: Global state, 16
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum node joining, 195
  prefs: []
  type: TYPE_NORMAL
- en: Gossip protocol, 239, 240
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum virtual machine (EVM), 202
  prefs: []
  type: TYPE_NORMAL
- en: Greatest common divisor (GCD), 86
  prefs: []
  type: TYPE_NORMAL
- en: Eventual consistency model, 145
  prefs: []
  type: TYPE_NORMAL
- en: Greenberger-Horne-Zeilinger (GHZ)
  prefs: []
  type: TYPE_NORMAL
- en: Externally owned accounts (EOAs), 196
  prefs: []
  type: TYPE_NORMAL
- en: state, 387
  prefs: []
  type: TYPE_NORMAL
- en: Grinding attack, 339
  prefs: []
  type: TYPE_NORMAL
- en: '**F**'
  prefs: []
  type: TYPE_NORMAL
- en: Fair scheduling, 287
  prefs: []
  type: TYPE_NORMAL
- en: '**H**'
  prefs: []
  type: TYPE_NORMAL
- en: Fault-tolerant broadcast
  prefs: []
  type: TYPE_NORMAL
- en: Happens-before relationship
  prefs: []
  type: TYPE_NORMAL
- en: algorithm, 113
  prefs: []
  type: TYPE_NORMAL
- en: definition, 51
  prefs: []
  type: TYPE_NORMAL
- en: First-in, first-out (FIFO), 118
  prefs: []
  type: TYPE_NORMAL
- en: example, 52
  prefs: []
  type: TYPE_NORMAL
- en: FLM impossibility, 190
  prefs: []
  type: TYPE_NORMAL
- en: faults/fault tolerance, 56–59
  prefs: []
  type: TYPE_NORMAL
- en: Fork resolution
  prefs: []
  type: TYPE_NORMAL
- en: Lamport clock, 52–55
  prefs: []
  type: TYPE_NORMAL
- en: byzantine, 246
  prefs: []
  type: TYPE_NORMAL
- en: logical clocks, 52
  prefs: []
  type: TYPE_NORMAL
- en: chainwork value, 242, 243
  prefs: []
  type: TYPE_NORMAL
- en: properties, 51
  prefs: []
  type: TYPE_NORMAL
- en: computational hash power, 242
  prefs: []
  type: TYPE_NORMAL
- en: safety/liveness, 59, 60
  prefs: []
  type: TYPE_NORMAL
- en: fault tolerance mechanism, 242
  prefs: []
  type: TYPE_NORMAL
- en: vector clock, 55, 56
  prefs: []
  type: TYPE_NORMAL
- en: hard, 244
  prefs: []
  type: TYPE_NORMAL
- en: Hard fork, 244, 245
  prefs: []
  type: TYPE_NORMAL
- en: regular, 244
  prefs: []
  type: TYPE_NORMAL
- en: Hash-based MACs (HMACs), 108
  prefs: []
  type: TYPE_NORMAL
- en: rules, 242
  prefs: []
  type: TYPE_NORMAL
- en: Hash functions
  prefs: []
  type: TYPE_NORMAL
- en: soft, 245
  prefs: []
  type: TYPE_NORMAL
- en: collision resistance
  prefs: []
  type: TYPE_NORMAL
- en: Friendly Finality Gadget (FFG), 370
  prefs: []
  type: TYPE_NORMAL
- en: property, 102
  prefs: []
  type: TYPE_NORMAL
- en: Full nodes, 194
  prefs: []
  type: TYPE_NORMAL
- en: definition, 101
  prefs: []
  type: TYPE_NORMAL
- en: '438'
  prefs: []
  type: TYPE_NORMAL
- en: INDEX
  prefs: []
  type: TYPE_NORMAL
- en: preimage resistance, 101, 102
  prefs: []
  type: TYPE_NORMAL
- en: Light nodes, 194
  prefs: []
  type: TYPE_NORMAL
- en: SHA, 103–107
  prefs: []
  type: TYPE_NORMAL
- en: Linear feedback shift registers (LFSRs), 72
  prefs: []
  type: TYPE_NORMAL
- en: Heartbeat mechanism, 310
  prefs: []
  type: TYPE_NORMAL
- en: Linearizability, 145
  prefs: []
  type: TYPE_NORMAL
- en: Heterogeneous multichains, 173
  prefs: []
  type: TYPE_NORMAL
- en: Logical clocks, 64
  prefs: []
  type: TYPE_NORMAL
- en: High-level transaction, 198
  prefs: []
  type: TYPE_NORMAL
- en: Log replication, 239
  prefs: []
  type: TYPE_NORMAL
- en: Homogenous distributed system, 8
  prefs: []
  type: TYPE_NORMAL
- en: blockchain appending, 241
  prefs: []
  type: TYPE_NORMAL
- en: HoneyBadger BFT (HBBFT), 413, 414
  prefs: []
  type: TYPE_NORMAL
- en: block timestamp sisgnificance,
  prefs: []
  type: TYPE_NORMAL
- en: Horizontal partitioning, 21
  prefs: []
  type: TYPE_NORMAL
- en: 247, 248
  prefs: []
  type: TYPE_NORMAL
- en: Horizontal sharding, 21
  prefs: []
  type: TYPE_NORMAL
- en: block validation, 240
  prefs: []
  type: TYPE_NORMAL
- en: HotStuff
  prefs: []
  type: TYPE_NORMAL
- en: caveat, 248, 249
  prefs: []
  type: TYPE_NORMAL
- en: definition, 353
  prefs: []
  type: TYPE_NORMAL
- en: fork resolution ( *see* Fork resolution)
  prefs: []
  type: TYPE_NORMAL
- en: hidden lock, 354
  prefs: []
  type: TYPE_NORMAL
- en: new block propagation, 239, 240
  prefs: []
  type: TYPE_NORMAL
- en: linear view change, 354
  prefs: []
  type: TYPE_NORMAL
- en: Sybil attack resistance, 246
  prefs: []
  type: TYPE_NORMAL
- en: optimistic responsiveness, 354
  prefs: []
  type: TYPE_NORMAL
- en: Long-range attacks, 338
  prefs: []
  type: TYPE_NORMAL
- en: pacemaker, 355
  prefs: []
  type: TYPE_NORMAL
- en: Lossy channels, 131
  prefs: []
  type: TYPE_NORMAL
- en: participant organization
  prefs: []
  type: TYPE_NORMAL
- en: Lower bound results, 148
  prefs: []
  type: TYPE_NORMAL
- en: topology, 355
  prefs: []
  type: TYPE_NORMAL
- en: QC, 356–358
  prefs: []
  type: TYPE_NORMAL
- en: '**M**'
  prefs: []
  type: TYPE_NORMAL
- en: safety/liveness, 358
  prefs: []
  type: TYPE_NORMAL
- en: Hybrid model approach, 153
  prefs: []
  type: TYPE_NORMAL
- en: Measurement-based consensus, 399
  prefs: []
  type: TYPE_NORMAL
- en: Hyperledger Intel Sawtooth
  prefs: []
  type: TYPE_NORMAL
- en: Memory-bound PoW, 255
  prefs: []
  type: TYPE_NORMAL
- en: blockchain, 219
  prefs: []
  type: TYPE_NORMAL
- en: Merkle Patricia trie, 200
  prefs: []
  type: TYPE_NORMAL
- en: Message authentication codes
  prefs: []
  type: TYPE_NORMAL
- en: (MACs), 68, 77
  prefs: []
  type: TYPE_NORMAL
- en: '**I, J, K**'
  prefs: []
  type: TYPE_NORMAL
- en: definition, 107
  prefs: []
  type: TYPE_NORMAL
- en: Incentive mechanisms, 235
  prefs: []
  type: TYPE_NORMAL
- en: HMACs, 108
  prefs: []
  type: TYPE_NORMAL
- en: Inclusive accountability, 181
  prefs: []
  type: TYPE_NORMAL
- en: operation, 108
  prefs: []
  type: TYPE_NORMAL
- en: Ivy, 189
  prefs: []
  type: TYPE_NORMAL
- en: Message call, 197
  prefs: []
  type: TYPE_NORMAL
- en: Message-passing algorithms, 13
  prefs: []
  type: TYPE_NORMAL
- en: '**L**'
  prefs: []
  type: TYPE_NORMAL
- en: Mining, 191, 201
  prefs: []
  type: TYPE_NORMAL
- en: Mirroring, 22
  prefs: []
  type: TYPE_NORMAL
- en: Lamport clock, 52
  prefs: []
  type: TYPE_NORMAL
- en: Mobile network, 6
  prefs: []
  type: TYPE_NORMAL
- en: Lamport’s algorithm, 260
  prefs: []
  type: TYPE_NORMAL
- en: Model checking mechanism, 419
  prefs: []
  type: TYPE_NORMAL
- en: Leader-based protocols, 208
  prefs: []
  type: TYPE_NORMAL
- en: Modern blockchain platforms, 203, 204
  prefs: []
  type: TYPE_NORMAL
- en: Leader election algorithm, 238, 239
  prefs: []
  type: TYPE_NORMAL
- en: Multiparty computation (MPC), 414
  prefs: []
  type: TYPE_NORMAL
- en: Lieutenants, 273
  prefs: []
  type: TYPE_NORMAL
- en: Multiserver architecture, 20
  prefs: []
  type: TYPE_NORMAL
- en: Light Ethereum Subprotocol (LES), 195
  prefs: []
  type: TYPE_NORMAL
- en: Multivalued consensus, 127
  prefs: []
  type: TYPE_NORMAL
- en: '439'
  prefs: []
  type: TYPE_NORMAL
- en: INDEX
  prefs: []
  type: TYPE_NORMAL
- en: '**N**'
  prefs: []
  type: TYPE_NORMAL
- en: BGP, 268–271
  prefs: []
  type: TYPE_NORMAL
- en: definition, 268
  prefs: []
  type: TYPE_NORMAL
- en: Nakamoto consensus
  prefs: []
  type: TYPE_NORMAL
- en: IC1/IC2, 268
  prefs: []
  type: TYPE_NORMAL
- en: agreement, 211
  prefs: []
  type: TYPE_NORMAL
- en: protocol case, 270, 272
  prefs: []
  type: TYPE_NORMAL
- en: chain progress, 213
  prefs: []
  type: TYPE_NORMAL
- en: signed message solution, BGP, 273–275
  prefs: []
  type: TYPE_NORMAL
- en: consistent/consistency, 213
  prefs: []
  type: TYPE_NORMAL
- en: eventual irrevocability, 213
  prefs: []
  type: TYPE_NORMAL
- en: finality, 212
  prefs: []
  type: TYPE_NORMAL
- en: '**P**'
  prefs: []
  type: TYPE_NORMAL
- en: protocol, 207
  prefs: []
  type: TYPE_NORMAL
- en: Parachains, 360
  prefs: []
  type: TYPE_NORMAL
- en: termination, 212
  prefs: []
  type: TYPE_NORMAL
- en: Parathread, 361
  prefs: []
  type: TYPE_NORMAL
- en: validity, 211
  prefs: []
  type: TYPE_NORMAL
- en: Partially synchronous model, 33
  prefs: []
  type: TYPE_NORMAL
- en: Nakamoto-style (PoW) consensus
  prefs: []
  type: TYPE_NORMAL
- en: Partial synchrony network model
  prefs: []
  type: TYPE_NORMAL
- en: algorithms, 163
  prefs: []
  type: TYPE_NORMAL
- en: algorithms, 275, 276
  prefs: []
  type: TYPE_NORMAL
- en: Nakamoto-style protocols, 416
  prefs: []
  type: TYPE_NORMAL
- en: Byzantine faults with
  prefs: []
  type: TYPE_NORMAL
- en: Nash equilibrium, 232, 233
  prefs: []
  type: TYPE_NORMAL
- en: authentication, 276, 277
  prefs: []
  type: TYPE_NORMAL
- en: Network partition
  prefs: []
  type: TYPE_NORMAL
- en: variables, 276
  prefs: []
  type: TYPE_NORMAL
- en: arbitrary links, 31
  prefs: []
  type: TYPE_NORMAL
- en: Paxos, 328
  prefs: []
  type: TYPE_NORMAL
- en: definition, 28
  prefs: []
  type: TYPE_NORMAL
- en: algorithm, work, 297–299
  prefs: []
  type: TYPE_NORMAL
- en: fair-loss links, 29
  prefs: []
  type: TYPE_NORMAL
- en: definition, 296
  prefs: []
  type: TYPE_NORMAL
- en: links, 29
  prefs: []
  type: TYPE_NORMAL
- en: failure scenarios, 301–303
  prefs: []
  type: TYPE_NORMAL
- en: logged perfect links, 31
  prefs: []
  type: TYPE_NORMAL
- en: multi-paxos, 306
  prefs: []
  type: TYPE_NORMAL
- en: perfect (reliable) links, 30
  prefs: []
  type: TYPE_NORMAL
- en: nodes, 297
  prefs: []
  type: TYPE_NORMAL
- en: stubborn links, 30
  prefs: []
  type: TYPE_NORMAL
- en: protocol, 296
  prefs: []
  type: TYPE_NORMAL
- en: Network time protocol (NTP), 44
  prefs: []
  type: TYPE_NORMAL
- en: run, 300
  prefs: []
  type: TYPE_NORMAL
- en: Nominators, 360
  prefs: []
  type: TYPE_NORMAL
- en: safety and liveness properties, 304
  prefs: []
  type: TYPE_NORMAL
- en: Nonce, 221, 224
  prefs: []
  type: TYPE_NORMAL
- en: variants, 305
  prefs: []
  type: TYPE_NORMAL
- en: Nondeterministic Polynomial (NP), 391
  prefs: []
  type: TYPE_NORMAL
- en: Payoff matrix, 233
  prefs: []
  type: TYPE_NORMAL
- en: Non-fungible tokens (NFTs), 170
  prefs: []
  type: TYPE_NORMAL
- en: Pay-to-Public-Key-Hash (P2PKH), 189
  prefs: []
  type: TYPE_NORMAL
- en: Normal log *vs.* blockchain log, 239
  prefs: []
  type: TYPE_NORMAL
- en: Permissioned blockchains, 172, 174
  prefs: []
  type: TYPE_NORMAL
- en: Permissionless blockchains, 172, 174
  prefs: []
  type: TYPE_NORMAL
- en: '**O**'
  prefs: []
  type: TYPE_NORMAL
- en: Physical clocks
  prefs: []
  type: TYPE_NORMAL
- en: atomic, 41–43
  prefs: []
  type: TYPE_NORMAL
- en: Off-chain transactions, 187
  prefs: []
  type: TYPE_NORMAL
- en: clock skew *vs*. drift, 41
  prefs: []
  type: TYPE_NORMAL
- en: Omega Ω failure detector, 159
  prefs: []
  type: TYPE_NORMAL
- en: definition, 39
  prefs: []
  type: TYPE_NORMAL
- en: On-chain transactions, 187
  prefs: []
  type: TYPE_NORMAL
- en: irreflexive partial order, 50
  prefs: []
  type: TYPE_NORMAL
- en: One-way property, 101
  prefs: []
  type: TYPE_NORMAL
- en: oscillator circuitry, 39
  prefs: []
  type: TYPE_NORMAL
- en: Opcodes, 188, 202
  prefs: []
  type: TYPE_NORMAL
- en: oscilloscope, 40
  prefs: []
  type: TYPE_NORMAL
- en: Oral message (OM) algorithm
  prefs: []
  type: TYPE_NORMAL
- en: partial order, 49
  prefs: []
  type: TYPE_NORMAL
- en: '440'
  prefs: []
  type: TYPE_NORMAL
- en: INDEX
  prefs: []
  type: TYPE_NORMAL
- en: relation, 49
  prefs: []
  type: TYPE_NORMAL
- en: dynamic cost adjustment, 226
  prefs: []
  type: TYPE_NORMAL
- en: set, 48
  prefs: []
  type: TYPE_NORMAL
- en: probabilistic aspects, 229
  prefs: []
  type: TYPE_NORMAL
- en: synchronization algorithm
  prefs: []
  type: TYPE_NORMAL
- en: progress free, 226–229
  prefs: []
  type: TYPE_NORMAL
- en: GPS, 44, 45
  prefs: []
  type: TYPE_NORMAL
- en: quick verification, 226
  prefs: []
  type: TYPE_NORMAL
- en: NTP, 44
  prefs: []
  type: TYPE_NORMAL
- en: PoW, state machine replication
  prefs: []
  type: TYPE_NORMAL
- en: UTC, 45–47
  prefs: []
  type: TYPE_NORMAL
- en: leader election algorithm, 238, 239
  prefs: []
  type: TYPE_NORMAL
- en: types, 47
  prefs: []
  type: TYPE_NORMAL
- en: log ( *see* Log replication)
  prefs: []
  type: TYPE_NORMAL
- en: Plaintext, 69
  prefs: []
  type: TYPE_NORMAL
- en: Practical Byzantine fault tolerance
  prefs: []
  type: TYPE_NORMAL
- en: Polkadot, 173
  prefs: []
  type: TYPE_NORMAL
- en: (PBFT), 142
  prefs: []
  type: TYPE_NORMAL
- en: consensus
  prefs: []
  type: TYPE_NORMAL
- en: advantages/disadvantages, 323, 324
  prefs: []
  type: TYPE_NORMAL
- en: BABE, 362–366
  prefs: []
  type: TYPE_NORMAL
- en: certificates, 319–322
  prefs: []
  type: TYPE_NORMAL
- en: definition, 361
  prefs: []
  type: TYPE_NORMAL
- en: definition, 315
  prefs: []
  type: TYPE_NORMAL
- en: GRANDPA, 366–368
  prefs: []
  type: TYPE_NORMAL
- en: operations, 316
  prefs: []
  type: TYPE_NORMAL
- en: hybrid approach, 361
  prefs: []
  type: TYPE_NORMAL
- en: phases, 315–319
  prefs: []
  type: TYPE_NORMAL
- en: definition, 359
  prefs: []
  type: TYPE_NORMAL
- en: safety/liveness, 324–326
  prefs: []
  type: TYPE_NORMAL
- en: relay chain, 360
  prefs: []
  type: TYPE_NORMAL
- en: Primary backup replication, 137, 138
  prefs: []
  type: TYPE_NORMAL
- en: validators, 359
  prefs: []
  type: TYPE_NORMAL
- en: Prisoner’s dilemma model, 233–235
  prefs: []
  type: TYPE_NORMAL
- en: Pool mining, 228
  prefs: []
  type: TYPE_NORMAL
- en: Private blockchains, 172
  prefs: []
  type: TYPE_NORMAL
- en: PoW concerns, 221
  prefs: []
  type: TYPE_NORMAL
- en: Process/node
  prefs: []
  type: TYPE_NORMAL
- en: 51% attack, 251, 252
  prefs: []
  type: TYPE_NORMAL
- en: byzantine process, 28
  prefs: []
  type: TYPE_NORMAL
- en: Eclipse attack, 253
  prefs: []
  type: TYPE_NORMAL
- en: crash, recovery, 27, 28
  prefs: []
  type: TYPE_NORMAL
- en: ESG metrics, 253–255
  prefs: []
  type: TYPE_NORMAL
- en: crash-stop faults, 27
  prefs: []
  type: TYPE_NORMAL
- en: Finney attack, 252, 253
  prefs: []
  type: TYPE_NORMAL
- en: definition, 26
  prefs: []
  type: TYPE_NORMAL
- en: race attack, 252
  prefs: []
  type: TYPE_NORMAL
- en: eavesdropping, 28
  prefs: []
  type: TYPE_NORMAL
- en: selfish mining, 252
  prefs: []
  type: TYPE_NORMAL
- en: failures, 27
  prefs: []
  type: TYPE_NORMAL
- en: Vector76 attack, 253
  prefs: []
  type: TYPE_NORMAL
- en: omission failures, 27
  prefs: []
  type: TYPE_NORMAL
- en: PoW formula
  prefs: []
  type: TYPE_NORMAL
- en: Proof of Authority (PoA), 413
  prefs: []
  type: TYPE_NORMAL
- en: attacker catching up
  prefs: []
  type: TYPE_NORMAL
- en: Proof of elapsed time (PoET), 412
  prefs: []
  type: TYPE_NORMAL
- en: probability, 230, 231
  prefs: []
  type: TYPE_NORMAL
- en: Proof of history (PoH), 342
  prefs: []
  type: TYPE_NORMAL
- en: Bitcoin’s difficulty formula, 221
  prefs: []
  type: TYPE_NORMAL
- en: Proof of stake (PoS)
  prefs: []
  type: TYPE_NORMAL
- en: miners task, 222–225
  prefs: []
  type: TYPE_NORMAL
- en: attacks, 338
  prefs: []
  type: TYPE_NORMAL
- en: partial hash inversion problem, 222
  prefs: []
  type: TYPE_NORMAL
- en: BFT-based, 336
  prefs: []
  type: TYPE_NORMAL
- en: SHA-256 hash, 221
  prefs: []
  type: TYPE_NORMAL
- en: Bitcoin’s PoW, 333
  prefs: []
  type: TYPE_NORMAL
- en: target value, 221, 222
  prefs: []
  type: TYPE_NORMAL
- en: chain-based, 335
  prefs: []
  type: TYPE_NORMAL
- en: PoW properties
  prefs: []
  type: TYPE_NORMAL
- en: committee-based, 335
  prefs: []
  type: TYPE_NORMAL
- en: completeness, 225
  prefs: []
  type: TYPE_NORMAL
- en: DPoS, 337
  prefs: []
  type: TYPE_NORMAL
- en: computationally complex, 225
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum, 339–341
  prefs: []
  type: TYPE_NORMAL
- en: '441'
  prefs: []
  type: TYPE_NORMAL
- en: INDEX
  prefs: []
  type: TYPE_NORMAL
- en: Proof of stake (PoS) ( *cont*.)
  prefs: []
  type: TYPE_NORMAL
- en: applications, 380
  prefs: []
  type: TYPE_NORMAL
- en: LPoS, 337
  prefs: []
  type: TYPE_NORMAL
- en: building blocks, 380
  prefs: []
  type: TYPE_NORMAL
- en: scheme, 334
  prefs: []
  type: TYPE_NORMAL
- en: definition, 378
  prefs: []
  type: TYPE_NORMAL
- en: types, 334
  prefs: []
  type: TYPE_NORMAL
- en: entanglement, 382, 383
  prefs: []
  type: TYPE_NORMAL
- en: Proof of work (PoW), 174, 201, 231, 232
  prefs: []
  type: TYPE_NORMAL
- en: optimization problems, 379
  prefs: []
  type: TYPE_NORMAL
- en: BFT-style protocols, 214, 216
  prefs: []
  type: TYPE_NORMAL
- en: qubit, 380, 382
  prefs: []
  type: TYPE_NORMAL
- en: combat junk emails, 215
  prefs: []
  type: TYPE_NORMAL
- en: route optimization, 379
  prefs: []
  type: TYPE_NORMAL
- en: CPU-bound, 255
  prefs: []
  type: TYPE_NORMAL
- en: superposition, 382
  prefs: []
  type: TYPE_NORMAL
- en: game theory, 232–237
  prefs: []
  type: TYPE_NORMAL
- en: Quantum consensus
  prefs: []
  type: TYPE_NORMAL
- en: hash functions, 215
  prefs: []
  type: TYPE_NORMAL
- en: algorithms, 388, 406
  prefs: []
  type: TYPE_NORMAL
- en: key intuition, 215
  prefs: []
  type: TYPE_NORMAL
- en: circuits, 386–388
  prefs: []
  type: TYPE_NORMAL
- en: memory-bound, 255
  prefs: []
  type: TYPE_NORMAL
- en: computational complexity
  prefs: []
  type: TYPE_NORMAL
- en: Nakamoto consensus, 214, 215
  prefs: []
  type: TYPE_NORMAL
- en: Big-O, 390
  prefs: []
  type: TYPE_NORMAL
- en: pedagogical explanation, 217–220
  prefs: []
  type: TYPE_NORMAL
- en: BQP, 392
  prefs: []
  type: TYPE_NORMAL
- en: requirements, 216, 217
  prefs: []
  type: TYPE_NORMAL
- en: NP, 391
  prefs: []
  type: TYPE_NORMAL
- en: scalability *vs.* performance
  prefs: []
  type: TYPE_NORMAL
- en: NP class, 391
  prefs: []
  type: TYPE_NORMAL
- en: trade-off, 216
  prefs: []
  type: TYPE_NORMAL
- en: polynomial time class, 391
  prefs: []
  type: TYPE_NORMAL
- en: Sybil attack, 215
  prefs: []
  type: TYPE_NORMAL
- en: PSPACE, 392
  prefs: []
  type: TYPE_NORMAL
- en: traditional BFT, 216
  prefs: []
  type: TYPE_NORMAL
- en: space complexity, 389
  prefs: []
  type: TYPE_NORMAL
- en: chain growth, 238
  prefs: []
  type: TYPE_NORMAL
- en: definition, 398
  prefs: []
  type: TYPE_NORMAL
- en: chain quality, 238
  prefs: []
  type: TYPE_NORMAL
- en: enhanced distributed
  prefs: []
  type: TYPE_NORMAL
- en: common prefix, 238
  prefs: []
  type: TYPE_NORMAL
- en: consensus, 403, 404
  prefs: []
  type: TYPE_NORMAL
- en: Proxy server–based architecture, 24
  prefs: []
  type: TYPE_NORMAL
- en: fast quantum byzantine
  prefs: []
  type: TYPE_NORMAL
- en: Public blockchain system model, 172, 213
  prefs: []
  type: TYPE_NORMAL
- en: agreement, 399, 401
  prefs: []
  type: TYPE_NORMAL
- en: Public key cryptography
  prefs: []
  type: TYPE_NORMAL
- en: FLP impossibility, 401, 402
  prefs: []
  type: TYPE_NORMAL
- en: definition, 81
  prefs: []
  type: TYPE_NORMAL
- en: gates, 384, 385
  prefs: []
  type: TYPE_NORMAL
- en: Diffie-Hellman key exchange, 82–84
  prefs: []
  type: TYPE_NORMAL
- en: leader election, 405
  prefs: []
  type: TYPE_NORMAL
- en: digital signatures, 85
  prefs: []
  type: TYPE_NORMAL
- en: RSA, 378
  prefs: []
  type: TYPE_NORMAL
- en: ECC, 88
  prefs: []
  type: TYPE_NORMAL
- en: Quantum information science and
  prefs: []
  type: TYPE_NORMAL
- en: ecosystem, 81
  prefs: []
  type: TYPE_NORMAL
- en: technology (QIST), 378
  prefs: []
  type: TYPE_NORMAL
- en: RSA, 85–87
  prefs: []
  type: TYPE_NORMAL
- en: Quantum information science (QIS), 378
  prefs: []
  type: TYPE_NORMAL
- en: symmetric algorithms, 81
  prefs: []
  type: TYPE_NORMAL
- en: Quantum key distribution (QKD), 396, 398
  prefs: []
  type: TYPE_NORMAL
- en: Public Key Infrastructure (PKI), 99
  prefs: []
  type: TYPE_NORMAL
- en: Quantum systems
  prefs: []
  type: TYPE_NORMAL
- en: blockchain, 395
  prefs: []
  type: TYPE_NORMAL
- en: '**Q**'
  prefs: []
  type: TYPE_NORMAL
- en: cryptography, 396, 397
  prefs: []
  type: TYPE_NORMAL
- en: distributed computing approach, 394
  prefs: []
  type: TYPE_NORMAL
- en: QKD-based consensus, 399
  prefs: []
  type: TYPE_NORMAL
- en: Internet, 393, 394
  prefs: []
  type: TYPE_NORMAL
- en: Quantum computer, 407
  prefs: []
  type: TYPE_NORMAL
- en: networks, 393
  prefs: []
  type: TYPE_NORMAL
- en: '442'
  prefs: []
  type: TYPE_NORMAL
- en: INDEX
  prefs: []
  type: TYPE_NORMAL
- en: Quantum teleportation, 394
  prefs: []
  type: TYPE_NORMAL
- en: RAID, 135
  prefs: []
  type: TYPE_NORMAL
- en: Quartz-based clocks, 40
  prefs: []
  type: TYPE_NORMAL
- en: state machine, 140–142, 144, 146
  prefs: []
  type: TYPE_NORMAL
- en: Quartz clocks, 42
  prefs: []
  type: TYPE_NORMAL
- en: RLPx, 195
  prefs: []
  type: TYPE_NORMAL
- en: Qubit, 380
  prefs: []
  type: TYPE_NORMAL
- en: Quorum
  prefs: []
  type: TYPE_NORMAL
- en: '**S**'
  prefs: []
  type: TYPE_NORMAL
- en: byzantine failures, 162
  prefs: []
  type: TYPE_NORMAL
- en: CFT, 161
  prefs: []
  type: TYPE_NORMAL
- en: Sapphire clocks, 43
  prefs: []
  type: TYPE_NORMAL
- en: definition, 160
  prefs: []
  type: TYPE_NORMAL
- en: Schelling point, 237
  prefs: []
  type: TYPE_NORMAL
- en: protocols, 162
  prefs: []
  type: TYPE_NORMAL
- en: Script, 188
  prefs: []
  type: TYPE_NORMAL
- en: Quorum availability property, 161
  prefs: []
  type: TYPE_NORMAL
- en: ScriptPubKey, 188, 189
  prefs: []
  type: TYPE_NORMAL
- en: Quorum certificate (QC), 356
  prefs: []
  type: TYPE_NORMAL
- en: ScriptSig, 188, 189
  prefs: []
  type: TYPE_NORMAL
- en: Secure Hash Algorithms (SHA), 103
  prefs: []
  type: TYPE_NORMAL
- en: Selfish mining/block withholding
  prefs: []
  type: TYPE_NORMAL
- en: '**R**'
  prefs: []
  type: TYPE_NORMAL
- en: attack, 339
  prefs: []
  type: TYPE_NORMAL
- en: Randomized algorithms, 212, 287
  prefs: []
  type: TYPE_NORMAL
- en: Sequential consistency, 145
  prefs: []
  type: TYPE_NORMAL
- en: Random oracles, 152
  prefs: []
  type: TYPE_NORMAL
- en: Serenity or Eth2, 368
  prefs: []
  type: TYPE_NORMAL
- en: Regular fork, 244
  prefs: []
  type: TYPE_NORMAL
- en: SHA-256 hash function, 184
  prefs: []
  type: TYPE_NORMAL
- en: Relative time algorithm, 365
  prefs: []
  type: TYPE_NORMAL
- en: Simultaneous move games, 233
  prefs: []
  type: TYPE_NORMAL
- en: Relay chain, 173, 359
  prefs: []
  type: TYPE_NORMAL
- en: Smart contracts, 202
  prefs: []
  type: TYPE_NORMAL
- en: Reliability, 5
  prefs: []
  type: TYPE_NORMAL
- en: Snap-and-chat protocols, 417
  prefs: []
  type: TYPE_NORMAL
- en: Reliable broadcast (RBC), 414
  prefs: []
  type: TYPE_NORMAL
- en: Soft fork, 245
  prefs: []
  type: TYPE_NORMAL
- en: Replicated And Fault Tolerant (RAFT)
  prefs: []
  type: TYPE_NORMAL
- en: Solana
  prefs: []
  type: TYPE_NORMAL
- en: assumptions, 308
  prefs: []
  type: TYPE_NORMAL
- en: definition, 342
  prefs: []
  type: TYPE_NORMAL
- en: definition, 308
  prefs: []
  type: TYPE_NORMAL
- en: ledger, 342
  prefs: []
  type: TYPE_NORMAL
- en: guarantees, 314, 315
  prefs: []
  type: TYPE_NORMAL
- en: PoH, 343–347
  prefs: []
  type: TYPE_NORMAL
- en: leader election, 310, 311
  prefs: []
  type: TYPE_NORMAL
- en: TowerBFT, 342
  prefs: []
  type: TYPE_NORMAL
- en: log replication, 311–313
  prefs: []
  type: TYPE_NORMAL
- en: transactions, 342
  prefs: []
  type: TYPE_NORMAL
- en: phases, 309
  prefs: []
  type: TYPE_NORMAL
- en: Solidity, 202
  prefs: []
  type: TYPE_NORMAL
- en: time, 309
  prefs: []
  type: TYPE_NORMAL
- en: Solo mining, 228
  prefs: []
  type: TYPE_NORMAL
- en: Replication
  prefs: []
  type: TYPE_NORMAL
- en: Space complexity, 423
  prefs: []
  type: TYPE_NORMAL
- en: active, 137
  prefs: []
  type: TYPE_NORMAL
- en: State machine replication (SMR),
  prefs: []
  type: TYPE_NORMAL
- en: advantages, 135
  prefs: []
  type: TYPE_NORMAL
- en: 137, 142, 349
  prefs: []
  type: TYPE_NORMAL
- en: chain, 139
  prefs: []
  type: TYPE_NORMAL
- en: State transition function (STF), 240
  prefs: []
  type: TYPE_NORMAL
- en: definition, 135
  prefs: []
  type: TYPE_NORMAL
- en: Strategic form, 233
  prefs: []
  type: TYPE_NORMAL
- en: methods, 136
  prefs: []
  type: TYPE_NORMAL
- en: Substitution-permutation
  prefs: []
  type: TYPE_NORMAL
- en: passive, 137
  prefs: []
  type: TYPE_NORMAL
- en: network (SPN), 73
  prefs: []
  type: TYPE_NORMAL
- en: primary backup, 138, 139
  prefs: []
  type: TYPE_NORMAL
- en: Superposition, 382
  prefs: []
  type: TYPE_NORMAL
- en: pros and cons, 137
  prefs: []
  type: TYPE_NORMAL
- en: Sybil attack mechanism, 214, 246
  prefs: []
  type: TYPE_NORMAL
- en: '443'
  prefs: []
  type: TYPE_NORMAL
- en: INDEX
  prefs: []
  type: TYPE_NORMAL
- en: Symmetric cryptosystems
  prefs: []
  type: TYPE_NORMAL
- en: Timestamping service, 169
  prefs: []
  type: TYPE_NORMAL
- en: AES, 77–79
  prefs: []
  type: TYPE_NORMAL
- en: Total order broadcast/atomic
  prefs: []
  type: TYPE_NORMAL
- en: block ciphers, 73
  prefs: []
  type: TYPE_NORMAL
- en: broadcast, 119
  prefs: []
  type: TYPE_NORMAL
- en: classes, 71
  prefs: []
  type: TYPE_NORMAL
- en: Total order/linear order, 50
  prefs: []
  type: TYPE_NORMAL
- en: definition, 70
  prefs: []
  type: TYPE_NORMAL
- en: TowerBFT, 332, 342, 347
  prefs: []
  type: TYPE_NORMAL
- en: stream ciphers, 71–73
  prefs: []
  type: TYPE_NORMAL
- en: Traditional BFT consensus
  prefs: []
  type: TYPE_NORMAL
- en: Symmetric key cryptography, 111
  prefs: []
  type: TYPE_NORMAL
- en: agreement, 210
  prefs: []
  type: TYPE_NORMAL
- en: Symmetric state consensus, 398
  prefs: []
  type: TYPE_NORMAL
- en: chain progress, 211
  prefs: []
  type: TYPE_NORMAL
- en: Synchrony and timing
  prefs: []
  type: TYPE_NORMAL
- en: consensus finality, 211
  prefs: []
  type: TYPE_NORMAL
- en: adversary, 36
  prefs: []
  type: TYPE_NORMAL
- en: instant irrevocability, 211
  prefs: []
  type: TYPE_NORMAL
- en: asynchronous distributed system, 32
  prefs: []
  type: TYPE_NORMAL
- en: integrity, 211
  prefs: []
  type: TYPE_NORMAL
- en: definitions, 34, 35
  prefs: []
  type: TYPE_NORMAL
- en: permissioned blockchain, 210
  prefs: []
  type: TYPE_NORMAL
- en: GST, 34
  prefs: []
  type: TYPE_NORMAL
- en: protocols, 208
  prefs: []
  type: TYPE_NORMAL
- en: partially synchronous model, 33
  prefs: []
  type: TYPE_NORMAL
- en: termination, 210
  prefs: []
  type: TYPE_NORMAL
- en: processors, 32
  prefs: []
  type: TYPE_NORMAL
- en: validity, 210
  prefs: []
  type: TYPE_NORMAL
- en: synchronous and asynchronous
  prefs: []
  type: TYPE_NORMAL
- en: Traditional BFT *vs.* Nakamoto
  prefs: []
  type: TYPE_NORMAL
- en: system, 35
  prefs: []
  type: TYPE_NORMAL
- en: consensus, 209
  prefs: []
  type: TYPE_NORMAL
- en: synchronous distributed system, 32
  prefs: []
  type: TYPE_NORMAL
- en: Traditional distributed consensus
  prefs: []
  type: TYPE_NORMAL
- en: System models
  prefs: []
  type: TYPE_NORMAL
- en: protocols, 207
  prefs: []
  type: TYPE_NORMAL
- en: channel reliability, 131
  prefs: []
  type: TYPE_NORMAL
- en: Transaction-based DAG, 415
  prefs: []
  type: TYPE_NORMAL
- en: distributed system, 128
  prefs: []
  type: TYPE_NORMAL
- en: Transaction pool transactions, 224
  prefs: []
  type: TYPE_NORMAL
- en: process failure, 130
  prefs: []
  type: TYPE_NORMAL
- en: Transaction processing unit, 342
  prefs: []
  type: TYPE_NORMAL
- en: synchrony, 129
  prefs: []
  type: TYPE_NORMAL
- en: Transactions, 187
  prefs: []
  type: TYPE_NORMAL
- en: Transaction structure, 198
  prefs: []
  type: TYPE_NORMAL
- en: '**T**'
  prefs: []
  type: TYPE_NORMAL
- en: Transaction trie, 200
  prefs: []
  type: TYPE_NORMAL
- en: Trapdoor functions, 83
  prefs: []
  type: TYPE_NORMAL
- en: Tendermint
  prefs: []
  type: TYPE_NORMAL
- en: Turbine, 342
  prefs: []
  type: TYPE_NORMAL
- en: algorithm, 350, 351
  prefs: []
  type: TYPE_NORMAL
- en: Two Generals’ Paradox/Two Generals’
  prefs: []
  type: TYPE_NORMAL
- en: assumptions, 348, 349
  prefs: []
  type: TYPE_NORMAL
- en: Problem, 132, 133
  prefs: []
  type: TYPE_NORMAL
- en: definition, 347
  prefs: []
  type: TYPE_NORMAL
- en: Two-phase commit (2PC), 263
  prefs: []
  type: TYPE_NORMAL
- en: messages, 349
  prefs: []
  type: TYPE_NORMAL
- en: protocol, 348
  prefs: []
  type: TYPE_NORMAL
- en: termination mechanism, 352, 353
  prefs: []
  type: TYPE_NORMAL
- en: '**U**'
  prefs: []
  type: TYPE_NORMAL
- en: timeouts, 350
  prefs: []
  type: TYPE_NORMAL
- en: Uniform agreement property, 117
  prefs: []
  type: TYPE_NORMAL
- en: variables, 350
  prefs: []
  type: TYPE_NORMAL
- en: Unspent transaction
  prefs: []
  type: TYPE_NORMAL
- en: Time complexity, 423
  prefs: []
  type: TYPE_NORMAL
- en: output (UTXO), 186
  prefs: []
  type: TYPE_NORMAL
- en: '444'
  prefs: []
  type: TYPE_NORMAL
- en: INDEX
  prefs: []
  type: TYPE_NORMAL
- en: '**V**'
  prefs: []
  type: TYPE_NORMAL
- en: protocol steps, 293, 294
  prefs: []
  type: TYPE_NORMAL
- en: subprotocols, 292
  prefs: []
  type: TYPE_NORMAL
- en: Verifiable delay function (VDF),
  prefs: []
  type: TYPE_NORMAL
- en: variables, 292
  prefs: []
  type: TYPE_NORMAL
- en: 109–111, 345
  prefs: []
  type: TYPE_NORMAL
- en: view change, 294, 295
  prefs: []
  type: TYPE_NORMAL
- en: Verifiable random function (VRF), 110,
  prefs: []
  type: TYPE_NORMAL
- en: 335, 339, 363
  prefs: []
  type: TYPE_NORMAL
- en: Viewstamped replication (VR)
  prefs: []
  type: TYPE_NORMAL
- en: '**W, X, Y, Z**'
  prefs: []
  type: TYPE_NORMAL
- en: protocol, 287
  prefs: []
  type: TYPE_NORMAL
- en: World state trie, 200
  prefs: []
  type: TYPE_NORMAL
- en: definition, 291
  prefs: []
  type: TYPE_NORMAL
- en: W state circuit, 388
  prefs: []
  type: TYPE_NORMAL
- en: '445'
  prefs: []
  type: TYPE_NORMAL
- en: Document Outline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Table of Contents](index_split_000.html#p5)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[About the Author](index_split_000.html#p15)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[About the Technical Reviewer](index_split_000.html#p16)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Acknowledgments](index_split_000.html#p17)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Introduction](index_split_000.html#p18)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 1: Introduction](index_split_000.html#p20)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Distributed Systems](index_split_000.html#p20)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Characteristics](index_split_000.html#p21)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Why Build Distributed Systems](index_split_000.html#p23)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Reliability](index_split_000.html#p24)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Performance](index_split_000.html#p24)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Responsiveness](index_split_000.html#p24)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Throughput](index_split_000.html#p25)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Resource Sharing](index_split_000.html#p25)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Inherently Distributed](index_split_000.html#p25)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Challenges](index_split_000.html#p26)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Fault Tolerance](index_split_000.html#p26)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Security](index_split_000.html#p26)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Heterogeneity](index_split_000.html#p27)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Distribution Transparency](index_split_000.html#p27)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Timing and Synchronization](index_split_000.html#p28)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Global State](index_split_000.html#p28)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Concurrency](index_split_000.html#p28)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Parallel vs. Distributed vs. Concurrency](index_split_000.html#p29)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Centralized vs. Decentralized vs. Distributed](index_split_000.html#p29)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Distributed Algorithm](index_split_000.html#p31)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Elements of Distributed Computing/Pertinent Terms/Concepts](index_split_000.html#p33)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Processes](index_split_000.html#p34)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Events](index_split_000.html#p34)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[State](index_split_000.html#p35)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Global State](index_split_000.html#p35)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Execution](index_split_000.html#p35)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Cuts](index_split_000.html#p36)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Types of Distributed Systems](index_split_000.html#p38)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Software Architecture Models](index_split_000.html#p38)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Client-Server](index_split_000.html#p38)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Multiserver](index_split_000.html#p39)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Proxy Servers](index_split_000.html#p43)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Peer to Peer](index_split_000.html#p43)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Distributed System Model](index_split_000.html#p44)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Processes](index_split_000.html#p45)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Crash-Stop Failure](index_split_000.html#p46)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Omission Failure](index_split_000.html#p46)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Crash with Recovery](index_split_000.html#p46)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Eavesdropping](index_split_000.html#p47)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Arbitrary (Byzantine)](index_split_000.html#p47)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Network](index_split_000.html#p47)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Link Failures](index_split_000.html#p48)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Fair-Loss Links](index_split_000.html#p48)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Fair-Loss](index_split_000.html#p48)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Finite Duplication](index_split_000.html#p48)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[No Creation](index_split_000.html#p48)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Stubborn Links](index_split_000.html#p49)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Stubborn Delivery](index_split_000.html#p49)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[No Creation](index_split_000.html#p49)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Perfect (Reliable) Links](index_split_000.html#p49)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Reliable Delivery](index_split_000.html#p49)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[No Duplication](index_split_000.html#p49)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[No Creation](index_split_000.html#p50)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Logged Perfect Links](index_split_000.html#p50)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Authenticated Perfect Links](index_split_000.html#p50)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Arbitrary Links](index_split_000.html#p50)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Synchrony and Timing](index_split_000.html#p50)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Synchronous](index_split_000.html#p51)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Asynchronous](index_split_000.html#p51)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Partially Synchronous](index_split_000.html#p52)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Eventually Synchronous](index_split_000.html#p53)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Formal Definitions](index_split_000.html#p53)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Adversary Model](index_split_000.html#p55)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Threshold Adversary](index_split_000.html#p55)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Dynamic Adversary](index_split_000.html#p56)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Static Adversary](index_split_000.html#p56)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Passive Adversary](index_split_000.html#p56)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Time, Clocks, and Order](index_split_000.html#p56)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Physical Clocks](index_split_000.html#p58)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Clock Skew vs. Drift](index_split_000.html#p60)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Atomic Clocks](index_split_000.html#p60)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Synchronization Algorithms for Physical Clocks](index_split_000.html#p62)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[NTP](index_split_000.html#p63)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[GPS As a Time Source](index_split_000.html#p63)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[UTC Time](index_split_000.html#p64)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Types of Physical Clocks](index_split_000.html#p66)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Set](index_split_000.html#p67)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Relation](index_split_001.html#p68)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Partial Order](index_split_001.html#p68)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Reflexivity](index_split_001.html#p68)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Antisymmetry](index_split_001.html#p69)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Transitivity](index_split_001.html#p69)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Irreflexive Partial Order](index_split_001.html#p69)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Irreflexive](index_split_001.html#p69)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Total Order](index_split_001.html#p69)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Happens-Before Relationship and Causality](index_split_001.html#p69)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Logical Clocks](index_split_001.html#p71)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Lamport Clocks](index_split_001.html#p71)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Vector Clocks](index_split_001.html#p74)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Faults and Fault Tolerance](index_split_001.html#p75)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Crash-Stop](index_split_001.html#p76)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Fail-Stop](index_split_001.html#p76)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Omission Faults](index_split_001.html#p76)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Send Omission](index_split_001.html#p76)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Receive Omission](index_split_001.html#p76)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[General Omission](index_split_001.html#p76)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Covert Faults](index_split_001.html#p76)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Computation Faults](index_split_001.html#p76)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Byzantine Faults](index_split_001.html#p77)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Byzantine Faults with Authentication](index_split_001.html#p77)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Byzantine Faults Without Authentication](index_split_001.html#p77)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Timing Faults](index_split_001.html#p77)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Safety and Liveness](index_split_001.html#p78)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Forms of Fault Tolerance](index_split_001.html#p79)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[CAP Theorem](index_split_001.html#p80)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Consistency](index_split_001.html#p80)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Availability](index_split_001.html#p80)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Partition Tolerance](index_split_001.html#p80)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Cryptography in Distributed Systems](index_split_001.html#p82)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Summary](index_split_001.html#p83)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Bibliography](index_split_001.html#p84)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 2: Cryptography](index_split_001.html#p86)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Introduction](index_split_001.html#p86)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[A Typical Cryptosystem](index_split_001.html#p87)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Cryptographic Primitives](index_split_001.html#p89)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Symmetric Cryptography](index_split_001.html#p89)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Stream Ciphers](index_split_001.html#p90)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Block Ciphers](index_split_001.html#p92)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Electronic Codebook](index_split_001.html#p93)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Cipher Block Chaining](index_split_001.html#p94)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Counter Mode](index_split_001.html#p95)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Keystream Generation Mode](index_split_001.html#p95)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Message Authentication Mode](index_split_001.html#p96)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Cryptographic Hash Mode](index_split_001.html#p96)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Advanced Encryption Standard](index_split_001.html#p96)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Some Basic Mathematics](index_split_001.html#p98)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Prime](index_split_001.html#p98)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Modular Arithmetic](index_split_001.html#p99)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Group](index_split_001.html#p99)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Abelian Group](index_split_001.html#p99)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Field](index_split_001.html#p99)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Finite Field (Galois Field)](index_split_001.html#p99)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Prime Fields](index_split_001.html#p99)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Generator](index_split_001.html#p100)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Public Key Cryptography](index_split_001.html#p100)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Diffie-Hellman Key Exchange](index_split_001.html#p101)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Digital Signatures](index_split_001.html#p104)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Entity Authentication](index_split_001.html#p104)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Key Agreement](index_split_001.html#p104)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[RSA](index_split_001.html#p104)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Key Pair Generation](index_split_001.html#p104)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Encryption and Decryption](index_split_001.html#p106)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example of Key Generation, Encryption, and Decryption](index_split_001.html#p106)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Elliptic Curve Cryptography](index_split_001.html#p107)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Point Addition](index_split_001.html#p108)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Point Doubling](index_split_001.html#p110)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Scalar Point Multiplication](index_split_001.html#p111)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Elliptic Curve Discrete Logarithm Problem](index_split_001.html#p111)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Digital Signatures](index_split_001.html#p113)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Authenticity](index_split_001.html#p113)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Unforgeability (Nonrepudiation)](index_split_001.html#p113)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Nonreusability](index_split_001.html#p114)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ECDSA Signatures](index_split_001.html#p115)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Multisignatures](index_split_001.html#p116)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Threshold Signatures](index_split_001.html#p117)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Aggregate Signatures](index_split_001.html#p118)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Ring Signatures](index_split_001.html#p119)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Hash Functions](index_split_001.html#p120)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Preimage Resistance](index_split_001.html#p120)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Second Preimage Resistance](index_split_001.html#p120)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Collision Resistance](index_split_001.html#p121)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Design of Secure Hash Algorithms (SHA)](index_split_001.html#p122)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Design of SHA-256](index_split_001.html#p122)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Preprocessing](index_split_001.html#p122)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Hash Computation](index_split_001.html#p123)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Design of SHA-3 (Keccak)](index_split_001.html#p124)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Message Authentication Codes](index_split_001.html#p126)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Hash-Based MACs (HMACs)](index_split_001.html#p127)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Verifiable Delay Functions](index_split_001.html#p128)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Verifiable Random Functions](index_split_001.html#p129)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Summary](index_split_001.html#p130)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Bibliography](index_split_001.html#p130)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 3: Distributed Consensus](index_split_001.html#p132)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Broadcast Primitives](index_split_001.html#p132)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Best-Effort Broadcast](index_split_002.html#p134)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Validity](index_split_002.html#p134)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[No Duplication](index_split_002.html#p134)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[No Creation](index_split_002.html#p135)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Reliable Broadcast](index_split_002.html#p135)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Validity](index_split_002.html#p135)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Agreement](index_split_002.html#p136)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Remarks](index_split_002.html#p136)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Uniform Reliable Broadcast](index_split_002.html#p136)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Uniform Agreement](index_split_002.html#p136)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[FIFO Reliable Broadcast](index_split_002.html#p137)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[FIFO Delivery](index_split_002.html#p138)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Causal Reliable Broadcast](index_split_002.html#p138)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Total Order Reliable Broadcast or Atomic Reliable Broadcast](index_split_002.html#p138)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Validity](index_split_002.html#p138)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Agreement](index_split_002.html#p138)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Integrity](index_split_002.html#p139)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Total Order](index_split_002.html#p139)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[FIFO Total Order Broadcast](index_split_002.html#p139)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Probabilistic Validity](index_split_002.html#p141)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Integrity](index_split_002.html#p141)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Relationship Between Broadcasts and Consensus](index_split_002.html#p141)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Agreement](index_split_002.html#p142)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Reliable Broadcast](index_split_002.html#p142)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Total Order Broadcast](index_split_002.html#p143)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The Byzantine Agreement Problem](index_split_002.html#p143)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The Basic Byzantine Generals Problem or BGP](index_split_002.html#p144)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The Interactive Consistency Problem](index_split_002.html#p144)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The Consensus Problem](index_split_002.html#p144)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[System Models](index_split_002.html#p147)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Distributed System](index_split_002.html#p147)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Timing Model/Synchrony](index_split_002.html#p148)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Process Failures](index_split_002.html#p149)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Channel Reliability](index_split_002.html#p150)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[History](index_split_002.html#p150)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Two Generals’ Problem](index_split_002.html#p151)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Byzantine Generals Problem](index_split_002.html#p152)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Replication](index_split_002.html#p154)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Active Replication](index_split_002.html#p156)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Passive Replication](index_split_002.html#p156)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Pros and Cons](index_split_002.html#p156)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Primary Backup Replication](index_split_002.html#p157)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chain Replication](index_split_002.html#p158)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[State Machine Replication](index_split_002.html#p159)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Same Initial State](index_split_002.html#p162)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Deterministic Operations](index_split_002.html#p162)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Coordination](index_split_002.html#p162)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Safety](index_split_002.html#p162)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Liveness](index_split_002.html#p162)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Linearizability](index_split_002.html#p164)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Sequential Consistency](index_split_002.html#p164)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Eventual Consistency](index_split_002.html#p164)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[SMR Using Weaker Broadcast Abstractions](index_split_002.html#p165)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Fundamental Results](index_split_002.html#p166)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Impossibility Results](index_split_002.html#p166)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Minimum Number of Processes](index_split_002.html#p167)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Crash Failure](index_split_002.html#p167)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Byzantine Failure](index_split_002.html#p167)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Minimum Connectivity](index_split_002.html#p168)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Minimum Rounds](index_split_002.html#p168)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[FLP Impossibility](index_split_002.html#p168)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Synchrony Assumptions](index_split_002.html#p171)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Random Oracles](index_split_002.html#p171)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Hybrid Models](index_split_002.html#p172)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Failure Detectors](index_split_002.html#p173)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Strong Completeness](index_split_002.html#p175)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Weak Completeness](index_split_002.html#p175)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Strong Accuracy](index_split_002.html#p175)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Weak Accuracy](index_split_002.html#p175)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Eventual Strong Accuracy](index_split_002.html#p175)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Eventual Weak Accuracy](index_split_002.html#p175)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Perfect Failure Detector P](index_split_002.html#p176)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Strong Failure Detector S](index_split_002.html#p176)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Eventually Perfect Failure Detector – Diamond P](index_split_002.html#p176)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Eventually Strong Failure Detector – Diamond S](index_split_002.html#p177)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Weak Failure Detector W](index_split_002.html#p177)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Eventually Weak Failure Detector (Diamond W)](index_split_002.html#p177)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Detector Q or V](index_split_002.html#p177)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Eventually Detector Q (Diamond Q) or Diamond V](index_split_002.html#p177)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Leader Elector Failure Detector](index_split_002.html#p178)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Solving Consensus Using Failure Detectors](index_split_002.html#p179)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Quorums](index_split_002.html#p179)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Crash Fault–Tolerant Quorums](index_split_002.html#p180)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Byzantine Quorums](index_split_002.html#p181)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Read and Write Quorums](index_split_002.html#p181)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Where Are We Now](index_split_002.html#p181)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Classical Consensus](index_split_002.html#p182)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Nakamoto and Post-Nakamoto Consensus](index_split_002.html#p182)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Summary](index_split_002.html#p182)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Bibliography](index_split_002.html#p183)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 4: Blockchain](index_split_002.html#p185)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[What Is Blockchain](index_split_002.html#p185)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Layman’s Definition](index_split_002.html#p185)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Technical Definition](index_split_002.html#p186)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Background](index_split_002.html#p186)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Digital Cash Creation Attempts](index_split_002.html#p186)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The First Blockchain?](index_split_002.html#p188)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Benefits of Blockchain](index_split_002.html#p188)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Types of Blockchain](index_split_002.html#p190)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Blockchain Is a Distributed System](index_split_002.html#p192)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[CAP and Permissionless Blockchain](index_split_002.html#p192)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[CAP and Permissioned Blockchain](index_split_002.html#p192)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Blockchain Ledger Abstraction](index_split_002.html#p193)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Properties](index_split_002.html#p194)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Consistency](index_split_002.html#p194)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Fault Tolerant](index_split_002.html#p194)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Finality](index_split_002.html#p194)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Immutability](index_split_003.html#p195)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Append Only](index_split_003.html#p195)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Tamper Resistant/Proof](index_split_003.html#p195)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Validity](index_split_003.html#p195)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Termination Guarantee of Blockchain Operations: get(), append(), verify()](index_split_003.html#p195)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Order](index_split_003.html#p195)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Verifiable](index_split_003.html#p196)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[How Blockchain Works](index_split_003.html#p196)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Anatomy of a Blockchain](index_split_003.html#p197)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Block](index_split_003.html#p198)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Platforms](index_split_003.html#p199)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Bitcoin](index_split_003.html#p199)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Bitcoin Node and Architecture](index_split_003.html#p199)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Cryptography in Bitcoin](index_split_003.html#p202)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Public Keys and Private Keys](index_split_003.html#p202)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Addresses and Accounts](index_split_003.html#p203)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Transactions and UTXO Model](index_split_003.html#p204)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Bitcoin Script and Miniscript](index_split_003.html#p206)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Blocks and Blockchain](index_split_003.html#p208)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Mining](index_split_003.html#p209)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Bitcoin As a Platform](index_split_003.html#p209)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Ethereum](index_split_003.html#p210)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Ethereum Network](index_split_003.html#p210)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Cryptography in Ethereum](index_split_003.html#p214)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Accounts and Addresses](index_split_003.html#p214)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Transactions and Executions](index_split_003.html#p215)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Blocks and Blockchain](index_split_003.html#p217)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Transaction Trie](index_split_003.html#p218)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[World State Trie](index_split_003.html#p218)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Transaction Receipts Trie](index_split_003.html#p218)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Account Storage Trie](index_split_003.html#p219)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Mining in Ethereum](index_split_003.html#p219)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Ethereum Virtual Machine and Smart Contracts](index_split_003.html#p220)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Summary](index_split_003.html#p221)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Bibliography](index_split_003.html#p222)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 5: Blockchain Consensus](index_split_003.html#p224)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Background](index_split_003.html#p225)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Blockchain Consensus](index_split_003.html#p227)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Traditional BFT](index_split_003.html#p227)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Agreement](index_split_003.html#p227)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Validity](index_split_003.html#p227)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Termination](index_split_003.html#p227)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Integrity](index_split_003.html#p228)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chain Progress (Liveness)](index_split_003.html#p228)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Instant Irrevocability](index_split_003.html#p228)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Consensus Finality](index_split_003.html#p228)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Nakamoto Consensus](index_split_003.html#p228)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Agreement](index_split_003.html#p228)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Validity](index_split_003.html#p228)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Termination](index_split_003.html#p229)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Consensus Finality](index_split_003.html#p229)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chain Progress (Liveness)](index_split_003.html#p230)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Consistent/Consistency](index_split_003.html#p230)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Eventual Irrevocability](index_split_003.html#p230)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[System Model](index_split_003.html#p230)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Public Blockchain System Model (Permissionless)](index_split_003.html#p230)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Consortium Blockchain System Model (Permissioned)](index_split_003.html#p231)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[First Blockchain Consensus](index_split_003.html#p231)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[How PoW Works](index_split_003.html#p233)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Pedagogical Explanation of PoW](index_split_003.html#p234)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PoW Formula](index_split_003.html#p238)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Task of Miners](index_split_003.html#p239)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Properties of PoW](index_split_003.html#p242)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Completeness](index_split_003.html#p242)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Computationally Complex – Difficult to Compute – Slow Creation](index_split_003.html#p242)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Auto-adjustable Cost – Dynamic Cost](index_split_003.html#p243)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Quick and Efficient Verification – Quick Verification](index_split_003.html#p243)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Progress Free](index_split_003.html#p243)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Probabilistic Aspects of Dynamic Parameters](index_split_003.html#p246)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Probability of an Attacker Catching Up](index_split_003.html#p247)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PoW Algorithm](index_split_003.html#p248)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Game Theory and Proof of Work](index_split_003.html#p249)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Prisoner’s Dilemma](index_split_003.html#p250)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PoW and Game Theory](index_split_003.html#p252)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Similarities Between PoW and Traditional BFT](index_split_004.html#p254)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Common Prefix](index_split_004.html#p255)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chain Quality](index_split_004.html#p255)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chain Growth](index_split_004.html#p255)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PoW As State Machine Replication](index_split_004.html#p255)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Leader Election Algorithm](index_split_004.html#p255)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Log Replication](index_split_004.html#p256)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[New Block Propagation](index_split_004.html#p256)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Block Validation](index_split_004.html#p257)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Append to the Blockchain](index_split_004.html#p258)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Fork Resolution](index_split_004.html#p259)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Sybil Resistance](index_split_004.html#p263)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Significance of Block Timestamp](index_split_004.html#p264)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[A Caveat](index_split_004.html#p265)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PoW As a Solution to Byzantine Generals Problem](index_split_004.html#p266)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Agreement](index_split_004.html#p267)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Validity – Predicate Based](index_split_004.html#p267)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Termination](index_split_004.html#p268)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PoW Concerns](index_split_004.html#p268)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[51% Attack](index_split_004.html#p268)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Selfish Mining](index_split_004.html#p269)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Race Attack](index_split_004.html#p269)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Finney Attack](index_split_004.html#p269)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Vector76 Attack](index_split_004.html#p270)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Eclipse Attack](index_split_004.html#p270)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ESG Impact](index_split_004.html#p270)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Variants of PoW](index_split_004.html#p272)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[CPU-Bound PoW](index_split_004.html#p272)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Memory-Bound PoW](index_split_004.html#p272)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Summary](index_split_004.html#p273)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Bibliography](index_split_004.html#p273)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 6: Early Protocols](index_split_004.html#p275)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Introduction](index_split_004.html#p275)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Distributed Transactions](index_split_004.html#p278)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Two-Phase Commit](index_split_004.html#p279)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Three-Phase Commit](index_split_004.html#p282)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Oral Message Algorithm](index_split_004.html#p284)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Signed Message Solution to Byzantine Generals Problem](index_split_004.html#p288)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[DLS Protocols Under Partial Synchrony](index_split_004.html#p291)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Ben-Or Algorithms](index_split_004.html#p294)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Consensus Using Failure Detectors](index_split_004.html#p300)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Summary](index_split_004.html#p303)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Bibliography](index_split_004.html#p303)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 7: Classical Consensus](index_split_004.html#p306)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Viewstamped Replication](index_split_004.html#p306)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Protocol Steps](index_split_004.html#p308)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[View Change](index_split_004.html#p309)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Paxos](index_split_004.html#p311)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Failure Scenarios](index_split_005.html#p316)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Safety and Liveness](index_split_005.html#p319)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[In Practice](index_split_005.html#p320)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Variants](index_split_005.html#p320)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Multi-Paxos](index_split_005.html#p321)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[RAFT](index_split_005.html#p323)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Leader Election](index_split_005.html#p325)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Log Replication](index_split_005.html#p326)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Guarantees and Correctness](index_split_005.html#p329)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PBFT](index_split_005.html#p330)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Certificates in PBFT](index_split_005.html#p334)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Types of Messages](index_split_005.html#p335)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[View Change](index_split_005.html#p336)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The Checkpoint Subprotocol](index_split_005.html#p338)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PBFT Advantages and Disadvantages](index_split_005.html#p338)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Strengths](index_split_005.html#p338)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Weaknesses](index_split_005.html#p339)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Safety and Liveness](index_split_005.html#p339)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Order Within a View](index_split_005.html#p341)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Order Across Views](index_split_005.html#p341)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Blockchain and Classical Consensus](index_split_005.html#p342)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Summary](index_split_005.html#p343)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Bibliography](index_split_005.html#p343)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 8: Blockchain Age Protocols](index_split_005.html#p345)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Introduction](index_split_005.html#p345)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Proof of Stake](index_split_005.html#p347)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chain-Based PoS](index_split_005.html#p349)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Committee-Based PoS](index_split_005.html#p349)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[BFT-Based PoS](index_split_005.html#p350)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Delegated PoS](index_split_005.html#p351)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Liquid PoS](index_split_005.html#p351)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Attacks](index_split_005.html#p352)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Nothing-at-Stake Problem](index_split_005.html#p352)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Long-Range Attacks](index_split_005.html#p352)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Other Attacks](index_split_005.html#p353)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Ethereum’s Proof of Work](index_split_005.html#p353)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Solana](index_split_005.html#p356)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Proof of History](index_split_005.html#p357)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Tendermint](index_split_005.html#p361)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[HotStuff](index_split_005.html#p367)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Linear View Change](index_split_005.html#p367)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Optimistic Responsiveness](index_split_005.html#p368)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chain Quality](index_split_005.html#p368)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Hidden Lock](index_split_005.html#p368)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Pacemaker](index_split_005.html#p369)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Better Participant Organization Topology](index_split_005.html#p369)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[How It Works](index_split_006.html#p370)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Prepare](index_split_006.html#p370)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Pre-commit](index_split_006.html#p370)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Commit](index_split_006.html#p370)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Decide](index_split_006.html#p370)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Safety and Liveness](index_split_006.html#p372)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Polkadot](index_split_006.html#p373)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Consensus in Polkadot](index_split_006.html#p375)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[BABE – Blind Assignment for Blockchain Extension](index_split_006.html#p376)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Genesis Phase](index_split_006.html#p377)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Normal Phase](index_split_006.html#p377)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Epoch Update](index_split_006.html#p378)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Safety and Liveness](index_split_006.html#p379)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chain Growth](index_split_006.html#p380)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chain Quality](index_split_006.html#p380)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chain Density](index_split_006.html#p380)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Common Prefix](index_split_006.html#p380)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[GRANDPA – GHOST-Based Recursive Ancestor Deriving Prefix Agreement](index_split_006.html#p380)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[GRANDPA Protocol Steps](index_split_006.html#p381)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Safety](index_split_006.html#p382)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Liveness](index_split_006.html#p382)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Ethereum 2](index_split_006.html#p382)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Casper](index_split_006.html#p384)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Casper FFG](index_split_006.html#p384)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Summary](index_split_006.html#p388)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Bibliography](index_split_006.html#p389)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 9: Quantum Consensus](index_split_006.html#p391)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Introduction](index_split_006.html#p391)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[What Is a Quantum Computer?](index_split_006.html#p392)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Qubit](index_split_006.html#p394)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Superposition](index_split_006.html#p396)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Entanglement](index_split_006.html#p396)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Maximal Coordination](index_split_006.html#p397)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Monogamy](index_split_006.html#p397)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Quantum Gates](index_split_006.html#p398)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Hadamard](index_split_006.html#p398)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[T](index_split_006.html#p399)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[CNOT](index_split_006.html#p399)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Toffoli (CCNOT)](index_split_006.html#p399)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Z](index_split_006.html#p399)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[NOT](index_split_006.html#p399)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Swap Gate](index_split_006.html#p399)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Measurement](index_split_006.html#p400)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Quantum Circuits](index_split_006.html#p400)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Teleportation Circuit](index_split_006.html#p401)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[GHZ Circuit](index_split_006.html#p401)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[W State Circuit](index_split_006.html#p402)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Quantum Algorithms](index_split_006.html#p402)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Quantum Computational Complexity](index_split_006.html#p403)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[P – Polynomial](index_split_006.html#p405)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[NP – Nondeterministic Polynomial](index_split_006.html#p405)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[BPP – Bounded Error Probabilistic Polynomial Time](index_split_006.html#p405)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[BQP – Bounded Error Quantum Polynomial Time](index_split_006.html#p406)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PSPACE – Polynomial Space](index_split_006.html#p406)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Other Quantum Systems](index_split_006.html#p407)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Quantum Networks](index_split_006.html#p407)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Quantum Internet](index_split_006.html#p407)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Quantum Distributed Systems – Distributed Quantum Computing](index_split_006.html#p408)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Quantum Blockchain](index_split_006.html#p409)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Quantum Cryptography](index_split_006.html#p410)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Quantum Consensus](index_split_006.html#p412)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Fast Quantum Byzantine Agreement](index_split_006.html#p413)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[How to Refute FLP Impossibility](index_split_006.html#p415)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Enhanced Distributed Consensus](index_split_006.html#p417)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Quantum Leader Election and Consensus](index_split_006.html#p419)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Other Algorithms](index_split_006.html#p420)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Summary](index_split_006.html#p421)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Bibliography](index_split_006.html#p422)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 10: Conclusion](index_split_006.html#p424)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Introduction](index_split_006.html#p424)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Other Protocols](index_split_006.html#p424)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PoET](index_split_006.html#p425)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Proof of Authority](index_split_006.html#p426)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[HoneyBadger BFT](index_split_006.html#p426)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Avalanche](index_split_006.html#p428)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[DAG-Based Consensus Protocols](index_split_006.html#p428)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Block-Based DAG](index_split_006.html#p429)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Transaction-Based DAG](index_split_006.html#p429)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Ebb-and-Flow Protocols](index_split_006.html#p429)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Formal Verification](index_split_006.html#p430)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Impossibility Results](index_split_006.html#p433)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Complexity and Performance](index_split_006.html#p435)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Message Complexity](index_split_006.html#p435)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Communication Complexity (Bit Complexity)](index_split_006.html#p435)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Time Complexity](index_split_006.html#p436)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Space Complexity](index_split_006.html#p436)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Comparison of Protocols](index_split_006.html#p437)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Network Model](index_split_006.html#p439)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Synchronous](index_split_006.html#p439)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Eventual Synchrony](index_split_006.html#p439)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Partial Synchrony](index_split_006.html#p439)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Weak Synchrony](index_split_006.html#p440)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Asynchronous](index_split_006.html#p440)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Research Directions](index_split_006.html#p441)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Summary](index_split_006.html#p443)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Bibliography](index_split_006.html#p443)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Index](index_split_006.html#p445)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
