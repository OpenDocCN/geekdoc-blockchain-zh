["```\nvar workflowStatusChangeEvent  =\n    contractInstance.WorkflowStatusChangeEvent();    *1*\n\nworkflowStatusChangeEvent\n   .watch(function(error, result) {                  *2*\n    if (!error)\n        refreshWorkflowStatus();\n    else\n        console.log(error);\n});\n```", "```\nvar pastWorkflowStatusChangeEvent =\n    contractInstance.WorkflowStatusChangeEvent(\n       {},\n       {fromBlock: 5000, toBlock: 'latest'});        *1*\n```", "```\npastWorkflowStatusChangeEvent.get(\n   function(error, logs) {                           *1*\n   if (!error)\n       logs.forEach(log => console.log(log.args));   *2*\n   else\n    console.log(error);\n});\n```", "```\nvar allEventPastEvents = contractInstance.allEvents(\n    {}, {fromBlock: 1000000, toBlock: 'latest'});        *1*\n```", "```\nallEventPastEvents.get((error, logs) => { \n  logs.forEach(log => console.log(log.args))\n});\n```", "```\nevent Transfer(address indexed from, address indexed to, uint256 value);\n```", "```\nvar specificSourceAccountAddress =\n    '0x8062a8850ef59dCd3469A83E04b4A40692a873Ba';\nvar transactionsFromSpecificAccount =\n    simpleCoinInstance.Transferred(\n    {from: specificSourceAccountAddress},\n    {fromBlock: 5000, toBlock: 'latest'});\ntransactionsFromSpecificAccount.get((error, logs) => {\n    logs.forEach(log => console.log(log.args));\n});\n```", "```\nevent ProposalRegisteredEvent(uint proposalId);\n```", "```\nevent ProposalRegisteredEvent(\n    address author, uint proposalId, string proposalDescription);\n```", "```\nevent ProposalRegisteredEvent(\n    address indexed author,\n    uint proposalId, string proposalDescription);\n```", "```\n    function authorize(address _authorizedAccount, uint256 _allowance)\n        public view returns (bool success) {\n        allowance[msg.sender][_authorizedAccount] = _allowance;\n        return true;\n    }\n```", "```\nWarning: Function declared as view, but this expression (potentially)\n     modifies the state...\n```", "```\nexternalContractAddress.call.value(etherAmount)(\n    bytes4(sha3(\"externalFunction()\")\n```", "```\nexternalContractAddress.call.value(etherAmount)()\n```", "```\ncontract ExternalContract {\n   ...\n   function payable() { }          *1*\n}\n\ncontract A {\n   ...\n   function doSomething()\n   {\n      ...\n      externalContractAddress.send(etherAmount); \n   }\n}\n```", "```\nexternalContractAddress.call.value(etherAmount)()\n```", "```\nexternalContractAddress.send(etherAmount);          *1*\n\nexternalContractAddress.call.value(etherAmount)();  *2*\n\nexternalContractAddress.call.value(etherAmount)(\n    bytes4(sha3(\"externalFunction()\");              *3*\n```", "```\ncontract ExternalContract {\n   ... \n   function externalFunction payable (uint _input) {\n   ...                                                           *1*\n   } \n}\n\ncontract A {\n   ...\n   function doSomething ()\n   {\n      uint stateVariable;\n\n      uint initialBalance = this.Balance;\n      uint commission = 60;\n      externalContractAddress.call.value(commission)(\n           bytes4(sha3(\"externalFunction()\")), 10);            *2*\n\n      require(this.Balance == initialBalance - commission);    *3*\n      require(stateVariable == expectedValue);                 *3*\n   }\n}\n```", "```\ncontract ExternalContract {\n   ...\n\n   function externalFunction payable (uint _input) {\n   ...                                                *1*\n   } \n}\n\ncontract A {\n   uint stateVariable;\n\n   ...\n   function doSomething ()\n   { \n      uint initialBalance = this.Balance;\n      uint commission = 60;\n\n      if (!externalContractAddress.call.value(commission)(\n         bytes4(sha3(\"externalFunction()\")), 10))\n         revert();\n   }\n   ...\n```", "```\nexternalContractAddress.transfer(etherAmount);        *1*\n```", "```\nExternalContract(externalContractAddress)\n    .externalFunction();                      *1*\n```", "```\ncontract A {\n   uint value;                                     *1*\n   address  msgSender;                             *1*\n   address externalContractAddress = 0x5;\n\n   function setValue(uint _value)\n   {\n      externalContractAddress.call.(\n          bytes4(sha3(\"setValue()\")), _value);     *2*\n   }\n}\n\ncontract ExternalContract {\n\n   uint value;                                     *3*\n   address msgSender;                              *3*\n\n   function setValue(uint _value) {\n       value = _value;                             *4*\n       msgSender = msg.sender;                     *5*\n   } \n} \n```", "```\nContractA.setValue(33)\n```", "```\ncontract A {\n   uint value;                                   *1*\n   address msgSender;                            *1*\n   address externalContractAddress = 0x5;\n\n   function setValue(uint _value)\n   {\n      externalContractAddress.delegatecall.(\n        bytes4(sha3(\"setValue()\")), _value);     *2*\n\n   }\n}\n\ncontract ExternalContract {\n\n   uint value;                                   *3*\n   address msgSender;                            *3*\n\n   function setValue(uint _value) {\n      value = _value;                            *4*\n      msgSender = msg.sender;                    *5*\n   } \n}\n```", "```\nContractA.setValue(33)\n```", "```\nfunction setValue(uint _value)\n{\n   externalContractAddress.callcode.(bytes4(sha3(\"setValue()\")), _value);\n}\n```", "```\ncontract Auction {//INCORRECT CODE //DO NOT USE!//UNDER APACHE LICENSE 2.0\n    // Copyright 2016 Smart Contract Best Practices Authors\n    address highestBidder;\n    uint highestBid;\n\n    function bid() payable {\n        require(msg.value >= highestBid);           *1*\n\n        if (highestBidder != 0) { \n           highestBidder.transfer(highestBid);      *2*\n        }\n\n       highestBidder = msg.sender;                  *3*\n       highestBid = msg.value;                      *3*\n    }\n}\n```", "```\ncontract MaliciousBidder {\n   address auctionContractAddress = 0x123;\n   function submitBid() public {\n      auctionContractAddress.call.value(\n          100000000000)(bytes4(sha3(\"bid()\")));\n   }\n\n   function payable() { \n      revert ();            *1*\n   } \n...\n}\n```", "```\nhighestBidder.transfer(highestBid);\n```", "```\nrequire(highestBidder.send(highestBid));\n```", "```\nfunction () payable() {\n      refunds +=  msg.value;       *1*\n}\n```", "```\n//UNDER APACHE LICENSE 2.0\n//Copyright 2016 Smart Contract Best Practices Authors\n//https://consensys.github.io/smart-contract-best-practices/\ncontract Auction {\n    address highestBidder;\n    uint highestBid;\n    mapping(address => uint) refunds;\n\n    function bid() payable external {\n         require(msg.value >= highestBid);\n\n        if (highestBidder != 0) {\n            refunds[highestBidder] += highestBid;     *1*\n        }\n\n        highestBidder = msg.sender;                   *2*\n        highestBid = msg.value;                       *2*\n    }\n\n    function withdrawRefund() external {\n        uint refund = refunds[msg.sender];\n        refunds[msg.sender] = 0;\n        msg.sender.transfer(refund);                  *3*\n        }\n    }\n}\n```", "```\ncontract Crowdsale {\n   address[] investors;\n   mapping(address => uint) investments;\n\n   function refundAllInvestors() payable onlyOwner external {\n      //INCORRECT CODE //DO NOT USE!\n\n      for (int i =0; i< investors.length; ++i) {\n         investors[i].send(investments[investors[i]]);     \n    }\n}\n```", "```\ncontract Crowdsale {\n   address[] investors;\n   mapping(address => uint) investments;\n   mapping(address => uint) refunds;\n\n   function refundAllInvestors() payable onlyOwner external {\n\n      for (int i =0; i< investors.length; ++i) {\n         refunds[investors [i]] = investments[i];\n         investments[investors[i]] = 0;     \n      }\n   }\n\n   function withdrawRefund() external {\n      uint refund = refunds[msg.sender];\n      refunds[msg.sender] = 0;\n      msg.sender.transfer(refund); \n   }\n}    \n```", "```\nfunction() public payable {}\n```", "```\n function() public payable {revert ();}\n```", "```\nselfdestruct(recipientAddress);\n```", "```\nfunction withdrawRefund() external { {//INCORRECT CODE //DO NOT USE!\n    // UNDER APACHE LICENSE 2.0\n    // Copyright 2016 Smart Contract Best Practices Authors\n   uint refund = refunds[msg.sender];\n   require (msg.sender.call.value(refund)());     *1*\n   refunds[msg.sender] = 0;                       *2*\n}\n```", "```\ncontract ReentrancyAttacker {\n   function() payable public () {\n     uint maxUint = 2 ** 256 - 1;\n     for (uint I = 0; i < maxUint; ++i)\n     { \n        for (uint j =0; j  < maxUint; ++j)\n        {\n           for  (uint k =0; k < maxUint; ++k)       *1*\n           {\n                ...\n     }\n}\n```", "```\nrefunds[msg.sender] = 0;\n```", "```\nfunction withdrawRefund() external {\n   uint refund = refunds[msg.sender];\n   refunds[msg.sender] = 0;\n   require (msg.sender.call.value(refund)());         *1*\n}\n```", "```\nfunction transfer(address _to, uint256 _amount) public {\n    require(coinBalance[msg.sender] > _amount);\n    require(coinBalance[_to] + _amount >= coinBalance[_to] );\n    coinBalance[msg.sender] -= _amount;  \n    coinBalance[_to] += _amount;   \n    emit Transfer(msg.sender, _to, _amount);  \n}\n```", "```\nfunction withdrawFullBalance() public {//INCORRECT CODE //DO NOT USE!\n    uint amountToWithdraw = coinBalance[msg.sender] * exchangeRate;\n    require(msg.sender.call.value(\n        amountToWithdraw)());               *1*\n    coinBalance[msg.sender] = 0;\n}\n```", "```\ncontract RaceConditionAttacker {\n   function() payable public () {\n      uint maxUint = 2 ** 256 - 1;\n         for (uint I = 0; i < maxUint; ++i)\n         { \n            for (uint j =0; j  < maxUint; ++j)\n            {\n               for   (uint k =0; k < maxUint; k++)\n               {\n                  ...\n     }\n}\n```", "```\nfunction withdrawFullBalance() public {\n    uint amountToWithdraw = coinBalance[msg.sender];\n    coinBalance[msg.sender] = 0;\n    require(msg.sender.call.value(\n        amountToWithdraw)());              *1*\n}\n```", "```\nfunction payable() { \n   revert ();              *1*\n} \n```", "```\nfunction bid() payable {//INCORRECT CODE//DO NOT USE!\n   //UNDER APACHE LICENSE 2.0\n   //Copyright 2016 Smart Contract Best Practices Authors\n\n   require(msg.value >= highestBid);          *1*\n\n   if (highestBidder != 0) { \n      highestBidder.transfer(highestBid));    *2*\n   }\n\n   highestBidder = msg.sender;                *3*\n   highestBid = msg.value;                    *3*\n}\n```", "```\ncontract Crowdsale {\n   address[] investors;\n   mapping(address => uint) investments;\n\n   function refundAllInvestors() payable onlyOwner external {\n      //INCORRECT CODE //DO NOT USE!    \n      for (int i =0; i< investors.length; ++i) {\n         investors[i].send(investments[investors[i]]);     \n    }\n}\n```"]