- en: © Elad Elrom 2019Elad ElromThe Blockchain Developer[https://doi.org/10.1007/978-1-4842-4847-8_2](https://doi.org/10.1007/978-1-4842-4847-8_2)
  prefs: []
  type: TYPE_NORMAL
- en: 2. Blockchain Nodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Elad Elrom^([1](#Aff2) )(1)New York, NY, USA
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, I covered basic concepts related to blockchain and
    the pieces that make up an individual blockchain. I covered how blockchain technology
    solved the double spending problem by utilizing a P2P network, which led to the
    creation of a global distributed shared ledger and digital cash. The blockchain
    P2P network is stitched together by connecting multiple nodes, and in this chapter,
    you will be taking a closer look at the nodes that make up the network.
  prefs: []
  type: TYPE_NORMAL
- en: The nodes or peers are machines that maintain the transactions and records on
    the blockchain network. Each cryptocurrency has its own blockchain and nodes;
    however, I will cover how to install three different blockchains that utilize
    different consensus mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, I will cover how to interact with a node. I will be using the bitcoin
    core API as an example so you will have a better understanding of the ledger,
    blocks, transactions, and wallets. These concepts will continue to lay out the
    foundations and basic concepts that are needed in the next chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Running a Blockchain Node
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we mentioned, the blockchain P2P network consists of peers that store a
    full copy of all the blocks in the network, which is the shared ledger. Each blockchain
    validates blocks via a specific consensus mechanism and is able to reject blocks
    that do not conform with the set of rules agreed on by the network. To be able
    to connect to blocks and execute commands, you need to have a peer connected to
    the blockchain. In this chapter, you will be setting up a full node and will learn
    how to get rewarded for helping the network; therefore, you will fully understand
    how the nodes on different networks operate. You will be creating nodes for the
    following: bitcoin, NEO, and EOS. Because blockchain technologies operate on different
    consensus mechanisms, they also have different names for the node capable of managing
    the blockchain.'
  prefs: []
  type: TYPE_NORMAL
- en: For bitcoin, a node that can create blocks is called a *miner* .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For NEO, a node that has management rights is called a *bookkeeping*  *node*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For EOS, a node running the underlying network layer and able to process all
    transactions is called a *block producer* .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The reason I selected these blockchains is so you can examine how different
    peers working on different networks with different consensus mechanism operate.
    Once you are able to work with different blockchains, you will start noticing
    a pattern and be well rounded in blockchain technology.
  prefs: []
  type: TYPE_NORMAL
- en: Create a Bitcoin Miner
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, you will turn your own computer into a bitcoin cryptominer  and
    start cryptomining. Before doing that, you need to understand that the hashing
    power of your computer is not going to generate enough hash power for the mining
    of bitcoin to be profitable. Nevertheless, it will allow you to fully understand
    the full cycle, and you may be able to find other coins where mining using your
    CPU/GPU is profitable such as ETN, BCN, XMR, and ETH. The process is similar in
    all PoW-based networks.
  prefs: []
  type: TYPE_NORMAL
- en: Today, for a miner to be profitable, it’s a matter of hash rate and power consumption,
    price of electricity, bitcoin puzzle difficulty rate, and maintenance costs as
    well as other factors.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Hash rate* is the number of calculations in a second that your computer can
    perform trying to solve the mathematical puzzle.'
  prefs: []
  type: TYPE_NORMAL
- en: In the early days of bitcoin, your desktop could use your central processing
    unit (CPU) or graphics processing unit (GPU) for processing bitcoin, and it would
    have been enough for bitcoin mining to be profitable. Your computer would have
    been able to support the bitcoin network; however, the competition has increased,
    and you now need a field programmable gate array (FPGA) or application-specific
    integrated circuit (ASIC)  miner to be profitable.
  prefs: []
  type: TYPE_NORMAL
- en: What are ASIC and FPGA miners? An FPGA is an integrated circuit that is able
    to be configured after being built. The miners have better performance than CPUs
    and GPUs mining; they can hash 750 megahashes per second.
  prefs: []
  type: TYPE_NORMAL
- en: ASICs  are computers that have an integrated circuit dedicated to performing
    the single task of mining instead of operating as a regular computer. There is
    nothing more on that computer; everything else was stripped out.
  prefs: []
  type: TYPE_NORMAL
- en: This makes the computer much faster and more efficient in processing transactions,
    and it is able to hash more. At the time of writing, there are ASICs that can
    hash over 56 TH/sec, and they use less power than older generation ASCIs.
  prefs: []
  type: TYPE_NORMAL
- en: This type of mining equipment is not only unique to bitcoin; at the time of
    writing, there are ASIC miners for other cryptocurrency such as litecoin, zCash,
    ethereum, and others.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, you first need mining software. There is a lot of mining software
    to choose from. For instance macOS users can, this one is free, open source, and
    easy to use: [http://downloads.fabulouspanda.co.uk/macminer/](http://downloads.fabulouspanda.co.uk/macminer/)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have downloaded the software, install it. Next, you need to join a
    mining pool. Here I’ll show how to connect to Antpool, the largest bitcoin pool;
    however, any pool would work. Sign up on Antpool here: [https://www.antpool.com](https://www.antpool.com)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Antpool calls a miner a *worker*. You can create a worker by clicking the Dashboard
    tab, then clicking the Worker link, and finally clicking Create Worker, as shown
    in Figure [2-1](#Fig1).![../images/475651_1_En_2_Chapter/475651_1_En_2_Fig1_HTML.jpg](../images/475651_1_En_2_Chapter/475651_1_En_2_Fig1_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2-1
  prefs: []
  type: TYPE_NORMAL
- en: Antpool dashboard page for creating a mining worker
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your worker ready, you will set up your miner as a CPU miner
    utilizing your CPU, and for your GPU, you could set your miner to utilize your
    graphics card.
  prefs: []
  type: TYPE_NORMAL
- en: Open the MacMiner software you downloaded and click File and then Preference
    option from the File drop menu. In the Preferences section, set the miner as a
    CPU and/or GPU miner, as shown in Figure [2-2](#Fig2).![../images/475651_1_En_2_Chapter/475651_1_En_2_Fig2_HTML.png](../images/475651_1_En_2_Chapter/475651_1_En_2_Fig2_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2-2
  prefs: []
  type: TYPE_NORMAL
- en: MacMiner preferences
  prefs: []
  type: TYPE_NORMAL
- en: In the next step of the preferences, you set the pool URL and your username.
    Antpool is set up without a password, so it’s not needed, and the pool URL is
    listed on the Antpool site:startum+tcp://startum.antpool.com:3333See Figure [2-3](#Fig3).![../images/475651_1_En_2_Chapter/475651_1_En_2_Fig3_HTML.png](../images/475651_1_En_2_Chapter/475651_1_En_2_Fig3_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2-3
  prefs: []
  type: TYPE_NORMAL
- en: MacMiner Preferences window for setting up a miner pool
  prefs: []
  type: TYPE_NORMAL
- en: That’s it. Click the Start button to start mining and click Stop to stop mining,
    as shown in Figure [2-4](#Fig4).![../images/475651_1_En_2_Chapter/475651_1_En_2_Fig4_HTML.jpg](../images/475651_1_En_2_Chapter/475651_1_En_2_Fig4_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2-4
  prefs: []
  type: TYPE_NORMAL
- en: MacMiner  starting a miner
  prefs: []
  type: TYPE_NORMAL
- en: Six years ago, you would have been able to mine more than 100 BTC on your GPU.
    As you can see, my mining power on my 2018 MacBook resulted in 13.74 Mh (Mega
    hashes) of hashing power.
  prefs: []
  type: TYPE_NORMAL
- en: There are many resources online to help you calculate mining profitability;
    try [http://www.bitcoinx.com/profit/](http://www.bitcoinx.com/profit/) . As expected
    and according to their calculation, it would not be profitable at the current
    conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Create a NEO Bookkeeping Node
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Previously I introduced NEO  as an example of a popular PoS blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you will be setting up a node (NEO calls these *bookkeeping
    nodes*) and getting the machine ready so it can be selected to help manage the
    network and receive a transaction reward.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: NEO does not call its managing node a miner. A miner can be an analogy for the
    hard work that nodes do to maintain a PoW-based blockchain. As NEO uses the PoS
    census algorithm and uses a technological democracy to selecting the managing
    nodes, there is no hashing power and no hard labor when using the PoW census algorithm.
    To better understand how Neo node works, it is recommended to read the NEO white
    paper at [https://github.com/neo-project/docs/blob/master/en-us/whitepaper.md](https://github.com/neo-project/docs/blob/master/en-us/whitepaper.md)
    .
  prefs: []
  type: TYPE_NORMAL
- en: The node validates the blockchain blocks and pays in a cryptocurrency coin called
    *gas*. To be selected, you need to set a full node on a capable machine. The minimum
    required machine is listed on the NEO project wiki at [https://github.com/neo-project/neo/wiki/Bookkeeping-Node-Deployment](https://github.com/neo-project/neo/wiki/Bookkeeping-Node-Deployment)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to obtain a consensus authority certificate and get staking gas
    to be nominated as a bookkeeping node.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may need to be a Chinese citizen and set up a Chinese business to receive
    an identification certificate; see the NEO docs at [http://docs.neo.org/en-us/index.html](http://docs.neo.org/en-us/index.html)
    . You also need 1,000 staking gas to be nominated as a bookkeeping node.
  prefs: []
  type: TYPE_NORMAL
- en: 'To receive a fee from supporting the NEO network, you will need to create a
    full node by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up a full NEO node.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Request a consensus authority certificate.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '3.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Stake 1,000 gas.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '4.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Be elected by NEO holders.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To set up a full NEO node, you also need to meet the system minimum requirement
    listed here: [https://github.com/neo-project/neo/wiki/Bookkeeping-Node-Deployment](https://github.com/neo-project/neo/wiki/Bookkeeping-Node-Deployment)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up a NEO Node on AWS Ubuntu
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As my computer does not meet the minimum requirement list, I will be utilizing
    AWS to set up a full node. However, if you have a machine that meets these requirements,
    feel free to skip using Amazon AWS or select another service provider to set your
    Node.
  prefs: []
  type: TYPE_NORMAL
- en: 'For AWS, go to the following URL: [https://aws.amazon.com/free/](https://aws.amazon.com/free/)
    . Select “Create free account” and sign up.'
  prefs: []
  type: TYPE_NORMAL
- en: Once you complete the sign-up process, select the free Basic Plan. Then sign
    into the console at [https://us-east-2.console.aws.amazon.com/console/home](https://us-east-2.console.aws.amazon.com/console/home)
    and select “Launch a virtual machine.”
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first step, you can select the machine type. Select Ubuntu. “On the
    Step 1, wizard page: Choose an Amazon Machine Image (AMI)” ➤ Next, select: Ubuntu
    Server 16.04 LTS (HVM), SSD Volume Type ➤ Click the “select” button. See Figure
    [2-5](#Fig5).![../images/475651_1_En_2_Chapter/475651_1_En_2_Fig5_HTML.jpg](../images/475651_1_En_2_Chapter/475651_1_En_2_Fig5_HTML.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2-5
  prefs: []
  type: TYPE_NORMAL
- en: AWS, selecting Ubuntu Server 16.04 LTS
  prefs: []
  type: TYPE_NORMAL
- en: On the next screen, select General purpose - t2.micro - free tier eligible check-box.
    See Figure [2-6](#Fig6).![../images/475651_1_En_2_Chapter/475651_1_En_2_Fig6_HTML.jpg](../images/475651_1_En_2_Chapter/475651_1_En_2_Fig6_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2-6
  prefs: []
  type: TYPE_NORMAL
- en: AWS, selecting t2.micro machine
  prefs: []
  type: TYPE_NORMAL
- en: 'On the next screen, you will be prompted to create key pairs: Select “create
    a new key pair” ➤ next, select “key pair name” ➤ call the key “neo” ➤ then download
    the key: “download key pair” ➤ Lastly, select “Launch Instances.” See Figure [2-7](#Fig7).
    Make sure you download the key, as you won’t be able to connect via SSH to the
    box without the key.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Secure Shell (SSH) uses port 22 to connect your computer to another computer
    on the Internet.
  prefs: []
  type: TYPE_NORMAL
- en: '![../images/475651_1_En_2_Chapter/475651_1_En_2_Fig7_HTML.jpg](../images/475651_1_En_2_Chapter/475651_1_En_2_Fig7_HTML.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-7
  prefs: []
  type: TYPE_NORMAL
- en: AWS key pairs
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you will get a message, with a link: your instances are now launching.
    The following instance launches have been initiated: [instance id].'
  prefs: []
  type: TYPE_NORMAL
- en: Click the link and you will be able to view the instance, as shown in Figure
    [2-8](#Fig8).![../images/475651_1_En_2_Chapter/475651_1_En_2_Fig8_HTML.jpg](../images/475651_1_En_2_Chapter/475651_1_En_2_Fig8_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2-8
  prefs: []
  type: TYPE_NORMAL
- en: AWS, launching an instance
  prefs: []
  type: TYPE_NORMAL
- en: In the instance, you will find a link to the security settings. Scroll to the
    right of the screen, or go to the top-left navigation bar, and select Network
    & Security ➤ Security Groups. You will be able to change the security settings.
  prefs: []
  type: TYPE_NORMAL
- en: For HTTP and SSH, you want to open the port to the world (0.0.0.0/0), but SSH
    limits you to your own computer, called My IP. See Figure [2-9](#Fig9).![../images/475651_1_En_2_Chapter/475651_1_En_2_Fig9_HTML.jpg](../images/475651_1_En_2_Chapter/475651_1_En_2_Fig9_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2-9
  prefs: []
  type: TYPE_NORMAL
- en: AWS inbound security rules
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can create an SSH shortcut to access the server via one command, as
    shown here:> mkdir ~/.ssh> vim ~/.ssh/configPaste the following into the config
    file:Host NEOHostName [ip address]User ubuntuIdentityFile /[location of key]/neo.pemConfigure
    these settings with the IP address of the machine and with the location of your
    key. Next set the permissions for the key.> chmod 400 /[location of key]/neo.pemNow,
    you can access your machine with one command, as shown in Figure [2-10](#Fig10).>
    ssh NEO![../images/475651_1_En_2_Chapter/475651_1_En_2_Fig10_HTML.jpg](../images/475651_1_En_2_Chapter/475651_1_En_2_Fig10_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2-10
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to an AWS machine via SSH
  prefs: []
  type: TYPE_NORMAL
- en: If you run into any problems connecting to the machine, use the AWS Troubleshooting
    page, which you can find at [https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/TroubleshootingInstancesConnecting.html#TroubleshootingInstancesConnectingMindTerm](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/TroubleshootingInstancesConnecting.html%2523TroubleshootingInstancesConnectingMindTerm)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Installing Bookkeeping-Node-Deployment on Ubuntu 16.04
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that you have a machine to fit the minimum needs of a full node, you can
    install the software needed. Start by installing dependencies, as shown here:>
    sudo sh -c 'echo "deb [arch=amd64] https://apt-mo.trafficmanager.net/repos/dotnet-release/
    trusty main" > /etc/apt/sources.list.d/dotnetdev.list'> sudo apt-key adv --keyserver
    apt-mo.trafficmanager.net --recv-keys 417A0893> sudo apt-get update> sudo apt-get
    install dotnet-dev-1.0.4It appears that the current installation instructions
    in the NEO docs produce errors during installation, as shown here:Depends:dotnet-sharedframework-microsoft.netcore.app-1.0.4,
    dotnet-sharedframework-microsoft.netcore.app-1.1.1The workaround is to install
    a different dotnet core environment sources list and update; then you will be
    able to install the dotnet-dev-1.0.4 core environment.> sudo sh -c 'echo "deb
    [arch=amd64] https://apt-mo.trafficmanager.net/repos/dotnet-release/ xenial main"
    > /etc/apt/sources.list.d/dotnetdev.list'> sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80
    --recv-keys 417A0893> sudo apt-get updateRemember to change the sources list back
    to the following:> sudo sh -c 'echo "deb [arch=amd64] https://apt-mo.trafficmanager.net/repos/dotnet-release/
    trusty main" > /etc/apt/sources.list.d/dotnetdev.list'Now that the dotnet core
    environment is installed, check whether the dotnet core environment is successfully
    installed with the following command:> mkdir hwapp> cd hwapp> dotnet new xunit
    --framework netcoreapp1.1> dotnet restore hwapp.csproj> dotnet run> cd ..> rm
    -rf hwapp/
  prefs: []
  type: TYPE_NORMAL
- en: Bookkeeping Node Deployment
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that you have the dotnet core environment installed, you can install additional
    dependencies and check out the NEO project.> sudo apt-get install libleveldb-dev
    sqlite3 libsqlite3-dev libunwind8-dev> git clone https://github.com/neo-project/neo-cli>
    git branch -a> git checkout v3.0> git checkout head
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the NEO node, you will need version 1.1.2 of .NET Core. Download the
    SDK binary; for Ubuntu 16.4, the commands are listed here: [https://www.microsoft.com/net/download/linux-package-manager/ubuntu16-04/sdk-2.1.300](https://www.microsoft.com/net/download/linux-package-manager/ubuntu16-04/sdk-2.1.300)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, run the dpkg package manager to install the package:> wget -q https://packages.microsoft.com/config/ubuntu/16.04/packages-microsoft-prod.deb>
    sudo dpkg -i packages-microsoft-prod.debNow you can restore the NEO build and
    compile, as shown here:> dotnet restore> dotnet publish -c ReleaseOnce you compile
    the code, you get the location of the DLLs.neo-cli -> /home/ubuntu/neo-cli/neo-cli/bin/Release/netcoreapp2.0/neo-cli.dll
    .neo-cli -> /home/ubuntu/neo-cli/neo-cli/bin/Release/netcoreapp2.0/publish/Run
    the full node:> dotnet /home/ubuntu/neo-cli/neo-cli/bin/Release/netcoreapp2.0/neo-cli.dll
    .This command opens a terminal command call “neo” with the version.NEO-CLI Version:
    3.0.0.0In the neo terminal, you can query the version to ensure it’s working correctly.neo>
    show stateYou can also create a wallet.neo> create wallet wallet.db3This command
    will request a password.password: [select a password]password: [select a passwrod]Then
    it generates a public key and address for your wallet.address: AXZmWZckF55xb1p566No2qh19uj8vt5d2R pubkey:
    03b80edc66c9324077c8c1c4bbad1e1ace7e1b7e8ac63945a3b5bb9f642f4520f1'
  prefs: []
  type: TYPE_NORMAL
- en: 'You now have a NEO node on an AWS machine, and you are able to interact with
    the NEO command-line interface (CLI). In the next chapters, you will be interacting
    with the CLI. Feel free to get a head start and review the documentation for smart
    contracts and dapp development at the NEO site here: [http://docs.neo.org/en-us/node/cli.html](http://docs.neo.org/en-us/node/cli.html)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Request Consensus Authority Certificate
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that you have a working node on a qualified Ubuntu server, you can obtain
    a consensus authority certificate. The NEO white paper discusses the need to have
    an actual real identity:'
  prefs: []
  type: TYPE_NORMAL
- en: '*“DBFT combines digital identity technology, meaning the bookkeepers can be
    a real name of the individual or institution. Thus, it is possible to freeze,
    revoke, inherit, retrieve, and affect judicial decisions on them. This facilitates
    the registration of compliant financial assets in the NEO network. The NEO network
    plans to support such operations when necessary.”*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'You can obtain CA certificates from OnChain/Neo directly. Additionally, you
    can find more information on the NEO forums: [https://www.reddit.com/r/NEO/](https://www.reddit.com/r/NEO/)
    . This process is beyond the scope of this book, but it’s needed in order to be
    selected as a node.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting Gas
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To be selected as a node, you also need 1,000 gas to stake in order to become
    a bookkeeper. The easiest way to purchase gas is on exchanges. The other option
    is to hold NEO, and you will get 0.33 gas per 1,000\. See Figure [2-11](#Fig11)
    shows a button to claim gas coins once you hold NEO coins.![../images/475651_1_En_2_Chapter/475651_1_En_2_Fig11_HTML.jpg](../images/475651_1_En_2_Chapter/475651_1_En_2_Fig11_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2-11
  prefs: []
  type: TYPE_NORMAL
- en: Neotracker.io provides a Claim Gas option
  prefs: []
  type: TYPE_NORMAL
- en: A simple calculation of prices of NEO and gas at the time of writing shows it’s
    a large investment.
  prefs: []
  type: TYPE_NORMAL
- en: Elected as a Bookkeeper
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'NEO is an electronic democracy, and NEO holders can vote on who should be a
    bookkeeper. At the time of writing, the NEO team has not implemented the voting
    features; however, they are likely to be implemented in the near future as the
    GitHub wiki shows a payment structure with fees, including 10 gas for voting a
    bookkeeper: [https://github.com/neo-project/neo/wiki/Network-Protocol](https://github.com/neo-project/neo/wiki/Network-Protocol)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: For now, stop the EC2 node so you won’t be charged.
  prefs: []
  type: TYPE_NORMAL
- en: To stop the instance, select EC2 Dashboard ➤ Running instances ➤ Actions ➤ Instance
    State ➤ Stop. See Figure [2-12](#Fig12).![../images/475651_1_En_2_Chapter/475651_1_En_2_Fig12_HTML.jpg](../images/475651_1_En_2_Chapter/475651_1_En_2_Fig12_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2-12
  prefs: []
  type: TYPE_NORMAL
- en: AWS, stop instance action
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Amazon can charge storage fees for the EBS volumes attached to a stopped instance.
    The cost is five cents per gigabyte. Amazon provides one year for free. To completely
    avoid being charged, you need to “terminate” the instance instead of just stopping
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make sure you are not charged at this URL: [https://console.aws.amazon.com/billing/home](https://console.aws.amazon.com/billing/home)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Create an EOS Block Producer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You will now learn how to run a full EOS  node on a dedicated server; you just
    need to make sure you meet the minimum hardware requirement. The requirements
    are listed here: [https://developers.eos.io/eosio-nodeos/docs/install-nodeos](https://developers.eos.io/eosio-nodeos/docs/install-nodeos)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the time of writing, the system requirements on all platforms are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 7 GB RAM free required
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 20 GB of available storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will learn how to set up an Ubuntu server. I will be using AWS. In AWS,
    select Ubuntu Server 16.04 LTS (HVM), SSD Volume Type ➤ Choose an Instance Type
    ➤ General purpose ➤ t2.large. This type of machine has 8 GB RAM free.
  prefs: []
  type: TYPE_NORMAL
- en: 'An EOS node needs at least 20 GB of a storage space, so you’ll set this machine
    to 25 GB to be safe. To do that, select Configure Instance Detail. Next select:
    add storage. In the next window select: Size (GiB) 25 GB. The next wizard window
    you will be able to: Review and Launch. Launch the instance.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For security, set the same settings as you did for the NEO full-node server:
    select an existing security group. Next, select: launch-wizard-1 that includes
    port 22 for SSH and public HTTP/HTTPS. Now we can: Review and Launch in the next
    window and lastly, Launch.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the key pairs, use the same key you created for NEO or create a new key.
    To select the same key, select Choose an existing key pair. We will call the key:
    EOS.'
  prefs: []
  type: TYPE_NORMAL
- en: That’s it. You can now update the SSH config file with the new server to be
    able to connect quickly.> vim ~/.ssh/configAnd paste the following:Host EOSHostName
    [ip address]User ubuntuIdentityFile /[location of key]/EOS.pemNow you can connect
    to the EOS server.> ssh EOS
  prefs: []
  type: TYPE_NORMAL
- en: Installing an EOS Full Node
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that you have the Ubuntu server configured with 8 GB of memory and a 25
    GB hard drive, you can clone the project and build.> git clone https://github.com/EOSIO/eos
    --recursive> cd eos> ./eosio_build.sh #takes about 30 mins to an hour.Once the
    build is completed, you will see the screen shown in Figure [2-13](#Fig13).![../images/475651_1_En_2_Chapter/475651_1_En_2_Fig13_HTML.jpg](../images/475651_1_En_2_Chapter/475651_1_En_2_Fig13_HTML.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2-13
  prefs: []
  type: TYPE_NORMAL
- en: EOS full-node build, complete output
  prefs: []
  type: TYPE_NORMAL
- en: 'Ensure that the daemon is working correctly by running the -h flag to get a
    list of commands.> cd build/programs/nodeos> ./nodeos -h #list of commandsNow
    you can run the EOS node daemon; Figure [2-14](#Fig14) shows the output.> ./nodeos
    -e -p eosio --plugin eosio::chain_api_plugin --plugin eosio::history_api_plugin![../images/475651_1_En_2_Chapter/475651_1_En_2_Fig14_HTML.jpg](../images/475651_1_En_2_Chapter/475651_1_En_2_Fig14_HTML.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2-14
  prefs: []
  type: TYPE_NORMAL
- en: EOS full node running
  prefs: []
  type: TYPE_NORMAL
- en: EOS provides a portal at [https://developers.eos.io/](https://developers.eos.io/)
    to get started with nodes, dapps, smart contract, tokens, and much more. In the
    next chapters, you will be interacting more with the EOS platform.
  prefs: []
  type: TYPE_NORMAL
- en: Marketing and Listing
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that you have an EOS node running, you need to create a marketing campaign
    to be elected. You can set the submission profile to be similar to this URL: [https://github.com/consenlabs/eos-bp-profile](https://github.com/consenlabs/eos-bp-profile)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you are ready to receive votes. You can get voting through the imToken
    2.0 app (iPhone or Android). It offers block producers voting; follow this guide
    for instructions: [https://medium.com/imtoken/guide-imtoken-2-0-block-producers-voting-141983f9a76e](https://medium.com/imtoken/guide-imtoken-2-0-block-producers-voting-141983f9a76e)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Terminating an EOS Node
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You want to ensure that you terminate the node so you won’t get charged, as
    this machine configuration is not part of the free tier server on Amazon. Just
    you did before, select EC2 Dashboard ➤ Running instances ➤ Actions ➤ Instance
    State ➤ Terminate.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also want to terminate the 25 GB volume you created. Select Volume from
    the left navigation menu and then select Actions ➤ Detach Volume. Then select
    Delete Volume. See Figure [2-15](#Fig15).![../images/475651_1_En_2_Chapter/475651_1_En_2_Fig15_HTML.jpg](../images/475651_1_En_2_Chapter/475651_1_En_2_Fig15_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2-15
  prefs: []
  type: TYPE_NORMAL
- en: Detaching a volume and deleting a volume
  prefs: []
  type: TYPE_NORMAL
- en: Bitcoin Core API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As a developer, you want to have deep understanding of how a technology works,
    so to better understand blockchain in general and the bitcoin blockchain specifically,
    you will be downloading and installing the bitcoin core code. The full node and
    the bitcoin miner you set up previously on bitcoin core can be compiled from source
    code, or you can use a precompiled executable.
  prefs: []
  type: TYPE_NORMAL
- en: Previously you set up a bitcoin node capable of doing mining on your computer.
    To interact with the bitcoin core API, you need a full node. What is the difference
    between a full node and a miner then?
  prefs: []
  type: TYPE_NORMAL
- en: A full node is a complete copy of the blockchain that is able to verify all
    the transactions that ever occurred on the blockchain since the first block was
    created. This requires 180 GB at the time of writing. However, as you will see,
    you can set the full node not to download the entire ledger. A full node does
    not need to solve any mathematical problem, and hashing is not an issue.
  prefs: []
  type: TYPE_NORMAL
- en: A miner is a node in the network; however, as you have seen, its job is to generate
    blocks by working on transactions and coming up with the best block (or hash)
    to store the information. Miners compete and spend about 10 minutes coming up
    with a solution to the problem. Full nodes keep blocks forever in the database
    and are verified by other nodes. Miners, on the other hand, don’t need to know
    about previous blocks, just the block before, and they focus on hashing. However,
    a bitcoin miner does download the entire 180 GB blockchain ledger.
  prefs: []
  type: TYPE_NORMAL
- en: In the following exercise, you will be installing and configuring a full node
    to be able to connect and interact with the bitcoin core API.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and Configurating a Full Bitcoin Node
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Setting Up Your System**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this exercise, you will set up your environment and then download, configure,
    and start a full working node of bitcoin. This will come in handy as you continue
    to examine how bitcoin and blockchain work. You will be using the bitcoin core
    source code. Bitcoin core code includes docs that give complete instructions for
    installing the code on different OSs. In this book, I am focusing on macOS, so
    I am providing instructions to expedite the installation process for your convenience;
    however, you can install bitcoin core on other platforms. Here is the link for
    the complete instructions for Mac and PC:'
  prefs: []
  type: TYPE_NORMAL
- en: 'macOS install instructions: [https://github.com/bitcoin/bitcoin/blob/master/doc/build-osx.md](https://github.com/bitcoin/bitcoin/blob/master/doc/build-osx.md)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Windows: [https://github.com/bitcoin/bitcoin/blob/master/doc/build-windows.md](https://github.com/bitcoin/bitcoin/blob/master/doc/build-windows.md)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To get started, you need Xcode and the Xcode tools installed, so this would
    be a good time to install these tools if you don’t have them already. To check
    whether Xcode is installed on your computer, open a command-line terminal by clicking
    the Spotlight Search and type **Terminal**.
  prefs: []
  type: TYPE_NORMAL
- en: At the command line, type the following command to check whether you have Xcode
    installed:> xcode-select –vIt should return xcode-select and the version number,
    as shown in Figure [2-16](#Fig16).![../images/475651_1_En_2_Chapter/475651_1_En_2_Fig16_HTML.jpg](../images/475651_1_En_2_Chapter/475651_1_En_2_Fig16_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2-16
  prefs: []
  type: TYPE_NORMAL
- en: Terminal xcode-select version
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t have Xcode installed, you can download it from [https://developer.apple.com/xcode/](https://developer.apple.com/xcode/)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**Note** This installation can take hours, depending on your Internet connection.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have Xcode downloaded, execute the command-line tools for Xcode.>
    xcode-select –installWith command-line tools installed, you can install Homebrew
    and the wget tools by using these commands:> /usr/bin/ruby -e "$(curl –fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)">
    brew install wgetAfter Homebrew and wget are installed, you are able to install
    the rest of the needed dependencies for bitcoin core, as shown here:> brew install
    automake berkeley-db4 libtool boost miniupnpc openssl pkg-config protobuf python
    qt libevent qrencode librsvg
  prefs: []
  type: TYPE_NORMAL
- en: '**Installing Bitcoin Core**'
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point you have the needed tools and dependencies installed, and you
    can clone the bitcoin code project, compile, and run it.> git clone https://github.com/bitcoin/bitcoin.git>
    cd bitcoin/Now, you can build the Berkeley DB version 4, used by the bitcoin core
    node:> ./contrib/install_db4.sh .Continue the installation;> ./autogen.sh> ./configure>
    make> make check && sudo make installBitcoin core code includes two tools: bitcoind
    and bitcoin-CLI.'
  prefs: []
  type: TYPE_NORMAL
- en: '*bitcoind (the bitcoin daemon)*: This implements the bitcoin protocol for remote
    procedure call (RPC) use. Once it’s installed, you can make API calls. There is
    a list of all the API calls here: [https://en.bitcoin.it/wiki/Original_Bitcoin_client/API_Calls_list](https://en.bitcoin.it/wiki/Original_Bitcoin_client/API_Calls_list)
    .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*bitcoin-CLI (the bitcoin command-line interface)*: This enables you to interact
    with the bitcoin core daemon. To ensure the installation went well, you can check
    that the bitcoin daemon and bitcoin-CLI are configured and working as expected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To ensure these tools were installed correctly, you can execute the which command
    on these tools to get the location of them.> which bitcoind> which bitcoin-cliThe
    output returns the location of the bitcoind and bitcoin-cli:/usr/local/bin/bitcoind/usr/local/bin/bitcoin-cli
  prefs: []
  type: TYPE_NORMAL
- en: '**Configuring and Compiling Bitcoin Core**'
  prefs: []
  type: TYPE_NORMAL
- en: Next, you want to configure a node. Each bitcoin core node does not do mining
    but contributes to the bitcoin network and consists of clients, miners, wallets,
    and so on. To configure the node, you can find the configuration files’ location
    by typing the following command in Terminal:> bitcoind -printtoconsoleAfter a
    few seconds, stop this service (Control+C). The command shows the bitcoin.conf
    configuration file location. See Figure [2-17](#Fig17) for the output."> Using
    config file /[path]/.bitcoin/bitcoin.conf"![../images/475651_1_En_2_Chapter/475651_1_En_2_Fig17_HTML.jpg](../images/475651_1_En_2_Chapter/475651_1_En_2_Fig17_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2-17
  prefs: []
  type: TYPE_NORMAL
- en: bitcoin.conf file location
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, a full-index bitcoin core node requires 2 GB RAM and
    at least 180 GB of disk space ( [https://blockchain.info/charts/blocks-size](https://blockchain.info/charts/blocks-size)
    ). Additionally, as the bitcoin nodes send and receive transactions and blocks
    constantly, you will need a fast internet connection.
  prefs: []
  type: TYPE_NORMAL
- en: The full node is advisable for a working project running a miner as you can
    run a dedicated server and interact with the bitcoind via Bitcoin-CLI; however,
    for the purpose of this book, most of the time you won’t need a full node. I recommend
    that you constrain bitcoin node resources usage on your computer so it won’t hog
    your computer’s resources and Internet bandwidth.
  prefs: []
  type: TYPE_NORMAL
- en: 'To limit your node from downloading the entire shared ledger, use vim or your
    favorite editor to edit the bitcoin.conf file.> vim /[path]/.bitcoin/bitcoin.confAfter
    vim opens up bitcoin.conf, paste the following configurations:alertnotify=myemailscript.sh
    "Alert: %s"prune=3000maxconnections=10dbcache=150maxmempool=100maxsendbuffer=500maxreceivebuffer=2000txindex=0Make
    sure you don’t erase the following lines already there:rpcuser=bitcoinrpcrpcpassword=[password]For
    your knowledge, the configuration file holds the following params:'
  prefs: []
  type: TYPE_NORMAL
- en: '***prune***: Utilizing prune, you can limit the disk usage. Set this to 3000.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Maxconnections***: By setting a limited maxconnections value, you are limiting
    the maximum nodes number to ten connections'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***dbcache***: In dbcache, you reduce the size of the UTXO cache from 300 MiB
    to 100 MiB.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Maxsendbuffer and maxreceivebuffer***: You can limit the memory buffer per
    connection to the number you set; for instance, set maxreceivebuffer to 2000 MB.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Txindex***: Set this to 1 to get transaction data for any transaction on
    the blockchain; however, this will use up more disk space.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Running Bitcoin Core Daemon**'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have configured your node, you can start the bitcoin core daemon.
    To run the bitcoind, execute the following command in Terminal:> bitcoind -printtoconsoleThe
    first time running the daemon, it will download the blockchain. This can take
    several hours (depending on your Internet connection). Because you set the parameter
    to print to the console (-printtoconsole), you will be able to watch the process
    as it downloads the entire blockchain. See Figure [2-18](#Fig18).![../images/475651_1_En_2_Chapter/475651_1_En_2_Fig18_HTML.jpg](../images/475651_1_En_2_Chapter/475651_1_En_2_Fig18_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2-18
  prefs: []
  type: TYPE_NORMAL
- en: Bitcoin core daemon (bitcoind)
  prefs: []
  type: TYPE_NORMAL
- en: 'While the process is running, open a second Terminal window to query the bitcoind
    interact with the APIs via the bitcoin-cli. Note: you can call the help feature
    and get help about the available APIs. For instance, to get a list of all available
    APIs, use this:> bitcoin-cli --help # outputs list of command-line options.> bitcoin-cli
    help # outputs list of RPC commands when the daemon is running.> bitcoin-cli help
    getblockhash # get help on specific API, for instance "getblockhash";To be able
    to retrieve the complete information, you would need to run a full node. To run
    a full node in the config file, change txindex=1 in the bitcoin.conf file and
    remove prune=3000. Open bitcoin.conf using your favorite editor.> vim /[path]/.bitcoin/bitcoin.confChange
    the params as follows:txindex=1 # prune=3000 - comment out this lineThis change
    will allow you to run a full node and provide the index information so you can
    review transaction data for any transaction on the blockchain. Now you can start
    the bitcoin core daemon again and tell the daemon to re-index all the data.> bitcoind
    -reindex –printtoconsole'
  prefs: []
  type: TYPE_NORMAL
- en: Once again, this process can take hours; however, as it is downloading the blocks,
    you will be able to interact with the downloaded blocks.
  prefs: []
  type: TYPE_NORMAL
- en: To get the blockchain information, you can query the daemon to show the progress
    of your node. See the expected output in Figure [2-19](#Fig19).> bitcoin-cli getblockchaininfo![../images/475651_1_En_2_Chapter/475651_1_En_2_Fig19_HTML.jpg](../images/475651_1_En_2_Chapter/475651_1_En_2_Fig19_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2-19
  prefs: []
  type: TYPE_NORMAL
- en: Getting blockchain information
  prefs: []
  type: TYPE_NORMAL
- en: This did not complete the full download of the bitcoin node; however, you already
    have 209,513 blocks and 538,726 block headers. The node first downloads the block
    headers of the best chain blocks and then downloads the full blocks.
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you set your environment and downloaded blocks, configured
    them, and started a bitcoin node.
  prefs: []
  type: TYPE_NORMAL
- en: Serialized Blocks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each full node holds the same validated blocks and follows the same rules (consensus
    rules). Each bitcoin block in the chain contains a 1 MB serialized code according
    to the current bitcoin consensus rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'The block header holds encoded information that includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Version
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Previous block header
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Merkle root hash
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: nBits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: nounce
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: txn_count (holds the total number of transactions)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: txns (raw transaction)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This data is being hashed and is part of the proof-of-work algorithm and the
    consensus rules. The Satoshi Nakamoto white paper explains the consensus rules.
  prefs: []
  type: TYPE_NORMAL
- en: '*“They vote with their CPU power, expressing their acceptance of valid blocks
    by working on extending them and rejecting invalid blocks by refusing to work
    on them. Any needed rules and incentives can be enforced with this consensus mechanism.”*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '—*Bitcoin: A Peer-to-Peer Electronic Cash System.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The proof of work (PoW) in bitcoin is based on Adam Back’s Hashcash. Each miner
    is racing to solve the problem; once the problem is solved, the process restarts.
    The problem is a mathematical puzzle known as a *proof-of-work problem* , and
    the reward is given to the first miner who solves the problem. Then the verified
    transactions are stored in the public ledger. You’ll learn more about this in
    the next section. It takes 9.9 minutes to generate about 25 bitcoins. Per the
    Satoshi white paper:'
  prefs: []
  type: TYPE_NORMAL
- en: '*“A block header with no transactions would be about 80 bytes. If we suppose
    blocks are generated every 10 minutes, 80 bytes ∗ 6 ∗ 24 ∗ 365 = 4.2MB per year”*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '—*Bitcoin: A Peer-to-Peer Electronic Cash System.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: At the time of writing, bitcoin processes three transactions per seconds, and
    if the bitcoin transactions increase to four transactions per second, then bitcoin
    will be operating at peak capacity. Ethereum, on the other hand, is running five
    transactions per seconds, and if it goes to eight, that would be peak capacity.
    This design creates a scalability flaw as large corporations need to process hundreds
    of thousands of transactions per seconds not just four to eight per second.
  prefs: []
  type: TYPE_NORMAL
- en: Block Header
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As mentioned, a block is shared between nodes on the bitcoin network. Each
    block header is a serialized 80-byte format. The following information is encoded
    in each block header:'
  prefs: []
  type: TYPE_NORMAL
- en: '***Version***: At the time of writing, there are four block versions. Version
    1 is the genesis block (2009), and version 2 was a soft fork in bitcoin core 0.7.0
    (2012). Version 3 blocks were a soft fork in bitcoin core 0.10.0 (2015). Version
    4 blocks are BIP65 in bitcoin core 0.11.2 (2015).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What is BIP? BIP is a *bitcoin improvement proposal* (BIP). It is a document
    for introducing features or information to bitcoin. BIP is the standard for communicating
    ideas as bitcoin is open source and has no formal structure.
  prefs: []
  type: TYPE_NORMAL
- en: '***Previous block header hash***: This is an SHA256(SHA256()) hash of the previous
    block’s header. This ensures integrity because changing one previous block will
    require changing each previous block.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Merkle root hash***: A Merkle tree is a binary tree that holds all the hashed
    pairs of the tree.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Time***: This is a Unix epoch time when the miner started hashing the header.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***nBits***: nBits is the target section of the block header.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***nonce***: This is an arbitrary number that miners change to modify the header
    hash in order to produce a hash that is less than or equal to the target threshold.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You already downloaded a portion of the blockchain, and you are able to query
    the block height already downloaded.> bitcoin-cli getblockhash 375617The daemon
    returned a string with the block hash of the best block chain at index 375617\.
    You can then request to get the actual block.> bitcoin-cli getblock 00000000000000000f270563d7f2187beec75cdc04f98823572e5a31baf0a261Figure
    [2-20](#Fig20) shows the results. As you can see, the block information includes
    the previousblockhash key and the nextblockhas key. These keys are SHA256(SHA256())
    hash-encrypted keys. The rules ensure blocks cannot be changed. These rules are
    part of the consensus rules that are set to maintain the blockchain security by
    untrusted nodes.![../images/475651_1_En_2_Chapter/475651_1_En_2_Fig20_HTML.jpg](../images/475651_1_En_2_Chapter/475651_1_En_2_Fig20_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2-20
  prefs: []
  type: TYPE_NORMAL
- en: Getting block information
  prefs: []
  type: TYPE_NORMAL
- en: Block Version
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The block version is part of the block header. You can see the block versions
    used in the block. In Figure [2-20](#Fig20) you can see that only version 1 is
    used for block 00000000000000000f270563d7f2187beec75cdc04f98823572e5a31baf0a261.
  prefs: []
  type: TYPE_NORMAL
- en: The consensus mechanism can only be changed by the bitcoin open source development
    team, which published instructions on how to handle upgrades suggestions. The
    BIP that introduced the upgrade method to handle the path for versioned transactions
    and blocks was used in versions 2, 3, and 4.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function added to bitcoin core manages the soft forking. You can learn
    more about this BIP feature here: [https://github.com/bitcoin/bips/blob/master/bip-0034.mediawiki](https://github.com/bitcoin/bips/blob/master/bip-0034.mediawiki)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Merkle Trees
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You called to retrieve the block information and received a Merkle root hash
    key. A Merkle tree is a binary tree. The root node of the Merkle tree holds all
    the hashed pairs of the tree. To help visualize this process, look at the following
    simple ASCII example of a binary list of a hashed tree:*Transactions list: H(A)->H(B)->H(C)->H(D)*            *Hash(A|B|C|D)*         */               \*     *Hash(A|B)         Hash(C|D)*        */
    \          /         \* *Hash(A)  Hash(B)  Hash(C)   Hash(D)*The block headers
    included in this Merkle root are a representation of the descendants of all the
    transactions in that block. HASH(A|B|C|D) is the Merkle root. Each element A,
    B, C, and D would be a hash of all the transactions in that block. In our example
    we have only one transaction in each block.*Merkle Root: H(A)*         */*     *Hash(A)*'
  prefs: []
  type: TYPE_NORMAL
- en: Target nBits
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The block header includes nBits*.* nBits is the target section of the block
    header. nBits is a 32-bit compact encoding of the 256-bit target threshold. It
    works like scientific notation but uses base-256 instead of base-10\. Every 2,016-block
    bitcoin core re-target point and adjusts nBits according to bitcoin difficulty
    rules. Bitcoin difficulty increases or decreases depending on whether it took
    less time or more time than two weeks to find 2,016 blocks. In other words, the
    difficulty will increase if the hash rate increases or decrease if the network
    hash rate decreases.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, to convert an nBits 0x181b8330 into the target threshold, you
    would calculate it using the same shorthand you use with regular scientific notation;
    see Figure [2-21](#Fig21).![../images/475651_1_En_2_Chapter/475651_1_En_2_Fig21_HTML.jpg](../images/475651_1_En_2_Chapter/475651_1_En_2_Fig21_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2-21
  prefs: []
  type: TYPE_NORMAL
- en: Calculating nBits. Photo credit. stackexchange.com.
  prefs: []
  type: TYPE_NORMAL
- en: Convert 0x1bc3300000000000000000000000000000000000000000000 to nBits of 0x181b8330\.
    That will be our target threshold.
  prefs: []
  type: TYPE_NORMAL
- en: txn_count
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The txn_count parameter  represents the total number of transactions in a given
    block including the coinbase transaction.
  prefs: []
  type: TYPE_NORMAL
- en: Coinbase is a special field used as an input for coinbase transactions. The
    coinbase allows you to claim the block reward and provides up to 100 bytes for
    arbitrary data.
  prefs: []
  type: TYPE_NORMAL
- en: Each block contains transactions, and the first transaction in a block is created
    by a miner; it includes a single coinbase.
  prefs: []
  type: TYPE_NORMAL
- en: Block Reward
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Bitcoin miners claim the reward for creating a block. The reward is the sum
    of block subsidies plus the transaction fees paid by transactions included in
    the block.
  prefs: []
  type: TYPE_NORMAL
- en: A block subsidy is the newly available satoshis reward. It started at 50 bitcoins
    and is being halved every 210,000 blocks, approximately once every four years.
    At the time of writing, it’s about 12.5 bitcoins. Eighty percent of the block
    subsidy has already been paid, and only 4.2 million bitcoins are left to mine
    until the 21 million supply cap is reached. At that point, the miners will receive
    a reward of only transaction fees.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned, each block contains transactions, and the first transaction in
    a block is created by a miner; it includes a single coinbase, the reward.
  prefs: []
  type: TYPE_NORMAL
- en: 'txns: Decode a Transaction'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: txns is the raw transaction in the block. To better understand this process,
    let’s work with an actual transaction. Bitcoin transactions that are stored in
    the blockchain ledger are broadcast between different peers in serialized byte
    format (raw format or raw transaction). To decode the SHA256 raw transaction,
    you can call the bitcoin client and utilize the different APIs.
  prefs: []
  type: TYPE_NORMAL
- en: To start, you can retrieve a block you would like to work with. The daemon you
    are running lists the blocks as the new best, as shown in Figure [2-22](#Fig22).![../images/475651_1_En_2_Chapter/475651_1_En_2_Fig22_HTML.jpg](../images/475651_1_En_2_Chapter/475651_1_En_2_Fig22_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2-22
  prefs: []
  type: TYPE_NORMAL
- en: Bitcoin daemon printing to console result
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, you are able to find the new best block by looking at the output
    of the bitcoin daemon. In this case, you choose the hash 000000000000ea2ca199cafd1362ece59d7c6f3867b5e0d6f20c12af6752fb48.
  prefs: []
  type: TYPE_NORMAL
- en: The best block chain is the block selected that is the hardest chain to re-create.
    Remember, in a chain of blocks, each block refers to the block that came before
    it; that’s how you have a blockchain that creates the security and prevents the
    double spending.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have the new best block, you can retrieve the hash data of that
    block.> bitcoin-cli getblock 000000000000ea2ca199cafd1362ece59d7c6f3867b5e0d6f20c12af6752fb48The
    getblock command  returns to a coded SHA256 hash data about the block you requested
    (Figure [2-23](#Fig23)).![../images/475651_1_En_2_Chapter/475651_1_En_2_Fig23_HTML.jpg](../images/475651_1_En_2_Chapter/475651_1_En_2_Fig23_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2-23
  prefs: []
  type: TYPE_NORMAL
- en: getblock retrieving block information
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s examine the result of the getblock call. You got a Merkle root as a hash
    as well as hash tx of all the transactions in that block."tx": [  "a73226fc261f95db14eba45cd734aeb0b8784911aeb24f301f94858a09184036",  Transaction
    hash 02,  Transaction hash 03, and so on...]'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, there are multiple tx (transactions) in the array of this block.
    You can now request to retrieve the raw transaction data of each transaction (tx).
  prefs: []
  type: TYPE_NORMAL
- en: The getrawtransaction command will return the raw data.> bitcoin-cli getrawtransaction
    a73226fc261f95db14eba45cd734aeb0b8784911aeb24f301f94858a09184036Here is the raw
    transaction SHA256 data:01000000010000000000000000000000000000000000000000000000000000000000000000ffffffff070439f3001b0141ffffffff0100f2052a01000000434104b5a750a0ca4bb5a47b6f169b8a8f42b39e2dbb7967d046f1bf018d927d102c280f1123ebfd973f6e651f2e5ff4486e18a90cc67d6d17ccdb95cd6bf028d791cfac00000000You
    can now decode the SHA256 raw transaction data with the decoderawtransaction command.>
    bitcoin-cli decoderawtransaction 01000000010000000000000000000000000000000000000000000000000000000000000000ffffffff070439f3001b0141ffffffff0100f2052a01000000434104b5a750a0ca4bb5a47b6f169b8a8f42b39e2dbb7967d046f1bf018d927d102c280f1123ebfd973f6e651f2e5ff4486e18a90cc67d6d17ccdb95cd6bf028d791cfac00000000The
    command returns the transaction result in a readable format, as shown in Figure
    [2-24](#Fig24).![../images/475651_1_En_2_Chapter/475651_1_En_2_Fig24_HTML.jpg](../images/475651_1_En_2_Chapter/475651_1_En_2_Fig24_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2-24
  prefs: []
  type: TYPE_NORMAL
- en: Decode transaction utilizing the decoderawtransaction command
  prefs: []
  type: TYPE_NORMAL
- en: Bitcoin Wallet
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you saw in Figure [2-24](#Fig24), the wallet address is 1Mr2G632PfQuq4uJXRBNWLoRKH71Qwor51,
    and the value is 50 coins.
  prefs: []
  type: TYPE_NORMAL
- en: You can also confirm the transactions of this wallet online by visiting services
    that contain a full node and checking the wallet’s balance. Figure [2-25](#Fig25)
    shows a screenshot from [https://bitref.com/1Mr2G632PfQuq4uJXRBNWLoRKH71Qwor51](https://bitref.com/1Mr2G632PfQuq4uJXRBNWLoRKH71Qwor51)
    .![../images/475651_1_En_2_Chapter/475651_1_En_2_Fig25_HTML.jpg](../images/475651_1_En_2_Chapter/475651_1_En_2_Fig25_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2-25
  prefs: []
  type: TYPE_NORMAL
- en: 1Mr2G632PfQuq4uJXRBNWLoRKH71Qwor51 wallet balance
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, you can query your wallet’s available funds via the CLI:> bitcoin-cli
    getbalance 1Mr2G632PfQuq4uJXRBNWLoRKH71Qwor51
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapters, I will be covering wallets, so I will explain in more
    detail the wallet’s operations, but for now, you can see that the user purchased
    50 coins in 2003 and sold them in 2012\. Notice that although you do not know
    the identity of the person who owns the wallet, you are able to view the wallet’s
    current balance as this is public information.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you learned how to run a blockchain node that can help manage
    a blockchain. For bitcoin, you created a node called a *miner*. For NEO, you created
    a node that has management rights called a b*ookkeeping node*, and for EOS you
    created a *block producer*. You also explored what you need to do to have your
    node elected or running so it is profitable.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you installed a full bitcoin node that is capable of running the bitcoin
    core API. You installed and configured your node and learned how to run the bitcoin
    core demon. You then interacted with the bitcoin core API and were able to learn
    how to serialize blocks and understand better the data inside each block.
  prefs: []
  type: TYPE_NORMAL
- en: I covered block rewards, transactions, and the bitcoin wallet. In the next chapter,
    you will be building your very own blockchain P2P network to get a much deeper
    understanding of how a blockchain works.
  prefs: []
  type: TYPE_NORMAL
