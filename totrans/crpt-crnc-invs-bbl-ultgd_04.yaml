- en: Chapter 4\. Blockchain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we get into any of the technical details behind Blockchain technology,
    it’s important to understand the problems that Blockchain solves. Why do we need
    Blockchain, and what does it do that our current technology can’t do?
  prefs: []
  type: TYPE_NORMAL
- en: The early adopters of Bitcoin and Blockchain technology spotted what they perceived
    as a fundamental flaw in the way we think about transactions, trust, and social
    institutions. The earliest versions of Blockchain came right around the same time
    as the 2007 financial crisis in the United States, when many people lost faith
    in societal institutions that were supposed to protect the interests of the common
    man. Of course, people were disillusioned by the banking system in the wake of
    the crisis, but they also lost faith in the government to regulate financial markets
    and in the press to investigate potential crises.
  prefs: []
  type: TYPE_NORMAL
- en: Most people would agree that our institutions have flaws and aren’t perfect
    solutions. But they do solve problems of trust, and they’ve been doing it for
    hundreds of years. In fact, we’re probably living in the most peaceful, comfortable
    era in human history. Any alternative to our current institutions needs to have
    clear advantages and strengths.
  prefs: []
  type: TYPE_NORMAL
- en: The idea behind Blockchain is to replace institutions run by imperfect human
    beings with technology that can do the job better and also empowers individuals.
    If you could create a way for strangers to trust one another without needing a
    bank or a government as an intermediary, you’d tackle one of society’s biggest
    bottlenecks. But in order to do so, you’d need a powerful system for creating
    consensus between strangers, and the creators of Blockchain believe that power
    lies in decentralization.
  prefs: []
  type: TYPE_NORMAL
- en: Basically all applications of Blockchain (and other cryptographic technologies)
    are based around the concept of decentralization. Instead of a rigid, slow central
    authority making decisions and governing relationships, Blockchain seeks to return
    regulatory power back to the individuals. Instead of trusting a major institution,
    Blockchain builds trust through consensus.
  prefs: []
  type: TYPE_NORMAL
- en: How Does the Blockchain Work?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In simplest terms, Blockchain uses a combination of cryptography and a public
    ledger to create trust between parties while maintaining privacy. Understanding
    the mechanics of how this works is a little bit more difficult, but in order to
    fully appreciate the genius behind Blockchain technology, we’ll need to dive into
    the technical details.
  prefs: []
  type: TYPE_NORMAL
- en: 'While Blockchain can include many more features, the fundamentals of a Blockchain
    are in the technology’s name:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The block: a block is a list of transactions from a certain time period. It
    contains all the information processed on the network within the past few minutes.
    The network only creates one block at a time.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The chain: each block is linked to the block before it using cryptographic
    algorithms. These algorithms are difficult for computers to calculate and often
    take several minutes for the fastest computers in the world to solve. Once solved,
    the cryptographic chain locks the block into place, making it difficult to change.
    We’ll look at this in greater depth in just a minute.'
  prefs: []
  type: TYPE_NORMAL
- en: The chain grows longer over time. Once a new block is created, the computers
    on the network work together to verify the transactions in the block and secure
    that block’s place in the chain.
  prefs: []
  type: TYPE_NORMAL
- en: The most fundamental part of the Blockchain is the ledger. It’s where information
    about the accounts on the network is stored. The ledger inside the Blockchain
    is what replaces the ledger at a bank or other institution. For a cryptocurrency,
    this ledger usually consists of account numbers, transactions, and balances. When
    you submit a transaction to the Blockchain, you’re adding information to the ledger
    about where currency is coming from and going to.
  prefs: []
  type: TYPE_NORMAL
- en: A Blockchain ledger is distributed across the network. Every node on the network
    keeps its own copy of the ledger and updates it when someone submits a new transaction.
    This “shared ledger” is how Blockchain intends to replace banks and other institutions.
    Instead of having the bank keep one official copy of the ledger, everyone will
    keep their own copy of the ledger and then we’ll verify transactions by consensus.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each Blockchain technology has its own ledger, and the various ledgers work
    very differently (as we’ll see). However the Bitcoin ledger, the first Blockchain
    ledger, requires three pieces of information to list a transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: 'An input: if John wants to send David a Bitcoin, he needs to tell the network
    where he got that Bitcoin in the first place. Maybe John received the Bitcoin
    yesterday from Sarah, so the first part of the ledger entry says so.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'An amount: this is how much John wants to send to David.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'An output: this is David’s Bitcoin address and where the Bitcoin should be
    deposited'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now comes the concept that’s difficult to grasp: there is no such thing as
    a Bitcoin. Of course, there are no physical Bitcoins. You probably already knew
    that. However, there are also no Bitcoins on a hard drive somewhere. You can’t
    point to a physical object, digital file, or piece of code and say, “this is a
    Bitcoin.” Instead, the entire Bitcoin network is only a series of transaction
    records. Every transaction in the history of Bitcoin lives in the Bitcoin Blockchain’s
    distributed ledger. If you want to prove that you have 20 Bitcoins, the only way
    you can do it is by pointing to the transactions where you received those 20 Bitcoins.'
  prefs: []
  type: TYPE_NORMAL
- en: Almost all Blockchain have this characteristic in common. The transaction history
    is the currency. There’s no difference between the two. Some new cryptocurrencies
    are altering the way the ledger is written in order to provide greater anonymity
    and privacy in transactions. They use certain identity masking techniques to hide
    the sender and receiver of the transaction while still maintaining a functional
    distributed ledger.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Block
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The ledger is the core of the block, but it’s not the only thing that goes into
    a newly created block. There is a header and a footer required for every block.
    Additionally, the transactions included in the block are put through a process
    that compresses, encodes, and standardizes them. When a verifier creates a new
    block, it looks completely different from the ledger it was based off of. However,
    the underlying ledger is still there and can be accessed in the future when new
    transactions require information about the previous blocks.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Transactions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first step in building a block is gathering and adding all the current transactions
    to the block’s ledger. When a user creates a new transaction, they broadcast that
    transaction to the entire network. Then a verifier’s computer will review the
    transaction to make sure it’s valid.
  prefs: []
  type: TYPE_NORMAL
- en: Since Blockchain currencies are nothing more than a series of transactions,
    the first step to verify a transaction is to look at where the sender says they
    originally got their money. The verifier will then review the history of the Blockchain
    to find the block and transaction where the sender received the money. If that
    input transaction is confirmed on the Blockchain, then the transaction is valid,
    and they will need to confirm the receiving party’s address. If the input transaction
    hasn’t been confirmed, then the current transaction is invalid, and it won’t be
    included in the ledger.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once all the transactions in that block have been verified, it’s time to create
    the ledger. Here’s a simple example, where the transactions are listed one right
    after another:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Input][Amount][Output address], [Input][Amount][Output address], [Input][Amount][Output
    address], [Input][Amount][Output address], [Input][Amount][Output address]...'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then the verifier will apply a cryptographic technique called hashing to each
    of the transactions. At its most basic definition, hashing takes a string of characters
    and generates another string of characters. So, when you feed the input, amount,
    and output address to a hashing algorithm, it will turn the transaction into a
    string of characters unique to that transaction, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: aba128d3931e54ce63a69d8c2c1c705ea9f39ca950df13655d92db662515eacf
  prefs: []
  type: TYPE_NORMAL
- en: (This is an actual transaction hash from the Bitcoin Blockchain.)
  prefs: []
  type: TYPE_NORMAL
- en: So hashing is used to standardize data while making sure that it hasn’t been
    tampered with. If someone were to try to change a transaction in the Blockchain,
    they’d have to rehash that transaction, and it would look entirely different.
    It would be obvious that it had been tampered with.
  prefs: []
  type: TYPE_NORMAL
- en: To make it even more difficult to tamper with the blockchain and reduce memory
    required to store the transaction ledger, most blockchains hash more than once.
    This means that they take the hash of a transaction, combine it with a hash of
    another transaction, and re-hash that into a new smaller hash. Combining transactions
    in this way is known as a Merkle Tree, and the root hash of all the transactions
    is included at the beginning of the block. Understanding why we need a Merkle
    Tree is a topic for a more in-depth book, but on a basic level, the Merkle Tree
    shows that all the transactions in the block are valid while using less memory
    in the long run.
  prefs: []
  type: TYPE_NORMAL
- en: Time Stamp & Block ID
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The final element in a block is the time stamp and any block ID information.
    This makes it easy to look up previous blocks later on. Future transactions will
    also be able to point to this block ID as the block containing the input transaction
    (also known as the “coinbase”) for the current transaction.
  prefs: []
  type: TYPE_NORMAL
- en: Linking Blocks Together
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The final step of creating a block is linking it to the previous blocks in the
    chain. There are a few ways to do this, but virtually all of them involve hashing
    in some way to make the content of the previous block part of the new block.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that hashing takes an input, no matter how big or small, and turning
    it into a string of characters. If you change the input even slightly, the entire
    output gets changed. In order to include the previous block’s contents in the
    new block, we can take the hash of the entire previous block and add that to the
    beginning of the next block. Doing so means that we’ve effectively linked the
    old block to the new block, because if anything changes in the older block, even
    the tiniest change, the entire block’s hash will change.
  prefs: []
  type: TYPE_NORMAL
- en: Now, once a block has been completed, it becomes MUCH harder to change it. Making
    an edit to an older block means you’d have to re-hash that entire block. Once
    you re-hash all of block 1, you’d have to crack open block 2, delete block 1’s
    old hash, insert block 1’s new hash, and now re-hash all of block 2\. But new
    blocks are being created all the time, so in order to change an older transaction,
    you’d have to edit every block after that transaction took place. The more time
    that goes by, the harder it becomes to hack the network and successfully change
    a transaction. This is why hashing is at the core of Blockchain security. The
    cryptography makes the transaction ledger difficult to change, meaning the ledger
    can be public and secure at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: However, the hashing itself is not that difficult. Most computers could easily
    re-hash a Blockchain in a few seconds. So in order to guarantee the hashing security
    does its job, we need to introduce a level of difficulty to the creation of a
    new block. Ideally, it would be something that slows an attacker down and makes
    it more likely that honest members of the network will win. In the Bitcoin Blockchain
    (and most other modern blockchains), that added difficulty is called “proof of
    work.”
  prefs: []
  type: TYPE_NORMAL
- en: I won’t explain proof of work here, a basic explanation of proof of work I covered
    in chapter 3 of this book or learn the in-depth details behind this technology
    in my book “[Blockchain Technology Explained](https://www.amazon.com/Blockchain-Technology-Explained-Beginners-Contracts-ebook/dp/B0785WDHS3/ref=sr_1_5?ie=UTF8&qid=1513029050&sr=8-5&keywords=blockchain)”.
  prefs: []
  type: TYPE_NORMAL
