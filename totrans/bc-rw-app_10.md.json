["```\npragma solidity ^0.7.0 || ^0.8.0;\nimport \"./IERC3156FlashBorrower.sol\";\n\ninterface IERC3156FlashLender {\n\n   function maxFlashLoan(\n      address token\n   ) external view returns (uint256);\n\n   function flashFee(\n      address token,\n      uint256 amount\n   ) external view returns (uint256);\n\n   function flashLoan(\n      IERC3156FlashBorrower receiver,\n      address token,\n      uint256 amount,\n      bytes calldata data\n   ) external returns (bool);\n\n```", "```\npragma solidity ^0.7.0 || ^0.8.0;`\n\ninterface IERC3156FlashBorrower {\n\n  function onFlashLoan(\n      address initiator,\n      address token,\n      uint256 amount,\n      uint256 fee,\n      bytes calldata data\n  ) external returns (bytes32);\n}\n\n```", "```\npragma solidity ^0.8.0;\n\n//interfaces discussed above\nimport \"./IERC3156FlashBorrower.sol\";\nimport \"./IERC3156FlashLender.sol\";\n\ninterface IERC20 {\n  function totalSupply() external view returns (uint256);\n  function balanceOf(address account) external view returns (uint256);\n  function transfer(address recipient, uint256 amount) external returns (bool);\n  function allowance(address owner, address spender) external view returns (uint256);\n  function approve(address spender, uint256 amount)\n  external returns (bool);\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n }\n\n//borrower implementation\ncontract FlashBorrower is IERC3156FlashBorrower {\n  enum Action {NORMAL, OTHER}\n  IERC3156FlashLender lender;\n  constructor (IERC3156FlashLender lender_) {\n    lender = lender_;\n  }\n\n  // @dev ERC-3156 Flash loan callback\n  function onFlashLoan(address initiator, address token, uint256 amount, uint256 fee, bytes calldata data) external override returns(bool) {\n       require(msg.sender == address(lender),\n\"FlashBorrower: Untrusted lender\"); \n      require(initiator == address(this),\n  \"FlashBorrower: Untrusted loan initiator\");\n(Action action) = abi.decode(data, (Action)); \n      return keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n  }\n\n  /// @dev Initiate a flash loan\n  function flashBorrow(address token, uint256 amount)\npublic {\nbytes memory data = abi.encode(Action.NORMAL); \n        uint256 _allowance = IERC20(token).\nallowance(address(this), address(lender));\n        uint256 _fee = lender.flashFee(token, amount);\nuint256 _repayment = amount + _fee; \n        IERC20(token).approve(address(lender), _allowance + _repayment);\n        lender.flashLoan(this, token, amount, data);\n      }\n}\n\n //Lender implementation\n contract FlashLender is IERC3156FlashLender {\nbytes32 public constant CALLBACK_SUCCESS = \nkeccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n    mapping(address => bool) public supportedTokens;\nuint256 public fee; // 1 == 0.0001 %. \n\n    constructor(address[] memory supportedTokens_, uint256 fee_)\n      {\n        for (uint256 i = 0; i < supportedTokens_.length; i++)\n        {\n            supportedTokens[supportedTokens_[i]] = true;\n         }\n         fee = fee_;\n} \nfunction flashLoan(IERC3156FlashBorrower receiver, \naddress token, uint256 amount, bytes calldata data)\nexternal override returns(bool) { \n      require(supportedTokens[token], \"FlashLender: Unsupported currency\");\n      uint256 fee = _flashFee(token, amount);\nrequire(IERC20(token).transfer(address(receiver), amount),\"FlashLender: Transfer failed\"); \nrequire(receiver.onFlashLoan(msg.sender, token, amount, fee, data) == CALLBACK_SUCCESS,\"FlashLender: Callback failed\"); \n      require(IERC20(token).transferFrom(address(receiver), address(this), amount + fee),\"FlashLender: Repay failed\");\n      return true;\n    }\n\n      function flashFee(address token, uint256 amount)\nexternal view override returns (uint256) { \n      require(supportedTokens[token],\"FlashLender: Unsupported currency\");\n      return _flashFee(token, amount);\n    }\n\n    function _flashFee(address token,uint256 amount) internal view returns (uint256) {\n    return amount * fee / 10000;\n    }\n\n    function maxFlashLoan(address token) external view override returns (uint256) {\n    return supportedTokens[token] ? IERC20(token).balanceOf(address(this)) : 0;\n    }\n}\n\n```", "```\npragma solidity ^0.4.17;\ncontract Auction {\n\n// Data\n//Structure to hold details of the item\n   struct Item {\n     uint itemId; // id of the item\n     uint[] itemTokens; //tokens bid in favor of the item\n   }\n\n//Structure to hold the details of a persons\n   struct Person {\n     uint remainingTokens; // tokens remaining with bidder uint personId; // it serves as tokenId as well address addr;//address of the bidder\n   }\n\n   mapping(address => Person) tokenDetails; //address to person\n   Person [4] bidders;//Array containing 4 person objects\n\n   Item [3] public items;//Array containing 3 item objects\n   address[3] public winners;//Array for address of winners\n   address public beneficiary;//owner of the smart contract\n\n   uint bidderCount=0;//counter\n\n   //functions\n\nfunction Auction() public payable{ //constructor \n\n    //Task 1\\. Initialize beneficiary with address of smart contract’s owner\n    //constructor,\"msg.sender\" is the address of the owner.\n// ** Start code here. 1 line approximately. **/ \n   beneficiary = msg.sender;\n    //** End code here. **/\n    uint[] memory emptyArray;\n    items[0] = Item({itemId:0,itemTokens:emptyArray});\n\n    //Task 2\\. Initialize two items with at index 1 and 2.\n// ** Start code here. 2 lines approximately. **/ \nitems[1] = Item({itemId:1,itemTokens:emptyArray}); \n    items[2] = Item({itemId:2,itemTokens:emptyArray});\n    //** End code here**/\n}\nfunction register() public payable{ \n\n   bidders[bidderCount].personId = bidderCount;\n\n//Task 3\\. Initialize the address of the bidder \n    /the bidders[bidderCount].addr be initialized with address of the registrant.*/\n\n    // ** Start code here. 1 line approximately. **/\n    bidders[bidderCount].addr = msg.sender;\n//** End code here. ** \n\n    bidders[bidderCount].remainingTokens = 5; //\nonly 5 tokens \ntokenDetails[msg.sender]=bidders[bidderCount]; \n    bidderCount++;\n}\nfunction bid(uint _itemId, uint _count) public payable{\n   /*\n    Bids tokens to a particular item.\n    Arguments:\n    _itemId -- uint, id of the item\n    _count -- uint, count of tokens to bid for the item\n   */\n   /*\n    Task 4\\. Implement the conditions below.\n     4.1 If the number of tokens remaining with the bidder is < count of tokens bidded, revert.\n     4.2 If there are no tokens remaining with the bidder, revert.\n     4.3 If the id of the item for which bid is placed, is greater than 2, revert. \"tokenDetails[msg.sender].remainingTokens\" gives the details of the number of tokens remaining with the bidder.\n   */\n\n    // ** Start code here. 2 lines approximately. **/\n    if (tokenDetails[msg.sender].remainingTokens<_count || tokenDetails[msg.sender].remainingTokens == 0 || _itemId > 2) revert();\n\n//** End code here. ** /*\n\n   Task 5\\. Decrement the remainingTokens by the number of tokens bid and store the value in balance variable.\n\"tokenDetails[msg.sender].remainingTokens\" should be decremented by \"_count\". */ \n// ** Start code here. 1 line approximately. ** uint balance=tokenDetails[msg.sender].remainingTokens - _count;\n//** End code here. ** \n\n   tokenDetails[msg.sender].remainingTokens=balance;\nbidders[tokenDetails[msg.sender].personId].remainingTokens=balance;//updating the same balance in bidders map. \n\n   Item storage bidItem = items[_itemId];\n   for(uint i=0; i<_count;i++) {\n    bidItem.\n    itemTokens.push(tokenDetails[msg.sender].personId);\n  }\n}\n   // Task 6\\. Create a modifier named \"onlyOwner\" to ensure that only owner is allowed to reveal winners\n // Use require to validate if \"msg.sender\" is equal to the \"beneficiary\".\n  modifier onlyOwner {\n   // ** Start code here. 2 lines approximately. ** require(msg.sender == beneficiary);\n   _;\n   //** End code here. **\n  }\n\nfunction revealWinners() public onlyOwner{\n\n   /*\nIterate over all the items present in the auction. \n    If at least on person has placed a bid, randomly select the winner */\n\n   for (uint id = 0; id < 3; id++) {\nItem storage currentItem=items[id]; \n     if(currentItem. itemTokens.length != 0){\n     // generate random# from block number\n     uint randomIndex = (block.number / currentItem. itemTokens.length)% currentItem. itemTokens.length;\n\n     // Obtain the winning tokenId\n     uint winnerId = currentItem. itemTokens[randomIndex];\n\n   /* Task 7\\. Assign the winners.\n   \" bidders[winnerId] \" will give the person object with the winnerId.\n   you need to assign the address of the person obtained above to winners[id] */\n\n// ** Start coding here *** 1 line approximately. \n   winners[id] = bidders[winnerId].addr;\n   //** end code here*\n   }\n  }\n}\nassist:\n    function getPersonDetails(uint id) public constant returns(uint,uint,address){\n   return (bidders[id].remainingTokens,bidders[id].personId,bidders[id].addr);\n  }\n}\n\n```", "```\nlet Auction = artifacts.require(\"./Auction.sol\");\n\nlet auctionInstance;\n\ncontract('AuctionContract', function (accounts) {\n   //accounts[0] is the default account\n   //Test case 1\n   it(\"Contract deployment\", function() {\n    //Fetching the contract instance of our smart contract\n   return Auction.deployed().then(function (instance) {\n    //We save the instance in a gDlobal variable and all smart contract functions are called using this auctionInstance = instance;\n    assert(auctionInstance !== undefined, 'Auction contract should be defined');\n    });\n});\n\n//Test Case\nit(\"Should set bidders\", function() { \n    return auctionInstance.register({from:accounts[1]}).then(function(result) {\n     return auctionInstance.getPersonDetails(0); }).then(function(result) {\n    assert.equal(result[2], accounts[1], 'bidder address set');\n   })\n });\n\n   //Test Case for checking if the bid is more than the token amount\n   it(\"Should NOT allow to bid more than remaining tokens\", function() {\n    /**********\n    Task 1: Call bid method from accounts[1] of Auction.sol using auctionInstance and\n    pass itemId=0, count=6 as arguments\n    To make a function call from account 1 use {from: accounts[1]} as an extra argument ***********/\n    return auctionInstance.bid(0,6,{from:accounts[1]}) .then(function (result) {\n    /*\nThis is to test for a negative condition and hence this particular block will not have executed if test case was correct. If this part is executed then throw an error and catch the error to assert false \n    */\n    throw(\"Failed to check remaining tokens less than count\");\n   }).catch(function (e) {\n   var a = e.toString();\n   if(e === \"Failed to check remaining tokens less than count\") {\n   /**********\n   Task 2: An error that has been intentionally thrown. Should you assert true or false?\n   Use assert(false) to assert false\n     Use assert(true) to assert true\n   ***********/\n   assert(false);\n   } else {\n    /**********\n     Task 3: assert the opposite here\n     ***********/ assert(true);\n    }\n   })\n});\nit(\"Should NOT allow non owner to reveal winners\", function() {\n/********** \nTask 4: Call revealWinners from account 1 \n    ***********/\nreturn auctionInstance.revealWinners({from:accounts[1]}) \n    .then(function (instance) {\n    /*\n    This is to test for a negative condition and hence this particular block will not have executed if the test case was correct. If this part is executed then throw an error and catch the error to assert false\n    */\n    throw(\"Failed to check owner in reveal winners\"); }).catch(function (e) {\n    if(e === \"Failed to check owner in reveal winners\") {\n/********** \n    Task 5: It's an intentionally thrown error.Should you assert true or false?\n    Use assert(false) to assert false\n    Use assert(true) to assert true\n    ***********/\n    assert(false);\n   } else\n     { /**********\n     Task 6: assert the opposite here\n     ***********/\n     assert(true);\n    }\n   })\n})\n    it(\"Should set winners\", function() {\n    /**********\nTask 7: Call register function from account 2 \n   ***********/\n    return auctionInstance.register({from:accounts[2]}) .then(function(result) {\n   /**********\n   Task 8: Call register function from account 3 ***********/\n    return auctionInstance.register({from:accounts[3]}) }).then(function() {\n   /**********\n   Task 9: Call register function from account 4 ***********/\n    return auctionInstance.register({from:accounts[4]}) }).then(function() {\n   /********** Task 10: Call bid method from accounts[2] of Auction.sol using auctionInstance and pass itemId=0, count=5 as arguments\n   ***********/\n    return auctionInstance.bid(0,5,{from:accounts[2]}) }).then(function() {\n   /**********\nTask 11: Call bid method from accounts[3] of Auction.sol using auctionInstance and pass itemId=1, count=5 as arguments \n   ***********/ return auctionInstance.bid(itemId=1,count=5,{from:accounts[3]}) }).then(function() { /********** Task 12: Call bid method from accounts[4] of Auction.sol using auctionInstance and pass itemId=2, count=5 as arguments\n    ***********/\n    return auctionInstance.bid(itemId=2,count=5,{from:accounts[4]})\n   }).then(function() {\n   /**********\n   Task 13: Call revealWinners function from accounts[0]\n   ***********/\nreturn auctionInstance.revealWinners({from:accounts[0]}) \n   }).then(function() {\n   /**********\n   Task 14: call winners function from accounts[0] to get the winner of item id 0\n   ***********/\n    return auctionInstance.winners(0,{from:accounts[0]}) }).then(function(result) {\n   /**********\n   Task 15: assert to see if the winner address is not the default address Default address is '0x0000000000000000000000000000000000000000' Use notEqual method of assert Parameters for notEqual : (result, default address , message);\n   ***********/\n     assert.notEqual(result, '0x0000000000000000000000000000000000000000', '')\n\n   /**********\n   Task 16: call winners function from accounts[0] to get the winner of item id 1\n   ***********/\n     return auctionInstance.winners(1,{from:accounts[0]}) }).then(function(result) {\n   /**********\n   Task 17: assert to see if the winner address is not the default address Default address is '0x0000000000000000000000000000000000000000' Use notEqual method of assert Parameters for notEqual : (result, default address , message);\n   ***********/\n     rassert.notEqual(result, '0x0000000000000000000000000000000000000000', '')\n   /**********\n   Task 18: Call winners function from account 3 to get the winner of item id 2\n   ***********/\n     return auctionInstance.winners(2,{from:accounts[0]}) }).then(function(result) {\n   /**********\n   Task 19: assert to see if the winner address is not the default address\n    Default address is '0x0000000000000000000000000000000000000000'\n      Use notEqual method of assert\n      Parameters for notEqual : (result, default address , message);\n   ***********/\n    assert.notEqual(result, '0x0000000000000000000000000000000000000000', '')\n   })\n   });\n});\n\n```", "```\nApp = {\n     web3Provider: null,\n     contracts: {},\n     names: new Array(),\n     url: '[http://127.0.100.94.1231](http://doi.org/127.0.100.94.1231)',\n     President:null,\n     currentAccount:null,\n     init: function() {\n       $.getJSON('../proposals.json', function(data) {\nvar proposalsRow = $('#proposalsRow'); \n       var proposalTemplate = $('#proposalTemplate');\n\nfor (i = 0; i < data.length; i ++) { \n       proposalTemplate.find('.panel-title').\n       text(data[i].name);\n\n       proposalTemplate.find('img').attr('src', data[i].picture);\n       proposalTemplate.find('.btn-vote').attr('data-id', data[i].id);\n\nproposalsRow.append(proposalTemplate.html()); \n       App.names.push(data[i].name);\n      }\n    });\n\n   return App.initWeb3();\n},\n\ninitWeb3: function() {\n     // Is there is an injected web3 instance?\n    if (typeof web3 !== 'undefined') {\nApp.web3Provider = web3.currentProvider; } else { \n    // If no injected web3 instance is detected, fallback to the TestRPC\n    App.web3Provider = new Web3.providers.HttpProvider(App.url);\n   }\n   web3 = new Web3(App.web3Provider);\n     App.populateAddress();\n    return App.initContract();\n},\n     initContract: function() {\n    $.getJSON('Ballot.json', function(data) {\n   // Get the necessary contract artifact file and instantiate it with truffle-contract\n    var voteArtifact = data;\n    App.contracts.vote = TruffleContract(voteArtifact);\n\n// Set the provider for our contract \nApp.contracts.vote.setProvider(App.web3Provider); \n\n   App.getPresident();\n   return App.bindEvents();\n  });\n},\n\n    bindEvents: function() {\n   $(document).on('click', '.btn-vote', App.handleVote);\n   $(document).on('click', '#win-count', App.handleWinner);\n   $(document).on('click', '#register', function(){ var ad = $('#enter_address').val(); App.handleRegister(ad);\n  });\n},\n\n    populateAddress : function(){ new Web3(new Web3.providers.HttpProvider(App.url)).\neth.getAccounts((err, accounts) => { \n   jQuery.each(accounts,function(i){\n     if(web3.eth.coinbase != accounts[i]){\n       var optionElement = '<option value=\"'+accounts[i]+'\">'+accounts[i]+'</option';\n       jQuery('#enter_address').append(optionElement);\n    }\n   });\n  });\n},\ngetPresident : function(){ \n   App.contracts.vote.deployed().then(function(instance) {\nreturn instance.President(); \n}).then(function(result) {\nApp.President = result.toString(); \nApp.currentAccount = web3.eth.coinbase; \n  if(App.President != App.currentAccount){ jQuery('#address_div').css('display','none');\n   jQuery('#register_div').css('display','none');\n  }else{\n    jQuery('#address_div').css('display','block');\n    jQuery('#register_div').css('display','block');\n   }\n  })\n},\n\nhandleRegister: function(addr){\n\n  var voteInstance;\n  App.contracts.vote.deployed().then(function(instance) {\n   voteInstance = instance;\n   return voteInstance.register(addr);\n  }).then( function(result){\nif(result.receipt.status == '0x01') \n   alert(addr + \" is registered successfully\")\n  else\n   alert(addr + \" account registeration failed due to revert\")\n  }).catch( function(err){\n   alert(addr + \" account registeration failed\")\n  })\n},\n\nhandleVote: function(event) { \n   event.preventDefault();\n   var proposalId = parseInt($(event.target).data('id'));\n   var voteInstance;\n\n  web3.eth.getAccounts(function(error, accounts) {\n   var account = accounts[0];\n\n  App.contracts.vote.deployed().then(function\n    (instance) {\n   voteInstance = instance;\n\n   return voteInstance.vote(proposalId, {from: account});\n  }).then(function(result){\nif(result.receipt.status == '0x01') \n    alert(account + \" voting done successfully\")\n    aelse\naalert(account + \" voting not done successfully due to revert\") \n    a}).catch(function(err){\n    aalert(account + \" voting failed\")\n   });\n  });\n},\n    handleWinner : function() {\nvar voteInstance; \nApp.contracts.vote.deployed().then(function(instance) { \nvoteInstance = instance; return voteInstance.Winner(); \n   }).then(function(res){\n     alert(App.names[res] + \" is the winner ! :)\"); }).catch(function(err){ console.log(err.message); }) } }; $(function() { $(window).load(function() { App.init();\n    console.log('starting app.js');\n   });\n});\n\n```", "```\n// SPDX-License-Identifier: BITS\n\npragma solidity 0.8.11;\n\nimport \"@openzeppelin/contracts/utils/cryptography/\ndraft-EIP712.sol\";\nimport \"./OrderMixin.sol\";\nimport \"./OrderRFQMixin.sol\";\n\ncontract LimitOrderProtocol is\n    EIP712(\"1inch Limit Order Protocol\", \"2\"),\n    OrderMixin,\n    OrderRFQMixin\n{\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view\nreturns(bytes32) {\n        return _domainSeparatorV4();\n    }\n}\nOrderMixin.sol\n// SPDX-License-Identifier: BITS\n\npragma solidity 0.8.11;\n\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/\ndraft-EIP712.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./helpers/AmountCalculator.sol\";\nimport \"./helpers/ChainlinkCalculator.sol\";\nimport \"./helpers/NonceManager.sol\";\nimport \"./helpers/PredicateHelper.sol\";\nimport \"./interfaces/InteractiveNotificationReceiver.\nsol\";\nimport \"./libraries/ArgumentsDecoder.sol\";\nimport \"./libraries/Permitable.sol\"; \n/// @title Regular Limit Order mixin\nabstract contract OrderMixin is\n    EIP712,\n    AmountCalculator,\n    ChainlinkCalculator,\n    NonceManager,\n    PredicateHelper,\n    Permitable\n{\n    using Address for address;\n    using ArgumentsDecoder for bytes;\n\n    /// @notice Emitted every time order gets filled,\nincluding partial fills\n    event OrderFilled(\n        address indexed maker,\n        bytes32 orderHash,\n        uint256 remaining\n    );\n\n    /// @notice Emitted when order gets cancelled\n    event OrderCanceled(\n        address indexed maker,\n        bytes32 orderHash,\n        uint256 remainingRaw\n    );\n\n    // Fixed-size order part with core information\n    struct StaticOrder {\n        uint256 salt;\n        address makerAsset;\n        address takerAsset;\n        address maker;\n        address receiver;\n        address allowedSender; // equals to Zero\naddress on public orders\n        uint256 makingAmount;\n        uint256 takingAmount;\n    }\n\n    // `StaticOrder` extension including variable-sized\nadditional order meta information \n\n   struct Order {\n      uint256 salt;\n      address makerAsset;\n      address takerAsset;\n      address maker;\n      address receiver;\n      address allowedSender; // equals to Zero address on public orders\n      uint256 makingAmount;\n      uint256 takingAmount;\n      bytes makerAssetData;\n      bytes takerAssetData;\n      bytes getMakerAmount; // this.staticcall(abi.encodePacked(bytes, swapTakerAmount)) => (swapMakerAmount)\n      bytes getTakerAmount; // this.staticcall(abi.encodePacked(bytes, swapMakerAmount)) => (swapTakerAmount)\n      bytes predicate; // this.staticcall(bytes) => (bool)\nbytes permit; // On first fill: \n      permit.1.call(abi.encodePacked(permit.selector, permit.2))\n      bytes interaction;\n    }\n\n    bytes32 constant public LIMIT_ORDER_TYPEHASH = keccak256(\n        \"Order(uint256 salt,address makerAsset,address takerAsset,address maker,address receiver,address allowedSender,uint256 makingAmount,uint256 takingAmount,bytes makerAssetData,bytes takerAssetData,bytes getMakerAmount,bytes getTakerAmount,bytes predicate,bytes permit,bytes interaction)\"\n      );\n      uint256 constant private _ORDER_DOES_NOT_EXIST = 0;\n      uint256 constant private _ORDER_FILLED = 1;\n\n      /// @notice Stores unfilled amounts for each order plus one.\n      /// Therefore 0 means order doesn't exist and 1 means order was filled\n      mapping(bytes32 => uint256) private _remaining;\n\n/// @notice Returns unfilled amount for order. \nThrows if order does not exist function remaining(bytes32 orderHash) external view returns(uint256) {\n      uint256 amount = _remaining[orderHash];\n      require(amount != _ORDER_DOES_NOT_EXIST, \"LOP: Unknown order\");\n      unchecked { amount -= 1; }\n      return amount;\n   }\n\n      /// @notice Returns unfilled amount for order\n      /// @return Result Unfilled amount of order plus one if order exists. Otherwise 0 function remainingRaw(bytes32 orderHash) external view returns(uint256) {\n      return _remaining[orderHash];\n   }\n\n      /// @notice Same as `remainingRaw` but for multiple orders\nfunction remainingsRaw(bytes32[] memory orderHashes) external view returns(uint256[] memory) { \n      uint256[] memory results = new uint256[](orderHashes.length);\n      for (uint256 i = 0; i < orderHashes.length; i++) {\n          results[i] = _remaining[orderHashes[i]];\n      }\n      return results;\n  }\n\n      /**\n      * @notice Calls every target with corresponding data. Then reverts with CALL_RESULTS_0101011 where zeroes and ones\n      * denote failure or success of the corresponding call\n      * @param targets Array of addresses that will be called\n       * @param data Array of data that will be passed to each call\n      */\nfunction simulateCalls(address[] calldata targets, bytes[] calldata data) external { \n            require(targets.length == data.length, \"LOP: array size mismatch\");\nbytes memory reason = new bytes(targets.length); \n            for (uint256 i = 0; i < targets.length; i++) {\n                  // solhint-disable-next-line avoid-low-level-calls\n\n                  (bool success, bytes memory result) = targets[i].call(data[i]);\nif (success andand result.length > 0) { \n                        success = result.length == 32 andand\nresult.decodeBool();\n            }\n            reason[i] = success ? bytes1(\"1\") :\n    bytes1(\"0\");\n            }\n\n            // Always revert and provide per call results\n            revert(string(abi.encodePacked(\"CALL_RESULTS_\",\n   reason)));\n      }\n\n      /// @notice Cancels order by setting remaining amount to zero function cancelOrder(Order memory order) external {\n            require(order.maker == msg.sender, \"LOP: Access denied\");\n\n            bytes32 orderHash = hashOrder(order);\nuint256 orderRemaining = _remaining[orderHash]; \n            require(orderRemaining != _ORDER_FILLED, \"LOP: already filled\");\n            emit OrderCanceled(msg.sender, orderHash, orderRemaining);\n            _remaining[orderHash] = _ORDER_FILLED;\n    }\n            /// @notice Fills an order. If one doesn't exist (first fill) it will be created using order.makerAssetData\n      /// @param order Order quote to fill\n      /// @param signature Signature to confirm quote ownership\n      /// @param makingAmount Making amount\n      /// @param takingAmount Taking amount\n      /// @param thresholdAmount Specifies maximum allowed takingAmount when takingAmount is zero, otherwise specifies minimum allowed makingAmount\n        function fillOrder(\n          Order memory order,\n          bytes calldata signature,\n          uint256 makingAmount,\n          uint256 takingAmount,\n          uint256 thresholdAmount\n       ) external returns(uint256 /* actualMakingAmount */, uint256 /* actualTakingAmount */) {\nreturn fillOrderTo(order, signature, makingAmount, takingAmount, thresholdAmount, msg.sender);\n   }\n\n      /// @notice Same as `fillOrder` but calls permit first,\n      /// allowing to approve token spending and make a swap in one transaction.\n      /// Also allows to specify funds destination instead of `msg.sender`\n      /// @param order Order quote to fill\n      /// @param signature Signature to confirm quote ownership\n      /// @param makingAmount Making amount\n      /// @param takingAmount Taking amount\n      /// @param thresholdAmount Specifies maximum allowed takingAmount when takingAmount is zero, otherwise specifies minimum allowed makingAmount\n      /// @param target Address that will receive swap funds\n/// @param permit Should consist of abiencoded token address and encoded `IERC20Permit.permit` call. \n      /// @dev See tests for examples function fillOrderToWithPermit(\n          Order memory order,\n          bytes calldata signature,\n          uint256 makingAmount,\n          uint256 takingAmount,\n          uint256 thresholdAmount,\n          address target,\n          bytes calldata permit\n) external returns(uint256 /* actualMakingAmount */, uint256 /* actualTakingAmount */) { \n       require(permit.length >= 20, \"LOP: permit length too low\");\n       (address token, bytes calldata permitData) = permit.decodeTargetAndData();\n       _permit(token, permitData);\n       return fillOrderTo(order, signature, makingAmount, takingAmount, thresholdAmount, target);\n    }\n\n      /// @notice Same as `fillOrder` but allows to specify funds destination instead of `msg.sender`\n      /// @param order Order quote to fill\n      /// @param signature Signature to confirm quote ownership\n      /// @param makingAmount Making amount\n      /// @param takingAmount Taking amount\n      /// @param thresholdAmount Specifies maximum allowed takingAmount when takingAmount is zero, otherwise specifies minimum allowed makingAmount\n      /// @param target Address that will receive swap funds\n      function fillOrderTo(\n        Order memory order,\n        bytes calldata signature,\n        uint256 makingAmount,\n        uint256 takingAmount,\n        uint256 thresholdAmount,\n        address target\n   ) public returns(uint256 /* actualMakingAmount */, uint256 /* actualTakingAmount */) {\n     require(target != address(0), \"LOP: zero target is forbidden\");\n    bytes32 orderHash = hashOrder(order);\n\n    { // Stack too deep\n        uint256 remainingMakerAmount = _remaining[orderHash];\nrequire(remainingMakerAmount != _ORDER_FILLED, \"LOP: remaining amount is 0\"); \n        require(order.allowedSender == address(0) || order.allowedSender == msg.sender, \"LOP: private order\");\n        if (remainingMakerAmount == _ORDER_DOES_NOT_EXIST) {\n           // First fill: validate order and permit maker asset\n           require(SignatureChecker.isValidSignatureNow(order.maker, orderHash, signature), \"LOP: bad signature\");\n           remainingMakerAmount = order.makingAmount;\n           if (order.permit.length >= 20) {\n              // proceed only if permit length is enough to store address\n              (address token, bytes memory permit) = order.permit.decodeTargetAndCalldata();\n_permitMemory(token, permit); \n              require(_remaining[orderHash] == _ORDER_DOES_NOT_EXIST, \"LOP: reentrancy detected\");\n         }\n   } else {\n         unchecked { remainingMakerAmount -= 1; }\n   }\n\n   // Check if order is valid\nif (order.predicate.length > 0) { \n      require(checkPredicate(order), \"LOP: predicate returned false\");\n   }\n\n// Compute maker and taker assets amount \nif ((takingAmount == 0) == (makingAmount == 0)) { \n         revert(\"LOP: only one amount should be 0\");\n      } else if (takingAmount == 0) {\n         uint256 requestedMakingAmount = makingAmount;\nif (makingAmount > remainingMakerAmount) { \n           makingAmount = remainingMakerAmount;\n       }\n       takingAmount = _callGetter(order.getTakerAmount, order.makingAmount, makingAmount, order.takingAmount);\n       // check that actual rate is not worse than what was expected\n// takingAmount / makingAmount <= thresholdAmount / requestedMakingAmount \n       require(takingAmount * requestedMakingAmount <= thresholdAmount * makingAmount, \"LOP: taking amount too high\");\n     } else {\n         uint256 requestedTakingAmount = takingAmount;\n         makingAmount = _callGetter(order.getMakerAmount, order.takingAmount, takingAmount, order.makingAmount);\n         if (makingAmount > remainingMakerAmount) {\n            makingAmount = remainingMakerAmount;\n            takingAmount = _callGetter(order.getTakerAmount, order.makingAmount, makingAmount, order.takingAmount);\n          }\n          // check that actual rate is not worse than what was expected\n          // makingAmount / takingAmount >= thresholdAmount / requestedTakingAmount\n\n          require(makingAmount * requestedTakingAmount >= thresholdAmount * takingAmount, \"LOP: making amount too low\");\n       }\n\n       require(makingAmount > 0 andand takingAmount > 0, \"LOP: can't swap 0 amount\");\n       // Update remaining amount in storage unchecked {\n         remainingMakerAmount = remainingMakerAmount - makingAmount;\n         _remaining[orderHash] = remainingMakerAmount + 1;\n     }\n     emit OrderFilled(msg.sender, orderHash, remainingMakerAmount);\n   }\n\n   // Taker => Maker\n   _makeCall(\n      order.takerAsset, abi.encodePacked(\n      IERC20.transferFrom.selector,\n      uint256(uint160(msg.sender)),\n      uint256(uint160(order.receiver == address(0) ? order.maker : order.receiver)),\n      takingAmount,\n      order.takerAssetData\n   )\n );\n // Maker can handle funds interactively if (order.interaction.length >= 20) {\n   // proceed only if interaction length is enough to store address\n      (address interactionTarget, bytes memory interactionData) = order.interaction.decodeTargetAndCalldata();\n      InteractiveNotificationReceiver(interactionTarget).notifyFillOrder(\n      msg.sender, order.makerAsset, order.takerAsset, makingAmount, takingAmount, interactionData\n    );\n  }\n\n    // Maker => Taker _makeCall(\norder.makerAsset, \n    abi.encodePacked(\n       IERC20.transferFrom.selector,\n      uint256(uint160(order.maker)),\n      uint256(uint160(target)),\n      makingAmount,\n      order.makerAssetData\n     )\n   );\n\n   return (makingAmount, takingAmount);\n }\n\n /// @notice Checks order predicate\n function checkPredicate(Order memory order) public view returns(bool) {\n    bytes memory result = address(this).functionStaticCall(order.predicate, \"LOP: predicate call failed\");\n    require(result.length == 32, \"LOP: invalid predicate return\");\n    return result.decodeBool();\n  }\n\n  function hashOrder(Order memory order) public view returns(bytes32) {\n   StaticOrder memory staticOrder;\n   assembly { // solhint-disable-line no-inline-assembly\n   staticOrder := order\n  }\n  return _hashTypedDataV4(\n    keccak256(\n      abi.encode(\n          LIMIT_ORDER_TYPEHASH,\n          staticOrder,\n          keccak256(order.makerAssetData),\n          keccak256(order.takerAssetData),\n          keccak256(order.getMakerAmount),\n          keccak256(order.getTakerAmount),\n          keccak256(order.predicate),\n          keccak256(order.permit),\n          keccak256(order.interaction)\n        )\n      )\n   );\n }\n\n function _makeCall(address asset, bytes memory assetData) private {\n   bytes memory result = asset.functionCall(assetData, \"LOP: asset.call failed\");\n   if (result.length > 0) {\n     require(result.length == 32 andand result.\ndecodeBool(), \"LOP: asset.call bad result\");\n  }\n }\n function _callGetter(bytes memory getter, uint256 orderExpectedAmount, uint256 amount, uint256 orderResultAmount) private view returns(uint256) {\n    if (getter.length == 0) {\n      // On empty getter calldata only exact amount is allowed\n      require(amount == orderExpectedAmount, \"LOP: wrong amount\");\n      return orderResultAmount;\n    }else {\n      bytes memory result = address(this).\nfunctionStaticCall(abi.encodePacked(getter, amount),\n\"LOP: getAmount call failed\"); \n      require(result.length == 32, \"LOP: invalid getAmount return\");\n      return result.decodeUint256();\n    }\n  }\n }\n\n```"]