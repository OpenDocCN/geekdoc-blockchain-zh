- en: Chapter 10
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第十章
- en: Blockchain Development
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链开发
- en: This chapter provides a general overview of blockchain development by offering
    insight into the most common development languages, development tools, and the
    blockchains they are used for.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章通过提供对最常见的开发语言、开发工具以及它们用于的区块链的洞察，提供了对区块链开发的概述。
- en: I will focus mainly on the high-level aspects of development around the Ethereum,
    Hyperledger, Corda, and Quorum blockchains as well as the development languages
    they are built on. The world of blockchain development is a far and wide specialization
    area. Each blockchain has its own approach to development, toolsets, consensus,
    and dependencies, and could merit its own book on the subject of blockchain development.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我将主要关注以太坊、Hyperledger、Corda 和 Quorum 区块链以及它们所构建的开发语言的高级开发方面。区块链开发领域是一个广阔而专业的领域。每个区块链都有自己的开发方法、工具集、共识和依赖关系，可能需要一本专门讨论区块链开发的书籍。
- en: Blockchain development is a growing area. The demand has never been higher due
    to the shortage of developers who understand blockchain. If you are developing
    in JavaScript, Golang, Python, or any common language, you are already on the
    road to being a blockchain developer.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链开发是一个不断增长的领域。由于了解区块链的开发者短缺，需求从未如此之高。如果你正在使用 JavaScript、Golang、Python 或任何常见语言进行开发，你已经在成为区块链开发者的道路上了。
- en: The goal of this chapter is to give an overview of how the blockchains are built
    around the programming languages, data structures, and programming building blocks.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是概述区块链是如何围绕编程语言、数据结构和编程构建模块构建的。
- en: 'If you are looking for programming instructions, note that this chapter does
    not focus on developing applications or programming methods; rather, this chapter
    is intended as a guide for systems engineers and other nondevelopers to grasp
    the complexity of blockchain development.  ## Common Programming Languages'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你正在寻找编程指南，请注意，本章不重点讨论应用程序开发或编程方法；相反，本章旨在为系统工程师和其他非开发人员提供一个了解区块链开发复杂性的指南。
    ## 常见编程语言'
- en: Blockchain programs are computer code and are known as *smart contracts*. Developers
    who are programming for web apps, enterprise apps, or cloud apps are likely frontrunners
    to be blockchain developers.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链程序是计算机代码，被称为*智能合约*。编写网络应用、企业应用或云应用的开发人员很可能成为区块链开发人员的领先者。
- en: If you're a system engineer, whether presales or postsales, you are also likely
    to understand some aspects of programming languages. Your customers are likely
    already using some of these in their development organizations, which can give
    your customers' organizations a head start in blockchain development.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是系统工程师，无论是售前还是售后，你也可能了解一些编程语言的某些方面。你的客户很可能已经在他们的开发组织中使用了其中一些，这可以让你的客户组织在区块链开发方面领先一步。
- en: The main point is that blockchains are about creating programs, and these programs
    are built on development languages you likely already use in your enterprises.
    The programs ultimately will solve problems, create value, or provide other tangible
    benefits for the company. The only significant learning curve is to know how the
    smart contracts interact with the blockchain network and perhaps to understand
    the APIs used to enable the client applications to interface with the application.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 主要观点是区块链是关于创建程序的，而这些程序是建立在你可能已经在企业中使用的开发语言上的。这些程序最终将解决问题、创造价值，或为公司提供其他实际的利益。唯一的重要学习曲线是了解智能合约如何与区块链网络交互，以及了解用于使客户端应用程序与应用程序接口交互的
    API。
- en: Let's run down the most common blockchain languages. This will give you a good
    idea of what's in demand. If you're looking for a blockchain developer, you will
    have a more concise requirements list to give to your recruiters.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们列举一下最常见的区块链语言。这将给你一个很好的了解需求的想法。如果你正在寻找区块链开发人员，你将有一个更加简洁的要求清单可以提供给你的招聘人员。
- en: '### Most Common Development Languages'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '### 最常见的开发语言'
- en: When it comes to development languages, a few languages are clearly in high
    demand in blockchain development. Some languages are used on only a few blockchains.
    For example, Solidity is used only on Ethereum and Quorum, but it makes up well
    over 60 percent of the blockchain developer requirements listed on LinkedIn at
    the time of writing.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到开发语言时，在区块链开发中有几种语言显然需求量很高。一些语言仅用于少数几个区块链。例如，Solidity 仅用于以太坊和 Quorum，但在撰写本文时占据了
    LinkedIn 上列出的区块链开发人员要求的总数的 60%以上。
- en: Note that other common development languages are also used, for example, in
    Bitcoin, Lisk, and EOS, as well as other newer blockchains that I do not cover
    in the book. The main coverage in this chapter will focus on Ethereum, Corda,
    Hyperledger Fabric, and Quorum.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，其他常见的开发语言也被使用，例如在比特币、Lisk 和 EOS 中，以及我在本书中未涵盖的其他新型区块链。本章的主要覆盖范围将集中在以太坊、Corda、Hyperledger
    Fabric 和 Quorum 上。
- en: 'The following are the most commonly used languages in enterprise blockchain
    development:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是企业区块链开发中最常用的语言：
- en: Solidity
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Solidity
- en: Golang
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Golang
- en: C++
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++
- en: JavaScript
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript
- en: Python
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python
- en: When it comes to holistic development and not just blockchain-focused development,
    Python is the clear winner at the time of writing. Finding Python professionals
    likely will not be an issue due to the wide acceptance of the Python development
    language.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 关于整体发展而言，而不仅仅是关注区块链的发展，Python 在撰写本文时是明显的赢家。由于 Python 开发语言的广泛接受，找到 Python 专业人士可能不是问题。
- en: For additional insight into which development languages are in demand and the
    current popularity of each language, refer to a resource compiled from Google
    called “PYPL Popularity of Programming Language Index,” at `[http://pypl.github.io/PYPL.html](http://pypl.github.io/PYPL.html)`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解哪些开发语言需求量大以及每种语言当前的流行程度，可以参考 Google 编制的一份资源，名为“PYPL 编程语言流行度指数”，网址为 `[http://pypl.github.io/PYPL.html](http://pypl.github.io/PYPL.html)`。
- en: '#### SOLIDITY'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '#### SOLIDITY'
- en: When it comes to blockchain development, Solidity is the most widely used and
    in-demand developer requirement at the time of writing for enterprise blockchains.
    A contract-oriented Turing-complete programming language, Solidity has a large
    base of Ethereum developers, with an estimated 250,000+ users.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到区块链开发时，Solidity 是撰写本文时企业区块链最广泛使用和需求量最大的开发者要求。作为一种面向合约的图灵完备编程语言，Solidity
    拥有庞大的以太坊开发者基础，估计有 250,000+ 用户。
- en: Solidity is a relatively simple programming language that is used with Ethereum
    developers. Solidity was clearly developed specifically for the Ethereum platform.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Solidity 是与以太坊开发人员一起使用的相对简单的编程语言。Solidity 显然是专为以太坊平台而开发的。
- en: The developers of Solidity used specific features, functions, and concepts from
    C++, Python, JavaScript, and Golang to assemble the new language. Solidity's main
    program syntax is based on JavaScript, a widely used development language. Because
    Solidity is built from JavaScript, it has a low barrier of entry for developers.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Solidity 的开发者从 C++、Python、JavaScript 和 Golang 中提取了特定的功能、函数和概念来组装这种新语言。Solidity
    的主要程序语法基于 JavaScript，这是一种广泛使用的开发语言。由于 Solidity 是基于 JavaScript 构建的，因此对开发者来说门槛较低。
- en: When you think of developing in Ethereum, you think of Solidity since it was
    developed exclusively for Ethereum smart contracts initially. Solidity has essentially
    expanded to become its own standard for other blockchain platforms to follow.
    At the time of writing, the most widely used languages for writing smart contracts
    on Ethereum are Solidity and Vyper.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当你考虑在以太坊上开发时，你会想到 Solidity，因为它最初是专门为以太坊智能合约开发的。Solidity 实质上已经扩展为其他区块链平台遵循的标准。在撰写本文时，以太坊智能合约编写的最常用语言是
    Solidity 和 Vyper。
- en: Why is Solidity so popular? Solidity is a powerful and efficient toolset for
    developers because it allows programmers to write higher-level code, which is
    then compiled down into what is considered a low-level machine language. Smart
    contracts can be written in Solidity, Vyper, and Serpent mainly because they are
    high-level languages that are compiled down to bytecode. Bytecodes are essentially
    operation codes (opcodes) running instruction after instruction.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Solidity 为何如此受欢迎？Solidity 是开发人员的强大高效工具集，因为它允许程序员编写更高级的代码，然后编译成被视为低级机器语言的代码。智能合约可以用
    Solidity、Vyper 和 Serpent 编写，主要是因为它们是高级语言，会被编译成字节码。字节码本质上是操作码（opcodes），逐条指令运行。
- en: 'Blockchains that directly support smart contracts written in Solidity include
    Ethereum, Ethereum Classic, and Hyperledger Sawtooth (with Seth).  #### GOLANG'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '直接支持用 Solidity 编写的智能合约的区块链包括以太坊、以太坊经典和 Hyperledger Sawtooth（带有 Seth）。  ####
    GOLANG'
- en: Golang (Go) is an open source general programming language that is lightly based
    on the syntax of the C programming language. Golang also has some ease-of-use
    similarities to JavaScript, which gives Go a low barrier to entry.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Golang（Go）是一种开源的通用编程语言，它在语法上略微基于 C 编程语言。Golang 还具有一些与 JavaScript 类似的易用性特点，这使得
    Go 入门门槛较低。
- en: Originally designed by Google engineers, Golang was released directly to the
    open source community in 2009\. Golang has become a popular object-oriented and
    imperatively designed programming language. More than 800,000 developers use Golang.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Golang最初是由Google工程师设计的，在2009年直接发布给开源社区。Golang已经成为一种流行的面向对象和命令式设计的编程语言。超过800,000名开发者使用Golang。
- en: 'Hyperledger Fabric is built from Golang. The following are some of the benefits
    of using Golang (Go) with Hyperledger:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Hyperledger Fabric是用Golang构建的。以下是使用Golang（Go）与Hyperledger结合使用的一些好处：
- en: Provides a fast statically typed and compiled language
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供快速的静态类型和编译语言
- en: Supports type-safety and dynamic data entry
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持类型安全和动态数据输入
- en: Allows the creation of flexible and modular code, and thanks to its multithreading
    mechanisms, enables distributed computations and simplified network interaction
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许创建灵活和模块化的代码，通过其多线程机制，实现了分布式计算和简化的网络交互
- en: Provides convenient testing tools for developers on GitHub
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为GitHub上的开发者提供了便利的测试工具
- en: Offers efficient development processes
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供了高效的开发流程
- en: 'Ethereum''s SDK protocol is actually written in Go. There are many other blockchain
    applications of this language. Blockchains that are written in Golang (Go) include
    Hyperledger Fabric and NEO.  #### C++'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '以太坊的SDK协议实际上是用Go编写的。这种语言还有许多其他的区块链应用。使用Golang（Go）编写的区块链包括Hyperledger Fabric和NEO。  ####
    C++'
- en: C++ is the oldest development language used for blockchains. C++ has been around
    for more than 30 years and was originally known as “C with Classes.” C++ features
    worth noting for blockchains include memory control opportunities around scalability,
    which is a significant problem faced by blockchains today.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: C++是用于区块链的最古老的开发语言。C++已经存在了30多年，并且最初被称为“带类的C”。对于区块链而言，C++的一些值得注意的特性包括围绕可伸缩性的内存控制机会，这是当今区块链面临的重大问题。
- en: C++ is considered a general-purpose programming language with an extensive user
    base of more than 4 million developers. It can be used for higher-level tasks
    and also allows programmers to program to the hardware itself. This flexibility
    has made C++ highly popular for uses such as embedded systems and computer graphics.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: C++被认为是一种通用的编程语言，拥有超过400万开发者的庞大用户群。它可以用于高级任务，同时也允许程序员直接编程到硬件本身。这种灵活性使得C++在嵌入式系统和计算机图形等用途中广受欢迎。
- en: 'C++ offers the following benefits:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: C++提供了以下好处：
- en: Facilitates proper threading since there are many parallel operations that have
    to be performed simultaneously
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 促进了适当的线程处理，因为有许多并行操作必须同时执行
- en: Performs move semantics, which can significantly improve performance when it
    comes to the value of the variables retrieved
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行移动语义，这可以在检索变量值时显著提高性能
- en: Allows compile-time polymorphism, which enables developers to use functions
    in different ways, thereby decreasing code volume and boosting performance
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许编译时多态，使开发者能够以不同的方式使用函数，从而减少代码量并提高性能
- en: 'Blockchains that support C++ include Hyperledger Iroha, Bitcoin, EOS, and NEO.  ####
    JAVASCRIPT'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '支持C++的区块链包括Hyperledger Iroha、Bitcoin、EOS和NEO。  #### JAVASCRIPT'
- en: JavaScript is generally accepted to be the programming language of the Internet.
    It has been used primarily to enhance web pages to provide for a more dynamic,
    user-friendly experience. JavaScript is widely accepted for development use since
    it is good at handling asynchronous actions.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript通常被认为是互联网的编程语言。它主要用于增强网页，以提供更动态、用户友好的体验。JavaScript在开发中被广泛接受，因为它擅长处理异步操作。
- en: This property of asynchronous actions makes JavaScript well suited for blockchain
    operations that require scaling. As the number of users on your blockchain rises,
    JavaScript can scale with the blockchain.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这种异步操作的特性使得JavaScript非常适合需要扩展的区块链操作。随着区块链上用户数量的增加，JavaScript可以与区块链一起扩展。
- en: JavaScript is a lower entry point to developers who are interested in programming
    blockchains since it's easy to learn and widely used.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 对于对编程区块链感兴趣的开发者来说，JavaScript是一个更低的入门点，因为它易于学习并被广泛使用。
- en: 'Blockchains that support smart contracts in JavaScript include Hyperledger
    Fabric, Hyperledger Sawtooth, and Lisk.  #### PYTHON'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '支持JavaScript智能合约的区块链包括Hyperledger Fabric、Hyperledger Sawtooth和Lisk。  #### PYTHON'
- en: Python is an interpreted, higher-level, and general-purpose programming language.
    Python was created by Guido van Rossum and was first released in 1991\. Python
    has a design philosophy that emphasizes code readability, notably using significant
    whitespace.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Python 是一种解释性、高级的、通用的编程语言。Python 由 Guido van Rossum 创建，于 1991 年首次发布。Python 有一个强调代码可读性的设计哲学，尤其是使用显著的空格。
- en: From a development perspective, Python supports a large number of libraries.
    Python is also generally considered to be one of the simpler languages since it
    has an intuitive code structure. For example, code can be written once and run
    on almost any computer without needing to change the program.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 从开发的角度来看，Python 支持大量的库。Python 通常被认为是较简单的语言之一，因为它具有直观的代码结构。例如，代码可以编写一次，几乎可以在任何计算机上运行，而无需更改程序。
- en: 'NEO is an example of a blockchain that supports smart contracts in Python.  ###
    Less Widely Used Development Languages'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 'NEO 是支持 Python 中智能合约的区块链的一个例子。  ### 较少使用的开发语言'
- en: 'The following are some less commonly used but also notable development languages
    for enterprise blockchain development:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些较少使用但也值得注意的企业区块链开发语言：
- en: C#
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C#
- en: Java
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java
- en: Rust
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rust
- en: Simplicity
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单性
- en: Although many other languages have been developed, and new languages are likely
    being developed as you read this, I want to focus on languages that have mainstream
    use.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管许多其他语言已经开发出来，而且可能在您阅读此文本时正在开发新语言，但我想专注于主流使用的语言。
- en: '#### C#'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '#### C#'
- en: C# tutorials claim this programming language as an option, and it can be used
    to create blockchains because it is object-oriented. It is a widely popular language
    for portability since it is somewhat easy to code in a cross-platform manner for
    software. It is important to note that it has a close relation to Java and would
    be easily understood by developers.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: C# 教程将这种编程语言视为一个选择，它可以用于创建区块链，因为它是面向对象的。由于在跨平台软件中编写代码相对容易，它是一种广泛流行的可移植语言。重要的是要注意它与
    Java 有密切关系，并且开发人员很容易理解。
- en: 'Blockchains that are written in C# include NEO and Stratus.  #### JAVA'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '使用 C# 编写的区块链包括 NEO 和 Stratus。  #### JAVA'
- en: Java has been primarily used in website designs since it was simple to connect
    the link between blocks of information. Released in 1995 by Sun Microsystems,
    Java is a general-purpose programming language that is object-oriented, class-based,
    and concurrent.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 自从 Java 问世以来，它一直主要用于网站设计，因为它能够简单地连接信息块之间的链接。Java 由 Sun Microsystems 于 1995 年发布，是一种面向对象、基于类和并发的通用编程语言。
- en: There is also a runtime environment (JRE), which consists of the Java virtual
    machine and Java platform core classes and supports Java platform libraries. Java
    is often used for developing client-server web applications, allowing developers
    to run a compiled Java code on all the platforms that support Java without the
    need for recompilation, making it popular for running light-weight cryptocurrency
    applications.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个运行时环境（JRE），它由 Java 虚拟机和 Java 平台核心类组成，并支持 Java 平台库。Java 通常用于开发客户端-服务器 Web
    应用程序，使开发人员能够在支持 Java 的所有平台上运行已编译的 Java 代码，而无需重新编译，这使其在运行轻量级加密货币应用程序方面很受欢迎。
- en: 'Blockchains that support smart contracts in Java include NEM, NEO, and Corda.  ####
    RUST'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '支持 Java 中智能合约的区块链包括 NEM、NEO 和 Corda。  #### RUST'
- en: Rust is a system language created by Mozilla, one of the Internet pioneers.
    Rust has several advantages that enable rapid blockchain development, including
    efficient computer processing and flexibility around security.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 是由互联网先驱 Mozilla 创建的系统语言。Rust 具有几个优点，可以促进快速区块链开发，包括高效的计算处理和在安全性方面的灵活性。
- en: The Rust compiler provides for risk reduction when executing code since it helps
    to eliminate potential problems. Rust has a very active community and a well-provisioned
    communication and learning system for developers.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 编译器在执行代码时提供了风险降低，因为它有助于消除潜在的问题。Rust 社区非常活跃，为开发人员提供了充足的沟通和学习系统。
- en: 'Corda is an example of a blockchain that supports smart contracts in Rust.  ####
    SIMPLICITY'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 'Corda 是支持 Rust 中智能合约的区块链的一个例子。  #### 简单性'
- en: Simplicity is a newer blockchain programming language that was designed exclusively
    for smart contracts. Simplicity was developed by a company called Blockstream,
    which had a goal to provide the flexibility and expressiveness for blockchain
    computations as well as verifying the safety, security, and costs of smart contracts.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Simplicity 是一种较新的区块链编程语言，专门设计用于智能合约。Simplicity 是由一家名为 Blockstream 的公司开发的，其目标是为区块链计算提供灵活性和表达力，以及验证智能合约的安全性、安全性和成本。
- en: Simplicity was well thought out in the sense that it was developed to ensure
    that the programming challenges of traditional development languages were addressed.
    One of the main challenges was to actually program efficiently for the role of
    a blockchain. The role of a blockchain should be only to verify computation. A
    traditional programming model would be more focused on performing computation.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计 Simplicity 时，有一个很好的考虑，即确保解决传统开发语言的编程挑战。其中一个主要挑战是为区块链的角色有效地编程。区块链的角色应该只是验证计算。传统的编程模型更加关注执行计算。
- en: 'For more on this exciting new blockchain development language, refer to this
    site:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 有关这种令人兴奋的新区块链开发语言的更多信息，请参阅此网站：
- en: '`[https://blockstream.com/2018/11/28/en-simplicity-github/](https://blockstream.com/2018/11/28/en-simplicity-github/)`  ###
    Summary of Blockchain Platforms'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`[https://blockstream.com/2018/11/28/en-simplicity-github/](https://blockstream.com/2018/11/28/en-simplicity-github/)`  ###
    区块链平台摘要'
- en: Numerous languages are used on the various platforms for cryptocurrencies and
    enterprise blockchains. For example, in Ethereum you have several choices, but
    the main language from a development perspective to focus on is Solidity.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在各种加密货币和企业区块链平台上使用了许多语言。例如，在以太坊上，你有几个选择，但从开发角度来看，主要语言是 Solidity。
- en: '[Table 10.1](#c10-tbl-0001) summarizes the major enterprise blockchain languages.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[表10.1](#c10-tbl-0001) 总结了主要的企业区块链语言。'
- en: '[**TABLE 10.1**](#R_c10-tbl-0001): Blockchain Platforms and Development Languages'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '[**表10.1**](#R_c10-tbl-0001)：区块链平台和开发语言'
- en: '| BLOCKCHAIN PLATFORM | PLATFORM DEVELOPMENT | SMART CONTRACT LANGUAGES |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| 区块链平台 | 平台开发 | 智能合约语言 |'
- en: '| --- | --- | --- |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Ethereum | Solidity | Solidity/Vyper/Bamboo/Flint |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| 以太坊 | Solidity | Solidity/Vyper/Bamboo/Flint |'
- en: '| Hyperledger Fabric | Golang | Golang/JavaScript/Java |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| Hyperledger Fabric | Golang | Golang/JavaScript/Java |'
- en: '| Corda | Kotlin | Kotlin and Java |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| Corda | Kotlin | Kotlin 和 Java |'
- en: '| Quorum | Solidity | Solidity |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| Quorum | Solidity | Solidity |'
- en: '| Ripple | Python | N/A |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| Ripple | Python | N/A |'
- en: 'When considering a blockchain platform, it is important not only to consider
    your organization''s expertise requirements for blockchain development but also
    to review and document any legacy applications'' requirements that may be extended
    to the blockchain service.  ## Ethereum Development'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '在考虑区块链平台时，重要的不仅是考虑您组织对区块链开发的专业要求，还要审查和记录可能扩展到区块链服务的任何遗留应用程序的要求。 ## 以太坊开发'
- en: An open source and collaborative effort, Ethereum is by far the blockchain that
    has the most robust development ecosystem and developer following. The main feature
    of Ethereum that drives this large developer following is the Turing-complete
    language that facilitates the development of smart contracts.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个开源和协作的努力，以太坊是迄今为止拥有最强大的开发生态系统和开发者追随者的区块链。推动这一大规模开发者追随者的以太坊主要特征是图灵完备语言，它促进了智能合约的开发。
- en: Developers should note that Ethereum is geared toward applications that automate
    direct interaction between peers or that facilitate group routines over the Ethereum
    decentralized network.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员应注意，以太坊旨在用于自动化直接对等体之间的交互或促进在以太坊分散网络上的群体例行程序。
- en: Ethereum itself is only a protocol defining how the communication should work.
    There are several versions of the Ethereum protocol. The two most common versions
    are Go-Ethereum (aka GETH), which is written in Golang, and Parity, which is written
    in Rust.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊本身仅是定义通信应如何工作的协议。以太坊协议有几个版本。最常见的两个版本是 Go-Ethereum（又名 GETH），它是用 Golang 编写的；Parity，它是用
    Rust 编写的。
- en: 'There is a dearth of development tools, utilities, and testnets for Ethereum.
    Some of the most common tools include the following:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊缺乏开发工具、实用程序和测试网。一些最常见的工具包括以下内容：
- en: '**IDE**: Solidity Browser, Ethereum Studio'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IDE**：Solidity 浏览器，以太坊 Studio'
- en: '**Clients**: Geth, Parity, Ethereum Wallet'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端**：Geth、Parity、以太坊钱包'
- en: '**Storage**: IPFS (supported through Swarm and Storj)'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存储**：IPFS（通过 Swarm 和 Storj 支持）'
- en: '**Dapp** browsers: MetaMask, Mist'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Dapp**浏览器：MetaMask、Mist'
- en: '**Testing**: Testnets, TestRPC, localhost'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试：**测试网络、测试RPC、本地主机'
- en: 'There are numerous other tools for testing IDE environments, frontend and backend
    development, and security. For more details on the robust Ethereum ecosystem,
    check out the ConsenSys GitHub here:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他工具用于测试IDE环境、前端和后端开发以及安全性。有关强大的以太坊生态系统的更多详细信息，请查看ConsenSys GitHub网址：
- en: '`[https://github.com/ConsenSys/ethereum-developer-tools-list#smart-contract-languages](https://github.com/ConsenSys/ethereum-developer-tools-list#smart-contract-languages)`'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`[https://github.com/ConsenSys/ethereum-developer-tools-list#smart-contract-languages](https://github.com/ConsenSys/ethereum-developer-tools-list#smart-contract-languages)`'
- en: '### Smart Contracts'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '### 智能合约'
- en: A smart contract is computer program code capable of organizing, executing,
    and enforcing the negotiation or performance of an agreement using blockchain
    technology. From a development perspective, the blockchain is somewhat limited
    in the sense that the API calls that can made are minimal.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约是一种能够利用区块链技术组织、执行和强制执行协议谈判或履行的计算机程序代码。从开发的角度来看，区块链在某种程度上受到限制，因为可以进行的API调用很少。
- en: Developers are generally well versed in automating tasks, which is exactly what
    smart contracts perform. A smart contract is an automated process that can be
    considered a suitable legal contract in some scenarios.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员通常精通自动化任务，这正是智能合约所执行的任务。智能合约是一个自动化流程，在某些情况下可以被视为适当的法律合同。
- en: Smart contracts define the rules of engagement and the penalties around that
    agreement in the same way that a traditional contract does. Developers will clearly
    define how to handle any violations of the smart contract from a code perspective.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约定义了协议的参与规则和惩罚，就像传统合同一样。开发人员将清楚地定义如何从代码角度处理对智能合约的任何违规行为。
- en: In Ethereum, as in other blockchain languages, there are specific functions
    to deal with. Your developers should clearly understand how these functions work
    and how the program would come together as an application.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在以太坊中，与其他区块链语言一样，有特定的功能要处理。你的开发人员应清楚地了解这些功能的工作原理以及程序如何组合成应用。
- en: '#### SMART CONTRACT WORKFLOW'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 智能合约工作流程'
- en: As discussed in [Chapter 2](c02.xhtml), two types of functions are required
    in an Ethereum smart contract.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在[第二章](c02.xhtml)中讨论的，以太坊智能合约需要两种类型的功能。
- en: Constructor function, which is called only once when you deploy the smart contract
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数，在部署智能合约时仅调用一次
- en: Fallback function, which is invoked when someone sends ether to the address
    of your smart contract
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回退函数，在有人向智能合约地址发送以太币时调用
- en: '[Figure 10.1](#c10-fig-0001) shows the smart contract workflow in Ethereum.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '[图10.1](#c10-fig-0001)显示了以太坊中智能合约的工作流程。'
- en: '![Image described by caption and surrounding text.](images/c10f001.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![由标题和周围文本描述的图像。](images/c10f001.png)'
- en: '[**FIGURE 10.1**](#R_c10-fig-0001) Smart contract workflow'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '[**图10.1**](#R_c10-fig-0001) 智能合约工作流程'
- en: 'Here are the steps with more information:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是更多信息的步骤：
- en: '**Predefined contract:** All the smart contract participants will establish
    the terms and also establish the conditions for execution.'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**预定义合同：**所有智能合约参与者将建立条款，并确定执行条件。'
- en: '**Events:** These are really event “triggers” that kick off the execution of
    the contract. Events include initiating a transaction and receiving funds, for
    example.'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**事件：**这些实际上是触发合同执行的事件。例如，启动交易和接收资金。'
- en: '**Execute transfer:** The terms of the contract specifically dictate the movement
    of value based on the conditions met.'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**执行转移：**合同的条款明确规定了基于满足条件的价值转移。'
- en: '**Settlement:** The settlement of the contract is based on the requirements
    being met. For example, was $100,000 received from the title company?'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**结算：**合同的结算是基于满足的要求。例如，是否从产权公司收到了10万美元？'
- en: 'Smart contracts, when combined with other smart contracts, make a decentralized
    application (*dapp*). A dapp can be as simple as a few lines of code or as complex
    as possible with thousands of lines of code. Complexity can be built into the
    platform or could also be extended off-chain as well. Developers have myriad options
    during the development process to customize the dapps.  #### SMART CONTRACT ENFORCEMENT'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约与其他智能合约结合，形成去中心化应用（*dapp*）。Dapp可以简单到几行代码，也可以是包含数千行代码的复杂应用。复杂性可以内置到平台中，也可以作为离线扩展。开发人员在开发过程中有各种各样的选项来定制dapps。####
    智能合约执行
- en: To modify a smart contract's data, a blockchain user must send requests directly
    to its code. That is, the request does not go through an intermediary but instead
    will be fully handled by the smart contract code.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要修改智能合约的数据，区块链用户必须直接将请求发送到其代码。也就是说，请求不会通过中间人，而是完全由智能合约代码处理。
- en: The smart contract modification process that will kick off determines whether
    to fulfill the request and how to fulfill requests that have been sent. Effectively,
    the smart contract is self-enforcing the rules that are clearly defined.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 启动的智能合约修改流程将决定是否满足请求以及如何满足已发送的请求。实际上，智能合约是自我执行明确定义的规则。
- en: Comparatively, you can think of smart contract enforcement as how a traditional
    database such as SQL uses what is called an *enforced stored procedure*. In SQL
    you can specify how the stored procedure will work by using the `CREATE PROCEDURE`
    command. The `CREATE PROCEDURE` command will first reference specified parameters,
    such as students, addresses, money, and so on. Then the stored procedure will
    take in the specified value and compare it to what is in the `var_return` value.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，你可以将智能合约强制执行看作是传统数据库（如 SQL）使用所谓的*强制存储过程*的方式。在 SQL 中，你可以使用`CREATE PROCEDURE`命令指定存储过程的工作方式。`CREATE
    PROCEDURE`命令首先引用指定的参数，如学生、地址、货币等。然后，存储过程将接收指定的值并将其与`var_return`值进行比较。
- en: 'In SQL, all inserts have to be executed at once or none at all, which is similar
    to how a blockchain enforces the smart contract logic. In blockchain we would
    call this strict enforcement *predefined rules*. Predefined rules in a blockchain
    would specify whether a sender has provided the exact amount of funds. If the
    exact amount of funds were sent by the sender and then promptly received by the
    receiver, then the smart contract would execute. Simply put, smart contracts are
    all or nothing from a layperson''s perspective.  #### DAPPS'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '在 SQL 中，所有插入都必须一次性执行或全部不执行，这类似于区块链强制执行智能合约逻辑的方式。在区块链中，我们将这种严格执行称为*预定义规则*。区块链中的预定义规则将指定发送方是否提供了精确的资金金额。如果发送方发送了精确的资金金额，并且随后被接收方迅速接收，那么智能合约将执行。简而言之，从普通人的角度来看，智能合约要么全部执行，要么全部不执行。  ####
    DAPPS'
- en: Dapps (decentralized applications) run on a P2P network of computers (such as
    Ethereum) and are not centralized. When developing blockchain applications with
    Ethereum, you have two distinct options.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Dapps（去中心化应用程序）在一组计算机（例如以太坊）的点对点网络上运行，并非集中式。在使用以太坊开发区块链应用程序时，你有两个明显的选择。
- en: Use Solidity or another development language to develop smart contracts that
    will be deployed to the blockchain.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Solidity 或其他开发语言开发将部署到区块链的智能合约。
- en: Develop websites that interface with the Ethereum blockchain.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发与以太坊区块链进行接口的网站。
- en: When it comes to developing dapps, it's important to understand how different
    a blockchain is from a traditional client server application. Developers are well
    versed in client-server applications and understand the world of the Web. Moving
    from Web 2.0 to the new world of Web 3.0 will take newer skillsets and application
    development languages. Decentralized apps will become the thing of tomorrow, and
    developers need to get skilled in this area.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到开发 dapps 时，了解区块链与传统客户端服务器应用程序的不同是很重要的。开发人员熟悉客户端服务器应用程序，并了解 Web 的世界。从 Web
    2.0 迁移到 Web 3.0 的新世界将需要更新的技能集和应用程序开发语言。去中心化应用程序将成为明天的主流，开发人员需要在这个领域熟练掌握技能。
- en: '[Figure 10.2](#c10-fig-0002) provides a high-level comparison of Web 2.0 applications
    to the layers of a blockchain application Web 3.0.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10.2](#c10-fig-0002) 提供了 Web 2.0 应用程序与区块链应用程序 Web 3.0 层的高级比较。'
- en: '![Schematic diagram depicting Application-layer comparison.](images/c10f002.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![应用层比较的示意图](images/c10f002.png)'
- en: '[**FIGURE 10.2**](#R_c10-fig-0002) Application-layer comparison'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '[**图 10.2**](#R_c10-fig-0002) 应用层比较'
- en: The infrastructure layer in blockchain technology is different from Web 2.0
    in the sense that P2P networking is being introduced as the approach used to move
    from a centralized web to more of a decentralized web.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链技术中的基础设施层与 Web 2.0 不同，因为引入了点对点网络作为从集中式 Web 到更加去中心化 Web 的方法。
- en: Blockchain is considered to be fully capable of providing technological benefits
    because of its decentralized capacity. Web 3.0 is focused on changing our application
    stacks from client-server to a decentralized Web. With decentralization, the risk
    of common security breaches could be reduced due to the decentralization of data
    distribution.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链被认为能够提供技术优势，因为它具有去中心化的能力。Web 3.0 旨在将我们的应用堆栈从客户端服务器转变为去中心化的 Web。通过去中心化，由于数据分布的去中心化，常见的安全漏洞风险可能会降低。
- en: 'From an application-layer perspective, developers would need to consider dapps,
    business logic, application services, and even the user interfaces to integrate.  ####
    ETHEREUM GAS'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '从应用层面来看，开发人员需要考虑整合 dapps、业务逻辑、应用服务，甚至用户界面。  #### 以太坊 GAS'
- en: Ether, the native token of the Ethereum blockchain, is used to pay for transaction
    fees, miner rewards, and other services performed on the network.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊区块链的本地代币是以太币，用于支付交易费用、矿工奖励和在网络上执行的其他服务。
- en: To use the Ethereum network, you must pay with what is known as *gas*. Gas is
    a measurement roughly equivalent to computational steps for Ethereum. Every transaction
    is required to include a gas limit and a fee that it is willing to pay per gas.
    The blockchain miners have the choice of including the transaction and collecting
    the fee or not. Every operation has a gas expenditure on an Ethereum Virtual Machine
    (EVM), and that gas expenditure can be controlled from a cost perspective.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用以太坊网络，你必须支付所谓的 *gas*。Gas 是以太坊中大致等效于计算步骤的度量单位。每笔交易都需要包含一个 gas 限制和一笔愿意支付的每单位
    gas 的费用。区块链矿工可以选择包含交易并收取费用，也可以选择不包含。每个操作在以太坊虚拟机（EVM）上都有一个 gas 消耗，并且可以从成本的角度进行控制。
- en: The price of gas is the amount of ether you are willing to spend on every unit
    of gas. This gas price is similar to an auction limit where you can determine
    what you get and when you get it.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Gas 的价格是你愿意为每单位 gas 而花费的以太币数量。这个 gas 价格类似于一个拍卖限制，你可以确定你得到什么以及何时得到。
- en: Comparatively, if you are familiar with AWS EC2 virtual machines, then you may
    have used what are called *spot instances*. Spot instances in AWS are virtual
    machine instances that you can run programs on at a lower cost.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，如果你熟悉 AWS EC2 虚拟机，那么你可能已经使用过所谓的 *spot instances*。AWS 中的 spot instances
    是可以以较低成本运行程序的虚拟机实例。
- en: '[Figure 10.3](#c10-fig-0003) shows the main resource (`[ethgasstation.info](http://ethgasstation.info)`)
    for estimating gas resource costs on the Ethereum network.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10.3](#c10-fig-0003) 显示了估算以太坊网络 gas 资源成本的主要资源（[ethgasstation.info](http://ethgasstation.info)）。'
- en: '![Screen capture depicting ethgasstation.info web page.](images/c10f003.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![屏幕截图显示 ethgasstation.info 网页。](images/c10f003.png)'
- en: '[**FIGURE 10.3**](#R_c10-fig-0003) ETH gas station'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '[**图 10.3**](#R_c10-fig-0003) 以太坊 gas 站'
- en: Note that the more important it is to process the transaction, the higher the
    price. Essentially, the more gas you pay for, the faster your services execute.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，处理交易越重要，价格就越高。基本上，你支付的 gas 越多，你的服务执行速度就越快。
- en: 'One common concern around the gas model is that because it''s an estimate of
    resources, loops should be avoided. Avoiding loops can be a challenge to estimate
    since if your application scales or your user base grows, then the costs could
    skyrocket. Loops in Ethereum are similar to an all-you-can-eat buffet and need
    to be avoided.  #### ETHEREUM VIRTUAL MACHINE'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '围绕 gas 模型的一个常见关注点是，因为它是资源的估计，所以应该避免循环。避免循环可能会很难估计，因为如果你的应用程序扩展或你的用户群增长，那么成本可能会飙升。以太坊中的循环类似于无限自助餐，需要避免。  ####
    以太坊虚拟机'
- en: When developing on Ethereum, it is important to understand how the EVM has been
    designed and enabled for the Ethereum blockchain. For example, smart contracts
    are written in a smart contract programming language, such as Solidity, and then
    compiled into what is known as *bytecode*.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在以太坊上开发时，了解 EVM 是如何为以太坊区块链设计和启用的至关重要。例如，智能合约是用智能合约编程语言（如 Solidity）编写的，然后编译成所谓的
    *bytecode*。
- en: Bytecode enables what an EVM can read and execute. The smart contract that is
    rolled out is on every node of the network, runs the EVM, and executes the same
    instructions.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 字节码使得 EVM 能够读取和执行。部署的智能合约存在于网络的每个节点上，运行 EVM，并执行相同的指令。
- en: The EVM not only provides amazing value to enterprises and their users but also
    enables the development of potentially thousands of different applications all
    on one platform.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: The Ethereum blockchain is deterministic, meaning that the same input will produce
    the same output. This reduces the complexity of the programming involved and can
    remove numerous manual mistakes.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 10.4](#c10-fig-0004) shows the development and deployment process on
    an Ethereum EVM at a high level. A smart contract was developed in Solidity. We
    would compile our program and then deploy on the EVM.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '![Flow diagram depicting EVM development and deployment.](images/c10f004.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
- en: '[**FIGURE 10.4**](#R_c10-fig-0004) EVM development and deployment  ### Ethereum
    Ecosystem'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum has a solid and well-provisioned development system.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Solidity is the development language that is used to create Ethereum smart contracts.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Ethereum wallet is used for accessing Ethereum tokens, which are used to
    pay fees for the usage of the Ethereum resources.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testnets are used for the developers to deploy code on a test network away from
    the mainnet.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test ether is created to pay transaction fees on various testnets.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Development environments are provided for the building of smart contracts.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Truffle framework is a widely accepted development environment, testing
    framework, and asset pipeline for Ethereum.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '#### ETHER UNITS'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Ether is broken down into units or denominations. A *gwei* is a unit of Ethereum
    coin used to calculate transaction fees. For example, one Ethereum coin is worth
    1 billion Gwei.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 10.2](#c10-tbl-0002) shows the breakdown of the Ether units into the
    denominations.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[**TABLE 10.2**](#R_c10-tbl-0002): Ether Units'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '| UNIT | WEI VALUE | WEI |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
- en: '| Wei | 1 wei | 1 |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
- en: '| Kwie (babbage) | 1e3 wei | 1,000 |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
- en: '| Mwie (lovelace) | 1e6 wei | 1,000,000 |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
- en: '| Gwie (shannon) | 1e9 wei | 1,000,000,000 |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
- en: '| Microether (szabo) | 1e12 wei | 1,000,000,000,000 |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
- en: '| Milliether (finney) | 1e15 wei | 1,000,000,000,000,000 |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
- en: '| Ether | 1e18 wei | 1,000,000,000,000,000,000 |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
- en: 'For more information on the Ethereum denominations, visit `[http://ethdocs.org/en/latest/ether.html](http://ethdocs.org/en/latest/ether.html)`.  ####
    METAMASK'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: MetaMask is an inline Internet browser bridge that facilitates significant efficiencies
    around development and testing. For example, developers can run Ethereum decentralized
    applications (dapps) right in the Internet browser (Chrome), rather than having
    to run a full Ethereum node locally. By using MetaMask, a developer can control
    both CPU utilization as well storage space requirements on their laptop, desktop,
    or server.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: A full node would require more than 2 TB of data storage, whereas MetaMask is
    stored in your Internet browser. MetaMask has an ERC-20-compatible wallet and
    provides privacy and security tools to help prevent phishing.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Using MetaMask makes Ethereum development much more simplified around key management
    since it also encrypts the user's key locally and then requires the user to confirm
    the key. After confirming, the user signs the transactions/messages and then relays
    them to the Ethereum blockchain.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: MetaMask includes a secure identity vault, providing a user interface to manage
    your identities on different sites and sign blockchain transactions. MetaMask
    could also be considered a “zero client.” Zero clients run in the browser in JavaScript.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Use MetaMask for confirming your transaction's
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Balance
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gas limit
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gas price
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Figure 10.5](#c10-fig-0005) shows the initial menu of a MetaMask browser login
    from Chrome. You can see contract interactions that used micro instances of gas
    usage. Micro gas usage is considered to be less than a gwei of gas units.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '![Screen capture depicting MetaMask browser login from Chrome.](images/c10f005.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
- en: '[**FIGURE 10.5**](#R_c10-fig-0005) MetaMask'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'You can download MetaMask via a browser extension in Chrome or from `[https://metamask.io/](https://metamask.io/)`.
    Note that you should never download MetaMask from a third-party site due to the
    likelihood that the version has been tampered with or is malware.  #### MIST'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Mist has been the browser for decentralized web apps and has recently been announced
    to be deprecated. However, it is still widely used, and therefore some discussion
    on it makes sense.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Mist is an Ethereum browser where you get a web browser with direct Web3 access.
    Mist is a full node, so you don't have to connect to a third-party node. This
    is different from MetaMask in the sense that with Mist you are downloading a full
    node. In MetaMask, you do not download the full blockchain to your node (full
    node).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: A full node is where the node downloads locally the full blockchain that is
    the current world state. This will take up significant resources on most average
    personal computers, so ensure that you are not already resource challenged.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Another important note is that if you only need a wallet, then don't use Mist.
    Use MetaMask instead or even MyEtherWallet.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'You can download Mist from `[https://github.com/ethereum/mist](https://github.com/ethereum/mist)`.  ####
    PARITY'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Parity is a lightweight browser-based wallet that gives users access to decentralized
    applications and currencies on Ethereum. Parity is an implementation written in
    Rust and is one of the most common wallet implementations used in the Ethereum
    network.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'Parity comes with an extensive built-in Ethereum wallet and fully functional
    dapp environment. Parity has a Web3 dapp browser and is supported on Linux, macOS,
    and Windows.  #### GETH ETHEREUM'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Geth Ethereum is an implementation of Ethereum written in the Go programming
    language. To use Geth, you need to install the command-line interface and interact
    with a full node in Go.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'Geth is supported on various platforms such as Linux, macOS, and Windows. Geth
    is also built to be flexible in how you install it, which can be from a package
    manager, containers, or even stand-alone builds. Geth allows you to take part
    in the Ethereum mainnet and perform a number of tasks on the Ethereum blockchain,
    including the following:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Mining ether for profit
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transferring funds between Ethereum wallet addresses
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the block history on the blockchain explorer
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating smart contracts and dapps
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Geth is available for download at `[https://github.com/ethereum/go-ethereum/wiki/Geth](https://github.com/ethereum/go-ethereum/wiki/Geth)`.  ###
    Ethereum Networks'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: In Ethereum everyone can start their own blockchain based on the Ethereum protocol.
    We have a mainnet, which is the production blockchain network, and we have testing
    or development networks, which are exactly what they sound like.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: You can also deploy a private Ethereum network, or you can connect to any various
    networks that are available, such as Ropsten. This means the Ethereum mainnet
    can be replicated in a way that it behaves the same way the real mainnet does.
    The benefit is that it does not require any real financial resources from the
    developer community.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 'These “testnet” networks are for testing features and functions with your Ethereum
    smart contracts. These networks, which use a network ID, can be a moving target,
    so check the addresses routinely. The best resource to keep track of these Ethereum
    networks is the Ethereum Stack Exchange, available here:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '`[https://ethereum.stackexchange.com/questions/17051/how-to-select-a-network-id-or-is-there-a-list-of-network-ids/17101#17101](https://ethereum.stackexchange.com/questions/17051/how-to-select-a-network-id-or-is-there-a-list-of-network-ids/17101#17101)`'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Note also that not every testnet is supported in the same way, and generally
    developers tend to stick with what they are comfortable with.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Testing your smart contracts locally with MetaMask is expected. One more area
    of testing your smart contracts is to extend the test to a testnet with MetaMask.
    For example, Developers could develop locally and test to any number of supported
    testnets or the mainnet.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: As shown in [Figure 10.6](#c10-fig-0006), four main testnets are supported.
    The default network setting is the mainnet with MetaMask. Ethereum best practices
    dictate to develop first locally, and then developers would want to identify which
    testnet we will use to test the application. The supported testnets with MetaMask
    include Ropsten, Kovan, Rinkeby, and Goerli. We can also create a custom remote
    procedure call (RPC) to test against an on-premises blockchain.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '![Screen capture depicting MetaMask networks listed.](images/c10f006.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
- en: '[**FIGURE 10.6**](#R_c10-fig-0006) MetaMask networks'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: In the figure, you can see that Main Ethereum Network is the default network.
    When you change from the mainnet to the testnet, you need to ensure that you have
    test ether to perform application testing.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在图中，您可以看到 Main Ethereum Network 是默认网络。当您从主网切换到测试网络时，您需要确保您有足够的测试以太来执行应用程序测试。
- en: '#### ETHEREUM METAMASK FAUCET'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 以太坊 MetaMask 水龙头'
- en: When testing your Ethereum application on a testnet, you need to obtain what
    is known as test ether for the testnets. Test ether is essentially free ether
    to use only on the testnet to perform your application testing. To request your
    test Ether, you need to go to an Ethereum faucet.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试以太坊应用程序上进行测试时，您需要获取称为测试以太的测试网络。测试以太本质上是免费的以太，仅可在测试网络上使用以执行应用程序测试。要请求您的测试以太，您需要前往以太坊水龙头。
- en: An Ethereum *faucet* is an online platform that rewards users with small amounts
    of ether (ETH) for completing a variety of microtasks such as posting social media
    notices. In return, the requester receives test ether to use on the testnet.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊 *水龙头* 是一个在线平台，为完成各种微任务（如发布社交媒体通知）的用户提供少量以太（ETH）作为奖励。作为回报，请求者在测试网络上获得测试以太。
- en: To use the Ethereum MetaMask faucet, you need to have MetaMask installed and
    enabled in your browser. If you do not have MetaMask, then when you go to the
    Ethereum faucet, you would receive an error stating you need to have MetaMask
    installed and enabled.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用以太坊 MetaMask 水龙头，您需要在浏览器中安装并启用 MetaMask。如果您没有安装 MetaMask，则在前往以太坊水龙头时，您将收到一条错误消息，指出您需要安装并启用
    MetaMask。
- en: 'To install MetaMask, go here:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 MetaMask，请访问此处：
- en: '`[https://chrome.google.com/webstore/detail/metamask/nkbihfbeogaeaoehlefnkodbefgpgknn?hl=en](https://chrome.google.com/webstore/detail/metamask/nkbihfbeogaeaoehlefnkodbefgpgknn?hl=en)`'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`[https://chrome.google.com/webstore/detail/metamask/nkbihfbeogaeaoehlefnkodbefgpgknn?hl=en](https://chrome.google.com/webstore/detail/metamask/nkbihfbeogaeaoehlefnkodbefgpgknn?hl=en)`'
- en: After installing the Chrome extension and enabling it from the extension menu
    in Chrome, you can go to `[https://faucet.metamask.io/](https://faucet.metamask.io/)`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Chrome 扩展并在 Chrome 的扩展菜单中启用后，您可以访问 `[https://faucet.metamask.io/](https://faucet.metamask.io/)`。
- en: '[Figure 10.7](#c10-fig-0007) shows the MetaMask Ether Faucet. If you want to
    obtain some test ether to run on the Ropsten testnet, select Request 1 Ether From
    Faucet.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10.7](#c10-fig-0007) 显示了 MetaMask 以太水龙头。如果您想要获得一些测试以太以在 Ropsten 测试网络上运行，选择从水龙头请求
    1 以太。'
- en: '![Screen capture depicting MetaMask ether faucet.](images/c10f007.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![屏幕截图展示 MetaMask 以太水龙头。](images/c10f007.png)'
- en: '[**FIGURE 10.7**](#R_c10-fig-0007) MetaMask ether faucet'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '[**图 10.7**](#R_c10-fig-0007) MetaMask 以太水龙头'
- en: When connecting to the faucet, if your MetaMask is connected to the mainnet,
    then you would receive an error such as “currently on mainnet - please select
    the correct test network.”
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当连接到水龙头时，如果你的 MetaMask 已连接到主网，则会收到类似“当前在主网上 - 请选择正确的测试网络”的错误。
- en: '[Figure 10.8](#c10-fig-0008) shows the Connect Request screen where the developer
    need to connect our MetaMask account. Select Connect and you are on your way to
    receiving test ether.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10.8](#c10-fig-0008) 显示了连接请求屏幕，开发者需要连接我们的 MetaMask 帐户。选择连接，您就可以开始接收测试以太。'
- en: Once the task is done connecting the faucet, the developer then see test transactions
    under the transactions part of the faucet interface, as shown in [Figure 10.9](#c10-fig-0009).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成连接水龙头的任务，开发者就可以在水龙头界面的交易部分看到测试交易，如[图 10.9](#c10-fig-0009)所示。
- en: '[Figure 10.10](#c10-fig-0010) shows the transaction details on Etherscan. When
    you click the link to a transaction, you are brought to the Ropsten testnet on
    Etherscan (`[https://ropsten.etherscan.io/tx/0x4ce3ee99e291a69f35fe00d3a84e291634ef881388adb4f77130b8bf47253017](https://ropsten.etherscan.io/tx/0x4ce3ee99e291a69f35fe00d3a84e291634ef881388adb4f77130b8bf47253017)`).  ####
    RINKEBY TEST FAUCET'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10.10](#c10-fig-0010) 显示了在 Etherscan 上的交易详情。当您点击交易链接时，您将被带到 Ropsten 测试网上的
    Etherscan (`[https://ropsten.etherscan.io/tx/0x4ce3ee99e291a69f35fe00d3a84e291634ef881388adb4f77130b8bf47253017](https://ropsten.etherscan.io/tx/0x4ce3ee99e291a69f35fe00d3a84e291634ef881388adb4f77130b8bf47253017)`)。  ####
    RINKEBY 测试水龙头'
- en: The Rinkeby Ether testnet faucet (`[https://faucet.rinkeby.io/](https://faucet.rinkeby.io/)`)
    was implemented to prevent malicious actors from utilizing all available funds.
    This faucet has a different approach in how to request or obtain test ether. The
    requests are actually done via social media. At the time of writing, a Twitter
    or Facebook account is used to request funds within the permitted limits.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Rinkeby 以太测试网络水龙头（`[https://faucet.rinkeby.io/](https://faucet.rinkeby.io/)`）被实施以防止恶意行为者利用所有可用资金。该水龙头的请求实际上是通过社交媒体完成的。在撰写本文时，Twitter
    或 Facebook 帐户用于请求符合规定限制的资金。
- en: '![Image described by caption and surrounding text.](images/c10f008.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![由标题和周围文本描述的图像。](images/c10f008.png)'
- en: '[**FIGURE 10.8**](#R_c10-fig-0008) Connect Request screen'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '[**图 10.8**](#R_c10-fig-0008) 连接请求屏幕'
- en: '![Screen capture depicting Faucet transactions.](images/c10f009.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![显示水龙头交易的屏幕截图。](images/c10f009.png)'
- en: '[**FIGURE 10.9**](#R_c10-fig-0009) Faucet transactions'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '[**图 10.9**](#R_c10-fig-0009) 水龙头交易'
- en: '[Figure 10.11](#c10-fig-0011) shows a tweet with my Ether address that I want
    to receive the Rinkeby test Ether.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10.11](#c10-fig-0011) 显示了一个带有我的以太地址的推文，我希望收到 Rinkeby 测试以太币。'
- en: 'On the Rinkeby site, just paste your social media link in the box and select
    how much ether you need (see [Figure 10.12](#c10-fig-0012)). Note that this is
    test ether, not something you can trade. It''s that easy: just select Give Me
    Ether, and your account should be credited for the Rinkeby network. You can go
    back to MetaMask and validate the amount was deposited.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rinkeby 网站上，只需将您的社交媒体链接粘贴到框中，然后选择您需要的以太币数量（参见[图 10.12](#c10-fig-0012)）。请注意，这是测试以太币，而不是您可以交易的东西。操作非常简单：只需选择
    Give Me Ether，您的账户应该会在 Rinkeby 网络中存入相应金额。您可以返回 MetaMask 并验证存款金额。
- en: '![Screen capture depicting transaction details.](images/c10f010.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![显示交易详情的屏幕截图。](images/c10f010.png)'
- en: '[**FIGURE 10.10**](#R_c10-fig-0010) Ropsten testnet transaction details'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '[**图 10.10**](#R_c10-fig-0010) Ropsten 测试网络交易详情'
- en: '![Screen capture depicting Requesting test ether for Rinkeby.](images/c10f011.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![显示请求 Rinkeby 测试以太币的屏幕截图。](images/c10f011.png)'
- en: '[**FIGURE 10.11**](#R_c10-fig-0011) Requesting test ether for Rinkeby'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '[**图 10.11**](#R_c10-fig-0011) 请求 Rinkeby 测试以太币'
- en: '![Screen capture depicting Rinkeby Give Me Ether option.](images/c10f012.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![显示 Rinkeby Give Me Ether 选项的屏幕截图。](images/c10f012.png)'
- en: '[**FIGURE 10.12**](#R_c10-fig-0012) Rinkeby Give Me Ether option  ### Ethereum
    Nodes'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '[**图 10.12**](#R_c10-fig-0012) Rinkeby Give Me Ether 选项  ### 以太坊节点'
- en: Developers new to Ethereum should pay attention to the type of nodes deployed.
    One area that makes Ethereum so flexible and powerful is the different node capabilities
    and features.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 初次接触以太坊的开发人员应注意所部署的节点类型。使以太坊如此灵活和强大的一个方面是不同的节点功能和特性。
- en: 'Think of the node types as different use cases. Some are for deploying live
    applications, some are for development, and some are for testing your blockchain
    applications. Ethereum blockchain nodes that are not simulated include the following:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 将节点类型视为不同的用例。有些用于部署实时应用程序，有些用于开发，有些用于测试您的区块链应用程序。未模拟的以太坊区块链节点包括以下内容：
- en: Aleth is the new name of Cpp-ethereum, a collection of C++ libraries and tools
    for Ethereum blockchain. Aleth is supported on Ubuntu, macOS, and Windows.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Aleth 是 Cpp-ethereum 的新名称，它是用于以太坊区块链的一组 C++ 库和工具。Aleth 在 Ubuntu、macOS 和 Windows
    上都受支持。
- en: Go-Ethereum (GETH) is one of the three original implementations of the Ethereum
    protocol. It is written in Go, is a fully open source, and is licensed under the
    GNU LGPL v3\. It is supported as a stand-alone client, or you can install libraries.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go-Ethereum（GETH）是以太坊协议的三个原始实现之一。它用 Go 编写，是完全开源的，根据 GNU LGPL v3 许可。它可以作为独立客户端支持，或者您可以安装库。
- en: 'Parity is an Ethereum client and is written in the Rust language. Parity is
    a full node with the following node options: Full Working Node, Light, Warp, Full
    Node, or Archive node.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Parity 是以太坊客户端，使用 Rust 语言编写。Parity 是具有以下节点选项的完整节点：完整工作节点，轻节点，Warp，完整节点或存档节点。
- en: 'We can use simulations as well to mimic the real blockchain for development
    purposes. In-memory blockchain simulations for rapid development include the following:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用模拟来模仿真实的区块链以进行开发。用于快速开发的内存中区块链模拟包括以下内容：
- en: TestRPC, which is the Ethereum blockchain simulator
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TestRPC，即以太坊区块链模拟器
- en: Ganache, which allows you to create a private blockchain for simulation and
    which uses the Ganache CLI, which then uses Ethereum's to simulate full client
    behavior
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ganache，允许您为模拟创建私有区块链，使用 Ganache CLI，并使用以太坊来模拟完整的客户端行为
- en: Truffle Developer Console, which uses Ganache as part of the Truffle suite
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Truffle 开发者控制台，该控制台使用 Ganache 作为 Truffle 套件的一部分
- en: Clients can gain access to the blockchain in several convenient ways.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端可以通过几种便捷的方式访问区块链。
- en: MetaMask browser plugin through Infura
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 Infura 的 MetaMask 浏览器插件
- en: StatusIM Android or with iOS app through Infura
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: StatusIM Android 或通过 Infura 使用 iOS 应用程序
- en: Status IM is an application that combines a messenger, a crypto wallet, and
    the Web3 browser. You can find information about it at `[https://status.im/](https://status.im/)`.
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Status IM 是一个应用程序，它结合了信使、加密钱包和 Web3 浏览器。您可以在 `[https://status.im/](https://status.im/)`
    找到有关它的信息。
- en: Infura is a development suite that provides an instant, scalable API access
    to the Ethereum and IPFS networks. For more information, visit `[https://infura.io/](https://infura.io/)`.
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Infura 是一个提供即时、可扩展的以太坊和 IPFS 网络 API 访问的开发套件。有关更多信息，请访问 `[https://infura.io/](https://infura.io/)`。
- en: MIST dapp browser with integrated Geth
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MIST dapp 浏览器与集成的 Geth
- en: There are some simple ways to get started running a private blockchain test.
    For example, you are considering using Truffle there are three typical steps.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些简单的方法可以开始运行私有区块链测试。例如，如果您考虑使用 Truffle，则有三个典型步骤。
- en: Log in and then spin up a Truffle project. The project needs to lay out the
    implicit structure of your project. You can run the test on the mainnet, on Ganache
    as a private test blockchain.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录然后启动一个 Truffle 项目。该项目需要布置您项目的隐含结构。您可以在主网络上、在 Ganache 作为私有测试区块链上运行测试。
- en: Run the deployment file. You would point your project either to use Ganache
    or to use the mainnet network.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行部署文件。您可以将项目指向使用 Ganache 或使用主网络网络。
- en: 'Run the `truffle` migrate command. This will automatically run `truffle` compile,
    which will deploy the smart contracts on the network specified.  ### Solidity
    Programming Language'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `truffle` 迁移命令。这将自动运行 `truffle` 编译，该命令将在指定的网络上部署智能合约。### Solidity 编程语言
- en: Ethereum-based applications and smart contracts are written in Solidity, a language
    specifically designed to utilize the EVM.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 基于以太坊的应用程序和智能合约是用 Solidity 编写的，这是一种专门设计用于利用 EVM 的语言。
- en: Solidity, which was proposed in August 2014 by Dr. Gavin Wood, is similar to
    C. It is also similar to JavaScript, although it uses a whole new framework. Developers
    versed in JavaScript will have only a small knowledge gap to overcome. JavaScript
    is a universal language for the Web and is being used in a large number of applications.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: Solidity 是由 Gavin Wood 博士于 2014 年 8 月提出的一种类似于 C 的语言。它也类似于 JavaScript，尽管它使用了一个全新的框架。熟悉
    JavaScript 的开发人员只需要克服一小部分知识差距。JavaScript 是 Web 的通用语言，在大量应用程序中使用。
- en: 'Solidity is also similar to object-oriented languages like C++ and C#, whereas
    JavaScript is based on HTML and influenced by languages such as Self and Scheme.
    When it comes to handling complex data structures, Solidity is similar to Java
    in many respects. Solidity is designed specifically for Ethereum applications
    and runs only on the Ethereum blockchain.  ### Ethereum APIs'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: Solidity 也类似于面向对象的语言如 C++ 和 C#，而 JavaScript 基于 HTML 并受到诸如 Self 和 Scheme 的语言的影响。在处理复杂数据结构时，Solidity
    在许多方面类似于 Java。Solidity 是专门为以太坊应用设计的，并且仅在以太坊区块链上运行。### 以太坊 API
- en: Ethereum uses JSON, a lightweight data-interchange format, for its API library.
    It can represent numbers, strings, ordered sequences of values, and collections
    of name-value pairs.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊使用 JSON，一种轻量级的数据交换格式，用于其 API 库。它可以表示数字、字符串、有序值序列和名称-值对的集合。
- en: Application programming interfaces (APIs) are used to interact with the blockchain
    network. APIs are meant to provide a rapid on-ramp for developers. They are also
    referred to as *endpoints*.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序编程接口 (API) 用于与区块链网络进行交互。API 旨在为开发人员提供快速的入门。它们也被称为 *端点*。
- en: To talk to an Ethereum node from inside a JavaScript application, use the web3.js
    library, which gives a convenient interface for the RPC methods. For example,
    if you wanted to have your application access the Ethereum blockchain with Etherscan,
    you would want an API for that. The API for Etherscan is located at `[https://etherscan.io/apis](https://etherscan.io/apis)`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 要从 JavaScript 应用程序内部与以太坊节点通信，请使用 web3.js 库，该库为 RPC 方法提供了便捷的接口。例如，如果您希望应用程序访问具有
    Etherscan 的以太坊区块链，您将需要一个 API。Etherscan 的 API 位于 `[https://etherscan.io/apis](https://etherscan.io/apis)`。
- en: '#### REMIX'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '#### REMIX'
- en: Remix (`[https://remix.ethereum.org/](https://remix.ethereum.org/)`), also known
    as the Solidity browser, is a browser-based IDE that was built by the Ethereum
    development team to address ease of development. The Remix IDE is used to write,
    compile, and debug Solidity code.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: Remix（`[https://remix.ethereum.org/](https://remix.ethereum.org/)`），也称为 Solidity
    浏览器，是一个基于浏览器的 IDE，由以太坊开发团队构建，用于解决开发的便利性问题。Remix IDE 用于编写、编译和调试 Solidity 代码。
- en: Remix is more than just a powerful, open source development tool that enables
    you to write Solidity contracts straight from your browser. Remix is also an online
    learning solution since it enables developers to really get up to speed quickly
    around smart contract development. Remix supports development both locally and
    online.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: Remix 不仅是一个功能强大的开源开发工具，让您可以直接从浏览器中编写 Solidity 合约。Remix 还是一种在线学习解决方案，因为它使开发人员能够快速掌握智能合约开发。Remix
    支持本地和在线开发。
- en: Remix has what developers would consider modules. A module is basically a plugin
    that can be added to the development environment that is being used in Remix.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: Remix 具有开发者认为的模块。模块基本上是可以添加到 Remix 中使用的开发环境的插件。
- en: '![Screen capture depicting Remix interface.](images/c10f013.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![屏幕截图显示 Remix 界面。](images/c10f013.png)'
- en: '[**FIGURE 10.13**](#R_c10-fig-0013) Remix interface'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '[**FIGURE 10.13**](#R_c10-fig-0013) Remix 界面'
- en: '[Figure 10.13](#c10-fig-0013) shows the Remix interface, which was recently
    updated at the time of writing.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '[Figure 10.13](#c10-fig-0013) 显示了撰写时最近更新的 Remix 界面。'
- en: Remix includes a plugin for Etherscan Contract Verification. You can use the
    tool to verify that the code deployed with a contract is valid and to publish
    the code on Etherscan.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: Remix 包含一个用于 Etherscan 合约验证的插件。您可以使用该工具验证使用合约部署的代码是否有效，并在 Etherscan 上发布代码。
- en: Another useful feature is that you can choose your compiler version and also
    correlate this version to a nightly build. You can simply compile your code with
    different compilers and validate how these builds work out.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的功能是您可以选择您的编译器版本，并将此版本与夜间构建相关联。您可以简单地使用不同的编译器编译您的代码，并验证这些构建如何运行。
- en: '[Figure 10.14](#c10-fig-0014) shows an example of running test code in a specific
    version of the compiler and then receiving a green checkmark on the left sidebar
    indicating that the code was compiled successfully.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '[Figure 10.14](#c10-fig-0014) 显示了在特定版本编译器中运行测试代码的示例，然后在左侧边栏上接收到编译成功的绿色勾号。'
- en: '![Screen capture depicting Compile successful message in an example of running
    test code.](images/c10f014.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![屏幕截图显示编译成功的消息，示例中的测试代码。](images/c10f014.png)'
- en: '[**FIGURE 10.14**](#R_c10-fig-0014) Compile successful'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '[**FIGURE 10.14**](#R_c10-fig-0014) 编译成功'
- en: Another great feature is that you can push your code to Ethereum Swarm. Ethereum
    Swarm is a peer-to-peer (P2P) file storage distributed network that allows the
    distributed and encrypted storage of users' data.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个很棒的功能是你可以将你的代码推送到以太坊 Swarm。以太坊 Swarm 是一个点对点（P2P）文件存储分布式网络，允许用户数据的分布式和加密存储。
- en: 'Remix is a powerful yet complex tool since the ecosystem has grown significantly.
    It is the best way to learn Solidity for most developers wanting to develop in
    Ethereum.  #### VYPER'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 'Remix 是一个功能强大但复杂的工具，因为生态系统已经显著增长。对于大多数想要在以太坊上开发的开发者来说，这是学习 Solidity 的最佳方式。  ####
    VYPER'
- en: Vyper is a contract-oriented Pythonic programming language that specifically
    targets the EVM. It is still an experimental programming language, but it compiles
    down to EVM bytecode, just as does Solidity.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: Vyper 是一种面向合约的 Pythonic 编程语言，专门针对 EVM。它仍然是一种实验性编程语言，但它编译成了 EVM 字节码，就像 Solidity
    一样。
- en: Vyper is designed to be a simple-to-create and easy-to-comprehend smart contract
    engine that provides more transparency for all parties involved.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: Vyper 的设计目标是成为一个简单易懂的智能合约引擎，为所有参与方提供更多的透明度。
- en: 'Vyper looks logically similar to Solidity and has some similarities to Python
    as well. Vyper is still in beta mode at the time of writing, so I won''t cover
    it in detail.  #### WEB3-ETH'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 'Vyper 在逻辑上与 Solidity 相似，也与 Python 有一些相似之处。Vyper 在撰写本文时仍处于测试阶段，因此我不会详细介绍它。  ####
    WEB3-ETH'
- en: Web3-eth is used for blockchain and smart contract development in Ethereum.
    The library is Web3, and I like to consider it an “on-ramp” to Ethereum development
    and the world of decentralized applications.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: Web3-eth 用于以太坊的区块链和智能合约开发。该库是 Web3，我喜欢将其视为进入以太坊开发和去中心化应用程序世界的“入口”。
- en: You can use Web3-eth with Ganache, for example, and create test accounts to
    test your smart contracts. You can specify ether to transfer from and to your
    accounts. There are many more features about Web3-eth that support the rapid development
    of decentralized applications.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: Truffle，这是个 IDE
- en: The main challenge with Web3 is that if you're not careful with your development,
    you may actually be using a version that has some differences in how you would
    interact with the libraries.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '| 原型 | 原型 |'
- en: 'After downloading the Web3 library, you would simply initialize your application
    node by using the following command:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: Truffle Suite 本质上是一套 dapp 解决方案。以下解决方案是 Truffle Suite 的一部分：
- en: '[PRE0]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Before doing anything, refer to the web3 documentation at `[https://web3js.readthedocs.io/en/1.0/getting-started.html](https://web3js.readthedocs.io/en/1.0/getting-started.html)`.  ###
    Ethereum Testing'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 科文
- en: Software development generally has a flow that has been widely accepted, and
    this is true in the world of blockchain development as well. The main differences
    are that in blockchain the steps are different, and comparatively there is an
    additional step.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '| --- | --- |'
- en: '[Table 10.3](#c10-tbl-0003) compares the generally accepted steps in traditional
    software development to blockchain development.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解的主要点是，在区块链中有软件开发阶段，我们必须以不同的方式来对待它们。区块链部署智能合约，因此，开发起来可能比典型的企业应用程序简单。但是，需要注意的主要区别是，一旦部署到某些区块链上，智能合约是不可变的。
- en: '[**TABLE 10.3**](#R_c10-tbl-0003): Traditional vs. Blockchain Development'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 10.3](#c10-tbl-0003) 比较了传统软件开发中普遍接受的步骤与区块链开发。'
- en: '| TRADITIONAL SOFTWARE DEVELOPMENT PHASE | BLOCKCHAIN SOFTWARE DEVELOPMENT
    PHASE |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '在做任何事情之前，请参考 [web3 文档](https://web3js.readthedocs.io/en/1.0/getting-started.html)。
    ### 以太坊测试'
- en: '| --- | --- |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: 尽管测试网络用于测试，但仍需要使用以太，尽管是测试以太，用于维护节点。你可以通过几种方式获得测试以太，例如通过在测试网络上进行挖矿或使用水龙头。
- en: '| Prototype | Prototype |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| 生产 | 私有链测试 |'
- en: '| Alpha/Beta | Framework testing |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: 下载 Web3 库后，你只需使用以下命令初始化你的应用节点：
- en: '| Production | Private chain testing |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| 更新发布 | 测试网 |'
- en: '| Update release | Testnet |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: 你可以使用 Web3-eth 与 Ganache，例如，创建测试账户来测试你的智能合约。你可以指定以太从哪个账户转移至哪个账户。还有许多关于支持快速开发去中心化应用的
    Web3-eth 的功能。
- en: '|  | Mainnet |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: Ganache，允许开发者部署个人区块链
- en: The main point to understand is that there are software development phases in
    blockchain, and we must approach them differently. Blockchains deploy smart contracts
    and therefore, will likely be simpler to develop than typical enterprise applications.
    However, the main difference to be aware of is that smart contracts, once deployed
    to some blockchains, are immutable.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在将你的应用部署到主网之前，你会想在以太坊测试网络上进行测试。以下测试网络可直接从 MetaMask 获取：
- en: '#### ETHEREUM TESTNETS'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 'Drizzle，包含所有所需的前端库  #### Truffle'
- en: 'Before deploying your application on the mainnet, you would want to test it
    on the Ethereum testnet(s). The following testnets are available directly from
    MetaMask:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 瑞克比
- en: Rikeby
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件开发通常有一个被广泛接受的流程，这在区块链开发的世界也是如此。主要的区别在于，在区块链中步骤不同，而且相比之下还有一个额外的步骤。
- en: Ropsten
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '#### 以太坊测试网络'
- en: Kovan
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web3 的主要挑战在于，如果你在开发中不小心，可能实际上使用的是一种与库互动方式有所不同的版本。
- en: 'The testnets, even though for testing, require the use of ether, albeit test
    ether, which is used to maintain the nodes. You can gain the test ether in several
    ways, such as by mining the testnet or by using a faucet.  #### TRUFFLE SUITE'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '#### Truffle Suite'
- en: 'The Truffle Suite is essentially a suite of dapp solutions. The following solutions
    are part of the Truffle Suite:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: Ropsten
- en: Truffle, which is the IDE
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '|  | 主网 |'
- en: Ganache, which allows developers to deploy a personal blockchain
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '| Alpha/Beta | 框架测试 |'
- en: 'Drizzle, which contains all the needed front-end libraries  #### TRUFFLE'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[**表 10.3**](#R_c10-tbl-0003)：传统与区块链开发'
- en: Truffle is a developer environment, testing framework, and asset pipeline for
    blockchains. Truffle is essentially a JavaScript library that's based on NodeJS.
    Truffle is immensely popular and growing in usage monthly. Truffle was developed
    by Consensus.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: Truffle 是一个用于区块链的开发环境、测试框架和资产流水线。Truffle 本质上是一个基于 NodeJS 的 JavaScript 库。Truffle
    非常受欢迎，每月使用量都在增长。Truffle 是由 Consensus 开发的。
- en: Truffle allows developers to spin up smart contract projects at the click of
    a button and provides you with a project structure, files, and directories that
    make deployment and testing much easier (or else you would have to configure these
    yourself).
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: To install and run Truffle, you first need to install Node and the Node Package
    Manager (NPM). This can be found at `[https://nodejs.org/en/40T](https://nodejs.org/en/40T)`.
    After installing Node, you can go to any command-line interface (Terminal on Mac/Linux
    or PowerShell on Windows) and interact with npm.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: One interesting project from the Truffle framework is Truffle Box. These are
    preconfigured “mini scaffolding projects” that make starting a new distributed
    application much more streamlined. The list of truffle boxes can be found at `[http://truffleframework.com/boxes/40T](http://truffleframework.com/boxes/40T)`.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: Use a baseline JavaScript, React, Angular, or other language to start off with
    a Truffle box.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: You can view the number of downloads for the suite at the dashboard (`[https://truffleframework.com/dashboard](https://truffleframework.com/dashboard)`).
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 10.15](#c10-fig-0015) shows the Truffle Suite Activity Dashboard.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: 'Truffle Suite can be downloaded from `[https://truffleframework.com/](https://truffleframework.com/)`.  ####
    GANACHE'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: 'Ganache CLI is the latest version of TestRPC: a fast and customizable blockchain
    emulator. It allows you to make calls to the blockchain without the overhead of
    running an actual Ethereum node. Transactions are mined instantly.'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: You can think of Ganache as a personal blockchain for Ethereum development you
    can use to deploy contracts, develop your applications, and run tests. It is available
    as both a desktop application and a command-line tool.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: Ganache is available for Windows, Mac, and Linux. Many developers use Ganache
    to test their smart contracts during development. It provides convenient tools
    such as advanced mining controls and a built-in block explorer. ![Image described
    by caption and surrounding text.](images/c10f015.png)
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '[**FIGURE 10.15**](#R_c10-fig-0015) Truffle Activity Dashboard'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '#### DRIZZLE'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: 'Drizzle is a collection of front-end libraries that make writing dapp front
    ends simple, more efficient, and more predictable. The main core of Drizzle is
    based on a Redux store, and you access the development tools for Redux. The Drizzle
    package takes care of synchronization of your Ethereum-based services.  #### TRUFFLE
    OR GANACHE?'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: 'Deciding when to use Truffle or Ganache can be a bit confusing because the
    solutions have some overlap in capabilities. Here are some tips to help you decide
    whether to use Truffle or Ganache:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: Truffle will enable you to develop, test, and deploy your dapp, and it has integration
    with Ganache.
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ganache is part of the Truffle ecosystem, and you would use Ganache for the
    development of your dapps. Ganache essentially mimics a real blockchain. You could
    also pass on using Ganache and use Truffle to tie into a public testnet or deploy
    locally.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once the dapps are developed and tested, you then deploy them on an Ethereum
    client using Geth or Parity.  #### OPEN ZEPPELIN'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open Zeppelin is a well-formatted and prevalent framework of reusable smart
    contracts for Ethereum and other EVM-based blockchains. Open Zeppelin is a library
    for secure smart contract development.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: It provides implementations of standards like ERC-20 and ERC-721, which you
    can deploy as-is or extend to suit your needs, as well as Solidity components
    to build custom contracts and more complex decentralized systems.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: The reusable smart contracts are useful since they have been reviewed by peers
    and therefore audited. Using a template that would be ready, of course, provides
    benefits such as shortened development time and quicker time to market.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information about Open Zeppelin, visit `[https://openzeppelin.org/](https://openzeppelin.org/)`.  ####
    PRIVATE BLOCKCHAIN TESTING'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: 'One area of interest for developers is to be able to deploy, test, and validate
    an application locally and not have to connect to a VPN. Or perhaps you are developing
    applications and want to ensure specific variables for the networking are available.
    You would want to go with a private deployment such as Ganache.  #### ETHEREUM
    TOKENS'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: Tokens are created to specific standards in Ethereum called the ERC-20 standards.
    Tokens in the Ethereum ecosystem can represent any fungible tradable item such
    as loyalty points, metal certificates, IOUs, coins, etc.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: Tokens implement some basic features in a standard way in most cases, so this
    means that your token would be likely compatible with the Ethereum wallet or any
    other client or contract that uses the same standards.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: 'These tokens will need to follow specific standards, also referred to as *constants*.
    Examples include the following:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: Symbol, which is your token's symbol or ticker
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Name, which is the name you give it
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Total supply, which specifies the number of tokens issued
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decimals, which are the number of decimals used
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The standards are listed at `[Ethereum.org/token](http://ethereum.org/token)`.  ####
    ETHEREUM REQUEST FOR COMMENTS'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: 'An Ethereum request for comments (ERC) is a glorified GitHub issue tracker.
    This is the main point of contact where developers can ask for comments on contracts
    and other issues related to Ethereum proposals. An ERC starts with #1 and increments
    every time a new issue is opened.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find ERCs at `[https://eips.ethereum.org/erc](https://eips.ethereum.org/erc)`.  ####
    ETHEREUM ERC TOKEN (ERC-20)'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: The ERC-20 token contract is the “standard” template to deploy fungible tokens
    on the Ethereum blockchain as a smart contract. The ERC token standard is basically
    a standard interface as well as a sample implementation of the functions necessary
    to create and operate an ERC-20 token.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: 'Ethereum developers need to be very cognizant of how they develop applications.
    One way is to follow the ERC-20 standards. The ERC-20 standards serve several
    purposes, but the main purpose is focused on portability of the contracts.  ####
    ETHEREUM IMPROVEMENT PROPOSALS'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: 'Ethereum Improvement Proposals (EIPs) have the same format as ERCs but are
    used to propose changes in the Ethereum protocol. EIPs serve the same purpose
    as Bitcoin Improvement Proposals (BIPs). BIPs are used to introduce new features
    or information important to Bitcoin. EIPs start with EIP #1 and increment every
    time a new issue is opened.'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: 'To find out more, visit `[https://github.com/ethereum/EIPs](https://github.com/ethereum/EIPs)`.  ##
    Hyperledger Development'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: Developing applications in Hyperledger Fabric has some great benefits. The Hyperledger
    ecosystem is robust and well maintained for an open source project. The Hyperledger
    Project leaves little out for options in development and is clearly the most well-managed
    blockchain project.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: This section provides a broad idea of what a developer in Hyperledger Fabric
    would need to deal with and develop around.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '### Chaincode'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: Chaincode is a smart contract in Hyperledger Fabric and is invoked by a client
    application external to the blockchain network that manages access and modifications
    to a set of key-value pairs in the world state. The world state is the actual
    state of the current blockchain transactions that are recorded immutably.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: Chaincode services are secured and lightweight since the environment is deployed
    as a locked-down, secured container. This container has a set of signed base images
    that contain the secure OS and chaincode language, runtime, and SDK images for
    Golang, Java, and Node.js.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: Every chaincode must implement the chaincode interface, which is what is used
    to provide connections similar to an endpoint in cloud computing. The chaincode
    interface makes it possible for the client application to invoke a function that
    is called in response to the received transaction proposals. Chaincode implements
    the chaincode interface, in particular the `Init` and `Invoke` functions.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '#### INSTALLING CHAINCODE'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: When installing chaincode, you should ensure that you have the Go programming
    language installed first and then set up with the correct configuration requirements
    for your deployment type.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: You will want to make sure that a directory is created for your chaincode application
    as a child directory of `$GOPATH/src/.`
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: The following command will create such a directory called `wiley:code:`
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To enter into the directory, you can use the following command:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To create the source file for the chaincode, use the following command:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]  #### WRITING CHAINCODE CONSIDERATIONS'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: After installing Go and setting up your environment, you then can start developing
    your chaincode.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: Note this book will not be teaching chaincode but is organized to provide insight
    into the tasks developers would need to consider around Hyperledger development.
    Some of these tasks are different from Ethereum and worth noting for hiring managers
    to appreciate.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: The next thing you could do is then implement the init function. The init is
    called during chaincode instantiation and will initialize any data as part of
    the chaincode. Chaincode applications will implement the two functions that would
    be invoked via the invoke function.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: One area of confusion when setting your platform is around the database options.
    You may need to pay attention to the chaincode design if complex queries are based
    on an expected invocation sequence.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: This confusion can occur because an invalid transaction may very well occur
    if you're not aware of the database options for the state data. The state database
    could be written in LevelDB or in CouchDB.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: 'For tutorial information on getting started with chaincode, refer to the following
    site:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: '`[https://hyperledger-fabric.readthedocs.io/en/release-1.4/chaincode.html](https://hyperledger-fabric.readthedocs.io/en/release-1.4/chaincode.html)`  ####
    BLOCKCHAIN PLATFORM EXTENSION'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: The IBM Blockchain Platform Extension for VSCode helps Hyperledger Fabric developers
    to rapidly develop, provision, and test their chaincode. This also could be used
    to test client applications on their local machines. The extension is currently
    supported on Windows 10, Linux, and macOS.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: The extension works by creating a basic smart contract that locally manages
    an example asset in a development language of your choice.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: What is really helpful is that the extension provides all the dependencies that
    are required to deploy your smart contract to an instance of Hyperledger Fabric
    directly. These features enable efficient development for your chaincode on the
    IBM Blockchain service.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: 'To find out more about the VSCode extension, refer to the following site:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '`[https://cloud.ibm.com/docs/services/blockchain?topic=blockchain-develop-vscode](https://cloud.ibm.com/docs/services/blockchain?topic=blockchain-develop-vscode)`  ###
    Hyperledger Fabric Consensus Options'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: Hyperledger Fabric has two consensus options, and it is important to understand
    the difference from a development perspective. You cannot just roll back once
    you deploy your blockchain.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: Solo, which is for development, is a single node with no high availability.
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kafka is the production version that would be deployed on a live blockchain.
    Kafka is as close to a voting-based consensus as you get in Hyperledger.
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As discussed in [Chapter 2](c02.xhtml), consensus methods have different benefits
    but also cons. For example, having more nodes means more time to reach consensus.
    There''s also a trade-off between scalability and performance that developers
    should be aware of. The Hyperledger Fabric white paper on consensus is the main
    starting point. To find out more, see the following site:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: '`[https://www.hyperledger.org/wp-content/uploads/2017/08/Hyperledger_Arch_WG_Paper_1_Consensus.pdf](https://www.hyperledger.org/wp-content/uploads/2017/08/Hyperledger_Arch_WG_Paper_1_Consensus.pdf)`  ###
    Hyperledger Fabric Database Options'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: One of the important things to consider is the power of Hyperledger Fabric with
    the option of its state database. The ledger system in Hyperledger Fabric uses
    LevelDB, which allows concurrent writers to safely insert data into the database
    by providing internal synchronization.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: State database options include LevelDB and CouchDB. LevelDB is the default key-value
    state database embedded in the peer process. CouchDB is an alternative external
    state database that supports binary data.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 10.4](#c10-tbl-0004) shows the options for both the transaction logs
    and the state database.'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: '[**TABLE 10.4**](#R_c10-tbl-0004): Transaction Log and State Database Options'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: '|  | TRANSACTION LOGS | STATE DATA (WORLD STATE) |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-368
  prefs: []
  type: TYPE_TB
- en: '| **Type** | Immutable | Mutable |'
  id: totrans-369
  prefs: []
  type: TYPE_TB
- en: '| **Operations** | Create, retrieve | All CRUD |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
- en: '| **DC** | LevelDB | LevelDB/CouchDB |'
  id: totrans-371
  prefs: []
  type: TYPE_TB
- en: '| **Attitude** | Embedded in peers | Key-value paired (JSON, binary) |'
  id: totrans-372
  prefs: []
  type: TYPE_TB
- en: '| **Query** | Simple | CouchDB for complex (binary) |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
- en: 'It''s important to note that when assets are stored in the form of JSON documents,
    CouchDB allows you to perform complex queries for assets based on the asset state,
    for example. There really is no learning curve since the queries are formatted
    just like in CouchDB''s declarative JSON querying syntax format.  ### Client Applications'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: 'When developing client applications for blockchains, and specifically Hyperledger
    Fabric, there are some important considerations to design for depending on your
    specific use case. These client front-end considerations include the following:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: Secure the REST server via a secure protocol (HTTPS).
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use authentication options such as a passport through Oath or supported platforms.
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use multiuser mode for the REST API service.
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand the complete use case considerations for the blockchain applications.
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the current enterprise key management system (KMS).
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the current software development kits (SDKs) to ensure you're running the
    latest versions of supported components.
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Figure 10.16](#c10-fig-0016) shows the different layers of Hyperledger blockchain
    development. From a development perspective, if you are developing a blockchain
    application that is for the end user, that is considered front-end development.
    In front-end development, there would be development applications, wallets, mobile
    applications, monitoring tools.'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: '![Image described by caption and surrounding text.](images/c10f016.png)'
  id: totrans-383
  prefs: []
  type: TYPE_IMG
- en: '[**FIGURE 10.16**](#R_c10-fig-0016) Front-end application workflow'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: Hyperledger Fabric's business network archive (package) comprises the model
    file, chaincode, access control file, and static query file.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: The native query language can filter results returned by using clearly defined
    criteria. The native query language can also be invoked in transactions to perform
    operations such as an update.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: Blockchain queries are defined in a query file (`.qry`) in the parent directory
    of the business network definition.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: 'Events that occur will create notifications of significant operations on the
    blockchain (e.g., a new block), as well as notifications related to a milestone
    achieved while processing a smart contract/chaincode. The client app can subscribe
    to this event and take appropriate business actions.  ### Fabric REST Services'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: The REST server uses a business network card specified during startup to connect
    to and discover the assets, participants, and transactions within a deployed business
    network. This information visibility is required to generate the REST API. The
    business network card is known as the discovery business network card. By default,
    the discovery business network card is also used to handle all requests to the
    REST API.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: Chaincode Services uses Docker to host (deploy) the chaincode without relying
    on any virtual machine or computer language. Docker provides a secured, lightweight
    method to sandbox chaincode execution. The environment is a “locked-down” and
    secured container, along with a set of signed base images containing secure OS
    and chaincode language, runtime, and SDK images for Golang.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: 'Hyperledger includes the REST and JSON RPC APIs, events, and an SDK for applications
    to communicate with the network.  ### Service Discovery'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: To execute chaincode on peers, to submit transactions to orderers, and to be
    updated about the status of transactions, applications connect to an API exposed
    by an SDK. The discovery service improves this process by having the peers compute
    the needed information dynamically and present it to the SDK in a consumable manner.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: The application is bootstrapped knowing about a group of peers that are trusted
    by the application developer/administrator to provide authentic responses to discovery
    queries.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: 'A good candidate peer that needs to be used by the client application is one
    that is in the same organization.  ### Hyperledger Composer'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: Contributed by IBM and Oxgcains, Hyperledger Composer is an open source application
    development framework that was specifically built for Hyperledger. Composer simplifies
    the creation of Hyperledger Fabric blockchain applications and therefore brings
    efficiencies into the development cycle.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: The Composer tool is aimed at helping users to create blockchain applications
    based on Hyperledger Fabric without needing to know the low-level Go programming
    details that are involved in blockchain networks.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: If you want to build your blockchain application directly on Hyperledger Fabric,
    you have to write your chaincode in Go or Java, which is comparatively different
    from JavaScript because its composer is quite easy to code smart contract using
    a model file (`.cto`) and angular JavaScript.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: Hyperledger Composer primarily uses JavaScript for chaincode development, and
    this has a lower barrier to entry as well.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: Hyperledger Composer uses what's called *connection profiles* to define the
    system to connect to a connection profile, which is a JSON document that acts
    as part of a business network card. The connection profile describes a distinct
    set of components, including peers, orderers, and certificate authorities in a
    Hyperledger Fabric blockchain network. A connection profile is normally created
    by an administrator who understands the network topology.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: You can use queries to get data about the state of the blockchain. Queries are
    defined within a business network and can include variable parameters. Queries
    are sent using the Composer API.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: Events in Composer are defined in the business network definition in the same
    way as participants or assets. Events are emitted by the transaction processor
    function once it has been defined. An event indicates to external systems that
    something important has occurred on the ledger. Applications subscribe to emitted
    events using the Composer client API.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: Developers of the business network can create a set of access controls. Access
    controls are rules that determine which assets participants have access to in
    the business network and the conditions in which they can access them.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: A historian is a specialized type of registry that records successful transactions
    conducted on the business network.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: '#### HYPERLEDGER COMPOSER MODELING LANGUAGE'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: Hyperledger Composer is an object-oriented modeling language that defines the
    domain model for a business.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: 'The modeling language is saved as a `.cto` file. The CTO file contains the
    following:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: A single namespace, in which all resource declarations are implicit
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A set of resource definitions that includes assets, transactions, participants,
    and events
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The option to import resources from other namespaces
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a system namespace that contains base definitions of the asset, event,
    participant, and transactions. These base definitions are abstract types that
    are implicitly extended by all new assets, events, participants, and transactions.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: Events and transactions in the system namespace are defined by an eventID and
    transactionID, respectively, and a timestamp.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: 'The system namespace also includes a historian, which is a specialized registry
    that records successful transactions on the blockchain, as well as the participants
    and identities that submit transaction requests.  #### HYPERLEDGER COMPOSER RESOURCES'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: 'In Composer, resources are considered one of the following:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: Assets, participants, transactions, and events
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enumerated types
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concepts
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example of `Vehicle` as a super-type and `Car` as an asset with
    a set of parts:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In Composer, concepts are abstract classes that are not considered an asset,
    participant, or transaction. Concepts would need to be clearly defined because
    of this abstract quality. A mode of transportation could be a car, motorcycle,
    plane, boat, or any other mode of transport. We need to accommodate the possibility
    that a concept is abstract by adding strings and declaring the concepts to the
    code.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: The following code shows how to identify New York as a string in the program.
    This code is extending the possibility of New York City being either a street,
    a city, or a state in the United States. A concept then is added to address the
    possibility of New York City also being a street, city, or state in Canada.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Other programming areas that Composer can address include arrays, primitives,
    field validators, relationships, imports, and decorators.  #### HYPERLEDGER COMPOSER
    PLAYGROUND'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: Hyperledger Composer Playground, a free sandbox maintained by IBM, provides
    an environment that quickly models and tests a blockchain network. Composer Playground
    has a simple GUI to edit and test the business blockchain network. Playground
    simplifies what is normally a complex blockchain network for running blockchain
    testing.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: There is both an online version and an offline version of Playground. The online
    playground runs the business network in browser memory, and the local playground
    is deployed in Hyperledger Fabric instances.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: We can use Hyperledger Composer or Composer Playground to develop, test, and
    validate our blockchain ideas by deploying a new business network to Hyperledger
    Fabric. Composer is not a live blockchain and is exclusively focused on preproduction
    use cases.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 10.17](#c10-fig-0017) shows the Hyperledger Composer Playground login
    prompt.'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: Composer Playground is currently available at `[https://composer-playground.mybluemix.net/](https://composer-playground.mybluemix.net/)`.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: Hyperledger Fabric v1.4+, which should feature significant improvements to the
    developer experience, will include a new programming model. Note that Composer
    Playground will likely be deprecated in the future, but no clear road map has
    been released at the time of writing.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: '![Screen capture depicting Hyperledger Fabric Playground login.](images/c10f017.png)'
  id: totrans-429
  prefs: []
  type: TYPE_IMG
- en: '[**FIGURE 10.17**](#R_c10-fig-0017) Hyperledger Fabric Playground login  ##
    R3 Corda Development'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: Corda is written in Kotlin and is compatible with any JVM language. Kotlin is
    an odd language to some programmers who prefer Scala, for example. Kotlin does
    have a better type inference, better generics with type variance, and a more modern
    syntax.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: The two most popular languages for Corda development are Java and Kotlin. The
    real key is that it has great flexibility and interoperability with Java in both
    directions in programming perspectives.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: 'R3 Corda is primarily focused on implementing solutions for regulated financial
    services. Therefore, the development of Corda solutions often involves many types
    of financial assets. Some of the common financial assets that are defined in Corda
    contracts include the following:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: Cash
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stocks
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bonds
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Futures
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Credit letters
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Derivatives
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interest rate swaps
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A financial transaction is an agreement between buyer and seller parties to
    exchange one or more asset for payment of monetary value. This is essentially
    the focus of the smart contracts in Corda.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: When developing in Corda, there two main types of assets.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: Fungible assets, which are homogenous and are divisible, mergeable, and interchangeable
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nonfungible assets, which are unique and represent something that is not divisible,
    mergeable, or interchangeable
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I won't cover the business part of the house for the assets, so you may want
    to research more if this is of interest.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: '### Corda Consensus Model'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: 'Consensus in Corda is handled somewhat differently in some respects from other
    blockchains in that the unit of consensus in Corda is the state that can be handled
    in two distinct parts. In other blockchains state is considered less flexible—state
    meaning the current transaction view of the blockchain. Consensus in Corda is
    broken into two distinct parts: consensus over state validity and consensus over
    state uniqueness.'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: '*Consensus over state validity* is when the blockchain members reach certainty
    that a transaction is accepted by the contract''s states and has all the required
    signatures.'
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Consensus over state uniqueness* is when the blockchain members reach certainty
    that the output states created in a transaction are actually unique and not previously
    consumed.'
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Corda has pluggable uniqueness services to improve privacy, scalability, legal-system
    compatibility, and algorithmic agility.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: Pluggable uniqueness services in Corda with the use of shared cryptographic
    hashes ensure that restrictive viewing of transactions provide for the scalability
    and privacy required.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information on the Corda consensus model, refer to the following:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: '`[https://docs.corda.net/releases/release-M9.2/key-concepts-consensus-notaries.html](https://docs.corda.net/releases/release-M9.2/key-concepts-consensus-notaries.html)`  ###
    CorDapps'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: Developing applications in Corda revolves around the CorDapp (Corda distributed
    app) and how you define the business logic. The customer's main objective of any
    CorDapp is to allow participants to reach an agreement about transactions to the
    globally distributed ledger.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: CorDapps achieve this main objective by defining flows (*workflows*) that Corda
    node owners must invoke via RPCs. It is important to note that the core of contracts
    in Corda is an executable program that authenticates changes to all state objects
    in Corda transactions.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: 'CorDapps consist of the following software components:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: States define the facts over how an agreement will be reached.
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Contracts define what constitutes a valid global ledger update.
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Services provide the functions of the node—for example, what the node role is,
    such as a notary.
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flows specify the entire life cycle of state changes by invoking the smart contract
    that is consistent and related to the current state.
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service hubs maintain services and support APIs for accessing and controlling
    many aspects of the Corda platform from within server-side CorDapps code, not
    RPC client-side code.
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Client RPC operations are remote procedure calls.  ### Corda Network and Nodes'
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Corda network consists of a number of machines running nodes, including a
    single node operating as the network map service. These nodes communicate using
    persistent protocols in order to create and validate transactions.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: A Corda network is a connected graph. There is no global broadcast. The network
    maintains point-to-point and nonpersistent connections and supports AMQP/1.0 over
    TLS. Corda runs on a semiprivate permissioned network.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: A Corda node is a process that runs with a Java virtual machine (JVM). The Corda
    node's properties consist of several types of services and support custom functionality
    such as CorDapps.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: Nodes interact with each other following the flow framework, which reflects
    the business logic of the proposed transaction, and the custom functionality,
    which is dictated by the CorDapps. After the flow framework has been verified
    and completed, the transaction is committed to the ledger.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: To set up Corda nodes, you should use the templates provided by Corda. These
    templates are available in Kotlin and Java from GitHub (`[https://github.com/corda](https://github.com/corda)`).
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: 'When you are done setting up the Corda templates, you then would need to set
    up the network with a number of participants (nodes) by configuring the XML file.  ###
    Corda Service Hub'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: Corda nodes have something unique in the blockchain world—a service hub. The
    service hub maintains services and supports APIs for accessing and controlling
    many aspects of the Corda platform. All this is performed from within the server-side
    CorDapps code, not the RPC client-side code.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: Think of the service hub as the starting point for most operations that are
    performed inside a node. The service hub also defines how nodes access services
    internally by three distinct service calls.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: The CorDapps are what actually defines how a node owner interacts with a node.
    Of course, APIs are required to provide for the required operation on a Corda
    node. There are also a full suite of unique API calls that developer would want
    to review and test before deploying an application.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: 'For more on the API categories, refer to the following:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: '`[https://docs.corda.net/api/kotlin/corda/net.corda.core.node/-service-hub/index.html](https://docs.corda.net/api/kotlin/corda/net.corda.core.node/-service-hub/index.html)`  ###
    Corda Doorman'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: Corda networks are semiprivate and have a doorman service that enforces rules
    regarding the information that nodes must provide and the know-your-customer processes
    that they must complete before being admitted to the network.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: 'A node must contact the doorman and provide the required information. The doorman
    will give the node a root-authority-signed TLS certificate from the network''s
    permissioning service.  ### Corda Flows'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: 'Flows are used to model business processes between parties exchanging assets.
    Flows are what would be called a bilateral agreement, which is between two parties.
    There is no way that you can invoke smart contracts directly in Corda; therefore,
    you must write a flow, which specifies the entire life cycle of state changes.
    The flow does this by invoking the smart contract that is related to the current
    state.  ### Client RPC'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: A client remote procedure call is a protocol that the client's blockchain program
    uses to request blockchain access from a program that is located on a remote Corda
    node.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: RPCs are used to ensure that the application can communicate without having
    to fully dictate or understand the blockchain network's details. An RPC is also
    known as a function call or a subroutine call, which uses a client-server platform.
    The node in Corda owner can interact with the node via a client RPC.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: From a development perspective, the node owner does not have direct client-side
    access to Service Hub APIs. For developers to interact with a node, they need
    to write a client in a JVM-compatible language using the `CordaRPCClient` class.
    There are also a number of dependencies and permissions developers would need
    to address.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information, please refer to the following:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: '`[https://docs.corda.net/clientrpc.html](https://docs.corda.net/clientrpc.html)`  ###
    Oracles'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: An oracle is a trusted external source of factual and final information. A fact
    can be included in a transaction as part of a command. An oracle service can be
    used to access or validate off-ledger data. An oracle will sign a transaction
    only if the included off-ledger fact is actually true from its point of view.
    For example, an oracle service can be used to sign the transaction to ensure the
    exchange rate being referenced is correct at a certain point in time.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: 'In a nutshell, an oracle is a trusted service that can provide that capability
    in a controlled and deterministic manner for exchanges.  ### Corda DemoBench'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: DemoBench is used to run a multiple-node Corda network on a local development
    machine. R3 Corda DemoBench is available for both Windows and macOS as a free
    download at the Corda download site. Developers should start by using DemoBench
    to get a feel of how a CorDapp would work from a user perspective and then dive
    into the JVM.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 10.18](#c10-fig-0018) shows the view in DemoBench when a network is
    deployed.'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: '![Screen capture depicting DemoBench.](images/c10f018.png)'
  id: totrans-486
  prefs: []
  type: TYPE_IMG
- en: '[**FIGURE 10.18**](#R_c10-fig-0018) DemoBench'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: 'DemoBench writes a log file to the following locations:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: '**macOS/Linux**: `$HOME/DemoBench/demobench.log`'
  id: totrans-489
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Windows**: `%USERPROFILE%\DemoBench\demobench.log`'
  id: totrans-490
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Figure 10.19](#c10-fig-0019) shows the log files in a Corda DemoBench JVM.'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: You can download Corda DemoBench from `[https://www.corda.net/download.html](https://www.corda.net/download.html)`.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: '![Screen capture depicting DemoBench logs.](images/c10f019.png)'
  id: totrans-493
  prefs: []
  type: TYPE_IMG
- en: '[**FIGURE 10.19**](#R_c10-fig-0019) DemoBench logs  ## Quorum Development'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: Quorum is an open source private blockchain network developed by JP Morgan directly
    from the Ethereum code. This blockchain is a fork of the Ethereum blockchain.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum developers will have no real significant learning curve to become proficient
    in the platform. Quorum development is similar to Ethereum, so I won't cover the
    redundant areas again for Quorum. I will focus on the similarities and major differences
    between Quorum and Ethereum.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: Quorum's main distinguishing feature is the fact that it allows private transactions
    between the parties. It does this over a private deployment of Ethereum, not on
    the Ethereum mainnet.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: Quorum introduces an interesting new consensus algorithm called Raft. Similar
    to proof of stake (POS), Raft does not require calculation of a hash and validates
    blocks/transactions in under 0.5 seconds, which is fast for a blockchain. However,
    this speed comes at a cost to security since it has no Byzantine fault tolerance.
    Basically, if this consensus is used, the security has to be provided by the entities
    themselves to ensure that their nodes are not accessible to an attacker.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: Quorum offers more consensus mechanisms that in the long run will allow Byzantine
    fault tolerance, such as Quorum Chain, which is programmable through a smart contract
    and is intended to enable programmable consensus logic.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: Quorum allows transactions to be carried out privately between network participants
    and allows a transaction to be visible only to a specific group of participants.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: The data of the private transactions never reaches nonparticipating nodes, since
    instead of using blockchain communication to send the data, a point-to-point network
    is used, which works together with the blockchain and allows data to be sent from
    one node to another, called/provided by Constellation. This data is verified in
    the blockchain by means of its hashes, but the data is never sent via the “open”
    network.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: '### Quorum vs. Ethereum'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: From a development perspective, Quorum uses the same core as Ethereum. They
    share the same smart contract development language, Solidity.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: However, there is a difference in regard to the computation pricing where the
    gas system is concerned. The Quorum network developer doesn't have to worry about
    having enough gas to interact with the contracts. Developers do not need to worry
    about gas because Quorum is a private blockchain and doesn't use gas. Wallets
    are not used in Quorum as they are in Ethereum.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: 'However, Quorum does maintain an execution gas limit per transaction. This
    is to prevent someone from launching a code that could take the validators too
    long to process and effectively induce a vulnerability into the chain.  ### Quorum
    Cakeshop'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: Cakeshop is an SDK that has APIs for creating, managing, and integrating Ethereum-like
    ledgers such as Quorum. It is packaged as a Java web application archive (WAR)
    that you can run on Docker containers. Cakeshop has an intuitive graphical user
    interface and is fairly intuitive to use.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: Cakeshop downloads the latest version of Quorum and the boot node from Geth.
    This Cakeshop package includes the transaction managers, a Solidity compiler,
    and all the needed dependencies.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information on Cakeshop, visit `[https://github.com/jpmorganchase/cakeshop](https://github.com/jpmorganchase/cakeshop)`.  ##
    Blockchain Performance'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: Blockchains are generally technologies that are distributed and decentralized,
    and they can be fast. For example, a blockchain could be faster than another blockchain
    if you removed nodes. However, when you remove nodes, you effectively mitigate
    security or decentralization.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: It's important to note that a blockchain, like any other technology, cannot
    be everything at once, and therefore a compromise in the constraints must be made.
    This compromise is similar to how a project manager would handle project constraints.
    For example, in a project you could reduce the time to completion by investing
    more in labor, which may get your project completed earlier. The other side is
    that by adding more labor, you effectively increase your cost constraints.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: In blockchain projects, constraints are no different from a compromise perspective,
    and it's a give-and-take consideration to what your blockchain application would
    realize from a security, speed, or decentralization perspective. Want better performance
    (faster transactions)? Then reduce the number of nodes but also centralize the
    nodes more. By improving performance, you could very well impact decentralization
    as well as change your security posture.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: As shown in [Figure 10.20](#c10-fig-0020), the project management triangle (aka
    triple constraint) comprises three constraints.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: Time refers to the schedule allotted to the project.
  id: totrans-513
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cost refers to the budget for licenses, hardware, and manpower, both internal
    and external.
  id: totrans-514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scope refers to the amount of functionality to be delivered in the project.
  id: totrans-515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Diagram depicting a triangle marked Triple constraint with on the three sides.](images/c10f020.png)'
  id: totrans-516
  prefs: []
  type: TYPE_IMG
- en: '[**FIGURE 10.20**](#R_c10-fig-0020) Triple constraint'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: Projects need to adjust one of the three constraints to make up for another.
    Generally, the project sponsor will determine which two to excel at, and the third
    will have to be adjusted to meet the initial two constraints.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: Now let's discuss blockchains. As previously mentioned, blockchains are decentralized,
    are secure, and can be fast relative to other blockchains. These three constraints
    are a choice, and the customer would need to choose.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: Blockchains can effectively maintain two of three properties (constraints) where
    one property is effectively compromised to provide a different result for another
    property. These three properties (constraints) are
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: Speed (fast)
  id: totrans-521
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secure
  id: totrans-522
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decentralized
  id: totrans-523
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Figure 10.21](#c10-fig-0021) shows the blockchain paradigm. Ideally, blockchains
    would meet all our expectations. However, we don''t live in a perfect world, so
    developers need to determine what these properties really are and how they affect
    our blockchain implementation.'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram depicting a triangle marked Blockchain paradigm with on the three
    sides.](images/c10f021.png)'
  id: totrans-525
  prefs: []
  type: TYPE_IMG
- en: '[**FIGURE 10.21**](#R_c10-fig-0021) Blockchain paradigm'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the common properties developers want to measure or adjust
    in our blockchain performance requirements:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
- en: '**Speed**—The blockchain must provide for prompt processing, which should result
    in higher transactions per second (TPS). Speed is also referred to as how “fast”
    a transaction could occur. Note that “speed” or “fast” is relative only as compared
    to other blockchains. Comparing blockchains to client-servers is not relative
    here.'
  id: totrans-528
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security**—Generally, a certificate manager handles these encryption certificates.
    In most blockchain networks, X.509 certificates are commonly used to maintain
    these certificates. For example, in Hyperledger Fabric there is what is called
    a *certificate authority*. Permissions are also important to consider since they
    directly affect access to resources. In most permissioned blockchains, there would
    be permissioning, which means that there is centralized control over what users
    or applications have access to the blockchain resources.'
  id: totrans-529
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Decentralization**—This is true in the permissionless blockchains, such as
    Ethereum. However, Hyperledger, Corda, and Ripple are centralized platforms.'
  id: totrans-530
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To be fair, some blockchains, such as Ripple, state they can process around
    1,500 TPS, and Hyperledger Fabric, in a perfect world, could process up to 3,500
    TPS. However, these numbers are based on some kind of compromise.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
- en: Bitcoin's TPS is continually varying. In its current form, the network doesn't
    support more than 7 TPS, and Ethereum is not much better at around 14 TPS. The
    performance of Bitcoin and Ethereum, for example, is a direct result of the global
    scale, Internet reliance, and transaction workloads. More transactions increase
    the workload of all production blockchain nodes in Ethereum and Bitcoin, which
    effectively have to update their ledger for every transaction.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 10.5](#c10-tbl-0005) compares some of the common blockchains and legacy
    services.'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
- en: '[**TABLE 10.5**](#R_c10-tbl-0005): Transactions per Second (TPS) Comparisons'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: '|  | VISA | BTC | RIPPLE | PAYPAL | HYPERLEDGER |'
  id: totrans-535
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-536
  prefs: []
  type: TYPE_TB
- en: '| **TPS** | 24,000 | 4 | 1,500 | 193 | 3,500 |'
  id: totrans-537
  prefs: []
  type: TYPE_TB
- en: '| **Control** | Centralized | Decentralized | Centralized | Centralized | Centralized
    |'
  id: totrans-538
  prefs: []
  type: TYPE_TB
- en: '| **Notes** | Push | P2P | Hybrid | Hybrid | P2P |'
  id: totrans-539
  prefs: []
  type: TYPE_TB
- en: The “Notes” reference how a transaction is actually processed and then ingested
    from the application. Transactions that are sent from a client application to
    the server's processor application are push transactions. Transactions that are
    pulled from the client application are pull transactions. Push, pull, and hybrid
    transactions are client-server applications, which typically are decentralized.
    Transactions that use both push and pull processes in the application are considered
    hybrid. Transactions that are processed on the blockchain nodes and processed
    by each node are considered P2P transactions. Blockchains that are processed in
    a P2P transaction platform are the native forms of blockchain transactions.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
- en: '### Permission or Permissionless Performance'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps the real trade-off around performance is between permissioned and permissionless
    blockchains. Permissioned blockchains can generally perform better since they
    have fewer nodes in the blockchain network, and the nodes are centralized or localized.
    Performance is relative to the number of nodes.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
- en: For example, it has been stated that Hyperledger Fabric could theoretically
    reach 3,500 TPS. Of course, this number is in a perfect world, and it is well
    known that Hyperledger Fabric overall does not scale well from a performance perspective.
    Adding mode nodes and peers will substantially drop the TPS. When you add nodes
    that are not localized, you can expect the network latency to also reduce your
    TPS.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
- en: In the case of permissionless blockchains such as Ethereum, developers know
    that performance should not be an expectation. Permissionless blockchains are
    generally widely distributed with typically hundreds of nodes as well. The user
    base can be dependent on sporadic behavior—for example, in the world of Bitcoin,
    activity can spike when there is an event in China or when the United States makes
    a statement about regulating cryptocurrency.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
- en: 'If performance is part of your use case requirements, then permissionless blockchains
    are out of the question.  ### Performance Testing'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to performance testing, the main focus is transactions per second
    (TPS). Another factor is the size of the transactions. For example, a larger block
    size may not perform as well as a smaller block size.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
- en: 'Performance testing is generally accomplished through what is considered to
    be nonfunctional testing. Nonfunctional testing is a focused area that is mainly
    technically driven. Some technical areas that could be tested include the following:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: Network latency and bottlenecks
  id: totrans-548
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Block size adjustment
  id: totrans-549
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Signatures removed or included
  id: totrans-550
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sequencing of transactions
  id: totrans-551
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There seems to be a limited number of performance testing tools. However, there
    are a few solid choices depending on your platform. Ethereum has most choices
    available at the time of writing.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
- en: '#### ETHEREUM TESTING TOOLS'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
- en: There are numerous tools for Ethereum application development. It is important
    to note that in varying degrees when testing your Quorum blockchain applications
    some Ethereum tools could be made to work. At the time of writing, there are no
    testing tools for Quorum. From a testing perspective with Quorum you would want
    to ensure that you direct your tests to your localhost or a custom RPC.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are three common tools used in Ethereum testing:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
- en: '**Ethereum Tester** Ethereum Tester supports two distinct data formats that
    enable both front-end and backend testing. There is a significant installation
    process and some dependencies to deal with.'
  id: totrans-556
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On GitHub, visit `[https://github.com/ethereum/eth-tester](https://github.com/ethereum/eth-tester)`.
  id: totrans-557
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Truffle** Truffle is a battle-tested Ethereum development framework that
    you really have to know to develop in Ethereum. It has a great testing capacity
    built in as well. For example, you can write automated tests for smart contracts
    in JavaScript and Solidity and get your contracts developed quickly.'
  id: totrans-558
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To find out more about Truffle Suite, visit `[https://www.trufflesuite.com/](https://www.trufflesuite.com/)`.
  id: totrans-559
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Ganache** Ganache has the most popular library for Ethereum testing. Formerly
    known as TestRPC, Ganache is used to test Ethereum smart contracts locally—that
    is, it spins up an instance on your desktop/server and simulates a live blockchain.'
  id: totrans-560
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can learn more about Ganache at `[https://www.trufflesuite.com/ganache](https://www.trufflesuite.com/ganache)`.  ####
    HYPERLEDGER FABRIC TESTING TOOLS'
  id: totrans-561
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Hyperledger Fabric has some specific tools that can be used for testing. Hyperledger
    Composer currently is the most common tool used for Hyperledger development and
    testing. Hyperledger Composer is available for a local deployment using Docker
    containers, or you can use the web version called Hyperledger Composer Playground.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
- en: Hyperledger Composer is an open source development tool that contains many functions
    to help build blockchain applications. Some of those features also help with testing.
    At the time of writing, Composer supports interactive testing, automated unit
    testing, and automated system testing.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
- en: Composer has a command-line interface that enables you to run interactive “smoke
    tests” that can ensure the deployment would be successful. This also makes it
    easy to execute tests in a continuous integration/continuous delivery (CI/CD)
    pipeline.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
- en: 'Continuous integration (CI) is a process whereby a developer''s working copies
    are synchronized with a shared pipeline several times a day. Continuous delivery
    (CD) is the next process after continuous integration and enables placing a product
    into production, which historically is a manually driven process. Continuous deployment,
    the next logical next step after continuous delivery, automatically deploys the
    product into production after quality assurance (QA).  ## Blockchain Integration
    and Interoperability'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
- en: Blockchains are increasingly providing much more value by either going off chain
    or cross-chaining. Moving value from one blockchain to another blockchain is actually
    somewhat of a new approach even in blockchain's short history.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
- en: Before the idea and implementation of cross chains, developers be using an off-chain
    approach through a cryptocurrency gateway to exchange value. The main headache
    with that approach was that these gateways were centralized exchanges and could
    pose some concerns to privacy, costing, control, and performance.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
- en: A thin client generally only presents processed data provided by an application
    server, which performs the bulk of any required data processing. A device using
    web applications is a thin client, and generally these blockchain applications
    can be enabled by thin clients.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
- en: To integrate the blockchain with any traditional systems or with a front end
    that will allow our clients to interact with it in a user-friendly way, developers
    must use the client libraries available for the various “traditional languages.”
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
- en: Generally, the blockchain technologies communicate through RPC/HTTP and a client
    library for NodeJS or another library. Blockchain technologies exchange payments
    and digital assets. The ability to transfer and exchange digital assets originating
    from another blockchain without trusted intermediaries can be accomplished through
    the use of notary schemes, relays, and hashed time locks.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
- en: Vitalik Buterin, cofounder of Ethereum, noted that there are three primary methods
    to achieving true interoperability for a blockchain.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
- en: Notary schemes, which are an exchange of arbitrary data such as how to connect
    the blockchain to another blockchain. This is commonly referred to as *federation*
    of blockchains. An example would be a company such as Blockstream that provides
    a medium for transfer from one network to another network.
  id: totrans-572
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Relays provide for the exchange of arbitrary data via what is a gateway or data
    exchange. Some vendors refer to relays as a relay chain. A relay or relay chain
    is used to provide a gateway from one blockchain to another blockchain. BTCRelay
    is the most widely known relay and acts as a bridge between Bitcoin and Ethereum
    blockchains.
  id: totrans-573
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hashed time lock contracts (HTLCs) provide for the exchange of digital assets
    via a cross-chain atomic swap. HTLCs can provide for bidirectional payment channels
    between digital assets on specific blockchains. The most prominent example is
    the Bitcoin Lightning Network.
  id: totrans-574
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generally, whether a blockchain uses any one of the preceding methods is really
    dependent on the level of federation required, off-chain or side chain requirements,
    as well as any number of other factors.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
- en: '### Data Exchange Methods'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
- en: The terms *sidechains* and *payment gateways* are commonly used interchangeably
    in the blockchain industry. However, they are quite different. A sidechain is
    a separate blockchain that is attached to a parent blockchain using what is called
    a *two-way peg*. This two-way peg enables the interchangeability of assets at
    a predetermined rate between the parent blockchain and the sidechain. In simple
    terms, it's an exchange.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
- en: The original blockchain is usually referred to as the *main chain*, and all
    additional blockchains are referred to as *sidechains*.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
- en: Common sidechains that are in production mode include Rootstock and Liquid.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
- en: Rootstock (RSK) appears to be the most widely used and has created an open source
    testnet called Ginger for its sidechains. RSK has a two-way peg with the Bitcoin
    blockchain and rewards Bitcoin miners via merged mining. RSK's main goal is to
    enable the Bitcoin blockchain to have smart contract capabilities and make these
    integrated payments more efficient.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
- en: 'Liquid is a sidechain created by a blockchain startup called Blockstream. Liquid
    enables the instant movement of funds between cryptocurrency exchanges, and it''s
    very efficient. There is really no waiting for the confirmation in the Bitcoin
    blockchain.  ### Hash Timed Locks'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
- en: An HTLC is a class of blockchain-based payment system that uses hash locks.
    Time locks require the receiver of a payment to either acknowledge receipt prior
    to a deadline or basically forfeit the ability to claim the payment and then return
    it to the payer.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
- en: HTLCs allow for cross-chain atomic swaps, which means, for example, a sender
    could pay in Bitcoin, but the receiver could choose Litecoin as payment. The hashed
    time locks are fully funded bidirectional payment channels between assets on the
    specified blockchain platforms.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of the Lightning network, it is a decentralized micropayment solution
    on top of the Bitcoin blockchain.  ### Relays and Gateways'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
- en: A relay is effectively a way to interface a contract exchange between two different
    blockchains. Relays are also referred to as *gateways* or *payment gateways*.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
- en: The most prominent relay is BTC Relay, which allows Ethereum contracts to securely
    verify Bitcoin transactions without any intermediaries.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
- en: BTC Relay is an Ethereum contract that stores Bitcoin block headers only. It
    uses these block headers to build a mini version of the Bitcoin blockchain. The
    main benefit is that it allows Ethereum dapp users to pay with Bitcoin to use
    Ethereum dapps directly.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
- en: Some relays allow for a one-way exchange, and some allow for exchange both ways.
    For example, in BTC Relay, the exchange is one way, whereby the user can pay for
    Ethereum by using Bitcoin, but not the other way around.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
- en: 'For more on BTCRelay, refer to `[http://btcrelay.org/](http://btcrelay.org/)`.  ##
    Summary'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
- en: This chapter covered various development challenges, best practices, programming
    models, and frameworks.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
- en: Solidity is a newer but simple programming language that is popular among Ethereum
    developers. Other widely used development languages include C++, Java, Golang,
    and Rust. Blockchain developers experienced in these languages are on their way
    to blockchain success.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum development requirements should be reviewed before developing on Ethereum.
    You learned about Truffle, Ganache, MetaMask, testnets, and several areas of development
    focus on Ethereum.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
- en: Hyperledger development tools include Hyperledger Composer, an object-oriented
    modeling language that defines the domain model for a business network definition.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
- en: Hyperledger Fabric uses LevelDB as the database for the state database, but
    you may want to consider the option to configure peers to store database transactions
    in CouchDB.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
- en: The two most popular languages for Corda development are Java and Kotlin. The
    real key for using these languages is their great flexibility and interoperability
    with Java in both directions.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
- en: Quorum is an open source private blockchain network developed by JP Morgan from
    the Ethereum code. Ethereum developers will have a short ramp-up time to develop
    on the Quorum blockchain.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
- en: There are various aspects of interoperability and integration—such as hash locks,
    payment gateways, and sidechains—to consider when blockchain requirements call
    for different blockchains.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
