- en: Chapter 10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Blockchain Development
  prefs: []
  type: TYPE_NORMAL
- en: This chapter provides a general overview of blockchain development by offering
    insight into the most common development languages, development tools, and the
    blockchains they are used for.
  prefs: []
  type: TYPE_NORMAL
- en: I will focus mainly on the high-level aspects of development around the Ethereum,
    Hyperledger, Corda, and Quorum blockchains as well as the development languages
    they are built on. The world of blockchain development is a far and wide specialization
    area. Each blockchain has its own approach to development, toolsets, consensus,
    and dependencies, and could merit its own book on the subject of blockchain development.
  prefs: []
  type: TYPE_NORMAL
- en: Blockchain development is a growing area. The demand has never been higher due
    to the shortage of developers who understand blockchain. If you are developing
    in JavaScript, Golang, Python, or any common language, you are already on the
    road to being a blockchain developer.
  prefs: []
  type: TYPE_NORMAL
- en: The goal of this chapter is to give an overview of how the blockchains are built
    around the programming languages, data structures, and programming building blocks.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are looking for programming instructions, note that this chapter does
    not focus on developing applications or programming methods; rather, this chapter
    is intended as a guide for systems engineers and other nondevelopers to grasp
    the complexity of blockchain development.  ## Common Programming Languages'
  prefs: []
  type: TYPE_NORMAL
- en: Blockchain programs are computer code and are known as *smart contracts*. Developers
    who are programming for web apps, enterprise apps, or cloud apps are likely frontrunners
    to be blockchain developers.
  prefs: []
  type: TYPE_NORMAL
- en: If you're a system engineer, whether presales or postsales, you are also likely
    to understand some aspects of programming languages. Your customers are likely
    already using some of these in their development organizations, which can give
    your customers' organizations a head start in blockchain development.
  prefs: []
  type: TYPE_NORMAL
- en: The main point is that blockchains are about creating programs, and these programs
    are built on development languages you likely already use in your enterprises.
    The programs ultimately will solve problems, create value, or provide other tangible
    benefits for the company. The only significant learning curve is to know how the
    smart contracts interact with the blockchain network and perhaps to understand
    the APIs used to enable the client applications to interface with the application.
  prefs: []
  type: TYPE_NORMAL
- en: Let's run down the most common blockchain languages. This will give you a good
    idea of what's in demand. If you're looking for a blockchain developer, you will
    have a more concise requirements list to give to your recruiters.
  prefs: []
  type: TYPE_NORMAL
- en: '### Most Common Development Languages'
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to development languages, a few languages are clearly in high
    demand in blockchain development. Some languages are used on only a few blockchains.
    For example, Solidity is used only on Ethereum and Quorum, but it makes up well
    over 60 percent of the blockchain developer requirements listed on LinkedIn at
    the time of writing.
  prefs: []
  type: TYPE_NORMAL
- en: Note that other common development languages are also used, for example, in
    Bitcoin, Lisk, and EOS, as well as other newer blockchains that I do not cover
    in the book. The main coverage in this chapter will focus on Ethereum, Corda,
    Hyperledger Fabric, and Quorum.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the most commonly used languages in enterprise blockchain
    development:'
  prefs: []
  type: TYPE_NORMAL
- en: Solidity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Golang
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C++
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When it comes to holistic development and not just blockchain-focused development,
    Python is the clear winner at the time of writing. Finding Python professionals
    likely will not be an issue due to the wide acceptance of the Python development
    language.
  prefs: []
  type: TYPE_NORMAL
- en: For additional insight into which development languages are in demand and the
    current popularity of each language, refer to a resource compiled from Google
    called “PYPL Popularity of Programming Language Index,” at `[http://pypl.github.io/PYPL.html](http://pypl.github.io/PYPL.html)`.
  prefs: []
  type: TYPE_NORMAL
- en: '#### SOLIDITY'
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to blockchain development, Solidity is the most widely used and
    in-demand developer requirement at the time of writing for enterprise blockchains.
    A contract-oriented Turing-complete programming language, Solidity has a large
    base of Ethereum developers, with an estimated 250,000+ users.
  prefs: []
  type: TYPE_NORMAL
- en: Solidity is a relatively simple programming language that is used with Ethereum
    developers. Solidity was clearly developed specifically for the Ethereum platform.
  prefs: []
  type: TYPE_NORMAL
- en: The developers of Solidity used specific features, functions, and concepts from
    C++, Python, JavaScript, and Golang to assemble the new language. Solidity's main
    program syntax is based on JavaScript, a widely used development language. Because
    Solidity is built from JavaScript, it has a low barrier of entry for developers.
  prefs: []
  type: TYPE_NORMAL
- en: When you think of developing in Ethereum, you think of Solidity since it was
    developed exclusively for Ethereum smart contracts initially. Solidity has essentially
    expanded to become its own standard for other blockchain platforms to follow.
    At the time of writing, the most widely used languages for writing smart contracts
    on Ethereum are Solidity and Vyper.
  prefs: []
  type: TYPE_NORMAL
- en: Why is Solidity so popular? Solidity is a powerful and efficient toolset for
    developers because it allows programmers to write higher-level code, which is
    then compiled down into what is considered a low-level machine language. Smart
    contracts can be written in Solidity, Vyper, and Serpent mainly because they are
    high-level languages that are compiled down to bytecode. Bytecodes are essentially
    operation codes (opcodes) running instruction after instruction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Blockchains that directly support smart contracts written in Solidity include
    Ethereum, Ethereum Classic, and Hyperledger Sawtooth (with Seth).  #### GOLANG'
  prefs: []
  type: TYPE_NORMAL
- en: Golang (Go) is an open source general programming language that is lightly based
    on the syntax of the C programming language. Golang also has some ease-of-use
    similarities to JavaScript, which gives Go a low barrier to entry.
  prefs: []
  type: TYPE_NORMAL
- en: Originally designed by Google engineers, Golang was released directly to the
    open source community in 2009\. Golang has become a popular object-oriented and
    imperatively designed programming language. More than 800,000 developers use Golang.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hyperledger Fabric is built from Golang. The following are some of the benefits
    of using Golang (Go) with Hyperledger:'
  prefs: []
  type: TYPE_NORMAL
- en: Provides a fast statically typed and compiled language
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supports type-safety and dynamic data entry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allows the creation of flexible and modular code, and thanks to its multithreading
    mechanisms, enables distributed computations and simplified network interaction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provides convenient testing tools for developers on GitHub
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Offers efficient development processes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ethereum''s SDK protocol is actually written in Go. There are many other blockchain
    applications of this language. Blockchains that are written in Golang (Go) include
    Hyperledger Fabric and NEO.  #### C++'
  prefs: []
  type: TYPE_NORMAL
- en: C++ is the oldest development language used for blockchains. C++ has been around
    for more than 30 years and was originally known as “C with Classes.” C++ features
    worth noting for blockchains include memory control opportunities around scalability,
    which is a significant problem faced by blockchains today.
  prefs: []
  type: TYPE_NORMAL
- en: C++ is considered a general-purpose programming language with an extensive user
    base of more than 4 million developers. It can be used for higher-level tasks
    and also allows programmers to program to the hardware itself. This flexibility
    has made C++ highly popular for uses such as embedded systems and computer graphics.
  prefs: []
  type: TYPE_NORMAL
- en: 'C++ offers the following benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: Facilitates proper threading since there are many parallel operations that have
    to be performed simultaneously
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performs move semantics, which can significantly improve performance when it
    comes to the value of the variables retrieved
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allows compile-time polymorphism, which enables developers to use functions
    in different ways, thereby decreasing code volume and boosting performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Blockchains that support C++ include Hyperledger Iroha, Bitcoin, EOS, and NEO.  ####
    JAVASCRIPT'
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript is generally accepted to be the programming language of the Internet.
    It has been used primarily to enhance web pages to provide for a more dynamic,
    user-friendly experience. JavaScript is widely accepted for development use since
    it is good at handling asynchronous actions.
  prefs: []
  type: TYPE_NORMAL
- en: This property of asynchronous actions makes JavaScript well suited for blockchain
    operations that require scaling. As the number of users on your blockchain rises,
    JavaScript can scale with the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript is a lower entry point to developers who are interested in programming
    blockchains since it's easy to learn and widely used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Blockchains that support smart contracts in JavaScript include Hyperledger
    Fabric, Hyperledger Sawtooth, and Lisk.  #### PYTHON'
  prefs: []
  type: TYPE_NORMAL
- en: Python is an interpreted, higher-level, and general-purpose programming language.
    Python was created by Guido van Rossum and was first released in 1991\. Python
    has a design philosophy that emphasizes code readability, notably using significant
    whitespace.
  prefs: []
  type: TYPE_NORMAL
- en: From a development perspective, Python supports a large number of libraries.
    Python is also generally considered to be one of the simpler languages since it
    has an intuitive code structure. For example, code can be written once and run
    on almost any computer without needing to change the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'NEO is an example of a blockchain that supports smart contracts in Python.  ###
    Less Widely Used Development Languages'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some less commonly used but also notable development languages
    for enterprise blockchain development:'
  prefs: []
  type: TYPE_NORMAL
- en: C#
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rust
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simplicity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although many other languages have been developed, and new languages are likely
    being developed as you read this, I want to focus on languages that have mainstream
    use.
  prefs: []
  type: TYPE_NORMAL
- en: '#### C#'
  prefs: []
  type: TYPE_NORMAL
- en: C# tutorials claim this programming language as an option, and it can be used
    to create blockchains because it is object-oriented. It is a widely popular language
    for portability since it is somewhat easy to code in a cross-platform manner for
    software. It is important to note that it has a close relation to Java and would
    be easily understood by developers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Blockchains that are written in C# include NEO and Stratus.  #### JAVA'
  prefs: []
  type: TYPE_NORMAL
- en: Java has been primarily used in website designs since it was simple to connect
    the link between blocks of information. Released in 1995 by Sun Microsystems,
    Java is a general-purpose programming language that is object-oriented, class-based,
    and concurrent.
  prefs: []
  type: TYPE_NORMAL
- en: There is also a runtime environment (JRE), which consists of the Java virtual
    machine and Java platform core classes and supports Java platform libraries. Java
    is often used for developing client-server web applications, allowing developers
    to run a compiled Java code on all the platforms that support Java without the
    need for recompilation, making it popular for running light-weight cryptocurrency
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Blockchains that support smart contracts in Java include NEM, NEO, and Corda.  ####
    RUST'
  prefs: []
  type: TYPE_NORMAL
- en: Rust is a system language created by Mozilla, one of the Internet pioneers.
    Rust has several advantages that enable rapid blockchain development, including
    efficient computer processing and flexibility around security.
  prefs: []
  type: TYPE_NORMAL
- en: The Rust compiler provides for risk reduction when executing code since it helps
    to eliminate potential problems. Rust has a very active community and a well-provisioned
    communication and learning system for developers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Corda is an example of a blockchain that supports smart contracts in Rust.  ####
    SIMPLICITY'
  prefs: []
  type: TYPE_NORMAL
- en: Simplicity is a newer blockchain programming language that was designed exclusively
    for smart contracts. Simplicity was developed by a company called Blockstream,
    which had a goal to provide the flexibility and expressiveness for blockchain
    computations as well as verifying the safety, security, and costs of smart contracts.
  prefs: []
  type: TYPE_NORMAL
- en: Simplicity was well thought out in the sense that it was developed to ensure
    that the programming challenges of traditional development languages were addressed.
    One of the main challenges was to actually program efficiently for the role of
    a blockchain. The role of a blockchain should be only to verify computation. A
    traditional programming model would be more focused on performing computation.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more on this exciting new blockchain development language, refer to this
    site:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[https://blockstream.com/2018/11/28/en-simplicity-github/](https://blockstream.com/2018/11/28/en-simplicity-github/)`  ###
    Summary of Blockchain Platforms'
  prefs: []
  type: TYPE_NORMAL
- en: Numerous languages are used on the various platforms for cryptocurrencies and
    enterprise blockchains. For example, in Ethereum you have several choices, but
    the main language from a development perspective to focus on is Solidity.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 10.1](#c10-tbl-0001) summarizes the major enterprise blockchain languages.'
  prefs: []
  type: TYPE_NORMAL
- en: '[**TABLE 10.1**](#R_c10-tbl-0001): Blockchain Platforms and Development Languages'
  prefs: []
  type: TYPE_NORMAL
- en: '| BLOCKCHAIN PLATFORM | PLATFORM DEVELOPMENT | SMART CONTRACT LANGUAGES |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Ethereum | Solidity | Solidity/Vyper/Bamboo/Flint |'
  prefs: []
  type: TYPE_TB
- en: '| Hyperledger Fabric | Golang | Golang/JavaScript/Java |'
  prefs: []
  type: TYPE_TB
- en: '| Corda | Kotlin | Kotlin and Java |'
  prefs: []
  type: TYPE_TB
- en: '| Quorum | Solidity | Solidity |'
  prefs: []
  type: TYPE_TB
- en: '| Ripple | Python | N/A |'
  prefs: []
  type: TYPE_TB
- en: 'When considering a blockchain platform, it is important not only to consider
    your organization''s expertise requirements for blockchain development but also
    to review and document any legacy applications'' requirements that may be extended
    to the blockchain service.  ## Ethereum Development'
  prefs: []
  type: TYPE_NORMAL
- en: An open source and collaborative effort, Ethereum is by far the blockchain that
    has the most robust development ecosystem and developer following. The main feature
    of Ethereum that drives this large developer following is the Turing-complete
    language that facilitates the development of smart contracts.
  prefs: []
  type: TYPE_NORMAL
- en: Developers should note that Ethereum is geared toward applications that automate
    direct interaction between peers or that facilitate group routines over the Ethereum
    decentralized network.
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum itself is only a protocol defining how the communication should work.
    There are several versions of the Ethereum protocol. The two most common versions
    are Go-Ethereum (aka GETH), which is written in Golang, and Parity, which is written
    in Rust.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a dearth of development tools, utilities, and testnets for Ethereum.
    Some of the most common tools include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**IDE**: Solidity Browser, Ethereum Studio'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Clients**: Geth, Parity, Ethereum Wallet'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Storage**: IPFS (supported through Swarm and Storj)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dapp** browsers: MetaMask, Mist'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Testing**: Testnets, TestRPC, localhost'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are numerous other tools for testing IDE environments, frontend and backend
    development, and security. For more details on the robust Ethereum ecosystem,
    check out the ConsenSys GitHub here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[https://github.com/ConsenSys/ethereum-developer-tools-list#smart-contract-languages](https://github.com/ConsenSys/ethereum-developer-tools-list#smart-contract-languages)`'
  prefs: []
  type: TYPE_NORMAL
- en: '### Smart Contracts'
  prefs: []
  type: TYPE_NORMAL
- en: A smart contract is computer program code capable of organizing, executing,
    and enforcing the negotiation or performance of an agreement using blockchain
    technology. From a development perspective, the blockchain is somewhat limited
    in the sense that the API calls that can made are minimal.
  prefs: []
  type: TYPE_NORMAL
- en: Developers are generally well versed in automating tasks, which is exactly what
    smart contracts perform. A smart contract is an automated process that can be
    considered a suitable legal contract in some scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Smart contracts define the rules of engagement and the penalties around that
    agreement in the same way that a traditional contract does. Developers will clearly
    define how to handle any violations of the smart contract from a code perspective.
  prefs: []
  type: TYPE_NORMAL
- en: In Ethereum, as in other blockchain languages, there are specific functions
    to deal with. Your developers should clearly understand how these functions work
    and how the program would come together as an application.
  prefs: []
  type: TYPE_NORMAL
- en: '#### SMART CONTRACT WORKFLOW'
  prefs: []
  type: TYPE_NORMAL
- en: As discussed in [Chapter 2](c02.xhtml), two types of functions are required
    in an Ethereum smart contract.
  prefs: []
  type: TYPE_NORMAL
- en: Constructor function, which is called only once when you deploy the smart contract
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fallback function, which is invoked when someone sends ether to the address
    of your smart contract
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Figure 10.1](#c10-fig-0001) shows the smart contract workflow in Ethereum.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image described by caption and surrounding text.](images/c10f001.png)'
  prefs: []
  type: TYPE_IMG
- en: '[**FIGURE 10.1**](#R_c10-fig-0001) Smart contract workflow'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the steps with more information:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Predefined contract:** All the smart contract participants will establish
    the terms and also establish the conditions for execution.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Events:** These are really event “triggers” that kick off the execution of
    the contract. Events include initiating a transaction and receiving funds, for
    example.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Execute transfer:** The terms of the contract specifically dictate the movement
    of value based on the conditions met.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Settlement:** The settlement of the contract is based on the requirements
    being met. For example, was $100,000 received from the title company?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Smart contracts, when combined with other smart contracts, make a decentralized
    application (*dapp*). A dapp can be as simple as a few lines of code or as complex
    as possible with thousands of lines of code. Complexity can be built into the
    platform or could also be extended off-chain as well. Developers have myriad options
    during the development process to customize the dapps.  #### SMART CONTRACT ENFORCEMENT'
  prefs: []
  type: TYPE_NORMAL
- en: To modify a smart contract's data, a blockchain user must send requests directly
    to its code. That is, the request does not go through an intermediary but instead
    will be fully handled by the smart contract code.
  prefs: []
  type: TYPE_NORMAL
- en: The smart contract modification process that will kick off determines whether
    to fulfill the request and how to fulfill requests that have been sent. Effectively,
    the smart contract is self-enforcing the rules that are clearly defined.
  prefs: []
  type: TYPE_NORMAL
- en: Comparatively, you can think of smart contract enforcement as how a traditional
    database such as SQL uses what is called an *enforced stored procedure*. In SQL
    you can specify how the stored procedure will work by using the `CREATE PROCEDURE`
    command. The `CREATE PROCEDURE` command will first reference specified parameters,
    such as students, addresses, money, and so on. Then the stored procedure will
    take in the specified value and compare it to what is in the `var_return` value.
  prefs: []
  type: TYPE_NORMAL
- en: 'In SQL, all inserts have to be executed at once or none at all, which is similar
    to how a blockchain enforces the smart contract logic. In blockchain we would
    call this strict enforcement *predefined rules*. Predefined rules in a blockchain
    would specify whether a sender has provided the exact amount of funds. If the
    exact amount of funds were sent by the sender and then promptly received by the
    receiver, then the smart contract would execute. Simply put, smart contracts are
    all or nothing from a layperson''s perspective.  #### DAPPS'
  prefs: []
  type: TYPE_NORMAL
- en: Dapps (decentralized applications) run on a P2P network of computers (such as
    Ethereum) and are not centralized. When developing blockchain applications with
    Ethereum, you have two distinct options.
  prefs: []
  type: TYPE_NORMAL
- en: Use Solidity or another development language to develop smart contracts that
    will be deployed to the blockchain.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Develop websites that interface with the Ethereum blockchain.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When it comes to developing dapps, it's important to understand how different
    a blockchain is from a traditional client server application. Developers are well
    versed in client-server applications and understand the world of the Web. Moving
    from Web 2.0 to the new world of Web 3.0 will take newer skillsets and application
    development languages. Decentralized apps will become the thing of tomorrow, and
    developers need to get skilled in this area.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 10.2](#c10-fig-0002) provides a high-level comparison of Web 2.0 applications
    to the layers of a blockchain application Web 3.0.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Schematic diagram depicting Application-layer comparison.](images/c10f002.png)'
  prefs: []
  type: TYPE_IMG
- en: '[**FIGURE 10.2**](#R_c10-fig-0002) Application-layer comparison'
  prefs: []
  type: TYPE_NORMAL
- en: The infrastructure layer in blockchain technology is different from Web 2.0
    in the sense that P2P networking is being introduced as the approach used to move
    from a centralized web to more of a decentralized web.
  prefs: []
  type: TYPE_NORMAL
- en: Blockchain is considered to be fully capable of providing technological benefits
    because of its decentralized capacity. Web 3.0 is focused on changing our application
    stacks from client-server to a decentralized Web. With decentralization, the risk
    of common security breaches could be reduced due to the decentralization of data
    distribution.
  prefs: []
  type: TYPE_NORMAL
- en: 'From an application-layer perspective, developers would need to consider dapps,
    business logic, application services, and even the user interfaces to integrate.  ####
    ETHEREUM GAS'
  prefs: []
  type: TYPE_NORMAL
- en: Ether, the native token of the Ethereum blockchain, is used to pay for transaction
    fees, miner rewards, and other services performed on the network.
  prefs: []
  type: TYPE_NORMAL
- en: To use the Ethereum network, you must pay with what is known as *gas*. Gas is
    a measurement roughly equivalent to computational steps for Ethereum. Every transaction
    is required to include a gas limit and a fee that it is willing to pay per gas.
    The blockchain miners have the choice of including the transaction and collecting
    the fee or not. Every operation has a gas expenditure on an Ethereum Virtual Machine
    (EVM), and that gas expenditure can be controlled from a cost perspective.
  prefs: []
  type: TYPE_NORMAL
- en: The price of gas is the amount of ether you are willing to spend on every unit
    of gas. This gas price is similar to an auction limit where you can determine
    what you get and when you get it.
  prefs: []
  type: TYPE_NORMAL
- en: Comparatively, if you are familiar with AWS EC2 virtual machines, then you may
    have used what are called *spot instances*. Spot instances in AWS are virtual
    machine instances that you can run programs on at a lower cost.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 10.3](#c10-fig-0003) shows the main resource (`[ethgasstation.info](http://ethgasstation.info)`)
    for estimating gas resource costs on the Ethereum network.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Screen capture depicting ethgasstation.info web page.](images/c10f003.png)'
  prefs: []
  type: TYPE_IMG
- en: '[**FIGURE 10.3**](#R_c10-fig-0003) ETH gas station'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the more important it is to process the transaction, the higher the
    price. Essentially, the more gas you pay for, the faster your services execute.
  prefs: []
  type: TYPE_NORMAL
- en: 'One common concern around the gas model is that because it''s an estimate of
    resources, loops should be avoided. Avoiding loops can be a challenge to estimate
    since if your application scales or your user base grows, then the costs could
    skyrocket. Loops in Ethereum are similar to an all-you-can-eat buffet and need
    to be avoided.  #### ETHEREUM VIRTUAL MACHINE'
  prefs: []
  type: TYPE_NORMAL
- en: When developing on Ethereum, it is important to understand how the EVM has been
    designed and enabled for the Ethereum blockchain. For example, smart contracts
    are written in a smart contract programming language, such as Solidity, and then
    compiled into what is known as *bytecode*.
  prefs: []
  type: TYPE_NORMAL
- en: Bytecode enables what an EVM can read and execute. The smart contract that is
    rolled out is on every node of the network, runs the EVM, and executes the same
    instructions.
  prefs: []
  type: TYPE_NORMAL
- en: The EVM not only provides amazing value to enterprises and their users but also
    enables the development of potentially thousands of different applications all
    on one platform.
  prefs: []
  type: TYPE_NORMAL
- en: The Ethereum blockchain is deterministic, meaning that the same input will produce
    the same output. This reduces the complexity of the programming involved and can
    remove numerous manual mistakes.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 10.4](#c10-fig-0004) shows the development and deployment process on
    an Ethereum EVM at a high level. A smart contract was developed in Solidity. We
    would compile our program and then deploy on the EVM.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Flow diagram depicting EVM development and deployment.](images/c10f004.png)'
  prefs: []
  type: TYPE_IMG
- en: '[**FIGURE 10.4**](#R_c10-fig-0004) EVM development and deployment  ### Ethereum
    Ecosystem'
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum has a solid and well-provisioned development system.
  prefs: []
  type: TYPE_NORMAL
- en: Solidity is the development language that is used to create Ethereum smart contracts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Ethereum wallet is used for accessing Ethereum tokens, which are used to
    pay fees for the usage of the Ethereum resources.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testnets are used for the developers to deploy code on a test network away from
    the mainnet.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test ether is created to pay transaction fees on various testnets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Development environments are provided for the building of smart contracts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Truffle framework is a widely accepted development environment, testing
    framework, and asset pipeline for Ethereum.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '#### ETHER UNITS'
  prefs: []
  type: TYPE_NORMAL
- en: Ether is broken down into units or denominations. A *gwei* is a unit of Ethereum
    coin used to calculate transaction fees. For example, one Ethereum coin is worth
    1 billion Gwei.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 10.2](#c10-tbl-0002) shows the breakdown of the Ether units into the
    denominations.'
  prefs: []
  type: TYPE_NORMAL
- en: '[**TABLE 10.2**](#R_c10-tbl-0002): Ether Units'
  prefs: []
  type: TYPE_NORMAL
- en: '| UNIT | WEI VALUE | WEI |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Wei | 1 wei | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| Kwie (babbage) | 1e3 wei | 1,000 |'
  prefs: []
  type: TYPE_TB
- en: '| Mwie (lovelace) | 1e6 wei | 1,000,000 |'
  prefs: []
  type: TYPE_TB
- en: '| Gwie (shannon) | 1e9 wei | 1,000,000,000 |'
  prefs: []
  type: TYPE_TB
- en: '| Microether (szabo) | 1e12 wei | 1,000,000,000,000 |'
  prefs: []
  type: TYPE_TB
- en: '| Milliether (finney) | 1e15 wei | 1,000,000,000,000,000 |'
  prefs: []
  type: TYPE_TB
- en: '| Ether | 1e18 wei | 1,000,000,000,000,000,000 |'
  prefs: []
  type: TYPE_TB
- en: 'For more information on the Ethereum denominations, visit `[http://ethdocs.org/en/latest/ether.html](http://ethdocs.org/en/latest/ether.html)`.  ####
    METAMASK'
  prefs: []
  type: TYPE_NORMAL
- en: MetaMask is an inline Internet browser bridge that facilitates significant efficiencies
    around development and testing. For example, developers can run Ethereum decentralized
    applications (dapps) right in the Internet browser (Chrome), rather than having
    to run a full Ethereum node locally. By using MetaMask, a developer can control
    both CPU utilization as well storage space requirements on their laptop, desktop,
    or server.
  prefs: []
  type: TYPE_NORMAL
- en: A full node would require more than 2 TB of data storage, whereas MetaMask is
    stored in your Internet browser. MetaMask has an ERC-20-compatible wallet and
    provides privacy and security tools to help prevent phishing.
  prefs: []
  type: TYPE_NORMAL
- en: Using MetaMask makes Ethereum development much more simplified around key management
    since it also encrypts the user's key locally and then requires the user to confirm
    the key. After confirming, the user signs the transactions/messages and then relays
    them to the Ethereum blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: MetaMask includes a secure identity vault, providing a user interface to manage
    your identities on different sites and sign blockchain transactions. MetaMask
    could also be considered a “zero client.” Zero clients run in the browser in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Use MetaMask for confirming your transaction's
  prefs: []
  type: TYPE_NORMAL
- en: Balance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gas limit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gas price
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Figure 10.5](#c10-fig-0005) shows the initial menu of a MetaMask browser login
    from Chrome. You can see contract interactions that used micro instances of gas
    usage. Micro gas usage is considered to be less than a gwei of gas units.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Screen capture depicting MetaMask browser login from Chrome.](images/c10f005.png)'
  prefs: []
  type: TYPE_IMG
- en: '[**FIGURE 10.5**](#R_c10-fig-0005) MetaMask'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can download MetaMask via a browser extension in Chrome or from `[https://metamask.io/](https://metamask.io/)`.
    Note that you should never download MetaMask from a third-party site due to the
    likelihood that the version has been tampered with or is malware.  #### MIST'
  prefs: []
  type: TYPE_NORMAL
- en: Mist has been the browser for decentralized web apps and has recently been announced
    to be deprecated. However, it is still widely used, and therefore some discussion
    on it makes sense.
  prefs: []
  type: TYPE_NORMAL
- en: Mist is an Ethereum browser where you get a web browser with direct Web3 access.
    Mist is a full node, so you don't have to connect to a third-party node. This
    is different from MetaMask in the sense that with Mist you are downloading a full
    node. In MetaMask, you do not download the full blockchain to your node (full
    node).
  prefs: []
  type: TYPE_NORMAL
- en: A full node is where the node downloads locally the full blockchain that is
    the current world state. This will take up significant resources on most average
    personal computers, so ensure that you are not already resource challenged.
  prefs: []
  type: TYPE_NORMAL
- en: Another important note is that if you only need a wallet, then don't use Mist.
    Use MetaMask instead or even MyEtherWallet.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can download Mist from `[https://github.com/ethereum/mist](https://github.com/ethereum/mist)`.  ####
    PARITY'
  prefs: []
  type: TYPE_NORMAL
- en: Parity is a lightweight browser-based wallet that gives users access to decentralized
    applications and currencies on Ethereum. Parity is an implementation written in
    Rust and is one of the most common wallet implementations used in the Ethereum
    network.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parity comes with an extensive built-in Ethereum wallet and fully functional
    dapp environment. Parity has a Web3 dapp browser and is supported on Linux, macOS,
    and Windows.  #### GETH ETHEREUM'
  prefs: []
  type: TYPE_NORMAL
- en: Geth Ethereum is an implementation of Ethereum written in the Go programming
    language. To use Geth, you need to install the command-line interface and interact
    with a full node in Go.
  prefs: []
  type: TYPE_NORMAL
- en: 'Geth is supported on various platforms such as Linux, macOS, and Windows. Geth
    is also built to be flexible in how you install it, which can be from a package
    manager, containers, or even stand-alone builds. Geth allows you to take part
    in the Ethereum mainnet and perform a number of tasks on the Ethereum blockchain,
    including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Mining ether for profit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transferring funds between Ethereum wallet addresses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the block history on the blockchain explorer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating smart contracts and dapps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Geth is available for download at `[https://github.com/ethereum/go-ethereum/wiki/Geth](https://github.com/ethereum/go-ethereum/wiki/Geth)`.  ###
    Ethereum Networks'
  prefs: []
  type: TYPE_NORMAL
- en: In Ethereum everyone can start their own blockchain based on the Ethereum protocol.
    We have a mainnet, which is the production blockchain network, and we have testing
    or development networks, which are exactly what they sound like.
  prefs: []
  type: TYPE_NORMAL
- en: You can also deploy a private Ethereum network, or you can connect to any various
    networks that are available, such as Ropsten. This means the Ethereum mainnet
    can be replicated in a way that it behaves the same way the real mainnet does.
    The benefit is that it does not require any real financial resources from the
    developer community.
  prefs: []
  type: TYPE_NORMAL
- en: 'These “testnet” networks are for testing features and functions with your Ethereum
    smart contracts. These networks, which use a network ID, can be a moving target,
    so check the addresses routinely. The best resource to keep track of these Ethereum
    networks is the Ethereum Stack Exchange, available here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[https://ethereum.stackexchange.com/questions/17051/how-to-select-a-network-id-or-is-there-a-list-of-network-ids/17101#17101](https://ethereum.stackexchange.com/questions/17051/how-to-select-a-network-id-or-is-there-a-list-of-network-ids/17101#17101)`'
  prefs: []
  type: TYPE_NORMAL
- en: Note also that not every testnet is supported in the same way, and generally
    developers tend to stick with what they are comfortable with.
  prefs: []
  type: TYPE_NORMAL
- en: Testing your smart contracts locally with MetaMask is expected. One more area
    of testing your smart contracts is to extend the test to a testnet with MetaMask.
    For example, Developers could develop locally and test to any number of supported
    testnets or the mainnet.
  prefs: []
  type: TYPE_NORMAL
- en: As shown in [Figure 10.6](#c10-fig-0006), four main testnets are supported.
    The default network setting is the mainnet with MetaMask. Ethereum best practices
    dictate to develop first locally, and then developers would want to identify which
    testnet we will use to test the application. The supported testnets with MetaMask
    include Ropsten, Kovan, Rinkeby, and Goerli. We can also create a custom remote
    procedure call (RPC) to test against an on-premises blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: '![Screen capture depicting MetaMask networks listed.](images/c10f006.png)'
  prefs: []
  type: TYPE_IMG
- en: '[**FIGURE 10.6**](#R_c10-fig-0006) MetaMask networks'
  prefs: []
  type: TYPE_NORMAL
- en: In the figure, you can see that Main Ethereum Network is the default network.
    When you change from the mainnet to the testnet, you need to ensure that you have
    test ether to perform application testing.
  prefs: []
  type: TYPE_NORMAL
- en: '#### ETHEREUM METAMASK FAUCET'
  prefs: []
  type: TYPE_NORMAL
- en: When testing your Ethereum application on a testnet, you need to obtain what
    is known as test ether for the testnets. Test ether is essentially free ether
    to use only on the testnet to perform your application testing. To request your
    test Ether, you need to go to an Ethereum faucet.
  prefs: []
  type: TYPE_NORMAL
- en: An Ethereum *faucet* is an online platform that rewards users with small amounts
    of ether (ETH) for completing a variety of microtasks such as posting social media
    notices. In return, the requester receives test ether to use on the testnet.
  prefs: []
  type: TYPE_NORMAL
- en: To use the Ethereum MetaMask faucet, you need to have MetaMask installed and
    enabled in your browser. If you do not have MetaMask, then when you go to the
    Ethereum faucet, you would receive an error stating you need to have MetaMask
    installed and enabled.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install MetaMask, go here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[https://chrome.google.com/webstore/detail/metamask/nkbihfbeogaeaoehlefnkodbefgpgknn?hl=en](https://chrome.google.com/webstore/detail/metamask/nkbihfbeogaeaoehlefnkodbefgpgknn?hl=en)`'
  prefs: []
  type: TYPE_NORMAL
- en: After installing the Chrome extension and enabling it from the extension menu
    in Chrome, you can go to `[https://faucet.metamask.io/](https://faucet.metamask.io/)`.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 10.7](#c10-fig-0007) shows the MetaMask Ether Faucet. If you want to
    obtain some test ether to run on the Ropsten testnet, select Request 1 Ether From
    Faucet.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Screen capture depicting MetaMask ether faucet.](images/c10f007.png)'
  prefs: []
  type: TYPE_IMG
- en: '[**FIGURE 10.7**](#R_c10-fig-0007) MetaMask ether faucet'
  prefs: []
  type: TYPE_NORMAL
- en: When connecting to the faucet, if your MetaMask is connected to the mainnet,
    then you would receive an error such as “currently on mainnet - please select
    the correct test network.”
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 10.8](#c10-fig-0008) shows the Connect Request screen where the developer
    need to connect our MetaMask account. Select Connect and you are on your way to
    receiving test ether.'
  prefs: []
  type: TYPE_NORMAL
- en: Once the task is done connecting the faucet, the developer then see test transactions
    under the transactions part of the faucet interface, as shown in [Figure 10.9](#c10-fig-0009).
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 10.10](#c10-fig-0010) shows the transaction details on Etherscan. When
    you click the link to a transaction, you are brought to the Ropsten testnet on
    Etherscan (`[https://ropsten.etherscan.io/tx/0x4ce3ee99e291a69f35fe00d3a84e291634ef881388adb4f77130b8bf47253017](https://ropsten.etherscan.io/tx/0x4ce3ee99e291a69f35fe00d3a84e291634ef881388adb4f77130b8bf47253017)`).  ####
    RINKEBY TEST FAUCET'
  prefs: []
  type: TYPE_NORMAL
- en: The Rinkeby Ether testnet faucet (`[https://faucet.rinkeby.io/](https://faucet.rinkeby.io/)`)
    was implemented to prevent malicious actors from utilizing all available funds.
    This faucet has a different approach in how to request or obtain test ether. The
    requests are actually done via social media. At the time of writing, a Twitter
    or Facebook account is used to request funds within the permitted limits.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image described by caption and surrounding text.](images/c10f008.png)'
  prefs: []
  type: TYPE_IMG
- en: '[**FIGURE 10.8**](#R_c10-fig-0008) Connect Request screen'
  prefs: []
  type: TYPE_NORMAL
- en: '![Screen capture depicting Faucet transactions.](images/c10f009.png)'
  prefs: []
  type: TYPE_IMG
- en: '[**FIGURE 10.9**](#R_c10-fig-0009) Faucet transactions'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 10.11](#c10-fig-0011) shows a tweet with my Ether address that I want
    to receive the Rinkeby test Ether.'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the Rinkeby site, just paste your social media link in the box and select
    how much ether you need (see [Figure 10.12](#c10-fig-0012)). Note that this is
    test ether, not something you can trade. It''s that easy: just select Give Me
    Ether, and your account should be credited for the Rinkeby network. You can go
    back to MetaMask and validate the amount was deposited.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Screen capture depicting transaction details.](images/c10f010.png)'
  prefs: []
  type: TYPE_IMG
- en: '[**FIGURE 10.10**](#R_c10-fig-0010) Ropsten testnet transaction details'
  prefs: []
  type: TYPE_NORMAL
- en: '![Screen capture depicting Requesting test ether for Rinkeby.](images/c10f011.png)'
  prefs: []
  type: TYPE_IMG
- en: '[**FIGURE 10.11**](#R_c10-fig-0011) Requesting test ether for Rinkeby'
  prefs: []
  type: TYPE_NORMAL
- en: '![Screen capture depicting Rinkeby Give Me Ether option.](images/c10f012.png)'
  prefs: []
  type: TYPE_IMG
- en: '[**FIGURE 10.12**](#R_c10-fig-0012) Rinkeby Give Me Ether option  ### Ethereum
    Nodes'
  prefs: []
  type: TYPE_NORMAL
- en: Developers new to Ethereum should pay attention to the type of nodes deployed.
    One area that makes Ethereum so flexible and powerful is the different node capabilities
    and features.
  prefs: []
  type: TYPE_NORMAL
- en: 'Think of the node types as different use cases. Some are for deploying live
    applications, some are for development, and some are for testing your blockchain
    applications. Ethereum blockchain nodes that are not simulated include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Aleth is the new name of Cpp-ethereum, a collection of C++ libraries and tools
    for Ethereum blockchain. Aleth is supported on Ubuntu, macOS, and Windows.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go-Ethereum (GETH) is one of the three original implementations of the Ethereum
    protocol. It is written in Go, is a fully open source, and is licensed under the
    GNU LGPL v3\. It is supported as a stand-alone client, or you can install libraries.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Parity is an Ethereum client and is written in the Rust language. Parity is
    a full node with the following node options: Full Working Node, Light, Warp, Full
    Node, or Archive node.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can use simulations as well to mimic the real blockchain for development
    purposes. In-memory blockchain simulations for rapid development include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: TestRPC, which is the Ethereum blockchain simulator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ganache, which allows you to create a private blockchain for simulation and
    which uses the Ganache CLI, which then uses Ethereum's to simulate full client
    behavior
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Truffle Developer Console, which uses Ganache as part of the Truffle suite
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clients can gain access to the blockchain in several convenient ways.
  prefs: []
  type: TYPE_NORMAL
- en: MetaMask browser plugin through Infura
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: StatusIM Android or with iOS app through Infura
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Status IM is an application that combines a messenger, a crypto wallet, and
    the Web3 browser. You can find information about it at `[https://status.im/](https://status.im/)`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Infura is a development suite that provides an instant, scalable API access
    to the Ethereum and IPFS networks. For more information, visit `[https://infura.io/](https://infura.io/)`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: MIST dapp browser with integrated Geth
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are some simple ways to get started running a private blockchain test.
    For example, you are considering using Truffle there are three typical steps.
  prefs: []
  type: TYPE_NORMAL
- en: Log in and then spin up a Truffle project. The project needs to lay out the
    implicit structure of your project. You can run the test on the mainnet, on Ganache
    as a private test blockchain.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the deployment file. You would point your project either to use Ganache
    or to use the mainnet network.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the `truffle` migrate command. This will automatically run `truffle` compile,
    which will deploy the smart contracts on the network specified.  ### Solidity
    Programming Language'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ethereum-based applications and smart contracts are written in Solidity, a language
    specifically designed to utilize the EVM.
  prefs: []
  type: TYPE_NORMAL
- en: Solidity, which was proposed in August 2014 by Dr. Gavin Wood, is similar to
    C. It is also similar to JavaScript, although it uses a whole new framework. Developers
    versed in JavaScript will have only a small knowledge gap to overcome. JavaScript
    is a universal language for the Web and is being used in a large number of applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Solidity is also similar to object-oriented languages like C++ and C#, whereas
    JavaScript is based on HTML and influenced by languages such as Self and Scheme.
    When it comes to handling complex data structures, Solidity is similar to Java
    in many respects. Solidity is designed specifically for Ethereum applications
    and runs only on the Ethereum blockchain.  ### Ethereum APIs'
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum uses JSON, a lightweight data-interchange format, for its API library.
    It can represent numbers, strings, ordered sequences of values, and collections
    of name-value pairs.
  prefs: []
  type: TYPE_NORMAL
- en: Application programming interfaces (APIs) are used to interact with the blockchain
    network. APIs are meant to provide a rapid on-ramp for developers. They are also
    referred to as *endpoints*.
  prefs: []
  type: TYPE_NORMAL
- en: To talk to an Ethereum node from inside a JavaScript application, use the web3.js
    library, which gives a convenient interface for the RPC methods. For example,
    if you wanted to have your application access the Ethereum blockchain with Etherscan,
    you would want an API for that. The API for Etherscan is located at `[https://etherscan.io/apis](https://etherscan.io/apis)`.
  prefs: []
  type: TYPE_NORMAL
- en: '#### REMIX'
  prefs: []
  type: TYPE_NORMAL
- en: Remix (`[https://remix.ethereum.org/](https://remix.ethereum.org/)`), also known
    as the Solidity browser, is a browser-based IDE that was built by the Ethereum
    development team to address ease of development. The Remix IDE is used to write,
    compile, and debug Solidity code.
  prefs: []
  type: TYPE_NORMAL
- en: Remix is more than just a powerful, open source development tool that enables
    you to write Solidity contracts straight from your browser. Remix is also an online
    learning solution since it enables developers to really get up to speed quickly
    around smart contract development. Remix supports development both locally and
    online.
  prefs: []
  type: TYPE_NORMAL
- en: Remix has what developers would consider modules. A module is basically a plugin
    that can be added to the development environment that is being used in Remix.
  prefs: []
  type: TYPE_NORMAL
- en: '![Screen capture depicting Remix interface.](images/c10f013.png)'
  prefs: []
  type: TYPE_IMG
- en: '[**FIGURE 10.13**](#R_c10-fig-0013) Remix interface'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 10.13](#c10-fig-0013) shows the Remix interface, which was recently
    updated at the time of writing.'
  prefs: []
  type: TYPE_NORMAL
- en: Remix includes a plugin for Etherscan Contract Verification. You can use the
    tool to verify that the code deployed with a contract is valid and to publish
    the code on Etherscan.
  prefs: []
  type: TYPE_NORMAL
- en: Another useful feature is that you can choose your compiler version and also
    correlate this version to a nightly build. You can simply compile your code with
    different compilers and validate how these builds work out.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 10.14](#c10-fig-0014) shows an example of running test code in a specific
    version of the compiler and then receiving a green checkmark on the left sidebar
    indicating that the code was compiled successfully.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Screen capture depicting Compile successful message in an example of running
    test code.](images/c10f014.png)'
  prefs: []
  type: TYPE_IMG
- en: '[**FIGURE 10.14**](#R_c10-fig-0014) Compile successful'
  prefs: []
  type: TYPE_NORMAL
- en: Another great feature is that you can push your code to Ethereum Swarm. Ethereum
    Swarm is a peer-to-peer (P2P) file storage distributed network that allows the
    distributed and encrypted storage of users' data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remix is a powerful yet complex tool since the ecosystem has grown significantly.
    It is the best way to learn Solidity for most developers wanting to develop in
    Ethereum.  #### VYPER'
  prefs: []
  type: TYPE_NORMAL
- en: Vyper is a contract-oriented Pythonic programming language that specifically
    targets the EVM. It is still an experimental programming language, but it compiles
    down to EVM bytecode, just as does Solidity.
  prefs: []
  type: TYPE_NORMAL
- en: Vyper is designed to be a simple-to-create and easy-to-comprehend smart contract
    engine that provides more transparency for all parties involved.
  prefs: []
  type: TYPE_NORMAL
- en: 'Vyper looks logically similar to Solidity and has some similarities to Python
    as well. Vyper is still in beta mode at the time of writing, so I won''t cover
    it in detail.  #### WEB3-ETH'
  prefs: []
  type: TYPE_NORMAL
- en: Web3-eth is used for blockchain and smart contract development in Ethereum.
    The library is Web3, and I like to consider it an “on-ramp” to Ethereum development
    and the world of decentralized applications.
  prefs: []
  type: TYPE_NORMAL
- en: You can use Web3-eth with Ganache, for example, and create test accounts to
    test your smart contracts. You can specify ether to transfer from and to your
    accounts. There are many more features about Web3-eth that support the rapid development
    of decentralized applications.
  prefs: []
  type: TYPE_NORMAL
- en: The main challenge with Web3 is that if you're not careful with your development,
    you may actually be using a version that has some differences in how you would
    interact with the libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'After downloading the Web3 library, you would simply initialize your application
    node by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Before doing anything, refer to the web3 documentation at `[https://web3js.readthedocs.io/en/1.0/getting-started.html](https://web3js.readthedocs.io/en/1.0/getting-started.html)`.  ###
    Ethereum Testing'
  prefs: []
  type: TYPE_NORMAL
- en: Software development generally has a flow that has been widely accepted, and
    this is true in the world of blockchain development as well. The main differences
    are that in blockchain the steps are different, and comparatively there is an
    additional step.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 10.3](#c10-tbl-0003) compares the generally accepted steps in traditional
    software development to blockchain development.'
  prefs: []
  type: TYPE_NORMAL
- en: '[**TABLE 10.3**](#R_c10-tbl-0003): Traditional vs. Blockchain Development'
  prefs: []
  type: TYPE_NORMAL
- en: '| TRADITIONAL SOFTWARE DEVELOPMENT PHASE | BLOCKCHAIN SOFTWARE DEVELOPMENT
    PHASE |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Prototype | Prototype |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha/Beta | Framework testing |'
  prefs: []
  type: TYPE_TB
- en: '| Production | Private chain testing |'
  prefs: []
  type: TYPE_TB
- en: '| Update release | Testnet |'
  prefs: []
  type: TYPE_TB
- en: '|  | Mainnet |'
  prefs: []
  type: TYPE_TB
- en: The main point to understand is that there are software development phases in
    blockchain, and we must approach them differently. Blockchains deploy smart contracts
    and therefore, will likely be simpler to develop than typical enterprise applications.
    However, the main difference to be aware of is that smart contracts, once deployed
    to some blockchains, are immutable.
  prefs: []
  type: TYPE_NORMAL
- en: '#### ETHEREUM TESTNETS'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before deploying your application on the mainnet, you would want to test it
    on the Ethereum testnet(s). The following testnets are available directly from
    MetaMask:'
  prefs: []
  type: TYPE_NORMAL
- en: Rikeby
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ropsten
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kovan
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The testnets, even though for testing, require the use of ether, albeit test
    ether, which is used to maintain the nodes. You can gain the test ether in several
    ways, such as by mining the testnet or by using a faucet.  #### TRUFFLE SUITE'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Truffle Suite is essentially a suite of dapp solutions. The following solutions
    are part of the Truffle Suite:'
  prefs: []
  type: TYPE_NORMAL
- en: Truffle, which is the IDE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ganache, which allows developers to deploy a personal blockchain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Drizzle, which contains all the needed front-end libraries  #### TRUFFLE'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Truffle is a developer environment, testing framework, and asset pipeline for
    blockchains. Truffle is essentially a JavaScript library that's based on NodeJS.
    Truffle is immensely popular and growing in usage monthly. Truffle was developed
    by Consensus.
  prefs: []
  type: TYPE_NORMAL
- en: Truffle allows developers to spin up smart contract projects at the click of
    a button and provides you with a project structure, files, and directories that
    make deployment and testing much easier (or else you would have to configure these
    yourself).
  prefs: []
  type: TYPE_NORMAL
- en: To install and run Truffle, you first need to install Node and the Node Package
    Manager (NPM). This can be found at `[https://nodejs.org/en/40T](https://nodejs.org/en/40T)`.
    After installing Node, you can go to any command-line interface (Terminal on Mac/Linux
    or PowerShell on Windows) and interact with npm.
  prefs: []
  type: TYPE_NORMAL
- en: One interesting project from the Truffle framework is Truffle Box. These are
    preconfigured “mini scaffolding projects” that make starting a new distributed
    application much more streamlined. The list of truffle boxes can be found at `[http://truffleframework.com/boxes/40T](http://truffleframework.com/boxes/40T)`.
  prefs: []
  type: TYPE_NORMAL
- en: Use a baseline JavaScript, React, Angular, or other language to start off with
    a Truffle box.
  prefs: []
  type: TYPE_NORMAL
- en: You can view the number of downloads for the suite at the dashboard (`[https://truffleframework.com/dashboard](https://truffleframework.com/dashboard)`).
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 10.15](#c10-fig-0015) shows the Truffle Suite Activity Dashboard.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Truffle Suite can be downloaded from `[https://truffleframework.com/](https://truffleframework.com/)`.  ####
    GANACHE'
  prefs: []
  type: TYPE_NORMAL
- en: 'Ganache CLI is the latest version of TestRPC: a fast and customizable blockchain
    emulator. It allows you to make calls to the blockchain without the overhead of
    running an actual Ethereum node. Transactions are mined instantly.'
  prefs: []
  type: TYPE_NORMAL
- en: You can think of Ganache as a personal blockchain for Ethereum development you
    can use to deploy contracts, develop your applications, and run tests. It is available
    as both a desktop application and a command-line tool.
  prefs: []
  type: TYPE_NORMAL
- en: Ganache is available for Windows, Mac, and Linux. Many developers use Ganache
    to test their smart contracts during development. It provides convenient tools
    such as advanced mining controls and a built-in block explorer. ![Image described
    by caption and surrounding text.](images/c10f015.png)
  prefs: []
  type: TYPE_NORMAL
- en: '[**FIGURE 10.15**](#R_c10-fig-0015) Truffle Activity Dashboard'
  prefs: []
  type: TYPE_NORMAL
- en: '#### DRIZZLE'
  prefs: []
  type: TYPE_NORMAL
- en: 'Drizzle is a collection of front-end libraries that make writing dapp front
    ends simple, more efficient, and more predictable. The main core of Drizzle is
    based on a Redux store, and you access the development tools for Redux. The Drizzle
    package takes care of synchronization of your Ethereum-based services.  #### TRUFFLE
    OR GANACHE?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Deciding when to use Truffle or Ganache can be a bit confusing because the
    solutions have some overlap in capabilities. Here are some tips to help you decide
    whether to use Truffle or Ganache:'
  prefs: []
  type: TYPE_NORMAL
- en: Truffle will enable you to develop, test, and deploy your dapp, and it has integration
    with Ganache.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ganache is part of the Truffle ecosystem, and you would use Ganache for the
    development of your dapps. Ganache essentially mimics a real blockchain. You could
    also pass on using Ganache and use Truffle to tie into a public testnet or deploy
    locally.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once the dapps are developed and tested, you then deploy them on an Ethereum
    client using Geth or Parity.  #### OPEN ZEPPELIN'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open Zeppelin is a well-formatted and prevalent framework of reusable smart
    contracts for Ethereum and other EVM-based blockchains. Open Zeppelin is a library
    for secure smart contract development.
  prefs: []
  type: TYPE_NORMAL
- en: It provides implementations of standards like ERC-20 and ERC-721, which you
    can deploy as-is or extend to suit your needs, as well as Solidity components
    to build custom contracts and more complex decentralized systems.
  prefs: []
  type: TYPE_NORMAL
- en: The reusable smart contracts are useful since they have been reviewed by peers
    and therefore audited. Using a template that would be ready, of course, provides
    benefits such as shortened development time and quicker time to market.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information about Open Zeppelin, visit `[https://openzeppelin.org/](https://openzeppelin.org/)`.  ####
    PRIVATE BLOCKCHAIN TESTING'
  prefs: []
  type: TYPE_NORMAL
- en: 'One area of interest for developers is to be able to deploy, test, and validate
    an application locally and not have to connect to a VPN. Or perhaps you are developing
    applications and want to ensure specific variables for the networking are available.
    You would want to go with a private deployment such as Ganache.  #### ETHEREUM
    TOKENS'
  prefs: []
  type: TYPE_NORMAL
- en: Tokens are created to specific standards in Ethereum called the ERC-20 standards.
    Tokens in the Ethereum ecosystem can represent any fungible tradable item such
    as loyalty points, metal certificates, IOUs, coins, etc.
  prefs: []
  type: TYPE_NORMAL
- en: Tokens implement some basic features in a standard way in most cases, so this
    means that your token would be likely compatible with the Ethereum wallet or any
    other client or contract that uses the same standards.
  prefs: []
  type: TYPE_NORMAL
- en: 'These tokens will need to follow specific standards, also referred to as *constants*.
    Examples include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Symbol, which is your token's symbol or ticker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Name, which is the name you give it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Total supply, which specifies the number of tokens issued
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decimals, which are the number of decimals used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The standards are listed at `[Ethereum.org/token](http://ethereum.org/token)`.  ####
    ETHEREUM REQUEST FOR COMMENTS'
  prefs: []
  type: TYPE_NORMAL
- en: 'An Ethereum request for comments (ERC) is a glorified GitHub issue tracker.
    This is the main point of contact where developers can ask for comments on contracts
    and other issues related to Ethereum proposals. An ERC starts with #1 and increments
    every time a new issue is opened.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find ERCs at `[https://eips.ethereum.org/erc](https://eips.ethereum.org/erc)`.  ####
    ETHEREUM ERC TOKEN (ERC-20)'
  prefs: []
  type: TYPE_NORMAL
- en: The ERC-20 token contract is the “standard” template to deploy fungible tokens
    on the Ethereum blockchain as a smart contract. The ERC token standard is basically
    a standard interface as well as a sample implementation of the functions necessary
    to create and operate an ERC-20 token.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ethereum developers need to be very cognizant of how they develop applications.
    One way is to follow the ERC-20 standards. The ERC-20 standards serve several
    purposes, but the main purpose is focused on portability of the contracts.  ####
    ETHEREUM IMPROVEMENT PROPOSALS'
  prefs: []
  type: TYPE_NORMAL
- en: 'Ethereum Improvement Proposals (EIPs) have the same format as ERCs but are
    used to propose changes in the Ethereum protocol. EIPs serve the same purpose
    as Bitcoin Improvement Proposals (BIPs). BIPs are used to introduce new features
    or information important to Bitcoin. EIPs start with EIP #1 and increment every
    time a new issue is opened.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To find out more, visit `[https://github.com/ethereum/EIPs](https://github.com/ethereum/EIPs)`.  ##
    Hyperledger Development'
  prefs: []
  type: TYPE_NORMAL
- en: Developing applications in Hyperledger Fabric has some great benefits. The Hyperledger
    ecosystem is robust and well maintained for an open source project. The Hyperledger
    Project leaves little out for options in development and is clearly the most well-managed
    blockchain project.
  prefs: []
  type: TYPE_NORMAL
- en: This section provides a broad idea of what a developer in Hyperledger Fabric
    would need to deal with and develop around.
  prefs: []
  type: TYPE_NORMAL
- en: '### Chaincode'
  prefs: []
  type: TYPE_NORMAL
- en: Chaincode is a smart contract in Hyperledger Fabric and is invoked by a client
    application external to the blockchain network that manages access and modifications
    to a set of key-value pairs in the world state. The world state is the actual
    state of the current blockchain transactions that are recorded immutably.
  prefs: []
  type: TYPE_NORMAL
- en: Chaincode services are secured and lightweight since the environment is deployed
    as a locked-down, secured container. This container has a set of signed base images
    that contain the secure OS and chaincode language, runtime, and SDK images for
    Golang, Java, and Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: Every chaincode must implement the chaincode interface, which is what is used
    to provide connections similar to an endpoint in cloud computing. The chaincode
    interface makes it possible for the client application to invoke a function that
    is called in response to the received transaction proposals. Chaincode implements
    the chaincode interface, in particular the `Init` and `Invoke` functions.
  prefs: []
  type: TYPE_NORMAL
- en: '#### INSTALLING CHAINCODE'
  prefs: []
  type: TYPE_NORMAL
- en: When installing chaincode, you should ensure that you have the Go programming
    language installed first and then set up with the correct configuration requirements
    for your deployment type.
  prefs: []
  type: TYPE_NORMAL
- en: You will want to make sure that a directory is created for your chaincode application
    as a child directory of `$GOPATH/src/.`
  prefs: []
  type: TYPE_NORMAL
- en: The following command will create such a directory called `wiley:code:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To enter into the directory, you can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To create the source file for the chaincode, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]  #### WRITING CHAINCODE CONSIDERATIONS'
  prefs: []
  type: TYPE_NORMAL
- en: After installing Go and setting up your environment, you then can start developing
    your chaincode.
  prefs: []
  type: TYPE_NORMAL
- en: Note this book will not be teaching chaincode but is organized to provide insight
    into the tasks developers would need to consider around Hyperledger development.
    Some of these tasks are different from Ethereum and worth noting for hiring managers
    to appreciate.
  prefs: []
  type: TYPE_NORMAL
- en: The next thing you could do is then implement the init function. The init is
    called during chaincode instantiation and will initialize any data as part of
    the chaincode. Chaincode applications will implement the two functions that would
    be invoked via the invoke function.
  prefs: []
  type: TYPE_NORMAL
- en: One area of confusion when setting your platform is around the database options.
    You may need to pay attention to the chaincode design if complex queries are based
    on an expected invocation sequence.
  prefs: []
  type: TYPE_NORMAL
- en: This confusion can occur because an invalid transaction may very well occur
    if you're not aware of the database options for the state data. The state database
    could be written in LevelDB or in CouchDB.
  prefs: []
  type: TYPE_NORMAL
- en: 'For tutorial information on getting started with chaincode, refer to the following
    site:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[https://hyperledger-fabric.readthedocs.io/en/release-1.4/chaincode.html](https://hyperledger-fabric.readthedocs.io/en/release-1.4/chaincode.html)`  ####
    BLOCKCHAIN PLATFORM EXTENSION'
  prefs: []
  type: TYPE_NORMAL
- en: The IBM Blockchain Platform Extension for VSCode helps Hyperledger Fabric developers
    to rapidly develop, provision, and test their chaincode. This also could be used
    to test client applications on their local machines. The extension is currently
    supported on Windows 10, Linux, and macOS.
  prefs: []
  type: TYPE_NORMAL
- en: The extension works by creating a basic smart contract that locally manages
    an example asset in a development language of your choice.
  prefs: []
  type: TYPE_NORMAL
- en: What is really helpful is that the extension provides all the dependencies that
    are required to deploy your smart contract to an instance of Hyperledger Fabric
    directly. These features enable efficient development for your chaincode on the
    IBM Blockchain service.
  prefs: []
  type: TYPE_NORMAL
- en: 'To find out more about the VSCode extension, refer to the following site:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[https://cloud.ibm.com/docs/services/blockchain?topic=blockchain-develop-vscode](https://cloud.ibm.com/docs/services/blockchain?topic=blockchain-develop-vscode)`  ###
    Hyperledger Fabric Consensus Options'
  prefs: []
  type: TYPE_NORMAL
- en: Hyperledger Fabric has two consensus options, and it is important to understand
    the difference from a development perspective. You cannot just roll back once
    you deploy your blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: Solo, which is for development, is a single node with no high availability.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kafka is the production version that would be deployed on a live blockchain.
    Kafka is as close to a voting-based consensus as you get in Hyperledger.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As discussed in [Chapter 2](c02.xhtml), consensus methods have different benefits
    but also cons. For example, having more nodes means more time to reach consensus.
    There''s also a trade-off between scalability and performance that developers
    should be aware of. The Hyperledger Fabric white paper on consensus is the main
    starting point. To find out more, see the following site:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[https://www.hyperledger.org/wp-content/uploads/2017/08/Hyperledger_Arch_WG_Paper_1_Consensus.pdf](https://www.hyperledger.org/wp-content/uploads/2017/08/Hyperledger_Arch_WG_Paper_1_Consensus.pdf)`  ###
    Hyperledger Fabric Database Options'
  prefs: []
  type: TYPE_NORMAL
- en: One of the important things to consider is the power of Hyperledger Fabric with
    the option of its state database. The ledger system in Hyperledger Fabric uses
    LevelDB, which allows concurrent writers to safely insert data into the database
    by providing internal synchronization.
  prefs: []
  type: TYPE_NORMAL
- en: State database options include LevelDB and CouchDB. LevelDB is the default key-value
    state database embedded in the peer process. CouchDB is an alternative external
    state database that supports binary data.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 10.4](#c10-tbl-0004) shows the options for both the transaction logs
    and the state database.'
  prefs: []
  type: TYPE_NORMAL
- en: '[**TABLE 10.4**](#R_c10-tbl-0004): Transaction Log and State Database Options'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | TRANSACTION LOGS | STATE DATA (WORLD STATE) |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **Type** | Immutable | Mutable |'
  prefs: []
  type: TYPE_TB
- en: '| **Operations** | Create, retrieve | All CRUD |'
  prefs: []
  type: TYPE_TB
- en: '| **DC** | LevelDB | LevelDB/CouchDB |'
  prefs: []
  type: TYPE_TB
- en: '| **Attitude** | Embedded in peers | Key-value paired (JSON, binary) |'
  prefs: []
  type: TYPE_TB
- en: '| **Query** | Simple | CouchDB for complex (binary) |'
  prefs: []
  type: TYPE_TB
- en: 'It''s important to note that when assets are stored in the form of JSON documents,
    CouchDB allows you to perform complex queries for assets based on the asset state,
    for example. There really is no learning curve since the queries are formatted
    just like in CouchDB''s declarative JSON querying syntax format.  ### Client Applications'
  prefs: []
  type: TYPE_NORMAL
- en: 'When developing client applications for blockchains, and specifically Hyperledger
    Fabric, there are some important considerations to design for depending on your
    specific use case. These client front-end considerations include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Secure the REST server via a secure protocol (HTTPS).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use authentication options such as a passport through Oath or supported platforms.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use multiuser mode for the REST API service.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand the complete use case considerations for the blockchain applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the current enterprise key management system (KMS).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the current software development kits (SDKs) to ensure you're running the
    latest versions of supported components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Figure 10.16](#c10-fig-0016) shows the different layers of Hyperledger blockchain
    development. From a development perspective, if you are developing a blockchain
    application that is for the end user, that is considered front-end development.
    In front-end development, there would be development applications, wallets, mobile
    applications, monitoring tools.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image described by caption and surrounding text.](images/c10f016.png)'
  prefs: []
  type: TYPE_IMG
- en: '[**FIGURE 10.16**](#R_c10-fig-0016) Front-end application workflow'
  prefs: []
  type: TYPE_NORMAL
- en: Hyperledger Fabric's business network archive (package) comprises the model
    file, chaincode, access control file, and static query file.
  prefs: []
  type: TYPE_NORMAL
- en: The native query language can filter results returned by using clearly defined
    criteria. The native query language can also be invoked in transactions to perform
    operations such as an update.
  prefs: []
  type: TYPE_NORMAL
- en: Blockchain queries are defined in a query file (`.qry`) in the parent directory
    of the business network definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Events that occur will create notifications of significant operations on the
    blockchain (e.g., a new block), as well as notifications related to a milestone
    achieved while processing a smart contract/chaincode. The client app can subscribe
    to this event and take appropriate business actions.  ### Fabric REST Services'
  prefs: []
  type: TYPE_NORMAL
- en: The REST server uses a business network card specified during startup to connect
    to and discover the assets, participants, and transactions within a deployed business
    network. This information visibility is required to generate the REST API. The
    business network card is known as the discovery business network card. By default,
    the discovery business network card is also used to handle all requests to the
    REST API.
  prefs: []
  type: TYPE_NORMAL
- en: Chaincode Services uses Docker to host (deploy) the chaincode without relying
    on any virtual machine or computer language. Docker provides a secured, lightweight
    method to sandbox chaincode execution. The environment is a “locked-down” and
    secured container, along with a set of signed base images containing secure OS
    and chaincode language, runtime, and SDK images for Golang.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hyperledger includes the REST and JSON RPC APIs, events, and an SDK for applications
    to communicate with the network.  ### Service Discovery'
  prefs: []
  type: TYPE_NORMAL
- en: To execute chaincode on peers, to submit transactions to orderers, and to be
    updated about the status of transactions, applications connect to an API exposed
    by an SDK. The discovery service improves this process by having the peers compute
    the needed information dynamically and present it to the SDK in a consumable manner.
  prefs: []
  type: TYPE_NORMAL
- en: The application is bootstrapped knowing about a group of peers that are trusted
    by the application developer/administrator to provide authentic responses to discovery
    queries.
  prefs: []
  type: TYPE_NORMAL
- en: 'A good candidate peer that needs to be used by the client application is one
    that is in the same organization.  ### Hyperledger Composer'
  prefs: []
  type: TYPE_NORMAL
- en: Contributed by IBM and Oxgcains, Hyperledger Composer is an open source application
    development framework that was specifically built for Hyperledger. Composer simplifies
    the creation of Hyperledger Fabric blockchain applications and therefore brings
    efficiencies into the development cycle.
  prefs: []
  type: TYPE_NORMAL
- en: The Composer tool is aimed at helping users to create blockchain applications
    based on Hyperledger Fabric without needing to know the low-level Go programming
    details that are involved in blockchain networks.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to build your blockchain application directly on Hyperledger Fabric,
    you have to write your chaincode in Go or Java, which is comparatively different
    from JavaScript because its composer is quite easy to code smart contract using
    a model file (`.cto`) and angular JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Hyperledger Composer primarily uses JavaScript for chaincode development, and
    this has a lower barrier to entry as well.
  prefs: []
  type: TYPE_NORMAL
- en: Hyperledger Composer uses what's called *connection profiles* to define the
    system to connect to a connection profile, which is a JSON document that acts
    as part of a business network card. The connection profile describes a distinct
    set of components, including peers, orderers, and certificate authorities in a
    Hyperledger Fabric blockchain network. A connection profile is normally created
    by an administrator who understands the network topology.
  prefs: []
  type: TYPE_NORMAL
- en: You can use queries to get data about the state of the blockchain. Queries are
    defined within a business network and can include variable parameters. Queries
    are sent using the Composer API.
  prefs: []
  type: TYPE_NORMAL
- en: Events in Composer are defined in the business network definition in the same
    way as participants or assets. Events are emitted by the transaction processor
    function once it has been defined. An event indicates to external systems that
    something important has occurred on the ledger. Applications subscribe to emitted
    events using the Composer client API.
  prefs: []
  type: TYPE_NORMAL
- en: Developers of the business network can create a set of access controls. Access
    controls are rules that determine which assets participants have access to in
    the business network and the conditions in which they can access them.
  prefs: []
  type: TYPE_NORMAL
- en: A historian is a specialized type of registry that records successful transactions
    conducted on the business network.
  prefs: []
  type: TYPE_NORMAL
- en: '#### HYPERLEDGER COMPOSER MODELING LANGUAGE'
  prefs: []
  type: TYPE_NORMAL
- en: Hyperledger Composer is an object-oriented modeling language that defines the
    domain model for a business.
  prefs: []
  type: TYPE_NORMAL
- en: 'The modeling language is saved as a `.cto` file. The CTO file contains the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: A single namespace, in which all resource declarations are implicit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A set of resource definitions that includes assets, transactions, participants,
    and events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The option to import resources from other namespaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a system namespace that contains base definitions of the asset, event,
    participant, and transactions. These base definitions are abstract types that
    are implicitly extended by all new assets, events, participants, and transactions.
  prefs: []
  type: TYPE_NORMAL
- en: Events and transactions in the system namespace are defined by an eventID and
    transactionID, respectively, and a timestamp.
  prefs: []
  type: TYPE_NORMAL
- en: 'The system namespace also includes a historian, which is a specialized registry
    that records successful transactions on the blockchain, as well as the participants
    and identities that submit transaction requests.  #### HYPERLEDGER COMPOSER RESOURCES'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Composer, resources are considered one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Assets, participants, transactions, and events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enumerated types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concepts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example of `Vehicle` as a super-type and `Car` as an asset with
    a set of parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In Composer, concepts are abstract classes that are not considered an asset,
    participant, or transaction. Concepts would need to be clearly defined because
    of this abstract quality. A mode of transportation could be a car, motorcycle,
    plane, boat, or any other mode of transport. We need to accommodate the possibility
    that a concept is abstract by adding strings and declaring the concepts to the
    code.
  prefs: []
  type: TYPE_NORMAL
- en: The following code shows how to identify New York as a string in the program.
    This code is extending the possibility of New York City being either a street,
    a city, or a state in the United States. A concept then is added to address the
    possibility of New York City also being a street, city, or state in Canada.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Other programming areas that Composer can address include arrays, primitives,
    field validators, relationships, imports, and decorators.  #### HYPERLEDGER COMPOSER
    PLAYGROUND'
  prefs: []
  type: TYPE_NORMAL
- en: Hyperledger Composer Playground, a free sandbox maintained by IBM, provides
    an environment that quickly models and tests a blockchain network. Composer Playground
    has a simple GUI to edit and test the business blockchain network. Playground
    simplifies what is normally a complex blockchain network for running blockchain
    testing.
  prefs: []
  type: TYPE_NORMAL
- en: There is both an online version and an offline version of Playground. The online
    playground runs the business network in browser memory, and the local playground
    is deployed in Hyperledger Fabric instances.
  prefs: []
  type: TYPE_NORMAL
- en: We can use Hyperledger Composer or Composer Playground to develop, test, and
    validate our blockchain ideas by deploying a new business network to Hyperledger
    Fabric. Composer is not a live blockchain and is exclusively focused on preproduction
    use cases.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 10.17](#c10-fig-0017) shows the Hyperledger Composer Playground login
    prompt.'
  prefs: []
  type: TYPE_NORMAL
- en: Composer Playground is currently available at `[https://composer-playground.mybluemix.net/](https://composer-playground.mybluemix.net/)`.
  prefs: []
  type: TYPE_NORMAL
- en: Hyperledger Fabric v1.4+, which should feature significant improvements to the
    developer experience, will include a new programming model. Note that Composer
    Playground will likely be deprecated in the future, but no clear road map has
    been released at the time of writing.
  prefs: []
  type: TYPE_NORMAL
- en: '![Screen capture depicting Hyperledger Fabric Playground login.](images/c10f017.png)'
  prefs: []
  type: TYPE_IMG
- en: '[**FIGURE 10.17**](#R_c10-fig-0017) Hyperledger Fabric Playground login  ##
    R3 Corda Development'
  prefs: []
  type: TYPE_NORMAL
- en: Corda is written in Kotlin and is compatible with any JVM language. Kotlin is
    an odd language to some programmers who prefer Scala, for example. Kotlin does
    have a better type inference, better generics with type variance, and a more modern
    syntax.
  prefs: []
  type: TYPE_NORMAL
- en: The two most popular languages for Corda development are Java and Kotlin. The
    real key is that it has great flexibility and interoperability with Java in both
    directions in programming perspectives.
  prefs: []
  type: TYPE_NORMAL
- en: 'R3 Corda is primarily focused on implementing solutions for regulated financial
    services. Therefore, the development of Corda solutions often involves many types
    of financial assets. Some of the common financial assets that are defined in Corda
    contracts include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Cash
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stocks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bonds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Futures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Credit letters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Derivatives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interest rate swaps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A financial transaction is an agreement between buyer and seller parties to
    exchange one or more asset for payment of monetary value. This is essentially
    the focus of the smart contracts in Corda.
  prefs: []
  type: TYPE_NORMAL
- en: When developing in Corda, there two main types of assets.
  prefs: []
  type: TYPE_NORMAL
- en: Fungible assets, which are homogenous and are divisible, mergeable, and interchangeable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nonfungible assets, which are unique and represent something that is not divisible,
    mergeable, or interchangeable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I won't cover the business part of the house for the assets, so you may want
    to research more if this is of interest.
  prefs: []
  type: TYPE_NORMAL
- en: '### Corda Consensus Model'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consensus in Corda is handled somewhat differently in some respects from other
    blockchains in that the unit of consensus in Corda is the state that can be handled
    in two distinct parts. In other blockchains state is considered less flexible—state
    meaning the current transaction view of the blockchain. Consensus in Corda is
    broken into two distinct parts: consensus over state validity and consensus over
    state uniqueness.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Consensus over state validity* is when the blockchain members reach certainty
    that a transaction is accepted by the contract''s states and has all the required
    signatures.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Consensus over state uniqueness* is when the blockchain members reach certainty
    that the output states created in a transaction are actually unique and not previously
    consumed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Corda has pluggable uniqueness services to improve privacy, scalability, legal-system
    compatibility, and algorithmic agility.
  prefs: []
  type: TYPE_NORMAL
- en: Pluggable uniqueness services in Corda with the use of shared cryptographic
    hashes ensure that restrictive viewing of transactions provide for the scalability
    and privacy required.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information on the Corda consensus model, refer to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[https://docs.corda.net/releases/release-M9.2/key-concepts-consensus-notaries.html](https://docs.corda.net/releases/release-M9.2/key-concepts-consensus-notaries.html)`  ###
    CorDapps'
  prefs: []
  type: TYPE_NORMAL
- en: Developing applications in Corda revolves around the CorDapp (Corda distributed
    app) and how you define the business logic. The customer's main objective of any
    CorDapp is to allow participants to reach an agreement about transactions to the
    globally distributed ledger.
  prefs: []
  type: TYPE_NORMAL
- en: CorDapps achieve this main objective by defining flows (*workflows*) that Corda
    node owners must invoke via RPCs. It is important to note that the core of contracts
    in Corda is an executable program that authenticates changes to all state objects
    in Corda transactions.
  prefs: []
  type: TYPE_NORMAL
- en: 'CorDapps consist of the following software components:'
  prefs: []
  type: TYPE_NORMAL
- en: States define the facts over how an agreement will be reached.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Contracts define what constitutes a valid global ledger update.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Services provide the functions of the node—for example, what the node role is,
    such as a notary.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flows specify the entire life cycle of state changes by invoking the smart contract
    that is consistent and related to the current state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service hubs maintain services and support APIs for accessing and controlling
    many aspects of the Corda platform from within server-side CorDapps code, not
    RPC client-side code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Client RPC operations are remote procedure calls.  ### Corda Network and Nodes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Corda network consists of a number of machines running nodes, including a
    single node operating as the network map service. These nodes communicate using
    persistent protocols in order to create and validate transactions.
  prefs: []
  type: TYPE_NORMAL
- en: A Corda network is a connected graph. There is no global broadcast. The network
    maintains point-to-point and nonpersistent connections and supports AMQP/1.0 over
    TLS. Corda runs on a semiprivate permissioned network.
  prefs: []
  type: TYPE_NORMAL
- en: A Corda node is a process that runs with a Java virtual machine (JVM). The Corda
    node's properties consist of several types of services and support custom functionality
    such as CorDapps.
  prefs: []
  type: TYPE_NORMAL
- en: Nodes interact with each other following the flow framework, which reflects
    the business logic of the proposed transaction, and the custom functionality,
    which is dictated by the CorDapps. After the flow framework has been verified
    and completed, the transaction is committed to the ledger.
  prefs: []
  type: TYPE_NORMAL
- en: To set up Corda nodes, you should use the templates provided by Corda. These
    templates are available in Kotlin and Java from GitHub (`[https://github.com/corda](https://github.com/corda)`).
  prefs: []
  type: TYPE_NORMAL
- en: 'When you are done setting up the Corda templates, you then would need to set
    up the network with a number of participants (nodes) by configuring the XML file.  ###
    Corda Service Hub'
  prefs: []
  type: TYPE_NORMAL
- en: Corda nodes have something unique in the blockchain world—a service hub. The
    service hub maintains services and supports APIs for accessing and controlling
    many aspects of the Corda platform. All this is performed from within the server-side
    CorDapps code, not the RPC client-side code.
  prefs: []
  type: TYPE_NORMAL
- en: Think of the service hub as the starting point for most operations that are
    performed inside a node. The service hub also defines how nodes access services
    internally by three distinct service calls.
  prefs: []
  type: TYPE_NORMAL
- en: The CorDapps are what actually defines how a node owner interacts with a node.
    Of course, APIs are required to provide for the required operation on a Corda
    node. There are also a full suite of unique API calls that developer would want
    to review and test before deploying an application.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more on the API categories, refer to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[https://docs.corda.net/api/kotlin/corda/net.corda.core.node/-service-hub/index.html](https://docs.corda.net/api/kotlin/corda/net.corda.core.node/-service-hub/index.html)`  ###
    Corda Doorman'
  prefs: []
  type: TYPE_NORMAL
- en: Corda networks are semiprivate and have a doorman service that enforces rules
    regarding the information that nodes must provide and the know-your-customer processes
    that they must complete before being admitted to the network.
  prefs: []
  type: TYPE_NORMAL
- en: 'A node must contact the doorman and provide the required information. The doorman
    will give the node a root-authority-signed TLS certificate from the network''s
    permissioning service.  ### Corda Flows'
  prefs: []
  type: TYPE_NORMAL
- en: 'Flows are used to model business processes between parties exchanging assets.
    Flows are what would be called a bilateral agreement, which is between two parties.
    There is no way that you can invoke smart contracts directly in Corda; therefore,
    you must write a flow, which specifies the entire life cycle of state changes.
    The flow does this by invoking the smart contract that is related to the current
    state.  ### Client RPC'
  prefs: []
  type: TYPE_NORMAL
- en: A client remote procedure call is a protocol that the client's blockchain program
    uses to request blockchain access from a program that is located on a remote Corda
    node.
  prefs: []
  type: TYPE_NORMAL
- en: RPCs are used to ensure that the application can communicate without having
    to fully dictate or understand the blockchain network's details. An RPC is also
    known as a function call or a subroutine call, which uses a client-server platform.
    The node in Corda owner can interact with the node via a client RPC.
  prefs: []
  type: TYPE_NORMAL
- en: From a development perspective, the node owner does not have direct client-side
    access to Service Hub APIs. For developers to interact with a node, they need
    to write a client in a JVM-compatible language using the `CordaRPCClient` class.
    There are also a number of dependencies and permissions developers would need
    to address.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information, please refer to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[https://docs.corda.net/clientrpc.html](https://docs.corda.net/clientrpc.html)`  ###
    Oracles'
  prefs: []
  type: TYPE_NORMAL
- en: An oracle is a trusted external source of factual and final information. A fact
    can be included in a transaction as part of a command. An oracle service can be
    used to access or validate off-ledger data. An oracle will sign a transaction
    only if the included off-ledger fact is actually true from its point of view.
    For example, an oracle service can be used to sign the transaction to ensure the
    exchange rate being referenced is correct at a certain point in time.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a nutshell, an oracle is a trusted service that can provide that capability
    in a controlled and deterministic manner for exchanges.  ### Corda DemoBench'
  prefs: []
  type: TYPE_NORMAL
- en: DemoBench is used to run a multiple-node Corda network on a local development
    machine. R3 Corda DemoBench is available for both Windows and macOS as a free
    download at the Corda download site. Developers should start by using DemoBench
    to get a feel of how a CorDapp would work from a user perspective and then dive
    into the JVM.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 10.18](#c10-fig-0018) shows the view in DemoBench when a network is
    deployed.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Screen capture depicting DemoBench.](images/c10f018.png)'
  prefs: []
  type: TYPE_IMG
- en: '[**FIGURE 10.18**](#R_c10-fig-0018) DemoBench'
  prefs: []
  type: TYPE_NORMAL
- en: 'DemoBench writes a log file to the following locations:'
  prefs: []
  type: TYPE_NORMAL
- en: '**macOS/Linux**: `$HOME/DemoBench/demobench.log`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Windows**: `%USERPROFILE%\DemoBench\demobench.log`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Figure 10.19](#c10-fig-0019) shows the log files in a Corda DemoBench JVM.'
  prefs: []
  type: TYPE_NORMAL
- en: You can download Corda DemoBench from `[https://www.corda.net/download.html](https://www.corda.net/download.html)`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Screen capture depicting DemoBench logs.](images/c10f019.png)'
  prefs: []
  type: TYPE_IMG
- en: '[**FIGURE 10.19**](#R_c10-fig-0019) DemoBench logs  ## Quorum Development'
  prefs: []
  type: TYPE_NORMAL
- en: Quorum is an open source private blockchain network developed by JP Morgan directly
    from the Ethereum code. This blockchain is a fork of the Ethereum blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum developers will have no real significant learning curve to become proficient
    in the platform. Quorum development is similar to Ethereum, so I won't cover the
    redundant areas again for Quorum. I will focus on the similarities and major differences
    between Quorum and Ethereum.
  prefs: []
  type: TYPE_NORMAL
- en: Quorum's main distinguishing feature is the fact that it allows private transactions
    between the parties. It does this over a private deployment of Ethereum, not on
    the Ethereum mainnet.
  prefs: []
  type: TYPE_NORMAL
- en: Quorum introduces an interesting new consensus algorithm called Raft. Similar
    to proof of stake (POS), Raft does not require calculation of a hash and validates
    blocks/transactions in under 0.5 seconds, which is fast for a blockchain. However,
    this speed comes at a cost to security since it has no Byzantine fault tolerance.
    Basically, if this consensus is used, the security has to be provided by the entities
    themselves to ensure that their nodes are not accessible to an attacker.
  prefs: []
  type: TYPE_NORMAL
- en: Quorum offers more consensus mechanisms that in the long run will allow Byzantine
    fault tolerance, such as Quorum Chain, which is programmable through a smart contract
    and is intended to enable programmable consensus logic.
  prefs: []
  type: TYPE_NORMAL
- en: Quorum allows transactions to be carried out privately between network participants
    and allows a transaction to be visible only to a specific group of participants.
  prefs: []
  type: TYPE_NORMAL
- en: The data of the private transactions never reaches nonparticipating nodes, since
    instead of using blockchain communication to send the data, a point-to-point network
    is used, which works together with the blockchain and allows data to be sent from
    one node to another, called/provided by Constellation. This data is verified in
    the blockchain by means of its hashes, but the data is never sent via the “open”
    network.
  prefs: []
  type: TYPE_NORMAL
- en: '### Quorum vs. Ethereum'
  prefs: []
  type: TYPE_NORMAL
- en: From a development perspective, Quorum uses the same core as Ethereum. They
    share the same smart contract development language, Solidity.
  prefs: []
  type: TYPE_NORMAL
- en: However, there is a difference in regard to the computation pricing where the
    gas system is concerned. The Quorum network developer doesn't have to worry about
    having enough gas to interact with the contracts. Developers do not need to worry
    about gas because Quorum is a private blockchain and doesn't use gas. Wallets
    are not used in Quorum as they are in Ethereum.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, Quorum does maintain an execution gas limit per transaction. This
    is to prevent someone from launching a code that could take the validators too
    long to process and effectively induce a vulnerability into the chain.  ### Quorum
    Cakeshop'
  prefs: []
  type: TYPE_NORMAL
- en: Cakeshop is an SDK that has APIs for creating, managing, and integrating Ethereum-like
    ledgers such as Quorum. It is packaged as a Java web application archive (WAR)
    that you can run on Docker containers. Cakeshop has an intuitive graphical user
    interface and is fairly intuitive to use.
  prefs: []
  type: TYPE_NORMAL
- en: Cakeshop downloads the latest version of Quorum and the boot node from Geth.
    This Cakeshop package includes the transaction managers, a Solidity compiler,
    and all the needed dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information on Cakeshop, visit `[https://github.com/jpmorganchase/cakeshop](https://github.com/jpmorganchase/cakeshop)`.  ##
    Blockchain Performance'
  prefs: []
  type: TYPE_NORMAL
- en: Blockchains are generally technologies that are distributed and decentralized,
    and they can be fast. For example, a blockchain could be faster than another blockchain
    if you removed nodes. However, when you remove nodes, you effectively mitigate
    security or decentralization.
  prefs: []
  type: TYPE_NORMAL
- en: It's important to note that a blockchain, like any other technology, cannot
    be everything at once, and therefore a compromise in the constraints must be made.
    This compromise is similar to how a project manager would handle project constraints.
    For example, in a project you could reduce the time to completion by investing
    more in labor, which may get your project completed earlier. The other side is
    that by adding more labor, you effectively increase your cost constraints.
  prefs: []
  type: TYPE_NORMAL
- en: In blockchain projects, constraints are no different from a compromise perspective,
    and it's a give-and-take consideration to what your blockchain application would
    realize from a security, speed, or decentralization perspective. Want better performance
    (faster transactions)? Then reduce the number of nodes but also centralize the
    nodes more. By improving performance, you could very well impact decentralization
    as well as change your security posture.
  prefs: []
  type: TYPE_NORMAL
- en: As shown in [Figure 10.20](#c10-fig-0020), the project management triangle (aka
    triple constraint) comprises three constraints.
  prefs: []
  type: TYPE_NORMAL
- en: Time refers to the schedule allotted to the project.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cost refers to the budget for licenses, hardware, and manpower, both internal
    and external.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scope refers to the amount of functionality to be delivered in the project.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Diagram depicting a triangle marked Triple constraint with on the three sides.](images/c10f020.png)'
  prefs: []
  type: TYPE_IMG
- en: '[**FIGURE 10.20**](#R_c10-fig-0020) Triple constraint'
  prefs: []
  type: TYPE_NORMAL
- en: Projects need to adjust one of the three constraints to make up for another.
    Generally, the project sponsor will determine which two to excel at, and the third
    will have to be adjusted to meet the initial two constraints.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's discuss blockchains. As previously mentioned, blockchains are decentralized,
    are secure, and can be fast relative to other blockchains. These three constraints
    are a choice, and the customer would need to choose.
  prefs: []
  type: TYPE_NORMAL
- en: Blockchains can effectively maintain two of three properties (constraints) where
    one property is effectively compromised to provide a different result for another
    property. These three properties (constraints) are
  prefs: []
  type: TYPE_NORMAL
- en: Speed (fast)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decentralized
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Figure 10.21](#c10-fig-0021) shows the blockchain paradigm. Ideally, blockchains
    would meet all our expectations. However, we don''t live in a perfect world, so
    developers need to determine what these properties really are and how they affect
    our blockchain implementation.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram depicting a triangle marked Blockchain paradigm with on the three
    sides.](images/c10f021.png)'
  prefs: []
  type: TYPE_IMG
- en: '[**FIGURE 10.21**](#R_c10-fig-0021) Blockchain paradigm'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the common properties developers want to measure or adjust
    in our blockchain performance requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Speed**—The blockchain must provide for prompt processing, which should result
    in higher transactions per second (TPS). Speed is also referred to as how “fast”
    a transaction could occur. Note that “speed” or “fast” is relative only as compared
    to other blockchains. Comparing blockchains to client-servers is not relative
    here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security**—Generally, a certificate manager handles these encryption certificates.
    In most blockchain networks, X.509 certificates are commonly used to maintain
    these certificates. For example, in Hyperledger Fabric there is what is called
    a *certificate authority*. Permissions are also important to consider since they
    directly affect access to resources. In most permissioned blockchains, there would
    be permissioning, which means that there is centralized control over what users
    or applications have access to the blockchain resources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Decentralization**—This is true in the permissionless blockchains, such as
    Ethereum. However, Hyperledger, Corda, and Ripple are centralized platforms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To be fair, some blockchains, such as Ripple, state they can process around
    1,500 TPS, and Hyperledger Fabric, in a perfect world, could process up to 3,500
    TPS. However, these numbers are based on some kind of compromise.
  prefs: []
  type: TYPE_NORMAL
- en: Bitcoin's TPS is continually varying. In its current form, the network doesn't
    support more than 7 TPS, and Ethereum is not much better at around 14 TPS. The
    performance of Bitcoin and Ethereum, for example, is a direct result of the global
    scale, Internet reliance, and transaction workloads. More transactions increase
    the workload of all production blockchain nodes in Ethereum and Bitcoin, which
    effectively have to update their ledger for every transaction.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 10.5](#c10-tbl-0005) compares some of the common blockchains and legacy
    services.'
  prefs: []
  type: TYPE_NORMAL
- en: '[**TABLE 10.5**](#R_c10-tbl-0005): Transactions per Second (TPS) Comparisons'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | VISA | BTC | RIPPLE | PAYPAL | HYPERLEDGER |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **TPS** | 24,000 | 4 | 1,500 | 193 | 3,500 |'
  prefs: []
  type: TYPE_TB
- en: '| **Control** | Centralized | Decentralized | Centralized | Centralized | Centralized
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Notes** | Push | P2P | Hybrid | Hybrid | P2P |'
  prefs: []
  type: TYPE_TB
- en: The “Notes” reference how a transaction is actually processed and then ingested
    from the application. Transactions that are sent from a client application to
    the server's processor application are push transactions. Transactions that are
    pulled from the client application are pull transactions. Push, pull, and hybrid
    transactions are client-server applications, which typically are decentralized.
    Transactions that use both push and pull processes in the application are considered
    hybrid. Transactions that are processed on the blockchain nodes and processed
    by each node are considered P2P transactions. Blockchains that are processed in
    a P2P transaction platform are the native forms of blockchain transactions.
  prefs: []
  type: TYPE_NORMAL
- en: '### Permission or Permissionless Performance'
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps the real trade-off around performance is between permissioned and permissionless
    blockchains. Permissioned blockchains can generally perform better since they
    have fewer nodes in the blockchain network, and the nodes are centralized or localized.
    Performance is relative to the number of nodes.
  prefs: []
  type: TYPE_NORMAL
- en: For example, it has been stated that Hyperledger Fabric could theoretically
    reach 3,500 TPS. Of course, this number is in a perfect world, and it is well
    known that Hyperledger Fabric overall does not scale well from a performance perspective.
    Adding mode nodes and peers will substantially drop the TPS. When you add nodes
    that are not localized, you can expect the network latency to also reduce your
    TPS.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of permissionless blockchains such as Ethereum, developers know
    that performance should not be an expectation. Permissionless blockchains are
    generally widely distributed with typically hundreds of nodes as well. The user
    base can be dependent on sporadic behavior—for example, in the world of Bitcoin,
    activity can spike when there is an event in China or when the United States makes
    a statement about regulating cryptocurrency.
  prefs: []
  type: TYPE_NORMAL
- en: 'If performance is part of your use case requirements, then permissionless blockchains
    are out of the question.  ### Performance Testing'
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to performance testing, the main focus is transactions per second
    (TPS). Another factor is the size of the transactions. For example, a larger block
    size may not perform as well as a smaller block size.
  prefs: []
  type: TYPE_NORMAL
- en: 'Performance testing is generally accomplished through what is considered to
    be nonfunctional testing. Nonfunctional testing is a focused area that is mainly
    technically driven. Some technical areas that could be tested include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Network latency and bottlenecks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Block size adjustment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Signatures removed or included
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sequencing of transactions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There seems to be a limited number of performance testing tools. However, there
    are a few solid choices depending on your platform. Ethereum has most choices
    available at the time of writing.
  prefs: []
  type: TYPE_NORMAL
- en: '#### ETHEREUM TESTING TOOLS'
  prefs: []
  type: TYPE_NORMAL
- en: There are numerous tools for Ethereum application development. It is important
    to note that in varying degrees when testing your Quorum blockchain applications
    some Ethereum tools could be made to work. At the time of writing, there are no
    testing tools for Quorum. From a testing perspective with Quorum you would want
    to ensure that you direct your tests to your localhost or a custom RPC.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are three common tools used in Ethereum testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ethereum Tester** Ethereum Tester supports two distinct data formats that
    enable both front-end and backend testing. There is a significant installation
    process and some dependencies to deal with.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On GitHub, visit `[https://github.com/ethereum/eth-tester](https://github.com/ethereum/eth-tester)`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Truffle** Truffle is a battle-tested Ethereum development framework that
    you really have to know to develop in Ethereum. It has a great testing capacity
    built in as well. For example, you can write automated tests for smart contracts
    in JavaScript and Solidity and get your contracts developed quickly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To find out more about Truffle Suite, visit `[https://www.trufflesuite.com/](https://www.trufflesuite.com/)`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Ganache** Ganache has the most popular library for Ethereum testing. Formerly
    known as TestRPC, Ganache is used to test Ethereum smart contracts locally—that
    is, it spins up an instance on your desktop/server and simulates a live blockchain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can learn more about Ganache at `[https://www.trufflesuite.com/ganache](https://www.trufflesuite.com/ganache)`.  ####
    HYPERLEDGER FABRIC TESTING TOOLS'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Hyperledger Fabric has some specific tools that can be used for testing. Hyperledger
    Composer currently is the most common tool used for Hyperledger development and
    testing. Hyperledger Composer is available for a local deployment using Docker
    containers, or you can use the web version called Hyperledger Composer Playground.
  prefs: []
  type: TYPE_NORMAL
- en: Hyperledger Composer is an open source development tool that contains many functions
    to help build blockchain applications. Some of those features also help with testing.
    At the time of writing, Composer supports interactive testing, automated unit
    testing, and automated system testing.
  prefs: []
  type: TYPE_NORMAL
- en: Composer has a command-line interface that enables you to run interactive “smoke
    tests” that can ensure the deployment would be successful. This also makes it
    easy to execute tests in a continuous integration/continuous delivery (CI/CD)
    pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: 'Continuous integration (CI) is a process whereby a developer''s working copies
    are synchronized with a shared pipeline several times a day. Continuous delivery
    (CD) is the next process after continuous integration and enables placing a product
    into production, which historically is a manually driven process. Continuous deployment,
    the next logical next step after continuous delivery, automatically deploys the
    product into production after quality assurance (QA).  ## Blockchain Integration
    and Interoperability'
  prefs: []
  type: TYPE_NORMAL
- en: Blockchains are increasingly providing much more value by either going off chain
    or cross-chaining. Moving value from one blockchain to another blockchain is actually
    somewhat of a new approach even in blockchain's short history.
  prefs: []
  type: TYPE_NORMAL
- en: Before the idea and implementation of cross chains, developers be using an off-chain
    approach through a cryptocurrency gateway to exchange value. The main headache
    with that approach was that these gateways were centralized exchanges and could
    pose some concerns to privacy, costing, control, and performance.
  prefs: []
  type: TYPE_NORMAL
- en: A thin client generally only presents processed data provided by an application
    server, which performs the bulk of any required data processing. A device using
    web applications is a thin client, and generally these blockchain applications
    can be enabled by thin clients.
  prefs: []
  type: TYPE_NORMAL
- en: To integrate the blockchain with any traditional systems or with a front end
    that will allow our clients to interact with it in a user-friendly way, developers
    must use the client libraries available for the various “traditional languages.”
  prefs: []
  type: TYPE_NORMAL
- en: Generally, the blockchain technologies communicate through RPC/HTTP and a client
    library for NodeJS or another library. Blockchain technologies exchange payments
    and digital assets. The ability to transfer and exchange digital assets originating
    from another blockchain without trusted intermediaries can be accomplished through
    the use of notary schemes, relays, and hashed time locks.
  prefs: []
  type: TYPE_NORMAL
- en: Vitalik Buterin, cofounder of Ethereum, noted that there are three primary methods
    to achieving true interoperability for a blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: Notary schemes, which are an exchange of arbitrary data such as how to connect
    the blockchain to another blockchain. This is commonly referred to as *federation*
    of blockchains. An example would be a company such as Blockstream that provides
    a medium for transfer from one network to another network.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Relays provide for the exchange of arbitrary data via what is a gateway or data
    exchange. Some vendors refer to relays as a relay chain. A relay or relay chain
    is used to provide a gateway from one blockchain to another blockchain. BTCRelay
    is the most widely known relay and acts as a bridge between Bitcoin and Ethereum
    blockchains.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hashed time lock contracts (HTLCs) provide for the exchange of digital assets
    via a cross-chain atomic swap. HTLCs can provide for bidirectional payment channels
    between digital assets on specific blockchains. The most prominent example is
    the Bitcoin Lightning Network.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generally, whether a blockchain uses any one of the preceding methods is really
    dependent on the level of federation required, off-chain or side chain requirements,
    as well as any number of other factors.
  prefs: []
  type: TYPE_NORMAL
- en: '### Data Exchange Methods'
  prefs: []
  type: TYPE_NORMAL
- en: The terms *sidechains* and *payment gateways* are commonly used interchangeably
    in the blockchain industry. However, they are quite different. A sidechain is
    a separate blockchain that is attached to a parent blockchain using what is called
    a *two-way peg*. This two-way peg enables the interchangeability of assets at
    a predetermined rate between the parent blockchain and the sidechain. In simple
    terms, it's an exchange.
  prefs: []
  type: TYPE_NORMAL
- en: The original blockchain is usually referred to as the *main chain*, and all
    additional blockchains are referred to as *sidechains*.
  prefs: []
  type: TYPE_NORMAL
- en: Common sidechains that are in production mode include Rootstock and Liquid.
  prefs: []
  type: TYPE_NORMAL
- en: Rootstock (RSK) appears to be the most widely used and has created an open source
    testnet called Ginger for its sidechains. RSK has a two-way peg with the Bitcoin
    blockchain and rewards Bitcoin miners via merged mining. RSK's main goal is to
    enable the Bitcoin blockchain to have smart contract capabilities and make these
    integrated payments more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: 'Liquid is a sidechain created by a blockchain startup called Blockstream. Liquid
    enables the instant movement of funds between cryptocurrency exchanges, and it''s
    very efficient. There is really no waiting for the confirmation in the Bitcoin
    blockchain.  ### Hash Timed Locks'
  prefs: []
  type: TYPE_NORMAL
- en: An HTLC is a class of blockchain-based payment system that uses hash locks.
    Time locks require the receiver of a payment to either acknowledge receipt prior
    to a deadline or basically forfeit the ability to claim the payment and then return
    it to the payer.
  prefs: []
  type: TYPE_NORMAL
- en: HTLCs allow for cross-chain atomic swaps, which means, for example, a sender
    could pay in Bitcoin, but the receiver could choose Litecoin as payment. The hashed
    time locks are fully funded bidirectional payment channels between assets on the
    specified blockchain platforms.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of the Lightning network, it is a decentralized micropayment solution
    on top of the Bitcoin blockchain.  ### Relays and Gateways'
  prefs: []
  type: TYPE_NORMAL
- en: A relay is effectively a way to interface a contract exchange between two different
    blockchains. Relays are also referred to as *gateways* or *payment gateways*.
  prefs: []
  type: TYPE_NORMAL
- en: The most prominent relay is BTC Relay, which allows Ethereum contracts to securely
    verify Bitcoin transactions without any intermediaries.
  prefs: []
  type: TYPE_NORMAL
- en: BTC Relay is an Ethereum contract that stores Bitcoin block headers only. It
    uses these block headers to build a mini version of the Bitcoin blockchain. The
    main benefit is that it allows Ethereum dapp users to pay with Bitcoin to use
    Ethereum dapps directly.
  prefs: []
  type: TYPE_NORMAL
- en: Some relays allow for a one-way exchange, and some allow for exchange both ways.
    For example, in BTC Relay, the exchange is one way, whereby the user can pay for
    Ethereum by using Bitcoin, but not the other way around.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more on BTCRelay, refer to `[http://btcrelay.org/](http://btcrelay.org/)`.  ##
    Summary'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter covered various development challenges, best practices, programming
    models, and frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: Solidity is a newer but simple programming language that is popular among Ethereum
    developers. Other widely used development languages include C++, Java, Golang,
    and Rust. Blockchain developers experienced in these languages are on their way
    to blockchain success.
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum development requirements should be reviewed before developing on Ethereum.
    You learned about Truffle, Ganache, MetaMask, testnets, and several areas of development
    focus on Ethereum.
  prefs: []
  type: TYPE_NORMAL
- en: Hyperledger development tools include Hyperledger Composer, an object-oriented
    modeling language that defines the domain model for a business network definition.
  prefs: []
  type: TYPE_NORMAL
- en: Hyperledger Fabric uses LevelDB as the database for the state database, but
    you may want to consider the option to configure peers to store database transactions
    in CouchDB.
  prefs: []
  type: TYPE_NORMAL
- en: The two most popular languages for Corda development are Java and Kotlin. The
    real key for using these languages is their great flexibility and interoperability
    with Java in both directions.
  prefs: []
  type: TYPE_NORMAL
- en: Quorum is an open source private blockchain network developed by JP Morgan from
    the Ethereum code. Ethereum developers will have a short ramp-up time to develop
    on the Quorum blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: There are various aspects of interoperability and integration—such as hash locks,
    payment gateways, and sidechains—to consider when blockchain requirements call
    for different blockchains.
  prefs: []
  type: TYPE_NORMAL
