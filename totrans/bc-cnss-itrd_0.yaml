- en: '![](index-1_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Blockchain Consensus**'
  prefs: []
  type: TYPE_NORMAL
- en: '**An Introduction to Classical,**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Blockchain, and Quantum**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Consensus Protocols**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Imran Bashir**'
  prefs: []
  type: TYPE_NORMAL
- en: '***Blockchain Consensus: An Introduction to Classical, Blockchain, and Quantum***'
  prefs: []
  type: TYPE_NORMAL
- en: '***Consensus Protocols***'
  prefs: []
  type: TYPE_NORMAL
- en: Imran Bashir
  prefs: []
  type: TYPE_NORMAL
- en: London, UK
  prefs: []
  type: TYPE_NORMAL
- en: 'ISBN-13 (pbk): 978-1-4842-8178-9'
  prefs: []
  type: TYPE_NORMAL
- en: 'ISBN-13 (electronic): 978-1-4842-8179-6'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://doi.org/10.1007/978-1-4842-8179-6](https://doi.org/10.1007/978-1-4842-8179-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Copyright © 2022 by Imran Bashir
  prefs: []
  type: TYPE_NORMAL
- en: This work is subject to copyright. All rights are reserved by the Publisher,
    whether the whole or part of the material is concerned, specifically the rights
    of translation, reprinting, reuse of illustrations, recitation, broadcasting,
    reproduction on microfilms or in any other physical way, and transmission or information
    storage and retrieval, electronic adaptation, computer software, or by similar
    or dissimilar methodology now known or hereafter developed.
  prefs: []
  type: TYPE_NORMAL
- en: Trademarked names, logos, and images may appear in this book. Rather than use
    a trademark symbol with every occurrence of a trademarked name, logo, or image
    we use the names, logos, and images only in an editorial fashion and to the benefit
    of the trademark owner, with no intention of infringement of the trademark.
  prefs: []
  type: TYPE_NORMAL
- en: The use in this publication of trade names, trademarks, service marks, and similar
    terms, even if they are not identified as such, is not to be taken as an expression
    of opinion as to whether or not they are subject to proprietary rights.
  prefs: []
  type: TYPE_NORMAL
- en: While the advice and information in this book are believed to be true and accurate
    at the date of publication, neither the authors nor the editors nor the publisher
    can accept any legal responsibility for any errors or omissions that may be made.
    The publisher makes no warranty, express or implied, with respect to the material
    contained herein.
  prefs: []
  type: TYPE_NORMAL
- en: 'Managing Director, Apress Media LLC: Welmoed Spahr'
  prefs: []
  type: TYPE_NORMAL
- en: 'Acquisitions Editor: Aditee Mirashi'
  prefs: []
  type: TYPE_NORMAL
- en: 'Development Editor: Laura Berendson'
  prefs: []
  type: TYPE_NORMAL
- en: 'Coordinating Editor: Aditee Mirashi'
  prefs: []
  type: TYPE_NORMAL
- en: Cover designed by eStudioCalamar
  prefs: []
  type: TYPE_NORMAL
- en: Cover image designed by Freepik (www.freepik.com)
  prefs: []
  type: TYPE_NORMAL
- en: Distributed to the book trade worldwide by Springer Science+Business Media New
    York, 1 New York Plaza, Suite 4600, New York, NY 10004-1562, USA. Phone 1-800-SPRINGER,
    fax (201) 348-4505, e-mail orders-ny@springer-sbm.com, or visit www.springeronline.com.
    Apress Media, LLC is a California LLC and the sole member (owner) is Springer
    Science + Business Media Finance Inc (SSBM Finance Inc). SSBM Finance Inc is a
    **Delaware** corporation.
  prefs: []
  type: TYPE_NORMAL
- en: For information on translations, please e-mail booktranslations@springernature.com;
    for reprint, paperback, or audio rights, please e-mail bookpermissions@springernature.com.
  prefs: []
  type: TYPE_NORMAL
- en: Apress titles may be purchased in bulk for academic, corporate, or promotional
    use. eBook versions and licenses are also available for most titles. For more
    information, reference our Print and eBook Bulk Sales web page at http://www.apress.com/bulk-sales.
  prefs: []
  type: TYPE_NORMAL
- en: Any source code or other supplementary material referenced by the author in
    this book is available to readers on GitHub (github.com/apress). For more detailed
    information, please visit http://www.apress.
  prefs: []
  type: TYPE_NORMAL
- en: com/source- code.
  prefs: []
  type: TYPE_NORMAL
- en: Printed on acid-free paper
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-4_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*This book is dedicated to my father, the most affectionate,*'
  prefs: []
  type: TYPE_NORMAL
- en: '*selfless, and hard-working person I’ve ever known.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you are stuck at a research problem, rigorously read*'
  prefs: []
  type: TYPE_NORMAL
- en: '*all relevant literature, you will find the answer.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*—Scientist Bashir Ahmed Khan*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table of Contents**'
  prefs: []
  type: TYPE_NORMAL
- en: 'About the Author �����������������������������������������������������������������������������������������������������xv
    About the Technical Reviewer �������������������������������������������������������������������������������xvii
    Acknowledgments ��������������������������������������������������������������������������������������������������xix
    Introduction ������������������������������������������������������������������������������������������������������������xxi
    Chapter 1: [Introduction���������������������������������������������������������������������������������������������
    1](https://doi.org/10.1007/978-1-4842-8179-6_1)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Distributed Systems ����������������������������������������������������������������������������������������������������������������������
    1](https://doi.org/10.1007/978-1-4842-8179-6_1#Sec1)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Characteristics ������������������������������������������������������������������������������������������������������������������������
    2](https://doi.org/10.1007/978-1-4842-8179-6_1#Sec2)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Why Build Distributed Systems �����������������������������������������������������������������������������������������������
    4](https://doi.org/10.1007/978-1-4842-8179-6_1#Sec3)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Challenges �������������������������������������������������������������������������������������������������������������������������������
    7](https://doi.org/10.1007/978-1-4842-8179-6_1#Sec10)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Parallel vs� Distributed vs� Concurrency ��������������������������������������������������������������������������������
    10](https://doi.org/10.1007/978-1-4842-8179-6_1#Sec18)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Centralized vs� Decentralized vs� Distributed ������������������������������������������������������������������������
    10](https://doi.org/10.1007/978-1-4842-8179-6_1#Sec19)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Distributed Algorithm �������������������������������������������������������������������������������������������������������������
    12](https://doi.org/10.1007/978-1-4842-8179-6_1#Sec20)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Elements of Distributed Computing/Pertinent Terms/Concepts ��������������������������������������������
    14](https://doi.org/10.1007/978-1-4842-8179-6_1#Sec21)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Types of Distributed Systems ������������������������������������������������������������������������������������������������
    19](https://doi.org/10.1007/978-1-4842-8179-6_1#Sec28)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Software Architecture Models �����������������������������������������������������������������������������������������������
    19](https://doi.org/10.1007/978-1-4842-8179-6_1#Sec29)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Distributed System Model �����������������������������������������������������������������������������������������������������
    25](https://doi.org/10.1007/978-1-4842-8179-6_1#Sec34)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Synchrony and Timing �����������������������������������������������������������������������������������������������������������
    31](https://doi.org/10.1007/978-1-4842-8179-6_1#Sec57)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Time, Clocks, and Order ���������������������������������������������������������������������������������������������������������
    37](https://doi.org/10.1007/978-1-4842-8179-6_1#Sec68)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Physical Clocks ����������������������������������������������������������������������������������������������������������������������
    39](https://doi.org/10.1007/978-1-4842-8179-6_1#Sec69)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Happens-Before Relationship and Causality �������������������������������������������������������������������������
    50](https://doi.org/10.1007/978-1-4842-8179-6_1#Sec86)'
  prefs: []
  type: TYPE_NORMAL
- en: '[CAP Theorem �������������������������������������������������������������������������������������������������������������������������������
    61](https://doi.org/10.1007/978-1-4842-8179-6_1#Sec105)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Consistency ���������������������������������������������������������������������������������������������������������������������������
    61](https://doi.org/10.1007/978-1-4842-8179-6_1#Sec106)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Availability �����������������������������������������������������������������������������������������������������������������������������
    61](https://doi.org/10.1007/978-1-4842-8179-6_1#Sec107)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Partition Tolerance �����������������������������������������������������������������������������������������������������������������
    61](https://doi.org/10.1007/978-1-4842-8179-6_1#Sec108)'
  prefs: []
  type: TYPE_NORMAL
- en: v
  prefs: []
  type: TYPE_NORMAL
- en: Table of ConTenTs
  prefs: []
  type: TYPE_NORMAL
- en: '[Cryptography in Distributed Systems �����������������������������������������������������������������������������������������
    63](https://doi.org/10.1007/978-1-4842-8179-6_1#Sec109)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Summary�������������������������������������������������������������������������������������������������������������������������������������
    64](https://doi.org/10.1007/978-1-4842-8179-6_1#Sec110)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Bibliography ��������������������������������������������������������������������������������������������������������������������������������
    65](https://doi.org/10.1007/978-1-4842-8179-6_1#Sec111)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 2: Cryptography ����������������������������������������������������������������������������������������
    67](https://doi.org/10.1007/978-1-4842-8179-6_2)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Introduction ���������������������������������������������������������������������������������������������������������������������������������
    67](https://doi.org/10.1007/978-1-4842-8179-6_2#Sec1)'
  prefs: []
  type: TYPE_NORMAL
- en: '[A Typical Cryptosystem ���������������������������������������������������������������������������������������������������������������
    68](https://doi.org/10.1007/978-1-4842-8179-6_2#Sec2)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Cryptographic Primitives �������������������������������������������������������������������������������������������������������������
    70](https://doi.org/10.1007/978-1-4842-8179-6_2#Sec3)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Symmetric Cryptography ������������������������������������������������������������������������������������������������������������
    70](https://doi.org/10.1007/978-1-4842-8179-6_2#Sec4)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Stream Ciphers ����������������������������������������������������������������������������������������������������������������������
    71](https://doi.org/10.1007/978-1-4842-8179-6_2#Sec5)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Block Ciphers ������������������������������������������������������������������������������������������������������������������������
    73](https://doi.org/10.1007/978-1-4842-8179-6_2#Sec6)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Advanced Encryption Standard ���������������������������������������������������������������������������������������������
    77](https://doi.org/10.1007/978-1-4842-8179-6_2#Sec13)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Some Basic Mathematics �����������������������������������������������������������������������������������������������������������
    79](https://doi.org/10.1007/978-1-4842-8179-6_2#Sec14)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Prime �������������������������������������������������������������������������������������������������������������������������������������
    79](https://doi.org/10.1007/978-1-4842-8179-6_2#Sec15)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Modular Arithmetic ����������������������������������������������������������������������������������������������������������������
    80](https://doi.org/10.1007/978-1-4842-8179-6_2#Sec16)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Group �������������������������������������������������������������������������������������������������������������������������������������
    80](https://doi.org/10.1007/978-1-4842-8179-6_2#Sec17)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Abelian Group ������������������������������������������������������������������������������������������������������������������������
    80](https://doi.org/10.1007/978-1-4842-8179-6_2#Sec18)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Field ���������������������������������������������������������������������������������������������������������������������������������������
    80](https://doi.org/10.1007/978-1-4842-8179-6_2#Sec19)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Finite Field (Galois Field) �������������������������������������������������������������������������������������������������������
    80](https://doi.org/10.1007/978-1-4842-8179-6_2#Sec20)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Prime Fields ���������������������������������������������������������������������������������������������������������������������������
    80](https://doi.org/10.1007/978-1-4842-8179-6_2#Sec21)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Generator �������������������������������������������������������������������������������������������������������������������������������
    81](https://doi.org/10.1007/978-1-4842-8179-6_2#Sec22)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Public Key Cryptography �������������������������������������������������������������������������������������������������������������
    81](https://doi.org/10.1007/978-1-4842-8179-6_2#Sec23)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Diffie-Hellman Key Exchange ������������������������������������������������������������������������������������������������
    82](https://doi.org/10.1007/978-1-4842-8179-6_2#Sec24)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Digital Signatures ������������������������������������������������������������������������������������������������������������������
    85](https://doi.org/10.1007/978-1-4842-8179-6_2#Sec25)'
  prefs: []
  type: TYPE_NORMAL
- en: '[RSA ����������������������������������������������������������������������������������������������������������������������������������������
    85](https://doi.org/10.1007/978-1-4842-8179-6_2#Sec28)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Elliptic Curve Cryptography ���������������������������������������������������������������������������������������������������
    88](https://doi.org/10.1007/978-1-4842-8179-6_2#Sec32)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Digital Signatures ������������������������������������������������������������������������������������������������������������������������
    94](https://doi.org/10.1007/978-1-4842-8179-6_2#Sec37)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Authenticity ���������������������������������������������������������������������������������������������������������������������������
    94](https://doi.org/10.1007/978-1-4842-8179-6_2#Sec38)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Unforgeability (Nonrepudiation) ���������������������������������������������������������������������������������������������
    94](https://doi.org/10.1007/978-1-4842-8179-6_2#Sec39)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Nonreusability �����������������������������������������������������������������������������������������������������������������������
    95](https://doi.org/10.1007/978-1-4842-8179-6_2#Sec40)'
  prefs: []
  type: TYPE_NORMAL
- en: '[ECDSA Signatures �����������������������������������������������������������������������������������������������������������������
    96](https://doi.org/10.1007/978-1-4842-8179-6_2#Sec41)'
  prefs: []
  type: TYPE_NORMAL
- en: vi
  prefs: []
  type: TYPE_NORMAL
- en: Table of ConTenTs
  prefs: []
  type: TYPE_NORMAL
- en: '[Multisignatures ����������������������������������������������������������������������������������������������������������������������
    97](https://doi.org/10.1007/978-1-4842-8179-6_2#Sec42)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Threshold Signatures ������������������������������������������������������������������������������������������������������������
    98](https://doi.org/10.1007/978-1-4842-8179-6_2#Sec43)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Aggregate Signatures ������������������������������������������������������������������������������������������������������������
    99](https://doi.org/10.1007/978-1-4842-8179-6_2#Sec44)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Ring Signatures �������������������������������������������������������������������������������������������������������������������
    100](https://doi.org/10.1007/978-1-4842-8179-6_2#Sec45)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Hash Functions �������������������������������������������������������������������������������������������������������������������������
    101](https://doi.org/10.1007/978-1-4842-8179-6_2#Sec46)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Preimage Resistance �����������������������������������������������������������������������������������������������������������
    101](https://doi.org/10.1007/978-1-4842-8179-6_2#Sec47)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Second Preimage Resistance ����������������������������������������������������������������������������������������������
    101](https://doi.org/10.1007/978-1-4842-8179-6_2#Sec48)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Collision Resistance ������������������������������������������������������������������������������������������������������������
    102](https://doi.org/10.1007/978-1-4842-8179-6_2#Sec49)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Design of Secure Hash Algorithms (SHA) ����������������������������������������������������������������������������
    103](https://doi.org/10.1007/978-1-4842-8179-6_2#Sec50)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Design of SHA-3 (Keccak) ���������������������������������������������������������������������������������������������������
    105](https://doi.org/10.1007/978-1-4842-8179-6_2#Sec54)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Message Authentication Codes �������������������������������������������������������������������������������������������������
    107](https://doi.org/10.1007/978-1-4842-8179-6_2#Sec55)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Hash-Based MACs (HMACs) ������������������������������������������������������������������������������������������������
    108](https://doi.org/10.1007/978-1-4842-8179-6_2#Sec56)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Verifiable Delay Functions���������������������������������������������������������������������������������������������������������
    109](https://doi.org/10.1007/978-1-4842-8179-6_2#Sec57)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Verifiable Random Functions ����������������������������������������������������������������������������������������������������
    110](https://doi.org/10.1007/978-1-4842-8179-6_2#Sec58)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Summary�����������������������������������������������������������������������������������������������������������������������������������
    111](https://doi.org/10.1007/978-1-4842-8179-6_2#Sec59)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Bibliography ������������������������������������������������������������������������������������������������������������������������������
    111](https://doi.org/10.1007/978-1-4842-8179-6_2#Sec60)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 3: Distributed Consensus ������������������������������������������������������������������������
    113](https://doi.org/10.1007/978-1-4842-8179-6_3)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Broadcast Primitives �����������������������������������������������������������������������������������������������������������������
    113](https://doi.org/10.1007/978-1-4842-8179-6_3#Sec1)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Best-Effort Broadcast ����������������������������������������������������������������������������������������������������������
    115](https://doi.org/10.1007/978-1-4842-8179-6_3#Sec2)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Reliable Broadcast���������������������������������������������������������������������������������������������������������������
    116](https://doi.org/10.1007/978-1-4842-8179-6_3#Sec6)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Uniform Reliable Broadcast �������������������������������������������������������������������������������������������������
    117](https://doi.org/10.1007/978-1-4842-8179-6_3#Sec10)'
  prefs: []
  type: TYPE_NORMAL
- en: '[FIFO Reliable Broadcast ������������������������������������������������������������������������������������������������������
    118](https://doi.org/10.1007/978-1-4842-8179-6_3#Sec12)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Causal Reliable Broadcast ���������������������������������������������������������������������������������������������������
    119](https://doi.org/10.1007/978-1-4842-8179-6_3#Sec14)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Total Order Reliable Broadcast or Atomic Reliable Broadcast ���������������������������������������������
    119](https://doi.org/10.1007/978-1-4842-8179-6_3#Sec15)'
  prefs: []
  type: TYPE_NORMAL
- en: '[FIFO Total Order Broadcast ��������������������������������������������������������������������������������������������������
    120](https://doi.org/10.1007/978-1-4842-8179-6_3#Sec20)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Relationship Between Broadcasts and Consensus �������������������������������������������������������������
    122](https://doi.org/10.1007/978-1-4842-8179-6_3#Sec23)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Agreement ��������������������������������������������������������������������������������������������������������������������������������
    123](https://doi.org/10.1007/978-1-4842-8179-6_3#Sec24)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Reliable Broadcast���������������������������������������������������������������������������������������������������������������
    123](https://doi.org/10.1007/978-1-4842-8179-6_3#Sec25)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Total Order Broadcast ����������������������������������������������������������������������������������������������������������
    124](https://doi.org/10.1007/978-1-4842-8179-6_3#Sec26)'
  prefs: []
  type: TYPE_NORMAL
- en: '[The Byzantine Agreement Problem �������������������������������������������������������������������������������������
    124](https://doi.org/10.1007/978-1-4842-8179-6_3#Sec27)'
  prefs: []
  type: TYPE_NORMAL
- en: vii
  prefs: []
  type: TYPE_NORMAL
- en: Table of ConTenTs
  prefs: []
  type: TYPE_NORMAL
- en: '[System Models �������������������������������������������������������������������������������������������������������������������������
    128](https://doi.org/10.1007/978-1-4842-8179-6_3#Sec31)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Distributed System ��������������������������������������������������������������������������������������������������������������
    128](https://doi.org/10.1007/978-1-4842-8179-6_3#Sec32)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Timing Model/Synchrony �����������������������������������������������������������������������������������������������������
    129](https://doi.org/10.1007/978-1-4842-8179-6_3#Sec33)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Process Failures ������������������������������������������������������������������������������������������������������������������
    130](https://doi.org/10.1007/978-1-4842-8179-6_3#Sec34)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Channel Reliability ���������������������������������������������������������������������������������������������������������������
    131](https://doi.org/10.1007/978-1-4842-8179-6_3#Sec35)'
  prefs: []
  type: TYPE_NORMAL
- en: '[History ���������������������������������������������������������������������������������������������������������������������������������������
    131](https://doi.org/10.1007/978-1-4842-8179-6_3#Sec36)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Two Generals’ Problem �������������������������������������������������������������������������������������������������������������
    132](https://doi.org/10.1007/978-1-4842-8179-6_3#Sec37)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Byzantine Generals Problem �����������������������������������������������������������������������������������������������������
    133](https://doi.org/10.1007/978-1-4842-8179-6_3#Sec38)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Replication ��������������������������������������������������������������������������������������������������������������������������������
    135](https://doi.org/10.1007/978-1-4842-8179-6_3#Sec39)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Active Replication ����������������������������������������������������������������������������������������������������������������
    137](https://doi.org/10.1007/978-1-4842-8179-6_3#Sec40)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Passive Replication �������������������������������������������������������������������������������������������������������������
    137](https://doi.org/10.1007/978-1-4842-8179-6_3#Sec41)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Pros and Cons����������������������������������������������������������������������������������������������������������������������
    137](https://doi.org/10.1007/978-1-4842-8179-6_3#Sec42)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Primary Backup Replication ������������������������������������������������������������������������������������������������
    138](https://doi.org/10.1007/978-1-4842-8179-6_3#Sec43)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chain Replication �����������������������������������������������������������������������������������������������������������������
    139](https://doi.org/10.1007/978-1-4842-8179-6_3#Sec44)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Fundamental Results �����������������������������������������������������������������������������������������������������������
    147](https://doi.org/10.1007/978-1-4842-8179-6_3#Sec55)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Quorums������������������������������������������������������������������������������������������������������������������������������������
    160](https://doi.org/10.1007/978-1-4842-8179-6_3#Sec83)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Crash Fault–Tolerant Quorums ��������������������������������������������������������������������������������������������
    161](https://doi.org/10.1007/978-1-4842-8179-6_3#Sec84)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Byzantine Quorums �������������������������������������������������������������������������������������������������������������
    162](https://doi.org/10.1007/978-1-4842-8179-6_3#Sec85)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Read and Write Quorums �����������������������������������������������������������������������������������������������������
    162](https://doi.org/10.1007/978-1-4842-8179-6_3#Sec86)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Where Are We Now ��������������������������������������������������������������������������������������������������������������������
    162](https://doi.org/10.1007/978-1-4842-8179-6_3#Sec87)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Classical Consensus ������������������������������������������������������������������������������������������������������������
    163](https://doi.org/10.1007/978-1-4842-8179-6_3#Sec88)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Nakamoto and Post-Nakamoto Consensus �������������������������������������������������������������������������
    163](https://doi.org/10.1007/978-1-4842-8179-6_3#Sec89)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Summary�����������������������������������������������������������������������������������������������������������������������������������
    163](https://doi.org/10.1007/978-1-4842-8179-6_3#Sec90)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Bibliography ������������������������������������������������������������������������������������������������������������������������������
    164](https://doi.org/10.1007/978-1-4842-8179-6_3#Sec91)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 4: Blockchain ������������������������������������������������������������������������������������������
    167](https://doi.org/10.1007/978-1-4842-8179-6_4)'
  prefs: []
  type: TYPE_NORMAL
- en: '[What Is Blockchain��������������������������������������������������������������������������������������������������������������������
    167](https://doi.org/10.1007/978-1-4842-8179-6_4#Sec1)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Layman’s Definition �������������������������������������������������������������������������������������������������������������
    167](https://doi.org/10.1007/978-1-4842-8179-6_4#Sec2)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Technical Definition �������������������������������������������������������������������������������������������������������������
    168](https://doi.org/10.1007/978-1-4842-8179-6_4#Sec3)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Background �������������������������������������������������������������������������������������������������������������������������������
    168](https://doi.org/10.1007/978-1-4842-8179-6_4#Sec4)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Digital Cash Creation Attempts ��������������������������������������������������������������������������������������������
    168](https://doi.org/10.1007/978-1-4842-8179-6_4#Sec5)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Benefits of Blockchain ��������������������������������������������������������������������������������������������������������������
    170](https://doi.org/10.1007/978-1-4842-8179-6_4#Sec7)'
  prefs: []
  type: TYPE_NORMAL
- en: viii
  prefs: []
  type: TYPE_NORMAL
- en: Table of ConTenTs
  prefs: []
  type: TYPE_NORMAL
- en: '[Types of Blockchain ������������������������������������������������������������������������������������������������������������������
    172](https://doi.org/10.1007/978-1-4842-8179-6_4#Sec8)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Blockchain Is a Distributed System ������������������������������������������������������������������������������������������
    174](https://doi.org/10.1007/978-1-4842-8179-6_4#Sec9)'
  prefs: []
  type: TYPE_NORMAL
- en: '[CAP and Permissionless Blockchain �����������������������������������������������������������������������������������
    174](https://doi.org/10.1007/978-1-4842-8179-6_4#Sec10)'
  prefs: []
  type: TYPE_NORMAL
- en: '[CAP and Permissioned Blockchain ��������������������������������������������������������������������������������������
    174](https://doi.org/10.1007/978-1-4842-8179-6_4#Sec11)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Blockchain Ledger Abstraction ��������������������������������������������������������������������������������������������
    175](https://doi.org/10.1007/978-1-4842-8179-6_4#Sec12)'
  prefs: []
  type: TYPE_NORMAL
- en: '[How Blockchain Works��������������������������������������������������������������������������������������������������������������
    178](https://doi.org/10.1007/978-1-4842-8179-6_4#Sec24)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Anatomy of a Blockchain ����������������������������������������������������������������������������������������������������������
    179](https://doi.org/10.1007/978-1-4842-8179-6_4#Sec25)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Block ������������������������������������������������������������������������������������������������������������������������������������
    180](https://doi.org/10.1007/978-1-4842-8179-6_4#Sec26)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Platforms �����������������������������������������������������������������������������������������������������������������������������������
    181](https://doi.org/10.1007/978-1-4842-8179-6_4#Sec27)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Bitcoin ���������������������������������������������������������������������������������������������������������������������������������
    181](https://doi.org/10.1007/978-1-4842-8179-6_4#Sec28)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Ethereum �����������������������������������������������������������������������������������������������������������������������������������
    192](https://doi.org/10.1007/978-1-4842-8179-6_4#Sec38)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Ethereum Network ���������������������������������������������������������������������������������������������������������������
    192](https://doi.org/10.1007/978-1-4842-8179-6_4#Sec39)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Cryptography in Ethereum ���������������������������������������������������������������������������������������������������
    196](https://doi.org/10.1007/978-1-4842-8179-6_4#Sec40)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Transactions and Executions �����������������������������������������������������������������������������������������������
    197](https://doi.org/10.1007/978-1-4842-8179-6_4#Sec42)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Blocks and Blockchain ��������������������������������������������������������������������������������������������������������
    199](https://doi.org/10.1007/978-1-4842-8179-6_4#Sec43)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Mining in Ethereum �������������������������������������������������������������������������������������������������������������
    201](https://doi.org/10.1007/978-1-4842-8179-6_4#Sec48)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Ethereum Virtual Machine and Smart Contracts �����������������������������������������������������������������
    202](https://doi.org/10.1007/978-1-4842-8179-6_4#Sec49)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Summary�����������������������������������������������������������������������������������������������������������������������������������
    203](https://doi.org/10.1007/978-1-4842-8179-6_4#Sec50)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Bibliography ������������������������������������������������������������������������������������������������������������������������������
    204](https://doi.org/10.1007/978-1-4842-8179-6_4#Sec51)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 5: Blockchain Consensus ������������������������������������������������������������������������
    207](https://doi.org/10.1007/978-1-4842-8179-6_5)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Background �������������������������������������������������������������������������������������������������������������������������������
    208](https://doi.org/10.1007/978-1-4842-8179-6_5#Sec1)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Blockchain Consensus ��������������������������������������������������������������������������������������������������������������
    210](https://doi.org/10.1007/978-1-4842-8179-6_5#Sec2)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Traditional BFT ���������������������������������������������������������������������������������������������������������������������
    210](https://doi.org/10.1007/978-1-4842-8179-6_5#Sec3)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Nakamoto Consensus ����������������������������������������������������������������������������������������������������������
    211](https://doi.org/10.1007/978-1-4842-8179-6_5#Sec11)'
  prefs: []
  type: TYPE_NORMAL
- en: '[System Model ���������������������������������������������������������������������������������������������������������������������������
    213](https://doi.org/10.1007/978-1-4842-8179-6_5#Sec19)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Public Blockchain System Model (Permissionless) �������������������������������������������������������������
    213](https://doi.org/10.1007/978-1-4842-8179-6_5#Sec20)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Consortium Blockchain System Model (Permissioned) �������������������������������������������������������
    214](https://doi.org/10.1007/978-1-4842-8179-6_5#Sec21)'
  prefs: []
  type: TYPE_NORMAL
- en: '[First Blockchain Consensus ������������������������������������������������������������������������������������������������������
    214](https://doi.org/10.1007/978-1-4842-8179-6_5#Sec22)'
  prefs: []
  type: TYPE_NORMAL
- en: '[How PoW Works ������������������������������������������������������������������������������������������������������������������
    216](https://doi.org/10.1007/978-1-4842-8179-6_5#Sec23)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Pedagogical Explanation of PoW �����������������������������������������������������������������������������������������
    217](https://doi.org/10.1007/978-1-4842-8179-6_5#Sec24)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PoW Formula �����������������������������������������������������������������������������������������������������������������������
    221](https://doi.org/10.1007/978-1-4842-8179-6_5#Sec25)'
  prefs: []
  type: TYPE_NORMAL
- en: ix
  prefs: []
  type: TYPE_NORMAL
- en: Table of ConTenTs
  prefs: []
  type: TYPE_NORMAL
- en: '[Similarities Between PoW and Traditional BFT ��������������������������������������������������������������������
    237](https://doi.org/10.1007/978-1-4842-8179-6_5#Sec39)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PoW As State Machine Replication ��������������������������������������������������������������������������������������
    238](https://doi.org/10.1007/978-1-4842-8179-6_5#Sec43)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PoW Concerns ���������������������������������������������������������������������������������������������������������������������
    251](https://doi.org/10.1007/978-1-4842-8179-6_5#Sec57)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Summary�����������������������������������������������������������������������������������������������������������������������������������
    256](https://doi.org/10.1007/978-1-4842-8179-6_5#Sec68)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Bibliography ������������������������������������������������������������������������������������������������������������������������������
    256](https://doi.org/10.1007/978-1-4842-8179-6_5#Sec69)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 6: Early Protocols ������������������������������������������������������������������������������������
    259](https://doi.org/10.1007/978-1-4842-8179-6_6)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Introduction �������������������������������������������������������������������������������������������������������������������������������
    259](https://doi.org/10.1007/978-1-4842-8179-6_6#Sec1)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Distributed Transactions �����������������������������������������������������������������������������������������������������������
    262](https://doi.org/10.1007/978-1-4842-8179-6_6#Sec2)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Two-Phase Commit��������������������������������������������������������������������������������������������������������������
    263](https://doi.org/10.1007/978-1-4842-8179-6_6#Sec3)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Three-Phase Commit �����������������������������������������������������������������������������������������������������������
    266](https://doi.org/10.1007/978-1-4842-8179-6_6#Sec4)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Oral Message Algorithm ������������������������������������������������������������������������������������������������������������
    268](https://doi.org/10.1007/978-1-4842-8179-6_6#Sec5)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Signed Message Solution to Byzantine Generals Problem ��������������������������������������������������
    272](https://doi.org/10.1007/978-1-4842-8179-6_6#Sec6)'
  prefs: []
  type: TYPE_NORMAL
- en: '[DLS Protocols Under Partial Synchrony ������������������������������������������������������������������������������������
    275](https://doi.org/10.1007/978-1-4842-8179-6_6#Sec7)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Ben-Or Algorithms ���������������������������������������������������������������������������������������������������������������������
    278](https://doi.org/10.1007/978-1-4842-8179-6_6#Sec8)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Consensus Using Failure Detectors �������������������������������������������������������������������������������������
    284](https://doi.org/10.1007/978-1-4842-8179-6_6#Sec9)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Summary�����������������������������������������������������������������������������������������������������������������������������������
    287](https://doi.org/10.1007/978-1-4842-8179-6_6#Sec10)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Bibliography ������������������������������������������������������������������������������������������������������������������������������
    287](https://doi.org/10.1007/978-1-4842-8179-6_6#Sec11)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 7: Classical Consensus ����������������������������������������������������������������������������
    291](https://doi.org/10.1007/978-1-4842-8179-6_7)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Viewstamped Replication����������������������������������������������������������������������������������������������������������
    291](https://doi.org/10.1007/978-1-4842-8179-6_7#Sec1)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Protocol Steps ���������������������������������������������������������������������������������������������������������������������
    293](https://doi.org/10.1007/978-1-4842-8179-6_7#Sec2)'
  prefs: []
  type: TYPE_NORMAL
- en: '[View Change ������������������������������������������������������������������������������������������������������������������������
    294](https://doi.org/10.1007/978-1-4842-8179-6_7#Sec3)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Paxos ����������������������������������������������������������������������������������������������������������������������������������������
    296](https://doi.org/10.1007/978-1-4842-8179-6_7#Sec4)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Failure Scenarios �����������������������������������������������������������������������������������������������������������������
    301](https://doi.org/10.1007/978-1-4842-8179-6_7#Sec5)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Safety and Liveness ������������������������������������������������������������������������������������������������������������
    304](https://doi.org/10.1007/978-1-4842-8179-6_7#Sec6)'
  prefs: []
  type: TYPE_NORMAL
- en: '[In Practice����������������������������������������������������������������������������������������������������������������������������
    305](https://doi.org/10.1007/978-1-4842-8179-6_7#Sec7)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Variants �������������������������������������������������������������������������������������������������������������������������������
    305](https://doi.org/10.1007/978-1-4842-8179-6_7#Sec8)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Multi-Paxos �������������������������������������������������������������������������������������������������������������������������
    306](https://doi.org/10.1007/978-1-4842-8179-6_7#Sec9)'
  prefs: []
  type: TYPE_NORMAL
- en: '[RAFT ������������������������������������������������������������������������������������������������������������������������������������������
    308](https://doi.org/10.1007/978-1-4842-8179-6_7#Sec10)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Leader Election ��������������������������������������������������������������������������������������������������������������������
    310](https://doi.org/10.1007/978-1-4842-8179-6_7#Sec11)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Log Replication ��������������������������������������������������������������������������������������������������������������������
    311](https://doi.org/10.1007/978-1-4842-8179-6_7#Sec12)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Guarantees and Correctness �����������������������������������������������������������������������������������������������
    314](https://doi.org/10.1007/978-1-4842-8179-6_7#Sec13)'
  prefs: []
  type: TYPE_NORMAL
- en: x
  prefs: []
  type: TYPE_NORMAL
- en: Table of ConTenTs
  prefs: []
  type: TYPE_NORMAL
- en: '[PBFT ������������������������������������������������������������������������������������������������������������������������������������������
    315](https://doi.org/10.1007/978-1-4842-8179-6_7#Sec14)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Certificates in PBFT �������������������������������������������������������������������������������������������������������������
    319](https://doi.org/10.1007/978-1-4842-8179-6_7#Sec15)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PBFT Advantages and Disadvantages ���������������������������������������������������������������������������������
    323](https://doi.org/10.1007/978-1-4842-8179-6_7#Sec19)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Safety and Liveness ������������������������������������������������������������������������������������������������������������
    324](https://doi.org/10.1007/978-1-4842-8179-6_7#Sec22)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Blockchain and Classical Consensus ����������������������������������������������������������������������������������������
    327](https://doi.org/10.1007/978-1-4842-8179-6_7#Sec25)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Summary�����������������������������������������������������������������������������������������������������������������������������������
    328](https://doi.org/10.1007/978-1-4842-8179-6_7#Sec26)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Bibliography ������������������������������������������������������������������������������������������������������������������������������
    328](https://doi.org/10.1007/978-1-4842-8179-6_7#Sec27)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 8: Blockchain Age Protocols �������������������������������������������������������������������
    331](https://doi.org/10.1007/978-1-4842-8179-6_8)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Introduction �������������������������������������������������������������������������������������������������������������������������������
    331](https://doi.org/10.1007/978-1-4842-8179-6_8#Sec1)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Proof of Stake ���������������������������������������������������������������������������������������������������������������������������
    333](https://doi.org/10.1007/978-1-4842-8179-6_8#Sec2)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chain-Based PoS �����������������������������������������������������������������������������������������������������������������
    335](https://doi.org/10.1007/978-1-4842-8179-6_8#Sec3)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Committee-Based PoS ���������������������������������������������������������������������������������������������������������
    335](https://doi.org/10.1007/978-1-4842-8179-6_8#Sec4)'
  prefs: []
  type: TYPE_NORMAL
- en: '[BFT-Based PoS ��������������������������������������������������������������������������������������������������������������������
    336](https://doi.org/10.1007/978-1-4842-8179-6_8#Sec5)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Delegated PoS ���������������������������������������������������������������������������������������������������������������������
    337](https://doi.org/10.1007/978-1-4842-8179-6_8#Sec6)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Liquid PoS ����������������������������������������������������������������������������������������������������������������������������
    337](https://doi.org/10.1007/978-1-4842-8179-6_8#Sec7)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Attacks���������������������������������������������������������������������������������������������������������������������������������
    338](https://doi.org/10.1007/978-1-4842-8179-6_8#Sec8)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Ethereum’s Proof of Work ���������������������������������������������������������������������������������������������������������
    339](https://doi.org/10.1007/978-1-4842-8179-6_8#Sec12)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Solana ���������������������������������������������������������������������������������������������������������������������������������������
    342](https://doi.org/10.1007/978-1-4842-8179-6_8#Sec13)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Proof of History ��������������������������������������������������������������������������������������������������������������������
    343](https://doi.org/10.1007/978-1-4842-8179-6_8#Sec14)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Tendermint ��������������������������������������������������������������������������������������������������������������������������������
    347](https://doi.org/10.1007/978-1-4842-8179-6_8#Sec15)'
  prefs: []
  type: TYPE_NORMAL
- en: '[HotStuff �������������������������������������������������������������������������������������������������������������������������������������
    353](https://doi.org/10.1007/978-1-4842-8179-6_8#Sec16)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Linear View Change �������������������������������������������������������������������������������������������������������������
    353](https://doi.org/10.1007/978-1-4842-8179-6_8#Sec17)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Optimistic Responsiveness ��������������������������������������������������������������������������������������������������
    354](https://doi.org/10.1007/978-1-4842-8179-6_8#Sec18)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chain Quality �����������������������������������������������������������������������������������������������������������������������
    354](https://doi.org/10.1007/978-1-4842-8179-6_8#Sec19)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Hidden Lock �������������������������������������������������������������������������������������������������������������������������
    354](https://doi.org/10.1007/978-1-4842-8179-6_8#Sec20)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Pacemaker ��������������������������������������������������������������������������������������������������������������������������
    355](https://doi.org/10.1007/978-1-4842-8179-6_8#Sec21)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Better Participant Organization Topology ����������������������������������������������������������������������������
    355](https://doi.org/10.1007/978-1-4842-8179-6_8#Sec22)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Polkadot ������������������������������������������������������������������������������������������������������������������������������������
    359](https://doi.org/10.1007/978-1-4842-8179-6_8#Sec29)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Consensus in Polkadot ��������������������������������������������������������������������������������������������������������
    361](https://doi.org/10.1007/978-1-4842-8179-6_8#Sec30)'
  prefs: []
  type: TYPE_NORMAL
- en: xi
  prefs: []
  type: TYPE_NORMAL
- en: Table of ConTenTs
  prefs: []
  type: TYPE_NORMAL
- en: '[Ethereum 2 ��������������������������������������������������������������������������������������������������������������������������������
    368](https://doi.org/10.1007/978-1-4842-8179-6_8#Sec44)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Casper ���������������������������������������������������������������������������������������������������������������������������������
    370](https://doi.org/10.1007/978-1-4842-8179-6_8#Sec45)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Summary�����������������������������������������������������������������������������������������������������������������������������������
    374](https://doi.org/10.1007/978-1-4842-8179-6_8#Sec47)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Bibliography ������������������������������������������������������������������������������������������������������������������������������
    375](https://doi.org/10.1007/978-1-4842-8179-6_8#Sec48)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 9: Quantum Consensus����������������������������������������������������������������������������
    377](https://doi.org/10.1007/978-1-4842-8179-6_9)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Introduction �������������������������������������������������������������������������������������������������������������������������������
    377](https://doi.org/10.1007/978-1-4842-8179-6_9#Sec1)'
  prefs: []
  type: TYPE_NORMAL
- en: '[What Is a Quantum Computer? �������������������������������������������������������������������������������������������������
    378](https://doi.org/10.1007/978-1-4842-8179-6_9#Sec2)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Qubit ������������������������������������������������������������������������������������������������������������������������������������
    380](https://doi.org/10.1007/978-1-4842-8179-6_9#Sec3)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Superposition ����������������������������������������������������������������������������������������������������������������������
    382](https://doi.org/10.1007/978-1-4842-8179-6_9#Sec4)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Entanglement ����������������������������������������������������������������������������������������������������������������������
    382](https://doi.org/10.1007/978-1-4842-8179-6_9#Sec5)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Quantum Gates �������������������������������������������������������������������������������������������������������������������������
    384](https://doi.org/10.1007/978-1-4842-8179-6_9#Sec8)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Hadamard ����������������������������������������������������������������������������������������������������������������������������
    384](https://doi.org/10.1007/978-1-4842-8179-6_9#Sec9)'
  prefs: []
  type: TYPE_NORMAL
- en: '[T�������������������������������������������������������������������������������������������������������������������������������������������
    385](https://doi.org/10.1007/978-1-4842-8179-6_9#Sec10)'
  prefs: []
  type: TYPE_NORMAL
- en: '[CNOT ������������������������������������������������������������������������������������������������������������������������������������
    385](https://doi.org/10.1007/978-1-4842-8179-6_9#Sec11)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Toffoli (CCNOT) ���������������������������������������������������������������������������������������������������������������������
    385](https://doi.org/10.1007/978-1-4842-8179-6_9#Sec12)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Z�������������������������������������������������������������������������������������������������������������������������������������������
    385](https://doi.org/10.1007/978-1-4842-8179-6_9#Sec13)'
  prefs: []
  type: TYPE_NORMAL
- en: '[NOT ��������������������������������������������������������������������������������������������������������������������������������������
    385](https://doi.org/10.1007/978-1-4842-8179-6_9#Sec14)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Swap Gate ���������������������������������������������������������������������������������������������������������������������������
    385](https://doi.org/10.1007/978-1-4842-8179-6_9#Sec15)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Measurement ����������������������������������������������������������������������������������������������������������������������
    386](https://doi.org/10.1007/978-1-4842-8179-6_9#Sec16)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Quantum Circuits ����������������������������������������������������������������������������������������������������������������������
    386](https://doi.org/10.1007/978-1-4842-8179-6_9#Sec17)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Teleportation Circuit ������������������������������������������������������������������������������������������������������������
    387](https://doi.org/10.1007/978-1-4842-8179-6_9#Sec18)'
  prefs: []
  type: TYPE_NORMAL
- en: '[GHZ Circuit ���������������������������������������������������������������������������������������������������������������������������
    387](https://doi.org/10.1007/978-1-4842-8179-6_9#Sec19)'
  prefs: []
  type: TYPE_NORMAL
- en: '[W State Circuit ���������������������������������������������������������������������������������������������������������������������
    388](https://doi.org/10.1007/978-1-4842-8179-6_9#Sec20)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Quantum Algorithms �����������������������������������������������������������������������������������������������������������������
    388](https://doi.org/10.1007/978-1-4842-8179-6_9#Sec21)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Quantum Computational Complexity �����������������������������������������������������������������������������������������
    389](https://doi.org/10.1007/978-1-4842-8179-6_9#Sec22)'
  prefs: []
  type: TYPE_NORMAL
- en: '[P – Polynomial ���������������������������������������������������������������������������������������������������������������������
    391](https://doi.org/10.1007/978-1-4842-8179-6_9#Sec23)'
  prefs: []
  type: TYPE_NORMAL
- en: '[NP – Nondeterministic Polynomial ��������������������������������������������������������������������������������������
    391](https://doi.org/10.1007/978-1-4842-8179-6_9#Sec24)'
  prefs: []
  type: TYPE_NORMAL
- en: '[BPP – Bounded Error Probabilistic Polynomial Time �����������������������������������������������������������
    391](https://doi.org/10.1007/978-1-4842-8179-6_9#Sec25)'
  prefs: []
  type: TYPE_NORMAL
- en: '[BQP – Bounded Error Quantum Polynomial Time ����������������������������������������������������������������
    392](https://doi.org/10.1007/978-1-4842-8179-6_9#Sec26)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PSPACE – Polynomial Space �����������������������������������������������������������������������������������������������
    392](https://doi.org/10.1007/978-1-4842-8179-6_9#Sec27)'
  prefs: []
  type: TYPE_NORMAL
- en: xii
  prefs: []
  type: TYPE_NORMAL
- en: Table of ConTenTs
  prefs: []
  type: TYPE_NORMAL
- en: '[Other Quantum Systems �����������������������������������������������������������������������������������������������������������
    393](https://doi.org/10.1007/978-1-4842-8179-6_9#Sec28)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Quantum Networks ��������������������������������������������������������������������������������������������������������������
    393](https://doi.org/10.1007/978-1-4842-8179-6_9#Sec29)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Quantum Internet ����������������������������������������������������������������������������������������������������������������
    393](https://doi.org/10.1007/978-1-4842-8179-6_9#Sec30)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Quantum Distributed Systems – Distributed Quantum Computing �������������������������������������
    394](https://doi.org/10.1007/978-1-4842-8179-6_9#Sec31)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Quantum Blockchain �����������������������������������������������������������������������������������������������������������
    395](https://doi.org/10.1007/978-1-4842-8179-6_9#Sec32)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Quantum Cryptography��������������������������������������������������������������������������������������������������������
    396](https://doi.org/10.1007/978-1-4842-8179-6_9#Sec33)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Quantum Consensus �����������������������������������������������������������������������������������������������������������������
    398](https://doi.org/10.1007/978-1-4842-8179-6_9#Sec34)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Fast Quantum Byzantine Agreement �����������������������������������������������������������������������������������
    399](https://doi.org/10.1007/978-1-4842-8179-6_9#Sec35)'
  prefs: []
  type: TYPE_NORMAL
- en: '[How to Refute FLP Impossibility ������������������������������������������������������������������������������������������
    401](https://doi.org/10.1007/978-1-4842-8179-6_9#Sec36)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Enhanced Distributed Consensus ����������������������������������������������������������������������������������������
    403](https://doi.org/10.1007/978-1-4842-8179-6_9#Sec37)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Quantum Leader Election and Consensus ���������������������������������������������������������������������������
    405](https://doi.org/10.1007/978-1-4842-8179-6_9#Sec38)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Other Algorithms ������������������������������������������������������������������������������������������������������������������
    406](https://doi.org/10.1007/978-1-4842-8179-6_9#Sec39)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Summary�����������������������������������������������������������������������������������������������������������������������������������
    407](https://doi.org/10.1007/978-1-4842-8179-6_9#Sec40)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Bibliography ������������������������������������������������������������������������������������������������������������������������������
    408](https://doi.org/10.1007/978-1-4842-8179-6_9#Sec41)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 10: Conclusion �����������������������������������������������������������������������������������������
    411](https://doi.org/10.1007/978-1-4842-8179-6_10)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Introduction �������������������������������������������������������������������������������������������������������������������������������
    411](https://doi.org/10.1007/978-1-4842-8179-6_10#Sec1)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Other Protocols �������������������������������������������������������������������������������������������������������������������������
    411](https://doi.org/10.1007/978-1-4842-8179-6_10#Sec2)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PoET�������������������������������������������������������������������������������������������������������������������������������������
    412](https://doi.org/10.1007/978-1-4842-8179-6_10#Sec3)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Proof of Authority �����������������������������������������������������������������������������������������������������������������
    413](https://doi.org/10.1007/978-1-4842-8179-6_10#Sec4)'
  prefs: []
  type: TYPE_NORMAL
- en: '[HoneyBadger BFT ����������������������������������������������������������������������������������������������������������������
    413](https://doi.org/10.1007/978-1-4842-8179-6_10#Sec5)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Avalanche ����������������������������������������������������������������������������������������������������������������������������
    415](https://doi.org/10.1007/978-1-4842-8179-6_10#Sec6)'
  prefs: []
  type: TYPE_NORMAL
- en: '[DAG-Based Consensus Protocols ����������������������������������������������������������������������������������������
    415](https://doi.org/10.1007/978-1-4842-8179-6_10#Sec7)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Ebb-and-Flow Protocols ������������������������������������������������������������������������������������������������������
    416](https://doi.org/10.1007/978-1-4842-8179-6_10#Sec10)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Formal Verification ��������������������������������������������������������������������������������������������������������������������
    417](https://doi.org/10.1007/978-1-4842-8179-6_10#Sec11)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Impossibility Results �����������������������������������������������������������������������������������������������������������������
    420](https://doi.org/10.1007/978-1-4842-8179-6_10#Sec12)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Complexity and Performance ����������������������������������������������������������������������������������������������������
    422](https://doi.org/10.1007/978-1-4842-8179-6_10#Sec13)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Message Complexity �����������������������������������������������������������������������������������������������������������
    422](https://doi.org/10.1007/978-1-4842-8179-6_10#Sec14)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Communication Complexity (Bit Complexity) �����������������������������������������������������������������������
    422](https://doi.org/10.1007/978-1-4842-8179-6_10#Sec15)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Time Complexity ������������������������������������������������������������������������������������������������������������������
    423](https://doi.org/10.1007/978-1-4842-8179-6_10#Sec16)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Space Complexity ����������������������������������������������������������������������������������������������������������������
    423](https://doi.org/10.1007/978-1-4842-8179-6_10#Sec17)'
  prefs: []
  type: TYPE_NORMAL
- en: xiii
  prefs: []
  type: TYPE_NORMAL
- en: Table of ConTenTs
  prefs: []
  type: TYPE_NORMAL
- en: '[Comparison of Protocols �����������������������������������������������������������������������������������������������������������
    424](https://doi.org/10.1007/978-1-4842-8179-6_10#Sec18)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Network Model ��������������������������������������������������������������������������������������������������������������������
    426](https://doi.org/10.1007/978-1-4842-8179-6_10#Sec19)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Research Directions ������������������������������������������������������������������������������������������������������������������
    428](https://doi.org/10.1007/978-1-4842-8179-6_10#Sec25)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Summary�����������������������������������������������������������������������������������������������������������������������������������
    430](https://doi.org/10.1007/978-1-4842-8179-6_10#Sec26)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Bibliography ������������������������������������������������������������������������������������������������������������������������������
    430](https://doi.org/10.1007/978-1-4842-8179-6_10#Sec27)'
  prefs: []
  type: TYPE_NORMAL
- en: Index ���������������������������������������������������������������������������������������������������������������������
    431
  prefs: []
  type: TYPE_NORMAL
- en: xiv
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-15_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**About the Author**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Imran Bashir** has an MSc in information security from Royal'
  prefs: []
  type: TYPE_NORMAL
- en: Holloway, University of London. He has a background in
  prefs: []
  type: TYPE_NORMAL
- en: software development, solution architecture, infrastructure
  prefs: []
  type: TYPE_NORMAL
- en: management, information security, and IT service
  prefs: []
  type: TYPE_NORMAL
- en: management. His current focus is on the latest technologies
  prefs: []
  type: TYPE_NORMAL
- en: such as the blockchain and quantum computing. He is
  prefs: []
  type: TYPE_NORMAL
- en: a member of the Institute of Electrical and Electronics
  prefs: []
  type: TYPE_NORMAL
- en: Engineers (IEEE) and the British Computer Society (BCS).
  prefs: []
  type: TYPE_NORMAL
- en: His book on blockchain technology, *Mastering Blockchain*,
  prefs: []
  type: TYPE_NORMAL
- en: is a widely accepted standard text on the subject. He has worked in various
    senior
  prefs: []
  type: TYPE_NORMAL
- en: technical roles for different organizations worldwide. Currently, he is working
    as a
  prefs: []
  type: TYPE_NORMAL
- en: researcher in London, UK.
  prefs: []
  type: TYPE_NORMAL
- en: xv
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-16_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**About the Technical Reviewer**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Prasanth Sahoo** is a thought leader, an adjunct professor, a'
  prefs: []
  type: TYPE_NORMAL
- en: technical speaker, and a full-time practitioner in blockchain,
  prefs: []
  type: TYPE_NORMAL
- en: DevOps, cloud, and Agile, working for PDI Software.
  prefs: []
  type: TYPE_NORMAL
- en: He was awarded the “Blockchain and Cloud Expert of
  prefs: []
  type: TYPE_NORMAL
- en: the Year Award 2019” from TCS Global Community
  prefs: []
  type: TYPE_NORMAL
- en: for his knowledge share within academic services to
  prefs: []
  type: TYPE_NORMAL
- en: the community. He is passionate about driving digital
  prefs: []
  type: TYPE_NORMAL
- en: technology initiatives by handling various community
  prefs: []
  type: TYPE_NORMAL
- en: initiatives through coaching, mentoring, and grooming
  prefs: []
  type: TYPE_NORMAL
- en: techniques.
  prefs: []
  type: TYPE_NORMAL
- en: xvii
  prefs: []
  type: TYPE_NORMAL
- en: '**Acknowledgments**'
  prefs: []
  type: TYPE_NORMAL
- en: This book would not have been possible without help from many people. First,
    I would
  prefs: []
  type: TYPE_NORMAL
- en: like to thank Aditee Mirashi from Apress for her time, patience, and dedication
    to this
  prefs: []
  type: TYPE_NORMAL
- en: project.
  prefs: []
  type: TYPE_NORMAL
- en: Over the years, I have gone through many books, papers, online resources, and
  prefs: []
  type: TYPE_NORMAL
- en: lectures from experts and academics in this field to learn about this subject.
    I want to
  prefs: []
  type: TYPE_NORMAL
- en: thank all those researchers and engineers who have shared their knowledge. I
    also want
  prefs: []
  type: TYPE_NORMAL
- en: to thank the reviewers whose suggestions have improved this book greatly.
  prefs: []
  type: TYPE_NORMAL
- en: I want to thank my wife and children for their support and bearing with me when
  prefs: []
  type: TYPE_NORMAL
- en: I was busy writing during weekends, which I was supposed to spend with them.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, I want to thank my father, my beacon of light. He sacrificed everything
    for
  prefs: []
  type: TYPE_NORMAL
- en: me, guided me at every step in life, and empowered me to achieve the best in
    life. Thank
  prefs: []
  type: TYPE_NORMAL
- en: you, Dad! He motivated me to write this book and suggested that I publish it
    in 2022\.
  prefs: []
  type: TYPE_NORMAL
- en: And my mother, whose unconditional love for me has no bounds. Thank you Ammi!
  prefs: []
  type: TYPE_NORMAL
- en: xix
  prefs: []
  type: TYPE_NORMAL
- en: '**Introduction**'
  prefs: []
  type: TYPE_NORMAL
- en: This book is an introduction to distributed consensus and its use in the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: It covers classical protocols, blockchain age protocols that emerged after Bitcoin,
    and
  prefs: []
  type: TYPE_NORMAL
- en: quantum protocols. Many enthusiasts have come from different backgrounds into
  prefs: []
  type: TYPE_NORMAL
- en: the blockchain world and may not have traditional distributed systems experience.
  prefs: []
  type: TYPE_NORMAL
- en: This book fills that knowledge gap. It introduces classical protocols and foundations
  prefs: []
  type: TYPE_NORMAL
- en: of distributed consensus so that a solid foundation is built to understand the
  prefs: []
  type: TYPE_NORMAL
- en: research on blockchain consensus. Many other people have come from traditional
  prefs: []
  type: TYPE_NORMAL
- en: distributed systems backgrounds, either developers or theorists. Still, they
    may lack the understanding of blockchain and relevant concepts such as Bitcoin
    and Ethereum. This
  prefs: []
  type: TYPE_NORMAL
- en: book will fill that gap too.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, as quantum computing will impact almost everything in the future,
    I have
  prefs: []
  type: TYPE_NORMAL
- en: also covered how quantum computing can help build quantum consensus algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: A clear advantage can be realized in the efficiency and security of consensus
    algorithms
  prefs: []
  type: TYPE_NORMAL
- en: by using quantum computing. Therefore, an entire chapter is dedicated to quantum
  prefs: []
  type: TYPE_NORMAL
- en: consensus.
  prefs: []
  type: TYPE_NORMAL
- en: This book is for everyone who wants to understand this fascinating world of
  prefs: []
  type: TYPE_NORMAL
- en: blockchain consensus and distributed consensus in general. A basic understanding
  prefs: []
  type: TYPE_NORMAL
- en: of computer science is all that's required to fully benefit from this book.
    This book can also serve as a study resource for a one-semester course on blockchain
    and distributed
  prefs: []
  type: TYPE_NORMAL
- en: consensus.
  prefs: []
  type: TYPE_NORMAL
- en: The book starts with a basic introduction to what distributed consensus is and
    covers
  prefs: []
  type: TYPE_NORMAL
- en: fundamental ideas such as causality, time, and various distributed system models.
    Then
  prefs: []
  type: TYPE_NORMAL
- en: to build the foundation for understanding the security aspects of blockchain
    consensus,
  prefs: []
  type: TYPE_NORMAL
- en: an introduction to cryptography is provided. Then a detailed introduction to
    distributed
  prefs: []
  type: TYPE_NORMAL
- en: consensus is presented. Next, an introduction to the blockchain is given, which
    gives a
  prefs: []
  type: TYPE_NORMAL
- en: solid understanding of what a blockchain is and how it is fundamentally a distributed
  prefs: []
  type: TYPE_NORMAL
- en: system. We then discuss blockchain consensus, focusing on the first cryptocurrency
  prefs: []
  type: TYPE_NORMAL
- en: blockchain, Bitcoin, and how it achieves its security and distributed consensus
    goals.
  prefs: []
  type: TYPE_NORMAL
- en: Starting from Chapt[er 6](https://doi.org/10.1007/978-1-4842-8179-6_6) is an
    introduction to early protocols covering classical work like the Byzantine generals
    problem and its various solutions. After this, classical
  prefs: []
  type: TYPE_NORMAL
- en: xxi
  prefs: []
  type: TYPE_NORMAL
- en: InTroduCTIon
  prefs: []
  type: TYPE_NORMAL
- en: protocols such as Paxos, DLS, and PBFT are covered. Next, the blockchain protocols
  prefs: []
  type: TYPE_NORMAL
- en: such as ETHASH, Tendermint, GRANDPA, BABE, HotStuff, and Casper are introduced.
  prefs: []
  type: TYPE_NORMAL
- en: These protocols are the latest in the research on blockchain consensus mechanisms.
    Of
  prefs: []
  type: TYPE_NORMAL
- en: course, we cannot cover everything due to the vastness of the subject. Still,
    this chapter dedicated to blockchain consensus introduces all those protocols
    which are state of
  prefs: []
  type: TYPE_NORMAL
- en: the art and in use in mainstream blockchain platforms, such as Polkadot, Ethereum,
  prefs: []
  type: TYPE_NORMAL
- en: and Cosmos.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter is another exciting topic, quantum consensus. With the advent
    of
  prefs: []
  type: TYPE_NORMAL
- en: quantum computing, it has been realized that quantum computing can significantly
  prefs: []
  type: TYPE_NORMAL
- en: enhance the classical distributed consensus results. Even results such as FLP
  prefs: []
  type: TYPE_NORMAL
- en: impossibility might be possible to refute using quantum properties like superposition
  prefs: []
  type: TYPE_NORMAL
- en: and entanglement.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last chapter summarizes what we have learned in the book, introduces
  prefs: []
  type: TYPE_NORMAL
- en: some exotic protocols, and suggests some research directions.
  prefs: []
  type: TYPE_NORMAL
- en: As this book focuses on the foundations of the blockchain and consensus, I believe
  prefs: []
  type: TYPE_NORMAL
- en: that this book will serve as a great learning resource for all enthusiasts who
    want to learn about the blockchain and blockchain consensus. Furthermore, I hope
    that this book will
  prefs: []
  type: TYPE_NORMAL
- en: serve technologists, researchers, students, developers, and indeed anyone who
    wants to
  prefs: []
  type: TYPE_NORMAL
- en: know about this fascinating subject well for many years to come.
  prefs: []
  type: TYPE_NORMAL
- en: xxii
  prefs: []
  type: TYPE_NORMAL
- en: '**CHAPTER 1**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Introduction**'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we explore the foundations of distributed computing. First,
    we will
  prefs: []
  type: TYPE_NORMAL
- en: answer the questions about a distributed system, its fundamental abstractions,
    system
  prefs: []
  type: TYPE_NORMAL
- en: models, and relevant ideas.
  prefs: []
  type: TYPE_NORMAL
- en: '**Distributed Systems**'
  prefs: []
  type: TYPE_NORMAL
- en: In the literature, there are many different definitions of distributed systems.
    Still,
  prefs: []
  type: TYPE_NORMAL
- en: fundamentally they all address the fact that a distributed system is a collection
    of
  prefs: []
  type: TYPE_NORMAL
- en: computers working together to solve a problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some definitions from famous scholars in this field are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*A distributed system is one in which the failure of a computer you didn’t*'
  prefs: []
  type: TYPE_NORMAL
- en: '*even know existed can render your own computer unusable.*'
  prefs: []
  type: TYPE_NORMAL
- en: —Leslie Lamport
  prefs: []
  type: TYPE_NORMAL
- en: '[https://lamport.azurewebsites.net/pubs/distributed-system.txt](https://lamport.azurewebsites.net/pubs/distributed-system.txt)'
  prefs: []
  type: TYPE_NORMAL
- en: '*A distributed system is a collection of autonomous computing elements*'
  prefs: []
  type: TYPE_NORMAL
- en: '*that appears to its users as a single coherent system.*'
  prefs: []
  type: TYPE_NORMAL
- en: —Tanenbaum
  prefs: []
  type: TYPE_NORMAL
- en: '[www.distributed-systems.net/index.php/books/ds3/](http://www.distributed-systems.net/index.php/books/ds3/)'
  prefs: []
  type: TYPE_NORMAL
- en: Here is my own attempt!
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: © Imran Bashir 2022
  prefs: []
  type: TYPE_NORMAL
- en: I. Bashir, *Blockchain Consensus*, [https://doi.org/10.1007/978-1-4842-8179-6_1](https://doi.org/10.1007/978-1-4842-8179-6_1#DOI)
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 1 IntroduCtIon
  prefs: []
  type: TYPE_NORMAL
- en: A distributed system is a collection of autonomous computers that collaborate
    with
  prefs: []
  type: TYPE_NORMAL
- en: each other on a message-passing network to achieve a common goal.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, this problem is not solvable by a single computer, or the distributed
    system
  prefs: []
  type: TYPE_NORMAL
- en: is inherently distributed such as a social media application.
  prefs: []
  type: TYPE_NORMAL
- en: Some everyday examples of distributed systems are Google, Facebook, Twitter,
  prefs: []
  type: TYPE_NORMAL
- en: Amazon, and the World Wide Web. Another class of recently emerged and popular
  prefs: []
  type: TYPE_NORMAL
- en: distributed systems is blockchain or distributed ledgers, which we will cover
    in
  prefs: []
  type: TYPE_NORMAL
- en: Chapt[er 4\.](https://doi.org/10.1007/978-1-4842-8179-6_4)
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we lay the foundations and look at the distributed systems
    in general,
  prefs: []
  type: TYPE_NORMAL
- en: their characteristics and properties, motivations, and system models that help
    reason
  prefs: []
  type: TYPE_NORMAL
- en: about the properties of a distributed system.
  prefs: []
  type: TYPE_NORMAL
- en: While distributed systems can be quite complex and usually have to address many
  prefs: []
  type: TYPE_NORMAL
- en: design aspects, including process design, messages (interaction between processes),
  prefs: []
  type: TYPE_NORMAL
- en: performance, security, and event management, a core problem is consensus.
  prefs: []
  type: TYPE_NORMAL
- en: Consensus is a fundamental problem in distributed systems where despite some
  prefs: []
  type: TYPE_NORMAL
- en: failures in the system, the processes within the distributed system always agree
    to the
  prefs: []
  type: TYPE_NORMAL
- en: state of the system. We will do more of this in Chapt[er 3](https://doi.org/10.1007/978-1-4842-8179-6_3).
  prefs: []
  type: TYPE_NORMAL
- en: In the first chapter, we will lay the foundation of distributed systems and
    build an
  prefs: []
  type: TYPE_NORMAL
- en: intuition about what they are and how they work. After this, we will cover cryptography,
  prefs: []
  type: TYPE_NORMAL
- en: blockchain, and consensus, which will provide a solid foundation to then move
    on and
  prefs: []
  type: TYPE_NORMAL
- en: read the rest of the chapters, covering more in-depth topics such as consensus
    protocols, design and implementation, and some latest research on quantum consensus.
  prefs: []
  type: TYPE_NORMAL
- en: But first, let’s have a closer look at the distributed system foundations and
    discuss
  prefs: []
  type: TYPE_NORMAL
- en: what characteristics a distributed system has.
  prefs: []
  type: TYPE_NORMAL
- en: '**Characteristics**'
  prefs: []
  type: TYPE_NORMAL
- en: 'What makes a system distributed? Here are some fundamental properties:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. No global physical clocks
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Autonomous processors/independent processors/
  prefs: []
  type: TYPE_NORMAL
- en: indepedently failing
  prefs: []
  type: TYPE_NORMAL
- en: 3\. No global shared common memory
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 1 IntroduCtIon
  prefs: []
  type: TYPE_NORMAL
- en: 4\. Heterogeneous
  prefs: []
  type: TYPE_NORMAL
- en: 5\. Coherent
  prefs: []
  type: TYPE_NORMAL
- en: 6\. Concurrency/concurrent operation
  prefs: []
  type: TYPE_NORMAL
- en: No global physical clock implies that the system is distributed in nature and
  prefs: []
  type: TYPE_NORMAL
- en: asynchronous. The computers or nodes in a distributed system are independent
    with
  prefs: []
  type: TYPE_NORMAL
- en: their own memory, processor, and operating system. These systems do not have
    a global
  prefs: []
  type: TYPE_NORMAL
- en: shared clock as a source of time for the entire system, which makes the notion
    of time
  prefs: []
  type: TYPE_NORMAL
- en: tricky in distributed systems, and we will shortly see how to overcome this
    limitation.
  prefs: []
  type: TYPE_NORMAL
- en: The fact that there is no global shared memory implies that the only way processes
    can
  prefs: []
  type: TYPE_NORMAL
- en: communicate with each other is by consuming messages sent over a network using
  prefs: []
  type: TYPE_NORMAL
- en: channels or links.
  prefs: []
  type: TYPE_NORMAL
- en: All processes or computers or nodes in a distributed system are independent,
    with
  prefs: []
  type: TYPE_NORMAL
- en: their own operating system, memory, and processor. There is no global shared
    memory
  prefs: []
  type: TYPE_NORMAL
- en: in a distributed system, which implies that each processor has its own memory
    and
  prefs: []
  type: TYPE_NORMAL
- en: its own view of its state and has limited local knowledge unless a message from
    other
  prefs: []
  type: TYPE_NORMAL
- en: node(s) arrives and adds to the local knowledge of the node.
  prefs: []
  type: TYPE_NORMAL
- en: Distributed systems are usually heterogeneous with multiple different types
  prefs: []
  type: TYPE_NORMAL
- en: of computers with different architecture and processors. Such a setup can include
  prefs: []
  type: TYPE_NORMAL
- en: commodity computers, high-end servers, IoT devices, mobile devices, and virtually
  prefs: []
  type: TYPE_NORMAL
- en: any device or "thing" that runs the distributed algorithm to solve a common
    problem (achieve a common goal) the distributed system has been designed for.
  prefs: []
  type: TYPE_NORMAL
- en: Distributed systems are also coherent. This feature abstracts away all minute
    details
  prefs: []
  type: TYPE_NORMAL
- en: of the dispersed structure of a distributed system, and to an end user, it appears
    as a
  prefs: []
  type: TYPE_NORMAL
- en: single cohesive system. This concept is known as distribution transparency.
  prefs: []
  type: TYPE_NORMAL
- en: Concurrency in a distributed system is concerned with the requirement
  prefs: []
  type: TYPE_NORMAL
- en: that the distributed algorithm should run concurrently on all processors in
    the
  prefs: []
  type: TYPE_NORMAL
- en: distributed system.
  prefs: []
  type: TYPE_NORMAL
- en: Figur[e 1-1 sho](#p23)ws a generic model of a distributed system.
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-23_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 1 IntroduCtIon
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 1-1\.** A distributed system*'
  prefs: []
  type: TYPE_NORMAL
- en: There are several reasons why we would want to build a distributed system. The
    most
  prefs: []
  type: TYPE_NORMAL
- en: common reason is scalability. For example, imagine you have a single server
    serving 100
  prefs: []
  type: TYPE_NORMAL
- en: users a day; when the number of users grows, the usual method is to scale vertically
    by
  prefs: []
  type: TYPE_NORMAL
- en: adding more powerful hardware, for example, faster CPU, more RAM, bigger hard
    disk,
  prefs: []
  type: TYPE_NORMAL
- en: etc., but in some scenarios, you can only go so much vertically, and at some
    point, you
  prefs: []
  type: TYPE_NORMAL
- en: have to scale horizontally by adding more computers and somehow distributing
    the load
  prefs: []
  type: TYPE_NORMAL
- en: between them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Why Build Distributed Systems**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following, we introduce some motivations behind building distributed
    systems:'
  prefs: []
  type: TYPE_NORMAL
- en: • Reliability
  prefs: []
  type: TYPE_NORMAL
- en: • Performance
  prefs: []
  type: TYPE_NORMAL
- en: • Resource sharing
  prefs: []
  type: TYPE_NORMAL
- en: • Inherently distributed
  prefs: []
  type: TYPE_NORMAL
- en: Let’s have a look at each one of these reasons separately.
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 1 IntroduCtIon
  prefs: []
  type: TYPE_NORMAL
- en: '**Reliability**'
  prefs: []
  type: TYPE_NORMAL
- en: Reliability is a key advantage of distributed systems. Imagine if you have a
    single
  prefs: []
  type: TYPE_NORMAL
- en: computer. Then, when it fails, there is no choice but to reboot it or get a
    new one if it had developed a significant fault. However, there are multiple nodes
    in distributed systems
  prefs: []
  type: TYPE_NORMAL
- en: in a system that allows a distributed system to tolerate faults up to a level.
    Thus, even if some computers fail in a distributed network, the distributed system
    keeps functioning.
  prefs: []
  type: TYPE_NORMAL
- en: Reliability is one of the significant areas of study and research in distributed
    computing, and we will look at it in more detail in the context of fault tolerance
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Reliability encompasses several aspects including availability, integrity, and
    fault
  prefs: []
  type: TYPE_NORMAL
- en: 'tolerance:'
  prefs: []
  type: TYPE_NORMAL
- en: • **Availability** simply means that when a request is made by a client,
  prefs: []
  type: TYPE_NORMAL
- en: the distributed system should always be available.
  prefs: []
  type: TYPE_NORMAL
- en: • **Integrity** ensures that the state of the distributed system should
  prefs: []
  type: TYPE_NORMAL
- en: always be in stable and consistent state.
  prefs: []
  type: TYPE_NORMAL
- en: • **Fault tolerance** enables a distributed system to function even in case
  prefs: []
  type: TYPE_NORMAL
- en: of some failures.
  prefs: []
  type: TYPE_NORMAL
- en: '**Performance**'
  prefs: []
  type: TYPE_NORMAL
- en: In distributed systems, better performance can be achieved naturally. For example,
    in
  prefs: []
  type: TYPE_NORMAL
- en: the case of a cluster of computers working together, better performance can
    be achieved
  prefs: []
  type: TYPE_NORMAL
- en: by parallelizing the computation. Also, in a geographically dispersed distributed
  prefs: []
  type: TYPE_NORMAL
- en: network, clients (users) accessing nodes can get data from the node which is
    closer to
  prefs: []
  type: TYPE_NORMAL
- en: their geographic region, which results in quicker data access. For example,
    in the case
  prefs: []
  type: TYPE_NORMAL
- en: of Internet file download, a mirror that is closer to your geographic region
    will provide much better download speed as compared to the one that might be in
    another continent.
  prefs: []
  type: TYPE_NORMAL
- en: Performance of a distributed system generally encompasses two facets,
  prefs: []
  type: TYPE_NORMAL
- en: responsiveness and throughput.
  prefs: []
  type: TYPE_NORMAL
- en: '**Responsiveness**'
  prefs: []
  type: TYPE_NORMAL
- en: This property guarantees that the system is reasonably responsive, and users
    can get
  prefs: []
  type: TYPE_NORMAL
- en: adequate response from the distributed system.
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 1 IntroduCtIon
  prefs: []
  type: TYPE_NORMAL
- en: '**Throughput**'
  prefs: []
  type: TYPE_NORMAL
- en: Throughput of a distributed system is another measure by which the performance
    of
  prefs: []
  type: TYPE_NORMAL
- en: the distributed system can be judged. Throughput basically captures the rate
    at which
  prefs: []
  type: TYPE_NORMAL
- en: processing is done in the system; usually, it is measured in transactions per
    second.
  prefs: []
  type: TYPE_NORMAL
- en: As we will see later in Chapter [5, hi](https://doi.org/10.1007/978-1-4842-8179-6_5)gh
    transaction per second rate is quite desirable in blockchain systems (distributed
    ledgers). Quite often, transactions per second or
  prefs: []
  type: TYPE_NORMAL
- en: queries executed per second are measured for a distributed database as a measure
  prefs: []
  type: TYPE_NORMAL
- en: of the performance of the system. Throughput is impacted by different aspects
    of the
  prefs: []
  type: TYPE_NORMAL
- en: distributed system, for example, processing speeds, communication network quality,
  prefs: []
  type: TYPE_NORMAL
- en: speed and reliability, and the algorithm. If your hardware is good, but the
    algorithm
  prefs: []
  type: TYPE_NORMAL
- en: is designed poorly, then that can also impact the throughput, responsiveness,
    and the
  prefs: []
  type: TYPE_NORMAL
- en: overall performance of the system.
  prefs: []
  type: TYPE_NORMAL
- en: '**Resource Sharing**'
  prefs: []
  type: TYPE_NORMAL
- en: Resources in a distributed system can be shared with other nodes/participants
    in the
  prefs: []
  type: TYPE_NORMAL
- en: distributed system. Sometimes, there are expensive resources such as a supercomputer,
  prefs: []
  type: TYPE_NORMAL
- en: a quantum computer, or some industrial grade printer which can be too expensive
    to
  prefs: []
  type: TYPE_NORMAL
- en: be made available at each site; in that case, resources can be shared via communication
  prefs: []
  type: TYPE_NORMAL
- en: links to other nodes remotely. Another scenario could be where data can be divided
    into
  prefs: []
  type: TYPE_NORMAL
- en: multiple partitions (shards) to enable quick access.
  prefs: []
  type: TYPE_NORMAL
- en: '**Inherently Distributed**'
  prefs: []
  type: TYPE_NORMAL
- en: There are scenarios where there is no option but to build a distributed system
    because
  prefs: []
  type: TYPE_NORMAL
- en: the problem can only be solved by a distributed system. For example, a messaging
  prefs: []
  type: TYPE_NORMAL
- en: system is inherently distributed. Mobile network is inherently by nature distributed.
  prefs: []
  type: TYPE_NORMAL
- en: In these and similar use cases, a distributed system is the only one that can
    solve the
  prefs: []
  type: TYPE_NORMAL
- en: problem; therefore, the system has to be distributed by design.
  prefs: []
  type: TYPE_NORMAL
- en: With all these benefits of distributed systems, there are some challenges that
    need to
  prefs: []
  type: TYPE_NORMAL
- en: be addressed when building distributed systems. The properties of distributed
    systems
  prefs: []
  type: TYPE_NORMAL
- en: such as no access to a global clock, asynchrony, and partial failures make designing
  prefs: []
  type: TYPE_NORMAL
- en: reliable distributed systems a difficult task. In the next section, we look
    at some of the primary challenges that should be addressed while building distributed
    systems.
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 1 IntroduCtIon
  prefs: []
  type: TYPE_NORMAL
- en: '**Challenges**'
  prefs: []
  type: TYPE_NORMAL
- en: Distributed systems are hard to build. There are multiple challenges that need
    to be
  prefs: []
  type: TYPE_NORMAL
- en: addressed while designing distributed systems. A collection of some common challenges
  prefs: []
  type: TYPE_NORMAL
- en: is presented as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '**Fault Tolerance**'
  prefs: []
  type: TYPE_NORMAL
- en: With more computers and at times 100s of thousands in a data center, for example,
    in
  prefs: []
  type: TYPE_NORMAL
- en: the case of cloud computing, inevitably something somewhere would be failing.
    In other
  prefs: []
  type: TYPE_NORMAL
- en: words, the probability of failing some part of the distributed system, be it
    a network
  prefs: []
  type: TYPE_NORMAL
- en: cable, a processor, or some other hardware, increases with the number of computers.
  prefs: []
  type: TYPE_NORMAL
- en: This aspect of distributed systems requires that even if some parts of the distributed
  prefs: []
  type: TYPE_NORMAL
- en: system fail (usually a certain threshold), the distributed system as a whole
    must keep
  prefs: []
  type: TYPE_NORMAL
- en: operating. To this end, there are various problems that are studied in distributed
  prefs: []
  type: TYPE_NORMAL
- en: computing under the umbrella of fault tolerance. Fault-tolerant consensus is
    one such
  prefs: []
  type: TYPE_NORMAL
- en: example where the efforts are made to build consensus algorithms that continue
    to run
  prefs: []
  type: TYPE_NORMAL
- en: correctly as specified even in the presence of a threshold of faulty nodes or
    links in a
  prefs: []
  type: TYPE_NORMAL
- en: distributed system. We will see more details about that in Chapt[er 3](https://doi.org/10.1007/978-1-4842-8179-6_3).
  prefs: []
  type: TYPE_NORMAL
- en: A relevant area of study is **failure detection** which is concerned with the
  prefs: []
  type: TYPE_NORMAL
- en: development of algorithms that attempt to detect faults in a distributed system.
    This is
  prefs: []
  type: TYPE_NORMAL
- en: especially an area of concern in asynchronous distributed systems where there
    is no
  prefs: []
  type: TYPE_NORMAL
- en: upper bound on the message delivery times. The problem becomes even more tricky
  prefs: []
  type: TYPE_NORMAL
- en: when there is no way to distinguish between a failed node and a node that is
    simply
  prefs: []
  type: TYPE_NORMAL
- en: slower and a lost message on the link. Failure detection algorithms give a probabilistic
  prefs: []
  type: TYPE_NORMAL
- en: indication about the failure of a process. This up or down status of the node
    then can be used to handle that fault.
  prefs: []
  type: TYPE_NORMAL
- en: Another area of study is **replication** which provides fault tolerance on the
    principle that if the same data is replicated across multiple nodes in a distributed
    system, then
  prefs: []
  type: TYPE_NORMAL
- en: even if some nodes go down the data is still available, which helps to keep
    the system
  prefs: []
  type: TYPE_NORMAL
- en: stable and continue to meet its specification (guarantees) and remain available
    to the
  prefs: []
  type: TYPE_NORMAL
- en: end users. We will see more about replication in Chapt[er 3\.](https://doi.org/10.1007/978-1-4842-8179-6_3)
  prefs: []
  type: TYPE_NORMAL
- en: '**Security**'
  prefs: []
  type: TYPE_NORMAL
- en: Being a distributed system with multiple users using it, out of which some might
    be
  prefs: []
  type: TYPE_NORMAL
- en: malicious, the security of distributed systems becomes a prime concern. This
    situation
  prefs: []
  type: TYPE_NORMAL
- en: '7'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 1 IntroduCtIon
  prefs: []
  type: TYPE_NORMAL
- en: is even more critical in geographically dispersed distributed systems and open
    systems
  prefs: []
  type: TYPE_NORMAL
- en: such as blockchains, for example, Bitcoin blockchain. To this, the fundamental
    science
  prefs: []
  type: TYPE_NORMAL
- en: used for providing security in distributed systems is cryptography, which we
    will cover
  prefs: []
  type: TYPE_NORMAL
- en: in detail in Chapter [2, and w](https://doi.org/10.1007/978-1-4842-8179-6_2)e
    will keep referring to it throughout the book, especially in relation to blockchain
    consensus. Here, we study topics such as cryptography
  prefs: []
  type: TYPE_NORMAL
- en: and address challenges such as authentication, confidentiality, access control,
  prefs: []
  type: TYPE_NORMAL
- en: nonrepudiation, and data integrity.
  prefs: []
  type: TYPE_NORMAL
- en: '**Heterogeneity**'
  prefs: []
  type: TYPE_NORMAL
- en: A distributed system is not necessarily composed of exactly the same hardware
    nodes. It
  prefs: []
  type: TYPE_NORMAL
- en: is possible and is called homogenous distributed system, but usually the hardware
    and
  prefs: []
  type: TYPE_NORMAL
- en: operating systems are different from each other. In this type of scenario, different
    operating systems and hardware can behave differently, leading to synchronization
    complexities.
  prefs: []
  type: TYPE_NORMAL
- en: Some nodes might be slow, running a different operating system which could have
    bugs,
  prefs: []
  type: TYPE_NORMAL
- en: some might run faster due to better hardware, and some could be resource constrained
  prefs: []
  type: TYPE_NORMAL
- en: as mobile devices or IoT devices. With all these different types of nodes (processes,
  prefs: []
  type: TYPE_NORMAL
- en: computers) in a distributed system, it becomes challenging to build a distributed
  prefs: []
  type: TYPE_NORMAL
- en: algorithm that works correctly on all these different types of systems and continues
    to
  prefs: []
  type: TYPE_NORMAL
- en: operate correctly despite the differences in the local operating environment
    of the nodes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Distribution Transparency**'
  prefs: []
  type: TYPE_NORMAL
- en: One of the goals of a distributed system is to achieve transparency. It means
    that the
  prefs: []
  type: TYPE_NORMAL
- en: distributed system, no matter how many individual computers and peripherals
    it is
  prefs: []
  type: TYPE_NORMAL
- en: built of, it should appear as a single coherent system to the end user. For
    example,
  prefs: []
  type: TYPE_NORMAL
- en: an ecommerce website may have many database servers, firewalls, web servers,
    load
  prefs: []
  type: TYPE_NORMAL
- en: balancers, and many other elements in their distributed system, but all that
    should be
  prefs: []
  type: TYPE_NORMAL
- en: abstracted away from the end user. The end user is not necessarily concerned
    about
  prefs: []
  type: TYPE_NORMAL
- en: these backend "irrelevant" details but only that when they make a request, the
    system responds. In summary, the distributed system is coherent if it behaves
    in accordance
  prefs: []
  type: TYPE_NORMAL
- en: with the expectation of the end user, despite its heterogeneous and dispersed
    structure.
  prefs: []
  type: TYPE_NORMAL
- en: For example, think about IPFS, a distributed file system. Even though the files
    are spread and sharded across multiple computers in the IPFS network, to the end
    user all that
  prefs: []
  type: TYPE_NORMAL
- en: detail is transparent, and the end user operates on it almost as if they are
    using a local file system. Similar observation can be made about other systems
    such as online email
  prefs: []
  type: TYPE_NORMAL
- en: platforms and cloud storage services.
  prefs: []
  type: TYPE_NORMAL
- en: '8'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 1 IntroduCtIon
  prefs: []
  type: TYPE_NORMAL
- en: '**Timing and Synchronization**'
  prefs: []
  type: TYPE_NORMAL
- en: Synchronization is a vital operation of a distributed system to ensure a stable
    global
  prefs: []
  type: TYPE_NORMAL
- en: state. As each process has its view of time depending on their internal physical
    clocks
  prefs: []
  type: TYPE_NORMAL
- en: which can drift apart, the time synchronization becomes one of the fundamental
    issues
  prefs: []
  type: TYPE_NORMAL
- en: to address in designing distributed systems. We will see some more details around
    this
  prefs: []
  type: TYPE_NORMAL
- en: interesting problem and will explore some solutions in our section on **timing,
    orders,**
  prefs: []
  type: TYPE_NORMAL
- en: '**and clocks** in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Global State**'
  prefs: []
  type: TYPE_NORMAL
- en: As the processes in a distributed system only have knowledge of their local
    states, it
  prefs: []
  type: TYPE_NORMAL
- en: becomes quite a challenge to ascertain the global state of the system. There
    are several
  prefs: []
  type: TYPE_NORMAL
- en: algorithms that can be used to do that, such as the Chandy-Lamport algorithm.
    We will
  prefs: []
  type: TYPE_NORMAL
- en: briefly touch upon that shortly.
  prefs: []
  type: TYPE_NORMAL
- en: '**Concurrency**'
  prefs: []
  type: TYPE_NORMAL
- en: Concurrency means multiple processes running at the same time. There is also
    a
  prefs: []
  type: TYPE_NORMAL
- en: distinction made between logical and physical concurrency. Logical concurrency
    refers
  prefs: []
  type: TYPE_NORMAL
- en: to the situation when multiple programs are executed in an interleaving manner
    on a
  prefs: []
  type: TYPE_NORMAL
- en: single processor. Physical concurrency is where program units from the same
    program
  prefs: []
  type: TYPE_NORMAL
- en: execute at the same time on two or more processors.
  prefs: []
  type: TYPE_NORMAL
- en: Distributed systems are ubiquitous. They are in everyday use and have become
  prefs: []
  type: TYPE_NORMAL
- en: part of our daily routine as a society. Be it the Internet, the World Wide Web,
    Bitcoin,
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum, Google, Facebook, or Twitter, distributed systems are now part of
    our daily
  prefs: []
  type: TYPE_NORMAL
- en: lives. At the core of distributed systems, there are distributed algorithms
    which form the foundation of the processing being performed by the distributed
    system. Each process
  prefs: []
  type: TYPE_NORMAL
- en: runs the same copy of the algorithm that intends to solve the problem for which
    the
  prefs: []
  type: TYPE_NORMAL
- en: distributed system has been developed, hence the term distributed algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: A process can be a computer, an IoT device, or a node in a data center. We abstract
  prefs: []
  type: TYPE_NORMAL
- en: these devices and represent these as processes, whereas physically it can be
    any physical computer.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s see some of the relevant technologies and terminologies.
  prefs: []
  type: TYPE_NORMAL
- en: '9'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 1 IntroduCtIon
  prefs: []
  type: TYPE_NORMAL
- en: '**Parallel vs. Distributed vs. Concurrency**'
  prefs: []
  type: TYPE_NORMAL
- en: The key difference between a parallel system and a distributed system is that
    parallel
  prefs: []
  type: TYPE_NORMAL
- en: systems’ primary focus is on high performance, whereas distributed systems are
  prefs: []
  type: TYPE_NORMAL
- en: concerned with tolerating partial failures. Also, parallel processing systems
    have direct access to a shared memory, whereas in distributed systems all processors
    have their own
  prefs: []
  type: TYPE_NORMAL
- en: local memory.
  prefs: []
  type: TYPE_NORMAL
- en: A comparison is shown in Ta[ble 1-1\.](#p29)
  prefs: []
  type: TYPE_NORMAL
- en: '***Table 1-1\.** Parallel vs. distributed systems*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Resource/**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Parallel**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Distributed**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Property**'
  prefs: []
  type: TYPE_NORMAL
- en: Memory
  prefs: []
  type: TYPE_NORMAL
- en: Shared memory, a common address
  prefs: []
  type: TYPE_NORMAL
- en: each processor has its own
  prefs: []
  type: TYPE_NORMAL
- en: space
  prefs: []
  type: TYPE_NORMAL
- en: memory
  prefs: []
  type: TYPE_NORMAL
- en: Coupling
  prefs: []
  type: TYPE_NORMAL
- en: tightly coupled
  prefs: []
  type: TYPE_NORMAL
- en: Loosely coupled
  prefs: []
  type: TYPE_NORMAL
- en: Synchronization
  prefs: []
  type: TYPE_NORMAL
- en: through a global shared clock
  prefs: []
  type: TYPE_NORMAL
- en: through synchronization algorithms
  prefs: []
  type: TYPE_NORMAL
- en: Goal
  prefs: []
  type: TYPE_NORMAL
- en: high performance
  prefs: []
  type: TYPE_NORMAL
- en: Scalability
  prefs: []
  type: TYPE_NORMAL
- en: algorithms
  prefs: []
  type: TYPE_NORMAL
- en: Concurrent
  prefs: []
  type: TYPE_NORMAL
- en: distributed
  prefs: []
  type: TYPE_NORMAL
- en: Messaging
  prefs: []
  type: TYPE_NORMAL
- en: no network, shared memory
  prefs: []
  type: TYPE_NORMAL
- en: Message-passing network
  prefs: []
  type: TYPE_NORMAL
- en: There are some overlapping ideas in the distributed computing, and sometimes
    it
  prefs: []
  type: TYPE_NORMAL
- en: becomes a bit difficult for beginners to understand. In the next section, I
    will try to clarify some of the pertinent terminology and some ambiguities.
  prefs: []
  type: TYPE_NORMAL
- en: '**Centralized vs. Decentralized vs. Distributed**'
  prefs: []
  type: TYPE_NORMAL
- en: A centralized system is a typical distributed system where clients connect to
    a central
  prefs: []
  type: TYPE_NORMAL
- en: server or a service provider. There is usually an administrator in control of
    the entire
  prefs: []
  type: TYPE_NORMAL
- en: system. A typical example is the standard client-server architecture, where
    all clients
  prefs: []
  type: TYPE_NORMAL
- en: send requests to a central server and receive responses. These systems are usually
    easier to develop and maintain. However, they are not fault tolerant (in the stricter
    sense of
  prefs: []
  type: TYPE_NORMAL
- en: client-server where there is only one central server); if the central server
    fails, the clients cannot connect and make requests.
  prefs: []
  type: TYPE_NORMAL
- en: '10'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-30_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 1 IntroduCtIon
  prefs: []
  type: TYPE_NORMAL
- en: A decentralized system is where there is no central owner of the system. Instead,
  prefs: []
  type: TYPE_NORMAL
- en: there can be multiple owners in different locations who oversee different parts
    of the
  prefs: []
  type: TYPE_NORMAL
- en: system, or there is no controller as in blockchain systems.
  prefs: []
  type: TYPE_NORMAL
- en: A distributed system compared to a centralized and decentralized system can
    be
  prefs: []
  type: TYPE_NORMAL
- en: thought of as a system where there may or may not be a central controller in
    the system;
  prefs: []
  type: TYPE_NORMAL
- en: however, the resources and nodes are distributed.
  prefs: []
  type: TYPE_NORMAL
- en: Figur[e 1-2 sho](#p30)ws a depiction of three types of systems.
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 1-2\.** Centralized vs. decentralized vs. distributed*'
  prefs: []
  type: TYPE_NORMAL
- en: Figur[e 1-2 sho](#p30)ws the traditional view of centralized, decentralized,
    and distributed systems. However, in recent years a slightly different picture
    started to emerge which
  prefs: []
  type: TYPE_NORMAL
- en: highlights the notion of a system with a central controller and the one with
    no controller at all and where all users participate equally without any dependence
    on a trusted
  prefs: []
  type: TYPE_NORMAL
- en: third party. These new types of distributed systems are blockchains, especially
    public
  prefs: []
  type: TYPE_NORMAL
- en: blockchains, where there is no central controller, such as Bitcoin blockchain.
    We will
  prefs: []
  type: TYPE_NORMAL
- en: cover more on blockchain in Chapter [4 and then thr](https://doi.org/10.1007/978-1-4842-8179-6_4)oughout
    the book. However, let’s now look at Figure [1-3](#p31), which depicts this type
    of architecture and highlights the differences from a control point of view.
  prefs: []
  type: TYPE_NORMAL
- en: '11'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-31_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 1 IntroduCtIon
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 1-3\.** Centralized vs. distributed vs. decentralized*'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that in Figur[e 1-3 the t](#p31)opology of distributed and decentralized
    systems may be the same, but there is a central controller, depicted by a symbolic
    hand on top of the figure. However, in a decentralized system notice that there
    is no hand shown, which
  prefs: []
  type: TYPE_NORMAL
- en: depicts there is no single central controller or an authority.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have focused mainly on the architecture of distributed systems and
  prefs: []
  type: TYPE_NORMAL
- en: generally defined and explored what distributed systems are. Now let’s look
    at the
  prefs: []
  type: TYPE_NORMAL
- en: most important fundamental element of a distributed system, that is, the distributed
  prefs: []
  type: TYPE_NORMAL
- en: algorithm that enables a distributed system to do what it is supposed to do.
    It is the
  prefs: []
  type: TYPE_NORMAL
- en: algorithm that runs on each node in a distributed system to accomplish a common
  prefs: []
  type: TYPE_NORMAL
- en: goal. For example, a common goal in a cryptocurrency blockchain is to disallow
    double-
  prefs: []
  type: TYPE_NORMAL
- en: spending. The logic to handle that is part of the distributed algorithm that
    runs on
  prefs: []
  type: TYPE_NORMAL
- en: each node of the cryptocurrency blockchain, and collectively and collaboratively,
    the
  prefs: []
  type: TYPE_NORMAL
- en: blockchain (the distributed system) accomplishes this task (goal) to avoid double-
  prefs: []
  type: TYPE_NORMAL
- en: spending. Don’t worry if some of these terms don’t make sense now; they will
    become
  prefs: []
  type: TYPE_NORMAL
- en: clear in Chapter [4](https://doi.org/10.1007/978-1-4842-8179-6_4).
  prefs: []
  type: TYPE_NORMAL
- en: '**Distributed Algorithm**'
  prefs: []
  type: TYPE_NORMAL
- en: A distributed algorithm runs on multiple computers concurrently to accomplish
  prefs: []
  type: TYPE_NORMAL
- en: something in a distributed system. In a distributed system, the same algorithm
    runs on
  prefs: []
  type: TYPE_NORMAL
- en: all computers concurrently to achieve a common goal.
  prefs: []
  type: TYPE_NORMAL
- en: '12'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 1 IntroduCtIon
  prefs: []
  type: TYPE_NORMAL
- en: In contrast with a sequential algorithm where each operation in execution comes
  prefs: []
  type: TYPE_NORMAL
- en: one after another, distributed algorithms are algorithms where the operations
    are
  prefs: []
  type: TYPE_NORMAL
- en: performed concurrently. Concurrent algorithms and concurrency are quite common
  prefs: []
  type: TYPE_NORMAL
- en: in computing, for example, multiple threads running simultaneously in a processor,
  prefs: []
  type: TYPE_NORMAL
- en: multiple applications running in a computer, multicore processors in a computer,
    or
  prefs: []
  type: TYPE_NORMAL
- en: multiple processes running concurrently in a distributed system.
  prefs: []
  type: TYPE_NORMAL
- en: We can define a distributed algorithm as an algorithm that runs concurrently
    on
  prefs: []
  type: TYPE_NORMAL
- en: multiple machines.
  prefs: []
  type: TYPE_NORMAL
- en: There are several advantages of distributed algorithms, including but not limited
  prefs: []
  type: TYPE_NORMAL
- en: to better performance where some computation can be parallelized to achieve
    higher
  prefs: []
  type: TYPE_NORMAL
- en: performance as compared to sequential algorithms. In addition, distributed algorithms
  prefs: []
  type: TYPE_NORMAL
- en: allow for fault tolerance; for example, if a certain threshold (which we will
    explain in
  prefs: []
  type: TYPE_NORMAL
- en: Chapt[er 3) of no](https://doi.org/10.1007/978-1-4842-8179-6_3)des fails, the
    distributed algorithms continue to operate.
  prefs: []
  type: TYPE_NORMAL
- en: There are message-passing algorithms where processes communicate over
  prefs: []
  type: TYPE_NORMAL
- en: the network by sending and receiving messages. Another type is shared memory
  prefs: []
  type: TYPE_NORMAL
- en: distributed algorithms, where the algorithms communicate by reading and writing
    from
  prefs: []
  type: TYPE_NORMAL
- en: shared memory.
  prefs: []
  type: TYPE_NORMAL
- en: Centralized algorithms execute sequentially, whereas distributed algorithms
    execute
  prefs: []
  type: TYPE_NORMAL
- en: concurrently. Centralized algorithms are not usually characterized by failures,
    whereas
  prefs: []
  type: TYPE_NORMAL
- en: distributed algorithms are designed to tolerate various types of failures. Sequential
  prefs: []
  type: TYPE_NORMAL
- en: algorithms tend to be more intuitive as they are designed for sequential execution,
  prefs: []
  type: TYPE_NORMAL
- en: whereas distributed algorithms can be challenging to understand. This is one
    of the
  prefs: []
  type: TYPE_NORMAL
- en: reasons why the correctness proofs of centralized algorithms are comparatively
    easier to
  prefs: []
  type: TYPE_NORMAL
- en: do and, in most cases, even apparent by observation. This is not the case in
    distributed
  prefs: []
  type: TYPE_NORMAL
- en: algorithms, where correctness can be deceiving. A seemingly correct algorithm
    may not
  prefs: []
  type: TYPE_NORMAL
- en: behave correctly in practice and could be subject to various failures and violations
    of
  prefs: []
  type: TYPE_NORMAL
- en: properties. For this purpose, several formal specifications and verification
    techniques
  prefs: []
  type: TYPE_NORMAL
- en: are used to ascertain the correctness of distributed algorithms. We will cover
    some
  prefs: []
  type: TYPE_NORMAL
- en: of these methods in Chapter [9\. Dis](https://doi.org/10.1007/978-1-4842-8179-6_9)tributed
    algorithms tend to be more challenging to design, debug, and implement as compared
    to sequential algorithms. Moreover,
  prefs: []
  type: TYPE_NORMAL
- en: from a complexity measure point of view, it’s generally the measure of the number
  prefs: []
  type: TYPE_NORMAL
- en: of instructions in a sequential centralized algorithm; however, the complexity
    of
  prefs: []
  type: TYPE_NORMAL
- en: distributed algorithms is measured in the number of messages.
  prefs: []
  type: TYPE_NORMAL
- en: '13'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-33_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 1 IntroduCtIon
  prefs: []
  type: TYPE_NORMAL
- en: '**Elements of Distributed Computing/Pertinent Terms/**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Concepts**'
  prefs: []
  type: TYPE_NORMAL
- en: A distributed system is composed of several elements. We are only interested
    in an
  prefs: []
  type: TYPE_NORMAL
- en: abstracted view of the system instead of specific hardware or network details.
    The
  prefs: []
  type: TYPE_NORMAL
- en: abstracted view allows designers to design and reason about the system under
    some
  prefs: []
  type: TYPE_NORMAL
- en: assumptions by building a system model. More on that later but let’s first look
    at the
  prefs: []
  type: TYPE_NORMAL
- en: basic elements in a distributed system.
  prefs: []
  type: TYPE_NORMAL
- en: A distributed system can be presented as a graph where nodes or processes are
  prefs: []
  type: TYPE_NORMAL
- en: depicted by vertices and communication links are depicted by edges. Some common
  prefs: []
  type: TYPE_NORMAL
- en: topologies are shown in Figur[e 1-4\.](#p33)
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 1-4\.** Distributed system topologies depicted as graphs*'
  prefs: []
  type: TYPE_NORMAL
- en: A distributed system is usually represented as a graph composed of nodes and
  prefs: []
  type: TYPE_NORMAL
- en: vertices. Nodes represent processes in the network, whereas vertices represent
  prefs: []
  type: TYPE_NORMAL
- en: communication links between the processes. These graphs also show the structural
    view
  prefs: []
  type: TYPE_NORMAL
- en: or topology of the network and help to visualize the system.
  prefs: []
  type: TYPE_NORMAL
- en: A distributed system can have different topologies (structures) and can be presented
  prefs: []
  type: TYPE_NORMAL
- en: as graphs. Common topologies include **ring** which depicts a topology where
    each node has two adjacent nodes. A **tree** structure is acyclic and connected.
    **Clique** is a fully connected graph where all processes are connected to each
    other directly.
  prefs: []
  type: TYPE_NORMAL
- en: Other elements
  prefs: []
  type: TYPE_NORMAL
- en: • Processes
  prefs: []
  type: TYPE_NORMAL
- en: '14'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 1 IntroduCtIon
  prefs: []
  type: TYPE_NORMAL
- en: • Events
  prefs: []
  type: TYPE_NORMAL
- en: • Executions
  prefs: []
  type: TYPE_NORMAL
- en: • Links
  prefs: []
  type: TYPE_NORMAL
- en: • State
  prefs: []
  type: TYPE_NORMAL
- en: • Global state
  prefs: []
  type: TYPE_NORMAL
- en: • Cuts
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at them in detail now.
  prefs: []
  type: TYPE_NORMAL
- en: '**Processes**'
  prefs: []
  type: TYPE_NORMAL
- en: A process in a distributed system is a computer that executes the distributed
    algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: It is also called a node. It is an autonomous computer that can fail independently
    and
  prefs: []
  type: TYPE_NORMAL
- en: can communicate with other nodes in the distributed network by sending and receiving
  prefs: []
  type: TYPE_NORMAL
- en: messages.
  prefs: []
  type: TYPE_NORMAL
- en: '**Events**'
  prefs: []
  type: TYPE_NORMAL
- en: An event can be defined as some operation occurring in a process. There can
    occur three
  prefs: []
  type: TYPE_NORMAL
- en: 'types of events in a process:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Internal events** occur when something happens locally in a'
  prefs: []
  type: TYPE_NORMAL
- en: process. In other words, a local computation performed by a
  prefs: []
  type: TYPE_NORMAL
- en: process is an internal event.
  prefs: []
  type: TYPE_NORMAL
- en: '**Message send** events occur when a process (node) sends a'
  prefs: []
  type: TYPE_NORMAL
- en: message out to other nodes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Message receive** events occur when a process (node) receives a'
  prefs: []
  type: TYPE_NORMAL
- en: message.
  prefs: []
  type: TYPE_NORMAL
- en: The diagram shown in Figur[e 1-5](#p35) presents this visually.
  prefs: []
  type: TYPE_NORMAL
- en: '15'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-35_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 1 IntroduCtIon
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 1-5\.** Events and processes in a three-node distributed system*'
  prefs: []
  type: TYPE_NORMAL
- en: '**State**'
  prefs: []
  type: TYPE_NORMAL
- en: The concept of state is critical in distributed systems. You will come across
    this term
  prefs: []
  type: TYPE_NORMAL
- en: quite a lot in this book and other texts on distributed systems, especially
    in the context of distributed consensus. Events make up the local state of a node.
    In other words, a state is composed of events (results of events) in a node. Or
    we can say that the contents of the
  prefs: []
  type: TYPE_NORMAL
- en: local memory, storage, and program as a result of events make up the process’s
    state.
  prefs: []
  type: TYPE_NORMAL
- en: '**Global State**'
  prefs: []
  type: TYPE_NORMAL
- en: The collection of states in all processes and communication links in a distributed
    system is called a **global state**.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is also known as configuration which can be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The configuration of a distributed system is composed of states of the processes
    and
  prefs: []
  type: TYPE_NORMAL
- en: messages in transit.
  prefs: []
  type: TYPE_NORMAL
- en: '**Execution**'
  prefs: []
  type: TYPE_NORMAL
- en: 'An execution in a distributed system is a run or computation of the distributed
    algorithm by a process. There are two types of executions:'
  prefs: []
  type: TYPE_NORMAL
- en: • Synchronous execution
  prefs: []
  type: TYPE_NORMAL
- en: • Asynchronous execution
  prefs: []
  type: TYPE_NORMAL
- en: '16'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-36_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 1 IntroduCtIon
  prefs: []
  type: TYPE_NORMAL
- en: '**Cuts**'
  prefs: []
  type: TYPE_NORMAL
- en: A cut can be defined as a line joining a single point in time on each process
    line in a
  prefs: []
  type: TYPE_NORMAL
- en: space-time diagram. Cuts on a space-time diagram can serve as a way of visualizing
    the
  prefs: []
  type: TYPE_NORMAL
- en: global state (at that cut) of a distributed computation. Also, it serves as
    a way to visualize what set of events occurred before and after the cut, that
    is, in the past or future. All events on the left of the cut are considered **past**,
    and all events on the right side of the cut are said to be **future**. There are
    consistent cuts and inconsistent cuts. If all received messages are sent within
    the elapsed time before the cut, that is, the past, it is called a consistent
    cut. In other words, a cut that obeys causality rules is a consistent cut. An
    inconsistent cut is where a message crosses the cut from the future (right side
    of the cut) to the past (left side of the cut).
  prefs: []
  type: TYPE_NORMAL
- en: If a cut crosses over a message from the past to the future, it is a graphical
  prefs: []
  type: TYPE_NORMAL
- en: representation of messages in transit.
  prefs: []
  type: TYPE_NORMAL
- en: The diagram shown in Figur[e 1-6](#p36) illustrates this concept, where *C*
    1 is an inconsistent cut and *C* 2 is a consistent cut.
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 1-6\.** A space-time diagram depicting cuts in a distributed system
    execution* Algorithms such as the Chandy-Lamport snapshot algorithm are used to
    create a'
  prefs: []
  type: TYPE_NORMAL
- en: consistent cut of a distributed system.
  prefs: []
  type: TYPE_NORMAL
- en: '17'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 1 IntroduCtIon
  prefs: []
  type: TYPE_NORMAL
- en: Taking a snapshot of a distributed system is helpful in creating a global picture
    of the
  prefs: []
  type: TYPE_NORMAL
- en: system. A snapshot or global snapshot captures the global state of the system
    containing
  prefs: []
  type: TYPE_NORMAL
- en: the local state of each process and the individual state of each communication
    link in the system. Such snapshots are very useful for debugging, checkpointing,
    and monitoring
  prefs: []
  type: TYPE_NORMAL
- en: purposes. A simple solution is to synchronize all clocks and create a snapshot
    at a
  prefs: []
  type: TYPE_NORMAL
- en: specific time, but accurate clock synchronization is not possible, and we can
    use
  prefs: []
  type: TYPE_NORMAL
- en: causality to achieve such an algorithm that gives us a global snapshot.
  prefs: []
  type: TYPE_NORMAL
- en: Assuming no failures, unidirectional FIFO channels, and existence of a
  prefs: []
  type: TYPE_NORMAL
- en: communication path between any two processes in the system, the Chandy-Lamport
  prefs: []
  type: TYPE_NORMAL
- en: 'algorithm works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: • An initiator process initiating the snapshot algorithm does the
  prefs: []
  type: TYPE_NORMAL
- en: 'following:'
  prefs: []
  type: TYPE_NORMAL
- en: • Records its own state
  prefs: []
  type: TYPE_NORMAL
- en: • Sends a marker message (a control message) to all processes
  prefs: []
  type: TYPE_NORMAL
- en: • Starts recording all incoming messages on its channels
  prefs: []
  type: TYPE_NORMAL
- en: '• A process receiving the marker message does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: • If it is the first time it sees this message, then it
  prefs: []
  type: TYPE_NORMAL
- en: • Records its own local state
  prefs: []
  type: TYPE_NORMAL
- en: • Marks the channel as empty
  prefs: []
  type: TYPE_NORMAL
- en: • Sends out a marker to all processes on its channels
  prefs: []
  type: TYPE_NORMAL
- en: • Starts recording all incoming channels, except the one it had
  prefs: []
  type: TYPE_NORMAL
- en: marked empty previously
  prefs: []
  type: TYPE_NORMAL
- en: • If not the first time
  prefs: []
  type: TYPE_NORMAL
- en: • Stops recording
  prefs: []
  type: TYPE_NORMAL
- en: • A snapshot is considered complete, and algorithm terminates, when
  prefs: []
  type: TYPE_NORMAL
- en: each process has received the marker on all its incoming channels.
  prefs: []
  type: TYPE_NORMAL
- en: • The initiator process is now able to build a complete snapshot
  prefs: []
  type: TYPE_NORMAL
- en: containing the saved state of each process and all messages.
  prefs: []
  type: TYPE_NORMAL
- en: '18'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 1 IntroduCtIon
  prefs: []
  type: TYPE_NORMAL
- en: Note that any process can initiate the snapshot, the algorithm does not interfere
    with
  prefs: []
  type: TYPE_NORMAL
- en: the normal operation of the distributed system, and each process records the
    state of
  prefs: []
  type: TYPE_NORMAL
- en: incoming channels and its own.
  prefs: []
  type: TYPE_NORMAL
- en: '**Types of Distributed Systems**'
  prefs: []
  type: TYPE_NORMAL
- en: There are two types of distributed systems from the communication point of view.
  prefs: []
  type: TYPE_NORMAL
- en: Shared memory systems are those where all nodes have direct access to the shared
  prefs: []
  type: TYPE_NORMAL
- en: memory. On the other hand, message-passing systems are those where nodes
  prefs: []
  type: TYPE_NORMAL
- en: communicate with each other via passing messages. In other words, nodes send
    and
  prefs: []
  type: TYPE_NORMAL
- en: receive messages using communication links to communicate with each other.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s discuss some software architecture models of distributed systems.
  prefs: []
  type: TYPE_NORMAL
- en: Software architecture models describe the design and structure of the system.
    Software
  prefs: []
  type: TYPE_NORMAL
- en: architecture answers questions such as what elements are involved and how they
  prefs: []
  type: TYPE_NORMAL
- en: interact with each other. The central focus of the distributed system software
    architecture is processes, and all other elements are built around them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Software Architecture Models**'
  prefs: []
  type: TYPE_NORMAL
- en: There are four main software architecture types which include the client-server
    model,
  prefs: []
  type: TYPE_NORMAL
- en: multiple server model, proxy server model, and peer-to-peer model.
  prefs: []
  type: TYPE_NORMAL
- en: '**Client-Server**'
  prefs: []
  type: TYPE_NORMAL
- en: This model is a common way to have two processes work together. A process assumes
  prefs: []
  type: TYPE_NORMAL
- en: the role of a client, and the other process assumes the role of a server. The
    server receives requests made by the client and responds with a reply. There can
    be multiple client
  prefs: []
  type: TYPE_NORMAL
- en: processes but only a single server process. For example, a classic web client
    and web
  prefs: []
  type: TYPE_NORMAL
- en: server (browser to a web server) design follows this type of architecture. Figur[e
    1-7](#p39)
  prefs: []
  type: TYPE_NORMAL
- en: depicts the so-called physical view of this type of architecture.
  prefs: []
  type: TYPE_NORMAL
- en: '19'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-39_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 1 IntroduCtIon
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 1-7\.** Client-server architecture*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Multiserver**'
  prefs: []
  type: TYPE_NORMAL
- en: A multiserver architecture is where multiple servers work together. In one style
    of
  prefs: []
  type: TYPE_NORMAL
- en: architecture, the server in the client-server model can itself become a client
    of another server. For example, if I have made a request from my web browser to
    a web server to
  prefs: []
  type: TYPE_NORMAL
- en: find prices of different stocks, it is possible that the web server now makes
    a request to the backend database server or, via a web service, requests this
    pricing information from some other server. In this scenario, the web server itself
    has become a client. This type of architecture can be seen as a multiserver architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Another quite common scenario is where multiple servers act together to provide
    a
  prefs: []
  type: TYPE_NORMAL
- en: service to a client, for example, multiple database servers providing data to
    a web server.
  prefs: []
  type: TYPE_NORMAL
- en: There are two usual methods to implement such collaborative architecture. The
    first is
  prefs: []
  type: TYPE_NORMAL
- en: '**data partitioning**, and another is **data replication**. Another closely
    related term to data partitioning is **data sharding**.'
  prefs: []
  type: TYPE_NORMAL
- en: Data partition refers to an architecture where data is distributed among the
    nodes
  prefs: []
  type: TYPE_NORMAL
- en: in a distributed system, and each node becomes responsible for its partition
    (section) of the data. Partitioning of data helps to achieve better performance,
    easier administration, load balancing, and better availability. For example, data
    for each department of a
  prefs: []
  type: TYPE_NORMAL
- en: company can be divided into partitions and stored separately on different local
    servers.
  prefs: []
  type: TYPE_NORMAL
- en: Another way of looking at it is that if we have a large table with one million
    rows, I might put half a million rows on one server and another half on another
    server. This scheme is
  prefs: []
  type: TYPE_NORMAL
- en: '20'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-40_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 1 IntroduCtIon
  prefs: []
  type: TYPE_NORMAL
- en: called **data sharding** or **horizontal partitioning**, or **horizontal sharding**
    depending on how the sharding is performed.
  prefs: []
  type: TYPE_NORMAL
- en: We can visualize the concept of partitioning in Figur[e 1-8\.](#p40)
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 1-8\.** Data partitioning*'
  prefs: []
  type: TYPE_NORMAL
- en: Note that data partitioning shown in Figure [1-8](#p40) is where a large central
    database is partitioned into smaller datasets relevant to each region, and a regional
    server then
  prefs: []
  type: TYPE_NORMAL
- en: manages the partition. However, in another type of partitioning, a large table
    can be
  prefs: []
  type: TYPE_NORMAL
- en: partitioned into different tables, but it remains on the same physical server.
    It is called logical partitioning.
  prefs: []
  type: TYPE_NORMAL
- en: A shard is a horizontal partition of data where each shard (fragment) resides
    on a
  prefs: []
  type: TYPE_NORMAL
- en: separate server. One immediate benefit of such an approach is load balancing
    to spread
  prefs: []
  type: TYPE_NORMAL
- en: the load between servers. This concept is shown in Figure [1-9](#p41).
  prefs: []
  type: TYPE_NORMAL
- en: '21'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-41_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 1 IntroduCtIon
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 1-9\.** Sharding*'
  prefs: []
  type: TYPE_NORMAL
- en: Data replication refers to an architecture where each node in the distributed
    system
  prefs: []
  type: TYPE_NORMAL
- en: holds an identical copy of the data. A typical simple example is that of the
    RAID 0 system; while they are not separate physical servers, the data is replicated
    across two disks,
  prefs: []
  type: TYPE_NORMAL
- en: which makes it a data replication (commonly called mirroring) architecture.
    In another
  prefs: []
  type: TYPE_NORMAL
- en: scenario, a database server might run a replication service to replicate data
    across
  prefs: []
  type: TYPE_NORMAL
- en: multiple servers. This type of architecture allows for better performance, fault
    tolerance, and higher availability. A specific type of replication and fundamental
    concept in a
  prefs: []
  type: TYPE_NORMAL
- en: distributed system is state machine replication used to build fault-tolerant
    distributed
  prefs: []
  type: TYPE_NORMAL
- en: systems. We will cover more about this in Chapt[er 3](https://doi.org/10.1007/978-1-4842-8179-6_3).
  prefs: []
  type: TYPE_NORMAL
- en: Figur[e 1-10 sho](#p42)ws multiserver architectures where a variation of the
    client-server model is shown. The server can act as a client to another server.
    This is another
  prefs: []
  type: TYPE_NORMAL
- en: approach where multiple servers work together closely to provide a service.
  prefs: []
  type: TYPE_NORMAL
- en: '22'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-42_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](index-42_2.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 1 IntroduCtIon
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 1-10\.** Multiple servers acting together (client-server and multiple
    servers* *coordinating closely/closely coupled servers)*'
  prefs: []
  type: TYPE_NORMAL
- en: Another diagram in Figure [1-11 sho](#p42)ws the concept of data replication.
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 1-11\.** Data replication*'
  prefs: []
  type: TYPE_NORMAL
- en: In summary, replication refers to a practice where a copy of the same data is
    kept on
  prefs: []
  type: TYPE_NORMAL
- en: multiple different nodes, whereas partitioning refers to a practice where data
    is split into smaller subsets, and these smaller subsets are then distributed
    across different nodes.
  prefs: []
  type: TYPE_NORMAL
- en: '23'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-43_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 1 IntroduCtIon
  prefs: []
  type: TYPE_NORMAL
- en: '**Proxy Servers**'
  prefs: []
  type: TYPE_NORMAL
- en: A proxy server–based architecture allows for intermediation between clients
    and
  prefs: []
  type: TYPE_NORMAL
- en: backend servers. A proxy server can receive the request from the clients and
    forward
  prefs: []
  type: TYPE_NORMAL
- en: it to the backend servers (most commonly, web servers). In addition, proxy servers
  prefs: []
  type: TYPE_NORMAL
- en: can interpret client requests and forward them to the servers after processing
    them.
  prefs: []
  type: TYPE_NORMAL
- en: This processing can include applying some rules to the request, perhaps anonymizing
  prefs: []
  type: TYPE_NORMAL
- en: the request by removing the client’s IP address. From a client’s perspective,
    using
  prefs: []
  type: TYPE_NORMAL
- en: proxy servers can improve performance by caching. These servers are usually
    used in
  prefs: []
  type: TYPE_NORMAL
- en: enterprise settings where corporate policies and security measures are applied
    to all
  prefs: []
  type: TYPE_NORMAL
- en: web traffic going in or out of the organization. For example, if some websites
    need to
  prefs: []
  type: TYPE_NORMAL
- en: be blocked, administrators can use a proxy server to do just that where all
    requests go
  prefs: []
  type: TYPE_NORMAL
- en: through the proxy server, and any requests for blocked sites are intercepted,
    logged, and ignored.
  prefs: []
  type: TYPE_NORMAL
- en: The diagram in Figur[e 1-12](#p43) shows a proxy architecture.
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 1-12\.** Proxy architecture – one proxy between servers and clients*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Peer to Peer**'
  prefs: []
  type: TYPE_NORMAL
- en: In the peer-to-peer architecture, the nodes do not have specific client or server
    roles.
  prefs: []
  type: TYPE_NORMAL
- en: They have equal roles. There is no single client or a server. Instead, each
    node can play either a client or a server role, depending on the situation. The
    fact that all nodes have an equal role resulted in the term "peer."
  prefs: []
  type: TYPE_NORMAL
- en: Peer-to-peer architecture is shown in the diagram in Figure [1-13\.](#p44)
  prefs: []
  type: TYPE_NORMAL
- en: '24'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-44_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 1 IntroduCtIon
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 1-13\.** Peer-to-peer architecture*'
  prefs: []
  type: TYPE_NORMAL
- en: In some scenarios, it is also possible that not all nodes have equal roles;
    some may
  prefs: []
  type: TYPE_NORMAL
- en: act as servers and clients to each other. Generally, however, all nodes have
    the same role in a peer-to-peer network.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have covered some architectural styles of distributed systems, let’s
    focus
  prefs: []
  type: TYPE_NORMAL
- en: on a more theoretical side of the distributed system, which focuses on the abstract
    view
  prefs: []
  type: TYPE_NORMAL
- en: of the distributed systems. First, we explore the distributed system model.
  prefs: []
  type: TYPE_NORMAL
- en: '**Distributed System Model**'
  prefs: []
  type: TYPE_NORMAL
- en: A system model allows us to see a distributed system abstractly. It captures
    the
  prefs: []
  type: TYPE_NORMAL
- en: assumptions about the behavior of the distributed system. It will enable us
    to define
  prefs: []
  type: TYPE_NORMAL
- en: some properties we expect from our distributed system and then reason about
    them. All
  prefs: []
  type: TYPE_NORMAL
- en: of this is at an abstract level without worrying about any technology or implementation
  prefs: []
  type: TYPE_NORMAL
- en: details. For example, a communication link abstraction only captures the fact
    that a
  prefs: []
  type: TYPE_NORMAL
- en: channel allows messages to be communicated/exchanged between processes without
  prefs: []
  type: TYPE_NORMAL
- en: specifying what it is. From an implementation point of view, it could be a fiber
    optic
  prefs: []
  type: TYPE_NORMAL
- en: cable or a wire.
  prefs: []
  type: TYPE_NORMAL
- en: We are not concerned with the specifics of the implementation of hardware
  prefs: []
  type: TYPE_NORMAL
- en: technology in a distributed system model. For example, a process is a node that
    performs
  prefs: []
  type: TYPE_NORMAL
- en: some events, and we do not concern ourselves with worrying about the exact hardware
  prefs: []
  type: TYPE_NORMAL
- en: or computer type.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we are interested in the abstracted view of the system rather
    than
  prefs: []
  type: TYPE_NORMAL
- en: physical infrastructure. Figur[e 1-14](#p45) demonstrates this concept.
  prefs: []
  type: TYPE_NORMAL
- en: '25'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-45_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 1 IntroduCtIon
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 1-14\.** Physical architecture (left) vs. abstract system model (right)*'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s see what the three fundamental abstractions in a distributed system
    are.
  prefs: []
  type: TYPE_NORMAL
- en: Failures characterize all these abstractions. We capture our assumption about
    what fault
  prefs: []
  type: TYPE_NORMAL
- en: might occur in our system. For example, processes or nodes can crash or act
    maliciously
  prefs: []
  type: TYPE_NORMAL
- en: in a distributed system. A network can drop messages, or messages can be delayed.
  prefs: []
  type: TYPE_NORMAL
- en: Message delays are captured using timing assumptions.
  prefs: []
  type: TYPE_NORMAL
- en: So, in summary, when a distributed system model is created, we make some
  prefs: []
  type: TYPE_NORMAL
- en: assumptions about the behavior of the system. This process includes timing assumptions
  prefs: []
  type: TYPE_NORMAL
- en: regarding processes and the network. We also make failure assumptions regarding
    the
  prefs: []
  type: TYPE_NORMAL
- en: network and the processors, for example, how a process can fail and whether
    it can
  prefs: []
  type: TYPE_NORMAL
- en: exhibit arbitrary failures, how an adversary can affect the processors or the
    network, and whether processes can crash or recover after a crash. Is it possible
    that the network links drop messages? In the next section, we discuss all these
    scenarios in detail.
  prefs: []
  type: TYPE_NORMAL
- en: '**Processes**'
  prefs: []
  type: TYPE_NORMAL
- en: A process or node is a fundamental element in a distributed system which runs
    the
  prefs: []
  type: TYPE_NORMAL
- en: distributed algorithm to achieve that common goal for which the distributed
    system has
  prefs: []
  type: TYPE_NORMAL
- en: been designed.
  prefs: []
  type: TYPE_NORMAL
- en: Now imagine what a process can do in a distributed system. First, let’s think
    about a
  prefs: []
  type: TYPE_NORMAL
- en: normal scenario. If a process is behaving according to the algorithm without
    any failures, then it is called a correct process or honest process. So, in our
    model we say that a node running correctly is one of the behaviors a node can
    exhibit. What else? Yes, of course, it can fail. If a node fails, we say it’s
    faulty; if not, then it is nonfaulty or correct or honest.
  prefs: []
  type: TYPE_NORMAL
- en: '26'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 1 IntroduCtIon
  prefs: []
  type: TYPE_NORMAL
- en: There are different types of failures that can occur in a process, such as
  prefs: []
  type: TYPE_NORMAL
- en: • Crash-stop
  prefs: []
  type: TYPE_NORMAL
- en: • Omission
  prefs: []
  type: TYPE_NORMAL
- en: • Crash with recovery
  prefs: []
  type: TYPE_NORMAL
- en: • Eavesdropping
  prefs: []
  type: TYPE_NORMAL
- en: • Arbitrary
  prefs: []
  type: TYPE_NORMAL
- en: '**Crash-Stop Failure**'
  prefs: []
  type: TYPE_NORMAL
- en: Crash-stop faults are where a process crashes and never recovers. This model
    of faults
  prefs: []
  type: TYPE_NORMAL
- en: or node behavior captures an irreparable hardware fault, for example, short
    circuit in a
  prefs: []
  type: TYPE_NORMAL
- en: motherboard causing failure.
  prefs: []
  type: TYPE_NORMAL
- en: '**Omission Failure**'
  prefs: []
  type: TYPE_NORMAL
- en: Omission failures capture the fault scenarios where a processor fails to send
    a message
  prefs: []
  type: TYPE_NORMAL
- en: 'or receive a message. Omission failures are divided into three categories:
    send'
  prefs: []
  type: TYPE_NORMAL
- en: omissions, receive omissions, and general omissions. Send omissions are where
    a
  prefs: []
  type: TYPE_NORMAL
- en: processor doesn’t send a message out which it was supposed to as per the distributed
  prefs: []
  type: TYPE_NORMAL
- en: algorithm; receive omissions occur when a process does not receive an expected
  prefs: []
  type: TYPE_NORMAL
- en: message. In practical terms, these omissions arise due to physical faults, memory
    issues, buffer overflows, malicious actions, and network congestions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Crash with Recovery**'
  prefs: []
  type: TYPE_NORMAL
- en: A process exhibiting crash with recovery behavior can recover after a crash.
    It captures
  prefs: []
  type: TYPE_NORMAL
- en: a scenario where a process crashes, loses its in-memory state, but recovers
    and resumes
  prefs: []
  type: TYPE_NORMAL
- en: its operation later. This occurrence can be seen as an omission fault too, where
    now the
  prefs: []
  type: TYPE_NORMAL
- en: node will not send or receive any messages because it has crashed. In practical
    terms, it can be a temporary intentional restart of a process or reboot after
    some operating system errors. Some examples include resumption of the normal operation
    after rebooting due
  prefs: []
  type: TYPE_NORMAL
- en: to a blue screen in Windows or kernel panic in Linux.
  prefs: []
  type: TYPE_NORMAL
- en: When a process crashes, it may lose its internal state (called amnesia), making
    a
  prefs: []
  type: TYPE_NORMAL
- en: recovery tricky. However, we can alleviate this problem by keeping stable storage
    (a log) which can help to resume operations from the last known good state. A
    node may also
  prefs: []
  type: TYPE_NORMAL
- en: '27'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 1 IntroduCtIon
  prefs: []
  type: TYPE_NORMAL
- en: lose all its state after recovery and must resynchronize with the rest of the
    network. It may also happen that a node is down for a long time and has desynchronized
    with the
  prefs: []
  type: TYPE_NORMAL
- en: rest of the network (other nodes) and has its old view of the state. In that
    case, the node must resynchronize with the network. This situation is especially
    true in blockchain
  prefs: []
  type: TYPE_NORMAL
- en: networks such as Bitcoin or Ethereum, where a node might be off the network
    for quite
  prefs: []
  type: TYPE_NORMAL
- en: some time. When it comes back online, it synchronizes again with the rest of
    the nodes
  prefs: []
  type: TYPE_NORMAL
- en: to resume its full normal operation.
  prefs: []
  type: TYPE_NORMAL
- en: '**Eavesdropping**'
  prefs: []
  type: TYPE_NORMAL
- en: In this model, a distributed algorithm may leak confidential information, and
    an
  prefs: []
  type: TYPE_NORMAL
- en: adversary can eavesdrop to learn some information from the processes. This model
  prefs: []
  type: TYPE_NORMAL
- en: is especially true in untrusted and geographically dispersed environments such
    as
  prefs: []
  type: TYPE_NORMAL
- en: a blockchain. The usual defense against these attacks is encryption which provides
  prefs: []
  type: TYPE_NORMAL
- en: confidentiality by encrypting the messages.
  prefs: []
  type: TYPE_NORMAL
- en: '**Arbitrary (Byzantine)**'
  prefs: []
  type: TYPE_NORMAL
- en: A Byzantine process can exhibit any arbitrary behavior. It can deviate from
    the
  prefs: []
  type: TYPE_NORMAL
- en: algorithm in any possible way. It can be malicious, and it can actively try
    to sabotage
  prefs: []
  type: TYPE_NORMAL
- en: the distributed algorithm, selectively omit some messages, or covertly try to
    undermine
  prefs: []
  type: TYPE_NORMAL
- en: the distributed algorithm. This type of fault is the most complex and challenging
    in
  prefs: []
  type: TYPE_NORMAL
- en: a distributed algorithm or system. In practical terms, it could be a hacker
    coming up
  prefs: []
  type: TYPE_NORMAL
- en: with novel ways to attack the system, a virus or worm on the network, or some
    other
  prefs: []
  type: TYPE_NORMAL
- en: unprecedented attack. There is no restriction on the behavior of a Byzantine
    faulty node; it can do anything.
  prefs: []
  type: TYPE_NORMAL
- en: A relevant concept is that of the adversary model, where the adversary behavior
    is
  prefs: []
  type: TYPE_NORMAL
- en: modelled. We will cover this later in the section “Adversary Model”.
  prefs: []
  type: TYPE_NORMAL
- en: Now we look at another aspect of the distributed system model, network.
  prefs: []
  type: TYPE_NORMAL
- en: '**Network**'
  prefs: []
  type: TYPE_NORMAL
- en: In a distributed network, links (communication links) are responsible for passing
  prefs: []
  type: TYPE_NORMAL
- en: messages, that is, take messages from nodes and send to others. Usually, the
    assumption
  prefs: []
  type: TYPE_NORMAL
- en: is a bidirectional point-to-point connection between nodes.
  prefs: []
  type: TYPE_NORMAL
- en: A network partition is a scenario where the network link becomes unavailable
    for
  prefs: []
  type: TYPE_NORMAL
- en: some finite time between two groups of nodes. In practice, this could be due
    to a data
  prefs: []
  type: TYPE_NORMAL
- en: '28'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 1 IntroduCtIon
  prefs: []
  type: TYPE_NORMAL
- en: center not speaking to another or an incorrect/unintentional or even intentional/
  prefs: []
  type: TYPE_NORMAL
- en: malicious firewall rule prohibiting connections from one part of the network
    to another.
  prefs: []
  type: TYPE_NORMAL
- en: '**Link Failures**'
  prefs: []
  type: TYPE_NORMAL
- en: Links can experience crash failure where a correctly functioning link may stop
    carrying
  prefs: []
  type: TYPE_NORMAL
- en: messages. Another type of link failure is omission failure, where a link carries
    some
  prefs: []
  type: TYPE_NORMAL
- en: messages, and some don’t. Finally, Byzantine failures or arbitrary failures
    can occur on
  prefs: []
  type: TYPE_NORMAL
- en: links where the link can create rogue messages and modify messages and selectively
  prefs: []
  type: TYPE_NORMAL
- en: deliver some messages, and some don’t.
  prefs: []
  type: TYPE_NORMAL
- en: With this model, we can divide the communication links into different types
  prefs: []
  type: TYPE_NORMAL
- en: depending on how they fail and deliver the messages.
  prefs: []
  type: TYPE_NORMAL
- en: Two types of events occur on links (channels), the **send event** where a message
    is
  prefs: []
  type: TYPE_NORMAL
- en: put on the link and the **deliver event** where the link dispenses a message,
    and a process *delivers* it.
  prefs: []
  type: TYPE_NORMAL
- en: '**Fair-Loss Links**'
  prefs: []
  type: TYPE_NORMAL
- en: In this abstraction, we capture how messages on this link can be lost, duplicated,
    or
  prefs: []
  type: TYPE_NORMAL
- en: reordered. The messages may be lost but eventually delivered if the sender and
    receiver
  prefs: []
  type: TYPE_NORMAL
- en: process is correct and the sender keeps retransmitting. More formally, the three
  prefs: []
  type: TYPE_NORMAL
- en: properties are as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '**Fair-Loss**'
  prefs: []
  type: TYPE_NORMAL
- en: This property guarantees that the link with this property does not systematically
    drop
  prefs: []
  type: TYPE_NORMAL
- en: every message, which implies that, eventually, delivery of a message to the
    destination
  prefs: []
  type: TYPE_NORMAL
- en: node will be successful even if it takes several retransmissions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Finite Duplication**'
  prefs: []
  type: TYPE_NORMAL
- en: This property ensures that the network does not perform more retransmissions
    than the
  prefs: []
  type: TYPE_NORMAL
- en: sender does.
  prefs: []
  type: TYPE_NORMAL
- en: '**No Creation**'
  prefs: []
  type: TYPE_NORMAL
- en: This property ensures that the network does not corrupt messages or create messages
  prefs: []
  type: TYPE_NORMAL
- en: out of thin air.
  prefs: []
  type: TYPE_NORMAL
- en: '29'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 1 IntroduCtIon
  prefs: []
  type: TYPE_NORMAL
- en: '**Stubborn Links**'
  prefs: []
  type: TYPE_NORMAL
- en: This abstraction captures the behavior of the link where the link delivers any
    message
  prefs: []
  type: TYPE_NORMAL
- en: sent infinitely many times. The assumption about the processes in this abstraction
    is
  prefs: []
  type: TYPE_NORMAL
- en: that both sender and receiver processes are correct. This type of link will
    stubbornly try to deliver the message without considering performance. The link
    will just keep trying
  prefs: []
  type: TYPE_NORMAL
- en: regardless until the message is delivered.
  prefs: []
  type: TYPE_NORMAL
- en: Formally, there are two properties that stubborn links have.
  prefs: []
  type: TYPE_NORMAL
- en: '**Stubborn Delivery**'
  prefs: []
  type: TYPE_NORMAL
- en: This property means that if a message m is sent from a correct process p to
    a correct
  prefs: []
  type: TYPE_NORMAL
- en: process q once, it will be delivered infinitely many times by process q, hence
    the term
  prefs: []
  type: TYPE_NORMAL
- en: '"stubborn"!'
  prefs: []
  type: TYPE_NORMAL
- en: '**No Creation**'
  prefs: []
  type: TYPE_NORMAL
- en: This means that messages are not created out of the blue, and if a message is
    delivered
  prefs: []
  type: TYPE_NORMAL
- en: by some process, then it must have been sent by a process. Formally, if a process
    q
  prefs: []
  type: TYPE_NORMAL
- en: delivers a message m sent from process p, then the message m is indeed sent
    from
  prefs: []
  type: TYPE_NORMAL
- en: process p to process q.
  prefs: []
  type: TYPE_NORMAL
- en: '**Perfect (Reliable) Links**'
  prefs: []
  type: TYPE_NORMAL
- en: This is the most common type of link. In this link, if a process has sent a
    message, then it will eventually be delivered.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, TCP is a reliable link. There are three properties.
  prefs: []
  type: TYPE_NORMAL
- en: '**Reliable Delivery**'
  prefs: []
  type: TYPE_NORMAL
- en: If a message m is sent by a correct process p to a correct process q, then m
    is eventually delivered by q.
  prefs: []
  type: TYPE_NORMAL
- en: '**No Duplication**'
  prefs: []
  type: TYPE_NORMAL
- en: A correct process p does not deliver a message m more than once.
  prefs: []
  type: TYPE_NORMAL
- en: '30'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 1 IntroduCtIon
  prefs: []
  type: TYPE_NORMAL
- en: '**No Creation**'
  prefs: []
  type: TYPE_NORMAL
- en: This property ensures that messages are not created out of thin air, and if
    they are
  prefs: []
  type: TYPE_NORMAL
- en: delivered, they must have been created and sent by a correct process before
    delivering.
  prefs: []
  type: TYPE_NORMAL
- en: '**Logged Perfect Links**'
  prefs: []
  type: TYPE_NORMAL
- en: This type of link delivers messages into the receiver’s local message log or
    persistent
  prefs: []
  type: TYPE_NORMAL
- en: storage. This is useful in scenarios where the receiver might crash, but we
    need the
  prefs: []
  type: TYPE_NORMAL
- en: message to be safe. In this case, even if the receiver process crashes, the
    message is not lost because it persisted in the local storage.
  prefs: []
  type: TYPE_NORMAL
- en: '**Authenticated Perfect Links**'
  prefs: []
  type: TYPE_NORMAL
- en: This link guarantees that a message m sent from a process p to process q is
    indeed sent
  prefs: []
  type: TYPE_NORMAL
- en: from process p.
  prefs: []
  type: TYPE_NORMAL
- en: '**Arbitrary Links**'
  prefs: []
  type: TYPE_NORMAL
- en: In this abstraction, the link can exhibit any behavior. Here, we consider an
    active
  prefs: []
  type: TYPE_NORMAL
- en: adversary who has the power to control the messages. This link depicts scenarios
    where
  prefs: []
  type: TYPE_NORMAL
- en: an attacker can do malicious actions, modify the messages, replay them, or spoof
    them.
  prefs: []
  type: TYPE_NORMAL
- en: In short, on this link, any attack is possible.
  prefs: []
  type: TYPE_NORMAL
- en: In practical terms, this depicts a typical Internet connection where a hacker
    can
  prefs: []
  type: TYPE_NORMAL
- en: eavesdrop, modify, spoof, or replay the messages. But, of course, this could
    also be due
  prefs: []
  type: TYPE_NORMAL
- en: to Internet worms, traffic analyzers, and viruses.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note** here, we are talking about point-to-point links only; we will introduce'
  prefs: []
  type: TYPE_NORMAL
- en: broadcast later in Cha[pter 3\.](https://doi.org/10.1007/978-1-4842-8179-6_3)
  prefs: []
  type: TYPE_NORMAL
- en: '**Synchrony and Timing**'
  prefs: []
  type: TYPE_NORMAL
- en: In distributed systems, delays and speed assumptions capture the behavior of
    the
  prefs: []
  type: TYPE_NORMAL
- en: network.
  prefs: []
  type: TYPE_NORMAL
- en: In practical terms, delays are almost inevitable in a distributed system, first
  prefs: []
  type: TYPE_NORMAL
- en: because of inherent asynchrony, dispersion, and heterogeneity and specific causes
  prefs: []
  type: TYPE_NORMAL
- en: '31'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 1 IntroduCtIon
  prefs: []
  type: TYPE_NORMAL
- en: such as message loss, slow processors, and congestion on the network. Due to
    network
  prefs: []
  type: TYPE_NORMAL
- en: configuration changes, it may also happen that unexpected or new delays are
    introduced
  prefs: []
  type: TYPE_NORMAL
- en: in the distributed system.
  prefs: []
  type: TYPE_NORMAL
- en: Synchrony assumption in a distributed system is concerned with network delays
    and
  prefs: []
  type: TYPE_NORMAL
- en: processor delays incurred by slow network links or slow processor speeds.
  prefs: []
  type: TYPE_NORMAL
- en: In practical terms, processors can be slow because of memory exhaustion in the
  prefs: []
  type: TYPE_NORMAL
- en: nodes. For example, java programs can pause execution altogether during the
    "stop the world" type of garbage collection. On the other hand, some high-end
    processors are
  prefs: []
  type: TYPE_NORMAL
- en: inherently faster than low-end processors on resource-constrained devices. All
    these
  prefs: []
  type: TYPE_NORMAL
- en: differences and situations can cause delays in a distributed system.
  prefs: []
  type: TYPE_NORMAL
- en: In the following, we discuss three models of synchrony that capture the timing
  prefs: []
  type: TYPE_NORMAL
- en: assumption of distributed systems.
  prefs: []
  type: TYPE_NORMAL
- en: '**Synchronous**'
  prefs: []
  type: TYPE_NORMAL
- en: A synchronous distributed system has a known upper bound on the time it takes
    for
  prefs: []
  type: TYPE_NORMAL
- en: a message to reach a node. This situation is ideal. However, in practice, messages
    can
  prefs: []
  type: TYPE_NORMAL
- en: sometimes be delayed. Even in a perfect network, there are several factors,
    such as
  prefs: []
  type: TYPE_NORMAL
- en: network link quality, network latency, message loss, processing speed, or capacity
    of the processors, which can adversely affect the delivery of the message.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, synchronous systems exist, for example, a system on a chip (SoC),
  prefs: []
  type: TYPE_NORMAL
- en: embedded systems, etc.
  prefs: []
  type: TYPE_NORMAL
- en: '**Asynchronous**'
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous distributed systems are on the other end of the spectrum. In this
    model,
  prefs: []
  type: TYPE_NORMAL
- en: there is no timing assumption made regarding the timing. In other words, there
    is no
  prefs: []
  type: TYPE_NORMAL
- en: upper bound on the time it takes to deliver a message. There can be arbitrarily
    long and
  prefs: []
  type: TYPE_NORMAL
- en: unbounded delays in message delivery or processing in a node. The processes
    can run at
  prefs: []
  type: TYPE_NORMAL
- en: different speeds.
  prefs: []
  type: TYPE_NORMAL
- en: Also, a process can arbitrarily pause or delay the execution or can process
    faster
  prefs: []
  type: TYPE_NORMAL
- en: than other processes. You can probably imagine now that distributed algorithms
  prefs: []
  type: TYPE_NORMAL
- en: designed for such a system can be very robust and resilient. However, many problems
  prefs: []
  type: TYPE_NORMAL
- en: cannot be solved in an asynchronous distributed system. A whole class of results
    called
  prefs: []
  type: TYPE_NORMAL
- en: '"impossibility results" captures the unsolvable problems in distributed systems.
    We will look at impossibility results in more detail later in the chapter and
    then in Chapter [3\.](https://doi.org/10.1007/978-1-4842-8179-6_3)'
  prefs: []
  type: TYPE_NORMAL
- en: '32'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-52_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 1 IntroduCtIon
  prefs: []
  type: TYPE_NORMAL
- en: As several types of problems cannot be solved in an asynchronous model and the
  prefs: []
  type: TYPE_NORMAL
- en: synchronous model is too idealistic, we have to compromise. The compromise is
    called a
  prefs: []
  type: TYPE_NORMAL
- en: partially synchronous network.
  prefs: []
  type: TYPE_NORMAL
- en: '**Partially Synchronous**'
  prefs: []
  type: TYPE_NORMAL
- en: A partially synchronous model captures the assumption that the network is primarily
  prefs: []
  type: TYPE_NORMAL
- en: synchronous and well behaved, but it can sometimes behave asynchronously. For
  prefs: []
  type: TYPE_NORMAL
- en: example, processing speeds can differ, or network delays can occur, but the
    system
  prefs: []
  type: TYPE_NORMAL
- en: ultimately returns to a synchronous state to resume normal operation.
  prefs: []
  type: TYPE_NORMAL
- en: Another way to think about this is that the network usually is synchronous but
    can
  prefs: []
  type: TYPE_NORMAL
- en: unpredictably, for a bounded amount of time, behave asynchronously, but there
    are long
  prefs: []
  type: TYPE_NORMAL
- en: enough periods of synchrony where the system behaves correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Another way to think about this is that the real systems are synchronous most
    of the
  prefs: []
  type: TYPE_NORMAL
- en: time but can behave arbitrarily and unpredictably asynchronous at times. During
    the
  prefs: []
  type: TYPE_NORMAL
- en: synchronous period, the system is able to make decisions and terminate.
  prefs: []
  type: TYPE_NORMAL
- en: 'In summary, we can quote Leonardo da Vinci:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Time stays long enough for anyone who will use it.*'
  prefs: []
  type: TYPE_NORMAL
- en: Figur[e 1-15 sho](#p52)ws how a partially synchronous network behaves.
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 1-15\.** Partially synchronous network*'
  prefs: []
  type: TYPE_NORMAL
- en: '33'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-53_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 1 IntroduCtIon
  prefs: []
  type: TYPE_NORMAL
- en: '**Eventually Synchronous**'
  prefs: []
  type: TYPE_NORMAL
- en: In the eventually synchronous version of partial synchrony, the system can be
    initially
  prefs: []
  type: TYPE_NORMAL
- en: asynchronous, but there is an unknown time called global stabilization time
    (GST),
  prefs: []
  type: TYPE_NORMAL
- en: unknown to processors, after which the system eventually becomes synchronous.
    Also,
  prefs: []
  type: TYPE_NORMAL
- en: it does not mean that the system will forever remain synchronous after GST.
    That is not
  prefs: []
  type: TYPE_NORMAL
- en: possible practically, but the system is synchronous for a long enough period
    after GST to make a decision and terminate.
  prefs: []
  type: TYPE_NORMAL
- en: We can visualize the spectrum of synchrony models from asynchronous to
  prefs: []
  type: TYPE_NORMAL
- en: synchronous in Figure [1-16\.](#p53)
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 1-16\.** Synchrony models in distributed systems*'
  prefs: []
  type: TYPE_NORMAL
- en: Both message delivery delay and relative speed of the processes are taken into
  prefs: []
  type: TYPE_NORMAL
- en: consideration in synchrony models.
  prefs: []
  type: TYPE_NORMAL
- en: '**Formal Definitions**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Some formal definitions regarding the partial synchrony model are stated as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: • Delta *Δ* denotes a fixed upper bound on the time required for a
  prefs: []
  type: TYPE_NORMAL
- en: message to reach from one processor to another.
  prefs: []
  type: TYPE_NORMAL
- en: • Phi *Φ* denotes a fixed upper bound on the relative speed of different
  prefs: []
  type: TYPE_NORMAL
- en: processors.
  prefs: []
  type: TYPE_NORMAL
- en: • GST is the global stabilization time after which the system behaves
  prefs: []
  type: TYPE_NORMAL
- en: synchronously.
  prefs: []
  type: TYPE_NORMAL
- en: With these preceding variables defined, we can define various models of synchrony
  prefs: []
  type: TYPE_NORMAL
- en: 'as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: • Asynchronous systems are those where no fixed upper bounds *Δ* and
  prefs: []
  type: TYPE_NORMAL
- en: '*Φ* exist.'
  prefs: []
  type: TYPE_NORMAL
- en: '34'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-54_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 1 IntroduCtIon
  prefs: []
  type: TYPE_NORMAL
- en: • Synchronous systems are those where fixed upper bounds *Δ* and *Φ*
  prefs: []
  type: TYPE_NORMAL
- en: are known.
  prefs: []
  type: TYPE_NORMAL
- en: 'Partially synchronous systems can be defined in several ways:'
  prefs: []
  type: TYPE_NORMAL
- en: • Where fixed upper bounds *Δ* and *Φ* exist, but they are not known.
  prefs: []
  type: TYPE_NORMAL
- en: • Where fixed upper bounds *Δ* and *Φ* are known but hold after some
  prefs: []
  type: TYPE_NORMAL
- en: unknown time T. This is the eventually synchronous model. We can
  prefs: []
  type: TYPE_NORMAL
- en: say that eventually synchronous model is where fixed upper bounds
  prefs: []
  type: TYPE_NORMAL
- en: '*Δ* and *Φ* are known but only hold after some time, known as GST.'
  prefs: []
  type: TYPE_NORMAL
- en: • In another variation after GST *Δ* holds for long enough to allow the
  prefs: []
  type: TYPE_NORMAL
- en: protocol to terminate.
  prefs: []
  type: TYPE_NORMAL
- en: We will use synchrony models more formally in Chapt[er 3 in the con](https://doi.org/10.1007/978-1-4842-8179-6_3)text
    of circumventing FLP and consensus protocols. For now, as a foundation the concepts
  prefs: []
  type: TYPE_NORMAL
- en: introduced earlier are sufficient.
  prefs: []
  type: TYPE_NORMAL
- en: Figur[e 1-17 sho](#p54)ws synchronous vs. asynchronous communication using a
    space-time diagram.
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 1-17\.** Synchronous and asynchronous system*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have discussed the synchrony model, let’s now turn our attention
    to the
  prefs: []
  type: TYPE_NORMAL
- en: adversary model, which allows us to make assumptions about the effect of adversary
    on
  prefs: []
  type: TYPE_NORMAL
- en: a distributed system. In this model, we model how an adversary can behave and
    what
  prefs: []
  type: TYPE_NORMAL
- en: powers an adversary may have in order to adversely influence the distributed
    system.
  prefs: []
  type: TYPE_NORMAL
- en: '35'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 1 IntroduCtIon
  prefs: []
  type: TYPE_NORMAL
- en: '**Adversary Model**'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to assumptions about synchrony and timing in a distributed system
    model,
  prefs: []
  type: TYPE_NORMAL
- en: there is another model where assumptions about the power of the adversary and
    how
  prefs: []
  type: TYPE_NORMAL
- en: it can adversely affect the distributed system are made. This is an important
    model
  prefs: []
  type: TYPE_NORMAL
- en: which allows a distributed system designer to reason about different properties
    of the
  prefs: []
  type: TYPE_NORMAL
- en: distributed system while facing the adversary. For example, a distributed algorithm
  prefs: []
  type: TYPE_NORMAL
- en: is guaranteed to work correctly only if less than half of the nodes are controlled
    by a
  prefs: []
  type: TYPE_NORMAL
- en: malicious adversary. Therefore, adversary models are usually modelled with a
    limit to
  prefs: []
  type: TYPE_NORMAL
- en: what an adversary can do. But, if an adversary is assumed to be all-powerful
    who can do
  prefs: []
  type: TYPE_NORMAL
- en: anything and control all nodes and communication links, then there is no guarantee
    that
  prefs: []
  type: TYPE_NORMAL
- en: the system will ever work correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Adversary models can be divided into different types depending on the distributed
  prefs: []
  type: TYPE_NORMAL
- en: system and the influence they can have on the distributed system and adversely
  prefs: []
  type: TYPE_NORMAL
- en: affect them.
  prefs: []
  type: TYPE_NORMAL
- en: In this model, it is assumed there is an external entity that has corrupted
    the
  prefs: []
  type: TYPE_NORMAL
- en: processes and can control and coordinate faulty processes’ actions. This entity
    is called an adversary. Note that there is a slight difference compared to the
    failure model here
  prefs: []
  type: TYPE_NORMAL
- en: because, in the failure model, the nodes can fail for all sorts of reasons,
    but no external entity is assumed to take control of processes.
  prefs: []
  type: TYPE_NORMAL
- en: Adversaries can affect a distributed system in several ways. A system designer
  prefs: []
  type: TYPE_NORMAL
- en: using an adversary model considers factors such as the **type of corruption**,
    **time** **of corruption**, and **extent of corruption** (how many processes simultaneously).
    In addition, **computational power** available to the adversary, **visibility**,
    and **adaptability** of the adversary are also considered. The adversary model
    also allows designers to
  prefs: []
  type: TYPE_NORMAL
- en: specify to what limit the number of processes in a network can be corrupted.
  prefs: []
  type: TYPE_NORMAL
- en: We will briefly discuss these types here.
  prefs: []
  type: TYPE_NORMAL
- en: '**Threshold Adversary**'
  prefs: []
  type: TYPE_NORMAL
- en: A threshold adversary is a standard and widely used model in distributed systems.
    In this model, there is a limit imposed on the number of overall faulty processes
    in the system.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, there is a fixed upper bound f on the number of faulty processes
    in the
  prefs: []
  type: TYPE_NORMAL
- en: network. This model is also called the global adversary model. Many different
    algorithms
  prefs: []
  type: TYPE_NORMAL
- en: have been developed under this assumption. Almost all of the consensus protocols
  prefs: []
  type: TYPE_NORMAL
- en: work under at least the threshold adversary model where it is assumed that an
    adversary
  prefs: []
  type: TYPE_NORMAL
- en: '36'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 1 IntroduCtIon
  prefs: []
  type: TYPE_NORMAL
- en: can control up to f number of nodes in a network. For example, in the Paxos
    protocol
  prefs: []
  type: TYPE_NORMAL
- en: discussed in Chapt[er 7, c](https://doi.org/10.1007/978-1-4842-8179-6_7)lassical
    consensus algorithms achieve consensus under the assumption that an adversary
    can control less than half of the total number of nodes in
  prefs: []
  type: TYPE_NORMAL
- en: the network.
  prefs: []
  type: TYPE_NORMAL
- en: '**Dynamic Adversary**'
  prefs: []
  type: TYPE_NORMAL
- en: Also called adaptive adversary, in this model the adversary can corrupt processes
  prefs: []
  type: TYPE_NORMAL
- en: anytime during the execution of the protocol. Also, the faulty process then
    remains faulty until the execution ends.
  prefs: []
  type: TYPE_NORMAL
- en: '**Static Adversary**'
  prefs: []
  type: TYPE_NORMAL
- en: This type of adversary is able to perform its adversarial activities such as
    corrupting
  prefs: []
  type: TYPE_NORMAL
- en: processes only before the protocol is executed.
  prefs: []
  type: TYPE_NORMAL
- en: '**Passive Adversary**'
  prefs: []
  type: TYPE_NORMAL
- en: This type of adversary does not actively try to sabotage the system; however,
    it can learn some information about the system while running the protocol. Thus,
    it can be called a
  prefs: []
  type: TYPE_NORMAL
- en: semi-honest adversary.
  prefs: []
  type: TYPE_NORMAL
- en: 'An adversary can cause faults under two models: the crash failure model and
    the'
  prefs: []
  type: TYPE_NORMAL
- en: Byzantine failure model.
  prefs: []
  type: TYPE_NORMAL
- en: In the crash failure model, the adversary can stop a process from executing
    the
  prefs: []
  type: TYPE_NORMAL
- en: protocol it has control over anytime during the execution.
  prefs: []
  type: TYPE_NORMAL
- en: In the Byzantine failure model, the adversary has complete control over the
  prefs: []
  type: TYPE_NORMAL
- en: corrupted process and can control it to deviate arbitrarily from the protocol.
    Protocols
  prefs: []
  type: TYPE_NORMAL
- en: that work under these assumptions and tolerate such faults are called crash
    fault–
  prefs: []
  type: TYPE_NORMAL
- en: tolerant protocols (CFT) or Byzantine fault–tolerant protocols (BFT), respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '**Time, Clocks, and Order**'
  prefs: []
  type: TYPE_NORMAL
- en: Time plays a critical role in distributed systems. Almost always, there is a
    need to
  prefs: []
  type: TYPE_NORMAL
- en: measure time. For example, timestamps are required in log files in a distributed
  prefs: []
  type: TYPE_NORMAL
- en: system to show when a particular event occurred. From a security point of view,
    audit
  prefs: []
  type: TYPE_NORMAL
- en: timestamps are needed to indicate when a specific operation occurred, for example,
  prefs: []
  type: TYPE_NORMAL
- en: when a specific user logged in to the system. In operating systems, timing is
    required
  prefs: []
  type: TYPE_NORMAL
- en: '37'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-57_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](index-57_2.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 1 IntroduCtIon
  prefs: []
  type: TYPE_NORMAL
- en: for scheduling internal events. All these use cases and countless other computer
    and
  prefs: []
  type: TYPE_NORMAL
- en: distributed systems operations require some notion of time.
  prefs: []
  type: TYPE_NORMAL
- en: The notion of time in distributed systems is tricky. Events shown in Figur[e
    1-18](#p57) need to be ordered for a distributed system to be reasonably useful.
    Ordering of events in a
  prefs: []
  type: TYPE_NORMAL
- en: distributed system is one of the fundamental and critical requirements. As there
    is no
  prefs: []
  type: TYPE_NORMAL
- en: global shared clock in distributed systems, the ordering of events becomes a
    challenging
  prefs: []
  type: TYPE_NORMAL
- en: problem. To this end, the main concern here is to accomplish the correct order
    of
  prefs: []
  type: TYPE_NORMAL
- en: events in the system. We have this notion of time in our daily lives where we
    can say that something happened before something else. For example, if I sat an
    exam and the results
  prefs: []
  type: TYPE_NORMAL
- en: came out a week later, we can say confidently that the exam must have occurred
    or
  prefs: []
  type: TYPE_NORMAL
- en: happened before the results came out. We can visualize this relationship in
    the diagram
  prefs: []
  type: TYPE_NORMAL
- en: in Figure [1-19](#p57).
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 1-18\.** Events and processes in a three-node distributed system*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 1-19\.** Exam happened before the result – a happened-before relation*'
  prefs: []
  type: TYPE_NORMAL
- en: '38'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-58_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 1 IntroduCtIon
  prefs: []
  type: TYPE_NORMAL
- en: Usually, we are familiar with the physical clock, that is, our typical day-to-day
  prefs: []
  type: TYPE_NORMAL
- en: understanding and the notion of time where I can say something like I will meet
    you at 3
  prefs: []
  type: TYPE_NORMAL
- en: PM today, or the football match is at 11 AM tomorrow. This notion of time is
    what we are
  prefs: []
  type: TYPE_NORMAL
- en: familiar with. Moreover, physical clocks can be used in distributed systems,
    and several
  prefs: []
  type: TYPE_NORMAL
- en: algorithms are used to synchronize time across all nodes in a distributed system.
    These
  prefs: []
  type: TYPE_NORMAL
- en: algorithms can synchronize clocks in a distributed system using message passing.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s first have a look at the physical clocks and see some algorithms that
    can be used
  prefs: []
  type: TYPE_NORMAL
- en: for time synchronization based on internal physical clocks and external time
    source.
  prefs: []
  type: TYPE_NORMAL
- en: '**Physical Clocks**'
  prefs: []
  type: TYPE_NORMAL
- en: Physical clocks are in everyday use. Now prevalent digital clocks are based
    on quartz
  prefs: []
  type: TYPE_NORMAL
- en: crystal, whereas traditional mechanical clocks are based on spring mechanisms
    or
  prefs: []
  type: TYPE_NORMAL
- en: pendulums. Digital clocks, from wristwatches to clocks on a computer motherboard,
  prefs: []
  type: TYPE_NORMAL
- en: make use of quartz crystals. In practice, an oscillator circuit regulated by
    a quartz crystal is used to generate an accurate frequency. When the electric
    field is applied to a quartz crystal, it bends and starts to resonate at a frequency
    depending upon its size, cut,
  prefs: []
  type: TYPE_NORMAL
- en: temperature, and housing. The most common frequency is 32768 Hz which is almost
  prefs: []
  type: TYPE_NORMAL
- en: universally used in quartz-based clocks. Figur[e 1-20](#p58) shows, from left
    to right, a quartz crystal in a natural form, in a component form, and inside
    a casing with additional
  prefs: []
  type: TYPE_NORMAL
- en: oscillator circuitry.
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 1-20\.** A quartz crystal in a natural form (left), in a component
    form*'
  prefs: []
  type: TYPE_NORMAL
- en: '*(middle), and in a circuit (right)*'
  prefs: []
  type: TYPE_NORMAL
- en: '39'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-59_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 1 IntroduCtIon
  prefs: []
  type: TYPE_NORMAL
- en: Quartz-based clocks are usually accurate enough for general-purpose use. However,
  prefs: []
  type: TYPE_NORMAL
- en: several factors such as manufacturing differences, casing, and operating environment
  prefs: []
  type: TYPE_NORMAL
- en: (too cold, too hot) impact the operation of a quartz crystal. Usually, too low
    or high a
  prefs: []
  type: TYPE_NORMAL
- en: temperature can slow down the clock. Imagine if an electronic device operating
    in the
  prefs: []
  type: TYPE_NORMAL
- en: field is exposed to high temperatures; the clock can run slower than a clock
    working in
  prefs: []
  type: TYPE_NORMAL
- en: normal favorable conditions. This difference caused by the clock running faster
    or slower is called drift. Drift is measured in parts per million (ppm) units.
  prefs: []
  type: TYPE_NORMAL
- en: In almost all quartz clocks, the frequency of the quartz crystal is 32,768 kHz
    due to its cut and size and how it is manufactured. This is a specific cut and
    size which looks like a tuning fork, due to which the frequency produced is always
    32,768 Hertz. I decided to do
  prefs: []
  type: TYPE_NORMAL
- en: a small experiment with my oscilloscope and an old clock lying around to demonstrate
  prefs: []
  type: TYPE_NORMAL
- en: this fact.
  prefs: []
  type: TYPE_NORMAL
- en: Here are the results! Figur[e 1-21 sho](#p59)ws a quartz crystal in a clock
    circuit producing exactly 32,768 Hertz at normal room temperature, shown on the
    oscilloscope screen.
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 1-21\.** Quartz crystal clock measured using an oscilloscope*'
  prefs: []
  type: TYPE_NORMAL
- en: In Figur[e 1-21](#p59), the probes from the oscilloscope are connected to the
    quartz crystal component on the clock circuit, and the waveform is shown on the
    oscilloscope screen.
  prefs: []
  type: TYPE_NORMAL
- en: Also, the frequency is displayed at the right bottom of the oscilloscope screen,
    which
  prefs: []
  type: TYPE_NORMAL
- en: reads 32.7680KHz.
  prefs: []
  type: TYPE_NORMAL
- en: '40'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 1 IntroduCtIon
  prefs: []
  type: TYPE_NORMAL
- en: '**Clock Skew vs. Drift**'
  prefs: []
  type: TYPE_NORMAL
- en: Due to environmental factors such as temperature and manufacturing differences,
  prefs: []
  type: TYPE_NORMAL
- en: quartz crystal clocks can slow down, resulting in skew and drift. The immediate
  prefs: []
  type: TYPE_NORMAL
- en: difference between the time shown by two clocks is called their skew, whereas
    the rate at which two clocks count time differently is called drift. Note that
    the difference between physical clocks between nodes in a heterogeneous distributed
    system may be even more
  prefs: []
  type: TYPE_NORMAL
- en: significant than homogenous distributed systems where hardware, OS, and architecture
  prefs: []
  type: TYPE_NORMAL
- en: are the same for all nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Generally, it is expected that roughly a drift of one second over 11 days can
    develop,
  prefs: []
  type: TYPE_NORMAL
- en: which over time can lead to an observable and significant difference. Imagine
    two
  prefs: []
  type: TYPE_NORMAL
- en: servers running in a data center with no clock synchronization mechanism and
    are
  prefs: []
  type: TYPE_NORMAL
- en: only dependent on their internal quartz clock. In a month, they will be running
    two
  prefs: []
  type: TYPE_NORMAL
- en: to three seconds apart from each other. All time-dependent operations will run
    three
  prefs: []
  type: TYPE_NORMAL
- en: seconds apart, and over time this will continue to worsen. For example, a batch
    job that
  prefs: []
  type: TYPE_NORMAL
- en: is supposed to start at 11 AM will begin at 11 + 3 seconds in a month. This
    situation can cause issues with time-dependent jobs, can cause security issues,
    and can impact time-sensitive operations, and software may fail or depict an arbitrary
    behavior. A much more
  prefs: []
  type: TYPE_NORMAL
- en: accurate clock than a quartz clock is an atomic clock.
  prefs: []
  type: TYPE_NORMAL
- en: '**Atomic Clocks**'
  prefs: []
  type: TYPE_NORMAL
- en: Atomic clocks are based on the quantum mechanical properties of atoms. Atoms
    such
  prefs: []
  type: TYPE_NORMAL
- en: as cesium or rubidium and mercury are used, and resonant frequencies (oscillations)
    of
  prefs: []
  type: TYPE_NORMAL
- en: atoms are used to record accurate and precise times.
  prefs: []
  type: TYPE_NORMAL
- en: Our notion of time is based on astronomical observations such as changing seasons
  prefs: []
  type: TYPE_NORMAL
- en: and the Earth’s rotation. The higher the oscillation, the higher the frequency
    and the
  prefs: []
  type: TYPE_NORMAL
- en: more precise the time. This is the principle on which atomic clocks work and
    produce
  prefs: []
  type: TYPE_NORMAL
- en: highly precise time.
  prefs: []
  type: TYPE_NORMAL
- en: In 1967, the unit of time was defined as a second of “the duration of 9,192,631,770
  prefs: []
  type: TYPE_NORMAL
- en: periods of the radiation corresponding to the transition between the two hyperfine
    levels of the ground state of the caesium-133 atom.” In other words, oscillation
    of cesium atoms between two energy states exactly 9,192,631,770 times under controlled
    environment
  prefs: []
  type: TYPE_NORMAL
- en: defines a true second. An atomic clock is shown in Figur[e 1-22\.](#p61)
  prefs: []
  type: TYPE_NORMAL
- en: '41'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-61_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 1 IntroduCtIon
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 1-22\.** Cesium-based atomic clocks: image from [https://nara.](https://nara.getarchive.net/media/cesium-beam-atomic-clocks-at-the-us-naval-observatory-provide-the-basis-for-29fa0c)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[*getarchive.net/media/cesium-beam-atomic-clocks-at-the-us-naval-*](https://nara.getarchive.net/media/cesium-beam-atomic-clocks-at-the-us-naval-observatory-provide-the-basis-for-29fa0c)'
  prefs: []
  type: TYPE_NORMAL
- en: '[*observatory-provide-the-basis-for-29fa0c*](https://nara.getarchive.net/media/cesium-beam-atomic-clocks-at-the-us-naval-observatory-provide-the-basis-for-29fa0c)'
  prefs: []
  type: TYPE_NORMAL
- en: Now imagine a scenario where we discover a clock skew and see that one clock
    is
  prefs: []
  type: TYPE_NORMAL
- en: running behind ten seconds. We can usually and simply advance it to ten seconds
    to
  prefs: []
  type: TYPE_NORMAL
- en: make the clock accurate again. It is not ideal but not as bad as the clock skew,
    where we may discover a clock to run ten seconds behind. What can we do in that
    case? Can we
  prefs: []
  type: TYPE_NORMAL
- en: simply push it back to ten seconds? It is not a very good idea because we can
    then run
  prefs: []
  type: TYPE_NORMAL
- en: into situations where it would appear that a message is received before we sent
    it.
  prefs: []
  type: TYPE_NORMAL
- en: To address clock skews and drifts, we can synchronize clocks with a trusted
    and
  prefs: []
  type: TYPE_NORMAL
- en: accurate time source.
  prefs: []
  type: TYPE_NORMAL
- en: You might be wondering why there is such a requirement for more and more precise
  prefs: []
  type: TYPE_NORMAL
- en: clocks and sources of time. Quartz clocks are good enough for day-to-day use;
    then
  prefs: []
  type: TYPE_NORMAL
- en: we saw GPS as a more accurate time source, and then we saw atomic clocks that
    are
  prefs: []
  type: TYPE_NORMAL
- en: even more accurate and can drift only a second in about 300 million years! [1
    B](#p61)ut why do we need such highly accurate clocks? The answer is that for
    day-to-day use, it doesn’t
  prefs: []
  type: TYPE_NORMAL
- en: matter. If the time on my wristwatch is a few seconds different from other clocks,
    it’s
  prefs: []
  type: TYPE_NORMAL
- en: not a problem. If my post on a social media site has a timestamp that is a few
    seconds
  prefs: []
  type: TYPE_NORMAL
- en: 1 [www.nist.gov/si-redefinition/second/second-present](http://www.nist.gov/si-redefinition/second/second-present)
  prefs: []
  type: TYPE_NORMAL
- en: '42'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 1 IntroduCtIon
  prefs: []
  type: TYPE_NORMAL
- en: apart from the exact time I posted it, perhaps that is not an issue. Of course,
    as long
  prefs: []
  type: TYPE_NORMAL
- en: as the sequence is maintained, the timestamp is acceptable within a few seconds.
    But
  prefs: []
  type: TYPE_NORMAL
- en: the situation changes in many other practical scenarios and distributed systems.
    For
  prefs: []
  type: TYPE_NORMAL
- en: example, high-frequency trading systems require (by regulation MiFID II) that
    the
  prefs: []
  type: TYPE_NORMAL
- en: mechanism format the timestamp on messages in the trading system in microseconds
  prefs: []
  type: TYPE_NORMAL
- en: and be accurate within 100 microseconds. From a clock synchronization point
    of view,
  prefs: []
  type: TYPE_NORMAL
- en: only 100 microseconds divergence is allowed from UTC. While such requirements
    are
  prefs: []
  type: TYPE_NORMAL
- en: essential for the proper functioning and regulation of the trading systems,
    they also
  prefs: []
  type: TYPE_NORMAL
- en: pose technical challenges. In such scenarios, the choice of source of accurate
    time,
  prefs: []
  type: TYPE_NORMAL
- en: choice of synchronization algorithms, and handling of skews and drifts become
    of prime
  prefs: []
  type: TYPE_NORMAL
- en: importance.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see specific MiFID requirements here as a reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://ec.europa.eu/finance/securities/docs/isd/mifid/rts/160607-rts-25-](https://ec.europa.eu/finance/securities/docs/isd/mifid/rts/160607-rts-25-annex_en.pdf)'
  prefs: []
  type: TYPE_NORMAL
- en: '[annex_en.pdf](https://ec.europa.eu/finance/securities/docs/isd/mifid/rts/160607-rts-25-annex_en.pdf)'
  prefs: []
  type: TYPE_NORMAL
- en: There are other applications of atomic clocks in defense, geology, astronomy,
  prefs: []
  type: TYPE_NORMAL
- en: navigation, and many others.
  prefs: []
  type: TYPE_NORMAL
- en: Recently, Sapphire clocks have been developed, which are much more precise than
  prefs: []
  type: TYPE_NORMAL
- en: even cesium-based atomic clocks. It is so precise that it can lose or gain a
    second in three billion years.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, there are two ways in which time is represented in computers. One is
    epoch
  prefs: []
  type: TYPE_NORMAL
- en: time, also called Unix time, which is defined as the number of seconds elapsed
    since
  prefs: []
  type: TYPE_NORMAL
- en: January 1, 1970\. Another common timestamp format is ISO8601, which defines
    a date
  prefs: []
  type: TYPE_NORMAL
- en: and time format standard.
  prefs: []
  type: TYPE_NORMAL
- en: '**Synchronization Algorithms for Physical Clocks**'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two methods to synchronize clocks:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. External synchronization
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Internal synchronization
  prefs: []
  type: TYPE_NORMAL
- en: In the external clock synchronization method, there is an external and authoritative
  prefs: []
  type: TYPE_NORMAL
- en: source of time to which nodes in a distributed system synchronize with.
  prefs: []
  type: TYPE_NORMAL
- en: In the internal synchronization method, clocks in nodes (processes) are
  prefs: []
  type: TYPE_NORMAL
- en: synchronized with one another.
  prefs: []
  type: TYPE_NORMAL
- en: '43'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 1 IntroduCtIon
  prefs: []
  type: TYPE_NORMAL
- en: '**NTP**'
  prefs: []
  type: TYPE_NORMAL
- en: The network time protocol (NTP) allows clients to synchronize with UTC. In NTP,
    servers
  prefs: []
  type: TYPE_NORMAL
- en: are organized in so-called strata, where stratum 1 servers (primary time servers)
    are
  prefs: []
  type: TYPE_NORMAL
- en: directly connected to an accurate time source in stratum 0, for example, GPS
    or atomic
  prefs: []
  type: TYPE_NORMAL
- en: clock. Stratum 2 servers synchronize with stratum 1 servers over the network,
    and
  prefs: []
  type: TYPE_NORMAL
- en: stratum 2 servers synchronize with stratum 3 servers. This type of architecture
    provides
  prefs: []
  type: TYPE_NORMAL
- en: a reliable, secure, and scalable protocol. Reliability comes from the use of
    redundant
  prefs: []
  type: TYPE_NORMAL
- en: servers and paths. Security is provided by utilizing appropriate authentication
  prefs: []
  type: TYPE_NORMAL
- en: mechanisms, and scalability is characterized by NTP’s ability to serve a large
    number
  prefs: []
  type: TYPE_NORMAL
- en: of clients. While NTP is an efficient and robust protocol, inherent network
    latency,
  prefs: []
  type: TYPE_NORMAL
- en: misconfigurations in the protocol setup, network misconfigurations that may
    block the
  prefs: []
  type: TYPE_NORMAL
- en: NTP protocol, and several other factors can still cause clocks to drift.
  prefs: []
  type: TYPE_NORMAL
- en: '**GPS As a Time Source**'
  prefs: []
  type: TYPE_NORMAL
- en: A GPS receiver can be used as an accurate source of time. All 31 GPS satellites
    have
  prefs: []
  type: TYPE_NORMAL
- en: atomic clocks on board, which produce precise time. These satellites broadcast
    their
  prefs: []
  type: TYPE_NORMAL
- en: location and time, where GPS receivers receive and calculate time and position
    on earth
  prefs: []
  type: TYPE_NORMAL
- en: after applying some corrections for environmental factors and time dilation.
    Remember,
  prefs: []
  type: TYPE_NORMAL
- en: time runs slightly faster on GPS satellites than objects on the earth’s surface
    due to
  prefs: []
  type: TYPE_NORMAL
- en: relativity. Other relativity-related effects include time dilation, gravitational
    frequency shift, and eccentricity effects. All these errors are handled, and many
    other corrections are made before an accurate time is displayed on the GPS receiver.
    While the GPS as a
  prefs: []
  type: TYPE_NORMAL
- en: source of precise time is highly accurate, the inherent latency introduced even
    after the existence of correct and accurate time at the GPS receiver in the network
    can lead to drift and skew of clocks over time. There is a need to introduce some
    clock synchronization
  prefs: []
  type: TYPE_NORMAL
- en: algorithms to address this limitation.
  prefs: []
  type: TYPE_NORMAL
- en: A combination of atomic clocks and GPS is used in Google’s spanner (Google’s
  prefs: []
  type: TYPE_NORMAL
- en: globally distributed database) for handling timing uncertainties.
  prefs: []
  type: TYPE_NORMAL
- en: However, note that even with all the efforts, the clocks cannot be perfectly
  prefs: []
  type: TYPE_NORMAL
- en: synchronized, which is good enough for most applications. However, these very
    accurate
  prefs: []
  type: TYPE_NORMAL
- en: clocks are still not enough to capture the causality relationship between events
    in a
  prefs: []
  type: TYPE_NORMAL
- en: distributed system. The causality relationship between events and the fundamental
  prefs: []
  type: TYPE_NORMAL
- en: monotonicity property can be accurately captured by logical clocks.
  prefs: []
  type: TYPE_NORMAL
- en: '44'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 1 IntroduCtIon
  prefs: []
  type: TYPE_NORMAL
- en: In distributed systems, even if each process has a local clock and is synchronized
  prefs: []
  type: TYPE_NORMAL
- en: with some global clock source, there is still a chance that each local processor
    would see the time differently. The clocks can drift over time, the processors
    can experience bugs, or there can be an inherent drift, for example, quartz clocks
    or GPS systems, making it
  prefs: []
  type: TYPE_NORMAL
- en: challenging to handle time in a distributed system.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a distributed system with some nodes in the orbit and some in other
  prefs: []
  type: TYPE_NORMAL
- en: geographical locations on earth, and they all agree to use UTC. The physical
    clocks in
  prefs: []
  type: TYPE_NORMAL
- en: satellites or ISS will run at a different rate, and skew is inevitable. The
    core limitation in depending on physical clocks is that even if trying to synchronize
    them perfectly,
  prefs: []
  type: TYPE_NORMAL
- en: timestamps will be slightly apart. However, these physical clocks cannot (should
    not)
  prefs: []
  type: TYPE_NORMAL
- en: be used to establish the order of events in a distributed system because it
    is difficult to accurately find out the global order of events based on timestamps
    in different nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Physical clocks are not very suitable for distributed systems because they can
  prefs: []
  type: TYPE_NORMAL
- en: drift apart. Even with one universal source, such as the atomic clock through
    NTP,
  prefs: []
  type: TYPE_NORMAL
- en: they can still drift and desynchronize over time with the source. Even a difference
    of a
  prefs: []
  type: TYPE_NORMAL
- en: second can sometimes cause a big issue. In addition, there can be software bugs
    in the
  prefs: []
  type: TYPE_NORMAL
- en: implementation that can cause unintentional consequences. For example, let’s
    look at
  prefs: []
  type: TYPE_NORMAL
- en: a famous bug, the leap second bug that is a cause of significant disruption
    of Internet
  prefs: []
  type: TYPE_NORMAL
- en: services.
  prefs: []
  type: TYPE_NORMAL
- en: '**UTC Time**'
  prefs: []
  type: TYPE_NORMAL
- en: UTC time is a time standard used around the world. There are two sources of
    time that
  prefs: []
  type: TYPE_NORMAL
- en: 'are used to make up coordinated universal time (UTC):'
  prefs: []
  type: TYPE_NORMAL
- en: • International atomic time (TAI)
  prefs: []
  type: TYPE_NORMAL
- en: • TAI is based on around 400 atomic clocks around the world. A
  prefs: []
  type: TYPE_NORMAL
- en: combined and weighted output from all these atomic clocks is
  prefs: []
  type: TYPE_NORMAL
- en: produced. This is extremely accurate where they only deviate one
  prefs: []
  type: TYPE_NORMAL
- en: second in around 100 million years!
  prefs: []
  type: TYPE_NORMAL
- en: • Astronomical time
  prefs: []
  type: TYPE_NORMAL
- en: • This time is based on astronomical observations, that is, the
  prefs: []
  type: TYPE_NORMAL
- en: rotation of the Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '45'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 1 IntroduCtIon
  prefs: []
  type: TYPE_NORMAL
- en: While TAI is highly accurate, it doesn’t consider the Earth’s rotation, that
    is, the
  prefs: []
  type: TYPE_NORMAL
- en: astronomically observed time that determines the true length of the day. Earth’s
    rotation is not constant. It is occasionally faster and is slowing down overall.
    Therefore, days are not exactly 24 hours. The impact on Earth’s rotation is due
    to celestial bodies such as
  prefs: []
  type: TYPE_NORMAL
- en: the moon, tides, and other environmental factors. Therefore, UTC is kept in
    constant
  prefs: []
  type: TYPE_NORMAL
- en: comparison with the astronomical time, and any difference is added to UTC. This
  prefs: []
  type: TYPE_NORMAL
- en: difference is added in the form of leap second; before the difference between
    TAI and
  prefs: []
  type: TYPE_NORMAL
- en: astronomical time reaches 0.9, a leap second is added to the UTC. This is the
    practice
  prefs: []
  type: TYPE_NORMAL
- en: since 1972\.
  prefs: []
  type: TYPE_NORMAL
- en: OK, this seems like a reasonable solution to keep both times synced; however,
  prefs: []
  type: TYPE_NORMAL
- en: computers don’t seem to handle this situation well. Unix systems use Unix time
    (epoch),
  prefs: []
  type: TYPE_NORMAL
- en: simply the number of seconds elapsed since January 1, 1970\. When a leap second
    is
  prefs: []
  type: TYPE_NORMAL
- en: 'added, this is how the clock looks like: in a normal case, it is observed that
    after 23:59:59, there is 00:00:00\. However, adding a leap second seems as if
    after 23:59:59, there is'
  prefs: []
  type: TYPE_NORMAL
- en: 23:59:60 and then 00:00:00\. In other words, 23:59:59 happens twice. When Unix
    time
  prefs: []
  type: TYPE_NORMAL
- en: deals with this addition of an extra second, it can produce arbitrary behavior.
    In the past, when a leap second is added, servers across the Internet experienced
    issues and services
  prefs: []
  type: TYPE_NORMAL
- en: as critical as airline booking systems were disrupted.
  prefs: []
  type: TYPE_NORMAL
- en: A technique called "leap smear" has been developed, which allows for the gradual
    addition of a few milliseconds over a day to address this issue of sudden addition
    and
  prefs: []
  type: TYPE_NORMAL
- en: problem associated with this sudden one-second additional.
  prefs: []
  type: TYPE_NORMAL
- en: OK, so far, we have seen that UTC and astronomical time are synced by adding
    a leap
  prefs: []
  type: TYPE_NORMAL
- en: second. With the "leap second smear" technique, we can gradually add a leap
    second over time, which alleviates some of the issues associated with sudden additional
    leap
  prefs: []
  type: TYPE_NORMAL
- en: second. There are also calls to abolish this ritual altogether. However, so
    far, we see
  prefs: []
  type: TYPE_NORMAL
- en: adding a leap second as a reasonable solution, and it seems to work somewhat
    OK. We
  prefs: []
  type: TYPE_NORMAL
- en: just add a leap second when the Earth’s rotation slows down, but what if the
    Earth is
  prefs: []
  type: TYPE_NORMAL
- en: spinning faster? In 2020, the Earth indeed spun faster, during the pandemic,
    for whatever reason. Now the question is, do we remove one second from UTC? In
    other words,
  prefs: []
  type: TYPE_NORMAL
- en: introduce the negative leap second! This situation can pose some more challenges
    –
  prefs: []
  type: TYPE_NORMAL
- en: perhaps even more demanding to address as compared to adding a leap second.
  prefs: []
  type: TYPE_NORMAL
- en: The question is, what to do about this, ignore this? What algorithm can help
    to
  prefs: []
  type: TYPE_NORMAL
- en: remove one second and introduce a negative leap second?
  prefs: []
  type: TYPE_NORMAL
- en: So far, it is suggested that simply skip 23:59:59, that is, go from 23:59:58
    to 00:00:00
  prefs: []
  type: TYPE_NORMAL
- en: directly. It is expected that this is easier to deal with as compared to adding
    a leap
  prefs: []
  type: TYPE_NORMAL
- en: '46'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 1 IntroduCtIon
  prefs: []
  type: TYPE_NORMAL
- en: second. Perhaps, a solution is unnecessary because we may ignore the Earth spinning
  prefs: []
  type: TYPE_NORMAL
- en: faster or slower altogether and abolish the leap second adjustment practice,
    either
  prefs: []
  type: TYPE_NORMAL
- en: negative or positive. It is not ideal, but we might do that to avoid issues
    and ambiguity associated with handling leap seconds, especially adding leap seconds!
    At the time of
  prefs: []
  type: TYPE_NORMAL
- en: writing, this is an open question.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some more info are found her[e: https://fanf.dreamwidth.org/133823.html](https://fanf.dreamwidth.org/133823.html)'
  prefs: []
  type: TYPE_NORMAL
- en: (negative leap second) and [www.eecis.udel.edu/~mills/leap.html](https://www.eecis.udel.edu/~mills/leap.html).
  prefs: []
  type: TYPE_NORMAL
- en: To avoid limitations and problems associated with physical clocks and
  prefs: []
  type: TYPE_NORMAL
- en: synchronization, for distributed systems, we can use logical clocks, which have
    no
  prefs: []
  type: TYPE_NORMAL
- en: correlation with physical clocks but are a way to order the events in a distributed
    system.
  prefs: []
  type: TYPE_NORMAL
- en: Although, as we have seen, ordering of events and a causal relationship is an
    essential
  prefs: []
  type: TYPE_NORMAL
- en: requirement in distributed systems, logical clocks play a vital role in ensuring
    this in
  prefs: []
  type: TYPE_NORMAL
- en: distributed systems.
  prefs: []
  type: TYPE_NORMAL
- en: From a distributed system point of view, we learned earlier that the notion
    of global
  prefs: []
  type: TYPE_NORMAL
- en: state is very important, which allows us to observe the state of a distributed
    system
  prefs: []
  type: TYPE_NORMAL
- en: and helps to snapshot or checkpoint. Thus, time plays a vital role here because
    if time
  prefs: []
  type: TYPE_NORMAL
- en: is not uniform across the system (each processor running at a different time),
    and we
  prefs: []
  type: TYPE_NORMAL
- en: try to read states from all different processors and links in a system, it will
    result in an inconsistent state.
  prefs: []
  type: TYPE_NORMAL
- en: '**Types of Physical Clocks**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Physical clocks can be divided into two categories:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Time-of-day clocks
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Monotonic clocks
  prefs: []
  type: TYPE_NORMAL
- en: Time-of-day clocks are characterized by the representation of time since a fixed
  prefs: []
  type: TYPE_NORMAL
- en: point in time. For example, Unix time that is calculated from January 1, 1970
    is an
  prefs: []
  type: TYPE_NORMAL
- en: example of a time-of-day clock. The time can be adjusted via synchronization
    to a
  prefs: []
  type: TYPE_NORMAL
- en: time source and can move backward or forward. However, moving the time backward
  prefs: []
  type: TYPE_NORMAL
- en: is not a good idea. Such a scenario can lead to situations where, for example,
    it would
  prefs: []
  type: TYPE_NORMAL
- en: appear that a message is received before it was sent. This issue can happen
    due to the
  prefs: []
  type: TYPE_NORMAL
- en: timestamp being adjusted and moving backward in time due to adjustments made
    by
  prefs: []
  type: TYPE_NORMAL
- en: the synchronization algorithms, for example, NTP.
  prefs: []
  type: TYPE_NORMAL
- en: As the time always increases, time shouldn’t go backward; we need monotonic
  prefs: []
  type: TYPE_NORMAL
- en: clocks to handle such scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: '47'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 1 IntroduCtIon
  prefs: []
  type: TYPE_NORMAL
- en: With physical clocks, it is almost impossible to provide causality. Even if
    time
  prefs: []
  type: TYPE_NORMAL
- en: synchronization services are used, there is still a chance that the timestamp
    of one
  prefs: []
  type: TYPE_NORMAL
- en: process differs from another just enough to impact the order of events adversely.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, the ordering of events is a fundamental requirement in distributed systems.
    To
  prefs: []
  type: TYPE_NORMAL
- en: fully understand the nature of this ordering requirement, we use a formal notion
    of
  prefs: []
  type: TYPE_NORMAL
- en: something called "happens-before relationship."
  prefs: []
  type: TYPE_NORMAL
- en: Just before we introduce the happens-before relationship and causality, let
    us clarify
  prefs: []
  type: TYPE_NORMAL
