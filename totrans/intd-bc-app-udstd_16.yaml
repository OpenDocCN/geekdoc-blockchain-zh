- en: © The Author(s), under exclusive license to APress Media, LLC, part of Springer
    Nature 2022J. T. GeorgeIntroducing Blockchain Applications[https://doi.org/10.1007/978-1-4842-7480-4_16](https://doi.org/10.1007/978-1-4842-7480-4_16)
  prefs: []
  type: TYPE_NORMAL
- en: 16. Blockchain Technology and Distributed System Future Scope and B-Coin Project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Joseph Thachil George^([1](#Aff2)  )(1)Rome, Italy
  prefs: []
  type: TYPE_NORMAL
- en: Blockchain systems have attracted various industry stakeholders, including those
    in finance, healthcare, utilities, real estate, and government, since it solves
    many security problems in distributed systems. Public blockchains will play a
    significant role in cyber-security and Internet of Things (IoT) security as the
    commercial, government, and military sectors become more comfortable with it.
    At the same time, security and privacy problems in public blockchains will need
    to be addressed before they can be incorporated into existing core cloud and IoT
    devices.^([1](#Fn1))
  prefs: []
  type: TYPE_NORMAL
- en: The development of blockchain systems will bring new concerns linked to the
    Internet of Smart Things, including trust, security, and privacy. Academia and
    business are collaborating to create blockchain platforms to address these urgent
    cloud and IoT security issues.¹
  prefs: []
  type: TYPE_NORMAL
- en: We now know that blockchain platforms address issues such as cloud-based data
    proofing, information sharing, cloud storage, smart vehicles, IoT mass transit
    security, attack surface analysis, double spending prevention, trustless platform
    security, failure consensus protocols, statistics, and performance measures in
    cloud and IoT systems.
  prefs: []
  type: TYPE_NORMAL
- en: Military and commercial organizations have also used cloud technology to enable
    data storage, on-demand computation, and dynamic provisioning. Cloud services’
    ecosystems are diverse and dynamic. They necessitate interoperability since they
    incorporate multiple hardware and software components from several suppliers.
  prefs: []
  type: TYPE_NORMAL
- en: 16.1 Blockchain and IoT Security
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Vehicles, infrastructures, home monitors, smart healthcare imaging, and wearable
    electronics have all embraced the Internet of Things (IoT) as the principal way
    to optimize interconnectedness between the cyber and physical worlds. In the IoT
    context, security is still a major problem. Despite considerable advancements
    in security in the area of information technology in recent years, security at
    the application level remains an open research issue.
  prefs: []
  type: TYPE_NORMAL
- en: 16.1.1 Blockchain Implementations and Use Cases in IoT
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The distributed ledger technology  that underpins cryptocurrency, particularly
    Bitcoin, is known as blockchain. It’s already being used in a number of industries,
    notably in retail to move items through supply chains more easily and securely,
    and in medicine to preserve the integrity of contracts, clinical studies, and
    the medications themselves.
  prefs: []
  type: TYPE_NORMAL
- en: The quality of the products is constantly checked by incorporating blockchain
    into these and other industries. A blockchain-focused research center has also
    been formed to encourage the development and commercialization of the technology
    and its potential to transform the IoT ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: 16.1.2 Challenges with Integrating Blockchain Into IoT
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The IoT blockchain is gaining traction, but it is not without its challenges.
    To begin, the blockchain’s central idea is the chain of activities that have been
    completed. The chain is created by storing a reference to earlier operations,
    which are referred to in Bitcoin as *blocks* . Creating blocks, on the other hand,
    is a computationally expensive task that necessitates several processors and a
    significant amount of time. Because it’s tough to make a single block, manipulating
    it would be far more complex—you’d have to fake the preceding block and then follow
    the chain you made to modify it.
  prefs: []
  type: TYPE_NORMAL
- en: 16.2 Safety Recommendations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If properly managed, blockchain can significantly reduce costs and improve efficiency
    in IoT systems. However, technological adoption in IoT-enabled workplaces is far
    from ideal. Only 10% of blockchain ledgers in operation, for instance, are expected
    to integrate embedded technologies by 2020\. Additionally, most IoT systems have
    a long way to go before they are computationally capable of handling the load.
  prefs: []
  type: TYPE_NORMAL
- en: 'IoT users, both people and companies, should seek multi-layered security with
    end-to-end security that spans from the gateway to the endpoint and is capable
    of preventing potential network attacks and compromises, in addition to timely
    software upgrades to avoid downtime. This includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Changing the default credentials**. IoT botnets have been found to use manufacturer
    default credentials to connect to linked devices. To decrease the danger of a
    device breach, it is advised that users enable secure passwords and use unique
    and complicated passwords.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Strengthening the router’s security**. A network is made susceptible by a
    weak router. Using security management solutions to protect routers helps users
    keep track of all devices connected while protecting privacy and productivity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Configuring security devices**. The device’s default settings must be evaluated
    and modified to meet the needs of the user. To improve security, it’s a good idea
    to personalize features and turn off those that aren’t needed. Keep an eye on
    the network traffic. Actively monitoring for unusual behavior on the Internet
    can assist consumers in avoiding harmful efforts. Real-time scanning provided
    by security solutions may also be used to identify malware automatically and effectively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Implementing additional security measures**. For extra protection, users
    should activate firewalls and use the Wi-Fi Protected Access II security protocol.
    Web reputations and application control-based technologies also give greater network
    visibility.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.3 Blockchain Security and Privacy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Security and privacy threats can be exploited on blockchain networks. Several
    chapters characterize attack surfaces, identify vulnerabilities in consensus protocols,
    discuss privacy and security threats to blockchain without and with required authorization,
    diagnose problems to defend against duplicate spending, and isolate effective
    defenses adopted by blockchain technology or proposed by researchers to mitigate
    the risks.
  prefs: []
  type: TYPE_NORMAL
- en: Through cryptography, there is blockchain-based document ownership of all existing
    currencies inside a cryptocurrency ecosystem at any one time. A transaction is
    stored in a “block” on the blockchain once it has been confirmed and cryptographically
    verified by other network members or nodes.
  prefs: []
  type: TYPE_NORMAL
- en: The timing of the transaction, prior transactions, and transaction details are
    all stored in a block. Events are kept chronologically and cannot be altered after
    they have been entered as a block. Since the birth of Bitcoin and the initial
    use of blockchain technology, this technology has stimulated the development of
    additional cryptocurrencies and applications.
  prefs: []
  type: TYPE_NORMAL
- en: Data is not validated and controlled by a single organization, as in traditional
    systems, due to decentralization. Rather, every node or computer connected to
    the network verifies the authenticity of transactions. Cryptography secures and
    verifies transactions and data in the blockchain technology.
  prefs: []
  type: TYPE_NORMAL
- en: Data breaches have grown more prevalent as the use of technology has increased.
    Personal data and information are stored, abused, and misused, posing a danger
    to privacy. Numerous people are advocating for blockchain technology to be widely
    used because it can increase user privacy, data security, and data ownership.
  prefs: []
  type: TYPE_NORMAL
- en: 16.4 The Future Scope
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Despite the fact that there are numerous blockchain systems on the market and
    that substantial research and development is being done on specific blockchain
    aspects, additional study in the following categories is required.
  prefs: []
  type: TYPE_NORMAL
- en: '16.4.1 Blockchain Architecture: Private, Public, or Hybrid-Public Blockchain
    Design'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Transactions are conducted in a decentralized manner. Commercial businesses,
    on the other hand, are wary of incorporating a public blockchain into their corporate
    solutions, due to worries about privacy, performance, and reaction time. To solve
    these problems, more R&D in the public blockchain system is required.
  prefs: []
  type: TYPE_NORMAL
- en: Meanwhile, corporate players are moving closer to private/approved consensus
    mechanisms. Depending on the type of governance, this architecture might range
    from a single member to a consortium that controls the blockchain platform. The
    architecture, protocol, or method by which transactions are verified on these
    blockchain platforms has administrative components.
  prefs: []
  type: TYPE_NORMAL
- en: 16.4.2 Inducement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Bitcoin, there is a monetary incentive to join the blockchain platform; however,
    there are no monetary incentives in use cases like provenance and identity management.
    To achieve maximum involvement, the incentive structure must be included in the
    protocol.
  prefs: []
  type: TYPE_NORMAL
- en: To guarantee that blockchain protocols function to maximize advantages for the
    use case, mechanisms for incentive design may be generated from use cases. While
    trust management of the public blockchain may prevent manipulations or fraud,
    it is critical that the architecture incorporate incentive mechanisms with anti-fraud
    or anti-justice qualities. The processes involved in motivating participation
    need the development of theoretical models.
  prefs: []
  type: TYPE_NORMAL
- en: 16.4.3 Data Privacy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because blockchain transactions are public, data analysis techniques may be
    used to analyze the vast quantities of data included inside them. The identities
    of participants and the precise transactions they have done might be revealed
    as a result of this research. Stealth addresses, homomorphic cryptography, and
    zero-knowledge proof are among the approaches used to solve privacy problems in
    public blockchain systems. A mix of approaches is necessary to obtain the appropriate
    level of anonymity.
  prefs: []
  type: TYPE_NORMAL
- en: 16.5 Having Realistic Expectations of Blockchain
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Blockchain technology has been gaining attention for some time, and it can perhaps
    be said that despite being a complex technology, it has become a “mainstream”
    theme. Blockchain technology issues have been addressed by large newspapers, radios,
    and television shows that normally rarely focus on such innovative technologies.
    In many cases, blockchain technology is proposed as “the solution” to problems
    and needs that have never been truly satisfied by traditional technology. The
    expectations, not only of companies but of consumers, on blockchain technology
    have greatly increased. On the one hand, this situation favors debate and growth,
    but on the other hand it creates a dangerous situation because some of the “beneficial
    effects” “that today are attributed to blockchain technology are the result of
    misunderstandings. It is important to emphasize that blockchain technology cannot
    solve all our problems. The following sections discuss some of these issues.
  prefs: []
  type: TYPE_NORMAL
- en: 16.6 Food Certification
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the agri-food sector, blockchain technology has growing consensus, precisely
    because it can provide guarantees of reliability on often complex and fragmented
    supply chains, not only due to the size of the companies but because of the culture
    of the organizations or countries in which they are located. Blockchain technology
    guarantees the certainty, the immutability, and the transparency of the data that
    accompanies production.
  prefs: []
  type: TYPE_NORMAL
- en: We must not think that blockchain is, in itself, a guarantee of quality, which
    can “by itself” guarantee not only the certification but the quality of the product.
    Blockchain technology certifies the data and guarantees its identity and transparency
    for all ac-tors. But if the original data does not correctly represent the product
    that goes into production, if that data is “wrong” to begin with, blockchain technology
    does not correct it. On the contrary, blockchain ensures that that “wrong” data
    is kept intact throughout the supply chain. As they say, “garbage in, garbage
    out”.
  prefs: []
  type: TYPE_NORMAL
- en: The transparency of blockchain is a possible corrective, because everyone can
    see that the data and everyone can (if they are able to do so) ascertain its value
    and propose a correction. Blockchain technology guarantees the process of managing
    that data for all participants.
  prefs: []
  type: TYPE_NORMAL
- en: 16.7 Smart Contracts and Notaries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Smart contracts* can cause some confusion when compared to the discipline
    of the traditional contract. However, by briefly reviewing the essential requirements
    of the contract governed by civil code, it is easy to identify numerous similarities
    that could constitute the legal basis for assimilating smart contracts into the
    discipline of the traditional contract.^([2](#Fn2))'
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to state that the space of operation of this principle coincides
    with the space of operation of private autonomy; as an agreement, the contract
    is by definition a bilateral act. However, there are possible unilateral acts
    that can be classified in the contractual legal regime. In this case, they are
    non-intrusive unilateral acts of the legal sphere, as they “leave intact the power
    of the subject involved to totally self-determine with respect to the situation
    created.”^([3](#Fn3)) Examples of these types of contracts are power of attorney,
    wills, and waivers.
  prefs: []
  type: TYPE_NORMAL
- en: 16.7.1 Applying Blockchain Technology to Smart Contracts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At this junction, a quick description of how blockchain technology pertains
    to a smart contract and how a contract might physically assume a directly technical
    shape, as opposed to natural language, is required.
  prefs: []
  type: TYPE_NORMAL
- en: 'Preliminarily, it’s important to note that the parties’ involvement is plainly
    required at the outset. The parties will decide the contract’s conditions by mutual
    agreement. The core of the structure may be considered to be made up of three
    major elements: the account (also known as the parties’ identity), the assets
    you have (assets), and the contract.'
  prefs: []
  type: TYPE_NORMAL
- en: We use the term “account” to refer to an address that may be used to identify
    a person, entity, or group of individuals who will proceed to interact with the
    ledger in question, the so-called “ledger” of which we spoke previously in the
    chapter. Instead, products, often known as “assets,” contain both tangible and
    intangible items, as well as invoices and units of value transferred.
  prefs: []
  type: TYPE_NORMAL
- en: Assets can be defined more broadly as a collection of values traded and held
    by one or more parties that have access to the cryptographic key that permits
    a contract to be settled. The contract, defined as a logical series of activities
    that mediates the transfer of cash and data between the parties, is the final
    prerequisite (accounts).
  prefs: []
  type: TYPE_NORMAL
- en: These accounts change their status by sending updates to the master register,
    which include approved transactions. Before being collected and sequenced into
    a block, transactions are transmitted and validated for their integrity and for
    data integrity.
  prefs: []
  type: TYPE_NORMAL
- en: 'The account holder on the network digitally signs all transactions on the ledger.
    This gives the ledger three key characteristics that distinguish it from traditional
    network traffic:'
  prefs: []
  type: TYPE_NORMAL
- en: Authentication as part of harmful activity cannot be misrepresented as utilizing
    an account that isn’t a part of the transaction if it isn’t.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The transaction’s integrity, because the receipt of the transaction cannot be
    altered once it has occurred.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Non-malleability, because any modifications to the transaction will invalidate
    the issuer’s signature and render the transaction void.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before being added to the chain, each provision is negotiated and accepted by
    both parties. Once the clause has been accepted, it is placed into the first block
    and converted from plain language to an encrypted language that the system can
    understand.
  prefs: []
  type: TYPE_NORMAL
- en: The parties’ real actions are to input, using their cryptographic keys, both
    the clauses intended to perform the contract and the actions that the system will
    carry out automatically in the case of a breach. The contract will advance if
    the system records the fulfillment of the fact referred to in the clause; if,
    on the other hand, the clause’s content is broken, the contract will use technologies
    that make the remedies given by the parties individually or by law.
  prefs: []
  type: TYPE_NORMAL
- en: It will not be feasible to utilize the “backup” method if you find yourself
    in a scenario where one party claims to have a contract with certain provisions
    and the other claims to have the same contract, but with different clauses. The
    blockchain, like other everyday technology such as mobile phones and computers,
    has a data storage mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: No doubt, smart contracts based on blockchain technology can bring enormous
    benefits to companies, organizations, and public administrations. The prospects
    are unquestionable and sectors such as insurance, logistics, and procurement are
    already reaping important benefits from it. Here too there remains a point of
    utmost attention in the transition phase from the real, physical, and digital
    world, in the certainty of providing correct information by subjects, persons,
    or companies.
  prefs: []
  type: TYPE_NORMAL
- en: How to manage this passage the scenario is still open to debate. The function
    of the notary can play an important role in providing guarantees about secure
    data. Again, the blockchain does not ascertain the “truth” or quality of the information.
    The blockchain guarantees its incorruptibility, protects the data from possible
    violations, and transparently exposes changes to all the actors involved. In this
    way, blockchain speeds up any identification of “errors,” but it is not an “intelligent
    system” that can guarantee quality.
  prefs: []
  type: TYPE_NORMAL
- en: 16.7.2 Developing Blockchain in the Market
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Blockchain technology  is a recent phenomenon that has experienced an important
    series of accelerations and that has created many expectations. At the same time,
    developing and implementing blockchain is not an easy task and no single company
    can make it happen. For everyone—producers and companies and user organizations—blockchain
    is an ecosystem phenomenon, of a collaborative type.
  prefs: []
  type: TYPE_NORMAL
- en: If, on the one hand, the level of attention that accompanies blockchain is very
    high, on the other hand, the number of concrete cases, of projects actually in
    production in companies and organizations, is still quite low.
  prefs: []
  type: TYPE_NORMAL
- en: 16.7.3 The Geopolitics of the Blockchain
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Blockchain  has the characteristics of a revolution, and it also has disruptive
    characteristics, which can be destabilizing. For this and other reasons, there
    are very different ways of approaching the blockchain technology. There are countries
    or geographical areas that have embraced it (such as Dubai, Estonia, and Singapore),
    and there are countries that are taking a very careful and pragmatic approach,
    for example with an intense study of new regulations appropriate to management
    of such an innovative phenomenon (such as Switzerland, Austria, and Malta).
  prefs: []
  type: TYPE_NORMAL
- en: Then there is Europe, which is looking for its own dimension and is doing so
    with a series of initiatives, including the European Blockchain Partnership. There
    are also countries that are looking at blockchain with skepticism.
  prefs: []
  type: TYPE_NORMAL
- en: 16.7.4 Books, Whitepapers, and Blockchains
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With blockchain, an intense activity of publication, study, and in-depth analysis
    began with a rich publication of books and whitepapers. In the blockchain books
    section, you will find books specifically related to blockchain. In the books
    and whitepapers section, you will find information about the potential of Industry
    4.0 and digital transformation, including selected texts related to the issues
    of digital transformation in companies.
  prefs: []
  type: TYPE_NORMAL
- en: 16.8 Bitcoin (B-Coin) Sample Project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This project illustrates a cryptocurrency implemented in Python on top of blockchain
    technology. It is a simple blockchain cryptocurrency and should be used only for
    educational purposes. This blockchain network has no central authority. The information
    in it is open for everyone to see. Recall the main properties of blockchain technology:'
  prefs: []
  type: TYPE_NORMAL
- en: Decentralization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transparency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Immutability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this simple implementation of blockchain, B-Coin is built on top of the blockchain
    implementation. You can find more information in the original paper, found in
    the original Bitcoin repository at [https://github.com/bitcoin](https://github.com/bitcoin).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the project’s requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: Python 3.1 or 3.2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flask or Django
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Postman
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.8.1 The Project Code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following task is done using the code found in bitcoin.py. It has a class
    called blockchain. Note that this class creates blocks with five fields—index,
    timestamp, proof, previous_hash, and transactions. Additionally, we have a proof
    of work for mining the block. The goal is to have four leading zeros in the resultant
    hash. (See Listing [16-1](#PC2).)
  prefs: []
  type: TYPE_NORMAL
- en: 'It has the following functions and methods: # add transactions # adding the
    node # replacing the chain with the longest chainIn addition to these methods
    , it has the POST and GET methods for managing blocks in the chain.*************#
    Creating a block chain**class Blockchain:*    *def __init__(self):*        *#
    our whole chain*        *self.chain=[]*        *# list of transactions*        *self.transactions
    = []*        *# genesis block*        *self.create_block(proof= 1 , previous_hash=''0'')*        *#
    nodes in the network should be unique*        *self.nodes = set()*    *"""*    *This
    class is for method is for creating block with five fields*    *index, timestamp,
    proof, previous_hash,transactions*    *"""*    *def create_block(self, proof,
    previous_hash):*        *block={''index'' : len(self.chain) + 1,*                *''timestamp''
    : str(datetime.datetime.now()),*                *''proof'' : proof,*                *''previous_hash''
    : previous_hash,*                *''transactions'' : self.transactions}*        *#
    empty the transactions after all are added to the block*        *self.transactions
    = []*        *self.chain.append(block)*        *return block*    *# Getting the
    old block*    *def get_previous_block(self):*        *return self.chain[-1]**#
    We have a proof of work for mining the block.**# The goal is to have four leading
    zeros in the resultant hash.*    *def proof_of_work(self,previous_proof):*        *new_proof
    = 1*        *check_proof = False*        *# create a hash and look if new_proof**2
    - previous_proof**2 has leading 4 0s else increment the proof and check*        *while
    check_proof is False:*            *hash_operation = hashlib.sha256(str(new_proof**2
    - previous_proof**2).encode()).hexdigest()*            *if hash_operation[:4]==''0000'':*                *check_proof
    =  True*            *else:*                *new_proof +=1*        *return new_proof**#
    Hashing**# json. dumps() accepts a json object as input and returns a string.**#
    The hex() function returns a string after converting the string to bytes.*    *def
    hash(self,block):*        *encoded_block = json.dumps(block, sort_keys = True).encode()*        *return
    hashlib.sha256(encoded_block).hexdigest()*    *# Checking if a block is valid
    or not*    *def is_chain_valid(self, block):*        *previous_block = self.chain[0]*        *block_index=1*        *while
    block_index < len(self.chain):*            *block = self.chain[block_index]*            *#
    Check if the previous hash in the current block differs from the preceding block''s
    original hash.*            *if block[''previous_hash''] != self.hash(previous_block):*                *return
    False*            *# Check if the resultant hash of the proof**2 - previous_proof**2
    does not have 4 leading 0s*            *previous_proof = previous_block[''proof'']*            *proof
    = block[''proof'']*            *hash_operation = hashlib.sha256(str(proof**2 -
    previous_proof**2).encode()).hexdigest()*            *if hash_operation[:4] !=''0000'':*                *return
    False*            *# update the block and increase the index*            *previous_block=block*            *block_index
    +=1*        *return True*    *# add transactions*    *# We''ll send it to Postman
    in json format as a sample request.*    *def add_transaction(self, sender, receiver,
    amount):*        *self.transactions.append({''sender'' : sender,*                           *''receiver''
    : receiver,*                           *''amount'' : amount})*        *previous_block
    = self.get_previous_block()*        *# return the index of the current block (+1
    for genesis block)*        *return previous_block[''index''] + 1*    *# adding
    the node*    *def add_node(self,address):*        *# parsed_url = urlparse(''http://127.0.0.1:1000/'')*        *#
    parsed_url.netloc - ''127.0.0.1:1000''*        *parsed_url = urlparse(address)*        *self.nodes.add(parsed_url.netloc)*    *#
    replacing the chain with the longest chain*    *def replace_chain(self):*        *#
    taking all of our nodes*        *network = self.nodes*        *longest_chain =
    None*        *# max_length is set to the current length*        *max_length =
    len(self.chain)*        *# go through all of the nodes and see all of their chains*        *for
    node in network:*            *response = requests.get(f''http://{node}/get_chain'')*            *#
    if chain is valid*            *if response.status_code == 200:*                *#
    get its length and the chain*                *length = response.json()[''length'']*                *chain
    = response.json()[''chain'']*                *# if it has the length greater than
    the current length update the max_length and the longest chain*                *if
    length > max_length and self.is_chain_valid(chain):*                    *max_length
    = length*                    *longest_chain = chain*        *# if longest_chain
    is set chain the chain to the longest_chain*        *if longest_chain:*            *self.chain
    = longest_chain*            *return True*        *return False**# Creating a web
    app**app = Flask(__name__)**# Creating a port 1000 address for the node.**# uuid4()
    generates a globally unique identifier at random (UUID - generated using synchronization
    methods that ensure no two processes can obtain the same UUID)**node_address =
    str(uuid4()).replace(''-'', '''')**# Putting together a blockchain**blockchain=Blockchain()**#
    Mining a block**@app.route(''/mine_block'', methods = [''GET''])**def mine_block():*    *"""**We''ll
    use the previous block''s proof to compute the new proof and build the current
    block using that proof and the prior hash.*    *"""*    *previous_block = blockchain.get_previous_block()*    *previous_proof
    = previous_block[''proof'']*    *proof = blockchain.proof_of_work(previous_proof)*    *previous_hash
    = blockchain.hash(previous_block)*    *# We may award the bcoin if we mine a block.
    The miner who receives the block can be chosen.*    *blockchain.add_transaction(sender
    = node_address, receiver = ''Bharathi'', amount = 1)*    *block = blockchain.create_block(proof,
    previous_hash)*    *# Return the response*    *response = {''message'' : ''You
    just mined a block, congrats!'',*                *''index'' : block[''index''],*                *''timestamp''
    : block[''timestamp''],*                *''proof'' : block[''proof''],*                *''previous_hash''
    : block[''previous_hash''],*                *''transactions'' : block[''transactions'']}*    *#
    With an application/json mimetype, return a JSON representation of the supplied
    parameters (Multipurpose Internet Mail Extensions or MIME type).*    *return jsonify(response),
    200**# Getting the blockchain**@app.route(''/get_chain'', methods = [''GET''])**def
    get_chain():*    *# Return the response*    *response = {''chain'' : blockchain.chain,*                *''length''
    : len(blockchain.chain)}*    *return jsonify(response), 200**# Checking if the
    Blockchain is valid**@app.route(''/is_valid'', methods = [''GET''])**def is_valid():*    *is_valid
    = blockchain.is_chain_valid(blockchain.chain)*    *if is_valid:*        *response
    = {''message'': ''Everything is fine. The Blockchain is correct..''}*    *else:*        *response
    = {''message'': ''Weve got an issue. The Blockchain isnt trustworthy..''}*    *return
    jsonify(response), 200**# Adding a new transaction to the blockchain**@app.route(''/add_transaction'',
    methods = [''POST''])**def add_transaction():*    *# We''re sending the transactions
    to Postman in json format, thus we''ll get them back in json format.*    *json
    = request.get_json()*    *# checking if it contains all of the keys*    *transaction_keys
    = [''sender'', ''receiver'', ''amount'']*    *if not all(key in json for key in
    transaction_keys):*        *return ''Some elements of the transactions are missing'',
    400*    *# We will add the transaction and return the answer as added if it has
    all of the components.*    *index = blockchain.add_transaction(json[''sender''],json[''receiver''],json[''amount''])*    *response
    = {''message'' : fThis transaction will be added to the Block {index}''}*    *return
    jsonify(response), 201**# Our blockchain is becoming more decentralized.**#Connecting
    new nodes**@app.route(''/connect_node'', methods = [''POST''])**def connect_node():*    *#
    connecting all of the other nodes manually*    *json = request.get_json()*    *nodes
    = json.get(''nodes'')*    *# return none if node field is null*    *if nodes is
    None:*        *return ''No node'', 400**# We''ll manually add the nodes. This
    is repeated for each node.**# Because our nodes are a set, it will only include
    unique values if done separately for each node.*    *for node in nodes:*        *blockchain.add_node(node)*    *#
    show the nodes and mark the answer as all connected*    *response = {''message''
    : ''All of the nodes are now linked together. The node has now been added to the
    Bitcoin blockchain.'',*                *''total_nodes'' : list(blockchain.nodes)}*    *#
    http 201 created*    *return jsonify(response), 201**# Replacing the chain by
    the longest chain**@app.route(''/replace_chain'', methods = [''GET''])**def replace_chain():*    *#
    If any chain is longer, the longest chain will be displayed instead, otherwise
    the same chain will be displayed.*    *is_chain_replaced = blockchain.replace_chain()*    *if
    is_chain_replaced:*        *response = {''message'': ''Because the nodes are different,
    the longest chain is used to replace the chain..'',*                    *''new_chain''
    : blockchain.chain}*    *else:*        *response = {''message'': ''Everything
    is fine. The chain is the most*        *extensive.'', ''new_chain'' : blockchain.chain}*    *return
    jsonify(response), 200**# Running the app on the port**app.run(host = ''0.0.0.0'',
    port = 1001)********************************************************************************Listing
    16-1'
  prefs: []
  type: TYPE_NORMAL
- en: bitcoin.py
  prefs: []
  type: TYPE_NORMAL
- en: The next Python files are bcoin-node-1001.py, bcoin-node-1002.py, and bcoin-node-1003.py.
    These files represent each node (Bitcoins 1001, 1002, and 1003).
  prefs: []
  type: TYPE_NORMAL
- en: 'bcoin-node-1001.py: Has a class called Blockchain which manages nodes in the
    blockchain (or bitcoin node-1001). Additionally, it has functions for creating
    blocks, functions for adding transactions, and functions for validating blocks.
    In addition to this, the main block has GET and POST methods (see Listing [16-2](#PC3)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'bcoin-node-1002.py: Has a class called Blockchain which manages nodes in the
    blockchain (or bitcoin node-1002). Additionally, it has functions for creating
    blocks, functions for adding transactions, and functions for validating blocks.
    In addition to this , the main block has GET and POST methods (see Listing [16-3](#PC4)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'bcoin-node-1003.py: Has a class called Blockchain which manages nodes in the
    blockchain (or bitcoin node-1003). Additionally, it has functions for creating
    blocks, functions for adding transactions, and functions for validating blocks.
    In addition to this, the main block has GET and POST methods (see Listing [16-4](#PC5)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code listings show Python codes for three different Bitcoins.*#
    This is the Python class for Blockchain**class Blockchain:*    *def __init__(self):*        *self.chain=[]*        *self.transactions
    = []*        *self.create_block(proof= 1 , previous_hash=''0'')*        *self.nodes
    = set()**#Function for creating block*    *def create_block(self, proof, previous_hash):*        *block={''index''
    : len(self.chain) + 1,*                *''timestamp'' : str(datetime.datetime.now()),*                *''proof''
    : proof,*                *''previous_hash'' : previous_hash,*                *''transactions''
    : self.transactions}*        *self.transactions = []*        *self.chain.append(block)*        *return
    block*    *def get_previous_block(self):*        *return self.chain[-1]*    *def
    proof_of_work(self,previous_proof):*        *new_proof = 1*        *check_proof
    = False*        *while check_proof is False:*            *hash_operation = hashlib.sha256(str(new_proof**2
    - previous_proof**2).encode()).hexdigest()*            *if hash_operation[:4]==''0000'':*                *check_proof
    =  True*            *else:*                *new_proof +=1*        *return new_proof*    *def
    hash(self,block):*        *encoded_block = json.dumps(block, sort_keys = True).encode()*        *return
    hashlib.sha256(encoded_block).hexdigest()*    *def is_chain_valid(self, block):*        *previous_block
    = self.chain[0]*        *block_index=1*        *while block_index < len(self.chain):*            *block
    = self.chain[block_index]*            *if block[''previous_hash''] != self.hash(previous_block):*                *return
    False*            *previous_proof = previous_block[''proof'']*            *proof
    = block[''proof'']*            *hash_operation = hashlib.sha256(str(proof**2 -
    previous_proof**2).encode()).hexdigest()*            *if hash_operation[:4] !=''0000'':*                *return
    False*            *previous_block=block*            *block_index +=1*        *return
    True**#Function for adding transaction*    *def add_transaction(self, sender,
    receiver, amount):*        *self.transactions.append({''sender'' : sender,*                           *''receiver''
    : receiver,*                           *''amount'' : amount})*        *previous_block
    = self.get_previous_block()*        *return previous_block[''index''] + 1*    *def
    add_node(self,address):*        *parsed_url = urlparse(address)*        *self.nodes.add(parsed_url.netloc)*    *def
    replace_chain(self):*        *network = self.nodes*        *longest_chain = None*        *max_length
    = len(self.chain)*        *for node in network:*            *response = requests.get(f''http://{node}/get_chain'')*            *if
    response.status_code == 200:*                *length = response.json()[''length'']*                *chain
    = response.json()[''chain'']*                *if length > max_length and self.is_chain_valid(chain):*                    *max_length
    = length*                    *longest_chain = chain*        *if longest_chain:*            *self.chain
    = longest_chain*            *return True*        *return False**app = Flask(__name__)**node_address
    = str(uuid4()).replace(''-'', '''')**blockchain=Blockchain()**@app.route(''/mine_block'',
    methods = [''GET''])**def mine_block():*    *previous_block = blockchain.get_previous_block()*    *previous_proof
    = previous_block[''proof'']*    *proof = blockchain.proof_of_work(previous_proof)*    *previous_hash
    = blockchain.hash(previous_block)*    *blockchain.add_transaction(sender = node_address,
    receiver = ''Bharathi'', amount = 1)*    *block = blockchain.create_block(proof,
    previous_hash)*    *response = {''message'' : ''Congrats, you just mined a block!'',*                *''index''
    : block[''index''],*                *''timestamp'' : block[''timestamp''],*                *''proof''
    : block[''proof''],*                *''previous_hash'' : block[''previous_hash''],*                *''transactions''
    : block[''transactions'']}*    *return jsonify(response), 200**#Get method for
    blockchain**@app.route(''/get_chain'', methods = [''GET''])**def get_chain():*    *response
    = {''chain'' : blockchain.chain,*                *''length'' : len(blockchain.chain)}*    *return
    jsonify(response), 200* *#Validate method for blockchain**@app.route(''/is_valid'',
    methods = [''GET''])**def is_valid():*    *is_valid = blockchain.is_chain_valid(blockchain.chain)*    *if
    is_valid:*        *response = {''message'': ''Everything is fine. The Blockchain
    is correct.''}*    *else:*        *response = {''message'': ''Weve got an issue.
    The Blockchain isnt trustworthy..''}*    *return jsonify(response), 200* *#POST
    method for blockchain**@app.route(''/add_transaction'', methods = [''POST''])**def
    add_transaction():*    *json = request.get_json()*    *transaction_keys = [''sender'',
    ''receiver'', ''amount'']*    *if not all(key in json for key in transaction_keys):*        *return
    ''Some transactional components are missing.'', 400*    *index = blockchain.add_transaction(json[''sender''],json[''receiver''],json[''amount''])*    *response
    = {''message'' : This transaction will be added to the Block {index}''}*    *return
    jsonify(response), 201* *#Connect to the node**@app.route(''/connect_node'', methods
    = [''POST''])**def connect_node():*    *json = request.get_json()*    *nodes =
    json.get(''nodes'')*    *if nodes is None:*        *return ''No node'', 400*    *for
    node in nodes:*        *blockchain.add_node(node)*    *response = {''message''
    : ''All of the nodes are now linked together. The node has now been added to the
    Bitcoin blockchain'',*                *''total_nodes'' : list(blockchain.nodes)}*    *return
    jsonify(response), 201* *#method for changing mode**@app.route(''/replace_chain'',
    methods = [''GET''])**def replace_chain():*    *is_chain_replaced = blockchain.replace_chain()*    *if
    is_chain_replaced:*        *response = {''message'': ''Because the nodes are different,
    the longest chain is used to replace the chain..'',*                    *''new_chain''
    : blockchain.chain}*    *else:*        *response = {''message'': ''Everything
    is fine. The Blockchain is correct.*        *The chain is the longest one'',''new_chain''
    : blockchain.chain}*    *return jsonify(response), 200**app.run(host = ''0.0.0.0'',
    port = 1001)***********************************************************Listing
    16-2'
  prefs: []
  type: TYPE_NORMAL
- en: bcoin-node-1001.py
  prefs: []
  type: TYPE_NORMAL
- en: '*class Blockchain:*    *def __init__(self):*        *self.chain=[]*        *self.transactions
    = []*        *self.create_block(proof= 1 , previous_hash=''0'')*        *self.nodes
    = set()*    *def create_block(self, proof, previous_hash):*        *block={''index''
    : len(self.chain) + 1,*                *''timestamp'' : str(datetime.datetime.now()),*                *''proof''
    : proof,*                *''previous_hash'' : previous_hash,*                *''transactions''
    : self.transactions}*        *self.transactions = []*        *self.chain.append(block)*        *return
    block*    *def get_previous_block(self):*        *return self.chain[-1]*    *def
    proof_of_work(self,previous_proof):*        *new_proof = 1*        *check_proof
    = False*        *while check_proof is False:*            *hash_operation = hashlib.sha256(str(new_proof**2
    - previous_proof**2).encode()).hexdigest()*            *if hash_operation[:4]==''0000'':*                *check_proof
    =  True*            *else:*                *new_proof +=1*        *return new_proof*    *def
    hash(self,block):*        *encoded_block = json.dumps(block, sort_keys = True).encode()*        *return
    hashlib.sha256(encoded_block).hexdigest()*    *def is_chain_valid(self, block):*        *previous_block
    = self.chain[0]*        *block_index=1*        *while block_index < len(self.chain):*            *block
    = self.chain[block_index]*            *if block[''previous_hash''] != self.hash(previous_block):*                *return
    False*            *previous_proof = previous_block[''proof'']*            *proof
    = block[''proof'']*            *hash_operation = hashlib.sha256(str(proof**2 -
    previous_proof**2).encode()).hexdigest()*            *if hash_operation[:4] !=''0000'':*                *return
    False*            *previous_block=block*            *block_index +=1*        *return
    True*    *def add_transaction(self, sender, receiver, amount):*        *self.transactions.append({''sender''
    : sender,*                           *''receiver'' : receiver,*                           *''amount''
    : amount})*        *previous_block = self.get_previous_block()*        *return
    previous_block[''index''] + 1*    *def add_node(self,address):*        *parsed_url
    = urlparse(address)*        *self.nodes.add(parsed_url.netloc)*    *def replace_chain(self):*        *network
    = self.nodes*        *longest_chain = None*        *max_length = len(self.chain)*        *for
    node in network:*            *response = requests.get(f''http://{node}/get_chain'')*            *if
    response.status_code == 200:*                *length = response.json()[''length'']*                *chain
    = response.json()[''chain'']*                *if length > max_length and self.is_chain_valid(chain):*                    *max_length
    = length*                    *longest_chain = chain*        *if longest_chain:*            *self.chain
    = longest_chain*            *return True*        *return False**app = Flask(__name__)**node_address
    = str(uuid4()).replace(''-'', '''')**blockchain=Blockchain()**@app.route(''/mine_block'',
    methods = [''GET''])**def mine_block():*    *previous_block = blockchain.get_previous_block()*    *previous_proof
    = previous_block[''proof'']*    *proof = blockchain.proof_of_work(previous_proof)*    *previous_hash
    = blockchain.hash(previous_block)*    *blockchain.add_transaction(sender = node_address,
    receiver = ''Meghna'', amount = 1)*    *block = blockchain.create_block(proof,
    previous_hash)*    *response = {''message'' : ''Youve just mined a block, so congrats!'',*                *''index''
    : block[''index''],*                *''timestamp'' : block[''timestamp''],*                *''proof''
    : block[''proof''],*                *''previous_hash'' : block[''previous_hash''],*                *''transactions''
    : block[''transactions'']}*    *return jsonify(response), 200**@app.route(''/get_chain'',
    methods = [''GET''])**def get_chain():*    *response = {''chain'' : blockchain.chain,*                *''length''
    : len(blockchain.chain)}*    *return jsonify(response), 200**@app.route(''/is_valid'',
    methods = [''GET''])**def is_valid():*    *is_valid = blockchain.is_chain_valid(blockchain.chain)*    *if
    is_valid:*        *response = {''message'': ''Everything is fine. The Blockchain
    is correct..''}*    *else:*        *response = {''message'': ''We ve got an issue.
    The Blockchain isnt trustworthy..''}*    *return jsonify(response), 200**@app.route(''/add_transaction'',
    methods = [''POST''])**def add_transaction():*    *json = request.get_json()*    *transaction_keys
    = [''sender'', ''receiver'', ''amount'']*    *if not all(key in json for key in
    transaction_keys):*        *return ''Some transactional components are missing.'',
    400*    *index = blockchain.add_transaction(json[''sender''],json[''receiver''],json[''amount''])*    *response
    = {''message'' : f''This transaction will be added to the Block {index}''}*    *return
    jsonify(response), 201**@app.route(''/connect_node'', methods = [''POST''])**def
    connect_node():*    *json = request.get_json()*    *nodes = json.get(''nodes'')*    *if
    nodes is None:*        *return ''No node'', 400*    *for node in nodes:*        *blockchain.add_node(node)*    *response
    = {''message'' : ''All of the nodes are now linked together. The node has now
    been added to the Bitcoin blockchain.'',*                *''total_nodes'' : list(blockchain.nodes)}*    *return
    jsonify(response), 201**@app.route(''/replace_chain'', methods = [''GET''])**def
    replace_chain():*    *is_chain_replaced = blockchain.replace_chain()*    *if is_chain_replaced:*        *response
    = {''message'': ''Because the nodes are different, the longest chain is used to
    replace the chain..'',*                    *''new_chain'' : blockchain.chain}*    *else:*        *response
    = {''message'': ''Everything seems to be fine. It is the most extensive chain.'',*                    *''new_chain''
    : blockchain.chain}*    *return jsonify(response), 200**app.run(host = ''0.0.0.0'',
    port = 1002)*Listing 16-3'
  prefs: []
  type: TYPE_NORMAL
- en: bcoin-node-1002.py
  prefs: []
  type: TYPE_NORMAL
- en: '*class Blockchain:*    *def __init__(self):*        *self.chain=[]*        *self.transactions
    = []*        *self.create_block(proof= 1 , previous_hash=''0'')*        *self.nodes
    = set()*    *def create_block(self, proof, previous_hash):*        *block={''index''
    : len(self.chain) + 1,*                *''timestamp'' : str(datetime.datetime.now()),*                *''proof''
    : proof,*                *''previous_hash'' : previous_hash,*                *''transactions''
    : self.transactions}*        *self.transactions = []*        *self.chain.append(block)*        *return
    block*    *def get_previous_block(self):*        *return self.chain[-1]*    *def
    proof_of_work(self,previous_proof):*        *new_proof = 1*        *check_proof
    = False*        *while check_proof is False:*            *hash_operation = hashlib.sha256(str(new_proof**2
    - previous_proof**2).encode()).hexdigest()*            *if hash_operation[:4]==''0000'':*                *check_proof
    =  True*            *else:*                *new_proof +=1*        *return new_proof*    *def
    hash(self,block):*        *encoded_block = json.dumps(block, sort_keys = True).encode()*        *return
    hashlib.sha256(encoded_block).hexdigest()*    *def is_chain_valid(self, block):*        *previous_block
    = self.chain[0]*        *block_index=1*        *while block_index < len(self.chain):*            *block
    = self.chain[block_index]*            *if block[''previous_hash''] != self.hash(previous_block):*                *return
    False*            *previous_proof = previous_block[''proof'']*            *proof
    = block[''proof'']*            *hash_operation = hashlib.sha256(str(proof**2 -
    previous_proof**2).encode()).hexdigest()*            *if hash_operation[:4] !=''0000'':*                *return
    False*            *previous_block=block*            *block_index +=1*        *return
    True*    *def add_transaction(self, sender, receiver, amount):*        *self.transactions.append({''sender''
    : sender,*                           *''receiver'' : receiver,*                           *''amount''
    : amount})*        *previous_block = self.get_previous_block()*        *return
    previous_block[''index''] + 1*    *def add_node(self,address):*        *parsed_url
    = urlparse(address)*        *self.nodes.add(parsed_url.netloc)*    *def replace_chain(self):*        *network
    = self.nodes*        *longest_chain = None*        *max_length = len(self.chain)*        *for
    node in network:*            *response = requests.get(f''http://{node}/get_chain'')*            *if
    response.status_code == 200:*                *length = response.json()[''length'']*                *chain
    = response.json()[''chain'']*                *if length > max_length and self.is_chain_valid(chain):*                    *max_length
    = length*                    *longest_chain = chain*        *if longest_chain:*            *self.chain
    = longest_chain*            *return True*        *return False**app = Flask(__name__)**node_address
    = str(uuid4()).replace(''-'', '''')**blockchain=Blockchain()**@app.route(''/mine_block'',
    methods = [''GET''])**def mine_block():*    *previous_block = blockchain.get_previous_block()*    *previous_proof
    = previous_block[''proof'']*    *proof = blockchain.proof_of_work(previous_proof)*    *previous_hash
    = blockchain.hash(previous_block)*    *blockchain.add_transaction(sender = node_address,
    receiver = ''Meghna'', amount = 1)*    *block = blockchain.create_block(proof,
    previous_hash)*    *response = {''message'' : ''You just mined a block, congrats!!'',*                *''index''
    : block[''index''],*                *''timestamp'' : block[''timestamp''],*                *''proof''
    : block[''proof''],*                *''previous_hash'' : block[''previous_hash''],*                *''transactions''
    : block[''transactions'']}*    *return jsonify(response), 200**@app.route(''/get_chain'',
    methods = [''GET''])**def get_chain():*    *response = {''chain'' : blockchain.chain,*                *''length''
    : len(blockchain.chain)}*    *return jsonify(response), 200**@app.route(''/is_valid'',
    methods = [''GET''])**def is_valid():*    *is_valid = blockchain.is_chain_valid(blockchain.chain)*    *if
    is_valid:*        *response = {''message'': ''Everything is fine. The Blockchain
    is correct.''}*    *else:*        *response = {''message'': ''We ve got an issue.
    The Blockchain isnt trustworthy..''}*    *return jsonify(response), 200**@app.route(''/add_transaction'',
    methods = [''POST''])**def add_transaction():*    *json = request.get_json()*    *transaction_keys
    = [''sender'', ''receiver'', ''amount'']*    *if not all(key in json for key in
    transaction_keys):*        *return ''Some elements of the transactions are missing'',
    400*    *index = blockchain.add_transaction(json[''sender''],json[''receiver''],json[''amount''])*    *response
    = {''message'' : f''This transaction will be added to the Block {index}''}*    *return
    jsonify(response), 201**@app.route(''/connect_node'', methods = [''POST''])**def
    connect_node():*    *json = request.get_json()*    *nodes = json.get(''nodes'')*    *if
    nodes is None:*        *return ''No node'', 400*    *for node in nodes:*        *blockchain.add_node(node)*    *response
    = {''message'' : ''All of the nodes are now linked together. The node has now
    been added to the Bcoin blockchain.'',*                *''total_nodes'' : list(blockchain.nodes)}*    *return
    jsonify(response), 201**@app.route(''/replace_chain'', methods = [''GET''])**def
    replace_chain():*    *is_chain_replaced = blockchain.replace_chain()*    *if is_chain_replaced:*        *response
    = {''message'': ''Because the nodes are different, the longest chain is used to
    replace the chain..'',*                    *''new_chain'' : blockchain.chain}*    *else:*        *response
    = {''message'': ''Everything is fine. The chain is the most extensive.'',*                    *''new_chain''
    : blockchain.chain}*    *return jsonify(response), 200**app.run(host = ''0.0.0.0'',
    port = 1003)****************************************************************************Listing
    16-4'
  prefs: []
  type: TYPE_NORMAL
- en: bcoin-node-1003.py
  prefs: []
  type: TYPE_NORMAL
- en: 'Example node addresses (nodes.json in Listing [16-5](#PC6)) and transaction
    formats are shown in the .json files (transaction.json in Listing [16-6](#PC7)).{    "nodes"
    : ["http://127.0.0.1:1001",               "http://127.0.0.1:1002",               "http://127.0.0.1:1003"]}***************************************************************************Listing
    16-5'
  prefs: []
  type: TYPE_NORMAL
- en: nodes.json
  prefs: []
  type: TYPE_NORMAL
- en: To add a transaction, copy the contents from transaction.json and POST it in
    the JSON format to http://127.0.0.1:1001/add_transaction in Postman, as shown
    in Listing [16-6](#PC7).-Listing 16-6
  prefs: []
  type: TYPE_NORMAL
- en: transaction.json
  prefs: []
  type: TYPE_NORMAL
- en: '![../images/520777_1_En_16_Chapter/520777_1_En_16_Figa_HTML.jpg](../images/520777_1_En_16_Chapter/520777_1_En_16_Figa_HTML.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*****************************************************************************************************'
  prefs: []
  type: TYPE_NORMAL
- en: 16.8.2 Changing the Blockchain into Cryptocurrency
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To change the blockchain into cryptocurrency, follow these steps. First you
    have to add a transaction:*self.transactions = [] transaction to be created before****self.create_block
    Function******Then ; add_transaction(self, sender, receiver, amount)***Now you
    create a consensus:self.nodes = set()    **this is for init method**add_node(self,
    address)   **add node method for adding a new node**replace_chain(self)   **replace
    chain with long one**Now you have to decentralize the blockchain and apply consensus
    and transaction to it. In this sample coin, there are three nodes. They utilize
    the following addresses and ports listed (Flask):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Node 1: http://127.0.0.1:1001/'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Node 2: http://127.0.0.1:1002/'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Node 3: http://127.0.0.1:1003/'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To decentralize the Bitcoin network, mine blocks, send transactions, and apply
    consensus, copies of the code (bitcoin.py) have been created:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Node 1: bitcoin_node_1_1001.py'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Node 2: bitcoin_node_2_1002.py'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Node 3: bitcoin_node_3_1003.py'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the application is running on Flask, Postman requests are used to query
    the blockchain, create transactions, and apply a consensus. In this case, port
    1001 was utilized (Node 1).
  prefs: []
  type: TYPE_NORMAL
- en: 16.8.3 GET
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Get chain: [http://127.0.0.1:1001/get_chain](http://127.0.0.1:5001/get_chain)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Mine block: [http://127.0.0.1:1001/mine_block](http://127.0.0.1:5001/mine_block)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace chain: [http://127.0.0.1:1001/replace_chain](http://127.0.0.1:5001/replace_chain)'
  prefs: []
  type: TYPE_NORMAL
- en: 16.8.4 POST
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Add transaction: [http://127.0.0.1:1001/add_transaction](http://127.0.0.1:5001/add_transaction)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Connect node: [http://127.0.0.1:1001/connect_node](http://127.0.0.1:5001/connect_node)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Source code: [https://github.com/JosephThachilGeorge/Bitcoin](https://github.com/JosephThachilGeorge/Bitcoin)'
  prefs: []
  type: TYPE_NORMAL
- en: By looking at this project, you have come to know the concept of Bitcoin and
    how to mine it. So the question is, who are the miners?
  prefs: []
  type: TYPE_NORMAL
- en: 16.9 Functions of the Nodes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Bitcoin network is formed of nodes, that is, computers in communication
    with each other, thanks to Bitcoin’s open source software.
  prefs: []
  type: TYPE_NORMAL
- en: 'Nodes can have different functions: some nodes validate the regularity of transactions
    and other nodes propagate transactions to other nodes. The nodes of interest in
    this article are called “miners” and they create the chain of blocks, called blockchain,
    where all transactions are forever recorded.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s see what miners do. Mining nodes are owned by private citizens or
    companies that invest huge resources to solve a mathematical problem that can
    only be solved by trial and error. Anyone can mine Bitcoin money; let’s see what
    you need to have:'
  prefs: []
  type: TYPE_NORMAL
- en: For mining, you need specialized equipment; often, video cards for video games
    would suffice. However, there are now powerful processors (ASICS) developed to
    calculate the SHA-256 equation of Bitcoin to enhance the odds of winning.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second condition is to generate or purchase a large amount of electricity
    to power computers and associated cooling equipment; in fact, mining these machines
    heats up the surroundings and you must maintain an ideal temperature to maintain
    the machine’s physical integrity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next stage is to plan out how many hours will be needed to run the mining
    farm. Personnel working at Bitcoin mines are also responsible for the upkeep and
    replacement of machines, which, when used to their full computing capability,
    rapidly fail.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of this while competing with other miners.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the operations begin, your calculators do nothing but compute the same
    equation (SHA-256) over and over again, taking data from the Bitcoin network as
    input, and then trying to add a new number to the equation to see whether the
    output matches the protocol’s requirements. The result is a hexadecimal number
    of this type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![../images/520777_1_En_16_Chapter/520777_1_En_16_Figb_HTML.jpg](../images/520777_1_En_16_Chapter/520777_1_En_16_Figb_HTML.jpg)'
  prefs: []
  type: TYPE_IMG
- en: On first try, the mining machine inserts the number 1 into the SHA-256 equation
    and checks the output to see how many zeros are in front of the number. It recalculates
    SHA-256 using the same set of transactions on the second try and adds the number
    2\. On the third attempt it adds the number 3, and so on, until it obtains a number
    that starts with zeros. The outcome is completely random. These are huge numbers;
    in reality, every 10 minutes or so, one of the computers across the world discovers
    the exact number of zeros required by the protocol at that time.
  prefs: []
  type: TYPE_NORMAL
- en: When a miner discovers a viable solution, the entire computer network is vulnerable
    to transaction blockage. Because the conclusion is mathematically repeatable and
    verifiable, all miners can check it quickly and simply. The transactions included
    inside the mined block are 100% legitimate and may be added to the block chain.
  prefs: []
  type: TYPE_NORMAL
- en: The miner is a node or a user who has installed Bitcoin on their computer, but
    in addition to validating and propagating transactions, the miner also bears the
    responsibility of expending energy to solve the mathematical challenge that underpins
    the authorization to write in blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: These specific nodes make accessible energy resources in order to earn the prize
    while also ensuring that the system is protected against double spending in the
    absence of a centralized coordinator.
  prefs: []
  type: TYPE_NORMAL
- en: 16.9.1 Create a New Candidate Block by Combining Valid Transactions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The nearest nodes instantly check if you have the funds to spend once you send
    your transaction. The transaction is queued to be executed by the miners if this
    verification passes. The transaction is collected by a miner, who then combines
    it with other transactions in the ether to form a candidate block of transactions
    to be added to the blockchain. The miner’s job at this stage is to calculate the
    number that begins with 0.
  prefs: []
  type: TYPE_NORMAL
- en: 16.9.2 Computing Power on the Defensive Wall (Hash Rate)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because the amount of hash power (computing power) brought into the system is
    fully committed to ensuring that there are no fraudulent transactions, even miners
    who do not win the Bitcoins in the last block have contributed to Bitcoin’s security.
    This protective wall defends against double spending as well as intruders attempting
    to tamper with the blockchain’s facts.
  prefs: []
  type: TYPE_NORMAL
- en: Each miner can theoretically have a distinct set of transactions, and the first
    miner to discover a solution using the transactions they select gets to add their
    candidate block to the blockchain. When the network has agreed on which is the
    last valid block, the race starts to find the next block.
  prefs: []
  type: TYPE_NORMAL
- en: When the system’s processing capacity is good enough that valid blocks are discovered
    in fewer than 10 minutes, the mathematical puzzle’s complexity is increased by
    increasing the number of zeros in front of the solution to be found. While the
    system facilitates the solution by requiring miners to find a number with fewer
    zeros in front if the system’s computing power is insufficient and requires that
    new blocks are only found every 15 minutes, the system facilitates the solution
    by requiring miners to find a number with fewer zeros in front if the system’s
    computing power is insufficient.
  prefs: []
  type: TYPE_NORMAL
- en: This technique adapts to the difficulty dependent on the system’s computational
    capacity. As a result, as computer power declines, discovering Bitcoin is simpler,
    and more people will be motivated to mine, keeping the system afloat. When mining
    Bitcoin gets too difficult; however, only the most efficient miners remain on
    the market. This indicates that when the price of Bitcoin rises, hash power rises
    as well—more value, more computer power, and greater security.
  prefs: []
  type: TYPE_NORMAL
- en: 16.10 Creating New Bitcoins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Bitcoin is a currency, and contributing to its creation and upkeep allows you
    to earn Bitcoin in exchange for your efforts. Every four years, the compensation
    for blocks is halved. After ten years of unbroken activity, we are at 6.25 Bitcoins
    every 10 minutes. Aside from the Bitcoin prize, a successful miner also receives
    any commissions associated with the individual transactions.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the quantity of new Bitcoins continues to decrease; at the time
    of writing, the total number of Bitcoins produced since 2009 is about 18 million.
  prefs: []
  type: TYPE_NORMAL
- en: Continuing the mathematical series, around the year 2140, 21 million Bitcoins
    will have been mined.
  prefs: []
  type: TYPE_NORMAL
- en: 16.10.1 The Concept of Decentralization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Miners are components, nodes of the network, with the special duty of producing
    blockchain blocks and releasing new Bitcoins, ensuring security against double
    spending attempts.
  prefs: []
  type: TYPE_NORMAL
- en: The notion of decentralization  , or, to put it another way, the fact that you
    don’t need a central coordinator to verify that all parties behave correctly,
    is perhaps one of Bitcoin’s most revolutionary features.
  prefs: []
  type: TYPE_NORMAL
- en: How does Bitcoin’s decentralized coordination work? The answer is “proof of
    work,” a new approach for reaching an agreement on the state of balances. The
    job entails gathering transactions, generating candidate blocks, and computing
    hash with zeros in front, as stated. Proof of work is nothing more than a cunning
    ruse to compel the system to coordinate every 10 minutes on the status of Bitcoin
    balances.
  prefs: []
  type: TYPE_NORMAL
- en: The incentive mechanism draws new miners who are ready to spend resources to
    discover Bitcoin, and none of the participants in the game are interested in acting
    against the Bitcoin network’s interests.
  prefs: []
  type: TYPE_NORMAL
- en: Miners make significant investments in order to earn Bitcoins, and they will
    never attempt to compromise the protocol’s resilience because doing so would result
    in them losing the whole worth of the Bitcoins in their possession. Miners seldom
    sell their Bitcoins for less than the cost of manufacturing. This means that Bitcoin
    has a minimum price, determined by the cost of mining a single Bitcoin successfully.
  prefs: []
  type: TYPE_NORMAL
- en: Miners are honest because deceiving the system costs a lot of money initially;
    it is predicted that rearranging blockchain history to attack the system would
    cost $5 billion. Second, all hacking efforts would be futile since each node has
    the option of accepting or rejecting updates to its blockchain copy. Blocks with
    a double expense will never be accepted by honest nodes. In reality, the attacker
    would be on a blockchain other than the main one, a blockchain that has no value
    since it includes fraudulent data.
  prefs: []
  type: TYPE_NORMAL
- en: 16.11 Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter discussed the future scope of blockchain technology and distributed
    systems and touched on how you can achieve secure transactions using blockchain.
    The B-Coin project showed how Bitcoin works and how you can attain secure transactions
    using the Bitcoin concept.
  prefs: []
  type: TYPE_NORMAL
- en: I am sure that you now understand what Bitcoins are for. The uses of this digital
    currency, in fact, can be multiple and are not only linked to the speculation
    that is made on it. The blockchain method is also particularly interesting for
    its future developments, which could be related to every aspect of our existence.
    Now that you know how Bitcoin works, nothing can stop you in the discovery of
    the cryptocurrency!
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will focus on automated vehicle management systems.
  prefs: []
  type: TYPE_NORMAL
