- en: Chapter 6\. Testing and Maintenance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to the final chapter in [Part III](part03.xhtml#developing_smart_contracts_with_hyperle).
    The life cycle for smart contracts is the same as for other software. Once the
    software is developed, tested, and deployed, our attention transitions to maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many activities are performed to test and maintain software throughout its
    life cycle. These activities are grouped into two broad categories: technical
    and nontechnical. Our concern is with the technical activities that modify the
    software. Under maintenance, the modifications are generally either fixing something
    or adding something new. When bugs are discovered, they need to be corrected,
    so a maintenance task is created to fix the bug. When new features or capabilities
    are demanded, a maintenance task is created to add one or more new features to
    the software. Sometimes significant modifications can result in a release of a
    new version of software. This applies also to the clients of smart contracts.
    These activities continue until the software is retired. The majority of the software
    life cycle is consumed by maintenance. When fixing bugs or adding new features,
    testing is critical to success.'
  prefs: []
  type: TYPE_NORMAL
- en: Throughout the entire life cycle, including both development and maintenance,
    the activity of testing is relied upon to ensure that the software is working
    as expected and meets the functional and nonfunctional requirements. Testing can
    be executed in many ways, and several schools of thought exist on how to approach
    and implement testing. Whichever school you adhere to will work well for smart
    contract development and maintenance. Testing can be formal, not formal, or a
    combination of both. The choice is yours.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is divided into four distinct sections. The first section presents
    a smart contract maintenance task, which adds a web UI to the Fabcar smart contract.
    We provide the code, which gives you a working example of a web UI client application.
    The *fabric-samples* and SDKs do not offer any web UI samples. Instead, command-line
    clients are provided. We provide you with a web UI smart contract client to jumpstart
    your smart contract client development and serve as an example of a smart contract
    maintenance task. With a web UI client, you can perform end-to-end testing of
    your smart contract. Most smart contracts you develop will require one or more
    web UI clients. You test smart contract web UI clients just as you would any other
    web UI client. Testing smart contracts can be slow and difficult, using *test-network*.
    When testing smart contracts, especially prior to system or integration testing,
    you will want a way to iterate quickly as you build out your smart contract API,
    represented by your smart contract functions or transactions.
  prefs: []
  type: TYPE_NORMAL
- en: The second section walks you through a setup for rapidly testing smart contracts.
    This setup has a lot of steps, but delivers a way to rapidly and iteratively test
    smart contracts without the need to launch the test network and go through the
    time-consuming stop-deploy-start development cycle. With the method you will learn
    in this section, testing your smart contract functions is fast and easy. However,
    other system components (such as the peers, orderers, and databases) support your
    smart contract functions, and testing these components can be problematic. You
    will need to access these components’ log files to view and understand their output
    while you test your smart contract functions.
  prefs: []
  type: TYPE_NORMAL
- en: In the third section, you’ll learn about the available logs provided by the
    various components. You can use these logs, provided by Hyperledger Fabric, to
    help support your development, maintenance, and testing activities. In the fourth
    and final section, you’ll learn about unit testing, which is essential for maintaining
    code quality.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will help you achieve the following practical goals:'
  prefs: []
  type: TYPE_NORMAL
- en: Handling errors and processing responses in Fabric applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing and debugging a Fabric smart contract
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running unit tests on Fabric smart contracts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Following best practices for identifying and reviewing logs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Fabcar UI Client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Fabcar smart contract has no web UI client, so for an example maintenance
    exercise, we added one. We have already created the client for you by consolidating
    the Fabcar command-line executables into a web UI application client. You can
    download the client code from [*https://myhsts.org/hyperledger-fabric-book/*](https://myhsts.org/hyperledger-fabric-book/).
    Then follow along as we go through the code in this section to show you how easy
    it is to add a web client to a smart contract. Before we dive into the code, let’s
    discuss handling error responses.
  prefs: []
  type: TYPE_NORMAL
- en: Error Response Handling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Fabric can be deployed on premises or to the cloud, or in a hybrid architecture.
    Where Fabric is deployed should not change the expected error or success responses.
    If misconfigurations exist, error responses will be received. We will see some
    error and success responses later in this section.
  prefs: []
  type: TYPE_NORMAL
- en: The same best practices for handling error and success responses in web and
    software development should be practiced. Catch your errors, augment them with
    additional information if available, and present the error or response to the
    user in a readable and understandable format. Errors should be logged for analysis
    and correction.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the error handling for smart contracts is transparent and encapsulated
    in the SDKs and middleware that together form a cohesive distributed network and
    application architecture. This distributed architecture can be constructed with
    virtual technology like Docker, which provides flexibility in designing, operating,
    and managing the application and the way the responses behave. Fabric provides
    a virtualized architecture and operating environment suitable for developing smart
    contracts on a single laptop, cloud environment, or custom environment. The approach
    you choose and the tools you decide to use will vary with your personal preferences
    and provided resources, but the expected responses should be consistent across
    all environments.
  prefs: []
  type: TYPE_NORMAL
- en: We used JavaScript and Node.js to implement the web UI application, which we
    named *fabcar-ui*. Regardless of the client framework, responses will be the same
    across SDKs. The language selected for the smart contract development is independent
    from the language selected for the smart contract client and should not change
    the responses.
  prefs: []
  type: TYPE_NORMAL
- en: By designing enterprise application APIs, we can establish contract interfaces
    between our smart contracts and clients, providing a blueprint for what responses
    should look like and how to handle error responses. We can even extend this effort
    to the design of smart contract–specific APIs packaged into application libraries
    to be used by new and existing enterprise applications defining the expected error
    and success responses. This makes maintenance and testing much easier, consistent,
    and repeatable. This type of standardization supports the ability to extend the
    smart contract response to existing applications as well.
  prefs: []
  type: TYPE_NORMAL
- en: Fabcar UI Web Pages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The interface of the Fabcar UI is focused on simplicity. It takes the Fabcar
    smart contract client application executables and wraps them in a web GUI. We
    did not want to change any of the functional code and wanted to keep the separation
    of the executable’s function. We wanted to end up with a simple web app that you
    can extend, experiment with, and potentially use as a test harness, as well as
    provide you with an example of a simple smart contract web application.
  prefs: []
  type: TYPE_NORMAL
- en: With Node.js as our client platform, we selected the popular and easy-to-use
    Express framework. Express makes it easy to create small web applications. For
    a production application, frameworks like Angular, React, or Vue.js will work
    too. Applications can leverage the smart contract service via an enterprise published
    API. This allows for controlled maintenance and testing to ensure quality control.
    Let’s take a look at the Fabcar UI web pages. [Figure 6-1](#fabcar_ui_main_page)
    shows the main page.
  prefs: []
  type: TYPE_NORMAL
- en: '![Fabcar UI main page](Images/HLF_0601.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-1\. Fabcar UI main page
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This simple web page displays the application menu and instructions for using
    the Fabcar UI. Looking at the menu bar, you can see a menu item for each of the
    Fabcar smart contract command-line applications we explored in [Chapter 5](ch05.xhtml#smart_contract_invocation).
  prefs: []
  type: TYPE_NORMAL
- en: On the far right is a menu item labeled API. We called it API to be generic,
    because it loads a page for calling our new smart contract function, `callApi`.
    We will implement this new function in a bit, but before we do, we will use the
    Fabcar UI to call the nonexistent function and see the error response returned.
    Then we will implement it and see the successful response.
  prefs: []
  type: TYPE_NORMAL
- en: Reading the instructions displayed on the main page, you can see that the Fabcar
    smart contract sequence of execution is retained and mandatory, as it was in the
    command-line version. The goal of the Fabcar UI web app is to mirror the command-line
    app, but with a web UI, and keep it simple, so the separation between the web
    application code and the code specific to the Fabcar smart contract is clean.
    This design facilitates the ability to quickly iterate and add new functions and
    features, potentially becoming a test harness.
  prefs: []
  type: TYPE_NORMAL
- en: 'The UI interface of *fabcar-ui* is responsive and will work on any device capable
    of running a modern browser. All of the web pages are designed with the same layout:
    a menu, a button, and text display for instructions and responses. The responses
    are displayed in text without any formatting. Let’s review each page, starting
    with Enroll Admin. We will not display all the pages because they are similar.'
  prefs: []
  type: TYPE_NORMAL
- en: Enroll Admin
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We add the Enroll Admin page to our *fabcar-ui*. Clicking the Enroll Admin button
    will execute the `enroll` transaction request. The other pages—Register User,
    Invoke, Query, and API—look and function similar to the Enroll Admin page.
  prefs: []
  type: TYPE_NORMAL
- en: Register User
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Register User page functions like the Enroll Admin page. Clicking the Register
    User button executes the `register` function, which uses `Admin` to register the
    user. This is why we need to execute the Enroll Admin page first. Here is the
    successful response displayed after clicking the button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Invoke
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now with the `Admin` and `User` identities in the `wallet`, we can execute the
    `invoke` and `query` functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we click the Invoke button, we execute the `invoke` request. This request
    will call the Fabcar smart contract `invoke` transaction. This transaction adds
    a record to the ledger. Here is the successful response displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `invoke` function can be executed multiple times.
  prefs: []
  type: TYPE_NORMAL
- en: Query
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Query page will display the records from the ledger, which contain the records
    added by `invoke`. Clicking the Query button will display the records.
  prefs: []
  type: TYPE_NORMAL
- en: The `invoke` function on the client side generates a random number and appends
    it to the string `CAR0.`, so we can exercise the `invoke` transaction multiple
    times and see a unique response.
  prefs: []
  type: TYPE_NORMAL
- en: API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The final page is the API page. It too has a button and displays a text response.
    When the button is clicked, the `callApi` request is executed, which calls the
    `callApi` smart contract transaction. We have not added the `callApi` transaction
    to the Fabcar smart contract, so we will get an error response when we click the
    API button.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have looked at the web pages of the Fabcar UI web application, let’s
    review the code.
  prefs: []
  type: TYPE_NORMAL
- en: Fabcar UI Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We won’t review all the code in detail because we covered the smart contract–related
    code in [Chapter 5](ch05.xhtml#smart_contract_invocation). What we want to focus
    on is the new code, so you can modify or extend it to learn or for your own purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'We developed the Fabcar UI web application with Node.js, Express, and Jade,
    a templating tool. The main file is *app.js*, which is executed with Node.js like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This starts up a web server and listens on localhost and port 3000\. Once it’s
    started, you can open a browser and go to *http://localhost:3000* to display the
    Fabcar UI main page. The main file, *app.js*, contains the Express setup, the
    application `views`, which are the pages we reviewed, and the `actions`, which
    are executed by the buttons. The buttons call the `actions`, and the `actions`
    map to `handlers` that execute the smart contract client code. Let’s take a look
    at *app.js*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code begins by importing the `handlers—`one for each function. Each function
    is the code from the Fabcar client command-line version. Following the imports,
    we set up Express to point to our `views` that represent our pages and to our
    public directory that contains public resources like Bootstrap and CSS files.
    Here is the code that loads the `handlers` and sets up Express:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we have the `views`. With Express, one easy way to handle requests is
    to map them to a `view` and then render the `view` when the request is received.
    We implemented our `views` in a templating language called Jade. It’s a simple
    text-based markup language to simplify and reduce the verbosity of HTML. The page
    is responsive and uses Bootstrap with CSS to facilitate our visual style and menu.
    Here is the code that maps a request to a view that is rendered as a web page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'After the `views`, we mapped the `actions` by using the same simple design
    pattern. The `actions` call the `handlers`, which encapsulate the code from the
    command-line Fabcar smart contract client. These `actions` carry out an asynchronous
    design pattern. The request is received from the `view` when a user clicks a view
    button and then calls the smart contract and renders the response from the smart
    contract. Here is the code implementing the actions, which call the smart contract
    and render the response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The *app.js* code ends by setting the port for the server to listen on, printing
    a message to the console, and exiting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: A `view` file is displayed when a page request is received. The view is rendered,
    and when a button is clicked, a request for an `action` is sent by the page and
    received by *app.js*, where it is processed by one of the `handler` files. The
    `handler` files encapsulate the code from the command-line Fabcar smart contract
    client.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the `view` files use the same code template as shown here but vary their
    data where appropriate (for example, in `h1` or `href`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: When a `view` button is clicked, the `action` is called. The link is mapped
    in the *app.js* file to a `handler` that implements the `action`, which is one
    of the functions the command-line Fabcar smart contract client executed. Each
    executable has been taken from the Fabcar smart contract command-line client and
    refactored to a Node.js module, which can be imported and provides functions to
    call.
  prefs: []
  type: TYPE_NORMAL
- en: The same techniques were used for each handler. The main function was replaced
    and refactored to a module. This provides the module name as a reference to this
    function, which is called in *app.js* when the request is received as a result
    of clicking the button in the view. A variable was added, called `result`, to
    hold the response returned to the client.
  prefs: []
  type: TYPE_NORMAL
- en: We set the `result` variable with the success response we will return to the
    client. We commented out `process.exit(1)`, because we don’t want to exit the
    process, which is our web server. Then we set an error response to return to the
    client when an error occurs. Lastly, we replace the `main` function with the return
    `result`. Now the executable is a Node.js module that we can import to call the
    function. We performed these tasks for all executables, turning each into a module.
    This was easy because the executables were self-contained and independent.
  prefs: []
  type: TYPE_NORMAL
- en: 'This completes the code review portion. The separation of functions is clean.
    The handlers are where the smart contract–related code is implemented. These could
    be mocked and developed independently of the smart contract. As with the command-line
    Fabcar smart contract client, the *package.json* file contains the two Fabric
    SDK dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The *wallet* subdirectory works the same as it does in the command-line Fabcar
    smart contract client. When you execute `Enroll Admin,` an `Admin` identity is
    created and placed in the *wallet* subdirectory. When you execute `Register User`,
    an `appUser` identity is created and placed in the *wallet* subdirectory. Each
    time you start the test network, you must ensure that these identities are removed
    from the *wallet* subdirectory. If either identity is found, the client will print
    an error response to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This completes our coverage of Fabcar UI web pages and code. Now let’s execute
    *fabcar-ui* and look at responses we can receive.
  prefs: []
  type: TYPE_NORMAL
- en: Fabcar UI Execution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you have a test network up, we want to shut it down for this task. To shut
    down the test network, execute *`networkDown.sh`* located in the *fabcar* subdirectory.
    Keep the terminal open, because we will start the test network after looking at
    the error responses we will receive when it’s shut down. Open another terminal,
    go to the *fabcar-ui* subdirectory, and execute this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'When this finishes, execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now open your browser and go to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: You should see the Fabcar UI main page. Click the API menu item and then click
    the API button. You should see the failed response shown in [Figure 6-2](#fabcar_ui_callapi_error_response_page).
  prefs: []
  type: TYPE_NORMAL
- en: '![Fabcar UI callApi error response page](Images/HLF_0602.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-2\. Fabcar UI `callApi` error response page
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In the console, you should see the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This is an indication the test network is not up. Now in the terminal where
    you shut down *test-network*, make sure you are in the *fabcar* client subdirectory
    and start the test network by executing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the test network is up and running, let’s perform the same test: click
    the API menu item and then the API button. [Figure 6-3](#fabcar_ui_failed_enroll_admin_page)
    shows the result.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Fabcar UI failed enroll admin page](Images/HLF_0603.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-3\. Fabcar UI failed `enroll admin` page
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'You should see this in your console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This indicates a problem with the admin identity. We receive this because we
    started a test network that removes all prior artifacts, so the identities we
    have in our client wallet are not valid. Delete the two identities in the Fabcar
    UI *wallet* subdirectory and then execute the Enroll Admin and Register User requests.
    Then try the API request again. [Figure 6-4](#fabcar_ui_page_indicating_callapi_funct)
    shows the response.
  prefs: []
  type: TYPE_NORMAL
- en: '![Fabcar UI page indicating callApi function does not exist](Images/HLF_0604.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-4\. Fabcar UI page indicating `callApi` function does not exist
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In your console, you should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This response indicates that the Fabcar smart contract has no function by the
    name `callApi`.
  prefs: []
  type: TYPE_NORMAL
- en: We need to implement it in the Fabcar smart contract. This is the type of error
    response you will receive when a client calls a transaction that does not exist.
  prefs: []
  type: TYPE_NORMAL
- en: Since we are going to extend the Fabcar smart contract with a new function named
    `callApi`, it would be great if we had a way to quickly test the new function
    without requiring the test network to be stopped and started with each iteration,
    or the need to go through the deployment process discussed in earlier chapters.
    Well, there is a way, and it will allow quick iteration. Several setup steps are
    required, but in the end it is well worth the effort. Let’s get started.
  prefs: []
  type: TYPE_NORMAL
- en: Performing Rapid Smart Contract Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hyperledger Fabric v2 provides the test network. It includes all of the basic
    required components—for example, all Docker files, organization-related configuration,
    and scripts to install and deploy smart contracts. Developers can create applications
    and test smart contracts by using the test network, but using it can be slow.
    In this section, you’ll learn how to create an alternative development environment
    for rapidly testing the smart contract.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, shut down the test network because we will get port conflicts if we do
    not. Remember, you use *`networkdown.sh`* in the *fabcar* client subdirectory
    to shut down the test network. Once it is shut down, create a new directory in
    *fabric-samples* called *fabcar-debug* and change to that directory. Then download
    Fabric version 2.3 (or the version you are working with) from [*https://github.com/hyperledger/fabric*](https://github.com/hyperledger/fabric),
    and unzip it and copy it to *fabcar-debug*. All of our commands will be executed
    from this subdirectory, so keep this in mind as we progress through the several
    steps required to set up our smart contract testing and debugging environment.
  prefs: []
  type: TYPE_NORMAL
- en: Start the orderer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'From the subdirectory in *fabcar-debug* that contains the downloaded Fabric
    code, execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'When this command completes, there will be a new *build/bin* subdirectory.
    It contains the binaries we just built. We want to place this subdirectory on
    our path, so execute this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'A sample configuration is provided that we can leverage, so we want to set
    an environment variable so the tools can locate that configuration. Execute this
    command to set the environment variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to generate a genesis block. It will be used by the orderer we
    will start next. To generate the genesis block, execute this command, all on one
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see this at the end of the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we are almost ready to start the orderer. But first, we need to create
    the *hyperledger* subdirectory in the *var* subdirectory. This is a location Fabric
    uses. To create the *hyperledger* subdirectory, execute these commands, replacing
    the question marks with your username:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can start the orderer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'If you get port conflicts, you can execute this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This will list the TCP ports in use. The two ports you may have conflicts with
    are 8443 and 9443\. If you do, just change the port in conflict to 19443 or 18443
    in the *orderer.yaml* file located in the *sampleconfig* subdirectory. Look for
    `ListenAddress` in the `Operations` and `Admin` sections of the file to find the
    port. With the orderer running, it’s time to start our peer.
  prefs: []
  type: TYPE_NORMAL
- en: Start the peer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We need to start our peer in another terminal. Open another terminal and change
    to the Fabric subdirectory we are working in. Just as with the orderer, we need
    to set up our environment, so execute the commands to set the `PATH` and `FABRIC_CFG_PATH`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now start the peer by executing, on one line, the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'You may get this error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: You can fix it by changing the port to 19443 in the *core.yaml* file located
    in the *sampleconfig* subdirectory. Look for the `Operations` section and `ListenAddress`
    to find the port.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the peer is started, you should see this message near the end of the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Create a channel and join the peer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With the orderer and peer running, we need to open a third terminal and execute
    some deployment commands. So open a third terminal, change to the Fabric subdirectory
    we are working in, and set our two environment variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can execute the next step, which is to create our channel and join
    the peer. Execute this command, all on one line, which generates the create channel
    transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see this at the end of the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Then execute this command, which will create the channel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see this at the end of the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we join the peer by executing this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see at the end of the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The peer is now a member of the channel.
  prefs: []
  type: TYPE_NORMAL
- en: Build and run the chaincode
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At this point, we can build our chaincode, start it, approve it, and commit
    it. Once we execute these final steps, we can stop and start a smart contract,
    and invoke its transactions.
  prefs: []
  type: TYPE_NORMAL
- en: 'To build the chaincode used to make this setup work, execute this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'When the command finishes, start the chaincode by executing this command, all
    on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Approve and commit the chaincode
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Leave the chaincode running and open a fourth terminal that we will use to
    approve, commit, and execute the chaincode. In the fourth terminal, set our two
    environment variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now execute the three following commands, each on one line, that will approve,
    check the commit readiness of, and commit the chaincode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: All of these steps need to be executed only once. We can now execute transactions,
    stop and start smart contracts, and stop and start the orderer and peer. We can
    close and open new terminals. But for each new terminal, we need to set the `PATH`
    and `FABRIC_CFG_PATH` environment variables to point to the *build/bin* directory
    and the *sampleconfig* configuration directory. Using absolute paths and setting
    these in your shell configuration eliminates the need to set these each time a
    terminal is opened for use in this task. The directory used to set this up contains
    the created artifacts that let you reuse this setup when you need to.
  prefs: []
  type: TYPE_NORMAL
- en: This configuration and setup will let us start and stop any smart contract and
    let us debug it, but don’t expect advanced APIs to function correctly. There is
    no security, and the configuration is limited, but for fast debugging and experimentation,
    this is a good setup that’s much faster than executing the deployment steps (which
    take time and do not work well when needing to iterate quickly on a smart contract).
  prefs: []
  type: TYPE_NORMAL
- en: Test the deployed chaincode
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can run and debug only one smart contract at a time with this setup. Before
    we stop the running chaincode we started in the third terminal, let’s make sure
    everything is working. This smart contract needs to be initialized, so in this
    fourth terminal, execute this command, all on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see output like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the contract is initialized, we can invoke a transaction that moves
    10 units from A to B by using this command, entered on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see a successful response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, we can query to see whether `a` has the value `90`, as expected,
    with this command, entered on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'And you should see the response we expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Our smart contract debugging setup is complete and working. We can now stop
    the running smart contract in the third terminal we opened and close the third
    terminal. We will use the current terminal we are in, the fourth terminal, to
    invoke transactions on the Fabcar smart contract after we prepare it for this
    local testing and debug setup.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the Fabcar Smart Contract for Testing and Debugging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now open a fifth terminal and change to the *fabric-samples/chaincode/fabcar/javascript*
    subdirectory. Before we can start the Fabcar smart contract or any other Node.js
    JavaScript smart contract, we need to install the dependencies and modify the
    start command in the *package.json* file. When we deploy to a network like *test-network*,
    we don’t need to install the dependencies. The runtime will perform this for us
    in the deployed container before executing the app with Node.js. In a production
    environment, this may be an issue because npm will access the internet to pull
    down the dependencies, and this may be a security risk.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install the dependencies, execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'This command creates a new subdirectory called *node_modules*. It contains
    our dependencies. Now we need to edit *package.json* and modify the start command,
    so open *package.json* in your editor. Change the start command to this single-line
    command and save the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Now back in the fifth terminal where we just executed the `npm install` command,
    execute this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see this at the end of the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The Fabcar smart contract is now running, and we can invoke it from terminal
    4.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have gone through a lot of terminals to get to this point. So let’s review
    what we have running:'
  prefs: []
  type: TYPE_NORMAL
- en: Terminal 1 with orderer running.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Terminal 2 with peer running.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We closed the third terminal—we used it to run a sample Go smart contract to
    test that the setup is working.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Terminal 4, which we use to submit requests to test our smart contracts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Terminal 5,with the Fabcar smart contract running.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now from the fourth terminal, enter this command, all on one line, to initialize
    the Fabcar smart contract:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Now enter this command, all on one line, to query all cars:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see this output response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Great! We can now run Fabcar in our smart contract testing and debugging setup.
    This means we can rapidly test and debug it and any other smart contract too.
    Using this setup, let’s add a new transaction to the Fabcar smart contract and
    then test and debug it.
  prefs: []
  type: TYPE_NORMAL
- en: Performing Fabcar Testing and Debugging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we need to stop the running Fabcar smart contract in terminal 5 by pressing
    Ctrl-C. Then we need to load the Fabcar project into our editor or IDE.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the chaincode Fabcar JavaScript project loaded in your editor or IDE,
    let’s add the following `callApi` function right after the `changeCarOwner` function
    at the bottom of the *fabcar.js* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the file and start Fabcar. You can start it through your IDE or from the
    command line in terminal 5 as we did in the prior step. Then in terminal 4, use
    this command to test the new transaction by invoking the `callApi` transaction
    via the `peer` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The error response is telling us we need to supply an argument. This is an
    example of the help the middleware provides for testing and debugging. Let’s correct
    this by executing this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: We loaded the smart contract code in an editor, modified it, ran it, and tested
    it. This was a fast iteration. Using this procedure for development is robust
    even if we do not have the tooling to load the code in an IDE and debug it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a quick look at debugging. Remember, this setup we just went through
    is awesome because with it you can treat Fabric smart contracts just like regular
    Node.js JavaScript. With the setup up and running, we can almost forget about
    it. When we use the special `start` command to start our smart contracts, they
    run as a node process but are known to the peer, orderer, and channel—so we get
    the basic chaincode functionality we need to develop smart contracts, but without
    all the network overhead and chaincode deployment requirements. This `start` command
    can be reused and applied to any chaincode smart contract we want to run and test
    or debug:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: With this setup, you easily run the sample smart contracts in *fabric-samples*
    without the need to go through the deployment process. Just load the project in
    your IDE, install the dependencies, modify the `start` command, and then start
    or debug the smart contract. It will load and run, enabling you to submit requests
    by using the `peer` command, as we have demonstrated throughout this section.
  prefs: []
  type: TYPE_NORMAL
- en: This quick look at debugging uses WebStorm. After loading the chaincode Fabcar
    smart contract in WebStorm, all we need to do is click the start command in the
    *package.json* file and select the debug option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then WebStorm starts the app and attaches a debugger, as shown here :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Now we can set breakpoints in the Fabcar code or even dive into *node_modules*
    and set breakpoints on the Fabric SDK modules, which let us step through and learn
    how they operate and which functions are called as a result of our code. This
    can be a wonderful way to learn how the smart contracts function and figure out
    how to use more advanced functions available in the SDKs. We can step through
    our smart contract and examine variables, logic flow, called functions, the stack,
    and more.
  prefs: []
  type: TYPE_NORMAL
- en: Using the IDE method of development, we cannot test the smart contract via our
    web client because we have no security, and the full network is not operating.
    But from what we have learned, this is not necessary, because we can invoke all
    of the smart contract transactions from the command line by using the `peer` command,
    allowing us to focus on the development of smart contract transactions.
  prefs: []
  type: TYPE_NORMAL
- en: Smart contracts can start and stop, which allows quick iteration during development.
    This is important, because it eliminates the redeployment steps that slow down
    the development cycle. We can use our editor to write code, the command line to
    start and stop the smart contract, and the `peer` command to test it. If a test
    fails, we can set a breakpoint and execute code to hit the breakpoint and then
    debug it.
  prefs: []
  type: TYPE_NORMAL
- en: The debugger lets us see and analyze the runtime data, state, structures, stack,
    and more. Once we locate the problem, we make the edits and test again. This development
    cycle is repeated until we finish our initial implementation of the transactions.
    Once we complete this cycle of development, we can package and deploy our smart
    contract to the test network and test it in a systems environment, where security
    and multiple peers are involved in the execution of our new smart contract transactions.
    This is similar to the typical development process in practice today, where developers
    create and test code in a local controlled environment and promote it to systems
    or integration testing, then to a staging environment that mirrors production,
    and eventually to production. Using the setup we just went through is perfect
    for rapid local development of smart contracts.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying and Reviewing Logs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Log files are a primary source of information for smart contract developers.
    Knowing how to access logs is an important task for developers to gather information
    on the performance and functioning of their code. In this section, we will identify
    available logs and show how to review them.
  prefs: []
  type: TYPE_NORMAL
- en: This first log is the developer’s *console log*. In the previous section, where
    we set up a development environment for rapid testing and debugging, we started
    an orderer and peer. Both had console output that we can review and learn from
    as we invoke our smart contract transactions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of the log output from the orderer we started:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is a sample of log output from the peer we started:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: When we launch a test network, the first log of interest is the log output from
    the script that launches the network and deploys the Fabcar smart contract.. Reviewing
    this log offers a lot of knowledge about the commands used and the parameters
    supplied to those commands. Of interest to smart contract developers are the log
    entries that detail the several commands required to deploy a smart contract.
    The log entries are near the end of the log.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the test network finishes launching, we can run a Docker command to display
    the containers started:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will display a listing of the 11 Docker containers started along
    with port information, status, date created, command, image, and container ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'It is possible to use the container ID to review any container’s log output.
    We can even tail the log output with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'We can aggregate the log output of all these containers by using Logspout.
    The *monitordocker.sh* script, which will launch Logspout for us, is located at
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'To aggregate all of the container logs after launching the test network, just
    open a terminal and execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Now when you invoke smart contract transactions, the terminal will display the
    aggregated logs’ output. If you want to review specific log output from a particular
    container, we can use Docker.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Unit Test Contracts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the rapid smart contract testing session, we discussed how to test Fabcar.
    In large projects, many smart contracts will be frequently updated by team members.
    In today’s complex software development environment, unit tests are essential
    in the development life cycle, as they ensure that your specific module works
    under all expected conditions. A *unit test* isolates a function, class, or method
    and tests only that piece of code. It helps to debug code and improve code quality,
    which eventually results in more reliable code.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you learned in previous chapters, the Hyperledger Fabric smart contract
    supports code based on Go, Java, and Node.js. Each language has plenty of mock
    test frameworks we can use. For example, in this book, we use Node.js as our smart
    contract language, and instead of using Hyperledger Fabric directly to test in
    the sample network, we can use Mocha and Chai mock test frameworks to mock those
    Fabric SDK interfaces and directly test the smart contract logic. You can include
    the following node dependency in the *package.json* node project for doing unit
    tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Chai is a behavior-driven development/test-driven development (BDD/TDD) assertion
    library, and Mocha and Sinon.JS are popular standalone test frameworks. Sinon–Chai
    provides a set of custom assertions for using the Sinon.JS and Chai assertion
    libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'Further, the following is an example to show how we can use the JS test framework
    to test smart contracts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: We first import the node library in the test class. Then, create a `Context`
    class to mock `ChaincodeStub` and `ClientIdentity`. With the mock `Context` defined,
    we can then start to instantiate a smart contract by creating a `SomeContract`
    instance, and then get the instantiated result. Similarly, we can invoke smart
    contract transactions by calling `contract.txn(ctx, 'success')` to verify the
    result.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you gained four vital skills for developing Hyperledger Fabric
    smart contracts: creating a smart contract web app, performing rapid smart contract
    testing, monitoring logs, and creating unit test contracts. The first vital skill
    was creating a UI client for Fabric smart contracts. We did this as a maintenance
    task that added a web UI client to the Fabcar smart contract. A great benefit
    from this is we can now use the Fabcar UI web client as a template and quick start
    for our next smart contract.'
  prefs: []
  type: TYPE_NORMAL
- en: The second vital skill is all about testing smart contracts. We set up a testing
    environment that allows us to rapidly test smart contracts. Using this setup,
    you learned we can debug our smart contracts as they execute. The benefit of rapidly
    testing smart contracts is that it facilitates quick iteration for smart contract
    development and exploring the operation of other smart contracts. Without the
    setup, you learned we could use *test-network*. But that is slow, and debugging
    difficult. This setup skill alone is probably the most important skill you can
    possess for fast smart contract development, testing, and debugging.
  prefs: []
  type: TYPE_NORMAL
- en: In addition. you learned how to monitor logs and execute unit tests—two important
    skills for monitoring code execution and maintaining code quality.
  prefs: []
  type: TYPE_NORMAL
- en: 'You are now ready to take the knowledge and skills you have gained to [Chapter 7](ch07.xhtml#building_supply_chain_dapps_with_hyperl),
    which covers the most popular use case for Hyperledger Fabric: supply chains.'
  prefs: []
  type: TYPE_NORMAL
