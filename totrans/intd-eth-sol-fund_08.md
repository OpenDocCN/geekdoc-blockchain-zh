© Chris Dannen 2017Chris DannenIntroducing Ethereum and Solidity10.1007/978-1-4842-2535-6_8

# 8. Dapp 部署

正如你将看到的那样，部署 dapps 是一次冒险，探索着新的计算范式的前沿。Chris Dannen^(1 )(1)美国纽约布鲁克林分布式应用程序，或 dapp，与 EVM 协议的其他部分分享着一些相同的理想：不可变性的承诺。Dapps 由智能合约组成，在本书中已经多次指出，它们由以太坊网络上的所有节点在大约相同的时间执行。实际上，dapps 就像在 EVM 上运行的普遍可用的 Web 服务，但通过用户可以通过他们的网络浏览器或智能手机应用程序，或者类似 Mist 的以太坊浏览器的普通 HTML/CSS/JavaScript 前端访问的。注意：本章针对具有预先存在技能的开发人员。如果你是一个新手编码人员，请仔细阅读本章和第九章。然后，拿起一本 JavaScript 初学者书籍，提高你的脚本技能。接下来，访问 [`solidity.eth.guide`](http://solidity.eth.guide) 获取更多 Solidity 语言教程。运行基于区块链的应用程序客户端远比在云托管范式中管理客户端容易得多。枢纽-辐条式 Web 应用程序按垂直方向扩展，反映了它们运行的单个服务器。相比之下，以太坊应用程序水平扩展 - 就像你希望云应用程序扩展的方式。虽然今天加密网络在交易处理能力方面受到了明显的限制，但随着协议的其他组件成熟，它们将变得更快。

## 七种思考智能合约的方式

在每个 dapp 的背后都有一系列智能合约。智能合约在这些场景中非常有用，这些场景可能是原型设计的有趣问题领域：

+   为现实世界中的某物或其他合同维护一个会计系统

+   创建转发合同，例如将收入自动转发到一个单独的桶的储蓄账户

+   管理几方之间的关系，例如自由职业者协议或工资单

+   作为其他合同的软件库

+   充当其他系统或一组合同的控制器

+   为公共网络服务提供应用程序特定的逻辑

+   充当开发人员可以按需使用的实用程序，例如随机数生成器

Dapp 开发对应用程序开发者带来各种新的关注点，同时需要了解 Web3 JavaScript API 和 Solidity 编程语言。希望在阅读完本书大部分内容后，您感到准备就绪，可以直接使用这些工具进行工作！要更好地了解今天正在构建的各种 dapps，可以查看由 EtherCasts 经营的 [`dapps.ethercasts.com`](http://dapps.ethercasts.com) 。

## Dapp 合同数据模型

要部署一个工作合同，您首先需要知道的是可以在 EVM 中存储哪些类型的数据，以及您在哪里存储这些数据。正如我们在之前的章节中讨论过的，以太坊网络中的每个合同地址都有其智能合约的存储空间。这个存储空间没有限制，除非是您愿意支付的限制。截至撰写本文时，存储空间的成本约为每千字节 0.018 美元。Solidity 语言使得使用合同作为小型关系数据库变得容易。为了更加简便，Solidity 语言有两种熟悉的数据类型我们还没有提到：

+   映射

+   结构体

要了解更多关于在 Solidity 中使用这些类型的信息，请参阅 [`solidity.eth.guide`](http://solidity.eth.guide) 。在最基本的情况下，合约的个体存储空间是一个具有 2256 个可能键和相同数量值的键/值存储空间。这足够存储几乎任何类型的数据库结构。请记住，对象属性有时被开发者称为键，如键/值对或键/值存储的短语中所示。在我们的人类示例中，键/值对可能是 footSize = 11。一个包含每个人脚尺寸的表格位于专用服务器上是键/值存储的示例。作为一个有状态的交易机器，你可以把整个 EVM 想象成一个巨大的键/值存储，显示账户余额。希望到现在为止，你已经想象出了在 Solidity 合约中可以创建和使用的简单数据结构的种类。在下一节中，我们将开始分解分布式应用程序架构。

## **EVM 后端如何与 JS 前端通信**

以太坊网络与可以称为 HTTP 网络的网络之间的差距确实可以被跨越。假设一个顾客在一个由 dapp 驱动的网站上用传统的 web 浏览器输入午餐订单。为了成功地在她的浏览器和 EVM 之间传递关于她订单的数据（多少杯奶昔？），dapp 的前端必须以一定的格式“发送”数据给 EVM。备注：Dapps 可能不需要它们自己的一套合同；相反，它们可能能够调用其他合同中的某些公共函数来利用它们的功能。对于在智能合约中声明为 public 的每个函数，Solidity 自动创建一个访问函数，以便其他合同可以调用它。在计算中，数据交换格式的工作方式类似于国际邮政服务。尽管世界各地的不同服务器可能运行着不同的操作系统，用不同的语言编写，由完全不同的思想编写，但它们必须在某个时候与不像它们的服务器交换数据。为了正确地“翻译”，程序员们设计他们的程序以用某种符号向其他程序发送信息。通常，符号描述了一个对象的整个格式（在第一章中定义为一组属性和值）。例如，一个人的数据对象可能包括身高、体重、眼睛颜色、脚大小等等。

### JSON-RPC

在今天的 Web 应用程序中，JavaScript 代码可以通过一种称为 JavaScript 对象表示法（JSON）的通用对象表示法在网络上传递信息。JSON 对象可以包含数字、字符串和某些属性的有序值序列。在 Web3.js 中有两个重要的数据对象，它们在某种程度上相当于 JSON，因为它们在以太坊应用程序的前端和后端之间传递。它们被称为 JSON-RPC 对象，并随 Web3.js 库一起提供。Web3.js 的安装将在下面介绍。这两个对象的用法如下：

+   web3.eth 专门用于区块链交互。

+   web3.shh 专门用于 Whisper 交互。

Whisper 是一个私密消息传递协议，它本身是较大的以太坊协议的一部分。在运行时，你可以将 JSON-RPC 对象想象为在前端（在 HTTP Web 上）和后端（以太坊 Web）之间不断传递。

## Web 3 就在这里（几乎）

JavaScript 库 Web3.js 是新 Web 3 规范的一部分。你可以在 [`github.com/ethereum/web3.js/`](https://github.com/ethereum/web3.js/) 找到 Web 3 项目的 GitHub 页面。Web 3 是分散式网络的通用术语，就像 Web 2 是由网络托管的应用程序和服务定义的一样。Web 1 指的是最初的万维网，它托管了静态页面。从那时起，超文本传输协议一直在发展，以添加更多方法并支持越来越复杂的内容和脚本。Web 3 很大程度上是以以太坊协议为中心的愿景。它通常被认为有三个组成部分：

+   点对点身份验证和消息系统

+   共享状态（区块链）

+   分散式文件存储

前两个复选框已完成：以太坊网络已经运行，并且交易可行！凳子的第三条腿，去中心化文件存储，是 Swarm 项目的一部分，你将在第十一章中了解更多相关内容。在 Web 3 的范式中，没有 Web 服务器。没有缓存、反向代理、负载均衡器、内容分发网络（CDN）或其他传统大规模 Web 应用部署的残留。甚至去中心化域名服务器（DNS）也将是免费的。当 Swarm 存储上线时，它将变得廉价，就像以太坊的 Web 托管组件一样。对于所有类型的开发人员和黑客来说，Web 3 打破了“免费增值”应用部署模式，其中越来越多的用户和规模会给你带来越来越高的托管账单。在 EVM 中，你可以通过编写高效的代码来控制成本，并且你可以确保地球上的任何人都能在第一天就访问你的应用程序。让我们回到 Dapp 开发的具体细节，看看今天的 Web 如何与 EVM 进行通信。

## 使用 JavaScript API 进行实验

在第六章中，你看到通过在 Geth 的 JavaScript 控制台中输入命令与 EVM 交互是多么容易。当你这样做时，实际上是在调用以太坊 JavaScript API 中附带的个别 JavaScript 方法。你在 Geth 控制台中输入的这些 JavaScript 方法正在被一种专属于 Geth 的 JIT-like JavaScript 解释器解释。这被称为 JSRE 的交互使用，或在交互模式下使用它。然而，以太坊 JavaScript API 方法也可以暴露给普通的 Web 应用程序，使它们能够与 EVM 进行通信。

### 使用 Geth 进行 Dapp 部署

尽管其他以太坊客户端很受欢迎，但 Geth（用 Go 语言编写，由 Google 开发）及其对 JavaScript 的轻松解释使其成为将传统的 HTTP Web 前端 Web 应用程序与后端 EVM 合约连接起来的最快方法。因为这些是由 Geth 解释为 EVM 代码的 JavaScript 方法，所以可以将它们串联成脚本，这当然是 JavaScript 的自然用法。这被称为非交互式使用。注意：JavaScript API 的非交互式使用是我们称之为计算机编程的整个原因。一般来说，编程的目标是自动化否则需要手动在终端输入的命令，就像您输入安装 Geth 的命令一样。在进行复杂计算或构建分析模型时，这些指令字符串可能会变得又长又繁琐。通过在纯文本文件中编写指令字符串，程序员可以使程序简洁、快速、高效且可重复。编程的另一个目标是将人类操作员输入的任务分离，并以线程的方式同时执行，以便整个作业所需时间更少。正如您在 Geth 刚启动时看到的那样，只要 Geth 在运行，您就无法在命令行窗口中执行任何操作，而且该线程将一直运行下去。通过在 Geth 之上构建一个控制台，Ethcore 开发人员允许您，控制台的操作员，在后台同步 Geth 的同时发出命令，在本地机器的另一个线程上执行。接下来，您将了解连接到 EVM 作为后端的理想 Web 开发框架。

## 使用 Meteor 与 EVM

如果您是 JavaScript 开发人员，则可能已经听说过 Meteor.js，这是一个允许您编写反应式 Web 应用程序的库，该应用程序在服务器和客户端上运行对称代码。这个全栈框架非常适合实时 Web 应用程序，但对于以太坊前端开发也非常有用，因为它非常适合编写单页面应用程序或 SPA。下面是许多以太坊开发人员喜欢 Meteor 的原因：

+   它完全由 JavaScript 编写，工具也是如此。

+   您将获得整个开发环境的开箱即用。

+   部署非常容易。

+   接口完全是响应式的（类似于 Angular.js）。

+   使用一种名为 MiniMongo 的 NoSQL 数据模型，可以自动持久化到本地智能合约存储中。

要了解有关使用 Meteor.js 构建以太坊应用程序的更多信息，请查看 [`github.com/ethereum/wiki/wiki/Dapp-using-Meteor`](https://github.com/ethereum/wiki/wiki/Dapp-using-Meteor) 。此 URL 也列在 tutorials.eth.guide 上。接下来，您将了解如何将 Web3.js 库安装到开发机器上，以便在本地开始尝试与合约交互。

### 安装 Web3.js 以构建支持以太坊的 Web 应用程序

Web3.js 库通过 RPC 与本地节点通信。该库与任何以太坊节点配合使用，只要它正在暴露其 RPC 层。您需要在本地机器上安装此库进行开发，并在 Web 服务器上运行前端应用程序。即使不使用此命令标记在 Geth 中启动您的链，私有链默认会暴露这个。实际上，您可以将您的以太坊节点视为裸金属层，通过其 RPC 层暴露 EVM。该 RPC 层可以与同时运行 Web3.js 的 Web 服务器发送和接收 web3.eth 和 web3.shh 对象。要在本地开发环境中安装 Web3.js，请打开终端并使用您最熟悉的安装库：

+   npm：npm install web3

+   bower：bower install web3

+   meteor：meteor add ethereum:web3

+   vanilla：链接 dist./web3.min.js

然后，您需要创建一个 Web3 实例，并将本地主机设置为提供者。要继续学习如何使用 Web3.js，请访问 [`dapps.eth.guide`](http://dapps.eth.guide) 。接下来，您将了解如何在 Geth 控制台中执行 JavaScript 文件。

## 在控制台中执行合约

完整的 dapp 部署教程可能需要很多页，并且可以以几十种可能的方式执行。本节重点是快速入门。您可以直接在 Geth 中上传您的智能合约文件，通过简单添加 --exec 参数将它们发送到 EVM 中的交易中，然后编写指向本地脚本的 JavaScript 代码。例如：$ geth --exec 'loadScript("/Desktop/test.js")'实际上，您甚至可以执行位于另一台机器上的 JavaScript，只要它正在运行 Geth：$ geth --exec 'loadScript("/Desktop/test.js")' attach https://100.100.100.100:8000 接下来的部分涵盖了以太坊应用程序的架构，以及它们与传统 Web 架构的不同之处。

### 如何暴露合约接口

当使用 JavaScript dapp API 时，通过诸如 eth.contract() 函数这样的抽象层调用合约将返回一个对象，该对象包含调用 JavaScript 时该合约可以运行的所有函数。为了标准化这种自省功能，以太坊协议提供了一种称为应用二进制接口（Application Binary Interface）的东西，又称为合约 ABI。ABI 的行为类似于 API，为合约调用应用程序创建了一个标准语法。ABI 规定，合约将返回一个数组，该数组详细说明了正确的调用签名和可用的合约函数。对于一些开发人员，特别是那些来自苹果开发环境的开发人员，可能会感到惊讶，因为没有“随附”以太坊的框架来方便地编写常见的应用程序组件。尽管以太坊协议可能总体上没有太多特色，但在常见用例中仍然需要使合约以可预测的方式进行交互。这些情景包括货币单位、名称注册表和在交易所交易。ABI 是对这些情景的妥协。ABI 包含二进制一词，因为在 EVM 中，应用层下面的一层是运行 EVM 字节码的一层。您可以在 [`github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI#functions`](https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI#functions) 或 [`abi.eth.guide`](http://abi.eth.guide) 上找到此规范。智能合约的标准通常由一些常见方法的函数签名集合组成，例如发送、接收、注册、删除等。

## 原型设计建议

关于原型化 Solidity 合约的第一件事是，你不一定需要以太坊节点来测试你的合约。你可以使用以太坊虚拟机合约模拟器，[`github.com/EtherCasts/evm-sim/`](https://github.com/EtherCasts/evm-sim/)。这个模拟器允许开发人员在没有访问测试网的情况下独立测试他们的合约；例如，当从一台笔记本电脑上工作时。以下是原型化的其他最佳实践，当你进入使用实际以太时进行测试的阶段时：

+   不要在每个合约中使用太多以太，并在可能的情况下，对合约持有的金额设置上限。这是一个很好的故障保护机制，以防出现 bug 使你的资金被困住。在使用实际以太进行测试时，只需不要使用太多即可。

+   保持你的合约模块化且易于理解。在可能的情况下，将功能抽象为可以单独测试的库。限制变量的数量和函数的长度。一切都要有文档记录。

+   使用检查-效果-交互模式。这意味着你不应该编写等待来自另一个合约的返回数据的程序；这会导致超时。一般来说，你可以通过在更改状态之前对返回的数据执行检查来避免这种情况。

+   编写你自己的中间件。因为 EVM 是一个不太容易迁就的平台，所以你需要为自己的程序创建作为故障保护的机制。

+   正如在第五章中提到的，在代币合约教程中，开发人员正在围绕某些类型的合约制定标准。你可以将你的合约注册到 Etherchain 等第三方服务中，以便其他人可以使用它们。你会在 [`etherchain.org/contracts`](https://etherchain.org/contracts) 看到公开列出的合约。

+   测试，测试，测试！你可以在 [`test.eth.guide`](http://test.eth.guide) 找到测试资源。

你已经查看了几个明显是为演示目的编写的合约。你在真实的 dapps 服务中可能创建哪些简单的智能合约，部署它们的最佳方式是什么？这是本章最后一节的主题。

## 第三方部署库

部署更复杂的智能合约并将它们连接到网络稍微超出了本书的范围——部分原因是这是一个快速发展和不断变化的领域。截至本书写作时，这也是相当困难的，需要一些耐心。因此，开发工具是以太坊社区活跃发展的一个重要领域。领先的开发者团队已经创建了工具，使合约和 dapp 部署更加容易实现。以下是一些你应该知道的项目：

+   Monax 教程和 Solidity 合约

+   OpenZeppelin 智能合约

+   Truffle 部署、测试和资产创建环境

+   Dapple，一个用于复杂合约系统的开发环境

+   Populus，一个用 Python 编写的合约开发框架

+   Embark，一个用 JavaScript 编写的 dapp 开发框架

+   Ether Pudding，一个包构建器

+   Solium，Solidity 的一个代码检查工具

本书无法涵盖的 dapp 指南、教程、最佳实践和示例项目还有很多。你可以在[`dapp.eth.guide`](http://dapp.eth.guide)找到所有这些工具和库的最新链接，以及更多信息。此外，你还可以在[`help.eth.guide`](http://help.eth.guide)找到一系列 Gitter 频道，在那里你可以获得开发和部署方面的帮助。

## 概述

在本章中，你了解了以太坊可用于编写的合同类型以及部署它们的方法。还介绍了智能合约如何与应用程序的前端进行通信。以太坊 dapp 开发并不容易，但每天都变得越来越易于接近。加入 Gitter 频道或加入本地开发者社区。截至目前，全球各地有 450 个以太坊 Meetup 活动——确切地说是在 218 个城市和 57 个国家，共有 81,424 名成员和 2,257 个感兴趣的人。要找到离你最近的一个，请搜索 Meetup（[www.meetup.com](http://www.meetup.com)）。在下一章中，你将部署自己的私有区块链，以更好地理解区块链的工作原理。
