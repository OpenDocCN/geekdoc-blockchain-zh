- en: Chapter 3\. Hyperledger Fabric Architecture and Components
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章。超级账本 Fabric 架构和组件
- en: In the previous chapter, we surveyed four generations of blockchain technology,
    followed by the Hyperledger architecture and its components. We also introduced
    you to the Hyperledger ecosystem by reviewing its projects, tools, and libraries.
    This chapter looks deeper into the Hyperledger family by focusing on the Hyperledger
    Fabric project. Along the way, we will introduce you to all the Hyperledger Fabric
    components, including peers, channels, and chaincodes, for both building blockchain
    applications and understanding concepts covered in the rest of the chapters.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们调查了四代区块链技术，接着是超级账本架构及其组件。我们还通过审查其项目、工具和库介绍了超级账本生态系统。本章将深入了解超级账本家族，重点介绍超级账本
    Fabric 项目。在此过程中，我们将向您介绍所有超级账本 Fabric 组件，包括对构建区块链应用程序和理解其他章节中涵盖的概念都很重要的对等体、通道和链码。
- en: 'This chapter will help you understand the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将帮助您理解以下内容：
- en: Major highlights of Fabric versus other blockchain development platforms
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Fabric 与其他区块链开发平台的主要亮点
- en: The role of membership service providers, CAs, and identities in a Fabric permissioned
    network
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成员服务提供者、CA 和身份在 Fabric 权限网络中的角色
- en: The role of the ledger in Fabric
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Fabric 中账本的角色
- en: Main components of the Fabric network
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Fabric 网络的主要组成部分
- en: The roles that a peer plays in a Fabric network
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对等体在 Fabric 网络中扮演的角色
- en: The mechanisms through which peers process transactions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对等体处理交易的机制
- en: The role of private data and data collection in a Fabric permissioned network
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Fabric 权限网络中私有数据和数据收集的角色
- en: Hyperledger Fabric Overview
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 超级账本 Fabric 概述
- en: '*Hyperledger Fabric* started as a codebase project, combining previous work
    by Digital Asset Holdings (now called Digital Asset), Blockstream’s Libconsensus
    library, and IBM’s Open Blockchain platform. Fabric offers a unique elastic and
    extensible architecture, which performs over and above alternative blockchain
    platforms. Fabric works very well with other Hyperledger projects, libraries,
    and tools, allowing it to be a full-fledged blockchain platform. The Fabric network
    is scalable to meet the needs of enterprise applications.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*超级账本 Fabric* 作为一个代码库项目开始，结合了数字资产控股（现称为数字资产）、Blockstream 的 Libconsensus 库以及
    IBM 的开放区块链平台之前的工作。Fabric 提供了一种独特的弹性和可扩展的架构，其性能优于其他替代区块链平台。Fabric 与其他超级账本项目、库和工具非常配合，使其成为一个全功能的区块链平台。Fabric
    网络可扩展，以满足企业应用程序的需求。'
- en: Fabric is a platform for building distributed ledger solutions. It comes with
    several handy features, such as a modular architecture that offers high levels
    of confidentiality, flexibility, and scalability. This modular architecture makes
    it possible for components like consensus and membership services to act as plug-and-play
    accessories. Further, Fabric is designed to be resilient to technology changes
    by catering to the intricacies of the economic ecosystem. Lastly, Fabric is revolutionary
    because it allows entities to conduct confidential transactions without passing
    information through a central authority.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Fabric 是构建分布式账本解决方案的平台。它带有几个方便的功能，例如模块化架构，提供高度的保密性、灵活性和可扩展性。这种模块化架构使得像共识和成员服务这样的组件能够作为即插即用的附件。此外，Fabric
    设计成能够适应技术变化，通过满足经济生态系统的复杂性。最后，Fabric 革命性之处在于它允许实体进行保密交易，而不必通过中央机构传递信息。
- en: Throughout the remainder of this chapter, we will review the various Fabric
    components to provide a holistic view of its powerful features. By the end of
    this chapter, you will have a solid understanding of why Fabric is becoming a
    prominent choice for enterprise blockchain implementation.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的剩余部分，我们将回顾各种 Fabric 组件，以提供对其强大功能的全面认识。到本章结束时，你将对为什么 Fabric 正成为企业区块链实施的显著选择有着坚实的理解。
- en: Hyperledger Fabric Model
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Hyperledger Fabric 模型
- en: In blockchain application development, developers can build a distributed ledger
    technology in multiple ways. Hyperledger Fabric, however, is a unique implementation
    of DLT mainly aimed at enterprises rather than individuals.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在区块链应用开发中，开发者可以通过多种方式构建分布式账本技术。然而，Hyperledger Fabric 是一种独特的 DLT 实现，主要针对的是企业而不是个人。
- en: 'Fabric’s architecture separates the transaction flow into three main steps
    while following the execute-order-validate paradigm. In doing so, it lets Fabric
    execute untrusted codes in an untrusted environment. The execute-order-validate
    paradigm alone distinguishes Hyperledger from other widely adopted permissionless
    blockchains like Bitcoin or Ethereum, which have only order-execute models in
    place. Here’s how the steps in the paradigm are executed in a Fabric system:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Fabric 的架构将交易流程分为三个主要步骤，遵循执行-排序-验证范式。通过这样做，它让 Fabric 在不受信任的环境中执行不受信任的代码。执行-排序-验证范式单独将
    Hyperledger 与其他广泛采用的无许可区块链（如比特币或以太坊）区分开来，后者只有执行-排序模型。以下是范式中步骤在 Fabric 系统中的执行方式：
- en: For Fabric to execute a transaction, it first checks the transaction’s correctness.
    Then Fabric produces state updates for the transaction. The nodes that are executing
    transactions are called endorsers. They are called upon to validate and add a
    set of state updates produced as the result of a computation. At this stage, multiple
    transactions can be executed simultaneously. Therefore, state updates may contain
    a conflict.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 Fabric 执行事务，它首先检查事务的正确性。然后 Fabric 为事务生成状态更新。执行事务的节点称为背书者。他们被召唤来验证并添加作为计算结果产生的一组状态更新。在此阶段，可以同时执行多个事务。因此，状态更新可能包含冲突。
- en: The Fabric ordering service follows the consensus protocol defined in the Fabric
    network regardless of transaction semantics. The nodes running the consensus algorithm
    are called orderers (covered later in this chapter).
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Fabric 排序服务遵循 Fabric 网络中定义的共识协议，无论事务语义如何。运行共识算法的节点称为排序者（稍后在本章中介绍）。
- en: 'Fabric validates the transaction to ensure that two conditions are met:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Fabric 验证事务以确保满足两个条件：
- en: Transactions are executed according to the given transaction logic.
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 事务按照给定的事务逻辑执行。
- en: No state conflicts exist among submitted transactions, in which two transactions
    want to update the same state.
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提交的事务之间不存在状态冲突，即两个事务想要更新相同的状态。
- en: After transactions are validated, they are added to the ledger by using *committer*
    nodes. Note that endorsers are also committers.
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 验证事务后，使用 *提交者* 节点将其添加到账本上。请注意，背书者也是提交者。
- en: 'The execute-order-validate design has several main benefits. First, in an order-execute
    model, the nodes that are ordering transactions are also executing them. Thus,
    there will be validation against two assumptions:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 执行-排序-验证设计具有几个主要优点。首先，在顺序执行模型中，排序事务的节点也在执行它们。因此，将会针对两个假设进行验证：
- en: The ordering is correct.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排序是正确的。
- en: The computation is carried out properly.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算被正确执行。
- en: Conversely, trust assumption in Fabric can be treated differently for consensus
    as compared to transaction execution. This gives Fabric great flexibility, especially
    when it comes to confidentiality, because only a given subset of the network is
    called to execute certain transactions and not others.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，Fabric 中的信任假设在共识和事务执行方面可能被不同对待。这使得 Fabric 具有极大的灵活性，特别是在保密性方面，因为只有网络的特定子集被调用来执行某些事务，而不是其他事务。
- en: Secondly, the execute-order-validate design enables the parallel execution of
    multiple transactions simultaneously by different parts of the network. This is
    highly beneficial for the system’s overall throughput and addresses potential
    nondeterminism (which prevents the same input from acting differently in different
    environments). A flexible endorsement policy specifies which peers, or how many
    of them, should participate in the correct execution of the given business logic.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，执行-排序-验证设计使得网络的不同部分能够同时并行执行多个交易。这对系统的整体吞吐量非常有益，并解决了潜在的非确定性问题（即相同输入在不同环境中的行为不同）。灵活的认可策略指定了哪些对等方，或者其中多少个，应参与给定业务逻辑的正确执行。
- en: 'Fabric has the following six essential capabilities:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Fabric 具有以下六个基本功能：
- en: Identity management
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 身份管理
- en: The *membership service provider* (*MSP*) handles identity management. Fabric
    provides a membership identity service that manages user IDs and authenticates
    all participants on the network. It is a great asset for enterprise applications
    since they have a huge stock of credentials.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*成员服务提供商*(*MSP*)处理身份管理。Fabric 提供了一个成员身份服务，管理用户ID并对网络上的所有参与者进行身份验证。对企业应用程序来说，这是一个巨大的优势，因为它们拥有大量的凭据。'
- en: Privacy and confidentiality
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 隐私和保密性
- en: One way to achieve privacy and confidentiality in Fabric is through private
    channels. To put it simply, *private channels* are restricted message routes that
    can be used for transactions between specific subsets of network members. These
    private channels have many practicalities, especially among enterprise consortium
    members, as a subset of members may wish to share private data without affecting
    the rest of the network operation.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Fabric 中实现隐私和保密性的一种方法是通过私有通道。简而言之，*私有通道*是受限制的消息路由，可用于特定子集网络成员之间的交易。这些私有通道在企业联盟成员之间尤其实用，因为子集成员可能希望共享私有数据而不影响网络其他部分的运行。
- en: Channels deliver their promise as long as the ordering service is trusted, because
    all transactions must go through ordering, and their content is therefore visible
    to that service. Fabric offers *private data collections* (*PDCs*) when the ordering
    service cannot be trusted for confidentiality. A PDC can be considered a partition
    of a ledger visible only to a subset of the network. We discuss more on the ordering
    service and PDC later in this chapter.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 只要有序服务是可信的，通道就能够实现其承诺，因为所有交易都必须经过排序，因此它们的内容对该服务是可见的。当无法信任排序服务保密性时，Fabric 提供*私有数据集*(*PDCs*)。私有数据集可以被视为只对网络子集可见的分类账的一部分。我们稍后在本章中将更详细地讨论排序服务和私有数据集。
- en: Efficient processing
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 高效处理
- en: Fabric assigns network roles by node type to provide concurrency and parallelism.
    Such a feature alone will boost the performance of network operation by allowing
    transactions to be threaded for faster processing in a Fabric network. In addition,
    only a subset of the network working on executing certain transactions needs to
    know the business logic; thus, it frees up resources for the rest of the network.
    This makes it possible to load the business logic only where it is strictly needed
    and not make it available to the entire network.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Fabric通过节点类型分配网络角色以提供并发性和并行性。这样的特性单独就会通过在Fabric网络中允许交易进行线程化以实现更快的处理而提高网络操作的性能。此外，只有网络的子集正在执行某些交易时需要了解业务逻辑；因此，它释放了其他网络的资源。这使得只在严格需要的地方加载业务逻辑成为可能，并且不将其提供给整个网络。
- en: Business logic
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 业务逻辑
- en: The smart contract, or chaincode, defines the business logic that constitutes
    the execution of a transaction. Business logic can be written in any general-purpose
    programming language without systemic dependency on a native cryptocurrency. We
    discuss this more later in this and subsequent chapters.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约，或链码，定义了构成交易执行的业务逻辑。业务逻辑可以用任何通用编程语言编写，而不需要系统依赖于本地加密货币。我们将在本章和后续章节中更详细地讨论这一点。
- en: Governance
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 治理
- en: Governance models provide another essential capability. In Fabric, these models
    can be expressed by *policies*. A policy is required to identify the parties that
    can deploy a chaincode or can add an MSP to a channel. They are flexible and can
    be updated as needed by issuing proper configuration transactions. We discuss
    more on the role of policies later in this chapter.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 治理模型提供了另一个重要的能力。在Fabric中，这些模型可以通过*policies*来表示。策略需要识别可以部署链码或向通道添加MSP的各方。它们是灵活的，并且可以通过发出适当的配置交易来根据需要进行更新。我们将在本章后面更详细地讨论政策的作用。
- en: Modular architecture
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 模块化架构
- en: As discussed earlier, Fabric comes with a modular architecture that makes it
    more resilient to changes while allowing its common parts to be shared with other
    networks. In other words, once endowed with a modular design, Fabric will result
    in a universal blockchain architecture that any industry or public domain can
    adopt.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Fabric具有模块化架构，使其更具有适应性，同时允许其公共部分与其他网络共享。换句话说，一旦拥有模块化设计，Fabric将产生一种通用的区块链架构，任何行业或公共领域都可以采用。
- en: Blockchain Network
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 区块链网络
- en: Unlike other blockchain platforms, Fabric comes with a network that offers great
    flexibility in catering to various project sizes, from a basic two-member layout
    to a multilayer consortium consisting of multiple consortiums, each with several
    members. As a whole, networks play a crucial role in the scalability and adaptability
    of blockchain platforms among enterprises.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他区块链平台不同，Fabric提供了一个网络，能够灵活满足各种项目规模，从基本的两个成员布局到由多个联盟组成的多层联盟，每个联盟都有多个成员。总体而言，网络在企业区块链平台的可扩展性和适应性中起着至关重要的作用。
- en: The Fabric network may vary depending on the project being implemented. All
    organizations in a Fabric network will have access to certain components without
    restrictions, whereas some components are assigned to only a specific organization
    via an independent node called the *orderer service*. Thus, considering the logical
    characteristics of Fabric networks, you can begin to understand the multiple components
    that go into operation within Fabric.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Fabric 网络可能会因正在实施的项目而有所不同。Fabric 网络中的所有组织都将无限制地访问某些组件，而某些组件仅通过一个称为*orderer 服务*的独立节点分配给特定组织。因此，考虑到
    Fabric 网络的逻辑特性，您可以开始理解 Fabric 内部运作所涉及的多个组件。
- en: Each organization within the network can deploy as many nodes as it wishes.
    The trust that Fabric grants as a private and permissioned network is comprehensive,
    since the identity of all node participants within its network is known.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 网络中的每个组织都可以部署任意数量的节点。作为私有和权限网络的超级账本所授予的信任是全面的，因为其网络中所有节点参与者的身份是已知的。
- en: Identity
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 身份
- en: The concept of *identity* within Hyperledger Fabric is closely related to the
    concept of an MSP that we will see later. Each component that is part of the network—such
    as nodes, computers, administrators, and clients—have certified credentials generated
    by one or more authorities. These credentials are the identity that accredits
    them as network operators.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在超级账本 Fabric 中，*身份* 的概念与我们稍后将看到的 MSP 的概念密切相关。网络中的每个组件——如节点、计算机、管理员和客户端——都有由一个或多个权威机构生成的认证凭证。这些凭证是将它们认定为网络操作者的身份。
- en: Once an identity is issued, it will act on the network according to its assigned
    policies. That means it is the job of policies (as discussed later in this chapter)
    to set several authentication parameters such as who has access to what, and what
    actions an identity holder can perform in the network. For example, only an identity
    with specific administrative permissions can install a chaincode on a given peer,
    or only an identity with write permission can request to append a new transaction
    to a given ledger.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦身份被颁发，它将根据其分配的策略在网络上运作。这意味着策略（本章后面将讨论）的工作是设置多个认证参数，例如谁有权访问什么，以及身份持有者在网络中可以执行什么操作。例如，只有具有特定管理权限的身份才能在给定的对等方上安装链码，或者只有具有写权限的身份才能请求向给定分类帐追加新交易。
- en: Fabric does not impose any specific identity infrastructure/technology. This
    offers great flexibility and allows administrators to deploy Fabric networks in
    various contexts. Nevertheless, by default, Fabric can be configured to support
    any *public-key infrastructure* (*PKI*). A PKI is a commonly used infrastructure
    to organize the management of digital identities (from issuance to revocation).
    A digital identity is usually bound to a cryptographic key-pair (public/private
    keys). In such schemes, digital signatures are generated using a secret key in
    the possession of the owner of the digital identity, and a public key, available
    to anybody, is used to verify those signatures.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Fabric 不会强加任何特定的身份基础设施/技术。这提供了很大的灵活性，使管理员能够在各种环境中部署 Fabric 网络。然而，默认情况下，Fabric
    可以配置为支持任何*公钥基础设施*(*PKI*)。 PKI 是一种常用的基础设施，用于组织数字身份的管理（从发行到吊销）。数字身份通常绑定到一个加密密钥对（公钥/私钥）。在这种方案中，数字签名是使用数字身份所有者拥有的秘密密钥生成的，而任何人都可以使用的公钥用于验证这些签名。
- en: Last but not least, identities can be revoked. When this happens, an identity
    loses the ability to operate in the network. The mechanism used to revoke identities
    depends on the membership service provider used, and therefore, the underlying
    system used to organize digital identities.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但并非最不重要的，身份可以被吊销。当发生这种情况时，身份失去了在网络中操作的能力。用于吊销身份的机制取决于所使用的成员服务提供者，因此，用于组织数字身份的基础系统也有所不同。
- en: By leveraging the MSP, which we explore in the next section, other ways to organize
    digital identities can be supported.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用我们在下一节中探讨的 MSP，可以支持其他组织数字身份的方式。
- en: Membership Service Provider
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 成员服务提供者
- en: The *membership service provider* (*MSP*) provides Fabric a convenient abstraction
    that hides all the cryptographic mechanisms and protocols behind the definition
    and validation of identities and authentication. Indeed, an MSP provides a generic
    notion of identity and the rules to assert its validity. Also, it provides an
    API for authentication based on the well-defined concept of digital signatures.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*成员服务提供者*(*MSP*)为 Fabric 提供了一个方便的抽象，隐藏了身份和认证的定义和验证背后的所有加密机制和协议。实际上，MSP 提供了一个通用的身份概念和断言其有效性的规则。此外，它基于数字签名的明确定义概念提供了身份验证的
    API。'
- en: Fabric uses one or more MSPs to manage identities and their life cycles in its
    network. As a result of MSP abstraction, interoperability among different membership
    standards and architectures becomes a reality. In fact, when a new channel is
    created, the list of MSPs governing that channel must be included in the genesis
    block. This list can then subsequently be updated by issuing a proper channel
    configuration transaction.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Fabric 使用一个或多个 MSP 来管理其网络中的身份及其生命周期。由于 MSP 抽象，不同成员标准和架构之间的互操作性成为现实。事实上，当创建新通道时，管理该通道的
    MSP 列表必须包含在创世区块中。然后可以通过发出适当的通道配置交易来随后更新此列表。
- en: On the other hand, an MSP does not prescribe how identities should be issued,
    only how they should be validated. Indeed, once an identity is issued and assigned
    to a Fabric entity, this entity can then start interacting with the network. For
    example, clients use these credentials to authenticate their transactions, and
    peers use these credentials to authenticate transaction processing results (endorsements).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，MSP 不规定身份应该如何发放，只规定了应该如何验证身份。事实上，一旦身份被发放并分配给一个 Fabric 实体，这个实体就可以开始与网络交互。例如，客户端使用这些凭据来验证他们的交易，而对等体使用这些凭据来验证交易处理结果（认可）。
- en: To be more concrete, let’s consider Fabric’s default MSP implementation based
    on the X.509 standard. The *X.509* standard, commonly used on the internet, prescribes
    how public-key certificates must be formatted and used. These certificates carry
    public keys and information about the owners of these keys. Each certificate is
    signed by a certificate authority whose public key is stored in another certificate
    called the *root certificate*. Intermediate certificates are allowed, forming
    a chain of certification.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，让我们考虑基于 X.509 标准的 Fabric 默认 MSP 实现。*X.509* 标准通常用于互联网，规定了公钥证书的格式和使用方式。这些证书携带了公钥以及这些密钥的所有者的信息。每个证书都由一个证书颁发机构签名，其公钥存储在另一个称为*根证书*的证书中。中间证书也是允许的，形成一条认证链。
- en: In this context, an X.509-based MSP is defined by a set of root and intermediate
    certificates identifying the sources of trust for identity certification and a
    certificate revocation list (CRL). An identity is simply an X.509 certificate.
    We say that an identity is valid under a given X.509-based MSP if the corresponding
    certificate has been issued by one of the authorities listed in the MSP and is
    not in the list of revoked certificates. Keep in mind that certificate authorities
    typically maintain CRLs. When an authority updates its CRL, the MSP definition
    must be updated consequently. In Fabric, an MSP definition can be updated by issuing
    a valid configuration transaction. We talk about this in the coming sections.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个背景下，基于 X.509 的 MSP 是由一组根和中间证书来定义的，这些证书用于标识身份认证的信任源，以及一个证书吊销列表（CRL）。一个身份简单地就是一个
    X.509 证书。如果相应的证书由 MSP 中列出的权威机构之一颁发，并且不在吊销证书列表中，我们说这个身份在给定的基于 X.509 的 MSP 下是有效的。请记住，证书颁发机构通常会维护
    CRL。当一个权威机构更新其 CRL 时，MSP 的定义必须相应地更新。在 Fabric 中，可以通过发布有效的配置事务来更新 MSP 定义。我们将在接下来的章节中详细讨论这个问题。
- en: To recap, the X.509-based MSP allows Fabric to support almost any PKI whose
    certificates are issued by the major certificate authorities on the market (the
    same as normally used in a browser). If needed, a PKI can be put in place by using
    Hyperledger Fabric CA, a Fabric companion project that implements a certificate
    authority.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，基于 X.509 的 MSP 使 Fabric 能够支持几乎任何 PKI，其证书由市场上主要的证书颁发机构（与浏览器中通常使用的相同）颁发。如果需要，可以通过使用
    Hyperledger Fabric CA 来实现 PKI，这是一个 Fabric 的伴随项目，实现了证书颁发机构。
- en: It is worth mentioning that X.509 is not the only technology supported by Fabric.
    For additional privacy, Fabric is equipped with a technology called *Identity
    Mixer* (*Idemix*). This cryptographic protocol offers strong authentication while
    maintaining privacy. This lets a transactor obtain a valid member status for interacting
    with the network while safeguarding its own identity. Likewise, a transactor can
    sign multiple transactions without revealing any traces of its signatures. Though
    the anonymous operation of a transactor is possible, the transaction content can
    still be used to link multiple transactions and needs to be protected in other
    ways, such as using private data collections or advanced crypto technologies like
    ZKPs.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，X.509 不是 Fabric 支持的唯一技术。为了额外的隐私，Fabric 配备了一种称为 *Identity Mixer* (*Idemix*)
    的技术。这种加密协议提供了强大的身份验证同时保持隐私。这使得交易者可以获取与网络交互的有效成员状态，同时保护自己的身份。同样，交易者可以在不透露任何签名痕迹的情况下签署多个交易。虽然交易者的匿名操作是可能的，但交易内容仍然可以用于将多个交易链接在一起，并需要通过其他方式保护，例如使用私有数据集合或像
    ZKPs 这样的高级加密技术。
- en: At this point, it should be clear that the permissioned nature of Fabric heavily
    depends on the MSPs available in a given network. At one extreme, Fabric becomes
    permissionless as soon as a given network is equipped with an MSP that accepts
    any public keys like Bitcoin. Under such circumstances, the public parameters
    of the signature scheme are set in the genesis block. (An exception can still
    be represented by the orderers whose identities might be fixed in the genesis
    block.)
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，应该清楚 Fabric 的许可性质在很大程度上取决于给定网络中可用的 MSPs。在一个极端情况下，只要给定网络配备了一个像比特币那样接受任何公钥的
    MSP，Fabric 就变得无需许可。在这种情况下，签名方案的公共参数被设置在创世块中。（一个例外仍然可以由订单者代表，其身份可能在创世块中被固定。）
- en: As we have seen, the MSP equips Fabric with a well-defined concept of identity
    on top of which a complex access-control policy can be defined.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，MSP 为 Fabric 提供了一个明确定义的身份概念，复杂的访问控制策略可以在此基础上定义。
- en: Policies
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 策略
- en: In the previous section, you saw that the MSP gives Fabric the ability to recognize
    valid identities. Then, *policies* are the tools Fabric provides to reason about
    these identities. Policies configure the structure for how decisions are made
    within the network. In other words, these policies configure who can do what and
    on which element of the network.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，您看到 MSP 赋予了 Fabric 识别有效身份的能力。然后，*策略*是 Fabric 提供的用于思考这些身份的工具。策略配置了网络内如何做出决策的结构。换句话说，这些策略配置了谁可以在网络的哪个元素上做什么。
- en: Policies are overarching in Fabric, and they are the golden tool used to set
    the governance of the network. A policy governs who is allowed to access a given
    ledger, who can deploy a chaincode, and who can upgrade the channel configuration.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 策略在 Fabric 中是首要的，并且它们是设置网络治理的黄金工具。策略规定了谁被允许访问给定账本，谁可以部署链代码，以及谁可以升级通道配置。
- en: The first place where we encounter policies in Fabric is the *system channel*.
    Each Fabric network must define a system channel that, among other things, contains
    the MSPs that identify the parties forming the ordering service (also called *ordering
    organizations*), and the MSPs identifying the identities that can transact in
    the network (also known as *consortium organizations*). Then, using those MSPs,
    the system channel identifies who can create application channels (or simply *channels*)
    via a policy included in the system channel’s genesis block.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Fabric 中我们遇到策略的第一个地方是 *系统通道*。每个 Fabric 网络必须定义一个系统通道，其中包含了识别形成排序服务的各方（也称为 *排序组织*）的
    MSP，以及识别可以在网络中进行交易的身份的 MSP（也称为 *联合组织*）。然后，使用这些 MSP，系统通道通过包含在系统通道创世块中的策略来确定谁可以创建应用通道（或简称
    *通道*）。
- en: A channel’s *genesis block* is the second place where we come across policies.
    Indeed, creating a new channel means setting policies to add and remove members,
    and to approve a chaincode before it is defined and committed to the channel,
    among others. If policies are not set, they are inherited from the system channel.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 通道的 *创世块* 是我们遇到策略的第二个地方。事实上，创建一个新通道意味着设置策略来添加和删除成员，并在定义和提交到通道之前批准链码等。如果未设置策略，则从系统通道继承。
- en: Administrators can update a channel’s configuration by issuing a proper configuration
    update transaction. This transaction must be endorsed by enough entities that
    together can satisfy the specific policy the update is targeting. After the transaction
    gets committed, the changes are to be considered operational.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 管理员可以通过发出适当的配置更新事务来更新通道的配置。此事务必须由足够多的实体背书，这些实体一起可以满足目标更新的特定策略。事务提交后，更改将被视为操作性。
- en: 'The most commonly used form of policy in Fabric is called a *signature policy*.
    This is simply a monotone Boolean formula. The supported Boolean operators are
    `AND`, `OR`, and `NOutOf`, and they can be combined with flexibility. Here is
    an example: `OR(''Org1.peer'', ''Org2.peer'')`. This policy requires that at least
    a peer identity, valid under either the MSP named `Org1` or the MSP named `Org2`,
    provides a signature.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Fabric 中最常用的策略形式称为 *签名策略*。这只是一个单调布尔表达式。支持的布尔运算符有 `AND`、`OR` 和 `NOutOf`，它们可以灵活组合。以下是一个示例：`OR('Org1.peer',
    'Org2.peer')`。此策略要求至少一个对等身份，在名为 `Org1` 或名为 `Org2` 的 MSP 下有效，提供签名。
- en: This example also shows another useful tool that Fabric provides, called an
    *MSP principal*. A principal represents a group of identities that have some common
    characteristics. For instance, the `peer` MSP principle identifies all identities
    that are peers in a Fabric network. Fabric offers a series of handy principles
    to identify clients, peers, orderers, administrators, and so on.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子还展示了 Fabric 提供的另一个有用工具，称为 *MSP 主体*。主体表示具有某些共同特征的一组身份。例如，`peer` MSP 主体标识在
    Fabric 网络中作为对等体的所有身份。Fabric 提供了一系列方便的原则来识别客户端、对等体、排序器、管理员等。
- en: To summarize, policies are the tools that administrators can use to govern a
    Fabric network. Policies can be set to configure a network to be permissionless
    by allowing anyone to perform any operation (again, the ordering service may be
    an exception) or can be set to restrict access to specific processes.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，策略是管理员可以使用的工具，用于管理 Fabric 网络。可以设置策略以通过允许任何人执行任何操作（再次说明，订购服务可能是一个例外）来配置网络为无权限，也可以设置策略以限制对特定过程的访问。
- en: Nodes
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 节点
- en: '*Nodes* are the communication entities of the blockchain. A node is just a
    logical function in the sense that multiple nodes of different types can run on
    the same physical server. What counts is that the nodes are grouped *into trusted
    domains* and associated with the logical entities that control them.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*节点* 是区块链的通信实体。节点在某种程度上只是逻辑功能，这意味着不同类型的多个节点可以在同一物理服务器上运行。重要的是将节点分组 *成可信域* 并与控制它们的逻辑实体相关联。'
- en: 'A node has an identity, and this identity allows the node to perform certain
    operations. We can identify the following nodes in a Fabric network:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 节点具有身份，此身份允许节点执行某些操作。我们可以在 Fabric 网络中识别以下节点：
- en: Clients
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端
- en: Initiate the life cycle of a transaction in Fabric.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化 Fabric 中交易的生命周期。
- en: Endorsers
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 背书者
- en: Responsible for the execution of the business logic encapsulated in programs
    called *chaincodes*.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 负责执行封装在称为 *链代码* 的程序中的业务逻辑。
- en: Orderers
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 订购者
- en: Participate in the consensus algorithm to decide the order of transactions.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 参与共识算法以决定交易的顺序。
- en: Committers
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 提交者
- en: Fetch the ledger from the orderers and apply the validation logic to establish
    the validity of each ordered transaction. Endorsers are also committers.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 从订购者处获取分类帐，并应用验证逻辑以建立每个已排序交易的有效性。认可者也是提交者。
- en: Sometimes we will use the word *peer* to mean either an endorser or a committer.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们会用 *对等方* 这个词来指代背书者或提交者之一。
- en: Chaincode
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 链代码
- en: The widely used term *smart contract* is known as *chaincode* in Hyperledger
    Fabric. A chaincode is a piece of code that implements the application logic and
    runs during the execution phase. Besides exposing a predefined interface, chaincode
    developers are free to encode the computation in the best way they find to fit
    their goals. Fabric, for example, does not require the chaincode to be deterministic.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Hyperledger Fabric 中，广泛使用的术语 *智能合约* 被称为 *链代码*。链代码是实现应用逻辑并在执行阶段运行的代码片段。除了公开预定义接口外，链代码开发人员可以自由编码计算方式，以最好地实现他们的目标。例如，Fabric
    不要求链代码是确定性的。
- en: Chaincode is installed and instantiated in the peers of a channel required to
    execute it by duly authorized members and through a *Fabric chaincode life cycle*.
    A chaincode can be updated as well by using a similar process.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Chaincode 被安装并在通道的对等节点上实例化，以便由合适授权的成员执行，并通过 *Fabric 链代码生命周期*。通过类似的过程也可以更新链代码。
- en: Each chaincode must define an *endorsement policy* that is evaluated by the
    committers in the validation phase. A typical endorsement policy lets the chaincode
    specify the endorsers for a transaction in the form of a set of peers necessary
    for endorsement. It represents the trust assumption for the correct execution
    of the specific business logic encoded in the chaincode.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 每个链码必须定义一个*背书策略*，由验证阶段的提交者进行评估。典型的背书策略允许链码以一组对于交易必要的背书者的形式指定背书者。它代表了对编码在链码中的特定业务逻辑的正确执行的信任假设。
- en: 'A chaincode must expose two functions: `Init` and `Invoke`. `Init` is used
    to initialize any data structure the chaincode might need and is invoked only
    once, at initialization time. `Invoke` is the entry point to the business logic
    offered by the chaincode. A chaincode receives arguments, and on these, the chaincode
    decides what operation to execute.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 一个链码必须公开两个函数：`Init`和`Invoke`。`Init`用于初始化链码可能需要的任何数据结构，仅在初始化时调用一次。`Invoke`是链码提供的业务逻辑的入口点。链码接收参数，并根据这些参数决定要执行的操作。
- en: 'A chaincode can be thought of as a namespace inside the ledger that groups
    a set of key-value pairs managed by that chaincode. Those pairs are subject to
    change by completing a Fabric transaction life cycle. Let’s review this life cycle.
    The following steps are required to successfully commit a transaction:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 一个链码可以被看作是账本中的一个命名空间，它组织了由该链码管理的一组键值对。这些键值对可以通过完成 Fabric 交易生命周期来进行更改。让我们回顾一下这个生命周期。要成功提交交易，需要以下步骤：
- en: Propose the transaction. A client prepares and sends a transaction proposal
    to the endorsers of the chaincode the proposal is targeting. The transaction proposal
    specifies the chaincode and the arguments for the chaincode invocation.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提出交易。客户端准备并发送交易提案到目标链码的背书者。交易提案指定了链码和链码调用的参数。
- en: Execute the transaction proposal. The endorsers that receive the proposal execute,
    or simulate, the chaincode with the arguments provided in the proposal (the `Invoke`
    function is invoked). The result of the simulation consists of a return value
    and a read/write set.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行交易提案。接收提案的背书者执行或模拟使用提案中提供的参数在链码中运行（调用`Invoke`函数）。模拟的结果包括一个返回值和一个读/写集。
- en: The *read/write set* is a data structure that captures the updates to and the
    dependencies on the world state (more on this in [“Ledger”](#ledger)). The *read
    set* contains a list of unique keys and their current version numbers (the value
    does not need to be added because it is already known to the network). On the
    other hand, the *write set* contains the updated list of unique keys. In this
    case, the new values assigned to the keys must be included. Finally, a marker
    can be used to say that a key is deleted and should not be available anymore in
    the world state.
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*读/写集* 是一个数据结构，用于记录对世界状态的更新以及对其依赖关系（更多内容请参阅[“账本”](#ledger)）。*读集* 包含一组唯一键和它们当前的版本号（值不需要添加，因为网络已知）。另一方面，*写集*
    包含更新后的唯一键列表。在这种情况下，必须包含分配给键的新值。最后，可以使用一个标记来表示一个键已被删除，并且在世界状态中不应再可用。'
- en: We call the execution of the chaincode a *simulation* because the world state
    does not change at this stage. These are only proposed changes to the world state
    that need to be validated later. All peers that execute the chaincode sign the
    output of the execution and send it back to the application. This signature is
    called an *endorsement*.
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将链码的执行称为*模拟*，因为在此阶段世界状态不会改变。这些仅是对世界状态的建议性更改，需要稍后进行验证。执行链码的所有对等方都会签署执行的输出并将其发送回应用程序。此签名称为*背书*。
- en: Assemble the transaction. The client bundles all endorsers’ responses (the endorsements)
    into a transaction (an endorser transaction) and sends it to the ordering service.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 组装事务。客户端将所有背书人的响应（背书）捆绑到一个事务中（一个背书者事务），并将其发送到排序服务。
- en: Order the transaction. The ordering service collects incoming transactions and
    assembles them into blocks based on a consensus algorithm. Once a block is complete,
    the ordering service sends it to the committing peers.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对事务排序。排序服务收集传入的事务，并根据共识算法将它们组装成块。一旦一个块完成，排序服务就会将其发送给提交对等方。
- en: 'Validate the transaction. When the committing peers receive a new block, they
    append it to the ledger and validate every transaction in that block. Validation
    consists of ensuring that two requirements are satisfied: the endorsements of
    a transaction satisfy the endorsement policy for that chaincode, and the read/write
    set does not conflict with concurrent updates that were committed before. Only
    if a transaction is valid, the world state is updated by applying the changes
    in the read/write set.'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证事务。当提交对等方接收到一个新块时，它们将其附加到账本上，并验证该块中的每个事务。验证包括确保满足两个要求：事务的背书满足该链码的背书策略，并且读/写集不与已提交的并发更新冲突。只有当事务有效时，世界状态才会通过应用读/写集中的更改而更新。
- en: Decide transaction finality. As a nonmandatory step, the client can contact
    a selected number of peers in the network to ask about the finality of the transaction.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 决定事务的最终性。作为非强制步骤，客户端可以联系网络中选定数量的对等方，询问事务的最终性。
- en: A chaincode can also be invoked to retrieve state information as a result of
    a computation or just a lookup in the world state (e.g., the value of a certain
    key). This operation is sometimes called a *query*. In this case, steps 3 to 6
    can be avoided. The client is just retrieving information, not updating. Suppose
    the client decides to assemble a transaction with the received endorsements and
    submits that transaction for ordering. In that case, the client is making a *strong
    query* because the result is time-stamped on the ledger and can be verified by
    anyone.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一个链码也可以被调用来检索状态信息，作为计算的结果或者仅仅是在世界状态中查找（例如，某个键的值）。这个操作有时被称为 *查询*。在这种情况下，步骤 3
    到 6 可以被避免。客户端只是检索信息，而不是更新。假设客户端决定组装一个包含接收到的背书的交易并提交该交易进行排序。在这种情况下，客户端是在进行 *强查询*，因为结果在账本上有时间戳，可以被任何人验证。
- en: Long story short, the endorsers do not differentiate between an invocation or
    a query. The entry point is always the `Invoke` function.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 长话短说，背书人不区分调用还是查询。入口点始终是 `Invoke` 函数。
- en: Ledger
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 账本
- en: The *ledger* is one of the fundamental pieces within the entire blockchain and
    in Hyperledger Fabric as well. The ledger is stored as identical copies in each
    of the nodes that make up the network. Thus, each Fabric channel is bound to a
    ledger. Notice that a Fabric network can contain multiple channels, and in this
    sense, a channel can be seen as a way to partition data in multiple shards.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*账本* 是整个区块链以及 Hyperledger Fabric 中的一个基本组成部分。账本以相同的副本存储在构成网络的每个节点中。因此，每个 Fabric
    通道都与一个账本绑定。注意，一个 Fabric 网络可以包含多个通道，在这个意义上，通道可以被看作是在多个分片中分割数据的一种方式。'
- en: 'When we talk about a ledger, we refer to two key concepts: the world state
    and the blockchain. The *world state* is a part of the blockchain that refers
    to key-value pairs containing the latest data recorded within it. It is an easier
    way to access stored data. And then the *blockchain* is something bigger. It is
    all the records stored within the blockchain, in the form of transactions. These
    transactions are stored in blocks to be consulted later.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论账本时，我们指的是两个关键概念：世界状态和区块链。*世界状态* 是区块链的一部分，它指的是其中包含的最新数据的键值对。这是访问存储数据的一种更简单的方式。而
    *区块链* 则更大。它是区块链中存储的所有记录，以交易形式存储。这些交易存储在块中以供以后查询。
- en: Because of the execute-order-validate model used by Fabric, the ledger can be
    distinguished as a *raw leger* or *validated ledger*. The former represents the
    sequence of transactions ordered by the ordering service; the latter represents
    the sequence of valid transactions. It is from the validated ledger that the world
    state is constructed.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Fabric 使用的执行-排序-验证模型，账本可以区分为 *原始账本* 或 *验证账本*。前者表示由订单服务排序的交易序列；后者表示有效交易的序列。世界状态是从验证账本构建的。
- en: The Ordering Service
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 订单服务
- en: 'The orderers run the *ordering service*—a communication that provides a guarantee
    of delivery. The ordering service can be implemented in various ways: from a centralized
    service (used, for example, in development and testing) to distributed protocols
    that target different networks and different types of nodes.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 排序者运行*排序服务*——一种提供交付保证的通信。排序服务可以以各种方式实现：从集中式服务（例如，在开发和测试中使用）到针对不同网络和不同类型节点的分布式协议。
- en: The ordering service provides a shared communication channel to the nodes of
    a Fabric network, offering a broadcast service for messages containing transactions.
    Clients connect to the ordering service and can broadcast messages on a given
    channel, as long as the client has permissions to do that, which are then delivered
    to all peers. The channel broadcasts the same messages to all connected peers
    and sends them to all peers in the same logical order. The communicated messages
    are the candidate transactions for inclusion in the blockchain state.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 排序服务为 Fabric 网络的节点提供了共享通信通道，为包含交易的消息提供了广播服务。客户端连接到排序服务，并且可以在给定通道上广播消息，只要客户端有权限这样做，这些消息就会被传递到所有对等方。通道将相同的消息广播到所有连接的对等方，并按照相同的逻辑顺序发送给所有对等方。通信的消息是区块链状态中包含的候选交易。
- en: In short, a defined group of nodes orders transactions in blocks and broadcasts
    them to all connected peers. Some peers can interact directly with the ordering
    service to broadcast blocks in the network to make the block delivery fast. Such
    a dissemination process is done via a gossip protocol, which is particularly useful
    by preventing each peer from connecting to the ordering service.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，一组定义好的节点对交易进行排序并将其广播到所有连接的对等方。一些对等方可以直接与排序服务交互，以在网络中广播区块以加快区块传递速度。这样的传播过程通过一种八卦协议进行，通过阻止每个对等方连接到排序服务特别有用。
- en: Private Collections of Data
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 私有数据集合
- en: 'Among the evolutions of Hyperledger Fabric technology, one of the largest was
    the creation of *private data collections* (*PDCs*). The two primary use cases
    of a PDC are as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Hyperledger Fabric 技术的演变中，其中一个最大的是创建*私有数据集合*（*PDCs*）。PDC 的两个主要用例如下：
- en: When the ordering service cannot be trusted for confidentiality
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当无法信任排序服务的保密性时
- en: When data in a single ledger or Fabric channel must be partitioned and made
    visible only to certain parties
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个单一分类账或 Fabric 通道中的数据需要被划分并且只对特定方参与方可见时
- en: Each PDC is attached to a list of organizations and properties that define how
    private data should be disseminated and endorsed. With Fabric v2+, PDC definitions
    are part of the chaincode definition. The chaincode developer can use a specific
    API to manipulate those collections.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 PDC 都附属于一系列组织和属性，这些组织和属性定义了私有数据应如何传播和认可。在 Fabric v2+ 中，PDC 定义是链代码定义的一部分。链代码开发人员可以使用特定的
    API 来操作这些集合。
- en: A PDC can then be thought of as a subnamespace defined in the chaincode’s namespace.
    A PDC consists of a private part and a public part. The private part contains
    data disseminated via a peer-to-peer protocol among the organizations’ peers belonging
    to the PDC. The public part contains hashes of the private data that are endorsed
    and committed to the ledger. By default, these hashes are not salted; therefore,
    they can be susceptible to dictionary attacks. The chaincode developers should
    use proper strategies to avoid that.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，PDC 可以被视为在链码命名空间中定义的子命名空间。PDC 包括一个私有部分和一个公共部分。私有部分包含通过对属于 PDC 的组织的对等节点进行点对点协议传播的数据。公共部分包含私有数据的哈希，这些哈希经过认可并提交到账本。默认情况下，这些哈希值未经盐处理；因此，它们可能容易受到字典攻击。链码开发人员应使用适当的策略来避免这种情况。
- en: Summary
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, you learned about the features and components of Hyperledger
    Fabric. We started by reviewing its key features, such as assets, privacy, and
    consensus. We then discussed the following important elements of the blockchain
    network: identities, membership service provider, policies, peers, smart contracts
    and chaincode, ledger, ordering service, and private data collections. Understanding
    the Fabric network and how its components interact with one another is essential
    for building blockchain applications in Hyperledger Fabric.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您了解了 Hyperledger Fabric 的特性和组件。我们首先回顾了其关键特性，如资产、隐私和共识。然后我们讨论了区块链网络的以下重要元素：身份、成员服务提供商、策略、对等节点、智能合约和链码、账本、排序服务和私有数据集。了解
    Fabric 网络及其组件如何相互作用对于在 Hyperledger Fabric 中构建区块链应用程序至关重要。
- en: We hope that you have developed a good foundation for building your first blockchain
    application in Fabric by now. Indeed, this chapter gave you a high-level review
    of all parts that usually work in conjunction with one another in an enterprise
    Fabric blockchain application.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望您现在已经为在 Fabric 中构建您的第一个区块链应用程序打下了良好的基础。确实，本章为您提供了企业 Fabric 区块链应用程序中通常与彼此配合使用的所有部分的高级概述。
- en: In brief, in all previous chapters, we moved from a high-level hierarchy to
    a lower one by covering the concepts of blockchain, the Hyperledger family, and
    Hyperledger Fabric step by step. Now that we have covered all practical concepts,
    we will proceed with coding. We will start doing hands-on coding in the next chapter
    by building the first chaincode, or Fabric smart contract.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，在所有之前的章节中，我们通过逐步介绍区块链、Hyperledger 家族和 Hyperledger Fabric 的概念，从高级层次结构逐渐转向低级别。现在我们已经涵盖了所有的实际概念，我们将继续进行编码。在下一章中，我们将通过构建第一个链码或
    Fabric 智能合约来开始进行实际编码。
