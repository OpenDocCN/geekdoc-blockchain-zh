- en: © The Author(s), under exclusive license to APress Media, LLC, part of Springer
    Nature 2023B. Wu, B. WuBlockchain for Teens[https://doi.org/10.1007/978-1-4842-8808-5_2](https://doi.org/10.1007/978-1-4842-8808-5_2)
  prefs: []
  type: TYPE_NORMAL
- en: '2. Cryptography: The Backbone of Blockchain Security'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Brian Wu^([1](#Aff3)  ) and Bridget Wu^([1](#Aff3))(1)Livingston, NJ, USA
  prefs: []
  type: TYPE_NORMAL
- en: Blockchains are built based on a range of different cryptographic concepts.
    From safeguarding wallets and securing transactions to protecting consensus protocols
    and encrypting private data for anonymous accounts, almost everything needs cryptography
    to ensure proper functioning. Cryptography is the backbone of blockchain security.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will dive into everything you need to know about cryptography in
    blockchains, starting with the basics. Then, you will be introduced to the classical
    symmetric key cryptography, asymmetric cryptography, and more. As you advance,
    you will become well versed in how digital signatures work.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will also cover how to utilize hash functions to hash data, and
    at the end of the chapter, you will get an in-depth look at elliptic curve cryptography
    (ECC), a key type of encryption cryptography that is used in blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, the following topics related to cryptography will be discussed:'
  prefs: []
  type: TYPE_NORMAL
- en: The basics of cryptography
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Symmetric key cryptography
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asymmetric key cryptography
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Digital signatures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hash algorithms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ECC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Derived Ethereum addresses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Basics of Cryptography
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Chapter [1](535492_1_En_1_Chapter.xhtml), we have briefly discussed SHA-256
    hashing cryptography which is used to hash block data.
  prefs: []
  type: TYPE_NORMAL
- en: Let's use an example to illustrate how secure messages can be sent to the public.
    Suppose Alice sends a personal message to Bob. Alice wants this message to be
    private. Only Bob can understand the message, and the message cannot be altered
    during transmission. The message sent over the Internet could secretly be intercepted
    and recorded by an intruder (see Figure [2-1](#Fig1)). How can Alice and Bob stop
    this from happening? This is where cryptography comes in.![](../images/535492_1_En_2_Chapter/535492_1_En_2_Fig1_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: An illustration of a message sent by Alice to bob over the internet secretly
    intercepted and recorded by an intruder.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2-1
  prefs: []
  type: TYPE_NORMAL
- en: A message sent through a network
  prefs: []
  type: TYPE_NORMAL
- en: The word “crypto” comes from the Greek word “kryptós,” meaning “hidden or secret.”
  prefs: []
  type: TYPE_NORMAL
- en: “Cryptography” means “secret writing” and allows for the exchange of secure
    messages between willing parties.
  prefs: []
  type: TYPE_NORMAL
- en: The message is converted into a secret code equivalent called “ciphertext” via
    an encryption algorithm to prevent unauthorized access. The ciphertext is then
    sent over a public network, it is decrypted at the receiving end, and the recipient
    can view its contents.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, Alice uses a key to encrypt her message, converting
    it to ciphertext, and she sends it to Bob over the Internet. She does not need
    to worry about a hacker having access to her private message. To read ciphertext,
    a hacker must use a decryption key. When Bob receives this ciphertext message,
    he can use a key to recover the original plaintext via decryption.![](../images/535492_1_En_2_Chapter/535492_1_En_2_Fig2_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: A schematic depicts encrypting and decrypting of a message through the internet
    by Alice to Bob. The labeled process is my secret text, encrypt, ciphertext, decrypt,
    and text.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2-2
  prefs: []
  type: TYPE_NORMAL
- en: Encrypting and message over the Internet
  prefs: []
  type: TYPE_NORMAL
- en: 'Cryptography is mainly divided into three categories: symmetric key cryptography,
    asymmetric key cryptography, and keyless primitives such as hash function.'
  prefs: []
  type: TYPE_NORMAL
- en: Symmetric Key Cryptography
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Symmetric key cryptography is a cryptographic algorithm that uses a shared secret
    key between a sender and a receiver to encrypt and decrypt data. This secret key
    is called a symmetric key.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, Alice and Bob share the same secret key. Alice uses
    the secret key to encrypt the message, and the secret key is used in the decryption
    process when Bob reads the message. This shows how symmetric encryption works.
  prefs: []
  type: TYPE_NORMAL
- en: Symmetric encryption is typically more efficient than asymmetric encryption.
    Therefore, it is often used with large amounts of data encryption, personal data
    encryption, and decryption.
  prefs: []
  type: TYPE_NORMAL
- en: While there are several symmetric algorithms, the first US standard was DES.
  prefs: []
  type: TYPE_NORMAL
- en: Symmetric key cryptography can use either stream ciphers or block ciphers to
    encrypt data. Using stream ciphers is the preferred way to encrypt data in most
    cases.
  prefs: []
  type: TYPE_NORMAL
- en: Stream Ciphers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Stream ciphers encrypt plaintext messages one bit or byte at a time, resulting
    in a single-character-in, single-character-out cipher. It applies a random keystream
    of characters and the XOR operation to each binary digit in a data stream.
  prefs: []
  type: TYPE_NORMAL
- en: XOR is a Boolean logic operation and is known as the “exclusive or” or exclusive
    disjunction. It yields true when only one out of two inputs is true. If both or
    no inputs are true, the XOR operation output is false.
  prefs: []
  type: TYPE_NORMAL
- en: The truth table of an XOR logic is shown in Table [2-1](#Tab1) where 0 means
    FALSE, and 1 means TRUE.Table 2-1
  prefs: []
  type: TYPE_NORMAL
- en: Truth table for XOR
  prefs: []
  type: TYPE_NORMAL
- en: '|   | Input | Output |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **A** | **B** | **A XOR B** |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: 'So, if Bit A is 11000101, and Bit B is 10100110, the following shows what the
    output looks like when the XOR operation is applied for these two binary bits:'
  prefs: []
  type: TYPE_NORMAL
- en: '10101'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XOR     00110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Output     10011
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Keystream characters can be random combinations of any letters or numbers.
    Assume that we have a stream of plaintext bytes (p1, p2, p3, ..., pi), and the
    keystream generator outputs a stream of bytes (k1, k2, k3, ..., ki). To encrypt
    the stream of ciphertext bytes, the operand XOR needs to be applied to each plaintext
    and key to generate and encrypt the stream of ciphertext bytes (c1, c2, ..., ci).
    This can be expressed through the following:'
  prefs: []
  type: TYPE_NORMAL
- en: c1 = p1 XOR k1, ..., ci = pi XOR ki
  prefs: []
  type: TYPE_NORMAL
- en: Figure [2-3](#Fig3) illustrates stream cipher encryption. P1 is 00110101, and
    K1 is 11100011\. With XOR operation, the ciphertext encrypt result is 11010110.
  prefs: []
  type: TYPE_NORMAL
- en: 00110101 (plaintext)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XOR     11100011 (key)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Output     11010110 (plaintext)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../images/535492_1_En_2_Chapter/535492_1_En_2_Fig3_HTML.png)'
  prefs: []
  type: TYPE_IMG
- en: An illustration depicts the stream cipher encryption, processed in 3 steps data
    stream of P 1, P 2, to P i; keystream of K 1, K 2, to K i; and X O R of C 1, C
    2, to C i. P 1 is 00110101 plus K 1 is 11100011 implies C 1 as 11010110.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2-3
  prefs: []
  type: TYPE_NORMAL
- en: Stream cipher encryption
  prefs: []
  type: TYPE_NORMAL
- en: 'To decrypt the plaintext bytes, we apply the XOR operation with the ciphertext
    and key. The output will get the original plaintext bytes. This operation can
    be expressed by pi = ci XOR ki:'
  prefs: []
  type: TYPE_NORMAL
- en: 11010110 (ciphertext)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XOR     11100011 (key)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Output     00110101 (plaintext)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Block Ciphers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The main difference between a block cipher and a stream cipher is that a block
    cipher takes a fixed-size block of plaintext bytes as a single unit and encrypts
    block data as a ciphertext byte. Generally, the block size is the same as the
    key size.
  prefs: []
  type: TYPE_NORMAL
- en: Assume we have a block of plaintext bytes **p** and key bytes **k**. To encrypt
    the block of ciphertext byte **c**, we need to encrypt the plaintext with **key
    c = encrypt (p, k)** and recover the plaintext by decrypting the ciphertext with
    **key p = decrypt (c, k).**
  prefs: []
  type: TYPE_NORMAL
- en: Each block is of equal size. Let’s say the input is larger than the number of
    blocks, where the input size is 38 bits, and the block size is 6 bits. After 6
    blocks, there will be 2 bits left (38 – 6 * 6 = 2). In this case, we typically
    add padding (two 0) and append it to the end of the block.
  prefs: []
  type: TYPE_NORMAL
- en: Figure [2-4](#Fig4) shows an example of block cipher encryption. The plaintext
    is divided by n block (p[n]), and each block uses the same key to encrypt a ciphertext.
    The encryption process will start from the first block and end on the last block,
    and eventually, all block data will be encrypted.![](../images/535492_1_En_2_Chapter/535492_1_En_2_Fig4_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: A diagram of 3 blocks. The labels in 3 blocks are P 1, P 2, and P n and P1 leads
    to key, which leads to C 1; P 2 leads to key, which leads to C 2; and P n leads
    to key, which leads to C n. The process starts from the first block and ends on
    the last block.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2-4
  prefs: []
  type: TYPE_NORMAL
- en: Block cipher encryption
  prefs: []
  type: TYPE_NORMAL
- en: The most commonly used types of block ciphers include advanced encryption standard
    (AES), data encryption standard (DES), and triple DES (3DES or TDEA).
  prefs: []
  type: TYPE_NORMAL
- en: Asymmetric Key Cryptography
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Symmetric cryptography is relatively simpler and faster than asymmetric cryptography,
    only needing one key. It is typically used for big data encryption/decryption
    and confidentiality of bank transactions. Symmetric cryptography must share the
    same secret key before data encryption. In the previous example, the case becomes
    complex when Alice needs to send a private message to many people. If Alice uses
    a symmetric key (K) to encrypt all these messages and shares this key with Bob
    and others, there is a great risk that someone can secretly give a copy of K to
    others without Alice's knowledge. In this case, the entire communication channel
    has been compromised, and many unintended people can read and modify the messages
    and send them to any other members. To avoid this security risk, Alice must consider
    creating a large number of keys for each person that the message is sent to, but
    Alice will then have to remember all the secret keys. Alice needs to call her
    friends or be involved in face-to-face meetings over a trusted channel to distribute
    the secret keys. As a result, symmetric cryptography could quickly become less
    practical for many participants. This problem affected the industry in relation
    to the use of encryption for quite a long time, but in 1976, Diffie and Hellman
    introduced the concept of public key encryption, also known as asymmetric cryptography.^([1](#Fn1))
  prefs: []
  type: TYPE_NORMAL
- en: Public and Private Keys
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whitfield Diffie and Martin Hellman described how public key encryption works
    when two communicating parties exchange information across an insecure channel
    using a key pair consisting of a public key and a private key.
  prefs: []
  type: TYPE_NORMAL
- en: A private key is known only to the owner, and a public key is considered public
    information that is available to anyone. Each key has been designed for a specific
    purpose.
  prefs: []
  type: TYPE_NORMAL
- en: The public key is used to encrypt a message and convert it into ciphertext.
    The private key is used to decrypt a message that has been encrypted with the
    public key.
  prefs: []
  type: TYPE_NORMAL
- en: How the Diffie-Hellman Algorithm Works
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The Diffie-Hellman algorithm is based on a mathematic principle and uses the
    following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: g^a (mod p)
  prefs: []
  type: TYPE_NORMAL
- en: Modulo is the remainder of a division operation. For example, 5 mod 3 = 2 because
    2 would be left over. Mod can also be expressed as %.
  prefs: []
  type: TYPE_NORMAL
- en: With p, g as a prime number, g is a primitive root modulo p. The g and p numbers
    are public and can be seen and used by anyone.
  prefs: []
  type: TYPE_NORMAL
- en: In math, a g number is a primitive root modulo n if every integer relatively
    prime to n is congruent to a power of g modulo n.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, 2 is a primitive root mod 5, all the numbers relatively prime
    to 5 are 1, 2, 3, and 4; and each of these (mod 5) is itself, meaning that 2 (mod
    5) = 2:'
  prefs: []
  type: TYPE_NORMAL
- en: 2⁰ = 1, 1 (mod 5) = 1, so 2⁰ ≡ 1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2¹ = 2, 2 (mod 5) = 2, so 2¹ ≡ 2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2³ = 8, 8 (mod 5) = 3, so 2³ ≡ 3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2² = 4, 4 (mod 5) = 4, so 2² ≡ 4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, we will look at how the Diffie-Hellman algorithm works. Let's use a simple
    example to understand the algorithms of key exchange. Imagine Alice and Bob want
    to exchange information. Now, assume a hacker named Eve is trying to intercept
    the message.
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 1 –** Alice and Bob agree that all messages need to be calculated by
    the formula g^a (mod p) using a modulus p = 13 and base g = 6\. Alice and Bob
    both select a secret number that is known only to them. However, the formula and
    numbers g and p are public to everyone.![](../images/535492_1_En_2_Chapter/535492_1_En_2_Fig5_HTML.png)'
  prefs: []
  type: TYPE_NORMAL
- en: An illustration of the public value agreed upon by Alice and Bob. Modulus p
    equals 13 and base g equals 6.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2-5
  prefs: []
  type: TYPE_NORMAL
- en: Alice and Bob agree on public value
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 2 –** Alice chooses a secret random number (a = 5) as her private key,
    and Bob chooses his private key (b = 4).![](../images/535492_1_En_2_Chapter/535492_1_En_2_Fig6_HTML.png)'
  prefs: []
  type: TYPE_NORMAL
- en: An illustration of secret private keys of Alice and Bob. Alice's random secret
    key, a equals 5 and Bob's random secret key, a equals 4.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2-6
  prefs: []
  type: TYPE_NORMAL
- en: Alice’s and Bob’s secret keys
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 3 –** Alice and Bob will then use the formula to calculate public values
    using the p and g parameters and their private values.'
  prefs: []
  type: TYPE_NORMAL
- en: Alice will calculate using the following:![](../images/535492_1_En_2_Chapter/535492_1_En_2_Fig7_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: A schematic depicts the public values calculation of Alice and Bob. The public
    value for Alice is 6 power 5 is equal to 7776, mod 13 is equal to 2, and Bob is
    6 power 4 is equal to 1296, and mod 13 is equal to 9.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2-7
  prefs: []
  type: TYPE_NORMAL
- en: Alice and Bob calculate public values
  prefs: []
  type: TYPE_NORMAL
- en: 6⁵ (mod 13) = 7776 mod 13 = 2
  prefs: []
  type: TYPE_NORMAL
- en: 'Bob will calculate using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 6⁴ (mod 13) = 1296 mod 13 = 9
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 4 –** Alice sends her calculated result (2) to Bob over the Internet.
    Eve can see this. Bob sends his calculated result (9) to Alice, and Eve can see
    this also.![](../images/535492_1_En_2_Chapter/535492_1_En_2_Fig8_HTML.png)'
  prefs: []
  type: TYPE_NORMAL
- en: An illustration depicts the exchange of public keys each other by Alice and
    Bob. The exchange keys are 9 from Bob, and 2 from Alice.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2-8
  prefs: []
  type: TYPE_NORMAL
- en: Alice and Bob send their results to each other
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 5 –** Alice and Bob both received the other side''s public message,
    and they calculated the shared secret through the formula g^a (mod p).'
  prefs: []
  type: TYPE_NORMAL
- en: In this step, g is a public message sent from the other side.
  prefs: []
  type: TYPE_NORMAL
- en: Alice will calculate using the following equation:![](../images/535492_1_En_2_Chapter/535492_1_En_2_Fig9_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: An illustration depicts the secret calculation of Alice and Bob. The calculation
    for Alice is 9 power 5 is equal to 59049, 59049 mod 13 is equal to 3, Bod is 2
    power 4 is equal to 16, and 16 mod 13 is equal to 3.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2-9
  prefs: []
  type: TYPE_NORMAL
- en: Alice and Bob receiving the same values
  prefs: []
  type: TYPE_NORMAL
- en: 9⁵ (mod 13) = 59049 mod 13 = 3
  prefs: []
  type: TYPE_NORMAL
- en: 'Bob will calculate using the following equation:'
  prefs: []
  type: TYPE_NORMAL
- en: 2⁴ (mod 13) = 16 mod 13 = 3
  prefs: []
  type: TYPE_NORMAL
- en: Both Alice and Bob have gotten the same values.
  prefs: []
  type: TYPE_NORMAL
- en: Eve is a hacker. She intercepts the message sent between Alice and Bob. Eve
    can see the public value (g^a (mod p)), g is, she can see what p is, and she knows
    the computed results from Alice and Bob. However, Eve does not know the secret
    numbers chosen by Alice and Bob, and she will not be able to find them easily.![](../images/535492_1_En_2_Chapter/535492_1_En_2_Fig10_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: A schematic depicts Alice's and Bob's secret values not known by hacker Eve.
    The values are a is equal to 5 for Alice and 4 for Bob. Alice and Bob agreed that
    g power a, modulus p is equal to 13, and base g is equal to 6.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2-10
  prefs: []
  type: TYPE_NORMAL
- en: Hacker Eve does not know Alice’s and Bob’s secret values
  prefs: []
  type: TYPE_NORMAL
- en: 'From the Diffie and Hellman example, we can see that both Alice and Bob, using
    the following equation, computed to get the same result:'
  prefs: []
  type: TYPE_NORMAL
- en: '*(g*^(*a*) *(mod p))*^(*b*) *mod p = (g*^(*b*) *(mod p))*^(*a*) *mod p*'
  prefs: []
  type: TYPE_NORMAL
- en: The shared key is g^(ab). Typically, a, b, and p are much larger values. This
    is needed to make results secure.
  prefs: []
  type: TYPE_NORMAL
- en: In the original Diffie and Hellman description, the algorithm does not provide
    identity verification for communicating parties. This led to the algorithm being
    vulnerable to man-in-the-middle attacks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: Eve intercepts the message between Alice and Bob and blocks communication between
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Eve intercepts Alice’s public value (g^a(mod p)) and sends Alice her own public
    value (g^c(mod p)).
  prefs: []
  type: TYPE_NORMAL
- en: Eve intercepts Bob’s public value (g^b(mod p)) and sends Bob his public value
    (g^d(mod p)).
  prefs: []
  type: TYPE_NORMAL
- en: Neither Alice nor Bob can detect any problem, and each may assume that the other
    side received their message, but in reality, Eve can decrypt, read, modify, and
    re-encrypt all of their messages.![](../images/535492_1_En_2_Chapter/535492_1_En_2_Fig11_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: An image depicts the algorithm g power a mod p being vulnerable to man-in-the-middle
    attacks. The explanation is hacker Eve intercepts Alice and Bob's messages and
    blocks the communication between them.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2-11
  prefs: []
  type: TYPE_NORMAL
- en: A man-in-the-middle attack
  prefs: []
  type: TYPE_NORMAL
- en: Diffie and Hellman is the first asymmetric cryptography protocol and provided
    the basis for many authenticated protocols, such as the elliptic curve Diffie-Hellman
    asymmetric algorithm and RSA, that are widely used today. Crypto, secure shell
    (SSH), secure sockets layer (SSL), email, and VPN security are all based on these
    asymmetric algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: How Digital Signatures Work
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If Alice wants to send a signed message to Bob over the Internet, the following
    steps should be followed:'
  prefs: []
  type: TYPE_NORMAL
- en: '1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We begin with the message on Alice's (the sender’s) side.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The algorithm generates a one-way hash of the message based on the document
    checksum.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '3.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The hash is signed or encrypted using Alice's private key.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '4.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The message is sent to Bob.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '5.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bob receives the message.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '6.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bob decrypts the message using Alice's public key and verifies the message authentication
    that was signed by Alice.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '7.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The algorithm regenerates a hash of the message.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '8.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The two hash values are compared. If they are identical, we ensure that the
    transmitted document has not been altered since signing.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The process of a digital signature is shown in Figure [2-12](#Fig12).![](../images/535492_1_En_2_Chapter/535492_1_En_2_Fig12_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: A schematic depicts the process of digital signatures of Alice and Bob. The
    labeled process is origin document, hash, signing/encrypt, private key, public,
    unsigning/decrypt, origin document, and hash.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2-12
  prefs: []
  type: TYPE_NORMAL
- en: The process of digital signatures
  prefs: []
  type: TYPE_NORMAL
- en: Digital Signatures
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A digital signature is an asymmetric public key cryptography technique that
    verifies digital messages or document owner authenticity.
  prefs: []
  type: TYPE_NORMAL
- en: We often use the public key for message encryption and the private key for message
    decryption in public key encryption. However, in the case of a digital signature,
    the message is encrypted with a sender's private key, or in other words, the message
    is signed.
  prefs: []
  type: TYPE_NORMAL
- en: As the signer's public key is known, anybody can verify a message's digital
    signature.
  prefs: []
  type: TYPE_NORMAL
- en: 'A digital signature includes the following characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: Authentication (verification of who signed the origin of the document)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nonrepudiation (the identity of the signer and document that they have digitally
    signed should be undeniable)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrity (proof that the document has not been altered since signing)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hash Algorithms
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In Chapter [1](535492_1_En_1_Chapter.xhtml), “How Blockchain Works” section,
    the hash concept was introduced, and the way that blockchain uses the SHA-256
    hash function to hash transaction data was discussed. In the previous section,
    the process of digital signatures was discussed. The process indicated that the
    process needed to apply a hash function.
  prefs: []
  type: TYPE_NORMAL
- en: Hash algorithm is a mathematical function that divides original data input into
    smaller blocks of equal size and then executes the hash function to two fixed-size
    data blocks to generate a hash code. The algorithm starts from the first block
    of message data with a seed value that passes into the hash function, outputting
    the first hash code.![](../images/535492_1_En_2_Chapter/535492_1_En_2_Fig13_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: An illustration depicts the algorithm code of the 2 data blocks generate a hash
    function. It gives the hash value 356A192B7913B04C54574 D18C28D46E6395428AB.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2-13
  prefs: []
  type: TYPE_NORMAL
- en: Two fixed-size data blocks used to generate a hash code The process is similar
    to block cipher, discussed in the previous section. The hash process will start
    from the first block and end at the last block. This process can be repeated for
    as many rounds as are required by the algorithm. Eventually, all block data will
    be chained together and hashed.![](../images/535492_1_En_2_Chapter/535492_1_En_2_Fig14_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: A flow diagram of the hash algorithm. The labeled flows are data seed, message
    block, and hash function. The process is continued till receiving the hash value.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2-14
  prefs: []
  type: TYPE_NORMAL
- en: The hash algorithm
  prefs: []
  type: TYPE_NORMAL
- en: The Keccak-256 Algorithm
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Keccak-256 algorithm is a hash function that is widely used in an Ethereum
    blockchain. A few examples include Ethereum addresses, some smart contract functions,
    and the Ethereum consensus engine known as Ethash that plays an important role
    in producing blocks and other security actions.
  prefs: []
  type: TYPE_NORMAL
- en: The Keccak-256 is a family of SHA-3 hash functions. The function input can be
    a variable-length string or number, and generated output will always be a fixed-length,
    64-character (letters and numbers) output. The output can be converted to hexadecimal
    numbers. Like all other hash functions, it is a one-way cryptographic hash function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Keccak-256 is based on the sponge construction and is a sponge function family.
    Keccak-256 sponge function (Keccak[r,c]) needs two parameters: one of size r (the
    bitrate and the amount of data encoded for a single unit of time) and the other
    of size c (the capacity).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Padding**'
  prefs: []
  type: TYPE_NORMAL
- en: A padding function will append enough bits to the input data (M), and the length
    of the padded input can be split into multiple r-bit blocks.
  prefs: []
  type: TYPE_NORMAL
- en: '**Initialization**'
  prefs: []
  type: TYPE_NORMAL
- en: The padded input is broken into r-bit blocks, assuming the blocks' names are
    called M0, M1, M2, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Absorbing Phase**'
  prefs: []
  type: TYPE_NORMAL
- en: The r-bit block is XORed with small chunks of the input data M0\. The result
    is then passed to a compression function f. The output of function f XORed next
    message M1\. The process is repeated until each of the message blocks Mn is processed.
    In each step, a small chunk of the input data (the bit length of r) is “absorbed”
    into the buffer.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Squeezing Phase**'
  prefs: []
  type: TYPE_NORMAL
- en: The same process is repeated. The r-bit block of the buffer consists of the
    next r bits of output (Z0, Z1, Z2, and so on). The function f is used to extract
    r bits of data as the next r bits of the output. The process is repeated until
    the results are produced.
  prefs: []
  type: TYPE_NORMAL
- en: Figure [2-15](#Fig15) illustrates the Keccak-256 hash algorithm.![](../images/535492_1_En_2_Chapter/535492_1_En_2_Fig15_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: An algorithm depicts the Keceeak-256 hash values, through 2 processes absorbing
    and squeezing. The labeled process is the message, pad, and output.3658-89/+/
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2-15
  prefs: []
  type: TYPE_NORMAL
- en: The Keccak-256 hash algorithm
  prefs: []
  type: TYPE_NORMAL
- en: Elliptic Curve Cryptography (ECC)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ECC was discovered in 1985 by Victor Miller (IBM) and Neil Koblitz (University
    of Washington) independently and is currently one of the most robust and widely
    used types of encryption cryptography. Blockchain networks, such as Bitcoin and
    Ethereum, use ECC.
  prefs: []
  type: TYPE_NORMAL
- en: In 2005, the US National Security Agency (NSA) announced a set of unpublished
    algorithms known as Suite B protocols and posted a paper titled “The Case for
    Elliptic Curve Cryptography” in which they recommended that the US government
    use ECC to secure sensitive and unclassified communications. ^([2](#Fn2))
  prefs: []
  type: TYPE_NORMAL
- en: The NSA commented that analysts should “take advantage of the past 30 years
    of public key research and analysis and move from first generation public key
    algorithms and on to elliptic curves.”
  prefs: []
  type: TYPE_NORMAL
- en: Suite B’s protocols included both elliptic curve Diffie-Hellman (ECDH) and elliptic
    curve Menezes-Qu-Vanstone (ECMQV) for key exchange, the elliptic curve digital
    signature algorithm (ECDSA) for digital signatures, the advanced encryption standard
    (AES) for symmetric encryption, and the secure hashing algorithm (SHA). After
    the release of these protocols, ECC soon became the de facto standard for protecting
    modern industry communications.
  prefs: []
  type: TYPE_NORMAL
- en: ECC is based on algebraic properties of elliptic curves and provides equivalent
    security with much smaller key sizes than other asymmetric cryptography systems,
    such as RSA or DSA. For example, a 256-bit ECC key is equal in power to a 3072-bit
    RSA key. This also makes elliptic curves significantly faster.
  prefs: []
  type: TYPE_NORMAL
- en: '**What Is an Elliptic Curve?**'
  prefs: []
  type: TYPE_NORMAL
- en: 'An elliptic curve is a curve given through the following equation:'
  prefs: []
  type: TYPE_NORMAL
- en: y ² = x ³ + Ax + B
  prefs: []
  type: TYPE_NORMAL
- en: 'The curve, as required, is nonsingular and needs to have no repeated roots
    or self-intersections. To ensure that the curve is nonsingular, the condition
    can be expressed through the following equation:'
  prefs: []
  type: TYPE_NORMAL
- en: 4A³ + 27B² ≠ 0
  prefs: []
  type: TYPE_NORMAL
- en: An example of the elliptic curve when A = -1 and B = 1 can be seen in Figure
    [2-16](#Fig16):![](../images/535492_1_En_2_Chapter/535492_1_En_2_Fig16_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: A curve graph depicts the elliptic of the equation y square is equal to cubic
    x minus x plus 1\. The curve started at point negative 3, bent in negative 1.5,
    and ended at 3 approximately.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2-16
  prefs: []
  type: TYPE_NORMAL
- en: Elliptic curve y² = x³ - x + 1
  prefs: []
  type: TYPE_NORMAL
- en: y² = x³ - x + 1
  prefs: []
  type: TYPE_NORMAL
- en: In an elliptic curve, there is a useful property to create an addition on the
    curve, turning it into an abelian group. Take two points, P and Q, on the curve,
    and draw a line through them. The line will intersect the curve at one more point
    (R). Take P + Q as R, and from R, another line can be drawn either straight up
    (if R is below the x-axis) or straight down (if R is above the x-axis) to the
    other side of the curve, opposite to the point -R (see Figure [2-17](#Fig17)).![](../images/535492_1_En_2_Chapter/535492_1_En_2_Fig17_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: A curve graph depicts the addition of 2 points R and negative R of elliptic.
    The curve passes a line of axis P, Q, and R. The result is calculated by negative
    R implies P plus Q.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2-17
  prefs: []
  type: TYPE_NORMAL
- en: The elliptic curve addition of two points (R and -R)
  prefs: []
  type: TYPE_NORMAL
- en: 'The group law for an elliptic curve is expressed through either of the following
    equations:'
  prefs: []
  type: TYPE_NORMAL
- en: P + Q + R = 0, or P + Q = - R
  prefs: []
  type: TYPE_NORMAL
- en: The sum of the points P and Q is equal to the point - R.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the addition of points P = (x[1], y[1]) and Q = (x[2], y[2]) of an elliptic
    curve, a third point can be calculated using the following formulas:'
  prefs: []
  type: TYPE_NORMAL
- en: P + Q = R = (x[3], y[3]) where
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/535492_1_En_2_Chapter/535492_1_En_2_Figa_HTML.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Equations for x cube and y cube. Value of lambda for P not equal to Q and P
    equal to Q
  prefs: []
  type: TYPE_NORMAL
- en: 'Elliptic curve E over Z[p] is defined by the following equations, and Z[p]
    is field modulo p, meaning that {0, 1, 2, …, n - 1}:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/535492_1_En_2_Chapter/535492_1_En_2_Figb_HTML.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A formula depicts the mod p equation of y square equals cubic 3 plus A x plus
    B, and A B E Z of p, 4 cubic A plus 27 B square not equal to 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'By applying this formula, the elliptic curve E over Z[p] - E(Z[p]) has a list
    of points (x, y). In the following example, elliptic curve y² = x³ + Ax + B =
    x ³ + 2x + 3 → y²(mod 5), where A = 2, B = 3, and P = 5\. This can be seen through
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: X = 0 → y² = 3 → no solution (mod 5)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: X = 1 → y² = 6 → 6 (mod 5) = 1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: → y = 1, 4 because 1² (mod 5) = 1, and 4² (mod 5) = 1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: X = 2 → y² = 15 → 15 (mod 5) = 0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: → y = 0 because 0² (mod 5) = 0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: X = 3 → y² = 36 → 36 (mod 5) = 1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: → y = 1, 4 because 1² (mod 5) = 1, and 4² (mod 5) = 1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: X = 4 → y² = 75 → 75 (mod 5) = 0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: → y = 0 because 0² (mod 5) = 0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, the elliptic curve has the following seven points:'
  prefs: []
  type: TYPE_NORMAL
- en: (1, 1), (1, 4), (2, 0), (3, 1), (3, 4), (4, 0), ∞.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, rearranging the modulus operator P = 263 leaves the following equation:'
  prefs: []
  type: TYPE_NORMAL
- en: (x³ + 2x + 3) (mod 263)
  prefs: []
  type: TYPE_NORMAL
- en: Scalar multiplication over the elliptic curve y² = x³ + 2x + 3 in mod 263\.
    The curve has 270 points, including the point at infinity.![](../images/535492_1_En_2_Chapter/535492_1_En_2_Fig18_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: A dot depicts the elliptic curve of equation y square equal to cubic 3 plus
    2 x plus 3, representing the point as Q and P. Both axis ranges from 0 to 250.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2-18
  prefs: []
  type: TYPE_NORMAL
- en: Elliptic curve y² = x³ + 2x + 3 (mod 263)
  prefs: []
  type: TYPE_NORMAL
- en: In the elliptic curve, when if P is (x, y) ∈ *E(Z*[*p*]*)*, then (x, y) + (x,
    -y) = ∞ (the point at infinity).
  prefs: []
  type: TYPE_NORMAL
- en: 'So, if adding ∞ to any point P in E(Z[p]), we can always get P back. This can
    be expressed through the following equation:'
  prefs: []
  type: TYPE_NORMAL
- en: P + ∞ = ∞ + P = P for all ∈ E(Z[p])
  prefs: []
  type: TYPE_NORMAL
- en: 'In Alice’s and Bob’s message communication, P is a (x,y) point on the curve
    that both Bob and Alice will agree to. Bob’s private key is represented by n,
    and K is his public key. We multiply P and n together to produce K, as shown as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: K = n P
  prefs: []
  type: TYPE_NORMAL
- en: If we multiply K with P, it will get the point on the elliptic curve.
  prefs: []
  type: TYPE_NORMAL
- en: Deriving an Ethereum Address
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We have learned about cryptography so far. Now it is time to do some practice
    and apply our knowledge to generate an Ethereum address. We will utilize multiple
    online tools to do this exercise. Of course, you can choose a different tool if
    you find a better one, or you can even write code to implement the same result:'
  prefs: []
  type: TYPE_NORMAL
- en: '1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a random private key and derive the public key from this private key
    using EC curve (secp256k1).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The private key is 64 hexadecimal characters long (32 bytes).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Here we use an online tool ([https://​kjur.​github.​io/​jsrsasign/​sample/​sample-ecdsa.​html](https://kjur.github.io/jsrsasign/sample/sample-ecdsa.xhtml))
    to get a public and private key pair. The generated public and private key pair
    can be seen in Figure [2-19](#Fig19).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](../images/535492_1_En_2_Chapter/535492_1_En_2_Fig19_HTML.jpg)'
  prefs: []
  type: TYPE_IMG
- en: An algorithm depicts the elliptic supported by the chosen E C curve name and
    generates key pair. The process is generated by 2 keys E C private key and E C
    public key.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2-19
  prefs: []
  type: TYPE_NORMAL
- en: The elliptic curve generating public and private keys
  prefs: []
  type: TYPE_NORMAL
- en: 'Private key: 8c2b80899dd44981d7f8b38c1f5b13dbf1fbb98c360d9d1cfd63a3aed0d7b498'
  prefs: []
  type: TYPE_NORMAL
- en: 'Public key: 04502fa444861915b6a258c3daa2beaa41c9b912e6fd6cd526fa179c60362f602bd75e36cfe1513a1e460ca646476e54fab08aa42730068326ab0a8a2e57d2829b'
  prefs: []
  type: TYPE_NORMAL
- en: '2.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Derive the address from the following public key:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Start with the public key (128 characters) and apply the Keccak-256 hash of
    the public key. It will generate a string that is 64 characters long (32 bytes).
    Let’s use the Keccak-256 online tool ([https://​emn178.​github.​io/​online-tools/​keccak_​256.​html](https://emn178.github.io/online-tools/keccak_256.xhtml))
    to see the hash result (see Figure [2-20](#Fig20)).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](../images/535492_1_En_2_Chapter/535492_1_En_2_Fig20_HTML.png)'
  prefs: []
  type: TYPE_IMG
- en: Two algorithms depict the address and derivation of the Keccak-256 online hash
    function. The keys labeled are input type, hash, and auto-update.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2-20
  prefs: []
  type: TYPE_NORMAL
- en: Keccak-256 hash public key example
  prefs: []
  type: TYPE_NORMAL
- en: The result is db97247835ec1f9d0bd8b6ed***6a6d125cf3029f4ccbe72cc1b1a4c7a8c72467a3***
  prefs: []
  type: TYPE_NORMAL
- en: '3.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get the Ethereum address
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Take the last 20 bytes (40 characters) of the generated hash to get the Ethereum
    address with prefix 0x. 0x lets the people know the address in hexadecimal format.
    When prefixed with 0x, it becomes 42 characters long. So, in our example, the
    Ethereum address is
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '0x6a6d125cf3029f4ccbe72cc1b1a4c7a8c72467a3'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '4.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify the Ethereum address
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We use one of the online Ethereum address validator tools ([www.rfctools.com/ethereum-address-validator/](http://www.rfctools.com/ethereum-address-validator/))
    to verify our new Ethereum address.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](../images/535492_1_En_2_Chapter/535492_1_En_2_Fig21_HTML.png)'
  prefs: []
  type: TYPE_IMG
- en: A screenshot of the valid Ethereum address validator. The labeled R F C tools
    are cryptocurrency tools, of 4 steps, image tools, J S O N tools, and H T M L
    tools.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2-21
  prefs: []
  type: TYPE_NORMAL
- en: Validating the generated Ethereum address
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! We just generated a valid Ethereum address using our cryptography
    knowledge. At this level, you should get a good sense of how blockchain cryptography
    works.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cryptography is an essential mechanism for securing blockchain technology. It
    is used to secure the blockchain consensus mechanism, protect blockchain data,
    keep user accounts safe, and more. The main purpose of this chapter was to give
    a more thorough understanding of cryptography by giving a quick overview of how
    it works.
  prefs: []
  type: TYPE_NORMAL
- en: Although it only scratches the surface of cryptography technologies, this chapter
    will help you to enrich your knowledge of symmetric key cryptography and asymmetric
    key cryptography. More importantly, we now know how digital signatures work. We
    covered the hash algorithm, and we walked-through elliptic curve cryptography
    to understand how it works. Lastly, we learned how to generate an Ethereum address.
  prefs: []
  type: TYPE_NORMAL
- en: We will continue our journey and learn about Bitcoin, the future of money in
    the next chapter.
  prefs: []
  type: TYPE_NORMAL
