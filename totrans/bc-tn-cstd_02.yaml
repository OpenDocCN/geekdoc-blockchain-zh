- en: © The Author(s), under exclusive license to APress Media, LLC, part of Springer
    Nature 2023B. Wu, B. WuBlockchain for Teens[https://doi.org/10.1007/978-1-4842-8808-5_2](https://doi.org/10.1007/978-1-4842-8808-5_2)
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: © 作者（们），在APress Media, LLC独家授权下，隶属于Springer Nature 2023B.吴，B.吴青少年区块链[https://doi.org/10.1007/978-1-4842-8808-5_2](https://doi.org/10.1007/978-1-4842-8808-5_2)
- en: '2. Cryptography: The Backbone of Blockchain Security'
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2. 密码学：区块链安全的基石
- en: Brian Wu^([1](#Aff3)  ) and Bridget Wu^([1](#Aff3))(1)Livingston, NJ, USA
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 布鲁恩·吴^([1](#Aff3)   )和布里吉特·吴^([1](#Aff3))(1)新泽西州,美国,Livingston
- en: Blockchains are built based on a range of different cryptographic concepts.
    From safeguarding wallets and securing transactions to protecting consensus protocols
    and encrypting private data for anonymous accounts, almost everything needs cryptography
    to ensure proper functioning. Cryptography is the backbone of blockchain security.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链是基于一系列不同的密码学概念构建的。从保护钱包和确保交易的安全，到保护共识协议和为匿名账户加密私有数据，几乎所有的一切都需要密码学来确保正常运行。密码学是区块链安全的基石。
- en: This chapter will dive into everything you need to know about cryptography in
    blockchains, starting with the basics. Then, you will be introduced to the classical
    symmetric key cryptography, asymmetric cryptography, and more. As you advance,
    you will become well versed in how digital signatures work.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将深入探讨您需要了解的关于区块链中的密码学的所有内容，从基础开始。然后，您将被介绍到经典的对称密钥密码学、非对称密码学等等。随着您的进步，您将深入了解数字签名是如何工作的。
- en: This chapter will also cover how to utilize hash functions to hash data, and
    at the end of the chapter, you will get an in-depth look at elliptic curve cryptography
    (ECC), a key type of encryption cryptography that is used in blockchain.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还将介绍如何利用散列函数来散列数据，在章节的最后，你将深入了解一下椭圆曲线密码学（ECC），这是区块链中使用的一种关键类型的加密密码。
- en: 'In this chapter, the following topics related to cryptography will be discussed:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，将讨论与密码学相关的以下主题：
- en: The basics of cryptography
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密码学基础
- en: Symmetric key cryptography
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对称密钥密码学
- en: Asymmetric key cryptography
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非对称密钥密码学
- en: Digital signatures
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字签名
- en: Hash algorithms
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 散列算法
- en: ECC
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 椭圆曲线密码学
- en: Derived Ethereum addresses
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 派生以太坊地址
- en: The Basics of Cryptography
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 密码学基础
- en: In Chapter [1](535492_1_En_1_Chapter.xhtml), we have briefly discussed SHA-256
    hashing cryptography which is used to hash block data.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在第[1](535492_1_En_1_Chapter.xhtml)章中，我们已经简要讨论了用于散列块数据的SHA-256散列密码学。
- en: Let's use an example to illustrate how secure messages can be sent to the public.
    Suppose Alice sends a personal message to Bob. Alice wants this message to be
    private. Only Bob can understand the message, and the message cannot be altered
    during transmission. The message sent over the Internet could secretly be intercepted
    and recorded by an intruder (see Figure [2-1](#Fig1)). How can Alice and Bob stop
    this from happening? This is where cryptography comes in.![](../images/535492_1_En_2_Chapter/535492_1_En_2_Fig1_HTML.jpg)
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个例子来说明如何向公众发送安全的消息。假设爱丽丝给鲍勃发送了一条个人消息。爱丽丝希望这条消息是私人的。只有鲍勃能理解这条消息，在传输过程中消息不能被更改。通过互联网发送的消息可能会被入侵者秘密拦截并记录（见图[2-1](#Fig1)）。爱丽丝和鲍勃如何阻止这种情况发生？这就是密码学的作用所在。![](../images/535492_1_En_2_Chapter/535492_1_En_2_Fig1_HTML.jpg)
- en: An illustration of a message sent by Alice to bob over the internet secretly
    intercepted and recorded by an intruder.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 爱丽丝通过互联网给鲍勃发送的消息被入侵者秘密拦截和记录的说明。
- en: Figure 2-1
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-1
- en: A message sent through a network
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 通过网络发送的消息
- en: The word “crypto” comes from the Greek word “kryptós,” meaning “hidden or secret.”
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: “密码学”这个词来自希腊词“kryptós”，意思是“隐藏或秘密”。
- en: “Cryptography” means “secret writing” and allows for the exchange of secure
    messages between willing parties.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: “密码学”意味着“秘密书写”，并允许有意愿的各方之间交换安全的消息。
- en: The message is converted into a secret code equivalent called “ciphertext” via
    an encryption algorithm to prevent unauthorized access. The ciphertext is then
    sent over a public network, it is decrypted at the receiving end, and the recipient
    can view its contents.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 消息通过加密算法转换成称为“密文”的秘密代码等价物，以防止未经授权的访问。然后，密文通过公共网络发送，在接收端进行解密，收件人可以查看其内容。
- en: In the preceding example, Alice uses a key to encrypt her message, converting
    it to ciphertext, and she sends it to Bob over the Internet. She does not need
    to worry about a hacker having access to her private message. To read ciphertext,
    a hacker must use a decryption key. When Bob receives this ciphertext message,
    he can use a key to recover the original plaintext via decryption.![](../images/535492_1_En_2_Chapter/535492_1_En_2_Fig2_HTML.png)
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，爱丽丝用一个密钥来加密她的消息，将其转换为密文，并通过互联网发送给鲍勃。她不必担心黑客获取她的私人消息。要阅读密文，黑客必须使用解密密钥。当鲍勃收到这个密文消息时，他可以使用一个密钥通过解密来恢复原始明文。![](../images/535492_1_En_2_Chapter/535492_1_En_2_Fig2_HTML.png)
- en: A schematic depicts encrypting and decrypting of a message through the internet
    by Alice to Bob. The labeled process is my secret text, encrypt, ciphertext, decrypt,
    and text.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一个示意图展示了通过互联网，爱丽丝向鲍勃加密和解密消息的过程。带标签的过程是我的秘密文本，加密，密文，解密，和文本。
- en: Figure 2-2
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-2
- en: Encrypting and message over the Internet
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 通过互联网加密和发送消息
- en: 'Cryptography is mainly divided into three categories: symmetric key cryptography,
    asymmetric key cryptography, and keyless primitives such as hash function.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 密码学主要分为三类：对称密钥加密，非对称密钥加密和无密钥的原语，如哈希函数。
- en: Symmetric Key Cryptography
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对称密钥加密
- en: Symmetric key cryptography is a cryptographic algorithm that uses a shared secret
    key between a sender and a receiver to encrypt and decrypt data. This secret key
    is called a symmetric key.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 对称密钥加密是一种加密算法，它使用发送方和接收方之间的共享密钥来加密和解密数据。这个密钥被称为对称密钥。
- en: In the preceding example, Alice and Bob share the same secret key. Alice uses
    the secret key to encrypt the message, and the secret key is used in the decryption
    process when Bob reads the message. This shows how symmetric encryption works.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，爱丽丝和鲍勃共享同一个密钥。爱丽丝用这个密钥来加密消息，当鲍勃阅读消息时，这个密钥用于解密过程。这展示了对称加密是如何工作的。
- en: Symmetric encryption is typically more efficient than asymmetric encryption.
    Therefore, it is often used with large amounts of data encryption, personal data
    encryption, and decryption.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 对称加密通常比非对称加密更有效率。因此，它通常用于大量数据加密，个人数据加密和解密。
- en: While there are several symmetric algorithms, the first US standard was DES.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有几种对称算法，但第一个美国标准是DES。
- en: Symmetric key cryptography can use either stream ciphers or block ciphers to
    encrypt data. Using stream ciphers is the preferred way to encrypt data in most
    cases.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 对称密钥加密可以使用流密码或块密码来加密数据。在大多数情况下，使用流密码是加密数据的推荐方式。
- en: Stream Ciphers
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 流密码
- en: Stream ciphers encrypt plaintext messages one bit or byte at a time, resulting
    in a single-character-in, single-character-out cipher. It applies a random keystream
    of characters and the XOR operation to each binary digit in a data stream.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 流密码以一次一个位或字节的方式加密明文消息，结果是一个字符入，一个字符出的密码。它对每个数据流中的二进制位应用随机字符流和异或操作。
- en: XOR is a Boolean logic operation and is known as the “exclusive or” or exclusive
    disjunction. It yields true when only one out of two inputs is true. If both or
    no inputs are true, the XOR operation output is false.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 异或是一种布尔逻辑操作，也被称为“排他或”或排他联合。当两个输入中的只有一个为真时，它产生真。如果两个输入都为真或都不是真，异或操作的输出为假。
- en: The truth table of an XOR logic is shown in Table [2-1](#Tab1) where 0 means
    FALSE, and 1 means TRUE.Table 2-1
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 异或逻辑的真值表如表[2-1](#Tab1)所示，其中0表示假，1表示真。表2-1
- en: Truth table for XOR
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 异或的真值表
- en: '|   | Input | Output |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '** ** | 输入 | 输出 |'
- en: '| --- | --- | --- |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '**---** | **---** | **---** |'
- en: '| **A** | **B** | **A XOR B** |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '**A** | **B** | **A XOR B** |'
- en: '| 0 | 0 | 0 |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '**0** | **0** | **0** |'
- en: '| 0 | 1 | 1 |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '**0** | **1** | **1** |'
- en: '| 1 | 0 | 1 |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '**1** | **0** | **1** |'
- en: '| 1 | 1 | 0 |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '**1** | **1** | **0** |'
- en: 'So, if Bit A is 11000101, and Bit B is 10100110, the following shows what the
    output looks like when the XOR operation is applied for these two binary bits:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果位A是11000101，位B是10100110，当对这些两个二进制位应用异或操作时，输出如下所示：
- en: '10101'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '10101'
- en: XOR     00110
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异或 00110
- en: Output     10011
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出 10011
- en: 'Keystream characters can be random combinations of any letters or numbers.
    Assume that we have a stream of plaintext bytes (p1, p2, p3, ..., pi), and the
    keystream generator outputs a stream of bytes (k1, k2, k3, ..., ki). To encrypt
    the stream of ciphertext bytes, the operand XOR needs to be applied to each plaintext
    and key to generate and encrypt the stream of ciphertext bytes (c1, c2, ..., ci).
    This can be expressed through the following:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 密钥流字符可以是任何字母或数字的随机组合。假设我们有一个明文字节流 (p1, p2, p3, ..., pi)，密钥流生成器输出一个字节流 (k1, k2,
    k3, ..., ki)。要加密密文字节流，需要对每个明文和密钥应用异或操作以生成并加密密文字节流 (c1, c2, ..., ci)。这可以通过以下表达式来表示：
- en: c1 = p1 XOR k1, ..., ci = pi XOR ki
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: c1 = p1 XOR k1，...，ci = pi XOR ki
- en: Figure [2-3](#Fig3) illustrates stream cipher encryption. P1 is 00110101, and
    K1 is 11100011\. With XOR operation, the ciphertext encrypt result is 11010110.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 [2-3](#Fig3) 说明了流加密。P1 是 00110101，K1 是 11100011。通过异或操作，加密结果是 11010110。
- en: 00110101 (plaintext)
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 00110101 (明文)
- en: XOR     11100011 (key)
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XOR 11100011 (密钥)
- en: Output     11010110 (plaintext)
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出 11010110 (明文)
- en: '![](../images/535492_1_En_2_Chapter/535492_1_En_2_Fig3_HTML.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/535492_1_En_2_Chapter/535492_1_En_2_Fig3_HTML.png)'
- en: An illustration depicts the stream cipher encryption, processed in 3 steps data
    stream of P 1, P 2, to P i; keystream of K 1, K 2, to K i; and X O R of C 1, C
    2, to C i. P 1 is 00110101 plus K 1 is 11100011 implies C 1 as 11010110.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图示流加密，分 3 步处理 P 1、P 2 到 P i 的数据流；K 1、K 2 到 K i 的密钥流；以及 C 1、C 2 到 C i 的 XOR 操作。P
    1 是 00110101 加上 K 1 是 11100011 意味着 C 1 为 11010110。
- en: Figure 2-3
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-3
- en: Stream cipher encryption
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 流加密
- en: 'To decrypt the plaintext bytes, we apply the XOR operation with the ciphertext
    and key. The output will get the original plaintext bytes. This operation can
    be expressed by pi = ci XOR ki:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解密明文字节，我们将密文和密钥应用异或操作。输出将得到原始明文字节。这个操作可以表示为 pi = ci XOR ki：
- en: 11010110 (ciphertext)
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 11010110 (密文)
- en: XOR     11100011 (key)
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XOR 11100011 (密钥)
- en: Output     00110101 (plaintext)
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出 00110101 (明文)
- en: Block Ciphers
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 块加密
- en: The main difference between a block cipher and a stream cipher is that a block
    cipher takes a fixed-size block of plaintext bytes as a single unit and encrypts
    block data as a ciphertext byte. Generally, the block size is the same as the
    key size.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 块加密与流加密的主要区别在于，块加密将固定大小的明文字节块作为单个单元，并将其作为密文字节块进行加密。通常，块大小与密钥大小相同。
- en: Assume we have a block of plaintext bytes **p** and key bytes **k**. To encrypt
    the block of ciphertext byte **c**, we need to encrypt the plaintext with **key
    c = encrypt (p, k)** and recover the plaintext by decrypting the ciphertext with
    **key p = decrypt (c, k).**
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个明文字节块 **p** 和密钥字节块 **k**。要加密密文字节块 **c**，我们需要用 **密钥 c = 加密 (p, k)** 加密明文，并通过
    **密钥 p = 解密 (c, k)** 解密密文以恢复明文。
- en: Each block is of equal size. Let’s say the input is larger than the number of
    blocks, where the input size is 38 bits, and the block size is 6 bits. After 6
    blocks, there will be 2 bits left (38 – 6 * 6 = 2). In this case, we typically
    add padding (two 0) and append it to the end of the block.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 每个块的大小相等。假设输入大于块的数量，输入大小为 38 位，块大小为 6 位。经过 6 个块后，还剩下 2 位（38 - 6 * 6 = 2）。在这种情况下，我们通常添加填充（两个
    0）并附在块的末尾。
- en: Figure [2-4](#Fig4) shows an example of block cipher encryption. The plaintext
    is divided by n block (p[n]), and each block uses the same key to encrypt a ciphertext.
    The encryption process will start from the first block and end on the last block,
    and eventually, all block data will be encrypted.![](../images/535492_1_En_2_Chapter/535492_1_En_2_Fig4_HTML.png)
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图 [2-4](#Fig4) 显示了块加密的示例。明文被分成 n 个块 (p[n])，每个块使用相同的密钥来加密密文。加密过程将从第一个块开始，最后在最后一个块结束，最终所有块数据都将被加密。![](../images/535492_1_En_2_Chapter/535492_1_En_2_Fig4_HTML.png)
- en: A diagram of 3 blocks. The labels in 3 blocks are P 1, P 2, and P n and P1 leads
    to key, which leads to C 1; P 2 leads to key, which leads to C 2; and P n leads
    to key, which leads to C n. The process starts from the first block and ends on
    the last block.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 3 个块的图。3 个块的标签分别是 P 1、P 2 和 P n，P1 指向密钥，密钥指向 C 1；P 2 指向密钥，密钥指向 C 2；P n 指向密钥，密钥指向
    C n。过程从第一个块开始，最后一个块结束。
- en: Figure 2-4
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-4
- en: Block cipher encryption
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 块加密
- en: The most commonly used types of block ciphers include advanced encryption standard
    (AES), data encryption standard (DES), and triple DES (3DES or TDEA).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的块加密类型包括高级加密标准（AES）、数据加密标准（DES）和三重 DES（3DES 或 TDEA）。
- en: Asymmetric Key Cryptography
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 非对称密钥加密
- en: Symmetric cryptography is relatively simpler and faster than asymmetric cryptography,
    only needing one key. It is typically used for big data encryption/decryption
    and confidentiality of bank transactions. Symmetric cryptography must share the
    same secret key before data encryption. In the previous example, the case becomes
    complex when Alice needs to send a private message to many people. If Alice uses
    a symmetric key (K) to encrypt all these messages and shares this key with Bob
    and others, there is a great risk that someone can secretly give a copy of K to
    others without Alice's knowledge. In this case, the entire communication channel
    has been compromised, and many unintended people can read and modify the messages
    and send them to any other members. To avoid this security risk, Alice must consider
    creating a large number of keys for each person that the message is sent to, but
    Alice will then have to remember all the secret keys. Alice needs to call her
    friends or be involved in face-to-face meetings over a trusted channel to distribute
    the secret keys. As a result, symmetric cryptography could quickly become less
    practical for many participants. This problem affected the industry in relation
    to the use of encryption for quite a long time, but in 1976, Diffie and Hellman
    introduced the concept of public key encryption, also known as asymmetric cryptography.^([1](#Fn1))
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 对称加密相对简单且比非对称加密快，只需要一个密钥。它通常用于大数据加密/解密和银行交易的保密。在对数据进行加密之前，对称加密必须共享相同的密钥。在前面的例子中，当爱丽丝需要向许多人发送私人信息时，情况变得复杂。如果爱丽丝使用对称密钥（K）来加密所有这些信息并与鲍勃和其他人共享这个密钥，那么有人可能会在爱丽丝不知情的情况下秘密地将K的副本给其他人。在这种情况下，整个通信信道已经被
    compromised，许多无意中的人可以读取和修改消息并将其发送给任何其他成员。为了避免这种安全风险，爱丽丝必须考虑为每个接收消息的人创建大量密钥，但爱丽丝将不得不记住所有这些密钥。爱丽丝需要通过可靠的信道给她朋友打电话或参与面对面的会议来分发这些密钥。因此，对称加密对于许多参与者可能很快就会变得不那么实用。这个问题在行业中关于使用加密手段已经存在了很长时间，但在1976年，迪菲和赫尔曼引入了公钥加密的概念，也称为非对称加密。^([1](#Fn1))
- en: Public and Private Keys
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 公钥与私钥
- en: Whitfield Diffie and Martin Hellman described how public key encryption works
    when two communicating parties exchange information across an insecure channel
    using a key pair consisting of a public key and a private key.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 惠特菲尔德·迪菲和马丁·赫尔曼描述了当两个通信方在不安全的信道上交换信息时，如何使用由公钥和私钥组成的密钥对来进行公钥加密。
- en: A private key is known only to the owner, and a public key is considered public
    information that is available to anyone. Each key has been designed for a specific
    purpose.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 私钥只有密钥的所有者知道，公钥被认为是公开信息，可供任何人使用。每个密钥都是为特定目的而设计的。
- en: The public key is used to encrypt a message and convert it into ciphertext.
    The private key is used to decrypt a message that has been encrypted with the
    public key.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 公钥用于加密信息，将其转换为密文。私钥用于解密用公钥加密过的信息。
- en: How the Diffie-Hellman Algorithm Works
  id: totrans-79
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 迪菲-赫尔曼算法是如何工作的
- en: 'The Diffie-Hellman algorithm is based on a mathematic principle and uses the
    following formula:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 迪菲-赫尔曼算法基于一个数学原则，并使用以下公式：
- en: g^a (mod p)
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 模幂运算表示为 \(g^a \mod p\)
- en: Modulo is the remainder of a division operation. For example, 5 mod 3 = 2 because
    2 would be left over. Mod can also be expressed as %.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 模运算是指除法运算的余数。例如，\(5 \mod 3 = 2\) 因为2会被剩下。模运算也可以表示为 \%.
- en: With p, g as a prime number, g is a primitive root modulo p. The g and p numbers
    are public and can be seen and used by anyone.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在 \(p, g\) 为素数的情况下，\(g\) 是模 \(p\) 的原根。\(g\) 和 \(p\) 的数字是公开的，任何人都可以看到和使用。
- en: In math, a g number is a primitive root modulo n if every integer relatively
    prime to n is congruent to a power of g modulo n.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学中，如果每个与 \(n\) 互质的整数在模 \(n\) 下与 \(g\) 的幂相等，那么 \(g\) 就是模 \(n\) 的原根。
- en: 'For example, 2 is a primitive root mod 5, all the numbers relatively prime
    to 5 are 1, 2, 3, and 4; and each of these (mod 5) is itself, meaning that 2 (mod
    5) = 2:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，2是模5的原根，所有与5互质的数是1，2，3和4；而这些每个（模5）都是它自己，意味着 \(2 \mod 5 = 2\)：
- en: 2⁰ = 1, 1 (mod 5) = 1, so 2⁰ ≡ 1
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(2^0 = 1, 1 \mod 5 = 1, \) 所以 \(2^0 \equiv 1\)
- en: 2¹ = 2, 2 (mod 5) = 2, so 2¹ ≡ 2
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(2^1 = 2, 2 \mod 5 = 2, \)所以 \(2^1 \equiv 2\)
- en: 2³ = 8, 8 (mod 5) = 3, so 2³ ≡ 3
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(2^3 = 8, 8 \mod 5 = 3, \) 所以 \(2^3 \equiv 3\)
- en: 2² = 4, 4 (mod 5) = 4, so 2² ≡ 4
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(2^2 = 4, 4 \mod 5 = 4, \) 所以 \(2^2 \equiv 4\)
- en: Now, we will look at how the Diffie-Hellman algorithm works. Let's use a simple
    example to understand the algorithms of key exchange. Imagine Alice and Bob want
    to exchange information. Now, assume a hacker named Eve is trying to intercept
    the message.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将看看 Diffie-Hellman 算法是如何工作的。让我们用一个简单的例子来理解密钥交换的算法。想象一下爱丽丝和鲍勃想要交换信息。现在，假设一个名叫伊芙的黑客正在试图拦截消息。
- en: '**Step 1 –** Alice and Bob agree that all messages need to be calculated by
    the formula g^a (mod p) using a modulus p = 13 and base g = 6\. Alice and Bob
    both select a secret number that is known only to them. However, the formula and
    numbers g and p are public to everyone.![](../images/535492_1_En_2_Chapter/535492_1_En_2_Fig5_HTML.png)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 1 –** 爱丽丝和鲍勃同意所有消息都需要使用模数 p = 13 和基数 g = 6 的公式 g^a (mod p) 来计算。爱丽丝和鲍勃都选择了一个只有他们自己知道的密钥数字。然而，公式以及数字
    g 和 p 是公开给每个人的。![](../images/535492_1_En_2_Chapter/535492_1_En_2_Fig5_HTML.png)'
- en: An illustration of the public value agreed upon by Alice and Bob. Modulus p
    equals 13 and base g equals 6.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 爱丽丝和鲍勃同意的公共值图示。模数 p 等于 13，基数 g 等于 6。
- en: Figure 2-5
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 2-5**'
- en: Alice and Bob agree on public value
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 爱丽丝和鲍勃同意公共值
- en: '**Step 2 –** Alice chooses a secret random number (a = 5) as her private key,
    and Bob chooses his private key (b = 4).![](../images/535492_1_En_2_Chapter/535492_1_En_2_Fig6_HTML.png)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 2 –** 爱丽丝选择了一个秘密的随机数字（a = 5）作为她的私钥，鲍勃选择了他的私钥（b = 4）。![](../images/535492_1_En_2_Chapter/535492_1_En_2_Fig6_HTML.png)'
- en: An illustration of secret private keys of Alice and Bob. Alice's random secret
    key, a equals 5 and Bob's random secret key, a equals 4.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 爱丽丝和鲍勃的秘密私钥图示。爱丽丝的随机私钥 a 等于 5，鲍勃的随机私钥 a 等于 4。
- en: Figure 2-6
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 2-6**'
- en: Alice’s and Bob’s secret keys
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 爱丽丝和鲍勃的密钥
- en: '**Step 3 –** Alice and Bob will then use the formula to calculate public values
    using the p and g parameters and their private values.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 3 –** 爱丽丝和鲍勃然后将使用该公式，利用 p 和 g 参数以及他们的私有值来计算公共值。'
- en: Alice will calculate using the following:![](../images/535492_1_En_2_Chapter/535492_1_En_2_Fig7_HTML.png)
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 爱丽丝将使用以下方程计算：![](../images/535492_1_En_2_Chapter/535492_1_En_2_Fig7_HTML.png)
- en: A schematic depicts the public values calculation of Alice and Bob. The public
    value for Alice is 6 power 5 is equal to 7776, mod 13 is equal to 2, and Bob is
    6 power 4 is equal to 1296, and mod 13 is equal to 9.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图表展示了爱丽丝和鲍勃的公共值计算。爱丽丝的公共值为 6 的 5 次方等于 7776，模 13 等于 2，鲍勃的公共值为 6 的 4 次方等于 1296，模
    13 等于 9。
- en: Figure 2-7
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 2-7**'
- en: Alice and Bob calculate public values
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 爱丽丝和鲍勃计算公共值
- en: 6⁵ (mod 13) = 7776 mod 13 = 2
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 6⁵ (mod 13) = 7776 mod 13 = 2
- en: 'Bob will calculate using the following:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 鲍
- en: 6⁴ (mod 13) = 1296 mod 13 = 9
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 6⁴ (mod 13) = 1296 mod 13 = 9
- en: '**Step 4 –** Alice sends her calculated result (2) to Bob over the Internet.
    Eve can see this. Bob sends his calculated result (9) to Alice, and Eve can see
    this also.![](../images/535492_1_En_2_Chapter/535492_1_En_2_Fig8_HTML.png)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 4 –** 爱丽丝将她的计算结果（2）通过互联网发送给鲍勃。伊芙可以看到这个。鲍勃将他的计算结果（9）发送给爱丽丝，伊芙也可以看到这个。![](../images/535492_1_En_2_Chapter/535492_1_En_2_Fig8_HTML.png)'
- en: An illustration depicts the exchange of public keys each other by Alice and
    Bob. The exchange keys are 9 from Bob, and 2 from Alice.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图示展示了爱丽丝和鲍勃互相交换公共密钥的过程。交换的密钥是鲍勃的 9 和爱丽丝的 2。
- en: Figure 2-8
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 2-8**'
- en: Alice and Bob send their results to each other
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 爱丽丝和鲍勃将他们的结果互相发送
- en: '**Step 5 –** Alice and Bob both received the other side''s public message,
    and they calculated the shared secret through the formula g^a (mod p).'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 5 –** 爱丽丝和鲍勃都收到了对方的公共消息，并通过公式 g^a (mod p) 计算出了共享密钥。'
- en: In this step, g is a public message sent from the other side.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步中，g 是一个从另一方发送的公共消息。
- en: Alice will calculate using the following equation:![](../images/535492_1_En_2_Chapter/535492_1_En_2_Fig9_HTML.png)
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 爱丽丝将使用以下方程计算：![](../images/535492_1_En_2_Chapter/535492_1_En_2_Fig9_HTML.png)
- en: An illustration depicts the secret calculation of Alice and Bob. The calculation
    for Alice is 9 power 5 is equal to 59049, 59049 mod 13 is equal to 3, Bod is 2
    power 4 is equal to 16, and 16 mod 13 is equal to 3.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图示展示了爱丽丝和鲍勃的秘密计算。爱丽丝的计算为 9 的 5 次方等于 59049，59049 mod 13 等于 3，鲍勃的计算为 2 的 4 次方等于
    16，16 mod 13 等于 3。
- en: Figure 2-9
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 2-9**'
- en: Alice and Bob receiving the same values
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 爱丽丝和鲍勃得到相同的值
- en: 9⁵ (mod 13) = 59049 mod 13 = 3
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 9⁵ (mod 13) = 59049 mod 13 = 3
- en: 'Bob will calculate using the following equation:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 鲍勃将使用以下方程计算：
- en: 2⁴ (mod 13) = 16 mod 13 = 3
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 2⁴ (mod 13) = 16 mod 13 = 3
- en: Both Alice and Bob have gotten the same values.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 爱丽丝和鲍勃都得到了相同的值。
- en: Eve is a hacker. She intercepts the message sent between Alice and Bob. Eve
    can see the public value (g^a (mod p)), g is, she can see what p is, and she knows
    the computed results from Alice and Bob. However, Eve does not know the secret
    numbers chosen by Alice and Bob, and she will not be able to find them easily.![](../images/535492_1_En_2_Chapter/535492_1_En_2_Fig10_HTML.png)
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 伊娃是个黑客。她拦截了爱丽丝和鲍勃之间发送的消息。伊娃可以看到公开值（g^a (mod p)），看到g是什么，看到p是什么，看到爱丽丝和鲍勃的计算结果。然而，伊娃不知道爱丽丝和鲍勃选择的秘密数字，并且她无法轻易找到它们。![](../images/535492_1_En_2_Chapter/535492_1_En_2_Fig10_HTML.png)
- en: A schematic depicts Alice's and Bob's secret values not known by hacker Eve.
    The values are a is equal to 5 for Alice and 4 for Bob. Alice and Bob agreed that
    g power a, modulus p is equal to 13, and base g is equal to 6.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图表展示了黑客伊娃不知道的爱丽丝和鲍勃的秘密值。这些值是爱丽丝的a等于5，鲍勃的a等于4。爱丽丝和鲍勃同意g的a次幂模p等于13，底数g等于6。
- en: Figure 2-10
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-10
- en: Hacker Eve does not know Alice’s and Bob’s secret values
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 黑客伊娃不知道爱丽丝和鲍勃的秘密值
- en: 'From the Diffie and Hellman example, we can see that both Alice and Bob, using
    the following equation, computed to get the same result:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 从迪菲和赫尔曼的例子中，我们可以看出，爱丽丝和鲍勃都使用以下方程计算得到相同的结果：
- en: '*(g*^(*a*) *(mod p))*^(*b*) *mod p = (g*^(*b*) *(mod p))*^(*a*) *mod p*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*(g*^(*a*) *(mod p))*^(*b*) *mod p = (g*^(*b*) *(mod p))*^(*a*) *mod p*'
- en: The shared key is g^(ab). Typically, a, b, and p are much larger values. This
    is needed to make results secure.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 共享密钥是g^(ab)。通常，a、b和p的值都很大。这是为了使结果安全。
- en: In the original Diffie and Hellman description, the algorithm does not provide
    identity verification for communicating parties. This led to the algorithm being
    vulnerable to man-in-the-middle attacks.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在原始的迪菲和赫尔曼描述中，算法没有为通信方提供身份验证。这使得算法容易受到中间人攻击。
- en: 'Look at the following example:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的例子：
- en: Eve intercepts the message between Alice and Bob and blocks communication between
    them.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 伊娃拦截了爱丽丝和鲍勃之间的消息并阻断了他们之间的通信。
- en: Eve intercepts Alice’s public value (g^a(mod p)) and sends Alice her own public
    value (g^c(mod p)).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 伊娃拦截了爱丽丝的公开值（g^a(mod p)）并发送给爱丽丝她自己的公开值（g^c(mod p)）。
- en: Eve intercepts Bob’s public value (g^b(mod p)) and sends Bob his public value
    (g^d(mod p)).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 伊娃拦截了鲍勃的公开值（g^b(mod p)）并发送给鲍勃他的公开值（g^d(mod p)）。
- en: Neither Alice nor Bob can detect any problem, and each may assume that the other
    side received their message, but in reality, Eve can decrypt, read, modify, and
    re-encrypt all of their messages.![](../images/535492_1_En_2_Chapter/535492_1_En_2_Fig11_HTML.png)
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 爱丽丝和鲍勃都无法检测到任何问题，每个方向都可能认为对方收到了他们的消息，但实际上，伊娃可以解密、阅读、修改和重新加密他们的所有消息。![](../images/535492_1_En_2_Chapter/535492_1_En_2_Fig11_HTML.png)
- en: An image depicts the algorithm g power a mod p being vulnerable to man-in-the-middle
    attacks. The explanation is hacker Eve intercepts Alice and Bob's messages and
    blocks the communication between them.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图表展示了算法g的a次幂模p容易受到中间人攻击。解释是黑客伊娃拦截了爱丽丝和鲍勃的消息并阻断了他们之间的通信。
- en: Figure 2-11
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-11
- en: A man-in-the-middle attack
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 中间人攻击
- en: Diffie and Hellman is the first asymmetric cryptography protocol and provided
    the basis for many authenticated protocols, such as the elliptic curve Diffie-Hellman
    asymmetric algorithm and RSA, that are widely used today. Crypto, secure shell
    (SSH), secure sockets layer (SSL), email, and VPN security are all based on these
    asymmetric algorithms.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 迪菲和赫尔曼是第一个非对称加密协议，并为许多认证协议提供了基础，例如广泛使用的椭圆曲线迪菲-赫尔曼非对称算法和RSA。加密、安全外壳（SSH）、安全套接字层（SSL）、电子邮件和VPN安全都是基于这些非对称算法的。
- en: How Digital Signatures Work
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 数字签名是如何工作的
- en: 'If Alice wants to send a signed message to Bob over the Internet, the following
    steps should be followed:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果爱丽丝想通过互联网将一条已签名的消息发送给鲍勃，应遵循以下步骤：
- en: '1.'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '1.'
- en: We begin with the message on Alice's (the sender’s) side.
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们从发送方爱丽丝的消息开始。
- en: '2.'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '2.'
- en: The algorithm generates a one-way hash of the message based on the document
    checksum.
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 算法根据文档校验和生成消息的单向散列值。
- en: '3.'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '3.'
- en: The hash is signed or encrypted using Alice's private key.
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 消息的散列值使用爱丽丝的私钥进行签名或加密。
- en: '4.'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '4.'
- en: The message is sent to Bob.
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 消息被发送给鲍勃。
- en: '5.'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '5.'
- en: Bob receives the message.
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 鲍勃收到消息。
- en: '6.'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '6.'
- en: Bob decrypts the message using Alice's public key and verifies the message authentication
    that was signed by Alice.
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 鲍勃使用爱丽丝的公开密钥对消息进行解密，并验证爱丽丝签署的消息认证。
- en: '7.'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '7.'
- en: The algorithm regenerates a hash of the message.
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 算法重新生成消息的散列值。
- en: '8.'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '8.'
- en: The two hash values are compared. If they are identical, we ensure that the
    transmitted document has not been altered since signing.
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这两个散列值进行比较。如果它们相同，我们可以确保自签名以来传输的文档没有被篡改。
- en: The process of a digital signature is shown in Figure [2-12](#Fig12).![](../images/535492_1_En_2_Chapter/535492_1_En_2_Fig12_HTML.png)
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 数字签名的过程如图[2-12](#Fig12)所示。![](../images/535492_1_En_2_Chapter/535492_1_En_2_Fig12_HTML.png)
- en: A schematic depicts the process of digital signatures of Alice and Bob. The
    labeled process is origin document, hash, signing/encrypt, private key, public,
    unsigning/decrypt, origin document, and hash.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图解展示了Alice和Bob的数字签名过程。标记的过程是原始文档、散列、签名/加密、私钥、公钥、解签名/解密、原始文档和散列。
- en: Figure 2-12
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-12
- en: The process of digital signatures
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 数字签名过程
- en: Digital Signatures
  id: totrans-160
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 数字签名
- en: A digital signature is an asymmetric public key cryptography technique that
    verifies digital messages or document owner authenticity.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 数字签名是一种非对称公钥加密技术，用于验证数字消息或文档所有者的真实性。
- en: We often use the public key for message encryption and the private key for message
    decryption in public key encryption. However, in the case of a digital signature,
    the message is encrypted with a sender's private key, or in other words, the message
    is signed.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常在公钥加密中使用公钥进行消息加密，私钥进行消息解密。然而，在数字签名的情况下，消息是用发送者的私钥加密的，换句话说，消息被签名了。
- en: As the signer's public key is known, anybody can verify a message's digital
    signature.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 由于发送者的公钥是已知的，任何人都可以验证消息的数字签名。
- en: 'A digital signature includes the following characteristics:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 数字签名包括以下特性：
- en: Authentication (verification of who signed the origin of the document)
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证（验证谁签署了文档的来源）
- en: Nonrepudiation (the identity of the signer and document that they have digitally
    signed should be undeniable)
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可否认性（签署者和他们数字签名过的文档的身份应该是不可否认的）
- en: Integrity (proof that the document has not been altered since signing)
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完整性（证明文档自签名以来未被篡改的证据）
- en: Hash Algorithms
  id: totrans-168
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 散列算法
- en: In Chapter [1](535492_1_En_1_Chapter.xhtml), “How Blockchain Works” section,
    the hash concept was introduced, and the way that blockchain uses the SHA-256
    hash function to hash transaction data was discussed. In the previous section,
    the process of digital signatures was discussed. The process indicated that the
    process needed to apply a hash function.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在第[1](535492_1_En_1_Chapter.xhtml)章“区块链如何工作”部分，介绍了散列概念，并讨论了区块链如何使用SHA-256散列函数对交易数据进行散列。在前一节中，讨论了数字签名过程。该过程表明需要应用散列函数。
- en: Hash algorithm is a mathematical function that divides original data input into
    smaller blocks of equal size and then executes the hash function to two fixed-size
    data blocks to generate a hash code. The algorithm starts from the first block
    of message data with a seed value that passes into the hash function, outputting
    the first hash code.![](../images/535492_1_En_2_Chapter/535492_1_En_2_Fig13_HTML.jpg)
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 散列算法是一种数学函数，它将原始数据输入分为大小相等的较小数据块，然后执行散列函数生成两个固定大小的数据块的散列码。该算法从消息数据的第一块开始，使用一个种子值传入散列函数，输出第一个散列码。![](../images/535492_1_En_2_Chapter/535492_1_En_2_Fig13_HTML.jpg)
- en: An illustration depicts the algorithm code of the 2 data blocks generate a hash
    function. It gives the hash value 356A192B7913B04C54574 D18C28D46E6395428AB.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 插图展示了2个数据块生成散列函数的算法代码。它给出了散列值为356A192B7913B04C54574D18C28D46E6395428AB。
- en: Figure 2-13
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-13
- en: Two fixed-size data blocks used to generate a hash code The process is similar
    to block cipher, discussed in the previous section. The hash process will start
    from the first block and end at the last block. This process can be repeated for
    as many rounds as are required by the algorithm. Eventually, all block data will
    be chained together and hashed.![](../images/535492_1_En_2_Chapter/535492_1_En_2_Fig14_HTML.jpg)
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 用以生成散列码的两个固定大小的数据块 该过程类似于前节中讨论的块加密。散列过程将从第一块开始，结束于最后一块。这个过程可以根据算法要求重复多次。最终，所有块数据都将链接在一起并散列。![](../images/535492_1_En_2_Chapter/535492_1_En_2_Fig14_HTML.jpg)
- en: A flow diagram of the hash algorithm. The labeled flows are data seed, message
    block, and hash function. The process is continued till receiving the hash value.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 散列算法的流程图。标记的流程是数据种子、消息块和散列函数。该过程将持续到收到散列值。
- en: Figure 2-14
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-14
- en: The hash algorithm
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 散列算法
- en: The Keccak-256 Algorithm
  id: totrans-177
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Keccak-256算法
- en: The Keccak-256 algorithm is a hash function that is widely used in an Ethereum
    blockchain. A few examples include Ethereum addresses, some smart contract functions,
    and the Ethereum consensus engine known as Ethash that plays an important role
    in producing blocks and other security actions.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Keccak-256算法是一个广泛应用于以太坊区块链的哈希函数。一些例子包括以太坊地址、一些智能合约函数以及被称为Ethash的以太坊共识引擎，它在产生区块和其他安全行动中扮演着重要角色。
- en: The Keccak-256 is a family of SHA-3 hash functions. The function input can be
    a variable-length string or number, and generated output will always be a fixed-length,
    64-character (letters and numbers) output. The output can be converted to hexadecimal
    numbers. Like all other hash functions, it is a one-way cryptographic hash function.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Keccak-256是SHA-3哈希函数家族的一员。函数输入可以是一个变长字符串或数字，生成的输出将始终是一个固定长度的64个字符（字母和数字）输出。输出可以转换为十六进制数字。与其他所有哈希函数一样，它是一个单向加密哈希函数。
- en: 'Keccak-256 is based on the sponge construction and is a sponge function family.
    Keccak-256 sponge function (Keccak[r,c]) needs two parameters: one of size r (the
    bitrate and the amount of data encoded for a single unit of time) and the other
    of size c (the capacity).'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Keccak-256是基于吸墨构造的，是一个吸墨函数家族。Keccak-256吸墨函数（Keccak[r,c]）需要两个参数：一个大小为r（比特率和编码单个时间单位的数据显示量）和另一个大小为c（容量）。
- en: '**Padding**'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**填充**'
- en: A padding function will append enough bits to the input data (M), and the length
    of the padded input can be split into multiple r-bit blocks.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 填充函数将在输入数据（M）后添加足够的位，并且填充后的输入长度可以分为多个r位块。
- en: '**Initialization**'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**初始化**'
- en: The padded input is broken into r-bit blocks, assuming the blocks' names are
    called M0, M1, M2, and so on.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 填充后的输入被分成r位块，假设块的名称是M0, M1, M2, 等等。
- en: '**The Absorbing Phase**'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**吸收阶段**'
- en: The r-bit block is XORed with small chunks of the input data M0\. The result
    is then passed to a compression function f. The output of function f XORed next
    message M1\. The process is repeated until each of the message blocks Mn is processed.
    In each step, a small chunk of the input data (the bit length of r) is “absorbed”
    into the buffer.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: r位块与输入数据M0的小块进行异或操作。然后将结果传递给压缩函数f。函数f的输出与下一个消息M1进行异或。重复此过程，直到处理完每个消息块Mn。在每一步中，一小块输入数据（位长度为r）被“吸收”到缓冲区中。
- en: '**The Squeezing Phase**'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**压缩阶段**'
- en: The same process is repeated. The r-bit block of the buffer consists of the
    next r bits of output (Z0, Z1, Z2, and so on). The function f is used to extract
    r bits of data as the next r bits of the output. The process is repeated until
    the results are produced.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的过程重复进行。缓冲区的r位块由下一个r位输出（Z0, Z1, Z2, 等等）组成。使用函数f提取r位数据作为下一个r位输出。重复此过程直到产生结果。
- en: Figure [2-15](#Fig15) illustrates the Keccak-256 hash algorithm.![](../images/535492_1_En_2_Chapter/535492_1_En_2_Fig15_HTML.png)
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图[2-15](#Fig15)展示了Keccak-256哈希算法。![](../images/535492_1_En_2_Chapter/535492_1_En_2_Fig15_HTML.png)
- en: An algorithm depicts the Keceeak-256 hash values, through 2 processes absorbing
    and squeezing. The labeled process is the message, pad, and output.3658-89/+/
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 算法描述了通过两个吸收和压缩过程的Keccak-256哈希值。带标签的过程是消息、填充和输出。3658-89/+/
- en: Figure 2-15
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-15
- en: The Keccak-256 hash algorithm
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Keccak-256哈希算法
- en: Elliptic Curve Cryptography (ECC)
  id: totrans-193
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 椭圆曲线密码学（ECC）
- en: ECC was discovered in 1985 by Victor Miller (IBM) and Neil Koblitz (University
    of Washington) independently and is currently one of the most robust and widely
    used types of encryption cryptography. Blockchain networks, such as Bitcoin and
    Ethereum, use ECC.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 椭圆曲线密码学（ECC）是在1985年由Victor Miller（IBM）和Neil Koblitz（华盛顿大学）独立发现的，目前是最健壮且广泛使用的加密密码学类型之一。比特币和以太坊等区块链网络使用ECC。
- en: In 2005, the US National Security Agency (NSA) announced a set of unpublished
    algorithms known as Suite B protocols and posted a paper titled “The Case for
    Elliptic Curve Cryptography” in which they recommended that the US government
    use ECC to secure sensitive and unclassified communications. ^([2](#Fn2))
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 2005年，美国国家安全局（NSA）公布了一套未发表的算法，称为Suite B协议，并发布了一篇题为“椭圆曲线密码学的案例”的论文，他们建议美国政府使用ECC来保护敏感和非机密的通信。^([2](#Fn2))
- en: The NSA commented that analysts should “take advantage of the past 30 years
    of public key research and analysis and move from first generation public key
    algorithms and on to elliptic curves.”
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 美国国家安全局（NSA）评论称，分析师应该“利用过去30年的公钥研究和分析，从第一代公钥算法转向椭圆曲线。”
- en: Suite B’s protocols included both elliptic curve Diffie-Hellman (ECDH) and elliptic
    curve Menezes-Qu-Vanstone (ECMQV) for key exchange, the elliptic curve digital
    signature algorithm (ECDSA) for digital signatures, the advanced encryption standard
    (AES) for symmetric encryption, and the secure hashing algorithm (SHA). After
    the release of these protocols, ECC soon became the de facto standard for protecting
    modern industry communications.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 套件B的协议包括椭圆曲线Diffie-Hellman（ECDH）和椭圆曲线Menezes-Qu-Vanstone（ECMQV）用于密钥交换，椭圆曲线数字签名算法（ECDSA）用于数字签名，高级加密标准（AES）用于对称加密，以及安全散列算法（SHA）。这些协议发布后，ECC很快成为了保护现代工业通信的事实标准。
- en: ECC is based on algebraic properties of elliptic curves and provides equivalent
    security with much smaller key sizes than other asymmetric cryptography systems,
    such as RSA or DSA. For example, a 256-bit ECC key is equal in power to a 3072-bit
    RSA key. This also makes elliptic curves significantly faster.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 椭圆曲线基于椭圆曲线的代数性质，并提供了与其他非对称加密系统（如RSA或DSA）等效的安全性，但密钥尺寸要小得多。例如，一个256位的ECC密钥与一个3072位的RSA密钥具有相同的强度。这也使得椭圆曲线显著
    faster.
- en: '**What Is an Elliptic Curve?**'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '**椭圆曲线是什么？**'
- en: 'An elliptic curve is a curve given through the following equation:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 椭圆曲线是通过以下方程给出的：
- en: y ² = x ³ + Ax + B
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: y ² = x ³ + Ax + B
- en: 'The curve, as required, is nonsingular and needs to have no repeated roots
    or self-intersections. To ensure that the curve is nonsingular, the condition
    can be expressed through the following equation:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 曲线，如所需，是非单点的，并且需要没有重复的根或自交。为了确保曲线是非单点的，条件可以通过以下方程表达：
- en: 4A³ + 27B² ≠ 0
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 4A³ + 27B² ≠ 0
- en: An example of the elliptic curve when A = -1 and B = 1 can be seen in Figure
    [2-16](#Fig16):![](../images/535492_1_En_2_Chapter/535492_1_En_2_Fig16_HTML.png)
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当A = -1且B = 1时，椭圆曲线的例子可以在图[2-16](#Fig16)中看到：![](../images/535492_1_En_2_Chapter/535492_1_En_2_Fig16_HTML.png)
- en: A curve graph depicts the elliptic of the equation y square is equal to cubic
    x minus x plus 1\. The curve started at point negative 3, bent in negative 1.5,
    and ended at 3 approximately.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 曲线图描绘了方程y平方等于x立方减x加1的椭圆。曲线从点-3开始，在-1.5处弯曲，最终在大约3处结束。
- en: Figure 2-16
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-16
- en: Elliptic curve y² = x³ - x + 1
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 椭圆曲线y² = x³ - x + 1
- en: y² = x³ - x + 1
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: y² = x³ - x + 1
- en: In an elliptic curve, there is a useful property to create an addition on the
    curve, turning it into an abelian group. Take two points, P and Q, on the curve,
    and draw a line through them. The line will intersect the curve at one more point
    (R). Take P + Q as R, and from R, another line can be drawn either straight up
    (if R is below the x-axis) or straight down (if R is above the x-axis) to the
    other side of the curve, opposite to the point -R (see Figure [2-17](#Fig17)).![](../images/535492_1_En_2_Chapter/535492_1_En_2_Fig17_HTML.jpg)
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在椭圆曲线中，有一个有用的性质可以在曲线上创建加法，使其成为一个阿贝尔群。取曲线上的两个点P和Q，并通过它们画一条直线。这条直线将在曲线上 intersect
    at one more point (R)。取P + Q为R，从R，还可以画另一条直线，要么直线上升（如果R在x轴以下），要么直线下降（如果R在x轴以上）到曲线的另一侧，与点-R相对（见图[2-17](#Fig17)）。![](../images/535492_1_En_2_Chapter/535492_1_En_2_Fig17_HTML.jpg)
- en: A curve graph depicts the addition of 2 points R and negative R of elliptic.
    The curve passes a line of axis P, Q, and R. The result is calculated by negative
    R implies P plus Q.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 曲线图描绘了椭圆的2点R和负R的加法。曲线通过轴P、Q和R的直线。结果通过负R得出P加Q。
- en: Figure 2-17
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-17
- en: The elliptic curve addition of two points (R and -R)
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 两点（R和-R）的椭圆曲线加法
- en: 'The group law for an elliptic curve is expressed through either of the following
    equations:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 椭圆曲线的群法通过以下任意一个方程表达：
- en: P + Q + R = 0, or P + Q = - R
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: P + Q + R = 0，或者P + Q = - R
- en: The sum of the points P and Q is equal to the point - R.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 点P和Q的和等于点- R。
- en: 'With the addition of points P = (x[1], y[1]) and Q = (x[2], y[2]) of an elliptic
    curve, a third point can be calculated using the following formulas:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在椭圆曲线P = (x[1], y[1])和Q = (x[2], y[2])两点相加时，可以使用以下公式计算第三个点：
- en: P + Q = R = (x[3], y[3]) where
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: P + Q = R = (x[3], y[3])其中
- en: '![](../images/535492_1_En_2_Chapter/535492_1_En_2_Figa_HTML.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/535492_1_En_2_Chapter/535492_1_En_2_Figa_HTML.jpg)'
- en: Equations for x cube and y cube. Value of lambda for P not equal to Q and P
    equal to Q
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: x立方和y立方的方程。当P不等于Q和P等于Q时lambda的值
- en: 'Elliptic curve E over Z[p] is defined by the following equations, and Z[p]
    is field modulo p, meaning that {0, 1, 2, …, n - 1}:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 椭圆曲线E在Z[p]上由以下方程定义，而Z[p]是模p的场，意味着{0, 1, 2, …, n - 1}：
- en: '![](../images/535492_1_En_2_Chapter/535492_1_En_2_Figb_HTML.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/535492_1_En_2_Chapter/535492_1_En_2_Figb_HTML.jpg)'
- en: A formula depicts the mod p equation of y square equals cubic 3 plus A x plus
    B, and A B E Z of p, 4 cubic A plus 27 B square not equal to 0.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: 'By applying this formula, the elliptic curve E over Z[p] - E(Z[p]) has a list
    of points (x, y). In the following example, elliptic curve y² = x³ + Ax + B =
    x ³ + 2x + 3 → y²(mod 5), where A = 2, B = 3, and P = 5\. This can be seen through
    the following:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: X = 0 → y² = 3 → no solution (mod 5)
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: X = 1 → y² = 6 → 6 (mod 5) = 1
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: → y = 1, 4 because 1² (mod 5) = 1, and 4² (mod 5) = 1
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: X = 2 → y² = 15 → 15 (mod 5) = 0
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: → y = 0 because 0² (mod 5) = 0
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: X = 3 → y² = 36 → 36 (mod 5) = 1
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: → y = 1, 4 because 1² (mod 5) = 1, and 4² (mod 5) = 1
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: X = 4 → y² = 75 → 75 (mod 5) = 0
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: → y = 0 because 0² (mod 5) = 0
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, the elliptic curve has the following seven points:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: (1, 1), (1, 4), (2, 0), (3, 1), (3, 4), (4, 0), ∞.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, rearranging the modulus operator P = 263 leaves the following equation:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: (x³ + 2x + 3) (mod 263)
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Scalar multiplication over the elliptic curve y² = x³ + 2x + 3 in mod 263\.
    The curve has 270 points, including the point at infinity.![](../images/535492_1_En_2_Chapter/535492_1_En_2_Fig18_HTML.png)
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: A dot depicts the elliptic curve of equation y square equal to cubic 3 plus
    2 x plus 3, representing the point as Q and P. Both axis ranges from 0 to 250.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2-18
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Elliptic curve y² = x³ + 2x + 3 (mod 263)
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: In the elliptic curve, when if P is (x, y) ∈ *E(Z*[*p*]*)*, then (x, y) + (x,
    -y) = ∞ (the point at infinity).
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: 'So, if adding ∞ to any point P in E(Z[p]), we can always get P back. This can
    be expressed through the following equation:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: P + ∞ = ∞ + P = P for all ∈ E(Z[p])
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: 'In Alice’s and Bob’s message communication, P is a (x,y) point on the curve
    that both Bob and Alice will agree to. Bob’s private key is represented by n,
    and K is his public key. We multiply P and n together to produce K, as shown as
    follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: K = n P
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: If we multiply K with P, it will get the point on the elliptic curve.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Deriving an Ethereum Address
  id: totrans-247
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We have learned about cryptography so far. Now it is time to do some practice
    and apply our knowledge to generate an Ethereum address. We will utilize multiple
    online tools to do this exercise. Of course, you can choose a different tool if
    you find a better one, or you can even write code to implement the same result:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '1.'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a random private key and derive the public key from this private key
    using EC curve (secp256k1).
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The private key is 64 hexadecimal characters long (32 bytes).
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Here we use an online tool ([https://​kjur.​github.​io/​jsrsasign/​sample/​sample-ecdsa.​html](https://kjur.github.io/jsrsasign/sample/sample-ecdsa.xhtml))
    to get a public and private key pair. The generated public and private key pair
    can be seen in Figure [2-19](#Fig19).
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](../images/535492_1_En_2_Chapter/535492_1_En_2_Fig19_HTML.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
- en: An algorithm depicts the elliptic supported by the chosen E C curve name and
    generates key pair. The process is generated by 2 keys E C private key and E C
    public key.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2-19
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: The elliptic curve generating public and private keys
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 椭圆曲线生成公钥和私钥
- en: 'Private key: 8c2b80899dd44981d7f8b38c1f5b13dbf1fbb98c360d9d1cfd63a3aed0d7b498'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 私钥：8c2b80899dd44981d7f8b38c1f5b13dbf1fbb98c360d9d1cfd63a3aed0d7b498
- en: 'Public key: 04502fa444861915b6a258c3daa2beaa41c9b912e6fd6cd526fa179c60362f602bd75e36cfe1513a1e460ca646476e54fab08aa42730068326ab0a8a2e57d2829b'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 公钥：04502fa444861915b6a258c3daa2beaa41c9b912e6fd6cd526fa179c60362f602bd75e36cfe1513a1e460ca646476e54fab08aa42730068326ab0a8a2e57d2829b
- en: '2.'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '2.'
- en: 'Derive the address from the following public key:'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从以下公钥中派生地址：
- en: Start with the public key (128 characters) and apply the Keccak-256 hash of
    the public key. It will generate a string that is 64 characters long (32 bytes).
    Let’s use the Keccak-256 online tool ([https://​emn178.​github.​io/​online-tools/​keccak_​256.​html](https://emn178.github.io/online-tools/keccak_256.xhtml))
    to see the hash result (see Figure [2-20](#Fig20)).
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从公钥（128个字符）开始，应用公钥的Keccak-256散列。它会生成一个64个字符长（32字节）的字符串。让我们使用Keccak-256在线工具（[https://​emn178.​github.​io/​online-tools/​keccak_​256.​html](https://emn178.github.io/online-tools/keccak_256.xhtml)）来看散列结果（见图[2-20](#Fig20)）。
- en: '![](../images/535492_1_En_2_Chapter/535492_1_En_2_Fig20_HTML.png)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/535492_1_En_2_Chapter/535492_1_En_2_Fig20_HTML.png)'
- en: Two algorithms depict the address and derivation of the Keccak-256 online hash
    function. The keys labeled are input type, hash, and auto-update.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 两个算法展示了地址和Keccak-256在线散列函数的派生。标签的键是输入类型、散列和自动更新。
- en: Figure 2-20
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-20
- en: Keccak-256 hash public key example
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 公钥的Keccak-256散列示例
- en: The result is db97247835ec1f9d0bd8b6ed***6a6d125cf3029f4ccbe72cc1b1a4c7a8c72467a3***
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是db97247835ec1f9d0bd8b6ed***6a6d125cf3029f4ccbe72cc1b1a4c7a8c72467a3***
- en: '3.'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '3.'
- en: Get the Ethereum address
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 获取以太坊地址
- en: Take the last 20 bytes (40 characters) of the generated hash to get the Ethereum
    address with prefix 0x. 0x lets the people know the address in hexadecimal format.
    When prefixed with 0x, it becomes 42 characters long. So, in our example, the
    Ethereum address is
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 取生成的散列的后20字节（40字符）以获得带有前缀0x的以太坊地址。0x让人们知道地址以十六进制格式。当加上前缀0x时，它变成了42个字符长。所以，在我们的例子中，以太坊地址是
- en: '0x6a6d125cf3029f4ccbe72cc1b1a4c7a8c72467a3'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '0x6a6d125cf3029f4ccbe72cc1b1a4c7a8c72467a3'
- en: '4.'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '4.'
- en: Verify the Ethereum address
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 验证以太坊地址
- en: We use one of the online Ethereum address validator tools ([www.rfctools.com/ethereum-address-validator/](http://www.rfctools.com/ethereum-address-validator/))
    to verify our new Ethereum address.
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用其中一个在线以太坊地址验证工具（[www.rfctools.com/ethereum-address-validator/](http://www.rfctools.com/ethereum-address-validator/)）来验证我们新生成的以太坊地址。
- en: '![](../images/535492_1_En_2_Chapter/535492_1_En_2_Fig21_HTML.png)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/535492_1_En_2_Chapter/535492_1_En_2_Fig21_HTML.png)'
- en: A screenshot of the valid Ethereum address validator. The labeled R F C tools
    are cryptocurrency tools, of 4 steps, image tools, J S O N tools, and H T M L
    tools.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 有效以太坊地址验证器的屏幕截图。标签的R F C工具是加密货币工具，包括4个步骤、图像工具、J S O N工具和H T M L工具。
- en: Figure 2-21
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-21
- en: Validating the generated Ethereum address
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 验证生成的以太坊地址
- en: Congratulations! We just generated a valid Ethereum address using our cryptography
    knowledge. At this level, you should get a good sense of how blockchain cryptography
    works.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！我们刚刚使用密码学知识生成了一个有效的以太坊地址。在这个层面，你应该对区块链密码学的工作有一个很好的了解。
- en: Summary
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: Cryptography is an essential mechanism for securing blockchain technology. It
    is used to secure the blockchain consensus mechanism, protect blockchain data,
    keep user accounts safe, and more. The main purpose of this chapter was to give
    a more thorough understanding of cryptography by giving a quick overview of how
    it works.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 密码学是确保区块链技术安全的必要机制。它用于确保区块链共识机制、保护区块链数据、保持用户账户安全等。本章的目的是通过快速概述其工作原理，更深入地了解密码学。
- en: Although it only scratches the surface of cryptography technologies, this chapter
    will help you to enrich your knowledge of symmetric key cryptography and asymmetric
    key cryptography. More importantly, we now know how digital signatures work. We
    covered the hash algorithm, and we walked-through elliptic curve cryptography
    to understand how it works. Lastly, we learned how to generate an Ethereum address.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这章只触及了密码技术表面，但它将帮助你丰富对称密钥密码学和不对称密钥密码学的知识。更重要的是，我们现在知道了数字签名的运作方式。我们介绍了散列算法，并详细讲解了椭圆曲线密码学的工作原理。最后，我们学会了如何生成以太坊地址。
- en: We will continue our journey and learn about Bitcoin, the future of money in
    the next chapter.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续我们的旅程，在下一章学习比特币，货币的未来。
