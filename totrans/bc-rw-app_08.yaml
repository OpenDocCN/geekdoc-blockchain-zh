- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Encryption and Cybersecurity
  prefs: []
  type: TYPE_NORMAL
- en: 8.1 Cryptography
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cryptography is the technique of secure communication that allows only the actual
    sender of the message and the intended recipient to see the relevant content.
    The word is derived from the Greek root – *kryptos* (hidden).
  prefs: []
  type: TYPE_NORMAL
- en: Claude E. Shannon, who worked for years at Bell Labs, propounding the mathematical
    theory of cryptography, is considered as the father of cryptography. In this technique,
    an encrypted message replaces the character with another character. To decode
    encrypted content, you’ll need a grid or table that defines how letters are coded
    or decoded.
  prefs: []
  type: TYPE_NORMAL
- en: 8.1.1 Different Types of Cryptography
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In general, there are three types of cryptography:'
  prefs: []
  type: TYPE_NORMAL
- en: 8.1.1.1 Symmetric Key Cryptography
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Symmetric cryptography is an encryption system where the sender and receiver
    of a message encrypt and decrypt messages using common keys. Symmetric key systems
    are fast and simple but require the sender and receiver to exchange keys in a
    secure way. In symmetric cryptography, a secret key (or private key) is a short
    piece or code from which messages are decrypted and encrypted. The most popular
    symmetric key cryptography system is the Data Encryption System (DES).
  prefs: []
  type: TYPE_NORMAL
- en: 8.1.1.2 Asymmetric Key Cryptography
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Asymmetric encryption is also called public key encryption, but it actually
    results from the simultaneous use of two mathematically coupled keys, one the
    public key, and the other the private key. In this process, a message is encrypted
    and decrypted by the respective keys to protect it from unauthorized access or
    use. The public key is widely disseminated for encryption, and the private key
    of the receiver is used for decryption. The public key is known by all, so the
    intended receiver can only decode it because he alone knows the private key. Therefore,
    the private key is kept secret and is used only by its owner.
  prefs: []
  type: TYPE_NORMAL
- en: 8.1.1.3 Hash Functions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A hash function takes a set of inputs of any arbitrary size and fits them into
    a table or other data structure that contains elements of a fixed size. Hashing
    can be used to convert a password into a string of authorized characters, called
    a “hash value,” or “digest.”
  prefs: []
  type: TYPE_NORMAL
- en: With this data structure, the data in an array can be searched and stored in
    an efficient manner. Suppose someone has a table of 5,000 digits, and he needs
    to find a given number in that list – the software or system will scan each number
    in the list until a match is found.
  prefs: []
  type: TYPE_NORMAL
- en: The hash function in this algorithm does not use encryption but, instead, calculates
    a fixed-length hash value according to the plaintext, which makes it impossible
    to retrieve the contents of the plaintext. Many operating systems use hash functions
    to encrypt passwords. While it is possible, it is unlikely to produce the original
    input by reversing the output values.
  prefs: []
  type: TYPE_NORMAL
- en: 8.1.2 Cryptographic Schemes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The history of cryptography has several milestones that led to the formation
    of the fundamentals of modern algorithms. Cipher was a common notion for conveying
    confidential information in the early times. These ciphers have been conceived
    on the symmetric key encryption scheme. In contrast to present-day digital systems,
    which treat data as binary digits, these systems comprise letters as basic elements.
  prefs: []
  type: TYPE_NORMAL
- en: 8.1.2.1 Simple Substitution Cipher
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Simple Substitution Cipher is the most commonly used cipher that consists
    of an algorithm, substituting each plaintext character for each ciphertext character.
    This cipher makes use of permutation of alphabets. Despite the large number of
    infallible keys, this cipher has some inefficiencies, such as choosing an explicit
    permutation, which does not make this cipher secure.
  prefs: []
  type: TYPE_NORMAL
- en: 8.1.2.2 Caesar Cipher
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Caesar Cipher is the most candid form of substitution cipher scheme. Employing
    this cipher, each letter in the plaintext can be swapped with another alphabet
    letter to form the ciphertext. Even with modest processing power, a hacker can
    easily decrypt plaintext using one of the 26 potential keys, rendering it highly
    vulnerable.
  prefs: []
  type: TYPE_NORMAL
- en: 8.1.2.3Vigenère Cipher
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In order to provide more strength to the cryptosystem, the Caesar Cipher has
    been modified to design the Vigenère Cipher. This cipher operates with a text
    string as the visible cipher key. It converts every single letter of the key to
    a numeric value to transpose characters in plaintext. It was referred to as an
    unbreakable cipher because of the difficult level of decryption.
  prefs: []
  type: TYPE_NORMAL
- en: 8.1.2.4 Transposition Cipher
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In a Transposition Cipher, the positions held by the units of plaintext are
    shifted so that the ciphertext constitutes a permutation of the plaintext.
  prefs: []
  type: TYPE_NORMAL
- en: 8.2 Playfair Cipher
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Playfair Cipher was the first practical digraph substitution cipher, invented
    by Charles Wheatstone in 1854\. It was named after Lord Playfair who promoted
    the use of the cipher. The Playfair Cipher is rather quick and doesn’t necessitate
    any special equipment. They encrypt a pair of letters (digraphs) instead of a
    single alphabet, unlike traditional ciphers.
  prefs: []
  type: TYPE_NORMAL
- en: The cipher was used for strategic purposes during the Boer War, World War I
    (by the British Army), and World War II (by the Australians). Ciphers were used
    to protect important but noncritical secrets during the actual war. By the time
    enemies could decrypt the cryptographic information, it was useless to them.
  prefs: []
  type: TYPE_NORMAL
- en: However, the Playfair Cipher is no longer used, after the development of the
    computer, as computers can quickly and easily decode it, using break codes in
    a split of seconds. Furthermore, it is a time-consuming and labor-intensive process
    that does not require a Playfair cipher decoder or calculator. Despite the fact
    that Python and C both have Playfair Cipher programs, it can be risky for commercial
    organizations to use the Playfair Cipher.
  prefs: []
  type: TYPE_NORMAL
- en: 8.2.1 Encryption Algorithm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Playfair Cipher consists of a key and a plaintext. The key can be formed
    as a short or long word, using any 25-letter combination that doesn’t recur. This
    can be illustrated by an example of Playfair Ciphers with encryption and decryption
    algorithms:'
  prefs: []
  type: TYPE_NORMAL
- en: 8.2.1.1 Step 1 – Generate Squares (5 * 5)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The key square is a 5 * 5 grid of letters, which serves to encrypt the plaintext.
    Given that the grid can only fit 25 letters, one letter (J) of the alphabet is
    dropped from the table. Thus 25 letters are left in the alphabet, without any
    numerics, punctuation, or nonalphabet character. The cipher begins with the exclusive
    alphabet of the key in the order of occurrence, then the remaining characters
    of the alphabet in the same sequence. Thus, a cipher uses a single alphabetic
    class without repetition and includes a digraphic substitution.
  prefs: []
  type: TYPE_NORMAL
- en: 8.2.1.2 Step 2 – Algorithm to Encrypt Plaintext
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Plaintext is split into pairs of two letters (digraphs). For example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Plaintext: “ambidextrous”'
  prefs: []
  type: TYPE_NORMAL
- en: 'After Split: “am” “bi” “de” “xt” “ro” “us”'
  prefs: []
  type: TYPE_NORMAL
- en: If the number of letters is odd, a Z is added to the last letter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Plaintext: “workmanship”'
  prefs: []
  type: TYPE_NORMAL
- en: 'After Split: “wo” “rk” “ma” “ns” “hi” “pz”'
  prefs: []
  type: TYPE_NORMAL
- en: If a pair cannot be formed from the same letter, a bogus letter can be added
    to its previous letter by breaking the letter into singles
  prefs: []
  type: TYPE_NORMAL
- en: 'Plaintext: “ditto”'
  prefs: []
  type: TYPE_NORMAL
- en: 'After Split: “di” “tx” “to”'
  prefs: []
  type: TYPE_NORMAL
- en: Here “x” is the bogus letter.
  prefs: []
  type: TYPE_NORMAL
- en: If a letter stands alone in the pairing process, an additional fictitious letter
    can be added with the lone letter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Plaintext: “recurrence”'
  prefs: []
  type: TYPE_NORMAL
- en: 'After Split: “re” ”cu” “rx” “re” ”nc” “ez”'
  prefs: []
  type: TYPE_NORMAL
- en: Here “z” is the bogus letter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rules for Encryption:'
  prefs: []
  type: TYPE_NORMAL
- en: Consider the letters below each alphabet if both letters in a digraph are in
    the same column. Accordingly, if one of the digraph letters is the bottom letter
    in the grid, take into account the top alphabet in the same column (see [Figure
    8.1](#c08-fig-0001)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/c08f001.png)'
  prefs: []
  type: TYPE_IMG
- en: '[**Figure 8.1**](#rc08-fig-0001) Cipher encryption: If both the letters in
    the digraph are in the same column.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Digraph: “xt”'
  prefs: []
  type: TYPE_NORMAL
- en: 'Encrypted Text: “fp”'
  prefs: []
  type: TYPE_NORMAL
- en: 'Encryption: x -> f and t -> p'
  prefs: []
  type: TYPE_NORMAL
- en: Consider the letters to the right of each alphabet if both letters in a digraph
    are in the same row. As a result, if one of the digraph letters is represented
    by the rightmost alphabet in the grid, take into account the leftmost alphabet
    of the row (see [Figure 8.2](#c08-fig-0002)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/c08f002.png)'
  prefs: []
  type: TYPE_IMG
- en: '[**Figure 8.2**](#rc08-fig-0002) Cipher encryption: If both the letters in
    the digraph are in the same row.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Digraph: “bi”'
  prefs: []
  type: TYPE_NORMAL
- en: 'Encrypted Text: “it”'
  prefs: []
  type: TYPE_NORMAL
- en: 'Encryption: b -> i and i -> t'
  prefs: []
  type: TYPE_NORMAL
- en: If none of the preceding rules apply, draw a quadrilateral or rectangle with
    two letters in the digraph and consider the letters on the parallel opposite corners
    of the quadrangle (see [Figure 8.3](#c08-fig-0003)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/c08f003.png)'
  prefs: []
  type: TYPE_IMG
- en: '[**Figure 8.3**](#rc08-fig-0003) Cipher encryption: If none of the rules apply.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Digraph: “ro”'
  prefs: []
  type: TYPE_NORMAL
- en: 'Encrypted Text: “dv”'
  prefs: []
  type: TYPE_NORMAL
- en: 'Encryption: r -> d and o -> v'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in totto:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Plaintext: “ambidextrous”'
  prefs: []
  type: TYPE_NORMAL
- en: 'Encrypted Text: “rhitxsfpdvoz”'
  prefs: []
  type: TYPE_NORMAL
- en: 'Encryption: a -> r; m -> h; b -> i; i -> t; d -> x; e -> s; x -> f; t -> p;
    r -> d; o -> v; u -> o; and s -> z (see [Figure 8.4](#c08-fig-0004)).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/c08f004.png)'
  prefs: []
  type: TYPE_IMG
- en: '[**Figure 8.4**](#rc08-fig-0004) Cipher encryption: Plaintext to ciphertext.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Implementation of Playfair Cipher in C**'
  prefs: []
  type: TYPE_NORMAL
- en: Output (see [Code Cell 8.1](#c08-fea-1001))
  prefs: []
  type: TYPE_NORMAL
- en: 'Key text: “Monarchy”'
  prefs: []
  type: TYPE_NORMAL
- en: 'Plaintext: “ambidextrous”'
  prefs: []
  type: TYPE_NORMAL
- en: 'Ciphertext: “rhitxsfpdvoz”'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[**Code Cell 8.1 **](#rc08-fea-1001) Playfair Cipher – Encryption using C.'
  prefs: []
  type: TYPE_NORMAL
- en: 8.2.2 Decryption Algorithm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Playfair Cipher is decrypted by going reverse through the encryption process.
    The communication can be decrypted by the recipient, using the same key and the
    same key table that were used to encrypt it.
  prefs: []
  type: TYPE_NORMAL
- en: 8.2.2.1 Step 1 – Generate Squares (5 * 5)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The key is a 5 * 5 grid of square letters, which serves to decrypt the encrypted
    code. Since the grid can only accommodate 25 characters, at the time of encryption
    one letter (J) of the alphabet was dropped from the table. Thus there were only
    25 letters in the alphabet class without any digits, punctuation marks, or nonalphabet
    characters. The cipher began with the unique alphabet of the key in the order
    of occurrence; after that, the rest of the letters appear in order. A cipher was
    thus constructed, using a single alphabetic class without repetition, and it has
    a digraphic substitution.
  prefs: []
  type: TYPE_NORMAL
- en: Playfair cipher is a type of block cipher, which replaces a particular plaintext
    character during encryption with a ciphertext character depending on the adjacent
    character in the plaintext. The easiest way to crack the Playfair cipher is to
    perform frequency analysis of those letter pairs. Knowing the approximate frequencies
    for the language used in the message, an attempt can be made to match consecutive
    ciphertext pairs to consecutive pairs of letters in the language. Albeit this
    is a colossal task.
  prefs: []
  type: TYPE_NORMAL
- en: 8.2.2.2 Step 2 – Algorithm to Decrypt the Ciphertext
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The ciphertext is divided into dyads or digraphs – pairs of two letters. This
    is because at the time of encryption, an extra letter was added to an odd pair
    (if any) with a single letter to convert it into an even number. Since decryption
    itself is the reverse process of encryption, the letters are essentially even
    in number.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Ciphertext: “rhitxsfpdvoz”'
  prefs: []
  type: TYPE_NORMAL
- en: 'After Split: “rh” “it” “xs” “fp” “dv” “oz”'
  prefs: []
  type: TYPE_NORMAL
- en: Rules for Decryption
  prefs: []
  type: TYPE_NORMAL
- en: Consider the letters above each alphabet if both letters in a digraph are in
    the same column. Consequently, if one of the digraph letters is the top-most letter
    in the matrix, take into account the letter at the bottom in the same column (see
    [Figure 8.5](#c08-fig-0005)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/c08f005.png)'
  prefs: []
  type: TYPE_IMG
- en: '[**Figure 8.5**](#rc08-fig-0005) Cipher decryption: If both the letters in
    the digraph are in the same column.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Digraph: “fp”'
  prefs: []
  type: TYPE_NORMAL
- en: 'Decrypted Text: “xt”'
  prefs: []
  type: TYPE_NORMAL
- en: 'Decryption: f -> x and p -> t'
  prefs: []
  type: TYPE_NORMAL
- en: Consider the letters to the left of each alphabet if both letters in a digraph
    are in the same row. In this case, take into consideration the rightmost alphabet
    in the same row if one of the digraph letters is the leftmost letter in the matrix
    (see [Figure 8.6](#c08-fig-0006)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/c08f006.png)'
  prefs: []
  type: TYPE_IMG
- en: '[**Figure 8.6**](#rc08-fig-0006) Cipher decryption: If both the letters in
    the digraph are in the same row.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Digraph: “it”'
  prefs: []
  type: TYPE_NORMAL
- en: 'Decrypted Text: “bi”'
  prefs: []
  type: TYPE_NORMAL
- en: 'Decryption: i -> b and t -> i'
  prefs: []
  type: TYPE_NORMAL
- en: If none of the above rules apply, draw a quadrangle with two letters in the
    digraph and consider the letters on the parallel opposite corners of the quadrangle
    (see [Figure 8.7](#c08-fig-0007)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/c08f007.png)'
  prefs: []
  type: TYPE_IMG
- en: '[**Figure 8.7**](#rc08-fig-0007) Cipher decryption: If none of the rules apply.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Diagraph: “dv”'
  prefs: []
  type: TYPE_NORMAL
- en: 'Decrypted Text: “ro”'
  prefs: []
  type: TYPE_NORMAL
- en: 'Decryption: d -> r and v -> o'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Ciphertext: “rhitxsfpdvoz”'
  prefs: []
  type: TYPE_NORMAL
- en: 'Decrypted Text: “ambidextrous”'
  prefs: []
  type: TYPE_NORMAL
- en: 'Decryption: r -> a; h -> m; i -> b; t -> i; x -> d; s -> e; f -> x; p -> t;
    d -> r; v -> o; o -> u; and z -> s (see [Figure 8.8](#c08-fig-0008))'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/c08f008.png)'
  prefs: []
  type: TYPE_IMG
- en: '[**Figure 8.8**](#rc08-fig-0008) Cipher decryption: Ciphertext into plaintext.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Implementation of Playfair Cipher Decryption in C**'
  prefs: []
  type: TYPE_NORMAL
- en: Output (See [Code Cell 8.2](#c08-fea-1002))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[**Code Cell 8.2 **](#rc08-fea-1002) Playfair Cipher – Decryption using C.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Key text: “Monarchy”'
  prefs: []
  type: TYPE_NORMAL
- en: 'Plaintext: “rhitxsfpdvoz” Deciphered text: “ambidextrous”'
  prefs: []
  type: TYPE_NORMAL
- en: 8.2.3 Advantages and Disadvantages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 8.2.3.1 Advantages
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Playfair Ciphers seem to be more secure since the intricate mathematics that
    is used to create them renders it extremely difficult for the recipient to decrypt
    the information.
  prefs: []
  type: TYPE_NORMAL
- en: The frequency analysis that works well for simple substitution ciphers does
    not work here, so it’s hard to crack the encryption. However, if one tries to
    do so by frequency analysis, it will require a lot of ciphertext for 25 * 25 =
    625 possible digraphs in a Playfair iteration, as opposed to 25 monographs in
    a Simple Substitution Cipher.
  prefs: []
  type: TYPE_NORMAL
- en: Playfair Cipher is a manual process that does not need any digital device, such
    as a calculator or decoder, for encryption and decryption. While implementing
    encryption–decryption, using a Playfair Cipher in C, data can travel safely between
    its source and terminus without making any compromise.
  prefs: []
  type: TYPE_NORMAL
- en: Further, Brute-force attack does not affect the Playfair cipher.
  prefs: []
  type: TYPE_NORMAL
- en: 8.2.3.2 Disadvantages
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Playfair Cipher operates with the same key for encryption and decryption,
    making it possible to crack symmetric cryptography, and it cannot be used to transmit
    massive amounts of data.
  prefs: []
  type: TYPE_NORMAL
- en: In a Playfair Cipher, since the replacement itself is reverse, one can easily
    decode an information by employing frequency analysis. If a hacker knows the language
    of plaintext, he will understand that the ciphertext (RG) and its inverse (GR)
    have the corresponding plaintext in the digraph, such as HA and AH.
  prefs: []
  type: TYPE_NORMAL
- en: Further, it supports only 25 characters, that too either all upper case or lower
    case.
  prefs: []
  type: TYPE_NORMAL
- en: It does not support any numeric or special characters, such as symbols, equations,
    spaces, or punctuation marks.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, it does not allow languages other than English. Doesn’t even support
    encryption of media files.
  prefs: []
  type: TYPE_NORMAL
- en: 8.3 Hill Cipher
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Hill Cipher is a polygraphic substitution cipher constructed on linear algebra.
    Invented by Lester Sanders Hill in 1929, it works impeccably with digraphs (two-letter
    blocks), trigraphs (three-letter blocks), or other multiple-sized blocks to produce
    a consistent cipher. It was the first polygraphic cipher in which it was possible
    to work with more than three symbols at a time.
  prefs: []
  type: TYPE_NORMAL
- en: Each letter in Hill Cipher is represented by 26 modules. Often simple schemes
    such as A = 0, B = 1 ...
  prefs: []
  type: TYPE_NORMAL
- en: Z = 25 are used, but this is not an essential feature of the cipher (see [Figure
    8.9](#c08-fig-0009)). The matrix used for encryption is the cipher key and is
    chosen at random from a set of invertible *n* * *n* matrices (module 26). Here,
    *n* could be 2, 3, 4, 5 or 6\. To decrypt the message, each block is multiplied
    by the inverse of the matrix encoding.
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/c08f009.png)'
  prefs: []
  type: TYPE_IMG
- en: '[**Figure 8.9**](#rc08-fig-0009) Letters (left) and corresponding numbers (right)
    – Hill cipher encryption uses the above scheme of numbers and letters that can
    be modified as per condition.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Examples:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Input: Plaintext: “ACT”'
  prefs: []
  type: TYPE_NORMAL
- en: 'Key: “GYBNQKURP”'
  prefs: []
  type: TYPE_NORMAL
- en: 'Output: Ciphertext: “POH”'
  prefs: []
  type: TYPE_NORMAL
- en: 'Input: Plaintext: “GFG”'
  prefs: []
  type: TYPE_NORMAL
- en: 'Key: “HILLMAGIC”'
  prefs: []
  type: TYPE_NORMAL
- en: 'Output: Ciphertext: “SWK”'
  prefs: []
  type: TYPE_NORMAL
- en: 8.3.1 Substitution Scheme
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Typically, Hill Cipher encryption uses the following structure of alphanumeric
    (letters and numerals), but this can be modified as per requirement.
  prefs: []
  type: TYPE_NORMAL
- en: 8.3.1.1 Encryption
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To encrypt a given message, in parallel with modulus 26, each block consists
    of *n* letters and these are multiplied in an *n* * *n* matrix. Next, for decryption,
    each block needs to be multiplied by the inverse matrix (see [Figure 8.10](#c08-fig-0010)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/c08f010.png)'
  prefs: []
  type: TYPE_IMG
- en: '[**Figure 8.10**](#rc08-fig-0010) Hill Cipher encryption – ACT encrypts to
    POH.'
  prefs: []
  type: TYPE_NORMAL
- en: It corresponds to ciphertext of “POH”
  prefs: []
  type: TYPE_NORMAL
- en: 8.3.1.2 Decryption
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: It gives us back “ACT”, assuming that all the letters were in uppercase (see
    [Figure 8.11](#c08-fig-0011)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/c08f011.png)'
  prefs: []
  type: TYPE_IMG
- en: '[**Figure 8.11**](#rc08-fig-0011) Hill Cipher decryption – POH decrypts back
    to ACT.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Implementation of the above idea for *n* = 3**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Ciphertext: “POH”'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '**Code Cell 8.3** Encryption and decryption in Hill Cipher using C++.'
  prefs: []
  type: TYPE_NORMAL
- en: Hill cipher is an example of a classical symmetric encryption algorithm that
    has succumbed to know-plaintext attacks. In this type of attack, the cryptanalyst
    had the plaintext of certain messages and the corresponding cipher text of those
    messages. They try to work-out the algorithm to decrypt any new message encrypted
    with the same key. Thus its vulnerability to cryptanalysis has made it unfeasible
    in practice, however it still plays an important pedagogical role in cryptology
    and linear algebra.
  prefs: []
  type: TYPE_NORMAL
- en: 8.4 RSA Algorithm in Cryptography
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The RSA Algorithm is an asymmetric cryptography algorithm and hence, works on
    two different keys – the public key and the private key. It was invented in 1978
    by Ron Rivest, Adi Shamir, and Leonard Adelman. It is called the Rivest Shamir
    Adelman (RSA) Algorithm after their names.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose a client (user) sends his public key to a server (facilitator) to receive
    some data. Using the client’s public key, the server encrypts the data before
    sending it. The client collects this data but needs to decrypt it first. Since
    it is asymmetric and only the client (user) has its private key, no third party,
    excluding the user, can decipher the information, even if he has the user’s public
    key.
  prefs: []
  type: TYPE_NORMAL
- en: The idea of RSA is based on the fact that it is difficult to factorize a large
    integer. Though it is easy to get a product of two numbers, it does not seem possible
    to determine the original prime numbers from that product. Let’s understand it
    this way. The public key comprises two figures (numbers), one of which is a multiple
    of two larger prime numbers. The same two prime numbers are also used to generate
    the private keys. This implies that if one succeeds in factorizing a large number,
    the secret or private key can be hacked.
  prefs: []
  type: TYPE_NORMAL
- en: Hence, the defense mechanism behind the RSA Algorithm is that the hacker has
    to first determine the values *p* and *q* by a factorization of N that happens
    in exponential time. Thus, if N is a 100-digit integer, it would require more
    than seventy years to factorize. This complexity prevents an attacker from finding
    the decryption key I for the reason that *d* rests on *p*, *q* and the encryption
    key *e*. Therefore, even if the hacker obtains N and *e*, he will not be able
    to calculate *d* from N and *e*.
  prefs: []
  type: TYPE_NORMAL
- en: Since encryption strength is completely dependent on the key size, doubling
    or tripling the key size can make the encryption stronger. Typically, an RSA key
    can be 1024 or 2048 bits long, and currently, breaking such a large amount of
    encryption appears to be an impossible task.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using RSA Algorithms, the public and private keys can be generated as follows
    (Techtarget, 2022):'
  prefs: []
  type: TYPE_NORMAL
- en: Pick the two large primes *p* and *q*.
  prefs: []
  type: TYPE_NORMAL
- en: Find *n* = *p* x *q* by multiplying these values, where *n* is referred to as
    the modulus for encryption and decryption.
  prefs: []
  type: TYPE_NORMAL
- en: Choose a number *e* less than *n*, such that *n* is relatively prime to (*p*
    – 1) x (*q* – 1). This indicates that the only factor in common between *e* and
    (*p* – 1) x (*q* – 1) is 1.
  prefs: []
  type: TYPE_NORMAL
- en: If *n* = *p* x *q*, then the public key is <*e*, *n*>.
  prefs: []
  type: TYPE_NORMAL
- en: Public key <*e*, *n*> is used to encrypt a plaintext message *m*. The following
    formula is used to obtain ciphertext C from the plaintext.
  prefs: []
  type: TYPE_NORMAL
- en: '*m*^e mod *n* = C'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, *m* must be smaller than *n*. A larger message (>*n*) is treated
    as a sequence of communications, each of which is encrypted separately.
  prefs: []
  type: TYPE_NORMAL
- en: 'To find out the private key, the formula, given here, is used to calculate
    the *d*, such that:'
  prefs: []
  type: TYPE_NORMAL
- en: '*d[e]* mod {(*p* – 1) x (*q* – 1)} = 1'
  prefs: []
  type: TYPE_NORMAL
- en: Or
  prefs: []
  type: TYPE_NORMAL
- en: '*d[e]* mod φ (*n*) = 1 where φ (*n*) = (*p* – 1) x (*q* – 1)'
  prefs: []
  type: TYPE_NORMAL
- en: The private key is <*d*, *n*>.
  prefs: []
  type: TYPE_NORMAL
- en: A ciphertext message C is decoded using the private key <*d*, *n*>. To retrieve
    plaintext *m* from the ciphertext C, the formula, given hereafter, is used to
    get plaintext *m*.
  prefs: []
  type: TYPE_NORMAL
- en: '*m* = C*^d* mod *n*'
  prefs: []
  type: TYPE_NORMAL
- en: 8.4.1 Working Mechanism
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 8.4.1.1 Generating the Public Key
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Pick two prime numbers. Assume P and Q to be 53 and 59 respectively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now first component of the public key: *n* = P*Q = 3127.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Here, a minor exponent, say *e*, is also required
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, *e* ought to be:'
  prefs: []
  type: TYPE_NORMAL
- en: A whole number.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not be an element or factor of *n*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 < *e* < Φ(*n*) [Φ(*n*) is discussed below],
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, consider it to be equal to 3.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Our public key is made of *n* and *e*
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 8.4.1.2 Generating a Private Key
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Compute Φ(*n*) as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So as Φ(*n*) = (P – 1) x (Q – 1)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Thus, Φ(*n*) = 3016
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then, determine private key, *d*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For some whole number (integer) *k*, *d* = (*k**Φ(*n*) + 1) / *e*
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For *k* = 2, the value of *d* is 2011.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Thus, we now have: Public key (*n* = 3127 and *e* = 3) and private key (*d*
    = 2011)'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, encrypt “HI”:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Convert letters to numbers:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here, H = 8 and I = 9
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Accordingly, Encrypted Data *c* = 89*^e* mod *n* = 89³ mod (3127)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In consequence, the Encrypted Data turns out to be 1394
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Further, decrypt 1394:'
  prefs: []
  type: TYPE_NORMAL
- en: Decrypted Data = *c^d* mod *n* = (1394)^(2011) mod (3127)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, the Encrypted Data comes out to be 89 that represents “HI”
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Where, 8 = H and I = 9
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**C Implementation of RSA Algorithm for Small Values**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Data in message: 12.000000'
  prefs: []
  type: TYPE_NORMAL
- en: 'Data encrypted: 3,000,000'
  prefs: []
  type: TYPE_NORMAL
- en: 'Original Message Sent: 12.000000'
  prefs: []
  type: TYPE_NORMAL
- en: It seems impossible to factorize RSA-1024 and RSA-2048 for many years to come.
    Although the ransomware virus also uses RSA-2048 to encode files on infected machines,
    it is neither possible to decrypt these files without a decoding key, nor to factorize
    such a large key.
  prefs: []
  type: TYPE_NORMAL
- en: Applications of RSA can be viewed in web browsers, email, VPN, chat and a range
    of other communication channels. RSA is often used to create a secure connection
    between a VPN client and a VPN server. RSA algorithms can also be used for under
    protocols such as OpenVPN, TLS handshake to exchange keys and establish a secure
    channel.
  prefs: []
  type: TYPE_NORMAL
- en: RSA is an intrinsically fragile cryptosystem containing countless foot-guns
    that the average software engineer cannot be expected to avoid. Testing for weak
    parameters can be difficult, if not impossible, and their poor performance coerce
    developers to take risky shortcuts.
  prefs: []
  type: TYPE_NORMAL
- en: 8.5 Multiple Precision Arithmetic Library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| **Key Generation – Summary** |  |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | Select *p*, *q* *p*, *q* both prime |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | calculate *n* = *p***q* |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | calculate ø(*n*) = (*p* – 1)*(*q* – 1) |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | select integer *e* | *gcd* (ø(*n*),*e*) = 1;1 < *e* < ø(*n*) |'
  prefs: []
  type: TYPE_TB
- en: '|  | calculate *d* |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | Public Key | KU = *e*,*n* |'
  prefs: []
  type: TYPE_TB
- en: '|  | Private Key | KR = *d*,*n* |'
  prefs: []
  type: TYPE_TB
- en: '| **Encryption** |  |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | Plaintext | M < *n* |'
  prefs: []
  type: TYPE_TB
- en: '|  | Ciphertext | C = M*^e*(mod *n*) |'
  prefs: []
  type: TYPE_TB
- en: '| **Decryption** |  |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | Ciphertext | C |'
  prefs: []
  type: TYPE_TB
- en: '|  | Plaintext | M = C*^d*(mod *n*) |'
  prefs: []
  type: TYPE_TB
- en: The three distinct steps of the RSA method are shown in the equations above.
    N will be a 2048-bit number if a prime number generator produces the 1024-bit
    primes *p* and *q*. The software that processes 2048-bit will take a lot of time
    because all modulo procedures during encryption and decryption are implemented
    with regard to *N*, where *N* is a 2048-bit number.
  prefs: []
  type: TYPE_NORMAL
- en: Given the needs of the RSA Algorithm, a GNU Multiple Precision Arithmetic Library
    (GMP) can be implemented to support the creation of large-sized keys. This would
    expedite encryption and decryption comprising a large-size modulus. This library
    will facilitate the complete RSA Algorithm to run on a simple 64-bit operating
    system with no dependence on high-configuration hardware devices.
  prefs: []
  type: TYPE_NORMAL
- en: 8.5.1 GNU Multiple Precision Arithmetic Library
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: GMP is an open-source library used for arithmetic calculations. This includes
    extraordinary large or highly precise numbers, the majority of which are employed
    in cryptographic techniques. This makes it possible to execute arithmetic operations
    on signed integers, rational numbers, and decimal numbers, irrespective of the
    machine’s configuration or any practical limitation (GNU Library, 2022).
  prefs: []
  type: TYPE_NORMAL
- en: The native interface of the GNU library is designed to work with the C programming
    language. However, wrappers are available for C++, C#, Ada, Julia, OCaml, PHP,
    Python, Perl, R, Ruby, and the Wolfram language, among others.
  prefs: []
  type: TYPE_NORMAL
- en: 8.5.2 RSA Algorithm Implementation Using GMP Library
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A C program that shows the functioning of the RSA Algorithm with smaller prime
    numbers has been given in [code cell 8.4](#c08-fea-1004). To comprehend the procedure
    of the actual RSA Algorithm, C code using the GMP library, with large prime numbers,
    needs to be worked out. The program performs RSA-1024 by creating random prime
    integers *p* and *q* of 512 bits, followed by encoding and decoding. In such a
    backdrop, the value 1024 is assigned to the variable modulus size. This value
    can be modified to 2048 in order to produce an RSA key of 2048 bits.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[**Code Cell 8.4 **](#rc08-fea-1004) RSA Asymmetric Cryptography using C.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Implementation of RSA Algorithm**'
  prefs: []
  type: TYPE_NORMAL
- en: RSA Algorithms can be implemented in secure network transmissions and transactions
    for a variety of e-commerce applications. In addition, it can also be implemented
    to share credit card details to online traders, to enable voice messages over
    low bit rate channels, secure key swapping for high-speed IPSec, etc. (see [Code
    Cell 8.5](#c08-fea-1005)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[**Code Cell 8.5 **](#rc08-fea-1005) RSA Algorithms using C.'
  prefs: []
  type: TYPE_NORMAL
- en: 8.5.3 Weak RSA Decryption with Chinese Remainder Theorem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: RSA decryption takes longer than encryption because at the time of decryption
    of the private key, the parameter *d* is inevitably larger. Moreover, the parameters
    *p* and *q* are two exceptionally large prime numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '[RSA is quite slow due to the large number of computations. The message is
    usually much longer than the secret key to encrypt. One way is to use RSA to encrypt
    only one secret key, which is used in a symmetric encryption algorithm. This can
    yield the benefits of both the security of asymmetric encryption and the speed
    of symmetric encryption algorithms].'
  prefs: []
  type: TYPE_NORMAL
- en: Determine *m* such that *c* = *m^e* mod (*p* x *q*), given the whole numbers
    *c*, *e*, *p*, and *q*. (RSA decryption for frail integers).
  prefs: []
  type: TYPE_NORMAL
- en: 'Fundamentals: There is a public key represented by two factors or strictures
    *n* (modulus) and *e* (exponential). The modulus is the multiplication of two
    extraordinary large prime numbers (*p* and *q* as given following). The user must
    factorize *n* into two prime numbers (RSA being safe) in order to decrypt this
    message, and then determine the modular inverse of *e*, which is a time-consuming
    job.'
  prefs: []
  type: TYPE_NORMAL
- en: A text version is first transcribed into the corresponding decimal value – a
    parameter m to be found below. Then the message is encrypted by calculating *c*
    = *m*^e mod (*p* x *q*), where *c* stands for the encrypted text.
  prefs: []
  type: TYPE_NORMAL
- en: Here, an attempt is made to generate a private key by finding the values of
    *p*, *q*, and *d*, taking advantage of the exponent value and weak modulus to
    crack the encryption. In the present example, small values of *p* and *q* have
    been taken, nevertheless in actual applications, large values of *p* and *q* must
    be taken to protect the RSA system.
  prefs: []
  type: TYPE_NORMAL
- en: So, let’s try to find *d* in the cases that follow, given *p* and *q*.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: 'Input:'
  prefs: []
  type: TYPE_NORMAL
- en: '*c* = 1614'
  prefs: []
  type: TYPE_NORMAL
- en: '*e* = 65537'
  prefs: []
  type: TYPE_NORMAL
- en: '*p* = 53'
  prefs: []
  type: TYPE_NORMAL
- en: '*q* = 31'
  prefs: []
  type: TYPE_NORMAL
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '1372'
  prefs: []
  type: TYPE_NORMAL
- en: 'Explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: Calculate *c* = *m^e* mod (*p* x *q*).
  prefs: []
  type: TYPE_NORMAL
- en: Insert *m* = 1372.
  prefs: []
  type: TYPE_NORMAL
- en: On calculating, we get *c* = 1614.
  prefs: []
  type: TYPE_NORMAL
- en: 'Input:'
  prefs: []
  type: TYPE_NORMAL
- en: '*c* = 3893595'
  prefs: []
  type: TYPE_NORMAL
- en: '*e* = 101'
  prefs: []
  type: TYPE_NORMAL
- en: '*p* = 3191'
  prefs: []
  type: TYPE_NORMAL
- en: '*q* = 3203'
  prefs: []
  type: TYPE_NORMAL
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '6574839'
  prefs: []
  type: TYPE_NORMAL
- en: 'Explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: As stated above, if we compute *m^e* mod (*p* x *q*)
  prefs: []
  type: TYPE_NORMAL
- en: with *m* = 6574839, we get *c* = 3893595
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, the value of *m* can be obtained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: (1) Find out the modular inverse of *e*.
  prefs: []
  type: TYPE_NORMAL
- en: Use the following equation, *d* = *e*^(-1) mod (λ(*n*)),
  prefs: []
  type: TYPE_NORMAL
- en: where *n* is the number of variables and λ is the Carmichael Totient function.
  prefs: []
  type: TYPE_NORMAL
- en: (2) Now, determine *m* = *c^d* mod (*p* x *q*)
  prefs: []
  type: TYPE_NORMAL
- en: (3) The Chinese Remainder Theorem, as specified in the implementation below,
    can be used to speed up the calculation.
  prefs: []
  type: TYPE_NORMAL
- en: '**Python Implementation of Chinese Remainder Theorem**'
  prefs: []
  type: TYPE_NORMAL
- en: Output
  prefs: []
  type: TYPE_NORMAL
- en: '41892906'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '**Code Cell 8.6** Chinese Remainder Theorem.'
  prefs: []
  type: TYPE_NORMAL
- en: 8.6 SHA-512 Hash in Java
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Secure Hash Algorithm 512 (SHA-512) is a hashing algorithm, each output of which
    produces an SHA-512 length of 512 bits (64 bytes), i.e. 128 hexadecimal characters.
    It can convert any size text into a fixed-size string. This algorithm is commonly
    used to get email address hash, password hash, and digital record verification.
  prefs: []
  type: TYPE_NORMAL
- en: 'Six hash functions fall into the Secure Hash Algorithm – two families of the
    cryptographic hash functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Hash Algorithm | Hash Value |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| SHA-224 | 224-bit hash value |'
  prefs: []
  type: TYPE_TB
- en: '| SHA-256 | 256-bit hash value |'
  prefs: []
  type: TYPE_TB
- en: '| SHA-384 | 384-bit hash value |'
  prefs: []
  type: TYPE_TB
- en: '| SHA-512 | 512-bit hash value |'
  prefs: []
  type: TYPE_TB
- en: '| SHA-512/224 | 512-bit hash value |'
  prefs: []
  type: TYPE_TB
- en: '| SHA-512/256 | 512-bit hash value |'
  prefs: []
  type: TYPE_TB
- en: The most widely used and accepted hash algorithms of these are SHA-256 and SHA-512,
    which use 32-bit and 64-bit words, respectively, for computation. SHA-224 and
    SHA-384 are the short versions of SHA-256 and SHA-512 in that order. These are
    calculated with different starting values.
  prefs: []
  type: TYPE_NORMAL
- en: The MessageDigest Class, found in the package java.security, is used to compute
    cryptographic hash values in Java.
  prefs: []
  type: TYPE_NORMAL
- en: 'To determine a text’s hash value, the MessageDigest class offers these cryptographic
    hash functions:'
  prefs: []
  type: TYPE_NORMAL
- en: MD2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MD5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SHA-1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SHA-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SHA-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SHA-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SHA-512
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A static method named getInstance() initializes these algorithms. After choosing
    an algorithm, the message digest value is determined, and the output is reverted
    as a byte array. The BigInteger class is applied to change the resulting byte
    array into its signum representation. This representation is subsequently transformed
    to hexadecimal format to get the desired MessageDigest.
  prefs: []
  type: TYPE_NORMAL
- en: 'Input: hello'
  prefs: []
  type: TYPE_NORMAL
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: 309ecc489c12d6eb4cc40f50c902f2b4d0ed77ee511a7c7a9bcd3ca86d4cd86f989
  prefs: []
  type: TYPE_NORMAL
- en: dd35bc5ff499670da34255b45b0cfd830e81f605dcf7dc5542e93ae9cd76f
  prefs: []
  type: TYPE_NORMAL
- en: 'Input: helloworld'
  prefs: []
  type: TYPE_NORMAL
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: acc10c4e0b38617f59e88e49215e2e894afaee5ec948c2af6f44039f03c9fe47a9210
  prefs: []
  type: TYPE_NORMAL
- en: e01d5cd926c142bdc9179c2ad30f927a8faf69421ff60a5eaddcf8cb9c
  prefs: []
  type: TYPE_NORMAL
- en: '**Implementation of SHA-512 hash function**'
  prefs: []
  type: TYPE_NORMAL
- en: Output (see [Code Cell 8.7](#c08-fea-1007))
  prefs: []
  type: TYPE_NORMAL
- en: 'HashCode Generated by SHA-512 for:'
  prefs: []
  type: TYPE_NORMAL
- en: 'hello:'
  prefs: []
  type: TYPE_NORMAL
- en: 309ecc489c12d6eb4cc40f50c902f2b4d0ed77ee511a7c7a9bcd3ca86d4cd86f989
  prefs: []
  type: TYPE_NORMAL
- en: dd35bc5ff499670da34255b45b0cfd830e81f605dcf7dc5542e93ae9cd76f
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[**Code Cell 8.7 **](#rc08-fea-1007) Calculating SHA-512 hash value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'helloworld:'
  prefs: []
  type: TYPE_NORMAL
- en: 309ecc489c12d6eb4cc40f50c902f2b4d0ed77ee511a7c7a9bcd3ca86d4cd86f989
  prefs: []
  type: TYPE_NORMAL
- en: dd35bc5ff499670da34255b45b0cfd830e81f605dcf7dc5542e93ae9cd76f
  prefs: []
  type: TYPE_NORMAL
- en: SHA-1 forms a part of several widely used security applications and protocols,
    including TLS and SSL, PGP, SSH, S/MIME, and IPsec. These applications can use
    MD5 as well, as both MD5 and SHA-1 have derived from MD4\. SHA-1 was designed
    by the United States National Security Agency, and is a U.S. Federal Information
    Processing Standard.
  prefs: []
  type: TYPE_NORMAL
- en: 8.7 Cybersecurity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cybersecurity is a way of defending systems and networks against online attacks
    that try to access, modify, destroy, or extort money in exchange for sensitive
    digital information. Cyberattacks can be carried out through several malware like
    Trojans, Rootkits, Virus, etc. and are known as Distributed Denial-of-Service
    (DDoS) attacks, Man-in-the-Middle (MITM) attacks, phishing, Ransomware attacks,
    and Structured Language Query (SQL) injections (IBM, 2022). With the increasing
    dependence on technology and Big Data, there is an urgent need to address the
    security concerns with respect to protection of data and transactions.
  prefs: []
  type: TYPE_NORMAL
- en: 8.7.1 Common Cyberattacks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 8.7.1.1 Denial-of-Service Attacks
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A Denial-of-Service Attack is one in which cybercriminals flood a computer system’s
    network and servers with traffic to prevent legitimate requests from being served.
    This renders the system unusable, preventing an organization from performing important
    tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 8.7.1.2 Malware
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Malware, one of the most common cyberthreats, is malicious software designed
    to gain unauthorized access or harm a computer. This malware is created by a hacker
    or cybercriminal, for the purpose of making money or politics-driven cyberattacks,
    to disrupt or damage the computer of a legitimate user. It is often spread through
    an unsolicited email attachment or downloadable software that looks genuine and
    legitimate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Malware can be of many types, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '***Virus***'
  prefs: []
  type: TYPE_NORMAL
- en: It is a self-replicating program that fixes itself to an uninfected file and
    infects the entire computer system with files containing malicious code.
  prefs: []
  type: TYPE_NORMAL
- en: '***Trojan***'
  prefs: []
  type: TYPE_NORMAL
- en: This is a sort of malware, disguised as genuine software. Cyberattackers tempt
    users to upload Trojans to their computers and collect data by harming their systems.
  prefs: []
  type: TYPE_NORMAL
- en: '***Spyware***'
  prefs: []
  type: TYPE_NORMAL
- en: It is software that installs itself on a user’s computer and starts secretly
    monitoring their online behavior without their knowledge or permission. It relays
    the information so received, about an individual or organization, to other parties.
  prefs: []
  type: TYPE_NORMAL
- en: '***Ransomware***'
  prefs: []
  type: TYPE_NORMAL
- en: It’s a type of malicious malware that locks a user’s files and data, threatens
    to erase information, and blocks access to files or computer systems until a ransom
    is paid. Despite the ransom, the user is not assured that the files will be retrieved
    or the system will be restored.
  prefs: []
  type: TYPE_NORMAL
- en: '***Adware***'
  prefs: []
  type: TYPE_NORMAL
- en: It is an advertising software capable of spreading malware through billboards.
  prefs: []
  type: TYPE_NORMAL
- en: '***Botnet***'
  prefs: []
  type: TYPE_NORMAL
- en: This malware is a network of infected computers, used by cybercriminals to perform
    tasks online without the user’s consent.
  prefs: []
  type: TYPE_NORMAL
- en: 8.7.1.3 Man-in-the-Middle Attack
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Through a Man-in-the-Middle Attack, a cybercriminal intercepts communication
    between two individuals to steal data (see [Figure 8.12](#c08-fig-0012)). For
    example, on an unsecured WiFi network, an attacker can intercept the data being
    passed through a user’s device and the network.
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/c08f012.png)'
  prefs: []
  type: TYPE_IMG
- en: '[**Figure 8.12**](#rc08-fig-0012) Cyber threats (Man-in-the-Middle).'
  prefs: []
  type: TYPE_NORMAL
- en: 8.7.1.4 Phishing
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Phishing is the practice of sending fraudulent emails that closely resemble
    those sent from legitimate companies or trusted sources. This is the most common
    type of cyberattack whose basic objective is to steal sensitive data, such as
    credit card numbers and login passwords.
  prefs: []
  type: TYPE_NORMAL
- en: 8.7.1.5 Structured Language Query Injection
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Structured Language Query (SQL) Injection is a type of cyberattack used to steal
    data from data repositories. Cybercriminals, taking advantage of vulnerabilities
    in data-driven applications, insert malicious code into the database through malicious
    SQL statements that give them access to sensitive information contained in the
    database.
  prefs: []
  type: TYPE_NORMAL
- en: Social engineering is a tactic used by adversaries to disclose sensitive information
    by soliciting monetary payment to you or by gaining access to your confidential
    data. To make this happen, they insist the user click on links, download malware,
    or rely on a malicious source.
  prefs: []
  type: TYPE_NORMAL
- en: 8.7.1.6 Latest Cyberthreats
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '***Dridex Malware***'
  prefs: []
  type: TYPE_NORMAL
- en: It is a financial Trojan malware with wide capabilities. It infects computers
    through phishing emails or prevailing malware. It specializes in stealing personal
    data, login information, banking details, etc., which are then used to conduct
    fraudulent transactions.
  prefs: []
  type: TYPE_NORMAL
- en: To prevent this, it is important that devices are patched, antivirus is turned
    on and up to date, and files are backed up.
  prefs: []
  type: TYPE_NORMAL
- en: '***Emotet malware***'
  prefs: []
  type: TYPE_NORMAL
- en: Emotet is an advanced Trojan that thrives on crude passwords. It is capable
    of stealing data and loading other malware as well. The only way to avoid this
    malware, is to create secure passwords.
  prefs: []
  type: TYPE_NORMAL
- en: 8.7.2 Key Cybersecurity Features
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Checksums used in cryptography
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Codes for data backup and rectification
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assess to risks and threats
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mitigate system vulnerabilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Knowledge of malicious software
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access management and control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encryption
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up firewalls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementation of intrusion detection and prevention systems (IDS and IPS)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The cyberattack landscape has grown exponentially in the last few years (IBM,
    2022). Just as data breaches have seen an incredible increase and caused significant
    financial losses, blockchain has emerged as a promising mitigation technology
    for cybersecurity.
  prefs: []
  type: TYPE_NORMAL
- en: 8.7.3 Blockchain for Cybersecurity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Data is undoubtedly an imperative tool for the growth of any business. Enterprises
    collect sensitive data from a variety of sources and store those data smartly
    and securely. A majority of organizations still store their data in centralized
    storage that acts like a honeypot for cybercriminals. Organizations can shield
    their digital information and assets by implementing blockchain-based decentralized
    storage solutions. Decentralized storage platforms typically distribute users’
    files across multiple nodes on their network.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Internet of Things: IoT and other connected devices are facing security vulnerabilities
    and challenges over time. With the increasing use of AI, hackers find an easy
    access to the overall system. The use of blockchain-enabled, device-to-device
    encryption can be an effective solution for maintaining cybersecurity in IoT systems.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Distributed-Denial-of-Service: DDoS is one of the most popular cyberattacks
    today, which can disrupt normal traffic on a target server or network by creating
    a flood of internet data, thus affecting the infrastructure around it. Many new
    forms of DDoS attacks are emerging rapidly, including hide-and-seek malware. It
    is often seen that connected devices like routers, smartphones, vacuum robots,
    and webcams are compromised to launch attacks. It remains present even after system
    reboot. Blockchain, due to its immutability and cryptographic properties, can
    effectively overcome these anomalies.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Better Security for DNS: The Domain Name System (DNS) is just like a public
    directory that associates domain names with their IP addresses. Hackers exploit
    the connection between the IP address and the site to crash the domain, resulting
    in unnecessary losses for merchants and loyal customers. By decentralizing DNS
    entries, blockchain can provide a preventive solution to foil such attacks. Its
    decentralized network allows user domain information to be irreversibly stored
    on a distributed ledger, and connections can be operated by immutable smart contracts.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Multi-signature authentication: Tampering with usernames and passwords is a
    major cyberthreat. By confirming that they have access to numerous devices, blockchain
    technology enables users to employ a multi-signature authentication mechanism
    that does not require usernames or passwords.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Software Integrity: Blockchain can be used to protect devices from infection
    with malicious software by verifying installers. The hash of the software can
    be recorded on the blockchain, and the same may be compared with that of the installer
    to verify the integrity of the download (Cyber Management Alliance, 2020).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 8.7.4 Pros and Cons of Blockchain in Cybersecurity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 8.7.4.1 Pros
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'User Privacy: Full encryption of blockchain data by public and private keys
    ensures that data cannot be accessed by unauthorized parties as it flows through
    untrusted networks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Data transparency and traceability: In blockchain, with each subsequent iteration,
    the preceding state of the system is preserved, and therefore a complete history
    of transactions is available. Transaction data is digitally endorsed by the participants
    of the blockchain network, thereby maintaining transparency.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Data integrity: The inherent characteristics of immutability and traceability
    help blockchains to keep data intact. In the event of a cybercontrol attack, smart
    contracts can be used to check and enforce rules among all participants in order
    to avert and control account sharing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'No single point of failure: Blockchain systems are distributed, and a single
    point of failure cannot bring down the whole network. It nullifies IP-based DDoS
    attacks. The data remains accessible all the times through different nodes. In
    this way, the platform and system are made flexible through the use of several
    nodes and distributed operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Secure data transfer: Public key infrastructure (PKI) in blockchain preserves
    authentication at the time of data transfers. Though storing private key backups
    on secondary storage may pose a high risk, this can be avoided if cryptographic
    algorithms based on key management procedures and integer factorization problems,
    such as the Internet Engineering Task Force (IETF) or Remote Function Call (RFC),
    are implemented.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 8.7.4.2 Cons
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In order to encrypt a data, blockchain heavily relies on private keys; however
    if they are lost, the user’s access to encrypted data can be lost forever. Because
    once the private key is lost, it cannot be recovered.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Adaptability and scalability challenges: Governments and organizations may
    find it challenging to integrate blockchain technology because it will require
    a total replacement of all currently used systems. This is because blockchain
    networks have predetermined block volume and limitations to execute transactions
    per second. Increasing its scalability may be somewhat puzzling.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'High operating cost: Blockchain applications are more expensive than their
    nonblockchain counterparts due to the high computing and storage requirements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Lack of control: Blockchain perceptions are yet to be governed and regulated
    globally.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Blockchain literacy: Despite the countless applications of blockchain technology,
    there is a sheer paucity of such blockchain developers in the current scenario,
    who have in-depth knowledge of various programming languages and tools'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 8.7.5 Real-world Examples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Some prominent examples of using blockchain for cybersecurity:'
  prefs: []
  type: TYPE_NORMAL
- en: 8.7.5.1 Australian Government
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Canberra, Australia: The Australian government is planning to construct a cybersecurity
    network on a distributed ledger platform. The government has made substantial
    efforts to build a blockchain ecosystem and has teamed up with IBM to protect
    the storage of federal documents.'
  prefs: []
  type: TYPE_NORMAL
- en: 8.7.5.2Barclays
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'London, England – Conventional Banking: Barclays have recently submitted a
    patent application that attempts to leverage blockchain technology to optimize
    safety parameters during fund transfer. Employing distributed ledger technology
    (DLT), it will aid in regulating cryptocurrency transfers.'
  prefs: []
  type: TYPE_NORMAL
- en: Barclays pioneered the use of blockchain to trace financial transactions, adhere
    to regulations, and fight fraud. It holds a patent for the Know-Your-Customer
    process, which enables the bank to store all personally identifiable customer
    information on a secure blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: 8.7.5.3 Chinese Military
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Beijing, China – Defense and Armed Forces: The Chinese military and government
    are gearing up to use blockchain cybersecurity to protect critical government,
    military, and other intelligence data.'
  prefs: []
  type: TYPE_NORMAL
- en: 8.7.5.4 Cisco
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'San Jose, California (Internet of Things): Cisco intends to safeguard the IoT
    devices via blockchain technology because it circumvents a single point of failure
    and protects data through encryption. Cisco has earlier worked with hardware company,
    Rockwell Automation, and supply chain company, Flex, on establishing blockchain
    networks in manufacturing and shipping.'
  prefs: []
  type: TYPE_NORMAL
- en: 8.7.5.5 Coinbase
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'San Francisco, California – Cryptocurrency: Coinbase is an exchange for users
    to buy and sell digital currency. The wallet and password are kept in a safe database,
    using encryption. To make sure your crypto is secure, the company conducts rigorous
    background checks of employees. Coinbase has processed over $150 billion in trades
    so far.'
  prefs: []
  type: TYPE_NORMAL
- en: 8.7.5.6 Colorado State
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Denver, Colorado – Government: As per the bill approved by the Colorado Senate,
    the government will adopt blockchain technology to ensure the security of records
    and thwart attempts to attack it.'
  prefs: []
  type: TYPE_NORMAL
- en: 8.7.5.7 Founders Bank
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Valletta, Malta – Cryptocurrency: The bank aims to be the world’s first decentralized
    bank that will be owned neither by buyers nor by central authorities. The bank
    will be regulated by the holders of its token-based equity. The bank will use
    discrete silos for storage, large-scale public ledger systems, and encryption
    techniques to ensure that cryptocurrency trading can be conducted in a secure
    and orderly manner.'
  prefs: []
  type: TYPE_NORMAL
- en: 8.7.5.8 Health Linkage
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Mountain View – California: is a blockchain network used in the health-care
    system to preserve and exchange patient data through hospitals, diagnostic laboratories,
    pharmacy firms, and physicians. The company aims to secure patient medical history
    and allows only a few personnel to have access to the record. It will keep track
    of the significant health-related events to help doctors make informed decisions.'
  prefs: []
  type: TYPE_NORMAL
- en: 8.7.5.9 JP Morgan
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'New York – Traditional Banking: The largest financial institution in the US,
    JP Morgan, has developed an enterprise-focused version of Ethereum called Quorum,
    which uses the blockchain to handle private transactions. The bank deploys smart
    contracts on the network to process cryptographically secure but transparent transactions.
    JP Morgan’s blockchain-powered trial aims to cover all aspects of the loan lifecycle:
    origination, execution, and settlement.'
  prefs: []
  type: TYPE_NORMAL
- en: 8.7.5.10 Mobile Coin
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'San Francisco, California – Cryptocurrency: MobileCoin is evolving an easy-to-use
    cryptocurrency for resource-constrained enterprises that are not sufficiently
    equipped to process ledger information securely. MobileCoin is planning its product
    to integrate easily with Facebook Messenger, WhatsApp, and Signal.'
  prefs: []
  type: TYPE_NORMAL
- en: 8.7.5.11 Philips Healthcare
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Andover, Massachusetts – Healthcare: Philips Healthcare has teamed up with
    hospitals around the world to build a blockchain and AI-enabled health-care network.
    This ecosystem will trace and examine all aspects of the health-care system, including
    operational, secretarial and therapeutic data. Blockchain is implemented to secure
    the large amount of data thus stored.'
  prefs: []
  type: TYPE_NORMAL
- en: 8.7.5.12 Santander Bank
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Boston, Massachusetts – International Payments: Santander is the first bank
    in the United Kingdom to embrace blockchain to secure its international payment
    gateway. It empowers customers to make transactions between Santander’s accounts
    in Europe and South America. Santander’s One Pay FX, in partnership with Ripple,
    is prevalent in Brazil, Poland, Spain, and the UK.'
  prefs: []
  type: TYPE_NORMAL
- en: 8.7.5.13 Wall Street
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Outdated and centralized cybersecurity protocols and trillions of dollars in
    cash flow make large banks easy targets of hacking and fraud. Blockchain can decentralize
    risk and provide a multi-layered security protocol. This is probably why Wall
    Street’s attention is focused on blockchain’s bolstered security protocols. Some
    of Wall Street’s biggest financial institutions, such as JPMorgan and Bank of
    America, which often lag behind in adopting new technologies, are trying to stay
    ahead of the curve.
  prefs: []
  type: TYPE_NORMAL
- en: Like banking, the health-care industry constantly faces cyberattacks. Doctors,
    clinics, hospitals, and health-care syndicates not only keep patient’s bank information,
    but they also keep a lot of sensitive data, such as Social Security numbers, full
    names, weight, height, diseases, prescriptions, and medical conditions. Hackers
    extort millions of dollars from health-care syndicates all over the world by threatening
    to expose private data, and they might do so indefinitely unless new technologies
    are put in place. Blockchain could be an immediate solution to this problem. The
    decentralized state of DLT allows for information to be held in discrete silos
    and desists cybercriminals to access all identifiable aspects of a person’s health
    records.
  prefs: []
  type: TYPE_NORMAL
- en: Coming Up
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Beginning with early attempts at symmetric encryption with Playfair and Hill
    Ciphers, this chapter aimed to describe well-known asymmetric encryption key techniques
    like RSA. In addition, various types of cyberattacks and their prevention were
    discussed in depth using real-world examples.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter explores the possibilities of managing and verifying data and
    records through blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cyber Management Alliance, 2020\. [https://www.cm-alliance.com](https://www.cm-alliance.com).
    Accessed on 03 June 2020.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: GNU Library, 2022\. [https://gmplib.org](https://gmplib.org). Accessed on 01
    April 2022.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: IBM, 2022\. [https://www.ibm.com](https://www.ibm.com). Accessed on 20 March
    2022.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Techtarget, 2022\. RSA algorithm (Rivest-Shamir-Adleman). [https://www.techtarget.com](https://www.techtarget.com)/searchsecurity/definition/RSA.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
