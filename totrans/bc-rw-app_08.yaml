- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Encryption and Cybersecurity
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 加密与网络安全
- en: 8.1 Cryptography
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.1 密码学
- en: Cryptography is the technique of secure communication that allows only the actual
    sender of the message and the intended recipient to see the relevant content.
    The word is derived from the Greek root – *kryptos* (hidden).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 密码学是一种安全的通信技术，它只允许信息的实际发送者和预期的接收者看到相关内容。这个词来源于希腊词根——*kryptos*（隐藏）。
- en: Claude E. Shannon, who worked for years at Bell Labs, propounding the mathematical
    theory of cryptography, is considered as the father of cryptography. In this technique,
    an encrypted message replaces the character with another character. To decode
    encrypted content, you’ll need a grid or table that defines how letters are coded
    or decoded.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 克劳德·E·香农在贝尔实验室工作多年，提出了密码学的数学理论，被认为是密码学的之父。在这个技术中，加密的消息用另一个字符替换字符。要解密的加密内容，你需要一个网格或表格，定义字母是如何编码或解码的。
- en: 8.1.1 Different Types of Cryptography
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.1 不同类型的密码学
- en: 'In general, there are three types of cryptography:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，密码学有三种类型：
- en: 8.1.1.1 Symmetric Key Cryptography
  id: totrans-7
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.1.1 对称密钥加密
- en: Symmetric cryptography is an encryption system where the sender and receiver
    of a message encrypt and decrypt messages using common keys. Symmetric key systems
    are fast and simple but require the sender and receiver to exchange keys in a
    secure way. In symmetric cryptography, a secret key (or private key) is a short
    piece or code from which messages are decrypted and encrypted. The most popular
    symmetric key cryptography system is the Data Encryption System (DES).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 对称加密是一种加密系统，发送者和接收者使用共同的密钥来加密和解密消息。对称密钥系统快速简单，但需要发送者和接收者以安全的方式交换密钥。在对称加密中，秘密密钥（或私钥）是一段短代码，从中解密和加密消息。最流行的对称密钥加密系统是数据加密系统（DES）。
- en: 8.1.1.2 Asymmetric Key Cryptography
  id: totrans-9
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.1.2 非对称密钥加密
- en: Asymmetric encryption is also called public key encryption, but it actually
    results from the simultaneous use of two mathematically coupled keys, one the
    public key, and the other the private key. In this process, a message is encrypted
    and decrypted by the respective keys to protect it from unauthorized access or
    use. The public key is widely disseminated for encryption, and the private key
    of the receiver is used for decryption. The public key is known by all, so the
    intended receiver can only decode it because he alone knows the private key. Therefore,
    the private key is kept secret and is used only by its owner.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 非对称加密也称为公钥加密，但实际上是由两个数学上相互关联的密钥同时使用而产生的，一个是公钥，另一个是私钥。在这个过程中，消息分别用这两个密钥进行加密和解密，以防止未经授权的访问或使用。公钥广泛传播用于加密，接收者的私钥用于解密。公钥为众人所知，所以只有预期的接收者才能解码，因为他唯一知道私钥。因此，私钥保持秘密，仅由其所有者使用。
- en: 8.1.1.3 Hash Functions
  id: totrans-11
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.1.3 哈希函数
- en: A hash function takes a set of inputs of any arbitrary size and fits them into
    a table or other data structure that contains elements of a fixed size. Hashing
    can be used to convert a password into a string of authorized characters, called
    a “hash value,” or “digest.”
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希函数接受任意大小的输入集合，并将它们放入一个表或其他数据结构中，该结构包含固定大小的元素。哈希可以将密码转换成一系列授权字符，称为“哈希值”或“摘要”。
- en: With this data structure, the data in an array can be searched and stored in
    an efficient manner. Suppose someone has a table of 5,000 digits, and he needs
    to find a given number in that list – the software or system will scan each number
    in the list until a match is found.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 利用这种数据结构，数组中的数据可以有效地进行搜索和存储。假设某人有一个包含5000个数字的表格，他需要在列表中找到一个特定的数字——软件或系统将扫描列表中的每个数字，直到找到匹配项。
- en: The hash function in this algorithm does not use encryption but, instead, calculates
    a fixed-length hash value according to the plaintext, which makes it impossible
    to retrieve the contents of the plaintext. Many operating systems use hash functions
    to encrypt passwords. While it is possible, it is unlikely to produce the original
    input by reversing the output values.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 此算法中的哈希函数不使用加密，而是根据明文计算固定长度的哈希值，这使得无法恢复明文的内容。许多操作系统使用哈希函数来加密密码。虽然可能，但通过反转输出值产生原始输入的可能性不大。
- en: 8.1.2 Cryptographic Schemes
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.2 密码学方案
- en: The history of cryptography has several milestones that led to the formation
    of the fundamentals of modern algorithms. Cipher was a common notion for conveying
    confidential information in the early times. These ciphers have been conceived
    on the symmetric key encryption scheme. In contrast to present-day digital systems,
    which treat data as binary digits, these systems comprise letters as basic elements.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 密码学的历史有几个里程碑，导致了现代算法基础的形成。密码在早期时代是传递机密信息的常见概念。这些密码是基于对称密钥加密方案设计的。与当今的数字系统不同，这些系统以字母作为基本元素。
- en: 8.1.2.1 Simple Substitution Cipher
  id: totrans-17
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.2.1 简单替换密码
- en: The Simple Substitution Cipher is the most commonly used cipher that consists
    of an algorithm, substituting each plaintext character for each ciphertext character.
    This cipher makes use of permutation of alphabets. Despite the large number of
    infallible keys, this cipher has some inefficiencies, such as choosing an explicit
    permutation, which does not make this cipher secure.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 简单替换密码是最常用的密码，由一个算法组成，用每个密文字符替换每个明文字符。这种密码利用字母的排列。尽管有大量无懈可击的密钥，这种密码仍有一些效率低下的问题，比如选择一个显式的排列，这使得密码不安全。
- en: 8.1.2.2 Caesar Cipher
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.2.2 凯撒密码
- en: The Caesar Cipher is the most candid form of substitution cipher scheme. Employing
    this cipher, each letter in the plaintext can be swapped with another alphabet
    letter to form the ciphertext. Even with modest processing power, a hacker can
    easily decrypt plaintext using one of the 26 potential keys, rendering it highly
    vulnerable.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 凯撒密码是最简单的替换密码方案。使用这种密码，明文中的每个字母都可以与另一个字母表字母交换，形成密文。即使处理能力有限，黑客也可以用26个可能的密钥之一轻松解密明文，使其高度脆弱。
- en: 8.1.2.3Vigenère Cipher
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.2.3维吉尼亚密码
- en: In order to provide more strength to the cryptosystem, the Caesar Cipher has
    been modified to design the Vigenère Cipher. This cipher operates with a text
    string as the visible cipher key. It converts every single letter of the key to
    a numeric value to transpose characters in plaintext. It was referred to as an
    unbreakable cipher because of the difficult level of decryption.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供更多强度给加密系统，凯撒密码被修改成设计维吉尼亚密码。这种密码使用文本字符串作为可见的密钥。它将键上的每个字母转换为数值，以转换明文中的字符。因为它难以解密，曾被认为是不可破解的密码。
- en: 8.1.2.4 Transposition Cipher
  id: totrans-23
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.2.4 换位密码
- en: In a Transposition Cipher, the positions held by the units of plaintext are
    shifted so that the ciphertext constitutes a permutation of the plaintext.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在换位密码中，明文单元的位置被移动，使得密文是明文的排列。
- en: 8.2 Playfair Cipher
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.2 普莱费尔密码
- en: The Playfair Cipher was the first practical digraph substitution cipher, invented
    by Charles Wheatstone in 1854\. It was named after Lord Playfair who promoted
    the use of the cipher. The Playfair Cipher is rather quick and doesn’t necessitate
    any special equipment. They encrypt a pair of letters (digraphs) instead of a
    single alphabet, unlike traditional ciphers.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 普莱费尔密码是第一个实用的双字母替换密码，由查尔斯·惠斯通在1854年发明。它以推广使用该密码的劳德·普莱费尔爵士的名字命名。普莱费尔密码相当快，不需要任何特殊设备。与传统密码不同，它们加密的是字母对（双字母）。
- en: The cipher was used for strategic purposes during the Boer War, World War I
    (by the British Army), and World War II (by the Australians). Ciphers were used
    to protect important but noncritical secrets during the actual war. By the time
    enemies could decrypt the cryptographic information, it was useless to them.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这种密码在布尔战争、第一次世界大战（英国军队使用）和第二次世界大战（澳大利亚军队使用）期间用于战略目的。密码用于在实际战争中保护重要但非关键的秘密。等到敌人能解密加密信息时，这些信息对它们来说已经没有用了。
- en: However, the Playfair Cipher is no longer used, after the development of the
    computer, as computers can quickly and easily decode it, using break codes in
    a split of seconds. Furthermore, it is a time-consuming and labor-intensive process
    that does not require a Playfair cipher decoder or calculator. Despite the fact
    that Python and C both have Playfair Cipher programs, it can be risky for commercial
    organizations to use the Playfair Cipher.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，普莱费尔密码在计算机发展后不再使用，因为计算机可以迅速轻松地解密它，使用破译代码在几秒钟内完成。此外，它是一个耗时且劳动密集型的过程，不需要普莱费尔密码解码器或计算器。尽管Python和C都具有普莱费尔密码程序，但对于商业组织来说，使用普莱费尔密码是有风险的。
- en: 8.2.1 Encryption Algorithm
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.1 加密算法
- en: 'The Playfair Cipher consists of a key and a plaintext. The key can be formed
    as a short or long word, using any 25-letter combination that doesn’t recur. This
    can be illustrated by an example of Playfair Ciphers with encryption and decryption
    algorithms:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 普莱费尔密码由密钥和明文组成。密钥可以形成一个短词或长词，使用任何不重复的25个字母组合。可以通过一个普莱费尔密码的加密和解密算法示例来说明这一点：
- en: 8.2.1.1 Step 1 – Generate Squares (5 * 5)
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.2.1.1 步骤1 – 生成方格（5 * 5）
- en: The key square is a 5 * 5 grid of letters, which serves to encrypt the plaintext.
    Given that the grid can only fit 25 letters, one letter (J) of the alphabet is
    dropped from the table. Thus 25 letters are left in the alphabet, without any
    numerics, punctuation, or nonalphabet character. The cipher begins with the exclusive
    alphabet of the key in the order of occurrence, then the remaining characters
    of the alphabet in the same sequence. Thus, a cipher uses a single alphabetic
    class without repetition and includes a digraphic substitution.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 密钥方格是一个5 * 5的字母网格，用于加密明文。考虑到网格只能容纳25个字母，字母表中有一个字母（J）被从表中删除。因此，字母表中剩下25个字母，没有数字、标点符号或非字母字符。加密从密钥的独字母开始，按照出现顺序，然后是字母表中剩余的字母。因此，加密使用一个不重复的字母类，并包括双字母替换。
- en: 8.2.1.2 Step 2 – Algorithm to Encrypt Plaintext
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.2.1.2 步骤2 – 加密明文算法
- en: 'Plaintext is split into pairs of two letters (digraphs). For example:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 明文分为两个字母的对（双字母）。例如：
- en: 'Plaintext: “ambidextrous”'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 明文：“ambidextrous”
- en: 'After Split: “am” “bi” “de” “xt” “ro” “us”'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 分割后：“am” “bi” “de” “xt” “ro” “us”
- en: If the number of letters is odd, a Z is added to the last letter.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果字母数量是奇数，在最后一个字母后添加一个Z。
- en: 'Plaintext: “workmanship”'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 明文：“workmanship”
- en: 'After Split: “wo” “rk” “ma” “ns” “hi” “pz”'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 分割后：“wo” “rk” “ma” “ns” “hi” “pz”
- en: If a pair cannot be formed from the same letter, a bogus letter can be added
    to its previous letter by breaking the letter into singles
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果同一字母无法形成一对，可以通过将字母拆分为单个字母来给其前一个字母添加虚构字母。
- en: 'Plaintext: “ditto”'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 明文：“ditto”
- en: 'After Split: “di” “tx” “to”'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 分割后：“di” “tx” “to”
- en: Here “x” is the bogus letter.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 此处“x”是虚构字母。
- en: If a letter stands alone in the pairing process, an additional fictitious letter
    can be added with the lone letter.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个字母在配对过程中单独存在，可以给这个孤立的字母添加一个虚构的字母。
- en: 'Plaintext: “recurrence”'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 明文：“recurrence”
- en: 'After Split: “re” ”cu” “rx” “re” ”nc” “ez”'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 分割后：“re” ”cu” “rx” “re” ”nc” “ez”
- en: Here “z” is the bogus letter.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 此处“z”是虚构字母。
- en: 'Rules for Encryption:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 加密规则：
- en: Consider the letters below each alphabet if both letters in a digraph are in
    the same column. Accordingly, if one of the digraph letters is the bottom letter
    in the grid, take into account the top alphabet in the same column (see [Figure
    8.1](#c08-fig-0001)).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑每个字母表下方的字母，如果双字母中的两个字母在同一列。相应地，如果双字母中的一个字母是网格中的最后一个字母，请考虑同一列中的最上面字母（见[图8.1](#c08-fig-0001)）。
- en: '![](images/c08f001.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](images/c08f001.png)'
- en: '[**Figure 8.1**](#rc08-fig-0001) Cipher encryption: If both the letters in
    the digraph are in the same column.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '[**图8.1**](#rc08-fig-0001) 加密：如果双字母中的两个字母在同一列。'
- en: 'For example:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: 'Digraph: “xt”'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 双字母：“xt”
- en: 'Encrypted Text: “fp”'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 加密文本：“fp”
- en: 'Encryption: x -> f and t -> p'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 加密：x -> f 且 t -> p
- en: Consider the letters to the right of each alphabet if both letters in a digraph
    are in the same row. As a result, if one of the digraph letters is represented
    by the rightmost alphabet in the grid, take into account the leftmost alphabet
    of the row (see [Figure 8.2](#c08-fig-0002)).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑每个字母表右侧的字母，如果双字母中的两个字母在同一行。结果是，如果双字母中的一个字母用网格中最右边的字母表示，请考虑该行的最左边字母（见[图8.2](#c08-fig-0002)）。
- en: '![](images/c08f002.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](images/c08f002.png)'
- en: '[**Figure 8.2**](#rc08-fig-0002) Cipher encryption: If both the letters in
    the digraph are in the same row.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '[**图8.2**](#rc08-fig-0002) 加密：如果双字母中的两个字母在同一行。'
- en: 'For example:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: 'Digraph: “bi”'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 双字母：“bi”
- en: 'Encrypted Text: “it”'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 加密文本：“it”
- en: 'Encryption: b -> i and i -> t'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 加密：b -> i 且 i -> t
- en: If none of the preceding rules apply, draw a quadrilateral or rectangle with
    two letters in the digraph and consider the letters on the parallel opposite corners
    of the quadrangle (see [Figure 8.3](#c08-fig-0003)).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果上述规则都不适用，请绘制一个四边形或矩形，其中包含双字母中的两个字母，并考虑矩形的对角线相对角上的字母（见[图8.3](#c08-fig-0003)）。
- en: '![](images/c08f003.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](images/c08f003.png)'
- en: '[**Figure 8.3**](#rc08-fig-0003) Cipher encryption: If none of the rules apply.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '[**图8.3**](#rc08-fig-0003) 加密：如果上述规则都不适用。'
- en: 'For example:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: 'Digraph: “ro”'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 双字母：“ro”
- en: 'Encrypted Text: “dv”'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 加密文本：“dv”
- en: 'Encryption: r -> d and o -> v'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 加密：r -> d 且 o -> v
- en: 'Now, in totto:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，总结如下：
- en: 'Plaintext: “ambidextrous”'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 明文：“ambidextrous”
- en: 'Encrypted Text: “rhitxsfpdvoz”'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 加密文本：“rhitxsfpdvoz”
- en: 'Encryption: a -> r; m -> h; b -> i; i -> t; d -> x; e -> s; x -> f; t -> p;
    r -> d; o -> v; u -> o; and s -> z (see [Figure 8.4](#c08-fig-0004)).'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 加密：a -> r; m -> h; b -> i; i -> t; d -> x; e -> s; x -> f; t -> p; r -> d; o
    -> v; u -> o; 和 s -> z（参见 [图 8.4](#c08-fig-0004)）。
- en: '![](images/c08f004.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](images/c08f004.png)'
- en: '[**Figure 8.4**](#rc08-fig-0004) Cipher encryption: Plaintext to ciphertext.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '[**图 8.4**](#rc08-fig-0004)  加密过程：明文到密文。'
- en: '**Implementation of Playfair Cipher in C**'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**Playfair 密码在 C 语言中的实现**'
- en: Output (see [Code Cell 8.1](#c08-fea-1001))
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 输出（参见 [代码单元 8.1](#c08-fea-1001)）
- en: 'Key text: “Monarchy”'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 键文本：“Monarchy”
- en: 'Plaintext: “ambidextrous”'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 明文：“ambidextrous”
- en: 'Ciphertext: “rhitxsfpdvoz”'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 密文：“rhitxsfpdvoz”
- en: '[PRE0]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[**Code Cell 8.1 **](#rc08-fea-1001) Playfair Cipher – Encryption using C.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '[**代码单元 8.1**](#rc08-fea-1001) Playfair 密码 – 使用 C 进行加密。'
- en: 8.2.2 Decryption Algorithm
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.2 解密算法
- en: The Playfair Cipher is decrypted by going reverse through the encryption process.
    The communication can be decrypted by the recipient, using the same key and the
    same key table that were used to encrypt it.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Playfair 密码通过逆向加密过程进行解密。通信可以由接收者使用相同的密钥和相同的密钥表进行解密。
- en: 8.2.2.1 Step 1 – Generate Squares (5 * 5)
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.2.2.1 步骤 1 – 生成方块（5 * 5）
- en: The key is a 5 * 5 grid of square letters, which serves to decrypt the encrypted
    code. Since the grid can only accommodate 25 characters, at the time of encryption
    one letter (J) of the alphabet was dropped from the table. Thus there were only
    25 letters in the alphabet class without any digits, punctuation marks, or nonalphabet
    characters. The cipher began with the unique alphabet of the key in the order
    of occurrence; after that, the rest of the letters appear in order. A cipher was
    thus constructed, using a single alphabetic class without repetition, and it has
    a digraphic substitution.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 密钥是一个 5 * 5 的方块字母网格，用于解密加密代码。由于网格只能容纳 25 个字符，在加密时，字母表中的一个字母（J）被从表中删除。因此，在没有数字、标点符号或非字母字符的情况下，字母表类中只有
    25 个字母。密钥以发生顺序的独特字母表开始；之后，其余字母按顺序出现。因此，构建了一个不重复的单一字母类的双字母替换密码，并且它具有双字母替换。
- en: Playfair cipher is a type of block cipher, which replaces a particular plaintext
    character during encryption with a ciphertext character depending on the adjacent
    character in the plaintext. The easiest way to crack the Playfair cipher is to
    perform frequency analysis of those letter pairs. Knowing the approximate frequencies
    for the language used in the message, an attempt can be made to match consecutive
    ciphertext pairs to consecutive pairs of letters in the language. Albeit this
    is a colossal task.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Playfair 密码是一种块密码，它通过依赖于明文中的相邻字符来在加密过程中替换特定的明文字符。破解 Playfair 密码的最简单方法是对那些字母对进行频率分析。知道消息中使用的语言的大致频率，可以尝试将连续的密文对与语言中的连续字母对匹配。尽管这是一个巨大的任务。
- en: 8.2.2.2 Step 2 – Algorithm to Decrypt the Ciphertext
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.2.2.2 步骤 2 – 解密密文算法
- en: The ciphertext is divided into dyads or digraphs – pairs of two letters. This
    is because at the time of encryption, an extra letter was added to an odd pair
    (if any) with a single letter to convert it into an even number. Since decryption
    itself is the reverse process of encryption, the letters are essentially even
    in number.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 密文被划分为双字母或双字母对——两封信。这是因为加密时，如果有一个奇数对，会添加一个额外的字母以将其转换为偶数。由于解密本身是加密的逆过程，所以字母实际上是成对的。
- en: 'For example:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: 'Ciphertext: “rhitxsfpdvoz”'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 密文：“rhitxsfpdvoz”
- en: 'After Split: “rh” “it” “xs” “fp” “dv” “oz”'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 拆分后：“rh” “it” “xs” “fp” “dv” “oz”
- en: Rules for Decryption
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 解密规则
- en: Consider the letters above each alphabet if both letters in a digraph are in
    the same column. Consequently, if one of the digraph letters is the top-most letter
    in the matrix, take into account the letter at the bottom in the same column (see
    [Figure 8.5](#c08-fig-0005)).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑每个字母表上方的字母，如果双字母中的两个字母在同一列。结果是，如果双字母中的一个字母是矩阵中最上面的字母，请考虑同一列中底部的字母（参见 [图 8.5](#c08-fig-0005)）。
- en: '![](images/c08f005.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](images/c08f005.png)'
- en: '[**Figure 8.5**](#rc08-fig-0005) Cipher decryption: If both the letters in
    the digraph are in the same column.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '[**图 8.5**](#rc08-fig-0005)  解密过程：如果两个字母在双字母表中处于同一列。'
- en: 'For example:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: 'Digraph: “fp”'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 双字母表：“fp”
- en: 'Decrypted Text: “xt”'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 解密文本：“xt”
- en: 'Decryption: f -> x and p -> t'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 解密：f -> x 和 p -> t
- en: Consider the letters to the left of each alphabet if both letters in a digraph
    are in the same row. In this case, take into consideration the rightmost alphabet
    in the same row if one of the digraph letters is the leftmost letter in the matrix
    (see [Figure 8.6](#c08-fig-0006)).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果双字母词中的两个字母在同一行，考虑每个字母左侧的字母。在这种情况下，如果双字母词中的一个字母是矩阵中最左边的字母，考虑该行的最右边的字母（见[图8.6](#c08-fig-0006)）。
- en: '![](images/c08f006.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](images/c08f006.png)'
- en: '[**Figure 8.6**](#rc08-fig-0006) Cipher decryption: If both the letters in
    the digraph are in the same row.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '[**图8.6**](#rc08-fig-0006) 密码解密：如果双字母词中的两个字母在同一行。'
- en: 'For example:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: 'Digraph: “it”'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 双字母词：“it”
- en: 'Decrypted Text: “bi”'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 解密后的文本：“bi”
- en: 'Decryption: i -> b and t -> i'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 解密：i -> b，t -> i
- en: If none of the above rules apply, draw a quadrangle with two letters in the
    digraph and consider the letters on the parallel opposite corners of the quadrangle
    (see [Figure 8.7](#c08-fig-0007)).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果以上规则都不适用，请用双字母词中的两个字母画一个四边形，并考虑四边形的对角线上的字母（见[图8.7](#c08-fig-0007)）。
- en: '![](images/c08f007.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](images/c08f007.png)'
- en: '[**Figure 8.7**](#rc08-fig-0007) Cipher decryption: If none of the rules apply.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '[**图8.7**](#rc08-fig-0007) 密码解密：如果以上规则都不适用。'
- en: 'For example:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: 'Diagraph: “dv”'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 双字母词：“dv”
- en: 'Decrypted Text: “ro”'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 解密后的文本：“ro”
- en: 'Decryption: d -> r and v -> o'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 解密：d -> r，v -> o
- en: 'For example:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: 'Ciphertext: “rhitxsfpdvoz”'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 密码文：“rhitxsfpdvoz”
- en: 'Decrypted Text: “ambidextrous”'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 解密后的文本：“ambidextrous”
- en: 'Decryption: r -> a; h -> m; i -> b; t -> i; x -> d; s -> e; f -> x; p -> t;
    d -> r; v -> o; o -> u; and z -> s (see [Figure 8.8](#c08-fig-0008))'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 解密：r -> a；h -> m；i -> b；t -> i；x -> d；s -> e；f -> x；p -> t；d -> r；v -> o；o ->
    u；z -> s（见[图8.8](#c08-fig-0008)）
- en: '![](images/c08f008.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](images/c08f008.png)'
- en: '[**Figure 8.8**](#rc08-fig-0008) Cipher decryption: Ciphertext into plaintext.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '[**图8.8**](#rc08-fig-0008) 密码解密：密码文转明文。'
- en: '**Implementation of Playfair Cipher Decryption in C**'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**Playfair密码解密在C语言中的实现**'
- en: Output (See [Code Cell 8.2](#c08-fea-1002))
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 输出（见[代码单元8.2](#c08-fea-1002)）
- en: '[PRE1]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[**Code Cell 8.2 **](#rc08-fea-1002) Playfair Cipher – Decryption using C.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '[**代码单元8.2**](#rc08-fea-1002) Playfair密码——使用C语言进行解密。'
- en: 'Key text: “Monarchy”'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 键文本：“Monarchy”
- en: 'Plaintext: “rhitxsfpdvoz” Deciphered text: “ambidextrous”'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 明文：“rhitxsfpdvoz” 解密后文本：“ambidextrous”
- en: 8.2.3 Advantages and Disadvantages
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.3 优点和缺点
- en: 8.2.3.1 Advantages
  id: totrans-128
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.2.3.1 优点
- en: Playfair Ciphers seem to be more secure since the intricate mathematics that
    is used to create them renders it extremely difficult for the recipient to decrypt
    the information.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Playfair密码由于其使用的复杂数学使其 extremely difficult for the recipient to decrypt the
    information，因此似乎更加安全。
- en: The frequency analysis that works well for simple substitution ciphers does
    not work here, so it’s hard to crack the encryption. However, if one tries to
    do so by frequency analysis, it will require a lot of ciphertext for 25 * 25 =
    625 possible digraphs in a Playfair iteration, as opposed to 25 monographs in
    a Simple Substitution Cipher.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 对简单替换密码有效的频率分析在这里不起作用，所以很难破解加密。然而，如果尝试通过频率分析来破解，将需要大量的密码文，以25 * 25= 625种可能在Playfair迭代中的双字母词，而不是在简单替换密码中的25个单字母词。
- en: Playfair Cipher is a manual process that does not need any digital device, such
    as a calculator or decoder, for encryption and decryption. While implementing
    encryption–decryption, using a Playfair Cipher in C, data can travel safely between
    its source and terminus without making any compromise.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Playfair密码是一种不需要任何数字设备（如计算器或解码器）的手动过程，用于加密和解密。在C语言中实现Playfair密码的加密-解密时，数据可以在源和终点之间安全传输，而不会做出任何妥协。
- en: Further, Brute-force attack does not affect the Playfair cipher.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，暴力破解对Playfair密码没有影响。
- en: 8.2.3.2 Disadvantages
  id: totrans-133
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.2.3.2 缺点
- en: The Playfair Cipher operates with the same key for encryption and decryption,
    making it possible to crack symmetric cryptography, and it cannot be used to transmit
    massive amounts of data.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Playfair密码使用相同的密钥进行加密和解密，使其可能破解对称密码学，并且不能用于传输大量数据。
- en: In a Playfair Cipher, since the replacement itself is reverse, one can easily
    decode an information by employing frequency analysis. If a hacker knows the language
    of plaintext, he will understand that the ciphertext (RG) and its inverse (GR)
    have the corresponding plaintext in the digraph, such as HA and AH.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在Playfair密码中，由于替换本身就是反转的，因此可以通过频率分析轻松解码信息。如果黑客知道明文的语言，他将明白密码文（RG）及其逆文（GR）在双字母词中有对应的明文，例如HA和AH。
- en: Further, it supports only 25 characters, that too either all upper case or lower
    case.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，它只支持25个字符，而且只能是全部大写或全部小写。
- en: It does not support any numeric or special characters, such as symbols, equations,
    spaces, or punctuation marks.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 它不支持任何数字或特殊字符，如符号、方程、空格或标点符号。
- en: In addition, it does not allow languages other than English. Doesn’t even support
    encryption of media files.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，它只允许使用英语以外的语言。甚至不支持媒体文件的加密。
- en: 8.3 Hill Cipher
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.3 希尔密码
- en: The Hill Cipher is a polygraphic substitution cipher constructed on linear algebra.
    Invented by Lester Sanders Hill in 1929, it works impeccably with digraphs (two-letter
    blocks), trigraphs (three-letter blocks), or other multiple-sized blocks to produce
    a consistent cipher. It was the first polygraphic cipher in which it was possible
    to work with more than three symbols at a time.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 希尔密码是一种基于线性代数的多元替换密码。由莱斯特·桑德斯·希尔于1929年发明，它完美地适用于双字母（两个字母的块）、三字母（三个字母的块）或其他多种大小的块，以产生一致的密码。它是第一个可以一次处理超过三个符号的多字母密码。
- en: Each letter in Hill Cipher is represented by 26 modules. Often simple schemes
    such as A = 0, B = 1 ...
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 希尔密码中的每个字母都表示为26个模块。通常使用简单的方案，如A = 0, B = 1 ...
- en: Z = 25 are used, but this is not an essential feature of the cipher (see [Figure
    8.9](#c08-fig-0009)). The matrix used for encryption is the cipher key and is
    chosen at random from a set of invertible *n* * *n* matrices (module 26). Here,
    *n* could be 2, 3, 4, 5 or 6\. To decrypt the message, each block is multiplied
    by the inverse of the matrix encoding.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Z = 25 被使用，但这不是密码的一个重要特征（见[图8.9](#c08-fig-0009)）。用于加密的矩阵是密钥，从可逆的*n* * *n*矩阵集合（模26）中随机选择。在这里，*n*
    可以是2、3、4、5或6。为了解密消息，每个块需要与编码矩阵的逆相乘。
- en: '![](images/c08f009.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](images/c08f009.png)'
- en: '[**Figure 8.9**](#rc08-fig-0009) Letters (left) and corresponding numbers (right)
    – Hill cipher encryption uses the above scheme of numbers and letters that can
    be modified as per condition.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '[**图8.9**](#rc08-fig-0009) 字母（左）和相应的数字（右） - 希尔密码加密使用上述字母和数字方案，可以根据条件进行修改。'
- en: 'Examples:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：
- en: 'Input: Plaintext: “ACT”'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 输入：明文：“ACT”
- en: 'Key: “GYBNQKURP”'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 密钥：“GYBNQKURP”
- en: 'Output: Ciphertext: “POH”'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：密文：“POH”
- en: 'Input: Plaintext: “GFG”'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 输入：明文：“GFG”
- en: 'Key: “HILLMAGIC”'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 密钥：“HILLMAGIC”
- en: 'Output: Ciphertext: “SWK”'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：密文：“SWK”
- en: 8.3.1 Substitution Scheme
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.1 替换方案
- en: Typically, Hill Cipher encryption uses the following structure of alphanumeric
    (letters and numerals), but this can be modified as per requirement.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，希尔密码加密使用以下字母数字（字母和数字）结构，但根据需要可以进行修改。
- en: 8.3.1.1 Encryption
  id: totrans-154
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.1.1 加密
- en: To encrypt a given message, in parallel with modulus 26, each block consists
    of *n* letters and these are multiplied in an *n* * *n* matrix. Next, for decryption,
    each block needs to be multiplied by the inverse matrix (see [Figure 8.10](#c08-fig-0010)).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 要加密给定的消息，与模26同时进行，每个块由*n*个字母组成，这些字母在*n* * *n*矩阵中相乘。接下来，为了解密，每个块需要与逆矩阵相乘（见[图8.10](#c08-fig-0010)）。
- en: '![](images/c08f010.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](images/c08f010.png)'
- en: '[**Figure 8.10**](#rc08-fig-0010) Hill Cipher encryption – ACT encrypts to
    POH.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '[**图8.10**](#rc08-fig-0010) 希尔密码加密 - ACT 加密为 POH。'
- en: It corresponds to ciphertext of “POH”
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 它对应于密文“POH”
- en: 8.3.1.2 Decryption
  id: totrans-159
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.1.2 解密
- en: It gives us back “ACT”, assuming that all the letters were in uppercase (see
    [Figure 8.11](#c08-fig-0011)).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 它给了我们“ACT”，假设所有的字母都是大写的（见[图8.11](#c08-fig-0011)）。
- en: '![](images/c08f011.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](images/c08f011.png)'
- en: '[**Figure 8.11**](#rc08-fig-0011) Hill Cipher decryption – POH decrypts back
    to ACT.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '[**图8.11**](#rc08-fig-0011) 希尔密码解密 - POH 解密回 ACT。'
- en: '**Implementation of the above idea for *n* = 3**'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**n=3的上述想法实现**'
- en: 'Ciphertext: “POH”'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 密文：“POH”
- en: '[PRE2]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**Code Cell 8.3** Encryption and decryption in Hill Cipher using C++.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码单元8.3** 利用希尔密码使用C++进行加密和解密。'
- en: Hill cipher is an example of a classical symmetric encryption algorithm that
    has succumbed to know-plaintext attacks. In this type of attack, the cryptanalyst
    had the plaintext of certain messages and the corresponding cipher text of those
    messages. They try to work-out the algorithm to decrypt any new message encrypted
    with the same key. Thus its vulnerability to cryptanalysis has made it unfeasible
    in practice, however it still plays an important pedagogical role in cryptology
    and linear algebra.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 希尔密码是已经屈服于已知明文攻击的经典对称加密算法的一个例子。在这种类型的攻击中，密码分析师拥有某些消息的明文和这些消息的相应密文。他们试图解算出算法来解密用相同的密钥加密的任何新消息。因此，其对密码分析的脆弱性使得它在实际中不可行，然而，它在密码学和线性代数的教学中仍然扮演着重要的角色。
- en: 8.4 RSA Algorithm in Cryptography
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.4 密码学中的RSA算法
- en: The RSA Algorithm is an asymmetric cryptography algorithm and hence, works on
    two different keys – the public key and the private key. It was invented in 1978
    by Ron Rivest, Adi Shamir, and Leonard Adelman. It is called the Rivest Shamir
    Adelman (RSA) Algorithm after their names.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: RSA算法是一种非对称加密算法，因此，它使用两个不同的密钥工作——公钥和私钥。它是在1978年由Ron Rivest，Adi Shamir和Leonard
    Adelman发明的。它被称为Rivest Shamir Adelman（RSA）算法，以他们的名字命名。
- en: Suppose a client (user) sends his public key to a server (facilitator) to receive
    some data. Using the client’s public key, the server encrypts the data before
    sending it. The client collects this data but needs to decrypt it first. Since
    it is asymmetric and only the client (user) has its private key, no third party,
    excluding the user, can decipher the information, even if he has the user’s public
    key.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一个客户端（用户）将他的公钥发送到一个服务器（协调员）以接收一些数据。使用客户端的公钥，服务器在发送之前加密数据。客户端收集这些数据，但需要先解密。由于它是非对称的，只有客户端（用户）有它的私钥，即使他拥有用户的公钥，第三方也无法解密信息。
- en: The idea of RSA is based on the fact that it is difficult to factorize a large
    integer. Though it is easy to get a product of two numbers, it does not seem possible
    to determine the original prime numbers from that product. Let’s understand it
    this way. The public key comprises two figures (numbers), one of which is a multiple
    of two larger prime numbers. The same two prime numbers are also used to generate
    the private keys. This implies that if one succeeds in factorizing a large number,
    the secret or private key can be hacked.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: RSA算法的基本思想基于大整数分解的困难性。虽然乘法两个数字很容易，但从乘积中确定原始的素数却似乎是不可能的。让我们这样来理解它。公钥包括两个数字（数），其中一个是大于两个素数的乘积。这两个相同的素数也用于生成私钥。这暗示着如果一个人成功地对一个大的数字进行因式分解，那么秘密或私钥就可以被黑客攻击。
- en: Hence, the defense mechanism behind the RSA Algorithm is that the hacker has
    to first determine the values *p* and *q* by a factorization of N that happens
    in exponential time. Thus, if N is a 100-digit integer, it would require more
    than seventy years to factorize. This complexity prevents an attacker from finding
    the decryption key I for the reason that *d* rests on *p*, *q* and the encryption
    key *e*. Therefore, even if the hacker obtains N and *e*, he will not be able
    to calculate *d* from N and *e*.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，RSA算法背后的防御机制是，黑客必须首先通过指数时间的大整数分解来确定值*p*和*q*。因此，如果N是一个100位整数，那么分解它将需要超过70年。这种复杂性阻止了攻击者找到解密密钥I，因为*d*依赖于*p*、*q*和加密密钥*e*。因此，即使黑客获得了N和*e*，他们也无法从N和*e*计算出*d*。
- en: Since encryption strength is completely dependent on the key size, doubling
    or tripling the key size can make the encryption stronger. Typically, an RSA key
    can be 1024 or 2048 bits long, and currently, breaking such a large amount of
    encryption appears to be an impossible task.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 由于加密强度完全取决于密钥大小，将密钥大小加倍或三倍可以增强加密。通常，RSA密钥可以是1024或2048位长，而现在，破解如此大量的加密似乎是一个不可能的任务。
- en: 'Using RSA Algorithms, the public and private keys can be generated as follows
    (Techtarget, 2022):'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 使用RSA算法，可以按照以下方式生成公钥和私钥（Techtarget，2022）：
- en: Pick the two large primes *p* and *q*.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 选取两个大素数*p*和*q*。
- en: Find *n* = *p* x *q* by multiplying these values, where *n* is referred to as
    the modulus for encryption and decryption.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 通过乘以这些值找到*n* = *p* x *q*，其中*n*被称为加密和解密的模数。
- en: Choose a number *e* less than *n*, such that *n* is relatively prime to (*p*
    – 1) x (*q* – 1). This indicates that the only factor in common between *e* and
    (*p* – 1) x (*q* – 1) is 1.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 选择一个小于*n*的数字*e*，使得*n*与(*p* – 1) x (*q* – 1)互质。这表明*e*和(*p* – 1) x (*q* – 1)之间唯一的共同因子是1。
- en: If *n* = *p* x *q*, then the public key is <*e*, *n*>.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*n* = *p* x *q*，那么公钥是<*e*, *n*>。
- en: Public key <*e*, *n*> is used to encrypt a plaintext message *m*. The following
    formula is used to obtain ciphertext C from the plaintext.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 公钥<*e*, *n*>用于加密明文消息*m*。以下公式用于从明文获得密文C。
- en: '*m*^e mod *n* = C'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '*m*^e mod *n* = C'
- en: In this case, *m* must be smaller than *n*. A larger message (>*n*) is treated
    as a sequence of communications, each of which is encrypted separately.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，*m*必须小于*n*。一个更大的消息（>*n*）被视为一系列通信，每个都单独加密。
- en: 'To find out the private key, the formula, given here, is used to calculate
    the *d*, such that:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找到私钥，使用以下公式计算*d*，使得：
- en: '*d[e]* mod {(*p* – 1) x (*q* – 1)} = 1'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '*d[e]* mod {(*p* – 1) x (*q* – 1)} = 1'
- en: Or
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '*d[e]* mod φ (*n*) = 1 where φ (*n*) = (*p* – 1) x (*q* – 1)'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: The private key is <*d*, *n*>.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: A ciphertext message C is decoded using the private key <*d*, *n*>. To retrieve
    plaintext *m* from the ciphertext C, the formula, given hereafter, is used to
    get plaintext *m*.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '*m* = C*^d* mod *n*'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 8.4.1 Working Mechanism
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 8.4.1.1 Generating the Public Key
  id: totrans-190
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Pick two prime numbers. Assume P and Q to be 53 and 59 respectively.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now first component of the public key: *n* = P*Q = 3127.'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Here, a minor exponent, say *e*, is also required
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, *e* ought to be:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: A whole number.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not be an element or factor of *n*.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 < *e* < Φ(*n*) [Φ(*n*) is discussed below],
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, consider it to be equal to 3.
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Our public key is made of *n* and *e*
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 8.4.1.2 Generating a Private Key
  id: totrans-200
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Compute Φ(*n*) as follows:'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So as Φ(*n*) = (P – 1) x (Q – 1)
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Thus, Φ(*n*) = 3016
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then, determine private key, *d*:'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For some whole number (integer) *k*, *d* = (*k**Φ(*n*) + 1) / *e*
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For *k* = 2, the value of *d* is 2011.
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Thus, we now have: Public key (*n* = 3127 and *e* = 3) and private key (*d*
    = 2011)'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: 'First, encrypt “HI”:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: 'Convert letters to numbers:'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here, H = 8 and I = 9
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Accordingly, Encrypted Data *c* = 89*^e* mod *n* = 89³ mod (3127)
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In consequence, the Encrypted Data turns out to be 1394
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Further, decrypt 1394:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Decrypted Data = *c^d* mod *n* = (1394)^(2011) mod (3127)
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, the Encrypted Data comes out to be 89 that represents “HI”
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Where, 8 = H and I = 9
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**C Implementation of RSA Algorithm for Small Values**'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'Data in message: 12.000000'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: 'Data encrypted: 3,000,000'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 'Original Message Sent: 12.000000'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: It seems impossible to factorize RSA-1024 and RSA-2048 for many years to come.
    Although the ransomware virus also uses RSA-2048 to encode files on infected machines,
    it is neither possible to decrypt these files without a decoding key, nor to factorize
    such a large key.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Applications of RSA can be viewed in web browsers, email, VPN, chat and a range
    of other communication channels. RSA is often used to create a secure connection
    between a VPN client and a VPN server. RSA algorithms can also be used for under
    protocols such as OpenVPN, TLS handshake to exchange keys and establish a secure
    channel.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: RSA is an intrinsically fragile cryptosystem containing countless foot-guns
    that the average software engineer cannot be expected to avoid. Testing for weak
    parameters can be difficult, if not impossible, and their poor performance coerce
    developers to take risky shortcuts.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 8.5 Multiple Precision Arithmetic Library
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| **Key Generation – Summary** |  |  |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
- en: '|  | Select *p*, *q* *p*, *q* both prime |  |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
- en: '|  | calculate *n* = *p***q* |  |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
- en: '|  | calculate ø(*n*) = (*p* – 1)*(*q* – 1) |  |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
- en: '|  | select integer *e* | *gcd* (ø(*n*),*e*) = 1;1 < *e* < ø(*n*) |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
- en: '|  | calculate *d* |  |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
- en: '|  | Public Key | KU = *e*,*n* |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
- en: '|  | Private Key | KR = *d*,*n* |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
- en: '| **Encryption** |  |  |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
- en: '|  | Plaintext | M < *n* |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
- en: '|  | Ciphertext | C = M*^e*(mod *n*) |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
- en: '| **Decryption** |  |  |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
- en: '|  | Ciphertext | C |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
- en: '|  | Plaintext | M = C*^d*(mod *n*) |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
- en: The three distinct steps of the RSA method are shown in the equations above.
    N will be a 2048-bit number if a prime number generator produces the 1024-bit
    primes *p* and *q*. The software that processes 2048-bit will take a lot of time
    because all modulo procedures during encryption and decryption are implemented
    with regard to *N*, where *N* is a 2048-bit number.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: RSA方法的三步分别显示在上面的等式中。如果一个素数生成器生成了1024位的素数*p*和*q*，那么*N*将是一个2048位的数。处理2048位的软件会花费很多时间，因为所有的模运算过程在加密和解密时都是以*N*为参照，而*N*是一个2048位的数。
- en: Given the needs of the RSA Algorithm, a GNU Multiple Precision Arithmetic Library
    (GMP) can be implemented to support the creation of large-sized keys. This would
    expedite encryption and decryption comprising a large-size modulus. This library
    will facilitate the complete RSA Algorithm to run on a simple 64-bit operating
    system with no dependence on high-configuration hardware devices.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于RSA算法的需求，可以使用GNU多精度算术库（GMP）来支持大型密钥的创建。这将加快包含大模数的大规模加密和解密过程。这个库将使完整的RSA算法能够在没有依赖高配置硬件设备的简单64位操作系统上运行。
- en: 8.5.1 GNU Multiple Precision Arithmetic Library
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.5.1 GNU多精度算术库
- en: GMP is an open-source library used for arithmetic calculations. This includes
    extraordinary large or highly precise numbers, the majority of which are employed
    in cryptographic techniques. This makes it possible to execute arithmetic operations
    on signed integers, rational numbers, and decimal numbers, irrespective of the
    machine’s configuration or any practical limitation (GNU Library, 2022).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: GMP是一个开源库，用于算术计算。这包括非常大的或高度精确的数字，其中大部分用于密码技术。这使得它可以在有符号整数、有理数和十进制数上执行算术运算，而不受机器配置或任何实际限制的影响（GNU库，2022）。
- en: The native interface of the GNU library is designed to work with the C programming
    language. However, wrappers are available for C++, C#, Ada, Julia, OCaml, PHP,
    Python, Perl, R, Ruby, and the Wolfram language, among others.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: GNU库的本地方法是为C编程语言设计的。然而，为C++、C#、Ada、Julia、OCaml、PHP、Python、Perl、R、Ruby和其他语言提供了包装器。
- en: 8.5.2 RSA Algorithm Implementation Using GMP Library
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.5.2 使用GMP库的RSA算法实现
- en: A C program that shows the functioning of the RSA Algorithm with smaller prime
    numbers has been given in [code cell 8.4](#c08-fea-1004). To comprehend the procedure
    of the actual RSA Algorithm, C code using the GMP library, with large prime numbers,
    needs to be worked out. The program performs RSA-1024 by creating random prime
    integers *p* and *q* of 512 bits, followed by encoding and decoding. In such a
    backdrop, the value 1024 is assigned to the variable modulus size. This value
    can be modified to 2048 in order to produce an RSA key of 2048 bits.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 一个用C语言编写的展示RSA算法在小素数情况下的工作原理的程序在[代码单元8.4](#c08-fea-1004)中给出。为了理解实际RSA算法的步骤，需要用GMP库编写一个使用大素数的C代码。该程序通过创建512位随机素数*p*和*q*来执行RSA-1024，然后进行编码和解码。在这样的背景下，变量模数大小被赋值为1024。这个值可以修改为2048，以生成一个2048位的RSA密钥。
- en: '[PRE3]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[**Code Cell 8.4 **](#rc08-fea-1004) RSA Asymmetric Cryptography using C.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '[**代码单元8.4 **](#rc08-fea-1004) 使用C语言的RSA非对称加密。'
- en: '**Implementation of RSA Algorithm**'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '**RSA算法的实现**'
- en: RSA Algorithms can be implemented in secure network transmissions and transactions
    for a variety of e-commerce applications. In addition, it can also be implemented
    to share credit card details to online traders, to enable voice messages over
    low bit rate channels, secure key swapping for high-speed IPSec, etc. (see [Code
    Cell 8.5](#c08-fea-1005)).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: RSA算法可以实现于安全的网络传输和交易中，应用于各种电子商务应用。此外，它还可以实现于向在线交易商分享信用卡详细信息，实现低比特率通道上的语音消息，高速IPSec的安全密钥交换等。（参见[代码单元8.5](#c08-fea-1005)）。
- en: '[PRE4]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[**Code Cell 8.5 **](#rc08-fea-1005) RSA Algorithms using C.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '[**代码单元8.5 **](#rc08-fea-1005) 使用C语言的RSA算法。'
- en: 8.5.3 Weak RSA Decryption with Chinese Remainder Theorem
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.5.3 使用中国剩余定理的弱RSA解密
- en: RSA decryption takes longer than encryption because at the time of decryption
    of the private key, the parameter *d* is inevitably larger. Moreover, the parameters
    *p* and *q* are two exceptionally large prime numbers.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: RSA解密比加密需要更长的时间，因为在私钥解密的时刻，参数*d*不可避免地更大。此外，参数*p*和*q*是两个非常大的素数。
- en: '[RSA is quite slow due to the large number of computations. The message is
    usually much longer than the secret key to encrypt. One way is to use RSA to encrypt
    only one secret key, which is used in a symmetric encryption algorithm. This can
    yield the benefits of both the security of asymmetric encryption and the speed
    of symmetric encryption algorithms].'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '[由于计算量大，RSA 相当慢。消息通常比加密的秘密钥长得多。一种方法是只用 RSA 加密一个秘密密钥，该密钥用于对称加密算法。这可以同时获得非对称加密的安全性和对称加密算法的速度]。'
- en: Determine *m* such that *c* = *m^e* mod (*p* x *q*), given the whole numbers
    *c*, *e*, *p*, and *q*. (RSA decryption for frail integers).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 确定 m 使得 c = m^e mod (p x q)，给定整数 c、e、p 和 q。（RSA 解密脆弱整数）。
- en: 'Fundamentals: There is a public key represented by two factors or strictures
    *n* (modulus) and *e* (exponential). The modulus is the multiplication of two
    extraordinary large prime numbers (*p* and *q* as given following). The user must
    factorize *n* into two prime numbers (RSA being safe) in order to decrypt this
    message, and then determine the modular inverse of *e*, which is a time-consuming
    job.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 基础：有一个由两个因子或结构 n（模数）和 e（指数）表示的公钥。模数是两个非常大的质数（如后面给出的 p 和 q）的乘积。用户必须将 n 分解为两个质数（RSA
    安全）以解密此消息，然后确定 e 的模逆，这是一项耗时的工作。
- en: A text version is first transcribed into the corresponding decimal value – a
    parameter m to be found below. Then the message is encrypted by calculating *c*
    = *m*^e mod (*p* x *q*), where *c* stands for the encrypted text.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 首先将文本版本转换为相应的十进制值——下面要找到的参数 m。然后通过计算 c = m^e mod (p x q)*c* 表示加密文本。
- en: Here, an attempt is made to generate a private key by finding the values of
    *p*, *q*, and *d*, taking advantage of the exponent value and weak modulus to
    crack the encryption. In the present example, small values of *p* and *q* have
    been taken, nevertheless in actual applications, large values of *p* and *q* must
    be taken to protect the RSA system.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，通过利用指数值和弱模数来找到 p、q 和 d 的值，尝试生成私钥。在当前示例中，已经取了小的 p 和 q 值，尽管如此，在实际应用中，必须取大的
    p 和 q 值以保护 RSA 系统。
- en: So, let’s try to find *d* in the cases that follow, given *p* and *q*.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们在下面的情况下尝试找到 d，给定 p 和 q。
- en: Examples
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: 'Input:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 输入：
- en: '*c* = 1614'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: c = 1614
- en: '*e* = 65537'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: e = 65537
- en: '*p* = 53'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: p = 53
- en: '*q* = 31'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: q = 31
- en: 'Output:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '1372'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '1372'
- en: 'Explanation:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 解释：
- en: Calculate *c* = *m^e* mod (*p* x *q*).
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 计算 c = m^e mod (p x q)。
- en: Insert *m* = 1372.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 插入 m = 1372。
- en: On calculating, we get *c* = 1614.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 计算得到 c = 1614。
- en: 'Input:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 输入：
- en: '*c* = 3893595'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: c = 3893595
- en: '*e* = 101'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: e = 101
- en: '*p* = 3191'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: p = 3191
- en: '*q* = 3203'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: q = 3203
- en: 'Output:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '6574839'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '6574839'
- en: 'Explanation:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 解释：
- en: As stated above, if we compute *m^e* mod (*p* x *q*)
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所述，如果我们计算 m^e mod (p x q)
- en: with *m* = 6574839, we get *c* = 3893595
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 当 m = 6574839 时，我们得到 c = 3893595
- en: 'In general, the value of *m* can be obtained as follows:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，m 的值可以如下获得：
- en: (1) Find out the modular inverse of *e*.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: （1）找出 e 的模逆。
- en: Use the following equation, *d* = *e*^(-1) mod (λ(*n*)),
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下等式，d = e^(-1) mod (λ(n))，
- en: where *n* is the number of variables and λ is the Carmichael Totient function.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 n 是变量数，λ 是卡迈克尔函数。
- en: (2) Now, determine *m* = *c^d* mod (*p* x *q*)
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: （2）现在，确定 m = c^d mod (p x q)
- en: (3) The Chinese Remainder Theorem, as specified in the implementation below,
    can be used to speed up the calculation.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: （3）如下面实现所示，中国剩余定理可以用来加速计算。
- en: '**Python Implementation of Chinese Remainder Theorem**'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '**中国剩余定理的 Python 实现**'
- en: Output
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 输出
- en: '41892906'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '41892906'
- en: '[PRE5]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**Code Cell 8.6** Chinese Remainder Theorem.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码单元 8.6** 中国的剩余定理。'
- en: 8.6 SHA-512 Hash in Java
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.6 SHA-512 哈希在 Java 中
- en: Secure Hash Algorithm 512 (SHA-512) is a hashing algorithm, each output of which
    produces an SHA-512 length of 512 bits (64 bytes), i.e. 128 hexadecimal characters.
    It can convert any size text into a fixed-size string. This algorithm is commonly
    used to get email address hash, password hash, and digital record verification.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 安全哈希算法 512（SHA-512）是一种哈希算法，其每个输出产生一个 512 位长（64 字节）的 SHA-512 值，即 128 个十六进制字符。它可以将任何大小的文本转换为固定大小的字符串。此算法常用于获取电子邮件地址哈希、密码哈希和数字记录验证。
- en: 'Six hash functions fall into the Secure Hash Algorithm – two families of the
    cryptographic hash functions:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 六个哈希函数属于安全哈希算法——两种加密哈希函数的家族：
- en: '| Hash Algorithm | Hash Value |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '| 哈希算法 | 哈希值 |'
- en: '| --- | --- |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| SHA-224 | 224-bit hash value |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '| SHA-224 | 224 位哈希值 |'
- en: '| SHA-256 | 256-bit hash value |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '| SHA-256 | 256 位哈希值 |'
- en: '| SHA-384 | 384-bit hash value |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
- en: '| SHA-512 | 512-bit hash value |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
- en: '| SHA-512/224 | 512-bit hash value |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
- en: '| SHA-512/256 | 512-bit hash value |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
- en: The most widely used and accepted hash algorithms of these are SHA-256 and SHA-512,
    which use 32-bit and 64-bit words, respectively, for computation. SHA-224 and
    SHA-384 are the short versions of SHA-256 and SHA-512 in that order. These are
    calculated with different starting values.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: The MessageDigest Class, found in the package java.security, is used to compute
    cryptographic hash values in Java.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: 'To determine a text’s hash value, the MessageDigest class offers these cryptographic
    hash functions:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: MD2
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MD5
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SHA-1
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SHA-224
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SHA-256
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SHA-384
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SHA-512
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A static method named getInstance() initializes these algorithms. After choosing
    an algorithm, the message digest value is determined, and the output is reverted
    as a byte array. The BigInteger class is applied to change the resulting byte
    array into its signum representation. This representation is subsequently transformed
    to hexadecimal format to get the desired MessageDigest.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: 'Input: hello'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: 'Output:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: 309ecc489c12d6eb4cc40f50c902f2b4d0ed77ee511a7c7a9bcd3ca86d4cd86f989
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: dd35bc5ff499670da34255b45b0cfd830e81f605dcf7dc5542e93ae9cd76f
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: 'Input: helloworld'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: 'Output:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: acc10c4e0b38617f59e88e49215e2e894afaee5ec948c2af6f44039f03c9fe47a9210
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: e01d5cd926c142bdc9179c2ad30f927a8faf69421ff60a5eaddcf8cb9c
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '**Implementation of SHA-512 hash function**'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: Output (see [Code Cell 8.7](#c08-fea-1007))
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: 'HashCode Generated by SHA-512 for:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: 'hello:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: 309ecc489c12d6eb4cc40f50c902f2b4d0ed77ee511a7c7a9bcd3ca86d4cd86f989
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: dd35bc5ff499670da34255b45b0cfd830e81f605dcf7dc5542e93ae9cd76f
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[**Code Cell 8.7 **](#rc08-fea-1007) Calculating SHA-512 hash value.'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: 'helloworld:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: 309ecc489c12d6eb4cc40f50c902f2b4d0ed77ee511a7c7a9bcd3ca86d4cd86f989
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: dd35bc5ff499670da34255b45b0cfd830e81f605dcf7dc5542e93ae9cd76f
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: SHA-1 forms a part of several widely used security applications and protocols,
    including TLS and SSL, PGP, SSH, S/MIME, and IPsec. These applications can use
    MD5 as well, as both MD5 and SHA-1 have derived from MD4\. SHA-1 was designed
    by the United States National Security Agency, and is a U.S. Federal Information
    Processing Standard.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: 8.7 Cybersecurity
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cybersecurity is a way of defending systems and networks against online attacks
    that try to access, modify, destroy, or extort money in exchange for sensitive
    digital information. Cyberattacks can be carried out through several malware like
    Trojans, Rootkits, Virus, etc. and are known as Distributed Denial-of-Service
    (DDoS) attacks, Man-in-the-Middle (MITM) attacks, phishing, Ransomware attacks,
    and Structured Language Query (SQL) injections (IBM, 2022). With the increasing
    dependence on technology and Big Data, there is an urgent need to address the
    security concerns with respect to protection of data and transactions.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: 8.7.1 Common Cyberattacks
  id: totrans-337
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 8.7.1.1 Denial-of-Service Attacks
  id: totrans-338
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A Denial-of-Service Attack is one in which cybercriminals flood a computer system’s
    network and servers with traffic to prevent legitimate requests from being served.
    This renders the system unusable, preventing an organization from performing important
    tasks.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 拒绝服务攻击是指网络犯罪分子用流量淹没计算机系统的网络和服务器，以阻止合法请求得到服务。这使得系统无法使用，阻止组织执行重要任务。
- en: 8.7.1.2 Malware
  id: totrans-340
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.7.1.2 恶意软件
- en: Malware, one of the most common cyberthreats, is malicious software designed
    to gain unauthorized access or harm a computer. This malware is created by a hacker
    or cybercriminal, for the purpose of making money or politics-driven cyberattacks,
    to disrupt or damage the computer of a legitimate user. It is often spread through
    an unsolicited email attachment or downloadable software that looks genuine and
    legitimate.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件是常见的网络安全威胁之一，是旨在获得未授权访问或损害计算机的恶意软件。这种恶意软件由黑客或网络犯罪分子创建，目的是为了赚钱或基于政治动机的网络攻击，干扰或损坏合法用户的计算机。它通常通过一个看似正宗和合法的无需请求的电子邮件附件或可下载软件来传播。
- en: 'Malware can be of many types, such as:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件可以是多种类型，例如：
- en: '***Virus***'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '**病毒**'
- en: It is a self-replicating program that fixes itself to an uninfected file and
    infects the entire computer system with files containing malicious code.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 它是一种自我复制的程序，将自己固定在未感染的文件上，并使用包含恶意代码的文件感染整个计算机系统。
- en: '***Trojan***'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '**特洛伊木马**'
- en: This is a sort of malware, disguised as genuine software. Cyberattackers tempt
    users to upload Trojans to their computers and collect data by harming their systems.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种伪装成正宗软件的恶意软件。网络攻击者诱使用户上传特洛伊木马到他们的计算机上，并通过损害他们的系统来收集数据。
- en: '***Spyware***'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '**间谍软件**'
- en: It is software that installs itself on a user’s computer and starts secretly
    monitoring their online behavior without their knowledge or permission. It relays
    the information so received, about an individual or organization, to other parties.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种安装在用户计算机上并秘密监视他们在线行为而不为他们所知或同意的软件。它将关于个人或组织的信息传递给其他方。
- en: '***Ransomware***'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '**勒索软件**'
- en: It’s a type of malicious malware that locks a user’s files and data, threatens
    to erase information, and blocks access to files or computer systems until a ransom
    is paid. Despite the ransom, the user is not assured that the files will be retrieved
    or the system will be restored.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种恶意恶意软件，它锁定用户的文件和数据，威胁要抹掉信息，并封锁文件或计算机系统的访问，直到支付赎金为止。尽管支付了赎金，用户也不能保证文件会被恢复或系统会被修复。
- en: '***Adware***'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '**广告软件**'
- en: It is an advertising software capable of spreading malware through billboards.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 它是一种广告软件，可以通过广告牌传播恶意软件。
- en: '***Botnet***'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '**僵尸网络**'
- en: This malware is a network of infected computers, used by cybercriminals to perform
    tasks online without the user’s consent.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 这种恶意软件是一个由感染计算机组成的网络，网络犯罪分子利用它在线执行任务，而无需用户的同意。
- en: 8.7.1.3 Man-in-the-Middle Attack
  id: totrans-355
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.7.1.3 中间人攻击
- en: Through a Man-in-the-Middle Attack, a cybercriminal intercepts communication
    between two individuals to steal data (see [Figure 8.12](#c08-fig-0012)). For
    example, on an unsecured WiFi network, an attacker can intercept the data being
    passed through a user’s device and the network.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 通过中间人攻击，一名网络犯罪分子拦截两个人之间的通信来窃取数据（见[图8.12](#c08-fig-0012)）。例如，在未加密的WiFi网络上，攻击者可以拦截用户设备与网络之间传递的数据。
- en: '![](images/c08f012.png)'
  id: totrans-357
  prefs: []
  type: TYPE_IMG
  zh: '![](images/c08f012.png)'
- en: '[**Figure 8.12**](#rc08-fig-0012) Cyber threats (Man-in-the-Middle).'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '[**图8.12**](#rc08-fig-0012) 网络安全威胁（中间人攻击）。'
- en: 8.7.1.4 Phishing
  id: totrans-359
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.7.1.4 网络钓鱼
- en: Phishing is the practice of sending fraudulent emails that closely resemble
    those sent from legitimate companies or trusted sources. This is the most common
    type of cyberattack whose basic objective is to steal sensitive data, such as
    credit card numbers and login passwords.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 网络钓鱼是发送模仿合法公司或可信来源的欺诈性电子邮件的做法。这是最常见的网络攻击类型，其基本目标是窃取敏感数据，例如信用卡号码和登录密码。
- en: 8.7.1.5 Structured Language Query Injection
  id: totrans-361
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.7.1.5 结构化语言查询注入
- en: Structured Language Query (SQL) Injection is a type of cyberattack used to steal
    data from data repositories. Cybercriminals, taking advantage of vulnerabilities
    in data-driven applications, insert malicious code into the database through malicious
    SQL statements that give them access to sensitive information contained in the
    database.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 结构化语言查询（SQL）注入是一种用于从数据存储库中窃取数据的网络攻击类型。网络犯罪分子利用数据驱动应用程序中的漏洞，通过恶意的SQL语句将恶意代码插入数据库，从而获得对数据库中包含的敏感信息的访问权限。
- en: Social engineering is a tactic used by adversaries to disclose sensitive information
    by soliciting monetary payment to you or by gaining access to your confidential
    data. To make this happen, they insist the user click on links, download malware,
    or rely on a malicious source.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 社交工程是一种策略，敌对势力通过向你们索要货币支付或获取你们的机密数据来揭露敏感信息。为了实现这一目的，他们坚持要求用户点击链接、下载恶意软件或依赖恶意来源。
- en: 8.7.1.6 Latest Cyberthreats
  id: totrans-364
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.7.1.6 最新的网络威胁
- en: '***Dridex Malware***'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '***Dridex恶意软件***'
- en: It is a financial Trojan malware with wide capabilities. It infects computers
    through phishing emails or prevailing malware. It specializes in stealing personal
    data, login information, banking details, etc., which are then used to conduct
    fraudulent transactions.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种具有广泛能力的金融特洛伊木马。它通过钓鱼邮件或现有恶意软件感染计算机。它专门窃取个人数据、登录信息、银行详情等，然后用于进行欺诈交易。
- en: To prevent this, it is important that devices are patched, antivirus is turned
    on and up to date, and files are backed up.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止这种情况发生，确保设备打补丁、开启并更新防病毒软件以及备份文件是非常重要的。
- en: '***Emotet malware***'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '***Emotet恶意软件***'
- en: Emotet is an advanced Trojan that thrives on crude passwords. It is capable
    of stealing data and loading other malware as well. The only way to avoid this
    malware, is to create secure passwords.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: Emotet 是一种先进的特洛伊木马，它依赖于简单的密码。它能够窃取数据并加载其他恶意软件。避免这种恶意软件的唯一方法是创建安全的密码。
- en: 8.7.2 Key Cybersecurity Features
  id: totrans-370
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.7.2 关键网络安全特性
- en: Checksums used in cryptography
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**加密中使用的校验和**'
- en: Codes for data backup and rectification
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据备份和修复的代码
- en: Assess to risks and threats
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估风险和威胁
- en: Mitigate system vulnerabilities
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减轻系统漏洞
- en: Knowledge of malicious software
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 恶意软件的知识
- en: Access management and control
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问管理和控制
- en: Authentication
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证
- en: Encryption
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加密
- en: Setting up firewalls
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置防火墙
- en: Implementation of intrusion detection and prevention systems (IDS and IPS)
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施入侵检测和预防系统（IDS和IPS）
- en: The cyberattack landscape has grown exponentially in the last few years (IBM,
    2022). Just as data breaches have seen an incredible increase and caused significant
    financial losses, blockchain has emerged as a promising mitigation technology
    for cybersecurity.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年中，网络攻击的规模呈指数级增长（IBM，2022）。正如数据泄露数量惊人地增加并造成重大经济损失一样，区块链已经作为一种有前景的网络安全缓解技术出现。
- en: 8.7.3 Blockchain for Cybersecurity
  id: totrans-382
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.7.3 区块链在网络安全中的应用
- en: Data is undoubtedly an imperative tool for the growth of any business. Enterprises
    collect sensitive data from a variety of sources and store those data smartly
    and securely. A majority of organizations still store their data in centralized
    storage that acts like a honeypot for cybercriminals. Organizations can shield
    their digital information and assets by implementing blockchain-based decentralized
    storage solutions. Decentralized storage platforms typically distribute users’
    files across multiple nodes on their network.
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据无疑是任何业务增长的重要工具。企业从各种来源收集敏感数据，并智能和安全管理这些数据。大多数组织仍然将数据存储在像网络犯罪分子的蜜罐一样的集中存储中。组织可以通过实施基于区块链的分布式存储解决方案来保护其数字信息和资产。分布式存储平台通常会将用户文件分散存储在其网络上的多个节点上。
- en: 'Internet of Things: IoT and other connected devices are facing security vulnerabilities
    and challenges over time. With the increasing use of AI, hackers find an easy
    access to the overall system. The use of blockchain-enabled, device-to-device
    encryption can be an effective solution for maintaining cybersecurity in IoT systems.'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 物联网（IoT）及其他连接设备面临着随时间推移而增加的安全漏洞和挑战。随着人工智能的广泛应用，黑客找到了轻松访问整个系统的途径。在物联网系统中，基于区块链的设备间加密可以是一个有效的解决方案，以维护网络安全。
- en: 'Distributed-Denial-of-Service: DDoS is one of the most popular cyberattacks
    today, which can disrupt normal traffic on a target server or network by creating
    a flood of internet data, thus affecting the infrastructure around it. Many new
    forms of DDoS attacks are emerging rapidly, including hide-and-seek malware. It
    is often seen that connected devices like routers, smartphones, vacuum robots,
    and webcams are compromised to launch attacks. It remains present even after system
    reboot. Blockchain, due to its immutability and cryptographic properties, can
    effectively overcome these anomalies.'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分布式拒绝服务：DDoS是目前最流行的网络攻击之一，通过创建大量的互联网数据洪水，可以破坏目标服务器或网络的正常流量，从而影响其周围的基础设施。许多新的DDoS攻击形式正在迅速出现，包括捉迷藏式恶意软件。通常可以看到，路由器、智能手机、吸尘机器人和网络摄像头等连网设备被用来发起攻击。即使在系统重启后，这种攻击仍然存在。由于其不可变性和加密特性，区块链可以有效地克服这些异常。
- en: 'Better Security for DNS: The Domain Name System (DNS) is just like a public
    directory that associates domain names with their IP addresses. Hackers exploit
    the connection between the IP address and the site to crash the domain, resulting
    in unnecessary losses for merchants and loyal customers. By decentralizing DNS
    entries, blockchain can provide a preventive solution to foil such attacks. Its
    decentralized network allows user domain information to be irreversibly stored
    on a distributed ledger, and connections can be operated by immutable smart contracts.'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更好的DNS安全：域名系统（DNS）就像一个公共目录，将域名与它们的IP地址关联起来。黑客利用IP地址和网站之间的连接来崩溃域名，给商家的忠实顾客带来不必要的损失。通过去中心化DNS条目，区块链可以提供一个预防性的解决方案来挫败此类攻击。其去中心化网络允许用户域信息不可逆转地存储在分布式账本上，连接可以通过不可变的智能合约来操作。
- en: 'Multi-signature authentication: Tampering with usernames and passwords is a
    major cyberthreat. By confirming that they have access to numerous devices, blockchain
    technology enables users to employ a multi-signature authentication mechanism
    that does not require usernames or passwords.'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 多签名认证：篡改用户名和密码是主要的网络威胁。区块链技术通过确认用户能够访问多个设备，使得用户能够采用一种不需要用户名或密码的多签名认证机制。
- en: 'Software Integrity: Blockchain can be used to protect devices from infection
    with malicious software by verifying installers. The hash of the software can
    be recorded on the blockchain, and the same may be compared with that of the installer
    to verify the integrity of the download (Cyber Management Alliance, 2020).'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 软件完整性：区块链可以用来保护设备不受恶意软件感染，通过验证安装程序。软件的哈希值可以记录在区块链上，并与安装程序的哈希值进行比较，以验证下载的完整性（网络管理联盟，2020年）。
- en: 8.7.4 Pros and Cons of Blockchain in Cybersecurity
  id: totrans-389
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.7.4 区块链在网络安全中的优缺点
- en: 8.7.4.1 Pros
  id: totrans-390
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.7.4.1 优点
- en: 'User Privacy: Full encryption of blockchain data by public and private keys
    ensures that data cannot be accessed by unauthorized parties as it flows through
    untrusted networks.'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户隐私：通过公钥和私钥对区块链数据进行完全加密，确保数据在流经不可信网络时无法被未授权的各方访问。
- en: 'Data transparency and traceability: In blockchain, with each subsequent iteration,
    the preceding state of the system is preserved, and therefore a complete history
    of transactions is available. Transaction data is digitally endorsed by the participants
    of the blockchain network, thereby maintaining transparency.'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据透明度和可追溯性：在区块链中，随着每一轮迭代，系统的先前状态都被保留，因此可以获取完整的交易历史。交易数据得到区块链网络中参与者的数字背书，从而保持透明度。
- en: 'Data integrity: The inherent characteristics of immutability and traceability
    help blockchains to keep data intact. In the event of a cybercontrol attack, smart
    contracts can be used to check and enforce rules among all participants in order
    to avert and control account sharing.'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据完整性：不可变性和可追溯性是区块链的固有特性，帮助区块链保持数据完整。在遭遇网络攻击的情况下，智能合约可以用来在所有参与者之间检查并执行规则，以预防和控制账户共享。
- en: 'No single point of failure: Blockchain systems are distributed, and a single
    point of failure cannot bring down the whole network. It nullifies IP-based DDoS
    attacks. The data remains accessible all the times through different nodes. In
    this way, the platform and system are made flexible through the use of several
    nodes and distributed operations.'
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有单点故障：区块链系统是分布式的，单点故障无法使整个网络瘫痪。它消除了基于IP的DDoS攻击。数据通过不同的节点始终可用。通过使用多个节点和分布式操作，使平台和系统变得灵活。
- en: 'Secure data transfer: Public key infrastructure (PKI) in blockchain preserves
    authentication at the time of data transfers. Though storing private key backups
    on secondary storage may pose a high risk, this can be avoided if cryptographic
    algorithms based on key management procedures and integer factorization problems,
    such as the Internet Engineering Task Force (IETF) or Remote Function Call (RFC),
    are implemented.'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全数据传输：区块链中的公钥基础设施（PKI）在数据传输时保存认证。尽管将私钥备份存储在次要存储设备上可能存在高风险，但如果实施了基于密钥管理程序和整数分解问题的加密算法，如互联网工程任务组（IETF）或远程函数调用（RFC），则可以避免这种情况。
- en: 8.7.4.2 Cons
  id: totrans-396
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.7.4.2 缺点
- en: In order to encrypt a data, blockchain heavily relies on private keys; however
    if they are lost, the user’s access to encrypted data can be lost forever. Because
    once the private key is lost, it cannot be recovered.
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了加密数据，区块链严重依赖私钥；然而，如果私钥丢失，用户对加密数据的访问可能会永远丢失。因为一旦私钥丢失，它就无法恢复。
- en: 'Adaptability and scalability challenges: Governments and organizations may
    find it challenging to integrate blockchain technology because it will require
    a total replacement of all currently used systems. This is because blockchain
    networks have predetermined block volume and limitations to execute transactions
    per second. Increasing its scalability may be somewhat puzzling.'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适应性和可扩展性挑战：政府和组织可能会发现整合区块链技术具有挑战性，因为它将需要替换目前使用的所有系统。这是因为区块链网络具有预定的区块体积和每秒执行交易的限制。增加其可扩展性可能会有些令人困惑。
- en: 'High operating cost: Blockchain applications are more expensive than their
    nonblockchain counterparts due to the high computing and storage requirements.'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高运营成本：由于高计算和存储要求，区块链应用比其非区块链竞争对手更昂贵。
- en: 'Lack of control: Blockchain perceptions are yet to be governed and regulated
    globally.'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺乏控制：区块链的观念尚未受到全球治理和监管。
- en: 'Blockchain literacy: Despite the countless applications of blockchain technology,
    there is a sheer paucity of such blockchain developers in the current scenario,
    who have in-depth knowledge of various programming languages and tools'
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 区块链素养：尽管区块链技术有无数的应用，但在当前情况下，拥有各种编程语言和工具深入了解的区块链开发者却寥寥无几。
- en: 8.7.5 Real-world Examples
  id: totrans-402
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.7.5 现实世界示例
- en: 'Some prominent examples of using blockchain for cybersecurity:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 使用区块链进行网络安全的一些突出示例：
- en: 8.7.5.1 Australian Government
  id: totrans-404
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.7.5.1 澳大利亚政府
- en: 'Canberra, Australia: The Australian government is planning to construct a cybersecurity
    network on a distributed ledger platform. The government has made substantial
    efforts to build a blockchain ecosystem and has teamed up with IBM to protect
    the storage of federal documents.'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 堪培拉，澳大利亚：澳大利亚政府计划在一个分布式账本平台上建立一个网络安全网络。政府已经做出了大量努力来建立区块链生态系统，并与IBM合作，保护联邦文件的存储。
- en: 8.7.5.2Barclays
  id: totrans-406
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.7.5.2巴克莱
- en: 'London, England – Conventional Banking: Barclays have recently submitted a
    patent application that attempts to leverage blockchain technology to optimize
    safety parameters during fund transfer. Employing distributed ledger technology
    (DLT), it will aid in regulating cryptocurrency transfers.'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 伦敦，英国 —— 传统银行：巴克莱银行最近提交了一份专利申请，试图利用区块链技术来优化基金转移过程中的安全参数。通过采用分布式账本技术（DLT），它将有助于监管加密货币的转移。
- en: Barclays pioneered the use of blockchain to trace financial transactions, adhere
    to regulations, and fight fraud. It holds a patent for the Know-Your-Customer
    process, which enables the bank to store all personally identifiable customer
    information on a secure blockchain.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 巴克莱银行率先使用区块链追踪金融交易、遵守法规和打击欺诈。它持有知识你的客户（Know-Your-Customer）流程的专利，该流程使银行能够将所有可识别的客户信息安全地存储在区块链上。
- en: 8.7.5.3 Chinese Military
  id: totrans-409
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.7.5.3 中国军队
- en: 'Beijing, China – Defense and Armed Forces: The Chinese military and government
    are gearing up to use blockchain cybersecurity to protect critical government,
    military, and other intelligence data.'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 北京，中国 —— 国防和武装力量：中国的军队和政府正在准备利用区块链网络安全来保护关键的政府、军事和其他情报数据。
- en: 8.7.5.4 Cisco
  id: totrans-411
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.7.5.4 思科
- en: 'San Jose, California (Internet of Things): Cisco intends to safeguard the IoT
    devices via blockchain technology because it circumvents a single point of failure
    and protects data through encryption. Cisco has earlier worked with hardware company,
    Rockwell Automation, and supply chain company, Flex, on establishing blockchain
    networks in manufacturing and shipping.'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '-   圣何塞，加利福尼亚州（物联网）：思科计划通过区块链技术保护物联网设备，因为区块链技术可以绕过单点故障，并通过加密保护数据。思科之前曾与硬件公司罗克韦尔自动化以及供应链公司Flex合作，在制造和运输领域建立区块链网络。'
- en: 8.7.5.5 Coinbase
  id: totrans-413
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '-   8.7.5.5 Coinbase'
- en: 'San Francisco, California – Cryptocurrency: Coinbase is an exchange for users
    to buy and sell digital currency. The wallet and password are kept in a safe database,
    using encryption. To make sure your crypto is secure, the company conducts rigorous
    background checks of employees. Coinbase has processed over $150 billion in trades
    so far.'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '-   旧金山，加利福尼亚州——加密货币：Coinbase是一个用户购买和出售数字货币的交易所。钱包和密码保存在一个安全的数据库中，使用加密技术。为了确保您的加密货币安全，该公司对员工进行严格的背景调查。Coinbase到目前为止已经处理了超过1500亿美元的交易。'
- en: 8.7.5.6 Colorado State
  id: totrans-415
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '-   8.7.5.6 科罗拉多州'
- en: 'Denver, Colorado – Government: As per the bill approved by the Colorado Senate,
    the government will adopt blockchain technology to ensure the security of records
    and thwart attempts to attack it.'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '-   科罗拉多州丹佛市——政府：根据科罗拉多州参议院通过的法案，政府将采用区块链技术确保记录的安全并阻止攻击企图。'
- en: 8.7.5.7 Founders Bank
  id: totrans-417
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '-   8.7.5.7 创始人银行'
- en: 'Valletta, Malta – Cryptocurrency: The bank aims to be the world’s first decentralized
    bank that will be owned neither by buyers nor by central authorities. The bank
    will be regulated by the holders of its token-based equity. The bank will use
    discrete silos for storage, large-scale public ledger systems, and encryption
    techniques to ensure that cryptocurrency trading can be conducted in a secure
    and orderly manner.'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '-   瓦莱塔，马耳他——加密货币：这家银行旨在成为世界上第一家去中心化的银行，既不由购买者拥有，也不由中央当局拥有。该银行将由其基于代币的股权持有者进行监管。银行将使用独立的存储筒仓、大规模公共账本系统和加密技术，以确保加密货币交易能够安全、有序地进行。'
- en: 8.7.5.8 Health Linkage
  id: totrans-419
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '-   8.7.5.8 健康链接'
- en: 'Mountain View – California: is a blockchain network used in the health-care
    system to preserve and exchange patient data through hospitals, diagnostic laboratories,
    pharmacy firms, and physicians. The company aims to secure patient medical history
    and allows only a few personnel to have access to the record. It will keep track
    of the significant health-related events to help doctors make informed decisions.'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '-   山景城——加利福尼亚州：是一家在医疗系统中使用的区块链网络，通过医院、诊断实验室、制药公司和医生保存和交换患者数据。该公司旨在保护患者的病历，并只允许少数人员访问记录。它将追踪重要的健康相关事件，以帮助医生做出明智的决策。'
- en: 8.7.5.9 JP Morgan
  id: totrans-421
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '-   8.7.5.9 摩根大通'
- en: 'New York – Traditional Banking: The largest financial institution in the US,
    JP Morgan, has developed an enterprise-focused version of Ethereum called Quorum,
    which uses the blockchain to handle private transactions. The bank deploys smart
    contracts on the network to process cryptographically secure but transparent transactions.
    JP Morgan’s blockchain-powered trial aims to cover all aspects of the loan lifecycle:
    origination, execution, and settlement.'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '-   纽约——传统银行：美国最大的金融机构，摩根大通，开发了一个以企业为重点的以太坊版本，名为Quorum，它使用区块链处理私人交易。银行在网络上部署智能合约以处理加密安全但透明的交易。摩根大通的基于区块链的试点旨在涵盖贷款生命周期的所有方面：发起、执行和结算。'
- en: 8.7.5.10 Mobile Coin
  id: totrans-423
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '-   8.7.5.10 Mobile Coin'
- en: 'San Francisco, California – Cryptocurrency: MobileCoin is evolving an easy-to-use
    cryptocurrency for resource-constrained enterprises that are not sufficiently
    equipped to process ledger information securely. MobileCoin is planning its product
    to integrate easily with Facebook Messenger, WhatsApp, and Signal.'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '-   旧金山，加利福尼亚州——加密货币：MobileCoin正在开发一种易于使用的加密货币，适用于资源受限的企业，这些企业没有足够的能力安全地处理账本信息。MobileCoin计划使其产品能轻松与Facebook
    Messenger、WhatsApp和Signal集成。'
- en: 8.7.5.11 Philips Healthcare
  id: totrans-425
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '-   8.7.5.11 飞利浦医疗保健'
- en: 'Andover, Massachusetts – Healthcare: Philips Healthcare has teamed up with
    hospitals around the world to build a blockchain and AI-enabled health-care network.
    This ecosystem will trace and examine all aspects of the health-care system, including
    operational, secretarial and therapeutic data. Blockchain is implemented to secure
    the large amount of data thus stored.'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 马萨诸塞州安多弗——医疗保健：飞利浦医疗保健与世界各地的医院合作，建立了一个基于区块链和人工智能的医疗保健网络。这个生态系统将追踪和检查医疗保健系统的各个方面，包括运营、秘书处和治疗数据。区块链被用来保护存储在这些系统中的大量数据。
- en: 8.7.5.12 Santander Bank
  id: totrans-427
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.7.5.12 桑坦德银行
- en: 'Boston, Massachusetts – International Payments: Santander is the first bank
    in the United Kingdom to embrace blockchain to secure its international payment
    gateway. It empowers customers to make transactions between Santander’s accounts
    in Europe and South America. Santander’s One Pay FX, in partnership with Ripple,
    is prevalent in Brazil, Poland, Spain, and the UK.'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 马萨诸塞州波士顿——国际支付：桑坦德银行是英国第一家采用区块链来保护其国际支付网关的银行。它使客户能够进行桑坦德在欧洲和南美洲账户之间的交易。桑坦德的One
    Pay FX与Ripple合作，在巴西、波兰、西班牙和英国非常流行。
- en: 8.7.5.13 Wall Street
  id: totrans-429
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.7.5.13 华尔街
- en: Outdated and centralized cybersecurity protocols and trillions of dollars in
    cash flow make large banks easy targets of hacking and fraud. Blockchain can decentralize
    risk and provide a multi-layered security protocol. This is probably why Wall
    Street’s attention is focused on blockchain’s bolstered security protocols. Some
    of Wall Street’s biggest financial institutions, such as JPMorgan and Bank of
    America, which often lag behind in adopting new technologies, are trying to stay
    ahead of the curve.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 过时且集中的网络安全协议和数万亿美元的现金流动使大型银行成为黑客和欺诈的目标。区块链可以分散风险并提供多层次的安全协议。这可能是华尔街关注区块链加强的安全协议的原因。华尔街一些最大的金融机构，如摩根大通和美国银行，虽然通常在采用新技术方面落后，但它们正试图保持领先。
- en: Like banking, the health-care industry constantly faces cyberattacks. Doctors,
    clinics, hospitals, and health-care syndicates not only keep patient’s bank information,
    but they also keep a lot of sensitive data, such as Social Security numbers, full
    names, weight, height, diseases, prescriptions, and medical conditions. Hackers
    extort millions of dollars from health-care syndicates all over the world by threatening
    to expose private data, and they might do so indefinitely unless new technologies
    are put in place. Blockchain could be an immediate solution to this problem. The
    decentralized state of DLT allows for information to be held in discrete silos
    and desists cybercriminals to access all identifiable aspects of a person’s health
    records.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 与银行行业一样，医疗保健行业也不断面临网络攻击。医生、诊所、医院和医疗保健集团不仅保存着患者的银行信息，还保存着大量敏感数据，如社会保障号码、全名、体重、身高、疾病、处方和医疗状况。黑客通过威胁公开私人数据，向全球医疗保健集团勒索数百万美元，如果没有新技术的实施，他们可能会无限期地这样做。区块链可能是这个问题的立即解决方案。分布式账本技术（DLT）的去中心化状态使得信息可以存储在离散的隔离区中，并阻止网络犯罪分子访问一个人健康记录的所有可识别方面。
- en: Coming Up
  id: totrans-432
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 接下来
- en: Beginning with early attempts at symmetric encryption with Playfair and Hill
    Ciphers, this chapter aimed to describe well-known asymmetric encryption key techniques
    like RSA. In addition, various types of cyberattacks and their prevention were
    discussed in depth using real-world examples.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 本章从早期对称加密的普莱菲尔和希尔密码开始，旨在描述著名的非对称加密密钥技术，如RSA。此外，还深入讨论了各种网络攻击及其预防，使用了现实世界的例子。
- en: The next chapter explores the possibilities of managing and verifying data and
    records through blockchain.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将探讨通过区块链管理和验证数据和记录的可能性。
- en: References
  id: totrans-435
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考文献
- en: Cyber Management Alliance, 2020\. [https://www.cm-alliance.com](https://www.cm-alliance.com).
    Accessed on 03 June 2020.
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 网络安全联盟，2020. [https://www.cm-alliance.com](https://www.cm-alliance.com)。访问日期：2020年6月3日。
- en: GNU Library, 2022\. [https://gmplib.org](https://gmplib.org). Accessed on 01
    April 2022.
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: GNU库，2022. [https://gmplib.org](https://gmplib.org)。访问日期：2022年4月1日。
- en: IBM, 2022\. [https://www.ibm.com](https://www.ibm.com). Accessed on 20 March
    2022.
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: IBM, 2022. [https://www.ibm.com](https://www.ibm.com). 访问日期：2022年3月20日。
- en: Techtarget, 2022\. RSA algorithm (Rivest-Shamir-Adleman). [https://www.techtarget.com](https://www.techtarget.com)/searchsecurity/definition/RSA.
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Techtarget, 2022. RSA算法（Rivest-Shamir-Adleman）。[https://www.techtarget.com](https://www.techtarget.com)/searchsecurity/definition/RSA。
