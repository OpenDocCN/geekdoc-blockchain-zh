- en: © The Author(s), under exclusive license to APress Media, LLC, part of Springer
    Nature 2021B. SitnikovskiIntroducing Blockchain with Lisp[https://doi.org/10.1007/978-1-4842-6969-5_4](https://doi.org/10.1007/978-1-4842-6969-5_4)
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: © 作者，独家许可由 APress Media, LLC 持有，隶属于 Springer Nature 2021B。Sitnikovski 以 Lisp
    介绍区块链[https://doi.org/10.1007/978-1-4842-6969-5_4](https://doi.org/10.1007/978-1-4842-6969-5_4)
- en: 4. Extending the Blockchain
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4. 扩展区块链
- en: Boro Sitnikovski^([1](#Aff2)  )(1)Skopje, North Macedonia![../images/510363_1_En_4_Chapter/510363_1_En_4_Figa_HTML.jpg](../images/510363_1_En_4_Chapter/510363_1_En_4_Figa_HTML.jpg)
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Boro Sitnikovski^([1](#Aff2)  )(1) 马其顿首都斯科普里![../images/510363_1_En_4_Chapter/510363_1_En_4_Figa_HTML.jpg](../images/510363_1_En_4_Chapter/510363_1_En_4_Figa_HTML.jpg)
- en: '*Extensions, by D. Bozhinovski*'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*扩展，作者 D. Bozhinovski*'
- en: In the previous chapter, we implemented blockchain’s basic components. In this
    chapter, we will extend the blockchain with smart contracts and peer-to-peer support.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们实现了区块链的基本组件。在本章中，我们将通过智能合约和点对点支持来扩展区块链。
- en: 4.1 Smart Contracts Implementation
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1 智能合约的实现
- en: Bitcoin’s blockchain is programmable, which means that the transaction conditions
    themselves can be programmed by users. For example, users can write *scripts*
    (short pieces of code) to add requirements that must be satisfied before making
    a transaction.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币的区块链是可编程的，这意味着交易条件本身可以由用户编程。例如，用户可以编写*脚本*（短小的代码片段）来添加在进行交易之前必须满足的要求。
- en: In Section 2.4, we created an executable that we can send to our friends, but
    they cannot change the executable because they don’t have the original code. And
    even if they did have the original code, not all users have programming skills.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 2.4 节，我们创建了一个可执行文件，可以发送给我们的朋友，但他们无法更改可执行文件，因为他们没有原始代码。即使他们有原始代码，也并非所有用户都具有编程技能。
- en: The point of smart contracts is to allow non-programmers to adjust the behavior
    of the transactional process without having to change the original code.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约的要点是允许非程序员调整交易流程的行为，而无需更改原始代码。
- en: 4.1.1 The smart-contracts.rkt File
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.1 smart-contracts.rkt 文件
- en: 'The idea is to implement a small language, which users can consume. Our implementation
    will depend on transactions:1   (**require** "transaction.rkt")We have to extend
    the original valid-transaction? so that it will also consider contracts when calculating
    validity:1   (**define** (valid-transaction-contract? t c)2     (**and** (eval-contract
    t c)3          (valid-transaction? t)))We will now implement a procedure that
    will accept a transaction, a contract, a scripting language (which is really just
    an S-expression), and return some value. The returned value can be true, false,
    a number, or a string. 1   (**define** (eval-contract t c) 2     (**match** c 3       [(?
    number? x) x] 4       [(? string? x) x] 5       [`() #t] 6       [`true #t] 7       [`false
    #f] 8       [`(if ,co ,tr ,fa) (**if** co tr fa)] 9       [`(+ ,l ,r) (+ l r)]10       [**else**
    #f]))'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '这个想法是实现一个小语言，用户可以使用。我们的实现将依赖于事务：1   (**require** "transaction.rkt")我们必须扩展原始的valid-transaction?，使其在计算有效性时也考虑合同：1   (**define**
    (valid-transaction-contract? t c)2     (**and** (eval-contract t c)3          (valid-transaction?
    t)))现在我们将实现一个过程，它将接受一个事务、一个合同、一个脚本语言（实际上只是一个S表达式），并返回一些值。返回的值可以是true、false、数字或字符串。1   (**define**
    (eval-contract t c) 2     (**match** c 3       [(? number? x) x] 4       [(? string?
    x) x] 5       [`() #t] 6       [`true #t] 7       [`false #f] 8       [`(if ,co
    ,tr ,fa) (**if** co tr fa)] 9       [`(+ ,l ,r) (+ l r)]10       [**else** #f]))'
- en: 'We used new syntax here, called match. It is similar to cond, except that it
    can directly compare the structure of an object. For example, ? <expr> <pat> matches
    when <expr> is true and stores the value in <pat>. In the previous code, if we
    pass a number, it will return that same number. Additionally, if we pass the value
    true (i.e., c matches true), then it will return #t. Another example is if c matches
    a structure of the form (if X Y Z) (quoted^([1](#Fn1))), then it will return the
    evaluation of (if X Y Z).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用了称为匹配(match)的新语法。它类似于cond，不同之处在于它可以直接比较对象的结构。例如，? <expr> <pat> 在<expr>为真时匹配并将值存储在<pat>中。在前面的代码中，如果我们传递一个数字，它将返回相同的数字。另外，如果我们传递true值（即c匹配true），那么它将返回#t。另一个例子是如果c匹配形式为(if
    X Y Z)的结构（引用自[1](#Fn1)），那么它将返回(if X Y Z)的评估结果。
- en: 'Here are a few example uses: 1   > (**define** test-transaction (transaction
    "BoroS" "Boro" "You" "a book" 2     ''() ''())) 3   > (eval-contract test-transaction
    123) 4   123 5   > (eval-contract test-transaction "Hi") 6   "Hi" 7   > (eval-contract
    test-transaction ''()) 8   #t 9   > (eval-contract test-transaction ''true)10   #t11   >
    (eval-contract test-transaction ''false)12   #f13   > (eval-contract test-transaction
    ''(if #t "Hi" "Hey"))14   "Hi"15   > (eval-contract test-transaction ''(if #f
    "Hi" "Hey"))16   "Hey"17   > (eval-contract test-transaction ''(+ 1 2))18   3However,
    we still haven’t used any of the transaction’s values in our language. Let’s extend
    it with a few more commands:1   ...2        [`from (transaction-from t)]3        [`to
    (transaction-to t)]4        [`value (transaction-value t)]5   ...Now we can do
    something like this:1   > (eval-contract test-transaction ''from)2   "Boro"3   >
    (eval-contract test-transaction ''to)4   "You"5   > (eval-contract test-transaction
    ''value)6   "a book"We will implement a few more operators so that the scripting
    language becomes more expressive:1   ...2        [`(* ,l ,r) (* l r)]3        [`(-
    ,l ,r) (- l r)]4        [`(= ,l ,r) (equal? l r)]5        [`(> ,l ,r) (> l r)]6        [`(<
    ,l ,r) (< l r)]7        [`(and ,l ,r) (**and** l r)]8        [`(or ,l ,r) (**or**
    l r)]9   ...However, there is a problem in the language implementation. Consider
    the evaluations of (+ 1 2) and (+ (+ 1 2) 3):1   > (eval-contract test-transaction
    ''(+ 1 2))2   33   > (eval-contract test-transaction ''(+ (+ 1 2) 3))4   . . +:
    **contract** violation'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '这里有几个示例用法：1   > (**define** test-transaction (transaction "BoroS" "Boro" "You"
    "a book" 2     ''() ''())) 3   > (eval-contract test-transaction 123) 4   123 5   >
    (eval-contract test-transaction "Hi") 6   "Hi" 7   > (eval-contract test-transaction
    ''()) 8   #t 9   > (eval-contract test-transaction ''true)10   #t11   > (eval-contract
    test-transaction ''false)12   #f13   > (eval-contract test-transaction ''(if #t
    "Hi" "Hey"))14   "Hi"15   > (eval-contract test-transaction ''(if #f "Hi" "Hey"))16   "Hey"17   >
    (eval-contract test-transaction ''(+ 1 2))18   3然而，我们仍然没有在我们的语言中使用任何交易的值。让我们用几个更多的命令来扩展它：1   ...2        [`from
    (transaction-from t)]3        [`to (transaction-to t)]4        [`value (transaction-value
    t)]5   ...现在我们可以这样做：1   > (eval-contract test-transaction ''from)2   "Boro"3   >
    (eval-contract test-transaction ''to)4   "You"5   > (eval-contract test-transaction
    ''value)6   "a book"我们将实现更多的操作符，以使脚本语言变得更具表现力：1   ...2        [`(* ,l ,r) (* l
    r)]3        [`(- ,l ,r) (- l r)]4        [`(= ,l ,r) (equal? l r)]5        [`(>
    ,l ,r) (> l r)]6        [`(\< ,l ,r) (\< l r)]7        [`(and ,l ,r) (**and**
    l r)]8        [`(or ,l ,r) (**or** l r)]9   ...然而，在语言实现中存在问题。考虑到(+ 1 2)和(+ (+
    1 2) 3)的计算：1   > (eval-contract test-transaction ''(+ 1 2))2   33   > (eval-contract
    test-transaction ''(+ (+ 1 2) 3))4   . . +: **contract** violation'
- en: The problem happens in the matching clause [`(+ ,l ,r) (+ l r)]. When we match
    against '(+ (+ 1 2) 3)), we end up with (+ '(+ 1 2) 3), and Racket cannot sum
    a quoted list with a number. The solution to this problem is to *recursively*
    evaluate every subexpression. So the match turns from [`(+ ,l ,r) (+ l r)] to
    [`(+ ,l ,r) (+ (eval-contract t l) (eval-contract t r))].
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配子句[`(+ ,l ,r) (+ l r)]出现问题。当我们匹配 '(+ (+ 1 2) 3)) 时，我们得到了 (+ '(+ 1 2) 3)，而
    Racket 不能将一个带引号的列表与一个数字相加。解决此问题的方法是对每个子表达式进行*递归*评估。因此，匹配从[`(+ ,l ,r) (+ l r)]变为[`(+
    ,l ,r) (+ (eval-contract t l) (eval-contract t r))]。
- en: In this case, the evaluation will happen as follows:1   (eval-contract t '(+
    (+ 1 2) 3))2   = (eval-contract t (list '+ (eval-contract t '(+ 1 2))3                               (eval-contract
    t 3)))4   = (eval-contract t (list '+ (+ 1 2) 3))5   = (eval-contract t (list
    '+ 3 3))6   = (eval-contract t '(+ 3 3))7   = (eval-contract t 6)8   = 6
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，评估将按如下进行：1   (eval-contract t '(+ (+ 1 2) 3))2   = (eval-contract t (list
    '+ (eval-contract t '(+ 1 2))3                               (eval-contract t
    3)))4   = (eval-contract t (list '+ (+ 1 2) 3))5   = (eval-contract t (list '+
    3 3))6   = (eval-contract t '(+ 3 3))7   = (eval-contract t 6)8   = 6
- en: It is important to remember the distinction between a quoted list and a non-quoted
    one; the latter will attempt evaluation. In this case, we juggled the quotations
    to produce the desired results.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 记住引用列表和非引用列表之间的区别是很重要的；后者将尝试评估。在这种情况下，我们调整了引号以产生期望的结果。
- en: 'We will have to rewrite all of the operators: 1   ... 2        [`(+ ,l ,r)
    (+ (eval-contract t l) (eval-contract t r))] 3        [`(* ,l ,r) (* (eval-contract
    t l) (eval-contract t r))] 4        [`(- ,l ,r) (- (eval-contract t l) (eval-contract
    t r))] 5        [`(= ,l ,r) (= (eval-contract t l) (eval-contract t r))] 6        [`(>
    ,l ,r) (> (eval-contract t l) (eval-contract t r))] 7        [`(< ,l ,r) (< (eval-contract
    t l) (eval-contract t r))] 8        [`(**and** ,l ,r) (and (eval-contract t l)
    (eval-contract t r))] 9        [`(**or** ,l ,r) (or (eval-contract t l) (eval-contract
    t r))]10   ...The if implementation in the language has the same problem. So we
    will also change it:1   ...2        [`(if ,co ,tr ,fa) (**if** (eval-contract
    t co)3                           (eval-contract t tr)4                           (eval-contract
    t fa))]5   ...Thus, the final procedure becomes: 1   (**define** (eval-contract
    t c) 2     (**match** c 3       [(? number? x) x] 4       [(? string? x) x] 5       [`()
    #t] 6       [`true #t] 7       [`false #f] 8       [`(if ,co ,tr ,fa) (**if**
    (eval-contract t co) 9                              (eval-contract t tr)10                              (eval-contract
    t fa))]11       [`(+ ,l ,r) (+ (eval-contract t l) (eval-contract t r))]12       [`from
    (transaction-from t)]13       [`to (transaction-to t)]14       [`value (transaction-value
    t)]15       [`(+ ,l ,r) (+ (eval-contract t l) (eval-contract t r))]16       [`(*
    ,l ,r) (* (eval-contract t l) (eval-contract t r))]17       [`(- ,l ,r) (- (eval-contract
    t l) (eval-contract t r))]18       [`(= ,l ,r) (= (eval-contract t l) (eval-contract
    t r))]19       [`(> ,l ,r) (> (eval-contract t l) (eval-contract t r))]20       [`(<
    ,l ,r) (< (eval-contract t l) (eval-contract t r))]21       [`(**and** ,l ,r)
    (and (eval-contract t l) (eval-contract t r))]22       [`(**or** ,l ,r) (or (eval-contract
    t l) (eval-contract t r))]23       [**else** #f]))Users can now supply scripting
    code, such as (if (= (+ 1 2) 3) from to):1   > (eval-contract test-transaction
    ''(if (= (+ 1 2) 3) from to))2   "Boro"3   > (eval-contract test-transaction ''(if
    (= (+ 1 2) 4) from to))4   "You"Finally, we provide the output, which is just
    the transaction validity check:1   (**provide** valid-transaction-contract?)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '我们将不得不重新编写所有的运算符： 1   ... 2        [`(+ ,l ,r) (+ (eval-contract t l) (eval-contract
    t r))] 3        [`(* ,l ,r) (* (eval-contract t l) (eval-contract t r))] 4        [`(-
    ,l ,r) (- (eval-contract t l) (eval-contract t r))] 5        [`(= ,l ,r) (= (eval-contract
    t l) (eval-contract t r))] 6        [`(> ,l ,r) (> (eval-contract t l) (eval-contract
    t r))] 7        [`(< ,l ,r) (< (eval-contract t l) (eval-contract t r))] 8        [`(**and**
    ,l ,r) (and (eval-contract t l) (eval-contract t r))] 9        [`(**or** ,l ,r)
    (or (eval-contract t l) (eval-contract t r))]10   ...语言中的 if 实现也存在相同的问题。因此，我们也会更改它：1   ...2        [`(if
    ,co ,tr ,fa) (**if** (eval-contract t co)3                           (eval-contract
    t tr)4                           (eval-contract t fa))]5   ...因此，最终的过程变为： 1   (**define**
    (eval-contract t c) 2     (**match** c 3       [(? number? x) x] 4       [(? string?
    x) x] 5       [`() #t] 6       [`true #t] 7       [`false #f] 8       [`(if ,co
    ,tr ,fa) (**if** (eval-contract t co) 9                              (eval-contract
    t tr)10                              (eval-contract t fa))]11       [`(+ ,l ,r)
    (+ (eval-contract t l) (eval-contract t r))]12       [`from (transaction-from
    t)]13       [`to (transaction-to t)]14       [`value (transaction-value t)]15       [`(+
    ,l ,r) (+ (eval-contract t l) (eval-contract t r))]16       [`(* ,l ,r) (* (eval-contract
    t l) (eval-contract t r))]17       [`(- ,l ,r) (- (eval-contract t l) (eval-contract
    t r))]18       [`(= ,l ,r) (= (eval-contract t l) (eval-contract t r))]19       [`(>
    ,l ,r) (> (eval-contract t l) (eval-contract t r))]20       [`(< ,l ,r) (< (eval-contract
    t l) (eval-contract t r))]21       [`(**and** ,l ,r) (and (eval-contract t l)
    (eval-contract t r))]22       [`(**or** ,l ,r) (or (eval-contract t l) (eval-contract
    t r))]23       [**else** #f]))现在用户可以提供脚本代码，比如 (if (= (+ 1 2) 3) from to)：1   >
    (eval-contract test-transaction ''(if (= (+ 1 2) 3) from to))2   "Boro"3   > (eval-contract
    test-transaction ''(if (= (+ 1 2) 4) from to))4   "You"最后，我们提供输出，这只是交易有效性检查：1   (**provide**
    valid-transaction-contract?)'
- en: 4.1.2 Updating Existing Code
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.2 更新现有代码
- en: Now that we have implemented the logic for smart contracts, the next thing we
    need to address is the front-end—how users can use its functionality. For that
    matter, we will update the implementation to support contracts by reading from
    a file. If a file named contract.script exists, we will read and parse it (with
    read) and then run the code.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实现了智能合约的逻辑，接下来需要解决的是前端——用户如何使用其功能。为此，我们将更新实现以支持通过读取文件来使用合约。如果存在名为 contract.script
    的文件，我们将读取并解析它（使用 read），然后运行代码。
- en: We will rewrite the money sending procedure in blockchain.rkt to accept contracts.
    It’s the same procedure except that we use valid-transaction-contract? instead
    of valid-transaction?. 1   (**define** (send-money-blockchain b from to value
    c) 2     (**letrec** ([my-ts 3               (filter (**lambda** (t) (equal? from
    (transaction-io-owner t))) 4                       (blockchain-utxo b))] 5               [t
    (make-transaction from to value my-ts)]) 6       (**if** (transaction? t) 7           (**let**
    ([processed-transaction (process-transaction t)]) 8             (**if** (**and** 9                  (>=
    (balance-wallet-blockchain b from) value)10                  (valid-transaction-contract?
    processed-transaction c))11                  (add-transaction-to-blockchain b
    processed-transaction)12                  b))13           (add-transaction-to-blockchain
    b '()))))Next, we will update utils.rkt to add this helper procedure for reading
    contracts:1   (**define** (file->contract file)2     (**with-handlers** ([exn:fail?
    (**lambda** (exn) '())])3       (read (open-input-file **file**))))
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 blockchain.rkt 中重新编写发送货币的过程以接受合约。这是相同的过程，只是我们使用 valid-transaction-contract?
    代替 valid-transaction?。
- en: Here, we used with-handlers, which accepts a procedure that handles the case
    when something may fail—in this case, read or open-input-file.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了 with-handlers，它接受一个处理当某些事情可能失败时的过程——在本例中为 read 或 open-input-file。
- en: Finally, make sure to add file->contract to the list of provides in utils.rkt.
    Additionally, in main.rkt update every use of send-money-blockchain to additionally
    send (file->contract "contract.script") as an argument so that the contract processed
    is the one read from contract.script.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请确保将 file->contract 添加到 utils.rkt 中提供的列表中。此外，在 main.rkt 中更新每次使用 send-money-blockchain
    时，额外发送 (file->contract "contract.script") 作为参数，以便处理的合约是从 contract.script 中读取的那个。
- en: We will also need to update blockchain.rkt and main.rkt because they now rely
    on a procedure implemented in the smart contracts package. We will add (require
    "smart-contracts.rkt") to them.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要更新 blockchain.rkt 和 main.rkt，因为它们现在依赖于智能合约包中实现的一个过程。我们将在它们中添加 (require
    "smart-contracts.rkt")。
- en: '![../images/510363_1_En_4_Chapter/510363_1_En_4_Figb_HTML.gif](../images/510363_1_En_4_Chapter/510363_1_En_4_Figb_HTML.gif)Exercise
    4-1'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '![../images/510363_1_En_4_Chapter/510363_1_En_4_Figb_HTML.gif](../images/510363_1_En_4_Chapter/510363_1_En_4_Figb_HTML.gif)练习
    4-1'
- en: Come up with a few valid expressions and evaluate them using eval-contract.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 想出几个有效的表达式，并使用 eval-contract 来评估它们。
- en: '![../images/510363_1_En_4_Chapter/510363_1_En_4_Figc_HTML.gif](../images/510363_1_En_4_Chapter/510363_1_En_4_Figc_HTML.gif)Exercise
    4-2'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '![../images/510363_1_En_4_Chapter/510363_1_En_4_Figc_HTML.gif](../images/510363_1_En_4_Chapter/510363_1_En_4_Figc_HTML.gif)练习
    4-2'
- en: Repeat the previous exercise, but use the contract.script file.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 重复上一个练习，但使用 contract.script 文件。
- en: '**Hint**: This exercise might require you to create an executable.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**：此练习可能需要您创建一个可执行文件。'
- en: 4.2 Peer-to-Peer Implementation
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2 对等体实现
- en: In Section 3.6.2, we used DrRacket to execute the blockchain implementation.
    That’s okay for testing purposes. However, if we wanted to share that implementation
    with other users and ask them to execute it, it will be kind of inconvenient because
    there’s no way to share data between different users.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 3.6.2 节，我们使用 DrRacket 来执行区块链实现。这对于测试目的来说没问题。但是，如果我们想要与其他用户分享该实现并要求他们执行它，那将会有点不方便，因为没有办法在不同用户之间共享数据。
- en: In this section, we will implement peer-to-peer support so that users who are
    interested in our implementation can join the system/community.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将实现对等支持，以便对我们的实现感兴趣的用户可以加入系统/社区。
- en: Before we dive into the implementation, Figure [4-1](#Fig1) shows a high overview
    of the architecture that we will build.![../images/510363_1_En_4_Chapter/510363_1_En_4_Fig1_HTML.jpg](../images/510363_1_En_4_Chapter/510363_1_En_4_Fig1_HTML.jpg)
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入实现之前，图 [4-1](#Fig1) 展示了我们将构建的架构的高层概述。![../images/510363_1_En_4_Chapter/510363_1_En_4_Fig1_HTML.jpg](../images/510363_1_En_4_Chapter/510363_1_En_4_Fig1_HTML.jpg)
- en: Figure 4-1
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-1
- en: Peer-to-peer architecture
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 对等体架构
- en: 'Every peer node (user connected to the system) list will consist of the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 每个对等节点（连接到系统的用户）列表将包括以下内容：
- en: '*Peer context data* *:* Information such as relations with other peers, list
    of connected peers, and so on.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*对等体上下文数据：* 诸如与其他对等体的关系、连接的对等体列表等信息。'
- en: '*Generic handler:* Transforms the peer context data.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*通用处理程序：* 转换对等体上下文数据。'
- en: 'Further, there will be two ways to establish communication with other peers:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，将有两种与其他对等体建立通信的方式：
- en: A peer will accept new connections from other peers.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对等体将接受来自其他对等体的新连接。
- en: A peer will try to connect/make new connections to other peers.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对等体将尝试连接/建立新的与其他对等体的连接。
- en: Whenever a connection is established, peers will communicate with each other
    through the generic handler, parsing and evaluating commands such as syncing/updating
    the blockchain, updating the list of peers, and so on.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 每当建立连接时，对等方将通过通用处理程序进行通信，解析和评估命令，例如同步/更新区块链，更新对等方列表等。
- en: 'Consider this example scenario: Assume there are three peers—Peer 1, Peer 2,
    and Peer 3\. Peer 1 and Peer 2 are online, and Peer 3 is offline at the moment.
    Peer 1 has the following list of valid peers: (Peer 1, Peer 2, Peer 3). Peer 2’s
    list of peers is empty. According to the diagram, Peer 1 will accept new connections
    and try to connect to peers. So, Peer 1 will try to connect to Peer 2\. This connection
    will be successful, and the next step is for Peer 1 to send some data to Peer
    2 (e.g., the list of valid peers).'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例场景：假设有三个对等方 - 对等方 1、对等方 2 和对等方 3。对等方 1 和对等方 2 在线，对等方 3 目前离线。对等方 1 有以下有效对等方列表：(对等方
    1，对等方 2，对等方 3)。对等方 2 的对等方列表为空。根据图示，对等方 1 将接受新连接并尝试连接到对等方。因此，对等方 1 将尝试连接到对等方 2。此连接将成功，下一步是对等方
    1 向对等方 2 发送一些数据（例如，有效对等方列表）。
- en: Peer 2’s list of peers was empty, but now it will be merged with Peer 1, so
    it will become (Peer 1, Peer 2, Peer 3). Peer 1 and Peer 2 are connected to each
    other, and they will keep trying to connect to Peer 3\. Once Peer 3 becomes available,
    the same algorithm will be executed and Peer 3 will join the network.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 对等方 2 的对等方列表为空，但现在它将与对等方 1 合并，因此它将变为 (对等方 1，对等方 2，对等方 3)。 对等方 1 和对等方 2 互相连接，并且它们将继续尝试连接到对等方
    3。一旦对等方 3 可用，将执行相同的算法，对等方 3 将加入网络。
- en: With this approach, the goal is to build a system similar to the high-level
    description shown in Figures [1-1](#Fig1) and [1-3](510363_1_En_1_Chapter.xhtml#Fig3)
    (Chapter [1](510363_1_En_1_Chapter.xhtml)).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 采用这种方法，目标是构建类似于图 [1-1](#Fig1) 和 [1-3](510363_1_En_1_Chapter.xhtml#Fig3) （第 [1](510363_1_En_1_Chapter.xhtml)
    章）中显示的高级描述的系统。
- en: Building communication systems of this type is naturally complex. It is suggested
    you consult the Racket manuals (by pressing the F1 key) for every procedure that
    you will be using.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 构建这种类型的通信系统自然复杂。建议您为您将使用的每个过程参考 Racket 手册（通过按下 F1 键）。
- en: 4.2.1 The peer-to-peer.rkt File
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.1 对等方对等方.rkt 文件
- en: To start, we will add dependencies for the block implementation and rely on
    serialization to send data to other peers:1   (**require** "blockchain.rkt")2   (**require**
    "block.rkt")3   (**require** racket/serialize)
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们将添加块实现的依赖项，并依靠序列化将数据发送到其他对等方：1   (**require** "blockchain.rkt")2   (**require**
    "block.rkt")3   (**require** racket/serialize)
- en: 4.2.1.1 Peer Context Structure
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.1.1 对等方上下文结构
- en: We will implement structures that hold information about the peers so that we
    have a reference to send data to the correct destinations. The peer-info structure  contains
    an IP address and a port of a peer. Think of an IP address and a port similar
    to a street address and a number, respectively.1   (**struct** peer-info2     (ip
    port)3     **#:prefab**)The peer-info-io structure  additionally contains IO ports
    (think communication channels) for sending and receiving data between peers:1   (**struct**
    peer-info-io2     (peer-info input-port output-port)3     **#:prefab**)
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现保存有关对等方信息的结构，以便我们有一个参考可以将数据发送到正确的目的地。peer-info 结构包含对等方的 IP 地址和端口信息。可以将
    IP 地址和端口类比为街道地址和号码。1   (**结构体** peer-info2     (ip port)3     **#:prefab**)peer-info-io
    结构还包含了用于对等方之间发送和接收数据的 IO 端口（通信通道）：1   (**结构体** peer-info-io2     (peer-info input-port
    output-port)3     **#:prefab**)
- en: The reason we separate peer-info and peer-info-io is that later in main-p2p.rkt,
    we won’t have the context of input/output ports (before a connection to a peer
    is established), so it gives us a nice way to reuse the structure.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 peer-info 和 peer-info-io 分开的原因是，在 main-p2p.rkt 中稍后，我们不会拥有输入/输出端口的上下文（在建立到对等方的连接之前），因此这为我们提供了重用结构的良好方法。
- en: 'Finally, peer-context-data contains all the information needed for a single
    peer, that is:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，peer-context-data 包含了单个对等方所需的所有信息，即：
- en: List of valid peers
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有效对等方列表
- en: List of connected peers
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接的对等方列表
- en: A reference to the blockchain
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 区块链的引用
- en: 1   (**struct** peer-context-data2     (name3      port4      [valid-peers **#:mutable**]5      [connected-peers
    **#:mutable**]6      [blockchain **#:mutable**])7     **#:prefab**)
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 1   (**结构体** peer-context-data2     (name3      port4      [valid-peers **#:mutable**]5      [connected-peers
    **#:mutable**]6      [blockchain **#:mutable**])7     **#:prefab**)
- en: The list^([2](#Fn2)) of valid peers will be updated depending on the information
    retrieved from the connected peers. The list of connected peers will be a (not
    necessarily strict) subset of valid-peers. The blockchain will be updated with
    the data combined from all peers. We make them mutable because it provides an
    easy way to update the data.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 根据从连接的对等方检索到的信息，有效对等方的列表^([2](#Fn2)) 将进行更新。连接的对等方列表将是有效对等方的（不一定严格的）子集。区块链将使用从所有对等方组合的数据进行更新。我们将它们设置为可变的，因为这提供了一种轻松更新数据的方法。
- en: 4.2.1.2 Generic Handler
  id: totrans-56
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.1.2 通用处理器
- en: The generic handler  will be a handler procedure that will be used both by the
    server (the “accepting new connections” part of the diagram) and the client (the
    “connecting to new peers” part of the diagram). It will be a procedure that accepts
    commands (commands similar in nature to the smart contracts’ eval-contract implementation)
    and then does something depending on the command.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 通用处理器将是一个处理器过程，将由服务器（图中的“接受新连接”部分）和客户端（图中的“连接到新对等方”部分）共同使用。它将是一个接受命令的过程（命令的性质类似于智能合约的
    eval-contract 实现），然后根据命令执行相应操作。
- en: 'Here’s a list of commands that peers will send to each other:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是对等方将发送给彼此的命令的列表：
- en: '| **Request** | **Response** | **Notes** |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| **请求** | **响应** | **备注** |'
- en: '| --- | --- | --- |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| get-valid-peers | valid-peers:X | A peer may request a list of valid peers.
    The response will be X – valid peers. Note that this response should automatically
    trigger the valid-peers command. |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| 获取有效的节点 | 有效的节点:X | 一个节点可以请求有效节点的列表。响应将是 X - 有效的节点。请注意，此响应应自动触发有效的节点命令。 |'
- en: '| get-latest-blockchain | latest-blockchain:X | A peer may request the latest
    blockchain from another peer. The response will be X - the latest version of the
    blockchain. This should trigger the latest-blockchain command. |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 获取最新的区块链 | 最新的区块链:X | 一个节点可以向另一个节点请求最新的区块链。响应将是 X - 区块链的最新版本。这应该触发最新的区块链命令。
    |'
- en: '| latest-blockchain:X |   | When a peer gets this request, it will update the
    blockchain, given it is valid. |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| 最新的区块链:X |   | 当一个节点收到此请求时，如果它是有效的，它将更新区块链。 |'
- en: '| valid-peers:X |   | When a peer gets this request, it will update the list
    of valid peers. |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 有效的节点:X |   | 当一个节点收到此请求时，它将更新有效节点列表。 |'
- en: 'The commands  in this table will allow the peers to sync data with each other.
    We will now provide the handler implementation. It accepts a peer-context and
    input/output ports. Given these, it will read the input (command) and send the
    appropriate output (evaluated command) back to the peer: 1   (**define** (handler
    peer-context in out) 2     (flush-output out) 3     (**define** line (read-line
    in)) 4     (**when** (string? line) *; it can be eof* 5       (**cond** [(string-prefix?
    line "get-valid-peers") 6              (fprintf out "valid-peers:~a\n" 7                       (serialize 8                        (set->list 9                         (peer-context-data-valid-peers
    peer-context))))10              (handler peer-context in out)]11             [(string-prefix?
    line "get-latest-blockchain")12              (fprintf out "latest-blockchain:")13              (write14               (serialize
    (peer-context-data-blockchain peer-context)) out)15              (handler peer-context
    in out)]16             [(string-prefix? line "latest-blockchain:")17              (**begin**
    (maybe-update-blockchain peer-context line)18                     (handler peer-context
    in out))]19             [(string-prefix? line "valid-peers:")20              (**begin**
    (maybe-update-valid-peers peer-context line)21                     (handler peer-context
    in out))]22             [(string-prefix? line "exit")23              (fprintf
    out "bye\n")]24             [**else** (handler peer-context in out)])))We used
    some new procedures  here:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这张表中的命令将允许对等体彼此同步数据。我们现在将提供处理程序的实现。它接受一个对等体上下文和输入/输出端口。有了这些，它将读取输入（命令）并将适当的输出（评估后的命令）发送回对等体：1   (**define**
    (handler peer-context in out) 2     (flush-output out) 3     (**define** line
    (read-line in)) 4     (**when** (string? line) *; 它可能是eof* 5       (**cond** [(string-prefix?
    line "get-valid-peers") 6              (fprintf out "valid-peers:~a\n" 7                       (serialize 8                        (set->list 9                         (peer-context-data-valid-peers
    peer-context))))10              (handler peer-context in out)]11             [(string-prefix?
    line "get-latest-blockchain")12              (fprintf out "latest-blockchain:")13              (write14               (serialize
    (peer-context-data-blockchain peer-context)) out)15              (handler peer-context
    in out)]16             [(string-prefix? line "latest-blockchain:")17              (**begin**
    (maybe-update-blockchain peer-context line)18                     (handler peer-context
    in out))]19             [(string-prefix? line "valid-peers:")20              (**begin**
    (maybe-update-valid-peers peer-context line)21                     (handler peer-context
    in out))]22             [(string-prefix? line "exit")23              (fprintf
    out "bye\n")]24             [**else** (handler peer-context in out)])))我们在这里使用了一些新的过程：
- en: An output buffer (output communication channel with a peer) is usually filled
    with bytes. We need to flush (empty) this buffer every time we want to send a
    message, to avoid resending the previous messages. We achieve this using `flush-output`.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出缓冲区（与对等体通信的输出通道）通常由字节填充。每次我们想发送消息时，我们需要刷新（清空）此缓冲区，以避免重新发送先前的消息。我们使用`flush-output`来实现这一点。
- en: read-line is similar to read except that it will stop reading once a newline
    is reached.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`read-line`类似于`read`，但是一旦读取到换行符就会停止读取。'
- en: string-prefix? checks to see if a string starts with some other string.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`string-prefix?`用于检查字符串是否以另一个字符串开头。'
- en: fprintf is similar to printf except that we can also supply the first argument
    to specify where this message should be sent.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: fprintf 类似于 printf，只是我们还可以提供第一个参数来指定消息应该发送到哪里。
- en: set->list converts a set to a list.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: set->list 将一个集合转换为一个列表。
- en: There’s a little trick involved in the latest-blockchain case—we used write
    instead of (fprintf out "latest-blockchain:∼a\n"). The reason for that is that
    print (and thus printf and fprintf) cannot be relied on for output that needs
    to be formatted in a specific way. For example  , print prints strings with quotation
    marks (to make the printed data more legible to the user), and this will be messed
    up when we try to deserialize the data we received, so we want to send the data
    in its “raw” format.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在 latest-blockchain 情况中涉及到一个小技巧 —— 我们使用了 write 而不是 (fprintf out "latest-blockchain:∼a\n")。其原因是
    print（以及 printf 和 fprintf）不能保证以特定方式格式化输出。例如，print 打印带有引号的字符串（以使打印的数据对用户更易读），当我们尝试对接收到的数据进行反序列化时，这会混乱，因此我们希望以“原始”格式发送数据。
- en: 'The next step is to implement procedures for updating the blockchain and the
    list of valid peers, under the conditions that the blockchain is valid and it
    has higher effort than ours. 1   (**define** (maybe-update-blockchain peer-context
    line) 2     (**let** ([latest-blockchain 3            (trim-helper line #rx"(latest-blockchain:|[\r\n]+)")] 4           [current-blockchain 5            (peer-context-data-blockchain
    peer-context)]) 6       (**when** (**and** (valid-blockchain? latest-blockchain) 7                   (>
    (get-blockchain-effort latest-blockchain) 8                      (get-blockchain-effort
    current-blockchain))) 9         (printf "Blockchain updated for peer ~a\n"10                 (peer-context-data-name
    peer-context))11         (set-peer-context-data-blockchain! peer-context12                                            latest-blockchain))))'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '下一步是在区块链有效且具有更高工作量的情况下，实现更新区块链和有效对等方列表的程序。 1 (**定义** (maybe-update-blockchain
    peer-context line) 2 (**让** ([latest-blockchain 3 (trim-helper line #rx"(latest-blockchain:|[\r\n]+)")]
    4 [current-blockchain 5 (peer-context-data-blockchain peer-context)]) 6 (**当**
    (**和** (valid-blockchain? latest-blockchain) 7 (> (get-blockchain-effort latest-blockchain)
    8 (get-blockchain-effort current-blockchain))) 9 (printf "已更新对等方 ~a 的区块链\n" 10
    (peer-context-data-name peer-context)) 11 (set-peer-context-data-blockchain! peer-context
    12 latest-blockchain))))'
- en: 'We used #rx"..." for the first time—this specifies a regular expression. Think
    of it as a way to define a search pattern in some string.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '我们首次使用了 #rx"..."，这指定了一个正则表达式。将其视为在某个字符串中定义搜索模式的一种方式。'
- en: 'For example, #rx"(latest-blockchain:|[\r\n]+)" matches the following strings:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，#rx"(latest-blockchain:|[\r\n]+)" 匹配以下字符串：
- en: latest-blockchain:a\n
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: latest-blockchain:a\n
- en: latest-blockchain:b\n
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: latest-blockchain:b\n
- en: In general, latest-blockchain:...\n
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一般来说，latest-blockchain:...\n
- en: 'The previous procedure  will update the blockchain only when it is valid and
    the effort is higher than the current one. We define the effort as the sum of
    all blocks’ nonces:1   (**define** (get-blockchain-effort b)2     (foldl + 0 (map
    block-nonce (blockchain-blocks b))))To update the list of valid peers is to merge
    the current list of valid peers with the newly received list, thus mutating the
    peer-context structure  :1   (**define** (maybe-update-valid-peers peer-context
    line)2     (**let** ([valid-peers (list->set3                         (trim-helper
    line #rx"(valid-peers:|[\r\n]+)"))]4           [current-valid-peers (peer-context-data-valid-peers5                                 peer-context)])6       (set-peer-context-data-valid-peers!7        peer-context8        (set-union
    current-valid-peers valid-peers))))We also used this procedure, which is just
    a helper one that will remove a command (prefix) from a string, allowing us to
    focus on the input. For example, when we receive valid-peers:X, it will remove
    valid-peers:, allowing us to retrieve X easily.1   (**define** (trim-helper line
    x)2     (deserialize3      (read4       (open-input-string5        (string-replace
    line x "")))))'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '上述过程仅在区块链有效且努力大于当前区块链时才会更新区块链。我们将努力定义为所有区块的nonce之和：1   (**define** (get-blockchain-effort
    b)2     (foldl + 0 (map block-nonce (blockchain-blocks b))))更新有效同行列表是将当前有效同行列表与新接收的列表合并，从而改变同行上下文结构：1   (**define**
    (maybe-update-valid-peers peer-context line)2     (**let** ([valid-peers (list->set3                         (trim-helper
    line #rx"(valid-peers:|[\r\n]+)"))]4           [current-valid-peers (peer-context-data-valid-peers5                                 peer-context)])6       (set-peer-context-data-valid-peers!7        peer-context8        (set-union
    current-valid-peers valid-peers))))我们还使用了这个过程，这只是一个辅助过程，它将从字符串中删除命令（前缀），使我们能够专注于输入。例如，当我们接收到
    valid-peers:X 时，它将删除 valid-peers:，使我们可以轻松检索 X。1   (**define** (trim-helper line
    x)2     (deserialize3      (read4       (open-input-string5        (string-replace
    line x "")))))'
- en: This concludes the handler implementation. Now there is a procedure that can
    be used by peers to accept commands and update the list of peers and the blockchain.
    In the next section, we will implement the communication between the peers—they
    should communicate with each other using these commands that we implemented  .
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了处理程序的实现。现在有一个流程可供同行使用，接受命令并更新同行和区块链的列表。在下一节中，我们将实现同行之间的通信——他们应该使用我们实现的这些命令相互通信。
- en: 4.2.1.3 Server Implementation
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.1.3 服务器实现
- en: 'When a peer connects to another peer (a server), here’s what should happen:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个同行连接到另一个同行（服务器）时，应该发生以下情况：
- en: '1.'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '1.'
- en: The server should wait for the incoming peer to send some command.
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 服务器应该等待传入的同行发送一些命令。
- en: '2.'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '2.'
- en: The server should use the handler procedure to handle the necessary data.
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 服务器应该使用处理程序来处理必要的数据。
- en: '3.'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '3.'
- en: The server should send the transformed data back to the incoming peer.
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 服务器应该将转换后的数据发送回传入的同行。
- en: However, if more than one peer connects, then the procedure will “block,” in
    the sense that the second peer will have to wait for the first one to be served,
    the third will have to wait for the second, and so on.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果多个对等体连接，则该过程将“阻塞”，即第二个对等体必须等待第一个被服务，第三个必须等待第二个，依此类推。
- en: To resolve this issue, we turn to threads. accept-and-handle is the main procedure
    that will serve the incoming peers. The procedure accepts a connection (listener
    object) and a peer context and launches handler in a thread for every incoming
    connection:1   (**define** (accept-and-handle listener peer-context)2     (**define-values**
    (in out) (tcp-accept listener))3     (thread4      (**lambda** ()5        (handler
    peer-context in out)6        (close-input-port in)7        (close-output-port
    out))))
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们转向线程。accept-and-handle 是主要的过程，用于为传入的对等体提供服务。该过程接受一个连接（监听器对象）和一个对等体上下文，并为每个传入连接启动一个处理程序线程：1   (**define**
    (accept-and-handle listener peer-context)2     (**define-values** (in out) (tcp-accept
    listener))3     (thread4      (**lambda** ()5        (handler peer-context in
    out)6        (close-input-port in)7        (close-output-port out))))
- en: We used a new procedure called tcp-accept that accepts a connection and returns
    the input (to read data) and the output ports (to send data). Using the define-values
    syntax, we store both of these values.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了一个名为 tcp-accept 的新过程，它接受一个连接并返回输入（用于读取数据）和输出端口（用于发送数据）。使用 define-values
    语法，我们存储了这两个值。
- en: 'peers/serve is the main server listener. This is straight copy-pasted from
    the Racket documentation, and the curious reader can navigate to the documentation
    and read more about the implementation details. In short, a *custodian* is a kind
    of container that ensures there are no bogus threads or input/output ports in
    the memory and takes care of this for us. 1   (**define** (peers/serve peer-context) 2     (**define**
    main-cust (make-custodian)) 3     (**parameterize** ([current-custodian main-cust]) 4       (**define**
    listener 5         (tcp-listen (peer-context-data-port peer-context) 5 #t)) 6       (**define**
    (loop) 7         (accept-and-handle listener peer-context) 8         (loop)) 9       (thread
    loop))10     (**lambda** ()11       (custodian-shutdown-all main-cust)))'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 'peers/serve 是主服务器监听器。这直接从 Racket 文档中复制粘贴过来的，并且对于好奇的读者可以导航到文档并阅读更多关于实现细节的内容。简而言之，*custodian*
    是一种容器，确保内存中没有虚假的线程或输入/输出端口，并且为我们处理这些。1   (**define** (peers/serve peer-context) 2     (**define**
    main-cust (make-custodian)) 3     (**parameterize** ([current-custodian main-cust]) 4       (**define**
    listener 5         (tcp-listen (peer-context-data-port peer-context) 5 #t)) 6       (**define**
    (loop) 7         (accept-and-handle listener peer-context) 8         (loop)) 9       (thread
    loop))10     (**lambda** ()11       (custodian-shutdown-all main-cust)))'
- en: The tcp-listen procedure  keeps listening to a specific port for new incoming
    connections.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: tcp-listen 过程持续监听特定端口，以获取新的传入连接。
- en: 4.2.1.4 Client Implementation
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.1.4 客户端实现
- en: 'Next  , we will implement connect-and-handle—a procedure that tries to connect
    to other peers, whereas previously we constructed a procedure that was supposed
    to serve incoming peers. This procedure will be similar to accept-and-handle,
    but kind of dual, in that it does not accept new connections. Rather, it tries
    to make a new connection: 1   (**define** (connect-and-handle peer-context peer) 2     (**begin** 3       (**define-values**
    (in out) 4         (tcp-connect (peer-info-ip peer) 5                      (peer-info-port
    peer))) 6 7       (**define** current-peer-io (peer-info-io peer in out)) 8 9       (set-peer-context-data-connected-peers!10        peer-context11        (cons
    current-peer-io12              (peer-context-data-connected-peers peer-context)))1314        (thread15         (**lambda**
    ()16           (handler peer-context in out)17           (close-input-port in)18           (close-output-port
    out)1920           (set-peer-context-data-connected-peers!21            peer-context22            (set-remove23             (peer-context-data-connected-peers
    peer-context)24             current-peer-io))))))This procedure is quite long
    so it deserves some unpacking:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将实现`connect-and-handle`——一种尝试连接其他对等节点的过程，而之前我们构建的是一个用于服务传入对等节点的过程。这个过程类似于`accept-and-handle`，但有些双重，因为它不接受新的连接。相反，它试图建立新的连接： 1   (**define**
    (connect-and-handle peer-context peer) 2     (**begin** 3       (**define-values**
    (in out) 4         (tcp-connect (peer-info-ip peer) 5                      (peer-info-port
    peer))) 6 7       (**define** current-peer-io (peer-info-io peer in out)) 8 9       (set-peer-context-data-connected-peers!10        peer-context11        (cons
    current-peer-io12              (peer-context-data-connected-peers peer-context)))1314        (thread15         (**lambda**
    ()16           (handler peer-context in out)17           (close-input-port in)18           (close-output-port
    out)1920           (set-peer-context-data-connected-peers!21            peer-context22            (set-remove23             (peer-context-data-connected-peers
    peer-context)24             current-peer-io))))))这个过程相当长，因此值得拆分一下：
- en: '1.'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '1.'
- en: The tcp-connect procedure tries to make a connection to a specific IP address
    and port (values that we extract from the peer-info structure).
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`tcp-connect`过程试图连接到特定的IP地址和端口（我们从`peer-info`结构中提取的值）。'
- en: '2.'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '2.'
- en: When the connection is successful, tcp-connect will return the input and output
    ports, which we can use to read data from and write data to, respectively.
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当连接成功时，`tcp-connect`将返回输入和输出端口，我们可以分别用于读取数据和写入数据。
- en: '3.'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '3.'
- en: Next, the specific list of connected peers for the current context will be updated.
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，当前上下文的已连接对等节点的具体列表将被更新。
- en: '4.'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '4.'
- en: Finally, we launch a thread, using handler to handle the communication. When
    the connection is finished, we do a cleanup and remove the peer from the list
    of peers.
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，我们启动一个线程，使用`handler`来处理通信。当连接结束时，我们进行清理，并从对等节点列表中移除对等节点。
- en: 'The next procedure is to make sure we’re connected with all known peers. We
    use threads, again, for the same reason as in the server—we do not want this procedure
    to block the program from connecting to other clients while it tries to connect
    to one. This procedure is dual to peers/serve, and tcp-connect is dual to tcp-accept.
    We use sleep to wait for a few seconds before processing again in order to make
    the process more performant. 1   (**define** (peers/connect peer-context) 2     (**define**
    main-cust (make-custodian)) 3     (**parameterize** ([current-custodian main-cust]) 4       (**define**
    (loop) 5         (**let** ([potential-peers (get-potential-peers peer-context)]) 6           (**for**
    ([peer potential-peers]) 7             (**with-handlers** ([exn:fail? (**lambda**
    (x) #t)]) 8               (connect-and-handle peer-context peer)))) 9         (sleep
    10)10         (loop))11       (thread loop))12     (**lambda** ()13       (custodian-shutdown-all
    main-cust)))To implement get-potential-peers, we first get the list of connected
    and valid peers from the peer context. The valid peers that are not in the list
    of connected peers are potential peers we can make new connections with.1   (**define**
    (get-potential-peers peer-context)2     (**let** ([current-connected-peers3            (list->set4             (map
    peer-info-io-peer-info5                  (peer-context-data-connected-peers peer-context)))]6           [valid-peers
    (peer-context-data-valid-peers peer-context)])7       (set-subtract valid-peers
    current-connected-peers)))'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '下一步是确保我们与所有已知的对等体连接。我们再次使用线程，出于与服务器相同的原因——我们不希望此过程阻止程序在尝试连接一个客户端时连接到其他客户端。此过程对等于
    peers/serve，而 tcp-connect 对等于 tcp-accept。我们使用 sleep 在再次处理之前等待几秒钟，以使该过程更具性能。 1   (**定义**
    (peers/connect peer-context) 2     (**定义** main-cust (make-custodian)) 3     (**参数化**
    ([current-custodian main-cust]) 4       (**定义** (loop) 5         (**让** ([potential-peers
    (get-potential-peers peer-context)]) 6           (**对于** ([peer potential-peers]) 7             (**处理程序**
    ([exn:fail? (**lambda** (x) #t)]) 8               (connect-and-handle peer-context
    peer)))) 9         (sleep 10)10         (loop))11       (线程 loop))12     (**lambda**
    ()13       (custodian-shutdown-all main-cust)))要实现 get-potential-peers，我们首先从对等上下文获取已连接和有效对等体的列表。不在已连接对等体列表中的有效对等体是我们可以建立新连接的潜在对等体。1   (**定义**
    (get-potential-peers peer-context)2     (**让** ([current-connected-peers3            (list->set4             (map
    peer-info-io-peer-info5                  (peer-context-data-connected-peers peer-context)))]6           [valid-peers
    (peer-context-data-valid-peers peer-context)])7       (set-subtract valid-peers
    current-connected-peers)))'
- en: 4.2.1.5 Integrating Parts Together
  id: totrans-104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.1.5 零件的集成
- en: The next procedure will ping all peers (that have connected to us or that we
    have connected to) in an attempt to sync blockchain data and update other stuff,
    such as the list of valid peers: 1   (**define** (peers/sync-data peer-context) 2     (**define**
    (loop) 3       (sleep 10) 4       (**for** [(p (peer-context-data-connected-peers
    peer-context))] 5         (**let** ([in (peer-info-io-input-port p)] 6               [out
    (peer-info-io-output-port p)]) 7           (fprintf out "get-latest-blockchain\nget-valid-peers\n") 8           (flush-output
    out))) 9       (printf "Peer ~a reports ~a valid and ~a connected peers.\n"10               (peer-context-data-name
    peer-context)11               (set-count12                (peer-context-data-valid-peers
    peer-context))13               (set-count14                (peer-context-data-connected-peers
    peer-context)))15       (loop))16     (**define** t (thread loop))17     (**lambda**
    ()18       (kill-thread t)))The following procedure is the entry point, where
    everything is launched together:1   (**define** (run-peer peer-context)2     (**begin**3       (peers/serve
    peer-context)4       (peers/connect peer-context)5       (peers/sync-data peer-context)))Finally,
    we export the necessary objects:1   (**provide** (**struct-out** peer-context-data)2             (**struct-out**
    peer-info)3             run-peer)
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个过程将 ping 所有的对等节点（连接到我们或我们连接到的对等节点）以尝试同步区块链数据并更新其他内容，比如有效对等节点列表： 1   (**define**
    (peers/sync-data peer-context) 2     (**define** (loop) 3       (sleep 10) 4       (**for**
    [(p (peer-context-data-connected-peers peer-context))] 5         (**let** ([in
    (peer-info-io-input-port p)] 6               [out (peer-info-io-output-port p)]) 7           (fprintf
    out "get-latest-blockchain\nget-valid-peers\n") 8           (flush-output out))) 9       (printf
    "Peer ~a reports ~a valid and ~a connected peers.\n"10               (peer-context-data-name
    peer-context)11               (set-count12                (peer-context-data-valid-peers
    peer-context))13               (set-count14                (peer-context-data-connected-peers
    peer-context)))15       (loop))16     (**define** t (thread loop))17     (**lambda**
    ()18       (kill-thread t)))最后，我们导出必要的对象：1   (**provide** (**struct-out** peer-context-data)2             (**struct-out**
    peer-info)3             run-peer)
- en: 4.2.2 Updating Existing Code
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.2 更新现有代码
- en: We need to modify main-helper.rkt to include the peer-to-peer implementation:1   ;
    ...2   (**require** "peer-to-peer.rkt")3   ; ...45   (**provide** (**all-from-out**
    "blockchain.rkt")6             (**all-from-out** "utils.rkt")7             (**all-from-out**
    "peer-to-peer.rkt")8             format-transaction print-block print-blockchain
    print-wallets)
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要修改 main-helper.rkt，以包括点对点实现：1   ; ...2   (**require** "peer-to-peer.rkt")3   ;
    ...45   (**provide** (**all-from-out** "blockchain.rkt")6             (**all-from-out**
    "utils.rkt")7             (**all-from-out** "peer-to-peer.rkt")8             format-transaction
    print-block print-blockchain print-wallets)
- en: 4.2.3 The main-p2p.rkt File
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.3 main-p2p.rkt 文件
- en: This is where we will put all the components together and use them. We want
    this implementation to accept some input arguments, such as the blockchain database
    file and the IP and port addresses of each peer.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将所有组件放在一起并使用它们的地方。我们希望这个实现能够接受一些输入参数，比如区块链数据库文件和每个对等节点的 IP 和端口地址。
- en: 'Once we create an executable, we have a way to pass input to it by using the
    *command-line arguments* . For example, if our executable is named blockchain,
    we can pass additional data to it by running ./blockchain <param1> <param2> <...>.
    Racket provides a built-in procedure called current-command-line-arguments , which
    will read these arguments into a vector (similar to a list), and we then use vector->list
    to convert it to a list for further processing.1   (**require** "main-helper.rkt")23   (**define**
    args (vector->list  (current-command-line-arguments)))45   (**when** (not (= 3
    (length args)))6     (begin7       (printf "Usage: main-p2p.rkt db.data port ip1:port1,ip2:port2...")8       (newline)9       (exit)))string-to-peer-info
    is a helper procedure that does additional parsing for the peers’ information:1   (**define**
    (string-to-peer-info s)2     (**let** ([s (string-split s ":")])3       (peer-info
    (car s) (string->number (cadr s)))))We proceed by parsing the arguments:1   (**define**
    db-filename (car args))2   (**define** port (string->number (cadr args)))3   (**define**
    valid-peers4     (map string-to-peer-info (string-split (caddr args) ",")))We
    then proceed with checking if the database file exists using file-exists?. This
    file will contain contents from a previous blockchain if it exists. If the file
    doesn’t exist, we will proceed to create one.1   (**define** db-blockchain2     (**if**
    (file-exists? db-filename)3         (file->struct db-filename)4         (initialize-new-blockchain)))We
    provide the functionality for creating a new blockchain: 1   (**define** wallet-a
    (make-wallet)) 2 3   (**define** (initialize-new-blockchain) 4     (**begin** 5       (**define**
    coin-base (make-wallet)) 6 7       (printf "Making genesis transaction...\n") 8       (**define**
    genesis-t (make-transaction coin-base wallet-a 100 ''())) 910       (**define**
    utxo (list11                      (make-transaction-io 100 wallet-a)))1213       (printf
    "Mining genesis block...\n")14       (**define** b (init-blockchain genesis-t
    "1337cafe" utxo))15       b))Next is the code for initialization of the current
    peer—it is named Test peer, and it contains data from the parsed command-line
    arguments (the port, valid peers, etc.).1   (**define** peer-context2     (peer-context-data
    "Test peer"3                        port4                        (list->set valid-peers)5                        ''()6                        db-blockchain))7   (**define**
    (get-blockchain) (peer-context-data-blockchain peer-context))89   (run-peer peer-context)We
    keep exporting the database to have up-to-date information whenever a user quits
    the app.1   (**define** (export-loop)2     (**begin**3       (sleep 10)4       (struct->file
    (get-blockchain) db-filename)5       (printf "Exported blockchain to ''~a''...\n"
    db-filename)6       (export-loop)))78   (thread export-loop)Finally, we create
    a procedure to keep mining empty blocks. Note that the peer-to-peer implementation
    runs in threaded mode, so there will be no blocking if we keep running this procedure. 1   (**define**
    (mine-loop) 2     (**let** ([newer-blockchain 3            (send-money-blockchain
    (get-blockchain) 4                                   wallet-a 5                                   wallet-a 6                                   1 7                                   (file->contract
    "contract.script"))]) 8       (set-peer-context-data-blockchain! peer-context
    newer-blockchain) 9       (printf "Mined a block!")10       (sleep 5)11       (mine-loop)))1213   (mine-loop)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '一旦我们创建了一个可执行文件，我们可以通过使用*命令行参数*的方式向其传递输入。例如，如果我们的可执行文件名为blockchain，我们可以通过运行./blockchain
    <param1> <param2> <...> 来向其传递附加数据。Racket 提供了一个名为current-command-line-arguments的内置过程，它将这些参数读入一个向量（类似于列表），然后我们使用vector->list将其转换为一个列表以进行进一步处理。1   (**require**
    "main-helper.rkt")23   (**define** args (vector->list  (current-command-line-arguments)))45   (**when**
    (not (= 3 (length args)))6     (begin7       (printf "Usage: main-p2p.rkt db.data
    port ip1:port1,ip2:port2...")8       (newline)9       (exit)))string-to-peer-info是一个辅助过程，用于对对等体信息进行进一步解析：1   (**define**
    (string-to-peer-info s)2     (**let** ([s (string-split s ":")])3       (peer-info
    (car s) (string->number (cadr s)))))我们继续通过解析参数进行下一步操作：1   (**define** db-filename
    (car args))2   (**define** port (string->number (cadr args)))3   (**define** valid-peers4     (map
    string-to-peer-info (string-split (caddr args) ",")))接着我们检查数据库文件是否存在，使用file-exists?。如果该文件存在，它将包含来自先前区块链的内容。如果文件不存在，我们将继续创建一个。1   (**define**
    db-blockchain2     (**if** (file-exists? db-filename)3         (file->struct db-filename)4         (initialize-new-blockchain)))我们提供了创建新区块链的功能： 1   (**define**
    wallet-a (make-wallet)) 2 3   (**define** (initialize-new-blockchain) 4     (**begin** 5       (**define**
    coin-base (make-wallet)) 6 7       (printf "Making genesis transaction...\n") 8       (**define**
    genesis-t (make-transaction coin-base wallet-a 100 ''())) 910       (**define**
    utxo (list11                      (make-transaction-io 100 wallet-a)))1213       (printf
    "Mining genesis block...\n")14       (**define** b (init-blockchain genesis-t
    "1337cafe" utxo))15       b))接下来是初始化当前对等体的代码——它被命名为Test peer，并包含来自解析的命令行参数的数据（端口、有效对等体等）。1   (**define**
    peer-context2     (peer-context-data "Test peer"3                        port4                        (list->set
    valid-peers)5                        ''()6                        db-blockchain))7   (**define**
    (get-blockchain) (peer-context-data-blockchain peer-context))89   (run-peer peer-context)我们持续导出数据库以便在用户退出应用程序时获取最新信息。1   (**define**
    (export-loop)2     (**begin**3       (sleep 10)4       (struct->file (get-blockchain)
    db-filename)5       (printf "Exported blockchain to ''~a''...\n" db-filename)6       (export-loop)))78   (thread
    export-loop)最后，我们创建一个过程来持续挖掘空块。请注意，对等体间的实现以线程模式运行，因此如果我们持续运行此过程，将不会出现阻塞。 1   (**define**
    (mine-loop) 2     (**let** ([newer-blockchain 3            (send-money-blockchain
    (get-blockchain) 4                                   wallet-a 5                                   wallet-a 6                                   1 7                                   (file->contract
    "contract.script"))]) 8       (set-peer-context-data-blockchain! peer-context
    newer-blockchain'
- en: We can proceed by creating an executable and share it with our friends. If we
    know their IP addresses (or they know ours), we can make a connection and thus
    form a system.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过创建一个可执行文件并与朋友分享来继续进行。如果我们知道他们的IP地址（或者他们知道我们的IP地址），我们可以建立连接，从而形成一个系统。
- en: 4.3 Summary
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3 总结
- en: 'Congratulations! As part of this chapter, we added two new important features
    to the blockchain implementation: smart contracts and peer-to-peer support. This
    concludes the blockchain implementation of this book.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！作为本章的一部分，我们向区块链实现添加了两个重要的新功能：智能合约和点对点支持。这标志着本书对区块链的实现工作的结束。
