- en: '![](index-358_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 9 Layer 2 and ethereum 2
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 9-3\.** Components and workflow of plasma scalability*'
  prefs: []
  type: TYPE_NORMAL
- en: '*solutions*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Plasma Smart Contract on Ethereum Mainnet**'
  prefs: []
  type: TYPE_NORMAL
- en: The top layer is the layer 1 or root blockchain, which in this context is
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum mainnet. Plasma smart contracts are deployed to Ethereum
  prefs: []
  type: TYPE_NORMAL
- en: mainnet, and it has the following functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Deposit function for users to deposit assets to use in layer 1: This'
  prefs: []
  type: TYPE_NORMAL
- en: deposit function will allow a user to send a transaction to a plasma smart
  prefs: []
  type: TYPE_NORMAL
- en: contract with a certain asset value. The asset sent by the user through
  prefs: []
  type: TYPE_NORMAL
- en: the deposit function will be locked in the mainnet by the plasma smart
  prefs: []
  type: TYPE_NORMAL
- en: contract. A record will be created by the smart contract, and a new token
  prefs: []
  type: TYPE_NORMAL
- en: related to this deposit will be created. After that, the deposit function can
  prefs: []
  type: TYPE_NORMAL
- en: emit a deposit event to notify plasma blockchain. The token and its value
  prefs: []
  type: TYPE_NORMAL
- en: will be replicated in the plasma blockchain and used as assets for the layer
  prefs: []
  type: TYPE_NORMAL
- en: 2 blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: SubmitPlasmaTxRecord function for layer 2 plasma blockchain
  prefs: []
  type: TYPE_NORMAL
- en: 'to submit the transaction Merkle tree to the layer 1 root chain: The'
  prefs: []
  type: TYPE_NORMAL
- en: transactions in the plasma blockchain are recorded in a Merkle tree
  prefs: []
  type: TYPE_NORMAL
- en: structure, and the root of the Merkle tree is sent to the parent or root
  prefs: []
  type: TYPE_NORMAL
- en: blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: '348'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9 Layer 2 and ethereum 2
  prefs: []
  type: TYPE_NORMAL
- en: StartWithdraw function that allows users to withdraw assets from the
  prefs: []
  type: TYPE_NORMAL
- en: 'layer 2 chain to the layer 1 blockchain: The function is normally called'
  prefs: []
  type: TYPE_NORMAL
- en: by users directly or by operators that connect with both layer 1 and layer
  prefs: []
  type: TYPE_NORMAL
- en: 2 blockchains. The caller of this function should provide plasma block
  prefs: []
  type: TYPE_NORMAL
- en: number, transaction indexid, transaction record, Merkle proof, and
  prefs: []
  type: TYPE_NORMAL
- en: signatures. When users withdraw assets from the plasma blockchain, the
  prefs: []
  type: TYPE_NORMAL
- en: assets in the plasma chain will be burned, and then the assets originally
  prefs: []
  type: TYPE_NORMAL
- en: deposited on the layer 1 chain will be distributed to the target user. To
  prefs: []
  type: TYPE_NORMAL
- en: ensure that the burning operation and unlock operation are secure, there
  prefs: []
  type: TYPE_NORMAL
- en: will be a wait period for the StartWithdraw function to distribute the funds
  prefs: []
  type: TYPE_NORMAL
- en: to the users. This is to ensure that the assets in layer 2 are burned before
  prefs: []
  type: TYPE_NORMAL
- en: the same value of asset in layer 1 is distributed. During this wait period,
  prefs: []
  type: TYPE_NORMAL
- en: anyone can challenge this withdrawal by providing proofs from the plasma
  prefs: []
  type: TYPE_NORMAL
- en: blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: ChallengeWithdraw function that allows any user or operator to
  prefs: []
  type: TYPE_NORMAL
- en: provide evidence to challenge the withdrawal transaction waiting to be
  prefs: []
  type: TYPE_NORMAL
- en: 'validated: The caller of this function needs to provide a withdrawal ID'
  prefs: []
  type: TYPE_NORMAL
- en: that is challenged and other inputs such as Merkle root and proofs that
  prefs: []
  type: TYPE_NORMAL
- en: are similar to the StartWithdraw function. The inputs from StartWithdraw
  prefs: []
  type: TYPE_NORMAL
- en: function and ChallengeWithdraw function are compared and validated.
  prefs: []
  type: TYPE_NORMAL
- en: If the challenge is successful, then the StartWithdraw transaction will
  prefs: []
  type: TYPE_NORMAL
- en: be voided.
  prefs: []
  type: TYPE_NORMAL
- en: '**Operators**'
  prefs: []
  type: TYPE_NORMAL
- en: Operators connect plasma blockchain with layer 1 root chain. It watches
  prefs: []
  type: TYPE_NORMAL
- en: deposit events in layer 1 and then generates a new token ID to represent
  prefs: []
  type: TYPE_NORMAL
- en: the one in the mainnet and then mint the same value of tokens in the
  prefs: []
  type: TYPE_NORMAL
- en: plasma chain. Once the new token is generated on the plasma blockchain,
  prefs: []
  type: TYPE_NORMAL
- en: the depositor owns the token and can send the token to any user in the
  prefs: []
  type: TYPE_NORMAL
- en: layer 2 chain. Operators will also submit plasma blockchain Merkle tree
  prefs: []
  type: TYPE_NORMAL
- en: root records to the layer 1 blockchain. Users can withdraw their assets
  prefs: []
  type: TYPE_NORMAL
- en: '349'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9 Layer 2 and ethereum 2
  prefs: []
  type: TYPE_NORMAL
- en: to layer 1 using smart contract functions calls on blockchain. If the
  prefs: []
  type: TYPE_NORMAL
- en: withdrawal is requested in layer 2, the operator will also pass the request
    to
  prefs: []
  type: TYPE_NORMAL
- en: layer 1 for processing.
  prefs: []
  type: TYPE_NORMAL
- en: '**Transactions or Smart Contracts on Layer 2**'
  prefs: []
  type: TYPE_NORMAL
- en: In the plasma layer 2 chain, users can send regular transactions among
  prefs: []
  type: TYPE_NORMAL
- en: each other. The plasma chain can also implement smart contract
  prefs: []
  type: TYPE_NORMAL
- en: capability to withdraw assets to the layer 1 blockchain. The transactions
  prefs: []
  type: TYPE_NORMAL
- en: in the plasma chain are packaged into a Merkle tree and saved as a
  prefs: []
  type: TYPE_NORMAL
- en: blockchain state. The root of the Merkle is sent to the layer 1 chain
  prefs: []
  type: TYPE_NORMAL
- en: for record.
  prefs: []
  type: TYPE_NORMAL
- en: '**Plasma Chain**'
  prefs: []
  type: TYPE_NORMAL
- en: Plasma chains can be implemented in various ways. Since the security
  prefs: []
  type: TYPE_NORMAL
- en: of the plasma chain is coupled with the root chain and receipts of
  prefs: []
  type: TYPE_NORMAL
- en: transactions are sent to the receiver, plasma chains do not need to have full
  prefs: []
  type: TYPE_NORMAL
- en: consensus to ensure security. The plasma chain can be implemented in
  prefs: []
  type: TYPE_NORMAL
- en: various ways. In one implementation, a plasma chain can be implemented
  prefs: []
  type: TYPE_NORMAL
- en: as a server that takes user transaction inputs and also has a Merkle tree
  prefs: []
  type: TYPE_NORMAL
- en: structure or a database to store transactions. The plasma chain can
  prefs: []
  type: TYPE_NORMAL
- en: also be implemented as a POA (proof of authority) or BFT (Byzantine
  prefs: []
  type: TYPE_NORMAL
- en: Fault Tolerance) blockchain. In this POA or BFT plasma blockchain, a
  prefs: []
  type: TYPE_NORMAL
- en: couple of permissioned nodes create a blockchain to accept plasma layer
  prefs: []
  type: TYPE_NORMAL
- en: transactions. The root of the transaction Merkle tree is then calculated and
  prefs: []
  type: TYPE_NORMAL
- en: sent to the root blockchain for record and verification. The plasma chain
  prefs: []
  type: TYPE_NORMAL
- en: can also be implemented as a POS (proof of stake) chain where anyone can
  prefs: []
  type: TYPE_NORMAL
- en: run a node by staking an asset to a smart contract on the root chain. The
  prefs: []
  type: TYPE_NORMAL
- en: assets staked in the plasma chain are to secure the plasma chain. If there
  prefs: []
  type: TYPE_NORMAL
- en: is a collusion of nodes in the plasma chain, the stakes of these nodes get
  prefs: []
  type: TYPE_NORMAL
- en: slashed through a smart contract on the root chain.
  prefs: []
  type: TYPE_NORMAL
- en: '350'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-361_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 9 Layer 2 and ethereum 2
  prefs: []
  type: TYPE_NORMAL
- en: '**Transaction Merkle Tree Example**'
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum blockchains leverage the Merkle tree extensively. A Merkle tree
  prefs: []
  type: TYPE_NORMAL
- en: is a data structure that arranges data/message and its respective hash
  prefs: []
  type: TYPE_NORMAL
- en: in a hierarchical tree structure to ensure data integrity and processing
  prefs: []
  type: TYPE_NORMAL
- en: efficiency. There are multiple Merkle trees. A standard Merkle tree is the
  prefs: []
  type: TYPE_NORMAL
- en: one that records the elements and their hash in a binary tree structure as
  prefs: []
  type: TYPE_NORMAL
- en: 'shown in the following diagram (Figure [9-4](#p361)):'
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 9-4\.** A standard Merkle tree example*'
  prefs: []
  type: TYPE_NORMAL
- en: The leaf nodes are data nodes, and the nodes on top of leaf nodes
  prefs: []
  type: TYPE_NORMAL
- en: store the hash of the data element. Here, H(A) means a hash of data A. The
  prefs: []
  type: TYPE_NORMAL
- en: hashing function can be sha256 or keccak256, which are commonly used
  prefs: []
  type: TYPE_NORMAL
- en: in Ethereum. With these Merkle trees, the integrity of each node can be
  prefs: []
  type: TYPE_NORMAL
- en: verified by providing root hash and hashes of the “uncle’s” node. For
  prefs: []
  type: TYPE_NORMAL
- en: example, in the preceding diagram, to prove transactions of A element
  prefs: []
  type: TYPE_NORMAL
- en: are valid, users need to provide hash_b, hash_c, and hash_d to compute
  prefs: []
  type: TYPE_NORMAL
- en: '351'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9 Layer 2 and ethereum 2
  prefs: []
  type: TYPE_NORMAL
- en: the root node hash and compare with the root hash as recorded in the
  prefs: []
  type: TYPE_NORMAL
- en: root chain.
  prefs: []
  type: TYPE_NORMAL
- en: The following code snippet demonstrates how the Merkle tree in the
  prefs: []
  type: TYPE_NORMAL
- en: preceding diagram is implemented in Solidity. The source code for this
  prefs: []
  type: TYPE_NORMAL
- en: Merkle tree demo program is located at the GitHub location.
  prefs: []
  type: TYPE_NORMAL
- en: /**
  prefs: []
  type: TYPE_NORMAL
- en: '* *@title MerkleDemo for 4 leaf nodes*'
  prefs: []
  type: TYPE_NORMAL
- en: '*/'
  prefs: []
  type: TYPE_NORMAL
- en: '*contract MerkleDemo {*'
  prefs: []
  type: TYPE_NORMAL
- en: '*//declear leaf nodes*'
  prefs: []
  type: TYPE_NORMAL
- en: '*string public leaf_a = "Alice sent 10 tokens to Bob";*'
  prefs: []
  type: TYPE_NORMAL
- en: '*string public leaf_b = "Bob sent 9 tokens to Cathy";*'
  prefs: []
  type: TYPE_NORMAL
- en: '*string public leaf_c = "Cathy sent 8 tokens to David";*'
  prefs: []
  type: TYPE_NORMAL
- en: '*string public leaf_d = "David sent 7 tokens to Eric";*'
  prefs: []
  type: TYPE_NORMAL
- en: '*//declare parent node and root node as 32 bytes hash.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*bytes32 public hash_a;*'
  prefs: []
  type: TYPE_NORMAL
- en: '*bytes32 public hash_b;*'
  prefs: []
  type: TYPE_NORMAL
- en: '*bytes32 public hash_c;*'
  prefs: []
  type: TYPE_NORMAL
- en: '*bytes32 public hash_d;*'
  prefs: []
  type: TYPE_NORMAL
- en: '*bytes32 public hash_cd;*'
  prefs: []
  type: TYPE_NORMAL
- en: '*bytes32 public hash_ab;*'
  prefs: []
  type: TYPE_NORMAL
- en: '*bytes32 public hash_ab_cd;*'
  prefs: []
  type: TYPE_NORMAL
- en: '*bytes32 public hash_root;*'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code snippet, four leaf nodes – leaf_a, leaf_b, leaf_c,
  prefs: []
  type: TYPE_NORMAL
- en: and leaf_d – are defined as string type variables that record simplified
  prefs: []
  type: TYPE_NORMAL
- en: transactions. The content of the leaf nodes is hashed and stored in
  prefs: []
  type: TYPE_NORMAL
- en: variables of hash_a, hash_b, hash_c, and hash_d of bytes32 data type.
  prefs: []
  type: TYPE_NORMAL
- en: hash_a and hash_b are combined to form a parent hash named hash_
  prefs: []
  type: TYPE_NORMAL
- en: ab. Hash_c and hash_d are combined to form parent node hash_cd. And
  prefs: []
  type: TYPE_NORMAL
- en: '352'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9 Layer 2 and ethereum 2
  prefs: []
  type: TYPE_NORMAL
- en: finally, hash_ab and hash_cd are combined to form hash_ab_cd. Hash_ab_
  prefs: []
  type: TYPE_NORMAL
- en: cd is the top node equivalent to hash_root.
  prefs: []
  type: TYPE_NORMAL
- en: The constructor of MerkleDemo smart contract constructs the Merkle
  prefs: []
  type: TYPE_NORMAL
- en: 'tree as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: /*
  prefs: []
  type: TYPE_NORMAL
- en: '* *Constructor function to construct a merkle tree.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*/'
  prefs: []
  type: TYPE_NORMAL
- en: '*constructor() public {*'
  prefs: []
  type: TYPE_NORMAL
- en: '*// construct a Merkle tree with sha256 hash function.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*// abi.encodePacked concatenate two child hashes*'
  prefs: []
  type: TYPE_NORMAL
- en: '*hash_a = sha256(abi.encodePacked(leaf_a));*'
  prefs: []
  type: TYPE_NORMAL
- en: '*hash_b = sha256(abi.encodePacked(leaf_b));*'
  prefs: []
  type: TYPE_NORMAL
- en: '*hash_c = sha256(abi.encodePacked(leaf_c));*'
  prefs: []
  type: TYPE_NORMAL
- en: '*hash_d = sha256(abi.encodePacked(leaf_d));*'
  prefs: []
  type: TYPE_NORMAL
- en: '*hash_ab= sha256(abi.encodePacked(hash_a, hash_b));*'
  prefs: []
  type: TYPE_NORMAL
- en: '*hash_cd= sha256(abi.encodePacked(hash_c, hash_d));*'
  prefs: []
  type: TYPE_NORMAL
- en: '*hash_ab_cd= sha256(abi.encodePacked(hash_ab, hash_cd));*'
  prefs: []
  type: TYPE_NORMAL
- en: '*hash_root = hash_ab_cd;*'
  prefs: []
  type: TYPE_NORMAL
- en: '*}*'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code in the constructor, the sha256 Solidity function
  prefs: []
  type: TYPE_NORMAL
- en: is used to hash a leaf or nonleaf node. abi.encodePacked function is to
  prefs: []
  type: TYPE_NORMAL
- en: concatenate two elements and hash the merged result to get the parent
  prefs: []
  type: TYPE_NORMAL
- en: node. Once the hash_root is generated, it is saved to the root blockchain
  prefs: []
  type: TYPE_NORMAL
- en: and can be used to validate nodes in the Merkle tree as requested by the
  prefs: []
  type: TYPE_NORMAL
- en: users or operators.
  prefs: []
  type: TYPE_NORMAL
- en: To check if a transaction represented by a leaf node is in the Merkle
  prefs: []
  type: TYPE_NORMAL
- en: 'tree, simply use the following checkMerkleTree function:'
  prefs: []
  type: TYPE_NORMAL
- en: /**
  prefs: []
  type: TYPE_NORMAL
- en: '* *Check if a leaf is valid*'
  prefs: []
  type: TYPE_NORMAL
- en: '* *@param _leaf Leaf to check.*'
  prefs: []
  type: TYPE_NORMAL
- en: '353'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9 Layer 2 and ethereum 2
  prefs: []
  type: TYPE_NORMAL
- en: '* *@param _index Index of the leaf in the tree.*'
  prefs: []
  type: TYPE_NORMAL
- en: '* *@param _rootHash Root of the tree.*'
  prefs: []
  type: TYPE_NORMAL
- en: '* *@param _proof Merkle proof showing the leaf is in*'
  prefs: []
  type: TYPE_NORMAL
- en: '*the tree.*'
  prefs: []
  type: TYPE_NORMAL
- en: '* *@return True if the leaf is in the tree, false otherwise.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*/'
  prefs: []
  type: TYPE_NORMAL
- en: '*function checkMerkleTree(*'
  prefs: []
  type: TYPE_NORMAL
- en: '*string memory _leaf,*'
  prefs: []
  type: TYPE_NORMAL
- en: '*uint256 _index,*'
  prefs: []
  type: TYPE_NORMAL
- en: '*bytes32 _rootHash,*'
  prefs: []
  type: TYPE_NORMAL
- en: '*bytes memory _proof*'
  prefs: []
  type: TYPE_NORMAL
- en: '*) public pure returns (bool) {*'
  prefs: []
  type: TYPE_NORMAL
- en: '*// Check _proof to be one or multiple bytes32*'
  prefs: []
  type: TYPE_NORMAL
- en: '*require(_proof.length % 32 == 0, "proof length not*'
  prefs: []
  type: TYPE_NORMAL
- en: '*valid.");*'
  prefs: []
  type: TYPE_NORMAL
- en: '*// Compute the merkle root.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*bytes32 proofElement;*'
  prefs: []
  type: TYPE_NORMAL
- en: '*bytes32 parentHash = sha256(abi.encodePacked(_leaf));*'
  prefs: []
  type: TYPE_NORMAL
- en: '*uint256 index = _index;*'
  prefs: []
  type: TYPE_NORMAL
- en: '*//loops through each bytes32 element in the proof*'
  prefs: []
  type: TYPE_NORMAL
- en: '*for (uint256 i = 32; i <= _proof.length; i += 32) {*'
  prefs: []
  type: TYPE_NORMAL
- en: '*assembly {*'
  prefs: []
  type: TYPE_NORMAL
- en: '*proofElement = mload(add(_proof, i))*'
  prefs: []
  type: TYPE_NORMAL
- en: '*}*'
  prefs: []
  type: TYPE_NORMAL
- en: '*if (index % 2 == 0) { // leaf node is on the left*'
  prefs: []
  type: TYPE_NORMAL
- en: '*parentHash = sha256(abi.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*encodePacked(parentHash, proofElement));*'
  prefs: []
  type: TYPE_NORMAL
- en: '*} else { //leaf node is on the right*'
  prefs: []
  type: TYPE_NORMAL
- en: '*parentHash = sha256(abi.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*encodePacked(proofElement, parentHash));*'
  prefs: []
  type: TYPE_NORMAL
- en: '*}*'
  prefs: []
  type: TYPE_NORMAL
- en: '354'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9 Layer 2 and ethereum 2
  prefs: []
  type: TYPE_NORMAL
- en: '*index = index / 2; //Go to the next level*'
  prefs: []
  type: TYPE_NORMAL
- en: '*}*'
  prefs: []
  type: TYPE_NORMAL
- en: '*// If parentHash equal _rootHash, then it is validated.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*return parentHash == _rootHash;*'
  prefs: []
  type: TYPE_NORMAL
- en: '*}*'
  prefs: []
  type: TYPE_NORMAL
- en: The checkMerkleTree function takes a leaf node contract (i.e., a
  prefs: []
  type: TYPE_NORMAL
- en: transaction), an index that shows the location of the leaf node, a root
  prefs: []
  type: TYPE_NORMAL
- en: hash, and then a proof to compute if the root hash as computed by the
  prefs: []
  type: TYPE_NORMAL
- en: leaf node and proof matches what is recorded. If the computed hash root
  prefs: []
  type: TYPE_NORMAL
- en: and the recorded one match, the leaf and proof are considered as valid.
  prefs: []
  type: TYPE_NORMAL
- en: Otherwise, the leaf node or the transaction that it represents is considered
  prefs: []
  type: TYPE_NORMAL
- en: as tempered.
  prefs: []
  type: TYPE_NORMAL
- en: And then we have a testcasedemo function to verify leaf nodes c and d
  prefs: []
  type: TYPE_NORMAL
- en: 'for the untempered and tempered cases as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*// test some leaf nodes in the Merkle tree*'
  prefs: []
  type: TYPE_NORMAL
- en: '*function testCasesdemo() public payable returns(string*'
  prefs: []
  type: TYPE_NORMAL
- en: '*memory, string memory, string memory, string memory){*'
  prefs: []
  type: TYPE_NORMAL
- en: '*//valid and invalid transaction message to be validated*'
  prefs: []
  type: TYPE_NORMAL
- en: '*string memory test_leaf_c = "Cathy sent 8 tokens*'
  prefs: []
  type: TYPE_NORMAL
- en: '*to David";*'
  prefs: []
  type: TYPE_NORMAL
- en: '*string memory test_leaf_d = "David sent 7 tokens*'
  prefs: []
  type: TYPE_NORMAL
- en: '*to Eric";*'
  prefs: []
  type: TYPE_NORMAL
- en: '*// These two are tempered and should not be validated*'
  prefs: []
  type: TYPE_NORMAL
- en: '*string memory test_leaf_c_tempered = "Cathy sent 100000*'
  prefs: []
  type: TYPE_NORMAL
- en: '*tokens to David";*'
  prefs: []
  type: TYPE_NORMAL
- en: '*string memory test_leaf_d_tempered = "David sent 100000*'
  prefs: []
  type: TYPE_NORMAL
- en: '*tokens to Eric";*'
  prefs: []
  type: TYPE_NORMAL
- en: '*// leaf_a, leaf_b, leaf_c, lead_d have index = 0, 1, 2,*'
  prefs: []
  type: TYPE_NORMAL
- en: '*3 respectively.*'
  prefs: []
  type: TYPE_NORMAL
- en: '355'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9 Layer 2 and ethereum 2
  prefs: []
  type: TYPE_NORMAL
- en: '*// Use test_index variable to represent index*'
  prefs: []
  type: TYPE_NORMAL
- en: '*uint test_index = 2;*'
  prefs: []
  type: TYPE_NORMAL
- en: '*// construct Merkle proof for leaf_c*'
  prefs: []
  type: TYPE_NORMAL
- en: '*bytes memory merkle_proof = abi.encodePacked(hash_d,*'
  prefs: []
  type: TYPE_NORMAL
- en: '*hash_ab);*'
  prefs: []
  type: TYPE_NORMAL
- en: '*bool result = checkMerkleTree(test_leaf_c, test_index,*'
  prefs: []
  type: TYPE_NORMAL
- en: '*hash_root, merkle_proof);*'
  prefs: []
  type: TYPE_NORMAL
- en: '*string memory return_leaf_c = string(abi.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*encodePacked(test_leaf_c, ": ",result?"true":"false"));*'
  prefs: []
  type: TYPE_NORMAL
- en: '*//Do the same validation for tempered leaf_c*'
  prefs: []
  type: TYPE_NORMAL
- en: '*result = checkMerkleTree(test_leaf_c_tempered, test_*'
  prefs: []
  type: TYPE_NORMAL
- en: '*index, hash_root, merkle_proof);*'
  prefs: []
  type: TYPE_NORMAL
- en: '*string memory return_leaf_c_tempered =*'
  prefs: []
  type: TYPE_NORMAL
- en: '*string(abi.encodePacked(test_leaf_c_tempered, ":*'
  prefs: []
  type: TYPE_NORMAL
- en: '*",result?"true":"false"));*'
  prefs: []
  type: TYPE_NORMAL
- en: '*// Do the same leaf_d, similar to leaf_c*'
  prefs: []
  type: TYPE_NORMAL
- en: '*test_index = 3;*'
  prefs: []
  type: TYPE_NORMAL
- en: '*merkle_proof = abi.encodePacked(hash_c, hash_ab);*'
  prefs: []
  type: TYPE_NORMAL
- en: '*result = checkMerkleTree(test_leaf_d, test_index, hash_*'
  prefs: []
  type: TYPE_NORMAL
- en: '*root, merkle_proof);*'
  prefs: []
  type: TYPE_NORMAL
- en: '*string memory return_leaf_d = string(abi.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*encodePacked(test_leaf_d, ": ",result?"true":"false"));* *result = checkMerkleTree(test_leaf_d_tempered,
    test_*'
  prefs: []
  type: TYPE_NORMAL
- en: '*index, hash_root, merkle_proof);*'
  prefs: []
  type: TYPE_NORMAL
- en: '*string memory return_leaf_d_tempered =*'
  prefs: []
  type: TYPE_NORMAL
- en: '*string(abi.encodePacked(test_leaf_d_tempered, ":*'
  prefs: []
  type: TYPE_NORMAL
- en: '*",result?"true":"false"));*'
  prefs: []
  type: TYPE_NORMAL
- en: '*//Return and output results*'
  prefs: []
  type: TYPE_NORMAL
- en: '*return (return_leaf_c, return_leaf_c_tempered, return_*'
  prefs: []
  type: TYPE_NORMAL
- en: '*leaf_d, return_leaf_d_tempered);*'
  prefs: []
  type: TYPE_NORMAL
- en: '*}*'
  prefs: []
  type: TYPE_NORMAL
- en: '356'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9 Layer 2 and ethereum 2
  prefs: []
  type: TYPE_NORMAL
- en: This test method constructs test_leaf_c and test_leaf_d transactions
  prefs: []
  type: TYPE_NORMAL
- en: that are valid. Also, it modified the two transactions to test_leaf_c_
  prefs: []
  type: TYPE_NORMAL
- en: tempered and test_leaf_d_tempered and changed the transferred token to
  prefs: []
  type: TYPE_NORMAL
- en: a larger amount. The proof for each node is also constructed and the index
  prefs: []
  type: TYPE_NORMAL
- en: for the transaction specified. The leaf node, index, root hash, and proof are
  prefs: []
  type: TYPE_NORMAL
- en: 'sent to checkMerkleTree function for verification. The result is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '*//Output of testCasedemo*'
  prefs: []
  type: TYPE_NORMAL
- en: '*{*'
  prefs: []
  type: TYPE_NORMAL
- en: '*"0": "string: Cathy sent 8 tokens to David: true",*'
  prefs: []
  type: TYPE_NORMAL
- en: '*"1": "string: Cathy sent 100000 tokens to David: false",*'
  prefs: []
  type: TYPE_NORMAL
- en: '*"2": "string: David sent 7 tokens to Eric: true",*'
  prefs: []
  type: TYPE_NORMAL
- en: '*"3": "string: David sent 100000 tokens to Eric: false"*'
  prefs: []
  type: TYPE_NORMAL
- en: '*}*'
  prefs: []
  type: TYPE_NORMAL
- en: The output shows that the untempered transactions are validated as
  prefs: []
  type: TYPE_NORMAL
- en: true and the tempered ones are validated as false.
  prefs: []
  type: TYPE_NORMAL
- en: '**Transaction Merkle Tree for Plasma MVP**'
  prefs: []
  type: TYPE_NORMAL
- en: In the last code example, we showed a standard Merkle tree with simple
  prefs: []
  type: TYPE_NORMAL
- en: transaction messages of “User A sent x tokens to user B” recorded in the
  prefs: []
  type: TYPE_NORMAL
- en: leaf nodes. Although we are able to show that these transaction messages
  prefs: []
  type: TYPE_NORMAL
- en: can be proved with a root hash recorded in the root chain and a proof
  prefs: []
  type: TYPE_NORMAL
- en: submitted by a user or operator, a simple message format is not sufficient
  prefs: []
  type: TYPE_NORMAL
- en: enough to be used practically for plasma transactions. More complex
  prefs: []
  type: TYPE_NORMAL
- en: Merkle tree formats have been proposed for both fungible and nonfungible
  prefs: []
  type: TYPE_NORMAL
- en: tokens. In the following, we describe Plasma MVP and Plasma Cash.
  prefs: []
  type: TYPE_NORMAL
- en: '357'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9 Layer 2 and ethereum 2
  prefs: []
  type: TYPE_NORMAL
- en: Plasma MVP uses a standard Merkle tree that uses UTXO to record
  prefs: []
  type: TYPE_NORMAL
- en: transactions and send the root hash to the root chain. Vitalik proposed
  prefs: []
  type: TYPE_NORMAL
- en: using the following unspent transaction output (UTXO) format for the
  prefs: []
  type: TYPE_NORMAL
- en: 'Merkle leaf node:'
  prefs: []
  type: TYPE_NORMAL
- en: '*[blknum1, txindex1, oindex1, sig1, # Input 1*'
  prefs: []
  type: TYPE_NORMAL
- en: '*blknum2, txindex2, oindex2, sig2, # Input 2*'
  prefs: []
  type: TYPE_NORMAL
- en: '*newowner1, denom1, # Output 1*'
  prefs: []
  type: TYPE_NORMAL
- en: '*newowner2, denom2, # Output 2*'
  prefs: []
  type: TYPE_NORMAL
- en: '*fee]*'
  prefs: []
  type: TYPE_NORMAL
- en: This leaf node format uses two inputs and two outputs. The two
  prefs: []
  type: TYPE_NORMAL
- en: inputs allow a user to combine two UTXOs to send to one address.
  prefs: []
  type: TYPE_NORMAL
- en: The two outputs allow a user to send partial UTXO to one user and the
  prefs: []
  type: TYPE_NORMAL
- en: others to another user. In this leaf node format, blknum1, txindex1, and
  prefs: []
  type: TYPE_NORMAL
- en: oindex1 represent blockchain number, transaction index, and output
  prefs: []
  type: TYPE_NORMAL
- en: index for input 1\. This uniquely identifies the leaf node of the transaction
  prefs: []
  type: TYPE_NORMAL
- en: Merkle tree. The sig1 is used to sign the transaction to ensure the sender
  prefs: []
  type: TYPE_NORMAL
- en: is the owner of the UTXO. Similarly, blknum2, txindex2, oindex2, and
  prefs: []
  type: TYPE_NORMAL
- en: sig2 represent the block number, transaction index, output index, and
  prefs: []
  type: TYPE_NORMAL
- en: signature of input 2\. For the outputs, newowner1 and denom1 represent
  prefs: []
  type: TYPE_NORMAL
- en: the amount of token to be allocated to the new owner 1\. And newowner2
  prefs: []
  type: TYPE_NORMAL
- en: and denom2 represent the amount of token to be allocated to the new
  prefs: []
  type: TYPE_NORMAL
- en: owner 2\. And finally, the fee in the transaction is the amount of token to
  prefs: []
  type: TYPE_NORMAL
- en: pay for the plasma transaction.
  prefs: []
  type: TYPE_NORMAL
- en: Using UTXO format for Merkle tree nodes, the transactions can be
  prefs: []
  type: TYPE_NORMAL
- en: uniquely identified, and there is no need to traverse the Merkle tree to
  prefs: []
  type: TYPE_NORMAL
- en: query other transactions. To make the query even more efficient, the
  prefs: []
  type: TYPE_NORMAL
- en: blknum, txindex, and oindex can be merged to become a uint256 integer.
  prefs: []
  type: TYPE_NORMAL
- en: '358'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9 Layer 2 and ethereum 2
  prefs: []
  type: TYPE_NORMAL
- en: This way, one integer can be used to uniquely identify a UTXO transaction
  prefs: []
  type: TYPE_NORMAL
- en: 'using the following conversion:'
  prefs: []
  type: TYPE_NORMAL
- en: '*utxo_index = blknum*1000000000+txindex*10000+oindex;*'
  prefs: []
  type: TYPE_NORMAL
- en: To retrieve blknum, txindex, and oindex from utxo_index, use the
  prefs: []
  type: TYPE_NORMAL
- en: 'following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Blknum = utxo_index/1000000000;*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Txindex = (utxo % 1000000000)/10000;*'
  prefs: []
  type: TYPE_NORMAL
- en: '*oindex = utxo_index - blknum*1000000000-txindex*10000;*'
  prefs: []
  type: TYPE_NORMAL
- en: Using the UTXO format, Plasma MVP can record fungible tokens with
  prefs: []
  type: TYPE_NORMAL
- en: a UTXO format efficiently on the plasma chain. Users can also withdraw
  prefs: []
  type: TYPE_NORMAL
- en: their assets or UTXO on the root chain. To submit a withdrawal request,
  prefs: []
  type: TYPE_NORMAL
- en: simply send a utxo_index to identify the location of the UTXO, the
  prefs: []
  type: TYPE_NORMAL
- en: transaction itself, the Merkle root, and the signature. The smart contract
  prefs: []
  type: TYPE_NORMAL
- en: will do the following to distribute the funds to the new owner of the
  prefs: []
  type: TYPE_NORMAL
- en: 'root chain:'
  prefs: []
  type: TYPE_NORMAL
- en: • Check that the sender for the withdrawal request is the
  prefs: []
  type: TYPE_NORMAL
- en: same as the owner of the UTXO.
  prefs: []
  type: TYPE_NORMAL
- en: • The transaction has been signed by the sender.
  prefs: []
  type: TYPE_NORMAL
- en: • The output 1 and output 2 amount plus the transaction
  prefs: []
  type: TYPE_NORMAL
- en: fee is the same as the sum of input 1 and input 2\.
  prefs: []
  type: TYPE_NORMAL
- en: • The UTXO for the sender is not spent yet. This would
  prefs: []
  type: TYPE_NORMAL
- en: require some time to confirm.
  prefs: []
  type: TYPE_NORMAL
- en: Once all validity checking passes, the plasma smart contract on the
  prefs: []
  type: TYPE_NORMAL
- en: root chain will distribute the assets on the root chain to the new owners.
  prefs: []
  type: TYPE_NORMAL
- en: '359'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-370_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 9 Layer 2 and ethereum 2
  prefs: []
  type: TYPE_NORMAL
- en: '**Transaction Merkle Tree for Plasma Cash**'
  prefs: []
  type: TYPE_NORMAL
- en: With Plasma MVP mentioned earlier, users can send fungible assets through
  prefs: []
  type: TYPE_NORMAL
- en: UTXO to the end users. However, the Plasma MVP does not solve the
  prefs: []
  type: TYPE_NORMAL
- en: problem for nonfungible tokens. UTXO has a denominator for transactions
  prefs: []
  type: TYPE_NORMAL
- en: but does not require a unique ID. Plasma Cash is an extension of UTXO
  prefs: []
  type: TYPE_NORMAL
- en: where each token is assigned a serial number for record and transfer.
  prefs: []
  type: TYPE_NORMAL
- en: Although cash or money is normally considered as fungible, Plasma
  prefs: []
  type: TYPE_NORMAL
- en: Cash is actually best for dealing with nonfungible tokens similar to ERC721
  prefs: []
  type: TYPE_NORMAL
- en: or assets that are uniquely identifiable.
  prefs: []
  type: TYPE_NORMAL
- en: To allow Merkle trees to work with nonfungible tokens, a sparse Merkle
  prefs: []
  type: TYPE_NORMAL
- en: tree is proposed to ensure uniqueness of a token. The following diagram
  prefs: []
  type: TYPE_NORMAL
- en: (Figure [9-5) is an illus](#p370)tration of how a sparse Merkle tree works for
    a nonfungible token.
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 9-5\.** A Sparse Merkle tree example*'
  prefs: []
  type: TYPE_NORMAL
- en: '360'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9 Layer 2 and ethereum 2
  prefs: []
  type: TYPE_NORMAL
- en: For ERC721 NFT token, there is an NFT identifier to represent the
  prefs: []
  type: TYPE_NORMAL
- en: tokenId to represent the index of the token. This uint32 tokenId can be
  prefs: []
  type: TYPE_NORMAL
- en: casted to a smaller size integer such as uint32 and uint64\.
  prefs: []
  type: TYPE_NORMAL
- en: A Merkle tree can be constructed to represent the tokenId of an NFT. In
  prefs: []
  type: TYPE_NORMAL
- en: this Merkle tree structure, echa token is represented by a leaf node. For a
  prefs: []
  type: TYPE_NORMAL
- en: tokenId of size n of uint, the number of leaf nodes will be 2^n. For example,
  prefs: []
  type: TYPE_NORMAL
- en: the tokenId of uint8 will have a leaf number of 2^8=256\. Similarly, the
  prefs: []
  type: TYPE_NORMAL
- en: leaf numbers for uint16, uint32, and uint64 are 65536, 4294967296, and
  prefs: []
  type: TYPE_NORMAL
- en: 18446744073709551616, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: The location of the leaf node is equivalent to the tokenId. The leaf
  prefs: []
  type: TYPE_NORMAL
- en: indexes from left to right are arranged from 0 to (2^n-1). The content
  prefs: []
  type: TYPE_NORMAL
- en: of the leaf node is a byte32 data that is the hash of a transaction of NFT
  prefs: []
  type: TYPE_NORMAL
- en: token. The Plasma transaction format is a tuple of (slot, previousBlock,
  prefs: []
  type: TYPE_NORMAL
- en: denomination, owner, hash). Here, slot is the same as tokenId that
  prefs: []
  type: TYPE_NORMAL
- en: represents to the index of the leaf node, previousBlock is the block number
  prefs: []
  type: TYPE_NORMAL
- en: that contains this tokenId’s owner transfer, denomination is default to 1
  prefs: []
  type: TYPE_NORMAL
- en: for NFT case, owner is the new owner for this token transfer, and hash is
  prefs: []
  type: TYPE_NORMAL
- en: a sha256 or keccak256 hashing of the other parameters. Once the hash is
  prefs: []
  type: TYPE_NORMAL
- en: computed, its value is inserted to the leaf node at the location of the slot
    or
  prefs: []
  type: TYPE_NORMAL
- en: tokenId.
  prefs: []
  type: TYPE_NORMAL
- en: For a tokenId range of 0 to 2^n-1, there needs to be n level of nodes
  prefs: []
  type: TYPE_NORMAL
- en: from root node to leaf node. If we label the leaf nodes to be at level 0, then
  prefs: []
  type: TYPE_NORMAL
- en: the root node will be at level n-1\. For tokenId with size of uint16, there
    will
  prefs: []
  type: TYPE_NORMAL
- en: be 16 layers, and uint64 will have 64 layers.
  prefs: []
  type: TYPE_NORMAL
- en: The merkle tree can be initialized as an empty Merkle tree where the
  prefs: []
  type: TYPE_NORMAL
- en: leaf nodes are all hash of null.
  prefs: []
  type: TYPE_NORMAL
- en: For level zero, the hash content of the node will be hash_null = H(null)
  prefs: []
  type: TYPE_NORMAL
- en: = sha256(null)=e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934
  prefs: []
  type: TYPE_NORMAL
- en: ca495991b7852b855\.
  prefs: []
  type: TYPE_NORMAL
- en: Level 1 hash_null_null = H(H(null), H(null))
  prefs: []
  type: TYPE_NORMAL
- en: Level 2 hash is hash_null_null_null_null = H(H(H(null), H(null)),
  prefs: []
  type: TYPE_NORMAL
- en: H(H(null), H(null)))
  prefs: []
  type: TYPE_NORMAL
- en: '361'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9 Layer 2 and ethereum 2
  prefs: []
  type: TYPE_NORMAL
- en: And so on until it gets to the root of the Merkle tree.
  prefs: []
  type: TYPE_NORMAL
- en: Here, H(x) is a hash function such as sha256 or keccak256 that takes a
  prefs: []
  type: TYPE_NORMAL
- en: string as input and produces a bytes32 hash. H(x, y) is a function that packs
  prefs: []
  type: TYPE_NORMAL
- en: x and y and then gets its hash.
  prefs: []
  type: TYPE_NORMAL
- en: These precalculated values can be used for the proof computation to
  prefs: []
  type: TYPE_NORMAL
- en: improve efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: When there is a transaction, a bytes32 hash will be calculated and
  prefs: []
  type: TYPE_NORMAL
- en: stored in a leaf node. Accordingly, all the parent nodes of this leaf node
  prefs: []
  type: TYPE_NORMAL
- en: will be updated up to the root node of the Merkle tree. If there are n levels
  prefs: []
  type: TYPE_NORMAL
- en: for a Merkle tree, each update of a leaf node will trigger n-1 updates to the
  prefs: []
  type: TYPE_NORMAL
- en: parent nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Each block will have a Merkle tree. Since the number of transactions
  prefs: []
  type: TYPE_NORMAL
- en: for each block is much less than the number of possible tokenIds, the
  prefs: []
  type: TYPE_NORMAL
- en: Merkle tree will be sparsely populated. Majority of the nodes will be null.
  prefs: []
  type: TYPE_NORMAL
- en: The parent nodes that go from a leaf node to the root node will be the
  prefs: []
  type: TYPE_NORMAL
- en: default value calculated in the preceding table and can be represented by a
  prefs: []
  type: TYPE_NORMAL
- en: bit rather than a full 32-byte hash. The fact that nodes that are affected with
  prefs: []
  type: TYPE_NORMAL
- en: transactions are scattered in the Merkle tree gives the storage structure the
  prefs: []
  type: TYPE_NORMAL
- en: name of sparse Merkle tree.
  prefs: []
  type: TYPE_NORMAL
- en: Different from the Plasma MVP, the proof for Plasma Cash uses two
  prefs: []
  type: TYPE_NORMAL
- en: 'lists: one is a simplified bit list for the precalculated hashes of null or
    its'
  prefs: []
  type: TYPE_NORMAL
- en: parents; another one is the concatenated bytes32 hash list. The reason for
  prefs: []
  type: TYPE_NORMAL
- en: using a bit list is to save storage space and computation effort as most of
  prefs: []
  type: TYPE_NORMAL
- en: the nodes are not altered and have predefined values.
  prefs: []
  type: TYPE_NORMAL
- en: The mechanism for providing proofs for a leaf node for Plasma Cash
  prefs: []
  type: TYPE_NORMAL
- en: is different from that of Plasma MVP. In MVP Merkle tree, a proof is a list
  prefs: []
  type: TYPE_NORMAL
- en: of node hashes that can be used to compute with a leaf node to derive the
  prefs: []
  type: TYPE_NORMAL
- en: root node hash. It is normally the concatenated list of hashes by the sibling
  prefs: []
  type: TYPE_NORMAL
- en: nodes of the target leaf node or its parent nodes. For Plasma Cash, since it
  prefs: []
  type: TYPE_NORMAL
- en: is a sparse Merkle tree, most of the sibling nodes will be null or predefined.
  prefs: []
  type: TYPE_NORMAL
- en: These nodes can be presented by a bit=0 to mean that the default hash
  prefs: []
  type: TYPE_NORMAL
- en: value should be used. If the bit is set to 1, then the changed hash value
  prefs: []
  type: TYPE_NORMAL
- en: '362'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9 Layer 2 and ethereum 2
  prefs: []
  type: TYPE_NORMAL
- en: should be used. In the simple sparse Merkle tree shown earlier, for the
  prefs: []
  type: TYPE_NORMAL
- en: tokenId=0 leaf_a node, the proof is hash_b and hash_c_d. Since hash_b is
  prefs: []
  type: TYPE_NORMAL
- en: hash_null, which is already known, the proof can have a bit proof showing
  prefs: []
  type: TYPE_NORMAL
- en: 01 uses first bit=0 to mean that the first hash is hash_null, which is already
  prefs: []
  type: TYPE_NORMAL
- en: known, and the second bit is 1 to mean that the modified hash should
  prefs: []
  type: TYPE_NORMAL
- en: be used. This cuts down the proof size almost by half. If there are more
  prefs: []
  type: TYPE_NORMAL
- en: nodes and the data is sparsely populated, the proof size can be decreased
  prefs: []
  type: TYPE_NORMAL
- en: dramatically.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, with sparse Markle trees, the proof size is decreased, and the
  prefs: []
  type: TYPE_NORMAL
- en: computational workload is decreased as well.
  prefs: []
  type: TYPE_NORMAL
- en: There are many alterations in implementing plasma layer 2
  prefs: []
  type: TYPE_NORMAL
- en: technology. With both plasma and state channels, layer 1 does not have
  prefs: []
  type: TYPE_NORMAL
- en: full information about layer 2\. Therefore, the security of plasma or state
  prefs: []
  type: TYPE_NORMAL
- en: channel depends on layer 2 providing proof and transactions to the layer.
  prefs: []
  type: TYPE_NORMAL
- en: This dependency on layer 2 limits the usage of state channel and plasma.
  prefs: []
  type: TYPE_NORMAL
- en: The third type of layer 2 technology is called rollup. This is different
  prefs: []
  type: TYPE_NORMAL
- en: from plasma or state channels. In layer 2 rollup, the transactions are
  prefs: []
  type: TYPE_NORMAL
- en: actually repackaged and then performed in the layer 1 blockchain. With
  prefs: []
  type: TYPE_NORMAL
- en: rollup, the layer 1 blockchain no longer needs to ask users or layer 2
  prefs: []
  type: TYPE_NORMAL
- en: operators for proof and transaction data. In the following, we describe how
  prefs: []
  type: TYPE_NORMAL
- en: rollup works.
  prefs: []
  type: TYPE_NORMAL
- en: '**Layer 2 Rollup**'
  prefs: []
  type: TYPE_NORMAL
- en: In previous sections, we discussed layer 2’s state channel and plasma. State
  prefs: []
  type: TYPE_NORMAL
- en: channel has the advantage of only interacting with layer 1 when opening or
  prefs: []
  type: TYPE_NORMAL
- en: closing the state channel. However, state channels will require participants
  prefs: []
  type: TYPE_NORMAL
- en: to be enrolled in the channel and cannot send transactions to an arbitrary
  prefs: []
  type: TYPE_NORMAL
- en: address. Layer 2 plasma solved this problem by using operators to send
  prefs: []
  type: TYPE_NORMAL
- en: layer 2 transaction Merkle tree root to the layer 1 storage. However, plasma
  prefs: []
  type: TYPE_NORMAL
- en: layer 2 has the limitation of relying on layer 2 to store and provide proofs
  prefs: []
  type: TYPE_NORMAL
- en: and challenges. In this section, we introduce a third layer 2 technology
  prefs: []
  type: TYPE_NORMAL
- en: '363'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9 Layer 2 and ethereum 2
  prefs: []
  type: TYPE_NORMAL
- en: called rollup. Rollup is a technology that repackages transactions in layer
  prefs: []
  type: TYPE_NORMAL
- en: 2 and sends them as a batch transaction to layer 1\. The parameters in the
  prefs: []
  type: TYPE_NORMAL
- en: batch transactions are optimized to save gas fee and increase scalability.
  prefs: []
  type: TYPE_NORMAL
- en: There are two kinds of rollup technology that are being developed. One
  prefs: []
  type: TYPE_NORMAL
- en: is using fraud proof that allows participants to challenge layer 2 to layer
  prefs: []
  type: TYPE_NORMAL
- en: 1 transactions. Typical fraud proof solutions are called optimistic layer 2
  prefs: []
  type: TYPE_NORMAL
- en: solutions such as Arbitrum, Polygon, and Optimism. Another kind is called
  prefs: []
  type: TYPE_NORMAL
- en: validity proof that uses validation methods such as zero knowledge proof
  prefs: []
  type: TYPE_NORMAL
- en: to interact between layer 2 and layer 1\. Validity proof layer 2 solutions
  prefs: []
  type: TYPE_NORMAL
- en: include zk-rollup, zksync, etc.
  prefs: []
  type: TYPE_NORMAL
- en: '**Optimistic Layer 2**'
  prefs: []
  type: TYPE_NORMAL
- en: An overview of optimistic rollup is shown in the following diagram of
  prefs: []
  type: TYPE_NORMAL
- en: Figur[e 9-6](#p375). The top layer shows the layer 1 blockchain such as Ethereum
    mainnet. An optimistic rollup smart contract is deployed to the layer 1
  prefs: []
  type: TYPE_NORMAL
- en: mainnet. There are several major functions for the rollup smart contract.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the smart contract has a function to receive transactions from
  prefs: []
  type: TYPE_NORMAL
- en: layer 2 blockchain in a Merkle tree format and process these transactions
  prefs: []
  type: TYPE_NORMAL
- en: on layer 1\.
  prefs: []
  type: TYPE_NORMAL
- en: On layer 2, there is a similar blockchain built with OVM (Optimistic
  prefs: []
  type: TYPE_NORMAL
- en: Virtual Machine). OVM supports smart contracts and can process
  prefs: []
  type: TYPE_NORMAL
- en: transactions. The transactions on layer 2 are arranged based on the
  prefs: []
  type: TYPE_NORMAL
- en: transaction time. The ordering of transactions is done by sequencers. The
  prefs: []
  type: TYPE_NORMAL
- en: ordering of transactions is very important as there might be dependencies
  prefs: []
  type: TYPE_NORMAL
- en: among these transactions.
  prefs: []
  type: TYPE_NORMAL
- en: When transactions in layer 2 are repackaged and rolled up to layer 1,
  prefs: []
  type: TYPE_NORMAL
- en: there will be a wait period as layer 1 does not have enough information
  prefs: []
  type: TYPE_NORMAL
- en: to prove that the transactions are valid. During this wait period, the
  prefs: []
  type: TYPE_NORMAL
- en: optimistic rollup smart contract allows third parties to provide fraud
  prefs: []
  type: TYPE_NORMAL
- en: proof to disqualify a rollup and to claim reward tokens. The reward to
  prefs: []
  type: TYPE_NORMAL
- en: '364'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-375_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 9 Layer 2 and ethereum 2
  prefs: []
  type: TYPE_NORMAL
- en: fraud prover comes from the rollup transaction stakes deposited by
  prefs: []
  type: TYPE_NORMAL
- en: the aggregators. If an aggregator provides valid faulty proof, the stake
  prefs: []
  type: TYPE_NORMAL
- en: deposited by the aggregator will be forfeited.
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 9-6\.** Overview of Optimistic Rollup*'
  prefs: []
  type: TYPE_NORMAL
- en: Since optimistic rollup relies on fraud proof to ensure that the
  prefs: []
  type: TYPE_NORMAL
- en: transactions in layer 2 are properly propagated to layer 1, there is an
  prefs: []
  type: TYPE_NORMAL
- en: overhead of several days to one week for the rollup transactions to be
  prefs: []
  type: TYPE_NORMAL
- en: finalized in layer 1\. This means that to claim assets in layer one, users
  prefs: []
  type: TYPE_NORMAL
- en: will need to wait for up to one week to clear all the challenges posted
  prefs: []
  type: TYPE_NORMAL
- en: on the rollups. This is a bottleneck for optimistic rollup. To overcome
  prefs: []
  type: TYPE_NORMAL
- en: the limitation of fraud proof mechanism, the validation proof method is
  prefs: []
  type: TYPE_NORMAL
- en: proposed to allow transactions to use rollup proof to prove their validity.
  prefs: []
  type: TYPE_NORMAL
- en: In the following, we describe zk-SNARK (Zero-Knowledge Succinct Non-
  prefs: []
  type: TYPE_NORMAL
- en: interactive Argument of Knowledge) for validation proof rollup.
  prefs: []
  type: TYPE_NORMAL
- en: '365'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9 Layer 2 and ethereum 2
  prefs: []
  type: TYPE_NORMAL
- en: '**zk-SNARK Layer 2**'
  prefs: []
  type: TYPE_NORMAL
- en: zk-SNARK is a layer 2 rollup scalability solution that uses zero knowledge
  prefs: []
  type: TYPE_NORMAL
- en: proof to ensure the rollup transactions from layer 2 to layer 1 are always
  prefs: []
  type: TYPE_NORMAL
- en: in a valid state. Zero Knowledge proof is a technology for a party to prove
  prefs: []
  type: TYPE_NORMAL
- en: that a statement is true without revealing what information is processed
  prefs: []
  type: TYPE_NORMAL
- en: and how the conclusion is derived. zk-SNARK stands for Zero-Knowledge
  prefs: []
  type: TYPE_NORMAL
- en: Succinct Non-interactive Argument of Knowledge. zk-SNARK is a special
  prefs: []
  type: TYPE_NORMAL
- en: 'zero knowledge proof whose mechanism has the following characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Succinct** – The proof is short and easily verifiable.'
  prefs: []
  type: TYPE_NORMAL
- en: This is best for onchain verification, where the gas
  prefs: []
  type: TYPE_NORMAL
- en: costs for the Ethereum, and other networks are
  prefs: []
  type: TYPE_NORMAL
- en: expensive and many nodes will need to verify the
  prefs: []
  type: TYPE_NORMAL
- en: same statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**Non-interactive** – Proof generation and verification'
  prefs: []
  type: TYPE_NORMAL
- en: do not require users’ manual interventions.
  prefs: []
  type: TYPE_NORMAL
- en: The offchain applications can programmably
  prefs: []
  type: TYPE_NORMAL
- en: generate proofs, and onchain smart contracts can
  prefs: []
  type: TYPE_NORMAL
- en: verify proofs.
  prefs: []
  type: TYPE_NORMAL
- en: '**Argument of Knowledge** – Meaning that the'
  prefs: []
  type: TYPE_NORMAL
- en: statements can be confirmed or falsified with zero
  prefs: []
  type: TYPE_NORMAL
- en: knowledge proof system. The communications
  prefs: []
  type: TYPE_NORMAL
- en: parties gain knowledge of the other party without
  prefs: []
  type: TYPE_NORMAL
- en: the need to disclose the private information and
  prefs: []
  type: TYPE_NORMAL
- en: knowledge.
  prefs: []
  type: TYPE_NORMAL
- en: Zero knowledge proof is viewed as no private knowledge leak proof.
  prefs: []
  type: TYPE_NORMAL
- en: It means that a person can prove that a knowledge is possessed without
  prefs: []
  type: TYPE_NORMAL
- en: revealing it. Normally, in order to convince another person that you know
  prefs: []
  type: TYPE_NORMAL
- en: something, you have to reveal that knowledge. Zero Knowledge proof is a
  prefs: []
  type: TYPE_NORMAL
- en: privacy-enhanced crypto computation that can prove beyond reasonable
  prefs: []
  type: TYPE_NORMAL
- en: doubt about a statement without leaking that statement.
  prefs: []
  type: TYPE_NORMAL
- en: '366'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-377_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 9 Layer 2 and ethereum 2
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: Alice wants to show to Bob that she knows how to do square'
  prefs: []
  type: TYPE_NORMAL
- en: root. If the test is just to supply an input and an output such as input=16
  prefs: []
  type: TYPE_NORMAL
- en: and output=4, the third party can know this is about square root. If the
  prefs: []
  type: TYPE_NORMAL
- en: input and output are hashed, then the third party will not know that the
  prefs: []
  type: TYPE_NORMAL
- en: rule of square root is used.
  prefs: []
  type: TYPE_NORMAL
- en: Zero knowledge proof can be used in privacy computing and layer
  prefs: []
  type: TYPE_NORMAL
- en: 2 rollup. With zero knowledge proof such as zk-SNARK, the rollup
  prefs: []
  type: TYPE_NORMAL
- en: transactions between layer 1 and layer 2 can be validated without the need
  prefs: []
  type: TYPE_NORMAL
- en: 'of third-party challenges. In the following figure (Figure [9-7](#p377)), we
    explain who zk-SNARK can be used for layer 2 rollup solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 9-7\.** zk-SNARK work flow*'
  prefs: []
  type: TYPE_NORMAL
- en: '367'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9 Layer 2 and ethereum 2
  prefs: []
  type: TYPE_NORMAL
- en: To use zero knowledge proof, first is to define the tasks. This could
  prefs: []
  type: TYPE_NORMAL
- en: be proof a person is over a certain age, a person possesses a password, a
  prefs: []
  type: TYPE_NORMAL
- en: transaction is signed with a private key, the transactions in a Merkle tree
  prefs: []
  type: TYPE_NORMAL
- en: are all valid, etc. Then variables will need to be defined, and functions will
  prefs: []
  type: TYPE_NORMAL
- en: need to be written to ensure the proofing conditions are met. For example,
  prefs: []
  type: TYPE_NORMAL
- en: 'the functions for the preceding tasks will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: //Define a function to check the age is over certain age such as
  prefs: []
  type: TYPE_NORMAL
- en: drinking age
  prefs: []
  type: TYPE_NORMAL
- en: function proveAge(private age) {
  prefs: []
  type: TYPE_NORMAL
- en: const Drinking_Age = 21;
  prefs: []
  type: TYPE_NORMAL
- en: require (age >= Drinking_Age);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: //Define a function for checking a person possesses a password by
  prefs: []
  type: TYPE_NORMAL
- en: checking the hash of the password matches a known value
  prefs: []
  type: TYPE_NORMAL
- en: function provePassword(private string password, public
  prefs: []
  type: TYPE_NORMAL
- en: bytes32 hash) {
  prefs: []
  type: TYPE_NORMAL
- en: bytes32 password_hash_calculated = sha256(password);
  prefs: []
  type: TYPE_NORMAL
- en: require( password_hash == password_hash_calculated);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: Once the knowledge statement functions are defined, they will need
  prefs: []
  type: TYPE_NORMAL
- en: to be simplified or reduced to meet the zero knowledge proof format.
  prefs: []
  type: TYPE_NORMAL
- en: This is because the zero knowledge proof has some requirements such as
  prefs: []
  type: TYPE_NORMAL
- en: not revealing any private variables and needing to be stateless. There are
  prefs: []
  type: TYPE_NORMAL
- en: many ways to do this. One of the ways is to rewrite the functions to meet
  prefs: []
  type: TYPE_NORMAL
- en: the R1CS (rank-1 constraint systems) format. This is done by writing the
  prefs: []
  type: TYPE_NORMAL
- en: functions using circuit models. Once R1CS are defined, a QAP (Quadratic
  prefs: []
  type: TYPE_NORMAL
- en: Arithmetic Program) is used to represent the knowledge statement. Using
  prefs: []
  type: TYPE_NORMAL
- en: QAP, the system can generate a proof key and a verification key. The proof
  prefs: []
  type: TYPE_NORMAL
- en: key is given to a prover, and the verification key is given to a verifier.
  prefs: []
  type: TYPE_NORMAL
- en: '368'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-379_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 9 Layer 2 and ethereum 2
  prefs: []
  type: TYPE_NORMAL
- en: As shown in the following figure (Figure [9-8](#p379)), the prover uses the
    proof key, public inputs, and witness to generate a proof. The proof is then sent
  prefs: []
  type: TYPE_NORMAL
- en: to the verifier. The verifier uses public knowledge or public variable data
  prefs: []
  type: TYPE_NORMAL
- en: and the proof to verify that the knowledge statement is true or false.
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 9-8\.** zk-SNARK proof and verification*'
  prefs: []
  type: TYPE_NORMAL
- en: Fully understanding zero knowledge proof and zk-SNARK requires a
  prefs: []
  type: TYPE_NORMAL
- en: strong mathematical background. Here, we summarize conceptually how
  prefs: []
  type: TYPE_NORMAL
- en: 'zk-SNARK works:'
  prefs: []
  type: TYPE_NORMAL
- en: • Zero knowledge proof allows two parties to verify a
  prefs: []
  type: TYPE_NORMAL
- en: statement without disclosing private information.
  prefs: []
  type: TYPE_NORMAL
- en: • zk-SNARK is a subset of zero knowledge proof that
  prefs: []
  type: TYPE_NORMAL
- en: meets the succinct, non-interactive, and augment of
  prefs: []
  type: TYPE_NORMAL
- en: knowledge requirements.
  prefs: []
  type: TYPE_NORMAL
- en: • Layer 2 zk-rollup uses zk-SNARK because this is
  prefs: []
  type: TYPE_NORMAL
- en: computationally feasible onchain. The heavy duty
  prefs: []
  type: TYPE_NORMAL
- en: computing is carried out offchain to generate a proof.
  prefs: []
  type: TYPE_NORMAL
- en: The verification step is efficient and succinct and can
  prefs: []
  type: TYPE_NORMAL
- en: be carried out onchain with smart contracts.
  prefs: []
  type: TYPE_NORMAL
- en: '369'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9 Layer 2 and ethereum 2
  prefs: []
  type: TYPE_NORMAL
- en: • To design a zk-SNARK, the first thing is to define a
  prefs: []
  type: TYPE_NORMAL
- en: proof task. This task is to define a function to verify a
  prefs: []
  type: TYPE_NORMAL
- en: statement.
  prefs: []
  type: TYPE_NORMAL
- en: • The defined verification function is then flattened and
  prefs: []
  type: TYPE_NORMAL
- en: reduced to multiple steps of arithmetic operations.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, these arithmetic operations are called zero
  prefs: []
  type: TYPE_NORMAL
- en: knowledge circuits. The circuits can take private and
  prefs: []
  type: TYPE_NORMAL
- en: public inputs and generate a corresponding output.
  prefs: []
  type: TYPE_NORMAL
- en: • Once an arithmetic circuit is defined, a proof key and
  prefs: []
  type: TYPE_NORMAL
- en: a verification key can be generated through a setup
  prefs: []
  type: TYPE_NORMAL
- en: process. The proof key is given to a prover, and the
  prefs: []
  type: TYPE_NORMAL
- en: verification key is given to a verifier. The verifier can be
  prefs: []
  type: TYPE_NORMAL
- en: a smart contract.
  prefs: []
  type: TYPE_NORMAL
- en: • The prover can do offchain computation with a proof
  prefs: []
  type: TYPE_NORMAL
- en: key and generate a proof.
  prefs: []
  type: TYPE_NORMAL
- en: • The proof and the public data are then sent to a
  prefs: []
  type: TYPE_NORMAL
- en: verification smart contract to verify.
  prefs: []
  type: TYPE_NORMAL
- en: zk-SNARK is still under development, and it is foreseeable that more
  prefs: []
  type: TYPE_NORMAL
- en: research will generate better zk-SNARK mechanisms for layer 2 rollup.
  prefs: []
  type: TYPE_NORMAL
- en: '**Ethereum 2**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Major Changes in Ethereum 2**'
  prefs: []
  type: TYPE_NORMAL
- en: Both Ethereum 2 and layer 2 are developed to solve scalability problems in
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum mainnet and improve energy efficiency. In fact, sometimes, the
  prefs: []
  type: TYPE_NORMAL
- en: layer 2 solution is jokingly called Ethereum 1.5\. Ethereum 2 is a promising
  prefs: []
  type: TYPE_NORMAL
- en: network improvement to Ethereum 1 with the following new components
  prefs: []
  type: TYPE_NORMAL
- en: and features.
  prefs: []
  type: TYPE_NORMAL
- en: '370'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9 Layer 2 and ethereum 2
  prefs: []
  type: TYPE_NORMAL
- en: '**Transferring from POW to POS**'
  prefs: []
  type: TYPE_NORMAL
- en: Compared with proof-of-work (POW) consensus, proof of state (POS) has
  prefs: []
  type: TYPE_NORMAL
- en: the advantages of energy efficiency, higher scalability, better incentive, and
  prefs: []
  type: TYPE_NORMAL
- en: shorter block time. POS allows one system to have additional computing
  prefs: []
  type: TYPE_NORMAL
- en: power to do extra work such as hosting multiple staking accounts or
  prefs: []
  type: TYPE_NORMAL
- en: running services to connect with beacon chains or sidechains.
  prefs: []
  type: TYPE_NORMAL
- en: '**Beacon Chain**'
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum beacon chain is an essential proof-of-stake blockchain that
  prefs: []
  type: TYPE_NORMAL
- en: connects stakers and shards. The stakers are from Ethereum 1 mainnet
  prefs: []
  type: TYPE_NORMAL
- en: accounts that send their ether asset to a staking smart contract to
  prefs: []
  type: TYPE_NORMAL
- en: participate in the beacon chain block generations. The shards are storage
  prefs: []
  type: TYPE_NORMAL
- en: and computational blockchains that expand the features of EVM and state
  prefs: []
  type: TYPE_NORMAL
- en: storage of the mainnet.
  prefs: []
  type: TYPE_NORMAL
- en: '**Sharding**'
  prefs: []
  type: TYPE_NORMAL
- en: Sharding is a new architecture of Ethereum blockchains that allow a
  prefs: []
  type: TYPE_NORMAL
- en: hierarchical set of blockchains to process transactions independently
  prefs: []
  type: TYPE_NORMAL
- en: and then aggregate block hashes to its parent shard and eventually store
  prefs: []
  type: TYPE_NORMAL
- en: the hash on the beacon chain. Sharding allows a cluster of blockchains
  prefs: []
  type: TYPE_NORMAL
- en: to process transactions and execute smart contracts simultaneously and
  prefs: []
  type: TYPE_NORMAL
- en: hence dramatically improve the scalability of Ethereum 1 mainnet.
  prefs: []
  type: TYPE_NORMAL
- en: '**Ethereum 2 Architectural Overview**'
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum 2 is an extension of Ethereum 1 with added beacon chains and
  prefs: []
  type: TYPE_NORMAL
- en: sharding chains. The following diagram (Figur[e 9-9) sho](#p382)ws an overview
    of Ethereum 2’s architecture.
  prefs: []
  type: TYPE_NORMAL
- en: '371'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-382_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 9 Layer 2 and ethereum 2
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 9-9\.** Ethereum 2 topology and workflow*'
  prefs: []
  type: TYPE_NORMAL
- en: There are three blockchains in Ethereum 2 including the legacy
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum mainnet. The Ethereum mainnet provides the staking assets for
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum 2’s proof-of-stake mechanism. The beacon chain is a proof-of-
  prefs: []
  type: TYPE_NORMAL
- en: stake-based blockchain that records the staking information, generates
  prefs: []
  type: TYPE_NORMAL
- en: random numbers, proposes validators, and connects with sharding
  prefs: []
  type: TYPE_NORMAL
- en: blockchain to record the data and transaction Merkle tree of sharding
  prefs: []
  type: TYPE_NORMAL
- en: blockchains. Then there are also multiple sharding blockchains that are
  prefs: []
  type: TYPE_NORMAL
- en: used to store Ethereum 2 data and carry out EVM computations and
  prefs: []
  type: TYPE_NORMAL
- en: process transactions.
  prefs: []
  type: TYPE_NORMAL
- en: To generate and validate blocks for the three types of blockchains
  prefs: []
  type: TYPE_NORMAL
- en: mentioned earlier for Ethereum 2, there are four types of client nodes that
  prefs: []
  type: TYPE_NORMAL
- en: we want to mention. The first one is the Ethereum 1 client nodes such as
  prefs: []
  type: TYPE_NORMAL
- en: geth client that generate blocks for Ethereum 1 mainnet. The second one
  prefs: []
  type: TYPE_NORMAL
- en: is beacon nodes that propose blocks for the beacon chain. The third one is
  prefs: []
  type: TYPE_NORMAL
- en: validation nodes for the beacon chain. The validator node will generate or
  prefs: []
  type: TYPE_NORMAL
- en: validate beacon chain blocks through beacon chain nodes. Then the fourth
  prefs: []
  type: TYPE_NORMAL
- en: '372'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9 Layer 2 and ethereum 2
  prefs: []
  type: TYPE_NORMAL
- en: one is the sharding nodes that are responsible for blocks of the sharding
  prefs: []
  type: TYPE_NORMAL
- en: blockchains.
  prefs: []
  type: TYPE_NORMAL
- en: The blockchain nodes mentioned earlier connect and communicate
  prefs: []
  type: TYPE_NORMAL
- en: with one another through peer-to-peer or RCP protocols. Several
  prefs: []
  type: TYPE_NORMAL
- en: interactions/edges in the diagram are labeled as A, B, C, D, E, F, and G.
  prefs: []
  type: TYPE_NORMAL
- en: The edge A is an interaction of an account owner wallet with Ethereum
  prefs: []
  type: TYPE_NORMAL
- en: 1 node. The interaction allows a user to construct and sign a transaction
  prefs: []
  type: TYPE_NORMAL
- en: in a wallet and then send the signed translation to an Ethereum 1 client
  prefs: []
  type: TYPE_NORMAL
- en: node. The client node then validates the transaction and packages to a
  prefs: []
  type: TYPE_NORMAL
- en: new block. In the diagram, the wallet is only connected to an Ethereum 1
  prefs: []
  type: TYPE_NORMAL
- en: node as there is currently no Ethereum 2 wallet to interact with the beacon
  prefs: []
  type: TYPE_NORMAL
- en: chain yet.
  prefs: []
  type: TYPE_NORMAL
- en: The edge B represents Ethereum 1 client nodes to view Ethereum 1
  prefs: []
  type: TYPE_NORMAL
- en: mainnet blocks and transactions or write blocks to the blockchain. In the
  prefs: []
  type: TYPE_NORMAL
- en: context of Ethereum 2, the interaction B is mainly for a staker to stake an
  prefs: []
  type: TYPE_NORMAL
- en: asset to the Ethereum 2 staking smart contract deployed on Ethereum 1
  prefs: []
  type: TYPE_NORMAL
- en: mainnet. Once an asset is deployed as a stake, the smart contract function
  prefs: []
  type: TYPE_NORMAL
- en: will emit an event to show the staking address and amount.
  prefs: []
  type: TYPE_NORMAL
- en: The edge C is an interaction between an Ethereum 1 client node and
  prefs: []
  type: TYPE_NORMAL
- en: a beacon node. The staking information in Ethereum 1 blockchain should
  prefs: []
  type: TYPE_NORMAL
- en: be visible to the beacon nodes. Beacon nodes use RPC to connect with a
  prefs: []
  type: TYPE_NORMAL
- en: client node and get all the events emitted by the staking smart contract.
  prefs: []
  type: TYPE_NORMAL
- en: When the new staking information is retrieved from Ethereum mainnet,
  prefs: []
  type: TYPE_NORMAL
- en: the beacon node generates a block to keep the new staking information.
  prefs: []
  type: TYPE_NORMAL
- en: The edge D is for interaction between the beacon nodes and Sharding
  prefs: []
  type: TYPE_NORMAL
- en: nodes. The edge E is for sharding nodes to propose blocks for sharding
  prefs: []
  type: TYPE_NORMAL
- en: blockchain. Sharding nodes are to carry out the data storage and
  prefs: []
  type: TYPE_NORMAL
- en: transaction processing.
  prefs: []
  type: TYPE_NORMAL
- en: The edge F is for interactions and communications between a validator
  prefs: []
  type: TYPE_NORMAL
- en: node and a beacon node. Proof-of-Stake (POS) miners need to run client
  prefs: []
  type: TYPE_NORMAL
- en: nodes to request tasks from the beacon chain, package transactions,
  prefs: []
  type: TYPE_NORMAL
- en: validate blocks, and propose blocks. Ethereum 2 architecture separates
  prefs: []
  type: TYPE_NORMAL
- en: '373'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9 Layer 2 and ethereum 2
  prefs: []
  type: TYPE_NORMAL
- en: beacon nodes from validator nodes. The beacon node does the work of
  prefs: []
  type: TYPE_NORMAL
- en: managing communications and management of epoch, slots, random
  prefs: []
  type: TYPE_NORMAL
- en: number generation, and validator selections. The validator nodes do the
  prefs: []
  type: TYPE_NORMAL
- en: processing of transactions and blocks. The miner-specific information such
  prefs: []
  type: TYPE_NORMAL
- en: as miner credentials is only stored in validator nodes, not in the beacon
  prefs: []
  type: TYPE_NORMAL
- en: node. The communication between beacon nodes and miner nodes is done
  prefs: []
  type: TYPE_NORMAL
- en: through RPC protocol.
  prefs: []
  type: TYPE_NORMAL
- en: The edge G is beacon nodes to propose beacon blocks to the beacon
  prefs: []
  type: TYPE_NORMAL
- en: chain. Each beacon node will synchronize with the beacon chain, manage
  prefs: []
  type: TYPE_NORMAL
- en: stakers registry, organize validators into committees, manage epoch and
  prefs: []
  type: TYPE_NORMAL
- en: slots, generate a random number, assign validator roles, and propose new
  prefs: []
  type: TYPE_NORMAL
- en: blocks to the beacon chain.
  prefs: []
  type: TYPE_NORMAL
- en: From Ethereum 2 architectural topology and interactions, it is clear
  prefs: []
  type: TYPE_NORMAL
- en: that Ethereum 1 mainnet is still an essential component of Ethereum 2\.
  prefs: []
  type: TYPE_NORMAL
- en: The staking power of POS comes from the assets designated by owners
  prefs: []
  type: TYPE_NORMAL
- en: to participate in the POS consensus for Ethereum 2\. It is important to
  prefs: []
  type: TYPE_NORMAL
- en: understand the process for Ethereum 1 to migrate to Ethereum 2\.
  prefs: []
  type: TYPE_NORMAL
- en: '**Migrating from Ethereum 1 to Ethereum 2: POS**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Deposit, Staking, and Slashing**'
  prefs: []
  type: TYPE_NORMAL
- en: The migration from Ethereum 1 to Ethereum 2 has been done in a phased
  prefs: []
  type: TYPE_NORMAL
- en: approach. The first phase of Ethereum 2 is to build a beacon chain
  prefs: []
  type: TYPE_NORMAL
- en: based on proof-of-stake consensus. In the following, we mention some
  prefs: []
  type: TYPE_NORMAL
- en: important concepts and steps for staking Ethereum 1 asset to migrating to
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum 2\.
  prefs: []
  type: TYPE_NORMAL
- en: The assets of the proof of stake are deposited in Ethereum 1 mainnet
  prefs: []
  type: TYPE_NORMAL
- en: through a deposit smart contract. In the following, a snippet of deposit
  prefs: []
  type: TYPE_NORMAL
- en: contract interface is shown.
  prefs: []
  type: TYPE_NORMAL
- en: '374'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9 Layer 2 and ethereum 2
  prefs: []
  type: TYPE_NORMAL
- en: // Deposit contract interface based on the following specs for
  prefs: []
  type: TYPE_NORMAL
- en: 'Ethereum 2:'
  prefs: []
  type: TYPE_NORMAL
- en: // https://github.com/ethereum/eth2.0-specs
  prefs: []
  type: TYPE_NORMAL
- en: '*interface IDepositContract {*'
  prefs: []
  type: TYPE_NORMAL
- en: '*/// @notice A processed deposit event.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*event DepositEvent(*'
  prefs: []
  type: TYPE_NORMAL
- en: '*bytes pubkey,*'
  prefs: []
  type: TYPE_NORMAL
- en: '*bytes withdrawal_credentials,*'
  prefs: []
  type: TYPE_NORMAL
- en: '*bytes amount,*'
  prefs: []
  type: TYPE_NORMAL
- en: '*bytes signature,*'
  prefs: []
  type: TYPE_NORMAL
- en: '*bytes index*'
  prefs: []
  type: TYPE_NORMAL
- en: '*);*'
  prefs: []
  type: TYPE_NORMAL
- en: '*/// @notice Submit a Phase 0 DepositData object.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*/// @param pubkey A BLS12-381 public key.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*/// @param withdrawal_credentials Commitment to a public*'
  prefs: []
  type: TYPE_NORMAL
- en: '*key for withdrawals.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*/// @param signature A BLS12-381 signature.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*/// @param deposit_data_root The SHA-256 hash of the SSZ-*'
  prefs: []
  type: TYPE_NORMAL
- en: '*encoded DepositData object.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*/// Used as a protection against malformed input.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*function deposit(*'
  prefs: []
  type: TYPE_NORMAL
- en: '*bytes calldata pubkey,*'
  prefs: []
  type: TYPE_NORMAL
- en: '*bytes calldata withdrawal_credentials,*'
  prefs: []
  type: TYPE_NORMAL
- en: '*bytes calldata signature,*'
  prefs: []
  type: TYPE_NORMAL
- en: '*bytes32 deposit_data_root*'
  prefs: []
  type: TYPE_NORMAL
- en: '*) external payable;*'
  prefs: []
  type: TYPE_NORMAL
- en: '*/// @notice Query the current deposit root hash.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*/// @return The deposit root hash.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*function get_deposit_root() external view returns (bytes32);*'
  prefs: []
  type: TYPE_NORMAL
- en: '*/// @notice Query the current deposit count.*'
  prefs: []
  type: TYPE_NORMAL
- en: '375'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9 Layer 2 and ethereum 2
  prefs: []
  type: TYPE_NORMAL
- en: '*/// @return The deposit count encoded as a little endian*'
  prefs: []
  type: TYPE_NORMAL
- en: '*64-bit number.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*function get_deposit_count() external view returns (bytes*'
  prefs: []
  type: TYPE_NORMAL
- en: '*memory);*'
  prefs: []
  type: TYPE_NORMAL
- en: '*}*'
  prefs: []
  type: TYPE_NORMAL
- en: The deposit smart contract uses a sparse Merkle tree to store the stake
  prefs: []
  type: TYPE_NORMAL
- en: deposit records and use a deposit event to notify external programs such
  prefs: []
  type: TYPE_NORMAL
- en: as beacon nodes. Major functions supported by this smart contract include
  prefs: []
  type: TYPE_NORMAL
- en: deposit, get_deposit_root, and get_deposit_count. When depositing a
  prefs: []
  type: TYPE_NORMAL
- en: stake, users need to supply information such as public key, withdrawal
  prefs: []
  type: TYPE_NORMAL
- en: credential, owner signature, and deposit data root hash. The deposit
  prefs: []
  type: TYPE_NORMAL
- en: amount is in msg.value and hence is not a function parameter. The deposit
  prefs: []
  type: TYPE_NORMAL
- en: ID is incremented automatically and does not need to be supplied.
  prefs: []
  type: TYPE_NORMAL
- en: When depositing assets to the deposit smart contract, one key point
  prefs: []
  type: TYPE_NORMAL
- en: to remember is that Ethereum 1 public key and private key pair curve has
  prefs: []
  type: TYPE_NORMAL
- en: been replaced with BLS12-381 curve that is more versatile. The Ethereum
  prefs: []
  type: TYPE_NORMAL
- en: 2 key pair will need to be generated through a new tool with a 24-word
  prefs: []
  type: TYPE_NORMAL
- en: mnemonic phrase. Different from Ethereum 1, Ethereum 2 has both
  prefs: []
  type: TYPE_NORMAL
- en: withdraw keys and validator keys for an account. One set of mnemonic
  prefs: []
  type: TYPE_NORMAL
- en: phrases can generate multiple withdraw public keys, and one withdraw
  prefs: []
  type: TYPE_NORMAL
- en: key can derive multiple validator keys.
  prefs: []
  type: TYPE_NORMAL
- en: '**Run an Ethereum 2 Validator Node**'
  prefs: []
  type: TYPE_NORMAL
- en: '**with POS Staking**'
  prefs: []
  type: TYPE_NORMAL
- en: Running a validator node will get rewards from Ethereum 2 blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike Bitcoin or Ethereum mining, Ethereum 2 is based on proof of
  prefs: []
  type: TYPE_NORMAL
- en: stake, and hence, all the nodes will get rewarded if the nodes are online
  prefs: []
  type: TYPE_NORMAL
- en: and function correctly. The reward return rate is about 3–8% APR at
  prefs: []
  type: TYPE_NORMAL
- en: ether value. The following shows major steps to build an Ethereum 2
  prefs: []
  type: TYPE_NORMAL
- en: mining node.
  prefs: []
  type: TYPE_NORMAL
- en: '376'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9 Layer 2 and ethereum 2
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, Ethereum 2 depends on Ethereum 1\. Therefore, an Ethereum
  prefs: []
  type: TYPE_NORMAL
- en: 1 node is still needed. This node can be built with geth or can be a stable
  prefs: []
  type: TYPE_NORMAL
- en: public node with a static IP.
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, users need to allocate staking funds. A minimum of 32 ethers
  prefs: []
  type: TYPE_NORMAL
- en: is needed to run a validator node. Users also need to consider that if their
  prefs: []
  type: TYPE_NORMAL
- en: node goes down, there is a penalty that will decrease the staking balance.
  prefs: []
  type: TYPE_NORMAL
- en: Thirdly, users need to prepare a deposit account. There is a deposit
  prefs: []
  type: TYPE_NORMAL
- en: tool that can be used to generate mnemonic phrases and derive
  prefs: []
  type: TYPE_NORMAL
- en: withdrawal keys and validator keys. These keys are extremely important
  prefs: []
  type: TYPE_NORMAL
- en: and should be safeguarded. If the mnemonic phrases and withdrawal keys
  prefs: []
  type: TYPE_NORMAL
- en: are lost, the locked ether for Ethereum 2 will be lost.
  prefs: []
  type: TYPE_NORMAL
- en: Fourthly, download and run beacon nodes and validator nodes.
  prefs: []
  type: TYPE_NORMAL
- en: There are multiple vendors who provide the packages to run beacon and
  prefs: []
  type: TYPE_NORMAL
- en: validator nodes.
  prefs: []
  type: TYPE_NORMAL
- en: And finally, use scripts or third-party tools to deposit assets to deposit
  prefs: []
  type: TYPE_NORMAL
- en: contracts. The deposited event will be detected by the beacon node. The
  prefs: []
  type: TYPE_NORMAL
- en: deposit will be in pending state for a certain time and then become active.
  prefs: []
  type: TYPE_NORMAL
- en: One important factor to consider is that unlike proof-of-work
  prefs: []
  type: TYPE_NORMAL
- en: consensus, the proof-of-stake mechanism implements penalties for
  prefs: []
  type: TYPE_NORMAL
- en: validators. The Ethereum beacon chain implemented two penalties for
  prefs: []
  type: TYPE_NORMAL
- en: validators. One is the inactivity penalty that punishes validator nodes
  prefs: []
  type: TYPE_NORMAL
- en: that are offline or do not propose/attest a block. Another one is slashing
  prefs: []
  type: TYPE_NORMAL
- en: that punishes validators that construct or attest malicious blocks. It is
  prefs: []
  type: TYPE_NORMAL
- en: recommended that validators run a monitoring program to ensure that
  prefs: []
  type: TYPE_NORMAL
- en: their nodes are working actively and correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Many tools and solutions have been developed on this. Users can
  prefs: []
  type: TYPE_NORMAL
- en: check the Ethereum 2 website to see the recommended ones.
  prefs: []
  type: TYPE_NORMAL
- en: '377'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9 Layer 2 and ethereum 2
  prefs: []
  type: TYPE_NORMAL
- en: '**Uncertainties with Ethereum 2**'
  prefs: []
  type: TYPE_NORMAL
- en: Although Ethereum 2 has been viewed as a promising solution for
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum mainnet scalability solutions, there are still some uncertainties
  prefs: []
  type: TYPE_NORMAL
- en: about this project. For example, the sharding chain is still not finalized.
  prefs: []
  type: TYPE_NORMAL
- en: There has been a lot of debates on sharding regarding security and the
  prefs: []
  type: TYPE_NORMAL
- en: staking economy. It is recommended that readers keep an open mind on
  prefs: []
  type: TYPE_NORMAL
- en: the road map, implementation, and rollout of Ethereum 2\.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we explained various layer 2 scalability solutions including
  prefs: []
  type: TYPE_NORMAL
- en: state channel, plasma, rollups, as well as Ethereum 2 technology.
  prefs: []
  type: TYPE_NORMAL
- en: Each technology has its pros and cons. When designing decentralized
  prefs: []
  type: TYPE_NORMAL
- en: applications, it is important to consider the usage models of the
  prefs: []
  type: TYPE_NORMAL
- en: applications and choose the most feasible technology to scale out the
  prefs: []
  type: TYPE_NORMAL
- en: solutions.
  prefs: []
  type: TYPE_NORMAL
- en: '378'
  prefs: []
  type: TYPE_NORMAL
- en: '**CHAPTER 10**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Fund a Project:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Tokens and Gas Fees**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Introduction**'
  prefs: []
  type: TYPE_NORMAL
- en: In previous chapters, we went through the technical aspects of smart
  prefs: []
  type: TYPE_NORMAL
- en: contract coding, development, and deployment as well as blockchain
  prefs: []
  type: TYPE_NORMAL
- en: security and scalability.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will discuss how to fund a project from both the
  prefs: []
  type: TYPE_NORMAL
- en: business and technical aspects of smart contracts.
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum has achieved several milestones relevant to project
  prefs: []
  type: TYPE_NORMAL
- en: funding, such as the Initial Coin Offering (ICO), Nonfungible Token
  prefs: []
  type: TYPE_NORMAL
- en: (NFT), decentralized finance (DeFi), and Decentralized Autonomous
  prefs: []
  type: TYPE_NORMAL
- en: Organization (DAO). It is foreseeable that the Security Token Offering
  prefs: []
  type: TYPE_NORMAL
- en: (STO), Central Bank Digital Currency (CBDC), and other decentralized
  prefs: []
  type: TYPE_NORMAL
- en: applications will soon gain popularity. All of these use cases have one
  prefs: []
  type: TYPE_NORMAL
- en: 'common and essential element: the token. In the following, we describe'
  prefs: []
  type: TYPE_NORMAL
- en: how tokens are used to represent assets to fund a project and how to use
  prefs: []
  type: TYPE_NORMAL
- en: smart contracts to program tokens.
  prefs: []
  type: TYPE_NORMAL
- en: © Weijia Zhang and Tej Anand 2022
  prefs: []
  type: TYPE_NORMAL
- en: '379'
  prefs: []
  type: TYPE_NORMAL
- en: W. Zhang and T. Anand, *Blockchain and Ethereum Smart Contract Solution Development*,
  prefs: []
  type: TYPE_NORMAL
- en: '[https://doi.org/10.1007/978-1-4842-8164-2_10](https://doi.org/10.1007/978-1-4842-8164-2_10#DOI)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Chapter 10 Fund a projeCt: tokens and Gas Fees'
  prefs: []
  type: TYPE_NORMAL
- en: '**Tokens for Funding Ecosystem Projects**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Tokens in ICO and DeFi**'
  prefs: []
  type: TYPE_NORMAL
- en: An ICO in Ethereum is a fundraising mechanism that was popular around
  prefs: []
  type: TYPE_NORMAL
- en: the year 2017\. It is enabled by the ERC20 token, which allows tokens to
  prefs: []
  type: TYPE_NORMAL
- en: be programmable, distributed, and traded in the Ethereum ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: The ERC20 token is fungible, meaning that it only has value and cannot
  prefs: []
  type: TYPE_NORMAL
- en: be distinguished among each other. The ERC20 token follows the
  prefs: []
  type: TYPE_NORMAL
- en: 'specification of EIP-20 located in the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://eips.ethereum.org/EIPS/eip- 20](https://eips.ethereum.org/EIPS/eip-20)'
  prefs: []
  type: TYPE_NORMAL
- en: In the ERC20 specification, several standard functions as well as two
  prefs: []
  type: TYPE_NORMAL
- en: events are defined, and all smart contracts that issue ERC20 tokens will
  prefs: []
  type: TYPE_NORMAL
- en: need to implement them accordingly. The function specifications are as
  prefs: []
  type: TYPE_NORMAL
- en: 'follows:'
  prefs: []
  type: TYPE_NORMAL
- en: // Returns the name of the token
  prefs: []
  type: TYPE_NORMAL
- en: function name() public view returns (string)
  prefs: []
  type: TYPE_NORMAL
- en: //Returns the name of the symbol. Normally several capitalized
  prefs: []
  type: TYPE_NORMAL
- en: letters, optional.
  prefs: []
  type: TYPE_NORMAL
- en: function symbol() public view returns (string)
  prefs: []
  type: TYPE_NORMAL
- en: // Returns the number of decimals the token uses.
  prefs: []
  type: TYPE_NORMAL
- en: function decimals() public view returns (uint8)
  prefs: []
  type: TYPE_NORMAL
- en: // Returns the total supply of the token
  prefs: []
  type: TYPE_NORMAL
- en: function totalSupply() public view returns (uint256)
  prefs: []
  type: TYPE_NORMAL
- en: // Returns the account balance of another account with
  prefs: []
  type: TYPE_NORMAL
- en: address _owner.
  prefs: []
  type: TYPE_NORMAL
- en: function balanceOf(address _owner) public view returns (uint256
  prefs: []
  type: TYPE_NORMAL
- en: balance)
  prefs: []
  type: TYPE_NORMAL
- en: '380'
  prefs: []
  type: TYPE_NORMAL
- en: 'Chapter 10 Fund a projeCt: tokens and Gas Fees'
  prefs: []
  type: TYPE_NORMAL
- en: //Transfers _value amount of tokens to address _to, and MUST
  prefs: []
  type: TYPE_NORMAL
- en: fire the Transfer event.
  prefs: []
  type: TYPE_NORMAL
- en: function transfer(address _to, uint256 _value) public returns
  prefs: []
  type: TYPE_NORMAL
- en: (bool success)
  prefs: []
  type: TYPE_NORMAL
- en: // Transfers _value amount of tokens from address _from to
  prefs: []
  type: TYPE_NORMAL
- en: address _to, and MUST fire the Transfer event.
  prefs: []
  type: TYPE_NORMAL
- en: function transferFrom(address _from, address _to, uint256 _
  prefs: []
  type: TYPE_NORMAL
- en: value) public returns (bool success)
  prefs: []
  type: TYPE_NORMAL
- en: //Allows _spender to withdraw from your account multiple times,
  prefs: []
  type: TYPE_NORMAL
- en: up to the _value amount. If this function is called again it
  prefs: []
  type: TYPE_NORMAL
- en: overwrites the current allowance with _value.
  prefs: []
  type: TYPE_NORMAL
- en: function approve(address _spender, uint256 _value) public
  prefs: []
  type: TYPE_NORMAL
- en: returns (bool success)
  prefs: []
  type: TYPE_NORMAL
- en: //Returns the amount which _spender is still allowed to
  prefs: []
  type: TYPE_NORMAL
- en: withdraw from _owner.
  prefs: []
  type: TYPE_NORMAL
- en: function allowance(address _owner, address _spender) public
  prefs: []
  type: TYPE_NORMAL
- en: view returns (uint256 remaining)
  prefs: []
  type: TYPE_NORMAL
- en: Events
  prefs: []
  type: TYPE_NORMAL
- en: // this event MUST trigger when tokens are transferred,
  prefs: []
  type: TYPE_NORMAL
- en: including zero value transfers
  prefs: []
  type: TYPE_NORMAL
- en: event Transfer(address indexed _from, address indexed _to,
  prefs: []
  type: TYPE_NORMAL
- en: uint256 _value)
  prefs: []
  type: TYPE_NORMAL
- en: //this event MUST trigger on any successful call to
  prefs: []
  type: TYPE_NORMAL
- en: approve(address _spender, uint256 _value)
  prefs: []
  type: TYPE_NORMAL
- en: event Approval(address indexed _owner, address indexed _
  prefs: []
  type: TYPE_NORMAL
- en: spender, uint256 _value)
  prefs: []
  type: TYPE_NORMAL
- en: '381'
  prefs: []
  type: TYPE_NORMAL
- en: 'Chapter 10 Fund a projeCt: tokens and Gas Fees'
  prefs: []
  type: TYPE_NORMAL
- en: There are two smart contract packages that have been implemented
  prefs: []
  type: TYPE_NORMAL
- en: 'for the EIP-20 standard: the OpenZeppelin package and the ConsenSys'
  prefs: []
  type: TYPE_NORMAL
- en: package. Developers can extend these packages and make their own
  prefs: []
  type: TYPE_NORMAL
- en: ERC20 tokens with a few customized lines of code. For example, by
  prefs: []
  type: TYPE_NORMAL
- en: importing the OpenZeppelin ERC20 package, a developer can create an
  prefs: []
  type: TYPE_NORMAL
- en: ERC20 token named “DEVELOPER_TOKEN” with a symbol of DEV and a
  prefs: []
  type: TYPE_NORMAL
- en: 'customizable total supply as input for the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '*// contracts/DEVToken.sol*'
  prefs: []
  type: TYPE_NORMAL
- en: '*// SPDX-License-Identifier: MIT*'
  prefs: []
  type: TYPE_NORMAL
- en: '*pragma solidity ^0.8.0;*'
  prefs: []
  type: TYPE_NORMAL
- en: '*import "@openzeppelin/contracts/token/ERC20/ERC20.sol";*'
  prefs: []
  type: TYPE_NORMAL
- en: '*contract DEVToken is ERC20 {*'
  prefs: []
  type: TYPE_NORMAL
- en: '*constructor(uint256 initialSupply) ERC20("DEVELOPER_TOKEN",*'
  prefs: []
  type: TYPE_NORMAL
- en: '*"DEV") {*'
  prefs: []
  type: TYPE_NORMAL
- en: '*_mint(msg.sender, initialSupply);*'
  prefs: []
  type: TYPE_NORMAL
- en: '*}*'
  prefs: []
  type: TYPE_NORMAL
- en: '*}*'
  prefs: []
  type: TYPE_NORMAL
- en: When the preceding smart contract is deployed with an initialSupply
  prefs: []
  type: TYPE_NORMAL
- en: specified, the deployed token will have totalSupply equal to the initialSupply.
  prefs: []
  type: TYPE_NORMAL
- en: Once an ERC20 token is created, another smart contract can be written
  prefs: []
  type: TYPE_NORMAL
- en: to handle the minting and distribution of the token. This smart contract
  prefs: []
  type: TYPE_NORMAL
- en: is sometimes called the crowdsale smart contract when used for ICOs. A
  prefs: []
  type: TYPE_NORMAL
- en: 'smart contract for crowdsale normally contains the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ratio of token and ether** – The ratio of ether and'
  prefs: []
  type: TYPE_NORMAL
- en: the target token.
  prefs: []
  type: TYPE_NORMAL
- en: '**Time of the crowdsale** – The start time and end'
  prefs: []
  type: TYPE_NORMAL
- en: time when the token is available for distribution.
  prefs: []
  type: TYPE_NORMAL
- en: '**KYC/AML** – The crowdsale can have a white list for'
  prefs: []
  type: TYPE_NORMAL
- en: senders who can participate in the crowdsale.
  prefs: []
  type: TYPE_NORMAL
- en: '382'
  prefs: []
  type: TYPE_NORMAL
- en: 'Chapter 10 Fund a projeCt: tokens and Gas Fees'
  prefs: []
  type: TYPE_NORMAL
- en: '**Refunds** – The smart contract can also implement'
  prefs: []
  type: TYPE_NORMAL
- en: the functions to refund the token.
  prefs: []
  type: TYPE_NORMAL
- en: Besides crowdfunding, ERC20 tokens are extensively used in other
  prefs: []
  type: TYPE_NORMAL
- en: decentralized finance (DeFi) projects such as Compound for lending,
  prefs: []
  type: TYPE_NORMAL
- en: Uniswap for exchanges, and USDC for stablecoins.
  prefs: []
  type: TYPE_NORMAL
- en: In the Ethereum community, there are also some discussions on
  prefs: []
  type: TYPE_NORMAL
- en: whether the ERC20 token is a utility token or a security token. These are
  prefs: []
  type: TYPE_NORMAL
- en: country or state specific and should be consulted with legal professionals.
  prefs: []
  type: TYPE_NORMAL
- en: '**Token in NFT**'
  prefs: []
  type: TYPE_NORMAL
- en: Different from ERC20 tokens, nonfungible tokens (NFT) are distinguishable
  prefs: []
  type: TYPE_NORMAL
- en: and can be used to represent ownership. For example, birth certificates,
  prefs: []
  type: TYPE_NORMAL
- en: diplomas, and rental contracts are all nonfungible and have clear ownership.
  prefs: []
  type: TYPE_NORMAL
- en: An NFT is specified as an EIP-721 standard to represent
  prefs: []
  type: TYPE_NORMAL
- en: • Physical assets such as houses, cars, and artwork
  prefs: []
  type: TYPE_NORMAL
- en: • Virtual collectables such as digital art and
  prefs: []
  type: TYPE_NORMAL
- en: collectable cards
  prefs: []
  type: TYPE_NORMAL
- en: • “Negative assets” such as loans and debt
  prefs: []
  type: TYPE_NORMAL
- en: 'The detailed specification of the EIP-721 is located in the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://eips.ethereum.org/EIPS/eip- 721](https://eips.ethereum.org/EIPS/eip-721)'
  prefs: []
  type: TYPE_NORMAL
- en: Similar to the ERC20 token, the ERC721 NFT also defines the token name,
  prefs: []
  type: TYPE_NORMAL
- en: 'token symbol, and total supply. There are some major differences for the NFT:'
  prefs: []
  type: TYPE_NORMAL
- en: • Each NFT token has an index that is unique.
  prefs: []
  type: TYPE_NORMAL
- en: • Each NFT token has an owner.
  prefs: []
  type: TYPE_NORMAL
- en: • Since NFTs can point to a physical or virtual asset outside
  prefs: []
  type: TYPE_NORMAL
- en: the blockchain, there is an interface ERC721Metadata
  prefs: []
  type: TYPE_NORMAL
- en: that defines a function called tokenURL.
  prefs: []
  type: TYPE_NORMAL
- en: '383'
  prefs: []
  type: TYPE_NORMAL
- en: 'Chapter 10 Fund a projeCt: tokens and Gas Fees'
  prefs: []
  type: TYPE_NORMAL
- en: '*function tokenURI(uint256 _tokenId) external*'
  prefs: []
  type: TYPE_NORMAL
- en: '*view returns (string);*'
  prefs: []
  type: TYPE_NORMAL
- en: This tokenURL function takes an input of _tokenId
  prefs: []
  type: TYPE_NORMAL
- en: and returns a Universal Resource Identifier (URI)
  prefs: []
  type: TYPE_NORMAL
- en: that points to an NFT item defined in a conventional
  prefs: []
  type: TYPE_NORMAL
- en: digital system.
  prefs: []
  type: TYPE_NORMAL
- en: • Each NFT token can be transferred from one owner to
  prefs: []
  type: TYPE_NORMAL
- en: 'another with the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '*function transferFrom(address _from, address*'
  prefs: []
  type: TYPE_NORMAL
- en: '*_to, uint256 _tokenId) external payable;*'
  prefs: []
  type: TYPE_NORMAL
- en: • There are also other functions or interfaces that help
  prefs: []
  type: TYPE_NORMAL
- en: NFT tokens to be assigned, transferred, or identified.
  prefs: []
  type: TYPE_NORMAL
- en: NFT tokens based on the EIP-721/ERC721 standard have been
  prefs: []
  type: TYPE_NORMAL
- en: implemented by several projects. For example, 0xcert and OpenZeppelin
  prefs: []
  type: TYPE_NORMAL
- en: have implemented ERC721 token smart contract packages. Developers
  prefs: []
  type: TYPE_NORMAL
- en: can easily extend the ERC721 package and create their own ERC721
  prefs: []
  type: TYPE_NORMAL
- en: nonfungible tokens.
  prefs: []
  type: TYPE_NORMAL
- en: For example, for a college to create an NFT for their students’
  prefs: []
  type: TYPE_NORMAL
- en: diplomas, the smart contract can be written with the following
  prefs: []
  type: TYPE_NORMAL
- en: 'sample code:'
  prefs: []
  type: TYPE_NORMAL
- en: '// SPDX-License-Identifier: MIT'
  prefs: []
  type: TYPE_NORMAL
- en: pragma solidity ^0.7.0;
  prefs: []
  type: TYPE_NORMAL
- en: import "https://github.com/OpenZeppelin/openzeppelin-contracts/
  prefs: []
  type: TYPE_NORMAL
- en: blob/release-v3.4/contracts/token/ERC721/ERC721.sol";
  prefs: []
  type: TYPE_NORMAL
- en: contract TTCDiploma is ERC721 {
  prefs: []
  type: TYPE_NORMAL
- en: uint private _tokenIds;
  prefs: []
  type: TYPE_NORMAL
- en: address admin;
  prefs: []
  type: TYPE_NORMAL
- en: '384'
  prefs: []
  type: TYPE_NORMAL
- en: 'Chapter 10 Fund a projeCt: tokens and Gas Fees'
  prefs: []
  type: TYPE_NORMAL
- en: constructor() ERC721("TexasTechnologyCollegeDiploma",
  prefs: []
  type: TYPE_NORMAL
- en: '"TTC") public {'
  prefs: []
  type: TYPE_NORMAL
- en: admin = msg.sender;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: function issueDiploma(address student, string memory
  prefs: []
  type: TYPE_NORMAL
- en: tokenURI) public returns (uint256) {
  prefs: []
  type: TYPE_NORMAL
- en: require(msg.sender == admin); // only admin can issue
  prefs: []
  type: TYPE_NORMAL
- en: diploma.
  prefs: []
  type: TYPE_NORMAL
- en: _tokenIds++;
  prefs: []
  type: TYPE_NORMAL
- en: uint256 newDiplomaId = _tokenIds;
  prefs: []
  type: TYPE_NORMAL
- en: _mint(student, newDiplomaId);
  prefs: []
  type: TYPE_NORMAL
- en: _setTokenURI(newDiplomaId, tokenURI);
  prefs: []
  type: TYPE_NORMAL
- en: return newDiplomaId;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: In this program, the TTCDiploma smart contract is written to issue
  prefs: []
  type: TYPE_NORMAL
- en: diplomas for students. When the smart contract is deployed, the token
  prefs: []
  type: TYPE_NORMAL
- en: name and token symbol are provided. Also, the smart contract deployment
  prefs: []
  type: TYPE_NORMAL
- en: address is assigned as the admin address. Only admin can perform
  prefs: []
  type: TYPE_NORMAL
- en: privileged actions such as issuing diplomas. In the issueDiploma function,
  prefs: []
  type: TYPE_NORMAL
- en: the sender is checked to see if it has admin permissions. If it does, the
  prefs: []
  type: TYPE_NORMAL
- en: tokenId is incremented, and a new diploma ID is generated. This new
  prefs: []
  type: TYPE_NORMAL
- en: diplomaId is then assigned a tokenURI that points to an external source
  prefs: []
  type: TYPE_NORMAL
- en: for retrieving the diploma for that ID. When students want to retrieve the
  prefs: []
  type: TYPE_NORMAL
- en: diploma, they simply sign a message and send it to the URI specified by the
  prefs: []
  type: TYPE_NORMAL
- en: diplomaId. The diploma server pointed by the URI will check the signed
  prefs: []
  type: TYPE_NORMAL
- en: message to verify that the requester is the legitimate owner of the diploma
  prefs: []
  type: TYPE_NORMAL
- en: and will then output the diploma to the request.
  prefs: []
  type: TYPE_NORMAL
- en: '385'
  prefs: []
  type: TYPE_NORMAL
- en: 'Chapter 10 Fund a projeCt: tokens and Gas Fees'
  prefs: []
  type: TYPE_NORMAL
- en: NFT tokens can be used in many fields. There have been many projects
  prefs: []
  type: TYPE_NORMAL
- en: that provide marketplaces for NFT artwork and collectables. Projects such
  prefs: []
  type: TYPE_NORMAL
- en: as OpenSea and Decentraland are popular for the NFT marketplace.
  prefs: []
  type: TYPE_NORMAL
- en: '**Tokens in DeFi (Compound, Uniswap,**'
  prefs: []
  type: TYPE_NORMAL
- en: '**and Stablecoins)**'
  prefs: []
  type: TYPE_NORMAL
- en: In Chapter [1](https://doi.org/10.1007/978-1-4842-8164-2_1), several DeFi projects
    such as the decentralized lending platform, decentralized exchange, and stablecoins
    are mentioned. All DeFi
  prefs: []
  type: TYPE_NORMAL
- en: projects use one or multiple ERC20 tokens as asset tokens or governance
  prefs: []
  type: TYPE_NORMAL
- en: tokens. In the following, we mention several examples.
  prefs: []
  type: TYPE_NORMAL
- en: Compound is a project for a decentralized lending platform that allows
  prefs: []
  type: TYPE_NORMAL
- en: users to lend or borrow cryptocurrency without the need for going through
  prefs: []
  type: TYPE_NORMAL
- en: intermediaries such as banks. Lenders can send their asset tokens to a
  prefs: []
  type: TYPE_NORMAL
- en: Compound smart contract and receive cTokens to represent the amount
  prefs: []
  type: TYPE_NORMAL
- en: of assets that are deposited to the lending pool. cTokens can earn interest
  prefs: []
  type: TYPE_NORMAL
- en: and can also be traded. Borrowers can borrow cryptocurrency from the
  prefs: []
  type: TYPE_NORMAL
- en: Compound protocol. In order to borrow a crypto asset, borrowers need to
  prefs: []
  type: TYPE_NORMAL
- en: supply other crypto assets as collaterals. The collateral calculation is based
  prefs: []
  type: TYPE_NORMAL
- en: on the token price feed and a published formula. If the borrowed asset
  prefs: []
  type: TYPE_NORMAL
- en: cannot be paid back and the collateral values fall below the threshold to
  prefs: []
  type: TYPE_NORMAL
- en: secure the borrowed balance, the collateral can be liquidated based on the
  prefs: []
  type: TYPE_NORMAL
- en: rules written in the smart contract.
  prefs: []
  type: TYPE_NORMAL
- en: The cTokens represent crypto assets supplied in the lending
  prefs: []
  type: TYPE_NORMAL
- en: protocol. In addition, Compound has issued a governing token named
  prefs: []
  type: TYPE_NORMAL
- en: COMP. COMP can be earned by supplying or borrowing assets in the
  prefs: []
  type: TYPE_NORMAL
- en: lending protocol. The COMP token can be used to vote on proposals. All
  prefs: []
  type: TYPE_NORMAL
- en: cTokens and COMP tokens are ERC20 tokens.
  prefs: []
  type: TYPE_NORMAL
- en: Uniswap is a decentralized exchange platform using the Automated
  prefs: []
  type: TYPE_NORMAL
- en: Market Maker (AMM) mechanism. Different users can trade their crypto
  prefs: []
  type: TYPE_NORMAL
- en: assets without a dependency on centralized exchanges. Uniswap liquidity
  prefs: []
  type: TYPE_NORMAL
- en: '386'
  prefs: []
  type: TYPE_NORMAL
- en: 'Chapter 10 Fund a projeCt: tokens and Gas Fees'
  prefs: []
  type: TYPE_NORMAL
- en: providers provide pairs of crypto assets as trading pairs for the liquidity
  prefs: []
  type: TYPE_NORMAL
- en: pool. Traders then trade their assets with the assets in the liquidity pool.
  prefs: []
  type: TYPE_NORMAL
- en: There are two kinds of tokens that are designed for Uniswap and other
  prefs: []
  type: TYPE_NORMAL
- en: similar decentralized exchange platforms. The first kind of token is called
    a
  prefs: []
  type: TYPE_NORMAL
- en: liquidity provider (LP) token, which represents the supplier’s contribution
  prefs: []
  type: TYPE_NORMAL
- en: to the liquidity pool. The LP token is an ERC20 token that is trading pair
  prefs: []
  type: TYPE_NORMAL
- en: specific. Each trading pair will have its own LP token. Another Uniswap
  prefs: []
  type: TYPE_NORMAL
- en: token is a UNI token that is an ERC20 token as well. The UNI token is
  prefs: []
  type: TYPE_NORMAL
- en: a governance token that can be used to vote on proposals within the
  prefs: []
  type: TYPE_NORMAL
- en: Uniswap ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: Stablecoins such as DAI, USDT, and USDC are all ERC20 format tokens
  prefs: []
  type: TYPE_NORMAL
- en: that can be traded or transferred. Additional functions such as automatic
  prefs: []
  type: TYPE_NORMAL
- en: minting and burning based on supply and demand are built on top of
  prefs: []
  type: TYPE_NORMAL
- en: the ERC20 format to make its value stable. Stablecoin values can be kept
  prefs: []
  type: TYPE_NORMAL
- en: stable with several mechanisms such as fiat-collateralization, crypto-
  prefs: []
  type: TYPE_NORMAL
- en: collateralization, or algorithmic mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: Although most of the DeFi tokens are ERC20 tokens, they are not the
  prefs: []
  type: TYPE_NORMAL
- en: same as each DeFi builds additional functions on top of the standard
  prefs: []
  type: TYPE_NORMAL
- en: ERC20 tokens. DeFi projects are all open source, and the code for their
  prefs: []
  type: TYPE_NORMAL
- en: tokens can be viewed and inspected in public source code repositories.
  prefs: []
  type: TYPE_NORMAL
- en: '**Tokens for Enterprises/Standardized**'
  prefs: []
  type: TYPE_NORMAL
- en: '**(Pervasive) Tokens**'
  prefs: []
  type: TYPE_NORMAL
- en: The ICO is enabled by an ERC20 token, which enables tokens to be
  prefs: []
  type: TYPE_NORMAL
- en: programmable, distributed, and traded in the Ethereum ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: An ERC20 token is a fungible token that is not distinguishable between
  prefs: []
  type: TYPE_NORMAL
- en: individual tokens. An NFT milestone is empowered by ERC721, which
  prefs: []
  type: TYPE_NORMAL
- en: allows a token to be unique, traceable, exchangeable, and tradable. STO is
  prefs: []
  type: TYPE_NORMAL
- en: empowered by ERC1400 that allows owners to own a portion of an entity
  prefs: []
  type: TYPE_NORMAL
- en: asset. Tokens are inseparable from decentralized applications.
  prefs: []
  type: TYPE_NORMAL
- en: '387'
  prefs: []
  type: TYPE_NORMAL
- en: 'Chapter 10 Fund a projeCt: tokens and Gas Fees'
  prefs: []
  type: TYPE_NORMAL
- en: Tokens in public blockchains are open, permissionless, and intended
  prefs: []
  type: TYPE_NORMAL
- en: for large-scale distribution. For enterprises, there is a need to have a more
  prefs: []
  type: TYPE_NORMAL
- en: structured and formal framework for tokens that can propagate through
  prefs: []
  type: TYPE_NORMAL
- en: different private blockchains and are easy to design and customize.
  prefs: []
  type: TYPE_NORMAL
- en: Enterprise tokens have potential uses in many areas including the
  prefs: []
  type: TYPE_NORMAL
- en: 'following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Supply chain tokens**'
  prefs: []
  type: TYPE_NORMAL
- en: In a supply chain, assets can correspond to parts, inventory, orders,
  prefs: []
  type: TYPE_NORMAL
- en: shipment, loans, and bills of lading. All these assets can be tokenized and
  prefs: []
  type: TYPE_NORMAL
- en: recorded in the blockchain. Operations on these assets can be modeled as
  prefs: []
  type: TYPE_NORMAL
- en: transactions in the blockchain. Enterprises such as IBM, FedEx, Microsoft,
  prefs: []
  type: TYPE_NORMAL
- en: and Accenture are all building blockchain solutions to help solve supply
  prefs: []
  type: TYPE_NORMAL
- en: chain problems to increase efficiency, enhance traceability, and maximize
  prefs: []
  type: TYPE_NORMAL
- en: transparency. The types of tokens used in the supply chain are broader
  prefs: []
  type: TYPE_NORMAL
- en: than ERC20 or ERC721 that are commonly used in DeFi. In a supply
  prefs: []
  type: TYPE_NORMAL
- en: chain system, all identifiable items can be tokenized and recorded in the
  prefs: []
  type: TYPE_NORMAL
- en: blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: '**Industry-Specific Tokens**'
  prefs: []
  type: TYPE_NORMAL
- en: Tokens can be expanded to represent all identifiable items and can be
  prefs: []
  type: TYPE_NORMAL
- en: used in all industries for physical, digital, or virtual assets. For example,
  prefs: []
  type: TYPE_NORMAL
- en: in the renewable energy domain, solar or wind power generation can be
  prefs: []
  type: TYPE_NORMAL
- en: tokenized and traded. Below we describe how carbon credit tokens can be
  prefs: []
  type: TYPE_NORMAL
- en: used to characterize and tokenize CO2 emission and how these credits can
  prefs: []
  type: TYPE_NORMAL
- en: be traded in the marketplace (Figure [10-1).](#p399)
  prefs: []
  type: TYPE_NORMAL
- en: '388'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-399_1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Chapter 10 Fund a projeCt: tokens and Gas Fees'
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 10-1\.** Overview of Carbon Credit Token (CCT)*'
  prefs: []
  type: TYPE_NORMAL
- en: To establish a carbon credit market, the authority will first need to mint
  prefs: []
  type: TYPE_NORMAL
- en: and issue an ERC20 token to represent CO2 reduction. The carbon credit
  prefs: []
  type: TYPE_NORMAL
- en: authority first creates a Carbon Credit Token (CCT) by using a name such
  prefs: []
  type: TYPE_NORMAL
- en: as “United Groups’ Carbon Credit,” a symbol of “CCT,” and a total amount
  prefs: []
  type: TYPE_NORMAL
- en: for CO2 reduction. The initial carbon credit is minted and owned by the
  prefs: []
  type: TYPE_NORMAL
- en: authority account. Only the authority has the privilege to transfer or grant
  prefs: []
  type: TYPE_NORMAL
- en: the carbon credits.
  prefs: []
  type: TYPE_NORMAL
- en: To manage the carbon credits, the authority will appoint auditors
  prefs: []
  type: TYPE_NORMAL
- en: to review and audit the requests from green energy providers to decide
  prefs: []
  type: TYPE_NORMAL
- en: whether the claims can be granted. If the claims are granted, an event is
  prefs: []
  type: TYPE_NORMAL
- en: emitted to show the projectId and the credit amount.
  prefs: []
  type: TYPE_NORMAL
- en: To claim a carbon credit, green energy providers will first create
  prefs: []
  type: TYPE_NORMAL
- en: an NFT token to represent the project. This NFT token is unique and
  prefs: []
  type: TYPE_NORMAL
- en: points to the project records. The project team then files a claim that
  prefs: []
  type: TYPE_NORMAL
- en: contains information about the CO2 reduction amount and the carbon
  prefs: []
  type: TYPE_NORMAL
- en: '389'
  prefs: []
  type: TYPE_NORMAL
- en: 'Chapter 10 Fund a projeCt: tokens and Gas Fees'
  prefs: []
  type: TYPE_NORMAL
- en: credit requested. The NFT related to the project will also have a Unified
  prefs: []
  type: TYPE_NORMAL
- en: Resource Location that points to an external source that records all
  prefs: []
  type: TYPE_NORMAL
- en: relevant documents and reports for the project. Once this data is written
  prefs: []
  type: TYPE_NORMAL
- en: to the blockchain, a Claim event is emitted to inform auditors to audit the
  prefs: []
  type: TYPE_NORMAL
- en: information in the claim. After the claims are audited and approved, the
  prefs: []
  type: TYPE_NORMAL
- en: authority will transfer the carbon credit to the green energy providers’
  prefs: []
  type: TYPE_NORMAL
- en: accounts. The provider can then send the CCT asset to the carbon credit
  prefs: []
  type: TYPE_NORMAL
- en: marketplace for trading.
  prefs: []
  type: TYPE_NORMAL
- en: On the consumption side, manufacturers or consumers who need
  prefs: []
  type: TYPE_NORMAL
- en: the carbon credit to meet the quota will buy carbon credits from the
  prefs: []
  type: TYPE_NORMAL
- en: marketplace. The cryptocurrency paid to the green energy provider for
  prefs: []
  type: TYPE_NORMAL
- en: CCT asset can be used to expand the work of the green energy provider to
  prefs: []
  type: TYPE_NORMAL
- en: produce more renewable energy.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a carbon credit project example, refer to the following repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/masaun/tokenized- carbon- credit- marketplace/](https://github.com/masaun/tokenized-carbon-credit-marketplace/blob/main/smart-contract/contracts/GreenNFT.sol)'
  prefs: []
  type: TYPE_NORMAL
- en: '[blob/main/smart- contract/contracts/GreenNFT.sol](https://github.com/masaun/tokenized-carbon-credit-marketplace/blob/main/smart-contract/contracts/GreenNFT.sol)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Token Taxonomy Initiative**'
  prefs: []
  type: TYPE_NORMAL
- en: Carbon credit token, solar token, electricity token, parts token, system
  prefs: []
  type: TYPE_NORMAL
- en: token, and water token can all be classified as enterprise tokens and can
  prefs: []
  type: TYPE_NORMAL
- en: be designed using a more formal definition of tokens. Organizations such
  prefs: []
  type: TYPE_NORMAL
- en: as the Enterprise Ethereum Alliance (EEA) and InterWork Alliance (IWA)
  prefs: []
  type: TYPE_NORMAL
- en: have been working on Token Taxonomy Initiatives (TTI) to develop a token
  prefs: []
  type: TYPE_NORMAL
- en: framework that can be formalized and used to tokenize all identifiable
  prefs: []
  type: TYPE_NORMAL
- en: assets in complex enterprise use cases.
  prefs: []
  type: TYPE_NORMAL
- en: The token taxonomy infrastructure and framework have the following
  prefs: []
  type: TYPE_NORMAL
- en: 'goals and key features:'
  prefs: []
  type: TYPE_NORMAL
- en: • Blockchain agnostic, meaning that it is not dependent
  prefs: []
  type: TYPE_NORMAL
- en: on Solidity, Haskell, WASM, or Java programming
  prefs: []
  type: TYPE_NORMAL
- en: languages for different blockchains
  prefs: []
  type: TYPE_NORMAL
- en: '390'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-401_1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Chapter 10 Fund a projeCt: tokens and Gas Fees'
  prefs: []
  type: TYPE_NORMAL
- en: • Understandable for both business and technical
  prefs: []
  type: TYPE_NORMAL
- en: professionals
  prefs: []
  type: TYPE_NORMAL
- en: • Descriptive as well as programmable
  prefs: []
  type: TYPE_NORMAL
- en: • Address broad usage scenarios for the enterprise and
  prefs: []
  type: TYPE_NORMAL
- en: public blockchains
  prefs: []
  type: TYPE_NORMAL
- en: • Aim for ease of use, improved interoperability,
  prefs: []
  type: TYPE_NORMAL
- en: easier communication, and faster and more secure
  prefs: []
  type: TYPE_NORMAL
- en: development
  prefs: []
  type: TYPE_NORMAL
- en: The following picture (Figur[e 10-2) sho](#p401)ws the hierarchy of token
  prefs: []
  type: TYPE_NORMAL
- en: taxonomy. Different from ERC20 and ERC721 where tokens are defined
  prefs: []
  type: TYPE_NORMAL
- en: in specification and coded into smart contract, the Token Taxonomy
  prefs: []
  type: TYPE_NORMAL
- en: Framework (TTF) defines tokens in three layers. The first layer is the
  prefs: []
  type: TYPE_NORMAL
- en: template layer where the property, formula, and behavior of the tokens
  prefs: []
  type: TYPE_NORMAL
- en: are defined. The token templates can be generic, such as the loyalty token
  prefs: []
  type: TYPE_NORMAL
- en: template or inventory token template. The second layer is the class layer
  prefs: []
  type: TYPE_NORMAL
- en: when templates are assigned parameters to create token classes. For
  prefs: []
  type: TYPE_NORMAL
- en: example, loyalty token templates can be applied with airline loyalty or
  prefs: []
  type: TYPE_NORMAL
- en: hotel loyalty parameters to create an airline loyalty token class or hotel
  prefs: []
  type: TYPE_NORMAL
- en: loyal token class. The token class can then be instantiated into instances
  prefs: []
  type: TYPE_NORMAL
- en: such as a Delta or AA airlines loyalty token.
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 10-2\.** Token Taxonomy example*'
  prefs: []
  type: TYPE_NORMAL
- en: '391'
  prefs: []
  type: TYPE_NORMAL
- en: 'Chapter 10 Fund a projeCt: tokens and Gas Fees'
  prefs: []
  type: TYPE_NORMAL
- en: When using this framework for an Ethereum smart contract, the
  prefs: []
  type: TYPE_NORMAL
- en: template layer is similar to ERC20 or ERC721 specifications. The class
  prefs: []
  type: TYPE_NORMAL
- en: layer extends the ERC20 smart contracts into airline loyalty tokens or hotel
  prefs: []
  type: TYPE_NORMAL
- en: tokens. The instance layer constructs specific tokens with the token smart
  prefs: []
  type: TYPE_NORMAL
- en: contract constructor function during deployment.
  prefs: []
  type: TYPE_NORMAL
- en: TTF also defines several fundamental attributes for a formalized token,
  prefs: []
  type: TYPE_NORMAL
- en: 'including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Token unit** – The unit of a token that can be Fractional, Whole, or'
  prefs: []
  type: TYPE_NORMAL
- en: Singleton.
  prefs: []
  type: TYPE_NORMAL
- en: Fractional means that the token can be divided into fractional units.
  prefs: []
  type: TYPE_NORMAL
- en: Whole means that the token cannot be divided but can have
  prefs: []
  type: TYPE_NORMAL
- en: multiple copies.
  prefs: []
  type: TYPE_NORMAL
- en: Singleton means that the token cannot be divided and has a
  prefs: []
  type: TYPE_NORMAL
- en: quantity of 1\.
  prefs: []
  type: TYPE_NORMAL
- en: '**Value type** – If the token has value, its value type is Intrinsic. If a
    token'
  prefs: []
  type: TYPE_NORMAL
- en: is a representation of a physical or digital item that has value, its value
    type
  prefs: []
  type: TYPE_NORMAL
- en: is Reference.
  prefs: []
  type: TYPE_NORMAL
- en: '**Representation type** – Tokens that do not have individual identities'
  prefs: []
  type: TYPE_NORMAL
- en: are called common or fungible tokens. Tokens that have an index or serial
  prefs: []
  type: TYPE_NORMAL
- en: number are called unique or nonfungible tokens.
  prefs: []
  type: TYPE_NORMAL
- en: '**Template type** – Templates describe the basic characteristics of'
  prefs: []
  type: TYPE_NORMAL
- en: tokens. Primitive tokens such as ERC20 or ERC721 are single tokens. More
  prefs: []
  type: TYPE_NORMAL
- en: complex tokens can be created by extending the basic tokens. A hybrid
  prefs: []
  type: TYPE_NORMAL
- en: token can have a parent token as well as child tokens of different types.
  prefs: []
  type: TYPE_NORMAL
- en: Besides the fundamental properties mentioned earlier, the tokens
  prefs: []
  type: TYPE_NORMAL
- en: defined in TTF can also have behavioral properties that allow them to be
  prefs: []
  type: TYPE_NORMAL
- en: mintable, transferable, and burnable.
  prefs: []
  type: TYPE_NORMAL
- en: Transferability is the ability to transfer ownership of the token. Both
  prefs: []
  type: TYPE_NORMAL
- en: ERC20 and ERC721 tokens are transferable.
  prefs: []
  type: TYPE_NORMAL
- en: Mintability is the ability to issue new tokens of the class. Creating new
  prefs: []
  type: TYPE_NORMAL
- en: diplomas for graduating students is an example of minting.
  prefs: []
  type: TYPE_NORMAL
- en: '392'
  prefs: []
  type: TYPE_NORMAL
- en: 'Chapter 10 Fund a projeCt: tokens and Gas Fees'
  prefs: []
  type: TYPE_NORMAL
- en: Burnability is the ability to remove tokens from the supply. Some
  prefs: []
  type: TYPE_NORMAL
- en: projects can burn project tokens to decrease the circulating number of
  prefs: []
  type: TYPE_NORMAL
- en: token supply.
  prefs: []
  type: TYPE_NORMAL
- en: The TTI might seem to be abstract when viewed from the framework
  prefs: []
  type: TYPE_NORMAL
- en: point of view. It is actually quite useful to build generic tools such as
  prefs: []
  type: TYPE_NORMAL
- en: a token designer that can be used to create tokens through a GUI that
  prefs: []
  type: TYPE_NORMAL
- en: supports drag-and-drop features. Developers or users do not need to write
  prefs: []
  type: TYPE_NORMAL
- en: smart contract code for tokens. The code will be automatically generated
  prefs: []
  type: TYPE_NORMAL
- en: when users define tokens through text or GUI tools. The work of TTI is still
  prefs: []
  type: TYPE_NORMAL
- en: in progress and is currently not accepted as a standard yet.
  prefs: []
  type: TYPE_NORMAL
- en: '**Token Economy Consideration**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Token Allocation**'
  prefs: []
  type: TYPE_NORMAL
- en: When reward tokens are proposed and designed, they need to be awarded
  prefs: []
  type: TYPE_NORMAL
- en: to those who contribute to the projects. Normally, stakeholders such as
  prefs: []
  type: TYPE_NORMAL
- en: project teams, funders, and communities will need to be considered. For
  prefs: []
  type: TYPE_NORMAL
- en: example, the Filecoin project is a blockchain-based decentralized storage
  prefs: []
  type: TYPE_NORMAL
- en: network. The project team built a persistent storage service on top of the
  prefs: []
  type: TYPE_NORMAL
- en: IPFS protocol that allows data users to use Filecoin to incentivize miners
  prefs: []
  type: TYPE_NORMAL
- en: to provide long-term data storage and availability. Filecoin tokens are
  prefs: []
  type: TYPE_NORMAL
- en: designed as a fungible token that uses the percentage chart, shown in the
  prefs: []
  type: TYPE_NORMAL
- en: following diagram (Figure [10-3), t](#p404)o allocate Filecoin tokens.
  prefs: []
  type: TYPE_NORMAL
- en: '393'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-404_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Chapter 10 Fund a projeCt: tokens and Gas Fees'
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 10-3\.** Filecoin token allocation*'
  prefs: []
  type: TYPE_NORMAL
- en: For the Filecoin project, the maximum number of tokens created
  prefs: []
  type: TYPE_NORMAL
- en: will be 20 billion. Five percent of the tokens are allocated to the Filecoin
  prefs: []
  type: TYPE_NORMAL
- en: Foundation to facilitate governance of the Filecoin network, fund critical
  prefs: []
  type: TYPE_NORMAL
- en: development projects, support the growth of the Filecoin ecosystem, and
  prefs: []
  type: TYPE_NORMAL
- en: advocate for Filecoin and the decentralized web. Another 4.5% of the
  prefs: []
  type: TYPE_NORMAL
- en: tokens are allocated to the Protocol Labs team and contributors, and 10.5%
  prefs: []
  type: TYPE_NORMAL
- en: are for the Protocol Labs company. The Filecoin project allocates 10%
  prefs: []
  type: TYPE_NORMAL
- en: of their tokens for the fundraising. The majority of tokens are allocated
  prefs: []
  type: TYPE_NORMAL
- en: to miners to support storage mining rewards, block rewards, and other
  prefs: []
  type: TYPE_NORMAL
- en: operations such as faucets and storage incentives. The final 15% of the
  prefs: []
  type: TYPE_NORMAL
- en: tokens are reserved for future mining services and rewards.
  prefs: []
  type: TYPE_NORMAL
- en: '**Token Distribution**'
  prefs: []
  type: TYPE_NORMAL
- en: Once the tokens are allocated, there are different ways to distribute the
  prefs: []
  type: TYPE_NORMAL
- en: tokens to the receivers, as shown in the following diagram (Figur[e 10-4):](#p405)
  prefs: []
  type: TYPE_NORMAL
- en: '394'
  prefs: []
  type: TYPE_NORMAL
- en: 'Chapter 10 Fund a projeCt: tokens and Gas Fees'
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 10-4\.** Token Distribution methods*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Gas Fee Consideration**'
  prefs: []
  type: TYPE_NORMAL
- en: When funding a project, there are many factors to consider.
  prefs: []
  type: TYPE_NORMAL
- en: The Ethereum blockchain has been made sustainable with a gas
  prefs: []
  type: TYPE_NORMAL
- en: economy in which each transaction is paid by senders to blockchain
  prefs: []
  type: TYPE_NORMAL
- en: miners. If a project is building a new blockchain, then the gas fee
  prefs: []
  type: TYPE_NORMAL
- en: mechanism should be considered thoroughly to ensure a sustainable
  prefs: []
  type: TYPE_NORMAL
- en: network system. For projects that build decentralized applications, the cost
  prefs: []
  type: TYPE_NORMAL
- en: of gas consumption should be examined to make sure the high gas cost
  prefs: []
  type: TYPE_NORMAL
- en: '395'
  prefs: []
  type: TYPE_NORMAL
- en: 'Chapter 10 Fund a projeCt: tokens and Gas Fees'
  prefs: []
  type: TYPE_NORMAL
- en: of transactions will not become a showstopper for the applications. In the
  prefs: []
  type: TYPE_NORMAL
- en: following, we discuss how Ethereum gas works and if there exist ways to
  prefs: []
  type: TYPE_NORMAL
- en: lower gas fees in smart contract development.
  prefs: []
  type: TYPE_NORMAL
- en: '**What Is Ethereum Gas?**'
  prefs: []
  type: TYPE_NORMAL
- en: In the Ethereum blockchain, gas can be viewed as the cost of performing
  prefs: []
  type: TYPE_NORMAL
- en: transactions or as the mechanism to power the blockchain ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: When a transaction is sent to the blockchain, a small amount of ether
  prefs: []
  type: TYPE_NORMAL
- en: needs to be specified and paid to the miner in order for the Ethereum
  prefs: []
  type: TYPE_NORMAL
- en: blockchain node to take in the transaction to a block. The higher the gas
  prefs: []
  type: TYPE_NORMAL
- en: fee, the higher the possibility for mining nodes to include the transaction.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to rewarding miners, the gas mechanism also increases the cost
  prefs: []
  type: TYPE_NORMAL
- en: of network attacks by malicious users. In a public blockchain, everyone
  prefs: []
  type: TYPE_NORMAL
- en: can access the network and send transactions to the miners. Without an
  prefs: []
  type: TYPE_NORMAL
- en: appropriate gas fee, tremendous amounts of transactions may be sent to
  prefs: []
  type: TYPE_NORMAL
- en: the network, causing congestion issues or even halting the network. The
  prefs: []
  type: TYPE_NORMAL
- en: gas fee is a well-designed mechanism to maintain a sustainable network
  prefs: []
  type: TYPE_NORMAL
- en: and balance decentralized application ecosystems.
  prefs: []
  type: TYPE_NORMAL
- en: '**Understand Ethereum Gas with Gas Station Analogy**'
  prefs: []
  type: TYPE_NORMAL
- en: Gas in Ethereum is a complex concept. It is difficult to grasp its meaning
  prefs: []
  type: TYPE_NORMAL
- en: and implication for the blockchain network and application ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will use a gas station analogy to help readers better
  prefs: []
  type: TYPE_NORMAL
- en: understand gas usage in Ethereum (Figur[e 10-5).](#p407)
  prefs: []
  type: TYPE_NORMAL
- en: '396'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-407_1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Chapter 10 Fund a projeCt: tokens and Gas Fees'
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 10-5\.** Gas Station Analogy*'
  prefs: []
  type: TYPE_NORMAL
- en: Gas in transportation is used as fuel to power vehicles to move
  prefs: []
  type: TYPE_NORMAL
- en: people and goods from one location to another. On the other hand, gas in
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum is used to power the Ethereum network to make it more secure
  prefs: []
  type: TYPE_NORMAL
- en: and less congested and to incentivize blockchain miners. Gas in Ethereum
  prefs: []
  type: TYPE_NORMAL
- en: is used to pay for transferring assets, deploying smart contracts, or calling
  prefs: []
  type: TYPE_NORMAL
- en: smart contract functions.
  prefs: []
  type: TYPE_NORMAL
- en: In a gas station, the gas price is normally marked as dollars per gallon,
  prefs: []
  type: TYPE_NORMAL
- en: while in Ethereum, the gas price is also used to refer to the unit price of
  prefs: []
  type: TYPE_NORMAL
- en: gas. The concept of the gas price is not that straightforward. The gas price
  prefs: []
  type: TYPE_NORMAL
- en: unit in Ethereum is wei per gas unit, where wei is the smallest unit of ether.
  prefs: []
  type: TYPE_NORMAL
- en: One ether is equal to 10 to the power of 18 wei. The gas unit refers to the
  prefs: []
  type: TYPE_NORMAL
- en: mining cost in Ethereum. It is manually defined in the gas cost table in the
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum yellow paper. For example, an addition operation has a gas cost
  prefs: []
  type: TYPE_NORMAL
- en: of 3, and multiplication has a gas cost of 5\. The total gas fee will be equal
    to
  prefs: []
  type: TYPE_NORMAL
- en: the gas price multiplied with the gas consumed.
  prefs: []
  type: TYPE_NORMAL
- en: '397'
  prefs: []
  type: TYPE_NORMAL
- en: 'Chapter 10 Fund a projeCt: tokens and Gas Fees'
  prefs: []
  type: TYPE_NORMAL
- en: In the Ethereum gas mechanism, there is also the concept of gas limits.
  prefs: []
  type: TYPE_NORMAL
- en: This is the maximum amount of gas a single transaction can consume.
  prefs: []
  type: TYPE_NORMAL
- en: The reason to have a gas limit is to protect the sender account. Sometimes,
  prefs: []
  type: TYPE_NORMAL
- en: a smart contract might go into a computation loop and drain the whole
  prefs: []
  type: TYPE_NORMAL
- en: account balance if there is no gas limit set. For a car, the gas limit is the
    gas
  prefs: []
  type: TYPE_NORMAL
- en: tank capacity. When a gas limit is set and the consumption of gas exceeds
  prefs: []
  type: TYPE_NORMAL
- en: that limit, the transaction will be marked as failed, and the state is reverted
  prefs: []
  type: TYPE_NORMAL
- en: back to its original state.
  prefs: []
  type: TYPE_NORMAL
- en: There are two kinds of transactions, the first of which is a simple asset
  prefs: []
  type: TYPE_NORMAL
- en: transfer to move assets from one account to another. These asset transfers
  prefs: []
  type: TYPE_NORMAL
- en: will consume 21,000 Gwei gas. The second transaction type is the smart
  prefs: []
  type: TYPE_NORMAL
- en: contract call. The gas consumption is much more than the common asset
  prefs: []
  type: TYPE_NORMAL
- en: transfer.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, for the Ethereum blockchain, there is also a maximum
  prefs: []
  type: TYPE_NORMAL
- en: block gas limit. This is the limit of gas for all transactions in a block.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the gas consumed here is in the unit of wei. Normally, the
  prefs: []
  type: TYPE_NORMAL
- en: actual cost is measured in USD in which the gas consumed is multiplied by
  prefs: []
  type: TYPE_NORMAL
- en: the price of ether to get the fiat cost.
  prefs: []
  type: TYPE_NORMAL
- en: '**Quantize Gas Expenses in a Smart Contract Program**'
  prefs: []
  type: TYPE_NORMAL
- en: When a decentralized application is deployed, one of the biggest costs for
  prefs: []
  type: TYPE_NORMAL
- en: the users is the gas fee. The gas fee for Ethereum mainnet transactions
  prefs: []
  type: TYPE_NORMAL
- en: has been skyrocketing and sometimes reaches over 200 USD for a single
  prefs: []
  type: TYPE_NORMAL
- en: transaction. Hence, the feasibility study of the project will need to include
  prefs: []
  type: TYPE_NORMAL
- en: a gas fee expenses analysis to see if the project is financially sustainable.
  prefs: []
  type: TYPE_NORMAL
- en: For example, some people have proposed using blockchain to build a
  prefs: []
  type: TYPE_NORMAL
- en: decentralized music service. Quantitative analysis can help determine the
  prefs: []
  type: TYPE_NORMAL
- en: cost feasibility for storing musical data, both for musical bits and metadata.
  prefs: []
  type: TYPE_NORMAL
- en: '398'
  prefs: []
  type: TYPE_NORMAL
- en: 'Chapter 10 Fund a projeCt: tokens and Gas Fees'
  prefs: []
  type: TYPE_NORMAL
- en: As explained in Chapt[er 7, S](https://doi.org/10.1007/978-1-4842-8164-2_7)olidity
    smart contracts are compiled into bytecodes and then deployed to and executed
    on the blockchain. Each
  prefs: []
  type: TYPE_NORMAL
- en: bytecode command contains an opcode and operands. The gas costs for
  prefs: []
  type: TYPE_NORMAL
- en: various opcodes are shown in the Ethereum yellow paper with some added
  prefs: []
  type: TYPE_NORMAL
- en: opcodes and modification in EIPs. The following is the summary of the gas
  prefs: []
  type: TYPE_NORMAL
- en: costs for categories of opcodes (Figure [10-6](#p409)).
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 10-6\.** Gas costs for various opcodes*'
  prefs: []
  type: TYPE_NORMAL
- en: '399'
  prefs: []
  type: TYPE_NORMAL
- en: 'Chapter 10 Fund a projeCt: tokens and Gas Fees'
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 10-6\.*** ( *continued*)'
  prefs: []
  type: TYPE_NORMAL
- en: As we can see from the gas cost table, arithmetic operations such as
  prefs: []
  type: TYPE_NORMAL
- en: addition, subtraction, multiplication, division, and logical operations
  prefs: []
  type: TYPE_NORMAL
- en: such as AND/OR only cost about 2 to 5 gas units and can be viewed as
  prefs: []
  type: TYPE_NORMAL
- en: low gas fee operations. Environment operations such as getting sender
  prefs: []
  type: TYPE_NORMAL
- en: address, ether value, and block number are also low gas operations that
  prefs: []
  type: TYPE_NORMAL
- en: only consume 2 gas units. The memory manipulating operations are more
  prefs: []
  type: TYPE_NORMAL
- en: complex. The operation on a single 256-bit word is only 2 for loading and
  prefs: []
  type: TYPE_NORMAL
- en: 3 for storing. However, memory storage also has an additional memory
  prefs: []
  type: TYPE_NORMAL
- en: expansion cost. When more data is stored, there is a cost for memory.
  prefs: []
  type: TYPE_NORMAL
- en: The cost for memory storage operations is not linear. We will explain this
  prefs: []
  type: TYPE_NORMAL
- en: further with the next table.
  prefs: []
  type: TYPE_NORMAL
- en: '400'
  prefs: []
  type: TYPE_NORMAL
- en: 'Chapter 10 Fund a projeCt: tokens and Gas Fees'
  prefs: []
  type: TYPE_NORMAL
- en: The most expensive opcode operation is storing to the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: When storing data to the blockchain, the cost per word is 20,000 gas
  prefs: []
  type: TYPE_NORMAL
- en: units for a nonzero value and 5,000 for a zero value. Loading data from
  prefs: []
  type: TYPE_NORMAL
- en: blockchain is 200 gas units per word.
  prefs: []
  type: TYPE_NORMAL
- en: There are program counter–related operations such as JUMP, JUMPI,
  prefs: []
  type: TYPE_NORMAL
- en: PC, and JUMPDEST defined in the table as well. They cause 1 to 10 gas
  prefs: []
  type: TYPE_NORMAL
- en: units, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Halting program operations have very different gas costs. Opcode
  prefs: []
  type: TYPE_NORMAL
- en: STOP or RETURN is used to halt the execution of a function. The RETURN
  prefs: []
  type: TYPE_NORMAL
- en: opcode also returns output data to the calling function. Both opcodes do
  prefs: []
  type: TYPE_NORMAL
- en: not consume gas.
  prefs: []
  type: TYPE_NORMAL
- en: REVERT is an operation that encounters an issue and has to undo all
  prefs: []
  type: TYPE_NORMAL
- en: changes to the blockchain. The remaining unused gas allocated to the
  prefs: []
  type: TYPE_NORMAL
- en: transaction is returned to the sender. The SELFDESTRUCT operation halts
  prefs: []
  type: TYPE_NORMAL
- en: the execution and registers an account for later use. This opcode costs at
  prefs: []
  type: TYPE_NORMAL
- en: least 5000 gas units.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding table shows the gas cost at the opcode and word
  prefs: []
  type: TYPE_NORMAL
- en: payload level. For storage operations, the cost is not necessarily linear. For
  prefs: []
  type: TYPE_NORMAL
- en: example, for memory storage operations, there is an additional memory
  prefs: []
  type: TYPE_NORMAL
- en: expansion cost. The total cost for MSTORE and MSTORE8 is defined as
  prefs: []
  type: TYPE_NORMAL
- en: the sum of memory expansion and static store operations as shown in the
  prefs: []
  type: TYPE_NORMAL
- en: 'following:'
  prefs: []
  type: TYPE_NORMAL
- en: gas_cost_operation = (new_mem_size_words ^ 2 // 512) + (3 * new_
  prefs: []
  type: TYPE_NORMAL
- en: mem_size_words)
  prefs: []
  type: TYPE_NORMAL
- en: The following table (Figur[e 10-7) sho](#p412)ws the cost of storage for stack,
    memory, and persisted storage for word, kilobyte, and megabyte data sizes.
  prefs: []
  type: TYPE_NORMAL
- en: '401'
  prefs: []
  type: TYPE_NORMAL
- en: 'Chapter 10 Fund a projeCt: tokens and Gas Fees'
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 10-7\.** Gas cost of storages for various categories and sizes*'
  prefs: []
  type: TYPE_NORMAL
- en: For the stack operations, there is no additional memory expansion
  prefs: []
  type: TYPE_NORMAL
- en: cost. The gas per word for POP, PUSHX, DUPX, and SWAPX is defined as
  prefs: []
  type: TYPE_NORMAL
- en: 2, 3, 3, and 3 per word, respectively. In Ethereum, a word has 256 bits or 32
  prefs: []
  type: TYPE_NORMAL
- en: bytes in size. Since one kilobyte is equal to 32 words (1024 bytes/32 bytes),
  prefs: []
  type: TYPE_NORMAL
- en: the gas cost per kilobyte is 32 times the gas cost per word. Hence, the gas
  prefs: []
  type: TYPE_NORMAL
- en: per KB for POP, PUSH, DUP, and SWAP is 64, 96, 96, and 96, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, since 1MB is 1024 times of 1KB, the gas per MB for POP, PUSH,
  prefs: []
  type: TYPE_NORMAL
- en: DUP, and SWAP is 65,536, 98,304, 98304, and 98304, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: For memory operations, it is more complex when scaling it to
  prefs: []
  type: TYPE_NORMAL
- en: KB and MB.
  prefs: []
  type: TYPE_NORMAL
- en: The first MLOAD does not have a memory expansion cost. The gas cost
  prefs: []
  type: TYPE_NORMAL
- en: for 1KB is equal to 32 times the gas cost per word, which is 96, and the cost
  prefs: []
  type: TYPE_NORMAL
- en: per MB is 1024 times the cost per KB, which is 98,304\.
  prefs: []
  type: TYPE_NORMAL
- en: For both MSTORE and MSTORE8, there are memory expansion costs
  prefs: []
  type: TYPE_NORMAL
- en: with the formula shown in the preceding equation. The cost per KB and
  prefs: []
  type: TYPE_NORMAL
- en: 'MB for MSTORE and MSTORE8 is shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: For 1KB MSTORE or MSTORE8, there are 32 words for new_mem_size_
  prefs: []
  type: TYPE_NORMAL
- en: 'word. The following memory expansion equation is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '402'
  prefs: []
  type: TYPE_NORMAL
- en: 'Chapter 10 Fund a projeCt: tokens and Gas Fees'
  prefs: []
  type: TYPE_NORMAL
- en: gas_cost_operation = ( new_mem_size_word ^ 2 // 512) + (3 * new_
  prefs: []
  type: TYPE_NORMAL
- en: mem_size_words)
  prefs: []
  type: TYPE_NORMAL
- en: The result is
  prefs: []
  type: TYPE_NORMAL
- en: gas_cost_operation_per_KB = (32^2)/512+3*32 = 98
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, for 1MB MSTORE and MSTORE8, there are
  prefs: []
  type: TYPE_NORMAL
- en: 32*1024=32,768 words.
  prefs: []
  type: TYPE_NORMAL
- en: The result becomes
  prefs: []
  type: TYPE_NORMAL
- en: gas_cost_operation_per_MB = (32768^2)/512+3*32768 = 2,195,456
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, the calculation shows that the memory storage operations
  prefs: []
  type: TYPE_NORMAL
- en: are not linear. It increases dramatically when the stored data size increases.
  prefs: []
  type: TYPE_NORMAL
- en: For the persisted storage with SSTORE and SLOAD, the gas cost grows
  prefs: []
  type: TYPE_NORMAL
- en: linearly with data size. The cost per word for SLOAD is 200\. Hence, the
  prefs: []
  type: TYPE_NORMAL
- en: MLOAD gas cost per KB and MB is 6,400 and 6,553,600, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, since cost per word for SSTORE is 20,000, the cost for KB and MB
  prefs: []
  type: TYPE_NORMAL
- en: is 640,000 and 655,360,000, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: From the preceding calculations, it is shown that the quantitative
  prefs: []
  type: TYPE_NORMAL
- en: calculation of gas usage and cost is quite complex. In general, storing data
  prefs: []
  type: TYPE_NORMAL
- en: in the blockchain and using large amounts of memory in the running
  prefs: []
  type: TYPE_NORMAL
- en: nodes are also expensive and should be minimized as much as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Gas estimation should be built into project proposals to seek proper
  prefs: []
  type: TYPE_NORMAL
- en: funding in order to make the project sustainable.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs: []
  type: TYPE_NORMAL
- en: In this capture, we describe core components for funding a decentralized
  prefs: []
  type: TYPE_NORMAL
- en: application project, including token design, token allocation, distribution,
  prefs: []
  type: TYPE_NORMAL
- en: and gas cost. For the Ethereum blockchain, the significant gas cost is still
  prefs: []
  type: TYPE_NORMAL
- en: a big challenge. There are alternatives such as using a similar blockchain
  prefs: []
  type: TYPE_NORMAL
- en: with EVM and Solidity support but a lower gas fee. There is also a
  prefs: []
  type: TYPE_NORMAL
- en: possibility to build a blockchain that does not require a gas fee. These
  prefs: []
  type: TYPE_NORMAL
- en: solutions are all technically possible and can be evaluated to see if it fits
  prefs: []
  type: TYPE_NORMAL
- en: with the business model.
  prefs: []
  type: TYPE_NORMAL
- en: '403'
  prefs: []
  type: TYPE_NORMAL
- en: '**CHAPTER 11**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Building Team**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Projects**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem Statement and Brainstorming**'
  prefs: []
  type: TYPE_NORMAL
- en: When the Ethereum blockchain was first built, there was no chainId in
  prefs: []
  type: TYPE_NORMAL
- en: the blocks. The concept of chainId was introduced after a DAO attack
  prefs: []
  type: TYPE_NORMAL
- en: in 2016 that resulted in 3.6 million ethers stolen and made Ethereum
  prefs: []
  type: TYPE_NORMAL
- en: blockchain to fork into two blockchains, that is, Ethereum mainnet (ETH)
  prefs: []
  type: TYPE_NORMAL
- en: and Ethereum Classic. The following diagram (Figur[e 11-1) sho](#p415)ws how
    the fork happened. In the diagram, block m is a block where the DAO attack
  prefs: []
  type: TYPE_NORMAL
- en: happened. The Ethereum foundation had a vote, and the community
  prefs: []
  type: TYPE_NORMAL
- en: decided to patch the Ethereum node client and invalidate the hacker
  prefs: []
  type: TYPE_NORMAL
- en: accounts. This is not a rollback but rather an update of all client nodes
  prefs: []
  type: TYPE_NORMAL
- en: to force a change of the state of Ethereum. There are some miners who
  prefs: []
  type: TYPE_NORMAL
- en: believe that blockchain should be immutable and should not be changed
  prefs: []
  type: TYPE_NORMAL
- en: due to attack. These miners continue to append blocks to the DAO
  prefs: []
  type: TYPE_NORMAL
- en: attacked blocks and retain the immutability of the Ethereum blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: They called this blockchain Ethereum Classic (ETC). Since then, there
  prefs: []
  type: TYPE_NORMAL
- en: have been two forked Ethereum blockchains that share the same blocks
  prefs: []
  type: TYPE_NORMAL
- en: until the block of 1920000\.
  prefs: []
  type: TYPE_NORMAL
- en: © Weijia Zhang and Tej Anand 2022
  prefs: []
  type: TYPE_NORMAL
- en: '405'
  prefs: []
  type: TYPE_NORMAL
- en: W. Zhang and T. Anand, *Blockchain and Ethereum Smart Contract Solution Development*,
  prefs: []
  type: TYPE_NORMAL
- en: '[https://doi.org/10.1007/978-1-4842-8164-2_11](https://doi.org/10.1007/978-1-4842-8164-2_11#DOI)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-415_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 11 Building team projeCts
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 11-1\.** Overview of ETH and ETC fork*'
  prefs: []
  type: TYPE_NORMAL
- en: With Ethereum blockchains forked into ETH and ETC, there is a
  prefs: []
  type: TYPE_NORMAL
- en: double spend or replay attack issue. If Alice has 50 ethers at block M, she
  prefs: []
  type: TYPE_NORMAL
- en: actually has 50 ethers for ETH chain and 50 ethers for ETC chain. Suppose
  prefs: []
  type: TYPE_NORMAL
- en: Alice signs a transaction to transfer 50 ethers to Bob on the ETH chain,
  prefs: []
  type: TYPE_NORMAL
- en: since the ETC and ETH are almost identical, Bob can take the same signed
  prefs: []
  type: TYPE_NORMAL
- en: transaction and send it to the ETC chain and receive 50 ethers on the ETC
  prefs: []
  type: TYPE_NORMAL
- en: chain as well.
  prefs: []
  type: TYPE_NORMAL
- en: To overcome double spend/replay attack on two blockchains, Vitalik
  prefs: []
  type: TYPE_NORMAL
- en: proposed EIP-155 (simple replay attack protection) to assign an integer
  prefs: []
  type: TYPE_NORMAL
- en: to each blockchain and sign the transaction with a chainId. This way, the
  prefs: []
  type: TYPE_NORMAL
- en: transaction signed by Alice for Ethereum mainnet (ETH) cannot be resent
  prefs: []
  type: TYPE_NORMAL
- en: to Ethereum Classic (ETC) chain to cause double spend.
  prefs: []
  type: TYPE_NORMAL
- en: In EIP-155, some chainIds are preallocated as shown in the following
  prefs: []
  type: TYPE_NORMAL
- en: table (Figur[e 11-2](#p416)). To obtain a new chainId, an administrator on behalf
    of the blockchain community will need to go to [https://github.com/](https://github.com/ethereum-lists/chains)
  prefs: []
  type: TYPE_NORMAL
- en: '[ethereum-lists/chains](https://github.com/ethereum-lists/chains) to submit
    a pull request to register for a new chainId. The assignment of the chainId is
    on the first-come first-serve basis'
  prefs: []
  type: TYPE_NORMAL
- en: to ensure there is no collision of the chainIds.
  prefs: []
  type: TYPE_NORMAL
- en: '406'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 11 Building team projeCts
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 11-2\.** Chainids defined in Ethereum mainnet and testnetst*'
  prefs: []
  type: TYPE_NORMAL
- en: Although EIP-155 solves the replay attack for various blockchains,
  prefs: []
  type: TYPE_NORMAL
- en: there are some drawbacks including that the chainId is self-defined and
  prefs: []
  type: TYPE_NORMAL
- en: not bundled with blockchain property. A malicious user may construct
  prefs: []
  type: TYPE_NORMAL
- en: a blockchain with a chainId of another blockchain. This can cause
  prefs: []
  type: TYPE_NORMAL
- en: crosschain transaction being sent to a wrong target blockchain. Another
  prefs: []
  type: TYPE_NORMAL
- en: drawback is that when a blockchain is forked into two blockchains such as
  prefs: []
  type: TYPE_NORMAL
- en: the case of ETH and ETC, the two blockchains will have the same chainId
  prefs: []
  type: TYPE_NORMAL
- en: to cause conflict.
  prefs: []
  type: TYPE_NORMAL
- en: '**Specifications and Solutions**'
  prefs: []
  type: TYPE_NORMAL
- en: To overcome the drawback of simple number-based chainId, a
  prefs: []
  type: TYPE_NORMAL
- en: crosschainId with 32 bytes can be used to add more information to the
  prefs: []
  type: TYPE_NORMAL
- en: crosschain ID to make it more versatile. The crosschainId can have a
  prefs: []
  type: TYPE_NORMAL
- en: genesis block hash and a checksum so that third-party application and
  prefs: []
  type: TYPE_NORMAL
- en: user can verify that the crosschain ID is valid for a particular blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: '407'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 11 Building team projeCts
  prefs: []
  type: TYPE_NORMAL
- en: The specification of the crosschainId is published as Ethereum
  prefs: []
  type: TYPE_NORMAL
- en: Improvement Protocol (EIP) 3220 and is shown in the following.
  prefs: []
  type: TYPE_NORMAL
- en: '**EIP-3220: Crosschain Identifier Specification**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Simple Summary**'
  prefs: []
  type: TYPE_NORMAL
- en: A self-verifying unique blockchain identifier that deals with forks.
  prefs: []
  type: TYPE_NORMAL
- en: '**Abstract**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The crosschain ID is a 32-byte hex string and with some bytes extracted from*'
  prefs: []
  type: TYPE_NORMAL
- en: '*blockchain hash and some manually defined to characterize a blockchain.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*We also propose a* *registration and lookup service* *to retrieve blockchain*
    *metadata from the crosschain ID.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Motivation**'
  prefs: []
  type: TYPE_NORMAL
- en: '*With the success of Bitcoin and Ethereum, various blockchains such as EOS,*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Ripple, Litecoin, Besu, Wanchain, and the like have been developed and*'
  prefs: []
  type: TYPE_NORMAL
- en: '*are growing at a fast pace. There are also other private and consortium*'
  prefs: []
  type: TYPE_NORMAL
- en: '*blockchains such as Hyperledger Fabric, Hyperledger Besu, Stellar, Corda,*'
  prefs: []
  type: TYPE_NORMAL
- en: '*and Quorum that only allow nodes with permitted identities to join the*'
  prefs: []
  type: TYPE_NORMAL
- en: '*blockchain network. The growth of public and private blockchains imposes*'
  prefs: []
  type: TYPE_NORMAL
- en: '*challenges for interchain interoperability, particularly when these chains
    are*'
  prefs: []
  type: TYPE_NORMAL
- en: '*heterogeneous and incompatible. The Enterprise Ethereum Alliance formed*'
  prefs: []
  type: TYPE_NORMAL
- en: '*the* *Crosschain Interoperability Task Force (CITF)* *to look into common*
    *crosschain problems and solutions. CITF team noticed that there is a lack*'
  prefs: []
  type: TYPE_NORMAL
- en: '*of unique identifiers to characterize and describe a blockchain. Several*'
  prefs: []
  type: TYPE_NORMAL
- en: '*proposals were discussed in EEA Crosschain Interoperability Task Force*'
  prefs: []
  type: TYPE_NORMAL
- en: '*meetings and discussions.*'
  prefs: []
  type: TYPE_NORMAL
- en: '408'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 11 Building team projeCts
  prefs: []
  type: TYPE_NORMAL
- en: '[*EIP- 155*](https://eips.ethereum.org/EIPS/eip-155) *provides a unique identifier
    to a blockchain to provide simple* *relay attack protection. This specification
    defines an integer for chainId*'
  prefs: []
  type: TYPE_NORMAL
- en: '*for a blockchain and signs the chainId into a transaction data and hence*'
  prefs: []
  type: TYPE_NORMAL
- en: '*prevents attackers to send the same transaction to different blockchains.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*This specification will require blockchains to define a chainId and register*'
  prefs: []
  type: TYPE_NORMAL
- en: '*the chainId in a public repository.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*The challenge of using an integer for chainId is that it is not broad*'
  prefs: []
  type: TYPE_NORMAL
- en: '*enough to cover all blockchains and it does not prevent different blockchains*'
  prefs: []
  type: TYPE_NORMAL
- en: '*using the same chainId. Also, it does not address the issue for two forked*'
  prefs: []
  type: TYPE_NORMAL
- en: '*blockchains having the same chainId.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Hence, there is a need for a more robust blockchain identifier that will*'
  prefs: []
  type: TYPE_NORMAL
- en: '*overcome these drawbacks, especially for crosschain operations where*'
  prefs: []
  type: TYPE_NORMAL
- en: '*multiple chains are involved. A blockchain identifier (crosschain ID) should*'
  prefs: []
  type: TYPE_NORMAL
- en: '*be unique and satisfy the following* *requirements:*'
  prefs: []
  type: TYPE_NORMAL
- en: • *Should provide identification, description, and discovery*
  prefs: []
  type: TYPE_NORMAL
- en: '*of blockchains*'
  prefs: []
  type: TYPE_NORMAL
- en: • *Should provide unique identification of each blockchain*
  prefs: []
  type: TYPE_NORMAL
- en: '*in the crosschain service ecosystem*'
  prefs: []
  type: TYPE_NORMAL
- en: • *Should provide descriptions for blockchain identities*
  prefs: []
  type: TYPE_NORMAL
- en: '*such as chainId, name, type, consensus scheme, etc.*'
  prefs: []
  type: TYPE_NORMAL
- en: • *Should provide a discovery mechanism for supported*
  prefs: []
  type: TYPE_NORMAL
- en: '*blockchains and also for new blockchains in the*'
  prefs: []
  type: TYPE_NORMAL
- en: '*ecosystem*'
  prefs: []
  type: TYPE_NORMAL
- en: • *Should provide a mechanism for a joining blockchain to*
  prefs: []
  type: TYPE_NORMAL
- en: '*register to the ecosystem*'
  prefs: []
  type: TYPE_NORMAL
- en: • *Should provide a mechanism for a blockchain to edit*
  prefs: []
  type: TYPE_NORMAL
- en: '*properties or unregister from the crosschain ecosystem*'
  prefs: []
  type: TYPE_NORMAL
- en: '409'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 11 Building team projeCts
  prefs: []
  type: TYPE_NORMAL
- en: • *Should provide a mechanism to get some critical*
  prefs: []
  type: TYPE_NORMAL
- en: '*information of the blockchain*'
  prefs: []
  type: TYPE_NORMAL
- en: • *Should provide a mechanism to differentiate an original*
  prefs: []
  type: TYPE_NORMAL
- en: '*blockchain and a forked blockchain*'
  prefs: []
  type: TYPE_NORMAL
- en: • *Should provide a mechanism to verify a chainId without*
  prefs: []
  type: TYPE_NORMAL
- en: '*external registration service*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Specification**'
  prefs: []
  type: TYPE_NORMAL
- en: The following diagram (Figure [11-3](#p420)) shows the definition of a 32-Byte
    Crosschain ID.
  prefs: []
  type: TYPE_NORMAL
- en: '410'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 11 Building team projeCts
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 11-3\.** Definition of a 32-byte crosschainId*'
  prefs: []
  type: TYPE_NORMAL
- en: '411'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 11 Building team projeCts
  prefs: []
  type: TYPE_NORMAL
- en: '**Rationale**'
  prefs: []
  type: TYPE_NORMAL
- en: '*We have considered various alternative specifications such as using a*'
  prefs: []
  type: TYPE_NORMAL
- en: '*random unique hex string to represent a blockchain. The drawback of*'
  prefs: []
  type: TYPE_NORMAL
- en: '*this method is that the random ID cannot be used to verify a blockchain’s*'
  prefs: []
  type: TYPE_NORMAL
- en: '*intrinsic identity such as the block hash of the genesis block. A second*'
  prefs: []
  type: TYPE_NORMAL
- en: '*alternative is simply using a genesis block hash to represent a blockchain
    ID*'
  prefs: []
  type: TYPE_NORMAL
- en: '*for* *crosschain operations. The drawback of this is that this ID does not
    have* *information about the property of the blockchain and it has problems when*'
  prefs: []
  type: TYPE_NORMAL
- en: '*a blockchain is forked into two blockchain.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Backward Compatibility**'
  prefs: []
  type: TYPE_NORMAL
- en: '*CrosschainId can be* *backward compatible* *with EIP-155\. The crosschain
    ID*'
  prefs: []
  type: TYPE_NORMAL
- en: '*contains a 4-byte segment to record the chainId based on EIP-155\.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Security Considerations**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Collision of crosschain ID: Two blockchains can contain the same crosschain*'
  prefs: []
  type: TYPE_NORMAL
- en: '*ID and hence mistakenly transfer assets to a wrong blockchain.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*This security concern is addressed by comparing the hash of the*'
  prefs: []
  type: TYPE_NORMAL
- en: '*crosschain ID with the hash of the genesis block. If it matches, then the*'
  prefs: []
  type: TYPE_NORMAL
- en: '*crosschain ID is verified. If not, the* *crosschain ID* *can be compared with
    the* *forked block hash. If none of the block hash match the crosschain ID hash,*'
  prefs: []
  type: TYPE_NORMAL
- en: '*then the crosschain ID cannot be verified.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Preventing relay attack: Although crosschain ID by itself is different from*'
  prefs: []
  type: TYPE_NORMAL
- en: '*chainId and it is not signed into blockchain transaction, the crosschain ID*'
  prefs: []
  type: TYPE_NORMAL
- en: '*can still be used for preventing relay attack. An application that handles*'
  prefs: []
  type: TYPE_NORMAL
- en: '*crosschain transaction can verify the crosschain ID with its block hash*'
  prefs: []
  type: TYPE_NORMAL
- en: '*and decide whether the transaction is valid or not. Any transaction with a*'
  prefs: []
  type: TYPE_NORMAL
- en: '*nonverifiable crosschain ID should be rejected.*'
  prefs: []
  type: TYPE_NORMAL
- en: '412'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 11 Building team projeCts
  prefs: []
  type: TYPE_NORMAL
- en: '*The* *crosschain ID* *is not required to be signed into blockchain tx. For*
    *blockchains that do not cryptographically sign crosschain ID into the blocks,*'
  prefs: []
  type: TYPE_NORMAL
- en: '*the crosschain ID cannot be verified with the blocks themselves and has*'
  prefs: []
  type: TYPE_NORMAL
- en: '*to be verified with external smart contract address and offchain utilities*'
  prefs: []
  type: TYPE_NORMAL
- en: '*implemented based on the crosschain ID specification.*'
  prefs: []
  type: TYPE_NORMAL
- en: To use the crosschainId, a service needs to be developed and deployed
  prefs: []
  type: TYPE_NORMAL
- en: to a blockchain to register crosschain identities for different blockchains.
  prefs: []
  type: TYPE_NORMAL
- en: 'This service should provide the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: • Allow a user to register a blockchain to the service
  prefs: []
  type: TYPE_NORMAL
- en: • Allow administrator or a group of administrators to
  prefs: []
  type: TYPE_NORMAL
- en: approve or revoke a blockchain registered by a user
  prefs: []
  type: TYPE_NORMAL
- en: • Allow a user to modify the blockchain information
  prefs: []
  type: TYPE_NORMAL
- en: before it is finalized
  prefs: []
  type: TYPE_NORMAL
- en: • Allow any user to list and retrieve crosschain IDs that
  prefs: []
  type: TYPE_NORMAL
- en: are registered
  prefs: []
  type: TYPE_NORMAL
- en: • Allow lookup of crosschain ID through legacy chainId
  prefs: []
  type: TYPE_NORMAL
- en: defined in EIP-155
  prefs: []
  type: TYPE_NORMAL
- en: '**Architecture**'
  prefs: []
  type: TYPE_NORMAL
- en: The architecture of the crosschain identity service is shown in the
  prefs: []
  type: TYPE_NORMAL
- en: following diagram (Figure [11-4). T](#p423)he blockchain shown on the bottom
    layer provides security and immutability for the service. The middle layer
  prefs: []
  type: TYPE_NORMAL
- en: is the smart contracts with functions such as adding crosschain ID, query
  prefs: []
  type: TYPE_NORMAL
- en: ID, approve or revoke ID, modify ID, etc. The smart contract can query or
  prefs: []
  type: TYPE_NORMAL
- en: save states to the blockchain through EVM. The top layer is the GUI layer
  prefs: []
  type: TYPE_NORMAL
- en: that renders web pages, processes user inputs, and communicates with
  prefs: []
  type: TYPE_NORMAL
- en: smart contracts with Web3 and MetaMask wallet. The Web3 layer will need
  prefs: []
  type: TYPE_NORMAL
- en: to connect with an RPC node in order to access smart contracts.
  prefs: []
  type: TYPE_NORMAL
- en: '413'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-423_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 11 Building team projeCts
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 11-4\.** Crosschain id service architecture*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Design the Smart Contract**'
  prefs: []
  type: TYPE_NORMAL
- en: 'When designing the smart contract, the following factors are considered:'
  prefs: []
  type: TYPE_NORMAL
- en: actors and roles, data structures, events, and functions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Roles**'
  prefs: []
  type: TYPE_NORMAL
- en: Three roles are defined for the crosschain ID service smart contract. The
  prefs: []
  type: TYPE_NORMAL
- en: owner is a role who deploys the smart contract. This owner owns the smart
  prefs: []
  type: TYPE_NORMAL
- en: contract and has the privilege to assign an administrator for the smart
  prefs: []
  type: TYPE_NORMAL
- en: contract. The administrator (admin) manages the crosschain IDs and
  prefs: []
  type: TYPE_NORMAL
- en: can approve or revoke a crosschain ID. Then there are also regular users
  prefs: []
  type: TYPE_NORMAL
- en: who can query crosschain IDs, add a new crosschain ID, or modify its
  prefs: []
  type: TYPE_NORMAL
- en: information.
  prefs: []
  type: TYPE_NORMAL
- en: '414'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 11 Building team projeCts
  prefs: []
  type: TYPE_NORMAL
- en: '**Events**'
  prefs: []
  type: TYPE_NORMAL
- en: When users perform operations on the smart contract, several kinds
  prefs: []
  type: TYPE_NORMAL
- en: of events can be emitted so that client applications can query what has
  prefs: []
  type: TYPE_NORMAL
- en: 'happened. Four events are defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '**AddChainId** – This event is emitted when a new'
  prefs: []
  type: TYPE_NORMAL
- en: crosschain ID is added to the service.
  prefs: []
  type: TYPE_NORMAL
- en: '**VerifyChainId** – This event is emitted when a'
  prefs: []
  type: TYPE_NORMAL
- en: crosschain ID has been verified and approved by the
  prefs: []
  type: TYPE_NORMAL
- en: administrator.
  prefs: []
  type: TYPE_NORMAL
- en: '**RevokeChainId** – This event is emitted when'
  prefs: []
  type: TYPE_NORMAL
- en: a crosschain ID has been revoked by the
  prefs: []
  type: TYPE_NORMAL
- en: administrator.
  prefs: []
  type: TYPE_NORMAL
- en: '**ModifyChainIdInfo** – This event is emitted when a'
  prefs: []
  type: TYPE_NORMAL
- en: registrator modifies metadata of a crosschain ID.
  prefs: []
  type: TYPE_NORMAL
- en: '**Data Structures**'
  prefs: []
  type: TYPE_NORMAL
- en: Several data structures have been defined. There is a chainidInfo data
  prefs: []
  type: TYPE_NORMAL
- en: struct that contains manager address, long name, short name, category,
  prefs: []
  type: TYPE_NORMAL
- en: and URL string of a blockchain. There is a Status enumeration with values
  prefs: []
  type: TYPE_NORMAL
- en: of Pending, Verified, and Revoked. Pending is a status when a crosschain
  prefs: []
  type: TYPE_NORMAL
- en: ID is just registered. Verified is a status when an administrator approves
  prefs: []
  type: TYPE_NORMAL
- en: the crosschain ID. Revoked is a status when the administrator finds issues
  prefs: []
  type: TYPE_NORMAL
- en: with the crosschain ID and rejects its registration. There are also several
  prefs: []
  type: TYPE_NORMAL
- en: mapping data structures such as idStatus and idInfo that allow the smart
  prefs: []
  type: TYPE_NORMAL
- en: contract to look up crosschain ID status and metadata information. And
  prefs: []
  type: TYPE_NORMAL
- en: finally, there is a legacyIds that maps a legacy ID with a new crosschain ID.
  prefs: []
  type: TYPE_NORMAL
- en: '415'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 11 Building team projeCts
  prefs: []
  type: TYPE_NORMAL
- en: '**Functions**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following functions are defined for the smart contract:'
  prefs: []
  type: TYPE_NORMAL
- en: '**addChainId** – This function adds a new crosschain'
  prefs: []
  type: TYPE_NORMAL
- en: ID to the service. It can be called by any user.
  prefs: []
  type: TYPE_NORMAL
- en: '**changeAdmin** – This function changes the'
  prefs: []
  type: TYPE_NORMAL
- en: administrator of the service. It can be called by the
  prefs: []
  type: TYPE_NORMAL
- en: owner of the smart contract.
  prefs: []
  type: TYPE_NORMAL
- en: '**apporveChainid** – This function changes the status'
  prefs: []
  type: TYPE_NORMAL
- en: of the crosschain ID to Verified. It can only be called
  prefs: []
  type: TYPE_NORMAL
- en: by the administrator of the smart contract service.
  prefs: []
  type: TYPE_NORMAL
- en: '**revokeChainid** – This function changes the status of'
  prefs: []
  type: TYPE_NORMAL
- en: the crosschain ID to Revoked. It can only be called
  prefs: []
  type: TYPE_NORMAL
- en: by the administrator of the smart contract service.
  prefs: []
  type: TYPE_NORMAL
- en: '**modifyChainidInfo** – This function modified the'
  prefs: []
  type: TYPE_NORMAL
- en: metadata information of the crosschain ID. It can be
  prefs: []
  type: TYPE_NORMAL
- en: called by the manager of a crosschain ID.
  prefs: []
  type: TYPE_NORMAL
- en: '**getChainIdStatus** – This function returns the status'
  prefs: []
  type: TYPE_NORMAL
- en: of the crosschain ID.
  prefs: []
  type: TYPE_NORMAL
- en: '**getChainIdFromLegacyId** – This function returns'
  prefs: []
  type: TYPE_NORMAL
- en: the crosschain ID associated with a legacy ID.
  prefs: []
  type: TYPE_NORMAL
- en: '**getChainIdInfo** – This function returns the'
  prefs: []
  type: TYPE_NORMAL
- en: metadata information of a chainId.
  prefs: []
  type: TYPE_NORMAL
- en: '**UML of Smart Contract**'
  prefs: []
  type: TYPE_NORMAL
- en: To better visualize the crosschain id service smart contract, the following
  prefs: []
  type: TYPE_NORMAL
- en: 'UML (Universal Modeling Language) diagram (Figur[e 11-5) is g](#p426)enerated:
    416'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-426_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 11 Building team projeCts
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 11-5\.** UML diagram of crosschain id service smart contract*'
  prefs: []
  type: TYPE_NORMAL
- en: '417'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 11 Building team projeCts
  prefs: []
  type: TYPE_NORMAL
- en: '**Smart Contract Code**'
  prefs: []
  type: TYPE_NORMAL
- en: The code and explanation for the crosschain ID smart contract are shown
  prefs: []
  type: TYPE_NORMAL
- en: 'in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '// SPDX-License-Identifier: GPL-3.0'
  prefs: []
  type: TYPE_NORMAL
- en: pragma solidity >=0.7.0 <0.9.0;
  prefs: []
  type: TYPE_NORMAL
- en: /**
  prefs: []
  type: TYPE_NORMAL
- en: '* @title CrosschainId'
  prefs: []
  type: TYPE_NORMAL
- en: '* @dev manage crosschain identity services'
  prefs: []
  type: TYPE_NORMAL
- en: '*/'
  prefs: []
  type: TYPE_NORMAL
- en: contract CrosschainIdService {
  prefs: []
  type: TYPE_NORMAL
- en: // string message;
  prefs: []
  type: TYPE_NORMAL
- en: address public owner;
  prefs: []
  type: TYPE_NORMAL
- en: address public admin;
  prefs: []
  type: TYPE_NORMAL
- en: bytes32 public latestChainid;
  prefs: []
  type: TYPE_NORMAL
- en: // bytes4 public newlid;
  prefs: []
  type: TYPE_NORMAL
- en: uint public totalcount;
  prefs: []
  type: TYPE_NORMAL
- en: bytes32 public newSha256;
  prefs: []
  type: TYPE_NORMAL
- en: enum Status{PENDING, VERIFIED, REVOKED}
  prefs: []
  type: TYPE_NORMAL
- en: // mapping(bytes32 => bytes32) chainidlist;
  prefs: []
  type: TYPE_NORMAL
- en: mapping(bytes32 => Status) public idStatus;
  prefs: []
  type: TYPE_NORMAL
- en: // mapping legacy id with chainid for faster lookup
  prefs: []
  type: TYPE_NORMAL
- en: mapping(uint => bytes32) legacyIds;
  prefs: []
  type: TYPE_NORMAL
- en: struct chainidInfo {
  prefs: []
  type: TYPE_NORMAL
- en: address manager;
  prefs: []
  type: TYPE_NORMAL
- en: string longname;
  prefs: []
  type: TYPE_NORMAL
- en: string shortname;
  prefs: []
  type: TYPE_NORMAL
- en: string category;
  prefs: []
  type: TYPE_NORMAL
- en: string url;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '418'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 11 Building team projeCts
  prefs: []
  type: TYPE_NORMAL
- en: mapping(bytes32 => chainidInfo) idInfo;
  prefs: []
  type: TYPE_NORMAL
- en: event AddChainId(bytes32 indexed chainId, string name);
  prefs: []
  type: TYPE_NORMAL
- en: event VerifyChainId(bytes32 indexed chainId);
  prefs: []
  type: TYPE_NORMAL
- en: event RevokeChainId(bytes32 indexed chainId);
  prefs: []
  type: TYPE_NORMAL
- en: event ModifyChainIdInfo(bytes32 indexed chainId);
  prefs: []
  type: TYPE_NORMAL
- en: modifier onlyOwner() {
  prefs: []
  type: TYPE_NORMAL
- en: require(msg.sender == owner);
  prefs: []
  type: TYPE_NORMAL
- en: _;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: modifier onlyAdmin() {
  prefs: []
  type: TYPE_NORMAL
- en: require(msg.sender == admin);
  prefs: []
  type: TYPE_NORMAL
- en: _;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: //add common crosschain id such as Etherem mainnet.
  prefs: []
  type: TYPE_NORMAL
- en: constructor() {
  prefs: []
  type: TYPE_NORMAL
- en: owner = msg.sender;
  prefs: []
  type: TYPE_NORMAL
- en: admin = msg.sender;
  prefs: []
  type: TYPE_NORMAL
- en: addChainId(0xd4e56740f876aef8c010b86a40d5f56745a118d090
  prefs: []
  type: TYPE_NORMAL
- en: 6a34e69aec8c0db1cb8fa3, 1, 'Ethereum Mainnet');
  prefs: []
  type: TYPE_NORMAL
- en: modifyChainIdInfo(latestChainid, "Ethereum Mainnet",
  prefs: []
  type: TYPE_NORMAL
- en: '"eth", "mainnet", "www.etherscan.io");'
  prefs: []
  type: TYPE_NORMAL
- en: addChainId(0x6341fd3daf94b748c72ced5a5b26028f2474f5f0
  prefs: []
  type: TYPE_NORMAL
- en: 0d824504e4fa37a75767e177, 4, 'Ethereum Rinkeby');
  prefs: []
  type: TYPE_NORMAL
- en: modifyChainIdInfo(latestChainid, "Ethereum Rinkeby",
  prefs: []
  type: TYPE_NORMAL
- en: '"rinkeby", "testnet", "rinkeby.etherscan.io");'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: // add a crosschainId
  prefs: []
  type: TYPE_NORMAL
- en: '// @hash: The block hash for a genesis block or the first'
  prefs: []
  type: TYPE_NORMAL
- en: forked block
  prefs: []
  type: TYPE_NORMAL
- en: '419'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 11 Building team projeCts
  prefs: []
  type: TYPE_NORMAL
- en: '// legacyid: Legacy chainid based on EIP-155'
  prefs: []
  type: TYPE_NORMAL
- en: // name of the blockchain
  prefs: []
  type: TYPE_NORMAL
- en: function addChainId(bytes32 hash, uint legacyid, string
  prefs: []
  type: TYPE_NORMAL
- en: memory name) public returns (bytes32 chainid) {
  prefs: []
  type: TYPE_NORMAL
- en: require(hash != 0x00);
  prefs: []
  type: TYPE_NORMAL
- en: //require (check uniqueness, check oracle if needed)
  prefs: []
  type: TYPE_NORMAL
- en: // trim the other 16 bytes
  prefs: []
  type: TYPE_NORMAL
- en: hash = (hash >> 128) <<128;
  prefs: []
  type: TYPE_NORMAL
- en: //get legacy chainid in bytes32 format
  prefs: []
  type: TYPE_NORMAL
- en: bytes32 legacy_chainid = bytesToBytes32(toBytes(l
  prefs: []
  type: TYPE_NORMAL
- en: egacyid));
  prefs: []
  type: TYPE_NORMAL
- en: // reserve 8 bytes for legacy chainid. Merge with
  prefs: []
  type: TYPE_NORMAL
- en: block hash
  prefs: []
  type: TYPE_NORMAL
- en: hash = hash | (legacy_chainid << 64);
  prefs: []
  type: TYPE_NORMAL
- en: // Calculate sha256 of the combined hash
  prefs: []
  type: TYPE_NORMAL
- en: newSha256 = sha256(abi.encodePacked(hash));
  prefs: []
  type: TYPE_NORMAL
- en: // merge the hash with first two bytes of sha256 as
  prefs: []
  type: TYPE_NORMAL
- en: checksum
  prefs: []
  type: TYPE_NORMAL
- en: hash = hash | (newSha256 >> 240);
  prefs: []
  type: TYPE_NORMAL
- en: chainid = hash;
  prefs: []
  type: TYPE_NORMAL
- en: //Check if chainid already registered. If idStatus is
  prefs: []
  type: TYPE_NORMAL
- en: empty it has 0x00, revert and exit
  prefs: []
  type: TYPE_NORMAL
- en: if(abi.encodePacked(idStatus[chainid]).length > 1) {
  prefs: []
  type: TYPE_NORMAL
- en: revert();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: if(legacyIds[legacyid] != bytes32(0)) {
  prefs: []
  type: TYPE_NORMAL
- en: revert();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '420'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 11 Building team projeCts
  prefs: []
  type: TYPE_NORMAL
- en: legacyIds[legacyid] = chainid;
  prefs: []
  type: TYPE_NORMAL
- en: latestChainid = chainid;
  prefs: []
  type: TYPE_NORMAL
- en: // set idStatus to PENDING
  prefs: []
  type: TYPE_NORMAL
- en: idStatus[chainid] = Status.PENDING;
  prefs: []
  type: TYPE_NORMAL
- en: // set chainid metadata (partial). The rest set with
  prefs: []
  type: TYPE_NORMAL
- en: modifyChainIdInfo
  prefs: []
  type: TYPE_NORMAL
- en: idInfo[chainid].manager = msg.sender;
  prefs: []
  type: TYPE_NORMAL
- en: idInfo[chainid].longname = name;
  prefs: []
  type: TYPE_NORMAL
- en: //increment totalcount
  prefs: []
  type: TYPE_NORMAL
- en: totalcount++;
  prefs: []
  type: TYPE_NORMAL
- en: emit AddChainId(chainid, name);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: //The owner changes the administrator of the service. The
  prefs: []
  type: TYPE_NORMAL
- en: admin can be a multisign address managed out of chain
  prefs: []
  type: TYPE_NORMAL
- en: function changeAdmin(address newAdmin) onlyOwner public {
  prefs: []
  type: TYPE_NORMAL
- en: admin = newAdmin;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: // require sender to be admin
  prefs: []
  type: TYPE_NORMAL
- en: // approve a chainid
  prefs: []
  type: TYPE_NORMAL
- en: function approveChainid(bytes32 chainId) onlyAdmin public {
  prefs: []
  type: TYPE_NORMAL
- en: require(idStatus[chainId] == Status.PENDING);
  prefs: []
  type: TYPE_NORMAL
- en: idStatus[chainId] = Status.VERIFIED;
  prefs: []
  type: TYPE_NORMAL
- en: emit VerifyChainId(chainId);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: // require sender to be admin
  prefs: []
  type: TYPE_NORMAL
- en: // revoke a chainid
  prefs: []
  type: TYPE_NORMAL
- en: function revokeChainid(bytes32 chainId) onlyAdmin public {
  prefs: []
  type: TYPE_NORMAL
- en: '421'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 11 Building team projeCts
  prefs: []
  type: TYPE_NORMAL
- en: require(idStatus[chainId] != Status.REVOKED); //Can
  prefs: []
  type: TYPE_NORMAL
- en: revoke chainId in PENDING or VERIFIED status
  prefs: []
  type: TYPE_NORMAL
- en: idStatus[chainId] = Status.REVOKED;
  prefs: []
  type: TYPE_NORMAL
- en: emit RevokeChainId(chainId);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: function modifyChainIdInfo(bytes32 chainid, string memory
  prefs: []
  type: TYPE_NORMAL
- en: longname, string memory shortname, string memory category,
  prefs: []
  type: TYPE_NORMAL
- en: string memory url) public {
  prefs: []
  type: TYPE_NORMAL
- en: require(idStatus[chainid] == Status.PENDING);
  prefs: []
  type: TYPE_NORMAL
- en: require(idInfo[chainid].manager == msg.sender);
  prefs: []
  type: TYPE_NORMAL
- en: if(bytes(longname).length > 1) {
  prefs: []
  type: TYPE_NORMAL
- en: idInfo[chainid].longname = longname;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: if(bytes(shortname).length > 1) {
  prefs: []
  type: TYPE_NORMAL
- en: idInfo[chainid].shortname = shortname;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: if(bytes(category).length > 1) {
  prefs: []
  type: TYPE_NORMAL
- en: idInfo[chainid].category = category;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: if(bytes(url).length > 1) {
  prefs: []
  type: TYPE_NORMAL
- en: idInfo[chainid].url = url;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: emit ModifyChainIdInfo(chainid);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: function getChainIdStatus(bytes32 hash) public view returns
  prefs: []
  type: TYPE_NORMAL
- en: (Status) {
  prefs: []
  type: TYPE_NORMAL
- en: return idStatus[hash];
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: function getChainIdFromLegacyId(uint legacyId) public view
  prefs: []
  type: TYPE_NORMAL
- en: returns (bytes32) {
  prefs: []
  type: TYPE_NORMAL
- en: '422'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 11 Building team projeCts
  prefs: []
  type: TYPE_NORMAL
- en: return legacyIds[legacyId];
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: function getChainIdInfo(bytes32 hash) public view returns
  prefs: []
  type: TYPE_NORMAL
- en: (chainidInfo memory) {
  prefs: []
  type: TYPE_NORMAL
- en: return idInfo[hash];
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: //convert an integer to byte array
  prefs: []
  type: TYPE_NORMAL
- en: function toBytes(uint256 x) public pure returns (bytes
  prefs: []
  type: TYPE_NORMAL
- en: memory b) {
  prefs: []
  type: TYPE_NORMAL
- en: b = new bytes(32);
  prefs: []
  type: TYPE_NORMAL
- en: // b = abi.encodePacked(x);
  prefs: []
  type: TYPE_NORMAL
- en: assembly { mstore(add(b, 32), x) }
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: //convert byte array to bytes32 fixed array
  prefs: []
  type: TYPE_NORMAL
- en: function bytesToBytes32(bytes memory source) public pure
  prefs: []
  type: TYPE_NORMAL
- en: returns (bytes32 result) {
  prefs: []
  type: TYPE_NORMAL
- en: if (source.length == 0) {
  prefs: []
  type: TYPE_NORMAL
- en: return 0x0;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: assembly {
  prefs: []
  type: TYPE_NORMAL
- en: result = mload(add(source, 32))
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '**Client Considerations**'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding section, a smart contract is deployed to a blockchain
  prefs: []
  type: TYPE_NORMAL
- en: that allows external programs to call the smart contract functions through
  prefs: []
  type: TYPE_NORMAL
- en: transactions. These client programs can be in command-line interfaces
  prefs: []
  type: TYPE_NORMAL
- en: '423'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 11 Building team projeCts
  prefs: []
  type: TYPE_NORMAL
- en: or web applications. A popular client application is through a web-based
  prefs: []
  type: TYPE_NORMAL
- en: browser to render the GUI and use MetaMask as a wallet to send the
  prefs: []
  type: TYPE_NORMAL
- en: transactions. In the following, we demonstrate how to build web pages to
  prefs: []
  type: TYPE_NORMAL
- en: interact with smart contracts.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, a web page to interact with a smart contract contains the
  prefs: []
  type: TYPE_NORMAL
- en: 'following components:'
  prefs: []
  type: TYPE_NORMAL
- en: • HTML pages to render the GUI
  prefs: []
  type: TYPE_NORMAL
- en: • JavaScript to process user inputs and smart
  prefs: []
  type: TYPE_NORMAL
- en: contract output
  prefs: []
  type: TYPE_NORMAL
- en: • Web3 for JavaScript and smart contract function calls
  prefs: []
  type: TYPE_NORMAL
- en: • MetaMask plug-in or extension for a wallet to sign
  prefs: []
  type: TYPE_NORMAL
- en: transactions
  prefs: []
  type: TYPE_NORMAL
- en: In the case of crosschainId service, the following HTML pages are
  prefs: []
  type: TYPE_NORMAL
- en: 'designed (Figur[e 11-6](#p433)):'
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 11-6\.** Html files for the crosschain id service user interfacet*'
  prefs: []
  type: TYPE_NORMAL
- en: '424'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-434_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 11 Building team projeCts
  prefs: []
  type: TYPE_NORMAL
- en: Each HTML page will have user input in the browser pages and also
  prefs: []
  type: TYPE_NORMAL
- en: include JavaScript to handle the browser events and user interactions.
  prefs: []
  type: TYPE_NORMAL
- en: '**HTML Page Example**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following (Figure [11-7](#p434)) is an example of an “Add crosschain id”
    GUI markup web page:'
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 11-7\.** Example of adding crosschain id GUI page*'
  prefs: []
  type: TYPE_NORMAL
- en: To render this page, the following HTML is written with multiple
  prefs: []
  type: TYPE_NORMAL
- en: clickable buttons and input fields. The “Connect Wallet” button allows
  prefs: []
  type: TYPE_NORMAL
- en: that page to connect to a MetaMask wallet. The “Add Crosschain id”
  prefs: []
  type: TYPE_NORMAL
- en: button triggers a call to crosschainId smart contract to add a chainId to
  prefs: []
  type: TYPE_NORMAL
- en: the blockchain. To send transactions to smart contracts on a blockchain,
  prefs: []
  type: TYPE_NORMAL
- en: several JavaScripts containing Web3, ABI, and APIs are included. The
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript codes are explained in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: <!DOCTYPE html>
  prefs: []
  type: TYPE_NORMAL
- en: <HTML>
  prefs: []
  type: TYPE_NORMAL
- en: <HEAD>
  prefs: []
  type: TYPE_NORMAL
- en: '425'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 11 Building team projeCts
  prefs: []
  type: TYPE_NORMAL
- en: <META name="generator" content=
  prefs: []
  type: TYPE_NORMAL
- en: '"HTML Tidy for HTML5 for Linux version 5.6.0">'
  prefs: []
  type: TYPE_NORMAL
- en: <META charset="utf-8">
  prefs: []
  type: TYPE_NORMAL
- en: <TITLE>CrosschainIdService</TITLE>
  prefs: []
  type: TYPE_NORMAL
- en: <BASE href="/">
  prefs: []
  type: TYPE_NORMAL
- en: <META name="viewport" content=
  prefs: []
  type: TYPE_NORMAL
- en: '"width=device-width, initial-scale=1">'
  prefs: []
  type: TYPE_NORMAL
- en: <LINK rel="stylesheet" href="stylesheets/bootstrap.min.css">
  prefs: []
  type: TYPE_NORMAL
- en: <LINK rel="stylesheet" href="stylesheets/style.css">
  prefs: []
  type: TYPE_NORMAL
- en: </HEAD>
  prefs: []
  type: TYPE_NORMAL
- en: <BODY>
  prefs: []
  type: TYPE_NORMAL
- en: <DIV class="container addCrosschainid">
  prefs: []
  type: TYPE_NORMAL
- en: <DIV class="row" id="addcrosschainidrow">
  prefs: []
  type: TYPE_NORMAL
- en: <DIV class="col-lg-6 text-center">
  prefs: []
  type: TYPE_NORMAL
- en: <H2>Add a new crosschain id</H2>
  prefs: []
  type: TYPE_NORMAL
- en: <p> <button class="enableEthereumButton">Connect
  prefs: []
  type: TYPE_NORMAL
- en: Wallet</button>
  prefs: []
  type: TYPE_NORMAL
- en: <br>Wallet Account:&nbsp; <span class="showAccount">
  prefs: []
  type: TYPE_NORMAL
- en: <hr>
  prefs: []
  type: TYPE_NORMAL
- en: <DIV class="blockhash">
  prefs: []
  type: TYPE_NORMAL
- en: <LABEL for="blockhash"><B>Genesis Blockhash</B>
  prefs: []
  type: TYPE_NORMAL
- en: </LABEL>
  prefs: []
  type: TYPE_NORMAL
- en: <INPUT type="text" class="ignore-form-control" id=
  prefs: []
  type: TYPE_NORMAL
- en: '"blockhash" placeholder="" value="[block0_hash]"'
  prefs: []
  type: TYPE_NORMAL
- en: size="34"
  prefs: []
  type: TYPE_NORMAL
- en: required="">
  prefs: []
  type: TYPE_NORMAL
- en: </DIV>
  prefs: []
  type: TYPE_NORMAL
- en: <DIV class="legacyid">
  prefs: []
  type: TYPE_NORMAL
- en: <LABEL for="legacyid"><B>legacy chainid</B></LABEL>
  prefs: []
  type: TYPE_NORMAL
- en: <INPUT type="text" class="ignore-form-control" id=
  prefs: []
  type: TYPE_NORMAL
- en: '"legacyid" placeholder="" value="[EIP-155 id]" size="10"'
  prefs: []
  type: TYPE_NORMAL
- en: '426'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 11 Building team projeCts
  prefs: []
  type: TYPE_NORMAL
- en: required="">
  prefs: []
  type: TYPE_NORMAL
- en: </DIV>
  prefs: []
  type: TYPE_NORMAL
- en: <DIV class="chainname">
  prefs: []
  type: TYPE_NORMAL
- en: <LABEL for="chainname"><B>Chain name</B></LABEL>
  prefs: []
  type: TYPE_NORMAL
- en: <INPUT type="text" class="ignore-form-control" id=
  prefs: []
  type: TYPE_NORMAL
- en: '"chainname" placeholder="" value="[Ethereum Mainnet]"'
  prefs: []
  type: TYPE_NORMAL
- en: size="20"
  prefs: []
  type: TYPE_NORMAL
- en: required="">
  prefs: []
  type: TYPE_NORMAL
- en: </DIV>
  prefs: []
  type: TYPE_NORMAL
- en: <br>
  prefs: []
  type: TYPE_NORMAL
- en: <div class="center-this" id="addChainidButton">
  prefs: []
  type: TYPE_NORMAL
- en: <button style="margin:0;" onclick="addChainid()"
  prefs: []
  type: TYPE_NORMAL
- en: id="addChainidButton">Add Crosschain id</button></div>
  prefs: []
  type: TYPE_NORMAL
- en: <DIV id="addChainidValue"></DIV>
  prefs: []
  type: TYPE_NORMAL
- en: </DIV>
  prefs: []
  type: TYPE_NORMAL
- en: </DIV><!-- <hr class="featurette-divider"> -->
  prefs: []
  type: TYPE_NORMAL
- en: <SCRIPT src="/scripts/web3.min.js"></SCRIPT>
  prefs: []
  type: TYPE_NORMAL
- en: <SCRIPT src="/scripts/jquery-3.3.1.slim.min.js"></SCRIPT>
  prefs: []
  type: TYPE_NORMAL
- en: <SCRIPT src="/scripts/jquery.min.js"></SCRIPT>
  prefs: []
  type: TYPE_NORMAL
- en: <SCRIPT src="/scripts/enableEthereum.js"></SCRIPT>
  prefs: []
  type: TYPE_NORMAL
- en: <SCRIPT src="/scripts/crosschainid_info.js"></SCRIPT>
  prefs: []
  type: TYPE_NORMAL
- en: <SCRIPT src="/scripts/addCrosschainid.js"></SCRIPT>
  prefs: []
  type: TYPE_NORMAL
- en: </DIV>
  prefs: []
  type: TYPE_NORMAL
- en: </BODY>
  prefs: []
  type: TYPE_NORMAL
- en: </HTML>
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript Example**'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding addCrosschainid.html file, several JavaScript files are
  prefs: []
  type: TYPE_NORMAL
- en: included. The web3.min.js file is a JavaScript Web3 implementation for
  prefs: []
  type: TYPE_NORMAL
- en: browsers. This is an open source file that can be downloaded from the
  prefs: []
  type: TYPE_NORMAL
- en: Web. The enableEthereum.js file is to implement the “Connect Wallet”
  prefs: []
  type: TYPE_NORMAL
- en: '427'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 11 Building team projeCts
  prefs: []
  type: TYPE_NORMAL
- en: button event. Clicking at this button will trigger a function call to get the
  prefs: []
  type: TYPE_NORMAL
- en: wallet address connected to the browser. In this enableEthereum.js script,
  prefs: []
  type: TYPE_NORMAL
- en: the ethereumButton object corresponds to the “Connect Wallet” button
  prefs: []
  type: TYPE_NORMAL
- en: and is registered with a click event handler to call getAccount() function.
  prefs: []
  type: TYPE_NORMAL
- en: The getAccount calls the Web3 function of eth_requestAccounts to retrieve
  prefs: []
  type: TYPE_NORMAL
- en: the accounts in the MetaMask. The first account is assigned to account0
  prefs: []
  type: TYPE_NORMAL
- en: that can be referred to by other scripts. Here, the showAccount object is a
  prefs: []
  type: TYPE_NORMAL
- en: Div object that will be populated with the account address retrieved from
  prefs: []
  type: TYPE_NORMAL
- en: the getAccount() function call.
  prefs: []
  type: TYPE_NORMAL
- en: —----------- enableEthereum.js —---------------------------
  prefs: []
  type: TYPE_NORMAL
- en: const ethereumButton = document.querySelector('.
  prefs: []
  type: TYPE_NORMAL
- en: enableEthereumButton');
  prefs: []
  type: TYPE_NORMAL
- en: const showAccount = document.querySelector('.showAccount');
  prefs: []
  type: TYPE_NORMAL
- en: var account0 = 0;
  prefs: []
  type: TYPE_NORMAL
- en: ethereumButton.addEventListener('click', () => {
  prefs: []
  type: TYPE_NORMAL
- en: getAccount();
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: async function getAccount() {
  prefs: []
  type: TYPE_NORMAL
- en: 'const accounts = await ethereum.request({ method: ''eth_'
  prefs: []
  type: TYPE_NORMAL
- en: requestAccounts' });
  prefs: []
  type: TYPE_NORMAL
- en: account0 = accounts[0];
  prefs: []
  type: TYPE_NORMAL
- en: showAccount.innerHTML = account0;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: Once enableEthereum.js retrieves the account, a user can enter block 0
  prefs: []
  type: TYPE_NORMAL
- en: hash, legacy chainId, and blockchain name and click the “Add crosschain
  prefs: []
  type: TYPE_NORMAL
- en: id” button to register a new blockchain ID. This function is implemented
  prefs: []
  type: TYPE_NORMAL
- en: in addCrosschainid.js JavaScript. In this script, the addChainid() function
  prefs: []
  type: TYPE_NORMAL
- en: is called when “Add Crosschain id” button in the web page is clicked. This
  prefs: []
  type: TYPE_NORMAL
- en: function first checks if the MetaMask wallet is enabled and connected.
  prefs: []
  type: TYPE_NORMAL
- en: If not, the user will be prompted to install a MetaMask extension. If yes,
  prefs: []
  type: TYPE_NORMAL
- en: '428'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 11 Building team projeCts
  prefs: []
  type: TYPE_NORMAL
- en: a smart contract object named myContract will be constructed with a
  prefs: []
  type: TYPE_NORMAL
- en: crosschain ID smart contract ABI and contract address. The ABI and
  prefs: []
  type: TYPE_NORMAL
- en: contract address are specified in a separate crosschainid_info.js file.
  prefs: []
  type: TYPE_NORMAL
- en: myContract object supports addChainId method that takes in parameters
  prefs: []
  type: TYPE_NORMAL
- en: of block hash, legacyId, and chain name. These parameters are fetched
  prefs: []
  type: TYPE_NORMAL
- en: through the input fields in the web page. There are multiple ways to call a
  prefs: []
  type: TYPE_NORMAL
- en: smart contract function. In this example, the smart contract function call
  prefs: []
  type: TYPE_NORMAL
- en: 'data is first calculated through the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: var chainidData = myContract.methods.addChainId(blockhash,
  prefs: []
  type: TYPE_NORMAL
- en: legacyid, chainname).encodeABI();
  prefs: []
  type: TYPE_NORMAL
- en: Then chainidData is sent to the smart contract through web3\.
  prefs: []
  type: TYPE_NORMAL
- en: eth.sendTransaction operation. The transaction receipt is
  prefs: []
  type: TYPE_NORMAL
- en: returned and shown on the web page.
  prefs: []
  type: TYPE_NORMAL
- en: —----------- addCrosschainid.js —--------------------------
  prefs: []
  type: TYPE_NORMAL
- en: //addCrosschain.js implements the addChainid function call to
  prefs: []
  type: TYPE_NORMAL
- en: add a crosschain id to smart contract
  prefs: []
  type: TYPE_NORMAL
- en: var web3;
  prefs: []
  type: TYPE_NORMAL
- en: const ethEnabled = () => {
  prefs: []
  type: TYPE_NORMAL
- en: if (typeof window.ethereum === 'undefined') {
  prefs: []
  type: TYPE_NORMAL
- en: alert("You need a Dapp browser to get started. Please
  prefs: []
  type: TYPE_NORMAL
- en: install metamask");
  prefs: []
  type: TYPE_NORMAL
- en: return false;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: web3 = new Web3(window.ethereum);
  prefs: []
  type: TYPE_NORMAL
- en: return true;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: function addChainid() {
  prefs: []
  type: TYPE_NORMAL
- en: if (!ethEnabled()) {
  prefs: []
  type: TYPE_NORMAL
- en: '429'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 11 Building team projeCts
  prefs: []
  type: TYPE_NORMAL
- en: alert("Please install an Ethereum-compatible browser or
  prefs: []
  type: TYPE_NORMAL
- en: extension like MetaMask to use this dApp!");
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: web3.eth.getAccounts(function(err, accounts) {
  prefs: []
  type: TYPE_NORMAL
- en: var myContract = new web3.eth.Contract(crosschainid_abi,
  prefs: []
  type: TYPE_NORMAL
- en: crosschainid_contract.toLowerCase());
  prefs: []
  type: TYPE_NORMAL
- en: var blockhash = $('.blockhash input').val();
  prefs: []
  type: TYPE_NORMAL
- en: var legacyid = $('.legacyid input').val();
  prefs: []
  type: TYPE_NORMAL
- en: var chainname = $('.chainname input').val();
  prefs: []
  type: TYPE_NORMAL
- en: var chainidData = myContract.methods.addChainId(blockhash,
  prefs: []
  type: TYPE_NORMAL
- en: legacyid, chainname).encodeABI();
  prefs: []
  type: TYPE_NORMAL
- en: var tx_chainid = web3.eth.sendTransaction({
  prefs: []
  type: TYPE_NORMAL
- en: 'from: accounts[0].toLowerCase(),'
  prefs: []
  type: TYPE_NORMAL
- en: 'to: crosschainid_contract.toLowerCase(),'
  prefs: []
  type: TYPE_NORMAL
- en: 'data: chainidData'
  prefs: []
  type: TYPE_NORMAL
- en: '}, function(err, transactionHash) {'
  prefs: []
  type: TYPE_NORMAL
- en: document.getElementById("addChainidValue").innerHTML =
  prefs: []
  type: TYPE_NORMAL
- en: '"addChainid tx:" + transactionHash;'
  prefs: []
  type: TYPE_NORMAL
- en: '})'
  prefs: []
  type: TYPE_NORMAL
- en: '})'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: $(document).ready(function() {
  prefs: []
  type: TYPE_NORMAL
- en: if (!ethEnabled()) {
  prefs: []
  type: TYPE_NORMAL
- en: alert("Please install an Ethereum-compatible browser or
  prefs: []
  type: TYPE_NORMAL
- en: extension like MetaMask to use this dApp!");
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: '430'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 11 Building team projeCts
  prefs: []
  type: TYPE_NORMAL
- en: The preceding example shows how to build an add crosschain ID
  prefs: []
  type: TYPE_NORMAL
- en: web page to interact with a deployed smart contract. Similar pages can
  prefs: []
  type: TYPE_NORMAL
- en: be built for other functions for listing crosschain IDs, modifying chainId
  prefs: []
  type: TYPE_NORMAL
- en: information, approving or revoking crosschain IDs, etc.
  prefs: []
  type: TYPE_NORMAL
- en: '**Security Review**'
  prefs: []
  type: TYPE_NORMAL
- en: There are many factors to be considered for security. The security
  prefs: []
  type: TYPE_NORMAL
- en: guideline in Chapter [8 sho](https://doi.org/10.1007/978-1-4842-8164-2_8)uld
    be followed. Each function in the smart contract should have a privilege check.
    For example, when modifying the
  prefs: []
  type: TYPE_NORMAL
- en: crosschain ID information, there should be a check on the requester to
  prefs: []
  type: TYPE_NORMAL
- en: ensure that it is the original registrator of the crosschain ID. The second
  prefs: []
  type: TYPE_NORMAL
- en: check is that the status of the crosschain ID should be in “Pending” state.
  prefs: []
  type: TYPE_NORMAL
- en: If the crosschain ID is in “Verified” or “Revoked” state, its information
  prefs: []
  type: TYPE_NORMAL
- en: cannot be modified.
  prefs: []
  type: TYPE_NORMAL
- en: Another important item is to ensure that only the administrator can
  prefs: []
  type: TYPE_NORMAL
- en: approve or revoke a crosschain ID registration. This administrator can be a
  prefs: []
  type: TYPE_NORMAL
- en: single account or a multisign account from a consortium. An administrator
  prefs: []
  type: TYPE_NORMAL
- en: can transfer its ownership to another account.
  prefs: []
  type: TYPE_NORMAL
- en: Besides security for the smart contract, the web pages security should
  prefs: []
  type: TYPE_NORMAL
- en: also be evaluated. For a service to be deployed for production, it is a best
  prefs: []
  type: TYPE_NORMAL
- en: practice to have a security audit and white box testing to ensure that there
  prefs: []
  type: TYPE_NORMAL
- en: is no major security vulnerability.
  prefs: []
  type: TYPE_NORMAL
- en: '**Deploy to Testnet**'
  prefs: []
  type: TYPE_NORMAL
- en: When writing the code for smart contract and web GUI, developers can
  prefs: []
  type: TYPE_NORMAL
- en: have a development system and a local web service to test the project.
  prefs: []
  type: TYPE_NORMAL
- en: Once local development is completed, it can be deployed to public testnet
  prefs: []
  type: TYPE_NORMAL
- en: for external users to test it. There are several options for Ethereum testnet.
  prefs: []
  type: TYPE_NORMAL
- en: For the Ethereum blockchain, there are four popular testnets that are
  prefs: []
  type: TYPE_NORMAL
- en: '431'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-441_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 11 Building team projeCts
  prefs: []
  type: TYPE_NORMAL
- en: available, including Ropsten, Kovan, Rinkeby, and Goerli testnets. All the
  prefs: []
  type: TYPE_NORMAL
- en: testnets mentioned here use proof-of-authority (POA) consensus and are
  prefs: []
  type: TYPE_NORMAL
- en: faster than the mainnet. To use these testnets, first connect the
  prefs: []
  type: TYPE_NORMAL
- en: MetaMask wallet to the testnet you want the smart contract to be deployed
  prefs: []
  type: TYPE_NORMAL
- en: to (Figur[e 11-8](#p441)). The testnets have been added to the MetaMask already.
  prefs: []
  type: TYPE_NORMAL
- en: If you cannot see the testnet listed, simply click at show/hide testnets to
  prefs: []
  type: TYPE_NORMAL
- en: open up the configuration widget and set “show the testnets” to “on.”
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 11-8\.** Connecting to the Ethereum mainnet or testnet through*'
  prefs: []
  type: TYPE_NORMAL
- en: '*MetaMask*'
  prefs: []
  type: TYPE_NORMAL
- en: '432'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 11 Building team projeCts
  prefs: []
  type: TYPE_NORMAL
- en: Once the MetaMask wallet is set to the designed testnet, testers
  prefs: []
  type: TYPE_NORMAL
- en: need to get some testing ether to test the dApp. These testnets all
  prefs: []
  type: TYPE_NORMAL
- en: provide a small amount of ether for testing purposes through dedicated
  prefs: []
  type: TYPE_NORMAL
- en: faucets. The faucet addresses and block browser URLs are shown in the
  prefs: []
  type: TYPE_NORMAL
- en: following (Figure [11-9):](#p442)
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 11-9\.** Ethereum testnet faucet addresses*'
  prefs: []
  type: TYPE_NORMAL
- en: Once a smart contract is deployed to testnet and the web pages are
  prefs: []
  type: TYPE_NORMAL
- en: set up to access the smart contract, the project team can announce alpha
  prefs: []
  type: TYPE_NORMAL
- en: or beta test programs to the users. The testing program is to involve
  prefs: []
  type: TYPE_NORMAL
- en: community members to try out the decentralized applications and report
  prefs: []
  type: TYPE_NORMAL
- en: issues found in the project. Normally, bounties are given to users who
  prefs: []
  type: TYPE_NORMAL
- en: report issues found in the project. Due to the immutability of blockchain,
  prefs: []
  type: TYPE_NORMAL
- en: it is critical that the dApps are tested thoroughly in testnet before being
  prefs: []
  type: TYPE_NORMAL
- en: deployed to the mainnet.
  prefs: []
  type: TYPE_NORMAL
- en: '**Deploy to Mainnet**'
  prefs: []
  type: TYPE_NORMAL
- en: Once the dApp is thoroughly tested in testnet, it can be deployed to the
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum mainnet. The tools and methods for deploying a smart contract
  prefs: []
  type: TYPE_NORMAL
- en: to a production network are the same as the testnet. There is no faucet for
  prefs: []
  type: TYPE_NORMAL
- en: the production network. The ether used for deploying smart contracts will
  prefs: []
  type: TYPE_NORMAL
- en: need to be purchased. Deployment requires noncustodial accounts where
  prefs: []
  type: TYPE_NORMAL
- en: '433'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 11 Building team projeCts
  prefs: []
  type: TYPE_NORMAL
- en: developers actually hold private keys. The custodial accounts hosted by
  prefs: []
  type: TYPE_NORMAL
- en: companies such as Coinbase and PayPal cannot be used. Developers need
  prefs: []
  type: TYPE_NORMAL
- en: to own the private key of an account in order to deploy a smart contract.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, there are several factors to consider for the deployment to the
  prefs: []
  type: TYPE_NORMAL
- en: mainnet.
  prefs: []
  type: TYPE_NORMAL
- en: First and foremost is security. Deployment of smart contracts is done
  prefs: []
  type: TYPE_NORMAL
- en: by sending a transaction to the address 0 of the blockchain. The smart
  prefs: []
  type: TYPE_NORMAL
- en: contract address is generated through hashing only the sender address
  prefs: []
  type: TYPE_NORMAL
- en: and the nonce of that transaction. The data field of the transaction will
  prefs: []
  type: TYPE_NORMAL
- en: be the bytecode of the smart contract and saved to the calculated address
  prefs: []
  type: TYPE_NORMAL
- en: on the blockchain. Once a smart contract is deployed, the owner of the
  prefs: []
  type: TYPE_NORMAL
- en: smart contract is the sender that sends the transaction. This sender may
  prefs: []
  type: TYPE_NORMAL
- en: be assigned privileges to make modifications to the blockchain. It is very
  prefs: []
  type: TYPE_NORMAL
- en: important to safeguard the smart contract owner address. Sometimes, a
  prefs: []
  type: TYPE_NORMAL
- en: smart contract owner can call a function to denounce the ownership or
  prefs: []
  type: TYPE_NORMAL
- en: transfer the ownership to another EOA (external owner account).
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, the smart contract address will need to be published in a
  prefs: []
  type: TYPE_NORMAL
- en: trusted media. Users interact with smart contracts by sending transactions
  prefs: []
  type: TYPE_NORMAL
- en: to the smart contract address. If users send the transactions to a smart
  prefs: []
  type: TYPE_NORMAL
- en: contract with the wrong address, the fake smart contract may intercept the
  prefs: []
  type: TYPE_NORMAL
- en: funds sent to faked smart contracts.
  prefs: []
  type: TYPE_NORMAL
- en: Thirdly, the token associated with the project smart contract will need
  prefs: []
  type: TYPE_NORMAL
- en: to be added from the users’ wallet. The instructions should be provided to
  prefs: []
  type: TYPE_NORMAL
- en: the users. For most of the crypto wallet, the tokens are not automatically
  prefs: []
  type: TYPE_NORMAL
- en: added to the wallet. Users need to add a token to the wallet by adding a
  prefs: []
  type: TYPE_NORMAL
- en: smart contract, token symbol, decimal value, etc. This information will
  prefs: []
  type: TYPE_NORMAL
- en: come from the project team and should be published to the users.
  prefs: []
  type: TYPE_NORMAL
- en: Fourthly, a stable RPC node should be selected and connected to the
  prefs: []
  type: TYPE_NORMAL
- en: MetaMask or other wallets. An RPC node is an Ethereum client node that
  prefs: []
  type: TYPE_NORMAL
- en: syncs all blocks to a system and opens connection to Web3 clients. The
  prefs: []
  type: TYPE_NORMAL
- en: RPC node can be owned by a third party or by the project team itself. In
  prefs: []
  type: TYPE_NORMAL
- en: '434'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 11 Building team projeCts
  prefs: []
  type: TYPE_NORMAL
- en: either case, the RPC node should be safeguarded and prevented from the
  prefs: []
  type: TYPE_NORMAL
- en: attacks.
  prefs: []
  type: TYPE_NORMAL
- en: And lastly, the web pages and smart contract should be properly
  prefs: []
  type: TYPE_NORMAL
- en: integrated. In the web pages, the Web3 object constructs transactions and
  prefs: []
  type: TYPE_NORMAL
- en: sends the request to the blockchain. It is important to evaluate the Web3
  prefs: []
  type: TYPE_NORMAL
- en: and other scripts to make sure that they will not be tempered.
  prefs: []
  type: TYPE_NORMAL
- en: Once the smart contracts are deployed to mainnet, it is open to the
  prefs: []
  type: TYPE_NORMAL
- en: world. Besides the interfaces such as web portal and CLI provided by
  prefs: []
  type: TYPE_NORMAL
- en: the project team, third-party developers can also write applications to
  prefs: []
  type: TYPE_NORMAL
- en: access the smart contract. Due to the “openness,” “decentralization,”
  prefs: []
  type: TYPE_NORMAL
- en: and “immutability” of blockchain, the operation of decentralized apps is
  prefs: []
  type: TYPE_NORMAL
- en: more challenging than regular applications and will need to be discussed
  prefs: []
  type: TYPE_NORMAL
- en: further.
  prefs: []
  type: TYPE_NORMAL
- en: '**Operation and Upgrade Consideration**'
  prefs: []
  type: TYPE_NORMAL
- en: Since decentralized applications are not supposed to have centralized
  prefs: []
  type: TYPE_NORMAL
- en: owner and management, there is a need to build a community that can
  prefs: []
  type: TYPE_NORMAL
- en: govern the operation and upgrade of decentralized applications. Many
  prefs: []
  type: TYPE_NORMAL
- en: projects build voting mechanisms to decide on project operation and
  prefs: []
  type: TYPE_NORMAL
- en: upgrade. Project team issues governing tokens and distributes them to
  prefs: []
  type: TYPE_NORMAL
- en: community members. The voting power is proportional to the amount of
  prefs: []
  type: TYPE_NORMAL
- en: governing tokens. The community members can earn governing tokens to
  prefs: []
  type: TYPE_NORMAL
- en: increase their voting capacity. When a new feature or upgrade is proposed,
  prefs: []
  type: TYPE_NORMAL
- en: it is sent to a voting system, and each community member can vote to
  prefs: []
  type: TYPE_NORMAL
- en: adopt or reject the proposal. The accepted proposals are implemented by
  prefs: []
  type: TYPE_NORMAL
- en: developers as open source and then deployed to the mainnet.
  prefs: []
  type: TYPE_NORMAL
- en: One major challenge is to upgrade the deployed smart contract if
  prefs: []
  type: TYPE_NORMAL
- en: security vulnerability is found. Since there is no central authority, the
  prefs: []
  type: TYPE_NORMAL
- en: community will need to vote for an upgrade. However, since blockchain is
  prefs: []
  type: TYPE_NORMAL
- en: immutable, the deployed smart contract cannot be patched or upgraded.
  prefs: []
  type: TYPE_NORMAL
- en: '435'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 11 Building team projeCts
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the smart contract will need to be redeployed. When
  prefs: []
  type: TYPE_NORMAL
- en: redeploying a new smart contract, the tokens governed by the old smart
  prefs: []
  type: TYPE_NORMAL
- en: contract will need to be ported to the new smart contract. When the new
  prefs: []
  type: TYPE_NORMAL
- en: smart contract is deployed, all web pages and Web3 interface should point
  prefs: []
  type: TYPE_NORMAL
- en: to the new smart contract address. This is a very tedious and error-prone
  prefs: []
  type: TYPE_NORMAL
- en: process.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, it would be good to write upgradable smart contracts.
  prefs: []
  type: TYPE_NORMAL
- en: This is to separate a smart contract into two or multiple smart contracts.
  prefs: []
  type: TYPE_NORMAL
- en: The first smart contract is an entry smart contract with very simple
  prefs: []
  type: TYPE_NORMAL
- en: functionality such as receiving an address and calling a target smart
  prefs: []
  type: TYPE_NORMAL
- en: contract at that address. The target smart contract is the one with the
  prefs: []
  type: TYPE_NORMAL
- en: majority of functions implemented. If the target smart contract has
  prefs: []
  type: TYPE_NORMAL
- en: security vulnerability and needs to be upgraded, a new target smart
  prefs: []
  type: TYPE_NORMAL
- en: contract can be deployed, and the new address can be sent to the entry
  prefs: []
  type: TYPE_NORMAL
- en: smart contract. When the entry smart contract receives the new target
  prefs: []
  type: TYPE_NORMAL
- en: smart contract address, it will call the new target smart contract. With this
  prefs: []
  type: TYPE_NORMAL
- en: upgradable smart contract design, the web pages and CLI does not need to
  prefs: []
  type: TYPE_NORMAL
- en: be reconfigured as the entry smart contract address does not change.
  prefs: []
  type: TYPE_NORMAL
- en: To optimally operate a decentralized application, it is essential to build
  prefs: []
  type: TYPE_NORMAL
- en: some services to monitor key parameters. For example, the total minted
  prefs: []
  type: TYPE_NORMAL
- en: token should be monitored to ensure that no additional tokens are minted
  prefs: []
  type: TYPE_NORMAL
- en: by hackers. The transaction throughput and gas fees can also be monitored
  prefs: []
  type: TYPE_NORMAL
- en: to ensure that that dApp is in healthy operational state. In addition, the
  prefs: []
  type: TYPE_NORMAL
- en: EVM upgrades and Ethereum hark forks should also be monitored to
  prefs: []
  type: TYPE_NORMAL
- en: ensures there is no negative impacts to the decentralized applications.
  prefs: []
  type: TYPE_NORMAL
- en: And finally, a vibrant community is the key for a successful operation
  prefs: []
  type: TYPE_NORMAL
- en: of decentralized applications. Building a dApp is unseparable from
  prefs: []
  type: TYPE_NORMAL
- en: building a community. Only with active enrollments of community,
  prefs: []
  type: TYPE_NORMAL
- en: decentralized applications can sustain, grow, and survive severe attacks.
  prefs: []
  type: TYPE_NORMAL
- en: '436'
  prefs: []
  type: TYPE_NORMAL
- en: '**Index**'
  prefs: []
  type: TYPE_NORMAL
- en: '**A**'
  prefs: []
  type: TYPE_NORMAL
- en: Atomic value exchanges, 16
  prefs: []
  type: TYPE_NORMAL
- en: Auditors, 329
  prefs: []
  type: TYPE_NORMAL
- en: Abstract class, 295
  prefs: []
  type: TYPE_NORMAL
- en: Authorization through tx.origin,
  prefs: []
  type: TYPE_NORMAL
- en: Address type, 258, 259
  prefs: []
  type: TYPE_NORMAL
- en: 282, 283
  prefs: []
  type: TYPE_NORMAL
- en: Alternate currencies, 37
  prefs: []
  type: TYPE_NORMAL
- en: Automated Market Maker (AMM)
  prefs: []
  type: TYPE_NORMAL
- en: Application Bytecode Interface
  prefs: []
  type: TYPE_NORMAL
- en: mechanism, 224, 386
  prefs: []
  type: TYPE_NORMAL
- en: (ABI), 236, 246, 310
  prefs: []
  type: TYPE_NORMAL
- en: Application design decisions
  prefs: []
  type: TYPE_NORMAL
- en: consensus, 132, 133
  prefs: []
  type: TYPE_NORMAL
- en: '**B**'
  prefs: []
  type: TYPE_NORMAL
- en: data, 130–132
  prefs: []
  type: TYPE_NORMAL
- en: Backward compatible, 412
  prefs: []
  type: TYPE_NORMAL
- en: development stack, 135–138
  prefs: []
  type: TYPE_NORMAL
- en: Beacon chain, 371
  prefs: []
  type: TYPE_NORMAL
- en: smart contracts, 128, 129
  prefs: []
  type: TYPE_NORMAL
- en: Bitcoin, 12, 13, 164, 209
  prefs: []
  type: TYPE_NORMAL
- en: stakeholder
  prefs: []
  type: TYPE_NORMAL
- en: block, 167, 175
  prefs: []
  type: TYPE_NORMAL
- en: organization, 133–135
  prefs: []
  type: TYPE_NORMAL
- en: block header fields, 176
  prefs: []
  type: TYPE_NORMAL
- en: tokens, 124–127
  prefs: []
  type: TYPE_NORMAL
- en: blocks, 177
  prefs: []
  type: TYPE_NORMAL
- en: transactions, 122–124
  prefs: []
  type: TYPE_NORMAL
- en: coinbase transaction, 172
  prefs: []
  type: TYPE_NORMAL
- en: Application themes
  prefs: []
  type: TYPE_NORMAL
- en: components, 167
  prefs: []
  type: TYPE_NORMAL
- en: data sovereignty, 117
  prefs: []
  type: TYPE_NORMAL
- en: consensus mechanism, 184–187
  prefs: []
  type: TYPE_NORMAL
- en: payments, 117
  prefs: []
  type: TYPE_NORMAL
- en: design decision, 181
  prefs: []
  type: TYPE_NORMAL
- en: transparency, 117
  prefs: []
  type: TYPE_NORMAL
- en: distributed ledger software, 169
  prefs: []
  type: TYPE_NORMAL
- en: Arbitration, 224
  prefs: []
  type: TYPE_NORMAL
- en: economics, 182–184
  prefs: []
  type: TYPE_NORMAL
- en: Arithmetic operations, 280, 281,
  prefs: []
  type: TYPE_NORMAL
- en: fields, 174
  prefs: []
  type: TYPE_NORMAL
- en: 370, 400
  prefs: []
  type: TYPE_NORMAL
- en: hash Merkle root of
  prefs: []
  type: TYPE_NORMAL
- en: Assert() function, 279
  prefs: []
  type: TYPE_NORMAL
- en: transactions, 177
  prefs: []
  type: TYPE_NORMAL
- en: Assert violation, 279
  prefs: []
  type: TYPE_NORMAL
- en: inputs and outputs structure, 170
  prefs: []
  type: TYPE_NORMAL
- en: Asset management tools, 221
  prefs: []
  type: TYPE_NORMAL
- en: miners, 166
  prefs: []
  type: TYPE_NORMAL
- en: Asymmetric key cryptography,
  prefs: []
  type: TYPE_NORMAL
- en: mining node, 166
  prefs: []
  type: TYPE_NORMAL
- en: 48, 49, 55
  prefs: []
  type: TYPE_NORMAL
- en: mining reward, 197
  prefs: []
  type: TYPE_NORMAL
- en: © Weijia Zhang and Tej Anand 2022
  prefs: []
  type: TYPE_NORMAL
- en: '437'
  prefs: []
  type: TYPE_NORMAL
- en: W. Zhang and T. Anand, *Blockchain and Ethereum Smart Contract Solution Development*,
  prefs: []
  type: TYPE_NORMAL
- en: '[https://doi.org/10.1007/978-1-4842-8164-2](https://doi.org/10.1007/978-1-4842-8164-2#DOI)'
  prefs: []
  type: TYPE_NORMAL
- en: INDEX
  prefs: []
  type: TYPE_NORMAL
- en: Bitcoin ( *cont.* )
  prefs: []
  type: TYPE_NORMAL
- en: Blockchain application, 139
  prefs: []
  type: TYPE_NORMAL
- en: natural forks, 180
  prefs: []
  type: TYPE_NORMAL
- en: architectural layers, 136
  prefs: []
  type: TYPE_NORMAL
- en: network software
  prefs: []
  type: TYPE_NORMAL
- en: development process, 138
  prefs: []
  type: TYPE_NORMAL
- en: component, 169
  prefs: []
  type: TYPE_NORMAL
- en: success factors, 113, 114
  prefs: []
  type: TYPE_NORMAL
- en: node, 166, 169
  prefs: []
  type: TYPE_NORMAL
- en: Blockchain-based solutions, 120, 157
  prefs: []
  type: TYPE_NORMAL
- en: permissionless public
  prefs: []
  type: TYPE_NORMAL
- en: Blockchain-based systems
  prefs: []
  type: TYPE_NORMAL
- en: blockchain, 197
  prefs: []
  type: TYPE_NORMAL
- en: solution, 119
  prefs: []
  type: TYPE_NORMAL
- en: proof-of-work consensus
  prefs: []
  type: TYPE_NORMAL
- en: Blockchain Ethereum Classic
  prefs: []
  type: TYPE_NORMAL
- en: mechanism, 197
  prefs: []
  type: TYPE_NORMAL
- en: (ETC), 405
  prefs: []
  type: TYPE_NORMAL
- en: script, 175
  prefs: []
  type: TYPE_NORMAL
- en: Block header, 175
  prefs: []
  type: TYPE_NORMAL
- en: smart contracts, 197
  prefs: []
  type: TYPE_NORMAL
- en: Bob’s ping function, 280
  prefs: []
  type: TYPE_NORMAL
- en: transaction data structure, 170
  prefs: []
  type: TYPE_NORMAL
- en: Boolean, 255, 256
  prefs: []
  type: TYPE_NORMAL
- en: transaction life cycle, 165
  prefs: []
  type: TYPE_NORMAL
- en: Borrow cryptocurrency, 386
  prefs: []
  type: TYPE_NORMAL
- en: transactions, 167, 176
  prefs: []
  type: TYPE_NORMAL
- en: Browser client, 307
  prefs: []
  type: TYPE_NORMAL
- en: values in notional
  prefs: []
  type: TYPE_NORMAL
- en: Brute-force search process, 74
  prefs: []
  type: TYPE_NORMAL
- en: transaction, 171
  prefs: []
  type: TYPE_NORMAL
- en: Burnability, 393
  prefs: []
  type: TYPE_NORMAL
- en: wallet software component, 168
  prefs: []
  type: TYPE_NORMAL
- en: Business problems, 116, 119, 121
  prefs: []
  type: TYPE_NORMAL
- en: Bitcoin improvement proposals
  prefs: []
  type: TYPE_NORMAL
- en: Business process, 115
  prefs: []
  type: TYPE_NORMAL
- en: (BIP), 196
  prefs: []
  type: TYPE_NORMAL
- en: Business-to-business exchanges, 20
  prefs: []
  type: TYPE_NORMAL
- en: Blockchain, 168, 407, 408
  prefs: []
  type: TYPE_NORMAL
- en: Business use cases, 117
  prefs: []
  type: TYPE_NORMAL
- en: community, 406
  prefs: []
  type: TYPE_NORMAL
- en: Byte array, 259, 260
  prefs: []
  type: TYPE_NORMAL
- en: consensus, 84
  prefs: []
  type: TYPE_NORMAL
- en: Bytecodes, 305
  prefs: []
  type: TYPE_NORMAL
- en: distributed ledger, 84
  prefs: []
  type: TYPE_NORMAL
- en: 32-Byte Crosschain ID, 410
  prefs: []
  type: TYPE_NORMAL
- en: implementation
  prefs: []
  type: TYPE_NORMAL
- en: Byzantine Fault Tolerance (BFT)
  prefs: []
  type: TYPE_NORMAL
- en: categorization, 95–99
  prefs: []
  type: TYPE_NORMAL
- en: blockchain, 61, 72, 102, 214,
  prefs: []
  type: TYPE_NORMAL
- en: limitations, 102–106
  prefs: []
  type: TYPE_NORMAL
- en: 343, 346, 350
  prefs: []
  type: TYPE_NORMAL
- en: POW, 213
  prefs: []
  type: TYPE_NORMAL
- en: privacy, 87
  prefs: []
  type: TYPE_NORMAL
- en: provenance, 87
  prefs: []
  type: TYPE_NORMAL
- en: '**C**'
  prefs: []
  type: TYPE_NORMAL
- en: purist perspective, 99
  prefs: []
  type: TYPE_NORMAL
- en: CAP theorem, 66, 67, 75
  prefs: []
  type: TYPE_NORMAL
- en: smart contracts ( *see* Smart
  prefs: []
  type: TYPE_NORMAL
- en: CAP theorem–related design
  prefs: []
  type: TYPE_NORMAL
- en: contracts)
  prefs: []
  type: TYPE_NORMAL
- en: trade-offs, 73
  prefs: []
  type: TYPE_NORMAL
- en: specific variables, 268–270
  prefs: []
  type: TYPE_NORMAL
- en: Carbon credit market, 389
  prefs: []
  type: TYPE_NORMAL
- en: technology integration, 71–74
  prefs: []
  type: TYPE_NORMAL
- en: Carbon credit token, 390
  prefs: []
  type: TYPE_NORMAL
- en: '438'
  prefs: []
  type: TYPE_NORMAL
- en: INDEX
  prefs: []
  type: TYPE_NORMAL
- en: Central bank digital currency
  prefs: []
  type: TYPE_NORMAL
- en: Consensus mechanism, 82, 84, 85,
  prefs: []
  type: TYPE_NORMAL
- en: (CBDC), 143, 209, 379
  prefs: []
  type: TYPE_NORMAL
- en: 164, 184–187
  prefs: []
  type: TYPE_NORMAL
- en: Centralized ledger, 88, 89
  prefs: []
  type: TYPE_NORMAL
- en: ConsenSys package, 382
  prefs: []
  type: TYPE_NORMAL
- en: Centralized ownership, 69
  prefs: []
  type: TYPE_NORMAL
- en: Consistency, 72
  prefs: []
  type: TYPE_NORMAL
- en: Chainlink, 225
  prefs: []
  type: TYPE_NORMAL
- en: Consortium-based
  prefs: []
  type: TYPE_NORMAL
- en: ChallengeWithdraw function, 349
  prefs: []
  type: TYPE_NORMAL
- en: networks, 134
  prefs: []
  type: TYPE_NORMAL
- en: checkMerkleTree function, 353,
  prefs: []
  type: TYPE_NORMAL
- en: Constraints, 140
  prefs: []
  type: TYPE_NORMAL
- en: 355, 357
  prefs: []
  type: TYPE_NORMAL
- en: Constructor function, 252
  prefs: []
  type: TYPE_NORMAL
- en: checkNotEqual() function, 300
  prefs: []
  type: TYPE_NORMAL
- en: Contract accounts, 190
  prefs: []
  type: TYPE_NORMAL
- en: CLI clients, 308
  prefs: []
  type: TYPE_NORMAL
- en: Contract Bob, 280
  prefs: []
  type: TYPE_NORMAL
- en: Client computers, 68
  prefs: []
  type: TYPE_NORMAL
- en: Core blockchain layer, 213
  prefs: []
  type: TYPE_NORMAL
- en: Client nodes, 212, 372
  prefs: []
  type: TYPE_NORMAL
- en: Core capabilities of blockchain, 43
  prefs: []
  type: TYPE_NORMAL
- en: Coding events, 273
  prefs: []
  type: TYPE_NORMAL
- en: Cross-chain contract, 279
  prefs: []
  type: TYPE_NORMAL
- en: Coinbase transaction, 172, 219,
  prefs: []
  type: TYPE_NORMAL
- en: Crosschain ID, 407, 412, 413
  prefs: []
  type: TYPE_NORMAL
- en: 223, 230
  prefs: []
  type: TYPE_NORMAL
- en: Crosschain identifier
  prefs: []
  type: TYPE_NORMAL
- en: Command-line interface (CLI),
  prefs: []
  type: TYPE_NORMAL
- en: registration and lookup
  prefs: []
  type: TYPE_NORMAL
- en: 306, 308, 423
  prefs: []
  type: TYPE_NORMAL
- en: service, 408
  prefs: []
  type: TYPE_NORMAL
- en: Community-based blockchain
  prefs: []
  type: TYPE_NORMAL
- en: requirements, 409
  prefs: []
  type: TYPE_NORMAL
- en: networks, 135
  prefs: []
  type: TYPE_NORMAL
- en: Crosschain identity service, 413
  prefs: []
  type: TYPE_NORMAL
- en: Community Telegram chat
  prefs: []
  type: TYPE_NORMAL
- en: Crosschain ID registration, 431
  prefs: []
  type: TYPE_NORMAL
- en: group, 325
  prefs: []
  type: TYPE_NORMAL
- en: Crosschain ID smart contract, 418
  prefs: []
  type: TYPE_NORMAL
- en: Compilation tools, 217
  prefs: []
  type: TYPE_NORMAL
- en: Crosschain Interoperability Task
  prefs: []
  type: TYPE_NORMAL
- en: Complexity of blockchain
  prefs: []
  type: TYPE_NORMAL
- en: Force (CITF), 408
  prefs: []
  type: TYPE_NORMAL
- en: security, 319
  prefs: []
  type: TYPE_NORMAL
- en: Crosschain operations, 412
  prefs: []
  type: TYPE_NORMAL
- en: constraints of patches and
  prefs: []
  type: TYPE_NORMAL
- en: Cryptanalysis, 46
  prefs: []
  type: TYPE_NORMAL
- en: upgradability, 320
  prefs: []
  type: TYPE_NORMAL
- en: Cryptocurrencies, 227, 390
  prefs: []
  type: TYPE_NORMAL
- en: decentralized nature of
  prefs: []
  type: TYPE_NORMAL
- en: Crypto exchanges, 223
  prefs: []
  type: TYPE_NORMAL
- en: blockchain, 320
  prefs: []
  type: TYPE_NORMAL
- en: Cryptographic keys, 90
  prefs: []
  type: TYPE_NORMAL
- en: high value impact on
  prefs: []
  type: TYPE_NORMAL
- en: Cryptography, 44, 46, 164
  prefs: []
  type: TYPE_NORMAL
- en: business, 321
  prefs: []
  type: TYPE_NORMAL
- en: CryptoKitty, 322, 326, 333
  prefs: []
  type: TYPE_NORMAL
- en: privacy and anonymous nature
  prefs: []
  type: TYPE_NORMAL
- en: Cryptology
  prefs: []
  type: TYPE_NORMAL
- en: of blockchain, 320
  prefs: []
  type: TYPE_NORMAL
- en: asymmetric/public/private key
  prefs: []
  type: TYPE_NORMAL
- en: trustless and permissionless
  prefs: []
  type: TYPE_NORMAL
- en: cryptography, 49
  prefs: []
  type: TYPE_NORMAL
- en: environment, 320
  prefs: []
  type: TYPE_NORMAL
- en: cryptanalysis, 46
  prefs: []
  type: TYPE_NORMAL
- en: '439'
  prefs: []
  type: TYPE_NORMAL
- en: INDEX
  prefs: []
  type: TYPE_NORMAL
- en: Cryptology ( *cont.* )
  prefs: []
  type: TYPE_NORMAL
- en: Decentralized Autonomous
  prefs: []
  type: TYPE_NORMAL
- en: cryptography, 46
  prefs: []
  type: TYPE_NORMAL
- en: Organization (DAO), 129,
  prefs: []
  type: TYPE_NORMAL
- en: encryption-decryption
  prefs: []
  type: TYPE_NORMAL
- en: 142, 209, 226, 379
  prefs: []
  type: TYPE_NORMAL
- en: process, 45
  prefs: []
  type: TYPE_NORMAL
- en: Decentralized exchange (DEX),
  prefs: []
  type: TYPE_NORMAL
- en: high-level encryption-
  prefs: []
  type: TYPE_NORMAL
- en: 223, 224, 386
  prefs: []
  type: TYPE_NORMAL
- en: decryption process, 45
  prefs: []
  type: TYPE_NORMAL
- en: Decentralized Insurance
  prefs: []
  type: TYPE_NORMAL
- en: states of data, 55, 56
  prefs: []
  type: TYPE_NORMAL
- en: Platform, 226
  prefs: []
  type: TYPE_NORMAL
- en: strong asymmetric key
  prefs: []
  type: TYPE_NORMAL
- en: Decentralized Finance project
  prefs: []
  type: TYPE_NORMAL
- en: algorithms, 50
  prefs: []
  type: TYPE_NORMAL
- en: (DeFi), 141, 209, 222,
  prefs: []
  type: TYPE_NORMAL
- en: strong symmetric key
  prefs: []
  type: TYPE_NORMAL
- en: 386, 387
  prefs: []
  type: TYPE_NORMAL
- en: algorithms, 48
  prefs: []
  type: TYPE_NORMAL
- en: Delegated proof of stake, 185, 186
  prefs: []
  type: TYPE_NORMAL
- en: Deployment, 433
  prefs: []
  type: TYPE_NORMAL
- en: DepositEvent class, 274
  prefs: []
  type: TYPE_NORMAL
- en: '**D**'
  prefs: []
  type: TYPE_NORMAL
- en: Design trade-offs, 104, 121
  prefs: []
  type: TYPE_NORMAL
- en: Daily transactions, 344
  prefs: []
  type: TYPE_NORMAL
- en: Desktop clients, 308
  prefs: []
  type: TYPE_NORMAL
- en: dApp clients
  prefs: []
  type: TYPE_NORMAL
- en: Development blockchain, 228
  prefs: []
  type: TYPE_NORMAL
- en: browser client, 307
  prefs: []
  type: TYPE_NORMAL
- en: Development stack, 135–138
  prefs: []
  type: TYPE_NORMAL
- en: CLI clients, 308
  prefs: []
  type: TYPE_NORMAL
- en: Digital signatures, 44
  prefs: []
  type: TYPE_NORMAL
- en: CLI format, 306
  prefs: []
  type: TYPE_NORMAL
- en: fool-proof guarantee, 51
  prefs: []
  type: TYPE_NORMAL
- en: desktop client, 308
  prefs: []
  type: TYPE_NORMAL
- en: hashing, 51, 55
  prefs: []
  type: TYPE_NORMAL
- en: GUI format, 306
  prefs: []
  type: TYPE_NORMAL
- en: limitation, 51
  prefs: []
  type: TYPE_NORMAL
- en: mobile client, 307
  prefs: []
  type: TYPE_NORMAL
- en: one-way functions, 52
  prefs: []
  type: TYPE_NORMAL
- en: Data at rest, 55
  prefs: []
  type: TYPE_NORMAL
- en: process, 50
  prefs: []
  type: TYPE_NORMAL
- en: Data in transit, 55
  prefs: []
  type: TYPE_NORMAL
- en: Distributed applications (dApps),
  prefs: []
  type: TYPE_NORMAL
- en: Data in use, 56
  prefs: []
  type: TYPE_NORMAL
- en: 2, 125, 188, 191, 193, 196,
  prefs: []
  type: TYPE_NORMAL
- en: Data-related inefficiencies, 25–27
  prefs: []
  type: TYPE_NORMAL
- en: 197, 201
  prefs: []
  type: TYPE_NORMAL
- en: Data security risks, 30, 31
  prefs: []
  type: TYPE_NORMAL
- en: Distributed ledger, 32, 82, 84, 164
  prefs: []
  type: TYPE_NORMAL
- en: Data sharing, 5
  prefs: []
  type: TYPE_NORMAL
- en: block, 85
  prefs: []
  type: TYPE_NORMAL
- en: Data storage location, 284
  prefs: []
  type: TYPE_NORMAL
- en: databases and blockchain, 94
  prefs: []
  type: TYPE_NORMAL
- en: Data structures, 415
  prefs: []
  type: TYPE_NORMAL
- en: implementation, 94
  prefs: []
  type: TYPE_NORMAL
- en: data type, 255
  prefs: []
  type: TYPE_NORMAL
- en: peer nodes, 91–94
  prefs: []
  type: TYPE_NORMAL
- en: Decentralization, 4
  prefs: []
  type: TYPE_NORMAL
- en: privacy-preserving, 90, 94
  prefs: []
  type: TYPE_NORMAL
- en: Decentralized applications,
  prefs: []
  type: TYPE_NORMAL
- en: rules, 90
  prefs: []
  type: TYPE_NORMAL
- en: 435, 436
  prefs: []
  type: TYPE_NORMAL
- en: transactions, 93
  prefs: []
  type: TYPE_NORMAL
- en: '440'
  prefs: []
  type: TYPE_NORMAL
- en: INDEX
  prefs: []
  type: TYPE_NORMAL
- en: Distributed systems, 44, 164
  prefs: []
  type: TYPE_NORMAL
- en: sources, 23
  prefs: []
  type: TYPE_NORMAL
- en: CAP theorem, 66
  prefs: []
  type: TYPE_NORMAL
- en: time to settle transactions, 23
  prefs: []
  type: TYPE_NORMAL
- en: definition, 56
  prefs: []
  type: TYPE_NORMAL
- en: Economics, Bitcoin, 182–184
  prefs: []
  type: TYPE_NORMAL
- en: high availability, strong
  prefs: []
  type: TYPE_NORMAL
- en: Emitted event, 272–274
  prefs: []
  type: TYPE_NORMAL
- en: consistency, and network
  prefs: []
  type: TYPE_NORMAL
- en: Encryption-decryption process, 45
  prefs: []
  type: TYPE_NORMAL
- en: partition tolerance, 67
  prefs: []
  type: TYPE_NORMAL
- en: Energy consumption, 102
  prefs: []
  type: TYPE_NORMAL
- en: issues, goals, and
  prefs: []
  type: TYPE_NORMAL
- en: Enterprise businesses, 98
  prefs: []
  type: TYPE_NORMAL
- en: approaches, 65
  prefs: []
  type: TYPE_NORMAL
- en: Enterprise Ethereum Alliance
  prefs: []
  type: TYPE_NORMAL
- en: real-world issue
  prefs: []
  type: TYPE_NORMAL
- en: (EEA), 139, 211, 215,
  prefs: []
  type: TYPE_NORMAL
- en: complexity, 57, 58
  prefs: []
  type: TYPE_NORMAL
- en: 390, 408
  prefs: []
  type: TYPE_NORMAL
- en: consistency, 61–65
  prefs: []
  type: TYPE_NORMAL
- en: Entertainment
  prefs: []
  type: TYPE_NORMAL
- en: failures, 58–61
  prefs: []
  type: TYPE_NORMAL
- en: applications, 155–157
  prefs: []
  type: TYPE_NORMAL
- en: scalability, 58
  prefs: []
  type: TYPE_NORMAL
- en: Enum, 264, 265
  prefs: []
  type: TYPE_NORMAL
- en: views, 57
  prefs: []
  type: TYPE_NORMAL
- en: ERC20 specification, 380
  prefs: []
  type: TYPE_NORMAL
- en: Domain name servers (DNS), 68
  prefs: []
  type: TYPE_NORMAL
- en: ERC20 tokens, 380, 382, 383
  prefs: []
  type: TYPE_NORMAL
- en: Drizzle, 192
  prefs: []
  type: TYPE_NORMAL
- en: ERC721 NFT token, 361
  prefs: []
  type: TYPE_NORMAL
- en: Dynamically size array, 262, 263
  prefs: []
  type: TYPE_NORMAL
- en: ERP software, 4
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum, 99, 379, 380, 405
  prefs: []
  type: TYPE_NORMAL
- en: '**E**'
  prefs: []
  type: TYPE_NORMAL
- en: achievements, 191
  prefs: []
  type: TYPE_NORMAL
- en: Bitcoin UTXOs, 188
  prefs: []
  type: TYPE_NORMAL
- en: Economic exchange, 15
  prefs: []
  type: TYPE_NORMAL
- en: blockchain, 196
  prefs: []
  type: TYPE_NORMAL
- en: Economic inefficiencies
  prefs: []
  type: TYPE_NORMAL
- en: boot nodes, 212
  prefs: []
  type: TYPE_NORMAL
- en: Blockchain’s potential to
  prefs: []
  type: TYPE_NORMAL
- en: client nodes, 212
  prefs: []
  type: TYPE_NORMAL
- en: address, 31, 32
  prefs: []
  type: TYPE_NORMAL
- en: contract accounts, 190
  prefs: []
  type: TYPE_NORMAL
- en: data-related
  prefs: []
  type: TYPE_NORMAL
- en: dApp architecture and
  prefs: []
  type: TYPE_NORMAL
- en: inefficiencies, 25–27
  prefs: []
  type: TYPE_NORMAL
- en: development tools, 192
  prefs: []
  type: TYPE_NORMAL
- en: data security risks, 30, 31
  prefs: []
  type: TYPE_NORMAL
- en: distributed applications
  prefs: []
  type: TYPE_NORMAL
- en: fees to third parties, 24
  prefs: []
  type: TYPE_NORMAL
- en: creation, 191
  prefs: []
  type: TYPE_NORMAL
- en: fraud, 29
  prefs: []
  type: TYPE_NORMAL
- en: Ether denominations, 190
  prefs: []
  type: TYPE_NORMAL
- en: potential of blockchain
  prefs: []
  type: TYPE_NORMAL
- en: externally owned accounts, 190
  prefs: []
  type: TYPE_NORMAL
- en: capability, 33, 34
  prefs: []
  type: TYPE_NORMAL
- en: permissionless public
  prefs: []
  type: TYPE_NORMAL
- en: privacy trade-offs, 29
  prefs: []
  type: TYPE_NORMAL
- en: blockchain, 212
  prefs: []
  type: TYPE_NORMAL
- en: regulations and rules
  prefs: []
  type: TYPE_NORMAL
- en: risks, 189
  prefs: []
  type: TYPE_NORMAL
- en: constraints, 28, 29
  prefs: []
  type: TYPE_NORMAL
- en: SC, 343–347
  prefs: []
  type: TYPE_NORMAL
- en: '441'
  prefs: []
  type: TYPE_NORMAL
- en: INDEX
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum ( *cont.* )
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum blockchain platform, 210
  prefs: []
  type: TYPE_NORMAL
- en: scalability and security, 199
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum blockchains, 334, 406
  prefs: []
  type: TYPE_NORMAL
- en: Solidity, 188
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum-compatible
  prefs: []
  type: TYPE_NORMAL
- en: transactions, 189
  prefs: []
  type: TYPE_NORMAL
- en: blockchains, 214
  prefs: []
  type: TYPE_NORMAL
- en: transactions types, 190
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum ecosystem projects, 387
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum 1.5, 370
  prefs: []
  type: TYPE_NORMAL
- en: DAO, 226
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum 2, 213, 338
  prefs: []
  type: TYPE_NORMAL
- en: decentralized exchange (DEX),
  prefs: []
  type: TYPE_NORMAL
- en: architecture, 371–374
  prefs: []
  type: TYPE_NORMAL
- en: 223, 224
  prefs: []
  type: TYPE_NORMAL
- en: beacon chain, 371
  prefs: []
  type: TYPE_NORMAL
- en: Decentralized Insurance
  prefs: []
  type: TYPE_NORMAL
- en: migration from Ethereum 1,
  prefs: []
  type: TYPE_NORMAL
- en: Platform, 226
  prefs: []
  type: TYPE_NORMAL
- en: 374–376
  prefs: []
  type: TYPE_NORMAL
- en: Fortmatic, 221
  prefs: []
  type: TYPE_NORMAL
- en: mining node, 376
  prefs: []
  type: TYPE_NORMAL
- en: hosted service, 219
  prefs: []
  type: TYPE_NORMAL
- en: POW to POS, 371
  prefs: []
  type: TYPE_NORMAL
- en: KYC and Identity, 227
  prefs: []
  type: TYPE_NORMAL
- en: running a validator nodes,
  prefs: []
  type: TYPE_NORMAL
- en: MetaMask, 219, 220
  prefs: []
  type: TYPE_NORMAL
- en: 376, 377
  prefs: []
  type: TYPE_NORMAL
- en: MyEtherWallet (MEW), 220, 221
  prefs: []
  type: TYPE_NORMAL
- en: sharding, 371
  prefs: []
  type: TYPE_NORMAL
- en: NFT application, 224, 225
  prefs: []
  type: TYPE_NORMAL
- en: uncertainties, 378
  prefs: []
  type: TYPE_NORMAL
- en: Oracle service, 225, 226
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum blockchain, 209, 212,
  prefs: []
  type: TYPE_NORMAL
- en: smart contract–enabled
  prefs: []
  type: TYPE_NORMAL
- en: 228, 246, 269, 335, 395, 396,
  prefs: []
  type: TYPE_NORMAL
- en: banking dApp, 222, 223
  prefs: []
  type: TYPE_NORMAL
- en: 398, 403, 405, 406
  prefs: []
  type: TYPE_NORMAL
- en: Stablecoin, 227
  prefs: []
  type: TYPE_NORMAL
- en: advantages, 209
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum EVM storage data, 284
  prefs: []
  type: TYPE_NORMAL
- en: and infrastructure, 209
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum gas fee, 215
  prefs: []
  type: TYPE_NORMAL
- en: security ( *see* Security)
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum gas mechanism, 398
  prefs: []
  type: TYPE_NORMAL
- en: smart contracts, 319
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum improvement proposal
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum blockchain architecture
  prefs: []
  type: TYPE_NORMAL
- en: (EIP), 196, 408
  prefs: []
  type: TYPE_NORMAL
- en: application layer, 217, 218
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum.js retrieves, 428
  prefs: []
  type: TYPE_NORMAL
- en: components architecture and
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum mainnet (ETH), 341, 342,
  prefs: []
  type: TYPE_NORMAL
- en: overview, 211
  prefs: []
  type: TYPE_NORMAL
- en: 347, 364, 405
  prefs: []
  type: TYPE_NORMAL
- en: core blockchain layer, 213–215
  prefs: []
  type: TYPE_NORMAL
- en: EIP-155, 406, 407
  prefs: []
  type: TYPE_NORMAL
- en: Enterprise components layer,
  prefs: []
  type: TYPE_NORMAL
- en: and ETC, 406
  prefs: []
  type: TYPE_NORMAL
- en: 215, 216
  prefs: []
  type: TYPE_NORMAL
- en: and Ethereum Classic, 405
  prefs: []
  type: TYPE_NORMAL
- en: layers, 211, 218
  prefs: []
  type: TYPE_NORMAL
- en: plasma smart contract, 348, 349
  prefs: []
  type: TYPE_NORMAL
- en: network layer, 212, 213
  prefs: []
  type: TYPE_NORMAL
- en: transactions, 398
  prefs: []
  type: TYPE_NORMAL
- en: tooling layer, 216, 217
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum network, 212
  prefs: []
  type: TYPE_NORMAL
- en: '442'
  prefs: []
  type: TYPE_NORMAL
- en: INDEX
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum public blockchain, 215,
  prefs: []
  type: TYPE_NORMAL
- en: Financial services industry
  prefs: []
  type: TYPE_NORMAL
- en: 216, 231
  prefs: []
  type: TYPE_NORMAL
- en: blockchain solutions, 143
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum smart contract
  prefs: []
  type: TYPE_NORMAL
- en: capabilities, 140
  prefs: []
  type: TYPE_NORMAL
- en: development, 210
  prefs: []
  type: TYPE_NORMAL
- en: CBDC, 143
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum testnet, 431
  prefs: []
  type: TYPE_NORMAL
- en: crypto exchanges, 143
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum tools for smart contract
  prefs: []
  type: TYPE_NORMAL
- en: DeFi, 141
  prefs: []
  type: TYPE_NORMAL
- en: development
  prefs: []
  type: TYPE_NORMAL
- en: economic inefficiencies, 140
  prefs: []
  type: TYPE_NORMAL
- en: Etherscan, 231
  prefs: []
  type: TYPE_NORMAL
- en: quintessential third party, 140
  prefs: []
  type: TYPE_NORMAL
- en: Geth, 231–234
  prefs: []
  type: TYPE_NORMAL
- en: redundant work/rework/
  prefs: []
  type: TYPE_NORMAL
- en: MetaMask, 229–231
  prefs: []
  type: TYPE_NORMAL
- en: reconciliation work, 141
  prefs: []
  type: TYPE_NORMAL
- en: Remix, 238–243
  prefs: []
  type: TYPE_NORMAL
- en: themes, 141
  prefs: []
  type: TYPE_NORMAL
- en: tools and components, 228
  prefs: []
  type: TYPE_NORMAL
- en: Fixed size array, 261, 262
  prefs: []
  type: TYPE_NORMAL
- en: Truffle, 235–238
  prefs: []
  type: TYPE_NORMAL
- en: Fortmatic, 221
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum virtual machine (EVM),
  prefs: []
  type: TYPE_NORMAL
- en: Founder-directed network, 134
  prefs: []
  type: TYPE_NORMAL
- en: 191, 209, 214, 215, 241, 242,
  prefs: []
  type: TYPE_NORMAL
- en: Frequent flier points, 37
  prefs: []
  type: TYPE_NORMAL
- en: 245–247, 335, 371
  prefs: []
  type: TYPE_NORMAL
- en: Function
  prefs: []
  type: TYPE_NORMAL
- en: Etherscan, 231
  prefs: []
  type: TYPE_NORMAL
- en: crosschain ID, 416
  prefs: []
  type: TYPE_NORMAL
- en: Ether withdraw operation not
  prefs: []
  type: TYPE_NORMAL
- en: getChainIdFromLegacyId, 416
  prefs: []
  type: TYPE_NORMAL
- en: protected, 276
  prefs: []
  type: TYPE_NORMAL
- en: getChainIdInfo, 416
  prefs: []
  type: TYPE_NORMAL
- en: Events
  prefs: []
  type: TYPE_NORMAL
- en: getChainIdStatus, 416
  prefs: []
  type: TYPE_NORMAL
- en: defining, 271, 272
  prefs: []
  type: TYPE_NORMAL
- en: revoked, 416
  prefs: []
  type: TYPE_NORMAL
- en: emitted, 272–274
  prefs: []
  type: TYPE_NORMAL
- en: smart contract, 416
  prefs: []
  type: TYPE_NORMAL
- en: inheritable member, 271
  prefs: []
  type: TYPE_NORMAL
- en: Function access scopes, 254
  prefs: []
  type: TYPE_NORMAL
- en: storing location, 271
  prefs: []
  type: TYPE_NORMAL
- en: Functional security holes, 321
  prefs: []
  type: TYPE_NORMAL
- en: Exchange of money, 7
  prefs: []
  type: TYPE_NORMAL
- en: Functional security holes, smart
  prefs: []
  type: TYPE_NORMAL
- en: Exchange rate, 8
  prefs: []
  type: TYPE_NORMAL
- en: contracts
  prefs: []
  type: TYPE_NORMAL
- en: Exchange transactions, 9, 16
  prefs: []
  type: TYPE_NORMAL
- en: disabled smart contract, 323
  prefs: []
  type: TYPE_NORMAL
- en: Externally owned accounts, 190
  prefs: []
  type: TYPE_NORMAL
- en: fund deadlock, 321
  prefs: []
  type: TYPE_NORMAL
- en: fund leakage, 322
  prefs: []
  type: TYPE_NORMAL
- en: '**F**'
  prefs: []
  type: TYPE_NORMAL
- en: Orphan smart contract, 323
  prefs: []
  type: TYPE_NORMAL
- en: Function call value is not
  prefs: []
  type: TYPE_NORMAL
- en: Fault tolerance, 59, 72
  prefs: []
  type: TYPE_NORMAL
- en: checked, 276
  prefs: []
  type: TYPE_NORMAL
- en: Fault-tolerant distributed system, 60
  prefs: []
  type: TYPE_NORMAL
- en: Function modifier, 252
  prefs: []
  type: TYPE_NORMAL
- en: Filecoin project, 394
  prefs: []
  type: TYPE_NORMAL
- en: Function-specific variables, 281
  prefs: []
  type: TYPE_NORMAL
- en: '443'
  prefs: []
  type: TYPE_NORMAL
- en: INDEX
  prefs: []
  type: TYPE_NORMAL
- en: Function visibility error, 274, 275
  prefs: []
  type: TYPE_NORMAL
- en: provider credentialing, 150
  prefs: []
  type: TYPE_NORMAL
- en: Fungible tokens, 127
  prefs: []
  type: TYPE_NORMAL
- en: service cost, 145
  prefs: []
  type: TYPE_NORMAL
- en: stakeholders, 147
  prefs: []
  type: TYPE_NORMAL
- en: '**G**'
  prefs: []
  type: TYPE_NORMAL
- en: third-party
  prefs: []
  type: TYPE_NORMAL
- en: administrators, 145–147
  prefs: []
  type: TYPE_NORMAL
- en: Ganache tool, 228
  prefs: []
  type: TYPE_NORMAL
- en: Hyperledger, 97
  prefs: []
  type: TYPE_NORMAL
- en: Gas cost, 402
  prefs: []
  type: TYPE_NORMAL
- en: blockchain
  prefs: []
  type: TYPE_NORMAL
- en: Gas fee consideration
  prefs: []
  type: TYPE_NORMAL
- en: implementation, 193
  prefs: []
  type: TYPE_NORMAL
- en: ecosystems, 396
  prefs: []
  type: TYPE_NORMAL
- en: ecosystem, 195
  prefs: []
  type: TYPE_NORMAL
- en: gas consumption, 395
  prefs: []
  type: TYPE_NORMAL
- en: frameworks and tools, 193, 195
  prefs: []
  type: TYPE_NORMAL
- en: quantitative calculation, 403
  prefs: []
  type: TYPE_NORMAL
- en: governance model, 193, 196
  prefs: []
  type: TYPE_NORMAL
- en: Gas station, 397
  prefs: []
  type: TYPE_NORMAL
- en: Hyperledger Fabric, 97
  prefs: []
  type: TYPE_NORMAL
- en: Geth, 231–234
  prefs: []
  type: TYPE_NORMAL
- en: Geth client, 372
  prefs: []
  type: TYPE_NORMAL
- en: getMessage function, 317
  prefs: []
  type: TYPE_NORMAL
- en: '**I**'
  prefs: []
  type: TYPE_NORMAL
- en: Gift cards, 38
  prefs: []
  type: TYPE_NORMAL
- en: Indirect costs, 31
  prefs: []
  type: TYPE_NORMAL
- en: GitHub location, 352
  prefs: []
  type: TYPE_NORMAL
- en: Information exchange, 5
  prefs: []
  type: TYPE_NORMAL
- en: GitHub storage, 241
  prefs: []
  type: TYPE_NORMAL
- en: Information technology (IT),
  prefs: []
  type: TYPE_NORMAL
- en: 3, 30, 147
  prefs: []
  type: TYPE_NORMAL
- en: '**H**'
  prefs: []
  type: TYPE_NORMAL
- en: Institute for Applied Network
  prefs: []
  type: TYPE_NORMAL
- en: Security (IANS), 30
  prefs: []
  type: TYPE_NORMAL
- en: Halting program operations, 401
  prefs: []
  type: TYPE_NORMAL
- en: Integer, 256–258
  prefs: []
  type: TYPE_NORMAL
- en: Hashed digital signatures, 54
  prefs: []
  type: TYPE_NORMAL
- en: Integrated development
  prefs: []
  type: TYPE_NORMAL
- en: Hashing algorithms, 51–53
  prefs: []
  type: TYPE_NORMAL
- en: environment (IDE), 240, 247
  prefs: []
  type: TYPE_NORMAL
- en: hashMerkleRoot field, 177
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces, 296
  prefs: []
  type: TYPE_NORMAL
- en: Healthcare applications
  prefs: []
  type: TYPE_NORMAL
- en: Internal functions, 254
  prefs: []
  type: TYPE_NORMAL
- en: advocacy organizations, 147
  prefs: []
  type: TYPE_NORMAL
- en: Internet, 4
  prefs: []
  type: TYPE_NORMAL
- en: claims processing, 150
  prefs: []
  type: TYPE_NORMAL
- en: InterWork Alliance (IWA), 125, 390
  prefs: []
  type: TYPE_NORMAL
- en: clinical trials, 152
  prefs: []
  type: TYPE_NORMAL
- en: consumers interact with clinical
  prefs: []
  type: TYPE_NORMAL
- en: providers, 145
  prefs: []
  type: TYPE_NORMAL
- en: '**J**'
  prefs: []
  type: TYPE_NORMAL
- en: economic inefficiencies,
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript console, 232, 234
  prefs: []
  type: TYPE_NORMAL
- en: 148, 149
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript files, 427
  prefs: []
  type: TYPE_NORMAL
- en: healthcare supply chain, 151
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript scripts, 307
  prefs: []
  type: TYPE_NORMAL
- en: '444'
  prefs: []
  type: TYPE_NORMAL
- en: INDEX
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript VM, 242
  prefs: []
  type: TYPE_NORMAL
- en: leaf nodes, 351
  prefs: []
  type: TYPE_NORMAL
- en: JSON RPC, 217
  prefs: []
  type: TYPE_NORMAL
- en: MerkleDemo smart
  prefs: []
  type: TYPE_NORMAL
- en: contract, 353
  prefs: []
  type: TYPE_NORMAL
- en: '**K**'
  prefs: []
  type: TYPE_NORMAL
- en: Plasma Cash, 360–363
  prefs: []
  type: TYPE_NORMAL
- en: plasma MVP, 357–359
  prefs: []
  type: TYPE_NORMAL
- en: Know Your Customers (KYC), 227
  prefs: []
  type: TYPE_NORMAL
- en: source code, 352
  prefs: []
  type: TYPE_NORMAL
- en: testcasedemo function, 355, 357
  prefs: []
  type: TYPE_NORMAL
- en: '**L**'
  prefs: []
  type: TYPE_NORMAL
- en: MetaMask wallet, 193, 216, 217,
  prefs: []
  type: TYPE_NORMAL
- en: 219, 220, 229–231, 233, 242,
  prefs: []
  type: TYPE_NORMAL
- en: Layer 2
  prefs: []
  type: TYPE_NORMAL
- en: 243, 307, 316, 346, 425, 433
  prefs: []
  type: TYPE_NORMAL
- en: mechanisms, 343
  prefs: []
  type: TYPE_NORMAL
- en: Migration from Ethereum 1 to
  prefs: []
  type: TYPE_NORMAL
- en: performance and scalability, 343
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum 2, 374–376
  prefs: []
  type: TYPE_NORMAL
- en: plasma ( *see* Plasma)
  prefs: []
  type: TYPE_NORMAL
- en: Miner credentials, 374
  prefs: []
  type: TYPE_NORMAL
- en: rollup, 363–370
  prefs: []
  type: TYPE_NORMAL
- en: Miner node, 178
  prefs: []
  type: TYPE_NORMAL
- en: SC, 343–347
  prefs: []
  type: TYPE_NORMAL
- en: Miner software component
  prefs: []
  type: TYPE_NORMAL
- en: smart contracts, 343
  prefs: []
  type: TYPE_NORMAL
- en: interfaces, 169
  prefs: []
  type: TYPE_NORMAL
- en: Library, 296
  prefs: []
  type: TYPE_NORMAL
- en: Mintability, 392
  prefs: []
  type: TYPE_NORMAL
- en: Logical operators, 255
  prefs: []
  type: TYPE_NORMAL
- en: Mint event, 272
  prefs: []
  type: TYPE_NORMAL
- en: Mobile client, 307
  prefs: []
  type: TYPE_NORMAL
- en: '**M**'
  prefs: []
  type: TYPE_NORMAL
- en: Money
  prefs: []
  type: TYPE_NORMAL
- en: Bitcoin, 13
  prefs: []
  type: TYPE_NORMAL
- en: Mallory contract, 280
  prefs: []
  type: TYPE_NORMAL
- en: challenges/drawbacks, 10
  prefs: []
  type: TYPE_NORMAL
- en: Mapping data structures, 415
  prefs: []
  type: TYPE_NORMAL
- en: commodities, 11
  prefs: []
  type: TYPE_NORMAL
- en: Mapping data type, 263, 264
  prefs: []
  type: TYPE_NORMAL
- en: contract, 7
  prefs: []
  type: TYPE_NORMAL
- en: Membership rewards, 37
  prefs: []
  type: TYPE_NORMAL
- en: definition, 12
  prefs: []
  type: TYPE_NORMAL
- en: Memory operations, 402
  prefs: []
  type: TYPE_NORMAL
- en: exchange transactions, 8, 9
  prefs: []
  type: TYPE_NORMAL
- en: Merkle tree
  prefs: []
  type: TYPE_NORMAL
- en: medium of exchange, 12
  prefs: []
  type: TYPE_NORMAL
- en: binary tree structure, 351
  prefs: []
  type: TYPE_NORMAL
- en: properties, 11, 12
  prefs: []
  type: TYPE_NORMAL
- en: checkMerkleTree function, 353,
  prefs: []
  type: TYPE_NORMAL
- en: transactions, 7, 8
  prefs: []
  type: TYPE_NORMAL
- en: 355, 357
  prefs: []
  type: TYPE_NORMAL
- en: universally acceptable medium
  prefs: []
  type: TYPE_NORMAL
- en: code snippet, 352
  prefs: []
  type: TYPE_NORMAL
- en: of exchange, 9
  prefs: []
  type: TYPE_NORMAL
- en: data integrity and processing
  prefs: []
  type: TYPE_NORMAL
- en: msg variable, 269
  prefs: []
  type: TYPE_NORMAL
- en: efficiency, 351
  prefs: []
  type: TYPE_NORMAL
- en: MyEtherWallet (MEW), 220, 221
  prefs: []
  type: TYPE_NORMAL
- en: example, 351–357
  prefs: []
  type: TYPE_NORMAL
- en: MythX security verification, 289
  prefs: []
  type: TYPE_NORMAL
- en: '445'
  prefs: []
  type: TYPE_NORMAL
- en: INDEX
  prefs: []
  type: TYPE_NORMAL
- en: '**N**'
  prefs: []
  type: TYPE_NORMAL
- en: Plasma
  prefs: []
  type: TYPE_NORMAL
- en: operators, 349, 350
  prefs: []
  type: TYPE_NORMAL
- en: NFT applications, 224, 225
  prefs: []
  type: TYPE_NORMAL
- en: plasma chains, 350
  prefs: []
  type: TYPE_NORMAL
- en: NFT marketplace, 386
  prefs: []
  type: TYPE_NORMAL
- en: smart contracts, 348, 349
  prefs: []
  type: TYPE_NORMAL
- en: NodeKey, 212
  prefs: []
  type: TYPE_NORMAL
- en: transaction Merkle tree ( *see*
  prefs: []
  type: TYPE_NORMAL
- en: Nonfungible tokens (NFTs), 127,
  prefs: []
  type: TYPE_NORMAL
- en: Merkle tree)
  prefs: []
  type: TYPE_NORMAL
- en: 319, 360, 383, 392
  prefs: []
  type: TYPE_NORMAL
- en: transactions/smart
  prefs: []
  type: TYPE_NORMAL
- en: Nonnative tokens, 126
  prefs: []
  type: TYPE_NORMAL
- en: contracts, 350
  prefs: []
  type: TYPE_NORMAL
- en: Plasma blockchain, 349
  prefs: []
  type: TYPE_NORMAL
- en: '**O**'
  prefs: []
  type: TYPE_NORMAL
- en: Plasma Cash, 357, 360–363
  prefs: []
  type: TYPE_NORMAL
- en: One-way functions, 52
  prefs: []
  type: TYPE_NORMAL
- en: Plasma chains, 350
  prefs: []
  type: TYPE_NORMAL
- en: OpenSea, 225
  prefs: []
  type: TYPE_NORMAL
- en: Plasma MVP, 357–359, 362
  prefs: []
  type: TYPE_NORMAL
- en: Open Systems Interconnection
  prefs: []
  type: TYPE_NORMAL
- en: Polkadot, 199
  prefs: []
  type: TYPE_NORMAL
- en: (OSI), 211
  prefs: []
  type: TYPE_NORMAL
- en: Privacy, 82, 107
  prefs: []
  type: TYPE_NORMAL
- en: OpenZeppelin package, 382
  prefs: []
  type: TYPE_NORMAL
- en: Privacy preservation, 164
  prefs: []
  type: TYPE_NORMAL
- en: Optimistic layer 2, 364, 365
  prefs: []
  type: TYPE_NORMAL
- en: Privacy-preserving distributed
  prefs: []
  type: TYPE_NORMAL
- en: Optimistic Virtual Machine
  prefs: []
  type: TYPE_NORMAL
- en: ledgers, 90, 94
  prefs: []
  type: TYPE_NORMAL
- en: (OVM), 364
  prefs: []
  type: TYPE_NORMAL
- en: Privacy trade-offs, 29
  prefs: []
  type: TYPE_NORMAL
- en: Oracle service, 225, 226
  prefs: []
  type: TYPE_NORMAL
- en: Private keys, 73
  prefs: []
  type: TYPE_NORMAL
- en: Ouroboros, 199
  prefs: []
  type: TYPE_NORMAL
- en: Private permissioned
  prefs: []
  type: TYPE_NORMAL
- en: Outdated compilers, 285, 286
  prefs: []
  type: TYPE_NORMAL
- en: blockchain, 95, 97
  prefs: []
  type: TYPE_NORMAL
- en: Out-of-bound index, 284
  prefs: []
  type: TYPE_NORMAL
- en: Private permissionless, 95
  prefs: []
  type: TYPE_NORMAL
- en: Out-of-bound write, 284
  prefs: []
  type: TYPE_NORMAL
- en: Proof of authority (POA), 186, 213,
  prefs: []
  type: TYPE_NORMAL
- en: 343, 346, 350, 432
  prefs: []
  type: TYPE_NORMAL
- en: Proof-of-stake (POS), 185, 350, 371,
  prefs: []
  type: TYPE_NORMAL
- en: '**P**'
  prefs: []
  type: TYPE_NORMAL
- en: 372, 374–377
  prefs: []
  type: TYPE_NORMAL
- en: P2P network layer
  prefs: []
  type: TYPE_NORMAL
- en: Proof-of-work (POW), 178, 338,
  prefs: []
  type: TYPE_NORMAL
- en: communication, 337
  prefs: []
  type: TYPE_NORMAL
- en: 371, 377
  prefs: []
  type: TYPE_NORMAL
- en: Payable functions, 253
  prefs: []
  type: TYPE_NORMAL
- en: Public blockchains, 96, 342
  prefs: []
  type: TYPE_NORMAL
- en: Peer-to-peer networks, 32,
  prefs: []
  type: TYPE_NORMAL
- en: Public key, 48
  prefs: []
  type: TYPE_NORMAL
- en: 44, 67–71
  prefs: []
  type: TYPE_NORMAL
- en: Public permissioned
  prefs: []
  type: TYPE_NORMAL
- en: Permissioned blockchains, 96
  prefs: []
  type: TYPE_NORMAL
- en: blockchain, 95, 121
  prefs: []
  type: TYPE_NORMAL
- en: Permissionless
  prefs: []
  type: TYPE_NORMAL
- en: Public permissionless blockchain,
  prefs: []
  type: TYPE_NORMAL
- en: blockchains, 97
  prefs: []
  type: TYPE_NORMAL
- en: 95, 97, 99
  prefs: []
  type: TYPE_NORMAL
- en: '446'
  prefs: []
  type: TYPE_NORMAL
- en: INDEX
  prefs: []
  type: TYPE_NORMAL
- en: '**Q**'
  prefs: []
  type: TYPE_NORMAL
- en: '**S**'
  prefs: []
  type: TYPE_NORMAL
- en: Quadratic Arithmetic Program
  prefs: []
  type: TYPE_NORMAL
- en: S&H green stamps, 37
  prefs: []
  type: TYPE_NORMAL
- en: (QAP), 368
  prefs: []
  type: TYPE_NORMAL
- en: SC wallet, 345
  prefs: []
  type: TYPE_NORMAL
- en: Quantitative analysis, 398
  prefs: []
  type: TYPE_NORMAL
- en: Securities and Exchange
  prefs: []
  type: TYPE_NORMAL
- en: Quantum
  prefs: []
  type: TYPE_NORMAL
- en: Commission (SEC), 127
  prefs: []
  type: TYPE_NORMAL
- en: computing, 336–338
  prefs: []
  type: TYPE_NORMAL
- en: Security
  prefs: []
  type: TYPE_NORMAL
- en: Quorum, 142
  prefs: []
  type: TYPE_NORMAL
- en: attackable security holes in
  prefs: []
  type: TYPE_NORMAL
- en: smart contracts, 323–325
  prefs: []
  type: TYPE_NORMAL
- en: '**R**'
  prefs: []
  type: TYPE_NORMAL
- en: best practices for smart
  prefs: []
  type: TYPE_NORMAL
- en: contracts ( *see* Security
  prefs: []
  type: TYPE_NORMAL
- en: Race conditions, 278
  prefs: []
  type: TYPE_NORMAL
- en: practices, smart contracts)
  prefs: []
  type: TYPE_NORMAL
- en: Random Number Generator
  prefs: []
  type: TYPE_NORMAL
- en: compiler vulnerabilities,
  prefs: []
  type: TYPE_NORMAL
- en: (RNG), 286, 331
  prefs: []
  type: TYPE_NORMAL
- en: 285, 286
  prefs: []
  type: TYPE_NORMAL
- en: Rank-1 constraint systems (R1CS)
  prefs: []
  type: TYPE_NORMAL
- en: data type and data
  prefs: []
  type: TYPE_NORMAL
- en: format, 368
  prefs: []
  type: TYPE_NORMAL
- en: vulnerabilities
  prefs: []
  type: TYPE_NORMAL
- en: RCP protocols, 373
  prefs: []
  type: TYPE_NORMAL
- en: arbitrary storage locations,
  prefs: []
  type: TYPE_NORMAL
- en: Reduce functions, 52
  prefs: []
  type: TYPE_NORMAL
- en: 284, 285
  prefs: []
  type: TYPE_NORMAL
- en: Relational database management
  prefs: []
  type: TYPE_NORMAL
- en: authorization through tx.
  prefs: []
  type: TYPE_NORMAL
- en: systems, 4
  prefs: []
  type: TYPE_NORMAL
- en: origin, 282, 283
  prefs: []
  type: TYPE_NORMAL
- en: Remix, 238–243, 247, 292
  prefs: []
  type: TYPE_NORMAL
- en: block values, 283
  prefs: []
  type: TYPE_NORMAL
- en: Remix debugger, 302
  prefs: []
  type: TYPE_NORMAL
- en: shadowing state variables,
  prefs: []
  type: TYPE_NORMAL
- en: Remix development
  prefs: []
  type: TYPE_NORMAL
- en: 281, 282
  prefs: []
  type: TYPE_NORMAL
- en: tools, 309
  prefs: []
  type: TYPE_NORMAL
- en: unused variables, 285
  prefs: []
  type: TYPE_NORMAL
- en: Remix plug-in, 301
  prefs: []
  type: TYPE_NORMAL
- en: variable value overflow/
  prefs: []
  type: TYPE_NORMAL
- en: Remote procedure calls
  prefs: []
  type: TYPE_NORMAL
- en: underflow, 280, 281
  prefs: []
  type: TYPE_NORMAL
- en: (RPCs), 193
  prefs: []
  type: TYPE_NORMAL
- en: function vulnerabilities
  prefs: []
  type: TYPE_NORMAL
- en: RETURN opcode, 401
  prefs: []
  type: TYPE_NORMAL
- en: assert violation, 279
  prefs: []
  type: TYPE_NORMAL
- en: Ripple Labs, 142
  prefs: []
  type: TYPE_NORMAL
- en: cross-chain contract, 279
  prefs: []
  type: TYPE_NORMAL
- en: Rollup, 363
  prefs: []
  type: TYPE_NORMAL
- en: delegatecall function, 277
  prefs: []
  type: TYPE_NORMAL
- en: optimistic layer 2, 364, 365
  prefs: []
  type: TYPE_NORMAL
- en: DOS with failed function
  prefs: []
  type: TYPE_NORMAL
- en: zk-SNARK, 365
  prefs: []
  type: TYPE_NORMAL
- en: calls, 278
  prefs: []
  type: TYPE_NORMAL
- en: Root blockchain, 348
  prefs: []
  type: TYPE_NORMAL
- en: ether withdraw operation
  prefs: []
  type: TYPE_NORMAL
- en: RPC endpoint, 313
  prefs: []
  type: TYPE_NORMAL
- en: not protected, 276
  prefs: []
  type: TYPE_NORMAL
- en: '447'
  prefs: []
  type: TYPE_NORMAL
- en: INDEX
  prefs: []
  type: TYPE_NORMAL
- en: Security ( *cont.* )
  prefs: []
  type: TYPE_NORMAL
- en: Self-confined function, 253
  prefs: []
  type: TYPE_NORMAL
- en: function call value is not
  prefs: []
  type: TYPE_NORMAL
- en: Self-destruction functions, 276
  prefs: []
  type: TYPE_NORMAL
- en: checked, 276
  prefs: []
  type: TYPE_NORMAL
- en: setMessage function, 317
  prefs: []
  type: TYPE_NORMAL
- en: race conditions and
  prefs: []
  type: TYPE_NORMAL
- en: sha256/keccak256, 351, 362
  prefs: []
  type: TYPE_NORMAL
- en: transaction order
  prefs: []
  type: TYPE_NORMAL
- en: sha256 Solidity function, 353
  prefs: []
  type: TYPE_NORMAL
- en: dependence, 278, 279
  prefs: []
  type: TYPE_NORMAL
- en: Sharding nodes, 371, 373
  prefs: []
  type: TYPE_NORMAL
- en: self-destruction functions, 276
  prefs: []
  type: TYPE_NORMAL
- en: Signature manipulation, 286, 287
  prefs: []
  type: TYPE_NORMAL
- en: solidity deprecated
  prefs: []
  type: TYPE_NORMAL
- en: Small smart contract, 227
  prefs: []
  type: TYPE_NORMAL
- en: functions, 277
  prefs: []
  type: TYPE_NORMAL
- en: Smart contract, 382, 414, 415, 423,
  prefs: []
  type: TYPE_NORMAL
- en: visibility error, 274, 275
  prefs: []
  type: TYPE_NORMAL
- en: 431, 434
  prefs: []
  type: TYPE_NORMAL
- en: signature vulnerabilities, 286, 287
  prefs: []
  type: TYPE_NORMAL
- en: blockchain, 247
  prefs: []
  type: TYPE_NORMAL
- en: software development, 319
  prefs: []
  type: TYPE_NORMAL
- en: for business person, 246
  prefs: []
  type: TYPE_NORMAL
- en: Security audit, 329
  prefs: []
  type: TYPE_NORMAL
- en: bytecodes, 246
  prefs: []
  type: TYPE_NORMAL
- en: Security practices, smart contracts
  prefs: []
  type: TYPE_NORMAL
- en: code and explanation, 418
  prefs: []
  type: TYPE_NORMAL
- en: blockchain specific security
  prefs: []
  type: TYPE_NORMAL
- en: compilation, 246
  prefs: []
  type: TYPE_NORMAL
- en: tips, 334–336
  prefs: []
  type: TYPE_NORMAL
- en: components, 424
  prefs: []
  type: TYPE_NORMAL
- en: mitigation plans, 326, 327
  prefs: []
  type: TYPE_NORMAL
- en: crosschain id, 416
  prefs: []
  type: TYPE_NORMAL
- en: quantum computing, security
  prefs: []
  type: TYPE_NORMAL
- en: definition, 245
  prefs: []
  type: TYPE_NORMAL
- en: impact, 336–338
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum, 246
  prefs: []
  type: TYPE_NORMAL
- en: readable smart contract
  prefs: []
  type: TYPE_NORMAL
- en: function calling, 246
  prefs: []
  type: TYPE_NORMAL
- en: logic, 330
  prefs: []
  type: TYPE_NORMAL
- en: Solidity ( *see* Solidity
  prefs: []
  type: TYPE_NORMAL
- en: review gas consumption, 332, 333
  prefs: []
  type: TYPE_NORMAL
- en: programming language)
  prefs: []
  type: TYPE_NORMAL
- en: RNG, 331
  prefs: []
  type: TYPE_NORMAL
- en: for technical person, 246
  prefs: []
  type: TYPE_NORMAL
- en: security breaches and patches,
  prefs: []
  type: TYPE_NORMAL
- en: technical point of view, 246
  prefs: []
  type: TYPE_NORMAL
- en: 333, 334
  prefs: []
  type: TYPE_NORMAL
- en: and web GUI, 431
  prefs: []
  type: TYPE_NORMAL
- en: set a maximum amount of asset
  prefs: []
  type: TYPE_NORMAL
- en: Smart contract bytecodes, 236
  prefs: []
  type: TYPE_NORMAL
- en: values, 327, 328
  prefs: []
  type: TYPE_NORMAL
- en: Smart contract development tools
  prefs: []
  type: TYPE_NORMAL
- en: smart contract open source, 328
  prefs: []
  type: TYPE_NORMAL
- en: Mythx, 288, 289
  prefs: []
  type: TYPE_NORMAL
- en: smart contracts auditing,
  prefs: []
  type: TYPE_NORMAL
- en: solidity debug
  prefs: []
  type: TYPE_NORMAL
- en: 329, 330
  prefs: []
  type: TYPE_NORMAL
- en: debugging smart
  prefs: []
  type: TYPE_NORMAL
- en: source code and libraries, 327
  prefs: []
  type: TYPE_NORMAL
- en: contract, 303–305
  prefs: []
  type: TYPE_NORMAL
- en: well-tested libraries, 331
  prefs: []
  type: TYPE_NORMAL
- en: enabling debugger, 302
  prefs: []
  type: TYPE_NORMAL
- en: whitehat, 329
  prefs: []
  type: TYPE_NORMAL
- en: launching debugger, 302
  prefs: []
  type: TYPE_NORMAL
- en: Security vulnerability, 334
  prefs: []
  type: TYPE_NORMAL
- en: source code, 301
  prefs: []
  type: TYPE_NORMAL
- en: '448'
  prefs: []
  type: TYPE_NORMAL
- en: INDEX
  prefs: []
  type: TYPE_NORMAL
- en: solidity test, Remix Plug-in,
  prefs: []
  type: TYPE_NORMAL
- en: fixed size array, 261, 262
  prefs: []
  type: TYPE_NORMAL
- en: 296–298, 300, 301
  prefs: []
  type: TYPE_NORMAL
- en: integer, 256–258
  prefs: []
  type: TYPE_NORMAL
- en: solidity to UML
  prefs: []
  type: TYPE_NORMAL
- en: Mapping type, 263, 264
  prefs: []
  type: TYPE_NORMAL
- en: dApp project, 292
  prefs: []
  type: TYPE_NORMAL
- en: smart contract functions, 255
  prefs: []
  type: TYPE_NORMAL
- en: Remix, 292, 293
  prefs: []
  type: TYPE_NORMAL
- en: Struct, 266–268
  prefs: []
  type: TYPE_NORMAL
- en: stand-alone tools, 293–296
  prefs: []
  type: TYPE_NORMAL
- en: supports and non-
  prefs: []
  type: TYPE_NORMAL
- en: SSA, 290, 292
  prefs: []
  type: TYPE_NORMAL
- en: supported, 255
  prefs: []
  type: TYPE_NORMAL
- en: Smart contract–enabled banking
  prefs: []
  type: TYPE_NORMAL
- en: Solidity deprecated functions, 277
  prefs: []
  type: TYPE_NORMAL
- en: dApp, 222, 223
  prefs: []
  type: TYPE_NORMAL
- en: Solidity programming language
  prefs: []
  type: TYPE_NORMAL
- en: Smart contract languages, 218
  prefs: []
  type: TYPE_NORMAL
- en: bytecode, 247
  prefs: []
  type: TYPE_NORMAL
- en: Smart contracts, 82, 99–101, 105,
  prefs: []
  type: TYPE_NORMAL
- en: comments, 249
  prefs: []
  type: TYPE_NORMAL
- en: 164, 435
  prefs: []
  type: TYPE_NORMAL
- en: constructor function, 252
  prefs: []
  type: TYPE_NORMAL
- en: attackable security
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum smart contracts, 247
  prefs: []
  type: TYPE_NORMAL
- en: holes, 323–325
  prefs: []
  type: TYPE_NORMAL
- en: event, 271–274
  prefs: []
  type: TYPE_NORMAL
- en: auditing, 329, 330
  prefs: []
  type: TYPE_NORMAL
- en: function access scope, 254
  prefs: []
  type: TYPE_NORMAL
- en: security practices ( *see* Security
  prefs: []
  type: TYPE_NORMAL
- en: function modifier, 252, 253
  prefs: []
  type: TYPE_NORMAL
- en: practices, smart contracts)
  prefs: []
  type: TYPE_NORMAL
- en: Hello World example, 248
  prefs: []
  type: TYPE_NORMAL
- en: and writing code, 325
  prefs: []
  type: TYPE_NORMAL
- en: importing file, 251, 252
  prefs: []
  type: TYPE_NORMAL
- en: Smart wallet, 343
  prefs: []
  type: TYPE_NORMAL
- en: multiple scopes, 253, 254
  prefs: []
  type: TYPE_NORMAL
- en: Software application, 217
  prefs: []
  type: TYPE_NORMAL
- en: security ( *see* Security)
  prefs: []
  type: TYPE_NORMAL
- en: Software as a Service (SaaS), 5
  prefs: []
  type: TYPE_NORMAL
- en: source code, 247
  prefs: []
  type: TYPE_NORMAL
- en: sol2uml package, 293
  prefs: []
  type: TYPE_NORMAL
- en: Solidity smart contract
  prefs: []
  type: TYPE_NORMAL
- en: Solano, 199
  prefs: []
  type: TYPE_NORMAL
- en: programming, 319, 322
  prefs: []
  type: TYPE_NORMAL
- en: Solidity, 330
  prefs: []
  type: TYPE_NORMAL
- en: Solidity Static Analysis (SSA),
  prefs: []
  type: TYPE_NORMAL
- en: Solidity data types
  prefs: []
  type: TYPE_NORMAL
- en: 290, 292
  prefs: []
  type: TYPE_NORMAL
- en: address type, 258, 259
  prefs: []
  type: TYPE_NORMAL
- en: Solidity Unit Test plug-in, 296–301
  prefs: []
  type: TYPE_NORMAL
- en: blockchain specific
  prefs: []
  type: TYPE_NORMAL
- en: Sparse Merkle trees, 362, 376
  prefs: []
  type: TYPE_NORMAL
- en: variables, 268–270
  prefs: []
  type: TYPE_NORMAL
- en: Special global variables, 283
  prefs: []
  type: TYPE_NORMAL
- en: boolean, 255, 256
  prefs: []
  type: TYPE_NORMAL
- en: Stablecoins, 227, 387
  prefs: []
  type: TYPE_NORMAL
- en: byte array, 259, 260
  prefs: []
  type: TYPE_NORMAL
- en: Stable RPC node, 434
  prefs: []
  type: TYPE_NORMAL
- en: code security and execution
  prefs: []
  type: TYPE_NORMAL
- en: Stack-based programing
  prefs: []
  type: TYPE_NORMAL
- en: efficiency, 255
  prefs: []
  type: TYPE_NORMAL
- en: language, 201
  prefs: []
  type: TYPE_NORMAL
- en: Dynamically size array, 262, 263
  prefs: []
  type: TYPE_NORMAL
- en: Stakeholder organizational
  prefs: []
  type: TYPE_NORMAL
- en: Enum, 264, 265
  prefs: []
  type: TYPE_NORMAL
- en: models, 133
  prefs: []
  type: TYPE_NORMAL
- en: '449'
  prefs: []
  type: TYPE_NORMAL
- en: INDEX
  prefs: []
  type: TYPE_NORMAL
- en: StartWithdraw function, 349
  prefs: []
  type: TYPE_NORMAL
- en: CCT, 389, 390
  prefs: []
  type: TYPE_NORMAL
- en: State channel (SC), L2, 343–347
  prefs: []
  type: TYPE_NORMAL
- en: cTokens, 386
  prefs: []
  type: TYPE_NORMAL
- en: State channels (SC), 363
  prefs: []
  type: TYPE_NORMAL
- en: DeFi projects, 386
  prefs: []
  type: TYPE_NORMAL
- en: State channels (SC), L2
  prefs: []
  type: TYPE_NORMAL
- en: distribution, 394
  prefs: []
  type: TYPE_NORMAL
- en: components, 344, 345
  prefs: []
  type: TYPE_NORMAL
- en: ERC20, 380, 383
  prefs: []
  type: TYPE_NORMAL
- en: offchain computing, 346
  prefs: []
  type: TYPE_NORMAL
- en: ERC20 and ERC721, 391
  prefs: []
  type: TYPE_NORMAL
- en: participants, 347
  prefs: []
  type: TYPE_NORMAL
- en: function, 380
  prefs: []
  type: TYPE_NORMAL
- en: topology and workflow, 344
  prefs: []
  type: TYPE_NORMAL
- en: green energy, 390
  prefs: []
  type: TYPE_NORMAL
- en: transactions, 347
  prefs: []
  type: TYPE_NORMAL
- en: industries, 388
  prefs: []
  type: TYPE_NORMAL
- en: wallet, 345
  prefs: []
  type: TYPE_NORMAL
- en: NFT, 383, 384, 386
  prefs: []
  type: TYPE_NORMAL
- en: workflow, 345
  prefs: []
  type: TYPE_NORMAL
- en: in public blockchains, 388
  prefs: []
  type: TYPE_NORMAL
- en: State variables, 281
  prefs: []
  type: TYPE_NORMAL
- en: reward, 393
  prefs: []
  type: TYPE_NORMAL
- en: Storage, 214
  prefs: []
  type: TYPE_NORMAL
- en: smart contract, 382
  prefs: []
  type: TYPE_NORMAL
- en: Struct, 266–268
  prefs: []
  type: TYPE_NORMAL
- en: supply chain, 388
  prefs: []
  type: TYPE_NORMAL
- en: SubmitPlasmaTxRecord
  prefs: []
  type: TYPE_NORMAL
- en: taxonomy infrastructure and
  prefs: []
  type: TYPE_NORMAL
- en: function, 348
  prefs: []
  type: TYPE_NORMAL
- en: framework, 390
  prefs: []
  type: TYPE_NORMAL
- en: Supply chain, 388
  prefs: []
  type: TYPE_NORMAL
- en: templates, 392
  prefs: []
  type: TYPE_NORMAL
- en: Supply chain–oriented
  prefs: []
  type: TYPE_NORMAL
- en: unit, 392
  prefs: []
  type: TYPE_NORMAL
- en: transaction, 24
  prefs: []
  type: TYPE_NORMAL
- en: value, 392
  prefs: []
  type: TYPE_NORMAL
- en: Supply chain applications, 153, 154
  prefs: []
  type: TYPE_NORMAL
- en: Tokens, 124–127
  prefs: []
  type: TYPE_NORMAL
- en: Symmetric key cryptography, 47, 55
  prefs: []
  type: TYPE_NORMAL
- en: Token taxonomy framework (TTF),
  prefs: []
  type: TYPE_NORMAL
- en: System designer, 116
  prefs: []
  type: TYPE_NORMAL
- en: 125, 391
  prefs: []
  type: TYPE_NORMAL
- en: Traditional computer network
  prefs: []
  type: TYPE_NORMAL
- en: architecture, 68
  prefs: []
  type: TYPE_NORMAL
- en: '**T**'
  prefs: []
  type: TYPE_NORMAL
- en: Transaction, 7, 82, 106, 278
  prefs: []
  type: TYPE_NORMAL
- en: Target blockchain healthcare
  prefs: []
  type: TYPE_NORMAL
- en: Transaction-based analysis, 119
  prefs: []
  type: TYPE_NORMAL
- en: applications, 150, 158
  prefs: []
  type: TYPE_NORMAL
- en: Transaction fees, 341
  prefs: []
  type: TYPE_NORMAL
- en: testcasedemo function, 355, 357
  prefs: []
  type: TYPE_NORMAL
- en: Transaction logs, 271, 274
  prefs: []
  type: TYPE_NORMAL
- en: Testing program, 433
  prefs: []
  type: TYPE_NORMAL
- en: Traveler’s checks, 38
  prefs: []
  type: TYPE_NORMAL
- en: Third-party applications, 234
  prefs: []
  type: TYPE_NORMAL
- en: Truffle, 235–238
  prefs: []
  type: TYPE_NORMAL
- en: Third-party logistics (TPL), 19
  prefs: []
  type: TYPE_NORMAL
- en: Truisms, 6
  prefs: []
  type: TYPE_NORMAL
- en: Third-party RPC nodes, 308
  prefs: []
  type: TYPE_NORMAL
- en: Trust, firms, 6
  prefs: []
  type: TYPE_NORMAL
- en: Token, 434
  prefs: []
  type: TYPE_NORMAL
- en: TTCDiploma smart contract, 385
  prefs: []
  type: TYPE_NORMAL
- en: '450'
  prefs: []
  type: TYPE_NORMAL
- en: INDEX
  prefs: []
  type: TYPE_NORMAL
- en: '**U**'
  prefs: []
  type: TYPE_NORMAL
- en: compile smart contract, 310
  prefs: []
  type: TYPE_NORMAL
- en: deploy smart contract, 311, 313
  prefs: []
  type: TYPE_NORMAL
- en: UML diagram, 294
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum development
  prefs: []
  type: TYPE_NORMAL
- en: Uniswap, 386
  prefs: []
  type: TYPE_NORMAL
- en: blockchain, 308, 309
  prefs: []
  type: TYPE_NORMAL
- en: Universal Resource Identifier
  prefs: []
  type: TYPE_NORMAL
- en: writing, 313–315, 317
  prefs: []
  type: TYPE_NORMAL
- en: (URI), 384
  prefs: []
  type: TYPE_NORMAL
- en: Unspent transaction output
  prefs: []
  type: TYPE_NORMAL
- en: (UTXO) format,
  prefs: []
  type: TYPE_NORMAL
- en: '**X, Y**'
  prefs: []
  type: TYPE_NORMAL
- en: 188, 358–360
  prefs: []
  type: TYPE_NORMAL
- en: 0xcert, 225
  prefs: []
  type: TYPE_NORMAL
- en: '**V**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Z**'
  prefs: []
  type: TYPE_NORMAL
- en: Validation nodes, 372, 374
  prefs: []
  type: TYPE_NORMAL
- en: Value exchange
  prefs: []
  type: TYPE_NORMAL
- en: Zero-Knowledge Succinct Non-
  prefs: []
  type: TYPE_NORMAL
- en: data role, 18, 20
  prefs: []
  type: TYPE_NORMAL
- en: interactive Argument of
  prefs: []
  type: TYPE_NORMAL
- en: economy, 15, 22
  prefs: []
  type: TYPE_NORMAL
- en: Knowledge (zk-SNARK)
  prefs: []
  type: TYPE_NORMAL
- en: parties, 17
  prefs: []
  type: TYPE_NORMAL
- en: characteristics, 366
  prefs: []
  type: TYPE_NORMAL
- en: proprietary data, 22
  prefs: []
  type: TYPE_NORMAL
- en: define, 368
  prefs: []
  type: TYPE_NORMAL
- en: third parties role, 19
  prefs: []
  type: TYPE_NORMAL
- en: drinking age, 368
  prefs: []
  type: TYPE_NORMAL
- en: transactions, 88
  prefs: []
  type: TYPE_NORMAL
- en: layer 2 rollup solution, 367
  prefs: []
  type: TYPE_NORMAL
- en: Value types, 17
  prefs: []
  type: TYPE_NORMAL
- en: in privacy computing, 367
  prefs: []
  type: TYPE_NORMAL
- en: View function, 253
  prefs: []
  type: TYPE_NORMAL
- en: privacy-enhanced crypto
  prefs: []
  type: TYPE_NORMAL
- en: computation, 366
  prefs: []
  type: TYPE_NORMAL
- en: proof and verification, 369
  prefs: []
  type: TYPE_NORMAL
- en: '**W**'
  prefs: []
  type: TYPE_NORMAL
- en: R1CS format, 368
  prefs: []
  type: TYPE_NORMAL
- en: Wallet software component, 168
  prefs: []
  type: TYPE_NORMAL
- en: value, 368
  prefs: []
  type: TYPE_NORMAL
- en: Web Client
  prefs: []
  type: TYPE_NORMAL
- en: works, 369, 370
  prefs: []
  type: TYPE_NORMAL
- en: '451'
  prefs: []
  type: TYPE_NORMAL
- en: Document Outline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Table of Contents](index_split_000.html#p5)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[About the Authors](index_split_000.html#p14)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[About the Technical Reviewer](index_split_000.html#p16)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Acknowledgments](index_split_000.html#p17)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 1: Business and Economic Motivation for Blockchain](index_split_000.html#p19)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Introduction](index_split_000.html#p20)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[A Brief History of Money](index_split_000.html#p23)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Economy As Value Exchange](index_split_000.html#p30)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Current Economic Inefficiencies](index_split_000.html#p38)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Blockchain’s Potential to Address Current Economic Inefficiencies](index_split_000.html#p47)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter Summary/Key Takeaways](index_split_000.html#p50)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Sidebars](index_split_000.html#p52)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Quiz Questions](index_split_000.html#p54)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[References](index_split_000.html#p55)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 2: Overview of Core Technologies Supporting Blockchain](index_split_000.html#p58)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Introduction](index_split_000.html#p58)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Cryptology and Digital Signatures](index_split_000.html#p60)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Distributed Systems](index_split_001.html#p71)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Peer-to-Peer Networking](index_split_001.html#p82)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Blockchain Technology Integration](index_split_001.html#p86)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter Summary/Key Takeaways](index_split_001.html#p89)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Quiz Questions](index_split_001.html#p91)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Sidebar – Key Distributed Systems Terms and Definitions](index_split_001.html#p93)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[References](index_split_001.html#p94)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 3: Blockchain Components and Architecture](index_split_001.html#p95)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Introduction](index_split_001.html#p95)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Conceptual Overview of Blockchain Components](index_split_001.html#p97)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Distributed Ledgers and Technical Overview of Blockchains](index_split_001.html#p102)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Blockchain Implementation Categorization](index_split_001.html#p109)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Smart Contracts and Blockchain Components Summary](index_split_001.html#p113)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Blockchain Limitations](index_split_001.html#p116)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter Summary/Key Takeaways](index_split_002.html#p120)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Sidebar – Blockchain Terminology](index_split_002.html#p122)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Quiz Questions](index_split_002.html#p123)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[References](index_split_002.html#p125)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 4: Blockchain Business Applications](index_split_002.html#p126)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Introduction](index_split_002.html#p126)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Is a Blockchain Necessary?](index_split_002.html#p129)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Blockchain Application Design Decisions](index_split_002.html#p134)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Blockchain Applications](index_split_002.html#p152)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Blockchain Finance Applications](index_split_002.html#p152)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Blockchain Healthcare Applications](index_split_002.html#p158)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Blockchain Supply Chain Applications](index_split_002.html#p166)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Blockchain Entertainment Applications](index_split_002.html#p168)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter Summary/Key Takeaways](index_split_002.html#p170)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Quiz Questions](index_split_002.html#p172)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[References](index_split_003.html#p174)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 5: Blockchain Implementations Overview: Bitcoin, Ethereum, and Hyperledger](index_split_003.html#p176)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Introduction](index_split_003.html#p176)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Bitcoin Transactions, Blocks, and Mining](index_split_003.html#p178)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Bitcoin Economics](index_split_003.html#p195)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Consensus Protocols](index_split_003.html#p197)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Ethereum](index_split_003.html#p200)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Hyperledger](index_split_003.html#p206)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Bitcoin, Ethereum, and Hyperledger Comparison](index_split_003.html#p208)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Emerging Blockchain Implementations](index_split_003.html#p211)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter Summary/Key Takeaways](index_split_003.html#p213)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Sidebar – Stack-Based Programming Language](index_split_003.html#p214)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Quiz Questions](index_split_003.html#p215)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[References](index_split_003.html#p218)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Untitled](index_split_003.html#p181)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 6: Ethereum Architecture and Overview](index_split_003.html#p220)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Introduction](index_split_003.html#p220)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Ethereum Architecture](index_split_003.html#p222)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Network Layer](index_split_003.html#p223)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Core Blockchain Layer](index_split_003.html#p224)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Enterprise Components Layer](index_split_003.html#p226)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Tooling Layer](index_split_003.html#p227)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Application Layer](index_split_003.html#p228)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Ethereum Blockchain Ecosystem and DeFi Projects](index_split_004.html#p229)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Wallet to Manage Assets](index_split_004.html#p229)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Hosted Service](index_split_004.html#p230)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[MetaMask](index_split_004.html#p230)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[MyEtherWallet](index_split_004.html#p231)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Fortmatic](index_split_004.html#p232)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Smart Contract–Enabled Banking dApp](index_split_004.html#p233)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Decentralized Exchange in Ethereum](index_split_004.html#p234)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[NFT Applications](index_split_004.html#p235)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Oracle Service](index_split_004.html#p236)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[DAO Platforms](index_split_004.html#p237)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Decentralized Insurance Platform](index_split_004.html#p237)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Decentralized KYC and Identity](index_split_004.html#p238)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Stablecoin](index_split_004.html#p238)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Tools to Set Up a Smart Contract Development Environment](index_split_004.html#p239)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[MetaMask: The Simplest Way to Interact with the Ethereum Blockchain](index_split_004.html#p240)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Etherscan: The Most Comprehensive Blockchain Browser](index_split_004.html#p242)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Geth: The Swiss Army Knife for the Ethereum Blockchain](index_split_004.html#p242)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Truffle: The Most Comprehensive Smart Contract Development Tool](index_split_004.html#p246)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Remix: The Most Convenient Web-Based Smart Contract Development Tool](index_split_004.html#p249)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Summary](index_split_004.html#p255)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 7: Programming Smart Contract with Solidity](index_split_004.html#p256)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Introduction: What We Learned in the Last Chapter](index_split_004.html#p256)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[What Is Smart Contract](index_split_004.html#p256)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[What Is Solidity Programming Language](index_split_004.html#p258)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Module 1: Hello World Solidity Example](index_split_004.html#p259)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Solidity Comments](index_split_004.html#p260)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Solidity Program and Version Declaration](index_split_004.html#p260)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Import a Solidity File](index_split_004.html#p262)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Constructor Function](index_split_004.html#p263)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Function Modifier](index_split_004.html#p263)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Blockchain Access Scope: Pure/View/Payable Functions](index_split_004.html#p264)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Function Access Scope: Public, External, Internal, and Private](index_split_004.html#p265)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Module 2: Solidity Data Types](index_split_004.html#p266)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Boolean](index_split_004.html#p266)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Integer Type](index_split_004.html#p267)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Address Type](index_split_004.html#p269)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Byte Array](index_split_004.html#p270)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Fixed Size Array](index_split_004.html#p272)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Dynamically Sized Array](index_split_004.html#p273)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Mapping Data Type](index_split_004.html#p274)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Enum Data Type](index_split_004.html#p275)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Struct Data Type](index_split_004.html#p277)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Blockchain Specific Variables](index_split_004.html#p279)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Module 3: Events](index_split_004.html#p282)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[What Is Ethereum Event](index_split_004.html#p282)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Where Are Events Stored](index_split_004.html#p282)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[How to Define an Event](index_split_004.html#p282)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[How to Emit an Event](index_split_004.html#p283)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Event Examples](index_split_004.html#p284)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Module 4: Security](index_split_004.html#p285)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Function Vulnerabilities](index_split_004.html#p285)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Function Visibility Error](index_split_004.html#p285)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Vulnerability: Function Call Return Value Not Checked](index_split_004.html#p287)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Vulnerability: Ether Withdraw Operation Not Protected](index_split_004.html#p287)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Vulnerability: Self-Destruction Functions](index_split_004.html#p287)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Vulnerability: Use of Solidity Deprecated Functions](index_split_004.html#p288)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Vulnerability: Delegatecall to Untrusted Callee](index_split_004.html#p288)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Vulnerability: DOS with Failed Function Calls](index_split_004.html#p289)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Vulnerability: Race Conditions and Transaction Order Dependence](index_split_004.html#p289)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Vulnerability: Assert Violation](index_split_004.html#p290)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Vulnerability: Cross Contract Call Enters into a Loop](index_split_004.html#p290)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Data Type and Data Vulnerabilities](index_split_005.html#p291)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Vulnerability: Variable Value Overflow or Underflow](index_split_005.html#p291)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Vulnerability: Shadowing State Variables](index_split_005.html#p292)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Vulnerability: Authorization Through tx.origin](index_split_005.html#p293)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Vulnerability: Using Block Values to Represent Time](index_split_005.html#p294)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Vulnerability: Writing to Arbitrary Storage Locations](index_split_005.html#p295)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Vulnerability: Unused Variables](index_split_005.html#p296)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Compiler Vulnerabilities](index_split_005.html#p296)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Outdated Compilers](index_split_005.html#p296)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Randomness Vulnerability](index_split_005.html#p297)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Vulnerability: Weak Randomness from Blockchain Attributes](index_split_005.html#p297)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Signature Vulnerability](index_split_005.html#p297)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Vulnerability: Signature Manipulation](index_split_005.html#p297)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Module Summary](index_split_005.html#p298)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Module 5: Tools, Test, and Debug](index_split_005.html#p298)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Tools](index_split_005.html#p299)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[MythX: A Security Scanning Tool](index_split_005.html#p299)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Solidity Static Analysis: A Security Plug-in for Remix](index_split_005.html#p301)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Solidity to UML: Smart Contract Visualization Tool](index_split_005.html#p303)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Solidity to UML for Remix](index_split_005.html#p303)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Solidity to UML Stand-Alone Tools](index_split_005.html#p304)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Solidity Test](index_split_005.html#p307)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Solidity Unit Testing: A Remix Plug-in for Testing](index_split_005.html#p307)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Solidity Debug](index_split_005.html#p312)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Enable the Debugger](index_split_005.html#p313)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Launch the Debugger](index_split_005.html#p313)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Debug the Smart Contract](index_split_005.html#p314)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Module 6: Client Considerations](index_split_005.html#p316)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Types of dApp clients](index_split_005.html#p317)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Browser Client](index_split_005.html#p318)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Mobile Clients](index_split_005.html#p318)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Desktop Client](index_split_005.html#p319)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[CLI Client](index_split_005.html#p319)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Web Client Example for Interacting with Smart Contract](index_split_005.html#p319)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Step 1: Create an Ethereum development blockchain](index_split_005.html#p319)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Step 2: Compile and deploy the smart contract to the development blockchain](index_split_005.html#p321)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Step 3: Deploy the smart contract](index_split_005.html#p322)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Step 4: Write web client to interact with the smart contract](index_split_005.html#p324)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Summary](index_split_005.html#p329)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 8: Security Considerations](index_split_005.html#p330)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Introduction](index_split_005.html#p330)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Functional Security Holes in Smart Contracts](index_split_005.html#p332)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Fund Deadlock](index_split_005.html#p332)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Fund Leakage](index_split_005.html#p333)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Disabled Smart Contract](index_split_005.html#p334)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Orphan Smart Contract](index_split_005.html#p334)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Attackable Security Holes in Smart Contracts](index_split_005.html#p334)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Best Security Practices for Smart Contracts](index_split_005.html#p336)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Have a Security Risk Mitigation Plan](index_split_005.html#p337)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Checking Both Main Source Code and Libraries](index_split_005.html#p338)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Put a Cap to the Max Funds](index_split_005.html#p338)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Make Your Smart Contract Open Source and Leverage the Community Effort to
    Harden the Security](index_split_005.html#p339)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Yes, There Are Blockchain Security Whitehats](index_split_005.html#p340)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Have Smart Contract Audited](index_split_005.html#p340)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Readable Smart Contract Logic](index_split_005.html#p341)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Modularize the Smart Contract](index_split_005.html#p341)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Using Well-Tested Libraries](index_split_005.html#p342)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Use a Good Random Number Generator](index_split_005.html#p342)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Review Gas Consumption in Security Context](index_split_005.html#p343)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Wisely Use Blockchain](index_split_005.html#p343)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Stay on Top of Security Breaches and Patches](index_split_005.html#p344)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Blockchain Specific Security Tips](index_split_005.html#p345)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Security Impact of Quantum Computing](index_split_005.html#p347)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Summary](index_split_005.html#p350)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 9: Layer 2 and Ethereum 2](index_split_005.html#p351)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Problem with Ethereum Mainnet](index_split_005.html#p351)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Layer 2 Technology](index_split_005.html#p353)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Ethereum State Channel](index_split_005.html#p353)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Plasma As a Layer 2 Technology](index_split_005.html#p357)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Plasma Smart Contract on Ethereum Mainnet](index_split_006.html#p358)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Operators](index_split_006.html#p359)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Transactions or Smart Contracts on Layer 2](index_split_006.html#p360)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Plasma Chain](index_split_006.html#p360)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Transaction Merkle Tree Example](index_split_006.html#p361)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Transaction Merkle Tree for Plasma MVP](index_split_006.html#p367)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Transaction Merkle Tree for Plasma Cash](index_split_006.html#p370)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Layer 2 Rollup](index_split_006.html#p373)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Optimistic Layer 2](index_split_006.html#p374)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[zk-SNARK Layer 2](index_split_006.html#p376)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Ethereum 2](index_split_006.html#p380)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Major Changes in Ethereum 2](index_split_006.html#p380)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Transferring from POW to POS](index_split_006.html#p381)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Beacon Chain](index_split_006.html#p381)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Sharding](index_split_006.html#p381)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Ethereum 2 Architectural Overview](index_split_006.html#p381)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Migrating from Ethereum 1 to Ethereum 2: POS Deposit, Staking, and Slashing](index_split_006.html#p384)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Run an Ethereum 2 Validator Node with POS Staking](index_split_006.html#p386)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Uncertainties with Ethereum 2](index_split_006.html#p388)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Summary](index_split_006.html#p388)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 10: Fund a Project: Tokens and Gas Fees](index_split_006.html#p389)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Introduction](index_split_006.html#p389)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Tokens for Funding Ecosystem Projects](index_split_006.html#p390)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Tokens in ICO and DeFi](index_split_006.html#p390)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Token in NFT](index_split_006.html#p393)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Tokens in DeFi (Compound, Uniswap, and Stablecoins)](index_split_006.html#p396)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Tokens for Enterprises/Standardized (Pervasive) Tokens](index_split_006.html#p397)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Supply chain tokens](index_split_006.html#p398)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Industry-Specific Tokens](index_split_006.html#p398)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Token Taxonomy Initiative](index_split_006.html#p400)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Token Economy Consideration](index_split_006.html#p403)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Token Allocation](index_split_006.html#p403)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Token Distribution](index_split_006.html#p404)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Gas Fee Consideration](index_split_006.html#p405)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[What Is Ethereum Gas?](index_split_006.html#p406)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Understand Ethereum Gas with Gas Station Analogy](index_split_006.html#p406)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Quantize Gas Expenses in a Smart Contract Program](index_split_006.html#p408)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Summary](index_split_006.html#p413)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 11: Building Team Projects](index_split_006.html#p414)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Problem Statement and Brainstorming](index_split_006.html#p414)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Specifications and Solutions](index_split_006.html#p416)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[EIP-3220: Crosschain Identifier Specification](index_split_006.html#p417)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Simple Summary](index_split_006.html#p417)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Abstract](index_split_006.html#p417)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Motivation](index_split_006.html#p417)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Specification](index_split_006.html#p419)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Rationale](index_split_006.html#p421)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Backward Compatibility](index_split_006.html#p421)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Security Considerations](index_split_006.html#p421)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Architecture](index_split_006.html#p422)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Design the Smart Contract](index_split_006.html#p423)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Roles](index_split_006.html#p423)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Events](index_split_006.html#p424)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Data Structures](index_split_006.html#p424)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Functions](index_split_006.html#p425)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[UML of Smart Contract](index_split_006.html#p425)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Smart Contract Code](index_split_006.html#p427)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Client Considerations](index_split_006.html#p432)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[HTML Page Example](index_split_006.html#p434)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[JavaScript Example](index_split_006.html#p436)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Security Review](index_split_006.html#p440)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Deploy to Testnet](index_split_006.html#p440)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Deploy to Mainnet](index_split_006.html#p442)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Operation and Upgrade Consideration](index_split_006.html#p444)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Index](index_split_006.html#p446)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
