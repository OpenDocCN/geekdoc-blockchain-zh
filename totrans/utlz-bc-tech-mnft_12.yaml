- en: Chapter 11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Transformation of Traditional Gas Industries to Blockchain-Enabled Gas Industries:'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Secured Supply Chain Strategy for Tracking Gas
  prefs: []
  type: TYPE_NORMAL
- en: Vladimir Nikolaevich Kustov
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saint Petersburg State University of Railway Transport of Emperor Alexander
    I, Russia
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ABSTRACT
  prefs: []
  type: TYPE_NORMAL
- en: 'The author considers the main purpose of this chapter to be the presentation
    of a modern approach to the digital transformation of traditional business processes
    in the gas industry. Using the example of a pilot project successfully implemented
    in the gas industry, the author shows the process of synthesizing a high-tech
    supply chain infrastructure based on blockchain. The presentation begins with
    a description of the main business processes of the supply chain. The functions
    for all participants of the system are described and visualized in detail. The
    main components of the system are considered: digital dispatcher, supply monitor,
    interaction interfaces, and production environment. A comparative analysis of
    the security of modern blockchain platforms is provided. The author carefully
    analyzes the technologies for creating and ensuring the security of smart contracts
    and offers a step-by-step method for implementing secure smart contracts. At the
    end of the chapter, the results of choosing the most secure blockchain platforms
    are presented.'
  prefs: []
  type: TYPE_NORMAL
- en: INTRODUCTION
  prefs: []
  type: TYPE_NORMAL
- en: 'Recently, only a lazy person has not written or talked about blockchain technology.
    Blockchain – what is it: the technology of the future or self-deception in the
    light of its little knowledge and applicability today? It is possible to argue,
    answering this question, for a long time and persistently. This chapter discusses
    the technological features of ensuring the security of this new technology, which
    often remain “behind the scenes” or represent some superficial, short, and non-revealing
    description (Kustov & Stankevich, 2019).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The views on blockchain technology expressed by experts in the field of information
    security and information technologies in print and oral presentations can be defined
    as opposed and considered at two criteria levels (Kustov & Stankevich, 2018):'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. prospects for implementation;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2\. the consequences of performance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second criterion directly follows from the first, and both allow us to divide
    experts into skeptics and enthusiasts. At the first level – “Prospects” – opinions
    are divided into those that express a sincere belief in blockchain and its existence
    within a variety of systems and services and those that deny it, referring to
    the possibility of an alternative, simpler, and, consequently, more reliable approaches
    to solving specific tasks. The second criterion – “Consequences” - divides experts
    into those who express unbridled delight in the light of the upcoming “revolution”
    (Swan, 2018), comparable to the creation of the Internet, and those who associate
    blockchain with the death of existing information and payment systems (Chris,
    2017). To the point, the creator of the blockchain, Satoshi Nakomoto, did not
    expect such a sad outcome in any way (Satoshi, 2008).
  prefs: []
  type: TYPE_NORMAL
- en: However, in practice, a huge mass of positive examples of the use of new technology
    prevails (Eman et al., 2020), (Nin et al., 2021), (Ahmed et al., 2021). The gas
    industry is no exception, and much attention is paid to the distributed registry
    technology.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the author considers the main purpose of this chapter to be the presentation
    of a modern approach to the digital transformation of traditional business processes
    in the gas industry. In recent years, several blockchain pilot projects have been
    implemented in the gas industry. Using the example of a pilot project successfully
    implemented in the gas industry, the author shows the process of synthesizing
    a high-tech supply chain infrastructure based on blockchain. Three completed pilot
    projects are particularly indicative:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. A pilot project to create a supply efficiency management system using blockchain
    technology.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2\. Develop a technological platform prototype for automating concluding, monitoring,
    and executing contracts based on blockchain technology.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3\. Development of a new digital Smart Fuel platform using blockchain technology.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As part of the first project, gas industry specialists tested blockchain technology
    and the Internet of Things concept in material and technical resources logistics.
  prefs: []
  type: TYPE_NORMAL
- en: Radiofrequency tags (RFID) and satellite positioning sensors (GPS) were installed
    by technical specialists on the shut-off valves and pipe products purchased for
    the gas production company. At the shipment stage of pipe product shipment from
    the manufacturer, a document with information about the delivery was formed after
    reading the RFID tags. The GPS sensor made it possible to monitor cargo movement
    to the storage base, the speed of its movement, the number, and the duration of
    stops on the way. All data received from the devices was recorded by a smart contract
    and reflected in the blockchain. In the future, information about warehouse and
    transport operations — entering products into a warehouse, moving to a berth for
    loading, delivery to a platform in the Pechora Sea — was transmitted according
    to a similar scheme. The blockchain provided an inextricable link between the
    physical delivery, all concurrent processes, and document flow and allowed all
    participants to access reliable information in encrypted form.
  prefs: []
  type: TYPE_NORMAL
- en: The successful implementation of the pilot project confirmed the possibility
    of using blockchain technology in supply chain management. The gas industry is
    considering the prospects for further using the potential of the blockchain and
    replicating the experience gained.
  prefs: []
  type: TYPE_NORMAL
- en: “Blockchain in deliveries has allowed us to create an ecosystem for the interaction
    of all participants in the process, such as the manufacturer, inspector, logistics
    operator, warehouse, and consumer. We see potential in the development and further
    application of the technology” (Karaev, 2018).
  prefs: []
  type: TYPE_NORMAL
- en: According to the second project, a prototype of a technological platform was
    developed on the basis of blockchain technology, which provides for the automation
    of the process of concluding, monitoring, and executing contracts. This system
    also assumes automatic arbitration and automatic calculation of gas payments.
    The developed system is open to all participants of the contractual process, and
    it is completely protected from unauthorized interference and unauthorized changes.
    The gas industry is currently actively working on implementing automating the
    support of the contractual process for gas supplies. At the initial stage, this
    work is carried out only for large industrial gas consumers. “The digital economy
    is the future that has already come. This project is a vivid example of a combination
    of industry, technological and financial expertise, in which all participants
    benefit” (Vanurina, 2019).
  prefs: []
  type: TYPE_NORMAL
- en: As part of the third project, a new Smart Fuel platform was developed based
    on the blockchain, designed to accelerate mutual settlements between the fuel
    operator and the airline.
  prefs: []
  type: TYPE_NORMAL
- en: As a result of its use, the settlement time was reduced from four days to fifteen
    seconds. “The Smart Fuel digital system simplifies the work of our partners as
    much as possible and increases the financial security of mutual settlements. Our
    solution allows us to take into account all the needs of airlines, reduce import
    dependence on foreign services, and has a high potential for scaling for the aviation
    industry” (Egorov, 2021).
  prefs: []
  type: TYPE_NORMAL
- en: 'Because of the implementation of the pilot projects mentioned above, the following
    estimates of their economic efficiency were obtained:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Reducing administrative and commercial costs by 5-10% (thanks to the pilot
    projects) allows large oil and gas companies to save 0.4-0.7 billion dollars.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2\. One of the largest oil and gas companies estimated that the use of blockchain
    in the oil and gas business increases the company's efficiency by 10-15%.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3\. This oil and gas company believes that implementing the pilot project will
    allow the company to save up to 10% of tax costs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Limiting the scope of this chapter, the author further examines in more detail
    the stages of work on only one of these projects. To create and implement modern
    technologies at gas industry enterprises, a pilot project was carried out on the
    topic “Managing the quality of material and technical resources and supply efficiency
    using Blockchain technology,” consisting of the following main stages:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Research and graphical visualization of the main business processes of the
    supply efficiency management system at gas industry enterprises using Blockchain
    technology.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2\. Comparative analysis of blockchain platforms, testing, and selection of
    a platform for implementation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's take a closer look at the pilot design process by the steps listed above.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: RESEARCH AND GRAPHICAL VISUALIZATION OF THE MAIN BUSINESS PROCESSES OF THE SUPPLY
    EFFICIENCY MANAGEMENT SYSTEM
  prefs: []
  type: TYPE_NORMAL
- en: The urgent need to develop a system for tracking the supply of MTR at gas industry
    enterprises is due to the very complex and time-consuming interaction of supply
    participants who have their separate information systems (IS). Data processing
    in the existing supply system is carried out exclusively centrally using data
    processing Centers (DPC). There was a need to compare data processing processes
    centrally with the help of a data center and decentralized with the help of distributed
    registry technology (blockchain). The results of the comparison are presented
    in Table 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'As can be seen from Table 1, the use of Blockchain technology in data processing
    has significant advantages:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Increasing the level of trust,
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: • Control of the business process by all participants of the process,
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: • Control of user access by consensus decision,
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: • Ensuring the automatically guaranteed fulfillment of contractual obligations
    through the use of smart contracts,
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: • Using the built-in certified cryptographic protection tools (СCPT),
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: • Guaranteed data immutability,
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: • The absence of expensive and security-sensitive DPC,
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: • Using standard communication channels,
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: • Increased reliability due to profound territorial decentralization,
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: • Extensive scaling of the proposed solution based on the use of boxed versions
    of the developed product.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The listed set of very significant advantages is a weighty argument in favor
    of using Blockchain technology.
  prefs: []
  type: TYPE_NORMAL
- en: 'As for the current situation in the existing supply system, as can be seen
    from Figure 1, the existing supply system was completely outdated, redundant,
    and did not meet modern concepts. The main components of a typical information
    system (IS) of an ancient supply chain, shown in Figure 1, are:'
  prefs: []
  type: TYPE_NORMAL
- en: • IS operator;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Operator IS;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • IS of the Customer (gas company);
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • IS of the Transport company;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Manufacturer IS;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • The Inspector IS.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All information systems were heterogeneous. Each gas company created its own
    corporate IS. Communication channels were not standardized. As shown in Figure
    1, during the interaction of the Transport Company's IS ↔ the Customer's IS, and
    the operator IS ↔ the inspector IS, the most archaic methods of communication
    were observed, up to the “pigeon mail”, of course, allegorically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Three types of communication were actively used: telephone (IS of the inspector
    ↔ IS of the Operator), regular mail (IS of the Manufacturer ↔ IS of the Customer),
    paper document management: IS of the Manufacturer ↔ IS of the Operator, IS of
    the Transport Company ↔ IS of the Inspector. Sometimes non-traditional types of
    communication were also used (for example, courier delivery) for the Customer''s
    IS ↔ The Transport Company''s IP. The customers were the largest gas and gas transportation
    companies. Large telecommunications companies acted as operators, logistics operators
    acted as transport companies, metallurgical, and pipe enterprises acted as producers,
    since the main supply was pipe products. The supervisory gas company specially
    created for this purpose acts as an Inspector.'
  prefs: []
  type: TYPE_NORMAL
- en: In this situation, it was decided to reorganize the supply chain. The main goal
    of the reorganization was to create a supply process controlled by a program code
    (a special software platform). The general scheme of the pilot project is shown
    in Figure 2.
  prefs: []
  type: TYPE_NORMAL
- en: Table 1\. Comparison of CDP and blockchain applications in the pilot project
  prefs: []
  type: TYPE_NORMAL
- en: '| No | Requirements for the implementation of the project | Centralized data
    processing (СDP) | The technology of distributed registries |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | The ability to integrate the participant''s IP directly with the data
    storage and processing point in the participant''s infrastructure. | Centralized
    data processing. Disadvantage: the need for all participants to trust the operator.
    | Storage and processing of data for all participants in the process. Advantage:
    there is no need to trust the operator. |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | It is necessary to be able to audit the implementation of the business
    process by all participants . | Closed code that provides a business process.
    Disadvantage: the inability to check the logic of the business process by all
    participants. | Open source code that provides a business process. Advantage:
    the ability to check the logic of the business process by all participants). |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | It is necessary to control the rights of users on the participant''s
    side. | Availability of centralized user access control. Disadvantage: the ability
    to disconnect participants by a centralized solution. | Distributed user access
    control. Advantage: restriction of participants by consensus decision/ |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | Ensuring guaranteed performance of obligations. | Lack of guaranteed
    fulfillment of obligations within the system. Disadvantage: the need to trust
    the developer. | Ensuring guaranteed fulfillment of obligations within the system.
    Advantage: provided by the properties of smart contracts. |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | Ensuring the immutability of historical data over time, the need to differentiate
    data access managed by data owners. | Hashing and encryption. Disadvantage: the
    use of third-party cryptographic tools. It is necessary to purchase certified
    funds. | Hashing and encryption. Disadvantage: the use of third-party cryptographic
    tools. It is necessary to purchase certified funds. |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | Ensuring the immutability of historical data over time. | The operations
    “create”, “read”, “change”, “delete” data are supported. | The “create” and “read”
    data operations are supported. Advantage: immutability of data. |'
  prefs: []
  type: TYPE_TB
- en: '| 7-9 | Reducing the cost of implementing, replicating, and supporting the
    solution. | The need to connect the process participants to the operator''s capacities.
    Disadvantage: loss of control. | Advantage: there is no need to connect participants
    to the operator''s capacities. |'
  prefs: []
  type: TYPE_TB
- en: '| The need for reliable high-speed communication channels. Disadvantage: high
    costs. | Advantage: standard communication channels. |'
  prefs: []
  type: TYPE_TB
- en: '| The need to provide a fault-tolerant infrastructure. Disadvantage: high costs.
    | Reliability is ensured by territorial decentralization. Advantage: the costs
    are distributed to the participants. |'
  prefs: []
  type: TYPE_TB
- en: '| 10 | The need to scale the solution to a large number of participants in
    the process. | Disadvantage: dependence on the operator''s resources. | Advantage:
    scaling depends on the resources of the participants. |'
  prefs: []
  type: TYPE_TB
- en: '| 11 | The need for the legal significance of the transmitted and stored information.
    | Disadvantage non-certified cryptographic means of the EDI operator. | Advantage:
    the presence of certified crypto funds on the platform for two platforms in the
    Russian Federation, three more platforms are being certified. |'
  prefs: []
  type: TYPE_TB
- en: '| 12 | The need to ensure transparency of the project life cycle as a whole,
    including at subsequent stages. | Replication of data at subsequent stages of
    the project lifecycle. Disadvantage: requires integration with the developed solution.
    | Advantage: The ability to replicate data for use by solutions based on blockchain
    platforms from the boxed version. |'
  prefs: []
  type: TYPE_TB
- en: '| Figure 1\. General view of the supply chain |'
  prefs: []
  type: TYPE_TB
- en: '| ![Figure978-1-7998-8697-6.ch011.f01](i/ch011.f01.png) |'
  prefs: []
  type: TYPE_TB
- en: 'The main element of the pilot project is the Product environment; the main
    component is the blockchain platform, which stores a log of all events in the
    system in transactions. In addition, other main components can be distinguished
    in this diagram of the pilot project, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: • Delivery contract;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Production;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Payment;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Input control.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These processes interact with the Blockchain platform through the interfaces
    of the SAP ERP system.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, the following processes also became integral elements of the pilot
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: • Inspection control;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Delivery.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As interfaces for interaction with the Blockchain platform, these processes,
    respectively, use the products developed during the implementation of the pilot
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: • Digital Inspector;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Supply monitor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| Figure 2\. General scheme of the pilot project |'
  prefs: []
  type: TYPE_TB
- en: '| ![Figure978-1-7998-8697-6.ch011.f02](i/ch011.f02.png) |'
  prefs: []
  type: TYPE_TB
- en: In general, the diagram of providing the implemented platform with an entire
    supply lifecycle is shown in Figure 3.
  prefs: []
  type: TYPE_NORMAL
- en: '| Figure 3\. Diagram of providing the implemented platform with an entire supply
    lifecycle |'
  prefs: []
  type: TYPE_TB
- en: '| ![Figure978-1-7998-8697-6.ch011.f03](i/ch011.f03.png) |'
  prefs: []
  type: TYPE_TB
- en: The following stages act as the life cycle stages by the widely used “BUY-SHIP-PAY”
    technology. At the Production stage, a Digital Inspector is used for inspection
    supervision, and its use ensures a complete rejection of paper document management
    during inspections. Obtaining the initial data for the digital inspector is provided
    by objective control sensors that fully cover the entire production process with
    their observation.
  prefs: []
  type: TYPE_NORMAL
- en: At the delivery stage, the use of a Delivery Monitor is provided. It provides
    100% train tracking and accurate cargo arrival forecast. GPS trackers on cars
    are also used for monitoring, providing objective information about the delivery.
  prefs: []
  type: TYPE_NORMAL
- en: Automatic data processing is provided at all stages marked in green using a
    Delivery Tracking System operating on the Blockchain platform.
  prefs: []
  type: TYPE_NORMAL
- en: This system eliminates the majority of paper documents and reduces administrative
    costs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4 shows a diagram of the delivery process before the reorganization
    (“As it was”). The diagram contains the following stages: Placing specifications
    at the factory, Inspection control, shipment and acceptance of products, and Mutual
    settlements.'
  prefs: []
  type: TYPE_NORMAL
- en: '| Figure 4\. Diagram of the delivery process before the reorganization (“As
    it was”) |'
  prefs: []
  type: TYPE_TB
- en: '| ![Figure978-1-7998-8697-6.ch011.f04](i/ch011.f04.png) |'
  prefs: []
  type: TYPE_TB
- en: Figure 5 shows a diagram of the delivery process after the reorganization.
  prefs: []
  type: TYPE_NORMAL
- en: '| Figure 5\. Diagram of the delivery process after the reorganization (“As
    it became”) |'
  prefs: []
  type: TYPE_TB
- en: '| ![Figure978-1-7998-8697-6.ch011.f05](i/ch011.f05.png) |'
  prefs: []
  type: TYPE_TB
- en: The scheme, in general, is almost identical to the one shown in Figure 4\. However,
    significant changes in the stages framed in red in Figure 5 will be noted below.
    Both schemes provide freight forwarding services at the stage of shipment and
    acceptance of products.
  prefs: []
  type: TYPE_NORMAL
- en: For each stage of the delivery process, detailed transaction chains have been
    developed, implemented by the implemented platform. An example of such a transaction
    chain for the first stage of the diagram (see Figure 4) is shown in Figure 6
  prefs: []
  type: TYPE_NORMAL
- en: '| Figure 6\. Inspection control “As it was” |'
  prefs: []
  type: TYPE_TB
- en: '| ![Figure978-1-7998-8697-6.ch011.f06](i/ch011.f06.png) |'
  prefs: []
  type: TYPE_TB
- en: This diagram shows the transaction chains for each performer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Participation in the following transactions is provided for the Gas Company
    (Customer):'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Coordination of production tasks (PT) with the inspection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2\. Coordination of the rules of interaction (RI).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3\. Coordination of the control plan (PCI).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4\. Checking and approving the PT execution report.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Participation in the following transactions is provided for the factory''s
    company:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Coordination RI.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2\. Production schedule preparation with the allocation of a sales order.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3\. Coordination of the control plan (PCI) with the inspection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4\. Sending an inspector request at the plant, gas company, and inspection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5\. Manufacturing, testing, and acceptance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 6\. Discrepancy Resolving.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Participation in the following transactions is provided for the inspection:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Coordination of PT.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2\. RI Development and approval by enterprises and manufacturers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3\. Coordination of the PCI.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4\. Quality control and acceptance of works. Warning of the gas company's report.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5\. Sending the certificate to the manufacturer for shipment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 6\. Discrepancy registration notification.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7\. The quality certificate is approved.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 8\. Formation and direction of TP to a gas company.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The document type is indicated in unique icons (PDF file, MS Excel table, paper
    document, postal item). Transactions are interconnected by links that implement
    the logic of the corresponding business process.
  prefs: []
  type: TYPE_NORMAL
- en: '| Figure 7\. Inspection control “As it became.” |'
  prefs: []
  type: TYPE_TB
- en: '| ![Figure978-1-7998-8697-6.ch011.f07](i/ch011.f07.png) |'
  prefs: []
  type: TYPE_TB
- en: 'Figure 7 shows the business process inspection control transaction diagram
    after the reorganization “As it became.” The logic of the business process has
    not changed. However, the processing of transactions marked in red involves the
    participation of new components of the business process: the Blockchain platform
    and the Digital Inspector. The documents processed by these components are marked
    with the corresponding red icons.'
  prefs: []
  type: TYPE_NORMAL
- en: '| Figure 8\. Model of digital document flow and data exchange of participants
    in contractual relations |'
  prefs: []
  type: TYPE_TB
- en: '| ![Figure978-1-7998-8697-6.ch011.f08](i/ch011.f08.png) |'
  prefs: []
  type: TYPE_TB
- en: 'During the implementation of this stage, a Model of digital document management
    and data exchange of participants in contractual relations was also developed,
    shown in Figure 8\. For each element in the document chain, the document''s title
    is given in the block''s header displaying the document. The lower part of the
    block contains the names of the subjects interacting with this document, performing
    the roles: the drafter of the document (indicated in blue), the recipient of the
    document (indicated in green), and the approving person (indicated in orange).
    The initial document in the chain is indicated in blue, and the final document
    is green. In addition, the sent documents are indicated in black, and the documents
    requiring approval are indicated in orange. The digital document management Model
    developed at this stage significantly simplified code writing at the smart contract
    development stage and helped avoid errors.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then the chains of documentation transactions were developed for the two main
    stages of the pipe product delivery process:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Production of products – Inspection control / Payment of inspection control;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2\. Logistics / Payment for manufacturing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Figure 9 shows an example of a chain of documentation transactions for the
    Production of products – Inspection control / Payment of inspection control stage.
    For each transaction, the name of the forwarded document and the participants
    of the interaction are indicated. In addition, the type of operation is specified
    by the legend: document forwarding (white), control event (red), request (yellow),
    execution (green).'
  prefs: []
  type: TYPE_NORMAL
- en: '| Figure 9\. The chain of documentation transactions at the stage: production
    of products – inspection control / payment of inspection control |'
  prefs: []
  type: TYPE_TB
- en: '| ![Figure978-1-7998-8697-6.ch011.f09](i/ch011.f09.png) |'
  prefs: []
  type: TYPE_TB
- en: The development of documentation transaction chains completes the first stage
    of the pilot project. At the second stage of the pilot project, a comparative
    analysis of blockchain platforms, their testing and the choice of a platform for
    implementation were performed.
  prefs: []
  type: TYPE_NORMAL
- en: COMPARATIVE ANALYSIS OF BLOCKCHAIN PLATFORMS AND THE CHOICE OF A PLATFORM FOR
    IMPLEMENTATION
  prefs: []
  type: TYPE_NORMAL
- en: Information Security Requirements (When Developing Smart Contracts)
  prefs: []
  type: TYPE_NORMAL
- en: According to statistics, more than 70% of smart contracts carry vulnerabilities
    (Report, 2019). There is not yet a proven software package that allows you to
    fully investigate the code of smart contracts by static and dynamic analysis in
    a fully automatic mode and find vulnerabilities (Shapiev, 2019) in them that can
    cause harm in millions of dollars.
  prefs: []
  type: TYPE_NORMAL
- en: Blockchain technology has tremendous popularity and is being implemented everywhere.
    In static code analysis, the program is analyzed without its actual execution
    and dynamic analysis in the execution process. In most cases, static analysis
    means analysis carried out using automated source or executable code tools, performed
    without running the program.
  prefs: []
  type: TYPE_NORMAL
- en: This term is usually applied to analysis performed by automated tools, and human
    analysis is called program concept, program understanding, or code mapping. In
    most cases, the analysis is performed on different versions of the source code.
    Since the Solidity programming language and the term smart contract itself is
    pretty new and used directly in the modern sphere of the crypto economy, many
    potential vulnerabilities can lead to substantial financial losses. Thus, the
    developer of a smart contract, or an entire project, is obliged to pay attention
    to checking his code for vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the moment, the dynamic analysis of smart contracts is reduced to checking
    the code in actual conditions, either in the blockchain platform or in its test
    version. In general, dynamic code analysis is a method of analyzing program code
    directly during its execution. The process of dynamic analysis can be divided
    into several stages:'
  prefs: []
  type: TYPE_NORMAL
- en: • Preparation of source codes;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Conducting a trial run of the code and collecting the necessary information;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Analysis of the extracted data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'During the trial run, we can execute the program on both real and virtual simulators.
    In this case, we must obtain the executable file from the source code. It is impossible
    to analyze the code containing problems of compiling or assembling the file in
    this way. With the help of dynamic analysis, the following data can be obtained:'
  prefs: []
  type: TYPE_NORMAL
- en: • Resources used - the execution time of the code as a whole or its modules;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Number of web requests;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Cyclomatic complexity;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Code errors;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Memory leaks;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Vulnerabilities in the code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The dynamic analysis allows you to ensure that the project is working well or
    identifies errors, showing that it is necessary to fix them. Dynamic analysis
    is more advantageous from the point of view of improving quality since it does
    not allow you to lose sight of the program's shortcomings, as, for example, with
    static analysis. However, even if no defects were detected during the analysis,
    this does guarantee no “100%”defects since the full coverage of the program with
    tests does not mean that there are no errors in the code since the dynamic analysis
    cannot detect logical errors.
  prefs: []
  type: TYPE_NORMAL
- en: Simplified Methodology for Finding Vulnerabilities in Smart Contracts
  prefs: []
  type: TYPE_NORMAL
- en: 'To write a secure functioning smart contract, you need to go through several
    stages of security development:'
  prefs: []
  type: TYPE_NORMAL
- en: • Design,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Development,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Testing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design (Writing a Specification)
  prefs: []
  type: TYPE_NORMAL
- en: This process is also called the development of system requirements. Before writing
    a smart contract, you need to describe its concept, actions, processes, and interaction.
    It is worth discussing these actions with the customer and approving all the requirements.
    Next, define the plan and the dependence of the processes in the smart contract.
    Analyze all current vulnerabilities and think about the security of operations.
  prefs: []
  type: TYPE_NORMAL
- en: Development
  prefs: []
  type: TYPE_NORMAL
- en: This stage consists of the process of implementing smart contracts. To successfully
    write secure code, you need to analyze the current vulnerabilities in code development
    and the features of the development language. It is essential to do this before
    writing it since it will be difficult to fix errors and vulnerabilities in the
    code in the future. After that, you can start writing secure code.
  prefs: []
  type: TYPE_NORMAL
- en: Testing
  prefs: []
  type: TYPE_NORMAL
- en: This stage is testing and investigating the written code of a smart contract
    for the presence of vulnerabilities. For this stage, the developer can write tests
    independently. Still, it will be much easier to use a ready-made set of tests,
    thanks to which you can find vulnerabilities in smart contracts.
  prefs: []
  type: TYPE_NORMAL
- en: We should be borne in mind that a full security check costs a lot of money.
    Therefore, it will also take time. Consequently, it is always easier to write
    and initially secure a contract than to fix vulnerabilities later. It is also
    possible to use external audits at this stage. A visual representation of the
    actions for implementing a secure and functioning smart contract in the IDEF0
    methodology has the form shown in Figure 10.
  prefs: []
  type: TYPE_NORMAL
- en: '| Figure 10\. Stages of developing a secure smart contract |'
  prefs: []
  type: TYPE_TB
- en: '| ![Figure978-1-7998-8697-6.ch011.f10](i/ch011.f10.png) |'
  prefs: []
  type: TYPE_TB
- en: The next stage is the development of secure code. For this, you will need a
    method for ensuring the security of a smart contract. In addition, a security
    specialist is engaged in the development, which creates a security task, and at
    the exit from this stage, a secure code should appear.
  prefs: []
  type: TYPE_NORMAL
- en: The last stage in the IDEFO methodology (functional modeling methodology and
    graphical notation intended for formalization and description of business processes)
    is testing, where the testing procedure is the control tool, and the developer
    and test programs, analyzers are the mechanism. In the end, after passing all
    the stages, a secure smart contract is obtained.
  prefs: []
  type: TYPE_NORMAL
- en: Structure of the Methodology
  prefs: []
  type: TYPE_NORMAL
- en: As it was written above, this security technique is needed to develop a secure
    smart contract code. A smart contract (using the example of Ethereum) is developed
    in a specially created Solidity language (Official, 2018), (Dannen, 2018). It
    is a statistically typed JavaScript-like programming language.
  prefs: []
  type: TYPE_NORMAL
- en: For convenience, the methodology was divided into three parts. The user of the
    method will write a properly functioning and secure smart contract code simply.
  prefs: []
  type: TYPE_NORMAL
- en: 'The methodology includes three stages:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Study and understanding of known code writing vulnerabilities that are not
    related to the solidity programming language and the blockchain environment, but
    which are also relevant in these areas;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2\. Features of the solidity language, without which a smart contract working
    will not work;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3\. Recommendations for the correct and safe functioning of smart contracts
    in the EVM Ethereum itself.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A visual representation of the methodology plan is shown in Figure 11.
  prefs: []
  type: TYPE_NORMAL
- en: '| Figure 11\. The plan of the methodology for ensuring the security of a smart
    contract |'
  prefs: []
  type: TYPE_TB
- en: '| ![Figure978-1-7998-8697-6.ch011.f11](i/ch011.f11.png) |'
  prefs: []
  type: TYPE_TB
- en: Vulnerabilities and Problems that Arise When Writing Smart Contracts
  prefs: []
  type: TYPE_NORMAL
- en: The security of smart contracts must be reliably ensured. There are many examples
    of how the vulnerabilities of smart contracts lead to very significant economic
    losses, and here are just two examples.
  prefs: []
  type: TYPE_NORMAL
- en: Just following intuition instead of best practices may only lead to unwanted
    loopholes. The well-known DAO (Decentralized Autonomous Organisation) hack can
    be considered a prime example of overlooked side effects in smart contracts. The
    Ethereum-based DAO began as the world's largest crowd-funding project yet quickly
    turned into one of the most memorable failures when exploiting a recursive call
    pattern resulted in the sudden removal of DAO funds. The following hard fork of
    the Ethereum blockchain to undo the damage of over $50 million (see https://www.zeit.de/digital/internet/2016-06/the-dao-blockchain-ether-hack)
    only fueled controversy.
  prefs: []
  type: TYPE_NORMAL
- en: Just as severe, with damage totaling $30 million (see https://www.coindesk.com/30-million-ether-reported-stolen-parity-wallet-breach),
    was the Parity wallet breach related to Ethereum in July 2017\. Careless use of
    a delegate call command in a critical library enabled the attacker to gain ownership
    of a multi-signature wallet and to redirect all of its funds
  prefs: []
  type: TYPE_NORMAL
- en: For a smart contract to be secure and an attacker could not break it or send
    tokens to himself, you need to remember typical and well-known errors when writing
    code for applications. It is especially true for smart contracts since the developer
    will not correct mistakes after sending them to the blockchain in the future.
  prefs: []
  type: TYPE_NORMAL
- en: 'Below is an up-to-date list of errors that we can use to avoid for the correct
    operation of programs, namely smart contracts, with explanations:'
  prefs: []
  type: TYPE_NORMAL
- en: • Buffer overflow is one of the most well-known computer systems and application
    hacking methods available in smart contracts. A phenomenon that occurs when an
    application or program writes data outside of the buffer allocated in memory.
    Overflow occurs due to incorrect work with the entered data and the memory allocated
    for them and in the absence of strict protection on the part of the application
    for the entered values. Since smart contracts can read the user's data, you need
    to remember the restriction of the data entered. If you restrict the buffer in
    the array when creating it and do not check what the user entered, then an attacker
    has a chance to rewrite part of the smart contract, respectively, to get data
    or access to it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '• Vulnerability of using format strings. These are errors when there is no
    control over the input-output field and the use of a format string, thanks to
    which the input-output of arguments occurs. Therefore, it is possible to compromise
    the processor''s memory: getting password values, addresses. The user can access
    it and write values to the memory cells, thanks to which a buffer overflow is
    possible. And it is also possible to get data from any memory area that the processor
    can process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Checking the arguments. The developer should understand that the user can
    enter anything in the smart contract input field. The user can enter data that
    can be interpreted into the program and change something meaningful that can disrupt
    the operation of the smart contract or can execute arbitrary code. You should
    limit the data entered or provide for the output of errors with explanations.
    The data may not fall within the acceptable interval, especially true with smart
    contracts since the process may affect financial transactions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Vulnerabilities of corrupted input. They also occur in cases when the data
    entered by the user is transmitted to the interpreter without sufficient control.
    The user can set the input data so that the running interpreter will execute a
    completely different command that the authors of the vulnerable program intended.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specific Vulnerabilities and Errors Affecting the Security of Smart Contracts
    Written in the Solidity Language
  prefs: []
  type: TYPE_NORMAL
- en: 'Visibility and Delegate Call: In solidity, as in other programming languages,
    the functions public and private are provided. Anyone can call the first ones,
    the second ones can be reached only within the contract. There is a handy Delegatecall
    function. It is the basis for implementing libraries and modular code. It also
    allows you to load code from another address at runtime dynamically. The storage,
    current address, and balance are still related to the calling contract, and only
    the code is taken from the called address. However, it has vulnerabilities since
    an attacker can gain access to the contract ownership with the owner function
    during the delegation process. So when using the Delegate function, you need to
    be careful and check what it interacts with function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Front-Running Attack: In the blockchain, all transactions are processed and
    recorded in the block by miners. There is a pool of transactions, and usually,
    the miner arranges them in the order of the commission and then processes them.
    Therefore, an attacker can view all transactions, find the right one and send
    the same one. Still, with a higher commission, his transaction will be in priority,
    and there is a high probability that it will be processed and written to the block
    faster than the first transaction. This vulnerability is especially relevant in
    lotteries and sweepstakes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sending the Ether to the Contract: Solidity has a self-destruct function: it
    deletes the smart contract and sends all tokens to a specific address. The nuance
    is that the address may be a contract whose backup function may not be performed.
    That means that if a contract function has a conditional operator that depends
    on the fact that the balance of this contract is below a certain amount, this
    operator can potentially be bypassed by the user. If you send a return function,
    the contract cannot receive ether, but the backup function is not called if you
    select the self-destruct contract as the target. So it would be best if you never
    used the contract balance as a means of protection.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Calling the Unknown: In this case, the attacker''s contract can first claim
    leadership by sending a sufficient amount of ether to an insecure contract. Then
    the transactions of another player who tries to claim the leadership will be rejected
    due to the revert function. Despite a simple attack, this leads to permanent denial
    of service of the contract, which makes it useless.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Small Address Attack: Since the user can work with the exchange, he can enter
    an incorrect address, which is less in the number of bits. Since a fixed-length
    string is fed to the EVM, the EVM complements it with insignificant zeros if the
    string is smaller than it. Accordingly, the number of tokens may change because
    of this in the encoding. And the entry in the blockchain will not be at all the
    one that the user wanted. It is important to check for the correct number of characters
    in the address in the smart contract, and if this check is not passed, then do
    not carry out transactions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples of the source texts of smart contracts in which the
    vulnerabilities are present:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Race Condition Type: The vulnerability lies in the possibility of calling the
    external code again, during the execution of the contract code. This can lead
    to different function calls interacting in destructive ways. Example of a smart
    contract code with this vulnerability:'
  prefs: []
  type: TYPE_NORMAL
- en: 1     mapping (address} =˃ uint) private userBalances;
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: 3 ▼     function wthdrawBalance() public {
  prefs: []
  type: TYPE_NORMAL
- en: 4          uint amountToWithdraw = userBalances[msg.sender];
  prefs: []
  type: TYPE_NORMAL
- en: 5          require(msg.sender.call.value(amountToWithdraw)(); // 1
  prefs: []
  type: TYPE_NORMAL
- en: 6 ▼     /* In line 1, the external code is called, which can be called again
  prefs: []
  type: TYPE_NORMAL
- en: 7      until the end of the first call */
  prefs: []
  type: TYPE_NORMAL
- en: 8          userBalances[msg.sender] = Ø;
  prefs: []
  type: TYPE_NORMAL
- en: 9     }
  prefs: []
  type: TYPE_NORMAL
- en: 'Dependence on the timestamp. When writing a smart contract, you need to keep
    in mind that the node offering the next block can write a timestamp into it based
    on its interests. Thus, it can influence the execution of a contract relying on
    the timestamp value in its code. Example of a smart contract code with this vulnerability:'
  prefs: []
  type: TYPE_NORMAL
- en: 1     uint someVariable = now + 1;
  prefs: []
  type: TYPE_NORMAL
- en: 2 ▼     if (now % 2 == Ø) { // now installed by the miner
  prefs: []
  type: TYPE_NORMAL
- en: 3          // important code
  prefs: []
  type: TYPE_NORMAL
- en: 4     }
  prefs: []
  type: TYPE_NORMAL
- en: 5 ▼     if ((someVariable - 1ØØ) % 2 == Ø) { // someVariable depends on now
  prefs: []
  type: TYPE_NORMAL
- en: 6          // important code
  prefs: []
  type: TYPE_NORMAL
- en: 7     }
  prefs: []
  type: TYPE_NORMAL
- en: 'Data type overflow. Data type overflow is dangerous because the value change
    may occur according to logic not provided by the developer. This vulnerability
    can occur both with the upper bound of the data type and with the lower one. Example
    of a smart contract code with this vulnerability:'
  prefs: []
  type: TYPE_NORMAL
- en: 1     mapping (addres =˃ uint256) public balanceOf
  prefs: []
  type: TYPE_NORMAL
- en: 2     // Unsafe option
  prefs: []
  type: TYPE_NORMAL
- en: 3 ▼     function transfer(addres _to, uint256 _value) {
  prefs: []
  type: TYPE_NORMAL
- en: 4 ▼          /* Checking the availability of the amount to send */
  prefs: []
  type: TYPE_NORMAL
- en: 5          require(balanceOf[msg.sender] =˃ _value);
  prefs: []
  type: TYPE_NORMAL
- en: 6 ▼          /* Add and subtract new balances */
  prefs: []
  type: TYPE_NORMAL
- en: 7          balanceOf[msg.sender] -= _value;
  prefs: []
  type: TYPE_NORMAL
- en: 8          balanceOf[_to] += _value;
  prefs: []
  type: TYPE_NORMAL
- en: 9     }
  prefs: []
  type: TYPE_NORMAL
- en: 10     // Safe option
  prefs: []
  type: TYPE_NORMAL
- en: 11 ▼     function transfer(addres _to, uint256 _value) {
  prefs: []
  type: TYPE_NORMAL
- en: 12 ▼     /* Checking the availability of the amount to send and checking for
    overflow */
  prefs: []
  type: TYPE_NORMAL
- en: 13          require(
  prefs: []
  type: TYPE_NORMAL
- en: 14          balanceOf[msg.sender] -=value &&
  prefs: []
  type: TYPE_NORMAL
- en: 15          balanseOf[_to} + _value >= balanceOf[_to]
  prefs: []
  type: TYPE_NORMAL
- en: 16          );
  prefs: []
  type: TYPE_NORMAL
- en: 17 ▼     /* Change Balances */
  prefs: []
  type: TYPE_NORMAL
- en: 18          balanceOf[msg.sender] -= _value;
  prefs: []
  type: TYPE_NORMAL
- en: 19          balanceOf[_to] += _value;
  prefs: []
  type: TYPE_NORMAL
- en: 20     }
  prefs: []
  type: TYPE_NORMAL
- en: Justification of the Choice of Tested Platforms
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on all the collected data, it can be concluded that it is advisable to
    test the following number of platforms:'
  prefs: []
  type: TYPE_NORMAL
- en: 1) Hyperledger;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2) Corda;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3) Apla;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4) Exonum;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5) Universa;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 6) Quorum.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Currently, the developers of all platforms listed above may change the concept
    or release. The main criterion is the availability of a distribution kit (a significant
    version according to the platform's numbering of software versions). As it turned
    out, not all platforms have reached the stage of a major public release. Also,
    each of the above platforms has a test network that will allow you to conduct
    load testing with minimal costs to purchase internal cryptocurrency or platform
    tokens. Due to this circumstance, it is essential to make a basic configuration
    of each platform and identify potential aspects for testing.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, we can conclude that now we have selected platforms that close
    the list of tasks from the point of view of technologies - a centralized database,
    the main functional criteria of which are to prevent downtime, the same results
    of processing identical transactions, the availability of protection mechanisms
    against forgery, transaction rollbacks and violations of legitimacy.
  prefs: []
  type: TYPE_NORMAL
- en: Security Requirements (Authentication and Access Control Methods, Logging, Corporate
    Certificates)
  prefs: []
  type: TYPE_NORMAL
- en: The comparative characteristics of the platforms under consideration are presented
    in Table 2.
  prefs: []
  type: TYPE_NORMAL
- en: Table 2\. The results of the comparison of blockchain platforms.
  prefs: []
  type: TYPE_NORMAL
- en: '| Requirement | Hyperledger Fabric | Corda | Waves Vostok | Apla | Ethereum
    |'
  prefs: []
  type: TYPE_TB
- en: '| Availability of an authentication mechanism with the possibility of integration
    with the LDAP directory service | Carried out by the development Integration module
    | Identically | Identically | Carried out by the development Integration module
    (it is possible to use built-in tools) | No information available |'
  prefs: []
  type: TYPE_TB
- en: '| Availability of access control mechanisms (DAC RB AC) | There is no need
    to develop an integration module | Identically | Identically | It has an access
    control mechanism | No information available |'
  prefs: []
  type: TYPE_TB
- en: '| Availability of a system for logging events occurring in the system | The
    blockchain contains a transaction log that various existing systems can analyze
    | Identically | Identically | Identically | No information available |'
  prefs: []
  type: TYPE_TB
- en: '| Availability of a notification system (alarm system) about events occurring
    in the system | It is carried out through the development of an integration module
    | Identically | Identically | Identically | No information available |'
  prefs: []
  type: TYPE_TB
- en: '| The possibility of using SHA-3 as a cryptographic hash function | Open Sours,
    modification required | SHA-256 is used; changing the algorithm is possible only
    in the open version (not Enterprise) | SHA-256 is used, a closed platform, it
    is impossible to change the hash function | SHA-256 is used, the possibility of
    changing the hash function is not defined | No information available |'
  prefs: []
  type: TYPE_TB
- en: '| The ability to import corporate certificates for signing transactions | There
    is a possibility of implementation | There is no possibility | Identically | Identically
    | No information available |'
  prefs: []
  type: TYPE_TB
- en: '| Requirement | Masterchain | Bifury Exonum | SAP Leonardo | Universa | Quorum
    |'
  prefs: []
  type: TYPE_TB
- en: '| Availability of an authentication mechanism with the possibility of integration
    with the LDAP directory service | No information available | Carried out by the
    development Integration module | No information available | Carried out by the
    development Integration module. The function is under development. | Carried out
    by the development Integration module |'
  prefs: []
  type: TYPE_TB
- en: '| Availability of access control mechanisms (DAC RB AC) | There is no mechanism
    | There is no need to develop an integration module | No information available
    | There is no mechanism, feature in the development | There is no need to develop
    an integration module |'
  prefs: []
  type: TYPE_TB
- en: '| Availability of a system for logging events occurring in the system | The
    blockchain contains a transaction log that various existing systems can analyze
    | Identically | No information available | Identically | Identically |'
  prefs: []
  type: TYPE_TB
- en: '| Availability of a notification system (alarm system) about events occurring
    in the system | It is carried out through the development of an integration module
    | Identically | No information available | Identically | Identically |'
  prefs: []
  type: TYPE_TB
- en: '| The possibility of using SHA-3 as a cryptographic hash function | No information
    available | Modification is required; SHA-3 is not implemented by default in the
    platform | No information available | The hashing method is not defined in the
    documentation | There is a possibility of using SHA-3 |'
  prefs: []
  type: TYPE_TB
- en: '| The ability to import corporate certificates for signing transactions | No
    information available | There is no possibility | No information available | There
    is no possibility | Identically |'
  prefs: []
  type: TYPE_TB
- en: METHODS AND MEANS OF FORMAL VERIFICATION OF THE PROGRAM CODE OF SMART CONTRACTS
  prefs: []
  type: TYPE_NORMAL
- en: Verification of the program code is verifying the results of its work for compliance
    with specifications (requirements formulated from the outside).
  prefs: []
  type: TYPE_NORMAL
- en: In the formulation of the problem of this work, the concept of verification
    is not used in a strictly mathematical sense. Verification, in the strict sense,
    really works with ready-made requirements received from the outside. In addition
    to verifying compliance, it implies a preliminary analysis of the subject area
    and identification of requirements that contribute to the most secure functioning
    of contracts.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the requirements, each smart contract has a specific business
    logic, the requirements for which can only be collected separately. Verification
    of specific requirements for adequacy, unambiguity, completeness, consistency,
    and other important properties can only be carried out separately for each smart
    contract and verification of the smart contract code for compliance with these
    specific requirements.
  prefs: []
  type: TYPE_NORMAL
- en: The process of collecting and analyzing business requirements is a separate
    task, different from the task of this work. Formal verification of program code
    is a more strict concept, meaning formal proof of compliance or non-compliance
    of the code results with formal specifications.
  prefs: []
  type: TYPE_NORMAL
- en: Currently, three approaches to formal verification of programs are most widely
    used •
  prefs: []
  type: TYPE_NORMAL
- en: • Symbolic execution,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Checking models,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Verification using automatic proof of theorems.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these approaches should be discussed in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Symbolic Execution
  prefs: []
  type: TYPE_NORMAL
- en: The main idea of symbolic execution is that if the value of a variable is unknown,
    then when analyzing the code, it is indicated by some symbol, and further operations
    with this variable are performed as operations with this symbol.
  prefs: []
  type: TYPE_NORMAL
- en: It turns out that the whole process of reasoning, in this case, can be represented
    as an algorithm, which means that it can be done automatically, which is successfully
    used by many modern verifiers. With automatic verification, the conditions for
    the values of variables are formed somewhat differently. All possible branches
    of the program execution are sorted out one by one. When analyzing each branch,
    a set of conditions is compiled for the values of variables under which the program
    follows this branch. When each new condition appears, the entire set of conditions
    is checked for satisfiability.
  prefs: []
  type: TYPE_NORMAL
- en: If it turns out that many conditions are impossible at some point, it means
    that the program cannot follow this branch. The conditions are checked for feasibility
    by the SMT (Satisfaction Modulo Theories) solver.
  prefs: []
  type: TYPE_NORMAL
- en: 'Symbolic execution gives very decent results, applicable in practice, for real
    industrial programs. For example, the Microsoft SAGE system uses the symbolic
    execution approach, which is used to verify various Microsoft products: both typical
    applications, such as PowerPoint, and the Windows operating system itself. Of
    course, in the verifiers used in practice, the analysis process is complex and
    non-trivial, and real verifiers use various optimizations to simplify this process.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A PVS-static code analyzer in C, C++, C#, and Java is designed mainly to help
    developers in these languages. One of the ideas used in its work is symbolic execution.
    Symbolic execution serves as the basis for many verifiers designed for analyzing
    a variety of programs. There are tools for analyzing smart contracts of the Ethereum
    network that use symbolic execution: Mythril, Oyente, Manticore (it also allows
    you to analyze ELF files). We should also mention SMT-solvers, without the use
    of which no tool for symbolic execution can do.'
  prefs: []
  type: TYPE_NORMAL
- en: Software code verification systems refer to such solvers as Z3, Spacer, Cvc3,
    Yices, Alt-Ergo, Gappa, veriT. SMT solvers are used in symbolic execution and
    in other approaches, which will be discussed later.
  prefs: []
  type: TYPE_NORMAL
- en: Checking Models
  prefs: []
  type: TYPE_NORMAL
- en: 'This approach is based on the fact that the system''s behavior is represented
    in a specific model. As a rule, the model describes the system in a simplified
    form. The behavior of the described model must be checked for compliance with
    specific regulations that must be set along with the model itself. When it comes
    to the verification of temporal (ital. - the tempo of models that take into account
    cause-and-effect relationships in time conditions), the rules for compliance with
    which the behavior of the model is checked take into account the time aspect.
    This means that in the formulations of the rules, there are such concepts as “never,”
    “always,” “ever,” “eventually.” Examples of such rules are the following statements:
    “the balance of a certain account will never be zero”, “if a message is sent,
    it will eventually be processed”.'
  prefs: []
  type: TYPE_NORMAL
- en: Verifiers that implement model verification are based on a serious scientific
    theory, described step by step (Velder et al., 2011). Different verifiers based
    on model verification use different working schemes. It would be superfluous to
    dwell in detail on the theory of mathematical logic and consider all the algorithms
    used by different tools for the overview part so that we will give one of the
    verification schemes used, in particular, by the SPIN verifier.
  prefs: []
  type: TYPE_NORMAL
- en: 'The user describes the system''s behavior in the built-in programming language
    (in the case of SPIN, the Promela language). The verifier looks at the system
    being checked as a finite automaton, each state is characterized by a set of values
    of all global variables. The user also sets rules (statements that take into account
    the time aspect). For compliance, you need to check the system''s behavior. By
    negating these statements, another finite automaton is constructed specially.
    Then the intersection of the languages generated by these two automata is constructed.
    If the intersection is empty, the verification was successful since the negations
    of the rules we set cannot come true. If the intersection is not empty, it serves
    as an example of a case when the system''s behavior violates the rules we have
    set. Many verifiers are based on checking temporal models: SPIN (the most famous),
    Eldarica, Uppaal, NuSMV.'
  prefs: []
  type: TYPE_NORMAL
- en: Automatic Proof of Theorems
  prefs: []
  type: TYPE_NORMAL
- en: In the most general terms, verification using automatic proof of theorems looks
    like this.
  prefs: []
  type: TYPE_NORMAL
- en: Both the system specification and its implementation are written as formulas
    in a certain logic. Let's denote the specification formula φ, the implementation
    formula - ψ. We need to check the expression ψ→φ for truth. The system meets the
    specifications if and only if this expression is true. For the proof ψ→φ, programs
    for automatic proof of theorems are used. Such programs are based on a theory
    developed by mathematical logic. Many algorithms used for automatic verification
    of theorems belong to the same theory. Here we will present a very brief introductory
    introduction to mathematical logic. Automated theorem-proving programs usually
    use first-order predicate logic. There is a complete set of variables in this
    logic, a set of functional and predicate symbols of a given arity. Arity refers
    to the number of arguments of a functional or predicate symbol.
  prefs: []
  type: TYPE_NORMAL
- en: A term is a variable or string of the form f(t[1], t[2],..., t[n]), where f
    is the functional symbol of arity n and t[i] are terms. Constants can be considered
    as functions of arity 0\. The predicate has the form P(t[1], t[2],..., t[n]),
    where P is the predicate symbol of arity n, and t[i] are terms.
  prefs: []
  type: TYPE_NORMAL
- en: Propositions are predicates, logical combinations of propositions or propositions
    equipped with quantification of existence or universality. There are also many
    types of typed logic, and each variable has a type. Each function symbol has many
    argument types and a result type, and each predicate symbol has many argument
    types but no result type. Quantifications in this logic are also typed.
  prefs: []
  type: TYPE_NORMAL
- en: In predicate logic, there are rules for inference and obtaining consequences,
    according to which the validity of one or more sentences follows the validity
    of another sentence. The algorithm for automatic proof of theorems is reduced
    to the application of these inference rules. Automatic proof requires inference
    rules and a strategy for how to search for proof. For example, a strategy may
    suggest using inference rules from the end, starting with the sentence that needs
    to be proved.
  prefs: []
  type: TYPE_NORMAL
- en: The strategies used by the programs for proving theorems are based on algorithms
    for traversing in width and depth. The proof problem has twice the exponential
    complexity concerning the length of the sentence being proved. That is why automatic
    proof programs are usually interactive since, in this case, the user can help
    the program build a proof, which significantly reduces the complexity of the task.
  prefs: []
  type: TYPE_NORMAL
- en: Interaction with the automatic proof system requires a highly qualified user.
  prefs: []
  type: TYPE_NORMAL
- en: We note Coq, Simplify, Isabelle/HOL, HOL 4, HOL Light, Mizar among the tools
    for automatic proof used to verify program code.
  prefs: []
  type: TYPE_NORMAL
- en: Protection of Hyperleger and Exonum Services from Errors
  prefs: []
  type: TYPE_NORMAL
- en: 'In writing the functions of Hyperleger and Exonum smart contracts, which describe
    some business logic for working with objects stored in the blockchain, the programmer
    may make mistakes. Some of these errors can be found by the compiler itself and
    will be eliminated in time. Others can lead to the following consequences:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Emergency stop of the blockchain node. A program that implements the node's
    logic and executes the code of the services can terminate and output an error.
    Implementing the code of services on Rust, Exonum or Golang platforms in Hyperleger
    may happen because the situations of calling the panic function were not correctly
    handled, or the functions that explicitly cause panic were not taken into account.
    For services in Java, Node.js, this situation may occur due to non-intercepted
    exceptions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2\. Emergency termination of an external API call that changes the network state
    or does not change it. Similar to the previous case, there may be a situation
    when the REST API request handler will not be able to terminate correctly. This
    will not cause the node to stop, but the program executing the request will not
    receive an error message or a result.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3\. The node hangs. If the transaction processing function has a high computational
    complexity or enters an erroneous state with an eternal cycle, the network nodes
    will not be able to perform the transaction.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4\. The external API handler freezes. In case of a programmer error, the external
    REST API handler thread may never be complete, or it will run for an unacceptably
    long time, consuming the resources of network nodes. The Hyperleger and Exonum
    blockchains are private, and only a limited set of nodes can create transactions
    in them. Therefore, they do not have a built-in mechanism for protecting against
    DOS, and all responsibility for the absence of such situations falls on the programmer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5\. Littering of the network. Since the smart contract can make transactions
    in calculating the next block, the network can constantly increase the size of
    the blockchain indefinitely.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 6\. Invalid calls inside transaction calculation functions. Functions that calculate
    transactions should not depend directly or indirectly on external data sources
    since transactions should result on any node.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7\. Recursive calls between the functions of smart contracts can violate the
    logic of their operation or an eternal loop in the handler thread.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 8\. Inconsistency of transaction calls. The service can store data both locally
    on each node and globally. In the Exonum blockchain, the hash of the current state
    of the service is returned by the state_hash function; in Hyperleger, the PutState
    function writes the data stored in blocks. At the same time, you need to carefully
    ensure that the data loaded into the blocks does not depend on the local data
    stored on the node. Otherwise, each node of the network will calculate it differently,
    and the transaction will not be consistent when the block is enabled.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some of the errors described above are listed in the DASP-10 list compiled for
    the Ethereum blockchain. Due to the richer execution model of smart contracts
    (services) compared to Ethereum, other errors in writing functions become possible
    in the Hyperleger and Exonum blockchains.
  prefs: []
  type: TYPE_NORMAL
- en: It is necessary to perform thorough testing of the services to avoid the occurrence
    of these errors. However, insufficiently large projects, it becomes more difficult
    to find an error using tests. The reason is that tests can check only a finite
    set of program execution paths. When adding new functions and branches to the
    code, the number of input data variants that need to be included in the test grows
    non-linearly. A combinatorial explosion of variants occurs.
  prefs: []
  type: TYPE_NORMAL
- en: Recommendations for Developing a Methodology for Formal Verification of Smart
    Contracts
  prefs: []
  type: TYPE_NORMAL
- en: 'As a result of the analysis of the languages of development of services of
    the Hyperleger and Exonum platforms, the following conclusions were made:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. You need to verify the transaction functions and event handler functions
    separately. Transaction functions should be calculated the same way on different
    nodes, and at other times, the values returned to it should not depend on the
    node's local memory or external data. The verification method should check this
    and allow you to deal with such errors. Handler functions can use both local variables
    and freely access external data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2\. Denial of Service check. It is necessary to take into account all situations
    when the service may be blocked. For each cycle, it is essential to estimate the
    number of iterations for recursion to evaluate its depth. In the Golang and Rust
    languages, avoiding all constructs that explicitly or implicitly cause panic is
    necessary. In the Java language, it is essential to catch all exceptions. The
    verifier must detect all situations that can lead to hanging any called function
    of the contract or their combinations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '3\. Access control. Although blockchains are private, and a limited set of
    nodes can make transactions in them, it is necessary to consider the risk of an
    attack on such nodes. There are no built-in authentication tools for transaction
    requests in blockchains; there is only a way to confirm such a right through the
    public key mechanism:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a. There are three types of REST API requests in Exonum. The first type is public
    read requests; any client can make them, they do not change the state of the blockchain,
    but they can change the state of local node variables. The second type is requests
    for transactions, and they must be signed with private keys. The third is administrative
    requests for configuring contracts. The secrecy of storing private keys ensures
    security. At the same time, access to the node itself is not provided by additional
    authentication mechanisms.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: b. The Hyperledger Fabric blockchain supports authentication in the parallel
    Hyperleger composer (OAuth) and fabric-rest (JWT) projects.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Following the service's business logic, the verification method should detect
    potential opportunities for violating access rights to contract functions.
  prefs: []
  type: TYPE_NORMAL
- en: When building smart contracts for the Hyperleger and Exonum platforms, it is
    necessary to perform automated verification. You need to use either ready-made
    verification utilities (Java) or develop specialized verification tools for verification.
    The conditions to be checked must be drawn up following the requirements of business
    logic and to verify the correctness of the operation of the blockchain itself.
    The verification algorithm should look like a set of mandatory requirements applied
    to the functions responsible for supporting the execution of transactions and
    for processing network events.
  prefs: []
  type: TYPE_NORMAL
- en: CONCLUSION
  prefs: []
  type: TYPE_NORMAL
- en: 'The presented chapter discusses the materials of a pilot project to create
    a supply efficiency management system using blockchain technology. The description
    of the project begins with the study of the main business processes of the supply
    chain. A detailed description and visualization of functions for all system participants
    is given: the customer, the manufacturer, the inspection, the transport company.
    The system''s main components are considered: a digital dispatcher, a supply monitor,
    interaction interfaces, and a production environment. A detailed comparative analysis
    of the security of most modern blockchain platforms is also presented. A distinctive
    feature is a thorough review of the technology for creating and ensuring the secure
    implementation of decentralized applications and smart contracts. The author offers
    a step-by-step method for implementing secure smart contracts. At the end of the
    chapter, the selection results of the most secure blockchain platforms are presented.
    The successful implementation of the pilot project confirmed the possibility of
    using blockchain technology in supply chain management. It showed prospects for
    further using the potential of blockchain and replicating the experience gained.
    Blockchain in the supply chain has allowed creating an ecosystem for the interaction
    of all participants in the process, such as the manufacturer, inspector, logistics
    operator, warehouse, and consumer. The approach discussed in the chapter certainly
    has the potential to develop and further apply blockchain technology.'
  prefs: []
  type: TYPE_NORMAL
- en: REFERENCES
  prefs: []
  type: TYPE_NORMAL
- en: 'Ahmed, A. A., Bassem, A. A., Irfan, M., Khan, M., Salvador, E. V., & Jialiang,
    P. (2021). Quantum-inspired blockchain-based cybersecurity: Securing smart edge
    utilities in IoT-based smart cities. Information Processing & Management , 58(4),
    102549\. doi:10.1016/j.ipm.2021.102549'
  prefs: []
  type: TYPE_NORMAL
- en: 'Chris, J. S. (2017). Who will be killed by blockchain: 4 small business areas
    that will soon disappear. https://incrussia.ru/understand/kogo-ubet-blokchejn-4-sfery-malogo-biznesa-kotorye-skoro-ischeznut/'
  prefs: []
  type: TYPE_NORMAL
- en: Dannen, K. (2018). Introduction to Ethereum and Solidity . Samizdat.
  prefs: []
  type: TYPE_NORMAL
- en: Egorov, V. (2021). Gazprom Neft sells its blockchain platform in the form of
    an NFT token. (https://beincrypto.ru/gazprom-neft-prodaet-reliz-sobstvennoj-blokchejn-platformy-v-vide-nft-tokena/)
  prefs: []
  type: TYPE_NORMAL
- en: 'Eman, M. A., Abdullah, M. I., Passent, M. E., Oh-Young, S., & Ali, K. B. (2020).
    DITrust chain: Towards blockchain-based trust models for sustainable healthcare
    IoT systems. IEEE Access: Practical Innovations, Open Solutions , 8, 111223–111238\.
    doi:10.1109/ACCESS.2020.2999468'
  prefs: []
  type: TYPE_NORMAL
- en: Karaev, A. (2018). “Gazprom Neft” has tested blockchain and the Internet of
    Things in logistics. (https://www.gazprom-neft.ru/press-center/news/v-gazprom-nefti-ispytali-blokcheyn-i-internet-veshchey-v-logistike/)
  prefs: []
  type: TYPE_NORMAL
- en: Kustov, V. N., & Stankevich, T. L. (2018). Once Again about Blockchain Technology.
    Intellectual Technologies on Transport , (3), 38–46.
  prefs: []
  type: TYPE_NORMAL
- en: 'Kustov, V. N., & Stankevich, T. L. (2018). Blockchain Prospects: a Dialogue
    between a Skeptic and an Optimist. Bulletin of Scientific Conferences, 1(37),
    77-84.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Kustov, V. N., & Stankevich, T. L. (2019). Blockchain Technology: a Story of
    Ingenious Simplicity or Enlightened Thinking. How to protect yourself from blockchain?
    Information Protection. INSIDE, 2(86), 11-18.'
  prefs: []
  type: TYPE_NORMAL
- en: Nin, H. L., Mohamed, E., Shanka, K., Gupta, B. B., & Ahmed, A. A. (2021). Secure
    blockchain enabled Cyber–physical systems in healthcare using deep belief network
    with ResNet model. Journal of Parallel and Distributed Computing , 153, 150–160\.
    doi:10.1016/j.jpdc.2021.03.011
  prefs: []
  type: TYPE_NORMAL
- en: Official documentation on the Solidity language from the Ethereum Foundation.
    (2018). https://solidity.readthedocs.io/en
  prefs: []
  type: TYPE_NORMAL
- en: Report of the company Positive Technologies. (2019). Initial Coin Offering.
    Threats to information security. https://www.ptsecurity.com/upload/corporate/ru-ru/analytics/ICO-Threats-rus.pdf
  prefs: []
  type: TYPE_NORMAL
- en: Roadmap for the development of the. (2019). End-to-end digital technology “of
    the Distributed Registry System” . Rostec.
  prefs: []
  type: TYPE_NORMAL
- en: Satoshi, N. (n.d.). Bitcoin. A Peer-to-Peer Electronic Cash System. https://bitcoin.org/bitcoin.pdf
  prefs: []
  type: TYPE_NORMAL
- en: Shapiev, M. M. (2019). Vulnerabilities of smart contracts and ways of their
    exploitation. Scientific Electronic Journal “Meridian”, 10(28), 1-5.
  prefs: []
  type: TYPE_NORMAL
- en: 'Swan, M. (2018). Blockchain: The scheme of a new economy. Olymp-Business Publishing
    House.'
  prefs: []
  type: TYPE_NORMAL
- en: Vanurina, V. (2019). Gazprom is switching to blockchain. https://news.rambler.ru/other/41980326-gazprom-perehodit-na-blokcheyn/
  prefs: []
  type: TYPE_NORMAL
- en: Velder, S. E., Lukin, M. A., Shalyto, A. A., & Yaminov, B. R. (2011). Verification
    of automaton programs [Verifikatsiya avtomatnykh program] . Nauka.
  prefs: []
  type: TYPE_NORMAL
