- en: '[CHAPTER 5](toc.xhtml#c05)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[The Whitepaper](toc.xhtml#c05)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Satoshi Nakamoto* published the Bitcoin Whitepaper titled “*Bitcoin: A Peer-to-Peer
    Electronic Cash System*”. This paper is available at **[https://bitcoin.org/bitcoin.pdf](https://bitcoin.org/bitcoin.pdf)**.
    Bitcoin and most cryptocurrencies are based on this whitepaper. It is important
    to understand the whitepaper thoroughly to be able to understand the content in
    the upcoming chapters. This chapter focuses on explaining the content in the whitepaper.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The whitepaper is not under any copyright protection as the creator of the
    paper was anonymous and never claimed any copyright on the paper. So, anyone can
    easily copy or refer to the paper. The Bitcoin Whitepaper is also in the blockchain,
    from where it can always be retrieved. Other than that, there are multiple other
    websites where the whitepaper is available. It is even available on the following
    Estonian government website:'
  prefs: []
  type: TYPE_NORMAL
- en: q-
  prefs: []
  type: TYPE_NORMAL
- en: '**[https://www.e-resident.gov.ee/bitcoin-whitepaper/](https://www.e-resident.gov.ee/bitcoin-whitepaper/)**'
  prefs: []
  type: TYPE_NORMAL
- en: 'And on the following US government website:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[https://www.ussc.gov/sites/default/files/pdf/training/annual-national-training-seminar/2018/Emerging_Tech_Bitcoin_Crypto.pdf](https://www.ussc.gov/sites/default/files/pdf/training/annual-national-training-seminar/2018/Emerging_Tech_Bitcoin_Crypto.pdf)**'
  prefs: []
  type: TYPE_NORMAL
- en: '[Structure](toc.xhtml#s79a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Abstract section of the whitepaper
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction section of the whitepaper
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transaction section of the whitepaper
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Timestamp Server section of the whitepaper
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Proofof-Work section of the whitepaper
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network section of the whitepaper
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Incentive section of the whitepaper
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reclaiming Disk Space section of the whitepaper
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simplified Payment Verification section of the whitepaper
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining and Splitting Value section of the whitepaper
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Privacy section of the whitepaper
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculations section of the whitepaper
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conclusion section of the whitepaper
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Objective](toc.xhtml#s80a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The primary objective of this chapter is to help readers understand the Bitcoin
    Whitepaper in depth.
  prefs: []
  type: TYPE_NORMAL
- en: '[Abstract section of the whitepaper](toc.xhtml#s81a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](images/Figure-5.1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 5.1:** Abstract section of the whitepaper'
  prefs: []
  type: TYPE_NORMAL
- en: Bitcoin is electronic cash that is completely peer-to-peer. There were a few
    cryptographic trials in the past that provided an electronic cash system. These
    implementations were centralized, and some of them failed. These implementations
    required a third party to avoid the double-spending problem. Bitcoin does not
    need third parties as it uses an immutable chain of blocks where each block contains
    a list of transactions, a hash confirming the integrity of transactions, and a
    timestamp. The chain of blocks maintains immutability by using hash-based proof
    of work.
  prefs: []
  type: TYPE_NORMAL
- en: Bitcoin is a cooperating system where nodes either comply with the consensus
    rules or are cooperating to attack the network. The cooperating systems form a
    pool of CPU power, which adds blocks to the existing chain. The longest chain
    stores the greatest CPU power and so, is considered the actual blockchain, and
    the other chain is discarded. This mechanism assumes that the greatest CPU power
    is owned by honest nodes. This assumption fails if the whole network is compromised.
    In the upcoming chapters, we will explain how this is not a problem anymore.
  prefs: []
  type: TYPE_NORMAL
- en: The Bitcoin network maintains trail-of-truth (blockchain) and so, allows any
    node to leave or join the network at will. The joining nodes sync up their local
    chain at the time of joining the network. If a node goes offline for some time,
    it will also need to sync up its local chain. If we look at the whitepaper, it
    is quite simple to understand and implement. Consequently, thousands of cryptocurrencies
    have come up, most using the almost original design.
  prefs: []
  type: TYPE_NORMAL
- en: '[Introduction section of the whitepaper](toc.xhtml#s82a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](images/Figure-5.2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 5.2:** Introduction section of the whitepaper'
  prefs: []
  type: TYPE_NORMAL
- en: The introduction section explains the drawback of a trusted third party that
    exists today. Trusted third parties are mostly large financial institutions that
    facilitate dispute resolution. Many a time, these disputes lead to transaction
    reversal, litigations, and losses. For a high-value transaction or transactions
    where services and payments can be reversed, these additional costs benefit them
    as not being able to reverse a transaction can lead to large losses. On the other
    hand, for small transactions or transactions where services and payments are non-reversible,
    these costs are unnecessary. Both these transactions are normally catered to by
    the same payment processors. The losses these payment processors must bear are
    born by both kinds of transactions, so the cost affects both transactions. In
    short, the cost of having trusted the third party is universal.
  prefs: []
  type: TYPE_NORMAL
- en: A peer-to-peer cash system intends to remove the need for trusted third parties,
    thereby removing the possibility of transaction reversal. An escrow mechanism
    can still be implemented to protect buyers. This mechanism can separate small
    non-reversal transactions that are akin to cash transactions from large transactions
    that need mediations and can have a separate escrow mechanism provided by a trusted
    third party without impacting the cost to the network itself.
  prefs: []
  type: TYPE_NORMAL
- en: '[Transactions section of the whitepaper](toc.xhtml#s83a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](images/Figure-5.3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 5.3:** Transaction section of the whitepaper'
  prefs: []
  type: TYPE_NORMAL
- en: The transaction section explains transactions as a trail of digital signatures
    that leads to the flow of bitcoin between parties. To understand this, we need
    to understand terms like Hashing and Digital Signatures.
  prefs: []
  type: TYPE_NORMAL
- en: '**Hashing**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hashing is a non-reversible** **process that generates a fixed byte output
    for a large text. The fixed byte output is called hash-code. Hashing has certain
    properties that make it very useful in applications such as bucketing for randomly
    distributing data in buckets. It is also useful in safely storing and transferring
    passwords. It is also used in network handshaking for sending challenge code.
    The hash-code output is deterministic, which means the same text will always generate
    the same hash-code. These pieces of code are very well randomized, so they cannot
    be determined by brute force or other more sophisticated attacks.**'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-5.4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 5.4:** Illustr ation of the irreversibility of hashing algorithm'
  prefs: []
  type: TYPE_NORMAL
- en: '**Digital Signatures**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Digital Signatures are like physical** **signatures as they ensure the integrity
    of the document, and they also ensure that the document is signed by the signer
    (authenticity). Digital Signature uses “Public and Private key cryptography”.
    A document is signed by the sender’s private key. This creates a signature that
    is a code, and it is kept along with the document for others to verify.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**The following is the Digital Signing process:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-5.5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 5.5:** Illustration of the Digital signing process'
  prefs: []
  type: TYPE_NORMAL
- en: The signature is verified by using the Sender’s public key. The verification
    algorithm uses Document content, Signature, and Sender’s public key for verification.
  prefs: []
  type: TYPE_NORMAL
- en: The following is the signature verification process.
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-5.6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 5.6:** Illustration of the digital signing verification process'
  prefs: []
  type: TYPE_NORMAL
- en: 'A transaction in Bitcoin has two sections: ins and outs. Input transactions
    carry information about the previous transaction, along with the signature of
    sender and its public key for verification. Out contains information of bitcoin
    to be transferred along with public key of the receiver. Only the receiver knows
    private keys and so, can unlock the bitcoin locked in the previous transaction
    and send it to the next receiver. This creates a chain of ownership. To understand
    this, let’s look at how Alice pays Bob.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-5.7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 5.7:** Illustration of transactions creation and broadcast'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alice wants to pay Bob. For this, Alice looks for her unspent transactions.
    She creates a transaction input by signing the hash of previous unspent transactions
    with her private key. This releases bitcoins locked in the previous transaction.
    She now creates out-of-transaction by adding a message for Bob along with Bob’s
    public key. For Bob to pay Dave, he needs to do the same: pick up his previous
    unspent transaction, hash it, and sign it with his private key to release locked
    bitcoin. And then he needs to create a message for Dave along with Dave’s public
    key. For these transactions to be considered valid, these and the trail of all
    previous transactions carrying value need to be validated by a majority of nodes
    in the Bitcoin network.'
  prefs: []
  type: TYPE_NORMAL
- en: The Bitcoin network consists of nodes that maintain verified copies of all previous
    transactions. When a new transaction is performed, it is broadcasted on the network,
    and all the participating nodes verify its validity based on all the existing
    unspent transactions already received. This mechanism does not leave any chance
    of missing a concerned transaction, avoiding the chance of double-spending by
    mistake or on purpose.
  prefs: []
  type: TYPE_NORMAL
- en: '[Timestamp Server section of the whitepaper](toc.xhtml#s84a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](images/Figure-5.8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 5.8:** Timestamp Server section of the whitepaper'
  prefs: []
  type: TYPE_NORMAL
- en: Timestamp Server is the node that is creating a block of transactions and putting
    timestamps to the block. After creating the block, the timestamp server widely
    publishes block-hash. Each block also contains a block-hash of the previous block
    header. Since the newly created block contains a block-hash of the previous block
    header that includes the timestamp of the creation of the previous block, the
    new block cannot have a timestamp older than the included block-hash. This method,
    consequently, imposes the necessity of chronological order on the blockchain.
    Thus, there is no need for reliance on an external source to impose the accuracy
    of the timestamp.
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-5.9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 5.9:** Block structure with Timestamp'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding figure, we can see that the N+1^(th) block contains a hash
    of the N^(th) block. Since N^(th) block-hash has a timestamp, the N+1^(th) block
    timestamp must have been created after the timestamp on the N^(th) block. This
    ensures that:'
  prefs: []
  type: TYPE_NORMAL
- en: '*N+1^(th) block timestamp>N^(th) block timestamp*'
  prefs: []
  type: TYPE_NORMAL
- en: Thus, it imposes chronological order on the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: '[Proof-of-Work section of the whitepaper](toc.xhtml#s85a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](images/Figure-5.10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 5.10:** Proof-of-Work section of the whitepaper'
  prefs: []
  type: TYPE_NORMAL
- en: 'Bitcoin uses a proof of work mechanism to ensure the integrity of the blockchain.
    The proof –of work algorithm necessitates CPU usage (work) in order to create
    a block. Any attacker who wants to modify an existing transaction will need to
    redo the work, create the block containing the transactions, and redo work to
    create blocks after it. The idea here is that a non-cooperating node needs to
    compete with cooperating nodes in the amount of work done in terms of CPU power.
    *Satoshi Nakamoto* suggests a simple proof of work mechanism that involves counting
    starting zeroes in a hash of the block. The logic here is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The probability of getting “0…..” binary hash value is 1/2.
  prefs: []
  type: TYPE_NORMAL
- en: The probability of getting “00….” binary hash value is 1/4.
  prefs: []
  type: TYPE_NORMAL
- en: The probability of getting “000…” binary hash value is 1/8.
  prefs: []
  type: TYPE_NORMAL
- en: 'The CPU power required to achieve the binary hash value is inverse of probability,
    i.e., as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*work≈1/probability*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Satoshi Nakamoto* also suggests changing the required work based on how quickly
    blocks have been getting created, thus maintaining block creation time.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the block now looks like the following illustration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-5.11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 5.11:** Block structure with Nonce, timestamp, and previous block
    hash'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, Target proof –of work necessitates the timestamp server to use the required
    amount of CPU work in order to create a block. This is calculated by taking the
    moving average of time to create each block and increasing or decreasing the value
    if blocks are taking lesser or longer time to create. The following equation shows
    how Target work is calculated:'
  prefs: []
  type: TYPE_NORMAL
- en: '*D[n]: Target Proof-of-work of Block with Height n*'
  prefs: []
  type: TYPE_NORMAL
- en: '*T[n]: Timestamp of n^(th) Block*'
  prefs: []
  type: TYPE_NORMAL
- en: '*ΔT: Expected Time to create Block*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/c05eq-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following flowchart shows how a Timestamp server finds the right nonce
    for block creation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-5.12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 5.12:** Process of mining a block by finding the required nonce'
  prefs: []
  type: TYPE_NORMAL
- en: Timestamp server increments Nonce and calculates block hash. If block-hash achieves
    the required work, the block is published to the Bitcoin network; otherwise, Timestamp
    server increments the Nonce till it achieves the required work or some other node
    publishes the block with the right nonce.
  prefs: []
  type: TYPE_NORMAL
- en: '[Network section of the whitepaper](toc.xhtml#s86a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](images/Figure-5.13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 5.13:** Network section of the whitepaper'
  prefs: []
  type: TYPE_NORMAL
- en: The term node used here is the same as the timestamp server used in previous
    sections. Now, we do not use the term node to describe nodes that create a block;
    instead, we call them mining nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Each node is connected to multiple nodes, and those nodes are connected to several
    other nodes. This creates a network of nodes. Each node tries to find nonce for
    the next block to be created in the blockchain. When a new transaction is created,
    like “*Alice pays Bob*”, it is sent to its peers. Each receiving node checks whether
    the transaction is valid and not trying to create an illegal transaction or trying
    to spend an already spent transaction. It is then sent to their peers and so on;
    this gets broadcasted to the whole network. Each receiving node adds a transaction
    to the block and races to find nonce. Whichever node finds the nonce first creates
    the block and sends the block to its peers. All the receiving nodes verify the
    block timestamp, transactions, nonce, and next target proof –of work. The receiving
    nodes then forward it to their peers and so on; this gets broadcasted. After receiving
    the block, each node starts working on the next nonce. This is the way the process
    continues.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image shows how blocks and transactions propagate:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-5.14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 5.14:** Transaction propagation on Bitcoin network'
  prefs: []
  type: TYPE_NORMAL
- en: A ping takes nearly 200ms to reach to cover the longest distance on earth. Block
    broadcast involves verification at each hop; so, to cover 95% of the network,
    propagation delay can be up to a minute. Due to this reason, multiple nodes can
    create a valid block without knowing the existence of an already created block.
    This creates branching on the blockchain. Depending on the location, nodes may
    choose different nodes as valid for the same block height. Since no node can know
    which block is to be considered and which one is to be rejected, they need to
    start working on the first one received but also save the other valid blocks.
    Now, there are multiple sets of nodes calculating nonce for different chains,
    so they may continue to create next blocks in their respective chains. To solve
    this issue of branching, the nodes must continue this process till one of the
    competing chains becomes longer than the rest. The nodes will then accept the
    longest chain as the correct one and discard the other chain. As the time, to
    find the nonce is significantly higher than the block propagation delay; the nodes
    competing for the next block will not be many.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an illustration of chain branching:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-5.15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 5.15:** Illustration of block branching due to almost simultaneous
    mining of blocks'
  prefs: []
  type: TYPE_NORMAL
- en: If, for some reason, blocks are not received by a node and a new block is received,
    the node can request for missed blocks from its peers. Since not receiving a block
    is not a problem, a block does not need to reach all nodes either.
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-5.16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 5.16:** Node requested missing block peer'
  prefs: []
  type: TYPE_NORMAL
- en: '[Incentive section of the whitepaper](toc.xhtml#s87a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](images/Figure-5.17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 5.17:** Incentive section of the whitepaper'
  prefs: []
  type: TYPE_NORMAL
- en: 'This section explains the incentive a node has in creating blocks and supporting
    the Bitcoin network. A node that successfully creates a block is incentivized
    in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Each newly created block awards bitcoin to the node that successfully finds
    Nonce.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additionally, in a transaction, input value minus output value also adds to
    the block reward collected by the node creating the block.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A node uses CPU power in trying to find nonce, which leads to power consumption.
    Since many nodes will be competing in finding a nonce, this process will mostly
    lead to failed attempts. The cost of energy used in this process will need to
    be recovered when the node succeeds. The node also needs to make revenue to run
    a profitable business as this is a business for the node owner. A block reward
    makes sure that the node has enough incentives to continue to find nonce.
  prefs: []
  type: TYPE_NORMAL
- en: If a group of nodes decides not to cooperate with the network and double-spend
    or change rules of acceptance of block/transaction or attack network in some way,
    then those nodes will form their own network. The network that will provide better
    incentives and where nodes play by the rules will provide better value for publishing
    transactions. Consequently, the reward will have a higher credit value. This will
    encourage nodes to cooperate and support the network instead of attacking it.
  prefs: []
  type: TYPE_NORMAL
- en: The node is free to include or exclude a transaction or not cooperate with the
    network. By including the reward, the creator of a transaction encourages the
    node to include the transaction in the block. As more and more transactions are
    included in the block, transaction reward will become the main driver of revenue
    for the mining node, and so, the need for block reward will diminish. The network
    implements a mechanism to reduce block rewards over time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure illustrates transaction rewards:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-5.18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 5.18:** Illustration of transaction reward payment'
  prefs: []
  type: TYPE_NORMAL
- en: Also, Block reward is the only source of minting bitcoin. This leads to predefined
    inflation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is bitcoin inflation plotted for past and future:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-5.19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 5.19:** Bitcoin inflation of past and future'
  prefs: []
  type: TYPE_NORMAL
- en: '[Reclaiming Disk Space section of the whitepaper](toc.xhtml#s88a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](images/Figure-5.20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 5.20:** Reclaiming Disk Space section of the whitepaper'
  prefs: []
  type: TYPE_NORMAL
- en: This section explains how we can compact stored blocks in the blockchain and,
    thus, reclaim disk space. Merkle Tree is a method of deriving code (called Merkle
    root) from a list of transactions. This code confirms the integrity of transactions
    included in the block. Merkle Root, being part of the Block header, also ensures
    that proof –of work protects it against modification.
  prefs: []
  type: TYPE_NORMAL
- en: 'The updated Block Header is now as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-5.21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 5.21:** Illustration of Bitcoin Block structure'
  prefs: []
  type: TYPE_NORMAL
- en: We can see that as transactions were not used in the calculation of Block hash,
    their integrity could not have been protected without Merkle root.
  prefs: []
  type: TYPE_NORMAL
- en: 'Calculation of Merkle Root can be understood from the following illustration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-5.22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 5.22:** Calculation of Merkle Tree Root'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding illustration, the first Hashes of each transaction are calculated.
    Then, recursively, pairs of hashes are concatenated and hashed to get hash for
    the upper level. If a pair is not available, the hash is concatenated with itself.
  prefs: []
  type: TYPE_NORMAL
- en: Each node verifies a block as it receives over the network and stores it on
    the disk. When enough blocks are saved on the disk and the node is confident that
    the older blocks will not change because of branching, the node can remove sent
    transactions from the older blocks and only keep headers and unspent transactions.
    This way, nodes can save a significant amount of disk space.
  prefs: []
  type: TYPE_NORMAL
- en: '[Simplified Payment Verification section of the whitepaper](toc.xhtml#s89a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](images/Figure-5.23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 5.23:** Simplified Payment Verification section of the whitepaper'
  prefs: []
  type: TYPE_NORMAL
- en: This section explains how a node that does not maintain full blocks can still
    verify received blocks. A node implementing Simplified Payment Verification only
    keeps Block headers for the longest chain, which means there are no competing
    chains, and the longest chain is already found. The node takes help from other
    nodes in its network that are maintaining full blockchain to verify blocks.
  prefs: []
  type: TYPE_NORMAL
- en: 'It uses a technique called *Merkle proof,* explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-5.24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 5.24:** Illustration of Merkle proof'
  prefs: []
  type: TYPE_NORMAL
- en: SPV node requests full node for Hashes related to T4\. The full node sends the
    hashes required to verify Merkle root. Since H34 can be derived from H3 and H4,
    H1234 can be derived from H34 and H12\. H12345555 can be derived from H1234 and
    H5555\. By giving H3, H4, H12, and H5555 and Merkle root H12345555, SPV node can
    verify the presence of T4 in the block with Merkle root H12345555.
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-5.25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 5.25:** Communication between SPV Node and Full Node'
  prefs: []
  type: TYPE_NORMAL
- en: However, attackers can form a network, and since SPV node depends on full nodes
    for verification, it may not know if the node it is communicating is fraudulent.
    Consequently, it can continue receiving fabricated transactions. This kind of
    attack can be handled if a node broadcast alerts for presence of invalid block
    when it sees on network.
  prefs: []
  type: TYPE_NORMAL
- en: '[Combining and Splitting Value section of the whitepaper](toc.xhtml#s90a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](images/Figure-5.26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 5.26:** Combining and Splitting Value section of the whitepaper'
  prefs: []
  type: TYPE_NORMAL
- en: This section explains the concept of combining and splitting of value in Bitcoin
    transactions instead of having one transaction for each bitcoin or fraction of
    bitcoin. If Alice needs to pay Bob, she needs to use unspent transactions paid
    to her that have combined value greater than or equal to the amount she needs
    to pay to Bob and pay herself back the remaining (change) value.
  prefs: []
  type: TYPE_NORMAL
- en: If the unspent transaction is bigger than the required amount, then the transaction
    will be split into the amount to be paid and the remaining change. If unspent
    transactions are smaller, then the value of multiple transactions needs to be
    combined to make the input value bigger than or equal to the required amount.
    If the input value is the same as the required amount, then output is only one
    transaction, which is the amount to be paid to Bob. However, if the input value
    is bigger, then Alice needs to pay herself the change. If the output is smaller
    than the input, then the remaining value is paid to the mining node, as we learned
    in one of the previous sections. This can be understood from *[Figure 5.18](#fig5_18)*.
  prefs: []
  type: TYPE_NORMAL
- en: '[Privacy section of the whitepaper](toc.xhtml#s91a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](images/Figure-5.27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 5.27:** Privacy section of the whitepaper'
  prefs: []
  type: TYPE_NORMAL
- en: This section explains how privacy can be achieved in the Bitcoin network even
    though all transactions are broadcasted. A user can keep its public keys anonymous
    this way. Although transactions are public, no one will know who the transaction
    belongs to. However, since change needs to be sent back to the owner of the transaction,
    its value and transaction details can be derived. To solve this, the owner of
    the transaction can send change to a different public key. This means a new key
    pair needs to be used every time. However, transaction history can still reveal
    the owner’s chain of transactions if their identity is revealed in one of the
    existing transactions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the illustration of the method of improving privacy in a transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-5.28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 5.28:** Method of improving the privacy of the sender in a transaction'
  prefs: []
  type: TYPE_NORMAL
- en: '[Calculations section of the whitepaper](toc.xhtml#s92a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](images/Figure-5.29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 5.29:** Calculations section of the whitepaper'
  prefs: []
  type: TYPE_NORMAL
- en: This section explains the condition when an attacker or group of attackers tries
    to mine more blocks than an honest node. If the attackers manage to have more
    CPU processing power and can mine more blocks, the attacker will be part of the
    network, which means it will have to depend on honest nodes to accept the blocks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consequently:'
  prefs: []
  type: TYPE_NORMAL
- en: The attacker cannot change block reward, so they cannot increase bitcoin supply.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The attacker cannot change the content of transactions from others’ payments
    as it cannot sign their transactions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The attacker cannot stop honest nodes from broadcasting transactions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The attacker can, however, change its own transaction, censor transactions by
    not including them, or reverse a transaction that was recently included.
  prefs: []
  type: TYPE_NORMAL
- en: Now, consider a situation wherein an attacker who may or may not hold the majority
    CPU power tries to attack a network. This situation is like Gambler’s Ruin Problem,
    and the solution is derived by using Binomial Random Walk.
  prefs: []
  type: TYPE_NORMAL
- en: The attacker wants to change a transaction at z-1 depth, so it will start from
    z depth. If they can mine a block before honest node, gap reduces by z-1, but
    if honest node mines the block, gap increases to z+1\. We are trying to find the
    probability of the attacker being able to create the longest chain.
  prefs: []
  type: TYPE_NORMAL
- en: In Gambler’s Ruin Problem, Gambler competes with the opponent and tries to win
    all fortune from the opponent. It is an iterative betting game in which either
    party wins or loses $1 on every bet. In the end, one party loses all its fortune.
  prefs: []
  type: TYPE_NORMAL
- en: At first, looking at Gambler’s ruin problem.
  prefs: []
  type: TYPE_NORMAL
- en: '*q: Probability of Gambler winning a single bet*'
  prefs: []
  type: TYPE_NORMAL
- en: '*p: Probability of Gambler losing a single bet*'
  prefs: []
  type: TYPE_NORMAL
- en: '*i: Initial fortune of Gambler*'
  prefs: []
  type: TYPE_NORMAL
- en: '*p=1-q*'
  prefs: []
  type: TYPE_NORMAL
- en: '*0< i< N*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-5.30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 5.30:** Illustration of Gambler’s ruin problem'
  prefs: []
  type: TYPE_NORMAL
- en: 'The probability of Gambler winning the game can be calculated as the sum of
    the following probabilities after the bet:'
  prefs: []
  type: TYPE_NORMAL
- en: If Gambler wins a bet with probability q, then the new game-winning probability
    is .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If Gambler loses a bet with probability p, then the new game-winning probability
    is.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Law of total probability, i.e., .
  prefs: []
  type: TYPE_NORMAL
- en: 'The probability of the gambler winning the game is the sum of probability of
    winning the game after winning or losing the current bet. This can be represented
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/107.jpg)![](images/c05eq-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In a winning situation, *P[N] = 1 and i = N - 1*
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/c05eq-5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, consider the case of Bitcoin mining in which attacker can mine blocks forever
    to defeat honest nodes. It is Gambler’s ruin problem with a difference. Attacker
    has infinite dollars and infinite time, and to win, attacker needs to create bigger
    chain by adding blocks more than honest node. At the beginning, attacker wants
    to be able to modify a transaction at z-1depth, so it starts at z depth.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure explains this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/Figure-5.31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 5.31:** Illustration of an attacker successfully mining longer chain'
  prefs: []
  type: TYPE_NORMAL
- en: Considering,
  prefs: []
  type: TYPE_NORMAL
- en: '*p: Probability of an honest node finding the next block*'
  prefs: []
  type: TYPE_NORMAL
- en: '*q: Probability of the attacker finding the next block*'
  prefs: []
  type: TYPE_NORMAL
- en: '*z: Blocks attacker has to add more than honest node*'
  prefs: []
  type: TYPE_NORMAL
- en: '*i: Number of additional blocks attacker can lose to honest node*'
  prefs: []
  type: TYPE_NORMAL
- en: '*q[z]: probability of the attacker to ever beat honest node*'
  prefs: []
  type: TYPE_NORMAL
- en: '*So, N= i + z*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Here, i* → *∞ since Gambler started with infinite resources.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/c05eq-6.jpg)![](images/c05eq-7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is how we reached the equation given in this section of the whitepaper.
  prefs: []
  type: TYPE_NORMAL
- en: Assuming that the attacker has a lower probability of finding the block than
    the honest node, i.e., the attacker’s chance of catching up goes down exponentially.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we are going a step ahead here and trying to determine the probability
    of the attacker being able to double spend if the merchant waits for z confirmations.
    Satoshi Nakamoto considers the probability distribution of the number of winning
    events in each time period as Poisson’s distribution because of the following
    reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: Mining events can occur any number of times during each interval.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each event occurs independently and does not affect the probability of other
    events.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The average rate of the event is constant as we know since block time is constant,
    and the probability of block mining is proportional to the ratio of CPU power,
    so it is also constant.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two events occurring at the exact same time is not possible as nodes judge based
    on arrival time, and if they do occur, they wait till the longest chain is found.
    So, two events occurring at the same time are rare and even if they occur, they
    can be safely considered different.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Considering,
  prefs: []
  type: TYPE_NORMAL
- en: '*T: Average block time*'
  prefs: []
  type: TYPE_NORMAL
- en: '*z: Required depth of transaction in blockchain to consider spent*'
  prefs: []
  type: TYPE_NORMAL
- en: '*P[p]: Probability of mining a block by honest node every T minutes*'
  prefs: []
  type: TYPE_NORMAL
- en: '*P[q]: Probability of mining a block by attacker node every T minutes*'
  prefs: []
  type: TYPE_NORMAL
- en: '*p: Number of blocks mined by honest node every T minutes*'
  prefs: []
  type: TYPE_NORMAL
- en: '*q: Number of blocks mined by attacker every T minutes*'
  prefs: []
  type: TYPE_NORMAL
- en: '*T[z]: Average Time interval for mining z blocks*'
  prefs: []
  type: TYPE_NORMAL
- en: '*T[z]= T*z*'
  prefs: []
  type: TYPE_NORMAL
- en: The quantities p and q are inverse of their respective probabilities of mining
    a block within time interval T.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore,
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/c05eq-8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Attacker can mine q blocks in T minutes, so it can mine:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/c05eq-9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The probability of k successes happening in an interval is given by Poisson
    density function
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/111.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As a more general case, we want to know the overall probability of attack successes
    for the merchant to accept a modified transaction in a block in the future if
    not in the current interval. So basically, even if the attacker has k successes
    in an interval, it can still achieve z-k blocks in the future and modify the future
    blocks in an interval.
  prefs: []
  type: TYPE_NORMAL
- en: This can be solved by using the Law of total probability, i.e., *P(A)= ∑[n]P(A|B[n]
    )P(B[n])*
  prefs: []
  type: TYPE_NORMAL
- en: '*P[s]: Total probability of successes*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/c05eq-10.jpg)![](images/c05eq-11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is the equation Satoshi Nakamoto used to write code and demonstrate that
    the probability drops exponentially.
  prefs: []
  type: TYPE_NORMAL
- en: From the equation, we can deduce that the probability of an attacker successfully
    mining z blocks reduces exponentially with the increase in value of z if the attacker
    does not control a majority of hash power. Therefore, it is important to wait
    for few blocks before confirming a transaction.
  prefs: []
  type: TYPE_NORMAL
- en: It is recommended that a merchant should confirm a payment only after the transaction
    is at the depth of 6 in the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: '[Conclusion section of the whitepaper](toc.xhtml#s93a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](images/Figure-5.32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 5.32:** Conclusion section of the whitepaper'
  prefs: []
  type: TYPE_NORMAL
- en: 'This section explains what we achieved in the paper. This can be listed as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A peer-to-peer payment system that protects against double-spending and does
    not require a trusted third party.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A digital signature provides ownership of the transaction.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If honest nodes control the majority of CPU power, then proof of work makes
    it impractical for an attacker to modify enough blocks in blockchain to cause
    double-spending.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nodes work independently with only little need for coordination. Nodes can leave
    and join the network independently. They do need to communicate, but their state
    does not depend on other nodes, and there is no need for routing, etc.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nodes do not need to reveal their identity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nodes votes with their CPU power, and so, compete in CPU power to mine blocks.
    Successful nodes get the incentive to support the network.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consensus rules are enforced through majority support and participation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Conclusion](toc.xhtml#s94a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about the content of the whitepaper in detail.
    You also learned about the calculations used in the whitepaper by deriving them.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will understand the structure of blocks in the blockchain
    by writing actual programs for parsing blocks and indexes stored in the filesystem
    by Bitcoin software. You will also understand mining in detail again through programming.
  prefs: []
  type: TYPE_NORMAL
- en: '[Points to remember](toc.xhtml#s95a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Bitcoin network does not require any intermediaries to send bitcoin between
    two parties.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blockchain is a trail of truth that every node maintains.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trusted third parties have a cost included in all the transactions, even if
    a transaction does not require dispute resolution.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bitcoin transactions can optionally have a trusted third party as escrow implementation
    rather than by rule.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transactions are a trail of digital signature linking the amount paid to the
    previous transaction and finally, leading to the mined coins.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hashing is irreversible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The digital signature ensures the integrity and authenticity of the document.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transactions once created are broadcast to the Bitcoin network.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each block in the blockchain is arranged in chronological order.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A nonce is a random value found by the miner so that it is within target proof
    –of work, and hence, acceptable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bitcoin maintains block time by adjusting the target proof –of work.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New blocks are published to the network.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In case two blocks are mined almost simultaneously, there will be multiple competing
    chains in a branch in the blockchain.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The longer chain in the competing branch is accepted, and the other one is rejected.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A miner who finds the required nonce is awarded a block reward.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additionally, miners collect a transaction fee from the included transaction
    in the block.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Miners have an incentive to protect the network instead of attacking it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bitcoin inflation is predetermined.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A node can prune older blocks by removing included transactions once enough
    newer blocks are received.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simplified Payment Verification node keeps only block headers of the longest
    chain with only the required transactions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SPV node takes help from full nodes to verify blocks and transactions using
    Merkle proof.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Payers of bitcoin can combine its unused bitcoin transaction output or split
    its previous unspent output.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One can enhance their privacy by never reusing their addresses.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The probability of malicious miners successfully reversing a transaction already
    included in the blockchain reduces exponentially as the depth of the block increases.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Questions](toc.xhtml#s96a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How does a node know that it has missed a block? How can it get the missed block?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why are there mostly one or two outs of a transaction?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What makes blockchain immutable? (Tick the correct answer)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Merkle root
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Digital Signature
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Proof –of work
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy of blockchain
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: True or False
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The greater the value of the Block-header hash, the greater is proof-of-work.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The success of SPV block verification depends on the honesty of its peers.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Bitcoins are created by _______.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why does sending bitcoin change back to the same public key reduce privacy?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In Gamber’s Ruin Problem: Ria starts with i = $2 and has a probability of winning
    a bet p = 0.7.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the probability of Ria winning a total fortune of N = $6?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the probability of Ria becoming infinitely rich?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: An attacker has the mining power of 20% of the entire network. An online store
    requires a bitcoin transaction to reach the depth of 6 in blockchain before they
    release the item.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the probability of the attacker mining 3 blocks during this time?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the probability of the attacker being able to produce the longest chain
    by mining 3 blocks during the confirmation time and additional blocks afterward?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
