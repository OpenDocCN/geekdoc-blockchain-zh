- en: 'Part I: Introduction'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this first part of the book, I introduce the basic concepts of blockchain
    technology, such as trustless consensus, cryptocurrencies, and cryptoeconomics.
    For application developers and business executives, it is crucial to understand
    these concepts, as they establish a common vocabulary for further discussion.
    It is necessary for you to learn the essential features and key characteristics
    of blockchain networks in order to design and develop blockchain applications.
  prefs: []
  type: TYPE_NORMAL
- en: 1. An Introduction to Blockchain
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The word *blockchain* started as a computer science term describing an abstract
    data structure. However, as the technology has become popular and even pervasive,
    the term has caught the imagination of many. Today, *blockchain* has many meanings
    to many people.
  prefs: []
  type: TYPE_NORMAL
- en: The Blockchain
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For computer scientists, a blockchain is a series of connected data blocks.
    Each block of data can store any information, but typically it stores a set of
    *transactions*. The information inside a block is represented by a unique *hash*.
    Each block’s data content contains the hash of the block that precedes itself
    on the chain ([Figure 1.1](ch01.xhtml#ch01fig1)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f01_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 1.1** A blockchain'
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: A cryptographic hash is a short representation of a large amount of data. It
    is extremely easy to compute. But if you only know the hash, it is extremely difficult
    to figure out the original data that produces this hash.
  prefs: []
  type: TYPE_NORMAL
- en: Why do we want to store data in this blockchain structure? Why can’t we just
    use a database? Well, a key feature of the blockchain is that it is hard to alter
    any data on the chain.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that you have a blockchain with 1,000 blocks. Now, someone wants to
    alter the content in block 10\. As the person alters the data, the hash of block
    10 also changes. Block 11 contains the hash of block 10, so the content in block
    11 also changes, which in turn results in a change in the hash of block 11\. This
    process propagates down the blockchain. So, to make any change in any block, you
    will end up reconstructing all the blocks that follow it. That is known as a *hard
    fork*, which creates a new blockchain that is incompatible with the existing one,
    even as they both use the identical software. In that sense, a blockchain is immutable.
    It is impossible for someone to “silently” modify the history of a blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see here, the longer the blockchain, the more stable it becomes.
    When you do transactions on the Bitcoin network, you will often hear that your
    transaction is securely “confirmed” after six or more blocks (about an hour, as
    the Bitcoin network creates one block every ten minutes). After six blocks, it
    is unlikely for an alternative blockchain fork to emerge and gain acceptance by
    the community. So, it is essentially certain that your transaction has been recorded
    as part of the permanent history.
  prefs: []
  type: TYPE_NORMAL
- en: While you can store any data in a blockchain, the most common use case of the
    blockchain is to store transaction records. That makes sense since the historic
    accuracy and validity of monetary transactions are critical. In practice, blockchains
    are used as digital ledgers to record transactions.
  prefs: []
  type: TYPE_NORMAL
- en: The Collaborative Ledger
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now, a database can also record (or *journal*) change histories. People have
    used spreadsheets or databases as transactional ledgers since the invention of
    the personal computer. The ledger itself is neither complicated nor a significant
    value-add.
  prefs: []
  type: TYPE_NORMAL
- en: 'The question remains: why do we need to bother with a new, more computationally
    intensive data structure like the blockchain? The answer lies in the second key
    feature of the blockchain: It is easy to organize a collaborative network around
    the blockchain.'
  prefs: []
  type: TYPE_NORMAL
- en: Since each block is added to the chain individually, we can design a network
    where one or more parties propose the next block, and then all network nodes (i.e.,
    participating computers on the network) can validate the proposed block and reach
    a consensus on whether it should be appended to the blockchain. If a proposed
    block is deemed invalid by most network participants, the blockchain can abandon
    it or even punish its proposers. For more technical details on blockchain consensus,
    please see [Chapter 2](ch02.xhtml#ch02).
  prefs: []
  type: TYPE_NORMAL
- en: The rule for validation depends on the specific blockchain. For example, the
    Bitcoin blockchain miners examine the cryptographic signatures and account balances
    for each transaction recorded in the block for its validity.
  prefs: []
  type: TYPE_NORMAL
- en: By doing so, the blockchain becomes a collaborative ledger.
  prefs: []
  type: TYPE_NORMAL
- en: Cryptocurrency
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The ledger records the movement of some currency. A major innovation is the
    realization that the blockchain can define its own “currency” to transact. It
    is called *cryptocurrency* because the validity of such currency is ensured by
    cryptography used in blockchain networks. For example, each transaction of such
    currency is digital signed to make sure it is authentic and unique. The cryptocurrency
    is also known as *crypto tokens* or just *tokens*. I will use these terms interchangeably
    throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rules for transaction validation allow a blockchain to create its own *monetary
    policy* that governs its cryptocurrency. For example, the Bitcoin blockchain defines
    the following rules for the creation and consumption of its cryptocurrency (i.e.,
    Bitcoins):'
  prefs: []
  type: TYPE_NORMAL
- en: New block proposers will receive newly created units of the Bitcoin currency.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There will be only 21 million Bitcoins in total, and hence the block award decreases
    over time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each Bitcoin can be divided into a million Satoshies to be used in transactions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bitcoin miners will receive Bitcoins for validating transactions in a new block.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The interesting aspect here is that such monetary policies are codified in the
    blockchain software for Bitcoin. No one can change a policy without creating a
    new blockchain (i.e., a hard fork).
  prefs: []
  type: TYPE_NORMAL
- en: 'The cryptocurrency created by the blockchain has a crucial function. It provides
    an engineering mechanism, through incentive design (or economics engineering),
    to accomplish something software engineering cannot accomplish alone: creating
    trust.'
  prefs: []
  type: TYPE_NORMAL
- en: We can build trustless yet collaborative networks using blockchain technology
    together with cryptocurrency design.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: For a long time, the technology community believed that the “enterprise” use
    of blockchain technology was to build a distributed ledger inside a company or
    a group of companies that already have trusted relationships. The trusted network
    validators and nodes made it easy to develop high-performance consensus protocols.
    Companies like IBM and Microsoft promoted the use of such permissioned or trusted
    blockchains.
  prefs: []
  type: TYPE_NORMAL
- en: However, after several years of experimentation, it became clear that such “enterprise”
    use of blockchains in a trusted/single company/centralized environment has limited
    impact on business practices. The trusted blockchain is just another data management
    software solution at the disposal of corporate IT departments. Such use of blockchains
    creates no network effect.
  prefs: []
  type: TYPE_NORMAL
- en: Smart Contracts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When the Bitcoin blockchain miners validate transactions, they are checking
    only for the most basic accounting rules. For instance, the transaction sender
    must have sufficient funds in her account and must sign the transaction with her
    private key. It is easy for Bitcoin miners to verify those transactions and reach
    consensus.
  prefs: []
  type: TYPE_NORMAL
- en: Now, instead of checking the basic accounting rules, the blockchain miners can
    run any kind of computer program and then reach consensus on the correctness of
    the computing results. The consensus results can then be saved to the blockchain
    for a permanent record. That is the idea behind the smart contract. The consensus
    mechanism developed for Bitcoin can be used to establish trust for any type of
    computation.
  prefs: []
  type: TYPE_NORMAL
- en: The Ethereum blockchain is among the first public blockchains to support smart
    contracts. It features a Turing complete virtual machine, known as the Ethereum
    Virtual Machine (EVM). The EVM runs on all nodes to validate the correctness of
    arbitrary computation tasks. Programs written for the EVM are stored in accounts
    on the blockchain. Any transaction that involves the account will be validated
    against the program by Ethereum miners before the transaction can be recorded
    on the blockchain. Smart contracts have become the most important applications
    for the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: The truly revolutionary idea behind blockchains is trustworthy computing results
    generated from uncooperative participants on trustless networks.
  prefs: []
  type: TYPE_NORMAL
- en: A Trustless Network
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The original killer application of blockchain technology is the Bitcoin. The
    Bitcoin was created by and is managed by a completely trustless network. Anyone
    can get on the Bitcoin network to validate transactions, propose new blocks, and
    receive Bitcoin awards if the block is accepted by the consensus. Bitcoin network
    participants do not know each other and do not trust each other. Yet, the system
    is designed to prevent any of the participants from making malicious changes to
    the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: The exact mechanism Bitcoin uses for consensus is called *proof of work* (PoW).
    We will discuss the technical details of PoW in [Chapter 2](ch02.xhtml#ch02).
    For now, just know that there are mechanisms for untrusted network participants
    to agree on which transactions are valid and should be recorded in the blockchain.
    Core to the consensus mechanism is the use of cryptocurrencies that incentivize
    participants to behave according to rules (e.g., not validate invalid transactions).
    This use of cryptocurrencies as incentives is known as *cryptoeconomics*.
  prefs: []
  type: TYPE_NORMAL
- en: The ability to reach consensus without a central trusted authority is powerful.
    The greatest Internet companies today are all built on the network effect. Companies
    like Uber and Airbnb act as central authorities for the networks they built. They
    make the rules, especially the rules around how money is transacted in the network.
    They make sure everyone follows the rules and in the process extract great profits.
    But are they really needed? Can the network function without the company being
    the rule maker and arbitrator? Why can’t the network participants themselves own
    the network and reap the profits?
  prefs: []
  type: TYPE_NORMAL
- en: 'However, past efforts to replace Uber and build a coop-style nonprofit transportation
    network have largely failed. There are a few reasons, listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: Replacing the centralized company with a centralized nonprofit does not solve
    the trust issue. Many nonprofits are corrupt and mostly enrich their operators.
    The drivers and riders still have no real “ownership” of the network.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A centralized nonprofit lacks the means to award early adopters and jump-start
    the network. Uber, however, can raise venture capital (VC) money and spend heavily
    on incentives until the network effect is self-sustainable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A blockchain network with crypto tokens could solve both problems. The network
    is run by untrusted peers and hence cannot be corrupted. The network can issue
    tokens to compensate early adopters through a process like an initial coin offering
    (ICO). Furthermore, by turning network participants (drivers and riders in the
    Uber example) into token holders, we can establish a monetary network and create
    loyalty to the network Uber has never been able to build.
  prefs: []
  type: TYPE_NORMAL
- en: New Ways of Collaborating
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This untrusted network opens new ways for people to collaborate. For instance,
    imagine that there is a valuable data set, but no one owns the whole data. Each
    participant in the network owns a piece of the data set, but they are reluctant
    to share, as the party that shares the last will benefit the most. In this scenario,
    the society often cannot make use of this data set.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: A concrete real-world case is the medical data held by hospitals—while extremely
    valuable collectively, no hospital is incentivized to share its own piece of the
    data.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s imagine a network where all parties can contribute data. When revenue
    is generated from the use of such data, the network will distribute the revenue
    to parties according to pre-agreed upon splits, and each distribution is independently
    validated by network participants so that there is no chance for cheating.
  prefs: []
  type: TYPE_NORMAL
- en: Such a data collaboration network was possible prior to blockchain technology,
    but it requires a centralized authority trusted by everyone to determine and distribute
    the revenue income. The trusted central authority has both incentives and opportunities
    to cheat, and that has made such trusted networks difficult to establish.
  prefs: []
  type: TYPE_NORMAL
- en: The Fat Protocol
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The characteristic of a blockchain network is that it can create value without
    a central corporation. The value of the network is not in a company’s shares but
    in the network protocol and is reflected as the value of the network tokens. This
    theory is called the *fat protocol theory*, originally proposed by Joel Monegro
    from Union Square Ventures. For example, on today’s Bitcoin or Ethereum network,
    no company has reached significant valuation, and yet the networks themselves
    are worth tens of billions of dollars. [Figure 1.2](ch01.xhtml#ch01fig2) shows
    how Internet protocols are “thin” and hence applications capture most of the value,
    while blockchain protocols are fat and can themselves capture value.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f01_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 1.2** The thin versus fat protocols (adapted from [https://www.usv.com/blog/fat-protocols](https://www.usv.com/blog/fat-protocols))'
  prefs: []
  type: TYPE_NORMAL
- en: The very existence of modern corporations is because external transaction costs
    between the corporation and its partners are much higher than the internal transaction
    costs within the departments.
  prefs: []
  type: TYPE_NORMAL
- en: That is due to the command-and-control structure corporations can impose on
    their internal departments. However, in today’s economy, as communication costs
    drop, external transaction costs drop to the point where companies are increasingly
    relying on outsourcing or contracting labor (see the earlier Uber and Airbnb examples).
  prefs: []
  type: TYPE_NORMAL
- en: The trustless blockchain networks will further reduce external transaction costs.
    Those networks streamline the transactions of not only information but also money.
    The public blockchain network, together with crypto tokens, enables new business
    models that could either replace today’s corporations or create new opportunities
    that cannot be solved by corporations.
  prefs: []
  type: TYPE_NORMAL
- en: The rules of collaboration and consensus of a blockchain network are embedded
    and enforced in the network protocol itself. This is of course different from
    the human-driven rules in most corporations. The blockchain collaboration rules
    are algorithmic, automatic, fast, fair, and consistent. To fully take advantage
    of blockchain networks, we should codify as many collaboration rules as possible
    into the network protocol.
  prefs: []
  type: TYPE_NORMAL
- en: In Code We Trust
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The smart contracts can often closely resemble legal contracts in the real world.
    For example, the transaction parties might enter an escrow agreement that the
    fund will be paid out only when certain conditions are met. It is now up to network
    validators and maintainers to assert whether such conditions are met and how the
    transaction should be executed when new blocks are appended to the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: However, unlike legal contracts that are enforced by the centralized government
    power, the smart contracts can automatically apply collaboration rules on the
    blockchain. The rules are written in code and checked by trustless participants
    of the network to prevent corruption or collusion. Because of that, we consider
    smart contract code the “law” in blockchain networks. The code is executed as
    written. Even if the code contains bugs or side effects unexpected by its author,
    it is still trusted as a source of truth and enforced as the law.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, I discussed the key concepts of blockchain networks. Through
    cryptocurrencies, a blockchain network combines software and economics engineering
    to create trust in a network of uncooperative participants. This could disrupt
    the greatest Internet companies today, as the network effects are no longer created
    by large companies at the center of such networks. The network is instead maintained
    by the software code shared by every participant. In code we trust.
  prefs: []
  type: TYPE_NORMAL
- en: 2. Reaching Consensus
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The central idea behind blockchain networks is not really the technology—hash
    algorithms and public key infrastructure (PKI) technologies have existed for many
    years. As we discussed in the previous chapter, the chief innovation in Bitcoin
    is a new incentive structure to make sure that although every individual in the
    network is uncooperative (i.e., decentralized), they will nevertheless collectively
    behave in a way that maintains the integrity and security of the network. Economic
    incentives from cryptocurrencies are working in tandem with technological solutions
    in blockchain networks to solve problems that were previously impossible to address
    with technology alone.
  prefs: []
  type: TYPE_NORMAL
- en: The most important example of this seamless collaboration between software engineering
    and economic design is the blockchain’s consensus mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: What Is Blockchain Consensus?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since a public blockchain is a distributed ledger maintained by untrusted participants,
    it is crucial to reach network-wide consensus on which transactions are valid
    and should be recorded on the blockchain. Automated consensus is the core idea
    behind blockchains. How to improve the efficiency of consensus without compromising
    security is one of the most important challenges facing blockchains today.
  prefs: []
  type: TYPE_NORMAL
- en: To be fair, the human society has long developed ways to reach consensus. For
    example, all types of voting systems are designed to reach consensus. Enabled
    by technologies, we now also have informal voting systems such as Facebook likes
    and Reddit upvotes. However, human voting is too slow and subject to humans’ unreliable
    interpretation of rules. It cannot handle high-speed, high-volume transactions
    required by a global computing network.
  prefs: []
  type: TYPE_NORMAL
- en: Algorithms can help us reach consensus much faster on the Internet scale. Such
    examples include Google page ranks, Google Ads auctions, online reputation scores,
    matching algorithms from Uber to Tinder, and so on. However, such algorithms are
    typically only appropriately correct. They cannot guarantee the accuracy of individual
    transactions. The blockchain network goes one step further and provides an automated
    computational method to definitively validate and record transactions.
  prefs: []
  type: TYPE_NORMAL
- en: While many blockchain projects innovate on the consensus mechanism to be “proof
    of XYZ,” we believe that, fundamentally, there are only two types of consensus—proof
    of work (PoW) and proof of stake (PoS).
  prefs: []
  type: TYPE_NORMAL
- en: Proof of Work (PoW)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Bitcoin is a classic example of a PoW consensus blockchain. While it suffers
    from various technical problems such as low performance, poor scalability, and
    wasteful electricity use, it has proven secure against highly motivated attacks
    by individuals, organizations, and even nation-states. It builds a trillion-dollar
    global network without requiring trust in any of its participants. So far, no
    one has been able to create a fraudulent transaction in the blockchain—despite
    the massive financial payoff such hacks could bring. That is a monumental achievement
    by Bitcoin’s creator, Satoshi Nakamoto.
  prefs: []
  type: TYPE_NORMAL
- en: In a PoW system, miners compete to solve a math puzzle for each block. The first
    one to solve this problem is the first to propose a new block and receive the
    Bitcoin award associated with the block. The “winner” can include any pending
    transactions he chooses in the block but cannot include any invalid ones (i.e.,
    all transactions must be properly signed, and their originating accounts must
    have sufficient funds). If other miners detect that there are invalid transactions
    in the block, they will propose competing blocks.
  prefs: []
  type: TYPE_NORMAL
- en: The community of miners “votes” by each independently choosing which competing
    blocks to build the subsequent new blocks upon. Let’s say that there is a malicious
    miner who includes a large unauthorized Bitcoin transaction to herself whenever
    she wins the math contest to propose a new block. But, no one else will build
    on her block since other miners are also selfish and have no incentive to break
    the rules to benefit her. If she continues to build on it, she will be the only
    one on that branch of the blockchain. It will become really obvious that her branch
    (or fork) of the blockchain is illegitimate.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if a majority of miners (as measured by computing power) collude, they
    could all intentionally build in the invalid block and make the fork appear as
    the legitimate trunk of the Bitcoin blockchain. That is known as a *51 percent
    attack*. In a large blockchain network such as Bitcoin, the amount of resources
    required to accumulate such computing power to reach 51 percent is enormous. With
    that kind of computing power, a potential attacker is economically better off
    following the rules to mine new Bitcoin blocks instead of trying to attack and
    destroy the Bitcoin value for everyone.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: A 51 percent attack is a way for the community to reach consensus to accept
    a block with invalid transactions.
  prefs: []
  type: TYPE_NORMAL
- en: Proof of Stake (PoS)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While PoW is a great invention that has been proven secure in the real world,
    it also suffers from many problems. It requires enormous amounts of computing
    power to perform wasteful computational work to artificially make it economically
    unfeasible for potential attackers. It encourages everyone to participate in the
    mining process, causing consensus to be slow to emerge and converge. When there
    are multiple competing blocks, it takes a long time (an hour or more) for the
    system to settle on a consensus branch.
  prefs: []
  type: TYPE_NORMAL
- en: To solve PoW’s problems, a new consensus mechanism called *proof of stake* was
    proposed. A PoS system allows a straight vote for each new block by the network’s
    stakeholders (account holders for the blockchain’s native cryptocurrency or token).
    The proposer of a new block is randomly chosen. Your voting power is proportional
    to the tokens you hold in your account. With voting, the blockchain can achieve
    finality in each block with a minimal amount of computation. The proposer of an
    accepted new block receives an award in the blockchain’s native cryptocurrency.
  prefs: []
  type: TYPE_NORMAL
- en: 'This process is called *minting* new cryptocurrency as opposed to POW’s *mining*.
    A PoS system is typically much more performant than a PoW system. Examples of
    large public PoS blockchains include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The Casper project ([https://github.com/ethereum/casper](https://github.com/ethereum/casper))
    aims to transform the Ethereum blockchain from a PoW system to a PoS system. Once
    completed, it will be the largest PoS blockchain ecosystem in the world.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The QTUM blockchain ([https://qtum.org/](https://qtum.org/)) is designed to
    be a PoS blockchain based on a Bitcoin-like infrastructure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: An interesting side effect of a PoS cryptocurrency is that stakeholders are
    encouraged to *stake* their tokens to participate in the voting process and receive
    new block awards. They are financially dis-incentivized to trade their tokens.
    That decreases the “money” supply and could make such cryptocurrency more valuable
    in the market.
  prefs: []
  type: TYPE_NORMAL
- en: The voting mechanism in a PoS system is the subject of intense research and
    innovation. Specifically, the system must assume uncooperative or even malicious
    voters. This is commonly known as the Byzantine Generals Problem in game theory.
    A voting mechanism that can be mathematically proven to withstand up to one-third
    of fraudulent voters has to be Byzantine fault tolerant (BFT). BFT consensus engines
    are now widely used in blockchain design.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, a plain PoS system also has significant shortcomings. Here are some
    examples:'
  prefs: []
  type: TYPE_NORMAL
- en: Participants could have nothing to lose by voting yes on invalid block proposals.
    Some kind of penalty (or *slashing*) must be introduced to “punish” misbehaving
    participants.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Voting itself is a technical endeavor few people master, as the performance
    and security requirements are high for a high-performance network.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allowing all stakeholders (even ones with a single token) to vote could result
    in the same performance degradation seen in PoW systems.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The large voting power from large stakeholders could result in a concentration
    of power over time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A few improvements to PoS have been suggested. A leading candidate is called
    *delegated proof of stake* (DPoS).
  prefs: []
  type: TYPE_NORMAL
- en: Delegated Proof of Stake (DPoS)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A DPoS system has only a limited number of validators who can propose and vote
    on new blocks. Stakeholders can “delegate” their cryptocurrencies to validators
    they choose, and validators will vote on their behalf. That allows validators
    to become professional operators (similar to a mining pool in a PoW system) and
    can be subject to penalties if they vote for invalid blocks (or are careless and
    hacked). Examples of DPoS blockchains include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The Bitshares project ([https://bitshares.org/](https://bitshares.org/)) is
    the pioneer of the DPoS concept. It is a public blockchain with 21 elected validators.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Cosmos project ([https://cosmos.network/](https://cosmos.network/)) is a
    public network of blockchains all built on the Tendermint DPoS consensus engine
    that can exchange information with each other. We will cover Cosmos in later chapters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The CyberMiles project ([http://cybermiles.io/](http://cybermiles.io/)) is a
    public blockchain network specifically optimized for smart contracts and compliant
    token issuance for commercial businesses. We will use CyberMiles as an example
    of blockchain system design in later chapters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In political economy terms, DPoS is similar to a representative democracy with
    landowner (or property owner) suffrage.
  prefs: []
  type: TYPE_NORMAL
- en: Validators, or representatives, are delegated by the community to decide the
    day-to-day questions, such as the consensus for each block and each transaction,
    to maintain the integrity of the ledger (no double spend) and the smart contract
    executions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The right to vote on representatives is given to participants who hold a certain
    form of property. This property represents a commitment to the community and also
    a loss of liquidity. In this case, the crypto tokens that represent the value
    of the blockchain network as a whole are the property. This model resembles the
    historical landowner suffrage.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notice that, similar to the democratic system, the property (or tokens) is used
    only for staking a delegate. The staked tokens are locked by the network to prevent
    trading and are made available for penalties. The ownership of the staked tokens
    is never transferred to the validator.
  prefs: []
  type: TYPE_NORMAL
- en: In the end, the purpose of the blockchain is to reach consensus. It is natural
    for us to model consensus after representative democracy mechanisms that human
    society has used for thousands of years.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, I explained how economic engineering works hand in hand with
    software engineering to secure blockchain networks. Such a trustless network requires,
    and also enables, valuable cryptocurrencies to function.
  prefs: []
  type: TYPE_NORMAL
- en: 3. Your First Blockchain App
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The easiest way to get started with blockchain application development is to
    use the open source BUIDL tool—an online integrated development environment (IDE)
    that works in any modern web browser. Just go to [http://buidl.secondstate.io/](http://buidl.secondstate.io/)
    and start coding! BUIDL provides a comprehensive coding environment for creating
    and deploying end-to-end blockchain applications ([Figure 3.1](ch03.xhtml#ch03fig1)).
    You can create an entire blockchain application inside BUIDL, from smart contracts
    on the back end to HTML on the front end, and everything in the middle.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 3.1** BUIDL is an open source online IDE for end-to-end blockchain
    app development.'
  prefs: []
  type: TYPE_NORMAL
- en: For beginners and experts alike, BUIDL takes much of the complexity and guesswork
    out of blockchain development and allows you to focus on coding. It does not require
    any software download or installation. It eliminates the need for developers to
    deal with wallets, private keys, cryptocurrencies, and lengthy transaction confirmation.
    Yet, it deploys your applications on live public blockchains and makes the application
    accessible to anyone you share to.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn to create your first blockchain application
    and then share it with the world. We will walk through key concepts behind blockchain
    applications, also known as *decentralized apps* (*dapps*).
  prefs: []
  type: TYPE_NORMAL
- en: Smart Contract
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In short, a *smart contract* is the back-end service code that lives on the
    blockchain. Once deployed, external applications can invoke functions and code
    inside a smart contract to perform tasks and record the results on the blockchain
    through consensus. The most popular programming language to write smart contracts
    is the Solidity language pioneered by Ethereum. In this example, let’s create
    a simple smart contract and deploy it with BUIDL.
  prefs: []
  type: TYPE_NORMAL
- en: Load BUIDL in your web browser. You will see a simple smart contract already
    in the online editor window ([Figure 3.2](ch03.xhtml#ch03fig2)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 3.2** A simple smart contract in BUIDL'
  prefs: []
  type: TYPE_NORMAL
- en: The contract simply allows you to store a number on the blockchain. You can
    view or update the stored number by calling its functions `get()` and `set()`.
    The code is as follows. The Solidity syntax should be familiar to most developers
    as it is similar to JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch03_images.xhtml#pro3_1)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Click the **Compile** button to compile the contract. A sidebar will open to
    show you the compiled application binary interface (ABI, a JSON-based artifact
    used by the blockchain to facilitate remote function calls) and the bytecode of
    the contract ([Figure 3.3](ch03.xhtml#ch03fig3)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 3.3** Compiled smart contract ready for deployment'
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can click the **Deploy to the chain** button in the left panel to
    instantiate and deploy the contract to a public blockchain. You can interact with
    deployed contracts by calling their public methods from inside BUIDL. For example,
    you can set the contract’s `storedData` value and click the **Transact** button
    to save the value onto the blockchain; then click the **Call** button to see the
    value in the LOG panel ([Figure 3.4](ch03.xhtml#ch03fig4)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 3.4** Interacting with a deployed smart contract on the blockchain'
  prefs: []
  type: TYPE_NORMAL
- en: You have probably noticed that the BUIDL IDE deploys to the Second State DevChain
    by default. This is an Ethereum-compatible public blockchain designed for improving
    the developer experience. For example, the DevChain has a block time of one second,
    and all transactions are confirmed as soon as the block is produced. DevChain
    smart contracts have a fast interaction time of one second instead of a confirmation
    time of minutes or even hours on the public Ethereum blockchain. The “gas price”
    on the DevChain is zero, and hence you do not need to worry about getting crypto
    tokens for pay for “gas.”
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, since the DevChain requires no gas or cryptocurrency, the address
    or account on the blockchain serves only as an ID for the caller of smart contract
    functions. BUIDL automatically generates five addresses for you to use. You can
    see them on the **Accounts** tab ([Figure 3.5](ch03.xhtml#ch03fig5)). You can
    set any of them as your own default address. If you already have an address, you
    can also import it into BUIDL. All address private keys are managed locally in
    your computer’s browser cache. BUIDL does not require you to have any crypto wallet,
    and hence it works on any browser, including smartphone browsers. You can truly
    code anywhere.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 3.5** Addresses/accounts in BUIDL'
  prefs: []
  type: TYPE_NORMAL
- en: Once your smart contract is written, you can deploy it to any Ethereum-compatible
    blockchain including the Ethereum mainnet and testnets. You can do that directly
    from within BUIDL. Please see [Chapter 4](ch04.xhtml#ch04) as well as the BUIDL
    documentation for details.
  prefs: []
  type: TYPE_NORMAL
- en: Front-End HTML
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Next click the **dapp** tab to work on the web application that interacts with
    the smart contract on the blockchain. The HTML front end of the application is
    simple. It displays two buttons that allow users to invoke the two corresponding
    smart contract functions ([Figure 3.6](ch03.xhtml#ch03fig6)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![image](Images/yuan_f03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 3.6** The HTML editor on the dapp tab'
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible to add CSS and JavaScript library resources to the HTML
    via the **Resources** tab in BUIDL ([Figure 3.7](ch03.xhtml#ch03fig7)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 3.7** Resources of the HTML web app'
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript and web3.js
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The HTML web page displays the UI of the dapp. The web application makes function
    calls against the smart contract via the JavaScript web3.js library ([Figure 3.8](ch03.xhtml#ch03fig8)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 3.8** The JavaScript editor on the dapp tab'
  prefs: []
  type: TYPE_NORMAL
- en: The JavaScript has several sections. The `/* Don't modify */` section is populated
    by the BUIDL tool. It contains code to instantiate the contract you just deployed
    via BUIDL. The contract instance and its operations are all defined in the `web3.js`
    library.
  prefs: []
  type: TYPE_NORMAL
- en: The event handler for the Set Data button shows how to call the smart contract’s
    `set()` function in a transaction from JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch03_images.xhtml#pro3_2)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The event handler for the Get Data button calls the smart contract’s get() function
    and displays the result.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch03_images.xhtml#pro3_3)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `web3.js` library supports the JavaScript front end to make remote function
    calls against smart contracts deployed on blockchains.
  prefs: []
  type: TYPE_NORMAL
- en: In Action
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To run the dapp, click the **Run** button in BUIDL. You will see the dapp UI
    in the right panel. You can click the **Set Data** button to store a number, and
    you can click the **Get Data** button to retrieve the stored number. [Figure 3.9](ch03.xhtml#ch03fig9)
    shows the dapp in action.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f03_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 3.9** Running the dapp in BUIDL'
  prefs: []
  type: TYPE_NORMAL
- en: Now you have a dapp running on a public blockchain!
  prefs: []
  type: TYPE_NORMAL
- en: Share Your Dapp
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since the Second State DevChain is a public blockchain, you can share your dapp
    with other people, and they will be able to access it, too. Just click the **Publish**
    button. BUIDL will package the application front end into a single HTML file and
    upload it to a public web site. Once it is done, BUIDL shows a Launched link ([Figure
    3.10](ch03.xhtml#ch03fig10)). Click that link to open the dapp web site. You can
    now share this link with anyone.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f03_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 3.10** Publishing your dapp from BUIDL'
  prefs: []
  type: TYPE_NORMAL
- en: You can also download and save the HTML file from that Launched link onto your
    local computer hard drive. You can put the HTML file on any web host and make
    it accessible to the world. There are many free services to host your HTML files.
  prefs: []
  type: TYPE_NORMAL
- en: When users come to the web page to interact with your dapp, they will see a
    small gadget at the bottom of the page that allows the user to select her blockchain
    address ([Figure 3.11](ch03.xhtml#ch03fig11)). Note that all those addresses are
    automatically generated, and the selected address serves as the user’s on-chain
    ID.
  prefs: []
  type: TYPE_NORMAL
- en: You can also import your own address private key or use your address in MetaMask
    wallet.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f03_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 3.11** Managing addresses in the dapp'
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned, the Second State DevChain requires no gas, and all those addresses
    can have zero balance in cryptocurrency. In an enterprise environment, each user
    might have a unique address as an ID. In such environment, you might need to provision
    addresses and private keys for your authorized users.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, I showed you how to create and deploy your first blockchain
    dapp using the BUIDL tool. The dapp you just built is compatible with the Ethereum
    protocol. In the next part, I will discuss the Ethereum protocol and its applications.
  prefs: []
  type: TYPE_NORMAL
