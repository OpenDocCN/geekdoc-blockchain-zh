- en: Chapter 10\. Overview of Other Hyperledger Projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 2](ch02.xhtml#overview_of_hyperledger_projects_and_to), we briefly
    reviewed 16 Hyperledger projects and tools and discussed the design philosophy,
    core components, and architecture of the Hyperledger ecosystem. In this chapter,
    we will continue our journey by delving into some of these projects in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will help you achieve the following practical goals:'
  prefs: []
  type: TYPE_NORMAL
- en: Building a decentralized identity management system with Hyperledger Aries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running off-chain transaction processing with Hyperledger Avalon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Hyperledger Besu as an open source Ethereum client to bring public blockchain
    to the enterprise
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building and managing supply chain solutions with Hyperledger Grid
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hyperledger Avalon addresses blockchain scalability and privacy challenges through
    trusted off-chain processing. By exploring Hyperledger Besu modular architecture,
    you learned how this open source Ethereum client brings public blockchain to the
    enterprise. As a platform to build supply chain solutions, Hyperledger Grid allows
    developers to choose the best reusable components, frameworks with existing distributed
    ledger platform software, and business-specific applications.
  prefs: []
  type: TYPE_NORMAL
- en: Hyperledger Aries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we discussed in [Chapter 2](ch02.xhtml#overview_of_hyperledger_projects_and_to),
    the *Hyperledger Aries* library is an infrastructure of interoperable tools for
    blockchain-rooted, peer-to-peer interactions. It includes a shared cryptographic
    wallet for blockchain clients, a decentralized identifier (DID) communications
    protocol for allowing off-ledger interactions among those clients, and key management
    technologies. A *shared cryptographic wallet* is a multisignature wallet that
    can be accessible by two or more users. Sending a transaction requires at least
    one “cosigner” of the wallet to be authorized by using their private keys.
  prefs: []
  type: TYPE_NORMAL
- en: Aries grew out of work on Hyperledger Indy, which is an active DLT within the
    Hyperledger family. Increasing demand for standalone libraries that could manage
    identities and boost the security of Hyperledger DLTs like Fabric and Sawtooth
    led to the incubation of Hyperledger Ursa and Hyperledger Aries. As covered in
    [Chapter 2](ch02.xhtml#overview_of_hyperledger_projects_and_to), while Ursa is
    focused on boosting security in the Hyperledger network, the Aries library is
    used in conjunction with other Hyperledger DLTs like Fabric or Sawtooth to manage
    their member IDs in its decentralized architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Aries provides both secure secret management and hardware security functionality
    that utilizes the cryptographic support provided by Ursa. Aries is a blockchain
    interface layer (known as a *resolver*) facilitating interoperability with other
    identity projects and used to create, manage, and transmit digital credentials,
    while Indy provides a resolver implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Aries supports these features:'
  prefs: []
  type: TYPE_NORMAL
- en: A blockchain resolver interface layer for supporting multiple blockchains and
    creating and signing blockchain transactions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A digital wallet for secure data store with vetted credentials
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An encrypted messaging system for off-ledger communication between clients using
    multiple transport protocols
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An implementation of ZKP W3C verifiable credentials using the ZKP primitives
    found in Ursa
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An implementation of the decentralized key management system (DKMS) specification
    currently being incubated in Indy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A mechanism to build higher-level protocols and API-like use cases based on
    the secure messaging functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Figure 10-1](#components_in_the_hyperledger_aries_arc) shows the components
    in the Hyperledger Aries architecture.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Components in the Hyperledger Aries architecture](Images/HLF_1001.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-1\. Components in the Hyperledger Aries architecture
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: By providing a blockchain resolver interface layer, Aries is the agent (client)
    part of a decentralized identity (ledger, DIDs, verifiable credentials). In the
    past, the Indy SDK initiated the decentralized identity. Aries can facilitate
    interoperability among other DID networks, such as Ethereum, Bitcoin, Hyperledger
    Fabric, and Sawtooth. With a pluggable resolver interface architecture, Aries
    provides opportunities for the open source community to build a dynamic set of
    capabilities to interact with a wide variety of use cases related to blockchain-based
    identity. Only minimal information is needed to establish trust, including public
    DIDs, schemas, and credential definitions. This is handled by ZKP in the agent.
    Aries provides a way to communicate data over secure channels between agents.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the current job market, an education background check is one of the critical
    processes used to confirm the education, training, or certification claims of
    candidates and identify any potential discrepancies. Aries can create, transmit,
    and store verifiable digital credentials (such as a college degree) to make this
    verification process more efficient. To demonstrate how Aries works, we will create
    the following two agents:'
  prefs: []
  type: TYPE_NORMAL
- en: Alice, who graduated from Faber College
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Faber College, which granted Alice’s degree
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Creating these agents requires two steps. First, Alice connects with the college
    and issues a credential about her degree. Second, Faber College will send a proof
    request to verify Alice’s degree. To run this Aries demonstration on the local
    machine, we first need the following installed:'
  prefs: []
  type: TYPE_NORMAL
- en: Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Compose
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Git
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To run this demo, we also use a *von-network* instance (a Hyperledger Indy public
    ledger sandbox) running in Docker locally. This instance implements an Indy ledger
    with four nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Set Up von-network
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start by opening a bash terminal and cloning the *von-network* Git repo:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Once we clone the repo, we can start to build VON Network Docker images and
    start our VON Network by using the *./manage* bash script in the *von-network*
    folder. The script simplifies the process of building the images and brings up
    the network.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The VON Network is a portable development-level Indy node network, which is
    part of the Verifiable Organizations Network (VON). The mission of VON is to build
    a network providing trustworthy data for organizations—locally and around the
    globe.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: After the VON Network is up and running, you can view the node pool and ledger
    by visiting [*http://your-machine-ip:9000*](http://your-machine-ip:9000) in your
    browser.
  prefs: []
  type: TYPE_NORMAL
- en: Run Hyperledger Aries Cloud Agent
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next, we will use Hyperledger Aries Cloud Agent Python (ACA-Py) to build and
    deploy two instances of the agents—one for Alice, the other for Faber College.
    ACA-Py is a foundation for building decentralized identity applications and services
    running in nonmobile environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run this command to clone the ACA-Py repo and navigate to the *demo* folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, start the Faber agent by issuing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You should see agent terminals for Faber show their public DIDs, and the schema
    and credential definition, and QR invitation code details.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open another terminal window and navigate to the *demo* folder. Then issue
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This brings up the Alice agent. With both agents starting, Alice is waiting
    for an input invitation from Faber.
  prefs: []
  type: TYPE_NORMAL
- en: Copy the Faber invitation JSON data from the Faber terminal and paste it at
    the Alice prompt. The agents will connect and then show a menu of options.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the connection is built between Alice and Faber, the Alice terminal will
    display a response with invitation key and DID information, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'For Faber, we now have five options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'For Alice, we have three options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Issue credentials
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can now test the credential exchange protocols by issuing and proving credentials
    from Faber. We don’t need to do anything from the Alice agent. Her agent will
    automatically receive credentials and respond to proof requests from the ACA-Py
    demo code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Faber terminal window, enter `**1**` to send a credential:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In the Alice terminal window, we will see this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: After Faber issues a credential offer, Alice receives the credential. Then Alice
    sends back a credential request. Faber receives Alice’s message and acknowledges
    that Alice has received the credential. Then Alice stores the credentials in her
    wallet.
  prefs: []
  type: TYPE_NORMAL
- en: Request a proof
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To request a proof, enter `**2**` in the Faber terminal, and we will see this
    message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The Alice terminal window will display the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We can see that after Faber sends a proof request, Alice receives a request
    and query for credentials in the wallet that satisfies the proof request. Then
    Alice generates the credential proof of degree and sends the proof back to Faber.
    Faber receives the proof provided by Alice and then starts to process and verify
    the proof.
  prefs: []
  type: TYPE_NORMAL
- en: Once the proof is verified, Faber will update and mark the proof as `true` to
    indicate it’s verified. As we can see, proof is generated on Alice’s side without
    exposing Alice’s actual personal data.
  prefs: []
  type: TYPE_NORMAL
- en: Hyperledger Avalon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Blockchain is a decentralized encrypted database system. Every transaction processed
    by a node needs to broadcast to other nodes in the network. This behavior ensures
    that transactions are transparent and reflects the state of the ledger. In addition,
    the behavior will result in data resiliency, as many copies of this data exist
    across the nodes participating in the network. However, using this architecture
    comes at the cost of scalability with low throughput. Only a limited number of
    transactions in the blockchain can be processed.
  prefs: []
  type: TYPE_NORMAL
- en: The public blockchain is accessible to everyone, and every transaction can be
    traced back to the first genesis block. A cryptocurrency user uses their private
    key to access the blockchain and initiate blockchain transactions. The transaction
    data in blockchain is pseudo-anonymous; it is not possible to assign the data
    to a person without connecting to additional personal information (e.g., a digital
    identity). In certain applications (global trading, for example), keeping some
    sensitive company data confidential and logic encrypted is required, to prevent
    it from becoming vulnerable to corruption, stolen by competitors, or explored
    by outside entities frontrunning the competition.
  prefs: []
  type: TYPE_NORMAL
- en: The *Hyperledger Avalon* project was created to address scalability and privacy
    challenges. Through trusted off-chain computing, Avalon is used to maintain resiliency
    and integrity guarantees as much as possible while accomplishing additional scalability
    and privacy.
  prefs: []
  type: TYPE_NORMAL
- en: The core strategy to accomplishing scalability and ensuring that computation
    is done correctly and secretly is a trusted compute service that provides a trusted
    execution environment, zero-knowledge proof, and multiparty computation.
  prefs: []
  type: TYPE_NORMAL
- en: Trusted Execution Environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Applications running in a *trusted execution environment* (*TEE*) can ensure
    strong data confidentiality. The Hyperledger Avalon TEE uses Intel’s Software
    Guard Extensions (SGX). This extension to the x86 architecture has a set of security-related
    instruction codes to run applications in a completely isolated, secure manner.
    It is built into some modern Intel central processing units (CPUs). In SGX, user-level
    code will allocate private regions of memory, called *enclaves*. The application
    process is running at higher privilege levels, not only isolated from other applications
    on the same system, but also from the operating system and possible hypervisor.
    System administrators can’t tamper with the application after it is started.
  prefs: []
  type: TYPE_NORMAL
- en: SGX data confidentiality brings significant benefits to the enterprise blockchain
    workloads and enhances a trustworthy link between off-chain and on-chain execution.
    SGX can handle accessing off-chain transaction resources and compute confidential
    data, trusted tokens, attested oracles, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Zero-Knowledge Proofs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Zero-knowledge proofs* (*ZKPs*) are mathematical methods that allow data to
    be verified without sharing or revealing that data. In a transaction using ZKPs,
    the basic roles are the prover and verifier. The *prove*r needs to prove something
    based on a small piece of unlinkable information to the verifier, without telling
    the verifier anything else about that information. The verifier must verify that
    the prover is telling the truth.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A true ZKPs needs to prove three criteria:'
  prefs: []
  type: TYPE_NORMAL
- en: Completeness
  prefs: []
  type: TYPE_NORMAL
- en: The statement from the prover is true and should eventually convince the honest
    verifier.
  prefs: []
  type: TYPE_NORMAL
- en: Soundness
  prefs: []
  type: TYPE_NORMAL
- en: If the statement is false, it cannot convince the verifier that the prover’s
    statement is true.
  prefs: []
  type: TYPE_NORMAL
- en: Zero-knowledge-ness
  prefs: []
  type: TYPE_NORMAL
- en: If the statement is true, only the statement being proven is revealed.
  prefs: []
  type: TYPE_NORMAL
- en: A simple example that presents the fundamental ideas of ZKPs is *Where’s Waldo*.^([1](ch10.xhtml#ch01fn2))
    It has cryptography’s favorite fictional characters, Alice and Bob. The objective
    of the *Where’s Waldo* book series is to comb through the crowds of people to
    find Waldo.
  prefs: []
  type: TYPE_NORMAL
- en: Assume that Bob is the prover, and Alice is the verifier. Bob claims he has
    an algorithm that can find Waldo easily, but he wants to be paid to use his algorithm.
    Alice wants to buy it, but she wants to be sure that Bob is not lying and wants
    him to prove himself. As with many transactions, Alice and Bob don’t fully trust
    each other.
  prefs: []
  type: TYPE_NORMAL
- en: Now, Bob needs proof his algorithm works. He points out the location of Waldo
    on the page. To make sure Bob’s algorithm fully works, Alice selects other pages
    that also have Waldo. As Bob has the algorithm, he will always be able to find
    Waldo on the page that Alice gives to him. The more times Bob repeats this exercise,
    the more probable it is that Bob has an effective, fast algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, the solutions fulfill the three properties of ZKP systems:
    soundness, completeness, and zero-knowledge:'
  prefs: []
  type: TYPE_NORMAL
- en: Soundness
  prefs: []
  type: TYPE_NORMAL
- en: Alice provides a random page of the scene to let Bob prove his algorithm, Bob’s
    proof systems are truthful and do not let him cheat.
  prefs: []
  type: TYPE_NORMAL
- en: Completeness
  prefs: []
  type: TYPE_NORMAL
- en: As long as Bob is able to consistently find Waldo by using his algorithm, Bob’s
    proof systems convince Alice that he can find Waldo.
  prefs: []
  type: TYPE_NORMAL
- en: Zero-knowledge
  prefs: []
  type: TYPE_NORMAL
- en: Bob proves to Alice that he has found Waldo without revealing his algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Multiparty Computation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Multiparty computation* (*MPC*) is a cryptographic protocol that allows independent
    parties to jointly compute a shared result without revealing an individual party’s
    data. Let’s take a look at an average salary example to understand how MPC works.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose Alice’s salary is $50K and Bob’s salary is $80K. Alice splits her salary
    into two randomly generated pieces: $20K and $30K, for example. Alice keeps $20K
    as a secret piece to herself and sends $30K to Bob. Similarly, Bob splits his
    salary into two randomly generated pieces: $10K and $70K. Bob keeps $70K as a
    secret piece to himself and sends $10K to Alice. Now Alice and Bob hold a set
    of values, as listed in [Table 10-1](#divided_salaries_of_alice_and_bob).'
  prefs: []
  type: TYPE_NORMAL
- en: Table 10-1\. Divided salaries of Alice and Bob
  prefs: []
  type: TYPE_NORMAL
- en: '|  | Alice | Bob |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **Total: $50K** | $20K | $30K |'
  prefs: []
  type: TYPE_TB
- en: '| **Total: $80K** | $10K | $70K |'
  prefs: []
  type: TYPE_TB
- en: Alice and Bob know nothing about each other’s salaries. They have no useful
    information from the other party’s secret piece.
  prefs: []
  type: TYPE_NORMAL
- en: However, Alice and Bob can locally sum up their values. This will provide valuable
    information, as shown in [Table 10-2](#combined_salaries_of_alice_and_bob). Then,
    the recombined sum divided by the number of participants yields an average salary
    of $65K.
  prefs: []
  type: TYPE_NORMAL
- en: Table 10-2\. Combined salaries of Alice and Bob
  prefs: []
  type: TYPE_NORMAL
- en: '|  | Alice | Bob |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **Total: $130K** | $30K | $100K |'
  prefs: []
  type: TYPE_TB
- en: Since MPC is complex, not many real-world projects use this technology. One
    well-known example is using the Sharemind MPC platform to perform research based
    on two private, secret, shared governmental databases; one 2015 project studied
    the correlation between working while attending college and failing to graduate
    on time.
  prefs: []
  type: TYPE_NORMAL
- en: Hyperledger Avalon Architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Avalon, trusted workers (e.g., TEE, MPC, and ZKP workers) are hosted by a
    trusted compute service (TCS). Workers are set up by the TCS. The workers can
    create attestation verification that is signed by TEE SGX as attestation information.
    The attestation information can be published in the worker directory on the blockchain.
    In a TEE SGX worker case, worker attestation information is generated as an asymmetric
    signing/verification key pair. A requester can find the worker in the worker directory
    from the DLT and verifies and stores its attestation info.
  prefs: []
  type: TYPE_NORMAL
- en: A requester app or smart contract submits a work order request. The TCS receives
    and maintains a work order queue. By checking available workers, the TCS schedules
    the work orders for execution. During the work order execution stage, the trusted
    workers execute these work orders and record the work order response on the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 10-2](#hyperledger_avalon_high_level_architect) shows the Hyperledger
    Avalon high-level architecture.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Hyperledger Avalon high-level architecture](Images/HLF_1002.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-2\. Hyperledger Avalon high-level architecture
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The requestor can connect to TCS via two models: the proxy model and direct
    model. In the *proxy model*, a blockchain connector is used to connect requests
    from a smart contract (Ethereum) or chaincode (Fabric) running on the DLT. In
    this model, the blockchain is acting as a proxy. The *direct model* provides a
    JSON RPC API for passing requests submitted by requesters via a frontend UI or
    command-line tools.'
  prefs: []
  type: TYPE_NORMAL
- en: In the middle tier, the work order queue manager will handle work order requests,
    delegate execution of the work orders to execution adaptors, and maintain work
    order queue size. The worker registry stores the list’s trusted compute workers.
  prefs: []
  type: TYPE_NORMAL
- en: Between frontend and middleware components is the KV Storage Manager, a thin
    wrapper implemented on top of the Lightning Memory-Mapped Database (LMDB) that
    maintains the worker directory and work order queue.
  prefs: []
  type: TYPE_NORMAL
- en: In the worker TCF microservice component, the trusted worker executes application-specific
    workloads. Workloads can be either static, precompiled scripts, or scripts that
    are provided at runtime (e.g., Solidity or Python). Workload script logic is typically
    application related.
  prefs: []
  type: TYPE_NORMAL
- en: Hyperledger Besu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Hyperledger Besu*, formerly known as *Pantheon*, is an open source Ethereum
    client designed to connect large enterprises with the public Ethereum blockchain.
    It is written in Java. Besu can be run on the Ethereum public network, private
    networks, and test networks such as Ropsten (proof-of-work testnet), Kovan (proof-of-authority
    testnet), Gorli (proof-of-authority testnet), and Rinkeby (proof-of-authority
    testnet).'
  prefs: []
  type: TYPE_NORMAL
- en: 'As a basic Ethereum client, it has the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: Connects to the blockchain network to synchronize blockchain transaction data
    or emit events to the network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processes transactions through smart contracts in an EVM environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provides data storage for networks (blocks)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Publishes a client API interface for developers to interact with the blockchain
    network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hyperledger Besu Architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Figure 10-3](#hyperledger_besu_architecture) shows the high-level Hyperledger
    Besu architecture, which consists of three key layers.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Hyperledger Besu architecture](Images/HLF_1003.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-3\. Hyperledger Besu architecture
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Ethereum storage layer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Ethereum Virtual Machine (EVM) is a powerful, Turing complete virtual machine
    embedded within each full Ethereum node. Smart contracts will compile and deploy
    to EVM bytecode. EVM is responsible for executing contract bytecode within an
    Ethereum blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: Besu implements proof-of-work (PoW) and proof-of-authority (PoA) consensus mechanisms
    via Ethash, Clique, and IBFT 2.0\. As explained in [Chapter 1](ch01.xhtml#fundamental_concepts_of_blockchain),
    PoW is a consensus algorithm that relies on energy by solving a cryptographic
    puzzle. The puzzle is to find an input that produces a hash number with a certain
    number of leading zeros. The work of resolving the math problem is called PoW.
  prefs: []
  type: TYPE_NORMAL
- en: PoA is an algorithm that selects a limited number of trusted nodes. These nodes
    have proven their authority and are responsible for validating transactions, generating
    new blocks, and keeping the network working. Besu implements several PoA protocols,
    including Clique and IBFT 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: Clique is a PoA blockchain consensus protocol. The blockchain runs the Clique
    protocol, maintaining the list of authorized signers. These approved signers validate
    transactions, and blocks and take turns to create the next block without mining.
    Therefore, the transaction task is computationally light. When creating a block,
    a miner collects and executes transactions, updates the network state with the
    calculated hash of the block, and signs the block by using their private key.
    By defining a period of time to create a block, Clique can limit the number of
    processed transactions.
  prefs: []
  type: TYPE_NORMAL
- en: IBFT 2.0 (Istanbul BFT 2.0) is a PoA Byzantine-fault-tolerant (BFT) blockchain
    consensus protocol. Transactions and blocks in the network are validated by authorized
    accounts, known as *validators*. Validators collect, validate, and execute transactions
    and create the next block. Existing validators can propose and vote to add or
    remove validators and maintain a dynamic validator set. The consensus can ensure
    immediate finality. As the name suggests, IBFT 2.0 builds upon the IBFT blockchain
    consensus protocol with improved safety and liveness. In IBFT 2.0 blockchain,
    all valid blocks are directly added in the main chain, and there are no forks.
  prefs: []
  type: TYPE_NORMAL
- en: Storage layer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Besu uses a RocksDB database to store data locally. This data is divided into
    two parts:'
  prefs: []
  type: TYPE_NORMAL
- en: Blockchain
  prefs: []
  type: TYPE_NORMAL
- en: Blockchain data is composed of block headers and block bodies. Each block header
    contains sets of block metadata (the hash of the previous block, a timestamp,
    nonce, etc.) that is used to cryptographically verify blockchain state. Block
    bodies contain the list of ordered transactions included in each block.
  prefs: []
  type: TYPE_NORMAL
- en: World state
  prefs: []
  type: TYPE_NORMAL
- en: The world state is a database that holds the current value of the attributes
    of a business object that have been added, modified, or deleted by the set of
    validated and committed transactions in the blockchain. Every block header references
    a world state via a `stateRoot` hash. The world state is a mapping between addresses
    and account states. As a global state, it is constantly updated by transaction
    executions.
  prefs: []
  type: TYPE_NORMAL
- en: Network storage layer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Besu implements point-to-point (P2P) networking with Ethereum’s DEVp2p network
    protocols for interclient communication and an additional subprotocol for IBFT
    2.0\. In the DEVp2p network, after the peer node’s secure TCP connection is established,
    DEVp2p negotiates an application session between two connected peers. Each node
    will send another peer a greeting message with its own node ID, DEVp2p version,
    client name, and other node-related metadata. Then the nodes start transmitting
    application data packets over DEVp2p. DEVp2p nodes will periodically ping connected
    clients to ensure that their connected peers are still active. If a corresponding
    DEVp2p message is not received by a client within the maximum allowed idle time,
    the node connection will be closed.
  prefs: []
  type: TYPE_NORMAL
- en: Besu provides powerful user-facing APIs through mainnet Ethereum, and EEA JSON-RPC
    APIs over HTTP and WebSocket protocols, as well as a GraphQL API.
  prefs: []
  type: TYPE_NORMAL
- en: Besu’s monitoring allows you to identify node and network issues. You can configure
    metrics and logging. Node performance is monitored by using the Prometheus Visual
    tool or the `debug_metrics` JSON-RPC API method. Network performance is monitored
    with Alethio tools such as Block Explorer and EthStats Network Monitor. You can
    also collect Besu log files to enable issue diagnosis.
  prefs: []
  type: TYPE_NORMAL
- en: Besu uses a private transaction manager, Orion, to implement privacy. Private
    transactions that were signed with the node private key are sent or received from
    the Besu node to the associated Orion node. Besu and Orion nodes both have public/private
    key pairs identifying them. Other parties cannot access the transaction content,
    sending party, or list of participating parties.
  prefs: []
  type: TYPE_NORMAL
- en: By enabling node permissioning and account permissioning, a permissioned network
    allows only specific nodes and accounts to access the network. Node permissioning
    is used to control connections between individual nodes. Account permissioning
    can limit which accounts a node can allow to perform the transactions, deny the
    broken smart contracts, suspend accounts, and enforce onboarding or identity requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Set Up Hyperledger Besu
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To demonstrate how Hyperledger Besu works, we will run a private network example.
    It uses the Hyperledger Besu Docker image to run a private network of Besu nodes.
    To run this example, you must have the following installed:'
  prefs: []
  type: TYPE_NORMAL
- en: Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Compose
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Git
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: cURL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Node.js (version 10+)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: npm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MetaMask
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you haven’t installed Docker and Docker Compose yet, you can find the installation
    guide at the Docker official website. The Node.js site will give you instructions
    to install Node.js and npm.
  prefs: []
  type: TYPE_NORMAL
- en: MetaMask as an Ethereum wallet is a Google Chrome browser plugin. It can connect
    a blockchain network from Ethereum-based DApps. Users can invoke smart contracts
    to transfer coins, play games, and more. You can find the installation guide at
    the MetaMask site (*[*https://metamask.io*](https://metamask.io)*).
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, we’ll open a bash terminal and clone the *besu-sample-network* Git
    repo, and then navigate to the *besu-sample-networks* directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, start the Besu sample network by running this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The script builds the images, and creates a local private Besu network using
    Docker. The default consensus mechanism is Ethash; you can select other consensus
    mechanism by using `-c <ibft2|clique|ethash>` on your private network.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the network starts, you should see a list of the running services in the
    terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll also see a list of the endpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: JSON-RPC HTTP service endpoint
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A JSON-RPC HTTP service endpoint is a lightweight remote procedure call (RPC)
    protocol that provides access to Besu node service from a DApp client or cryptocurrency
    wallets such as MetaMask. You can run RPC requests on rpcnode by using a cURL
    command or other HTTP tools (for example, Postman).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the command to submit a request to get the most recently mined block
    number. You will need to replace *<http-rpc-endpoint>* from *http://localhost:8545*
    with your machine IP address if you run from an external command-line terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The response shows the most recently mined block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: JSON-RPC WebSocket
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A JSON-RPC WebSocket service endpoint provides a web socket endpoint for a DApp
    client connected to node service.
  prefs: []
  type: TYPE_NORMAL
- en: GraphQL HTTP service endpoint
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: GraphQL, a query language for the HTTP API, supports a runtime for executing
    queries with the existing data. It is in contrast to REST APIs that expose a suite
    of URLs, and each of these URLs exposes a single resource. You can connect the
    HTTP GraphQL node service from your DApp.
  prefs: []
  type: TYPE_NORMAL
- en: GraphQL is both a query language for your API and a server-side runtime for
    executing queries by using a type system you define for your data
  prefs: []
  type: TYPE_NORMAL
- en: Web block explorer address
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The web block explorer address is an online block explorer that displays the
    contents of individual blockchain transactions, blocks, the transaction histories,
    and balances of addresses.
  prefs: []
  type: TYPE_NORMAL
- en: You can access the explorer by entering the web block explorer address in the
    browser ([Figure 10-4](#web_block_explorer_address)). It will display a summary
    of the private network.
  prefs: []
  type: TYPE_NORMAL
- en: '![Web block explorer address](Images/HLF_1004.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-4\. Web block explorer address
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In this example, the explorer indicates three peers: the one regular node,
    the mining node, and the bootnode. Click the block number (#1107) to display the
    block details ([Figure 10-5](#web_block_explorer_block_details)).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Web block explorer block details](Images/HLF_1005.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-5\. Web block explorer block details
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Prometheus address
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Prometheus provides monitoring and alerting services for Besu node metrics.
    The data stored in Prometheus can be used in Grafana to visualize the collected
    data. The link for the Prometheus address can access the Prometheus dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: Grafana address
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Grafana dashboard provides a visualization and analytics tool to monitor
    Besu network connection, sync state, and block import rate along with CPU and
    memory usage statistics. The required data in Grafana comes from the Prometheus
    data store, which is exported directly from Besu.
  prefs: []
  type: TYPE_NORMAL
- en: With the Besu example network set up, we will now run a smart contract and DApp
    in the Besu test network. In this DApp example, we will use MetaMask to send transactions.
  prefs: []
  type: TYPE_NORMAL
- en: Set up MetaMask and account
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Use the following steps to set up MetaMask:'
  prefs: []
  type: TYPE_NORMAL
- en: Sign in to MetaMask.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the MetaMask network list, select Custom RPC. Enter the JSON-RPC HTTP service
    endpoint: [*http://your-machine-ip:8545*](http://your-machine-ip:8545).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save and return to the MetaMask main screen. MetaMask is now connected to the
    private network RPC node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create an account or use one of the following accounts provided by Besu for
    testing purposes. You can import an account into MetaMask by using the private
    key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[Figure 10-6](#metamask_import_private_key_screen) shows the MetaMask Import
    private-key screen.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![MetaMask Import private key screen](Images/HLF_1006.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 10-6\. MetaMask Import private key screen
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: MetaMask is a browser extension cryptocurrency wallet for accessing Ethereum
    blockchain. You can visit *metamask.io* to get more info.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Smart Contract and DApp in Hyperledger Besu Private Network
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will run the PetShop tutorial on the Truffle website in the Hyperledger Besu
    private network we just set up. PetShop is an adoption tracking system for a pet
    shop. Users can adopt a pet by sending Ether tokens in the network.
  prefs: []
  type: TYPE_NORMAL
- en: The DApp requires you to install Truffle. For this setup, we use Truffle v5.0.15\.
    Truffle is an end-to-end Ethereum DApp development tool that provides a development
    environment for writing, compiling, testing, and deploying smart contracts and
    DApps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the command line and run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The PetShop source code for the smart contract and DApp are in the *pet-shop*
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Run *./run-dapp.sh* in the *besu-sample-networks* directory to start the PetShop
    DApp:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The *run-dapp.sh* script runs `npm install` under the *pet-shop* folder, then
    uses the Truffle command to compile, migrate, and test the smart contract in `sampleNetworkWallet`.
    If successful, it builds a container for the PetShop DApp and deploys it in *besu-sample-network*.
    The DApp container binds port 3001 on the system.
  prefs: []
  type: TYPE_NORMAL
- en: Once the DApp is up, you can open the browser by entering **[*http://your-machine-ip:3001*](http://your-machine-ip:3001)**,
    which should have the PetShop running. If you click the Adopt button to adopt
    a pet, a MetaMask window should pop up and ask to confirm or reject the current
    adoption transaction ([Figure 10-7](#in_this_pet_store_dappcomma_note_the_me)).
  prefs: []
  type: TYPE_NORMAL
- en: '![In this pet store DApp, note the MetaMask window in the upper right](Images/HLF_1007.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-7\. In this pet store DApp, note the MetaMask window in the upper
    right
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: After confirming the transaction, the status of the adopted pet will show Success.
    The MetaMask UI will keep a record of the confirmed transaction ([Figure 10-8](#metamask_transaction_confirmation)).
  prefs: []
  type: TYPE_NORMAL
- en: '![MetaMask transaction confirmation](Images/HLF_1008.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-8\. MetaMask transaction confirmation
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We can also search the same transaction from the Block Explorer UI by entering
    the transaction hash to see the transaction detail ([Figure 10-9](#block_explorer_transaction_detail)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Block Explorer transaction detail](Images/HLF_1009.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-9\. Block Explorer transaction detail
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'When all is completed, you can stop the private network and remove the containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The command will shut down the private network and delete all containers and
    images created from running the sample network.
  prefs: []
  type: TYPE_NORMAL
- en: Hyperledger Grid
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since the blockchain is a transparent, immutable, and secure decentralized
    system, it enables participants to record every transaction within a supply chain;
    the ledger data is shared among all actors. Traditional supply chain industries
    using blockchain technology could improve the following areas:'
  prefs: []
  type: TYPE_NORMAL
- en: Tracking the assets from production to delivery, or through use by the end user
    in the entire chain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verifying and authenticating physical assets in the chain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensuring that ledger data is immutable and shared among supply chain participants
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing better auditability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, developing blockchains for supply chain applications is not an easy
    task, especially when building everything from scratch. The use case can contain
    a vast amount of information on everything from a product order, to delivery,
    to the number of parts contained within one item. A small bug could cause the
    entire supply chain application to be corrupted and worthless. Developing a full
    production-ready blockchain application is also time-consuming. The Hyperledger
    ecosystem doesn’t have many reusable libraries, frameworks, domain models, or
    standard components that enable quickly creating supply chain solutions. This
    is what the *Hyperledger Grid* project is trying to solve.
  prefs: []
  type: TYPE_NORMAL
- en: Grid is a platform for building supply chain solutions that allows developers
    to choose the best reusable components, frameworks with existing distributed ledger
    platform software, and business-specific applications. [Figure 10-10](#hyperledger_grid_platform_stack)
    shows the Hyperledger Grid platform stack.
  prefs: []
  type: TYPE_NORMAL
- en: '![Hyperledger Grid platform stack](Images/HLF_1010.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-10\. Hyperledger Grid platform stack
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Grid’s key components are domain models, a smart contract, a universal client,
    Pike, and sample apps.
  prefs: []
  type: TYPE_NORMAL
- en: Domain Models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Grid uses existing open standards such as GS1, Open Data Initiative, and Blockchain
    in Transit Alliance (BiTA) standards to implement domain-specific data models.
    GS1 provides a global standard business language to identify, capture, and share
    supply chain data—ensuring that key information about products, locations, assets,
    and more is accessible, accurate, and easy to understand. The best known of these
    standards is the barcode.
  prefs: []
  type: TYPE_NORMAL
- en: Smart Contracts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The smart contract builds the business logic based on industry best practices,
    including product catalogs, product transformation, and batch behavior. It executes
    various business transactions in a decentralized way in the blockchain. The smart
    contracts are handled by the Sawtooth Sabre smart contract interpreter, which
    implements on-chain smart contracts in a WebAssembly virtual machine.
  prefs: []
  type: TYPE_NORMAL
- en: '*WebAssembly* is an open standard inside the W3C WebAssembly Community Group.
    It defines a fast, efficient, and portable WebAssembly binary-code format for
    executable programs. The corresponding low-level textual assembly language is
    readable and debuggable. WebAssembly is designed to be secure, and its code is
    run in a safe, sandboxed execution environment. By taking advantage of common
    hardware capabilities, it provides interfaces for nicely facilitating interactions
    with other web technologies and maintains backward compatibility.'
  prefs: []
  type: TYPE_NORMAL
- en: All Sawtooth Sabre objects are serialized using Protocol Buffers before being
    stored in state. These objects include namespace registries, contract registries,
    and contracts.
  prefs: []
  type: TYPE_NORMAL
- en: Pike
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Pike* is a smart contract that is designed to track agents and the organization’s
    identity permissions in the supply chain. The Pike agent is a cryptographic public
    key, which contains role information representing an organization’s relationships.
    These roles can be used to determine user access permission with a platform.'
  prefs: []
  type: TYPE_NORMAL
- en: 'An agent has five attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`public_key`'
  prefs: []
  type: TYPE_NORMAL
- en: An agent’s unique cryptographic public key
  prefs: []
  type: TYPE_NORMAL
- en: '`org_id`'
  prefs: []
  type: TYPE_NORMAL
- en: The agent’s organization identifier
  prefs: []
  type: TYPE_NORMAL
- en: '`active`'
  prefs: []
  type: TYPE_NORMAL
- en: The activity flag to indicate whether the agent is currently active at the organization
  prefs: []
  type: TYPE_NORMAL
- en: '`roles`'
  prefs: []
  type: TYPE_NORMAL
- en: A list of roles the agent has with the organization
  prefs: []
  type: TYPE_NORMAL
- en: '`metadata`'
  prefs: []
  type: TYPE_NORMAL
- en: A set of key-value data describing organization-specific information about the
    agent
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of a Pike agent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '`PikePayload` as a Pike transaction contains two parts: enumeration of action
    and transaction actions. The following Protocol Buffers code shows how to define
    `PikePayload`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: SDK
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Currently, Pike uses the Rust SDK to develop smart contracts. This SDK has
    three modules: permission, protocol, and protos. In the previous section, `PikePayload`
    is a protos module.'
  prefs: []
  type: TYPE_NORMAL
- en: Sample Apps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Grid provides sample apps that can help demonstrate how to combine Grid components
    to build a supply chain application. The Grid Track and Trace example is the first
    showcase. This smart contract allows users to track goods, including a history
    of ownership and custodianship, as well as histories for a variety of properties
    such as temperature and location through a supply chain.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter covered four members of the Hyperledger family: Hyperledger Aries,
    Hyperledger Avalon, Hyperledger Besu, and Hyperledger Grid. Specifically, we discussed
    how Aries works: it provides a blockchain interface layer, facilitates interoperability
    with other identity projects, and is used to create, manage, and transmit digital
    credentials. As a trusted compute framework, Avalon addresses blockchain scalability
    and privacy challenges through trusted off-chain processing. By exploring Besu
    modular architecture, you learned how this open source Ethereum client brings
    public blockchain to the enterprise. As a platform for building supply chain solutions,
    Grid allows developers to choose the best reusable components, frameworks with
    existing distributed ledger platform software, and business-specific applications.'
  prefs: []
  type: TYPE_NORMAL
- en: Concluding Remarks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout the course of this text, you have learned about all the aspects and
    facets to consider for developing and deploying an enterprise blockchain application
    by using Hyperledger Fabric. We hope that we have educated you not only on all
    of the facets and features of Fabric application development, but also on the
    importance of looking at your blockchain ecosystem in a much broader sense to
    include things such as intra-industry consortiums, data governance, and change
    management.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should walk away from this book feeling that you know how to build a private
    enterprise blockchain system using Hyperledger Fabric and that you know how to
    put together various components of Fabric to create and maintain a robust, secure,
    and scalable blockchain application. Because of a lack of space, some topics have
    been left out for you to explore on your own. Specifically, here are areas that
    merit further consideration:'
  prefs: []
  type: TYPE_NORMAL
- en: Using design patterns for integrating Fabric into current or legacy systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Considering post-production factors such as reliability, availability, and serviceability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing continuous integration and continuous delivery and DevOps best
    practices to achieve agility in the Fabric network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Taking microservices and event-driven architectures into consideration while
    designing your enterprise Fabric architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Best practices for achieving resilience and fault tolerance in a Fabric network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Best practices for securing Fabric smart contracts and networks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next Steps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You probably have lots of questions. That’s good. Gather those questions and
    send them to us (via [email](mailto:info@myhsts.org) or contact form on our [website](https://www.coding-bootcamps.com/)).
    But in general we recommend that you don’t stop here. Try to find practical problems
    and create and launch their solutions with Hyperledger Fabric.
  prefs: []
  type: TYPE_NORMAL
- en: Beyond practical experience, we recommend you keep reading. As always, check
    out the [Hyperledger website](https://www.hyperledger.org/) to follow the latest
    developments and see the latest projects built with Fabric, as well as to get
    the latest updates on Fabric versions and patches. Likewise, [Fabric Wiki](https://wiki.hyperledger.org/)
    pages provide developers with great hands-on resources for expanding their knowledge
    and expertise on all Hyperledger DLTs, tools, and libraries.
  prefs: []
  type: TYPE_NORMAL
- en: To help cement everything you have learned, you need to use it. Experience is
    one way we have already mentioned, but mentorship, teaching, and general presenting
    is another great way to learn. If you have to explain something to someone else,
    especially when the format is formal, like a presentation, it forces you to consolidate
    your ideas and commit your models and generalizations to memory. Don’t fall into
    the trap of thinking that you are not experienced enough to talk about it. You
    are; you are an expert in the experiences you have had. It is very likely that
    you can apply, explain, or teach some of your experiences with Hyperledger Fabric
    in a way that nobody else could. Give it a go!
  prefs: []
  type: TYPE_NORMAL
- en: Now It’s Your Turn
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With that, we will hand it over to you.
  prefs: []
  type: TYPE_NORMAL
- en: As you know, you can find more resources on the accompanying [website](https://www.myhsts.org/).
    But we also want to hear from you. We want to hear about the projects you are
    working on, your challenges, your tips and tricks, and your ideas for the future
    of Hyperledger Fabric. We especially want to talk to you if you are thinking about
    applying Fabric in industry or you are struggling with a problem. We can make
    your life easier with solutions, tips, and assessments to reduce effort, reduce
    risks, and improve performance. From designing a basic proof of concept to deploying
    a large-scale consortium solution, we are available to help. So feel free to reach
    us through our [website](https://www.hashflow.us/).
  prefs: []
  type: TYPE_NORMAL
- en: Good luck!
  prefs: []
  type: TYPE_NORMAL
- en: Further Reading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Hyperledger DLTs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Hyperledger Cookbook* by Brian Wu, Chuanfeng Zhang, and Andrew Zhang (Packt
    Publishing)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Blockchain with Hyperledger Fabric*, Second Edition, by Nitin Gaur et al.
    (Packt Publishing)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ethereum and Solidity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Learn Ethereum* by Brian Wu, Zhihong Zou, and Dongying Song (Packt Publishing)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ^([1](ch10.xhtml#ch01fn2-marker)) *Where’s Wally*, if you’re reading this outside
    of North America.
  prefs: []
  type: TYPE_NORMAL
