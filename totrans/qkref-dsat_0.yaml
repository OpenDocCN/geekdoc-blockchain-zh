- en: '![](image-vghl32yj.jpg)A Quick Reference toData Structures andComputer Algorithms ByRaji
    Ramakrishnan NairDivya JosephAlen Joseph ![](image-kmg9gkor.jpg)FIRST EDITION
    2019 Copyright © BPB Publications, INDIA ISBN: 978-93-88176-58-3 All Rights Reserved.
    No part of this publication can be stored in a retrieval system or reproduced
    in any form or by any means without the prior written permission of the publishers LIMITS
    OF LIABILITY AND DISCLAIMER OF WARRANTY The Author and Publisher of this book
    have tried their best to ensure that the programmes, procedures and functions
    described in the book are correct. However, the author and the publishers make
    no warranty of any kind, expressed or implied, with regard to these programmes
    or the documentation contained in the book. The author and publisher shall not
    be liable in any event of any damages, incidental or consequential, in connection
    with, or arising out of the furnishing, performance or use of these programmes,
    procedures and functions. Product name mentioned are used for identification purposes
    only and may be trademarks of their respective companies. All trademarks referred
    to in the book are acknowledged as properties of their respective owners. Distributors: BPB
    PUBLICATIONS20, Ansari Road, Darya GanjNew Delhi-110002Ph: 23254990/23254991 MICRO
    MEDIAShop No. 5, Mahendra Chambers,150 DN Rd. Next to Capital Cinema,V.T. (C.S.T.)
    Station, MUMBAI-400 001Ph: 22078296/22078297 BPB BOOK CENTRE376 Old Lajpat Rai
    Market,Delhi-110006Ph: 23861747 DECCAN AGENCIES4-3-329, Bank Street,Hyderabad-500195Ph:
    24756967/24756400 Published by Manish Jain for BPB Publications, 20, Ansari Road,
    Darya Ganj, New Delhi-110002 and Printed by Repro India Pvt Ltd, Mumbai Dedicated
    to My Students…My Strength and My Weakness “A book is a dream that you hold in
    your hand.”— Neil GaimanPreface quick reference to Data Structures and Computer
    is written in a very simple and understandable manner. The theory is described
    well with step by step examples. The book gives full understanding of each theoretical
    topic and easy implementation in programming. The book is going to help students
    in self-learning of data structures and in understanding how these concepts are
    implemented in programs. The book contains lot of figures and this will help students
    to visualize the concept effectively. Diagrams help students to understand how
    the programs involving data structure concepts are implemented within the computer
    system. Algorithms are included to clear the concept of data structure. Each algorithm
    is explained with figures to make student clearer about the concept. Sample data
    set is taken and step by step execution of algorithm is provided in the book to
    ensure the in – depth knowledge of students about the concept discussed. We have
    designed this book out of necessity. Right now, references that are available
    in market in this field, focusses on specific area only. For studying a specific
    topic, we have to refer minimum of 3 textbooks. That was really hectic and time
    consuming. Some textbooks focus on programming part, some focusses on algorithms
    and some focusses on its illustration using figures. Because of all these limitations,
    we thought to write a book which will satisfy the students in every way. Our book
    can be a handbook for some, a quick reference for competitive examinations and
    it can be surely a textbook in any University that offers Computer Science in
    their curriculum. This book is useful for all the students of B. Tech, B.E., MCA,
    BCA, B.Sc. (Computer Science), etc. A student with basic knowledge in this field
    can understand the concept from the beginning of the book itself. We think our
    book is one of a kind. We are trying to connect the past and the present here.
    The last module of our book is focussing on It explains the concepts of blockchain
    through a different dimension, that is, explaining the data structure aspect of
    blockchain. Our book contains seven chapters, focussing from basics of an algorithm
    to different design strategies. This book also includes different searching and
    sorting methods. Chapter 1: Algorithms and This chapter describes the algorithm
    and the performance analysis of an algorithm – Space Complexity and Time Complexity.
    Explains polynomials and its importance in day to day life. Explains polynomial
    addition in detail. Gives information related to sparse matrix and its representation
    in memory. C programs help to understand the implementation easily. Question bank
    is also provided at the end of the chapter. Chapter 2: Linked Lists: Here focus
    is given on the linked list implementations. Different types of linked lists have
    been discussed with its various operations. Diagrammatic representation of each
    operation helps to understand the working concept effectively. Static and dynamic
    representation of single linked list is well explained here. Doubly linked lists
    with its operations are well explained here. Programmes are given for different
    linked list operations. Question bank at the end of chapter helps to practice
    the concept well for future references. Chapter 3: Stacks and Queues: This chapter
    deals with the data structure used for specific situations, i.e., when we want
    to have insertion and deletion operation at only one place or when we want to
    perform insertion operation at one end and deletion operation at another end.
    Here we are focussing on the different memory representations of stacks and queues.
    Different operations of stacks are discussed well here. Applications of stack
    are well explained in this chapter. C programmes included help to understand the
    concept effectively. Different types of queues are also explained here. Question
    bank is provided at the end of the chapter help to refer in future. Chapter 4:
    Trees and Graphs: This chapter includes basic concepts related to trees. It focusses
    on different types of trees, especially binary tree concepts. Helps to understand
    the representation of binary tree in memory. Explains the different types of traversals
    available. Explains the different operations on binary trees. Other than this,
    introduces the concept of B and B+ trees. Explains the height balanced trees well.
    Also helps to understand the concept of graphs, with its various ways of representation
    in memory. Gives a good idea on graph traversals with proper explanation. Question
    bank is also provided at the end of each chapter. Chapter 5: Searching and Sorting:
    This chapter deals with the Divide and Conquer strategy. Mainly focusses on the
    different searching and sorting methods available. Many of the methods have been
    explained well with suitable examples. Question bank is also provided at the end
    of each chapter. Chapter 6: The Greedy Method: Here the concept of greedy method
    is well explained. Two algorithms are effectively explained and they are the Kruskal’s
    algorithm and the Prim’s algorithm. Question bank is provided at the end of the
    chapter. Chapter 7: Beauty of Blockchain: This chapter goes through Blockchain
    a real application of data structure; we are trying to bring curiosity to students
    about the disruptor technology which they are going to get hands-on experience
    in the near future. It is the difficult topic but we have tried to make it easier.
    First of all, we explained the origin of the Blockchain, clarify the dilution
    regarding Blockchain and cryptocurrency. Then the elements and jargons of Blockchain
    are discussed. We jump deeper explaining Blockchain terminology with use cases.
    After that, we go into different types of Blockchain, how to implement them and
    their different use cases. We concluded by explaining the advantages and disadvantages
    of Blockchain along with its future. Data Structures and Computer Algorithms are
    counted under the difficult topics in the field of Computer Applications. We have
    tried to make this subject a bit lighter for our students. Hope it will work out
    in the best way possible for our new generation students, because of the salient
    features of this book.Acknowledgment Writing a book is harder than I thought and
    more interesting and rewarding than I could have ever imagined. None of this would
    have been possible without my dear friend Kochumol She was the one who gave me
    first, a thought of converting my hand-written notebook to a real textbook. I
    am indebted to numerous peoples for their help. And, I am forever indebted to
    my dear and loving students, past and present, who gave me immense help in bringing
    this book project to completion. My sincere thanks go out to all my students,
    especially Jayakrishnan M. Without him, it would have been near impossible to
    translate the dream of my visualisation of technical concepts into pictorial representations.
    Special thanks to Anandhu Anil, Jojo Joseph, Gautham Nancy George and Akash S
    Panickar. My sincere thanks also go to my dear Principal, Fr. Roy Marian College
    Kuttikkanam (Autonomous) and Dr. Jose who were a constant source of inspiration
    in the journey of my book completion. Many of my colleagues at work have been
    extremely supportive of this effort. At the top of the list is Dr. Brijesh George
    Associate Professor & Head – Corporate Relations, Marian College Kuttikkanam,
    Chairman – Placement Officers Kerala Consortium. I would like to express the deepest
    appreciation to him, who has the attitude and the substance of a genius. Without
    his guidance and persistent help, my dream of completing a book would not have
    been possible. My heartfelt gratitude to my dear friends Mr. Krishnaraj S. (CEO
    – Synergy Thoughts, Master Trainer – ICT Academy of Kerala) and Ms. Minu Sivan
    Professor, Economics Department, Marian College Kuttikkanam) I came across many
    motivators in this journey especially Prof. Vijayakumar M. Director - Marian College
    Kuttikkanam (Autonomous)), Naseef Fr. Chackochi Meledam, Jobin Jacob, Sibu Thomas
    Mathew, Smitha Miss who supported me wholeheartedly through their words and prayers. To
    all my dear teachers who inspired me to write a book. To my husband, G. for believing
    in me. I love you. To our symbol of love, our daughter, for her patience and for
    her faith. Because she always understood. Finally, I would like to thank my family
    members, my mother and my for stoically putting up with my work at home. They
    all kept me going and this book would not have been possible without them. Last
    but not the least, I thank almighty who was there for me during my ups and downs
    in the journey of book completion.Raji Ramakrishnan Nair I feel I have learnt
    a lot from the journey of this book. This will be the great treasure I’m going
    to cherish not only in my future career but in my whole life. I would like to
    take this opportunity to express my immense gratitude to almighty GOD and all
    those persons who have given their priceless support and assistance.Divya Joseph I
    would like to thank almighty GOD and Mother Mary for being with me throughout
    the journey of book completion. I owe my gratitude to my parents and my I thank
    all my teachers whole heartedly, who helped me to reach here.Alen Joseph To the
    readers You all are the true inspiration behind this book. This Book is our first
    endeavour and we know that there might be instances where we could have made it
    better. Feel free to send us feedback to sales@bpbonline.com so that we can improve
    our future editions of this book with your help.About the Author Raji Ramakrishnan
    Nair (Author) has done BCA, MCA and M. Tech (IT) and currently working as an Assistant
    Professor at the P. G. Department of Computer Applications of Marian College Kuttikkanam
    (Autonomous). She has 14 years of teaching experience and believes that teaching
    is all about being ‘friend, philosopher and guide’ to her students. This book
    is inspired by her passion to simplify complex subjects for easy understanding;
    the real contribution of a great teacher. She is a philanthropist as well, actively
    involved in many social causes, which made her students to engage in relief works
    in Kerala mega flood and resulted in two houses being built for flood victims. Divya
    Joseph (Co – Author) Divya Jospeh, is a Teacher by passion and profession. She
    has done MTech (CSE) and BTech (IT) from Amal Jyothi College of Engineering, Kanjirapally.
    Presently, she is working as an Assistant Professor in the P.G. Department of
    Computer Applications, Marian College Kuttikkanam (Autonomous). Alen Joseph (Co
    – Author) Alen Joseph is a Blockchain Intern at UST Global Trivandrum. His great
    passion for teaching and research motivated him to write this book. He has done
    MCA from Marian College Kuttikkanam (Autonomous). He is a passionate tech enthusiast
    and his dream is to become a full-time researcher.Table of Content Preface Acknowledgment MODULE
    I: Algorithms and Arrays'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
- en: '| 1. | Algorithm'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '| 1. | 算法'
- en: '&#124; 1.1 &#124; Introduction &#124;'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 1.1 &#124; 介绍 &#124;'
- en: '&#124; 1.2 &#124; Basic Concepts – Data Structures and Types of Data Structure'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 1.2 &#124; 基本概念 - 数据结构和数据结构的类型'
- en: '&#124; 1.2.1 &#124; Data Type &#124;'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 1.2.1 &#124; 数据类型 &#124;'
- en: '&#124;'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '&#124; 1.3 &#124; Performance Analysis of an Algorithm'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 1.3 &#124; 算法性能分析'
- en: '&#124; 1.3.1 &#124; Space Complexity &#124;'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 1.3.1 &#124; 空间复杂度 &#124;'
- en: '&#124; 1.3.2 &#124; Time Complexity &#124;'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 1.3.2 &#124; 时间复杂度 &#124;'
- en: '&#124;'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '&#124; 1.4 &#124; Polynomials'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 1.4 &#124; 多项式'
- en: '&#124; 1.4.1 &#124; Introduction &#124;'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 1.4.1 &#124; 介绍 &#124;'
- en: '&#124; 1.4.2 &#124; Uses of Polynomials &#124;'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 1.4.2 &#124; 多项式的用途 &#124;'
- en: '&#124; 1.4.3 &#124; Polynomial Addition &#124;'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 1.4.3 &#124; 多项式加法 &#124;'
- en: '&#124; 1.4.4 &#124; Structure Polynomial &#124;'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 1.4.4 &#124; 多项式结构 &#124;'
- en: '&#124;'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '&#124; 1.5 &#124; Array Implementation of Polynomial Addition &#124;'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 1.5 &#124; 多项式加法的数组实现 &#124;'
- en: '&#124; 1.6 &#124; Sparse Matrices &#124;'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 1.6 &#124; 稀疏矩阵 &#124;'
- en: '&#124; 1.7 &#124; Transpose &#124;'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 1.7 &#124; 转置 &#124;'
- en: '&#124; 1.8 &#124; Program &#124;'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 1.8 &#124; 程序 &#124;'
- en: '&#124;  &#124; Exercises &#124;'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;  &#124; 练习 &#124;'
- en: '|'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'MODULE II: Linked Lists'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 第二模块：链表
- en: '| 2. | Linked Lists'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '| 2. | 链表'
- en: '&#124; 2.1 &#124; Introduction &#124;'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 2.1 &#124; 介绍 &#124;'
- en: '&#124; 2.1 &#124; Single Linked List'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 2.1 &#124; 单链表'
- en: '&#124; 2.2.1 &#124; Representation of a Linked List in Memory &#124;'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 2.2.1 &#124; 内存中链表的表示 &#124;'
- en: '&#124; 2.2.2 &#124; Operations on a Single Linked List &#124;'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 2.2.2 &#124; 单链表上的操作 &#124;'
- en: '&#124;'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '&#124; 2.3 &#124; Some important procedures &#124;'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 2.3 &#124; 一些重要的过程 &#124;'
- en: '&#124; 2.4 &#124; Doubly Linked List'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 2.4 &#124; 双链表'
- en: '&#124; 2.4.1 &#124; Operations on a Doubly Linked List &#124;'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 2.4.1 &#124; 双链表上的操作 &#124;'
- en: '&#124;'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '&#124; 2.5 &#124; Polynomial Addition Using Linked List &#124;'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 2.5 &#124; 使用链表进行多项式加法 &#124;'
- en: '&#124; 2.6 &#124; Linked list Implementation of Procedure POLYADD (X, Y, Z)
    &#124;'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 2.6 &#124; 使用链表实现 POLYADD 过程 &#124;'
- en: '&#124; 2.7 &#124; Program &#124;'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 2.7 &#124; 程序 &#124;'
- en: '&#124;  &#124; Exercises &#124;'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;  &#124; 练习 &#124;'
- en: '|'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'MODULE III: Stacks and Queues'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 第三模块：栈和队列
- en: '| 3. | Stacks and Queues'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '| 3. | 栈和队列'
- en: '&#124; 3.1 &#124; Definition and Concepts &#124;'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 3.1 &#124; 定义与概念 &#124;'
- en: '&#124; 3.2 &#124; Stack &#124;'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 3.2 &#124; 栈 &#124;'
- en: '&#124; 3.3 &#124; Representation of a Stack in Memory'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 3.3 &#124; 内存中栈的表示'
- en: '&#124; 3.3.1 &#124; Representation of a Stack using an Array &#124;'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 3.3.1 &#124; 使用数组表示栈 &#124;'
- en: '&#124; 3.3.2 &#124; Linked List Representation of Stacks &#124;'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 3.3.2 &#124; 栈的链表表示 &#124;'
- en: '&#124;'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '&#124; 3.4 &#124; Operations on Stacks &#124;'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 3.4 &#124; 栈的操作 &#124;'
- en: '&#124; 3.5 &#124; Applications of Stack &#124;'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 3.5 &#124; 栈的应用 &#124;'
- en: '&#124; 3.6 &#124; Queues'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 3.6 &#124; 队列'
- en: '&#124; 3.6.1 &#124; Representation of Queues &#124;'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 3.6.1 &#124; 队列的表示 &#124;'
- en: '&#124;'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '&#124; 3.7 &#124; Circular Queue &#124;'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 3.7 &#124; 循环队列 &#124;'
- en: '&#124; 3.8 &#124; Dequeue &#124;'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 3.8 &#124; 双端队列 &#124;'
- en: '&#124; 3.9 &#124; Priority Queue &#124;'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 3.9 &#124; 优先队列 &#124;'
- en: '&#124; 3.10 &#124; Application of Queues &#124;'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 3.10 &#124; 队列的应用 &#124;'
- en: '&#124; 3.11 &#124; Program &#124;'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 3.11 &#124; 程序 &#124;'
- en: '&#124;  &#124; Exercises &#124;'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;  &#124; 练习题 &#124;'
- en: '|'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'MODULE IV: Trees and Graphs'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '模块 IV: 树和图'
- en: '| 4. | Trees and Graphs'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '| 4. | 树和图'
- en: '&#124; 4.1 &#124; Introduction &#124;'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 4.1 &#124; 简介 &#124;'
- en: '&#124; 4.2 &#124; Basic Terminologies &#124;'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 4.2 &#124; 基本术语 &#124;'
- en: '&#124; 4.3 &#124; Tree &#124;'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 4.3 &#124; 树 &#124;'
- en: '&#124; 4.4 &#124; Binary Trees'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 4.4 &#124; 二叉树'
- en: '&#124; 4.4.1 &#124; Strictly Binary Tree &#124;'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 4.4.1 &#124; 严格二叉树 &#124;'
- en: '&#124; 4.4.2 &#124; Complete Binary Tree &#124;'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 4.4.2 &#124; 完全二叉树 &#124;'
- en: '&#124; 4.4.3 &#124; Extended Binary Tree &#124;'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 4.4.3 &#124; 扩展二叉树 &#124;'
- en: '&#124;'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '&#124; 4.5 &#124; Binary Tree Representation &#124;'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 4.5 &#124; 树的二叉树表示法 &#124;'
- en: '&#124; 4.6 &#124; Binary Tree Traversal &#124;'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 4.6 &#124; 二叉树遍历 &#124;'
- en: '&#124; 4.7 &#124; More on Binary Trees &#124;'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 4.7 &#124; 更多关于二叉树的内容 &#124;'
- en: '&#124; 4.8 &#124; Threaded Binary Trees &#124;'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 4.8 &#124; 线索二叉树 &#124;'
- en: '&#124; 4.9 &#124; Binary Tree Representation of Trees &#124;'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 4.9 &#124; 树的二叉树表示法 &#124;'
- en: '&#124; 4.10 &#124; Binary Search Tree &#124;'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 4.10 &#124; 二叉搜索树 &#124;'
- en: '&#124; 4.11 &#124; Procedure for deleting from a binary search tree &#124;'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 4.11 &#124; 从二叉搜索树中删除的过程 &#124;'
- en: '&#124; 4.12 &#124; Weighted Path Length &#124;'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 4.12 &#124; 权路径长度 &#124;'
- en: '&#124; 4.13 &#124; B Tree'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 4.13 &#124; B 树 &#124;'
- en: '&#124; 4.13.1 &#124; Insertion in B tree &#124;'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 4.13.1 &#124; B 树中的插入 &#124;'
- en: '&#124;'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '&#124; 4.14 &#124; B + tree &#124;'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 4.14 &#124; B + 树 &#124;'
- en: '&#124; 4.15 &#124; AVL Tree (Height Balanced Binary Trees)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 4.15 &#124; AVL 树（平衡二叉树）&#124;'
- en: '&#124; 4.15.1 &#124; Insertion in AVL tree &#124;'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 4.15.1 &#124; AVL 树中的插入 &#124;'
- en: '&#124;'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '&#124; 4.16 &#124; Graphs &#124;'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 4.16 &#124; 图 &#124;'
- en: '&#124; 4.17 &#124; Graph Representation &#124;'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 4.17 &#124; 图的表示 &#124;'
- en: '&#124; 4.18 &#124; Graph Traversals &#124;'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 4.18 &#124; 图的遍历 &#124;'
- en: '&#124;  &#124; Exercises &#124;'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;  &#124; 练习题 &#124;'
- en: '|'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'MODULE V: Searching and Sorting'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '模块 V: 搜索和排序'
- en: '| 5. | Searching and Sorting'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '| 5. | 搜索和排序'
- en: '&#124; 5.1 &#124; Searching'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 5.1 &#124; 搜索'
- en: '&#124; 5.1.1 &#124; Procedure SEQSRCH (*R*, *n*, *i*, *K*) &#124;'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 5.1.1 &#124; SEQSRCH 过程 (*R*, *n*, *i*, *K*) &#124;'
- en: '&#124; 5.1.2 &#124; Procedure BINSRCH (*F*, *n*, *i*, *K*) &#124;'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 5.1.2 &#124; BINSRCH 过程 (*F*, *n*, *i*, *K*) &#124;'
- en: '&#124;'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '&#124; 5.2 &#124; Fibonacci Search'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 5.2 &#124; 斐波那契搜索'
- en: '&#124; 5.2.1 &#124; Procedure FIBSEARCH (G, n, i, x) &#124;'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 5.2.1 &#124; FIBSEARCH 过程 (G, n, i, x) &#124;'
- en: '&#124;'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '&#124; 5.3 &#124; Sorting &#124;'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 5.3 &#124; 排序 &#124;'
- en: '&#124;  &#124; Exercises &#124;'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;  &#124; 练习题 &#124;'
- en: '|'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'MODULE VI: Greedy Method'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '模块 VI: 贪婪方法'
- en: '| 6. | Greedy Method'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '| 6. | 贪婪方法'
- en: '&#124; 6.1 &#124; The Greedy Method: Basic Concepts &#124;'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 6.1 &#124; 贪婪方法：基本概念 &#124;'
- en: '&#124; 6.2 &#124; Minimum – Cost Spanning Trees'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 6.2 &#124; 最小生成树 &#124;'
- en: '&#124; 6.2.1 &#124; Prim’s Algorithm &#124;'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 6.2.1 &#124; Prim 算法 &#124;'
- en: '&#124; 6.2.2 &#124; Kruskal’s Algorithm &#124;'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 6.2.2 &#124; Kruskal 算法 &#124;'
- en: '&#124;'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '&#124;  &#124; Exercises &#124;'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;  &#124; 练习题 &#124;'
- en: '|'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'MODULE VII: Beauty of Blockchain'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: MODULE VII：区块链的美
- en: '| 7. | Beauty of Blockchain'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '| 7. | 区块链的美'
- en: '&#124; 7.1 &#124; Origin of Blockchain &#124;'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 7.1 &#124; 区块链的起源 &#124;'
- en: '&#124; 7.2 &#124; Philosophy of Blockchain (Difference between Normal Ecosystem
    and Blockchain Ecosystem)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 7.2 &#124; 区块链哲学（普通生态系统与区块链生态系统的区别）'
- en: '&#124; 7.2.1 &#124; Normal Ecosystem &#124;'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 7.2.1 &#124; 普通生态系统 &#124;'
- en: '&#124; 7.2.2 &#124; Blockchain Ecosystem &#124;'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 7.2.2 &#124; 区块链生态系统 &#124;'
- en: '&#124;'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '&#124; 7.3 &#124; Distributed Ledgers &#124;'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 7.3 &#124; 分布式账本 &#124;'
- en: '&#124; 7.4 &#124; The Principle of the Blockchain &#124;'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 7.4 &#124; 区块链的原理 &#124;'
- en: '&#124; 7.5 &#124; The Blockchain Data Structure and its Working (Case Study:
    Bitcoin) &#124;'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 7.5 &#124; 区块链数据结构及其工作方式（案例研究：比特币） &#124;'
- en: '&#124; 7.6 &#124; Consensus Algorithm &#124;'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 7.6 &#124; 共识算法 &#124;'
- en: '&#124; 7.7 &#124; Proof of Work &#124;'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 7.7 &#124; 工作量证明 &#124;'
- en: '&#124; 7.8 &#124; Proof of Stake (PoS) &#124;'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 7.8 &#124; 股权证明（PoS） &#124;'
- en: '&#124; 7.9 &#124; Delegated Proof of Stake &#124;'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 7.9 &#124; 委托权益证明 &#124;'
- en: '&#124; 7.10 &#124; Smart Contacts &#124;'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 7.10 &#124; 智能合约 &#124;'
- en: '&#124; 7.11 &#124; Types of Blockchain &#124;'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 7.11 &#124; 区块链类型 &#124;'
- en: '&#124; 7.12 &#124; Advantage of Blockchain &#124;'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 7.12 &#124; 区块链的优势 &#124;'
- en: '&#124; 7.13 &#124; Disadvantage of Blockchain &#124;'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 7.13 &#124; 区块链的劣势 &#124;'
- en: '&#124; 7.14 &#124; Future of Blockchain &#124;'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 7.14 &#124; 区块链的未来 &#124;'
- en: '|'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'MODULE IAlgorithms and Arrays  CHAPTER 1 Algorithms and Arrays1.1 Introduction An
    algorithm is defined as a finite set of instructions, which when executed in an
    order, accomplishes a predefined task. Algorithm is actually the core logic of
    a problem, rather than the complete code or program. We can express an algorithm,
    either as an informal high-level description as pseudo code or using a flowchart. Each
    algorithm has the following properties:properties: properties: properties: properties:
    properties: properties: properties: properties: properties: properties: properties:
    properties:properties: properties: properties: properties: properties: properties:
    properties: properties:properties: properties: properties: properties: properties:
    properties: properties: properties: properties:properties: properties: properties:
    properties: properties: properties: properties: properties: properties: properties:
    properties: properties: properties: properties:properties: properties: properties:
    properties: properties: properties: properties: properties: properties: properties:
    properties: properties: properties: properties: properties: properties: properties:
    properties: properties: properties:1.2 Basic Concepts – Data Structures and Types
    of Data Structure Data can be organized in many ways and one of the ways is data
    structures. It is mainly used to represent data in the memory of the computer,
    so that, data can be retrieved effectively later. The idea behind the concept
    of data structure is to reduce the space and time complexities of different tasks.1.2.1
    Data Type There are various types of data available such as integer, string, and
    so on. To classify these available types of data, we use data type, which determines
    the values that can be used as well as the type of operations that can be performed
    on the corresponding type of data. Basically, there are two data types:  Built
    – in Data Type Derived Data Type Built-in Data Type When any programming language
    provides built – in support for any data type, then such type of data types is
    known as built – in data type. For example, the following built – in data types
    are provided by most of the programming languages – integers, boolean (TRUE or
    FALSE), floating (Decimal Numbers), characters, and strings. Derived Data Type Those
    data types which are implemented independently in one or the other way, are known
    as derived data types. These are mainly the combination of primary or built –
    in data types and associated operations on them. For example, list, array, stack,
    queue, and so on (figure 1.1). ![](image-xzgjrrdf.jpg)Figure 1.1 Classification
    of Data Structure The data structures can also be classified on the basis of the
    following characteristics:characteristics:characteristics: characteristics: characteristics:
    characteristics: characteristics: characteristics: characteristics: characteristics:
    characteristics: characteristics: characteristics: characteristics: characteristics:characteristics:
    characteristics: characteristics: characteristics: characteristics: characteristics:
    characteristics: characteristics: characteristics: characteristics: characteristics:
    characteristics:characteristics: characteristics: characteristics: characteristics:
    characteristics: characteristics: characteristics: characteristics: characteristics:
    characteristics: characteristics: characteristics: characteristics: characteristics:
    characteristics: characteristics: characteristics: characteristics: characteristics:
    characteristics: characteristics:characteristics: characteristics: characteristics:
    characteristics: characteristics: characteristics: characteristics: characteristics:
    characteristics: characteristics: characteristics: characteristics: characteristics:
    characteristics: characteristics: characteristics: characteristics: characteristics:
    characteristics: characteristics: characteristics: characteristics: characteristics:
    characteristics: characteristics: characteristics: characteristics:characteristics:
    characteristics: characteristics: characteristics: characteristics: characteristics:
    characteristics: characteristics: characteristics: characteristics: characteristics:
    characteristics: characteristics: characteristics: characteristics: characteristics:
    characteristics: characteristics: characteristics: characteristics: characteristics:
    characteristics: characteristics: characteristics:characteristics: characteristics:
    characteristics: characteristics: characteristics: characteristics: characteristics:
    characteristics: characteristics: characteristics: characteristics: characteristics:
    characteristics: characteristics: characteristics: characteristics: characteristics:
    characteristics: characteristics: characteristics: characteristics: characteristics:
    characteristics: characteristics: characteristics: characteristics: characteristics:
    characteristics: characteristics: characteristics:1.3 Performance Analysis of
    an Algorithm If we want to buy a television, there are many brands available in
    market. But, we have a fixed amount of money in hand as well as fixed amount of
    space to place this television at home. So, while deciding which television to
    buy, we have to go through almost all brands available in market, keeping three
    factors in mind, price, space, and performance. Depending on the availability
    and convenience, we choose the one which suits us. Similarly, in Computer Science,
    multiple algorithms are available to solve a particular problem. When we have
    more than one algorithm to solve a single problem, then we need to select the
    best one. Thus, performance analysis helps us to select the best algorithm from
    multiple algorithms to solve a problem. When there are multiple alternative algorithms
    to solve a problem, we have to analyse each of them and select the best option
    suitable for our requirements. Formal definition is as follows: Performance of
    an algorithm is a process of making evaluative judgment about It can also be defined
    as follows: Performance of an algorithm means estimating the resources which are
    required to an algorithm to perform its task. When we have multiple algorithms
    to solve a particular problem, then we have to select the best one suitable for
    the specified problem. For that, we compare all available algorithms, with each
    other which are meant to solve the specified problem, to select the best algorithm.
    For comparison, we use a set of parameters or set of elements, which includes,
    memory required by that algorithm, execution speed of that algorithm, memory space
    requirement of that algorithm, easy to understand, easy to implement, and so on. Normally,
    the performance of an algorithm depends on the following elements:elements: elements:
    elements: elements: elements: elements: elements: elements: elements: elements:
    elements: elements: elements:elements: elements: elements: elements: elements:
    elements: elements: elements: elements: elements: elements:elements: elements:
    elements: elements: elements: elements:elements: elements: elements: elements:
    elements: elements: elements: elements: elements: elements: elements: elements:
    elements: elements:elements: elements: elements: elements: elements: elements:
    elements: elements: elements: elements: elements: elements: elements: The analysis
    of an algorithm, considers only the space and time required by that algorithm
    and thus, ignores all remaining elements. Based on this information, performance
    analysis of an algorithm can also be defined as follows: Performance analysis
    of an algorithm is the process of calculating space required by that algorithm
    and time required by that algorithm. Performance analysis of an algorithm is performed
    by using the following measures:measures: measures: measures: measures: measures:
    measures: measures: measures: measures: measures: measures: measures: measures:
    measures: measures: measures: measures:measures: measures: measures: measures:
    measures: measures: measures: measures: measures: measures:1.3.1 Space Complexity The
    space complexity of any algorithm mainly comprises of program space and data space.
    The space needed by each algorithm is mainly the sum of the following components:components:
    components: components: components: components: components: components: components:
    components: components: components: components: components: components: components:
    components: components: components: components: components: components: components:
    components: components: components: components: components: components:components:
    components: components: components: components: components: components: components:
    components: components: components: components: components: components: components:
    components: components: components: components: components: components: components:
    components: components: components: Therefore, the total space requirement of
    any algorithm ‘A’ can be provided as: Space (A) = Fixed components (A) + Variable
    Components (A) When comparing the components, the most important part is the variable
    part, so it must be determined accurately, so the actual space requirement can
    be calculated for an algorithm ‘A’. Let us take some examples and understand how
    to find the space complexity of any given algorithm. Example 1 Algorithm add (x,
    y) { return x + y; } We know, space complexity of any algorithm is determined
    using the following formula: Space [s] = Fixed part + Variable part In our example,
    we find that there is no variable part, so the memory space needed for variable
    part is zero. Let us assume that, one word of memory is needed for each variable
    used in this algorithm. So, total two memory words needed to store the values
    of x and y. Thus, S [add] = 2\. Example 2 Algorithm add (a, n){ S: = 0.0; for
    i: = 1 to n do S: = S + a [i]; return S; } Here in this example, three variables
    are used and they are s, i, and n. Assuming that one memory word is needed to
    store the value of each variable, then we require total of 3 memory words to store
    the values of s, i, and n. Here, we have one array also and the size of the array
    is completely depending upon the value of n, so array can be expanded or get reduced
    according to the value of n. So, the space requirement of array ‘a’ is n. Therefore, Space
    complexity (add) = 3 + n = (n + 3) [n words for a[ ], one each for n, i, and s] Example
    3 Algorithm RecSum(a, n){if (n £ ) then return 0.0;Elsereturn RecSum(a, n-1) +
    a[n];} Let us solve this example with some data sets. Here our array is and let
    the size of n = So, the pictorial representation of this array is as follows: ![](image-dkau5pze.jpg) And
    suppose the values in a[1], a[2], and a[3] are 10, 20, and 30 respectively. So,
    array look like the following: ![](image-pqtcw52h.jpg) When the algorithm RecSum(a,n)
    is invoked by operating system, the stack representation is as follows:. Here,
    we have n = as assumed earlier. ![](image-slrieagv.jpg) When execution starts,
    the if condition is being checked and we found it is wrong, so else part is being
    executed and it returns RecSum(a, 2) + that means, return RecSum (a, 2) + and
    the next function call is RecSum(a, 2) and so the stack representation is as follows: ![](image-ddxbyfyb.jpg) Now,
    function RecSum(a, 2) is being executed and the if condition is being checked
    and we found it is false, so else part is being executed and it returns RecSum(a,
    1) + that means, return RecSum(a, 1) + and the next function call is RecSum(a,
    1) and so the stack representation is as follows: ![](image-6m2h2dox.jpg) When
    execution for function RecSum(a, 1) starts, the if condition is being checked
    and we found it is false, so the else part is being executed and it return RecSum(a,
    0) + that means return RecSum(a, 0)+10 and the next function call is RecSum(a,
    0) and so the stack representation is as follows: ![](image-7zn9od95.jpg) Now,
    function RecSum(a, 0) is being executed and the if condition is being checked
    and we found it is true and hence it return zero for this function call. Let us
    see how return function returns in the whole program and it is shown pictorially
    as follows: ![](image-dx0hymz1.jpg) Assume that the return address requires only
    one word of memory, so, each call to RecSum requires at least three words, which
    includes space for the value of the return address and a pointer to a[ Here, we
    can see the depth of the recursion stack is 3 + 1 (where 3 is the value of n that
    we assumed earlier). And, we know, for each call to RecSum requires 3 words, so
    for this algorithm, the recursion stack needed is as follows: follows: follows:
    follows: follows:follows: follows: So, in general, we can state that, the recursion
    stack spaceneeded is ≥ 3(n + 1) The space requirement S(P) of any algorithm P
    may therefore be written as S(P) = c + S p (instance characteristics), where ‘c’
    is a constant. For analysing the space complexity of an algorithm, we have to
    give importance on estimating (instance characteristics). This is very problem
    specific. So, for any given problem, we need to identify which instance characteristics
    to use to estimate the space requirements.1.3.2 Time Complexity Time complexity
    of any algorithm gives the total amount of time needed for that algorithm to complete
    its task. The time T(P) taken by a program is mainly the sum of the compile time
    and the run time (execution time). Time complexity of any algorithm depends on
    many things like hardware part of the system, operating system, processors, and
    so on. But, to calculate the time complexity of an algorithm, we will only consider
    the run time (execution time) of an algorithm. The main factor in determining
    the time complexity of an algorithm is the run time of that algorithm. The compile
    time of an algorithm doesn’t depend on the instance characteristics. And also,
    once a program is compiled, there is no need to recompile the same program for
    its every execution. The run time of an algorithm depends on the instance characteristics,
    so time complexity of an algorithm is very program specific. This run time is
    denoted by The time complexity of any algorithm is calculated by finding the total
    number of program steps involved to complete its task. A program step is loosely
    defined as a segment of a program, that has an execution time, but is independent
    of instance characteristics. The total number of program steps of any program
    depends upon the type of statement. For example, if the statement is a comment,
    then the program step associated with such statement is zero step, an assignment
    statement is counted as one step, and for an iterative statement such as and repeat-until
    statements, the program step depends upon the number of times the control part
    executes. Now we have to find the number of steps needed by a program to solve
    a particular problem in any one of the two ways available. In the first method,
    we have a global variable COUNT, initialized to 0\. Statements to increment COUNT
    by the appropriate amount are introduced into the program. This is done so that
    each time a statement in the original program is executed COUNT is incremented
    by the step count of that statement. Let us take an example. Following is the
    algorithm with COUNT statements added. ![](image-reiceb7j.jpg)Algorithm 1.1 Algorithm
    with COUNT statements added In algorithm 1.1, the change in the value of COUNT
    by the time this program terminates is the number of steps executed by this algorithm.
    To find the number of steps for algorithm 1.1, we find the total number of COUNT.
    We can see that, for each statement in the program, the COUNT is increased by
    1\. For the statements 3 and 13, the COUNT is increased by 1\. In the for loop,
    for each entry into the loop, the COUNT is incremented by 1\. So, we can see COUNT
    increment twice in the for loop. At the time of exit for for loop, COUNT is incremented
    once. So, when we go through the algorithm, we can find 2 increments for COUNT
    in for loop and outside invocation of add executes a total of 2n + 3 steps. Let
    us take another example, where recursive function is used. ![](image-uayndhko.jpg)![](image-mg7aqjer.jpg)Algorithm
    1.2 Algorithm with count added The algorithm 1.2, is divided into two parts: IF
    part and ELSE part. We are getting into the IF part, only when the condition mentioned
    is true, otherwise statements in the ELSE part will get executed. Let t RecSum
    (n) be the increase in the value of COUNT when algorithm 1.2 terminates. We know
    that t RecSum (0) = When n>o, COUNT increases by 2 plus whatever increase results
    from the invocation of RecSum from within the ELSE clause. The additional increase
    is because of t RecSum So, if the value of COUNT is zero, initially, its value
    at the time of termination is 2 + t RecSum When analysing a recursive program
    for its step count, we often obtain recursive formula for the step count, as shown
    below: (n) = 2 if n = 0  2 + (n – 1) if n > 0 These recursive formulas are referred
    to as recurrence relations. One way of solving any recurrence relation is to make
    repeated substitutions for each occurrence of the function on the right-hand side
    until all such occurrences disappear: ![](image-xwy5qj20.jpg) So, the step count
    for RecSum is 2n + The step count is useful in that it tells us how the run time
    for a program changes with changes in the instance characteristics. From the step
    count for RecSum, we see that if n is doubled, the run time also doubles (approximately);
    if n increases by a factor 10, the run time increased by a factor of 10, and so
    on. So, the run time grows linearly in Let us take another example, where COUNT
    is added to find the total step counts. ![](image-bikgtebh.jpg)Algorithm 1.3 Matrix
    addition with counting statements Now, to find the step count of algorithm 1.3,
    we have to analyse the inner loop, if any. Now, the inner for loop is for In this
    for loop, 2 count increments and the step COUNT for for j loop is 2n. And, in
    the for i loop, 2 count increments and the step count for for i loop is 2m. And,
    one step count outside the main for loop (i.e. for i loop). Therefore, the step
    count for Algorithm 1.3 is 2m + 2n + The second method to find the step count
    of any algorithm is to build a table in which we list the total number of steps
    contributed by each statement. In the table, we first determine the number of
    steps per execution (s/e) of the statement and the total number of times (i.e.
    frequency) each statement is executed. The s/e of a statement is the amount by
    which the count changes as a result of the execution of that statement. By combining
    these two quantities, the total contribution of each statement is obtained. By
    adding the contribution of all statements, the step count for the entire algorithm
    is obtained. The following examples, will help us to understand the second method
    to find the step count of any algorithm. In Table the number of steps per execution
    and the frequency of each of the statements in add have been listed. The total
    number of steps required by the algorithm is determined to be It is important
    to note that the frequency of the for statement is n+1 and not n. This is so because
    ‘i’ has to be incremented to n+1 before the ‘for loop can terminate. Table 1.1
    Step table for Algorithm 1.1 ![](image-5qvaiozi.jpg) Table 1.2 gives the step
    count for RecSum Notice that under the s/e (steps per execution) column, the else
    clause has been given a count of This is the total cost of this line each time
    it is executed. It includes all the steps that get executed as a result of the
    invocation of RecSum from the else clause. The frequency and total steps columns
    have been split into two parts. One for the case n = 0 and the other for the case
    n > This is necessary because the frequency (and hence total steps) for some statements
    is different for each of these cases. Table 1.2 Step table for Algorithm 1.2 ![](image-4h55nbjk.jpg)1.4
    Polynomials1.4.1 Introduction Polynomials are a union of several terms which can
    be added, subtracted, or multiplied but not divided. They are one of the most
    basic algebraic operations and many students don’t know why they have to learn
    about polynomials. Mostly polynomials are used in sophisticated applications,
    they also have many uses in everyday life.1.4.2 Uses of Polynomials Polynomials
    are used for various purposes in life. Polynomials are used in modelling, physics,
    industries, finance, construction, gravitation, chemistry, and so on. Hence, we
    understand that polynomials have different uses. People use polynomials in their
    day to day life. People use polynomials for creating of various buildings and
    objects, used in industries, used in construction. Polynomials are even used in
    marketing, finance, stocks, and so on. They are even used in various fields of
    science, such as physics, where we measure acceleration, or to express units of
    energy, inertia or even in electricity, and so on. In chemistry, polynomials are
    used in writing down the chemical equations, and so on. Polynomials are of great
    use to every person around.![1sa](1sa.PNG)1.4.3 Polynomial Addition Generally,
    a polynomial is a sum of terms where each term has the form ‘x’ is the variable,
    ‘a’ is the coefficient and ‘e’ is the exponent. When defining a data we have to
    decide what functions will be available, what their input is, what their output
    is and exactly what it is that they do. A complete specification of the data structure
    polynomial is now given:1.4.4 Structure Polynomial ZERO ( )→poly;ISZERO (poly)→
    Boolean COEF (poly,exp) →coef; ATTACH(poly, coef, emp)→poly REM (poly, exp) →poly SMULT
    (poly, coef, exp)→poly ADD (poly, poly) →poly; MULT (poly, poly)→poly; : : : End
    POLYNOMIAL For Polynomial, we can make some assumptions. Exponents should be unique
    and the terms are arranged in the decreasing order of their exponents. This considerably
    simplifies the operations COEF and REM while SMULT and MULT remain unchanged. Now
    we assume a new function EXP(poly)→ which returns the leading exponent of the
    poly, we can write a version of ADD which is expressed more like a program, but
    is still representation independent. //C=A+B where A, B are the input polynomials. //
    ZERO while not ISZERO(A) and not ISZERO(B) do case : EXP(A) C←ATTACH (C, COEF
    (B, EXP (B)), EXP(B)) B←REM (B, EXP(B)) : EXP(A) = EXP(B) C←ATTACH (C, COEF (A,
    EXP (A)) + COEF (B, EXP (B)), EXP(A)) A←REM (A, EXP(A)); B←REM (B, EXP(B)) : EXP(A)
    >EXP(B): C←ATTACH (C, COEF (A, EXP (A)), EXP(A)) A←REM (A, EXP(A)) End end //insert
    any terms in A or B into C// The basic loop of this algorithm, merges the terms
    of the two polynomials, depending upon the result of comparing the elements. The
    case structure determines how the components are related and performs their respective
    action. Since the tests within the case structure require two terms, if one polynomial
    gets exhausted, we must exist and the remaining terms of the other can be copied
    directly into the result. A general polynomial A(x) can be written as: ![](image-yrvdjop8.jpg) Where
    ≠ 0 and we say that the degree of A is n. Then we can represent A(x) as an ordered
    list of coefficients using one dimensional array of length ![](image-g9jhv4mx.jpg) The
    first element is the degree of A, followed by n+1 coefficients in order of decreasing
    exponent. Scheme 1 The above representation has got one major disadvantage. Here,
    large amount of storage is wasted for certain polynomials. Consider for instance.
    It will require a vector of length 1002, while 999 of those values will be zero. Scheme
    2 Then an alternative scheme is considered where we take the polynomial A(x) above
    and keep only its nonzero coefficients. Then we will represent the above polynomial
    as: ![](image-kmwzl4sj.jpg) In general, the polynomial in (1) could be represented
    by the ordered list of length + 1, ![](image-y99o5ozy.jpg) The first entry is
    the number of nonzero terms. Then, for each term there are two entries representing
    an exponent- coefficient pair. Procedure for adding 2 polynomials represented
    as in scheme 2\. Procedure PADD (A, B, C) // A(1:2m+1), B(1:2n+1), C (1:2(m +
    n) + 1)// 1\. m ←A(1); n←B(1) 2\. p←q←r←2; // r←2; q←r; p←q// 3\. while p ≤ 2m
    and q ≤ 2n do 4\. case // compare exponents// : // add coefficients// if C(r +
    1)≠ 0 then [C(r)← A(P); r ← r + 2] //store exponent// p ← p + 2; q ← q + 2 //
    advance to next terms// :A(p) < B(q): C(r+1) ← B(q+1); C(r) ← B(q) // store new
    term// q ← q + 2; r ← r + 2 // advance to next term// :A(p) > B(q): C(r+1) ← A(p+1);
    C(r) ← A(p) p ← p + 2; r ← r + 2 5\. while p ≤ 2m do //copy remaining terms of
    A// C(r)←A(p); C(r+1) ← A(p+1) P←p+2; r←r+2 end 6\. while q ≤ 2n do // copy remaining
    terms of // C(r)← B(p); C(r+1) ← B(q+1) q ← q + 2; r ← r + 2 end 7\. C (1) ← r/2
    -1// no. of terms in the sum //  end1.5 Array Implementation of Polynomial Addition Explanation
    of Procedure PADD (A, B, C) We can see three array declarations in the comment
    at the initial of the procedure. And the three arrays have been declared are A
    is 2 where m is the total number of non-zero terms present is array A. The size
    of array B is 2 where n is the total number of non-zero terms present in the array
    B. And in the worst-case, the maximum size needed for the resultant array C is
    (m + n) where m + n will be the number of non-zero terms present in array C, in
    the worst-case. Let us take two polynomials as: ![](image-lxnbi18k.jpg) The polynomial
    A(x) is represented in array A as: ![](image-n3b11def.jpg) The polynomial B(x)
    is represented in array B as: ![](image-2s5a9pxf.jpg) Now the resultant array
    C will look like this: ![](image-xpzil8da.jpg) In the first statement, we are
    initializing the two variables m and n and values assigned to m and n are A (1)
    and B (1) respectively. So, m=4 and n =3\. Three pointer variables are used in
    the procedure. Pointer variables p, q, traversing the arrays 2, initializes pointer
    variables p, q, and r to 2, i.e., p=2, q=2, r=2\. That means, pointer variables
    are pointing to the cells of arrays A, B, and respectively. Pictorial representation
    of arrays A, B & C after statement 2 are as follows. ![](image-8kodwc6t.jpg) ![](image-64rk7e8x.jpg) Statement
    3 checks the conditions p ≤ 2 m and q ≤ 2 n and in our case, the condition is
    true, so we are able to enter into the while loop, i.e., 2 ≤ 8 (2x4) and 6(2x3)
    is TRUE. There case statement is in the while loop. Now, we have to check which
    case statement satisfies now. Case 3 satisfies now, since A (p) > B (q) that means
    A (2)> B (2) > 10 >8 is true. So, coefficient from A is taken and get stored in
    C, at proper location. Exponent from A is taken and get stored in C, at its proper
    location. Then, the arrays who are induced in this process, their pointer variables
    will get updated simultaneous Here in this case, p and r get updated. Pictorial
    representation after this process; ![](image-qojcl5ka.jpg) Again, while loop conditions
    are checked and found its TRUE again, i.e., p ≤ 2 m q ≤ 2 n is TRUE, i.e.; 4 ≤
    8 and 2 ≤ 6 n TRUE, so entering again into the while loop. Case statements are
    being observed and found that case 2 satisfies now, i.e., A(p)< B(q), i.e.; A
    (4) < B92), i.e.; 5<8 is TRUE Now, copy the coefficient from B and store it in
    C at proper position; copy exponent of B and store it in C at proper position.
    And lastly, update q, and r respectively.’ Pictorial representation after this
    process is: ![](image-xh9gb8ky.jpg) Again, while loop conditions are checked and
    found its TRUE again, i.e.; p ≤ 2 m and q ≤ 2 n is TRUE, i.e.; 4≤8 and 4≤6 is
    TRUE, so entering again into the while loop case statement are being observed
    and found that case 1 satisfies now, i.e., A(p)= B i.e., A (4) = B i.e.; 5=5 is
    TRUE Now, coefficients of A and B get added and checked whether the result of
    addition is a zero term or not. If it’s a non-zero term, then the result is stored
    in the appropriate location of C, exponent from A is copied to C and then all
    the 3-pointer variables, p, q, and r, get updated. Otherwise, only p and q are
    got updated. Pictorial representation after this process is: ![](image-pt4lwej4.jpg) ![](image-22voxdcn.jpg) Again,
    while loop conditions are checked and found it is TRUE again, i.e., p ≤ 2 m and
    q ≤ 2 n is TRUE, i.e., 6 ≤ 8 and 6 ≤ 6 is TRUE, so entering again into the while
    loop. Case statement are being observed and found that case 3 satisfies now, i.e.,
    A(p) > i.e.; A (6)> B i.e.; 2>1 is TRUE. Now, copy the coefficient of A and store
    it in C and then copy the exponent from A and store it in C and then p and r,
    get updated. Pictorial representation after this process is: ![](image-qu3bmyzw.jpg) Now
    again while loop conditions are checked and found it is TRUE again, i.e, p ≤ 2
    m and q ≤ 2 n is TRUE, i.e, 8 ≤ 8 and 6 ≤ 6 is TRUE, so entering again into the
    while loop. Case statements are being observed and found that case 2 is TRUE,
    i.e; A(p) ≤ i.e, A (8) < B i.e.; 0<1 is TRUE. Now, copy the coefficient of B and
    store it in C, copy the exponent of B and store it in C and then update q and
    r simultaneously. Pictorial representation after this process is: ![](image-nt1stia1.jpg) While
    loop is being checked and found it is FALSE now, i.e. p ≤ 2 m and q ≤ 2 n is FALSE,
    so exiting from the while loop. Now statement 5 is being executed and the condition
    for the while loop is found TRUE, i.e, , p ≤ 2 m is TRUE, i.e; 8 ≤ 8 is TRUE,
    so entering into the while loop and copy the remaining terms of A into C, and
    then updating the p and r simultaneously. The pictorial representation after this
    process is: ![](image-lzp7io1z.jpg) ![](image-ij7lmhdy.jpg) Statement 5 is again
    checked and found the condition for while loop as FALSE and hence, exiting from
    this while loop. Statement 6 is checked and found the condition for while loop
    as FALSE and hence, without entering into the while loop, it exits from there. Now,
    statement 7 is executed, and here the total number of terms in C is being calculated
    and the result is then stored in C (1). ![](image-kks7q8nf.jpg) Now, our final
    resultant array C will look as follows: ![](image-j85i2xkt.jpg)1.6 Sparse Matrices A
    general matrix consists of rows and columns of numbers as in (Figure 1.1). ![](image-vkt9sdsv.jpg)Figure
    1.2 Sparse Matrices The first matrix figure 1.1(a) has 5 rows and 3 columns, the
    second matrix figure 1.1 (b) has 6 rows and 6 columns. In general, we write m
    ¥ n to designate a matrix with m rows and n columns. Such a matrix has mn elements.
    When m is equal to we call such matrix as square matrix. We can see that the matrix
    of figure 1.1 (b) has many zero entries. Such a matrix is called sparse matrix.
    There is no exact definition for a sparse matrix or we cannot say of when a matrix
    is sparse or when it is not. A sparse matrix requires us to consider an alternative
    form of representation. The alternative representation will explicitly store only
    non – zero elements. Each element of a matrix is represented by its row and column
    position, say We can store a matrix in the form j, We can store the sparse matrix
    P with the array A where i.e., number of nonzero terms. Sparse Matrix Representation ![](image-hai5y0ha.jpg) A
    matrix with a relatively high proportion of zero is called a sparse matrix. Transpose ![](image-g3exrqd4.jpg) ![](image-yvh37vjj.jpg) Procedure
    for Transpose of a Matrix Procedure TRANSPOSE // A is a matrix represented in
    sparse form// // B is set to be its transpose// 1\. (m,n,t)←(A(0,1),A(0,2),A(0,3)) 2\.
    (B(0,1),B(0,2),B(0,3)) ← (n,m,t) 3\. if t ≤ 0 then return // check for zero matrix// 4\.
    q ← 1 // q is position of next term in B // 5\. for col ← 1 to n do // transpose
    by columns // 6\. for p ← 1 to t do // for all nonzero terms do // 7\. if A(p,
    2) = col // correct column// 8\. then [(B(q, 2), B(q, 2), B(q, 3)← // investment
    term of B// (A (p,2),A(P,1),A(p,3)) q ← q + 1] 9\. 10\. end 11\. end1.7 Transpose The
    variable q always gives us the position in B where the next term in the transpose
    is to be inserted. The terms in B are generated by rows. Since the rows of B are
    the columns of row i of B is obtained by collecting all the nonzero terms in column
    i of This is being done in lines 5-12\. On the first iteration of the for loop
    of lines 5-12 all terms from column 1 of A are collected, then all terms from
    column 2 and so on until eventually, all terms from column n are collected. For
    each iteration of the loop of lines 5-12 then if clause of line 7 is tested t
    times. Since the number of iterations of the loop of lines 5-12 is the total time
    for line 7 becomes The assignment in lines 8-10 takes place exactly t times as
    there are only t non-zero terms in the sparse matrix being generated. Lines 1-4
    take a constant amount of time. The total time for the algorithm is therefore
    addition to the space needed for A & the algorithm requires only a fixed amount
    of additional space, i.e, space for the variable m, n, t, q col and p. The time
    for algorithm TRANSPOSE becomes when t is of the order of This is worse than the
    time using arrays. Explanation of Procedure TRANSPOSE (A, B) Let us take a matrix
    A ![](image-mfgo14sn.jpg) The tuple representation of matrix A is as follows: ![](image-4b1j2qip.jpg) The
    procedure TRANSPOSE is going to transpose the given matrix A and the result is
    stored in B. Statement 1, is initializing three variables and t with the values
    in A (0, A (0, and A (0, 3) respectively. So, and t where ‘m’ is the number of
    rows in A, ‘n’ is the number of columns in A and ‘t’ is the number of non-zero
    terms in A. Statement 2, initializes the first row of array B with the value of
    n, m, and t. So, B(0,2)= m=4 and B(0,3)=t=4 Now, array B looks like this: 1 2
    3 B (0 [4 4 4] Statement 3, checks whether the total number of non-zero terms,
    t is equal 0 it’s zero then return from the algorithm, otherwise the process of
    transpose continues. Statement 4, one pointer variable ‘q’ is used to position
    itself to the next term in B. It is initialized to 1 initially. Now our B looks
    like this: ![](image-lpiss7ws.jpg) The transpose is done by using the method of
    transpose by columns. Statement 5, the for loop is executed ‘n’ times and since
    here the value of ‘n’ is 4, the ‘for’ loop will be executed for 4 times. The initial
    value of Col=1 Statement 6, the pointer variable ‘p’ is used in the ‘for’ loop
    and this ‘for’ loop is going to execute for 4 times and thus, traversing each
    non-zero term in A. p=1\. Statement 7, checks whether the second column of array
    A, matches with matching occurs then transpose occurs, otherwise not. So, Col
    = 1 p = 1 If A (p, 2) = Col A (1, 2) = 1 1 = 1 ∴ Matching occurred, transposing
    takes place and the statement 8 does the transposing and then the pointer variable
    ‘q’ got updated. Now, the array B looks like the following: ![](image-12fklwz2.jpg) Again,
    control comes to statement 6, and ‘p’ is initialized to 2 and we can see that
    for all values of ‘p’, no matching occurs anymore. And thus, exiting from ‘for’
    loop and the control comes to statement 5 and thus initializes col= We can see
    that, for all values of ‘p’ for Col matching does not occur and hence exiting
    from the inner for loop and the control comes to statement 5\. Now, the for loop
    initializes the At this point, matching occurs twice and hence the following changes
    occurred in the array B, as shown below: ![](image-0sxijkii.jpg) Now our control
    comes to the main ‘for’ loop and thus At this point, one-matching occurs and hence
    the following changes occurred in the array B, as below: ![](image-ez39njgk.jpg) Thus,
    transposing complete.1.8 Program 1\. Program to Implement Polynomial Addition
    using Array #include<stdio.h></stdio.h>#include#define max 20struct poly{ int
    exp,coef; }; void main(){ struct poly p1[max],p2[max],p3[max]; int max1,max2,max3; clrscr(); printf(“\nEnter
    first poly : “); max1 = read_poly(p1); printf(“\nEnter second poly : “); max2
    = read_poly(p2); max3 = add_poly(p1,p2,p3,max1,max2); printf(“\nFirst poly is
    “); print_poly(p1,max1); printf(“\nSecond poly is “); print_poly(p2,max2); printf(“\n
    The resultant poly after addition is”); print_poly(p3,max3); } // mainint read_poly(struct
    poly p[]){ int i,texp; i=0; printf(“\nEnter exp ( use -1 to exit) : “); scanf(“%d”,&texp); while
    ( texp != -1) { p[i].exp = texp; printf(“\nEnter coef : “); scanf(“%d”,&p[i].coef); i++; printf(“\nEnter
    exp ( use -1 to exit) : “); scanf(“%d”,&texp); } //whil;e return(i); }// read_poly int
    print_poly(struct poly p[], int max1){ int i; for(i=0;i < max1;i++)printf(“%+dX%d
    “,p[i].coef,p[i].exp);return; } // print_polyint add_poly( p1,p2,p3,max1,max2)struct
    poly p1[],p2[],p3[];int max1,max2;{ int i,j,k; i = j = k = 0; while ( i < max1
    && j < max2){ if( p1[i].exp > p2[j].exp) { p3[k] = p1[i]; k++; i++; } elseif(
    p1[i].exp < p2[j].exp) { p3[k] = p2[j]; k++; j++; } else { p3[k].exp = p1[i].exp; p3[k].coef
    = p1[i].coef + p2[j].coef; i++; j++; k++; } } //while while( i < max1 ){ p3[k]
    = p1[i]; k++; i++; } //while while( j < max2 ) { p3[k] = p2[j]; k++; j++; } //while return(k); }//
    add_poly 2\. Program to Implement Sparse Matrix using Array #include<stdio.h></stdio.h> void
    main () { static int array[10][10]; int i, j, m, n; int counter = 0; printf(“Enter
    the order of the matix \n”); scanf(“%d %d”, &m, &n); printf(“Enter the co-efficients
    of the matix \n”); for (i = 0; i < m; ++i) { for (j = 0; j < n; ++j) { scanf(“%d”,
    &array[i][j]); if (array[i][j] == 0) {  ++counter; } } } if (counter > ((m * n)
    / 2)) { printf(“The given matrix is sparse matrix \n”); } else printf(“The given
    matrix is not a sparse matrix \n”); printf(“There are %d number of zeros”, counter); }Exercises  Define
    Algorithm. What is data structure? What are the major data structures used in
    the following areas: RDMS, Network data model and Hierarchical data model? What
    are different data types available? Why we need to do algorithm analysis? Compare
    arrays with ordered lists. List out the limitations of an array. Define Sparse
    Matrix. List the features of a good algorithm with an example. Apply your knowledge
    on ALGORITHM and develop an algorithm to calculate the sum of n numbers in an
    array. Use your knowledge on algorithm and construct an algorithm to find the
    factorial of a given number. Illustrate the different data structures available. What
    are common operations that can be performed on a data structure? Tell me in your
    own words about the asymptotic analysis of an algorithm. What are the criteria
    for algorithm analysis? Analyze the asymptotic notation for a given algorithm. Recall
    different schemes to represent polynomial expression in a memory. Illustrate an
    algorithm and create a recursive algorithm to find the sum of n numbers in an
    array. List out the areas in which data structures are applied extensively? Examine
    the space complexity and time complexity of any algorithm. Apply the concept of
    tuple representation to transpose the sparse matrix. Illustrate the array implementation
    of polynomial addition. MODULE IILinked Lists  CHAPTER 2 Linked Lists2.1 Introduction A
    linked list or one – way list, is mainly defined as a collection of data elements,
    called nodes, linearly arranged, where the linear order is maintained by using
    pointers. That is, in a linked list, each node is compartmentalized into two parts,
    the first part contains the data of the element and the second part, called the
    link part or next pointer field, contains the address of the node, coming next
    in the current working linked list. Figure 2.1 is a schematic diagram of a linked
    list with 6 nodes; each node is shown with 2 parts. The left part contains the
    information part of the node, which may contain entire records of data items (e.g.,
    NAME, ADDRESS) and the right part represents the next pointer field of the node,
    and here is an arrow drawn from it to the next node in the list. The next pointer
    field of the last node contains a special value, called the null pointer, which
    is any invalid address. ![](image-tjr75aqj.jpg)Figure 2.1 Linked list with 6 nodes The
    null pointer, denoted by ‘X'' in the diagram, indicates the end of the list. The
    linked list also contains a pointer variable called START or which gives the information
    related to the address of the first node of the list. We actually need this address
    in START to trace all the rest of the available nodes in the given linked list. A
    special case is the list, which doesn’t contain any nodes. Such a list is called
    the null list or empty list. A null pointer is used in the variable START, to
    denote the null list or empty list. Definition A linked list, is defined as an
    ordered collection of finites, similar data elements called nodes, where links
    or pointers maintain the linear order. In a linked list, depending on the requirements,
    the pointers are maintained and the linked list can be classified into three major
    groups:groups: groups: groups:groups: groups: groups:groups: groups: groups:2.2
    Single Linked List In a single linked list, each node contains only one link,
    which points to the subsequent node in the list.2.2.1 Representation of a Linked
    List in Memory There are two ways to represent a linked list in memory:memory:
    memory: memory: memory:memory: memory: memory: memory: memory: memory: memory:
    memory: (i) Static Representation using Array The static representation of a single
    linked list maintains two arrays parallelly: one array is for data, and other
    is for links. Static representation for the linked list is shown as follows (figure
    2.2, 2.3). ![](image-0oapsxak.jpg)Figure 2.2 A single linked list with 6 nodes ![](image-kg8ymyyh.jpg)Figure
    2.3 Static representation of a single linked list using arrays (ii) Dynamic Representation The
    linked list can be represented efficiently using free pool of storage. This logical
    method includes a memory bank (a collection of free memory spaces), and a memory
    manager (a program). During the process of creating a linked list, when a node
    is required, the request is placed before the memory manager, and then the memory
    manager will search the memory bank for the block requested and if it is found,
    grants a desired block to the requested caller. One program called the garbage
    collector returns the unused node to the memory bank. Memory bank is a list of
    memory space, which is available to a program. Such form of memory management
    is known as dynamic memory management. The dynamic representation of linked list
    uses the dynamic memory management policy. The mechanism of dynamic representation
    of single linked list is illustrated as shown in figure 2.2\. A linked list containing
    free pool of storage space is available, whose pointer is stored in AVAIL. When
    a request is placed before the memory manager for a node, the list AVAIL is being
    searched for the block of appropriate size. If AVAIL is empty or the block of
    expected size is not found, the memory manager will return a message accordingly.
    Suppose, the desired block is available and let it be XY. Then, the memory manager
    will return the pointer of XY to the requested caller working linked list in a
    temporary buffer, say NEW. The newly availed node XY then can be inserted at any
    position in the linked list by changing the pointer of the concerned nodes. In
    figure the node XY is inserted at the end and change of pointers are shown by
    the dotted arrows. ![](image-rkbe4svg.jpg)Figure 2.4 Allocation of node from memory
    bank to a linked list Procedure INIT (n) // initialize the storage pool, through
    the LINK field, to contain nodes with address 1, 2, 3....n and set to AV to point
    to the first node in this list// for i←1 to n-1 do LINK ( i ) ← i + 1 end LINK
    ( n ) ← 0 AV ← 1 end INIT2.2.2 Operations on a Single Linked List Possible operations
    on a single linked list are listed as follows:  Traverse a linked list. Insertion
    of a node into a linked list. Delete a node from a linked list. Copy linked list
    to make a duplicate linked list. Merging two linked lists into one list. Searching
    for an element in a list. Traverse a Single Linked List The traversing a single
    linked list, means to visit every node in the list starting from the first node
    to the last node. Algorithm TRAVERSE (HEADER) 1\. ptr1 = HEADER.link // ptr1 is
    to store the pointer to current node. 2\. While (ptr1 ≠ NULL) do // Continue till
    the last node. 3\. PROCESS (ptr1) // perform PROCESS () on the On the current
    node. 4\. ptr1 = ptr1.link // Move to the next node. 5\. End while 6\. Stop Insertion
    of a node into a single linked list There are various positions where a node can
    be inserted:inserted: inserted: inserted: inserted: inserted: inserted: inserted:inserted:
    inserted: inserted: inserted: inserted: inserted: inserted: inserted:inserted:
    inserted: inserted: inserted: inserted: inserted: inserted: (i) Insert at front Algorithm
    INSERT_FRONT (HEADER, X) 1\. new = GETNODE (NODE) 2\. if (new = NULL) then (a)
    Print “Memory underflow!!!” (b) exit 3\. else (a) new. LINK = HEADER.LINK (b)
    new. DATA = X (c) HEADER.LINK = new 4\. Endif 5\. Stop Procedure GETNODE(Y) //Y
    is set to point to a free node if there is one on AV// If AV=0 then call NO-MORE-NODES y←
    AV LINK (AV) End GETNODE (ii) Insert at end Algorithm INSERT_END (HEADER, X) 1\.
    new = GETNODE (NODE) 2\. If (new = NULL) then (a) Print “Memory is insufficient!!!” (b)
    Exit 3\. Else (a) ptr = HEADER. LINK (b) While (ptr. LINK ≠ NULL) do (i) ptr =
    ptr. LINK (c) End while (d) ptr. LINK = new (e) new. DATA = X (f) new. LINK =
    NULL 4\. End if 5\. Stop Procedure RET(Y) // Y Points to a node which is to be
    returned to theavailable space list// LINK (Y) ← AV AV ← Y End RET (iii) Insert
    at any position Algorithm INSERT _ANV (HEADER, X, KEY) 1\. new = GETNODE (NODE) 2\.
    if (new = NULL) then (i) print “memory is insufficient!!!” (ii) exit 3\. Else (i)
    ptr = HEADER (ii) While [(ptr. DATA ≠ KEY) AND (ptr. LINK ≠  NULL)] do (a) ptr
    = ptr. LINK (iii) Endwhile (iv) If (ptr. LINK=NULL) then  (a) Print “KEY is not
    available in the list!!!”  (b) Exit  (v) Else  (a) new. LINK = ptr. LINK  (b)
    new. DATA = X  (c) ptr. LINK = new (vi) Endif 4\. Endif 5\. Stop Deletion of a
    Node from a Single Linked List There are also various cases of deletion:deletion:
    deletion: deletion: deletion: deletion: deletion: deletion:deletion: deletion:
    deletion: deletion: deletion: deletion: deletion:deletion: deletion: deletion:
    deletion: deletion: deletion: deletion: (i) Deletion at the front of the list The
    following algorithm is to delete a node from a single linked list at the front
    of the list: Algorithm DELETE _ FRONT (HEADER) 1\. ptr = HEADER.LINK 2\. If (ptr
    = NULL) (a) Print “The list is empty: No deletion” (b) exit 3\. else (a) ptr1
    = ptr. LINK (b) HEADER. LINK = ptr1 4\. RET (ptr) 5\. Endif 6\. Stop ![](image-0cfx5rth.jpg) (ii)
    Deletion at the end of the list The following algorithm is to delete a node at
    the end from a single linked list. Algorithm DELETE_ END (HEADER) 1\. ptr = HEADER
    // Start from the Header node 2\. If (ptr. LINK=NULL) then (a) Print “The list
    is empty: No deletion” (b) Exit 3\. Else (a) While (ptr. LINK ≠ NULL) do //Go
    to the last node (i) ptr1 = ptr // to store the previous ptr (ii) ptr = ptr. LINK
    // move to the next (b) Endwhile (c) ptr1.LINK = NULL (d) RET (ptr) 4\. Endif 5\.
    Stop ![](image-m64xke40.jpg) (iii) Deletion of a node from a single linked list
    at any position in the list Algorithm DELETE_ANY 1\. ptr1 = HEADER // start from
    the header node 2\. ptr = ptr1.LINK  // points to the node, if any 3\. While (ptr
    ≠ NULL) do (a) If (ptr. DATA ≠ KEY)then (i) ptr1 = ptr (ii) ptr = ptr. LINK (b)
    Else (i) ptr1.LINK = ptr. LINK (ii) RET (ptr) (iii) Exit (c) Endif 4\. Endwhile 5\.
    If (ptr=NULL)then (a) Print “Node with KEY doesn’t exist: No deletion” 6\. End
    if 7\. Stop Merging of 2 single linked lists into one list. Algorithm MERGE (HEADER1,
    HEADER2; HEADER) 1\. ptr = HEADER1 2\. While (ptr. LINK ≠ NULL) do // move to
    the last node in the list L1 (a) ptr = ptr. LINK 3\. Endwhile 4\. ptr. LINK =
    HEADER2\. LINK //last node in L1 points to the first node in L2 5\. RET (HEADER2) //
    Return the header node to the memory bank 6\. HEADER =HEADER1 // HEADER becomes
    the header node of the merged list. 7\. Stop ![](image-kx58yw8x.jpg) Copy of a
    single linked list For a given list we can copy it into another list by duplicating
    the content of each node into a newly allocated node. 1\. ptr = HEADER. LINK //
    current position in the master list 2\. HEADER1 =GETNODE (NODE) // Get a node
    for the header of a duplicate list 3\. ptr1 = HEADER1 // ptr1 is the current position
    in dup.list 4\. ptr1\. DATA = NULL // Header node doesn’t contain any data 5\.
    While (ptr ≠ NULL) do // Till the traversal of a master node is finished (a) New
    = GETNODE (NODE) // Get a new node from memory bank (b) New. DATA = ptr. DATA
    // copy the content (c) ptr1.LINK = new  // Insert the node if the end of the
    duplicate list (d) New. LINK = NULL (e) ptr1 =New (f) ptr = ptr. LINK  // ptr
    move to the next node in the master list 6\. Endwhile 7\. Stop ![](image-zroizosc.jpg) Linked
    Stacks and Queues When we have only one stack or one queue, sequential representation
    of stacks and queue are sufficient. However, when several stacks and queues co-exist
    there was no efficient way to represent sequentially. In this case, we can use
    linked list. The following fig. Linked Stack and fig. Linked Queue, shows linked
    stack and linked queue: ![](image-o7d8h0s8.jpg)Figure 2.5 Linked stack and Queue (b)
    Linked stack The direction of links for both the stack and queue are such as to
    facilitate easy insertion and deletion of nodes. In the case of figure one can
    easily add a node at the top or delete one from the top. In figure one can easily
    insert a node at the rear and deletion can be easily performed at the front. If
    we wish to represent ‘n’ stacks and ‘m’ queues, simultaneously, then the following
    algorithms and initial conditions, will serve the needed goal: ![](image-dv7ft67q.jpg) Initial
    conditions: T (j) = 0 1≤ j ≤ n F(j) = 0 1≤ j ≤ m Boundary Conditions: T (j) =
    0 iff stack j empty F(j) = 0 iff queue j empty Procedure ADDLS (i,Y) //add element
    Y in the stack i // Call GETNODE (Z) DATA (Z) ← Y // store data value Y into new
    node // LINK (Z) ← T(i) //attach new node to top of ith sack// T (i) ←Z // reset
    stack pointer // end ADDLS Procedure DELETES (i, Y) //delete the top node from
    stack i and set Y to be the DATA field of this node. If T(i) = 0 then call STACKEMPTY X
    ←T(i) // set X as the top node of stack i // Y← DATA (X) // y updates to a new
    data // T (i) ←LINK (X) //delete the node from top of stack i // Call RET (X)
    // return node to the storage pool // end DELETES. Procedure ADDQueue (i,y) //
    add Y to the queue // Call GETNODE (Z) DATA (Z) ← y; LINK (Z) ← 0; If F(i) = 0
    then F(i) ← R(i) ← Z // queue was empty else LINK (R(i))←Z; R(i) ← Z; // queue
    contains elements // end ADDQueue Procedure DELETEQ (i, n) //delete the start
    node in the ith queue, set n to its DATA field // If F(i) = 0, call QueueEMPTY else Z←
    F(i); F(i) ←LINK (Z) // set Z to front node // n← DATA (Z) ; // remove data // Call
    RET (Z) // return node// end DELETEQ2.3 Some important procedures (1) Procedure
    to count the number of nodes in a single linked list. Algorithm COUNT_SL (count,
    HEADER) 1\. ptr = HEADER.LINK 2\. count = 0 3\. While (ptr.link=NULL) (a) ptr
    = ptr.LINK (b) count = count +1 4\. Endwhile 5\. Print “The number of nodes is
    count” 6\. End COUNT_SL (2) Procedure to reverse the given singly linked list. Algorithm
    REVERSE_SL (HEADER, P1, P2, P3) 1\. P1 = HEADER.LINK 2\. P2 = P1.LINK 3\. P3 =
    P2.LINK 4\. P1.LINK = NULL 5\. P2.LINK = P1 6\. While (P3.LINK! = NULL) 7\. (a)
    P1 = P2 (b) P2 = P3 (c) P3 =P3.LINK (d) P2.LINK = P1 8\. Endwhile 9\. P3\. LINK
    ←P2 10\. Header.LINK ←P3 11\. End REVERSE_SL // include ‘If’ if there is only
    one node in the list and return.// Note: Reverse Linked List ![](image-s4q2ur38.jpg) Reverse
    of the above linked list will do the following things:things: things: things:
    things: things: things: things: things: things: things:things: things: things:
    things: things: things: things: things: things: things: things: things: things:
    things: things: things: things:things: things: things: things: things: things:
    things: things: things: things: things: things:things: things: things: things:
    things: things: things: things: things: things: things: things: things: things:
    things: things: Now the reversed linked list will be as: ![](image-tcoykcqg.jpg)2.4
    Doubly Linked List We have seen in single linked list, we can traverse only in
    one direction because each node has address of next node only. Suppose we are
    in the middle of linked list and we want to do operation with just previous node
    then, we have no way to go on previous node, we will again traverse from starting
    node. So, this is a drawback of single linked list. To overcome the above drawback,
    another data structure doubly linked list is introduced. In this, each node has
    address of previous and next node also, i.e., each node has 2 link fields, one
    points to the forward and the second points to the reverse direction respectively. In
    the doubly linked list, a node has minimum of 3 fields say: DATA, LLINK (left
    link) and RLINK (right link). The only drawback is that each node has to contain
    the address information of previous node. ![](image-g0sks1sz.jpg)Figure 2.6 Doubly
    Linked List A sample doubly linked list is shown above. Besides these 5 nodes
    a special node has been added called a head node. Now, assume that P points to
    any node in a doubly linked list. Then we get the following: ![](image-9utzcq41.jpg) Procedure
    DDELETE(Y,L) //DDELETE deletes node Y from list L. // if Y = L then call NO_NODES //L
    is a list which contains at least one node// RLINK (LLINK(Y)) ← RLINK(Y) LLINK
    (RLINK(Y)) ← LLINK(Y) call RET(Y) end DDELETE Procedure DINSERT (N,X) //insert
    node R to the right of node X// LLINK(N) ←X // set LLINK & RLINK fields of node
    N// RLINK (N)←RLINK(X) LLINK(RLINK(X)) ←N RLINK(X) ←N end DINSERT2.4.1 Operations
    on a Doubly Linked List Possible operations on a doubly linked list are listed
    as follows:  Traversing a list. Insertion of a node into a list. Deletion of a
    node from a list. Traversing a Doubly Linked List To traverse a doubly linked
    list, we mean to visit every node in the list starting from the beginning of the
    linked list to the end of the linked list, i.e., from the start node to the last
    node. Algorithm TRAVERSE_DL (HEADER) 1\. ptr = HEADER.RLINK 2\. While (ptr ≠ NULL)do (a)
    PROCESS(ptr) (b) ptr = ptr.RLINK 3\. Endwhile 4\. Stop. ![](image-ba12kkun.jpg) Insert
    a node into a double-linked list Insertion in a doubly linked list may be possible
    in three ways:ways: ways: ways:ways: ways: ways:ways: ways: ways: (1) Insertion
    at beginning The following algorithm INSERT_DL_FRONT will insert a node as the
    first node of the list. Algorithm INSERT_DL_FRONT(X) // X the data content of
    the node to be inserted// // Double linked list whose pointer to the // // header
    node is HEADER// 1\. ptr = HEADER.RLINK //point to the node 2\. new = GETNODE(NODE)
    // Avail a new node from thememory bank 3\. if (new ≠ NULL) then // if new node
    is available a) new. LLINK = HEADER // newly inserted node points the header b)
    HEADER.RLINK = new // Header now points to the new node. c) new.RLINK = ptr//
    set the RLINK of new d) ptr.LLINK = new // set the LLINK of ptr e) new.DATA =
    X // copy the data into newly inserted node. 4\. Else a) Print “Unable to allocate
    memory: insertion is  not possible” 5\. Endif 6\. Stop ![](image-mygh0d7g.jpg) (2)
    Insertion of a node at the end The algorithm INSERT_DL_END is to insert a node
    at the end into a doubly linked list. Algorithm INSERT_DL_END(X) 1\. ptr = HEADER.RLINK 2\.
    While (ptr.RLINK!=NULL) do a) ptr = ptr.RLINK 3\. Endwhile 4\. new = GETNODE(NODE) 5\.
    If (NEW ≠ NULL) then a) NEW. LLINK = ptr b) NEW. RLINK = NULL c) NEW. DATA = X d)
    ptr. RLINK = NEW 6\. else a) print “Unable to allocate memory: Insert not possible” 7\.
    Endif 8\. Stop ![](image-vhk3aeql.jpg) (3) Insertion of a node at any position
    in the list The algorithm INSERT_DL_ANY is to insert a node into a doubly linked
    list at any position. Algorithm INSERT_DL_ANY (X,KEY) // X be the data content
    of the node to be inserted, // and KEY the data content of the node after which //
    the new node to be inserted. 1\. ptr = HEADER 2\. While (ptr.DATA ≠ KEY) and (ptr.RLINK≠NULL)do a)
    ptr = ptr.RLINK 3\. End 4\. NEW = GETNODE(NODE) 5\. If (NEW = null) then a) Print
    “memory is not available” b) Exit 6\. Endif 7\. If (ptr. RLINK = NULL) // If the
    KEY node is at theend or not found. a) NEW. LLINK = ptr b) ptr. RLINK = NEW //
    insert at the end. c) NEW. RLINK = NULL d) NEW. DATA = X 8\. Else // The KEY is
    available a) ptr1 = ptr.RLINK // next node after the key node b) NEW. LLINK =
    ptr c) NEW. RLINK = ptr1 d) ptr. RLINK = NEW e) ptr1.LLINK = NEW f) ptr = NEW
    // this becomes the current node g) NEW. DATA = X 9\. Endif 10\. Stop ![](image-ceiey7yk.jpg) Deletion
    in a double linked list Deletion in a doubly linked list may be possible in three
    ways:ways: ways: ways: ways:ways: ways: ways: ways:ways: ways: ways: ways: 1\.
    Deletion at the front Algorithm DELETE_DL_FRONT() 1\. ptr = HEADER.RLINK 2\. If
    (ptr = NULL) then a) Print “List is empty: Deletion not possible” b) Exit 3\.
    Else a) ptr1 = ptr.RLINK b) HEADER.RLINK = ptr1 c) If (ptr1 ≠ NULL) // if the
    list contains a node after the first node of deletion a) ptr1.LLINK = HEADER d)
    Endif e) RET(ptr) 4\. Endif 5\. Stop ![](image-r56qwump.jpg) 2\. Deletion at the
    end Algorithm DELETE_DL_END() 1\. ptr = HEADER 2\. While (ptr. RLINK! = NULL)
    do //move to the last node a) ptr = ptr.RLINK 3\. End while 4\. If (ptr = HEADER)
    then a) Print “list empty : No Deletion” b) Exit 5\. Else a) ptr1 = ptr.LLINK
    // Pointer to the previous node of last node. b) ptr1.RLINK = NULL c) RET(ptr) 6\.
    Endif 7\. Stop ![](image-pl9wewey.jpg) (3) Deletion at any position Algorithm
    DELETE_DL_ANY (KEY) // A doubly linked list with data, and KEY, the data // content
    of the key node to be deleted. 1\. ptr = HEADER.RLINK 2\. IF (ptr = NULL ) then (a)
    Print “List is empty : No deletion” (b) Exit 3\. Endif 4\. While (ptr.DATA≠KEY)
    and (ptr.RLINK≠NULL) do (a) ptr = ptr.RLINK 5\. Endwhile 6\. If (ptr.DATA=KEY)
    then (a) ptr1=ptr.LLINK (b) ptr2=ptr.RLINK (c) ptr1.RLINK = ptr2 (d) If (ptr2≠NULL)
    then // if the deleted node is last node (i) ptr2.LLINK=ptr1 (e) Else (i) ptr1.RLINK=NULL (f)
    Endif (g) RET (ptr) 7\. Else (a) Print “The node doesn’t exist in the given list”. 8\.
    Endif 9\. Stop ![](image-9g3i2gzn.jpg)2.5 POLYNOMIAL ADDITION USING LINKED LIST Procedure
    POLYADD (X, Y, Z) //Polynomials X and Y represented as singly linked list are
    summed to form the new list named Z// 1\. a <- X; b <- Y // a, b pointers to next
    term of X, Y// 2\. call GETNODE(Z); d <- Z; // initial node for Z, returned later// 3\.
    while a ≠0 and b ≠0 do // while there are more terms in X and Y// 4\. case 5\.
    : EXP (a) = EXP (b): //equal exponents// 6\. x <- CEOF(a) + COEF(b) 7\. If x =
    0 call ATTACH (x, EXP(a), d) 8\. a <- LINK(a); b <- LINK(b) // advance to next
    terms// 9\. : EXP(a) < EXP(b): 10\. Call ATTACH (COEF(b), EXP(b), d) 11\. b <-
    LINK(b) //advance to next term// 12\. : else: call ATTACH (COEF(a), EXP(a), d) 13\.
    a <- LINK(a) //advance to next term of X// 14\. end 15\. end 16\. while a ≠ 0
    do // copy remaining terms of X// 17\. call ATTACH (COEF(a), EXP(a), d) 18\. a
    <- LINK(a) 19\. end 20\. while b ≠ 0 do // copy remaining terms of Y// 21\. call
    ATTACH (COEF(b), EXP(b), d) 22\. b <- LINK(b) 23\. end 24\. LINK(d) < - 0; t <-
    Z; Z <- LINK(Z) //delete extra initial node// 25\. Call RET(t) 26\. end POLYADD.2.6
    Linked list Implementation of Procedure POLYADD (X, Y, Z) Let us take two polynomials
    as: A = – + B = + + x The Polynomial A is represented using linked list as follows: ![](image-6rtiim1y.jpg) The
    polynomial B(x) is represented using linked list as follows: ![](image-69fyrv70.jpg) Pointers
    and ‘q’ are used to point next terms of A & B respectively. This assignment is
    done in statement 1\. So, polynomial A and polynomial B, will be as follows: ![](image-subl0fl7.jpg) Statement
    2, creates a node C and a pointer ‘d’ is used to point nodes in C. The pictorial
    representation of the statement 2 is as follows: ![](image-d9ufnflb.jpg) Statement
    3, checks whether there are more terms in A and B or not. If both A & B contains
    more term, then while loop execution proceeds otherwise, not. In our case, A &
    B contain more terms, so control enters into the while loop. Now, case statements
    are there, and we have to check which case statement satisfies now. Here, EXP
    (p) > i.e.; 10 > is TRUE, so when statement 12 gets executed, the following changes
    occur in C and A: ![](image-l7nzkp37.jpg) Again statement 3 was checked and we
    found that the condition for while is TRUE so, while loop is getting executed
    once again. Now, we have to check which case statement satisfies now. Here, EXP(p)
    < i.e; 5 < 8, is TRUE, so when statements 10 and 11 get executed, the following
    changes occurred in B and C: ![](image-sl8ubwat.jpg) Statement 3 checked again
    and we found that the conditions for while loop is TRUE, so while loop is getting
    executed once again. Now, we have to check which case statement satisfies now. Here,
    EXP (p) = EXP i.e., 5 = 5, is TRUE, so statement 6 gets executed and addition
    of coefficients happen and the result get stored in ‘x’. Now, x is checked whether
    it is a zero term or non-zero term. If it is a zero term, then only p and q get
    updated, otherwise, the new term x has to be attached in C and corresponding pointers
    d, p & q are to be updated. In our case, x=0, so only p & q have to be updated
    and the pictorial representation of changes occurred are shown as follows: ![](image-kpqtige2.jpg) Now
    again statement 3 is being checked and we found that the conditions for while
    loop is TRUE, so while loop is getting executed once again. We have to check which
    case statement satisfies now. Here, Exp (p) > Exp i.e., 2 > 1, is TRUE, so statement
    12 gets executed, the following changes occurred in C and A: ![](image-xtop9myo.jpg) Since,
    the updated value of p=0, we found that the conditions for while loop gets false,
    and hence control is not entering into the while loop. Now, statement 16, is being
    checked and found condition as FALSE and hence, control checks statement 20 and
    found it as TRUE and hence, the remaining terms of B are being copied to C and
    q is being updated. The pictorial representation of the above-mentioned process
    is shown as follows: ![](image-7u30y4lr.jpg) Since all the terms from B have been
    copied to C, control moves to statement 24\. When statement 24 gets executed,
    the following changes occurred in C: ![](image-1m365ind.jpg) Now, at last, when
    statement 25 gets executed, it is going to return that node in C, which is being
    pointed by ‘t’. The pictorial representation is as follows: ![](image-pleslc1f.jpg)2.7
    Program 1\. Program implementing operations of single linked list #include<stdio.h></stdio.h>#include#include<stdlib.h></stdlib.h> void
    insertAtBeginning(int);void insertAtEnd(int);void insertBetween(int,int,int);void
    display();void removeBeginning();void removeEnd();void removeSpecific(int); struct
    Node{ int data; struct Node *next; }*head = NULL; void main(){ int choice,value,choice1,loc1,loc2; clrscr(); while(1){ printf("
    main Menu: \n\n********* MENU ************\ n1\. Insert\n2\. Display\n3\. Delete\n4\.
    Exit\nEnter your choice: "); scanf("%d",&choice); switch(choice) {  case 1: printf("Enter
    value: "); scanf("%d",&value); while(1){ printf("Where you want to insert: \n1\. Beginning\n2\.
    End\n3\. Between\nEnter your choice: "); scanf("%d",&choice1); switch(choice1) { 
    case 1: insertAtBeginning(value); break;  case 2: insertAtEnd(value); break; 
    case 3: printf("Enter the 2 values:"); scanf("%d%d",&loc1,&loc2); insertBetween(value,loc1,loc2); break; 
    default: printf("\nWrong Input!! \n"); goto mainMenu; } goto subMenuEnd; } subMenuEnd: break; case
    2: display(); break; case 3: printf("Select your Delete option: \n1\. From Beginning\n2\.
    From End\n3\. Spesific\nEnter your choice: "); scanf("%d",&choice1); switch(choice1) { 
    case 1: removeBeginning(); break;  case 2: removeEnd(value); break;  case 3: printf("Enter
    the value: ");  scanf("%d",&loc2);  removeSpecific(loc2);  break;  default: printf("\nWrong
    Input!! Try again!!!\n");  goto mainMenu; } break; case 4: exit(0); default: printf("\nWrong
    input!!! Try again!!\n"); } } } void insertAtBeginning(int value){ struct Node
    *newNode; newNode = (struct Node*)malloc(sizeof(struct Node)); newNode->data =
    value; if(head == NULL) { newNode->next = NULL; head = newNode; } else { newNode->next
    = head; head = newNode; } printf("\nOne node inserted!!!\n"); } void insertAtEnd(int
    value) { struct Node *newNode; newNode = (struct Node*)malloc(sizeof(struct Node)); newNode->data
    = value; newNode->next = NULL; if(head == NULL) head = newNode; else { struct
    Node *temp = head; while(temp->next != NULL) temp = temp->next; temp->next = newNode; } printf("\nOne
    node inserted!!!\n"); } void insertBetween(int value, int lo1, int lo2) { struct
    Node *newNode; newNode = (struct Node*)malloc(sizeof(struct Node)); newNode->data
    = value; if(head == NULL) { newNode->next = NULL; head = newNode; } else { struct
    Node *temp = head; while(temp->data != lo1 && temp->data != lo2) temp = temp->next; newNode->next
    = temp->next; temp->next = newNode; } printf("\nOne node inserted!!!\n"); } void
    removeBeginning() { if(head == NULL) printf("\n\nList is Empty!!!"); else { struct
    Node *temp = head; if(head->next == NULL) { head = NULL;  free(temp); } else { head
    = temp->next; free(temp); printf("\nOne node deleted!!!\n\n"); } } } void removeEnd() { if(head
    == NULL) { printf("\nList is Empty!!!\n"); } else { struct Node *temp1 = head,*temp2; if(head->next
    == NULL) head = NULL; else { while(temp1->next != NULL)  { temp2 = temp1; temp1
    = temp1->next;  } temp2->next = NULL; } free(temp1); printf("\nOne node deleted!!!\n\n"); } } void
    removeSpecific(int delValue) { struct Node *temp1 = head, *temp2; while(temp1->data
    != delValue) {  if(temp1 -> next == NULL){  printf("\nGiven node not found"); 
    goto functionEnd;  }  temp2 = temp1;  temp1 = temp1 -> next; } temp2 -> next =
    temp1 -> next; free(temp1); printf("\nOne node deleted!!!\n\n"); functionEnd: } void
    display() { if(head == NULL) { printf("\nList is Empty\n"); } else { struct Node
    *temp = head; printf("\n\nList elements are - \n"); while(temp->next != NULL) { printf("%d
    --->",temp->data); temp = temp->next; } printf("%d --->NULL",temp->data); } } 2\.
    Program for implementing doubly linked list #include<stdio.h></stdio.h>#include#include<stdlib.h></stdlib.h> void
    insertAtBeginning(int);void insertAtEnd(int);void insertBetween(int,int,int);void
    display();void removeBeginning();void removeEnd();void removeSpecific(int); struct
    Node{ int data; struct Node *next; }*head = NULL; void main() { int choice,value,choice1,loc1,loc2; clrscr(); while(1){ printf("\n
    MainMenu: \n********* MENU ************\n1\. Insert\n2\. Display\n3\. Delete\n4\. Exit\nEnter
    your choice: "); scanf("%d",&choice); switch(choice) {  case 1: printf("Enter
    value: ");  scanf("%d",&value);  while(1){  printf("Where you want to insert:
    \ n1.Beginning\n2.End\n3\. Between\nEnter your choice: ");  scanf("%d",&choice1); 
    switch(choice1)  {  case 1: insertAtBeginning(value);   break;  case 2: insertAtEnd(value); 
     break;  case 3: printf("Enter the 2 values:");   scanf("%d%d",&loc1,&loc2); insertBetween(value,loc1,loc2); 
     break;  default: printf("\nWrong Input!! \n");  goto mainMenu;  } goto subMenuEnd;  }  subMenuEnd:  break; case
    2: display();  break; case 3: printf("Select your Delete option: \n1\. From Beginning\n2\.
    From End\n3\. Spesific\nEnter your choice: "); scanf("%d",&choice1); switch(choice1) { 
    case 1: removeBeginning();  break;  case 2: removeEnd(value);  break;  case 3:
    printf("Enter the value: ");  scanf("%d",&loc2);  removeSpecific(loc2);  break; 
    default: printf("\nWrong Input!! \n");  goto mainMenu;  }  break;  case 4: exit(0); 
    default: printf("\nWrong input!!!\n"); } } } void insertAtBeginning(int value) { struct
    Node *newNode; newNode = (struct Node*)malloc(sizeof(struct Node)); newNode->data
    = value; if(head == NULL) {  newNode->next = NULL;  head = newNode; } else { 
    newNode->next = head;  head = newNode; } printf("\nOne node inserted!!!\n"); } void
    insertAtEnd(int value) { struct Node *newNode; newNode = (struct Node*)malloc(sizeof(struct Node)); newNode->data
    = value; newNode->next = NULL; if(head == NULL)  head = newNode; else {  struct
    Node *temp = head;  while(temp->next != NULL) temp = temp->next;  temp->next =
    newNode; } printf("\nOne node inserted!!!\n"); } void insertBetween(int value,
    int loc1, int lo2) { struct Node *newNode; newNode = (struct Node*)malloc(sizeof(struct Node)); newNode->data
    = value; if(head == NULL) {  newNode->next = NULL;  head = newNode; } else { 
    struct Node *temp = head;  while(temp->data != loc1 && temp->data != lo2)  temp
    = temp->next;  newNode->next = temp->next;  temp->next = newNode; } printf("\nOne
    node inserted!!!\n"); } void removeBeginning() { if(head == NULL)  printf("\n\nList
    is Empty!!!"); else {  struct Node *temp = head;  if(head->next == NULL)  {  head
    = NULL;   free(temp);  }  else  {  head = temp->next;  free(temp);  printf("\nOne
    node deleted!!!\n\n");  } } } void removeEnd() { if(head == NULL) {  printf("\nList
    is Empty!!!\n"); } else {  struct Node *temp1 = head,*temp2;  if(head->next ==
    NULL) head = NULL;  else  {  while(temp1->next != NULL)  { temp2 = temp1; temp1
    = temp1->next;  }  temp2->next = NULL;  }  free(temp1); printf("\nOne node deleted!!!\n\n"); } } void
    removeSpecific(int delValue) { struct Node *temp1 = head, *temp2; while(temp1->data
    != delValue) {  if(temp1 -> next == NULL){  printf("\nGiven node not found");
    goto  functionEnd;  }  temp2 = temp1;  temp1 = temp1 -> next; } temp2 -> next
    = temp1 -> next; free(temp1); printf("\nOne node deleted!!!\n\n"); functionEnd: } void
    display() { if(head == NULL) {  printf("\nList is Empty\n"); } else {  struct
    Node *temp = head;  printf("\n\nList elements are - \n");  while(temp->next !=
    NULL)  {  printf("%d --->",temp->data);  temp = temp->next;  } printf("%d --->NULL",temp->data); } } 3\.
    Program to add two polynomials using linked list #include<stdio.h></stdio.h>#include#include<math.h></math.h> typedef
    struct node { int power; float coeff; struct node *next; }node;  node * insert(node
    *head,int power1,float coeff1);  node * create();  node * padd(node *p1,node *p2); 
    node * pmul(node *p1,node *p2);  float eval(node *p1,float x);  void print(node
    *head); node *insert(node *head,int power1,float coeff1)  { node *p,*q; /*terms
    are store in increasing order of power*/ /*Location for inseration is identified
    using pointer.  p is the pointer which used to store the address of the node created
    for  the current term.For the term with same power, the coefficients  are added*/ 
    p=(node*) malloc(sizeof(node));  p->power=power1;  p->coeff=coeff1;  p->next=NULL; 
    if(head==NULL)  {   head=p;   head->next=head;   return(head);  }   if(power1>head->power) 
     {   p->next=head->next;   head->next=p;   head=p;   return(head);   }   if(power1==head->power) 
     {   head->coeff=head->coeff+coeff1;   return(head);   }  q=head;  while(q->next!=head
    && power1>=q->next->power)   q=q->next;  if(p->power==q->power)   q->coeff=q->coeff+coeff1; 
    else   {   p->next=q->next;   q->next=p;   }  return(head); } node *create() { 
    int n,i,power1;  float coeff1;  node *head=NULL;  printf("\nEnter No. of Terms:"); 
    scanf("%d",&n);  printf(" Enter %d terms",&n);  printf("Coefficent must be entered
    after the power");  for(i=1;i<=n;i++) { scanf("%d%f",&power1,&coeff1);  head=insert(head,power1,coeff1); } 
    return(head); } node * padd(node *p1,node *p2) { node *p; node *head=NULL; int
    power;float coeff; p=p1->next; do {  head=insert(head,p->power,p->coeff);  p=p->next; }
    while(p!=p1->next); p=p2->next; do {  head=insert(head,p->power,p->coeff);  p=p->next; }
    while(p!=p2->next); return(head); } node *pmul(node *p1,node *p2) { node *head1,*head2; node
    *head=NULL; head2=p2->next;  do  { head1=p1->next;  do  { // for(p=head1;p!=NULL;p=p->next) 
    head=insert(head,head1->power+head2- >power,head1->coeff * head2->coeff);  head1=head1->next; 
    }while(head1!=p1->next); head2=head2->next;  }while(head2!=p2->next);  return(head); } float
    eval(node *head,float x) { float value=0.00; node *p; p=head->next; do  { value=value+p->coeff
    * pow(x,p->power);  p=p->next;  }while(p!=head->next); return(value); } void print(
    node *head) { node *p; p=head->next; printf("\n"); do  { printf("%6.2fx^%d ",p->coeff,p->power); p=p->next; 
    }while(p!=head->next); } void main() { node *p1,*p2,*p3; int op; float value,x; p1=p2=p3=NULL; clrscr(); do {
    printf("\n1)Create first polynomial");  printf("\n2)Create second polynomial"); 
    printf("\n3)Add\n4)Quit");  printf("\nEnter Your Choice: ");  scanf("%d",&op); 
    switch(op) { case 1: p1=create();break; case 2: p2=create();break; case 3: p3=padd(p1,p2); 
    print(p3);break;  }  }while(op!=4); }Exercises'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '| 1. | In a circular linked list'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '| 1. | 在循环链表中'
- en: '&#124; (a) &#124; Components are all linked together in some linear order.
    &#124;'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; 所有组件都以某种线性顺序链接在一起。 &#124;'
- en: '&#124; (b) &#124; There is no beginning and no end. &#124;'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (b) &#124; 没有开始也没有结束。 &#124;'
- en: '&#124; (c) &#124; Components are arranged hierarchically. &#124;'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; 组件按层次排列。 &#124;'
- en: '&#124; (d) &#124; Traversal is possible in the forward and backward direction.
    &#124;'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (d) &#124; 可以向前和向后遍历。 &#124;'
- en: '|'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: (b)
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: (b)
- en: '| 2. | A sequential collection of data elements, where the sequential order
    is given by means of pointer is called?'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '| 2. | 一个数据元素的顺序集合，其中顺序由指针给出的数据结构是？'
- en: '&#124; (a) &#124; Linked list &#124; (b) &#124; Node list &#124;'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; 链表 &#124; (b) &#124; 节点列表 &#124;'
- en: '&#124; (c) &#124; Primitive list &#124; (d) &#124; None &#124;'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; 原始列表 &#124; (d) &#124; 无 &#124;'
- en: '|'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: (a)
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: (a)
- en: '| 3. | Among the following, which operation is performed more efficiently by
    doubly linked list than by singly linked list?'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '| 3. | 在以下操作中，双向链表比单向链表更有效执行的是？'
- en: '&#124; (a) &#124; Deleting a node whose location in given. &#124;'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; 删除给定位置的节点。 &#124;'
- en: '&#124; (b) &#124; Searching of a given unsorted list for a given data. &#124;'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (b) &#124; 在给定的未排序列表中搜索给定数据。 &#124;'
- en: '&#124; (c) &#124; Traversing a list to process each node. &#124;'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; 遍历列表以处理每个节点。 &#124;'
- en: '&#124; (d) &#124; None of the above. &#124;'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (d) &#124; 以上都不是。 &#124;'
- en: '|'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: (a)
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: (a)
- en: '| 4. | In linked list each node contains minimum of two fields. One field is
    to store the original data, and the next field is?'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '| 4. | 在链表中，每个节点包含至少两个字段。一个字段用于存储原始数据，另一个字段是？'
- en: '&#124; (a) &#124; Pointer to character &#124; (b) &#124; Pointer to integer
    &#124;'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; 指向字符的指针 &#124; (b) &#124; 指向整数的指针 &#124;'
- en: '&#124; (c) &#124; Pointer to node &#124; (d) &#124; Node &#124;'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; 指向节点的指针 &#124; (d) &#124; 节点 &#124;'
- en: '|'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: (c)
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: (c)
- en: '| 5. | Take an implementation of unsorted doubly linked list. Suppose it is
    representated using a head pointer only. Given the representation, which one among
    the following operations can be implemented in O(1) time? i) Insertion at the
    start of the linked list. ii) Insertion at the end of the given working linked
    list. iii) Deletion of the start node of the linked list. iv) Deletion of the
    last node of the current working linked list.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '| 5. | 考虑一个未排序的双向链表的实现。假设它仅使用头指针表示。在给定的表示法下，以下哪种操作可以在O(1)时间内实现？i）在链表的开头插入。ii）在给定的工作链表的末尾插入。iii）删除链表的起始节点。iv）删除当前工作链表的最后一个节点。'
- en: '&#124; (a) &#124; I and II &#124; (b) &#124; I and III &#124;'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; I 和 II &#124; (b) &#124; I 和 III &#124;'
- en: '&#124; (c) &#124; I,II and III &#124; (d) &#124; I,II,III and IV &#124;'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; I，II 和 III &#124; (d) &#124; I，II，III 和 IV &#124;'
- en: '|'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: (b)
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: (b)
- en: '| 6. | In a circular linked list, insertion of node requires modification of?'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '| 6. | 在循环链表中，插入节点需要修改什么？'
- en: '&#124; (a) &#124; One pointer &#124; (b) &#124; Two pointer &#124;'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; 一个指针 &#124; (b) &#124; 两个指针 &#124;'
- en: '&#124; (c) &#124; three pointer &#124; (d) &#124; None &#124;'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; 三指针 &#124; (d) &#124; 无 &#124;'
- en: '|'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: (b)
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: (b)
- en: '| 7. | A variant of the linked list where no node contains NULL pointer is?'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '| 7. | 一种链表的变体，其中没有节点包含 NULL 指针是？'
- en: '&#124; (a) &#124; Singly linked list &#124; (b) &#124; Doubly linked list &#124;'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; 单向链表 &#124; (b) &#124; 双向链表 &#124;'
- en: '&#124; (c) &#124; Circular linked list &#124; (d) &#124; None &#124;'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; 循环链表 &#124; (d) &#124; 无 &#124;'
- en: '|'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: (c)
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: (c)
- en: '| 8. | Which of the following statements about data structure linked list is/
    are TRUE?'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '| 8. | 关于数据结构链表的以下哪些描述是正确的？'
- en: '&#124; (a) &#124; Addition and deletion in the current working linked list
    require moderation of the existing pointers. &#124;'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; 在当前工作链表中进行添加和删除需要修改现有指针。 &#124;'
- en: '&#124; (b) &#124; The linked list pointers do not provide a well ordered way
    to search an item in the linked list. &#124;'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (b) &#124; 链表指针不提供一种良好的有序方式来在链表中搜索项目。 &#124;'
- en: '&#124; (c) &#124; The pointers in the linked list always maintained in the
    non-decreasing order. &#124;'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; 链表中的指针始终保持非递减顺序。 &#124;'
- en: '&#124; (d) &#124; The linked list data structure provides a systematic way
    to find kth element in the list &#124;'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (d) &#124; 链表数据结构提供了一种系统化的方法来在列表中找到第 k 个元素 &#124;'
- en: '|'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: (b)
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: (b)
- en: '| 9. | Linked lists are not suitable for the implementation of?'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '| 9. | 链表不适合实现哪些内容？'
- en: '&#124; (a) &#124; Insertion sort &#124; (b) &#124; Radix sort &#124;'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; 插入排序 &#124; (b) &#124; 基数排序 &#124;'
- en: '&#124; (c) &#124; Polynomial manipulation &#124; (d) &#124; Binary search &#124;'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; 多项式操作 &#124; (d) &#124; 二分搜索 &#124;'
- en: '|'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: (d)
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: (d)
- en: '| 10. | To insert an element at the second location in the linked list, the
    asymptotic time complexity would be?'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '| 10. | 在链表中的第二个位置插入一个元素，渐进时间复杂度将是多少？'
- en: '&#124; (a) &#124; O(1) &#124; (b) &#124; O(n) &#124;'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; O(1) &#124; (b) &#124; O(n) &#124;'
- en: '&#124; (c) &#124; O(n²) &#124; (d) &#124; None &#124;'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; O(n²) &#124; (d) &#124; 无 &#124;'
- en: '|'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '(a)(a) (a) (a) (a) (a) (a)(a) (a) (a) (a) (a) (a) (a) (a) (a) (a)(a) (a) (a)
    (a) (a) (a) (a)(a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a)(a)
    (a) (a) (a) (a) (a)(a) (a) (a) (a) (a) (a) (a) (a) (a)(a) (a) (a) (a) (a) (a)
    (a) (a) (a) (a)(a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a)(a)
    (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a)(a) (a) (a) (a) (a) (a) (a) (a) (a)
    (a) (a) (a)(a) (a) (a) (a) (a) (a) (a) (a) (a) (a)(a) (a) (a) (a) (a) (a) (a)
    (a) (a) (a) (a) (a)(a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a)(a) (a) (a) (a)
    (a)(a) (a) (a) (a) (a) (a) (a) (a) (a)(a) (a) (a) (a) (a) (a) (a) (a) (a) (a)(a)
    (a) (a) (a) (a) (a) (a) (a) (a) (a) (a)(a) (a) (a) (a) (a) (a) (a) (a) (a) (a)
    (a) (a)(a) (a) (a) (a) (a) (a) (a)(a) (a) (a) (a) (a)(a) (a) (a) (a) (a) (a) (a)
    (a) (a) (a) (a) (a) (a) (a)(a) (a) (a) (a) (a)(a) (a) (a) (a) (a) (a) (a) (a)(a)
    (a) (a) (a) (a)(a) (a) (a) (a) (a)(a) (a) (a) (a) (a) (a) (a) (a) (a)(a) (a) (a)
    (a) (a) (a) (a) (a) (a) (a) (a) (a) (a)(a) (a) (a) (a) (a) (a) (a) (a) (a)(a)
    (a) (a) (a) (a) (a) (a) (a) (a)(a) (a) (a) (a)(a) (a) (a) (a) (a) (a) (a) (a)
    (a) (a)(a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a)(a) (a) (a)
    (a) (a) (a) (a) (a) (a) (a) (a) (a) (a)(a) (a) (a) (a) (a) (a) (a) (a) (a) (a)(a)
    (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a)(a) (a) (a) (a)(a)
    (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a)(a) (a) (a) (a)
    (a) (a) (a)(a) (a) (a) (a) (a) (a) (a) (a) (a) (a)(a) (a) (a) (a)(a) (a) (a) (a)
    (a) (a) (a) (a) (a) (a) (a) (a)(a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a)
    (a) (a) (a)(a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a)(a) (a)
    (a) (a) (a) (a) (a) (a)(a) (a) (a) (a) (a)(a) (a) (a) (a) (a) (a) (a) (a) (a)
    (a) (a) (a) (a) (a) (a) MODULE IIIStacks and Queues  CHAPTER 3 Stacks and Queues3.1
    Definition and Concepts It may be possible that there is a need for a data structure
    which takes operation on only one end. i.e., beginning or end of the list. In
    linked list and arrays, we can perform operations at any place of the list. Stack
    and Queue, are data structures which fulfill the requirements to perform operation
    on only at one end.3.2 Stack A stack is a special purpose data structure, containing
    a list, where data are arranged in order, in which all operations such as insertions
    and deletions are carried out in only one place, called the TOP of the stack. Given
    a stack, S = …., then we say that is the bottom most element and element is on
    top of element 1 < i ≤ ![](image-h9f0xe1c.jpg) A stack is a collection of similar
    data, which is having some order, where all the operations like insertion and
    deletion, carried out, only at one end. Stack is also a linear data structure,
    the insertion and deletion operations in case of stack is specially termed as
    PUSH and POP respectively, and the position of the stack where such operations
    are carried out, is known as the TOP of the stack. An element in a stack is commonly
    termed as an ITEM. The SIZE of a stack defines the maximum number of elements
    that a stack can hold at once (figure 3.1). Figure 3.1 Schematic diagram of a
    stack In stack, the element, which is inserted the last, is the first to be removed
    from the stack. For this reason, stacks are also known as Last In First Out(LIFO)
    lists. One natural example of stacks which arises in Computer Programming is the
    processing of subroutine calls and their returns. Suppose we have a main procedure
    and 3 subroutines as follows: ![](image-25h4gc8z.jpg)Figure 3.2 Sequence of subroutines
    being called The MAIN program calls subroutine X. On completion of X, execution
    of MAIN will resume at location b. The address b is passed to X, which saves it
    in some location for later procession. X then invokes Y, which in turn calls Z.
    In every case the calling procedure passes the return address to the called procedure.
    If we examine the memory which Z is computing there will be an implicit stack
    which looks like (a, b, c, d). ![](image-ushopf3v.jpg) The first entry, a, is
    the address in the operating system where MAIN returns the output. This list is
    operating as a stack, since the returns will be made in the reverse order of the
    calls. Thus, d is removed before c, c before b and b before a. Equivalently, this
    means that Z must finish processing before Y, Y before X, and X before MAIN. With
    respect to an object stack, there are several necessary operations: CREATE Which
    creates STACK, which is empty. ADD Which inserts the element i onto the stack
    STACK and returns a new value for the stack STACK. DELETE Which removes the top
    element of stack STACK and returns the updated stack STACK. TOP Which returns
    the topmost element of stack STACK. Which returns true if STACK is empty else
    false.3.3 Representation of a Stack in Memory There are several ways to represent
    a stack in a memory. Mainly there are two ways: using one-dimensional array and
    a singly linked list.3.3.1 Representation of a Stack using an Array Initially,
    we have to get a block in memory, of the desired size to hold the full volume
    of the available stack. Then, beginning from the first location of the memory
    block, items of the stack can be stored in sequential fashion. ![](image-iq15zrj4.jpg)Figure
    3.3 Array representation of Stack In the above figure 3.3 ITEMi denote the i-th
    item in the stack, l and u denote the index range of array in use, usually values
    of these are 1 and SIZE respectively. TOP is a pointer to point the position of
    array up to which it is filled with the items of stack. With this representation,
    following 2 status can be stated: ![](image-t0xytnq8.jpg)3.3.2 Linked List Representation
    of Stacks The representation of a stack, using an array, is simple and suitable,
    but it restricts to represent a stack with a fixed size. In most of the applications,
    size of the stack may vary during program execution. The solution to the problem
    is to represent a stack using linked list. The structure using a single linked
    list is sufficient to represent any stack. Here, the DATA field is for the ITEM
    and LINK field is to point to the next item. The following figure 3.4 Linked list
    representation of stack the stack implemented using single linked list______________ ![](image-y6t78glk.jpg)Figure
    3.4 Linked list Representation of stack In the linked list representation, first
    node in the list is the current item that is, the item which is at the top of
    the stack and the last node is the node containing bottom-most node. Thus, PUSH
    operation will add a new node at the front and POP operation will remove a node
    from the front of the list. SIZE of the stack is not important here because this
    representation allows dynamic stacks instead of static stacks as with arrays. In
    the linked list representation of stacks, whether a stack is empty or not, can
    be determined by testing the LINK field of the STACK-HEAD node.3.4 Operations
    on Stacks Basic operations that are required to manipulate a stack are as follows:follows:
    follows: follows: follows: follows: follows: follows: follows: follows: follows:follows:
    follows: follows: follows: follows: follows: follows: follows: follows: follows:
    follows: In a stack, PUSH and POP operations, are represented, using an array
    in the following way: Procedure PUSH (item, STACK, n, top) // insert item in to
    the stack of maximum size n; topis the number of elements currently in STACK //if
    top ≥ n then call STACK_FULLtop ← top + 1STACK (top) ← itemend PUSH Procedure
    POP (Items, STACK, TOP) // deletes the topmost element of the STACK and savesthat
    data in item unless STACK is empty.//if top ≤ 0 then call STACK _EMPTYitem ← STACK
    (top)top ← top -1end POP The following procedures show how PUSH and POP operations
    for a stack are represented using a single linked list. Procedure PUSH (ITEM) //Input
    : ITEM is the data to be inserted in the given stack. Output : A single linked
    list is the output with the data ITEM inserted in the newly added node. Data structure
    : A single linked list data structure whose pointer to the header is represented
    by STACK-HEAD and TOP is the pointer pointing to the first node.// new = GETNODE
    (NODE) new.DATA = ITEM new.LINK = TOP TOP = new STACK_HEAD.LINK = TOP end PUSH ![](image-u9rhevuf.jpg)(Initial
    state) ![](image-zmh1xk2n.jpg)(Linked list or stack after push operation) Procedure
    POP ( ) //Input: A stack with list of data. Output: The removed data is stored
    in ITEM. Data structure: A single linked list structure whose pointer to the header
    to known from STACK_HEAD & TOP is the pointer to the first node. // if TOP = NULL Print
    “Stack is empty” Exit else ptr = TOP.LINK ITEM = TOP.DATA STACK_HEAD.LINK=ptr TOP
    = ptr End if End POP ![](image-ru6dder8.jpg)(Linked list or stack after pop operation)3.5
    Applications of Stack Some of the uses of stack are described as follows:-follows:-
    follows:- follows:-follows:- follows:- follows:- follows:-follows:- follows:-
    follows:- follows:- follows:- follows:- follows:- follows:-follows:- follows:-
    follows:- follows:- follows:- follows:- follows:- follows:- follows:-follows:-
    follows:- follows:- follows:- follows:- follows:- (i) Implementation of recursion ![](image-ryzng6sx.jpg) ![](image-eorjoflf.jpg) (ii)
    Reversal of String using stack The reversing of a string is possible by pushing
    or inserting, each character of the string one by one, in the stack. When the
    whole string is being pushed on the stack we will pop the characters from the
    stack and we will get the reversed string. (iii) Checking validity of an expression
    containing nested parentheses. We can use stack to check the validity of an expression
    which uses nested parentheses. An expression is said to be valid if it satisfies
    these two conditions:conditions: conditions: conditions: conditions: conditions:
    conditions: conditions: conditions: conditions: conditions: conditions: conditions:
    conditions: conditions: conditions: conditions: conditions: conditions: conditions:conditions:
    conditions: conditions: conditions: conditions: conditions: conditions: conditions:
    conditions: conditions: conditions: conditions: conditions: conditions: conditions:
    conditions: conditions: For example:example:example:example:example: The procedure
    is Take a Boolean variable valid which will be true if the expression is valid
    and will be false if the expression is invalid. Initially let it be true.true.
    true. true. true. true. true. true. true. true.true. true. true. true. true. true.
    true. true. true. true. true. true. true. true.true. true. true. true. true. true. 
    If the stack is empty  Valid = false Else  POP an element from stack  If popped
    parenthesis doesn’t match the  parenthesis being scanned  Valid = falsefalse false
    false false false false false false false false false false false false false (iv)
    Polish Notation with arithmetic expression An arithmetic expression consists of
    operands and operators. Operands are variable or constants and operators are of
    various types like arithmetic, unary and binary operators [for e.g.’ – (unary),
    +(addition), -(subtraction), * (multiplication), /(division), and so on.], relational
    operators (such as AND, OR, NOT, XOR, and so on.). In addition to these, parenthesis’
    like ‘(‘and ‘)’ are also used. A simple arithmetic expression is cited below: X
    + Y * Z / A – B ^ C * D The problem to evaluate such expression is the order of
    evaluation. These are two ways to fix it: First, we can assign to each operator
    a precedence and associativity is given in the following table. and associativity
    of ![](image-zmz2fj5h.jpg) Using the above rules of precedence and associativity
    of operators, we can evaluate the following expression as stated below: X + Y
    * Z /A – B ^ C * D ![](image-j5qcrhkq.jpg) The above rules for precedence of associativity
    vary from one programming language to another. Another way of fixing the order
    of evaluation is parenthesize the expression fully, this allows one to override
    the rule of precedence and associativity. For example., ![](image-1dz1yz33.jpg) Polish
    Notation There are three notations to represent an arithmetic expression, viz,
    infix, prefix, and postfix (or suffix). Infix:<operand><operator><operand></operand></operator></operand> This
    is called infix because the operators come in between the operands. Eg: A + C
    * E – Prefix :<operator><operand><operand></operand></operand></operator> Here,
    operators come before the operands. For example: * , etc. This notation was introduced
    by polish mathematician Jan Lukasiewicz & hence also termed as polish Postfix
    :<operand><operand><operator></operator></operand></operand> Here operator is
    suffixed by operands. For example: AB+, CD-, EF*, GH/, etc. This notation is reverse
    to the polish notation hence it is also termed as Reverse Polish For example:- Infix
    (E-(A/C))) Prefix * (-E/AC))  = ((+A-^BCD) * (-E/AC))  = * + A-^BCD – E/AC Postfix
    : ((A+((B^C)-D)) * (E-(A/C)))  = ((A+(BC^D-)) * (EAC/-))  = ((ABC^D -+) * (EAC/-)) 
    = ABC^D - + EAC/- * Converting Infix expression into postfix expression Let us
    take an arithmetic expression: ![](image-9npk7rps.jpg) Here we can see that the
    expression inside the parenthesis is evaluated first and after that evaluation
    is on the basis of operation precedence. We can see, each time we have to know
    the information of parenthesis and precedence of operators for evaluating expression
    and every time we are traversing to different place in expression for evaluation.
    So now, we have a need of the process of evaluation where parenthesis should not
    come and evaluation should be based on scanning the expression from left to right
    and the operator which is coming first should be evaluated with its operands. In
    arithmetic expression, where operator will be before or after operands, known
    as polish notation. In polish notation, we don’t have a need of any parenthesis
    and by scanning from left to right, we can evaluate the expression one by one.
    There is no need of traversal in expression at different places for evaluation. So,
    computer takes the input in infix form and converts them into postfix form then
    it evaluates expression efficiently. Before converting the infix expression into
    postfix expression, we have to have some assumptions. Here, we are scanning the
    input expression from left-to-right and operators involved are only ‘^’ (exponentiation),
    ‘+’, ‘-’, ‘*’, and ‘/’. We need one stack for temporary storage of operators.
    And the end of the input expression is identified by adding a unique symbol, let
    it be ‘#’, at the end of the input expression. Let us take an array INFIX, which
    stores the infix expression and an array POSTFIX, which stores the postfix expression
    in postfix form. The steps that are involved to convert the infix expression into
    postfix expression are the following: Step Add the unique symbol ‘#’ at the end
    of array INFIX and into stack. Step Scan symbols of array INFIX, one by one from
    left to right. Step If symbol is left parenthesis ‘(‘then add it to the stack. Step If
    symbol is an operand, then add it to array postfix. Step Step Step If symbol is
    ‘#’ then pop all the symbols from stack and add them to array POSTFIX except ‘#’. Step The
    same process can be repeated until ‘#’ comes in scanning array INFIX. Let us take
    an infix expression and convert it into postfix: A*(B + C ^ D ) - E^ F * (G /
    H) Initially ‘#’ will be added in stack and at the end of infix expression. So,
    now the infix expression will be: ![](image-l7aa40u4.jpg) So, now the postfix
    expression is as follows: A B C D ^ + * E F ^ G H / * - We can see that the resultant
    postfix expression is parenthesis free and operators are in order of sequence
    of evaluation with operands. Evaluation of postfix expression Evaluation of postfix
    expression also requires stack but here stack contains the operands instead of
    operators. Whenever any operators in scanning, we evaluate with last two elements
    of stack. Initially one unique symbol will be added at the end of arithmetic expression
    for termination of scanning. Here we have no need of information of operator precedence. Let
    us take an array POSTFIX, which has arithmetic expression in postfix form. Following
    are the steps involved to evaluate the postfix expression: Step Add the unique
    symbol ‘#’ at the end of array postfix. Step Scan the symbol of array POSTFIX
    one by one from left to right. Step If symbol is operand then push it into stack. Step If
    the scanned symbol is operator then pop last two elements of stack and evaluate
    it as _____ [top-1] operator [top] and push it to stack. Step Continue the same
    steps until ‘#’ comes in scanning. Step Pop the element of stack which will be
    value of evaluation of postfix arithmetic expression. Let us take a postfix expression
    and evaluate it: 4, 5, 4, 2, ^, +, *, 2, 2, ^, 9, 3, /, *, - ![](image-hkfb2e8b.jpg) ![](image-p277xri7.jpg) So,
    after evaluation of the postfix expression, its value is 72\.3.6 Queues Queue
    is a simple but very powerful data structure to solve numerous computer applications. Queue
    is an ordered list of data elements in which we can insert elements only at one
    ending point of the list, known as the REAR and delete elements only at the other
    end, called the FRONT of the queue. Examples:  Queuing in front of a counter. Traffic
    control at a turning point. Process synchronization in multi-user environment. Resource
    sharing in a computer centre. Queue is a linear data structure like arrays, stacks
    & linked lists, where ordering of the elements are in linear fashion. The only
    difference between stack and queue is that in case of stack, insertion and deletion
    (PUSH & POP) operations are at one end (TOP) only, but in case of a queue, insertion
    (called ENQUEUE) and deletion (called DEQUEUE) operations take place at two ends
    called REAR and FRONT of the queue respectively. Following figure 3.5 represents
    a model of queue structure. ![](image-5taf31lp.jpg)Figure 3.5 Model of a queue Elements
    in a queue are termed as ITEM, the number of elements that a queue can accommodate
    is termed as LENGTH. The data in queue is processed in the same order as it was
    entered, that is why, queue is also alternatively termed as First – In – First
    – Out queue _arr ![](image-o5epjlxn.jpg)(a) Empty Queue ![](image-fs9wsoji.jpg)(b)
    Adding an element in queue ![](image-k7jn7ol0.jpg)(c) Adding an element in queue ![](image-gb8kysex.jpg)(d)Adding
    an element in queue ![](image-cit7fmzt.jpg)(e) Deleting an element in queue ![](image-4bmsfgw4.jpg)(f)
    Adding an element in queue3.6.1 Representation of Queues These are two ways to
    represent a queue in memory:memory: memory: memory:memory: memory: memory: Queue
    is also a collection of same type of elements. So, we can take array for implementing
    the queue. As we want to add an item in queue at the rear end and delete the item
    in the queue at the front, we take 2 variables REAR (keeps the status of last
    added item in queue) and FRONT (keeps the status of first item of queue). Possibility
    of 2 conditions:conditions: conditions: conditions: conditions: conditions: conditions:
    conditions: conditions: conditions: conditions: conditions: conditions: conditions:
    conditions: conditions: conditions: conditions: conditions: conditions: conditions:
    conditions: conditions: conditions: conditions: conditions: conditions: conditions:
    conditions: conditions: conditions:conditions: conditions: conditions: conditions:
    conditions: conditions: conditions: conditions: conditions: conditions: conditions:
    conditions: conditions: conditions: conditions: conditions: conditions: conditions:
    conditions: conditions: conditions: conditions: conditions: conditions: conditions:
    conditions: conditions: conditions: conditions: conditions: conditions: conditions:
    conditions: ![](image-hrki8wey.jpg)Figure 3.6 Array Representation of a Queue Procedure
    ENQUEUE (ITEM) I (REAR=N) then // Queue is full 1\. Print “Queue is full” 2\.
    Exit  1\. If (REAR=0) and (FRONT=0) // Queue is empty 1.FRONT = 1 2.Endif 3.REAR
    = REAR + 1 4\. Q [REAR] = ITEM // Insert the item into the  queue REAR. III Endif IV
    stop. OR Procedure ADDQUEUE (data, Q, num, rear) // insert data into the queue
    represented in Q (1:num) // if rear = num then call QUEUE_FULL rear ← rear + 1 Q
    (rear) ← data end ADDQUEUE Procedure DEQUEUE ( ) 1\. If (FRONT = 0) THEN 1\. Print
    “Queue is empty” 2\. exit 2\. else 1\. ITEM = Q [FRONT] // get the element 2\.
    If (FRONT = REAR) // when queue contains single element 1\. REAR = 0 // the queue
    becomes empty 2\. FRONT = 0 3\. Else 1\. FRONT = FRONT + 1 4\. Endif 3\. Endif 4\.
    Stop OR Procedure DELETEQ (item, Q, front, rear) // delete an element from a queue
    // if front = rear then call QUEUE_EMPTY +1 Q (front) end DELETEQ Linked list
    implementation of queue Queue can also be executed through linked list. The structure
    of a node will be as _________ Struct node { int data; struct node * link; } Add
    operations in queue For adding the element in queue, we can insert the element
    at the end of linked list. Here, FRONT will be pointing to the first node of linked
    list and REAR will be pointing to the last node of linked list. ![](image-b3v77x3t.jpg) tm
    info = add_item; link = NULL; if (front= = NULL) /*Queue empty */ front = tmp; else =
    tmp; rear = tmp; Delete operation in queue For deleting the element of a queue,
    we delete the first node of the linked list. Since queue is a first in first out
    structure and first node of the linked list will be the first element of queue. ![](image-7yc3am60.jpg) if
    (front = = NULL) print (“Queue is empty”); else { tmp = front; printif (“Deleted
    element is  free (tmp); } Here front is pointing to the first element of queue.
    After deleting the element it will point to the next element of queue.3.7 Circular
    Queue In an ordinary queue, when implemented using an array and the REAR pointer
    reaches the end of the queue, insertion will be denied even if room is available
    at the front, one way to remove this is using a circular array. Physically, a
    circular array is the same as ordinary array, say, A [1..N], but logically it
    implies that A[1]comes after A[n]. The following fig 3.7 shows logical and physical
    representations for a circular array. The principle for representation of a circular
    array is as stated below Figure 3.7: ![](image-adgov212.jpg) (a) Circular array
    (Physical) Figure 3.7 Logical and physical representations for a circular array. (b)
    Circular queue (Logical) Both pointers will move in clockwise direction. This
    is controlled by the MOD operation, for e.g., if the concerned pointer is at ‘i’
    then shift to the next location will be i MOD LENGTH +1, 1≤ i ≤ LENGTH (where
    LENGTH is the queue length). Thus, if i = LENGTH (i.e, at the end), the next position
    for the pointer is 1\. Possible Conditions: (1) Circular queue is empty FRONT
    = 0 REAR = 0 (2) Circular queue is full FRONT = (REAR MOD LENGTH) +1 Algorithm
    ENQUEUE (ITEM)(ITEM) (ITEM) (ITEM) (ITEM) (ITEM) (ITEM) (ITEM) (ITEM) (ITEM) (ITEM)(ITEM)
    (ITEM) (ITEM) (ITEM) (ITEM) (ITEM) (ITEM) (ITEM) (ITEM) (ITEM) (ITEM) (ITEM) (ITEM)(ITEM)
    (ITEM) (ITEM) (ITEM) (ITEM) (ITEM) (ITEM) (ITEM) (ITEM) (ITEM) (ITEM) (ITEM) (ITEM)
    (ITEM) (ITEM) (ITEM) Steps: (FRONT=0) then // when queue is empty (i) FRONT =
    1 (ii)REAR = 1 (iii)CQ[FRONT]=ITEM 2\. Else // when queue not empty (i) next =
    (REAR MOD LENGTH) +1 (ii) IF (next ≠FRONT) then  // Queue not full (a) REAR =
    next (b) CQ[REAR] = ITEM (iii) Else (a) Print “Queue is full” (iv) Endif 3\. Endif 4\.
    Stop Algorithm DEQUEUE ( )) ) ) ) ) ) ) ) ) ) ) )) ) ) ) ) ) ) ) ) ) )) ) ) )
    ) ) ) ) Steps: 1\. If (FRONT = 0) then (i) Print “queue empty” (ii) Exit 2\. Else (i)
    ITEM = CQ [FRONT] (ii) If (FRONT = REAR) then // Queue  contains single element. (a)
    FRONT = 0 (b) REAR = 0 (iii) Else (a) FRONT = (FRONT MOD LENGTH) +1 (iv) Endif 3\.
    Endif 4\. Stop3.8 Dequeue Queue is an ordered list of data elements, in which
    we can add the element only at one end called the REAR of queue and delete the
    element only at the other end, called the FRONT of the queue. But in dequeue,
    also called the double ended queue, here we can add or delete the element from
    both ends. Dequeue can be of two types:types: types:types: types: In input restricted
    dequeue, element can be added at only one end but we can delete the element from
    both sides. In output restricted dequeue, element can be added from both sides
    but deletion is allowed only at one end. Structure of dequeue is as follows: ![](image-eqmpvr7h.jpg) Array
    Implementation of Dequeue Here we are taking array for implementing the dequeue.
    Similarly, as queue it has also 2 operations:operations:operations: We maintain
    2 pointers LEFT and RIGHT which indicate the left and right position of the dequeue. ![](image-uaitbw5w.jpg)3.9
    Priority Queue In priority queue every element of queue has some priority and
    based on that priority it will be processed. So, the element of more priority
    will be processed before the element which has less priority. Suppose 2 elements
    have same priority then in this case FIFO rule will follow, means the element
    which is at the first place in the queue will be processed first. In computer
    implementation, priority queue is used in the CPU scheduling algorithm, in which
    CPU has need to process those processes first which have more priority. In priority
    queue, an element can be inserted or deleted not only at the ends but at any position
    on the queue. ![](image-wzeft51f.jpg) Here, an element X of priority may be deleted
    before an element which is at FRONT, similarly, insertion of an element is based
    on its priority, that is, instead of adding it after the REAR it may be inserted
    at an intermediate position dictated by its priority value.  Priority queue doesn’t
    strictly follow first-in -first-out principle which is the basic principle of
    a queue.  Two operations going on: Insertion and Deletion. There are various ways
    of implementing the structure of a priority queue. These are as follows:follows:
    follows: follows: follows: follows:follows: follows:follows: follows: follows:
    follows: follows: follows:follows: follows: follows: Linked –list representation
    of a priority queue This representation assumes the node structure as the following: ![](image-9eik81fp.jpg) LLINK
    and RLINK are two usual link fields DATA is to store the actual content and PRIORITY
    is to store the priority value of the item. FRONT and REAR are 2 pointers pointing
    the first and last node in the queue, respectively. Here all the nodes are in
    sorted order according to the priority values of the items in the nodes. Following
    is an instance of priority queue: ![](image-hzcf7htk.jpg)3.10 Application of Queues Numerous
    applications of queue structure are known in Computer Science. Applications are
    as follows:  Simulation CPU scheduling in multiprogramming environment Round Robin
    Algorithm3.11 Program 1\. Program of array implementation of stack operations #include<stdio.h></stdio.h>#include #define
    SIZE 10 void push(int);void pop();void display(); int stack[SIZE], top = -1; void
    main(){ int value, option; clrscr(); while(1){  printf(“\n\n***** MENU *****”); 
    printf(“\n1\. Push\n\n2\. Pop\n\n3\. Display\n\n4\. Exit”);  printf(“\nEnter your
    choice: “);  scanf(“%d”,&option);  switch(option){  case 1: printf(“Enter the
    value that has to be inserted: “);   scanf(“%d”,&value);   push(value);   break; 
    case 2: pop();   break;  case 3: display();   break;  case 4: exit(0);  default:
    printf(“\nWrong selection!!! Try again!!!”);  } } } void push(int value){ if(top
    == SIZE-1)  printf(“\nStack is Full!!! Insertion is not possible!!!”); else{ 
    top++;  stack[top] = value;  printf(“\nInsertion success!!!”); } } void pop(){ if(top
    == -1)  printf(“\nStack is Empty!!! Deletion is not possible!!!”); else{  printf(“\nDeleted
    : %d”, stack[top]);  top--; } } void display(){ if(top == -1)  printf(“\nStack
    is Empty!!!”); else{  int i;  printf(“\nStack elements are:\n”);  for(i=top; i>=0;
    i--)   printf(“%d\n”,stack[i]); } } 2\. Program of linked list implementation
    of stack operations #include<stdio.h></stdio.h>#include struct Node{ int data; struct
    Node *nextptr; }*top = NULL; void pushEle(int);void popEle();void displayValue(); void
    main() { int urChoice, value; printf(“\nStack using Linked List”); while(1){ 
    printf(“\n****** MENU ******”);  printf(“\n1.Push”);  printf(“\n2.Pop”);  printf(“\n3.Display”); 
    printf(“\n4.Exit”);  printf(“\nEnter your urChoice: “);  scanf(“%d”,&urChoice); 
    switch(urChoice){  case 1: printf(“Enter the value that has to be inserted: “);   scanf(“%d”,
    &value);    pushEle(value);    break;  case 2: popEle(); break;  case 3: displayValue();
    break;  case 4: exit(0);  default: printf(“\nWrong selection!!! Please try again!!!\n”); 
    } } } void pushEle(int value) { struct Node *newNode; newNode = (struct Node*)malloc(sizeof(struct Node)); newNode->data
    = value; if(top == NULL)  newNode->nextptr = NULL; else  newNode->nextptr = top; top
    = newNode; printf(“\nInsertion is Success!!!\n”); } void popEle() { if(top ==
    NULL)  printf(“\nStack is Empty!!!\n”); else{  struct Node *temp = top;  printf(“\nDeleted
    element: %d”, temp->data);  top = temp->nextptr;  free(temp); } } void displayValue() { if(top
    == NULL)  printf(“\nStack is Empty!!!\n”); else{  struct Node *temp = top;  while(temp->nextptr
    != NULL){   printf(“%d--->”,temp->data);  temp = temp -> nextptr;  }   printf(“%d--->NULL”,temp->data); } } 3\.
    Program of reversing a string using stack #include<stdio.h></stdio.h>#include #define
    MAXSIZE 20 int elemnt;int top = -1;char stack_array[MAXSIZE];void pushEle(char
    elemnt);int checkIsEmpty();int checkIsFull();char popEle(); void main(){ char
    stack_str[30]; int count; printf(“Enter A String:\t”); scanf(“%s”, stack_str); for(count
    = 0; count < strlen(stack_str); count++) { pushEle(stack_str[count]); } for(count
    = 0; count < strlen(stack_str); count++) { stack_str[count] = popEle(); } printf(“%s”,
    stack_str); printf(“\n”); } void pushEle(char elemnt) { if(checkIsFull()) { printf(“\nStack
    Overflow\n”); } else { top = top + 1; stack_array[top] = elemnt; } } char popEle() { if(checkIsEmpty()) { printf(“\nStack
    Underflow\n”); return 1; } else { elemnt = stack_array[top]; top = top - 1; return
    elemnt; } } int checkIsEmpty() { if(top == -1) return 1; else return 0; } int
    checkIsFull() { if(top == MAXSIZE-1) return 1; else return 0; } 4\. Program which
    converts an infix expression to a postfix expression and evaluate the postfix
    expression #define SIZE 50#include#include<stdio.h></stdio.h> char stack[SIZE]; int
    topofstack = -1; /* Global declarations */ /* Function to remove spaces from given
    string */ void RemoveSpaces(char* source) { char* i = source; char* j = source; while(*j
    != 0) { *i = *j++; if(*i != ‘ ‘)  i++; } *i = 0; } /* Function for PUSH operation
    */ void push(char ele) { stack[++topofstack] = ele; } /* Function for POP operation
    */char pop() { return (stack[topofstack--]); } /* Function for precedence */ int
    precedence(char ele) { switch (ele)  { case ‘(‘: return 1; case ‘+’: case ‘-’: return
    2; case ‘*’: case ‘/’: return 3; case ‘#’: return 0; } } void infix_2_postfix(char
    *infix, char *postfix) { char ch, ele; int i = 0, k = 0; RemoveSpaces(infix); push(‘#’); while
    ((ch = infix[i++]) != ‘\n’) { if (ch == ‘(‘) push(ch); else if (isalnum(ch)) postfix[k++]
    = ch; else if (ch == ‘)’) { while (stack[topofstack] != ‘(‘) postfix[k++] = pop(); ele
    = pop(); /* Remove ( */ } else { /* Operator */ while (precedence(stack[topofstack]) >=
    precedence(ch)) postfix[k++] = pop(); push(ch); } } while (stack[topofstack] !=
    ‘#’) /* Pop from stack till empty */ postfix[k++] = pop(); postfix[k] = 0; /*
    Make postfix as valid string */ } /* * Function to evaluate a postfix expression */ int
    eval_postfix(char *postfix) { char ch; int i = 0, op1, op2; while((ch = postfix[i++])
    != 0) { if(isdigit(ch)) push(ch-’0’); /* Push the operand */ else { /* Operator,pop
    two operands */ op2 = pop(); op1 = pop(); switch(ch) { case ‘+’ : push(op1+op2); break; case
    ‘-’ : push(op1-op2); break; case ‘*’ : push(op1*op2); break; case ‘/’ : push(op1/op2); break; } } } return
    stack[topofstack]; } void main() { /* Main Program */ char infx[50], pofx[50]; printf(“\nInput
    the infix expression: “); fgets(infx, 50, stdin); infix_2_postfix(infx, pofx); printf(“\nGiven
    Infix Expression: %sPostfix Expression: %stack”, infx, pofx); topofstack = -1; printf(“\nResult
    of evaluation of postfix expression : %d”, eval_postfix(pofx)); } 5\. Program
    of queue operations using an array #include<stdio.h></stdio.h>#include#define
    SIZE 10 void enQueue(int); void deQueue(); void display(); int queue[SIZE], front
    = -1, rear = -1; void main() { int value, option; clrscr(); while(1){ printf(“\n\n*****
    MENU *****”); printf(“\n1.Insertion”); printf(“\n2.Deletion”); printf(“\n3\. Display”); printf(“\n4\.
    Exit”); printf(“\nEnter your choice: “); scanf(“%d”,&option); switch(option){ case
    1: printf(“Enter the value that has to be inserted: “);  scanf(“%d”,&value); 
    enQueue(value);  break; case 2: deQueue();  break; case 3: display();  break; case
    4: exit(0); default: printf(“\nWrong selection!!! Try again!!!”);  } } } void
    enQueue(int value){ if(rear == SIZE-1)  printf(“\nQueue is Full!!! Insertion is
    not possible!!!”); else{ if(front == -1) front = 0; rear++; queue[rear] = value; printf(“\nInsertion
    success!!!”); } } void deQueue(){ if(front == rear)  printf(“\nQueue is Empty!!!
    Deletion is not possible!!!”); else{ printf(“\nDeleted : %d”, queue[front]); front++; if(front
    == rear) front = rear = -1; } } void display(){ if(rear == -1)  printf(“\nQueue
    is Empty!!!”); else{  int i;  printf(“\nQueue elements are:\n”);  for(i=front;
    i<=rear; i++)  printf(“%d\t”,queue[i]); } } 6\. Program of linked list implementation
    of a queue #include<stdio.h></stdio.h>#include struct Node { int data; struct
    Node *nextptr; }*front = NULL,*rearptr = NULL; void insertEle(int);void deleteEle();void
    displayEle(); void main() { int option, value; clrscr(); printf(“\nQueue Implementation
    using Linked List \n”); while(1){  printf(“\n****** MENU ******”);  printf(“\n1\.
    Insert\n\n2\. Delete\n\n3\. Display\n\n4\. Exit\n”);  printf(“Enter your choice:
    “);  scanf(“%d”,&option);  switch(option){ case 1: printf(“Enter the value that
    has to be inserted: “);  scanf(“%d”, &value);  insertEle(value);  break; case
    2: deleteEle(); break; case 3: displayEle(); break; case 4: exit(0); default:
    printf(“\nWrong selection!!! Please try again!!!\n”);  } } } void insertEle(int
    value) { struct Node *newNode; newNode = (struct Node*)malloc(sizeof(struct Node)); newNode->data
    = value; newNode -> nextptr = NULL; if(front == NULL)  front = rearptr = newNode; else{ 
    rearptr -> nextptr = newNode;  rearptr = newNode; } printf(“\nInsertion is Success!!!\n”); } void
    deleteEle() { if(front == NULL)  printf(“\nQueue is Empty!!!\n”); else{  struct
    Node *temp = front;  front = front -> nextptr;  printf(“\nDeleted element: %d\n”,
    temp->data);  free(temp); } } void displayEle() { if(front == NULL)  printf(“\nQueue
    is Empty!!!\n”); else{  struct Node *temp = front;  while(temp->nextptr != NULL){  printf(“%d--->”,temp->data); temp
    = temp -> nextptr;  }  printf(“%d--->NULL\n”,temp->data); } } 7\. Program of circular
    queue using array #include<stdio.h></stdio.h>#include<stdlib.h></stdlib.h> struct
    node { int info; struct node *ptr; }*front,*rear,*temp,*front1; int frontelement();void
    enq(int data);void deq();void empty();void display();void create();void queuesize(); int
    count = 0; void main() { int no, ch, e; printf(“\n 1 - Enque”); printf(“\n 2 -
    Deque”); printf(“\n 3 - Display Front element”); printf(“\n 4 - Empty”); printf(“\n
    5 - Exit”); printf(“\n 6 - Display”); printf(“\n 7 - Queue size”); create(); while
    (1) {  printf(“\n Enter choice : “);  scanf(“%d”, &ch);  switch (ch)  {  case
    1:  printf(“Enter data : “);  scanf(“%d”, &no);  enq(no);  break;  case 2:  deq(); 
    break;  case 3:  e = frontelement();  if (e != 0)   printf(“Front element : %d”,
    e);  else   printf(“\n No front element in Queue as queue is empty”);  break; 
    case 4:  empty();  break;  case 5:  exit(0);  case 6:  display();  break;  case
    7:  queuesize();  break;  default:  printf(“Wrong choice, Please enter correct choice
    “);  break;  } } } /* Create an empty queue */ void create() { front = rear =
    NULL; } /* Returns queue size */ void queuesize() {  printf(“\n Queue size : %d”,
    count); } /* Enqueing the queue */ void enq(int data) { if (rear == NULL) {  rear
    = (struct node *)malloc(1*sizeof(struct node));  rear->ptr = NULL;  rear->info
    = data;  front = rear; } else {  temp=(struct node *)malloc(1*sizeof(struct node)); 
    rear->ptr = temp;  temp->info = data;  temp->ptr = NULL;  rear = temp; } count++; } /*
    Displaying the queue elements */ void display() { front1 = front; if ((front1
    == NULL) && (rear == NULL)) {  printf(“Queue is empty”);  return; } while (front1
    != rear) {  printf(“%d “, front1->info);  front1 = front1->ptr; } if (front1 ==
    rear)  printf(“%d”, front1->info); } /* Dequeing the queue */ void deq(){ front1
    = front; if (front1 == NULL) {  printf(“\n Error: Trying to display elements from
    empty queue”);  return; } else  if (front1->ptr != NULL)  { front1 = front1->ptr; printf(“\n
    Dequed value : %d”, front- >info);  free(front); front = front1;  }  else  { printf(“\n
    Dequed value : %d”, front- >info);  free(front); front = NULL; rear = NULL;  } 
    count--; } /* Returns the front element of queue */ int frontelement() { if ((front
    != NULL) && (rear != NULL))  return(front->info); else  return 0; } /* Display
    if queue is empty or not */ void empty() { if ((front == NULL) && (rear == NULL)) 
    printf(“\n Queue empty”); else  printf(“Queue not empty”); } 8\. Program of queue
    using circular linked list #include<stdio.h></stdio.h>#include struct node{ int
    data; struct node *nextptr; }*frontptr = NULL,*rearptr = NULL; void insert(int); void
    delete(); void display(); void main() { int ch, val; clrscr(); printf(“\nLinked
    list implementation of Queue\n”); while(1){  printf(“\n****** MENU ******”); 
    printf(“\n1\. Insert”);  printf(“\n2\. Delete”);  printf(“\n3\. Display”;  printf(“\n4\.
    Exit\n”);  printf(“Enter your ch: “);  scanf(“%d”,&ch);  switch(ch){  case 1:
    printf(“Enter the val to be insert: “);  scanf(“%d”, &val);  insert(val);  break; 
    case 2: delete(); break;  case 3: display(); break;  case 4: exit(0);  default:
    printf(“\nWrong selection!!! Please try again!!!\n”);  } } } void insert(int val) { struct
    node *newNode; newNode = (struct node*)malloc(sizeof(struct node)); newNode->data
    = val; newNode -> nextptr = NULL; if(frontptr == NULL)  frontptr = rearptr = newNode; else{ 
    rearptr -> nextptr = newNode;  rearptr = newNode; } printf(“\nInsertion is Success!!!\n”); } void
    delete() { if(frontptr == NULL)  printf(“\nQueue is Empty!!!\n”); else{  struct
    node *temp = frontptr;  frontptr = frontptr -> nextptr;  printf(“\nDeleted element:
    %d\n”, temp->data);  free(temp); } } void display() { if(frontptr == NULL)  printf(“\nQueue
    is Empty!!!\n”); else{ struct node *temp = frontptr; while(temp->nextptr != NULL){ 
    printf(“%d--->”,temp->data);  temp = temp -> nextptr;  }  printf(“%d--->NULL\n”,temp->data); } } 9\.
    Program of priority queue using linked list #include<stdio.h></stdio.h>#include<stdlib.h></stdlib.h> struct
    node {  int value, prr;  struct node *next; }*start; //start is declared void
    push(int, int); void pop(); void pop(); {  struct node *tempory;  tempory = start; 
    printf(“\nPriority Queue: “);  while(tempory!=NULL)  {  printf(“%d,%d “,tempory->value,
    tempory- >prr);  tempory=tempory->next;  } printf(“\n”); } void push(int ele,int
    pri) {  struct node *tempory, *t;  tempory = (struct node *)malloc(sizeof(struct node)); 
    tempory->value=ele;  tempory->prr=pri;  tempory->next=NULL;  if(start==NULL) start
    = tempory;  else if(start->prr>pri)  {  tempory->next=start;  start=tempory; 
    }  else  {  t=start;  while(t->next!=NULL && (t->next)->prr<=pri )   t=t->next;  tempory->next=t->next;  t->next=tempory; 
    } disp(); } void del() //remove elements {  if(start!=NULL)  {  printf(“\n\tRemoved:
    %d”,start->value);  start = start->next;  disp();  }  else  printf(“\nError List
    Empty”); } int main() {  int ch, ele, prr, checker=1; while(checker==1) {  printf(“\n
    In Priority Queue Select:\n\ n1.Insert\n2.Remove\n3.Exit\n”);  scanf(“%d”,&ch); 
    switch(ch){  case 1:  printf(“\nEnter element and its priority: “);  scanf(“%d%d”,&ele,&prr);
    //input from user  push(ele,prr); //Send Element and its priority for insertion 
    break;  case 2:  del();  break;  case 3:  checker=0; //Stops the loop  break; 
    default:  printf(“please choose the correct Choice”); printf(“\nPress 0 to stop
    or press 1 to continue”); scanf(“%d”,&checker); } } return 0; } //end of Main 10\.
    Program of input – output restricted dequeue using an array # include<stdio.h></stdio.h> #
    define MAX 5 int deque_arr[MAX]; int lft = -1; int rht = -1; /*Begin of insert_right*/ void
    insert_right() {  int added_item;  if((lft == 0 && rht == MAX-1) || (lft == rht+1)) 
    { printf(“Queue Overflow\n”);  return;}  if (lft == -1) /* if queue is initially
    empty */  { lft = 0;  rht = 0;}  else  if(rht == MAX-1) /*rht is at last position
    of queue */  rht = 0;  else  rht = rht+1;  printf(“Input the element for adding
    in queue : “);  scanf(“%d”, &added_item);  deque_arr[rht] = added_item ; } /*End
    of insert_right*/ /*Begin of insert_left*/ void insert_left() { added_item;  if((lft
    == 0 && rht == MAX-1) || (lft == rht+1))  { printf(“Queue Overflow \n”);  return;
    }  if (lft == -1)/*If queue is initially empty*/  { lft = 0;  rht = 0; }  else 
    if(lft== 0)  lft=MAX-1;  else  lft=lft-1;  printf(“Input the element for adding
    in queue : “);  scanf(“%d”, &added_item);  deque_arr[lft] = added_item ; } /*End
    of insert_left*/ /*Begin of delete_left*/ void delete_left() { if (lft == -1) 
    { printf(“Queue Underflow\n”);  return ; }  printf(“Element deleted from queue
    is : %d\n”,deque_arr[lft]);  if(lft == rht) /*Queue has only one element */  {
    lft = -1;  rht=-1; }  else  if(lft == MAX-1)   lft = 0;  else   lft = lft+1; } /*End
    of delete_left*/ /*Begin of delete_right*/ void delete_right() {if (lft == -1) 
    {printf(“Queue Underflow\n”);  return ; }  printf(“Element deleted from queue
    is : %d\n”,deque_arr[rht]);  if(lft == rht) /*queue has only one element*/  {
    lft = -1;  rht=-1; }  else  if(rht == 0)   rht=MAX-1;  else   rht=rht-1; } /*End
    of delete_right*/ /*Begin of input_que*/ void display_queue() { int front_pos
    = lft,rear_pos = rht;  if(lft == -1)  { printf(“Queue is empty\n”);  return; } 
    printf(“Queue elements :\n”);  if( front_pos <= rear_pos )  { while(front_pos
    <= rear_pos)  { printf(“%d “,deque_arr[front_pos]);  front_pos++; } }  else  {
    while(front_pos <= MAX-1)  { printf(“%d “,deque_arr[front_pos]);  front_pos++;
    } front_pos = 0;  while(front_pos <= rear_pos)  { printf(“%d “,deque_arr[front_pos]); 
    front_pos++;  }  }  printf(“\n”); } /*End of display_queue*/ /*Begin of input_que*/ void
    input_que() { int choice;  do  { printf(“1.Insert at rht\n”);  printf(“2.Delete
    from lft\n”); printf(“3.Delete from rht\n”);  printf(“4.Display\n”);  printf(“5.Quit\n”); 
    printf(“Enter your choice : “);  scanf(“%d”,&choice);  switch(choice)  { case
    1:  insert_right();  break;  case 2:  delete_left();  break;  case 3:  delete_right(); 
    break;  case 4:  display_queue();  break;  case 5:  break;  default:  printf(“Wrong
    choice\n”);  }  }while(choice!=5); } /*End of input_que*/ /*Begin of output_que*/ void
    output_que() { int choice;  do  { printf(“1.Insert at rht\n”);  printf(“2.Insert
    at lft\n”); printf(“3.Delete from lft\n”);  printf(“4.Display\n”);  printf(“5.Quit\n”); 
    printf(“Enter your choice : “);  scanf(“%d”,&choice);  switch(choice)  {  case
    1:  insert_right();  break;  case 2:  insert_left();  break;  case 3:  delete_left(); 
    break;  case 4:  display_queue();  break;  case 5:  break;  default:  printf(“Wrong
    choice\n”);  }  }while(choice!=5); } /*End of output_que*/ /*Begin of main*/ main() {
    int choice;  printf(“1.Input restricted dequeue\n”);  printf(“2.Output restricted
    dequeue\n”);  printf(“Enter your choice : “);  scanf(“%d”,&choice);  switch(choice) 
    {  case 1 :  input_que();  break;  case 2:  output_que();  break;  default:  printf(“Wrong
    choice\n”); }  } /*End of main*/Exercises Multiple Choice Questions'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '| 1. | Which one among the following is an application of Stack Data Structure?'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '| 1. | 以下哪一项是堆栈数据结构的应用之一？'
- en: '&#124; (a) &#124; Managing function calls &#124;'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; 管理函数调用 &#124;'
- en: '&#124; (b) &#124; The stock span problem &#124;'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (b) &#124; 股票跨度问题 &#124;'
- en: '&#124; (c) &#124; Arithmetic expression evaluation &#124;'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; 算术表达式求值 &#124;'
- en: '&#124; (d) &#124; All of the above &#124;'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (d) &#124; 以上全部 &#124;'
- en: '|'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Ans. (d)
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：(d)
- en: '| 2. | Which among the following is true about the stack, implemented using
    linked list?'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '| 2. | 使用链表实现的堆栈的以下哪项是真实的？'
- en: '&#124; (a) &#124; In push operation, if new nodes are added at the start of
    linked list, then in pop operation, nodes must be deleted from end. &#124;'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; 在推送操作中，如果新节点添加到链表的开头，则在弹出操作中，必须从末尾删除节点。 &#124;'
- en: '&#124; (b) &#124; In push operation, if new nodes are added at the end, then
    in pop operation, nodes must be removed from the beginning. &#124;'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (b) &#124; 在推送操作中，如果新节点添加到末尾，则在弹出操作中，必须从开头删除节点。 &#124;'
- en: '&#124; (c) &#124; Both of the above &#124;'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; 以上两者都是 &#124;'
- en: '&#124; (d) &#124; None of the above &#124;'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (d) &#124; 以上都不是 &#124;'
- en: '|'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Ans. (d)
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：(d)
- en: '| 3. | The following postfix expression with single digit operand is evaluated
    using a stack: 8 2 3 ^ / 2 3 * + 5 1 * -where ^ is the exponentiation operator.
    The top two elements of the stack after the first * is evaluated are as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '| 3. | 使用堆栈计算具有单个数字操作数的后缀表达式：8 2 3 ^ / 2 3 * + 5 1 * - 其中 ^ 是指数运算符。在第一个 * 计算后堆栈的前两个元素如下：'
- en: '&#124; (a) &#124; 6,1 &#124; (b) &#124; 5,7 &#124;'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; 6,1 &#124; (b) &#124; 5,7 &#124;'
- en: '&#124; (c) &#124; 3,2 &#124; (d) &#124; 1,5 &#124;'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; 3,2 &#124; (d) &#124; 1,5 &#124;'
- en: '|'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Ans. (a)
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：(a)
- en: '| 4. | The result evaluating the postfix expression 10 5 + 60 6 / * 8 – is
    as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '| 4. | 计算后缀表达式 10 5 + 60 6 / * 8 – 的结果如下：'
- en: '&#124; (a) &#124; 284 &#124; (b) &#124; 213 &#124;'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; 284 &#124; (b) &#124; 213 &#124;'
- en: '&#124; (c) &#124; 142 &#124; (d) &#124; 71 &#124;'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; 142 &#124; (d) &#124; 71 &#124;'
- en: '|'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Ans. (c)
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：(c)
- en: '| 5. | While inserting the elements 71, 65, 84, 69, 67, 83 in an empty binary
    search tree (BST) in the sequence shown, the element in the lowest level is:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '| 5. | 在显示的顺序中将元素 71、65、84、69、67、83 插入到空二叉搜索树（BST）中时，最低级别的元素是：'
- en: '&#124; (a) &#124; 65 &#124; (b) &#124; 67 &#124;'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; 65 &#124; (b) &#124; 67 &#124;'
- en: '&#124; (c) &#124; 69 &#124; (d) &#124; 83 &#124;'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; 69 &#124; (d) &#124; 83 &#124;'
- en: '|'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Ans. (b)
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：(b)
- en: '| 6. | Which among the given options can be taken as the example of Queue?'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '| 6. | 以下哪项可以作为队列的示例？'
- en: '&#124; (a) &#124; When a resource is being shared among multiple end users.
    &#124;'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; 当资源被多个终端用户共享时。 &#124;'
- en: '&#124; (b) &#124; When data is being transferred asynchronously (data not necessarily
    received at same rate as sent) between two processes. &#124;'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (b) &#124; 在两个进程之间异步传输数据（数据不一定以相同的速率接收和发送）时。 &#124;'
- en: '&#124; (c) &#124; Load Balancing &#124;'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; 负载平衡 &#124;'
- en: '&#124; (d) &#124; All of the above &#124;'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (d) &#124; 以上全部 &#124;'
- en: '|'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Ans. (d)
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：(d)
- en: '| 7. | On which type of data structure, these operations can be performed?
    Push, Pop, Peek'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '| 7. | 在哪种类型的数据结构上，可以执行这些操作？推入（Push）、弹出（Pop）、查看（Peek）'
- en: '&#124; (a) &#124; Queue &#124; (b) &#124; Priority Queue &#124;'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; 队列（Queue） &#124; (b) &#124; 优先队列（Priority Queue） &#124;'
- en: '&#124; (c) &#124; Stack &#124; (d) &#124; Both 1 and 2 &#124;'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; 堆栈（Stack） &#124; (d) &#124; 1 和 2 都是（Both 1 and 2） &#124;'
- en: '|'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Ans. (d)
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 答案为 (d)
- en: '| 8. | To implement a priority queue, how many stacks are needed. Assume a
    situation, where no other data structure like arrays, linked list is available
    to you.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '| 8. | 要实现一个优先队列，需要多少个堆栈。假设情况是，你没有其他数据结构如数组、链表可供使用。'
- en: '&#124; (a) &#124; 1 &#124; (b) &#124; 2 &#124;'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; 1 &#124; (b) &#124; 2 &#124;'
- en: '&#124; (c) &#124; 3 &#124; (d) &#124; 4 &#124;'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; 3 &#124; (d) &#124; 4 &#124;'
- en: '|'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Ans. (b)
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 答案为 (b)
- en: '| 9. | A priority queue can effectively be implemented using which of the given
    data structures? Consider that the number of insert and peek (operation to see
    the current highest priority item) and extraction (remove the highest priority
    item) operations are almost same.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '| 9. | 优先队列可以有效地使用哪些给定的数据结构来实现？考虑到插入、查看（查看当前最高优先级项的操作）和提取（移除最高优先级项的操作）操作的数量几乎相同。'
- en: '&#124; (a) &#124; Array &#124;'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; 数组（Array） &#124;'
- en: '&#124; (b) &#124; Linked List &#124;'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (b) &#124; 链表（Linked List） &#124;'
- en: '&#124; (c) &#124; Heap Data Structures like Binary Heap, Fibonacci Heap &#124;'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; 堆数据结构，如二叉堆、斐波那契堆（Heap Data Structures like Binary Heap, Fibonacci
    Heap） &#124;'
- en: '&#124; (d) &#124; None of the above &#124;'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (d) &#124; 以上都不是 &#124;'
- en: '|'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Ans. (c)
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 答案为 (c)
- en: '| 10. | In a queue, the initial values of front pointer f and rear pointer
    r should be …….. and ……….. respectively.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '| 10. | 在队列中，前指针 f 和后指针 r 的初始值应分别为……和……。'
- en: '&#124; (a) &#124; -1, -1 &#124; (b) &#124; 0, -1 &#124;'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; -1, -1 &#124; (b) &#124; 0, -1 &#124;'
- en: '&#124; (c) &#124; 0, 0 &#124; (d) &#124; -1, 0 &#124;'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; 0, 0 &#124; (d) &#124; -1, 0 &#124;'
- en: '|'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Ans. (b)
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 答案为 (b)
- en: '| 11. | The postfix form of the expression (H+I )*(J*K- L)*M / N is?'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '| 11. | 表达式 (H+I )*(J*K- L)*M / N 的后缀形式是？'
- en: '&#124; (a) &#124; HI + JK * L - MN / ** &#124; (b) &#124; HI + JK * L - M **
    N / &#124;'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; HI + JK * L - MN / ** &#124; (b) &#124; HI + JK * L - M **
    N / &#124;'
- en: '&#124; (c) &#124; HI + JK * L - *M * N / &#124; (d) &#124; HI + JKL * - * M
    * N / &#124;'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; HI + JK * L - *M * N / &#124; (d) &#124; HI + JKL * - * M
    * N / &#124;'
- en: '|'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Ans. (a)
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 答案为 (a)
- en: '| 12. | Which data structure is most likely used in a non-recursive implementation
    of a recursive algorithm?'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '| 12. | 在递归算法的非递归实现中，最有可能使用哪种数据结构？'
- en: '&#124; (a) &#124; Linked List &#124; (b) Stack &#124;'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; 链表（Linked List） &#124; (b) &#124; 堆栈（Stack） &#124;'
- en: '&#124; (c) &#124; Queue &#124; (d) &#124; Tree &#124;'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; 队列（Queue） &#124; (d) &#124; 树（Tree） &#124;'
- en: '|'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Ans. (b)
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 答案为 (b)
- en: '| 13. | The process of accessing stored data in a sequential access memory
    is similar to manipulating data on a ------?'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '| 13. | 在顺序访问内存中访问存储数据的过程类似于在 ------ 上操作数据？'
- en: '&#124; (a) &#124; Heap &#124; (b) &#124; Binary Tree &#124;'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; 堆栈（Heap） &#124; (b) &#124; 二叉树（Binary Tree） &#124;'
- en: '&#124; (c) &#124; Array &#124; (d) &#124; Stack &#124;'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; 数组（Array） &#124; (d) &#124; 堆栈（Stack） &#124;'
- en: '|'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Ans. (d)
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 答案为 (d)
- en: '| 14. | The postfix form of E*F+G/H is?'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '| 14. | 表达式 E*F+G/H 的后缀形式是？'
- en: '&#124; (a) &#124; *EF/GH+ &#124; (b) &#124; EF*GH/+ &#124;'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; *EF/GH+ &#124; (b) &#124; EF*GH/+ &#124;'
- en: '&#124; (c) &#124; E*FG+/H &#124; (d) &#124; EFGH+/* &#124;'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; E*FG+/H &#124; (d) &#124; EFGH+/* &#124;'
- en: '|'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Ans. (b)
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 答案 (b)
- en: '| 15. | The prefix form of *H-I/ (J * K* ⋀ *L)* is?'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '| 15. | *H-I/ (J * K* ⋀ *L)*的前缀形式是？'
- en: '&#124; (a) &#124; -/*⋀HJIKL &#124; (b) &#124; -HIJK*⋀KL &#124;'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; -/*⋀HJIKL &#124; (b) &#124; -HIJK*⋀KL &#124;'
- en: '&#124; (c) &#124; -H/I*J⋀KL &#124; (d) &#124; -H/IJ*⋀KL &#124;'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; -H/I*J⋀KL &#124; (d) &#124; -H/IJ*⋀KL &#124;'
- en: '|'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Ans. (c)
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 答案 (c)
- en: '| 16. | What is the output of the following operation Top (Push (S, Y))?'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '| 16. | 下面操作 Top (Push (S, Y)) 的输出是什么？'
- en: '&#124; (a) &#124; Y &#124; (b) &#124; Null &#124;'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; Y &#124; (b) &#124; 空 &#124;'
- en: '&#124; (c) &#124; S &#124; (d) &#124; None &#124;'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; S &#124; (d) &#124; 无 &#124;'
- en: '|'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Ans. (a)
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 答案 (a)
- en: '| 17. | Which among the following data structure is advisable for implementing
    recursion?'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '| 17. | 下列哪种数据结构适合实现递归？'
- en: '&#124; (a) &#124; Queue &#124; (b) &#124; Stack &#124;'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; 队列 &#124; (b) &#124; 栈 &#124;'
- en: '&#124; (c) &#124; Array &#124; (d) &#124; List &#124;'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; 数组 &#124; (d) &#124; 列表 &#124;'
- en: '|'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Ans. (b)
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 答案 (b)
- en: '| 18. | The output of evaluating the postfix expression 2, 4, 6, +, *, 4, 6,
    3, /, +, * is?'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '| 18. | 评估后缀表达式 2, 4, 6, +, *, 4, 6, 3, /, +, * 的输出是？'
- en: '&#124; (a) &#124; 600 &#124; (b) &#124; 120 &#124;'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; 600 &#124; (b) &#124; 120 &#124;'
- en: '&#124; (c) &#124; 650 &#124; (d) &#124; 588 &#124;'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; 650 &#124; (d) &#124; 588 &#124;'
- en: '|'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Ans. (b)
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 答案 (b)
- en: '| 19. | The conversion of the following Infix expression to Postfix form using
    a stack *a + b * c + (d * e + f) * g* is:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '| 19. | 将以下中缀表达式转换为后缀形式，使用栈*a + b * c + (d * e + f) * g*是:'
- en: '&#124; (a) &#124; abc*+de*f+g*+ &#124; (b) &#124; abc*+de*f+g+* &#124;'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; abc*+de*f+g*+ &#124; (b) &#124; abc*+de*f+g+* &#124;'
- en: '&#124; (c) &#124; abc+*de*f+g*+ &#124; (d) &#124; none &#124;'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; abc+*de*f+g*+ &#124; (d) &#124; 无 &#124;'
- en: '|'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Ans. (a)
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 答案 (a)
- en: '| 20. | Among the following statement(s) about stack data structure which statement(s)
    is/are NOT true?'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '| 20. | 关于栈数据结构的以下哪种陈述是/不正确的？'
- en: '&#124; (a) &#124; Stack data structure can also be executed using the linked
    list. &#124;'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; 栈数据结构也可以使用链表执行。 &#124;'
- en: '&#124; (b) &#124; New node is restricted to be added at the top of the stack
    only. &#124;'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (b) &#124; 新节点只能被限制在栈顶添加。 &#124;'
- en: '&#124; (c) &#124; Stack is also known as the **First-In-First-Out** (**FIFO**)
    data structure. &#124;'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; 栈也被称为**先进先出** (**FIFO**) 数据结构。 &#124;'
- en: '&#124; (d) &#124; The bottom most node of the stack has a NULL link. &#124;'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (d) &#124; 栈的最底部节点具有 NULL 链接。 &#124;'
- en: '|'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Ans. (c)
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 答案 (c)
- en: '| 21. | When a stack is implemented using a linked list, which among the following
    node is considered as Top of the stack?'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '| 21. | 当使用链表实现栈时，下列哪个节点被视为栈的顶部？'
- en: '&#124; (a) &#124; First node &#124; (b) &#124; Last node &#124;'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; 第一个节点 &#124; (b) &#124; 最后一个节点 &#124;'
- en: '&#124; (c) &#124; Any node &#124; (d) &#124; Middle node &#124;'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; 任何节点 &#124; (d) &#124; 中间节点 &#124;'
- en: '|'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Ans. (a)
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 答案 (a)
- en: '| 22. | Which among the following operations, take worst case linear time in
    the array implementation of stack?'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '| 22. | 在数组实现的栈中，以下哪些操作在最坏情况下需要线性时间？'
- en: '&#124; (a) &#124; Push &#124; (b) &#124; Pop &#124;'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; 入栈 &#124; (b) &#124; 出栈 &#124;'
- en: '&#124; (c) &#124; IsEmpty &#124; (d) &#124; None &#124;'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; 是否为空 &#124; (d) &#124; 都不是 &#124;'
- en: '|'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Ans. (d)
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：(d)
- en: '| 23. | Among the following, most commonly used application of a stack includes:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '| 23. | 在以下应用中，栈最常用于：'
- en: '&#124; (a) &#124; Parenthesis balancing program &#124;'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; 括号平衡程序 &#124;'
- en: '&#124; (b) &#124; Syntax analyser in compiler &#124;'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (b) &#124; 编译器中的语法分析器 &#124;'
- en: '&#124; (c) &#124; Keep track of local variables at run time &#124;'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; 在运行时跟踪本地变量 &#124;'
- en: '&#124; (d) &#124; All of the above &#124;'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (d) &#124; 以上所有选项 &#124;'
- en: '|'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Ans. (d)
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：(d)
- en: '| 24. | In linked list implementation of a queue, front, and rear pointers
    are tracked. Which of these pointers will change during an insertion into a NONEMPTY
    queue?'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '| 24. | 在队列的链表实现中，跟踪前端和后端指针。在向非空队列插入元素时，哪些指针会改变？'
- en: '&#124; (a) &#124; Only front pointer &#124;'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; 只有前指针 &#124;'
- en: '&#124; (b) &#124; Only rear pointer &#124;'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (b) &#124; 只有后指针 &#124;'
- en: '&#124; (c) &#124; Both front and rear pointer &#124;'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; 前指针和后指针都需要 &#124;'
- en: '&#124; (d) &#124; None of the front and rear pointer &#124;'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (d) &#124; 前指针和后指针都不需要 &#124;'
- en: '|'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Ans. (b)
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：(b)
- en: '| 25. | Stack is used for'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '| 25. | 栈用于'
- en: '&#124; (a) &#124; CPU Resource Allocation &#124; (b) &#124; Breadth First Traversal
    &#124;'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; CPU 资源分配 &#124; (b) &#124; 广度优先遍历 &#124;'
- en: '&#124; (c) &#124; Recursion &#124; (d) &#124; None of the above &#124;'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; 递归 &#124; (d) &#124; 以上都不是 &#124;'
- en: '|'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Ans. (c)
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：(c)
- en: '| 26. | push() and pop() functions are found in'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '| 26. | push() 和 pop() 函数常见于'
- en: '&#124; (a) &#124; queues &#124; (b) &#124; lists &#124;'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; 队列 &#124; (b) &#124; 列表 &#124;'
- en: '&#124; (c) &#124; stacks &#124; (d) &#124; trees &#124;'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; 栈 &#124; (d) &#124; 树 &#124;'
- en: '|'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Ans. (c)
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：(c)
- en: '| 27. | The minimum number of queues needed for priority queue implementation
    is ?'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '| 27. | 实现优先队列所需的最小队列数是多少？'
- en: '&#124; (a) &#124; 5 &#124; (b) &#124; 4 &#124;'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; 5 &#124; (b) &#124; 4 &#124;'
- en: '&#124; (c) &#124; 3 &#124; (d) &#124; 2 &#124;'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; 3 &#124; (d) &#124; 2 &#124;'
- en: '|'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Ans. (d)
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：(d)
- en: '| 28. | In the breadth first traversal of a graph, the data structure being
    used is ?'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '| 28. | 在图的广度优先遍历中，使用的数据结构是？'
- en: '&#124; (a) &#124; queue &#124; (b) &#124; stack &#124;'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; 队列 &#124; (b) &#124; 栈 &#124;'
- en: '&#124; (c) &#124; list &#124; (d) &#124; none of the above &#124;'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; 列表 &#124; (d) &#124; 以上都不是 &#124;'
- en: '|'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Ans. (a)
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：(a)
- en: '| 29. | A queue data-structure can be used for'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '| 29. | 队列数据结构可以用于'
- en: '&#124; (a) &#124; expression parsing &#124; (b) &#124; recursion &#124;'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; 表达式解析 &#124; (b) &#124; 递归 &#124;'
- en: '&#124; (c) &#124; resource allocation &#124; (d) &#124; ll of the above &#124;'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; 资源分配 &#124; (d) &#124; 以上全部选项 &#124;'
- en: '|'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Ans. (c)
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：(c)
- en: '| 30. | If locality is a concern, ________ graph traversal can be used. graph.'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '| 30. | 如果关注局部性，则可以使用 ________ 图的遍历方法。'
- en: '&#124; (a) &#124; Breadth First Search &#124; (b) &#124; Depth First Search
    &#124;'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; 广度优先搜索（BFS） &#124; (b) &#124; 深度优先搜索（DFS） &#124;'
- en: '&#124; (c) &#124; Either BFS or DFS &#124; (d) &#124; None of the above! &#124;'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; 要么广度优先搜索（BFS），要么深度优先搜索（DFS） &#124; (d) &#124; 以上都不是！ &#124;'
- en: '|'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Ans. (b)
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：(b)
- en: '| 31. | In conversion from prefix to postfix using stack data-structure, if
    operators and operands are pushed and popped exactly once, then the run-time complexity
    is'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '| 31. | 在使用栈数据结构从前缀转换为后缀时，如果运算符和操作数被推送和弹出恰好一次，那么运行时复杂度是'
- en: '&#124; (a) &#124; Ο(1) &#124; (b) &#124; Ο(n) &#124;'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; Ο(1) &#124; (b) &#124; Ο(n) &#124;'
- en: '&#124; (c) &#124; Ο(log n) &#124; (d) &#124; Ο(n2) &#124;'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; Ο(log n) &#124; (d) &#124; Ο(n2) &#124;'
- en: '|'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Ans. (b)
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：(b)
- en: '| 32. | If queue is implemented using arrays, what would be the worst run time
    complexity of queue and dequeue operations?'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '| 32. | 如果使用数组实现队列，那么队列和出队操作的最坏运行时间复杂度将是多少？'
- en: '&#124; (a) &#124; Ο(n), Ο(n) &#124; (b) &#124; Ο(n), Ο(1) &#124;'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; Ο(n), Ο(n) &#124; (b) &#124; Ο(n), Ο(1) &#124;'
- en: '&#124; (c) &#124; Ο(1), Ο(n) &#124; (d) &#124; Ο(1), Ο(1) &#124;'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; Ο(1), Ο(n) &#124; (d) &#124; Ο(1), Ο(1) &#124;'
- en: '|'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Ans. (c)
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：(c)
- en: '| 33. | Implementing a stack using queue(with only enqueue and dequeue operations),
    requires ___number of queues?'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '| 33. | 使用队列实现栈（仅使用入队和出队操作），需要多少个队列？'
- en: '&#124; (a) &#124; 1 &#124; (b) &#124; 2 &#124;'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; 1 &#124; (b) &#124; 2 &#124;'
- en: '&#124; (c) &#124; 3 &#124; (d) &#124; 4 &#124;'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; 3 &#124; (d) &#124; 4 &#124;'
- en: '|'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'Ans. (b) Short Answer QuestionsQuestions Questions Questions Questions Questions
    Questions Questions Questions Questions QuestionsQuestions Questions Questions
    Questions Questions Questions Questions Questions Questions QuestionsQuestions
    Questions Questions QuestionsQuestions Questions Questions QuestionsQuestions
    Questions Questions QuestionsQuestions Questions Questions QuestionsQuestions
    Questions Questions QuestionsQuestions Questions QuestionsQuestions Questions
    Questions QuestionsQuestions Questions Questions QuestionsQuestions Questions
    QuestionsQuestions Questions Questions Questions QuestionsQuestions Questions
    Questions QuestionsQuestions Questions Questions Questions QuestionsQuestions
    Questions Questions Questions Questions Questions Questions Questions Questions
    Questions Questions Questions QuestionsQuestions Questions Questions Questions
    Questions Questions Questions Questions Questions Questions Questions Questions
    QuestionsQuestions Questions Questions Questions Questions Questions QuestionsQuestions
    Questions Questions Questions Questions Questions Questions Questions QuestionsQuestions
    Questions Questions Questions Questions Questions Questions Questions Questions
    Questions Questions Questions Questions Questions QuestionsQuestions Questions
    Questions Questions Questions Questions Questions Long Answer QuestionsQuestions
    Questions Questions Questions Questions Questions Questions Questions Questions
    Questions QuestionsQuestions Questions Questions Questions Questions Questions
    Questions Questions Questions Questions QuestionsQuestions Questions Questions
    Questions Questions Questions Questions QuestionsQuestions Questions Questions
    Questions Questions Questions Questions QuestionsQuestions Questions Questions
    Questions Questions Questions Questions QuestionsQuestions Questions Questions
    Questions Questions Questions Questions Questions QuestionsQuestions Questions
    Questions Questions Questions Questions Questions Questions Questions Questions
    Questions Questions Questions Questions QuestionsQuestions Questions Questions
    Questions Questions Questions QuestionsQuestions Questions Questions Questions
    Questions Questions Questions Questions Questions Questions Questions Questions
    Questions Questions Questions Questions Questions Questions Questions Questions
    Questions QuestionsQuestions Questions Questions Questions Questions Questions
    Questions Questions Questions Questions Questions Questions Questions Questions
    Questions Questions Questions Questions Questions Questions Questions Questions
    Questions Questions QuestionsQuestions Questions Questions Questions Questions
    Questions Questions Questions Questions Questions Questions Questions Questions
    Questions Questions Questions Questions Questions Questions Questions Questions
    Questions Questions QuestionsQuestions Questions Questions Questions Questions
    Questions Questions Questions Questions Questions Questions Questions Questions
    Questions QuestionsQuestions Questions Questions Questions Questions Questions
    Questions Questions Questions Questions Questions Questions Questions Questions
    Questions QuestionsQuestions Questions Questions Questions Questions Questions
    Questions Questions Questions Questions MODULE IVTrees and Graphs  CHAPTER 4 Trees
    and Graphs4.1 Introduction Arrays, stacks, queues, and linked lists, are categorized
    as linear data structures. These are known as linear, because the elements are
    arranged sequentially (i.e., they are represented in memory using a one-dimensional
    array). A Tree is another advantageous data structure, where elements appear in
    a non-sequential manner, which is represented in memory using a two-dimensional
    array. ![](image-d9kz8tqu.jpg) There are various examples available, where tree
    data structure is the efficient means to maintain and manipulate data. In general,
    where the hierarchical relationship among data are to be preserved, tree is used.
    It is very useful information retrieval and searching in tree is also very fast
    and of O (log2n).4.2 Basic Terminologies (1) The most important component of any
    tree structure is a node. The concept of node is similar to the linked list. Node
    of a tree denotes the actual data and links to the other node. (figure 4.1) Figure
    4.1 Node (2) Parent of a node is defined as the immediate predecessor of a node.
    Here, X is the parent of Y & Z (figure 4.2). ![](image-y8mte31n.jpg)Figure 4.2
    Parent node (3) If the instant predecessor of a node is the parent of the node
    then all instant successors of a node are referred as child nodes. Child which
    is to the left of a particular node is referred as the left child node and that
    of at the right side is referred as the right child node. In the above Figure
    4.2, Y&Z are two children of X, where Y, the left child and Z, the right child. (4)
    This is a pointer, which points to some another node in a tree. (5) Root: This
    is a specially tagged node which has no parent. In Figure X is the root node. (6)
    The node which is placed at the bottom level of a tree and which does not have
    any child is known as leaf node. The leaf node is also referred as terminal node. In
    the below Figure H, I, K, L, E and M are leaf nodes. ![](image-kz0di7wh.jpg)Figure
    4.3 Leaf nodes (7) It is the rank of the hierarchy and root node is termed as
    in level O or level 1\. If any node is at level l then its child node will be
    at level l+1 and its parent node will be at level l-1\. Level of the root node
    is Zero (or level 1). (8) Maximum number of nodes, which are present in a path,
    from root node to a leaf node, is termed as the height of a tree. In Figure the
    longest path is A-C-F-J-M and hence the height of this tree is 5\. It can be easily
    derived as h = + 1 or h = where h is the height of a given tree and is the maximum
    level of that tree. (9) For a node, the maximum number of children possible is
    known as the degree of a node. In figure the degree is equal to 2 here. (10) The
    nodes which have the same parent are called siblings. In figure J and K are siblings.4.3
    Tree A tree is a collection of a finite set of one or more nodes such that:that:
    that: that: that: that: that: that: that: that:that: that: that: that: that: that:
    that: that: that: that: that: that: that: that: that: that: that: that: that:
    that: that: that: that: that: that: that: that: that: that: that: that: that:
    that: that: that: that:4.4 Binary Trees One of the important tree structure is
    a binary tree. It becomes distinctive by the fact that any node can have maximum
    of 2 branches i.e., the only restriction here is that, no node is available in
    a binary tree with degree greater than 2\. A binary tree is a defined set of nodes,
    which can be null or comprise of a root node and two disjoint binary trees called
    the left subtree and the right sub tree. Following features of a binary tree and
    a tree, makes important differences between them:them: them: them: them: them:
    them: them: them: them: them: them: them: them: them: them: them: them: them:them:
    them: them: them: them: them: them: them: them: them: them: them: them: them:
    them: them: them: them: them: them: them: them: them: them: them: Figure 4.4 Binary
    tree and tree As shown in figure 4.4, when the above trees are treated as Binary
    Trees, then they are considered as two different Binary trees. Whereas when they
    are treated as trees, then they are same.4.4.1 Strictly Binary Tree If every internal
    node (non –terminal node) has its non- empty left and right children then it is
    called strictly binary tree (figure 4.5). Figure 4.5 Strictly Binary Tree Here
    every internal node A, B, E has two non-empty left and right child, hence it is
    strictly binary tree.4.4.2 Complete Binary Tree A binary tree, where all the nodes
    have both children except last node, is known as a complete binary tree (figure
    4.6). ![](image-0scf57ys.jpg)Figure 4.6 Complete Binary Tree The main advantage
    with this structure is that we can easily find the left and right child of any
    node and similarly parent of any child. Two nodes of a node, that is, the left
    child and right child, will be at position 2N and 2N+1\. Similarly, parent of
    any node N will be (N/2). So, parent of I = (N/2) = (9/2) = 4, i.e. D. Left child
    of D = 2N = 2* 4 = 8, i.e. H Right child of D = 2N + 1 = 2 * 4 + 1 = 9, i.e. I4.4.3
    Extended Binary Tree A binary tree is called extended binary tree if every node
    of tree has zero or 2 children. It is also said to be 2- tree. Most of the nodes
    in binary tree have one child then we can add one or 2 children and can extend
    it. So, it can be converted to extended binary tree (figure 4.7). Extended Binary
    Tree ![](image-2742b0jk.jpg)Figure 4.7 Extended Binary Tree Here square nodes
    represent the extended nodes in the original binary tree.4.5 Binary Tree Representation There
    are two ways of representing binary trees in memory.memory. memory. memory. memory.memory.
    memory. Consider the following 2 sample binary trees (figure 4.8). ![](image-uz7y27io.jpg)Figure
    4.8 Binary tree A binary tree, when it is a full binary tree of depth k, will
    have nodes. (1) Suppose a binary tree is complete or nearly complete then the
    sequential representation of binary tree in memory is efficient method. This representation
    uses only a single linear array as follows:follows: follows: follows: follows:
    follows: follows: follows:follows: follows: follows: follows: follows: follows:
    follows: follows: follows: follows: follows: follows: follows: follows: follows:
    follows: follows: follows: follows: follows: follows: follows: follows: follows:
    follows: follows: follows: The NULL (-) is used to indicate an empty subtree.
    TREE (1) = NULL indicate that the tree is empty. In sequential representation
    of binary trees, numbering of nodes is done sequentially, that is, numbering starts
    with all nodes on level 1, then level 2, and so on. The direction of numbering
    of nodes on any level is from left to right as shown in the following figure ![](image-1gmpp1ht.jpg)Figure
    4.9 Direction of numbering of nodes ![](image-l774e5wm.jpg)Figure 4.10 Forming
    binary tree ![](image-c28fy66w.jpg)Figure 4.11 Inserting nodes in binary tree ![](image-m006ur9c.jpg)Figure
    4.12 A complete B.T of depth 5 From the above two sequential representation of
    binary trees we note that the array representation appears to be good and is wasteful
    for another binary tree. Another problem of this method is insertion or deletion
    of nodes from the middle of a tree, which require the movement of many nodes. (2)
    Linked Representation The problem mentioned in sequential representation method
    can be easily overcome by the use of linked list representation. Here each node
    will have three fields: LCHILD, DATA, and RCHILD. ![](image-l6skdyzj.jpg)Figure
    4.13 LCHILD and RCHILD ![](image-t87ytry3.jpg)Figure 4.14 Linked List Representation4.6
    Binary Tree Traversal On trees, we can perform numerous operations. One of the
    frequently performed operation is traversing a tree or visiting each node, absolutely
    one single time. When a full traversal on a tree is performed, it will produce
    a linear order for the information. In tree creation we take 3 parameters: node,
    left child, and right child, so traversing of binary tree means traversing of
    node, left subtree and right subtree. If root is defined as D, left subtree as
    L and right subtree as R, then there will be 6 combinations of traversals: DRL,
    DLR, LRD, LDR, RLD, RDL. We usually adopt the convention that we traverse left
    before right, then only 3 traversals remain: LDR, LRD & DLR. left subtree is always
    traversed before right subtree). DLR traversal is called preorder traversal, LDR
    is inorder traversal and LRD is post order traversal. The above 3 traversals produce
    the prefix, infix, and postfix forms of an expression respectively. ![](image-0omd9eig.jpg)Figure
    4.15 Traversals These traversals are: Preorder (DLR) traversaltraversal traversal
    traversaltraversal traversal traversal traversal traversal traversal traversal
    traversal traversaltraversal traversal traversal traversal traversal traversal
    traversal traversal traversal Inorder (LDR) traversaltraversal traversal traversal
    traversal traversal traversal traversal traversaltraversal traversal traversaltraversal
    traversal traversal traversal traversal traversal traversal traversal Postorder
    (LRD) traversaltraversal traversal traversal traversal traversal traversal traversal
    traversaltraversal traversal traversal traversal traversal traversal traversal
    traversaltraversal traversal traversal Procedure INORDER (TREE) //TREE is a binary
    tree with node having 3 fields LCHILD, DATA,RCHILD // If TREE≠0 then [Call INORDER
    (LCHILD(TREE)) Print (DATA(TREE)) Call INORDER(RCHILD(TREE))] end INORDER. Procedure
    PREORDER (TREE) //TREE is a binary tree with node having 3 fields LCHILD, DATA,RCHILD
    // If TREE≠0 then [ Print (DATA(TREE)) Call PREORDER (LCHILD(TREE)) Call PREORDER(RCHILD(TREE))] end
    PREORDER. Procedure POSTORDER (TREE) //TREE is a binary tree with node having
    3 fields LCHILD, DATA,RCHILD // If TREE≠0 then [ Call POSTORDER (LCHILD(TREE)) Call
    POSTORDER (RCHILD(TREE)) Print (DATA(TREE))] end POSTORDER. Creation of binary
    tree from preorder and inorder traversals Let us take the following preorder and
    inorder traversals for a tree. We have to create a binary tree from the given
    traversals. PREORDER – ABDHECFG INORDER  DHBEAFCG (1) In preorder traversal, root
    is the first node. Hence, A is the root of the binary tree. ![](image-vv811oy0.jpg) (2)
    Now we can find the node of left subtree and right sub tree with inorder sequence.
    Nodes which are to the left of the root node in inorder are nodes of left subtree
    and nodes which are to the right of the root node in inorder are nodes of right
    subtree. So, we get, Nodes of left subtree – D H B E Nodes of right subtree –
    F C G ![](image-yf4v51lc.jpg) (3) Now we have to find root of the left subtree
    of A. For that, we have to analyze the order of these nodes in given preorder
    traversal. We found B is the first node in preorder traversal. Thus, B is the
    root node of the left subtree of A. ![](image-uxw596nu.jpg) (4) To find which
    nodes will come to the left of B and which to the right of B, we have to analyse
    those nodes other than B in inorder traversal. And we found that, D and H are
    the nodes coming to the left of B and E, is the node coming to the right of B. ![](image-bvtyj1gz.jpg) (5)
    Next, we have to find which node is going to be the root node among the nodes
    in the left subtree of B. Similar process is used, check those nodes in PREORDER
    and we can conclude that D, is the root node for the left subtree of B. ![](image-o2spu9o7.jpg) Left
    subtree of B. (6) Next, we have to find where H has to be placed, i.e, whether
    it is right child of D or the left child of D. This can be found by analysing
    these nodes (D, H) in inorder traversal, and hence, we found that H is the right
    child of D. ![](image-l8cn9668.jpg) (7) Next, we have to find the root node for
    the right subtree of A. Checking F, C & G in preorder traversal, we find that
    the root node is C, since C is coming first in the traversal. ![](image-7bf4aiyd.jpg) (8)
    The next thing to identify is which nodes will go to the left subtree of C and
    which nodes will go to the right subtree of C. For this, we have to analyze order
    how these nodes are present in inorder traversal. Hence, we found that F is the
    left child of C and G is the right child of C. ![](image-9hh175oa.jpg) Creation
    of tree from postorder and inorder traversals Let us take the following postorder
    and inorder traversal for a tree. We have to create a binary tree from the given
    traversal.traversal. traversal. traversal. traversal. traversal. traversal. traversal.
    traversal. traversal. traversal. traversal. traversal.traversal. traversal. traversal.
    traversal. traversal. traversal. traversal. traversal. traversal. traversal. traversal.
    traversal.traversal. traversal. traversal. traversal. traversal. traversal. traversal.
    traversal. traversal. traversal. traversal. traversal. traversal. traversal. traversal.
    traversal. traversal. ![](image-6k5bkdim.jpg) traversal. traversal. traversal.
    traversal. traversal. traversal. traversal. traversal. traversal. traversal. traversal.
    traversal. traversal. ![](image-yqmkj33p.jpg) (iii) Now we have to find the root
    of the left subtree of A. For that we have to check the order of left subtree
    node of A in postorder and hence, found that B is the root of the left subtree
    of A. the left subtree of A. ![](image-nf26cfvn.jpg) (iv) Next step is to identify
    which all nodes come to the left of B and which all nodes come to the right of
    B. For that, we have to look all the left subtree nodes of A, in inorder and found
    that H and D are left subtree nodes of B and I and E are right subtree nodes of
    B. ![](image-93wzmss2.jpg) (v) Now we have to find which node is the root of the
    left subtree of B. For that check the postorder traversal, and hence found that,
    D, is the root of the left subtree of B. ![](image-eka2692p.jpg) (vi) Now we have
    to find whether H goes to the left of D or right of D and that can be concluded
    by looking into the inorder traversal. So, we found that H is the left child of
    D. ![](image-w33ncp27.jpg) (vii) Now, the next step is to find which node is the
    root node of the right subtree of B. This can be identified by checking the order
    of these nodes in postorder and thus, we found that E is the root node. ![](image-xj3v4yh7.jpg) (viii)
    Now we have to find whether I go to the left of E or right of E. This can be determined
    by looking into the inorder traversal. So, we found the I is the left child of
    E. ![](image-54d5rquk.jpg) (ix) Now we have to find the root node of the right
    subtree of A. For that, we have to analyse these nodes in postorder and found
    that C is the root node. Now, we have to determine the left subtree and right
    subtree of C, that can be identified by analyzing the inorder traversal. ![](image-no93pbu3.jpg) (xi)
    Now we have to find the root node of the left subtree of C and the root node of
    the right subtree of C. This can be done by looking into postorder traversal and
    found that F is the root node for the left subtree of C and G is the root node
    for the right subtree of C. ![](image-xy3daden.jpg) (xii) Now we have to determine,
    whether J go to the left of F or right of F. This can be determined by looking
    into the in order traversal. So, we found that J is the right child of F. ![](image-zg7n2s4e.jpg) (xiii)
    Next, we have to determine, which nodes are the left subtree of G and which nodes
    are the right subtree of G. This is determined by looking into the in order traversal
    and thus, we found that K is the left child of G and L is the right child of G.4.7
    More on Binary Trees Procedure COPY (TREE) //For a binary tree TREE, Copy returns
    a pointer to an exact copy of TREE; new nodes are created using the usual mechanism.
    // Q ← 0 if TREE ≠ 0 then [ R← COPY (LCHILD(TREE)) //copy left subtree S ← COPY
    (RCHILD (TREE)) // copy right subtree Call GETNODE(Q) LCHILD (Q) ← R; // store
    in fields of Q RCHILD (Q) ← S; // store in fields of Q DATA (Q) ← DATA (TREE)] return
    (Q). end COPY. Procedure EQUAL (X, Y) // This procedure outputs FALSE if the binary
    trees X & Y are not equivalent. Otherwise, outputs TRUE// ans ← FALSE case : X
    = 0 and Y = 0; ans ← TRUE : X ≠ 0 and Y ≠0: if DATA (X) = DATA (Y) then [ ans
    ← EQUAL (LCHILD(X), LCHILD(Y)) if ans then ans ← EQUAL(RCHILD(X), RCHILD(Y))] end return
    (ans) end EQUAL.4.8 Threaded Binary Trees In linked representation of any binary
    tree, we notice that there are more null links than actual pointers. One smart
    way is to make use of these null links and replace them by actual pointers. This
    idea has been devised by A.J. Perlis & C. Thornton. Their idea is to connect such
    nodes with other nodes in the tree, by replacing the null links by pointers, called
    threads. Binary trees with such pointers are called threaded binary trees. If
    the RCHILD (P) is equal to zero, we have to replace that link by a pointer to
    the node which comes after P, when traversing the tree in inorder. When the link
    of LCHILD at node P is replaced by a pointer to the node which immediately precedes
    node P in inorder. ![](image-y9xqi3na.jpg)Figure 4.16 (a) Binary Tree The corresponding
    threaded binary tree representation of the above figure is as follows: ![](image-g6lmdblm.jpg)Figure
    4.16 (b) Threaded Binary Tree The given tree T has 9 nodes and 10 empty links,
    which have been restored by threads. The nodes of the given tree, will be visited
    in the follwing order, when traversed in inorder: HDIBEAFCG. While representing
    threaded binary trees in memory, we must be able to distinguish between threads
    and normal pointers. This is usually done by adding two extra one-bit fields,
    LBIT and RBIT, in a node. LBIT (P) =1, only if LCHILD (P) is a conventional pointer. LBIT
    (P) = 0, only if LCHILD (P) is a thread. RBIT (P) = 1, only if RCHILD (P) is a
    standard pointer RBIT (P) = 0, only if RCHILD (P) is a thread. In figure 4.16
    (b) we see that two threads have been left dangling in LCHILD (H) & RCHILD (G).
    in order to leave no loose threads, it is assumed that a head node is present
    for all thread binary trees. The left subtree of the head node is the given tree
    T. Let us assume that an empty binary tree is represented by its head node as: ![](image-j5ur4gr3.jpg) The
    complement memory representation for the tree of figure 4.16 (b) is shown in the
    following figure 4.16 For any node X in a threaded binary tree, if RBIT (X) =
    O then the inorder successor of X is RHILD (X). When RBIT (X) = 1, the inorder
    successor of X is determined by moving through a path of left child links, which
    starts from the right child of X until a node with LBIT = O is reached. ![](image-ko08ekjo.jpg)Figure
    4.16 (c) Memory representation for the tree The algorithm INSUC is for obtaining
    the inorder successor of any node X in a threaded binary tree. Procedure INSUC
    (Y) //Find the inorder successor of Y in a threaded binary tree. // S← R CHILD
    (Y) // if RBIT (Y)= O we have reached the end// if RBIT (Y) = 1 then [while LBIT
    (S) =1 do //follow left S ← LCHILD (S) //until a thread end] return (S) end INSUC. Procedure
    TINORDER (T) //Traverse the threaded binary tree, T, in inoder// HEAD ← T loop T
    ← INSUC (T) if T = HEAD then return print (DATA (T)) forever end TINORDER. The
    computing time is O (n) for a binary tree with n nodes.4.9 Binary Tree Representation
    of Trees The main concept described in this topic is that every tree can be represented
    as a binary tree. ![](image-84xecubj.jpg)4.10 Binary Search Tree A BST is a binary
    tree, either it is empty or each node in the tree contain an identifier andand
    and and and and and and and and and and and and and and and and and and and and
    and and and and and and and andand and and and and and and and and and and and
    and and and and and and and andand and and and and and and and and and and and
    and and and and and and ![](image-1w26c4lt.jpg) Algorithm for searching (X) in
    a BST Procedure search (T, X, i) i = 0 while T≠ O do Case : DATA (T) = X i = T return :
    X< DATA (T) T = LCHILD (T) : X> DATA (T) T = RCHILD (T) end case end while return end
    search To determine whether an identifier X is present in a BST, X is compared
    with the root. If X is less than the identifier in the root, then the search continues
    in the left subtree. If X is equal to the identifier in the root the search terminates
    successfully, otherwise the search continue in the right subtree. Complexity of
    the searching algorithm Suppose we are searching for an item of information in
    a BST T, the number of comparisons is bounded by the depth of the tree. The average
    item to search for an item is a binary tree T with n elements is proportional
    to or O (log Algorithm for BST (inserting) Procedure BST (X, T, j) //Search the
    BST T for the node j such that IDENT (j)= X. If X is not already in the tree then
    it is entered in the appropriate position. Each node has LCHILD, IDENT and RCHILD
    fields. // p← 0; j← T // p will trail j through the tree// while j ≠ O do if X
    < IDENT (j) //search the left subtree// p = j j= LCHILD (j) elseif X = IDENT (j) return elseif
    X > IDENT (j) //search the right subtree p = j j = RCHILD (j) endif endif endif end
    do. //X is not in the tree & can be entered as a child of P// Call getnode (j) IDENT
    (j) = X LCHILD (j) = RCHILD (j) = O if T = O T = j Else if X< IDENT (p) LCHILD
    (p) =j else RCHILD (p) = j endif endif end BST.4.11 Procedure for deleting from
    a binary search tree The deletion algorithm must use search algorithm to find
    the location of the node ‘N’ which contain item and also the location of the parent
    node P The procedure N is deleted from the tree depends on the number of children
    of node There are three cases. Case N has no children. Then N is deleted, by storing
    the null pointer in the location of N in the parent node P (N). ![](image-lzxb6p50.jpg) Case
    N has exactly one child then N is deleted from T by simply replacing the location
    of N in (P (N)) by the location of only child of N. ![](image-xl9eyw6b.jpg) Case
    N has 2 children. Let S (N) denote the inorder successor of N. Then N is deleted
    from T by first deleting S (N) from T, by using case 1 or case 2 and replacing
    node N in T by node S (N). ![](image-v0fv2ppo.jpg) When binary search trees are
    being evaluated, it is always useful to add a special square node, wherever there
    is a null link. All binary trees with n nodes, will have n+1 null links and hence
    it will have n+1 square nodes. As these nodes are not the part of the original
    tree, they are referred as external nodes. All nodes which are not external nodes
    are termed as internal nodes. Each time a binary search tree is examined for an
    identifier which is not in the tree, the search terminated at an external node.
    Since all such searches represent be referred to as failure nodes. Here binary
    tree with an external node is called an extended binary tree. ![](image-343p4x6t.jpg) The
    sum of overall external nodes of the lengths of the path from the root to those
    nodes, is known as the external path length of a binary tree. The sum of all internal
    nodes of the length of the path from the root to those nodes, is known as the
    internal path length. The internal and external path length of the binary tree
    with internal nodes are related by the formula E = 1 + ![](image-x5ftjzpe.jpg) Where
    ‘n’ is the number of nodes in the binary tree.4.12 Weighted Path Length Let us
    assume T as a binary tree with n external nodes and each of the external node
    is assigned a weight (non-negative). The weighted path length P of the tree T
    is defined to be sum of the weighted path length, i.e., P = + + … Where Wi and
    Li denote the weight and path length of an external node N: ![](image-juxwc29r.jpg)4.13
    B Tree In multiway search tree, so many nodes have left subtree but have no right
    subtree. Similarly, they have right subtree but have no left subtree. Insertion
    of key also increases the height of tree. The access time in tree is totally dependent
    on level of tree. So, the aim is to minimize the access time which can be through
    balanced tree only. So, there is a need to take all the left nodes at same level
    & non-leaf nodes should not contain the empty subtree. So, for order n tree, maximum
    no. of children should be n and each node can contain k keys where k<=n-1 for
    balancing the tree each node should contain n/2 keys (except root). So, the B-tree
    of order n can be defined as:as: as: as: as: as: as: as: as: as: as: as: as:as:
    as: as: as: as: as: as: as: as: as: as: as: as: as: as: as:as: as: as: as: as:
    as: as: as: as:as: as: as: as: as: as: as: as: as: as: as: as: as: as: as: as:
    as:as: as: as: as: as: as: as: as: as: as: as: as: as: as: as: as: as: as: as:
    as: as: as: as: as: as: as: as: as: as: as: as: as: as: as: Let us take a B-tree
    of order -5\. ![](image-1gnm30tp.jpg) Here, we can find all leaf nodes at the
    same height. All non-leaf nodes have no empty subtree and they have keys one less
    than number of their children.4.13.1 Insertion in B tree Insertion of key requires
    first traversal in B-tree, to find whether key is already existing or not. Suppose
    key does not exist in tree then through traversal it will reach leaf node. Now
    we have two cases for inserting the key:key: key: key: key:key: key: key: key: In
    the case, we can simply add the key in node. But in second case, we will need
    to split the node in two nodes & median keys will go to the parent of that node.
    If parent is also full, then same thing will be repeated until it will get non-full
    parent node. Suppose root is full, then it will split into two nodes & median
    key will be root. For example: Let us take a list of keys to create a B-tree of
    order 5 10,70,60,20,110,40,80,130,100,50,190,90,180,240,30,120,140,160 ![](image-k835nlab.jpg) ![](image-7uxg03s7.jpg) ![](image-o8kmt49j.jpg) ![](image-kjkifcy3.jpg) ![](image-0dcstrnh.jpg)4.14
    B + tree In B-tree we can access record only randomly. We cannot traverse the
    records sequentially. After finding particular record we cannot get the previous
    or next record because it doesn’t provide sequential traversal. B+ tree has the
    both properties, random access as well as sequential traversal. In B+ tree all
    the keys which are in non-leaf node will be in leaf node also and each leaf node
    will point to the next leaf node, so we can traverse sequentially also. Here keys
    in leaf node will point to the full record attached with that particular key. Assume
    that we have a B+ tree of order 5 and understand the concept of B+ tree. ![](image-vbh4nj83.jpg) Here
    we can see all the keys in non leaf node are also in leaf node and each leaf node
    is pointing to the next leaf node. Now suppose we want to search the key 30 then
    first it will be compared with 100 then it will go to the left subtree, then it
    will compare with 30 and it will go to the left subtree. Now it’s in leaf node
    and it will find 30 and will get the record pointed by the key 30\. Now it can
    traverse sequentially in another leaf node also. So, it is getting property to
    traverse sequentially all the keys.4.15 AVL Tree (Height Balanced Binary Trees) Adelson-Velskii
    and Landis in 1962 introduced a binary tree structure that is balanced with respect
    to the height of sub trees. Because of this balance nature, dynamic retrievals
    can be performed in 0(log n) time. Also, a new identifier can be entered or deleted
    from such a tree in time 0(log The resulting tree remains height balanced. The
    tree introduced by them is given the name AVL-Tree. Definition: An empty tree
    is height balanced. If T is a not an empty binary tree with and as its left and
    right sub trees, then T is height balanced if:if: if: if: if: if: if: if:if: if:
    if: if: if: if: if: if: if: if: if: if: if: if: if: In an AVL tree, height of
    left and right sub tree of any node will be with maximum difference of one and
    it is basically a binary search tree. In an AVL tree, each node has a balance
    factor The difference found between the height of left subtree of a particular
    node and right subtree of a node,  Balance factor of a node = Height of left subtree
    – Height of right subtree  is known as the balance factor of a node. For a particular
    node, when the height of its right subtree is one more than height of its left
    subtree, then such node is called as right heavy or right high. A node is called
    left heavy or left high if its left subtree is one more than height of its right
    subtree. A node is called balanced if the height of right and left subtree is
    equal. The balance factor will be 1 for left height, -1 for right high and 0 for
    balanced node. So in an AVL tree, each node can have only 3 values of balance
    factor which are -1, 0, 1\. Example. of AVL trees. ![](image-5xt2tc6n.jpg) Example
    of BST but not AVL tree. ![](image-yfd7z9jb.jpg)4.15.1 Insertion in AVL tree Insertion
    in AVL tree is same as insertion in B.S.T. Here also we will search for the position
    where the new node is to be inserted and then insert the node. But AVL tree has
    a property that the height of left and right subtree will be with maximum difference
    of 1\. Suppose after inserting new node, this difference becomes more than one.
    In this condition, we have to restore the property of AVL tree again. To restore
    the property of AVL tree, we should convert the tree in such a way that:that:
    that: that: that: that: that: that: that: that: that: that: that: that: that:
    that: that: that: that: that: that:that: that: that: that: that: that: that: that:
    that: that: that: that: that: that: that: that: that: that: that: The rebalancing
    was carried out using four different kinds of rotations (AVL rotations), depending
    upon where the new node is inserted:inserted: inserted: inserted: inserted: inserted:
    inserted: inserted: inserted: inserted: inserted: inserted: inserted: inserted:
    inserted: inserted: inserted: inserted: inserted: inserted:inserted: inserted:
    inserted: inserted: inserted: inserted: inserted: inserted: inserted: inserted:
    inserted: inserted: inserted: inserted: inserted: inserted: inserted:inserted:
    inserted: inserted: inserted: inserted: inserted: inserted: inserted: inserted:
    inserted: inserted: inserted: inserted: inserted: inserted: inserted: inserted:inserted:
    inserted: inserted: inserted: inserted: inserted: inserted: inserted: inserted:
    inserted: inserted: inserted: inserted: inserted: inserted: inserted: inserted: Example: ![](image-mzr761j2.jpg) These
    rotations are featured by the nearest ancestor, A, of the inserted node, Y, whose
    balance factor becomes plus or minus two. The following are the characterization
    of rotation types:types: types: types: types: types: types: types: types: types:
    types: types: types: types: types: types: types: types: types: types: types: types:types:
    types: types: types: types: types: types: types: types: types: types: types: types:
    types: types: types: types: types:types: types: types: types: types: types: types:
    types: types: types: types: types: types: types: types: types: types: types:types:
    types: types: types: types: types: types: types: types: types: types: types: types:
    types: types: types: types: types: 1.LL: ![](image-cjvxqnqt.jpg) 2.RR: ![](image-p9tr57f0.jpg) 3.LR: ![](image-r5ylbdsb.jpg) 4.RL: ![](image-29i4y1oh.jpg)4.16
    Graphs Definitions and Terminology One of the important data structure in Computer
    Science, is graph and it has innumerable applications in real life scenarios.
    We unknowingly deal with them in our day to day life. Graph is a mathematical
    structure that deals with the pair-wise relationships between objects. It is actually
    a flow structure, representing relationship between various objects. The following
    are the components of a graph:  Vertices; also known as nodes Edges; also known
    as arcs The following diagram shows a basic graph with two vertices and an edge
    between them. ![](image-zfil9eoz.jpg) So, a graph, G, mainly contains two sets
    V and E. V is a finite and nonempty set of vertices, whereas E is a set of edges,
    or in other words, E is also said to be a set of pair of vertices. To represent
    a graph, we write G = (V, The following is a graph containing 5 vertices and 6
    edges. This graph G can be defined as G = (V, E) where V = {A, B, C, D, E} and
    E = {(A, B), (A, C), (B, C), (B, D), (B, E), (C, D), (D, E)} ![](image-ci7tcgxk.jpg) We
    generally study graph in two categories and they are as follows:follows: follows:follows:
    follows: Directed graph, also known as Di-graph and is represented through a pair
    of ordered vertices, means that the order of appearance of vertices in a set matter.
    i.e., (u, v) is not equal to (v, u). The following figure shows a directed graph: ![](image-ypbhaiuc.jpg) Here,
    edge (A, B) and (B, A) are not equal. However, in case of undirected graph, it
    consists of pair of unordered vertices, i.e., (u, V) and (v, u) are same. The
    following figure shows a undirected graph: ![](image-wd6oz75n.jpg) Here, edge
    (A, B) and (B, A) are not equal. Let’s have some knowledge about the reason to
    study graph. We will see some of the applications of a graph in our day to day
    life. Following are some of the applications of graphs:  Social Networks: Facebook,
    LinkedIn, Twitter, and so on. Graphs are used to represent a social network, where
    in these networks, each person is represented with a node. These nodes contain
    information about that person such as his name, gender, address, and so on., and
    the edges are used to represent a relationship. Road Network: ![](image-z7g67v12.jpg) Graphs
    are also used to represent a road network. Consider a network of cities, where
    each city in that network represents the vertex and the paths between two cities
    can be considered as edges of the network.  Precedence Constraints Problem: This
    is a problem where there is certain pre- requisite that must be followed. For
    example, in a bank, a customer can avail a loan only when he/she is the saving
    account holder of that bank, making it a pre-requisite for loan.4.17 Graph Representation Here
    we will see how to store graph in a memory. Several representations are possible
    for graphs, but here we are focussing on the three most commonly used representations:
    Adjacency Matrices, Adjacency Lists and Adjacency Multilists. Out of the several
    graph representations available, we choose any one of the available representation,
    depending on the application we have in mind and the functions we expect to perform
    on the graph. Adjacency Matrix By definition, it is a two – dimensional matrix
    of size VxV with 0’s and 1’s. Here, V represents the number of vertices a graph
    has. So, if we say that the entry in ith row and column, is 1, then it means that
    there is an edge available between i and j. Consider an undirected graph, with
    5 vertices, numbered as 0, 1, 2, 3, and 4\. ![](image-pmqg4b8g.jpg) The edges
    in the above graph determine that vertices are connected. Now, the corresponding
    adjacency matrix will be like this: ![](image-rie2jrag.jpg) All the 1’s in the
    matrix, indicate that the vertices are connected and all the 0’s indicates that
    the vertices are not connected. All the 0’s in the diagonal, indicates that there
    is no self-loop in the graph. Next observation about a graph is whether adjacency
    matrix is a symmetric matrix always. This will be true only when we have an undirected
    graph. Now, for a weighted graph where there is some weight associated with each
    edge, we can replace these 1’s with the weight of the edge. Following are the
    advantages of an adjacency matrix:  Easy to implement. Removing an edge takes
    O (1) time. For checking whether there is an edge from vertex u to v, it takes
    only O (1) time. Following are the disadvantages of an adjacency matrix:  Consumes
    more space (V x V). Adding a vertex is (V x V) time. Adjacency Lists As the name
    suggests, adjacency lists use an array of linked list to store a graph. Each node
    in an array corresponds to a node in a graph and the list attached with this index
    are its neighbour nodes. Consider the graph as shown below and its corresponding
    adjacency list: ![](image-0egyuhm4.jpg) Index 0 in the adjacency list shows the
    vertex 0\. We can see that vertex 0 is connected with vertices 1 and 4\. This
    is indicated in the adjacency list at index 0, following with a linked list containing
    two nodes containing 1 and 4\. Likewise, all the entries are being filled in the
    adjacency lists. Some of the advantages are as follows:  Save space O (|V| +|E|),
    where worst case is O (V x V). Adding a new vertex is easier. Some of the disadvantages
    are as follows:  Examining whether there is an edge from vertex u to vertex v,
    are not efficient and can be done in O(V) time. Adjacency Multi lists Consider
    a simple undirected graph G. ![](image-o6fmsoyf.jpg) Here, V(G) = {1, 2, 3, 4} And
    E(G) = {(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)} We are having one dimensional
    array containing 4 locations and we call that array as head nodes. Each node in
    the array corresponds to a node which is having the following structure: ![](image-wfd26qrf.jpg) Where
    M is a one-bit mark field that may be used to indicate whether or not the edge
    has been examined. The space requirements are the same as for normal adjacency
    lists except for the addition of the mark bit M. For the above graph, the adjacency
    multi list is as follows: ![](image-e69vd1g8.jpg) The lists are as follows: Vertex
    1: N1 -> N2 -> N3 Vertex 2: N1 -> N4 -> N5 Vertex 3: N2 -> N4 -> N6 Vertex 4:
    N3 -> N5 -> N64.18 Graph Traversals Explanation of Depth First Search (DFS) ![](image-bwc0oeiq.jpg) DFS
    requires a STACK. Let us start with vertex A. Push A on stack, then visit A and
    mark it as visited. ![](image-yvuh9vk2.jpg) Now, we have to identify all the unvisited
    vertices adjacent to A and these are B, D, and G. Out of these vertices, better
    to select that vertex that comes first in alphabetical order. Here, B comes first
    than D and G. So, we have to push B in stack and visit B and then mark it as visited. ![](image-u5pn88v3.jpg) Now,
    we have to identify all the unvisited vertices adjacent to B and these are E and
    F. Now, selecting E, push E in stack, visit E and then mark E as visited. ![](image-afjtgl7t.jpg) Now,
    we have to identify the unvisited vertices adjacent to E and the only vertex adjacent
    to E is G. So, push G in stack, visit G and Mark G as visited. ![](image-lodg54zg.jpg) Now,
    we have to identify the unvisited vertices adjacent to G and we find that all
    the vertices adjacent to G are already visited. Now we have to backtrack and pop
    up G from stack and look any unvisited vertices adjacent to E remaining or not.
    Since, E adjacent vertices have been visited, we pop up E from stack and the top
    same for B and stack now is B. check the same for B and now we found F as the
    node which is adjacent to B as well not visited also, so, push F in stack visit
    F and mark F as visited. ![](image-jhd436kf.jpg) Now, the top element in stack
    is F, so we have to identify all the unvisited vertices adjacent to F and we find
    these vertices are C and D. So we select C, push C in stack, visit C and then
    mark C as visited. ![](image-r88ou55y.jpg) Now, the top element in stack is C,
    so we have to identify all the unvisited vertices adjacent to C and we find H,
    push H in stack, visit H and mark it as visited. ![](image-gnh1f6l4.jpg) Since,
    H is on the top of stack now and no vertices are adjacent to H which are unvisited,
    so we have to backtrack. Pop H, then pop C and then we reach to F and we find
    one unvisited adjacent vertex for F and that is D. So, push D on stack, visit
    D and then mark D as visited. ![](image-x65s4klz.jpg) Since D does not contain
    any unvisited adjacent vertices anymore, Pop up D, then pop F, then B, then pop
    A and at last stack becomes empty. ![](image-rcfbhec1.jpg) The major difference
    between DFS and BFS is the data structure that is been used for supporting the
    traversals. In DFS, the supporting data structure is STACK and in case of BFS,
    the supporting data structure is QUEUE. We have to keep record of the vertices
    that we have to visit using QUEUE. The process of BFS starts by selecting any
    vertex as the staring vertex and here, we are selecting A as the vertex to start
    the traversal. So now mark A as visited. ![](image-aanlubxj.jpg) Now, we have
    to find those vertices which are adjacent to A as well not visited also. Here,
    these vertices are B, D, and G. We choose B as the next vertex to explore, as
    B comes first alphabetically. Now mark B as visited and then put B in Queue. ![](image-9k32couw.jpg) Now
    again moving to A, we have to find the next vertex connected to A alphabetically.
    And we found it is D. Now, mark D as visited and put D in Queue. ![](image-mnq8hetb.jpg) Again,
    moving to A, we have to find the next vertex connected to A alphabetically. And
    we found it is G. Now, mark G, as visited and put G in Queue. ![](image-3g2og3th.jpg) Moving
    to A to find the next vertex connected to A alphabetically, we found there is
    no such vertex available anymore, since all the adjacent vertices of A have already
    been visited. Now the next vertex to explore is B which is at the front of Queue.
    So, deque B from queue and find all the unvisited vertices from B and we found
    E. Visit E, mark E as visited and then put E in queue. ![](image-jna9ster.jpg) Now
    the next vertex to explore is D which is at the front of Queue. So, deque D from
    queue and find all the unvisited vertices from D and we found F. Visit F, mark
    F as visited and then put F in Queue. ![](image-onr3n313.jpg) Now the next vertex
    to explore is G at the front of the queue. So, deque G and since G has no unvisited
    adjacent vertices, G is said to be explored completely. ![](image-3n0gkju8.jpg) We
    have found the next vertex to explore as E, so deque E from Queue and since all
    its adjacent vertices have been visited, E is said to be explored completely. ![](image-l911z7mm.jpg) Now,
    the next vertex to explore is F, as F is the front element of queue. We have to
    find all the unvisited adjacent vertices of F, deque F and found C. So, now visit
    C, mark C as visited and put C in queue. ![](image-rcmcplha.jpg) Now the next
    vertex to explore is C, as C is the front element of queue. Deque C and then we
    have to find all the unvisited adjacent vertices of C and found H. So, now visit
    H, mark H as visited and put H in queue. ![](image-s091m136.jpg) Now, the next
    vertex to explore is H, as H is at the front of the queue. Deque H from queue
    and find all the unvisited adjacent vertices of H. We found no vertices are available
    anymore. And hence, our queue is also empty. That means, B F S is done successfully. ![](image-f1m8v2tm.jpg)Exercises Exercises
    Exercises Exercises Exercises Exercises Exercises Exercises Exercises ![](image-wpknlwui.jpg)'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '&#124; (a) &#124; B and E &#124; (b) &#124; C and D &#124;'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; B 和 E &#124; (b) &#124; C 和 D &#124;'
- en: '&#124; (c) &#124; A and E &#124; (d) &#124; C and B &#124;'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; A 和 E &#124; (d) &#124; C 和 B &#124;'
- en: '|'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Ans. (d)(d) (d) (d) (d) (d) (d) (d) (d) (d) (d) (d) (d) (d) ![](image-os3obvyq.jpg)
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 答案为 (d)(d) (d) (d) (d) (d) (d) (d) (d) (d) (d) (d) (d) (d) ![](image-os3obvyq.jpg)
- en: '|  |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '&#124; (a) &#124; GRAPH is a complete graph &#124;'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; 图是一个完全图 &#124;'
- en: '&#124; (b) &#124; GRAPH is an unconnected graph &#124;'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (b) &#124; 图是一个不连通的图 &#124;'
- en: '&#124; (c) &#124; The vertex connectivity of the graph is two. &#124;'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; 图的顶点连通度为二。 &#124;'
- en: '&#124; (d) &#124; The edge connectivity of the graph is one. &#124;'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (d) &#124; 图的边连通度为一。 &#124;'
- en: '|'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Ans. (c)
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 答案为 (c)
- en: '| 3. | How many edges are present in a graph which is a complete graph having
    n vertices?'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '| 3. | 一个具有 n 个顶点的完全图中有多少条边？'
- en: '&#124; (a) &#124; (n*(n+1))/2 &#124;'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; (n*(n+1))/2 &#124;'
- en: '&#124; (b) &#124; (n*(n-1))/2 &#124;'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (b) &#124; (n*(n-1))/2 &#124;'
- en: '&#124; (c) &#124; n &#124;'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; n &#124;'
- en: '&#124; (d) &#124; Information given is insufficient &#124;'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (d) &#124; 给定的信息不足 &#124;'
- en: '|'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Ans. (b)
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 答案为 (b)
- en: '| 4. | For a simple graph, the number of edges is twice the sum of the degrees
    of the vertices.'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '| 4. | 对于简单图，边的数量是顶点度数之和的两倍。'
- en: '&#124; (a) &#124; True &#124; (b) &#124; False &#124;'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; 正确 &#124; (b) &#124; 错误 &#124;'
- en: '|'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Ans. (b)
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 答案为 (b)
- en: '| 5. | Which of the following is correct?'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '| 5. | 以下哪项是正确的？'
- en: '&#124; (a) &#124; A graph contain no edges and many vertices &#124;'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; 图中不包含边且包含许多顶点 &#124;'
- en: '&#124; (b) &#124; A graph contain no vertices and many edges &#124;'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (b) &#124; 图中不包含顶点且包含许多边 &#124;'
- en: '&#124; (c) &#124; A graph contain no edges and no vertices &#124;'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; 图中不包含边且不包含顶点 &#124;'
- en: '&#124; (d) &#124; None of the mentioned &#124;'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (d) &#124; 以上都不是 &#124;'
- en: '|'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Ans. (b)
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 答案为 (b)
- en: '| 6. | When a graph contains vertices with equal degrees, is known as a __________'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '| 6. | 当图包含度相等的顶点时，被称为 __________'
- en: '&#124; (a) &#124; Multi Graph &#124; (b) &#124; Regular Graph &#124;'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; 多重图 &#124; (b) &#124; 正则图 &#124;'
- en: '&#124; (c) &#124; Simple Graph &#124; (d) &#124; Complete Graph &#124;'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; 简单图 &#124; (d) &#124; 完全图 &#124;'
- en: '|'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Ans. (b)(b) (b) (b) (b) (b) ![](image-sj7ub021.jpg)
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 答案为 (b)(b) (b) (b) (b) (b) ![](image-sj7ub021.jpg)
- en: '|   |'
  id: totrans-400
  prefs: []
  type: TYPE_TB
  zh: '|   |'
- en: '&#124; (a) &#124; True &#124; (b) &#124; False &#124;'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; 正确 &#124; (b) &#124; 错误 &#124;'
- en: '|'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Ans. (a)
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 答案为 (a)
- en: '| 8. | Among the following ways, which can be taken to represent a graph in
    memory?'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '| 8. | 在以下哪种方式中，可以用来表示内存中的图？'
- en: '&#124; (a) &#124; Adjacency Matrix and Adjacency List &#124;'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; 邻接矩阵和邻接表 &#124;'
- en: '&#124; (b) &#124; Matrix which is an incidence matrix &#124;'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (b) &#124; 是一个关联矩阵的矩阵 &#124;'
- en: '&#124; (c) &#124; Adjacency Matrix, Adjacency List and an Incidence Matrix
    &#124;'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; 邻接矩阵，邻接表和关联矩阵 &#124;'
- en: '&#124; (d) &#124; None of the above &#124;'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (d) &#124; 以上都不是 &#124;'
- en: '|'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Ans. (c)
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 答案为 (c)
- en: '| 9. | Adjacency matrix of all graphs is symmetric.'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '| 9. | 所有图的邻接矩阵都是对称的。'
- en: '&#124; (a) &#124; False &#124; (b) &#124; True &#124;'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; 错误 &#124; (b) &#124; 正确 &#124;'
- en: '|'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Ans. (a)
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 答案为 (a)
- en: '| 10. | The number of external nodes in a full binary tree with n internal
    nodes is?'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '| 10. | 一棵有 n 个内部节点的满二叉树中的外部节点数量是多少？'
- en: '&#124; (a) &#124; n &#124; (b) &#124; n+1 &#124;'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; n &#124; (b) &#124; n+1 &#124;'
- en: '&#124; (c) &#124; 2n &#124; (d) &#124; 2n + 1 &#124;'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; 2n &#124; (d) &#124; 2n + 1 &#124;'
- en: '|'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Ans. (b)
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：(b)
- en: '| 11. | The longest path containing number of edges from a given node to the
    leaf node is called _________ of the tree.'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '| 11. | 从给定节点到叶节点的包含边数最多的路径被称为树的_________。'
- en: '&#124; (a) &#124; Height &#124; (b) &#124; Depth &#124;'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; 高度 &#124; (b) &#124; 深度 &#124;'
- en: '&#124; (c) &#124; Length &#124; (d) &#124; None of the mentioned &#124;'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; 长度 &#124; (d) &#124; 上述都不是 &#124;'
- en: '|'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Ans. (a)
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：(a)
- en: '| 12. | Full binary tree is when:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '| 12. | 当:'
- en: '&#124; (a) &#124; Each node has zero or maximum of two child nodes. &#124;'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; 每个节点有零个或最多两个子节点。 &#124;'
- en: '&#124; (b) &#124; Each node has exactly two child nodes. &#124;'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (b) &#124; 每个节点恰好有两个子节点。 &#124;'
- en: '&#124; (c) &#124; All the leaves of the given full binary tress are at the
    level which is same. &#124;'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; 给定的满二叉树的所有叶子位于同一级别。 &#124;'
- en: '&#124; (d) &#124; Each node has exactly one or two child nodes. &#124;'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (d) &#124; 每个节点恰好有一个或两个子节点。 &#124;'
- en: '|'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Ans. (a)
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：(a)
- en: '| 13. | Which of the following is a disadvantage for trees?'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '| 13. | 以下哪项是树的一个缺点？'
- en: '&#124; (a) &#124; Hierarchical structure &#124;'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; 分层结构 &#124;'
- en: '&#124; (b) &#124; Faster search &#124;'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (b) &#124; 更快的搜索 &#124;'
- en: '&#124; (c) &#124; Router algorithms &#124;'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; 路由器算法 &#124;'
- en: '&#124; (d) &#124; Undo/Redo operations in a notepad &#124;'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (d) &#124; 记事本中的撤销/重做操作 &#124;'
- en: '|'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Ans. (d)
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：(d)
- en: '| 14. | What is the speciality about the in order traversal of a binary search
    tree?'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '| 14. | 二叉搜索树的中序遍历有什么特点？'
- en: '&#124; (a) &#124; It traverses in a non increasing order &#124;'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; 它以非递增的顺序遍历 &#124;'
- en: '&#124; (b) &#124; It traverses in an increasing order &#124;'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (b) &#124; 它以递增的顺序遍历 &#124;'
- en: '&#124; (c) &#124; It traverses in a random fashion &#124;'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; 它以随机的方式遍历 &#124;'
- en: '&#124; (d) &#124; None of the mentioned &#124;'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (d) &#124; 上述都不是 &#124;'
- en: '|'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Ans. (b)
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：(b)
- en: '| 15. | What is an AVL tree?'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '| 15. | AVL 树是什么？'
- en: '&#124; (a) &#124; a tree which is balanced and is a height balanced tree &#124;'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; 一棵平衡且是高度平衡树的树 &#124;'
- en: '&#124; (b) &#124; a tree which is unbalanced and is a height balanced tree
    &#124;'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (b) &#124; 一棵不平衡且是高度平衡树的树 &#124;'
- en: '&#124; (c) &#124; a tree with three children &#124;'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; 一个有三个子节点的树 &#124;'
- en: '&#124; (d) &#124; a tree with atmost 3 children &#124;'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (d) &#124; 最多有 3 个子节点的树 &#124;'
- en: '|'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Ans. (a)
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：(a)
- en: '| 16. | Weight balanced tree is?'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '| 16. | 权重平衡树是什么？'
- en: '&#124; (a) &#124; A binary tree that holds data related to sizes of all subtrees
    in each node &#124;'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; 一个二叉树，它保存每个节点中与所有子树大小相关的数据 &#124;'
- en: '&#124; (b) &#124; A binary tree which contains an additional information of
    weight &#124;'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (b) &#124; 包含额外权重信息的二叉树 &#124;'
- en: '&#124; (c) &#124; A height balanced binary tree &#124;'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; 一棵高度平衡的二叉树 &#124;'
- en: '&#124; (d) &#124; A normal binary tree &#124;'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (d) &#124; 一个普通的二叉树 &#124;'
- en: '|'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Ans. (a)
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 答案 (a)
- en: '| 17. | A node of the weight balanced tree has:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: '| 17. | 权重平衡树的节点具有：'
- en: '&#124; (a) &#124; key, left and right pointers, size &#124;'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; 关键字，左右指针，大小 &#124;'
- en: '&#124; (b) &#124; key, value &#124;'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (b) &#124; 关键字，值 &#124;'
- en: '&#124; (c) &#124; key, size &#124;'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; 关键字，大小 &#124;'
- en: '&#124; (d) &#124; key &#124;'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (d) &#124; 关键字 &#124;'
- en: '|'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Ans. (a)
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 答案 (a)
- en: '| 18. | Other name for directed graph is ……….?  |'
  id: totrans-467
  prefs: []
  type: TYPE_TB
  zh: '| 18. | 有向图的另一个名称是……？  |'
- en: '| 19. | Binary trees with threads are called as …….?  |'
  id: totrans-468
  prefs: []
  type: TYPE_TB
  zh: '| 19. | 带线索的二叉树称为……？  |'
- en: '| 20. | Graph G is ………….. if for any pair u, v of nodes in G there is a path
    from u to v or path from v to u. |'
  id: totrans-469
  prefs: []
  type: TYPE_TB
  zh: '| 20. | 图 G 是……如果对于 G 中的任意节点对 u，v，存在从 u 到 v 的路径或从 v 到 u 的路径。'
- en: '| 21. | What is a B tree? |'
  id: totrans-470
  prefs: []
  type: TYPE_TB
  zh: '| 21. | 什么是 B 树？ |'
- en: '| 22. | What are splay trees? |'
  id: totrans-471
  prefs: []
  type: TYPE_TB
  zh: '| 22. | 什么是伸展树？'
- en: '| 23. | Explain how we can find the depth of a binary tree? |'
  id: totrans-472
  prefs: []
  type: TYPE_TB
  zh: '| 23. | 解释如何找到二叉树的深度？ |'
- en: '| 24. | Explain pre-order and in-order tree traversal. |'
  id: totrans-473
  prefs: []
  type: TYPE_TB
  zh: '| 24. | 解释先序遍历和中序遍历树。 |'
- en: '| 25. | What is a B+ tree? Explain its uses. |'
  id: totrans-474
  prefs: []
  type: TYPE_TB
  zh: '| 25. | 什么是 B+ 树？解释其用途。 |'
- en: '| 26. | Define threaded binary tree. Explain its common uses |'
  id: totrans-475
  prefs: []
  type: TYPE_TB
  zh: '| 26. | 定义线索二叉树。解释其常见用途 |'
- en: '| 27. | Explain how binary tree traversal is implemented. |'
  id: totrans-476
  prefs: []
  type: TYPE_TB
  zh: '| 27. | 解释二叉树遍历是如何实现的。 |'
- en: '| 28. | Explain implementation of deletion from a binary tree. |'
  id: totrans-477
  prefs: []
  type: TYPE_TB
  zh: '| 28. | 解释从二叉树中删除的实现。'
- en: '| 29. | Explain the difference between Tree and Graph. |'
  id: totrans-478
  prefs: []
  type: TYPE_TB
  zh: '| 29. | 解释树和图的区别。'
- en: '| 30. | Which of the following is not true for a binary search tree?'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '| 30. | 以下哪一项对于二叉搜索树不正确？'
- en: '&#124; (a) &#124; The left child is always less than its parent node &#124;'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; 左子节点始终小于其父节点 &#124;'
- en: '&#124; (b) &#124; The right child node is greater than its parent node &#124;'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (b) &#124; 右子节点大于其父节点 &#124;'
- en: '&#124; (c) &#124; Individual subtrees, that is, the left and right sub-trees
    of any node should also be binary search trees &#124;'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; 每个节点的个别子树，即任何节点的左子树和右子树也应该是二叉搜索树 &#124;'
- en: '&#124; (d) &#124; None of the above. &#124;'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (d) &#124; 以上都不是。 &#124;'
- en: '|'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| 31. | Which among the following s said to be uique feature about the inorder
    traversal of a binary search tree?'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '| 31. | 以下哪一项被认为是二叉搜索树中中序遍历的独特特点？'
- en: '&#124; (a) &#124; It traverses in a non increasing order &#124;'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; 它以非递增的顺序遍历 &#124;'
- en: '&#124; (b) &#124; It traverses in an increasing order &#124;'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (b) &#124; 它以递增顺序遍历 &#124;'
- en: '&#124; (c) &#124; It traverses in a random fashion &#124;'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; 它以随机方式遍历 &#124;'
- en: '&#124; (d) &#124; None of the mentioned &#124;'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (d) &#124; 以上都不是 &#124;'
- en: '|'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| 32. | What is a full binary tree? |'
  id: totrans-491
  prefs: []
  type: TYPE_TB
  zh: '| 32. | 什么是满二叉树？'
- en: '| 33. | What is a complete binary tree? |'
  id: totrans-492
  prefs: []
  type: TYPE_TB
  zh: '| 33. | 什么是完全二叉树？ |'
- en: '| 34. | What is the time complexity for finding the height of the binary tree?  |'
  id: totrans-493
  prefs: []
  type: TYPE_TB
  zh: '| 34. | 查找二叉树高度的时间复杂度是多少？'
- en: '| 35. | In a simple graph, the number of edges is equal to twice the sum of
    the degrees of the vertices.'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: '| 35. | 在简单图中，边的数量等于顶点度数的两倍之和。'
- en: '&#124; (a) &#124; True &#124;'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; 是的 &#124;'
- en: '&#124; (b) &#124; False &#124;'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (b) &#124; 错误 &#124;'
- en: '|'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| 36. | Which of the following properties does a simple graph not hold?'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '| 36. | 简单图不具备以下哪种属性？'
- en: '&#124; (a) &#124; Must be connected &#124;'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; 必须连通 &#124;'
- en: '&#124; (b) &#124; Must be unweighted &#124;'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (b) &#124; 必须是无权的 &#124;'
- en: '&#124; (c) &#124; Must have no loops or multiple edges &#124;'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; 不能有环或多重边 &#124;'
- en: '&#124; (d) &#124; All of the mentioned &#124;'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (d) &#124; 所有提到的都是 &#124;'
- en: '|'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| 37. | Which of the following ways can be used to represent a graph?'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: '| 37. | 以下哪种方法可以用来表示图？'
- en: '&#124; (a) &#124; Adjacency List and Adjacency Matrix &#124;'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; 邻接表和邻接矩阵 &#124;'
- en: '&#124; (b) &#124; Incidence Matrix &#124;'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (b) &#124; 关联矩阵 &#124;'
- en: '&#124; (c) &#124; Adjacency List, Adjacency Matrix as well as Incidence Matrix
    &#124;'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; 邻接表、邻接矩阵以及关联矩阵 &#124;'
- en: '&#124; (d) &#124; None of the mentioned &#124;'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (d) &#124; 以上都不是 &#124;'
- en: '|'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| 38. | A graph with all vertices having equal degree is known as a __________'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: '| 38. | 所有顶点度数相等的图称为 __________'
- en: '&#124; (a) &#124; Multi Graph &#124;'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; 多重图 &#124;'
- en: '&#124; (b) &#124; Regular Graph &#124;'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (b) &#124; 正则图 &#124;'
- en: '&#124; (c) &#124; Simple Graph &#124;'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; 简单图 &#124;'
- en: '&#124; (d) &#124; Complete Graph &#124;'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (d) &#124; 完全图 &#124;'
- en: '|'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| 39. | For which of the following combinations of the degrees of vertices
    would the connected graph be eulerian?'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: '| 39. | 以下哪种顶点度数组合将得到欧拉连通图？'
- en: '&#124; (a) &#124; 1,2,3 &#124; (b) &#124; 2,3,4 &#124;'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; 1,2,3 &#124; (b) &#124; 2,3,4 &#124;'
- en: '&#124; (c) &#124; 2,4,5 &#124; (d) &#124; 1,3,5 &#124;'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; 2,4,5 &#124; (d) &#124; 1,3,5 &#124;'
- en: '|'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'MODULE VSearching and Sorting  CHAPTER 5 Searching and Sorting5.1 Searching A
    file comprises of records, where each record having one or more fields. The fields
    which are used to distinguish these records, are called keys. The key fields which
    are used for record identification will depend on the particular applications,
    because the same file can be utilised for several different applications. When
    there is a collection of records, there are at least two ways in which they are
    used to store them in memory: sequentially or non-sequentially. Let us assume,
    there is a sequential file F and we need to retrieve a record with a certain key
    value Suppose F has n number of records with the key informatiom stored in the
    record then one is able to carry out the retrieval by inspecting the key values
    Kn – 1, ..., in that order, until the correct record is located. Such a search
    process is known as sequential search, since the records are scrutinized linearly.5.1.1
    Procedure SEQSRCH (R, a file R containing key data ..., Kn for a record Ri such
    that K. If there is no such record found, then i is set to K0 ← K; i ← n While
    Ki ≠ K do i ← i – 1 end end SEQSRCH When a successful search is encountered, then
    the number of key comparisons made in such case, depends on the position where
    the concerned key has been placed in the file. If all keys present in the given
    file are unique and key Ki is being searched for, then – i + 1) key comparisons
    are made. If no such record is found in the file, then the file has key value
    K, which lead to i = 0, and the above algorithm requires + 1) comparisons. The
    average number of comparisons, which can occur in a successful search is, therefore,
    that is, ![](image-wjblcyez.jpg) For large n this many comparison is very inefficient.
    So, if the file is arranged in some predefined order, then one should be able
    to search for specific records quickly. One of the common methods available for
    searching an ordered linear file is called binary search. In this method, the
    search begins by inspecting the record in the middle of the file rather than the
    records present at either of the ends in linear search or sequential search. Let
    us assume that the file being searched is ordered in non-decreasing values of
    the key. Then, based on the results of the comparison with the middle key, the
    following conclusions are drawn:drawn: drawn: drawn: drawn: drawn: drawn: drawn:
    drawn: drawn: drawn: drawn: drawn: drawn: drawn: drawn: drawn: drawn: drawn: drawn:
    drawn: drawn: drawn: drawn: drawn: drawn: drawn:drawn: drawn: drawn: drawn: drawn:
    drawn: drawn: drawn: drawn: drawn: drawn: drawn: drawn: drawn:drawn: drawn: drawn:
    drawn: drawn: drawn: drawn: drawn: drawn: drawn: drawn: drawn: drawn: drawn: drawn:
    drawn: drawn: drawn: drawn: drawn: drawn: drawn: drawn: drawn: drawn: Consequently,
    after each comparison either the search terminates successfully or the size of
    the file remaining to be searched is about one half of the original size. Whereas,
    in the case of sequential search, after each comparison the size of the file remaining
    to the searched decreases by only 1\. Hence, in the worst case, this method requires
    O (log key comparisons to search a file.5.1.2 Procedure BINSRCH (F, n, i, K) //
    Search an ordered sequential file F with records ..., Rn and the keys £ K2 £ º
    £ Kn for a record Ri such that Ki – i – 0 if there is no such record else Ki=K// l
    u ← n while l ≤ u do m ← + // compute index of middle record // Case : K > Km
    : l ← m + 1 // look in upper half // : K = Km : i ← return : K < Km : u ← m –
    1 // look in lower half // End Case End While i ← 0 // no record with key K // end
    BINSRCH5.2 Fibonacci Search It is one of the searching methods which use the criteria
    other than equal setting for dividing the remaining file. So, the alternate method
    is Fibonacci search, which splits the sub file according to the Fibonacci sequence
    – 0,1, 1, 2, 3, 5, 8, 13, 21, ....... which is defined as F0 – 0, Fi – 1 and Fi
    – Fi – 1 + Fi – 2, i ≥2\. An advantage of Fibonacci search is that it involves
    only addition and subtraction rather than the division in the binary search. So,
    its average performance is better than that of binary search on computers for
    which division takes sufficiently more time than addition/subtraction.5.2.1 Procedure
    FIBSEARCH (G, n, i, x) // Search the sequencial file G, with keys ordered in non-decreasing
    order. For a record R, with = Assume that + m = n + 1, m ≥ 0 and + 1 > n + 1\.
    n is the number of records in G. and – 1 are consecutive fibonacci numbers. If
    x is not present, i is set to 0 // i = – p = – q = – 3 if x > // Set i so that
    size of the right subfile is i ← i + m while i ≠ 0 do case : x < if q = 0 , then
    i ← 0 else [ i ← i - q , t ← p , p ←q , q ← t – q ] : x = return : x > if p =
    1 then i ← 0 else [ i ← i + q , p ← p - q , q ← q – p ] end end end FIBSEARCH Fibonacci
    Search is a comparison-based technique that uses Fibonacci series to search an
    element in a sorted array. Similarities with Binary SearchSearch Search Search
    Search SearchSearch Search Search Search Search Differences with Binary SearchSearch
    Search Search Search Search Search Search Search Search Search Search Search Search
    Search Search Search Search SearchSearch Search Search Search Search Search Search
    Search Search Search Search Search Search Search Search Search Search Search Search
    Search Search Search Search Search Search Search Search SearchSearch Search Search
    Search Search Search Search Search Search Search Search Search Search Search Search
    Search Search Search Search Search Search Search Search Search Search Search Search
    Search Search Search Background Fibonacci Numbers are recursively defined as F(n)
    = F(n-1) + F(n-2), F(0) = 0, F(1) = 1\. First few fibonacci numbers are : 0, 1,
    1, 2, 3, 5, 8, 13, 21, 34, 55 … Algorithm Explanation Let A[1: n] be the sorted
    input array. Let the searched element be x. The idea is to first find the smallest
    Fibonacci number that is greater than or equal to the length of given array. Let
    the found Fibonacci number be – 1 – fibonacci number ). We use – fibonacci number
    as the index at which element x is to searched. That is fibonacci number – 3 be
    i, we compare A[i] with x, if x is same, we return it’s index i. Else if x is
    greater, we recur for subarray after i, else we recur for subarray before i. Below
    is the explanation of the complete algorithm: Let A[0..n – 1] be the input array
    and element to be searched be x.'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: '| 1. | Find the smallest Fibonacci Number greater than or equal to n. Let this
    number be *F**[k]* [– 1]. Let the two Fibonacci numbers preceding it be *F**[k]*
    [– 2]and *F**[k]* [– 3]. |'
  id: totrans-521
  prefs: []
  type: TYPE_TB
  zh: '| 1. | 找到大于或等于 n 的最小斐波那契数。让这个数字为 *F**[k]* [– 1]。让它之前的两个斐波那契数分别为 *F**[k]* [–
    2] 和 *F**[k]* [– 3]。 |'
- en: '| 2. | While the array has elements to be inspected: |'
  id: totrans-522
  prefs: []
  type: TYPE_TB
  zh: '| 2. | 当数组还有要检查的元素时： |'
- en: '| 3. | Compare x with the last element of the range covered by *F**[k]* [–
    3].'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: '| 3. | 将 x 与 *F**[k]* [– 3] 所覆盖的范围的最后一个元素进行比较。'
- en: '&#124; **1.** &#124; **If** x matches, return index &#124;'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; **1.** &#124; **如果** x 匹配，返回索引 &#124;'
- en: '&#124; **2.** &#124; **Else If** x is less than the element, move the three
    Fibonacci variables two Fibonacci down, indicating elimination of approximately
    rear two-third of the remaining array. &#124;'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; **2.** &#124; **否则如果** x 小于该元素，则将三个斐波那契变量向下移动两个斐波那契数，指示大约剔除了剩余数组的后三分之二。
    &#124;'
- en: '&#124; **3.** &#124; **Else** x is greater than the element, move the three
    Fibonacci variables one Fibonacci down. Reset offset to index. Together these
    indicate elimination of approximately front one-third of the remaining array.
    &#124;'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; **3.** &#124; **否则** x 大于该元素，则将三个斐波那契变量向下移动一个斐波那契数。将偏移量重置为索引。这些指示大约剔除了剩余数组的前三分之一。
    &#124;'
- en: '|'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'Illustration: Let us understand the algorithm with below example: ![](image-o6zccrlm.jpg) Consider
    the above array A of length (n) = 11, indexed from 1\. Let the searched element
    x = 85\. ![](image-10b0vr28.jpg) Let F be the array that contains the Fibonacci
    series. So, the smallest Fibonacci number that is greater than or equal to 11
    is 13\. Therefore, – 1 = 13, – 2 = 8, – 3 = 5\. The changes happening to these
    variables and the process of Fibonacci search is summarized in the table below: ![](image-i6xosr6t.jpg) ![](image-6dosc0ww.jpg) Thus
    element (x) = 85 is found at index 9\.5.3 Sorting Sorting methods are mainly characterized
    into a broad category:category: category:category: category: Internal methods
    are those methods to be used when the file to be sorted is small enough so that
    the entire sort can be carried out in main memory. External methods are those
    methods to be used on larger files. Examples of internal sorting methods are as
    follows:follows: follows:follows: follows:follows: follows:follows: follows:follows:
    follows:follows: follows:follows: follows: Examples of external sorting methods
    are as follows:follows: follows: follows:follows: follows: follows: • Internal
    Sorting Methods (1) Merge Sort This sorting technique uses the divide–and–conquer
    strategy. Here, we assume that the elements are to be sorted in non-decreasing
    order. Given a sequence of n elements (also called keys) the general idea is to
    split them into two sets a[2], º, and + 1], º, Each set is individually sorted,
    and the resulting sorted sequences are merged to produce a single sorted sequence
    of n elements. Algorithm MERGESORT describes this process using recursion and
    a function MERGE which merges two sorted sets. Algorithm MERGESORT (low, high) //a[low:
    high] is a global array to be sorted. If the array contains only one element then
    the list is already sorted. // { If < then { mid : = +  MERGESORT  MERGESORT (mid+1,
    high);  MERGE (low, mid, high);  } } Algorithm MERGE (low, mid, high) //a [low:
    high] is a global array containing 2 sorted subsets in [low: mid] and is a [mid
    + 1: high]. The goal is to merge these two sets into a single set residing in
    a [low: high]. B [ ] is an auxiliary global array// { i = j = While ≤ and ≤ do { If
    ≤ then { h + 1; } Else { = j = j + 1; } = } if > then for to high do {  } else for
    k: =h to mid do {  } for k: = low to high do : = } Analysis of Merge Sort If the
    time for the merging operation is proportional to n, then the computing time for
    merge sort is described by the recurrence relation: = n = 1, a is a constant +
    n > 1, c a constant When n is a power of 2, n = we can solve this equation by
    successive substitutions. = + + cn = + = + + ⋮ = + kcn = an + cn log n = O log ![](image-ne56eljm.jpg) Tree
    of calls of MERGESORT (1,10) ![](image-qtvy5141.jpg) Tree of calls of MERGE (1,5,10) Explanation
    of MERGE SORT Algorithm The following algorithms will help you to understand MERGE
    SORT more clearly and easily. MERGE (A, p, q, r) { (1) = q – p + 1 (2) = r – q (3)
    Let L and R [1 … + 1] be new arrays. (4) for (i = 1 to L[i] = A [p + i – 1] (5)
    for (j = 1 to R[j] = A[q + j] (6) L = ∞ (7) R = ∞ (8) i = 1, j = 1 (9) for (k
    = p to r) { if (L[i] ≤ R [j]) A[k] = L [i] i = i +1 else A[k] = R[j] j = j + 1 } And
    the merge-sort algorithm is as follows: Merge – sort (A, p, r) { if p < r q =
    [ (p + r)/2] merge – sort (A, p, q) merge – sort (A, q + 1, r) merge (A, p, q,
    r)} Merge sort is a sorting algorithm. Merge sort is supposed to be good in terms
    of time complexity. When compared to insertion sort and quick sort, merge sort
    is good sometimes. The heart of the merge-sort is a procedure called merging.
    So, let us explain first, what is happening in the merge algorithm. If input is
    given in an array, such that as shown below: ![](image-qqib4w26.jpg) In the above
    array, we can see that some elements are sorted. In this example, from index 1
    to 4, elements are sorted and from index 5 to 8, elements are sorted. But as a
    whole, elements are not sorted in the array. The array is actually containing
    two lists and these lists are sorted individually. Now, we have to merge these
    two lists in such a way that all the elements are sorted in the final list. Whenever
    an array A is given in such a way that elements from index p to q are sorted and
    elements from index q+1 to r are sorted. Now the job is to merge these two lists
    and make it a single sorted list. We have to create a new array L which will have
    exactly all the elements from p to q and its size must be one more than the total
    number of elements from p to q. Similarly, we have to create another array R which
    will have exactly all the elements from q+1 to r and its size must be one more
    than the total number of elements from q+1 to r. Now, we have to copy the elements
    from p to q in L and from q+1 to r in R. This copying is happening in statements
    4 and 5 respectively. The time taken to copy the elements from A to temporary
    arrays L & R is At the end of every list, we have to put a very large number and
    say we are putting ‘∞’ at the end. This is happening in statements 6 and 7\. ![](image-phzwrbjl.jpg) Now,
    we have to compare array L and array R. For that we need pointers to traverse
    the L and R array. Here, we are using i & j as pointers to traverse L & R respectively.
    Pointer i is initialised to the array index 1 and pointer j is initialised to
    the array index 1 of arrays L & R respectively. This initialisation is done in
    statement number statement 8\. In statement 9, for loop is doing the comparison
    of elements present in arrays L & R and the result is stored in array A. At the
    end of this for loop, array A will contain all the elements from L & R in sorted
    order. ![](image-4xl15tr0.jpg) Now, we have to understand how merge-sort algorithm
    works. Merge sort algorithm falls in the category called divide-and-conquer strategy.
    It means, if we have any problem of size n, we have to divide the problem of size
    n into sub problems and we have to solve the sub problems first and then combine
    the sub solutions of find a final solution to the given problem. Let us take an
    array A containing six elements and array index starts from 1\. And the array
    is as follows: Merge –sort works like the following: ![](image-vamfcs4r.jpg) (2)
    Quick Sort Procedure QSORT (m,n) //sort records Rn into non decreasing order on
    key Key Km is arbitrarily chosen as the canted key. Painters i & j are used to
    partition the sub file so that at any time £ l < i and ³ l > It is assumed that
    Km £ Kn + 1// if <then j K ← km loop repeat i ← i + 1 until Ki ≥ repeat j ← j
    – 1 until Kj ≥ if i < j then call INTERCHANGE else exit forever call INTERCHANGE call
    QSORT j – 1) call QSORT + 1, end QSORT. In quick sort, the division into two sub
    arrays is made so that the sorted sub arrays do not need to be merged later. This
    is accomplished by rearranging the elements in a [1:n] such that a[i] ≤ a[j] for
    all i between 1 & m and all j between m+1 and n for some m, 1 ≤ m ≤ Thus, the
    elements in a [1:m] and a [m+1: n] can be independently sorted. No merge is needed. The
    method is best stated recursively and where INTERCHANGE (x, y) performs t ← x;
    x ← y; y ← t Analysis of Quick sort The worst-case behaviour of this algorithm
    is examined and said to be Sometimes, each time a record is correctly positioned;
    the sub file to its left will be of the same size as that to its right. This would
    leave us with the sorting of two subfiles each of size roughly n/2\. The time
    required to position a record in a file of size n is If T is the time taken to
    sort a file of n records, then when the file splits roughly into two equal parts,
    each time a record is positioned correctly we have the following: T(n) ≤ cn +
    2T (n/2), for some constant ≤ cn + 2(cn/2 + 2T (n/4)) ≤ 2cn + 4T (n/4) ≤ cn =
    0 (n Explanation of QUICK SORT Algorithm Quick sort algorithm also follows the
    divide-and-conquer strategy. The main difference between merge sort and quick
    sort algorithm is that in merge sort, we know at which position the main list
    is going to get divided into two sub lists. But in quick sort we cannot identify
    the position at which division occurs prior to the process. As we know, the heart
    of the merge-sort algorithm is MERGE algorithm, similarly, the heart of the QUICK
    SORT algorithm is PARTITION algorithm. This algorithm is called QUICK sort algorithm,
    not because, this algorithm is faster than the other sorting algorithms available.
    The time complexity of quick sort is less when number of elements to sort is less.
    In case of merge-sort algorithm, if the number of elements to sort is less, the
    overhead for sorting is high, because merge-sort have lot of function calls. We
    have the following algorithm for quick-sort: PARTITION (A, p, r) { 1\. x = A[r] 2\.
    i = p – 1 3\. for (j = p to r – 1) { 4\. if (A[j] ≤ x) 5\. { i = i + 1 6\. Exchange
    A[i] with A[j] } } 7\. Exchange A[i+1] with A[r] 8\. Return i+1} QUICKSORT (A,p,r) { If
    (p < r) { q = PARTITION (A, p, r) QUICKSORT (A, p, q-1) QUICKSORT (A, q+1, r) } } Now
    we are going to sort the following elements stored in an array A. ![](image-h3i6731e.jpg) We
    are going to apply PARTITION algorithm and here p = 1 and r = Now executing our
    algorithm to sort the elements present in the given array. Here, x = A[8] = 7 This
    x is going to act as our pivot element and at the end of PARTITION algorithm,
    the element x = 7), is going to be placed at its correct position in the array
    forever. When it reaches its correct position in array, the original array get
    partitioned into two sublists, where all the elements to the left of x are less
    than x and all the elements to the right of x are greater than Here, two pointers
    are used i & j and i is initialised to 0 and j starts traversing the array from
    index 1\. Traversing of j starts at statement 3 in for loop. Here, j = 1, in for
    loop, if checking is done, and if condition becomes true, we have to increment
    the value of i and then exchange with When j = 2, if condition becomes true, so
    i = 1 and exchange A[1] and A[2] and our array looks like the following: ![](image-33w9uv8q.jpg) When
    j = 3, if condition becomes true, so i = 2 and exchange A[2] and A[3] and our
    array looks like the following: ![](image-815uuxkm.jpg) When j = 4, if condition
    becomes true, so i = 3 and exchange A[3] and A[4] and our array looks like the
    following ![](image-5tct88mm.jpg) When j = 6, if condition becomes true, so i
    = 4 and exchange A[4] and A[6] and our array looks like the following: ![](image-y31yxaek.jpg) When
    j = if condition becomes true, so i = 5 and exchange A[5] and A[7] and our array
    looks like the following ![](image-ajhw38bh.jpg) Now, exiting from the for loop,
    at statement 7, we have to exchange A[i+1] and i.e., A[6] and i.e., elements 9
    and 7 are to be exchanged and finally our array is like the following: ![](image-diap3f34.jpg) At
    this stage, we can see the element which was taken as the pivot element got its
    correct position in the array and thus, partitioning the original array into two
    sub lists, one list from index 1 to 5 and the other from index 7 to 8, such a
    way that all the elements to the left of 7 are less than 7 and all elements to
    the right of 7 are greater than 7\. The main algorithm to sort elements is the
    QUICKSORT algorithm and in this algorithm, PARTITION is being called. And this
    PARTITION algorithm is actually returning the array index ‘q’ which gives the
    position at which partitioning occurred. In our case, q = 6 and hence, then we
    have to call QUICKSORT (A,1,5) and QUICKSORT (A, 7, 8). Proceeding in the similar
    manner, the sub lists also get sorted. (3) Insertion Sort The basic step in this
    method is to insert a record R into a sequence of ordered records ≤ in such a
    way that the resulting sequence of size i+1 is also ordered. The following algorithm
    accomplishes this insertion. It assumes the existence of an artificial record
    with key = - 00 (i.e., all keys are ≥ Procedure INSORT (R, n) //sort the records
    ..., Rn in non decreasing value of the key K. Assume n > 1// K0 ← - 00 // create
    a dummy record R such that for j ← 2 to n do T←Rj Call INSERT (T, j-1)// insert
    records R2 to Rn//endend INSORT Procedure INSERT (R, i) //insert record R with
    key K into the ordered sequence R0, º,Ri in such a way that the resulting sequence
    is also ordered on key K. We assume that R0 is a record (may be a dummy) such
    that K ≥ K0//. j←i while K < Kj do // move Rj one space up as R is to be inserted
    left of Rj// Rj+1←Rj;j ← j – 1 end Rj+1 ← R end INSERT Example: Assuming n=5 &
    input sequence is (5,4,3,2,1), Then after each insertion we have the following: ![](image-f5ik6tr1.jpg) (4)
    Selection Sort As the name suggests, selection sort is the selection of an element
    and keeping it in sorted order. This is the simplest method of sorting in this
    method, to sort the data in ascending order; the element is compared with all
    other elements. If the element is found to be greater than the compared element,
    then they are interchanged. So after the first iteration, the smallest element
    is placed at the position. The same procedure is replaced for the element, and
    so on. This can be explained with the help of following figures: 25, 17, 31, 13,
    2\. ![](image-edwaico1.jpg) Analysis of Selection Sort As we have seen selection
    sort algorithm will search the smallest element in the array and that element
    will be at proper position. So in pass 1, it will compare (n-1) elements, same
    process will be for pass 2 but this time comparison will be (n-2), because element
    is already at proper position. The elements which are at correct position will
    not be disturbed. We can easily write functions for comparisons :as f = – + –
    + + + ... +3 + 2 + 1 This is arithmetic series in decreasing order, so applying
    the formula, Sum = n/2 [2a + (n-1) d] Where, n = number of elements in series, a
    = First element in series d = different between element and element or element
    – element. Hence, F(n) = (n-1)/2 [2(n-1) + {(n-1)-1} {(n-2) -(n-1)}] = (n-1)/2
    [2n-2 + (n-1-1) (n-2-n+1)] = (n-1)/2[2n-2+(n-2) (-1)] = (n-1)/2 [2n-2-n+2] = (n-1)/2
    (n) = n(n-1)/2 = O Since selection sort doesn’t see the order of elements, so
    its behaviour is near about same for best and worst case. The best thing with
    selection sort is that in every pass one element is in correct very fewer temporary
    variables is required to interchange the elements and it is simple to implement. Algorithm
    for selection sort /* initialize to SMALL with first array elemt.*/ 1\. SMALL
    = AR [L]; 2\. For I = L to U do 3\. SMALL = AR[I]; /*find smallest element & its 4\.
    For J = I to U do { 5\. If AR [J] < SMALL then { 6\. SMALL = AR[J] 7\. POS = J } 8\.
    J = J + 1 /*end of inner loop */ /*swap the smallest element with element4 9\.
    Temp = AR[I] 10\. AR [I] = SMALL 11\. AR [POS] = temp 12\. I = I + 1 } /* end
    of outloop*/ (5) Bubble Sort In this method to arrange elements in ascending order,
    to begin with, the element is compared with the element. If it is found to be
    greater than the element, then they are interchanged. Then the element is compared
    with the element, if it is found to be greater, then they are interchanged. In
    the same way all the elements (excluding last) are compared with their next element
    and are interchanged, if required. This is the interaction and on completing this
    iteration, the largest element gets placed at the last position. Similarly, in
    the second iteration, the comparisons are made and the largest element gets placed
    at the last position in list. As a result, after all the iterations the list becomes
    a sorted list. The iterations are shown in the following figures: ![](image-ptzb7x07.jpg) Analysis
    of Bubble Sort In bubble sort (n-1) comparisons will be in pass, (n-2) comparisons
    in pass, and so on. It is very simple to calculate the no. Of comparisons, total
    no. of comparisons will be as follows: (n-1) + (n-2) +, - .. + 2 + 1 F(n) = (n-1)
    + (n-2) + - - - + 2 + 1 It is a form of arithmetic progression series so we can
    apply formula. Sum = n/2 [2a + (n-1)d] /*replace with (n-1)*/ F(n) = (n-1)/2 [2(n-1)
    + {[(n-1)-1]*[(n-2)-(n-1)]}] = Algorithm to bubble sort array AR[L:U] 1\. For
    I = L to U 2\. { 3\. For J = L to U-1 4\. { 5\. If AR [J] > AR [J+1] then 6\.
    { /*swap the values*/ 7\. Temp = AR [J] 8\. AR [J] = AR[J+1] 9\. AR[J+1] = temp 10\.
    } /+end of if */ 11\. J = J+1 12\. } /* end of inner loop */ 13\. I = I + 1 14\.
    } /* end of outer loop*/ Explanation of Heap Sort The elements of the heap tree
    are represented by an array. The root will be largest element of heap tree. Since
    it is maintained in the array, so the largest value should be the last element
    of array. For heap sorting we will keep on deleting the root till there is only
    one element in the tree. Then, the array which represented the heap tree will
    now contain sorted elements. For heap sorting, following steps are follows:follows:
    follows: follows: follows: follows: follows: follows: follows: follows:follows:
    follows: follows: follows: follows: follows: follows: follows: follows: follows:
    follows: follows: follows: follows: follows: follows: follows: follows: follows:
    follows: follows: follows: follows: follows: Let us take a heap tree and apply
    heap tree sorting: ![](image-15ihp6i2.jpg) Step 1 : ![](image-6asbr74e.jpg) Before
    replacing the root node with the last node of the tree, we have to convert it
    into a heap tree. For that, we have to do some replacements. Since, 64 and 65
    are greater than 48 and 64 is the left child of 48 and 65 is the right child of
    48 and 65 is greater than left child 64, hence replace it with right child 65\. ![](image-u8crbkef.jpg) Here
    right child of 48 is 54, which is greater than 48, hence replace it with 54\. ![](image-m8rn3jze.jpg) Now
    our tree becomes a heap tree, so now we have to replace the root node with the
    last node of the tree and then our array will look like the following: ![](image-u48r52gs.jpg) Step ![](image-san3xlmv.jpg) Connect
    this tree into a heap tree, for that, do the necessary replacements. Here, left
    child of 29 is 64 and right child of 29 is 48 and since, left child is greater
    than right child, so, 64 and 29 get interchanged. Now, the tree looks like the
    following: ![](image-av7oj3ac.jpg) Here, left child of 29 is 56 and right child
    of 29 is 32 and since 56 is greater than 32, replace 29 and 56\. Now, the tree
    looks like the following: ![](image-gf2swkyn.jpg) Here, we can see the left child
    of 48 is 46 and right child of 48 is 54 and since, 54 is greater than 48, so we
    have to replace 48 and 54\. Now, the tree looks like the following: ![](image-qwtc5f6v.jpg) Now,
    this tree is a heap tree. Replace the root with the last node of the heap tree
    in array. So, the array is as follows: ![](image-vxaugfy0.jpg) Step Now the tree
    looks like the following: ![](image-386ywj5f.jpg) Here, the left child of 48 is
    56 and the right child of 48 is 54, and here 56 is greater than 48, so we have
    to replace 48 and 56\. Now, the tree looks like this: ![](image-7itnvn9e.jpg) Since,
    this tree is a heap tree. So the heap tree in array looks like the following: ![](image-01aw1b7d.jpg) Replace
    the element at root position with the last node of the tree in array. ![](image-1pr83ahj.jpg) Step
    4 : ![](image-fbp9s3cq.jpg) The left child of 46 is 48 and right child of 46 is
    54, and hence, 54 is greater than 46, so we have to replace 46 and 54, to convert
    it to a heap tree. Now, the tree looks like the following: ![](image-iur1rnm9.jpg) Now,
    the heap tree is ready. So replace the root node with the last node of the tree.
    And the heap trees in array look like the following: ![](image-86przvno.jpg) Step ![](image-ofrmdlx2.jpg) Here,
    left child of 32 is 48 and the right child of 32 is 46\. Since 48 is greater than
    32\. We have to replace, 32 and 48, to convert this tree into a heap tree. Now,
    the heap tree is a follows: ![](image-nq5fmh9y.jpg) Now, replace the root node
    with the last node of the tree. Now, the heap tree in array looks like the following: ![](image-xpj152hu.jpg) Step ![](image-fp4k6usk.jpg) The
    left child of 29 is 32 and the right child of 29 is 46\. Since 46 is greater than
    29, we have to replace 29 and 46, to convert the above tree to a heap tree. Now
    the tree looks like the following: ![](image-bajxg1u4.jpg) Its representation
    in array is like the following: ![](image-qg3av5cq.jpg) Replace the root node
    with the last node in tree. ![](image-ha2hzu99.jpg) Step ![](image-3xikbyr0.jpg) Since,
    the above figure is not a heap tree, so we have to convert it into a heap tree.
    The left child of 29 is 32 and since, the left child is greater than the root
    node, we have to interchange these two nodes to make it a heap tree. Now, the
    heap tree is as follows: ![](image-pnsam4s9.jpg) It’s representation as an array
    is like the following: ![](image-af04a2kf.jpg) Now we have to replace the root
    node with its left child node (here 29): ![](image-ukov5xuy.jpg) Step ![](image-g241txu4.jpg) The
    single node tree is a heap tree. And, so represent this node in array and the
    heap tree in array looks like the following: ![](image-nzsxn62a.jpg) Hence, our
    heap sorting has sorted the given elements in an increasing order.Exercises'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 'Illustration: 让我们通过下面的示例来理解算法：![](image-o6zccrlm.jpg) 考虑上述长度为（n）= 11 的数组 A，索引从
    1 开始。让搜索的元素 x = 85。![](image-10b0vr28.jpg) 让 F 是包含斐波那契数列的数组。因此，大于或等于 11 的最小斐波那契数是
    13。因此，- 1 = 13，- 2 = 8，- 3 = 5。下表总结了这些变量的变化以及斐波那契搜索的过程：![](image-i6xosr6t.jpg)
    ![](image-6dosc0ww.jpg) 因此，元素 (x) = 85 被找到在索引 9\.5.3。排序。排序方法主要分为以下几类：内部方法是当要排序的文件足够小以至于整个排序可以在主存储器中完成时要使用的方法。外部方法是用于更大文件的方法。内部排序方法的示例如下：外部排序方法的示例如下：'
- en: '| 1. | Which of the following sorting algorithms has the lowest worst-case
    complexity?'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: '| 1. | 以下哪种排序算法具有最低的最坏情况复杂度？'
- en: '&#124; (a) &#124; Merge Sort &#124; (b) &#124; Bubble Sort &#124;'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; Merge Sort &#124; (b) &#124; Bubble Sort &#124;'
- en: '&#124; (c) &#124; Quick Sort &#124; (d) &#124; Selection Sort &#124;'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; Quick Sort &#124; (d) &#124; Selection Sort &#124;'
- en: '|'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Ans. (a)
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: Ans. (a)
- en: '| 2. | If the number of records to be sorted is small, then …… sorting can
    be efficient.'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: '| 2. | 如果要排序的记录数量很少，那么……排序可能是高效的。'
- en: '&#124; (a) &#124; Merge &#124; (b) &#124; Heap &#124;'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; Merge &#124; (b) &#124; Heap &#124;'
- en: '&#124; (c) &#124; Selection &#124; (d) &#124; Bubble &#124;'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; Selection &#124; (d) &#124; Bubble &#124;'
- en: '|'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Ans. (c)
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: Ans. (c)
- en: '| 3. | The complexity of sorting algorithm measures the …… as a function of
    the number n of items to be sorter.'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: '| 3. | 排序算法的复杂度衡量……作为要排序的 n 个项的函数。'
- en: '&#124; (a) &#124; average time &#124; (b) &#124; running time &#124;'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; average time &#124; (b) &#124; running time &#124;'
- en: '&#124; (c) &#124; average-case complexity &#124; (d) &#124; case-complexity
    &#124;'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; average-case complexity &#124; (d) &#124; case-complexity
    &#124;'
- en: '|'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Ans. (b)
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: Ans. (b)
- en: '| 4. | The complexity of bubble sort algorithm is …..'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: '| 4. | 冒泡排序算法的复杂度是……'
- en: '&#124; (a) &#124; O (n) &#124; (b) &#124; O(logn) &#124;'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; O (n) &#124; (b) &#124; O(logn) &#124;'
- en: '&#124; (c) &#124; O(n2) &#124; (d) &#124; O(n logn) &#124;'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; O(n2) &#124; (d) &#124; O(n logn) &#124;'
- en: '|'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Ans. (c)
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: Ans. (c)
- en: '| 5. | Finding the location of a given item in a collection of items is called
    ……'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: '| 5. | 在集合中找到给定项目的位置称为……'
- en: '&#124; (a) &#124; Discovering &#124; (b) &#124; Finding &#124;'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; Discovering &#124; (b) &#124; Finding &#124;'
- en: '&#124; (c) &#124; Searching &#124; (d) &#124; Mining &#124;'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; Searching &#124; (d) &#124; Mining &#124;'
- en: '|'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Ans. (c)
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: Ans. (c)
- en: '| 6. | Which of the following is an external sorting?'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: '| 6. | 以下哪项是外部排序？'
- en: '&#124; (a) &#124; Insertion Sort &#124; (b) &#124; Bubble Sort &#124;'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; Insertion Sort &#124; (b) &#124; Bubble Sort &#124;'
- en: '&#124; (c) &#124; Merge Sort &#124; (d) &#124; Tree Sort &#124;'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; Merge Sort &#124; (d) &#124; Tree Sort &#124;'
- en: '|'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Ans. (c)
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: Ans. (c)
- en: '| 7. | The total number of comparisons in a bubble sort is ….'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: '| 7. | 冒泡排序中的总比较次数是……'
- en: '&#124; (a) &#124; O (n logn) &#124; (b) &#124; O(2n) &#124;'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; O (n logn) &#124; (b) &#124; O(2n) &#124;'
- en: '&#124; (c) &#124; O(n2) &#124; (d) &#124; O(n) &#124;'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; O(n2) &#124; (d) &#124; O(n) &#124;'
- en: '|'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Ans. (a)
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: Ans. (a)
- en: '| 8. | Merging k sorted tables into a single sorted table is called ……'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: '| 8. | 将 k 个已排序的表合并成一个单一的排序表称为……'
- en: '&#124; (a) &#124; k way merging &#124; (b) &#124; k th merge &#124;'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; k way merging &#124; (b) &#124; k th merge &#124;'
- en: '&#124; (c) &#124; k+1 merge &#124; (d) &#124; k-1 merge &#124;'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; k+1 merge &#124; (d) &#124; k-1 merge &#124;'
- en: '|'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Ans. (a)
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: Ans. (a)
- en: '| 9. | Sorting a file F usually refers to sorting F with respect to a particular
    key called …..'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: '| 9. | 对文件 F 进行排序通常指的是根据一个称为……的特定键对 F 进行排序。'
- en: '&#124; (a) &#124; Basic key &#124; (b) &#124; Primary key &#124;'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; Basic key &#124; (b) &#124; Primary key &#124;'
- en: '&#124; (c) &#124; Starting key &#124; (d) &#124; Index key &#124;'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; Starting key &#124; (d) &#124; Index key &#124;'
- en: '|'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Ans. (b)
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: Ans. (b)
- en: '| 10. | If the number of records to be sorted is large and the key is long,
    then …… sorting can be efficient.'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: '| 10. | 如果要排序的记录数很大且键值很长，则……排序可以很有效率。'
- en: '&#124; (a) &#124; Merge &#124; (b) &#124; Heap &#124;'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; 合并 &#124; (b) &#124; 堆 &#124;'
- en: '&#124; (c) &#124; Quick &#124; (d) &#124; Bubble &#124;'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; 快速 &#124; (d) &#124; 冒泡 &#124;'
- en: '|'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Ans. (c)
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 答案 (c)
- en: '| 11. | The function used to modify the way of sorting the keys of records
    is called ……..'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: '| 11. | 用于修改记录键排序方式的函数称为……..'
- en: '&#124; (a) &#124; Indexing function &#124; (b) &#124; Hash function &#124;'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; 索引函数 &#124; (b) &#124; 哈希函数 &#124;'
- en: '&#124; (c) &#124; Addressing function &#124; (d) &#124; All of the above &#124;'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; 寻址函数 &#124; (d) &#124; 以上全部 &#124;'
- en: '|'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Ans. (b)
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 答案 (b)
- en: '| 12. | Which of the following sorting algorithm is of divide and conquer type?'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: '| 12. | 以下哪种排序算法属于分而治之类型？'
- en: '&#124; (a) &#124; Bubble sort &#124; (b) &#124; Insertion sort &#124;'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; 冒泡排序 &#124; (b) &#124; 插入排序 &#124;'
- en: '&#124; (c) &#124; Quick sort &#124; (d) &#124; Merge sort &#124;'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; 快速排序 &#124; (d) &#124; 归并排序 &#124;'
- en: '|'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Ans. (c)
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 答案 (c)
- en: '| 13. | ………. sorting is good to use when alphabetizing large list of names.'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: '| 13. | ……….排序适用于对大量姓名进行字母排序。'
- en: '&#124; (a) &#124; Merge &#124; (b) &#124; Heap &#124;'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; 合并 &#124; (b) &#124; 堆 &#124;'
- en: '&#124; (c) &#124; Radix &#124; (d) &#124; Bubble &#124;'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; 基数 &#124; (d) &#124; 冒泡 &#124;'
- en: '|'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Ans. (c)
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 答案 (c)
- en: '| 14. | The operation that combines the element is of A and B in a single sorted
    list C with n = r + s element is called ….'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: '| 14. | 将元素 A 和 B 合并成一个单独的排序列表 C，其中 n = r + s 元素的操作称为……。'
- en: '&#124; (a) &#124; Inserting &#124; (b) &#124; Mixing &#124;'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; 插入 &#124; (b) &#124; 混合 &#124;'
- en: '&#124; (c) &#124; Merging &#124; (d) &#124; Sharing &#124;'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; 合并 &#124; (d) &#124; 分享 &#124;'
- en: '|'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Ans. (c)
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 答案 (c)
- en: '| 15. | Quick sort is also known as ……..'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: '| 15. | 快速排序也称为……..'
- en: '&#124; (a) &#124; merge sort &#124; (b) &#124; tree sort &#124;'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; 归并排序 &#124; (b) &#124; 树排序 &#124;'
- en: '&#124; (c) &#124; shell sort &#124; (d) &#124; partition and exchange sort
    &#124;'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; 希尔排序 &#124; (d) &#124; 分区和交换排序 &#124;'
- en: '|'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Ans. (d)
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 答案 (d)
- en: '| 16. | A pivot element to partition unsorted list is used in.'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: '| 16. | 用于分区未排序列表的主元素用于。'
- en: '&#124; (a) &#124; Merge Sort &#124; (b) &#124; Quick Sort &#124;'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; 归并排序 &#124; (b) &#124; 快速排序 &#124;'
- en: '&#124; (c) &#124; Insertion Sort &#124; (d) &#124; Selection Sort &#124;'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; 插入排序 &#124; (d) &#124; 选择排序 &#124;'
- en: '|'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Ans. (b)
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 答案 (b)
- en: '| 17. | Which from following technique is used for finding a value in an array?'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: '| 17. | 以下哪种技术用于在数组中查找值？'
- en: '&#124; (a) &#124; Bubble sort &#124; (b) &#124; Binary search algorithm &#124;'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; 冒泡排序 &#124; (b) &#124; 二分查找算法 &#124;'
- en: '&#124; (c) &#124; Linear search algorithm &#124; (d) &#124; All of them &#124;'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; 线性搜索算法 &#124; (d) &#124; 以上全部 &#124;'
- en: '|'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Ans. (d)
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 答案 (d)
- en: '| 18. | Which of the following is not a stable sorting algorithm?'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: '| 18. | 以下哪种不是稳定的排序算法？'
- en: '&#124; (a) &#124; Insertion sort &#124; (b) &#124; Selection sort &#124;'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; 插入排序 &#124; (b) &#124; 选择排序 &#124;'
- en: '&#124; (c) &#124; Bubble sort &#124; (d) &#124; Merge sort &#124;'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; 冒泡排序 &#124; (d) &#124; 归并排序 &#124;'
- en: '|'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Ans. (b)
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：(b)
- en: '| 19. | The time complexity of heap sort in worst case is'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: '| 19. | 堆排序的最坏情况时间复杂度是多少？'
- en: '&#124; (a) &#124; O (logn) &#124; (b) &#124; O (n) &#124;'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; O (logn) &#124; (b) &#124; O (n) &#124;'
- en: '&#124; (c) &#124; O(nlogn) &#124; (d) &#124; O(n²) &#124;'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; O(nlogn) &#124; (d) &#124; O(n²) &#124;'
- en: '|'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Ans. (c)
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：(c)
- en: '| 20. | Counting sort performs …………. Numbers of comparisons between input elements.'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: '| 20. | 计数排序执行……输入元素之间的比较次数。'
- en: '&#124; (a) &#124; 0 &#124; (b) &#124; n &#124;'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; 0 &#124; (b) &#124; n &#124;'
- en: '&#124; (c) &#124; nlogn &#124; (d) &#124; n² &#124;'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; nlogn &#124; (d) &#124; n² &#124;'
- en: '|'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Ans. (a)
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：(a)
- en: '| 21. | A sorting technique is called stable if it'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: '| 21. | 如果排序技术是稳定的，则它'
- en: '&#124; (a) &#124; Takes O (nlogn) times &#124;'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; 需要 O (nlogn) 次 &#124;'
- en: '&#124; (b) &#124; Maintains the relative order of occurrence of non-distinct
    elements &#124;'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (b) &#124; 维护非不同元素的出现顺序 &#124;'
- en: '&#124; (c) &#124; Uses divide-and-conquer paradigm &#124;'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; 使用分治范式 &#124;'
- en: '&#124; (d) &#124; Takes O (n) space &#124;'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (d) &#124; 需要 O (n) 空间 &#124;'
- en: '|'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Ans. (b)
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：(b)
- en: '| 22. | Which of the following algorithms has lowest worst case time complexity?'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: '| 22. | 以下哪种算法具有最低的最坏情况时间复杂度？'
- en: '&#124; (a) &#124; Insertion sort &#124; (b) &#124; Selection sort &#124;'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; 插入排序 &#124; (b) &#124; 选择排序 &#124;'
- en: '&#124; (c) &#124; Quick sort &#124; (d) &#124; Heap sort &#124;'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; 快速排序 &#124; (d) &#124; 堆排序 &#124;'
- en: '|'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Ans. (d)
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：(d)
- en: '| 23. | What is the disadvantage of selection sort?'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: '| 23. | 选择排序的缺点是什么？'
- en: '&#124; (a) &#124; It requires auxiliary memory &#124;'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; 它需要辅助内存 &#124;'
- en: '&#124; (b) &#124; It is not scalable &#124;'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (b) &#124; 它不可扩展 &#124;'
- en: '&#124; (c) &#124; It can be used for small keys &#124;'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; 它可以用于小键值 &#124;'
- en: '&#124; (d) &#124; None of the mentioned &#124;'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (d) &#124; 以上都不是 &#124;'
- en: '|'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'Ans. (b) Short Answer Questions Questions Questions Questions Questions Questions
    Questions QuestionsQuestions Questions Questions Questions Questions QuestionsQuestions
    Questions Questions Questions Questions Questions Questions Questions QuestionsQuestions
    Questions Questions Questions Questions Questions Questions QuestionsQuestions
    Questions Questions Questions Questions Questions QuestionsQuestions Questions
    Questions Questions Questions Questions QuestionsQuestions Questions Questions
    Questions Questions QuestionsQuestions Questions Questions Questions Questions
    Questions QuestionsQuestions Questions Questions Questions Questions Questions
    Questions QuestionsQuestions Questions Questions Questions QuestionsQuestions
    Questions Questions Questions Questions Questions Questions Long Answer Questions Questions
    Questions Questions Questions Questions Questions Questions Questions Questions
    Questions QuestionsQuestions Questions Questions Questions Questions Questions
    QuestionsQuestions Questions Questions Questions Questions QuestionsQuestions
    Questions Questions Questions Questions Questions Questions Questions Questions
    QuestionsQuestions Questions Questions Questions Questions Questions Questions
    Questions QuestionsQuestions Questions Questions Questions Questions Questions
    Questions Questions Questions QuestionsQuestions Questions Questions Questions
    Questions QuestionsQuestions Questions Questions Questions Questions Questions
    Questions QuestionsQuestions Questions Questions Questions Questions Questions
    QuestionsQuestions Questions Questions Questions QuestionsQuestions Questions
    Questions Questions QuestionsQuestions Questions Questions Questions QuestionsQuestions
    Questions Questions Questions QuestionsQuestions Questions Questions Questions
    QuestionsQuestions Questions Questions Questions Questions Questions Questions
    QuestionsQuestions Questions Questions Questions Questions Questions Questions
    Questions MODULE VIGreedy Method  CHAPTER 6 Greedy Method6.1 The Greedy Method:
    Basic Concepts This is one of the approaches for solving problem. As we have,
    divide and conquer approach, this design is also used to solve a problem. Let
    us understand what this method says. This method is used for solving an optimization
    problem. What are optimization problems? A problem which demands either minimum
    result or maximum result. So, for this, let us know few terms, which are explained
    through an example, given below. Suppose, there is a problem P. And the problem
    says, I have to travel from city A to city B. I have to complete this journey
    and this is going to be my problem. For this problem, I may have many solutions. P:
    A ⟶ B; where P is problem, A and B indicate cities. I can complete the journey
    by walk, let it be solution one, S1, or I can take a bike, solution two, S2, or
    I can take a car, solution three, S3, or I can take a train, solution four, S4,
    or I can take an aeroplane, solution five, S5\. We can see that, for a particular
    problem P, there are many solutions, S1, S2, S3, S4, S5, ….Sn. I can take any
    solution to solve the problem, if I do not have any constraints. But here I have
    one constraint or restriction, that says that I must complete the journey in 12
    hours. Then, out of many solutions available, let solutions S4 and S5 satisfy
    the given constraint. S4 is taking a train and S5 is taking an aeroplane to complete
    the journey. Here, solutions S4 and S5, are said to be feasible solutions, as
    they are the solutions which satisfy the given constraints of the mentioned problem. So,
    a feasible solution is defined as a solution which satisfies the condition given
    in the problem (though for a given problem, we might have many solutions). Now,
    if I say that I want to complete this journey in minimum cost. That is, I want
    to spend less amount as much as possible, then the given problem becomes a minimization
    problem. As the problem demands, the result should be minimum, then such problems
    come under minimization problem. Suppose, out of the two feasible solutions S4
    and S5, one of the solutions gives the minimum cost to complete the journey. Let
    that solution be S4\. Then, this solution S4 is called as an optimal solution. So,
    an optimal solution is defined as a solution which is a feasible solution, also
    giving me the best result. Definitely, for any problem there can be only one optimal
    solution. There can be a number of solutions, also there can be more than one
    feasible solution, but, all the time, problem will have only one optimal solution. This
    problem requires minimum result and some other problem requires maximum result.
    So, if a problem requires either minimum or maximum results, then we call that
    type of problem as an Optimization Problem. We can also say in other words that,
    an optimization problem requires either minimum result or maximum result. So,
    the greedy method is used for solving the optimization problem. Here is the general
    method of greedy technique. The control abstraction of the greedy approach is
    given as follows: Algorithm GREEDYMETHOD (g, m) { for i = 1 to m do { y = SELECT
    (m); if FEASIBLE (y) then SOLUTION = SOLUTION + y; } } Greedy method says that
    a problem should be solved in stages. In each stage, we will consider one input
    from a given problem and if that input is feasible, then we will include that
    into the solution. So, by including all those feasible inputs, we will get an
    optimal solution. So, in stages, each time we will take up an input and we consider
    it and if it is feasible, we will include it and like this, the procedure follows,
    and at the end, we will get an optimal solution. Let us take one example of our
    real life and understand the concept of the greedy technique, which we usually
    apply to solve the real-life problem. Suppose, the problem is to purchase a mobile
    phone online. For that, what should we normally do? We search different brands
    of mobile phones available in the online market. To check each mobile phone of
    every brand online is a difficult task. For ease the task, we shorten the available
    list by brands that we like most. Suppose, we need to check only Mi and Samsung
    brands. This itself has shorten the list by a huge amount. Now, we have to search
    mobile phones under these brands only. To again ease the task of searching, we
    try to put one more constraint, that is, check mobile phones whose costs is between
    Rs5000 – Rs10000/-. Satisfying all the constraints we put, we purchase a mobile
    phone for ourselves. The strategy that we followed here is the greedy technique.
    And this method is known to all of us. When we follow a known approach to solve
    a problem, that approach comes under the greedy technique. The mobile phone that
    we have purchased at the last, is not going to be the best among all mobile phones
    available in the market. But, since it has satisfied all the constraints that
    I have put before purchasing a mobile phone, this phone is going to be the best
    phone for me. Among all the algorithmic approaches available, the easiest and
    straightforward approach is the greedy method. Here, the decision what we take
    is on the basis of current scenario, without worrying, about its effect in future. In
    many situations, it is not going to produce an optimal solution, though it gives
    an approximate solution in a reasonable time.6.2 Minimum – Cost Spanning Trees Assume,
    G’ = (V, E) be a undirected connected graph. A subgraph, m = (V, E’) of G’ is
    a spanning tree of G’ if and only if, m is a tree. Here, we have a graph G = (V,
    E) where, V is the set of vertices and E is the set of edges. For the following
    figure: ![](image-2nhm0ofr.jpg) V = {1, 2, 3, 4, 5, 6} E = {(1, 2), (2, 3), (3,
    4), (4, 5), (5, 6), (1, 6)} Spanning tree is defined as a subgraph of a graph.
    For this, we have to take the subset of graph G. To construct a spanning tree,
    we have to take the subset of edges only. Vertices must be as it is. Spanning
    tree means all vertices remain the same. ![](image-vnmet3ff.jpg) Number of vertices,
    |V| = n = 6 Number of edges, |E| = |V| - 1 = 5 Therefore, spanning tree is defined
    as a subgraph of graph G, having all vertices of graph G and (n – 1) edges. So
    out of available edges (here 6 edges), we can take only 6 – 1 = 5 edges only. The
    spanning tree doesn’t contain any cycle. ![](image-6upnoqpb.jpg) To construct
    a spanning tree for a given graph G, we can select any edge to construct a spanning
    tree. Selecting an edge completely depends upon our choice. Let’s suppose S is
    a subgraph of G, that is, S C G, where S = (V’, E’) and V’ = V Therefore, the
    number of edges, |E| = |V| - 1 Now, the question is how many different spanning
    trees are possible for a given graph, G. For the above drawn graph G, number of
    edges is 6\. In a spanning tree, we can take only 5 edges (|E| = |V| - Therefore,
    the maximum number of ways to construct a spanning tree is, = 6 Suppose a graph
    contains a cycle and we have to determine the number of possible ways, to construct
    a spanning tree. ![](image-wkjfpbq6.jpg) In the above shown graph, we have two
    cycles and they are 1 – 2 – 3 – 5 – 6 - 1 and 3 – 4 – 5 – Therefore, the total
    number of spanning trees for the above drawn graph is, – m, where m is the total
    number of cycles in the given graph G. Therefore, for the above drawn graph, total
    number of edges, E = 7 and hence, the total number of ways to generate a spanning
    tree is as follows: = – 2 = 40 Now, we have a graph where all edges contain weights
    and hence, such type of graphs are known as weighted graphs. Therefore, for the
    above drawn graph, total number of edges, E = 7 and hence, the total number of
    ways to generate a spanning tree is as follows: ![](image-t35ck727.jpg) Here,
    I want to be clear about the total number of spanning trees that is possible for
    a particular graph. Let us draw some of the spanning trees for above drawn graph, ![](image-4si0ynqa.jpg) And
    so on. Now, from this example, we can say that if we have a weighted graph, then
    the cost of a spanning tree varies. So, for a weighted graph, if we want to find
    the minimum – cost spanning tree, we will have different methods available. The
    simplest method is to draw each and every spanning tree of the graph and find
    the cost for each spanning tree. The tree, which gives us the minimum - cost spanning
    tree for the given graph. But this method is too time consuming. We have other
    methods available to find the minimum – cost spanning tree, without finding out
    all possible spanning trees. For this, we will be using the greedy method. There
    are two algorithms, which follow the greedy approach, to find the minimum – cost
    spanning tree and they are as follows:follows: follows:follows: follows:6.2.1
    Prim’s Algorithm Algorithm Prim(E, cost, n, t) // E is the set of edges in G.
    cost[1: n, 1:n] is the cost // adjacency matrix of an n vertex graph such that
    cost[i,j] is // either a positive real number or ∞ if no edge (i,j) exits. //A
    minimum spanning tree is computed and stored as a set of //edges in the array
    t[1 :n-1,1:2]. (t[i, 1], t[i,2]) is an edge in // the minimum-cost spanning tree.
    The final cost is returned. { Let (k,l) be an edge of minimum cost in E; mincost:=
    cost[k,l]; for i :=1 to n do // lnitialize near. if (cost[i,l] < cost[i,k]) then
    near[i]:=l; else near [i]:=k; For i:=2 to n-1 do {//Find n-2 additional edges
    for t. Let j be an index such that near[j] ≠0 and cost[j,near[j]] is minimum; t[i,1]:=j;t[i:2]:=near[j]; mincost:=mincost+cost[j,near[j]]; near[j]:=0; for
    k :=1 to n do // Update near[]. if(near[k] ≠0) and (cost[k,near[k]]> cost[k,j])) then
    near[k]:=j; } return mincost; } Explanation of Prim’s Algorithm ![](image-kcpmhxsr.jpg) Let
    us see how prim’s method works. Here, we have 7 verities. From the given graph,
    we have to find the edge which has got the minimum cost, here edge (1,6) has minimum
    cost 10\. Selection of minimum cost edge in E is done in statement 9\. In statement
    10, mincost = cost[k,l] = cost[1,6] = 10 The set of edges in array t[1:n-1, 1:2]
    gives the set of edges in the minimum – cost spanning tree. ∴ t [1, 1] : = k =
    1 ; t [1,2] = l = 6 ; In lines 12 to 14 initialization of ‘near’ is happening.
    The next edge with the minimum cost has to be added in the set of edges in t. Initialization
    of near is done in the following manner: k : 1 and l : = 6 ; min cost : = 10 ; for
    i = 1 to 7 do cost [1,6] < cost [1,1] ; 10 < ∞ ; near [1] = 60 cost [2,6] < cost
    [2,1] ; 38 < 28 ; near [2] = 1 cost [3,6] < cost [3,1] ; 59 < 44 ; near [3] =
    1 cost [4,6] < cost [4,1] ; 47 < 56 ; near [4] = 6 cost [5,6] < cost [5,1] ; 25
    < 63 ; near [5] = 6 cost [6,6] < cost [6,1] ; ∞< 10 ; near [6] = 1 0 cost [7,6]
    < cost [7,1] ; 49 < 42 ; near [7] = 1 near [1] : = near [6] = 0 ; In the for loop
    of line 16, the remainder of the spanning tree is built up edge by edge. Lines
    18 and 19 select near as the next edge to include. We found that for j = 5, cost
    near is minimum. So, we are updating the array t as: t [2,1] : = j = 5 t [2,2]
    : = near = near [5] = 6 So, our array t looks like this: ![](image-mik3cskh.jpg) Calculating
    mincost in statement 21 and the new mincost. = mincost + cost near = 10 + cost
    [5, near [5]] = 10 + cost [5,6] = 10 + 25 = 35 Now, we have to reset the value
    of near = 0, so,near [5] = 0 Lines 23 + 25 update near [ ]. For k : = 1 to n k
    = 1 _____ no change in near [ ] k = 2 ; condition of ‘if’ is not true, so no change
    in near [ ] . k = 3 ; ‘if’ condition is true, so near [ 3 ] = 5 ; k = 4 ; ‘if’
    condition is true, so near [ 4 ] = 5 ; k = 5 ; _____ no change in near [ ] ; k
    = 6 ; _____ no change in near [ ] ; k = 7 ; ‘if’ condition is true, so near [
    7 ] = 5 ; Now, we have to again find an index j such that near ≠ 0 and cost near
    is minimum; we found j = 4, so the array t get updated: t = j t [3, 1] = 4t 2]
    = near t [3,2] = near [4] = 5 So, our array t looks like the following: ![](image-2ys1cbrx.jpg) Calculating
    mincost in statement 21, and the new mincost = mincost + cost [ j, near [ = 35
    + cost [4,5] = 35 + 22 = 57 Now, we have to reset the value of near [j] = so,near
    [4] = 0] Again we have to update near [ ] . For k = 1 to n k = 1 ;_____ no change
    in near [ ] ; k = 2 ; condition of ‘if’ is not true, so no change in near [ ]
    ; k = 3 ; ‘if’ condition is true, so near [ 3 ] = 4 k = 4 ; _____ no change in
    near [ ] ; k = 5 ; _____ no change in near [ ]; k = 6 ; _____ no change in near
    [ ] ; k = 7 ; ‘if’ condition is true, so near [ 7 ] = 4 Now, we have to again
    find an index j such that near [ ≠ 0 and cost [j, near [j]] is minimum; we found
    j = 3, so the array t get updated: t 1] = j t [4, 1] = 3t 2] = near t [4, 2] =
    near [3] = 4 So, array t looks like the following: ![](image-z9u2alt0.jpg) Calculating
    mincost in statement 21, and the new mincost = mincost + cost [j, near = 57 +
    cost [3,4] = 57 + 12 = 69 Now, we have to reset the value of near [j] = 0, so,near
    [3] = 0] Again we have to update near [ ] . For k = 1 to n k = 1 ; no change in
    near [ ]; k = 2 ; condition of ‘if’ is not true, so we have to change in near
    [2] = 3; k = 3 ; no change in near [ ]; k = 4 ; no change in near [ ]; k = 5 ;
    no change in near [ ]; k = 6 ; no change in near [ ]; k = 7 ; ‘if’ condition is
    true, so near [ 7 ] = 3; Now, we have to again find an index j such that near
    ≠ 0 and cost near is minimum; we found j = 2, so the array t get updated: t 1]
    = j t 5, 1] = 2 t = near t [5,2] = near [2] = 4 = 3 So, our array t looks like
    the following: ![](image-itbx2hox.jpg) Calculating mincost in statement 21, and
    the new mincost = mincost + cost [j, near = 69 + cost [2,3] = 69 + 16 = 85 Now,
    we have to reset the value of [j] = so,near [2] = 0] Again we have to update near
    [ ] . For k : = 1 to n – k = 1; no change in near [ ]; k = 2 ; no change in near
    [ ]; k = 3 ; no change in near [ ]; k = 4 ; no change in near [ ]; k = 5 ; no
    change in near [ ]; k = 6 ; no change in near [ ]; k = 7 ; ‘if’ condition is true,
    so near [ 7 ] = 2; Now, we have to again find an index j such that near ≠ 0 and
    cost near is minimum ; we found j = 7, so the array t get updated: t 1] = j t
    [6, 1] = 7 t 2] = near t [6, 2] = near [7] = 2 So, our array t looks like the
    following: ![](image-0j4to6id.jpg) Calculating mincost in statement 21, and the
    new mincost = mincost + cost [j, near [j]]; = 85 + cost [7,2] = 85 + 14 mincost
    = 99 Now, we have to reset the value of near [j] = so,near [7] = 0] Thus, at the
    end of the algorithm, it returns mincost = The minimum cost spanning true for
    the given graph is as shown in the following graph: ![](image-2crsvhd0.jpg)6.2.2
    Kruskal’s Algorithm Algorithm Kruskak (E, cost,n,t) //E is the set of edges in
    G. G has n vertices. cost[u,v] is the cost of edge (u,v). t is the set of edges
    in the //minimum-cost spanning tree. The final cost is returned. { Construct a
    heap out of the edge cost using Heapify; for i:=1 to n do parent[i]:=-1; //Each
    vertex is in a different set. i:=0; mincost:=0.0; while((i<n-1_ _="" span="">and
    (heap not empty)) do</n-1_> { Delete a minimum cost edge(u,v) from the heap and
    reheapify using Adjust; j:=Find(u);k:= Find(v); if(j ≠k) then { i:=i+1; t[I,1]:=u;
    t[I,2] :=v; mincost:=mincost+cost[u,v]; Union(j,k); } } if(i ≠ n-1)then write
    (“No spanning tree”); else return mincost; } Explanation of Kruskal’s Algorithm This
    algorithm is used for finding a minimum spanning tree, by opting the greedy approach.
    In Kruskal’s algorithm, every node is assumed as an independent tree and connects
    one node with another, only if the edge forming has the lowest cost compared to
    all other options available. Normally, we follow the steps given below for Kruskal’s
    algorithm:  Edges of graph are sorted on the basis of weights (or costs). We start
    the process by adding edges with smallest weight or cost to the spanning tree
    till we get the edge of the largest weight or cost. Only add edges which don’t
    form a cycle – edges which connect only disconnected components. Or, as a simpler
    explanation: Step Remove all loops and parallel edges. Step Arrange all the edges
    in ascending order of cost. Step Add edges with least weight. Let us take the
    following graph and see how Kruskal’s method is implemented to find the minimum
    cost spanning tree: ![](image-gkx5yhfi.jpg) Stages in Kruskal’s algorithm to find
    the minimum cost spanning tree: ![](image-hy24uvh3.jpg) ![](image-5zhw3dqh.jpg) ![](image-gwuiacc1.jpg) For
    clarity, Kruskal’s method is written out more formally in the following algorithm.
    We assume, E is the set of all edges in G. The only functions we wish to perform
    on this set are as follows: (1) Determine an edge with minimum cost, and (2) Delete
    this edge Some of the real – life applications of Kruskal’s algorithm are as follows: (1)
    Landing cables (2) TV Network (3) Tour operations Let us describe a problem and
    then come up with a solution. The problem is named as Pokemon Go -flavored and
    the problem is mentioned as follows:  Imagine, there are 8 Pokestops located in
    your area and you want to visit all of them. Each Pokestop can be reached via
    another Pokestop. Every connection has a positive distance ( > 0 ). The sum of
    the distances of all chosen connections must be minimal. ![](image-02zr463z.jpg)  The
    distance of a connection is indicated by ‘d’, which takes as input, two Pokestop
    IDs; d(1,2) = d(2, 1) = for example. So, what is the minimum sum of distances
    of the connections that connect all Pokestops? As a solution, we have to find
    a shortest path, which connects all Pokestops as well gives minimum cost path
    also. The key to the solution, in order to get the minimum sum, is to: Create
    a Minimum Spanning Tree How do we create an MST? We have the following step –
    by – step procedure to create an MST:'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: Ans. (b) 短答案问题 问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题问题-   Greedy
    Method  CHAPTER 6 贪婪方法6.1 贪婪方法：基本概念 这是解决问题的一种方法。正如我们有分而治之方法一样，这种设计也用于解决问题。 让我们了解一下这个方法在说什么。这种方法用于解决优化问题。什么是优化问题？一个要求最小结果或最大结果的问题。 所以，为此，让我们了解一下通过下面的一个例子解释的一些术语。 假设，有一个问题
    P。问题说，我必须从城市 A 去到城市 B。我必须完成这段旅程，这将成为我的问题。对于这个问题，我可能有很多解决方案。 P：A ⟶ B；其中 P 是问题，A
    和 B 表示城市。 我可以步行完成旅程，让它成为解决方案一，S1，或者我可以骑自行车，解决方案二，S2，或者我可以开车，解决方案三，S3，或者我可以坐火车，解决方案四，S4，或者我可以坐飞机，解决方案五，S5。我们可以看到，对于特定的问题
    P，有许多解决方案，S1，S2，S3，S4，S5，….Sn。如果我没有任何限制，我可以采取任何解决方案来解决问题。但是这里我有一个约束或限制，那就是我必须在
    12 小时内完成旅程。 然后，在许多可用的解决方案中，解决方案 S4 和 S5 满足给定的约束条件。 S4 是乘火车，S5 是乘飞机完成旅程。在这里，解决方案
    S4 和 S5 被称为可行解决方案，因为它们是满足所述问题的给定约束条件的解决方案。 因此，可行解决方案被定义为满足问题中给定条件的解决方案（尽管对于给定问题，我们可能有许多解决方案）。 现在，如果我说我想以最低成本完成这段旅程。也就是说，我希望尽可能少地花费金额，那么给定的问题就变成了最小化问题。由于问题要求结果应最小，因此此类问题属于最小化问题。 假设，在两个可行解决方案
    S4 和 S5 中，一个解决方案给出了完成旅程的最低成本。让该解决方案为 S4。那么，此解决方案 S4 称为最优解。 因此，最优解被定义为一个可行解决方案，同时也给出了最佳结果。 肯定地说，对于任何问题，只能有一个最优解。可能会有很多解决方案，也可能会有多个可行解决方案，但是，所有时间，问题将仅有一个最优解。 这个问题需要最小的结果，而另一些问题需要最大的结果。所以，如果一个问题要求最小或最大的结果，那么我们称这种类型的问题为优化问题。我们也可以用其他话来说，优化问题要求最小结果或最大结果。 因此，贪婪方法用于解决优化问题。 这里是贪婪技术的一般方法。贪婪方法的控制抽象如下所示： 算法
    GREEDYMETHOD（g，m） { 对于
- en: '| 1. | Create set A, initially equal to null, and create set P, initially equal
    to E, the set of all edges.  |'
  id: totrans-648
  prefs: []
  type: TYPE_TB
  zh: '| 1. | 创建集合 A，最初等于空集，并创建集合 P，最初等于 E，即所有边的集合。  |'
- en: '| 2. | Choose an edge in P of minimum distance, call it ‘e’, and'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: '| 2. | 在 P 中选择距离最小的边，称为‘e’，并'
- en: '&#124; (a) &#124; If adding e to A creates a cycle, remove e from P. &#124;'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; 如果将 e 添加到 A 中会形成环路，则将 e 从 P 中移除。 &#124;'
- en: '&#124; (b) &#124; Otherwise, move e from P to A. &#124;'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (b) &#124; 否则，将 e 从 P 移至 A。 &#124;'
- en: '|'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| 3. | If P is not empty, go to step 2.  |'
  id: totrans-653
  prefs: []
  type: TYPE_TB
  zh: '| 3. | 如果 P 不为空，则转到步骤 2。  |'
- en: '| 4. | Output the Minimum Spanning Tree (V, A) (where V is the set of all vertices).
    |'
  id: totrans-654
  prefs: []
  type: TYPE_TB
  zh: '| 4. | 输出最小生成树（V，A）（其中 V 是所有顶点的集合）。 |'
- en: The above-mentioned procedure is the way how MST is being produced using Kruskal’s
    Algorithm. Let us solve the problem Pokemon Go – flavoured. ![](image-6k6836os.jpg) Step
    We have a set A, which is empty initially and is shown as the following graph:- ![](image-c6ysx2qs.jpg) Now,
    in the step 2, it says that, choose an edge ‘e’, with minimum cost and here, we
    have the edge (4, 7) with minimum cost 2\. We have to move this edge from P to
    A, and the figure showing this change is shown as follows: ![](image-5cnk9d96.jpg) Step ![](image-wehow6ia.jpg) Next,
    again we check whether P is empty or not. Obviously, P is not empty. Let’s go
    to step 2 again for the next iteration and again take the next edge with minimum
    cost. We can see that, the edge (4, 6) has got the minimum cost and since, this
    edge does not form any cycle, so we move that edge from P to A, and the following
    figure shows the changes: ![](image-jd6f1vkq.jpg) Step ![](image-stg4oiz4.jpg) Again,
    to step 3 to check whether P is empty or not and found its not empty, so again
    moving to step 2 and find the edge with minimum cost. Here, the edge (1, 2) has
    got the minimum cost and we check whether the addition of this edge create any
    cycle in A or not. Since, it is not creating any cycle, we move this edge from
    P to A and the following figure shows the changes: ![](image-7lwjanaw.jpg) Step ![](image-t55g0fw2.jpg) Again,
    moving to step 3 and found that P is not empty. Again, to step 2 and find the
    next edge with minimum cost. Here, the next edge with minimum cost is (5, 7) with
    cost 7\. Since, the inclusion of this edge into A, does not create any cycle,
    so, this edge is moved from P to A. The changes are shown in the following figure: ![](image-rmbzv4y3.jpg) Step
    2: ![](image-14zdtdbo.jpg) Step 3 is being checked for emptiness and since P is
    not empty, step 2 is executed again to find the next edge with minimum cost. Here,
    the next minimum cost edge is (4, 5) with cost 11\. Since, the inclusion of this
    edge in A, will create cycle in A, so this edge is discarded from inclusion into
    A. And, this edge (4, 5) is being removed from P and the changes are shown in
    the following figure: ![](image-rv5ka3rl.jpg) Step 3 being checked for emptiness
    of P and since P is not empty, step 2 is executed again to find the next edge
    with minimum cost. Here, the next minimum cost edges are (3, 6) and (6, So, here
    the edges (3, 6) is included in A, since its inclusion does not create any cycle
    in A. The changes are shown in the following figure: ![](image-7pe0814h.jpg) Step ![](image-tbgqnj6z.jpg) Again
    executing step 3 and found that P is not empty, so executing step 2, to find the
    next edge with minimum cost and fond edge (6, 7) with minimum cost. But, its inclusion
    in A, will create cycle in A, so it is being removed from P. And the following
    figure shows the changes: ![](image-3qea1lny.jpg) Now, again step 3 executed and
    fond P is not empty. So, step 2 is again executed to find the edge with minimum
    cost and the edges we fond are (1, 4) and (2, 5) with cost as 17\. Here, the edge
    (1, 4) is included in A, since its inclusion does not create any cycle. The following
    figures show the changes: ![](image-qtbet7jz.jpg) Step ![](image-gd7a1sz0.jpg) Again,
    step 3 is executed to check the emptiness of P. Since P, is not empty, step 2
    is executed again, to find the next edge with minimum cost. Here, the edge we
    found is (2, 5) with cost 17\. Since, its inclusion in A will create cycle, so
    this edge needs to be removed from P. The following figure shows the changes: ![](image-luh7o6x9.jpg) Step
    3 is called again and we found that P is not empty. So, step 2 is being executed
    again to find the next edge with minimum cost. Here, the next edge with minimum
    cost is (7, 8) with 19 as cost. This edge is moved from P to A, since its inclusion
    does not create any cycle in A. The changes are shown in the following figures: ![](image-hk54gj29.jpg) Step ![](image-i6ak7obe.jpg) Step
    3 is again called and fond that P is not empty. So, step 2 is being called to
    find the next edge with minimum cost. Here, it is edge (3, 4) with cost 23\. But,
    its inclusion in A, will create cycle in A. So, this edge is being removed from
    P and the change is shown in the following figure: ![](image-v9yemeec.jpg) Now,
    again step 3 is called and since P is not empty, we have to execute step 2 again.
    We found the next edge with minimum cost is (1, But, its inclusion in A will create
    cycle in A, so it is removed from P. The following figure shows the change: ![](image-h2wtgwz7.jpg) Step
    3 is again called and found that P is not empty. So, step 2 is being executed
    to find the next edge with minimum cost. Here, it is the edge (2, 4) with cost
    31\. Since, its inclusion in A will create cycle in A, so this edge has to be
    removed from P. The following figure shows the change- ![](image-24y37uw0.jpg) Now,
    step 3 is executed and found that P is empty. So, step 4 is called and it outputs
    the Minimum Spanning Tree (V, A), as shown in the following figure- ![](image-naekynbq.jpg) Here,
    the cost of minimum spanning tree obtained is 2 + 3 + 5 + 7 + 13 + 17 + 19 = 66 Note:  Kruskal’s
    algorithm is an algorithm that produces a Minimum Spanning Tree of a given connected
    weighted graph. It is a greedy MST algorithm. The difference with Prim’s algorithm
    is that Prim’s algorithm grows only one tree, while Kruskal’s algorithm grows
    a collection of trees. The pseudocode for the Kruskal’s algorithm using the disjoint
    – set data structure for checking for cycles is given below- 1\. Sort all edges
    by their weight so that w_1 < = w_2 <= w_3 <= ……..<= w_n. 2\. Initially, A is
    an empty set (ø). 3\. For each vertex ‘u’ in V do 4\. CREATE-SET (u) 5\. EndFor 6\.
    For each edge (u, v) in E do 7\.  If (FIND-SET (u) != FIND-SET(v)) 8\. add (u,v)
    to A 9\. UNION (u,v) 10\. EndIf 11\. EndFor 12\. Return A.Exercises Exercises
    Exercises Exercises Exercises Exercises Exercises Exercises Exercises Exercises
    Exercises Exercises Exercises ![](image-fi0iaxbr.jpg) (a) ![](image-qoez0te5.jpg) (b) ![](image-o0iu3qky.jpg) (b)
    (b) (b) (b) (b) (b) (b) (b) ![](image-6cqgiqqg.jpg) (a) ![](image-9pwwey6y.jpg) (b) ![](image-egk5e7ap.jpg) (c) ![](image-cewtu9ug.jpg) (c)
    (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) ![](image-ttrg7cb0.jpg) (c)(c)
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 上述过程是使用克鲁斯卡尔算法生成最小生成树（MST）的方法。让我们解决一下“精灵宝可梦 Go”的问题。![](image-6k6836os.jpg) 第一步我们有一个初始为空的集合
    A，并且显示为以下图形:- ![](image-c6ysx2qs.jpg) 现在，在第二步中，它说，选择一个具有最小成本的边‘e’，在这里，我们有边（4，7），成本最小为2。我们必须将这条边从
    P 移动到 A，图示这种变化如下所示: ![](image-5cnk9d96.jpg) 步骤 ![](image-wehow6ia.jpg) 接下来，再次检查
    P 是否为空。显然，P 不为空。让我们再次进入步骤 2 进行下一次迭代，并再次选择具有最小成本的下一条边。我们可以看到，边（4，6）的成本最小，由于此边不形成任何环，因此我们将该边从
    P 移动到 A，以下图形显示了这些更改: ![](image-jd6f1vkq.jpg) 步骤 ![](image-stg4oiz4.jpg) 再次进入第
    3 步检查 P 是否为空，并发现 P 不为空。再次转到第 2 步，以寻找下一条具有最小成本的边。在这里，边（1，2）的成本最小，我们检查加入此边是否在 A
    中创建任何环。由于它不创建任何环，我们将此边从 P 移动到 A，以下图形显示了更改: ![](image-7lwjanaw.jpg) 步骤 ![](image-t55g0fw2.jpg) 再次转到第
    3 步，并发现 P 不为空。再次转到第 2 步，以查找具有最小成本的下一条边。在这里，具有最小成本的下一条边是（5，7），成本为7。由于将此边包含到 A 中不会创建任何环，因此将此边从
    P 移动到 A。更改如下图所示: ![](image-rmbzv4y3.jpg) 步骤 2: ![](image-14zdtdbo.jpg) 检查第 3 步是否为空，由于
    P 不为空，因此再次执行第 2 步以查找具有最小成本的下一条边。在这里，具有最小成本的下一条边是（4，5），成本为11。由于将此边包含到 A 中会在 A 中创建环，因此将此边丢弃。并且将此边（4，5）从
    P 中移除，并显示更改如下图所示: ![](image-rv5ka3rl.jpg) 检查第 3 步是否为空，由于 P 不为空，因此再次执行第 2 步以查找具有最小成本的下一条边。在这里，具有最小成本的下一条边是（3，6）和（6，因此，这里的边（3，6）被包含在
    A 中，因为其包含不会在 A 中创建任何环。更改如下图所示: ![](image-7pe0814h.jpg) 步骤 ![](image-tbgqnj6z.jpg) 再次执行第
    3 步，发现 P 不为空，因此执行第 2 步以查找具有最小成本的下一条边，并找到成本最小的边（6，7）。但是，将其包含在 A 中会在 A 中创建环，因此将其从
    P 中移除。以下图形显示了更改: ![](image-3qea1lny.jpg) 现在，再次执行第 3 步，并发现 P 不为空，因此必须再次执行第 2 步。我们找到具有最小成本的下一条边是（1，但是，将其包含在
    A 中会在 A 中创建环，因此将其从 P 中移除。以下图形显示了更改: ![](image-h2wtgwz7.jpg) 再次执行第 3 步，并发现 P 不为空，因此必须再次执行第
    2 步以查找具有最小成本的下一条边。在这里，具有最小成本的下一条边是（2，4），成本为31。由于将此边包含到 A 中会在 A 中创建环，因此必须将此边从 P
    中移除。以下图形显示了更改- ![](image-24y37uw0.jpg) 现在，执行第 3 步，并发现 P 为空。因此，调用第 4 步，它输出了最小生成树（V，A），如下图所示- ![](image-naekynbq.jpg) 在这里，获得的最小生成树的成本是 2
    + 3 + 5 + 7 + 13 + 17 + 19 = 66 注意:  克鲁斯卡尔算法是一种生成给定连接加权图的最小生成树的算法。 它是一种贪婪的 MST
    算法。 与普林姆算法的区别在于，普林姆算法仅增长一棵树，而克鲁斯卡尔算法增长一组树。 使用不相交 - 集数据结构检查循环的克鲁斯卡尔算法的伪代码如下- 1.按权重对所有边进行排序，以便w_1
    < = w_2 <= w_3 <= ……..<= w_n。 2.最初，A 是一个空集（ø
- en: '| 4. | To construct a minimum spanning tree (MST), Prim’s algorithm always
    selects an edge'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; (a) &#124; having minimum weight, which leads to minimum increase in
    the cost of MST &#124;'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; (b) &#124; having maximum number of vertices which gives a MST with
    least diameter &#124;'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; (c) &#124; that does not result into the formation of a cycle &#124;'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; (d) &#124; where addition of a new vertex into the partially constructed
    MST leads to minimum increment in cost of MST. &#124;'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
- en: '| 5. | The minimum spanning tree problem uses the following strategy ____'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; (a) &#124; Greedy &#124;'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; (b) &#124; Dynamic Programming &#124;'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; (c) &#124; Divide and Conquer &#124;'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; (d) &#124; None of these &#124;'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
- en: '| 6. | Answer questions a to c, using the given graph. |'
  id: totrans-668
  prefs: []
  type: TYPE_TB
- en: '![](image-2452zn9w.jpg) (c) (c) (c) (c) (c) (c) (c) (c)(c)(c)(c) (c) (c) (c)(c)
    (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c)(c)(c)(c) (c) (c) (c)(c)
    (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c)(c)(c) (c) (c)'
  id: totrans-669
  prefs: []
  type: TYPE_IMG
- en: '| 7. | Which of the following standard algorithms is not a Greedy algorithm?'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; (a) &#124; Dijkstra’s shortest path algorithm &#124;'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; (b) &#124; prim’s algorithm &#124;'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; (c) &#124; kruskal algorithm &#124;'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; (d) &#124; Huffman coding &#124;'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; (e) &#124; Bellmen ford shortest path algorithm &#124;'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
- en: '| 8. | Which of the following is true about Kruskal and Prim MST algorithms?
    Assume that Prim is implemented for adjacency list representation using Binary
    Heap and Kruskal is implemented using union by rank.'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; (a) &#124; Worst case time complexity of both algorithms is same &#124;'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; (b) &#124; Worst case time complexity of Kruskal is better than prime
    &#124;'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; (c) &#124; Worst case time complexity of prim is better than Kruskal
    &#124;'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
- en: '| 9. | Which of the following is true about Huffman Coding.'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; (a) &#124; Huffman coding may become lossy in some cases &#124;'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; (b) &#124; Huffman codes may not be optimal lossless codes in some cases
    &#124;'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (b) &#124; 在某些情况下，哈夫曼编码可能不是最优的无损编码。&#124;'
- en: '&#124; (c) &#124; in Huffman coding, no code is prefix of any other code. &#124;'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; 在哈夫曼编码中，没有任何码字是其他码字的前缀。&#124;'
- en: '&#124; (d) &#124; all of the above &#124;'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (d) &#124; 所有上述 &#124;'
- en: '|'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| 10. | Suppose the letters a, b, c, d, e, f have probabilities 1/2, 1/4, 1/8,
    1/16, 1/32, 1/32 respectively. Which of the following is the Huffman code for
    the letter a, b, c, d, e, f?'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: '| 10. | 假设字母 a, b, c, d, e, f 的概率分别为 1/2, 1/4, 1/8, 1/16, 1/32, 1/32。以下哪个是字母
    a, b, c, d, e, f 的哈夫曼编码？'
- en: '&#124; (a) &#124; 0, 10, 110, 1110, 11110, 11111 &#124;'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; 0, 10, 110, 1110, 11110, 11111 &#124;'
- en: '&#124; (b) &#124; 11, 10, 011, 010, 001, 000 &#124;'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (b) &#124; 11, 10, 011, 010, 001, 000 &#124;'
- en: '&#124; (c) &#124; 11, 10, 01, 001, 0001, 0000 &#124;'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; 11, 10, 01, 001, 0001, 0000 &#124;'
- en: '&#124; (d) &#124; 110, 100, 010, 000, 001, 111 &#124;'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (d) &#124; 110, 100, 010, 000, 001, 111 &#124;'
- en: '|'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| 11. | Suppose the letters a, b, c, d, e, f have probabilities 1/2, 1/4, 1/8,
    1/16, 1/32, 1/32 respectively. What is the average length of Huffman codes?'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: '| 11. | 假设字母 a, b, c, d, e, f 的概率分别为 1/2, 1/4, 1/8, 1/16, 1/32, 1/32。哈夫曼编码的平均长度是多少？'
- en: '&#124; (a) &#124; 3 &#124; (b) &#124; 2.1875 &#124;'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; 3 &#124; (b) &#124; 2.1875 &#124;'
- en: '&#124; (c) &#124; 2.25 &#124; (d) &#124; 1.9375 &#124;'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; 2.25 &#124; (d) &#124; 1.9375 &#124;'
- en: '|'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| 12. | Consider the undirected graph below: |'
  id: totrans-698
  prefs: []
  type: TYPE_TB
  zh: '| 12. | 考虑下面的无向图：|'
- en: '![](image-ht1ixyz1.jpg) Using Prim’s algorithm to construct a minimum spanning
    tree starting with node A, which one of the following sequences of edges represents
    a possible order in which the edges would be added to construct the minimum spanning
    tree?tree? tree? tree? tree? tree? tree? tree? tree? tree? tree? tree? tree?tree?
    tree? tree? tree? tree? tree? tree? tree? tree? tree? tree? tree?tree? tree? tree?
    tree? tree? tree? tree? tree? tree? tree? tree? tree?tree? tree? tree? tree? tree?
    tree? tree? tree? tree? tree? tree? tree?'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: '![](image-ht1ixyz1.jpg) 使用 Prim 算法构建以节点 A 开始的最小生成树，以下哪个边序列表示构建最小生成树时可能添加边的顺序？'
- en: '| 13. | A text is made up of the characters a, b, c, d, e each occurring with
    the probability 0.11, 0.40, 0.16, 0.09 and 0.24 respectively. The optimal Huffman
    coding technique will have the average length of:'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: '| 13. | 一段文本由字符 a, b, c, d, e 组成，各自的概率分别为 0.11, 0.40, 0.16, 0.09 和 0.24。最优哈夫曼编码技术的平均长度是：'
- en: '&#124; (a) &#124; 2.40 &#124; (b) &#124; 2.16 &#124;'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; 2.40 &#124; (b) &#124; 2.16 &#124;'
- en: '&#124; (c) &#124; 2.26 &#124; (d) &#124; 2.15 &#124;'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; 2.26 &#124; (d) &#124; 2.15 &#124;'
- en: '|'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| 14. | Six files F1, F2, F3, F4, F5 and F6 have 100, 200, 50, 80, 120, 150
    records respectively. In what order should they be stored so as to optimize act.
    Assume each file is accessed with the same frequency'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: '| 14. | 六个文件 F1, F2, F3, F4, F5 和 F6 分别有 100, 200, 50, 80, 120, 150 条记录。为了优化访问顺序，应该如何存储这些文件？假设每个文件的访问频率相同。'
- en: '&#124; (a) &#124; F3, F4, F1, F5, F6, F2 &#124;'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; F3, F4, F1, F5, F6, F2 &#124;'
- en: '&#124; (b) &#124; F2, F6, F5, F1, F4, F3 &#124;'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (b) &#124; F2, F6, F5, F1, F4, F3 &#124;'
- en: '&#124; (c) &#124; F1, F2, F3, F4, F5, F6 &#124;'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; F1, F2, F3, F4, F5, F6 &#124;'
- en: '&#124; (d) &#124; Ordering is immaterial as all files are accessed with the
    same frequency. &#124;'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (d) &#124; 排序是不重要的，因为所有文件的访问频率相同。 &#124;'
- en: '|'
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| 15. | Consider a job scheduling problem with 4 jobs J1, J2, J3, J4 and with
    corresponding deadlines: ( d1, d2, d3, d4) = (4, 2, 4, 2). Which of the following
    is not a feasible schedule without violating any job schedule?'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: '| 15. | 考虑一个作业调度问题，有 4 个作业 J1、J2、J3、J4，对应的截止时间为：(d1, d2, d3, d4) = (4, 2, 4,
    2)。以下哪个不是一个可行的调度，而且没有违反任何作业调度？'
- en: '&#124; (a) &#124; J2, J4, J1, J3 &#124;'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; J2, J4, J1, J3 &#124;'
- en: '&#124; (b) &#124; J4, J1, J2, J3 &#124;'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (b) &#124; J4, J1, J2, J3 &#124;'
- en: '&#124; (c) &#124; J4, J2, J1, J3 &#124;'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; J4, J2, J1, J3 &#124;'
- en: '&#124; (d) &#124; J4, J2, J3, J1 &#124;'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (d) &#124; J4, J2, J3, J1 &#124;'
- en: '|'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| 16. | What is greedy algorithm?  |'
  id: totrans-716
  prefs: []
  type: TYPE_TB
  zh: '| 16. | 什么是贪婪算法？ |'
- en: '| 17. | What is the use of greedy algorithm? |'
  id: totrans-717
  prefs: []
  type: TYPE_TB
  zh: '| 17. | 贪婪算法的用途是什么？ |'
- en: '| 18. | When is it convenient to solve a problem using a greedy algorithm?
    |'
  id: totrans-718
  prefs: []
  type: TYPE_TB
  zh: '| 18. | 何时方便使用贪婪算法解决问题？ |'
- en: '| 19. | Is Dijkstra’s Algorithm a greedy algorithm or a dynamic programming
    algorithm? |'
  id: totrans-719
  prefs: []
  type: TYPE_TB
  zh: '| 19. | 戴克斯特拉算法是贪婪算法还是动态规划算法？ |'
- en: '| 20. | What is an intuitive explanation of greedy algorithms? |'
  id: totrans-720
  prefs: []
  type: TYPE_TB
  zh: '| 20. | 贪婪算法的直观解释是什么？ |'
- en: '| 21. | Why do we need greedy algorithm? |'
  id: totrans-721
  prefs: []
  type: TYPE_TB
  zh: '| 21. | 我们为什么需要贪婪算法？ |'
- en: '| 22. | What are the best applications of greedy algorithm? |'
  id: totrans-722
  prefs: []
  type: TYPE_TB
  zh: '| 22. | 贪婪算法的最佳应用是什么？ |'
- en: '| 23. | What is a “greedy” classifier? |'
  id: totrans-723
  prefs: []
  type: TYPE_TB
  zh: '| 23. | “贪婪”分类器是什么？ |'
- en: '| 24. | What are the characteristics of a greedy algorithm? |'
  id: totrans-724
  prefs: []
  type: TYPE_TB
  zh: '| 24. | 贪婪算法的特点是什么？ |'
- en: '| 25. | Why does this greedy algorithm fail to accurately determine whether
    a graph is a perfect matching? |'
  id: totrans-725
  prefs: []
  type: TYPE_TB
  zh: '| 25. | 为什么这个贪婪算法无法准确确定图是否完全匹配？ |'
- en: '| 26. | Which of the following is/are the operations performed by kruskal’s
    algorithm.'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: '| 26. | 克鲁斯卡尔算法执行以下哪些操作？'
- en: '&#124; (i) &#124; sort the edges of G in increasing order by length &#124;'
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (i) &#124; 按长度递增顺序排序图 G 的边 &#124;'
- en: '&#124; (ii) &#124; keep a subgraph S of G initially empty iii) builds a tree
    one vertex at a time &#124;'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (ii) &#124; 保持图 G 的子图 S 最初为空 iii) 逐顶点构建树 &#124;'
- en: '&#124; (a) &#124; i, and ii only &#124;'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; 仅 i 和 ii &#124;'
- en: '&#124; (b) &#124; ii and iii only &#124;'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (b) &#124; 仅 ii 和 iii &#124;'
- en: '&#124; (c) &#124; i and iii only &#124;'
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; 仅 i 和 iii &#124;'
- en: '&#124; (d) &#124; All i, ii and iii &#124;'
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (d) &#124; 全部 i、ii 和 iii &#124;'
- en: '|'
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| 27. | Rather than build a subgraph one edge at a time …………………………. builds
    a tree one vertex at a time.'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: '| 27. | 不是逐边构建子图，而是逐顶点构建树…………………………'
- en: '&#124; (a) &#124; kruskal’s algorithm &#124;'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; 克鲁斯卡尔算法 &#124;'
- en: '&#124; (b) &#124; prim’s algorithm &#124;'
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (b) &#124; 普里姆算法 &#124;'
- en: '&#124; (c) &#124; dijkstra algorithm &#124;'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; 戴克斯特拉算法 &#124;'
- en: '&#124; (d) &#124; bellman ford algorithm &#124;'
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (d) &#124; 贝尔曼-福特算法 &#124;'
- en: '|'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| 28. | . ……………… is known as a greedy algorithm, because it chooses at each
    step the cheapest edge to add to subgraph S.'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: '| 28. | ……………… 被称为贪心算法，因为它在每一步都选择添加到子图S的最便宜的边。'
- en: '&#124; (a) &#124; Kruskal’s algorithm &#124;'
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; Kruskal 算法 &#124;'
- en: '&#124; (b) &#124; Prim’s algorithm &#124;'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (b) &#124; Prim 算法 &#124;'
- en: '&#124; (c) &#124; Dijkstra algorithm &#124;'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; Dijkstra 算法 &#124;'
- en: '&#124; (d) &#124; Bellman ford algorithm &#124;'
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (d) &#124; Bellman Ford 算法 &#124;'
- en: '|'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| 29. | The result of prim’s algorithm is a total time bound of ………………'
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: '| 29. | Prim算法的结果是………………的总时间界限。'
- en: '&#124; (a) &#124; O(logn) &#124;'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; O(logn) &#124;'
- en: '&#124; (b) &#124; O(m+n logn) &#124;'
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (b) &#124; O(m+n logn) &#124;'
- en: '&#124; (c) &#124; O(mn) &#124;'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; O(mn) &#124;'
- en: '&#124; (d) &#124; O(m logn) &#124;'
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (d) &#124; O(m logn) &#124;'
- en: '|'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| 30. | The ………………… process updates the costs of all the vertices V, connected
    to a vertex U, if we could improve the best estimate of the shortest path to V
    by including (U,V) in the path to V.'
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: '| 30. | 如果我们通过将(U,V)包含在到V的路径中来改进对V的最短路径的最佳估计，那么连接到顶点U的所有顶点V的成本将被更新。'
- en: '&#124; (a) &#124; relaxation &#124;'
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; 松弛 &#124;'
- en: '&#124; (b) &#124; improvement &#124;'
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (b) &#124; 改进 &#124;'
- en: '&#124; (c) &#124; shortening &#124;'
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; 缩短 &#124;'
- en: '&#124; (d) &#124; Costing &#124;'
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (d) &#124; 成本估算 &#124;'
- en: '|'
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| 31. | …………….. turns out that one can find the shortest paths from a given
    source to all points in a graph in the same time.'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: '| 31. | 原来可以在同一时间内从给定源到图中所有点找到最短路径。'
- en: '&#124; (a) &#124; Kruskal’s algorithm &#124;'
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; Kruskal 算法 &#124;'
- en: '&#124; (b) &#124; Prim’s algorithm &#124;'
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (b) &#124; Prim 算法 &#124;'
- en: '&#124; (c) &#124; Dijkstra algorithm &#124;'
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; Dijkstra 算法 &#124;'
- en: '&#124; (d) &#124; Bellman ford algorithm &#124;'
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (d) &#124; Bellman Ford 算法 &#124;'
- en: '|'
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| 32. | ……………. keeps two sets of vertices; S, the set of vertices whose shortest
    paths from the source have already been determined and V-S, the remaining vertices.'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: '| 32. | ……………. 保留两组顶点；S，已经确定了从源到达的最短路径的顶点集和V-S，其余顶点。'
- en: '&#124; (a) &#124; Kruskal’s algorithm &#124;'
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; Kruskal 算法 &#124;'
- en: '&#124; (b) &#124; Prim’s algorithm &#124;'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (b) &#124; Prim 算法 &#124;'
- en: '&#124; (c) &#124; Dijkstra algorithm &#124;'
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; Dijkstra 算法 &#124;'
- en: '&#124; (d) &#124; Bellman ford algorithm &#124;'
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (d) &#124; Bellman Ford 算法 &#124;'
- en: '|'
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| 33. | …………….. is a more generalized single source shortest path algorithm
    which can find t he shortest path in a graph with negative weighted edges.'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: '| 33. | …………….. 是更广义的单源最短路径算法，它可以在具有负权边的图中找到最短路径。'
- en: '&#124; (a) &#124; Kruskal’s algorithm &#124;'
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; Kruskal 算法 &#124;'
- en: '&#124; (b) &#124; Prim’s algorithm &#124;'
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (b) &#124; Prim 算法 &#124;'
- en: '&#124; (c) &#124; Dijkstra algorithm &#124;'
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; Dijkstra 算法 &#124;'
- en: '&#124; (d) &#124; Bellman ford algorithm &#124;'
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (d) &#124; Bellman Ford 算法 &#124;'
- en: '|'
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| 34. | A sample application of …………….. algorithm is to solve critical path
    problem, i.e. finding the longest path through a DAG.'
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: '| 34. | 一个示例应用……算法的是解决关键路径问题，即找到DAG中的最长路径。'
- en: '&#124; (a) &#124; DAG application path algorithm &#124;'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; DAG 应用路径算法 &#124;'
- en: '&#124; (b) &#124; DAG shortest path algorithm &#124;'
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (b) &#124; DAG 最短路径算法 &#124;'
- en: '&#124; (c) &#124; DAG critical path algorithm &#124;'
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; DAG 关键路径算法 &#124;'
- en: '&#124; (d) &#124; Bellman ford algorithm &#124;'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (d) &#124; 贝尔曼-福特算法 &#124;'
- en: '|'
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| 35. | In a directed graph, the …………….. can compute the transitive hull in
    O(n^3)'
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: '| 35. | 在有向图中，……………… 可以在 O(n^3) 的时间内计算传递闭包。'
- en: '&#124; (a) &#124; Transitive Hull &#124;'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; 传递闭包问题 &#124;'
- en: '&#124; (b) &#124; Minimax Distance &#124;'
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (b) &#124; 最小最大距离 &#124;'
- en: '&#124; (c) &#124; Max Min Distance &#124;'
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; 最大最小距离 &#124;'
- en: '&#124; (d) &#124; Safest Path &#124;'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (d) &#124; 最安全路径 &#124;'
- en: '|'
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| 36. | In a directed graph, the …………….. can compute the transitive hull in
    O(n^3)'
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: '| 36. | 在有向图中，……………… 可以在 O(n^3) 的时间内计算传递闭包。'
- en: '&#124; (a) &#124; Transitive Hull &#124;'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; 传递闭包问题 &#124;'
- en: '&#124; (b) &#124; Minimax Distance &#124;'
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (b) &#124; 最小最大距离 &#124;'
- en: '&#124; (c) &#124; Max Min Distance &#124;'
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; 最大最小距离 &#124;'
- en: '&#124; (d) &#124; Safest Path &#124;'
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (d) &#124; 最安全路径 &#124;'
- en: '|'
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| 37. | ……………… means, for all vertices, compute its reachability.'
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: '| 37. | ……………… 意味着，对于所有顶点，计算其可达性。'
- en: '&#124; (a) &#124; Transitive Hull &#124;'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; 传递闭包问题 &#124;'
- en: '&#124; (b) &#124; Minimax Distance &#124;'
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (b) &#124; 最小最大距离 &#124;'
- en: '&#124; (c) &#124; Max Min Distance &#124;'
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; 最大最小距离 &#124;'
- en: '&#124; (d) &#124; Safest Path &#124;'
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (d) &#124; 最安全路径 &#124;'
- en: '|'
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| 38. | For a directed graph with edge lengths, the floyd warshall algorithm
    can compute the …………….. between each pair of nodes in O(n^3).'
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: '| 38. | 对于带有边长度的有向图，弗洛伊德-沃尔沙尔算法可以在 O(n^3) 的时间内计算每对节点之间的 ………………。'
- en: '&#124; (a) &#124; Transitive Hull &#124;'
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; 传递闭包问题 &#124;'
- en: '&#124; (b) &#124; Minimax Distance &#124;'
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (b) &#124; 最小最大距离 &#124;'
- en: '&#124; (c) &#124; Max Min Distance &#124;'
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; 最大最小距离 &#124;'
- en: '&#124; (d) &#124; Safest Path &#124;'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (d) &#124; 最安全路径 &#124;'
- en: '|'
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| 39. | Given a directed graph where the edges are labeled with survival probabilities,
    we can compute the …………… between the two nodes with floyd warshall.'
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: '| 39. | 给定一个有向图，其中边缘带有生存概率标签，我们可以使用弗洛伊德-沃尔沙尔算法计算两个节点之间的 ………………。'
- en: '&#124; (a) &#124; Transitive Hull &#124;'
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; 传递闭包问题 &#124;'
- en: '&#124; (b) &#124; Minimax Distance &#124;'
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (b) &#124; 最小最大距离 &#124;'
- en: '&#124; (c) &#124; Max Min Distance &#124;'
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; 最大最小距离 &#124;'
- en: '&#124; (d) &#124; Safest Path &#124;'
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (d) &#124; 最安全路径 &#124;'
- en: '|'
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| 40. | ………………… describe efficient algorithms for computing G^T from G, for
    both the adjacency list and adjacency matrix representations of G.'
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: '| 40. | ………………… 描述了计算 G^T 从 G 的有效算法，适用于 G 的邻接表和邻接矩阵表示。'
- en: '&#124; (a) &#124; Graph transpose problem &#124;'
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; 图转置问题 &#124;'
- en: '&#124; (b) &#124; Strongly connected components problem &#124;'
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (b) &#124; 强连通分量问题 &#124;'
- en: '&#124; (c) &#124; Topological sort problem &#124;'
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; 拓扑排序问题 &#124;'
- en: '&#124; (d) &#124; Euler path problem &#124;'
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (d) &#124; 欧拉路径问题 &#124;'
- en: '|'
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| 41. | In …………… input is a directed acyclic graph (DAG)G=(V,E).'
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: '| 41. | 在 …………… 输入是一个有向无环图（DAG）G=(V,E)。'
- en: '&#124; (a) &#124; Graph transpose problem &#124;'
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; 图转置问题 &#124;'
- en: '&#124; (b) &#124; Strongly connected components problem &#124;'
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (b) &#124; 强连通分量问题 &#124;'
- en: '&#124; (c) &#124; Topological sort problem &#124;'
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; 拓扑排序问题 &#124;'
- en: '&#124; (d) &#124; Euler path problem &#124;'
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (d) &#124; 欧拉路径问题 &#124;'
- en: '|'
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| 42. | In …………………., a directed graph G is acylic if and only if a DFS of G
    yields no back edge.'
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: '| 42. | 在………………中，如果有向图G是无环的，那么对G进行DFS将不产生后向边。'
- en: '&#124; (a) &#124; Graph transpose problem &#124;'
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; 图转置问题 &#124;'
- en: '&#124; (b) &#124; Strongly connected components problem &#124;'
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (b) &#124; 强连通分量问题 &#124;'
- en: '&#124; (c) &#124; Topological sort problem &#124;'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; 拓扑排序问题 &#124;'
- en: '&#124; (d) &#124; Euler path problem &#124;'
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (d) &#124; 欧拉路径问题 &#124;'
- en: '|'
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| 43. | …………….. is a most generalized single source shortest path algorithm
    to find the shortest path in a graph even with negative weights.'
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: '| 43. | …………….. 是一种最广义的单源最短路径算法，即使在带负权重的图中也可以找到最短路径。'
- en: '&#124; (a) &#124; Kruskal’s algorithm &#124;'
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; Kruskal算法 &#124;'
- en: '&#124; (b) &#124; Prim’s algorithm &#124;'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (b) &#124; Prim算法 &#124;'
- en: '&#124; (C) &#124; Dijkstra algorithm &#124;'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (C) &#124; Dijkstra算法 &#124;'
- en: '&#124; (d) &#124; Bellman ford algorithm &#124;'
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (d) &#124; Bellman-Ford算法 &#124;'
- en: '|'
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| 44. | ………………… solves the problem of finding the shortest path from a point
    in a graph to a destination.'
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: '| 44. | ………………… 解决了在图中从一个点到目的地的最短路径问题。'
- en: '&#124; (a) &#124; Kruskal’s algorithm &#124;'
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (a) &#124; Kruskal算法 &#124;'
- en: '&#124; (b) &#124; Prim’s algorithm &#124;'
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (b) &#124; Prim算法 &#124;'
- en: '&#124; (c) &#124; Dijkstra algorithm &#124;'
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (c) &#124; Dijkstra算法 &#124;'
- en: '&#124; (d) &#124; Bellman ford algorithm &#124;'
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; (d) &#124; Bellman-Ford算法 &#124;'
- en: '|'
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| 45. | What is the use of greedy algorithms? Give a real example? |'
  id: totrans-842
  prefs: []
  type: TYPE_TB
  zh: '| 45. | 贪婪算法的用途是什么？给出一个实际例子。 |'
- en: '| 46. | Explain Dijkstra’s algorithm |'
  id: totrans-843
  prefs: []
  type: TYPE_TB
  zh: '| 46. | 解释Dijkstra算法 |'
- en: '| 47. | Explain Prim’s algorithm |'
  id: totrans-844
  prefs: []
  type: TYPE_TB
  zh: '| 47. | 解释Prim算法 |'
- en: 'tree? tree? tree?tree? tree? tree? tree? tree? tree? tree? tree? MODULE VIIBeauty
    of Blockchain  CHAPTER 7 Beauty of Blockchain7.1 Origin of Blockchain Stuart Haber
    and M Scott Stornetta in 1991 coined cryptographically secured chain of blocks.
    They wanted a system, which gave timestamps to document, that would make it secure
    and unaltered with, but they could only store a single document in a block. In
    1992 Haber and Stornetta with the help of Bayer incorporated Merkle tree (hash
    tree) to the design, which in turn helped in storing multiple documents into blocks. Satoshi
    Nakamoto introduced the first concept of blockchain that we used today in 2008\.
    The identity of Satoshi Nakamoto is still a mystery. Some say Satoshi Nakamoto
    is a single person; others say it is a group of people who do not want their identity
    revealed. The journey starts with a nine-page white paper published by Satoshi
    Nakamoto titled Bitcoin: A peer to peer electronic cash system. These nine pages
    are pure technology, orchestrated explaining a cryptocurrency based on a sophisticated
    mathematical formula and a highly protected distributed system where trust won''t
    be an issue. Satoshi''s description of Bitcoin as a peer to peer version of E-cash
    which would allow online payment transaction directly from one party to another
    without going through a financial institution. Each transaction is stored in a
    digital blockchain ledger, each block is added to the blockchain network with
    a unique digital signature. To validate the ledger, the network participants ran
    a sophisticated algorithm to authenticate their digital signature. Initially,
    the words block and chain were separate in Satoshi Nakamoto''s original paper
    but popularized as a single word, Blockchain. It was used to refer to a new type
    of applications of distributed blockchain database. Many people think that Bitcoin
    and Blockchain are the same things even though they aren''t. In 2014 many people
    started to think blockchain could be used for more than cryptocurrency. They started
    to invest and explore Blockchain; Blockchain become an open, decentralized ledger
    that records the transaction, between two parties permanently without a 3rd party
    authentication. In 2013 a programmer named Vitalik Buterin with the aim to build
    decentralized applications created an alternative to Bitcoin which would change
    the way people used Blockchain. The idea was coined in 2013 and Ethereum went
    live on 30 July 2015 with 11.9 million coins pre-mined for the crowd sale. That
    accounted for about 13% of total circulation. The most significant difference
    between Bitcoin and Ethereum is, Ethereum is not just a cryptocurrency, it can
    be used to record other assets such as loans and contracts using the concept of
    Smart Contracts and build an application on these Smart Contracts. When entrepreneurs
    discovered the power of Blockchain, there was a surge of investment and curiosity
    to see how Blockchain could be implemented in Supply chain, Healthcare, Insurance,
    Transportation, Voting, Contract management and more, now, nearly 15% of financial
    institution is currently using Blockchain Bitcoin is just one of the several hundred
    applications that use blockchain technology. It''s been an impressive decade of
    transformation for blockchain technology, and it will be intriguing to see where
    the next decade takes us.7.2 Philosophy of Blockchain (Difference between Normal
    Ecosystem and Blockchain Ecosystem)7.2.1 Normal Ecosystem ![](image-44c78m2v.jpg)Figure
    7.1 Normal Ecosystem Centralized Let''s take a centralized system like a simple
    web application that allows the user to cast a vote for a candidate. We create
    a highly secure website using HTML, CSS, JS as front end and the backend is made
    up of PHP or Python with MySQL as the database. Let''s say we conduct an election
    and 90% vote for part A, yet B won the election. The election was rigged, and
    DBA manipulated the result. This is the disadvantage of the centralized system;
    the center of authority who have access to the server can manipulate the result. Single
    point of failure The typical client-server architecture is a centralized system,
    which consists of a central server and many clients accessing the server for web
    pages. The server is a core point of failure even though the server goes down
    all the clients cannot access the system. Even if it has a backup server, there
    are times the servers are down for maintenances. Trust-based In the case of traditional
    system trust is a crucial factor, we trust the center of authority, let us use
    the example that we used earlier, there we see how the system can change a result
    of an election. We trust the system we believe that it is not biased, but if the
    system is corrupt, our opinion has no value. We have no other option rather than
    to trust the system.7.2.2 Blockchain Ecosystem Figure 7.2 Blockchain Ecosystem Decentralized-
    peer to peer-driven Blockchain ecosystem is different from the traditional system;
    it is decentralized peer to peer system, which means that it has no center of
    authority. Now let’s see how decentralized web application works, like our voting
    centralized website the front end is made up of the usual HTML, CSS, and JS but
    the back end and server side work complete different. Instead of having a database,
    central server or network the blockchain is a database and a network in one package.
    A blockchain is a peer-to-peer network grid of computers known as nodes, that
    share all the data and the code in the network. So, if you''re a device connected
    to the blockchain, you are a node in the network, and you talk to all the other
    compute nodes in the blockchain network. You now have a copy of all the data and
    the code on the blockchain. There are no more central servers — just a bunch of
    computers that talk to one another on the same network. So, if a person cast a
    vote every computer verify his/her vote and no one can change it. No single point
    of failure Since there is no center of authority that means no central point even
    if one node fails the copy of the data will appear on every other node so there
    will be no downtime. Every node act as a backup server and data loss is never
    going to happen. No need for trust Since Blockchain is a peer to decentralized
    peer system, there is no focal point each node in the network has equal power.
    We can say Blockchain is a democracy where every change in the Blockchain is seen
    by all the node in the network and any changes in the record can be validated
    by 51% majority. So, the chance of corruption or manipulation is very slim or
    none.7.3 Distributed Ledgers Distributed ledger technology is one of the integral
    parts of Blockchain technology and one of the founding principles of the blockchain,
    it existed even before Blockchain and Bitcoin and let''s see how it works. Distributed
    ledgers are also known as shared ledgers or Distributed ledger Technology Distributed
    ledger is a consensus that replicates the data to every node connected in the
    system that is; data is copied to every node in the system. So every system connected
    have equal access, and there is no center of authority. ![](image-butd1xhw.jpg)Figure
    7.3 Distributed Technology Distributed ledger technology has mainly three components
    they are as follows:  There must be a data model that captures the current state
    of the ledger. A language of transaction that changes the ledger state (Smart
    Contract). A protocol is used to build a consensus among participants around which
    transactions will be accepted, and in what order, by the ledger.7.4 The Principle
    of the Blockchain Blockchain work on the following principles to ensure the reliability
    and trustworthiness of a complicated system like blockchain Distributed Database The
    distributed database is one of main difference of blockchain from the traditional
    system, the data of each state is known to every node with the help of distributed
    ledger technology. A blockchain is a write-only data structure. No one can edit
    or delete data, to make blockchain more secure and trustworthy. Every transaction
    happening in the blockchain is known to every node in the network. Since the transaction
    history is shared, chance of data loss is minimal. Peer to Peer Communication The
    blockchain is technology build on the idea of decentralization. Peer to peer communication
    is way Blockchain archive decentralization. The blockchain is made up of independent
    nodes. A node makes a portion of computing resources such as disk storage, processing
    power or network bandwidth, directly available to other participants without the
    need for any central coordination by servers or stable hosts. Each peer can take
    on different roles like a miner or a full node. Each node is updated when the
    blockchain changes its state in such a way that each node will have the copy of
    the full blockchain. Transparency with Pseudonymity identity of every node connected
    to the blockchain is hidden- will, in turn, increases the transparency of the
    system this way no one can be manipulated. Transparency of data is built in the
    network as a whole. The blockchain resides in a state of consensus, which would
    automatically check itself. Due to the unique composition of a block, the data
    in a blockchain cannot be corrupted; hence changing any unit of information in
    it is almost practically impossible. However, in theory, this can be done, by
    using a large amount of computing power needed to override the entire system,
    this is not possible practically. Irreversibility of Records (immutability) The
    immutability of the data which is on the blockchain is perhaps the most important
    and compelling reason why we use blockchain in the first place — the situation
    that involves tractions. This Unchanging over time feature make blockchain more
    acceptable for many situations. We can use blockchain for accounting and financial
    transaction, identity management, and asset ownership. Once transaction information
    is stored onto the blockchain, no one can change it, or it is tough to do so. Cryptography
    based security Each transaction on the blockchain is made irreversible. This is
    achieved by use of a hash function. In the case of Bitcoin, this hash is generated
    by a node as a result of completing a complex mathematical problem.7.5 The Blockchain
    Data Structure and its Working (Case Study: Bitcoin) A blockchain is a specific
    form or sub-set of distributed ledger technologies, which constructs a chronological
    chain of blocks; hence the name A block is referred to as a set of transactions
    that are grouped together and is added to the network at the same time. A blockchain
    is a peer-to-peer distributed ledger, governed by a consensus, combined with a
    system called smart contracts. Combining all of these, they can be used to build
    the next generation of transactional applications that establish transparency,
    trust, and accountability at their center while keeping track of legal constraints
    and business processes. The blockchain then keeps track of various assets, the
    transactions are chained into blocks, and there can be any number of transactions
    per block. A block commonly consists of the following elements: ![](image-fjuomuzl.jpg)Figure
    7.4 Architecture of Bitcoin Header Block Every block in the blockchain has two
    part, transaction part and the header part. Transaction part holds the details
    of the transaction. New blocks are created when the transaction blocks gets filled.
    The blockchain header parts metadata can be divided into three parts. First part
    is a hash which is a reference to the previous(parent) block in the chain — the
    second set of the metadata help in achieving the consensus namely timestamp, difficulty,
    and nonce. Last part is the Merkel root, a data structure that stores the transaction
    details in a summarized manner efficiently. Block header hash A hash is used to
    identify the block uniquely; they are derived by hashing the block header. Each
    node computes each block''s hash, A node is a full client which is a client that
    owns the block chains and is sharing blocks and transactions across the blockchain
    network. A node is considered to be part of the blockchain infrastructure and
    does not necessarily have to be a miner. Each node keeps a copy of the ordered
    sequence of events in the form of a blockchain as the block is received from the
    blockchain network. The block hash may be stored as part of the block''s metadata,
    to facilitate indexing and faster retrieval of blocks from disk. Genesis Block The
    first block in any blockchain is known as the genesis block. From any block we
    can start at any block and follow the chain backward chronologically; you will
    arrive at the genesis block. The genesis block is statically encoded within the
    client software, which means the person who is creating a blockchain would manually
    create block’s hash, structure and other fields. These fields cannot be changed.
    Every blockchain has a secure root called Genesis Block from which the blockchain
    is built on. Time Stamp Every block contains a Unix time timestamp. It also acts
    as a source of validating for the block hash, they also make it more difficult
    for hackers to manipulate the blockchain. A timestamp is valid only if it is greater
    than the median timestamp of preceding 11 blocks, and is less than the network-adjusted
    time + 2 hours. Network-adjusted time is the median of the timestamps returned
    by all nodes connected to you. As a result, block timestamps are not precisely
    accurate, and they do not even need to be in order. Block times are accurate only
    to within an hour or two. When a node connects to another node, it gets a UTC
    timestamp from it and stores its offset from node-local UTC. The network-adjusted
    time is then the node-local UTC plus the median offset from all connected nodes.
    Network time is never adjusted more than 70 minutes from the local system time. Difficulty Difficulty
    is a measure of how difficult it is to find a hash below a given target or mine
    a hash for the transaction. It is really the time that take to produce a hash
    we don’t want to make it easy or hard to find a hash so we calculate difficult
    to make the system work smoothly. The Bitcoin network has a global block difficulty.
    Valid blocks must have a hash below this target. The value of difficulty can change,
    it depends up on the network. The difficulty adjusts every 2016 blocks (roughly
    every 2 weeks) in case of Bitcoin. Nonce A nonce is an arbitrarily chosen number
    used only once in cryptographic communication, in the spirit of a nonce word.
    They are often random or pseudo-random numbers. The nonce in a bitcoin block is
    a 32-bit field where the value of nonce is adjusted by miners so that the value
    of the hash of the block will be less than or equal to the present target of the
    blockchain network. The rest of the fields in the header block will not be changed,
    as they have a defined meaning. Any change to the block''s data such as the nonce
    would make the block hash completely different. Since it is difficult to predict
    which combination of bits will result in the correct hash, many different nonce
    values are tried, and the hash is recalculated for each value until a hash less
    than or equal to the present target of the network is found. The target required
    is also represented as the difficulty, where a higher difficulty represents a
    lower target. As this iterative calculation requires time and resources, the presentation
    of the block with the correct nonce value constitutes proof of work. Merkle Tree Merkle
    is a type of data structure used for the efficient verification and summarization
    of large collection of data. Merkle tree (Hash tree) are just binary trees that
    contain cryptographic hashes. That is why they are also known as Binary Hash Tree.
    They help in producing an overall fingerprint of the transactions conducted so
    far in the block. The tree follows a bottom-up approach. Note that the transaction
    data is not stored as such in the nodes of the Merkle tree rather, they initially
    hashed with SHA algorithm and kept in leaf nodes. The same applies to all transaction
    in the block. Consecutive nodes are combined together by concatenation of the
    hashes. These operations continue until a single node is formed at the top called
    the Merkle root and it contain the summary of all transactions in the block header. Since
    the Merkle tree is a binary tree data structure. If an odd number of transactions
    need to be summarized, the last node gets duplicated. ![](image-gc0cnysa.jpg)Figure
    7.5 Merkle Tree Structure7.6 Consensus Algorithm First of all, let us see what
    consensus is, to reach consensus means to agree on something. To arrive at a consensus
    people usually analyze the opinion of everyone to arriving at a conclusion or
    agreeing upon something. Trust is an essential part while arriving at a consensus.
    People can create ambiguity by telling lies. Only if people vouch for the person,
    his action can be trusted. Now let''s see how blockchain deals with this issue.
    How does Blockchain reach a consensus? Blockchain Consensus has two parts consensus
    and algorithm by combining them we end up with a set of rules by which all the
    nodes are approving or disapproving a transaction ending with a robust blockchain
    system. There are different types of consensus algorithm we use in blockchain
    some of the commonly used algorithms are listed as follows:7.7 Proof of Work Proof
    of Work is one of the commonly used consensuses. The most significant advantages
    of PoW is that it does not require every node to submit their opinion on the consensus.
    Instead, they use an encrypted transaction in the data block using a hash function
    to create a situation where there will be a complex mathematical equation that
    is hard to solve but easy to verify. Only one node will submit the solution. Every
    other participant within the network only verifies the conclusion. The hash function
    is developed to reject false information. In the case of Bitcoin which uses PoW,
    the person who publicly verifies the correct answer is rewarded with newly minted
    Bitcoins. The procedure of finding and verifying the valid and correct hashes
    is called Bitcoin mining. Giving rewards to Bitcoin miners increases broader participation
    and interest. A vast network of engaged members creates a safe and robust Blockchain
    where you can conduct your transactions with ease and anonymously. However, the
    disadvantage of PoW is the massive energy costs of computing. Bitcoin mining machines
    use much electricity and are considered environmentally unfriendly. Moreover,
    to become a participant, you should have a stake in the network.7.8 Proof of Stake
    (PoS) In PoS systems they use algorithms in place of hash functions reducing the
    energy costs for hash computing which makes them more environmentally friendly.
    They use simple digital signatures to validate the proof of ownership or stake.
    The system then selects a participant to verify new transactions in the database
    and create a new block in the blockchain network. The selection process is based
    on participants stake or holdings. The more stakes you have, the chances of you
    being picked increases. PoS also give rewards to help build a massive community
    of enthusiasts. A good example here is Peercoin. It uses PoS and rewards the strong
    validator with transaction fees rather than to give them newly mined coins. Minting
    is the creation of coins in PoS just like mining in PoW. While rewarding the participants
    with higher stakes will encourage them to acquire more stake, it also increases
    the risk of centralization which helps the rich get richer and have more control.7.9
    Delegated Proof of Stake Delegated Proof of Stake systems use democracy. Participants
    vote by using their coin stakes, for their representative who will verify the
    transactions in the database and receives newly minted coins. The representative
    will then share the coins with the voters based on how many coins one use to vote
    for the representative, relative to the coins used by other voters in the blockchain
    who cast a vote for the same representative. DPoS offers the flexibility by having
    many voting rounds and participants is allowed to change their vote and vote for
    a new representative if they feel like the representative has a better reputation.
    The DPoS algorithm also uses a feature called shuffle equation which makes the
    process of choosing representatives complex, reducing the chance for transaction
    interference. DPoS also reaches consensus much quicker than PoS or PoW because
    it has a small pool of delegates to choose. This poses the risk of centralization
    because representative delegates could form cartels or secretly collude. Further,
    it is designed to give more voting rights to persons who hold more coins (just
    like in PoS), and this can transfer more influence to fewer stakeholders increasing
    the risk of centralization.7.10 Smart Contacts Blockchain was initially designed
    for peer to peer money only. However, it soon showed the potential to be used
    for any peer to peer transaction on the Internet — the Ethereum project introduced
    in the idea of separating the blockchain layer from the contact layer , where
    the ledger itself is used by smart contracts that trigger transactions automatically
    when certain pre-defined conditions are met. By separating the blockchain layer
    from the smart contracts layer, blockchains like Ethereum focus on providing a
    more versatile development environment than the Bitcoin blockchain. These smart
    contracts are a segment of code that runs on top of a blockchain network, where
    digital assets are governed by a piece of code implementing arbitrary rules. They
    have properties similar to contractual agreements but should never be confused
    with legal contracts. When all parties to the smart contract satisfy the pre-defined
    arbitrary rules, the smart contract automatically executes the transaction. These
    smart contracts focus on providing transaction security superior to traditional
    contract law and reducing transaction costs of coordination and enforcement. Smart
    contracts can be used for simple financial transactions like sending money from
    point A to point B. Smart contracts can also be used for registering any ownership
    and property rights like intellectual property, and land registries , or managing
    smart access control for the sharing economy, to smart contracts can be used for
    much more complex transactions like governing a group of people that share the
    same goals and interests. Decentralized Autonomous Organizations is an example
    of complex smart ![](image-7hp1enw3.jpg) With blockchains and smart contracts,
    we can now imagine a world in which contracts are embedded in digital code and
    stored in transparent, shared databases, where they are protected from deletion,
    tampering, and revision. In this world, every agreement, every process, task ,
    and payment would have a digital record and signature that could be identified,
    validated, stored, and shared. Intermediaries like lawyers, brokers, and bankers,
    and public administrators might no longer be necessary. Individuals, organizations,
    machines, and algorithms would freely transact and interact with one another with
    little friction and a fraction of current transaction costs. Blockchains & smart
    contracts:  Radically reduce transaction costs (bureaucracy) through machine consensus
    and auto-enforceable code. Bypass the traditional principal-agent dilemmas of
    organizations, thus providing an operating system for what some refer to as trustless
    This means that you don''t have to trust people and organizations, you trust code,
    which is open source and provides transparent processes.7.11 Types of Blockchain Blockchain
    chain can be broadly classified into three types they are as follows:follows:
    follows:follows: follows:follows: follows: follows: follows: Public Blockchain Public
    Blockchain is permission less Blockchain work on the consensus of proof of work
    They are open to all. Anybody can download the code and run a public node on their
    system. They can validate transactions in the blockchain network, hence become
    a part of the consensus process – the process which determines what blocks get
    added to the chain and what current state is recorded and knows to anyone on the
    network. Anybody in the world can send transactions through the network and expect
    to see them included in the blockchain if they are valid. Anybody can read transaction
    on the .public block explorer. Transactions are transparent but anonymous/pseudonymous.
    All the cryptocurrencies such as Bitcoin and Ethereum come under public blockchain. Private
    Blockchain In Private Blockchain is a centralized Block Chain in a sense all write
    permission are kept centralized to one organization. Read permission can be set
    to public or restricted to some people part of the organization. Example applications
    include auditing, database management, and so on. which are internal to one company,
    and so public readability may in many situations not be needed at all. In other
    situations, public audit ability is desired. Private blockchains take advantage
    of blockchain technology by setting up participants and groups who verifies transactions
    internally. This creates the risk of security breaches just like in a centralized
    system, as opposed to public blockchain secured by game theoretic incentive mechanisms.
    Although, private blockchains have their use case when it comes to scalability
    and state compliance of data privacy rules and other regulatory issues. MONAX,
    Multichain are examples of Private Blockchain. Consortium or Federated Blockchain Federated
    Blockchains operate under the authority of a group. As compared to public Blockchains,
    they do not allow anyone with access to the Internet to participate in the process
    of verifying the transactions. Federated Blockchains are faster and higher scalability
    also provide more transaction privacy. Consortium blockchains are mostly used
    in the financial sector. A pre-selected set of nodes controls the consensus process;
    for example imagine a consortium of 10 financial organization, each of which operates
    a node and of which 6 must verify every block for the block to be valid. The right
    to read the details may be public, or restricted to the participants in the blockchain.
    R3 (Banks), EWF (Energy), B3i (Insurance) , Corda are examples of Consortium or
    Federated Blockchain. Difference between Public, Consortium and Private Blockchain ![](image-sj2ux6pa.jpg)7.12
    Advantage of Blockchain Save time Let''s take the case of a simple bank transaction
    it may take up to days and weeks for the transaction to be complete. This is due
    to the different verification procedure for the financial institution, and these
    banks are not open 24/7\. It works only during regular business hours 5 days a
    week. Blockchain transaction has done during any time of the day. There is no
    need of third-party verification so that transaction can be validated smoothly
    and quickly. Reduce Cost In any transaction that happens around us, like purchasing
    a film ticket or sending money to a friend, there will be intermediaries or 3rd
    party involvement in every transaction. The 3rd party is there to verify each
    transaction. These verification does not come for free. They work for financial
    benefits, and they are added to the transaction cost. Blockchain eliminates the
    3rd party hence reducing cost. Reduce risk The blockchain is a data structure
    that allows the user to make and verify transaction without a 3rd party involvement.
    This sharply reduces the risk of a backdoor transaction and unauthorized involvement.
    Blockchain work on the principle of dementalization where there is no central
    power. Every node in the network verifies the transaction. This way it becomes
    more difficult to tinker with data. Modification of transaction is a virtually
    impossible only way to manipulate transaction history is, only if we have access
    to more than 50% of nodes in the network, which is not even possible. Increasing
    trust T h e t ra nsparency in the blockchain network ensures the trust in the
    blockchain. The transparency of the data is to build within the network as a whole.
    The blockchain network lives in a state of consensus. Hence, b l o c k ch ain
    data is kept entirely accurate and consistent with all the members. If any changes
    happen to the members, Due to this if any data change happens to the public blockchain
    it is known to all the members that way data of blockchain cannot be corrupted.
    Thus, ensuring trust, b u t i n theory, this can be undone by using a considerable
    amount of computational power to override the blockchain network by controlling
    the majority of nodes in the network this is known as 51% attack, this is not
    practically possible.7.13 Disadvantage of Blockchain Even when we glorify blockchain,
    we are not thinking about the limitation. The blockchain is not a technology that
    is matured; it requires a lot of research and investment to bring out its full
    potential. Let''s see what the constraints we need to address while using Blockchain
    are. Block size and Response time All the transition in a blockchain network is
    through blocks. The size of blocks in case of bitcoin is about 1 Mb which is small;
    this limits the number of transactions in a second. Each block creation can take
    up to 10 minutes to be created and added to the blockchain network. So, this block
    size bottleneck can cause some time delay. Bitcoin can handle about 60 transactions
    per second, which is less in contrast to Visa''s peak rate of 47,000 per second.
    For it to expand into the same worldwide role as fiat currency, cryptocurrency
    must be able to process much higher numbers of transactions. Human Error Well,
    let''s consider blockchain as a database that stores transaction details every
    transaction recorded are saved to the database same as a centralized system. However,
    when a person enters faulty details into the network accidentally it gets saved
    to the system and cannot be changed, for example, the owner''s name of the car
    is spelled wrong and add to blockchain it will be saved under the wrong name,
    and it is an even bigger task to change it. So, it is preferred that the information
    going into the database is of high quality. The phrase garbage in, garbage out
    holds true in a blockchain system of record, just as with a centralized database. Standards Industry
    standards, legal, and governance frameworks needed for robustness, overall performance
    and security to adopt Blockchain on an industrial scale, there are no governing
    body or standard for blockchain. Only if there is a governing body that standardizes
    the way to implement block-chain then only blockchain will gain trust. Diverging
    interest Replacing existing infrastructure will need time and investment. Since
    blockchain is a disruptive technology, there are Conflicting interests. Some are
    ready to change to blockchain some are totally against it. There is a lack of
    expertise in blockchain in all IT companies; there is a need for teaching the
    existing staff the new technology and coming up with ideas to apply blockchain.
    Moreover, only if the dilemma to blockchain is solved everyone would try to use
    blockchain in daily life.7.14 Future of Blockchain Blockchain has the potential
    to disrupt not only the Internet but also top-down organizations. We are entering
    a new era of the Internet of agreements which are enabled by the Blockchain. Blockchain
    technology could be applied to the following:  Banking E-Government Energy Internet
    of Things Accounting Supply Chain Insurance Governance Blockchains are one of
    the building blocks for greater future innovations. When combined with AI, IoT
    and 3D printing we might enter the new era of humanity. The future of the web
    is decentralized without middlemen. Decentralized Autonomous Organizations might
    disrupt traditional governance. The first successful DAO was Bitcoin and this
    is only the beginning of a series of DAOs to come. Let see what the future holds
    for us.'
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
