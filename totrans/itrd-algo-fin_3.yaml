- en: ''
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Part III
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 第三部分
- en: Blockchain and Cryptocurrency
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链和加密货币
- en: Chapter 16
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第16章
- en: Background Concepts for Blockchain
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链的背景概念
- en: Understanding blockchain requires some background in two different areas of
    computer science and mathematics, namely cryptography and distributed computing.
    In this chapter, we provide a minimal introduction to these two areas.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 理解区块链需要一些计算机科学和数学的背景知识，即密码学和分布式计算。在本章中，我们对这两个领域进行了最基本的介绍。
- en: 16.1 Cryptography
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.1 密码术
- en: 16.1.1 Cryptographic Hash Function
  id: totrans-7
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.1.1 密码哈希函数
- en: Digital information appears in various forms. Examples would be messages on
    social networks, financial transactions and images. Whatever be the form, at a
    very basic level, any particular digital information can be considered to be a
    sequence of bits. The length of the sequence is not fixed. It can vary quite a
    bit, from a few hundred bits for a short message to a billion (or more) bits for
    a large image.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 数字信息以各种形式出现，例如社交网络上的消息、金融交易和图像。无论形式如何，在非常基本的层面上，任何特定的数字信息都可以被视为一系列位。序列的长度不是固定的，它可以有很大的变化，从一个短消息的几百位到一个大图像的十亿（甚至更多）位。
- en: A fundamental requirement in many cryptographic applications is the ability
    to associate a unique identifier to any digital information. Such an identifier
    is typically a short fixed length binary string. In many cases, it is more convenient
    to work with the unique identifier of a digital information rather than the information
    itself. Conventionlly, the digital information is called the *message* and the
    associated unique identifier is called the *digest* of the message.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多加密应用中，一个基本要求是能够将唯一标识符与任何数字信息关联起来。这样的标识符通常是一个短的固定长度的二进制字符串。在许多情况下，与数字信息的唯一标识符一起工作会更方便，而不是直接使用数字信息本身。通常，数字信息被称为*消息*，而关联的唯一标识符被称为*摘要*。
- en: A hash function is a method for computing the digest corresponding to any given
    message. Different hash functions give rise to different methods for computing
    a digest. Nevertheless, any such hash function should satisfy certain properties
    discussed below.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希函数是计算与任何给定消息对应的摘要的方法。不同的哈希函数导致不同的计算摘要的方法。然而，任何这样的哈希函数都应满足下面讨论的某些特性。
- en: '*Domain*: The domain of the hash function is ![inline-image](../images/CH016_1.jpg)
    where ![inline-image](../images/CH016_2.jpg) is a constant. This means that the
    hash function can be used to compute the digest of messages having lengths from
    0 (corresponding to the empty string) to ![inline-image](../images/CH016_3.jpg).
    Usually ![inline-image](../images/CH016_4.jpg) is taken to be a very large value
    such as 2^(64).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*域*：哈希函数的域是![inline-image](../images/CH016_1.jpg)，其中![inline-image](../images/CH016_2.jpg)是一个常数。这意味着哈希函数可以用于计算具有长度从0（对应空字符串）到![inline-image](../images/CH016_3.jpg)的消息的摘要。通常情况下，![inline-image](../images/CH016_4.jpg)被取为一个非常大的值，如2^(64)。'
- en: '*Range*: The range of the hash function is ![inline-image](../images/CH016_5.jpg),
    where *n* is a constant. This means that the digest produced by the hash function
    on any message is an *n*-bit string. The choice of *n* is determined by certain
    security considerations. Typically, *n* = 256 or higher.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*值域*：哈希函数的值域为 ![inline-image](../images/CH016_5.jpg)，其中 *n* 是一个常数。这意味着哈希函数对任何消息产生的摘要都是一个
    *n* 位的字符串。选择 *n* 受到一定的安全考虑的影响。通常情况下，*n* = 256 或更高。'
- en: '*Efficiency*: In many applications, it is routinely required to compute digests
    of millions of messages. So, a basic requirement is that it should be very fast
    to evaluate the application of the hash function to a message.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*效率*：在许多应用中，通常需要计算数百万条消息的摘要。因此，基本要求是计算哈希函数应用于消息的过程应该非常快速。'
- en: Formally, a hash function is a map
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 形式上，哈希函数是一个映射
- en: '![display-image](../images/CH016_6.jpg)(16.1)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![display-image](../images/CH016_6.jpg)(16.1)'
- en: where ![inline-image](../images/CH016_7.jpg) and ![inline-image](../images/CH016_8.jpg)
    are finite non-empty sets with ![inline-image](../images/CH016_9.jpg). Here, ![inline-image](../images/CH016_10.jpg)
    denotes the cardinality of a finite set *S*, i.e. the number of elements in *S*.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 ![inline-image](../images/CH016_7.jpg) 和 ![inline-image](../images/CH016_8.jpg)
    是有限非空集合，满足 ![inline-image](../images/CH016_9.jpg)。这里，![inline-image](../images/CH016_10.jpg)
    表示有限集合 *S* 的基数，即 *S* 中的元素数量。
- en: Note that the domain of a hash function is larger than its range. This implies
    that there cannot be a unique digest for every message in the domain of the hash
    function. Recall that we had motivated hash functions by the requirement of ensuring
    unique digests. Clearly, the condition of the domain being larger than the range
    and the requirement of unique digests are contradictory. This contradiction is
    resolved in the following manner.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希函数的定义域大于其值域。这意味着哈希函数的定义域中不可能有唯一的摘要与每个消息对应。回想我们之前为哈希函数提出的要求是确保唯一摘要。显然，定义域大于值域的条件和唯一摘要的要求是矛盾的。这种矛盾以以下方式解决。
- en: Let *M* and ![inline-image](../images/CH016_11.jpg) be two distinct elements
    of ![inline-image](../images/CH016_12.jpg) such that ![inline-image](../images/CH016_13.jpg).
    The pair of messages ![inline-image](../images/CH016_14.jpg) is called a collision
    for *H*. It is true that if *H* is evaluated on all elements in its domain, then
    collisions will certainly arise. However, since the domain is very large, in practice
    it will not be possible to evaluate *H* on the entire domain. Compared to the
    size of the domain, the hash function will be evaluated on only an insignificant
    fraction of the domain. To ensure the uniqueness of the digests, it is sufficient
    for the hash function to behave like an injective function on the inputs on which
    it is actually evaluated. This in particular means that in practice collisions
    should not arise. This leads to the following required property of a hash function.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让*M*和![inline-image](../images/CH016_11.jpg)成为![inline-image](../images/CH016_12.jpg)的两个不同元素，使得![inline-image](../images/CH016_13.jpg)。消息对![inline-image](../images/CH016_14.jpg)被称为*H*的一次碰撞。确实，如果在其定义域上对*H*进行评估，碰撞肯定会发生。但是，由于定义域非常大，在实践中将无法对*H*进行整个定义域的评估。与定义域的大小相比，哈希函数只会在定义域的微不足道的一小部分上进行评估。为了确保摘要的唯一性，哈希函数只需在实际评估的输入上表现得像一个单射函数即可。特别是，这意味着在实践中不应该发生碰撞。这导致哈希函数的以下所需特性。
- en: '**Collision-Resistant Hash Function (CRHF):** A hash function *H* is said to
    be collision resistant if it is *computationally difficult* to find a collision
    for *H*. Computational difficulty in the present context means that given reasonable
    computational resources, it should not be possible to find a collision for *H*
    in a reasonable amount of time.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**抗碰撞哈希函数（CRHF）：** 如果哈希函数*H*很难找到一个碰撞，那么称为抗碰撞的哈希函数。在当前的语境中，计算困难意味着在合理的计算资源下，不应该能够在合理的时间内找到*H*的碰撞。'
- en: We have mentioned above that it should be possible to evaluate a hash function
    very fast, i.e. given a message *M*, it should be possible to compute the digest
    *H*(*M*) within a (very small) fraction of a second. Consider the converse problem.
    Suppose that we are given a digest *y* which is an *n*-bit string. How difficult
    is it to find a message *M* such that *H*(*M*) = *y*? More generally, how difficult
    is it to find a pre-image of any given digest? One way to find a pre-image is
    to repeatedly apply *H* to different messages until a message is found which maps
    under *H* to *y*. Since there are 2 ^([*n*]) possible digests, this procedure
    may require applying *H* to 2 ^([*n*]) messages. A requirement on a hash function
    is that there should essentially be no better way of finding a pre-image.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到过，应该能够非常快速地评估一个哈希函数，即，给定一个消息*M*，应该能够在（非常小的）一秒内计算出摘要*H*(*M*)。考虑相反的问题。假设我们给定了一个*n*比特字符串的摘要*y*。找到一个消息*M*，使得*H*(*M*)
    = *y*，有多难呢？更一般地说，找到任何给定摘要的原像有多难呢？一种找到原像的方法是反复将*H*应用于不同的消息，直到找到一个消息，该消息在*H*下映射到*y*。由于存在2
    ^([*n*])个可能的摘要，这个过程可能需要将*H*应用于2 ^([*n*])个消息。对哈希函数的一个要求是基本上没有更好的方法来找到原像。
- en: '**One-Way Hash Function (OWHF):** A hash function *H* is said to be one way,
    if it is *computationally difficult* to find a pre-image of any element in the
    range of *H*.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**单向哈希函数（OWHF）：** 如果一个哈希函数 *H* 被认为是单向的，那么在 *H* 的值域中找到任何元素的原像是*计算难度*的。'
- en: Suppose that *M* and *y* are known such that *H*(*M*) = *y*. One may wish to
    find a message ![inline-image](../images/CH016_15.jpg) such that ![inline-image](../images/CH016_16.jpg).
    In other words, one pre-image of *y* under *H* is known to be *M* and the problem
    is to find another pre-image of *y*. This is not the same as asking for a pre-image
    of *y*. Neither is it the same as asking for a collision for *H*, since in a collision,
    one simply asks for a pair of distinct messages *M* and ![inline-image](../images/CH016_17.jpg)
    such that ![inline-image](../images/CH016_18.jpg); this is different from first
    specifying *y* and *M* and then asking for ![inline-image](../images/CH016_19.jpg).
    In fact, evidence suggests that finding a second pre-image has the same difficulty
    level as finding a pre-image and is actually a much more difficult task than finding
    a collision.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 假设已知 *M* 和 *y*，使得 *H*(*M*) = *y*。一个可能希望找到一个消息 ![inline-image](../images/CH016_15.jpg)，使得
    ![inline-image](../images/CH016_16.jpg)。换句话说，已知*H*下的*y*的一个原像是*M*，问题是找到另一个*y*的原像。这不同于请求*y*的原像。也不同于要求*H*的冲突，因为在冲突中，只需请求一对不同的消息*M*和![inline-image](../images/CH016_17.jpg)，使得![inline-image](../images/CH016_18.jpg)；这与首先指定*y*和*M*然后请求![inline-image](../images/CH016_19.jpg)是不同的。事实上，有证据表明找到第二个原像的难度与找到一个原像的难度相同，实际上比找到一个冲突要困难得多。
- en: '**Second Pre-Image-Resistant Hash Function:** A hash function *H* is said to
    be second pre-image resistant if it is *computationally difficult* to perform
    the following task. For any element in the range of *H*, given one of its pre-images,
    find a second one (or report that there is no second pre-image).'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**二次预像抗碰撞哈希函数：** 哈希函数 *H* 被称为二次预像抗碰撞的，如果对于执行以下任务来说是计算难度较大的。对于 *H* 的任何一个值域中的元素，在给定其中一个原像的情况下，找到第二个（或者报告没有第二个原像）是困难的。'
- en: Later, we justify the collision-resistant, one-way and the second pre-image-resistant
    properties of hash functions in the context of blockchain.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 后来，在区块链的上下文中，我们证明了哈希函数的抗碰撞、单向和二次预像抗碰撞的性质。
- en: 16.1.2 Hash Function as a Random Oracle
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.1.2 哈希函数作为随机预言机
- en: A cryptographic hash function is often modelled as a random oracle. Here a random
    oracle is a uniform random function from ![inline-image](../images/CH016_20.jpg)
    to ![inline-image](../images/CH016_21.jpg). Recall that ![inline-image](../images/CH016_22.jpg)
    and ![inline-image](../images/CH016_23.jpg) are finite non-empty sets. So, the
    set ![inline-image](../images/CH016_24.jpg) of all functions from ![inline-image](../images/CH016_25.jpg)
    to ![inline-image](../images/CH016_26.jpg) is a finite set. Suppose ![inline-image](../images/CH016_27.jpg)
    is a function chosen uniformly at random from ![inline-image](../images/CH016_28.jpg).
    Such an ![inline-image](../images/CH016_29.jpg) is said to be a random oracle.
    The function ![inline-image](../images/CH016_30.jpg) is viewed in the following
    manner. It is queried on an element of ![inline-image](../images/CH016_31.jpg)
    and returns an element of ![inline-image](../images/CH016_32.jpg). A crucial property
    of a random oracle is the following. Suppose *M* 1,…,*M* *k* are distinct elements
    of ![inline-image](../images/CH016_33.jpg). Then ![inline-image](../images/CH016_34.jpg)
    are *independent and uniform random* elements of ![inline-image](../images/CH016_35.jpg).
    Note that ![inline-image](../images/CH016_36.jpg) is a function, so if it is evaluated
    on the same input twice, it will return the same answer.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 密码学哈希函数通常被建模为随机预言机。在这里，随机预言机是一个从 ![inline-image](../images/CH016_20.jpg) 到 ![inline-image](../images/CH016_21.jpg)
    的均匀随机函数。请记住，![inline-image](../images/CH016_22.jpg) 和 ![inline-image](../images/CH016_23.jpg)
    是有限非空集合。因此，从 ![inline-image](../images/CH016_24.jpg) 到 ![inline-image](../images/CH016_26.jpg)
    的所有函数的集合是一个有限集合。假设 ![inline-image](../images/CH016_27.jpg) 是从 ![inline-image](../images/CH016_28.jpg)
    均匀随机选择的函数。这样的 ![inline-image](../images/CH016_29.jpg) 被称为随机预言机。函数 ![inline-image](../images/CH016_30.jpg)
    的视图如下。它在 ![inline-image](../images/CH016_31.jpg) 的元素上查询并返回 ![inline-image](../images/CH016_32.jpg)
    的元素。随机预言机的一个关键属性如下。假设 *M* 1,…,*M* *k* 是 ![inline-image](../images/CH016_33.jpg)
    的不同元素。那么 ![inline-image](../images/CH016_34.jpg) 是 ![inline-image](../images/CH016_35.jpg)
    中的*独立和均匀随机*元素。请注意，![inline-image](../images/CH016_36.jpg) 是一个函数，因此如果它在相同的输入上评估两次，它将返回相同的答案。
- en: Even though ![inline-image](../images/CH016_37.jpg) is a random oracle, the
    domain is still larger than the range. So, ![inline-image](../images/CH016_38.jpg)
    will still have collisions. Let us consider the difficulty of finding a collision
    for ![inline-image](../images/CH016_39.jpg). The only way to evaluate ![inline-image](../images/CH016_40.jpg)
    is by querying it on (distinct) messages *M* 1,…,*M* *k* . Suppose ![inline-image](../images/CH016_41.jpg)
    are the corresponding outputs. The probability that ![inline-image](../images/CH016_42.jpg)
    are all distinct is
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管![inline-image](../images/CH016_37.jpg)是一个随机预言机，但定义域仍然大于值域。因此，![inline-image](../images/CH016_38.jpg)仍然会发生碰撞。让我们考虑找到![inline-image](../images/CH016_39.jpg)碰撞的难度。评估![inline-image](../images/CH016_40.jpg)的唯一方法是在（不同的）消息*M*1,…,*M*k上查询它。假设![inline-image](../images/CH016_41.jpg)是相应的输出。![inline-image](../images/CH016_42.jpg)都是不同的概率是
- en: '![display-image](../images/CH016_43.jpg)(16.2)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![display-image](../images/CH016_43.jpg)(16.2)'
- en: For ![inline-image](../images/CH016_44.jpg), it can be shown that ![inline-image](../images/CH016_45.jpg).
    The probability of obtaining a collision is ![inline-image](../images/CH016_46.jpg).
    For *k* about ![inline-image](../images/CH016_47.jpg), the probability of obtaining
    a collision becomes greater than ![inline-image](../images/CH016_48.jpg). The
    value ![inline-image](../images/CH016_49.jpg) is called the birthday bound (following
    the so-called birthday paradox). So, if ![inline-image](../images/CH016_50.jpg)
    is queried on ![inline-image](../images/CH016_51.jpg) distinct messages, then
    finding a collision becomes likely.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 对于![inline-image](../images/CH016_44.jpg)，可以证明![inline-image](../images/CH016_45.jpg)。获得碰撞的概率是![inline-image](../images/CH016_46.jpg)。对于大约![inline-image](../images/CH016_47.jpg)的*k*，获得碰撞的概率大于![inline-image](../images/CH016_48.jpg)。值![inline-image](../images/CH016_49.jpg)被称为生日界限（遵循所谓的生日悖论）。因此，如果在![inline-image](../images/CH016_51.jpg)上查询![inline-image](../images/CH016_50.jpg)不同的消息，那么找到碰撞就变得可能。
- en: A concrete hash function *H* is not a random oracle. Often, however, it is assumed
    that *H* behaves like a random oracle. In particular, it is expected that *H*
    would need to be evaluated on ![inline-image](../images/CH016_52.jpg) distinct
    messages before obtaining a collision. The random oracle assumption on *H* is
    also often used to (heuristically) argue about the distribution of the outputs
    of *H*.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 具体的哈希函数*H*不是一个随机预言机。然而，通常假设*H*的行为类似于随机预言机。特别是，人们期望在获得碰撞之前需要对*H*进行![inline-image](../images/CH016_52.jpg)次评估。对*H*的随机预言机假设也经常用于（启发式地）论证*H*的输出分布。
- en: 16.1.3 Digital Signature Schemes
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.1.3数字签名方案
- en: A signature is a key component of any contract. It affirms the signer's commitment
    to the contract in a manner which cannot be repudiated in the future. In the digital
    world, a digital signature fulfills a role similar to that of a handwritten signature
    in the physical world. A digital signature is not, however, an exact analogue
    of a physical handwritten signature. We do not get into the finer distinctions
    between digital and physical signatures. Instead, we provide below a high-level
    overview of digital signatures.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 签名是任何合同的关键组成部分。它确认了签署者对合同的承诺，这种承诺在未来无法否认。在数字世界中，数字签名履行了类似于物理世界中手写签名的角色。然而，数字签名并不是物理手写签名的确切类比。我们不深入讨论数字和物理签名之间的细微差别。相反，我们在下面提供了数字签名的高级概述。
- en: An electronic contract (e-contract) is a digital document. Like a physical contract,
    an e-contract requires a non-repudiable commitment from the parties involved in
    the contract. This is achieved by affixing the digital signatures of the parties
    to the contract. Suppose Alice signs a digital document *M* to produce a signature
    *s*. There are two basic requirements from any such digital signature. First,
    it must be guaranteed that only Alice could have produced *s* on the message *M*.
    Second, given *M* and *s*, it must be possible for any other party (say Bob) to
    verify that *s* is indeed Alice's signature on *M*. The first condition requires
    Alice to possess some information which is available only to her. This is called
    Alice's signing (or secret) key ![inline-image](../images/CH016_53.jpg). To enable
    the second condition of public verifiability by Bob, Alice has to make public
    some information corresponding to her secret key. This is called Alice's verification
    (or public) key ![inline-image](../images/CH016_54.jpg).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 电子合同（e-合同）是一种数字文档。像物理合同一样，e-合同需要合同参与方的不可否认的承诺。这通过在合同上附上各方的数字签名来实现。假设爱丽丝签署了数字文档*M*以产生签名*s*。任何这样的数字签名都有两个基本要求。首先，必须保证只有爱丽丝才能在消息*M*上产生*s*。其次，给定*M*和*s*，任何其他方（比如鲍勃）都必须能够验证*s*确实是爱丽丝在*M*上的签名。第一个条件要求爱丽丝拥有一些仅她知道的信息。这称为爱丽丝的签名（或秘密）密钥
    ![inline-image](../images/CH016_53.jpg)。为了使鲍勃能够进行公开验证的第二个条件，爱丽丝必须公开一些与她的秘密密钥对应的信息。这称为爱丽丝的验证（或公开）密钥
    ![inline-image](../images/CH016_54.jpg)。
- en: 'More formally, a digital signature scheme consists of three procedures (or
    algorithms): ![inline-image](../images/CH016_55.jpg). Alice runs the ![inline-image](../images/CH016_56.jpg)
    algorithm to produce a matched pair of signing-verification key ![inline-image](../images/CH016_57.jpg).
    She keeps ![inline-image](../images/CH016_58.jpg) secret and publishes ![inline-image](../images/CH016_59.jpg)
    as her verification key. To sign a message *M*, Alice uses the ![inline-image](../images/CH016_60.jpg)
    algorithm on *M* and ![inline-image](../images/CH016_61.jpg) to produce a signature
    *s*. She then provides (*M*, *s*) as the message-signature pair. To verify, Bob
    uses the ![inline-image](../images/CH016_62.jpg) algorithm on (*M*, *s*) and ![inline-image](../images/CH016_63.jpg);
    if the answer of ![inline-image](../images/CH016_64.jpg) is ‘yes’, Bob accepts
    *s* as Alice''s signature on *M*, while if the answer is ‘no’, Bob rejects the
    message-signature pair.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 更正式地说，数字签名方案由三个过程（或算法）组成：![内联图片](../images/CH016_55.jpg)。爱丽丝运行![内联图片](../images/CH016_56.jpg)算法以生成一对匹配的签名-验证密钥![内联图片](../images/CH016_57.jpg)。她保持![内联图片](../images/CH016_58.jpg)保密，并发布![内联图片](../images/CH016_59.jpg)作为她的验证密钥。为了签署一条消息*M*，爱丽丝对*M*使用![内联图片](../images/CH016_60.jpg)算法和![内联图片](../images/CH016_61.jpg)以生成签名*s*。然后，她提供(*M*,
    *s*)作为消息-签名对。为了验证，鲍勃对(*M*, *s*)使用![内联图片](../images/CH016_62.jpg)算法和![内联图片](../images/CH016_63.jpg);
    如果![内联图片](../images/CH016_64.jpg)的答案是‘是’，鲍勃接受*s*作为爱丽丝对*M*的签名，而如果答案是‘否’，鲍勃拒绝消息-签名对。
- en: Note that the algorithms ![inline-image](../images/CH016_65.jpg) are not specific
    to Alice. Any other entity, say Charles, can also use ![inline-image](../images/CH016_66.jpg)
    to generate his signing and verification keys ![inline-image](../images/CH016_67.jpg)
    and ![inline-image](../images/CH016_68.jpg), respectively; and use ![inline-image](../images/CH016_69.jpg)
    with ![inline-image](../images/CH016_70.jpg) to sign a message. Further, ![inline-image](../images/CH016_71.jpg)
    can be used by Bob to verify signatures generated by Charles.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，算法![内联图片](../images/CH016_65.jpg)并不特定于爱丽丝。任何其他实体，比如查尔斯，也可以使用![内联图片](../images/CH016_66.jpg)生成他的签名和验证密钥![内联图片](../images/CH016_67.jpg)和![内联图片](../images/CH016_68.jpg)，并使用![内联图片](../images/CH016_69.jpg)与![内联图片](../images/CH016_70.jpg)来签署一条消息。此外，![内联图片](../images/CH016_71.jpg)还可以被鲍勃用来验证查尔斯生成的签名。
- en: A key requirement of a digital signature scheme is non-repudiability. If Alice
    claims *s* is her signature on a message *M*, then later she cannot go back on
    her claim and deny that she signed *M*. This is achieved by ensuring that ![inline-image](../images/CH016_72.jpg)
    will return ‘yes’ on inputs (*M*, *s*) and ![inline-image](../images/CH016_73.jpg)
    if and only if *s* was produced by applying ![inline-image](../images/CH016_74.jpg)
    on inputs *M* and ![inline-image](../images/CH016_75.jpg). Since ![inline-image](../images/CH016_76.jpg)
    is known only to Alice, it is concluded that she must have signed the message.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 数字签名方案的一个关键要求是不可否认性。如果爱丽丝声称*s*是她在消息*M*上的签名，那么她以后不能撤回她的声明并否认她签署了*M*。这通过确保当且仅当*s*是通过在*M*和的输入上应用![inline-image](../images/CH016_74.jpg)得到的时，![inline-image](../images/CH016_72.jpg)对(*M*,
    *s*)的输入返回“是”，并且![inline-image](../images/CH016_73.jpg)。由于![inline-image](../images/CH016_76.jpg)仅为爱丽丝所知，因此可以得出结论她必须已经签署了消息。
- en: For any signature scheme (digital or physical), the major threat is the possibility
    of forging a signature. Note that message-signature pairs are public. So, it is
    possible for a forger, say Eve, to obtain several valid message-signature pairs
    (*M* 1, *s* 1),…,(*M* [*k*] , *s* *k* ) produced by Alice using her signing key
    ![inline-image](../images/CH016_77.jpg). Eve does not have access to ![inline-image](../images/CH016_78.jpg).
    Suppose that after studying the obtained valid message-signature pairs produced
    by Alice, Eve produces a pair ![inline-image](../images/CH016_79.jpg) which is
    not equal to ![inline-image](../images/CH016_80.jpg) for any *i*. Further, suppose
    that running ![inline-image](../images/CH016_81.jpg) on ![inline-image](../images/CH016_82.jpg)
    and ![inline-image](../images/CH016_83.jpg) results in a ‘yes’ answer. So, ![inline-image](../images/CH016_84.jpg)
    is a message-signature pair which has not been produced by Alice, yet it verifies
    under her verification key. This means that Eve has successfully managed to forge
    a signature of Alice. A secure digital signature scheme should disallow such forgeries.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何签名方案（数字或物理），主要威胁是伪造签名的可能性。请注意，消息-签名对是公开的。因此，对于伪造者（比如夏娃），可以获得由爱丽丝使用她的签名密钥![inline-image](../images/CH016_77.jpg)生成的几个有效的消息-签名对(*M*
    1, *s* 1),…,(*M* [*k*], *s* *k* )。夏娃无法访问![inline-image](../images/CH016_78.jpg)。假设在研究由爱丽丝生成的获得的有效消息-签名对之后，夏娃产生了一个对*[inline-image](../images/CH016_79.jpg)*不等于任何*i*的对。此外，假设在![inline-image](../images/CH016_82.jpg)和![inline-image](../images/CH016_83.jpg)上运行![inline-image](../images/CH016_81.jpg)的结果是“是”。因此，![inline-image](../images/CH016_84.jpg)是一个消息-签名对，它没有由爱丽丝生成，但在她的验证密钥下验证。这意味着夏娃成功地伪造了爱丽丝的签名。安全的数字签名方案应该阻止这样的伪造。
- en: 16.2 Distributed Computing
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.2 分布式计算
- en: Distributed computing is a very broad notion. A basic feature of a distributed
    computing system is a collection of computers which are connected by a network.
    More generally, one may consider the computers to be the components of the system.
    The components interact among themselves by passing messages to each other using
    the network.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式计算是一个非常广泛的概念。分布式计算系统的一个基本特征是由网络连接的计算机集合。更一般地，可以将计算机视为系统的组成部分。这些组件通过使用网络相互交互，通过向彼此发送消息来实现交互。
- en: The topology of the network can be varied. Rarely is it the case where all nodes
    are directly connected to each other since such a connection structure would be
    very expensive. The topology could be structured, where the graph describing the
    interconnection network has some kind of a regular structure. Distributed computing
    systems based on the Internet, however, have an unstructured topology. Each component
    can communicate directly with only a small number of neighbours.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 网络的拓扑结构可以是多样的。很少情况下所有节点都直接连接在一起，因为这样的连接结构将会非常昂贵。拓扑结构可以是结构化的，其中描述相互连接网络的图具有某种规则结构。然而，基于互联网的分布式计算系统具有非结构化的拓扑结构。每个组件只能与少数邻居直接通信。
- en: The components operate asynchronously, i.e. there is no global clock determining
    which component does what at each time step. Further, the components can operate
    concurrently and pass messages to other components as and when required. One important
    characteristic is that components can fail. The failures occur independently and
    also asynchronously. Failure does not necessarily mean stoppage of operation.
    A failed component could be producing ‘garbage’ messages. In an adversarial scenario,
    a component could come under the control of an adversary who can then send out
    messages from the compromised component in order to mislead the operating components.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这些组件以异步方式运行，即没有全局时钟确定每个时间步骤中哪个组件执行什么操作。此外，这些组件可以并行运行，并在需要时向其他组件传递消息。一个重要的特点是组件可能会发生故障。故障会独立发生，并且异步发生。故障并不一定意味着操作停止。一个失败的组件可能会产生‘垃圾’消息。在对抗性场景中，一个组件可能会受到对手控制，然后从被损坏的组件发送消息，以误导正在运行的组件。
- en: The goal of a distributed computing system is to get some work done. The nature
    of the work could be to perform a joint computation of some computational task.
    Each component performs a portion of the work and sends to one special component.
    This component pools together the inputs from the various components to compute
    the final result. Alternatively, the task could be for the components to agree
    upon a common value. Since the components are distributed and communicate only
    using the network, this task itself is quite complex. In addition, it is required
    to perform the task under possible failure or possible malicious control of the
    components.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式计算系统的目标是完成一些工作。工作的性质可能是执行某些计算任务的联合计算。每个组件执行工作的一部分，并将其发送给一个特殊的组件。该组件将来自各个组件的输入汇集在一起，计算出最终结果。或者，任务可能是让组件就一个共同的值达成一致。由于组件是分布式的，并且仅使用网络进行通信，因此这个任务本身就非常复杂。此外，还需要在可能的组件故障或可能的恶意控制下执行任务。
- en: There are several types of distributed computing networks. Two typical examples
    are the client–server networks and the peer-to-peer (P2P) networks. In the client–server
    network, there is a set of clients, each of which can connect to a background
    server as and when required. Typically, clients may use the server to authenticate
    a user or to complete some heavy computation. The client–server model is not very
    relevant for blockchains, so we do not discuss it any further.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种类型的分布式计算网络。两个典型的例子是客户端-服务器网络和点对点（P2P）网络。在客户端-服务器网络中，有一组客户端，每个客户端都可以在需要时连接到一个后台服务器。通常，客户端可能使用服务器对用户进行身份验证或完成一些繁重的计算。客户端-服务器模型对区块链不太相关，因此我们不再进一步讨论。
- en: 16.2.1 Peer-to-Peer Network
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.2.1 点对点网络
- en: A P2P network is an interconnected network of components (sometimes called nodes).
    There is no central administrative system. All the peers, i.e. the nodes, have
    equal rights (hence the name peer). Note that equal rights does not necessarily
    mean equal computational resources. Two nodes could have different amounts of
    computing powers, yet as far as access to common resources of the network is concerned,
    both the nodes would have the same rights.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: P2P网络是一个相互连接的组件（有时称为节点）网络。没有中央管理系统。所有对等体，即节点，具有相等的权利（因此称为对等体）。请注意，相等的权利并不一定意味着相等的计算资源。两个节点可能具有不同数量的计算能力，但就访问网络的共享资源而言，这两个节点将具有相同的权利。
- en: A node in a P2P network may supply its computational resources to the other
    nodes. Alternatively, it may also utilise the resources of the other nodes for
    its purposes. So, a node is both a supplier and a consumer of resources. Well-known
    examples of P2P networks are file sharing systems.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: P2P网络中的一个节点可以向其他节点提供其计算资源。或者，它也可以利用其他节点的资源来完成自己的目的。因此，一个节点既是资源的提供者，也是资源的消费者。点对点网络的著名例子是文件共享系统。
- en: P2P networks usually do not have any structure. A node forwards messages to
    (a subset of) its neighbours. Any such message is then further relayed to the
    neighbours of the neighbours and so on and may ultimately reach all the nodes
    of the system. The manner in which nodes communicate using the network is determined
    by a protocol.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: P2P 网络通常没有任何结构。一个节点将消息转发给（一部分）邻居。任何此类消息然后进一步转发给邻居的邻居，依此类推，最终可能到达系统的所有节点。节点使用网络进行通信的方式由协议确定。
- en: 16.2.2 Gossip Protocol
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.2.2 八卦协议
- en: A gossip protocol is a template for P2P communication. It is based on how epidemics
    spread. Peer-to-peer gossip is used to ensure that data are routed to all members
    of a network. There are two possible purposes. The first is dissemination of data,
    and the second is aggregation of data. In the context of blockchain, dissemination
    of data is more relevant.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一个八卦协议是 P2P 通信的模板。它基于流行病传播的原理。点对点八卦用于确保数据被路由到网络的所有成员。有两种可能的目的。第一种是数据的传播，第二种是数据的聚合。在区块链的背景下，数据的传播更为相关。
- en: A gossip protocol is not unique, though any gossip protocol possesses some relevant
    features. A node interacts with some of its neighbouring nodes in a periodic manner,
    i.e. after some fixed interval of time, a node sends its data to its neighbours
    and receives their data. Each such interaction exchanges only a limited amount
    of information. Usually, some randomness is used by a node in selecting the nodes
    with which it will communicate. Since a node sends out the data to a number of
    nodes, there is an implicit redundancy in the system. The same data may reach
    a particular node using two different paths.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 八卦协议并不是唯一的，尽管任何八卦协议都具有一些相关特征。一个节点以周期性的方式与其一些相邻节点交互，即在一定时间间隔之后，一个节点向其邻居发送其数据并接收它们的数据。每次这样的交互仅交换有限量的信息。通常，一个节点在选择与其通信的节点时会使用一些随机性。由于一个节点向多个节点发送数据，系统中存在隐含的冗余。相同的数据可能通过两条不同的路径到达特定的节点。
- en: The communication among nodes is not assumed to be reliable. Links may fail,
    nodes may fail. Also, as mentioned above, one or more nodes may come under the
    control of an adversary. It is a challenge to achieve some notion of reliable
    communication even under such circumstances.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 节点之间的通信并不假定是可靠的。链接可能失败，节点可能失败。此外，如上所述，一个或多个节点可能受到对手的控制。在这种情况下，即使在这种情况下，实现某种可靠通信的概念也是一项挑战。
- en: 16.2.3 Byzantine Agreement
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.2.3 拜占庭协议
- en: In the above discussion, we have mentioned the possibility of malicious behaviour
    of participating nodes. Let us consider this in a little more detail. Suppose
    each of the nodes has some input (say a bit) and the goal is for all the nodes
    to decide on a common value. This common value must somehow depend on one or more
    of the inputs, as otherwise the problem becomes trivial; all the nodes agree on
    some constant value (say 1). To start with, assume for simplicity that any two
    nodes communicate directly. Typically, the nodes would be connected using a P2P
    network and a node would have to use the gossip protocol of the node to send a
    message to all the other nodes in the network.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '在上述讨论中，我们已经提到了参与节点可能存在恶意行为的可能性。让我们更详细地考虑一下这个问题。假设每个节点都有一些输入（比如一个位），目标是让所有节点决定一个共同的值。这个共同的值必须在某种程度上依赖于一个或多个输入，否则问题就变得太简单了；所有节点都会同意某个常量值（比如1）。首先，为简单起见，假设任意两个节点可以直接通信。通常情况下，节点会通过对节点的疏散协议向网络中的所有其他节点发送消息来连接。 '
- en: The nodes cannot be assumed to be reliable. A subset of nodes will perform the
    correct behaviour, while the behaviour of the rest of the nodes cannot be predicted.
    These other nodes are called Byzantine nodes. Byzantine behaviour of a node refers
    to arbitrary and/or unpredictable behaviour. It may stop relaying values, it may
    relay a random value, or it may even relay a malicious value (i.e. a value which
    is intended to confound the correct or non-Byzantine nodes). The correct nodes
    operate asynchronously and independent of each other. On the other hand, the Byzantine
    nodes can coordinate their activities as all of them may come under the control
    of some adversary. Whether a node is Byzantine or correct will not be known to
    the correct nodes. However, we may assume that a node cannot forge the sender
    address, i.e. a single node cannot impersonate all the nodes in the network.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 不能假设节点是可靠的。一部分节点将执行正确的行为，而其余节点的行为无法预测。这些其他节点称为拜占庭节点。节点的拜占庭行为指的是任意和/或不可预测的行为。它可能停止中继值，它可能中继一个随机值，或者甚至可能中继一个恶意值（即旨在使正确或非拜占庭节点混淆的值）。正确的节点异步地且彼此独立地运行。另一方面，拜占庭节点可以协调他们的活动，因为他们所有人都可能受到某个对手的控制。正确的节点不会知道节点是拜占庭的还是正确的。然而，我们可以假设一个节点不能伪造发送者地址，即一个单独的节点不能冒充网络中的所有节点。
- en: The goal of a Byzantine agreement protocol is for the correct nodes to agree
    on a common value under the above circumstances. Relevant features of an agreement
    protocol are that there must be termination, i.e. the protocol must terminate
    after a finite time. On termination, all the correct nodes should have a common
    value. This common value must be valid. There are several notions of validity.
    Any-input validity refers to the common value being the input of at least one
    (not necessarily correct) node. Correct-input validity refers to the common value
    being the input of at least one correct node. All-same validity refers to the
    situation where if all the correct nodes start with the same value, then the common
    value must be this value.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 拜占庭协议的目标是使正确的节点在上述情况下达成共识。协议的相关特性包括必须终止，即协议必须在有限时间内终止。终止时，所有正确的节点应该有一个共同的值。这个共同的值必须有效。有几种有效性概念。任何输入有效性是指共同值是至少一个（不一定是正确的）节点的输入。正确输入的有效性是指共同值是至少一个正确节点的输入。全相同的有效性是指如果所有正确的节点从相同的值开始，那么共同值必须是这个值。
- en: A basic question is whether Byzantine agreement is at all possible. It has been
    proved that for a network of *n* nodes, Byzantine agreement is not possible if
    at least ![inline-image](../images/CH016_85.jpg) of the nodes are Byzantine. On
    the other hand, research in this area over several decades has led to a collection
    of positive results obtaining various Byzantine agreement protocols under different
    scenarios.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一个基本问题是拜占庭协议是否可能。已经证明，对于一个包含 *n* 个节点的网络，如果至少有 ![inline-image](../images/CH016_85.jpg)
    的节点是拜占庭节点，则拜占庭协议是不可能的。另一方面，在这个领域数十年的研究已经取得了一系列积极的结果，在不同的情况下获得了各种拜占庭协议。
- en: 16.2.4 Consensus Protocol
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.2.4 共识协议
- en: A consensus protocol is a method of agreement among a number of nodes for a
    single data value in the presence of Byzantine nodes. The properties of termination
    and agreement discussed above are necessary properties of any consensus protocol.
    As for validity (sometimes also called integrity), typically the all-same notion
    of validity is used, i.e. if all the correct nodes proposed the same value, then
    at the end of the protocol any correct node must decide upon this value.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 共识协议是在存在拜占庭节点的情况下，多个节点就单个数据值达成一致的方法。上述终止和一致性的属性是任何共识协议的必要属性。至于有效性（有时也称为完整性），通常使用全相同的有效性概念，即如果所有正确的节点提议了相同的值，那么在协议结束时，任何正确的节点都必须决定采用此值。
- en: '**Notes**'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: Introduction to cryptology can be found in textbooks on cryptography such as
    the one by Stinson and Paterson (2018). Digital signature schemes have a large
    literature and come in many variants. See Sarkar (2015) for an overview of various
    types of digital signature schemes. Presently, there are several standardised
    digital signature schemes. We mention the elliptic curve digital signature scheme
    (ECDSA) which has been standardised by the NIST of the US (see NIST, 2016). The
    ECDSA is used in the cryptocurrency Bitcoin.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 加密学导论可以在密码学教材中找到，例如Stinson和Paterson（2018）的教材。数字签名方案有大量文献，并有许多变种。有关各种数字签名方案的概述，请参见Sarkar（2015）。目前，有几种标准化的数字签名方案。我们提到了由美国NIST标准化的椭圆曲线数字签名方案（ECDSA）（请参见NIST，2016）。ECDSA在加密货币比特币中使用。
- en: The Byzantine problem was introduced in Lamport, Shostak, and Pease (1982).
    Since then there has been a huge amount of work in the area. Our coverage has
    been rudimentary. Further discussions can be found in a number of textbooks.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 拜占庭问题最早出现在Lamport，Shostak和Pease（1982）中。此后，该领域进行了大量工作。我们的涉及尚属基础。更多讨论可以在许多教科书中找到。
- en: Chapter 17
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第17章
- en: Introduction to Blockchain
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链介绍
- en: This chapter provides an overview of the basic blockchain technology. In the
    next chapter we will see how a blockchain can be used to implement a cryptocurrency.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 本章概述了基本的区块链技术。在下一章中，我们将看到如何使用区块链来实现加密货币。
- en: 17.1 Transactions
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.1 交易
- en: Simply put, a transaction is a record of some kind of exchange between two or
    more parties. For example, one party supplies a service, while a second party
    provides payment for the service. To make a payment, a party must possess some
    amount of funds and then must provide a signed statement transferring the funds
    to another party.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地说，交易是两个或更多方之间某种交换的记录。例如，一方提供服务，而第二方为服务支付费用。要进行支付，一方必须拥有一定金额的资金，然后必须提供签名的声明，将资金转移给另一方。
- en: More generally, one can consider contracts between parties. A contract can be
    much more flexible than a transaction. It may include exit and penalty clauses
    and also may refer to unknown situations in the future. So, the language for writing
    a contract must be expressive enough to cover a whole multitude of tasks. We will
    come back to this issue when we discuss the interesting notion of smart contracts.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 更一般地，人们可以考虑各方之间的合同。合同比交易灵活得多。它可以包括退出和惩罚条款，也可能涉及未来的未知情况。因此，撰写合同的语言必须足够表达，以涵盖各种任务。当我们讨论有趣的智能合同概念时，我们将再次回到这个问题上。
- en: Whether we consider a transaction or a contract, such an instrument will be
    considered valid only if it is signed by the parties who are involved. For example,
    if somebody wishes to make a payment, the person must sign the statement which
    transfers money to another person. In the physical world, this is achieved by
    a signed cheque. So, the signature of the person making the payment is the key
    issue. Moving to the digital world, a transaction needs to be signed. For doing
    this, a digital signature scheme is used. Suppose Alice wishes to make a payment
    of $100 to Bob. She uses her signing key ![inline-image](../images/CH017_1.jpg)
    to digitally sign the statement ‘I transfer $100 to Bob’. This statement is considered
    to be a message *M*, and the signing algorithm is invoked on *M* and ![inline-image](../images/CH017_2.jpg)
    to produce the signature *s*. Using the verification algorithm and Alice's verification
    key ![inline-image](../images/CH017_3.jpg), anybody can verify that *s* is indeed
    Alice's signature on the message *M*. For the moment, let us consider transactions
    to be signed statement of this type. Later, we will consider somewhat more details.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们考虑的是一笔交易还是一份合同，只有涉及方签署的这种工具才被认为是有效的。例如，如果有人希望进行支付，该人必须签署将款项转移到另一个人的声明。在物理世界中，这是通过签署支票实现的。因此，付款人的签名是关键问题。转移到数字世界后，交易需要签名。为此，使用数字签名方案。假设Alice希望向Bob支付100美元。她使用自己的签名密钥
    ![inline-image](../images/CH017_1.jpg) 对声明“我将100美元转移到Bob”的数字签名。该声明被视为消息*M*，并且签名算法在*M*和
    ![inline-image](../images/CH017_2.jpg) 上被调用以生成签名*s*。使用验证算法和Alice的验证密钥 ![inline-image](../images/CH017_3.jpg)，任何人都可以验证*s*确实是Alice对消息*M*的签名。目前，让我们将交易视为这种类型的签署声明。稍后，我们将考虑更多细节。
- en: 17.2 Blocks of Transactions
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.2 交易区块
- en: An active system will generate millions of transactions. Further, future transactions
    may be based on the current transactions. For example, a payment system will consist
    of transactions where parties make payments to other parties. One party can receive
    money from another party and then based on the money received make a payment to
    a third party. At a top level, one may view the entire system to be the set of
    transactions that has taken place so far within the system.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一个活跃的系统将产生数百万笔交易。此外，未来的交易可能基于当前的交易。例如，支付系统将包括各方向其他方支付款项的交易。一方可以从另一方收到款项，然后根据收到的款项向第三方支付款项。在高层次上，我们可以将整个系统视为迄今为止在系统内发生的交易集合。
- en: For the purposes of keeping record, the transactions will need to be grouped
    together and stored. A block is essentially a group of transactions. There is
    no particular order in which the transactions in a block are stored.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了记录目的，交易需要被分组并存储。一个区块本质上是一组交易。区块中的交易存储顺序并无特定要求。
- en: Transactions can have varying sizes depending upon their complexities. In the
    context of payment system, a transaction may record a simple payment from one
    account of a party to another party. Such a transaction will have a small size.
    On the other hand, a transaction may also record payment from multiple accounts
    of a party to several parties. This will have a larger size. A block usually has
    a fixed size. So, depending upon the sizes of the transactions, it may store a
    variable number of transactions. This, however, is not important for a conceptual
    understanding. It is enough to view a block as storing a number of transactions.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 交易的大小可能会有所不同，取决于它们的复杂性。在支付系统的上下文中，一个交易可能记录一个简单的支付，从一个方的一个帐户到另一个方。这样的交易将有一个小的大小。另一方面，一个交易也可能记录了从一个方的多个帐户到多个方的支付。这将有一个更大的大小。一个区块通常有一个固定的大小。所以，取决于交易的大小，它可能存储不同数量的交易。然而，这对于概念理解并不重要。将一个区块视为存储一些交易就足够了。
- en: 17.3 Public Ledger as a Blockchain
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.3 公开分类账作为区块链
- en: Transactions of a system are entered and recorded in a ledger. In a physical
    system, a ledger would be a physical book where a bunch of transactions would
    be entered on each page of the book. In a digital system, blocks of transactions
    are chained together in a structure called a blockchain. A cryptographic hash
    function *H* is used to chain together the blocks of transactions. The entire
    chain is made public. So, a blockchain implements a public ledger.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 系统的交易被输入和记录在一个分类账中。在一个物理系统中，分类账将是一本物理书，在书的每一页上都会输入一堆交易。在数字系统中，交易块被链接在一起形成一个称为区块链的结构。一个加密哈希函数
    *H* 被用来将交易块链接在一起。整个链是公开的。所以，区块链实现了一个公开分类账。
- en: We have mentioned that a block contains a set of transactions. While this is
    indeed a rough conceptual view of a block, the actual information present in a
    block is more than just the transactions in it. Below we provide a more formal
    description.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到过一个区块包含一组交易。虽然这确实是一个对区块的粗略概念视图，但区块中实际包含的信息不仅仅是其中的交易。下面我们提供一个更正式的描述。
- en: Let *B* 0, *B* 1, …, *B* *r* be a sequence of blocks. The first block *B* 0
    is special since it has no previous blocks. It is sometimes called the *genesis
    block*. Formally, the block *B* [*i*] , *i* ≥ 1, can be considered to be a triplet
    ![inline-image](../images/CH017_4.jpg). (A block also stores some additional information
    called metadata which we ignore for the moment.) The transactions in the block
    constitute the component *R* [*i*] of the block *B* [*i*] and *h* [*i*] is the
    linking information. For the moment, let us ignore the role of ![inline-image](../images/CH017_5.jpg).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让 *B* 0, *B* 1, …, *B* *r* 成为一个区块序列。第一个区块 *B* 0 是特殊的，因为它没有前一个区块。有时候它被称为*创世区块*。正式来说，区块
    *B* [*i*]，*i* ≥ 1，可以被看作是一个三元组 ![inline-image](../images/CH017_4.jpg)。（一个区块还存储一些被称为元数据的附加信息，我们暂时忽略它。）区块中的交易构成了区块
    *B* [*i*] 的组件 *R* [*i*]，*h* [*i*] 是链接信息。暂时来说，让我们忽略 ![inline-image](../images/CH017_5.jpg)的作用。
- en: 'The hash function *H* is applied to the block *B* [*i*]−1 to obtain the component
    *h* [*i*] of the block *B* [*i*] , i.e. *h* [*i*] = *H*(*B* [*i*]−1). So, one
    may consider the component *h* [*i*] in the present block to ‘point’ to the previous
    block *B* [*i*]−1\. In other words, the hash function *H* is used to create the
    quantities *h* 1, *h* 2, … , *h* *r* which are the links in the blockchain. Note
    that the genesis block *B* 0 does not have the component *h* 0, since there is
    no earlier block to which it can point. Pictorially, this may be depicted as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希函数*H*被应用于块*B*[*i*]−1，以获得块*B*[*i*]的组成部分*h*[*i*]，即*h*[*i*] = *H*(*B*[*i*]−1)。因此，一个可以考虑在当前块中的组成部分*h*[*i*]指向前一块*B*[*i*]−1。换句话说，哈希函数*H*用于创建量*h*1、*h*2、……、*h**r*，它们是区块链中的链接。请注意，创世区块*B*0没有组成部分*h*0，因为它没有早期的块可以指向。在图形上，这可能被描述如下：
- en: '![display-image](../images/CH017_6.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![display-image](../images/CH017_6.jpg)'
- en: The arrows in the blockchain point in the backward direction indicating that
    the digest of block *B* [*i*] is part of block *B* [*i*]+1\. The chain, however,
    is computed only in the forward direction. Once the chain up to block *B* *r*
    is prepared, a group of transactions is taken as *R* *r*+1, the digest *h* *r*+1
    = *H*(*B* *r* ) is computed (for a suitable value of ![inline-image](../images/CH017_7.jpg))
    and the block ![inline-image](../images/CH017_8.jpg) is appended to the head of
    the chain.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链中的箭头指向后向方向，表明块*B*[*i*]的摘要是块*B*[*i*]+1的一部分。然而，链只在正向方向计算。一旦链达到块*B**r*，一组交易被视为*R**r*+1，计算摘要*h**r*+1
    = *H*(*B**r* )（对于适当的值![inline-image](../images/CH017_7.jpg)），并且块![inline-image](../images/CH017_8.jpg)被附加到链的头部。
- en: A basic requirement on any ledger is immutability. Essentially this means that
    once a transaction is entered into a ledger, it should not be possible to undo
    or alter it in any manner. This property should also hold in the case of a public
    ledger as described above. Ensuring immutability of the public ledger amounts
    to ensuring that once a block (and hence the transactions in the block) is inserted
    into the blockchain it cannot be changed thereafter. Let us consider this in more
    detail.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 任何账本的基本要求是不可变性。基本上意味着一旦交易记录进入账本，就不应该有任何方式可以撤销或更改它。在上述公共账本的情况下，这种属性也应该成立。确保公共账本的不可变性相当于确保一旦一个区块（因此是区块中的交易）被插入到区块链中后，就不能再进行更改。让我们更详细地考虑一下这一点。
- en: 'Suppose there are two blocks ![inline-image](../images/CH017_9.jpg) and ![inline-image](../images/CH017_10.jpg)
    with ![inline-image](../images/CH017_11.jpg) such that ![inline-image](../images/CH017_12.jpg).
    The component *R* [*i*] of block *B* [*i*] consists of all the transactions that
    have been included in the block. The difference between *R* [*i*] and ![inline-image](../images/CH017_13.jpg)
    could be due to alteration of some transaction *T* in ![inline-image](../images/CH017_14.jpg)
    to obtain transaction ![inline-image](../images/CH017_15.jpg) which is included
    in ![inline-image](../images/CH017_16.jpg). Since the digest of both *B* [*i*]
    and ![inline-image](../images/CH017_17.jpg) under the hash function *H* are equal
    and both the blocks contain the same value of ![inline-image](../images/CH017_18.jpg),
    any of the following two blockchains are valid:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有两个块![inline-image](../images/CH017_9.jpg)和![inline-image](../images/CH017_10.jpg)，满足![inline-image](../images/CH017_11.jpg)，使得![inline-image](../images/CH017_12.jpg)。块*B*
    [*i*]的组件*R* [*i*]包含了已经包含在块中的所有交易。*R* [*i*]和![inline-image](../images/CH017_13.jpg)之间的差异可能是由于修改了某些交易*T*来获得包含在![inline-image](../images/CH017_16.jpg)中的交易![inline-image](../images/CH017_15.jpg)。由于哈希函数*H*下的*B*
    [*i*]和![inline-image](../images/CH017_17.jpg)的摘要相等，并且两个块都包含相同的![inline-image](../images/CH017_18.jpg)的值，以下两个区块链都是有效的：
- en: '![display-image](../images/CH017_19.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![display-image](../images/CH017_19.jpg)'
- en: '![display-image](../images/CH017_20.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![display-image](../images/CH017_20.jpg)'
- en: An adversary may conduct transaction *T* which enters the first blockchain and
    then replaces the first blockchain by the second one which contains the transaction
    ![inline-image](../images/CH017_21.jpg) instead of *T*. This clearly violates
    the immutability of the blockchain.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 对手可能进行交易*T*，该交易进入第一个区块链，然后用包含交易![inline-image](../images/CH017_21.jpg)而不是*T*的第二个区块链替换第一个区块链。这显然违反了区块链的不可变性。
- en: The above scenario arose due to the occurrence of ![inline-image](../images/CH017_22.jpg)
    such that ![inline-image](../images/CH017_23.jpg). The pair ![inline-image](../images/CH017_24.jpg)
    is a collision for the hash function *H*. One of the requirements on *H* is that
    it should be collision-resistant, i.e. it should be computationally difficult
    to find a collision for *H*. For a collision-resistant *H*, it will not be possible
    (in reasonable time) to find *B* [*i*] and ![inline-image](../images/CH017_25.jpg)
    such that ![inline-image](../images/CH017_26.jpg). So, the described strategy
    of modifying the public ledger will not work.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 上述情景是由于![inline-image](../images/CH017_22.jpg)的发生而产生，使得![inline-image](../images/CH017_23.jpg)。对于哈希函数*H*，成对![inline-image](../images/CH017_24.jpg)是其碰撞。*H*的要求之一是它应该是碰撞性抗的，即对于*H*找到碰撞应该是计算上困难的。对于碰撞性抗的*H*，在合理的时间内不可能找到*B*
    [*i*]和![inline-image](../images/CH017_25.jpg)这样的![inline-image](../images/CH017_26.jpg)。因此，修改公共账本的描述策略将无法奏效。
- en: We have mentioned that the blockchain is to be computed in the forward direction.
    Let us consider the possibility of computing it in the backward direction. Suppose
    that the blockchain has *r* blocks and ![inline-image](../images/CH017_27.jpg)
    is the head of the blockchain. Computing the chain in the backward direction requires
    obtaining a block ![inline-image](../images/CH017_28.jpg) such that ![inline-image](../images/CH017_29.jpg).
    First assume that this is indeed possible. This would affect the immutability
    of the blockchain, since then *B* *r*−1 can be overwritten by ![inline-image](../images/CH017_30.jpg)
    to obtain a valid blockchain. The backward computation is possible only if given
    *h* [*r*] , it is possible to find ![inline-image](../images/CH017_31.jpg) such
    that ![inline-image](../images/CH017_32.jpg). In effect, this means that it is
    possible to compute a pre-image of *h* *r* under *H*. Recall that one of the properties
    required of the hash function *H* is that it is one-way which ensures that it
    is computationally difficult to find pre-images under *H*. So, the one-way property
    of the hash function *H* ensures that the blockchain cannot be computed in the
    backward direction.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到过区块链是向前计算的。让我们考虑向后计算的可能性。假设区块链有*r*个块，![inline-image](../images/CH017_27.jpg)是区块链的头。在向后方向计算链条需要获取一个块![inline-image](../images/CH017_28.jpg)，使得![inline-image](../images/CH017_29.jpg)。首先假设这确实是可能的。这将影响区块链的不可变性，因为然后*B*
    *r*−1可以被![inline-image](../images/CH017_30.jpg)覆盖以获得有效的区块链。只有在给定*h* [*r*]的情况下，向后计算才可能找到![inline-image](../images/CH017_31.jpg)，使得![inline-image](../images/CH017_32.jpg)。实际上，这意味着可以在*H*下计算*h*
    *r*的前像。回想一下，哈希函数*H*所需的一个属性是它是单向的，这确保了在*H*下找到前像是计算难度很大的。因此，哈希函数*H*的单向属性确保了不能向后计算区块链。
- en: 17.4 Distributed Public Ledger
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.4 分布式公共分类帐
- en: We have described how a public ledger can be set up using a blockchain. There
    could, conceivably, be implementations of a public ledger without using a blockchain.
    Presently, however, the most important method for realising a public ledger is
    to base it on a blockchain. So, our discussion of public ledger will be entirely
    based on blockchain technology.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经描述了如何使用区块链建立一个公共分类帐。理论上，可以使用不使用区块链的公共分类帐的实现。然而，目前实现公共分类帐的最重要方法是基于区块链。因此，我们对公共分类帐的讨论将完全基于区块链技术。
- en: In the previous sections of the chapter, we have provided a basic overview of
    a blockchain. The relevance of cryptographic properties of the hash function to
    the immutability of a blockchain has been explained. Next comes the question of
    how a blockchain is maintained. The short answer to this is that a blockchain
    is maintained in a distributed fashion. In this section, we elaborate further
    on this.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的前几节中，我们提供了区块链的基本概述。已经解释了哈希函数的加密属性与区块链的不可变性的相关性。接下来的问题是如何维护区块链。对此的简短答案是，区块链是以分布式方式维护的。在本节中，我们进一步阐述了这一点。
- en: The setting that we consider consists of many parties who are geographically
    distributed across the planet. There would be differences in the complexities
    of the parties. For the present, we ignore such differences and consider each
    party to be a node of the system. Again, for simplicity, we assume a node to be
    a computer. These nodes are connected to each other using the internet (or, maybe
    a part of it). So, one particular node can communicate directly to only a small
    number of nodes in its neighbourhood. This is the setting of P2P network, as has
    been described in Section 16.2.1.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们考虑的环境包括许多地理分布在全球各地的参与方。各方的复杂性可能会有所不同。目前，我们忽略这些差异，将每个参与方视为系统的一个节点。同样，为了简单起见，我们假设一个节点就是一台计算机。这些节点通过互联网（或者可能是其一部分）相互连接。因此，一个特定的节点只能直接与其邻近的少数节点进行通信。这就是P2P网络的设置，如第16.2.1节所述。
- en: The nodes themselves generate transactions which are to be included in the public
    ledger. The question then arises as to who maintains the public ledger. The answer
    is that all the nodes maintain the public ledger, i.e. each node maintains a copy
    of the public ledger. Since we are considering that the public ledger is implemented
    as a blockchain, it follows that each node maintains a copy of the blockchain.
    Since the blockchain is distributed across the whole network, the resulting public
    ledger is often called distributed public ledger. At this point, a crucial question
    arises. How is it ensured that the copies of the blockchain maintained by the
    different nodes are consistent? Below we address this issue.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 节点本身会生成需要包含在公共分类账中的交易。那么，谁来维护公共分类账呢？答案是所有节点都维护公共分类账，即每个节点都维护公共分类账的一份拷贝。由于我们考虑的公共分类账是以区块链实现的，因此每个节点都维护区块链的一份拷贝。由于区块链分布在整个网络中，因此产生的公共分类账通常称为分布式公共分类账。在这一点上，一个关键的问题出现了。如何确保由不同节点维护的区块链拷贝是一致的呢？下面我们来解决这个问题。
- en: Let us consider a particular node *v*. Transactions occur at the node *v*, i.e.
    the entity responsible for the node *v* may initiate transactions. These transactions
    are to be entered into the blockchain. So, node *v* uses the gossip protocol of
    the P2P network to send out the transactions to a subset of its neighbouring nodes.
    These neighbouring nodes further propagate the transactions until the transactions
    reach the entire network. Usually the gossip network is quite efficient and a
    transaction reaches the entire network within a few seconds (or, even less time).
    Similarly, node *v* receives transactions which have occurred at other nodes in
    the network.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个特定的节点*v*。交易发生在节点*v*上，即负责节点*v*的实体可能会启动交易。这些交易需要记录在区块链中。因此，节点*v*使用P2P网络的八卦协议将交易发送到其邻近节点的子集。这些邻近节点进一步传播交易，直到交易达到整个网络。通常，八卦网络非常高效，交易在几秒钟内（甚至更短的时间内）就能传播到整个网络。同样，节点*v*接收到网络中其他节点发生的交易。
- en: We have mentioned that each node in the network maintains a copy of the blockchain.
    The blockchain consists of blocks where each block is a group of transactions.
    Each node also receives transactions which have occurred in the network. Along
    with a copy of the blockchain, each node also maintains a list of transactions
    which have so far not entered the blockchain. This is the set of ‘un-blocked’
    transactions. Note that at a particular point of time, the list of un-blocked
    transactions maintained by the different nodes need not be the same; in fact,
    they will mostly be different. This is because a transaction generated at a particular
    node will require some time to travel throughout the network. Until it has reached
    all the nodes in the system, a subset of nodes will be recording it as ‘un-blocked’
    while the other nodes will not even be knowing about it.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到网络中的每个节点都维护着区块链的一个副本。区块链由一组交易组成，每个区块都是一组交易。每个节点还会接收网络中发生的交易。除了区块链的副本外，每个节点还维护着一份迄今尚未进入区块链的交易列表。这就是所谓的‘未阻塞’交易集合。需要注意的是，在特定时间点上，不同节点维护的未阻塞交易列表可能并不相同；事实上，它们通常是不同的。这是因为在特定节点生成的交易需要一定时间才能传播到整个网络。在它到达所有节点之前，一部分节点将把它记录为‘未阻塞’，而其他节点甚至可能不知道它的存在。
- en: Again, let us get back to node *v*. This node maintains a copy of the blockchain
    and a list of un-blocked transactions. Let us denote node *v*'s copy of the blockchain
    by ![inline-image](../images/CH017_33.jpg) and its list of un-blocked transactions
    as ![inline-image](../images/CH017_34.jpg). Apart from generating and propagating
    transactions, each node also tries to create a block and propagate it.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，让我们回到节点*v*。这个节点维护着区块链的一个副本和一个未被阻塞的交易列表。让我们用![inline-image](../images/CH017_33.jpg)来表示节点*v*的区块链副本，用![inline-image](../images/CH017_34.jpg)表示其未被阻塞的交易列表。除了生成和传播交易外，每个节点还尝试创建并传播一个区块。
- en: Suppose the header of ![inline-image](../images/CH017_35.jpg) is a block ![inline-image](../images/CH017_36.jpg),
    where *h* *r* = *H*(*B* *r*−1) is the digest under the hash function *H* of the
    previous block *B* *r*−1 in ![inline-image](../images/CH017_37.jpg), ![inline-image](../images/CH017_38.jpg)
    is the set of transactions in the block *B* and ![inline-image](../images/CH017_39.jpg)
    is a quantity which plays a special role. Node *v* takes a group of transactions
    from ![inline-image](../images/CH017_40.jpg) and checks the validity of each of
    these transactions. The checking of validity includes checking proper format and
    the verifications of the digital signatures of the various parties in a transaction.
    If a check fails, then *v* rejects the corresponding transaction and removes it
    from ![inline-image](../images/CH017_41.jpg). Once all the checks succeed, *v*
    takes this group of transactions to be ![inline-image](../images/CH017_42.jpg).
    Node *v* then computes ![inline-image](../images/CH017_43.jpg). Next, it attempts
    to obtain a suitable value for ![inline-image](../images/CH017_44.jpg) so as to
    be able to form a block ![inline-image](../images/CH017_45.jpg). We will later
    explain how ![inline-image](../images/CH017_46.jpg) is obtained. Once node *v*
    has been able to form block ![inline-image](../images/CH017_47.jpg), it removes
    the transactions in ![inline-image](../images/CH017_48.jpg) from ![inline-image](../images/CH017_49.jpg),
    inserts ![inline-image](../images/CH017_50.jpg) into ![inline-image](../images/CH017_51.jpg)
    as the new header and propagates this block to the network using the gossip protocol.
    So, apart from transactions, nodes in the network also propagate blocks that they
    have created.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 假设![inline-image](../images/CH017_35.jpg)的头部是一个区块![inline-image](../images/CH017_36.jpg)，其中
    *h* *r* = *H*(*B* *r*−1) 是前一个区块 *B* *r*−1 在![inline-image](../images/CH017_37.jpg)下哈希函数
    *H* 的摘要，![inline-image](../images/CH017_38.jpg)是区块 *B* 中的交易集，而![inline-image](../images/CH017_39.jpg)是一个发挥特殊作用的量。节点
    *v* 从![inline-image](../images/CH017_40.jpg)中取一组交易并检查每笔交易的有效性。有效性检查包括检查正确的格式和交易中各方数字签名的验证。如果检查失败，那么
    *v* 将拒绝相应的交易并将其从![inline-image](../images/CH017_41.jpg)中移除。一旦所有检查都成功，*v* 将这组交易视为![inline-image](../images/CH017_42.jpg)。然后，节点
    *v* 计算![inline-image](../images/CH017_43.jpg)。接下来，它尝试获得适当的值以便能够形成一个区块![inline-image](../images/CH017_45.jpg)。我们将在后面解释![inline-image](../images/CH017_46.jpg)是如何获得的。一旦节点
    *v* 能够形成区块![inline-image](../images/CH017_47.jpg)，它就从![inline-image](../images/CH017_49.jpg)中移除![inline-image](../images/CH017_48.jpg)中的交易，将![inline-image](../images/CH017_50.jpg)插入![inline-image](../images/CH017_51.jpg)作为新的头部，并使用八卦协议将该区块传播到网络中。因此，除了交易外，网络中的节点还会传播它们创建的区块。
- en: Let us now consider what happens when node *v* receives a block ![inline-image](../images/CH017_52.jpg).
    It checks whether ![inline-image](../images/CH017_53.jpg) and if this is true,
    it then inserts *B* as the new header in ![inline-image](../images/CH017_54.jpg)
    and removes the transactions in *R* from ![inline-image](../images/CH017_55.jpg).
    This results in the extension of the copy of the blockchain ![inline-image](../images/CH017_56.jpg)
    available with node *v* by one block. The gossip protocol ensures that the block
    *B* reaches all the nodes. Assuming that all nodes have the same copy of the blockchain,
    each node extends its copy of the blockchain by the block *B* and again all nodes
    in the network have the same copy of the blockchain. Recall that the start of
    the blockchain is by the genesis block which all nodes certainly have. So, ignoring
    conflicts, each node maintains the same copy of the blockchain.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当节点*v*接收到一个块![inline-image](../images/CH017_52.jpg)时，让我们考虑接下来会发生什么。 它会检查是否![inline-image](../images/CH017_53.jpg)，如果是，则将*B*插入![inline-image](../images/CH017_54.jpg)中并从![inline-image](../images/CH017_55.jpg)中删除*R*中的交易。
    这会导致节点*v*可用的区块链副本![inline-image](../images/CH017_56.jpg)扩展了一个块。 八卦协议确保块*B*到达所有节点。
    假设所有节点都具有相同的区块链副本，每个节点都将其区块链副本扩展了一个块*B*，然后网络中的所有节点再次具有相同的区块链副本。 请记住，区块链的起始点是所有节点肯定拥有的创世块。
    因此，忽略冲突，每个节点都维护相同的区块链副本。
- en: Conflicts, however, do arise. The nodes are creating blocks concurrently and
    independently of each other. Whenever a block is created, it is transmitted to
    the gossip network. Further, the list of un-blocked transactions maintained by
    the nodes is different. So, blocks created by different nodes will not necessarily
    have the same set of transactions. It is quite possible that the node *v* almost
    simultaneously receives two different blocks ![inline-image](../images/CH017_57.jpg)
    and ![inline-image](../images/CH017_58.jpg) such that ![inline-image](../images/CH017_59.jpg).
    In other words, both the blocks *B* and ![inline-image](../images/CH017_60.jpg)
    are compatible with the copy of the blockchain ![inline-image](../images/CH017_61.jpg)
    maintained by *v*. Note that one of the blocks *B* and ![inline-image](../images/CH017_62.jpg)
    could have been created by *v* itself. At this point, there needs to be some kind
    of a conflict resolution mechanism to determine which of the two blocks *B* and
    ![inline-image](../images/CH017_63.jpg) is to be inserted as the new header of
    ![inline-image](../images/CH017_64.jpg). The overall protocol for the blockchain
    will specify this conflict resolution mechanism. Later we will consider the special
    case of the Bitcoin protocol. For the moment, it is sufficient to note that one
    of the blocks *B* and ![inline-image](../images/CH017_65.jpg) is entered as the
    new header by *v*, while the other block is rejected. Suppose block *B* is accepted
    and ![inline-image](../images/CH017_66.jpg) is rejected. So, in some sense the
    blockchain protocol has to define when block *B* will be preferred over block
    ![inline-image](../images/CH017_67.jpg). Note that this preference relation is
    specified by the blockchain protocol and is followed by all the nodes in the network.
    So, all the nodes will prefer *B* over ![inline-image](../images/CH017_68.jpg)
    and extend their copies of the blockchain using *B* rather than ![inline-image](../images/CH017_69.jpg).
    This is a kind of consensus among the nodes and the preference relation of the
    blockchain protocol essentially specifies the consensus algorithm.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，冲突是不可避免的。节点并行且独立地创建区块。每当创建一个区块，它就会被传输到八卦网络中。此外，节点维护的未被阻塞的交易列表是不同的。因此，由不同节点创建的区块不一定具有相同的交易集。很有可能节点*v*几乎同时接收到两个不同的区块![inline-image](../images/CH017_57.jpg)和![inline-image](../images/CH017_58.jpg)，使得![inline-image](../images/CH017_59.jpg)。换句话说，区块*B*和![inline-image](../images/CH017_60.jpg)都与*v*维护的区块链的副本![inline-image](../images/CH017_61.jpg)兼容。请注意，区块*B*和![inline-image](../images/CH017_62.jpg)中的一个可能是由*v*自己创建的。在这一点上，需要一种冲突解决机制来确定两个区块*B*和![inline-image](../images/CH017_63.jpg)中的哪一个将被插入为![inline-image](../images/CH017_64.jpg)的新标题。区块链的整体协议将指定这种冲突解决机制。稍后我们将考虑比特币协议的特殊情况。目前，只需注意区块*B*和![inline-image](../images/CH017_65.jpg)中的一个被*v*输入为新标题，而另一个区块被拒绝。假设区块*B*被接受而![inline-image](../images/CH017_66.jpg)被拒绝。因此，在某种意义上，区块链协议必须定义区块*B*何时优先于区块![inline-image](../images/CH017_67.jpg)。请注意，此偏好关系由区块链协议指定，并由网络中的所有节点遵循。因此，所有节点都将优先选择*B*而不是![inline-image](../images/CH017_68.jpg)并使用*B*扩展其区块链的副本而不是![inline-image](../images/CH017_69.jpg)。这是节点之间的一种共识，而区块链协议的偏好关系基本上指定了共识算法。
- en: The scenario is actually more complex than the above. Competition to enter the
    blockchain is not only restricted to the two blocks which are received almost
    simultaneously by a node. Consider again node *v* and its copy of the blockchain
    ![inline-image](../images/CH017_70.jpg). Suppose node *v* receives a block ![inline-image](../images/CH017_71.jpg)
    and it finds that *H*(*B* [*i*]−1) = *h*. This means that the blockchain (*B*
    0,…,*B* [*i*]−1, *B*) is valid. Node *v* now has the option of either rejecting
    block *B* or of modifying its copy of the blockchain to (*B* 0,…,*B* [*i*]−1,
    *B*) and rejecting blocks ![inline-image](../images/CH017_72.jpg). The actual
    decision on which option node *v* should choose is also determined by the conflict
    resolution mechanism of the blockchain protocol.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 实际情况比上述更复杂。进入区块链的竞争不仅仅局限于几乎同时被一个节点接收的两个区块。再次考虑节点*v*及其区块链的副本![inline-image](../images/CH017_70.jpg)。假设节点*v*接收到一个区块![inline-image](../images/CH017_71.jpg)，并且发现*H*(*B*
    [*i*]−1) = *h*。这意味着区块链(*B* 0,…,*B* [*i*]−1, *B*)是有效的。节点*v*现在可以选择拒绝区块*B*，或者修改其区块链副本为(*B*
    0,…,*B* [*i*]−1, *B*)并拒绝区块![inline-image](../images/CH017_72.jpg)。节点*v*应该选择哪个选项的实际决定也由区块链协议的冲突解决机制确定。
- en: Suppose that following the blockchain protocol, node *v* chooses the blockchain
    (*B* 0,…,*B* [*i*]−1, *B*) and rejects the blocks *B* [*i*] ,…,*B* *r*−1, *B*
    *r* . Since the consensus protocol is followed by all the nodes in the network,
    any other node whose local copy of the blockchain is ![inline-image](../images/CH017_73.jpg)
    and receives block *B* also opts for the blockchain (*B* 0,…,*B* [*i*]−1, *B*)
    and rejects the blocks *B* [*i*] ,…,*B* *r*−1, *B* *r* . These later blocks are
    called stale blocks (and sometimes also called orphan blocks, though technically
    orphan blocks are different objects). The cost of creating these stale blocks
    has been wasted.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 假设按照区块链协议，节点*v*选择了区块链(*B* 0,…,*B* [*i*]−1, *B*)并拒绝了区块*B* [*i*]，…,*B* *r*−1,
    *B* *r*。由于网络中的所有节点都遵循共识协议，任何其他本地区块链副本为![inline-image](../images/CH017_73.jpg)且接收到区块*B*的节点也会选择区块链(*B*
    0,…,*B* [*i*]−1, *B*)并拒绝区块*B* [*i*]，…,*B* *r*−1, *B* *r*。这些后来的区块被称为陈旧区块（有时也称为孤立区块，尽管在技术上孤立区块是不同的对象）。创建这些陈旧区块的成本被浪费了。
- en: Another possibility may arise. Suppose that the local copies of the blockchain
    of all the nodes is ![inline-image](../images/CH017_74.jpg) and all of them receive
    block *B*. Further suppose that the rules of the blockchain protocol dictates
    that the blockchain must be modified to ![inline-image](../images/CH017_75.jpg).
    At this point, some of the nodes in the network decide to follow the protocol
    and update the local copies of the their blockchain while the rest of the nodes
    discard block *B* and continue with the blockchain ![inline-image](../images/CH017_76.jpg).
    This gives rise to two different blockchains which are the same up to block *B*
    [*i*]−1 and then forks into two distinct chains. The two disjoint subsets of nodes
    which work on the two different blockchains will no longer accept blocks and transactions
    from each other. Effectively, this results in a partition of the network into
    two different parts. This process is called forking of the blockchain and also
    the network. Forking can arise for a number of reasons. One important reason for
    a fork to occur is a change in the blockchain protocol which is accepted by a
    subset of nodes, but, not by the other nodes. In the context of cryptocurrency,
    forking may lead to one cryptocurrency being split into two cryptocurrencies.
    Later we provide further explanation of how this may happen.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 还有可能会出现另一种情况。假设所有节点的区块链的本地副本为 ![inline-image](../images/CH017_74.jpg)，它们都收到了区块
    *B*。进一步假设区块链协议规定区块链必须修改为 ![inline-image](../images/CH017_75.jpg)。此时，网络中的一些节点决定遵循协议并更新他们的区块链本地副本，而其余节点则丢弃区块
    *B* 并继续使用区块链 ![inline-image](../images/CH017_76.jpg)。这样就产生了两条不同的区块链，它们在区块 *B*
    [*i*]−1之前相同，然后分叉成两条不同的链。在这两个不同的区块链上工作的两个不相交的节点子集将不再接受彼此的区块和交易。实际上，这导致网络分为两个不同的部分。这个过程称为区块链和网络的分叉。分叉可能因多种原因而发生。导致分叉发生的一个重要原因是区块链协议的变化，该变化被一部分节点接受，而其他节点不接受。在加密货币的背景下，分叉可能导致一种加密货币分裂为两种加密货币。稍后我们将进一步解释这种情况可能发生的方式。
- en: 17.5 Permissionless versus Permissioned Blockchain
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.5 允许性与许可性区块链
- en: Distributed public ledger based on blockchain has been popularised by Bitcoin
    and the follow-up cryptocurrencies. Notable among the follow-ups is Ethereum which
    apart from providing a cryptocurrency also provides a platform for implementing
    smart contracts. All such blockchains can be considered to be public blockchains.
    In such blockchains, there is no restriction on who can become a node in the network.
    Anybody can download the software for the blockchain protocol onto a computer
    and create a node of the blockchain network. Such a system is considered to be
    permissionless since no permission is required from any authority to join the
    network. It is also called a decentralised system due to the fact that all nodes
    in the network have equal privileges, i.e. they are peers.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 基于区块链的分布式公共账本由比特币及其后续加密货币推广开来。其中值得注意的是以太坊，除了提供加密货币外，还提供了一个实现智能合约的平台。所有这些区块链都可以被视为公共区块链。在这种区块链中，没有限制谁可以成为网络中的节点。任何人都可以在计算机上下载区块链协议的软件，并创建一个区块链网络的节点。这样的系统被认为是无需许可的，因为不需要从任何权威处获得加入网络的许可。由于网络中的所有节点都具有相同的特权，即它们是对等的，它也被称为分散式系统。
- en: Subsequent to the popularisation of cryptocurrencies there has been a great
    deal of interest in the underlying blockchain technology to implement distributed
    public ledgers for various tasks. An organisation, for example, may employ a blockchain
    to maintain a public ledger of interal records. This would be very convenient,
    since the public ledger would be accessible to all internal members of the organisation.
    Such a public ledger is not really public, since the organisation might not wish
    to reveal its internal documents to entities outside the organisation. Further,
    it may also wish to provide access to the ledger only to a set of privileged members
    of the organisation. So, permission from some central authority is required to
    join the blockchain. Such a system is called permissioned blockchain.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在加密货币流行之后，人们对实现各种任务的分布式公共账本的底层区块链技术产生了极大兴趣。例如，一个组织可以使用区块链来维护内部记录的公共账本。这将非常方便，因为公共账本将对组织内所有成员可访问。这样的公共账本实际上并不是公开的，因为组织可能不希望将其内部文件透露给组织外的实体。此外，它可能还希望仅将账本访问权限提供给一组特权组织成员。因此，需要从某个中央机构获得许可才能加入区块链。这样的系统称为许可区块链。
- en: Chapter 18
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第18章
- en: 'Cryptocurrency: Basics'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 加密货币：基础知识
- en: In this chapter, we will consider cryptocurrencies. The cryptocurrency Bitcoin
    was proposed in 2009 and till date remains the most successful of all cryptocurrencies.
    Subsequent to Bitcoin, over 1,500 cryptocurrencies have been proposed. All of
    these are based on the blockchain technology, and most of them are conceptually
    very similar to Bitcoin differing mostly in the choice of tools to implement the
    various components. Our discussion of how a cryptocurrency can be realised using
    the Blockchain technology will be based on Bitcoin. Later we will discuss some
    conceptual variations that arise.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将考虑加密货币。比特币加密货币于2009年提出，并且至今仍然是所有加密货币中最成功的。在比特币之后，提出了1500多种加密货币。所有这些加密货币都基于区块链技术，其中大多数在概念上与比特币非常相似，主要区别在于选择实现各种组件的工具。我们关于如何使用区块链技术实现加密货币的讨论将以比特币为基础。稍后我们将讨论一些概念上的变化。
- en: 18.1 Owner
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.1 所有者
- en: While considering a cryptocurrency, the first issue that comes to the mind is
    how the currency is created. We will, however, defer this point. Let us assume
    that there is a unit of cryptocurrency and it exists. Existence of a cryptocurrency
    means that various amounts of it are held by different owners. At any point of
    time, the total amount of a cryptocurrency is the sum of the various amounts of
    the cryptocurrency held by the different owners. So, there is no existence of
    the cryptocurrency outside ownership.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当考虑加密货币时，首先想到的问题是货币是如何创建的。然而，我们将推迟这一点。让我们假设存在一单位加密货币。加密货币的存在意味着不同的所有者持有不同数量的加密货币。在任何时间点，加密货币的总量是由不同所有者持有的加密货币数量之和。因此，在所有权之外不存在加密货币的存在。
- en: In the physical world, a physical entity is the owner of a certain amount of
    any currency. Such a physical entity can be a person or an organisation. Ownership
    of physical currency can mean various things. One important consequence of ownership
    is that it provides the owner with the privilege of spending the amount of currency
    that is held by the owner. The spending is effected by transferring (a part of)
    the amount held by the owner to another entity. This later entity then becomes
    the new owner of the said amount of the currency.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，某个物理实体是某种货币的所有者。这样的物理实体可以是一个人或一个组织。拥有物理货币可以意味着各种各样的事情。所有权的一个重要后果是，它为所有者提供了花费所持有的货币数量的特权。花费是通过将所有者持有的金额的（一部分）转移给另一个实体来实现的。然后，该后续实体成为该货币数量的新所有者。
- en: A cryptocurrency system emulates the spending aspects of a physical currency.
    In doing this, it abstracts away the requirement of a physical entity. The notion
    of ownership is captured by the spending ability, i.e. the owner of a certain
    amount of cryptocurrency can spend this amount.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 加密货币系统模拟了物理货币的花费方面。通过这样做，它抽象出了对物理实体的要求。所有权的概念通过花费能力来捕捉，即一定数量的加密货币的所有者可以花费这个数量。
- en: Fix a digital signature scheme. Using the ![inline-image](../images/CH018_1.jpg)
    algorithm of the scheme, it is possible to create a pair of signing (or secret)
    and verification (or public) keys. Each time the ![inline-image](../images/CH018_2.jpg)
    algorithm is invoked, it returns a new pair of secret/public keys. At a conceptual
    level, in a cryptocurrency system, the public keys are the owners of various amounts
    of the cryptocurrency. (We will modify this statement later.) Suppose, a public
    key ![inline-image](../images/CH018_3.jpg) owns *x* amount of the cryptocurrency.
    Then ![inline-image](../images/CH018_4.jpg) can make payments of *x* 1,…,*x* [*t*]
    amounts of the cryptocurrency to public keys ![inline-image](../images/CH018_5.jpg),
    respectively, such that *x* = *x* 1 + ⋯ + *x* [*t*] . For making this payment,
    the signing key ![inline-image](../images/CH018_6.jpg) corresponding to ![inline-image](../images/CH018_7.jpg)
    is required. Whoever possesses this signing key can make such a payment.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 修复数字签名方案。使用方案的![inline-image](../images/CH018_1.jpg)算法，可以创建一对签名（或秘密）和验证（或公共）密钥。每次调用![inline-image](../images/CH018_2.jpg)算法时，它都会返回一对新的秘密/公共密钥。在概念上，在加密货币系统中，公共密钥是各种金额加密货币的所有者。（我们稍后会修改这个声明。）假设，一个公钥![inline-image](../images/CH018_3.jpg)拥有
    *x* 金额的加密货币。然后![inline-image](../images/CH018_4.jpg)可以向相应的公钥![inline-image](../images/CH018_5.jpg)支付
    *x* 1,…,*x* [*t*] 金额的加密货币，使得 *x* = *x* 1 + ⋯ + *x* [*t*] 。为了进行这种支付，需要与![inline-image](../images/CH018_7.jpg)对应的签名密钥![inline-image](../images/CH018_6.jpg)。拥有此签名密钥的人可以进行此类支付。
- en: Physical entities are owners of the signing keys which allow them to make payments
    held by the corresponding public keys. One physical entity can create multiple
    signing and public keys. The total ownership of cryptocurrency by this physical
    entity is the sum of the various amounts of cryptocurrencies which are held by
    the public keys for which the physical entity possesses the corresponding signing
    keys. If a signing key is lost, then there is no way to spend the amount of cryptocurrency
    owned by the corresponding public key. This amount of cryptocurrency essentially
    goes out of the system and is lost.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 物理实体是拥有相应公钥的签名密钥的所有者，这使得它们能够支付相应公钥持有的加密货币。一个物理实体可以创建多个签名和公钥。此物理实体对加密货币的总拥有权是该物理实体持有相应签名密钥的公钥持有的各种加密货币金额之和。如果签名密钥丢失，则无法花费由相应公钥拥有的加密货币金额。这笔加密货币实质上退出系统并且丢失。
- en: A cryptocurrency system provides a certain amount of anonymity to a participating
    physical entity. Identities of the physical entities who participate in the system
    are not part of the system. The system only recognises public keys. Payments are
    made from one public key to one or more public keys. For making such a payment,
    the identity of the physical entity is not required. As long as the physical entity
    possesses the appropriate signing key, it can make the required payment.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 加密货币系统为参与的物理实体提供一定程度的匿名性。参与系统的物理实体的身份不是系统的一部分。系统只识别公钥。支付是从一个公钥到一个或多个公钥进行的。为了进行这样的支付，不需要物理实体的身份。只要物理实体拥有适当的签名密钥，它就可以进行所需的支付。
- en: 18.2 Transactions
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.2 交易
- en: In Chapter 17, we have considered transactions in an abstract manner. In the
    context of a cryptocurrency, a transaction is a record of payment of the amount
    of cryptocurrency owned by one public key ![inline-image](../images/CH018_8.jpg)
    to one or more public keys ![inline-image](../images/CH018_9.jpg). So, there is
    a spender public key ![inline-image](../images/CH018_10.jpg) and a set of recipient
    public keys ![inline-image](../images/CH018_11.jpg). The statement of transfer
    is considered to be a message *M*. This message is digitally signed with the signing
    key ![inline-image](../images/CH018_12.jpg) corresponding to ![inline-image](../images/CH018_13.jpg)
    to produce a signature *s*. The task of signing represents the spender's commitment
    to the transaction. Since signing keys are not made public, only the physical
    entity who possesses the signing key ![inline-image](../images/CH018_14.jpg) can
    sign off on the transfer of funds. The statement of transfer *M* along with the
    signature *s* constitute a transaction.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在第17章中，我们以抽象的方式考虑了交易。在加密货币的背景下，一笔交易是指将由一个公钥 ![inline-image](../images/CH018_8.jpg)
    拥有的加密货币金额支付给一个或多个公钥 ![inline-image](../images/CH018_9.jpg) 的记录。因此，存在一个支付者公钥 ![inline-image](../images/CH018_10.jpg)
    和一组接收者公钥 ![inline-image](../images/CH018_11.jpg)。转账声明被视为一条消息 *M*。该消息使用与 ![inline-image](../images/CH018_13.jpg)
    相对应的签名密钥 ![inline-image](../images/CH018_12.jpg) 进行数字签名以生成签名 *s*。签名的任务代表支付者对交易的承诺。由于签名密钥不是公开的，因此只有拥有签名密钥
    ![inline-image](../images/CH018_14.jpg) 的物理实体才能签署资金的转移。转账声明 *M* 与签名 *s* 组成了一笔交易。
- en: Verification of a transaction (*M*, *s*) consists of several checks. One of
    these is the verification of the signature. The spender public key ![inline-image](../images/CH018_15.jpg)
    is public. So, anybody can use the verification algorithm along with ![inline-image](../images/CH018_16.jpg)
    to verify that (*M*, *s*) is a valid message-signature pair.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 交易 (*M*, *s*) 的验证包括几项检查。其中之一是签名的验证。支付者的公钥 ![inline-image](../images/CH018_15.jpg)
    是公开的。因此，任何人都可以使用验证算法和 ![inline-image](../images/CH018_16.jpg) 来验证 (*M*, *s*) 是否是一个有效的消息-签名对。
- en: The other important check on a transaction is to verify that ![inline-image](../images/CH018_17.jpg)
    indeed owns the stated amount of cryptocurrency. We consider this issue. As discussed
    in Chapter 17, transactions are grouped together into blocks, and the blocks are
    organised into the blockchain. The blockchain is public and constitutes the public
    ledger. So, any transaction which is part of the blockchain is publicly available.
    In the above, we have discussed how the transfer of cryptocurrency from one public
    key to another public key is effected. There is also a method for creating specific
    amounts of cryptocurrency and assigning it to a public key, and this information
    is also available on the blockchain. (We will discuss the procedure for creation
    of cryptocurrency later.) So, a certain amount of cryptocurrency gets created
    and assigned to a public key; a transaction distributes this amount to a set of
    public keys; subsequent transactions, in turn, distribute the amounts to other
    public keys and so on. All such information is available on the blockchain. Consequently,
    at any point of time, using the blockchain, it is possible to determine whether
    a particular public key indeed possesses a stated amount of cryptocurrency. As
    a result, it is possible to verify whether the spender public key in a transaction
    is indeed the owner of the amount it spends in the transaction.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 对交易的另一个重要检查是验证![inline-image](../images/CH018_17.jpg)确实拥有所声明的加密货币数量。我们考虑了这个问题。正如第17章所讨论的，交易被组合成块，并且这些块被组织成区块链。区块链是公开的，并构成公共账本。因此，任何属于区块链的交易都是公开可见的。在上文中，我们已经讨论了如何从一个公钥转移到另一个公钥。还有一种方法可以创建特定数量的加密货币并将其分配给一个公钥，这些信息也可以在区块链上找到。（我们将稍后讨论创建加密货币的程序。）因此，一定数量的加密货币被创建并分配给一个公钥；一笔交易将这个数量分配给一组公钥；随后的交易依次将金额分配给其他公钥，依此类推。所有这些信息都可以在区块链上找到。因此，在任何时候，使用区块链，都可以确定一个特定的公钥是否确实拥有所声明的加密货币数量。因此，可以验证交易中的花费者公钥是否确实是在交易中花费的金额的所有者。
- en: Chapter 17 discussed how a P2P network is used to implement a blockchain. One
    of the activities of the nodes in such a network is to group transactions into
    blocks. Before including a transaction into a block, a node verifies the transaction.
    Apart from basic verification, such as the sum of the amount transferred to the
    recipient public keys is at most the amount owned by the spender public keys,
    this verification consists of two essential tasks. The first is to determine whether
    the spender public key indeed owns the amount of cryptocurrency to be transferred,
    and the second is the verification of the signature in the transaction. If either
    of these checks fail, the transaction is discarded. Otherwise, the node includes
    it in the list of transactions and attempts to create a block.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 第17章讨论了如何使用P2P网络来实现区块链。在这种网络中，节点的一个活动是将交易分组到区块中。在将交易包含到一个区块之前，节点会验证交易。除了基本验证，如转移到收款者公钥的金额之和至多等于花费者公钥拥有的金额之外，这种验证包括两个关键任务。第一个是确定花费者公钥是否确实拥有要转移的加密货币金额，第二个是验证交易中的签名。如果这些检查中的任何一个失败，交易将被丢弃。否则，节点会将其包含在交易列表中，并尝试创建一个区块。
- en: So, far we have mentioned that a transaction consists of a single spender public
    key and possibly more than one recipient public keys. It is also possible for
    a transaction to have multiple spender public keys. In this case, the transaction
    has to be signed by the signing keys corresponding to each of the spender public
    keys. Further, the sum of the amounts of the cryptocurrency transferred to all
    the recipient public keys must be at most the sum of the amounts of the cryptocurrency
    owned by all the spender public keys.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经提到一个交易由一个花费者公钥和可能多个收款者公钥组成。一个交易也可能有多个花费者公钥。在这种情况下，交易必须由与每个花费者公钥对应的签名密钥签名。此外，转移到所有收款者公钥的加密货币金额之和必须至多等于所有花费者公钥拥有的加密货币金额之和。
- en: Suppose there are *s* spender public keys owning *x* 1,…,*x* *s* amounts of
    the cryptocurrency and there are *t* recipient public keys receiving *y* 1,…,*y*
    [*t*] amounts of the cryptocurrency. Then a necessary condition for a valid transaction
    is that ![inline-image](../images/CH018_18.jpg). If ![inline-image](../images/CH018_19.jpg),
    then the entire input amount is transferred to the output. On the other hand,
    if ![inline-image](../images/CH018_20.jpg), then the difference ![inline-image](../images/CH018_21.jpg)
    is transferred to the node in the P2P network which successfully creates a block
    containing the transaction. This difference *δ* is called the transaction fee
    and is an incentive for nodes in the network to include the transaction in a block.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 假设存在 *s* 个花费者公钥拥有 *x* 1,…,*x* *s* 数量的加密货币，并且存在 *t* 个接收者公钥接收 *y* 1,…,*y* [*t*]
    数量的加密货币。那么有效交易的一个必要条件是 ![inline-image](../images/CH018_18.jpg)。如果 ![inline-image](../images/CH018_19.jpg)，那么整个输入金额将被转移到输出中。另一方面，如果
    ![inline-image](../images/CH018_20.jpg)，那么差额 ![inline-image](../images/CH018_21.jpg)
    将被转移到成功创建包含交易的区块的 P2P 网络中的节点。这个差额 *δ* 被称为交易费，是网络中的节点将交易包含在区块中的激励。
- en: Note that the entire amount ![inline-image](../images/CH018_22.jpg) owned by
    the spender public keys is utilised, either by transferring to recipient public
    keys or as the transaction fee. There is no way for a spender public key to retain
    a part of the amount that it holds. Suppose a physical entity *A* possesses the
    secret key ![inline-image](../images/CH018_23.jpg) corresponding to a public key
    ![inline-image](../images/CH018_24.jpg) which owns *x* amount of the cryptocurrency.
    Further, suppose *A* wishes to make a payment of an amount *y* < *x* to a public
    key ![inline-image](../images/CH018_25.jpg). If *A* creates a transaction with
    ![inline-image](../images/CH018_26.jpg) as the spender key and transferring *y*
    to ![inline-image](../images/CH018_27.jpg), then the amount *x* − *y* becomes
    the transaction fee and is a loss to *A*. The way to make such a part payment
    is the following. Entity *A* creates a new public/signing key pair ![inline-image](../images/CH018_28.jpg)
    and ![inline-image](../images/CH018_29.jpg) and keeps ![inline-image](../images/CH018_30.jpg)
    secret. It then creates a transaction with ![inline-image](../images/CH018_31.jpg)
    as the spender public key transferring amount *y* to ![inline-image](../images/CH018_32.jpg)
    and amount *z* to ![inline-image](../images/CH018_33.jpg) such that *y* + *z*
    ≤ *x*. Since *A* possesses the signing key ![inline-image](../images/CH018_34.jpg),
    it can later spend the amount *z* assigned to ![inline-image](../images/CH018_35.jpg).
    Note that if *y* + *z* = *x*, then there is no transaction fee. Entity *A* may
    set the value of *z* such that there is a small amount of transaction fee to incentivise
    nodes to include the transaction into a block.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，花费者公钥拥有的整个金额![inline-image](../images/CH018_22.jpg)要么用于转移到接收者公钥，要么作为交易费用。花费者公钥无法保留其所持金额的一部分。假设一个实体*A*拥有与持有*x*金额的公钥![inline-image](../images/CH018_24.jpg)对应的秘钥![inline-image](../images/CH018_23.jpg)。此外，假设*A*希望向公钥![inline-image](../images/CH018_25.jpg)支付小于*x*的金额*y*。如果*A*创建一个以![inline-image](../images/CH018_26.jpg)作为花费者密钥，并向![inline-image](../images/CH018_27.jpg)转移*y*的交易，那么金额*x*
    − *y*将成为交易费用，对*A*来说是损失。实现这种部分支付的方法如下。实体*A*创建一个新的公共/签名密钥对![inline-image](../images/CH018_28.jpg)和![inline-image](../images/CH018_29.jpg)，并保持![inline-image](../images/CH018_30.jpg)的机密。然后，它创建一个以![inline-image](../images/CH018_31.jpg)作为花费者公钥，向![inline-image](../images/CH018_32.jpg)转移金额*y*和向![inline-image](../images/CH018_33.jpg)转移金额*z*的交易，使得*y*
    + *z* ≤ *x*。由于*A*拥有分配给![inline-image](../images/CH018_35.jpg)的金额*z*的签名密钥![inline-image](../images/CH018_34.jpg)，因此它稍后可以花费这笔金额*z*。请注意，如果*y*
    + *z* = *x*，则不存在交易费用。实体*A*可以设置*z*的值，以便有少量的交易费用，以激励节点将交易包含到一个区块中。
- en: 18.3 Cryptocurrency Addresses
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.3 加密货币地址
- en: We have mentioned that public keys are owners of cryptocurrency. This statement
    is not accurate. More technically, the owners of cryptocurrency are addresses.
    These addresses are formed by applying a hash function to the public keys. The
    hash function that is used to generate the addresses may be different from the
    hash function used to chain the blocks in the blockchain. Suppose *H* 1 is the
    hash function used to generate addresses. Given a public key ![inline-image](../images/CH018_36.jpg),
    an address is computed as ![inline-image](../images/CH018_37.jpg).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到公钥是加密货币的所有者。这种说法并不准确。更准确地说，加密货币的所有者是地址。这些地址是通过将哈希函数应用于公钥而形成的。用于生成地址的哈希函数可能与用于链式区块的哈希函数不同。假设*H*1是用于生成地址的哈希函数。给定一个公钥![inline-image](../images/CH018_36.jpg)，地址计算为![inline-image](../images/CH018_37.jpg)。
- en: Assuming that *H* 1 is collision resistant, cryptocurrency addresses are unique
    encodings of the public keys. Suppose that (*sk*, *pk*) is a pair of signing and
    verification keys and ![inline-image](../images/CH018_38.jpg). The amount of cryptocurrency
    associated with the address can be spent by whoever possesses the signing key
    ![inline-image](../images/CH018_39.jpg). If it is possible to generate another
    pair of signing and verification keys ![inline-image](../images/CH018_40.jpg)
    such that ![inline-image](../images/CH018_41.jpg), then using ![inline-image](../images/CH018_42.jpg)
    it becomes possible to spend the amount associated with the address *a*. Given
    ![inline-image](../images/CH018_43.jpg) and ![inline-image](../images/CH018_44.jpg),
    the task of obtaining ![inline-image](../images/CH018_45.jpg) such that ![inline-image](../images/CH018_46.jpg)
    is that of finding a second pre-image of the element *a* in the range of *H* 1\.
    Under the assumption that *H* 1 is second pre-image resistant, this task is computationally
    infeasible.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 假设*H*1是碰撞抵抗的，加密货币地址是公钥的唯一编码。假设(*sk*, *pk*)是一对签名和验证密钥，并且![inline-image](../images/CH018_38.jpg)。与地址关联的加密货币金额可以由持有签名密钥的人花费![inline-image](../images/CH018_39.jpg)。如果可能生成另一对签名和验证密钥![inline-image](../images/CH018_40.jpg)，使得![inline-image](../images/CH018_41.jpg)，那么使用![inline-image](../images/CH018_42.jpg)就可以花费与地址*a*关联的金额。给定![inline-image](../images/CH018_43.jpg)和![inline-image](../images/CH018_44.jpg)，获得![inline-image](../images/CH018_45.jpg)使得![inline-image](../images/CH018_46.jpg)的任务是在*H*1的范围内找到元素*a*的第二个前像。在*H*1是第二个前像抵抗的假设下，这个任务是计算上不可行的。
- en: We have mentioned that a transaction transfers funds from spender public keys
    to recipient public keys. A more accurate statement is that a transation transfers
    funds from spender addresses to recipient addresses where the addresses are computed
    as digests of relevant public keys by applying the hash function *H* 1\. For a
    conceptual understanding, it is not required to distinguish between public keys
    and their addresses. Accordingly, we will continue talking about cryptocurrency
    being assigned to public keys rather than to addresses.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到过，一笔交易将资金从花费者的公钥转移到收款者的公钥。更准确地说，一笔交易将资金从花费者的地址转移到收款者的地址，这些地址是通过应用哈希函数 *H*
    对相关公钥的摘要计算得出的。为了概念上的理解，不需要区分公钥和它们的地址。因此，我们将继续谈论加密货币被分配给公钥，而不是地址。
- en: 18.4 Recapitulation
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.4 回顾
- en: Let us briefly recapitulate what has been discussed. The owners of various amounts
    of cryptocurrency are public keys. Transactions record the details of payment
    from one or more public keys to one or more other public keys.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要回顾一下讨论的内容。各种数量的加密货币的所有者是公钥。交易记录了从一个或多个公钥到一个或多个其他公钥的支付细节。
- en: A cryptocurrency is implemented using a blockchain. Groups of transactions are
    organised into blocks, and the blocks are sequenced into the blockchain. The blockchain
    is maintained in a distributed fashion by a P2P network. Complete information
    regarding which public key owns what amount of cryptocurrency is available from
    the blockchain. Each node in the network maintains its own copy of the blockchain
    and the list of transactions which are yet to be inserted into the blockchain.
    Nodes generate transactions and use the gossip protocol of the P2P network to
    propagate them. Nodes also create blocks and propagate them using the gossip protocol.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 使用区块链实现加密货币。交易组织成块，并且这些块被顺序排列到区块链中。区块链通过点对点网络以分布式方式维护。关于哪个公钥拥有多少加密货币的完整信息可从区块链获取。网络中的每个节点维护自己的区块链副本和尚未插入到区块链的交易列表。节点生成交易并使用点对点网络的八卦协议传播它们。节点还创建块并使用八卦协议传播它们。
- en: A block is of the form ![inline-image](../images/CH018_47.jpg), where *h* is
    the digest under the hash function *H* of the previous block, *R* is a list of
    transactions and ![inline-image](../images/CH018_48.jpg) is a special value. So
    far, we have not explained the role of ![inline-image](../images/CH018_49.jpg).
    This parameter plays a crucial role in the creation of a block. Next we explain
    how a block is created and the role of ![inline-image](../images/CH018_50.jpg)
    in it.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 一个区块的形式如 ![inline-image](../images/CH018_47.jpg)，其中 *h* 是前一个区块在哈希函数 *H* 下的摘要，*R*
    是交易列表，而 ![inline-image](../images/CH018_48.jpg) 则是一个特殊值。到目前为止，我们还没有解释 ![inline-image](../images/CH018_49.jpg)
    的角色。这个参数在创建区块中起着至关重要的作用。接下来我们将解释区块如何创建以及 ![inline-image](../images/CH018_50.jpg)
    在其中的作用。
- en: 18.5 Creation of a Block via Proof of Work
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.5 通过工作证明创建区块
- en: Consider a node *v* whose local copy of the blockchain is ![inline-image](../images/CH018_51.jpg)
    with a block ![inline-image](../images/CH018_52.jpg) as the header. The list of
    un-blocked transactions available with *v* is ![inline-image](../images/CH018_53.jpg).
    To create a block, *v* chooses a list of transactions *R* from ![inline-image](../images/CH018_54.jpg)
    and verifies each of them. The verification checks on the transactions have been
    explained above. Node *v* computes ![inline-image](../images/CH018_55.jpg). Next
    it attempts to create a block ![inline-image](../images/CH018_56.jpg). It is in
    this step that ![inline-image](../images/CH018_57.jpg) plays a role.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个节点 *v*，其区块链的本地副本为 ![inline-image](../images/CH018_51.jpg)，其中的一个区块 ![inline-image](../images/CH018_52.jpg)
    为头部。节点 *v* 可用的未封锁交易列表为 ![inline-image](../images/CH018_53.jpg)。要创建一个区块，*v* 从 ![inline-image](../images/CH018_54.jpg)
    中选择一个交易列表 *R* 并验证每个交易。交易验证检查已在上文中解释过。节点 *v* 计算 ![inline-image](../images/CH018_55.jpg)。然后尝试创建一个区块
    ![inline-image](../images/CH018_56.jpg)。正是在这一步中，![inline-image](../images/CH018_57.jpg)
    起到作用。
- en: To create a block, node *v* is expected to do some work. Further, *v* is required
    to provide a proof that the required work has indeed been done. There is a system-wide
    parameter *d* which determines the *difficulty* of generating a proof of work.
    The difficulty *d* is a positive integer which controls the amount of work that
    is required to create a new block. The parameter *d* is not the actual difficulty;
    rather, the difficulty is inversely proportional to *d* as we will see below.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个区块，节点 *v* 预期需要做一些工作。此外，*v* 还需要提供一个证明，证明所需工作确实已完成。系统范围内有一个参数 *d*，它确定了生成工作证明的*难度*。难度
    *d* 是一个正整数，控制着创建新区块所需的工作量。参数 *d* 并非实际难度；相反，难度与 *d* 成反比，我们将在下文看到。
- en: As explained earlier, the digest (or, output) of the hash function *H* is an
    *n*-bit binary string and can be considered to be the binary representation of
    integers in the set {0,…,2 ^([*n*]) −1}. Interpreted in this manner, the output
    of *H* can be considered to be an integer. Suppose on some input, the output of
    *H* is *y*. If the most significant bit of *y* is 0, then *y* is less than 2 ^(*n*−1);
    if the two most significant bits of *y* is 0, then *y* is less than 2 ^(*n*−2);
    and so on.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面解释的，哈希函数 *H* 的摘要（或输出）是一个 *n* 位二进制字符串，可以被视为集合 {0,…,2 ^(*n*) −1} 中整数的二进制表示。用这种方式解释，*H*
    的输出可以被视为一个整数。假设在某些输入上，*H* 的输出是 *y*。如果 *y* 的最高有效位为 0，则 *y* 小于 2 ^(*n*−1)；如果 *y*
    的两个最高有效位为 0，则 *y* 小于 2 ^(*n*−2)；依此类推。
- en: For node *v* to create a block ![inline-image](../images/CH018_58.jpg), it must
    find a value of ![inline-image](../images/CH018_59.jpg) such that ![inline-image](../images/CH018_60.jpg).
    Let us consider the difficulty of this computational task.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要使节点 *v* 创建一个区块 ![inline-image](../images/CH018_58.jpg)，它必须找到一个值 *x*，使得 ![inline-image](../images/CH018_59.jpg)。让我们考虑一下这个计算任务的难度。
- en: One way for *v* to determine ![inline-image](../images/CH018_61.jpg) is to first
    choose a value *y* which is less than *d* and then find an ![inline-image](../images/CH018_62.jpg)
    such that ![inline-image](../images/CH018_63.jpg). This means that given a particular
    output *y*, it is required to find a pre-image ![inline-image](../images/CH018_64.jpg)
    of *y* under *H*, i.e. to invert the function *H*. Recall that one of the basic
    properties of *H* is that it is one-way which means that it is computationally
    infeasible to invert *H*. So, we can assume that *v* is unable to determine ![inline-image](../images/CH018_65.jpg)
    by inverting *H* on the digest *y*. The input to *H* is ![inline-image](../images/CH018_66.jpg),
    of which ![inline-image](../images/CH018_67.jpg) is obtained as ![inline-image](../images/CH018_68.jpg)
    and *R* is the set of transactions to be included in the block *B*. The quantities
    ![inline-image](../images/CH018_69.jpg) and *R* are fixed and there is flexibility
    only in choosing ![inline-image](../images/CH018_70.jpg). So, the task of inverting
    *H* in the present context is not simply to obtain any particular pre-image of
    *y*, but, one that has ![inline-image](../images/CH018_71.jpg) and *R* as the
    first two components. This is an even more difficult task than simply inverting
    *H*. Of course, since *H* is one-way to start with, this distinction does not
    matter.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Another way in which *v* can attempt to find ![inline-image](../images/CH018_72.jpg)
    is to repeatedly try distinct values of ![inline-image](../images/CH018_73.jpg)
    and compute ![inline-image](../images/CH018_74.jpg). By trying many values, *v*
    can hope to eventually find a value ![inline-image](../images/CH018_75.jpg) such
    that ![inline-image](../images/CH018_76.jpg). At this point, *v* has been able
    to create the block ![inline-image](../images/CH018_77.jpg). Node *v* will propagate
    *B* using the gossip protocol.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: How many times should *H* have to be computed before finding a desirable ![inline-image](../images/CH018_78.jpg)?
    To answer this question, the random oracle assumption on *H* is used, i.e. the
    hash function *H* is assumed to behave like a uniform random function which on
    distinct inputs returns independent and uniformly distributed *n*-bit strings
    (equivalently, independent and uniformly distributed integers from the set {0,…,2
    ^([*n*]) −1}). For any positive integer *d*, there are *d* non-negative integers
    less than *d*. So, under the random oracle assumption on *H*, the probability
    that a single invocation of *H* returns a *y* such that *y* < *d* is *d*/2 ^([*n*])
    . Considering *y* < *d* to be success, repeated invocations of *H* gives rise
    to independent Bernoulli trials with probability of success *d*/2 ^([*n*]) . The
    expected number of successes in *N* such trials is ![inline-image](../images/CH018_79.jpg).
    We wish to obtain one success and so setting *Nd*/2 ^([*n*]) = 1 gives *N* = 2
    ^([*n*]) /*d*, i.e. in about 2 ^([*n*]) /*d* trials, one may expect to obtain
    a ![inline-image](../images/CH018_80.jpg) such that ![inline-image](../images/CH018_81.jpg).
    So, for example, if *d* = 2 ^(*n*−32), then successful creation of a block requires
    about 2^(32) invocations of *H*.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Creation of a block by a node *v* requires repeated invocation of the hash function
    *H*. This is the work that the node *v* has to do to create the block. The value
    of ![inline-image](../images/CH018_82.jpg) such that ![inline-image](../images/CH018_83.jpg)
    is the *proof* that node *v* has indeed put in the required amount of work. Note
    that given the value ![inline-image](../images/CH018_84.jpg), checking the condition
    ![inline-image](../images/CH018_85.jpg) requires only one invocation of *H* and
    is very efficient. So, generating a proof of work is time consuming, while verifying
    a given proof is easy.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Any new block created by a node is propagated on the P2P network using the gossip
    protocol. Nodes which receive a new block will insert it into its copy of the
    blockchain. Before doing this, a node will verify the proof of work. If the verification
    fails, then the block will be rejected.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 任何一个节点创建的新区块都会使用八卦协议在P2P网络上传播。接收到新区块的节点会将其插入到自己的区块链副本中。在执行此操作之前，节点会验证工作证明。如果验证失败，则会拒绝该区块。
- en: The actual difficulty is inversely proportional to *d*. Difficulty of creating
    a new block is stored as part of the metadata of the block. The difficulty of
    a blockchain is the sum of difficulties of the blocks in the blockchain.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 实际困难与*d*成反比。创建新区块的难度作为区块的元数据的一部分存储。区块链的难度是区块链中各区块的难度之和。
- en: 18.6 Block Reward and Creation of Cryptocurrency
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.6 区块奖励和加密货币的创建
- en: Creating a new block requires a node to put in a certain amount of work. This
    work consists of using the computational resources of the node and has a cost.
    To incentivise nodes to create blocks, the system provides for a block reward.
    The block reward comes in the form of certain amount of cryptocurrency.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新区块需要节点投入一定量的工作。这项工作包括使用节点的计算资源，并带有成本。为了激励节点创建区块，系统提供了区块奖励。区块奖励以一定数量的加密货币形式提供。
- en: There are two components to a block reward. The first component comes from the
    minting of new currency which goes to the creator of the block. The second component
    consists of the transaction fees available in the transactions which have been
    grouped together in the block. The issue of transaction fees has already been
    explained. To incentivise nodes to include a transaction into a block, the total
    amount of cryptocurrency transferred to recipient public keys is kept less than
    the total amount of cryptocurrency held by the spender public keys. The difference
    is the fee of the transaction and is claimed by the node which successfully creates
    a block containing this transaction.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 区块奖励有两个组成部分。第一个组成部分来自于铸造新货币，该部分归区块创建者所有。第二个组成部分由交易费组成，这些交易已经被组合到区块中。交易费问题已经解释过了。为了激励节点将交易包含在区块中，转账给接收方公钥的加密货币总金额被保持小于由花费方公钥持有的加密货币总金额。差额是交易的费用，并由成功创建包含此交易的区块的节点所要求。
- en: New currency is created when a block is successfully created. The successful
    creation of a block is also called *mining* of a block. The rules of the cryptocurrency
    system specify the amount of cryptocurrency that is to be created when a block
    is successfully mined. This amount of cryptocurrency was not previously present
    in the system. So, the volume of cryptocurrency grows as new blocks are mined.
    In fact, the rules of the cryptocurrency system actually specify the rate at which
    the volume of cryptocurrency grows. The rate of creation of cryptocurrency decreases
    over time until finally no more new currency will be created.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Suppose node *v* successfully mines a block ![inline-image](../images/CH018_86.jpg).
    It may be noted here that all transactions in *R* other than the first one are
    present in ![inline-image](../images/CH018_87.jpg). The first transaction in *R*
    is special and is called a *coinbase transaction*. This transaction does not have
    any spender public key. It only has one or more recipient public keys. The amount
    of cryptocurrency assigned to the recipient public keys is the block reward which
    is the sum of the transaction fees of all the transactions in *R* and the amount
    of new currency that is created with the mining of the block. At a time when no
    more new currency will be created, the block reward will consist entirely of the
    transaction fees.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: 18.7 Hash Rate
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have seen that in about 2 ^([*n*]) /*d* invocations of *H* it becomes likely
    to obtain a digest which is less than *d*. These invocations are independent and
    can be performed in parallel.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: The nodes in the P2P network of the cryptocurrency system compete among themselves
    to mine a block. Mining a block essentially consists of applying the hash function
    *H* repeatedly. The repeated application of *H* requires computational power.
    Since computing consumes energy, mining a block also consumes a significant amount
    of electricity. While the nodes have the same privileges on the network, by no
    means do they have the same amount of computational power. Nodes with greater
    computational resources are more likely to mine a block.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: At any point of time, the nodes in the P2P network are applying *H* to mine
    a block. So, one may consider the total computational power of the network to
    be the number of times *H* is invoked in one second by all the nodes in the network.
    Essentially, this is the rate at which the entire network applies the hash function
    *H*. The hash rate *ν* *v* of a node *v* is the number of times *v* is able to
    apply *H* in one second. Then the total hash rate of the network is ![inline-image](../images/CH018_88.jpg)
    where the sum is over all the nodes in the network. The proportion of the hash
    rate of the entire network controlled by *v* is ![inline-image](../images/CH018_89.jpg).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: The quantity *p* *v* is the probability of *v* being able to mine the next block.
    Assume that a sufficiently large number *N* of blocks have been mined in the network.
    Then the expected number of blocks mined by *v* is *p* *v* *N*.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: A node *v* has to invest a certain amount of money μ to attain a hash rate *ν*
    *v* . Its expected return on this investment after *N* blocks have been mined
    is the total amount of block reward earned from *p* *v* *N* blocks. The business
    venture is profitable for *v* only if the total block reward for *p* *v* *N* blocks
    is more than *μ*. In determining profitablity, node *v* not only has to consider
    the cost of increasing its own hash rate but also has to take into account the
    investments being made by other nodes. This is because *p* *v* is the ratio of
    *ν* *v* to *ν*, where *ν* is the sum of the hash rates of all the nodes in the
    network. If *v* increases *ν* [*v*] , but other nodes also increase their hash
    rates perhaps outpacing *ν* [*v*] , then the ratio *p* *v* = *ν* *v* /*ν* may
    actually go down even though *ν* *v* increases. In such a situation, node *v*
    will not be able to make a profit even though it has increased its hash rate through
    a new investment.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: An interesting example is that of China's Bitmain versus Japan's GMO. GMO had
    invested heavily to improve its hash rate. However, Bitmain outpaced GMO and eventually,
    even though GMO increased its hash rate, its probability of mining did not improve.
    Overall, the investment in increasing computational power was not compensated
    by increased returns. This led GMO to withdraw from Bitcoin mining at the end
    of 2018, taking a loss of about US $300 million.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 18.8 Updating the Difficulty Parameter
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Suppose the network hash rate is ν hashes per second. With a fixed value of
    *d*, the number of hashes required to obtain a new block is about 2 ^([*n*]) /*d*.
    So, considering the network as a whole, a new block is mined in about every 2
    ^([*n*]) /(*dν*) seconds. Recall that the mining of a new block leads to the creation
    of new cryptocurrency. Thus, new amounts of the cryptocurrency are created every
    2 ^([*n*]) /(*dν*) seconds.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: The hash rate *ν* of the network depends upon the total computational capabilities
    of all the nodes in the P2P network. As the nodes in the network increase their
    computational resources, the hash rate *ν* increases. If *d* is kept constant,
    then new cryptocurrency will be created faster. If the total amount of money in
    the system increases very fast, this would lead to an inflationary situation.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: There are two ways in which such an inflationary scenario can be prevented.
    First, the value of the parameter *d* is decreased so that the value of 2 ^([*n*])
    /(*dν*) remains constant. Second, the amount of cryptocurrency created per block
    decreases at a steady pace. We discuss these two points with specific reference
    to Bitcoin.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: The goal of Bitcoin is to ensure that a new block is mined in about 10 minutes,
    i.e. ![inline-image](../images/CH018_90.jpg). When *ν* increases, the value of
    *d* is decreased so that the ratio 2 ^([*n*]) /(*dν*) remains about 360\. Since,
    we are considering a P2P network, there is no central node which knows the total
    hash rate *ν* of the system. So, the adjustment of the parameter *d* cannot be
    done directly based on the knowledge of *ν*. An increase of the hash rate *ν*
    of the network will have the effect of new blocks being discovered faster. The
    block discovery time is part of the metadata of each block and is available from
    the blockchain. So, the nodes in the network are able to obtain the time that
    was required to discover each block in the blockchain.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: At the creation rate of 10 minutes per block, in 2 weeks a total of 2,016 blocks
    can be mined. The Bitcoin protocol considers the mined blocks to be divided into
    windows of 2,016 blocks. The value of *d* is constant in each window of 2,016
    blocks, i.e. each such window is a constant difficulty period. At the end of a
    window of 2,016 blocks, the time to compute these blocks is considered. If this
    time is less than 2 weeks, then it indicates that the hash rate *ν* of the network
    has gone up, while if the time is more than 2 weeks, then the hash rate has gone
    down. The value of *d* is accordingly adjusted. We do not provide the exact details
    of this procedure, since that is not required for a conceptual understanding of
    the idea. It is sufficient to note that if less than 2 weeks' time was required,
    then the value of *d* is reduced while if more than 2 weeks' time was required,
    then the value of *d* is increased. In the next window of 2,016 blocks, the value
    of *d* remains constant. So far, the difficulty updation algorithm of Bitcoin
    has worked well to ensure that a new block is mined in about 10 minutes.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 18.9 Controlling the Rate of Money Creation
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The other way to control inflation is to reduce the amount of new currency that
    is created with every mined block. This is done in a controlled fashion. For this
    purpose, the blocks in the blockchain are considered to be divided into windows
    of size 210,000 blocks. At the rate of about 10 mintues for mining a block, the
    time for mining 210,000 blocks is about 4 years. In each window of 210,000 blocks,
    the amount of Bitcoin created by the mining of a new block remains constant. At
    the end of 210,000 blocks, this amount is halved. In the first window of 210,000
    blocks, the mining of each new block created 50 Bitcoins. In the next window of
    210,000, the mining of each new block created 25 bitcoins. The Bitcoin protocol
    is designed so that there are 64 such halving events. After that, the mining of
    a new block will not create any new Bitcoin. At the rate of 10 minutes per block,
    this event is expected to occur sometime in the year 2140\. The total amount of
    Bitcoin that can be created is 21 million. When no more new Bitcoin can be created,
    the entire cost of mining will have to be borne by the transaction fees of the
    transactions to be included in a block.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 18.10 Choosing between Competing Blocks
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Chapter 17, we have explained that each node in the P2P network maintains
    a private copy of the blockchain. Newly created blocks are propagated through
    the network using the gossip protocol. It is important to note that the time for
    a block to propagate through the entire network is insignificant in comparison
    to the time to create a new block.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Suppose a node *v* obtains a block. As mentioned earlier, it is possible for
    *v* to obtain two or more blocks almost simultaneously. The rules of the cryptocurrency
    system have to specify how node *v* will update its private copy of the blockchain.
    We explain this with reference to Bitcoin.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: The conflict resolution mechanism is based on difficulty. One simple rule is
    that if two blocks have the same difficulty, then *v* retains the block that it
    obtained earlier. Now suppose that *v* obtains two or more blocks such that there
    arises the possibility of two blockchains which are the same up to some point
    and then branch out. These two possible blockchains have two different values
    of difficulty. The updation rules of Bitcoin specify that node *v* will maintain
    the more difficult blockchain and discard the blockchain with lesser difficulty.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Given that the blocks have the same difficulty, node *v* will retain the longer
    chain. It is, however, possible, that node *v* will retain the shorter chain if
    it is more difficult. Difficulty of a blockchain captures the amount of work that
    has been put in to create the blockchain. Thus, the rules specify that the chain
    which required higher amount of work for its creation is retained.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 18.11 Confirmation of Transaction
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Transactions are issued by users. A transaction *T* enters the network through
    some node and is propagated to all the nodes. At some point, some node chooses
    the transaction for inclusion into a block *B*. Suppose that the node successfully
    mines the block. The block *B* is then propagated to the entire network. The node
    which originally propagated the transaction *T* also gets *B* and appends it to
    the head of its blockchain. At this point, the user which issued the transaction
    *T* may consider that the transaction has been confirmed by the network. However,
    as pointed out above, it is possible that the receipt or creation of another block
    ![inline-image](../images/CH018_91.jpg) results in the block *B* being removed
    from the blockchain. If this happens, then transaction *T* is no longer in the
    blockchain and the confirmation becomes invalid.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: In view of this problem, it is usually recommended that the user wait until
    the block *B* containing the transaction *T* is buried sufficiently deep in the
    blockchain. It is extremely unlikely that the blockchain will be modified to this
    depth. Bitcoin, for example, recommends waiting until block *B* is six blocks
    deep in the blockchain. Considering that a block is generated every 10 minutes,
    generating six blocks takes about an hour. So, the user has to wait for about
    an hour before considering that the transaction has been confirmed on the blockchain.
    This time does not consider the waiting time for a transaction to get into a block.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 18.12 No Double Spending
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A basic requirement for any currency is that it should not be possible to spend
    the same currency twice. Double spending refers to the situation where the owner
    of a currency is able to spend the same currency twice. Let us consider how such
    a situation may arise in a cryptocurrency and why this should not be possible.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Suppose a user *U* makes a payment of a certain amount of cryptocurrency as
    part of a transaction *T*. This user controls a node of the P2P network and introduces
    *T* to the network through this node. At some point of time, the transaction *T*
    is included into a mined block *B* and becomes part of the blockchain. Further,
    suppose that *B* gets embedded sufficiently deep in the blockchain so that the
    transaction *T* is considered to be confirmed. At this point, the user *U* receives
    the goods or services in lieu of the payment made via *T*.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: The payment made by *U* in transaction *T* is from a spender public key ![inline-image](../images/CH018_92.jpg)
    for which the corresponding signing key ![inline-image](../images/CH018_93.jpg)
    is known to *U*. Supppose that ![inline-image](../images/CH018_94.jpg) initially
    had *x* units of the cryptocurrency. After the transaction *T*, ![inline-image](../images/CH018_95.jpg)
    will no longer have any cryptocurrency associated with it. Once *T* gets confirmed,
    the public ledger records that there is no more currency associated with ![inline-image](../images/CH018_96.jpg).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Now consider that *U* wishes to spend the currency associated with ![inline-image](../images/CH018_97.jpg)
    again. The public ledger records that the entire amount associated with ![inline-image](../images/CH018_98.jpg)
    has been spent as part of transaction *T*. So, by checking the public ledger,
    anybody can verify that subsequent to transaction *T*, there is no longer any
    amount associated with ![inline-image](../images/CH018_99.jpg). So, while transaction
    *T* is on the public ledger, it is not possible for *U* to again spend the amount
    associated with ![inline-image](../images/CH018_100.jpg). Consequently, *U* may
    try to modify the public ledger so as to remove *T* from it. The transaction *T*
    is a part of the block *B*. So, *T* can be removed only by removing block *B*.
    Suppose *U* performs a new transaction ![inline-image](../images/CH018_101.jpg)
    which spends the amount associated with ![inline-image](../images/CH018_102.jpg)
    but the recipient public keys are different from those in *T*. *U* then replaces
    *T* in *B* with ![inline-image](../images/CH018_103.jpg) to create a possible
    block ![inline-image](../images/CH018_104.jpg). The creation of the block ![inline-image](../images/CH018_105.jpg)
    will require *U* to mine it, i.e. *U* will have to obtain a suitable value of
    ![inline-image](../images/CH018_106.jpg).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: At the time when *U* received the benefits of his original payment in the transaction
    *T*, the block *B* had already been embedded sufficiently deep in the blockchain.
    So, if *U* tries to modify the blockchain by replacing *B* with ![inline-image](../images/CH018_107.jpg),
    *U* will be required not only to mine the block ![inline-image](../images/CH018_108.jpg)
    but also the blocks subsequent to *B* in the blockchain. Suppose *B* had been
    embedded *t* blocks deep in the blockchain. Then *U* will be required to mine
    *t* blocks and propagate the new blocks to the network. Further, *U* will have
    to ensure that its propagation of the modified blockchain is accepted by the network.
    For this, it is required to mine these *t* blocks *before* some other node mines
    a new header for the original blockchain. Since, otherwise, *U*'s propagation
    of the modified blockchain will be rejected by the nodes in the network.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Thus, to double spend (i.e. to spend the currency associated with ![inline-image](../images/CH018_109.jpg)
    twice), *U* will be required to have substantially more computational power than
    the combined computational power of all the other nodes in the network. As long
    as such a condition does not occur, it is not possible to double spend.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 18.13 The 51% Attack
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A cryptocurrency system can be said to have been defeated if it becomes possible
    to spend the same amount of currency twice. This can be seen as an attack on the
    cryptocurrency system and is called a double spending attack.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: The computational power of a node *v* is measured by its hash rate *ν* *v* .
    Suppose that the node *v* acquires computational power such that *ν* *v* > *ν*/2,
    where ![inline-image](../images/CH018_110.jpg) is the total hash rate of the network.
    In other words, the hash rate of *v* is more than half of the network hash rate.
    As a result, *v* has more than 50% probability of mining each new block. This
    provides *v* with a high degree of control over the blocks that are mined and
    also increases its chances of launching a double spending attack on the network.
    Such a scenario is called the 51% attack.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: A double spending attack on the network may lead to a serious loss of credibility
    of the cryptocurrency and bring down its value. The lowering of value of the cryptocurrency
    will also affect the gains of the adversary who would have invested heavily in
    acquiring the computational power to ensure more than half of the hash rate of
    the network. It has been argued that this provides a natural de-motivating factor
    for an adversary to launch a double spending attack. However, double spending
    attacks have indeed been reported on several cryptocurrencies.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 19
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Cryptocurrency: Further Issues'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, we have seen some of the basic concepts of cryptocurrency.
    The present chapter looks at a number of issues which arise when a cryptocurrency
    is adopted in the real world.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 19.1 Mining Pools
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The nodes in the P2P network compete with each other to mine new blocks. This
    competition is inherently non-cooperative, i.e. the nodes do not cooperate among
    themselves for the task of block mining.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Mining of a block is a computation-intensive task. For Bitcoin, a substantial
    amount of computational power is required to ensure a significant probability
    of success in mining a block. An individual entity with limited computational
    power may not be able to successfully mine a block within a reasonable amount
    of time. This is the motivation for a group of entities to pool together their
    computational resources towards the goal of block mining. The pool as a whole
    acquires sufficient computational capability to ensure that a block is mined within
    a reasonable time. When a block is mined, the block reward is distributed among
    the members of the pool according to some formula based on the shares of the work
    done by each of the entities. The goal for an entity is that joining a pool ensures
    a steady flow of income rather than waiting for a few years before being able
    to successfully mine a block on its own.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: A mining pool represents a cooperative process. The method of sharing the block
    reward among the members of the pool provides the incentive mechanism. There are
    several such incentive mechanisms which are used in practice.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: While the overall task of block mining is non-cooperative, entities with low
    computational powers can cooperate among themselves to create mining pools. Thus,
    the activity of block mining shows both non-cooperative and cooperative characteristics.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 19.2 Change of Rules
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It has been mentioned several times that a cryptocurrency system (or protocol)
    operates under certain rules. These rules are implemented by the software which
    the nodes in the P2P network run. The basis for the operation of a cryptocurrency
    system is consensus. The rules which regulate the cryptocurrency operations are
    accepted by all the nodes. A set of rules is initially written and implemented
    in the software for the cryptocurrency system. Entities which would like to join
    the system, download the software and run them on computers and thus become nodes
    in the network. Entities can also have their own version of the software for possibly
    improving efficiency. Any such software will have to implement the same set of
    rules.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: As the system evolves with more and more nodes joining and transactions taking
    place, it may become necessary to change some of the rules. Consensus will also
    be required for such a change of rules. Cryptocurrency systems usually have in
    place some kind of mechanism for proposing and accepting a change of rule. We
    explain this issue in more detail with reference to Bitcoin.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: A proposal for a change of rules in Bitcoin is called a Bitcoin Improvement
    Protocol (BIP). A BIP is initially proposed by a handful of developers. One month
    after a BIP is defined it moves into a phase called the *started* phase. At this
    stage, support to the BIP has to be indicated by the participants in the network.
    The metadata for all blocks contain a provision for indicating support to a proposed
    BIP. This is in the form of a bit. The miner which mines the block, sets the bit
    to 1 if it supports the associated BIP, otherwise it is set to 0\. Several BIPs
    may be simultaneously under consideration. For each such BIP, a miner indicates
    its support or lack of it by setting the associated bit in the metadata of the
    newly mined block.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: A constant difficulty period is a window of 2,016 blocks during which the difficulty
    of block mining remains the same. Since mining a block takes about 10 minutes,
    a constant difficulty period lasts for about 2 weeks. In a year, there are about
    26 such constant difficulty periods. If in any such constant difficulty period,
    a BIP obtains support above a certain threshold number of blocks, then in the
    next difficulty period, all entities who wish to adopt the new rules can do so.
    The required threshold is 1,916 blocks (which is roughly 95% of 2016, the number
    of blocks mined in a 2-week period). Once the desired level of support is obtained
    for a BIP, it gets activated. After that, transactions and blocks following the
    new rules are accepted by the nodes in the network.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: A BIP is said to time-out or fail if it is not activated within 1 year of it
    being started. At that point, it is no longer considered for voting by the setting
    of bits in the newly mined blocks.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 19.3 Forks
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have mentioned how forking may arise when a node receives new blocks which
    require modifying its copy of the blockchain. This kind of forking is localised
    at the node itself. To handle such a fork, the node discards blocks from its blockchain
    and adopts the new blocks so as to be consistent with the other nodes. So, this
    kind of forking is transient, and the individual node of the system soon gets
    in synchronisation with the consensus public blockchain.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Forking of a blockchain can be more serious. Transactions and blocks have to
    follow the consensus rules. If the rules change and some of the nodes choose to
    follow the new rules, but the other nodes adhere to the old rules, then forking
    occurs. Such a forking leads to two distinct blockchains. The two blockchains
    have a common history, i.e. they have the same blocks up to a certain point and
    after that there is a bifurcation.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: There are two types of forks, namely soft and hard forks. Suppose a rule change
    is such that the blocks following the new rule are compatible with the older rules,
    then the nodes which choose to follow the older rules will continue incorporating
    such blocks into their blockchain. On the other hand, blocks generated by the
    old rules may not be acceptable to the nodes which follow the new rules. This
    leads to a fork. Such a fork is called a soft fork. A hard fork occurs when blocks
    which follow the new rules are incompatible with the old rules and are rejected
    by the nodes which follow the old rules. In view of this, a soft fork is said
    to be backward compatible while a hard fork is not.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: To consider common examples of soft and hard forks, suppose initially there
    is no limit on the number of transactions that can be included in a block. A later
    rule change imposes a size limit of a block. Then blocks following the new rule
    are compatible with the old rule and will be accepted by the nodes following the
    old rule. On the other hand, blocks generated using the old rule may be larger
    than the new size limit. Such blocks will be rejected by the nodes following the
    new rule. This leads to a soft fork. Now suppose that a further rule change takes
    place which increases the size limit of a block. Then a block following the new
    rule may be of size greater than that mandated by the old rules. Such a block
    will be rejected by the nodes which follow the old rules. This leads to a hard
    fork.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: While the above example is provided at several places, the two situations considered
    in the examples are not really that different. In the case of soft fork, generated
    blocks which follow either the old or the new rules will be accepted by the nodes
    which follow the old rules, while generated blocks which follow the new rules
    will be accepted only by the nodes which follow the new rules. On the other hand,
    in the case of hard fork, generated blocks which follow either the old or the
    new rules will be accepted by the nodes which follow the new rules, while generated
    blocks which follow the old rules will be accepted only by the nodes which follow
    the old rules. As such there is no essential difference between these two types
    of forks. One set of nodes accept blocks which follow either of the two rules,
    while another set of nodes accept blocks which follow only one set of rules. The
    blockchain of the nodes which follow either of the two rules will grow faster
    than the blockchain of the nodes which follow one set of rules.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: In a hard fork, blocks following the new rules are incompatible with the old
    rules. This does not say anything about whether blocks following the old rules
    are compatible with the new rules. It is possible that they are compatible as
    in the example of hard fork described above. On the other hand, it is also possible
    that the blocks following the old rule are incompatible with the new rules. This
    latter scenario means that blocks generated by one set of rules are incompatible
    with the other set of rules. Such a fork is irreconcilable.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Either a soft or a hard fork can be resolved by all the nodes adopting the new
    set of rules. The sooner this happens, the better it is for the cryptocurrency.
    If, however, one set of nodes continues to follow the old rules while the other
    nodes follow the new rules, then this leads to a split in the network and the
    blockchain. Such an eventuality can cause major disruption and lead to a cryptocurrency
    itself being bifurcated into two distinct currencies.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: If a fork results in the creation of two distinct cryptocurrencies, a peculiar
    situation may arise. The two cryptocurrencies will be supported by two blockchains.
    The two blockchains, however, will be the same up to a certain point and will
    bifurcate after that. Suppose an amount of cryptocurrency was transferred to a
    public key *pk* *U* in a transaction *T* which is present in the common part of
    the two blockchains. The transaction *T* will be considered to be valid in all
    subsequent blocks. In particular, *T* will be considered to be valid by both the
    blockchains. As a result, the entity which possesses the corresponding signing
    key *sk* *U* can now spend the amount on the two parts after the forking has taken
    place. This essentially constitutes spending the same amount on both the blockchains.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: 19.4 Value of a Cryptocurrency
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unlike fiat currencies, a cryptocurrency is not backed by any sovereign power.
    A cryptocurrency system becomes functional when a software implementing the system
    is made available to the public. This, by itself, is not sufficient to guarantee
    that the cryptocurrency will be adopted. As more and more computers become nodes
    on the P2P network by downloading and running the software, the acceptance of
    the cryptocurrency grows. Conversely, nodes join the P2P network if there is some
    value in doing so and this value arises from a broad acceptability of the cryptocurrency.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: A currency is used to pay for receiving some goods or services. Fundamentally,
    for a cryptocurrency to be used, there must be a set of entities who trust the
    system and are willing to accept payment in the currency for providing goods and
    services. As the size of such a set of entities grows, so does the acceptability
    of the cryptocurrency. Within a cryptocurrency system, the price of any particular
    goods and services in the cryptocurrency is determined by the market, just as
    in any other currency. Controlling the rate at which new amounts of the cryptocurrency
    is created (through block mining) provides a way to control inflationary pressure
    on the market.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Within the ambit of the cryptocurrency system, the relative values of different
    goods and services are determined by their availability and the demand for them
    among the holders of the cryptocurrency. As such, there is no intrinsic value
    of one unit of the cryptocurrency.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 19.5 Cryptocurrency Exchange
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Suppose an entity receives payment using a cryptocurrency in return for providing
    some goods and services. This amount of cryptocurrency can be used for further
    payments of other goods and services. It is possible that an entity possessing
    a certain amount of cryptocurrency wishes to purchase some goods or service which
    is not available from entities who are willing to accept payment using the cryptocurrency.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: To take another example, we have mentioned that the process of mining requires
    investment to increase computational power. This investment will typically be
    in terms of some fiat currency. The block reward for successful mining of a block
    is available in terms of the cryptocurrency. The miner needs to determine its
    net profit (or, loss) which is the difference between the return on block rewards
    and the investment. Unless both these quantities can be expressed in the same
    base, the difference cannot be computed.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Scenarios such as the above have motivated the emergence of cryptocurrency exchanges
    such as Coinbase or Kraken. A particular exchange may accept a few cryptocurrencies.
    On such an exchange it is possible to sell the accepted cryptocurrency and receive
    fiat currency in return. These exchanges also provide the facility for buying
    cryptocurrency. So, one may sell fiat currency and obtain cryptocurrency in return.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Suppose an entity holds a certain amount of cryptocurrency against a public
    key *pk* for which it possesses the corresponding signing key *sk*. Selling the
    cryptocurrency amounts to issuing a transaction where the spender public key is
    *pk* and the recipient public key is *pk*′ for which the receiving entity possesses
    the corresponding signing key *sk*′. Once this transaction is confirmed on the
    blockchain, the receiving entity transfers the agreed upon amount of the fiat
    currency to the seller of the cryptocurrency. Buying an amount of cryptocurrency
    in exchange for fiat currency is similar. Many major cities across the world have
    Bitcoin ATMs, which pay cash against Bitcoins. Some of these ATMs also accept
    other cryptocurrencies such as Litecoin and Ethereum. Further, there are also
    cryptocurrency debit cards like Monaco, Bitpay, CoinJar, and BCCPay.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: One of the original purposes of cryptocurrency exchanges was to facilitate the
    conversion of cryptocurreny to and from fiat currencies. Presently, however, cryptocurrency
    exchanges have developed beyond this original goal. They are gradually developing
    functionalities similar to that of regular stock exchanges. In a stock exchange,
    traders buy and sell assets or their derivatives, making profit from the price
    fluctuations of the items that are traded. Some cryptocurrency exchanges provide
    the opportunity to trade pairs. Such a pair could consist of a cryptocurrency
    and a fiat currency, or it could consist of two different cryptocurrencies. Profit
    or loss is made by the trader depending upon how the prices of the two currencies
    in a pair change relative to each other.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 19.6 Cryptocurrency Community
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A cryptocurrency community consists of all entities who participate in the activities
    related to the functioning of the cryptocurrency. At the lowermost level are the
    users who use the cryptocurrency for payments and also themselves make payments
    using the cryptocurrency. Miners are entities who are involved in the task of
    mining of blocks resulting in the creation of new amounts of the cryptocurrency.
    As discussed earlier, mining pools can be formed by entities to combine the computational
    resource required to mine a block. Finally, there are the cryptocurrency exchanges.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: All the entities in a cryptocurrency community are bound by the rules governing
    the currency. These rules are not enforced by any central agency. Rather, the
    force of the rules arise from their being accepted by all the entities in the
    system.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: 19.7 Stablecoin
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The exchange rate of a cryptocurrency can vary quite a lot. This is possibly
    due to speculative pressure. A wide variation in the exchange rate can deter people
    from adopting and using a crytocurrency. Several ideas and projects have been
    introduced to tackle this problem.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: At a basic level, the idea of stabilising the price of a cryptocurrency is to
    peg it to another asset. This later asset can be a fiat currency or some exchange-traded
    commodity, or it could even be another cryptocurrency. A cryptocurrency which
    has been designed to withstand high price volatility is called a stablecoin. A
    stablecoin could be either centralised or decentralised.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: In a centralised stablecoin, a trusted third party backs the cryptocurrency
    by performing the peg. The peg itself could be to a fiat currency which is maintained
    in some bank or in some kind of regulated financial institution which can serve
    as a depositary of the fiat currency used to peg the stablecoin. Alternatively,
    the peg could be to some exchange-traded commodity such as precious metals. The
    amount of the back-up currency or commodity used for the peg has to reflect the
    actual amount of the stablecoin in circulation. Since the value of the peg varies
    outside the space of the stablecoin, it protects the stablecoin from wild price
    fluctuations. Variation in the price of the underlying asset, however, will have
    an effect on the price of the stablecoin. Nonetheless, due to arbitrage, it is
    unlikely that the price of a stablecoin will drop below the price of the asset
    used for the peg. The main criticism of centralised stablecoin is the use of the
    trusted party which goes against the basic ethos of cryptocurrency.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: A decentralised stablecoin is pegged to another cryptocurrency. The mechanism
    is enforced through smart contracts on the blockchain itself. Since it is decentralised,
    there is no single centralised trusted party. For one thing, a decentralised stablecoin
    is more complicated to implement. Also, the variation in the prices of different
    crytocurrencies are usually correlated, so a stablecoin pegged to another cryptocurrency
    may not be sufficiently immune to wide price fluctuations.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: There are other more complicated variants of stablecoin which we do not include
    in this brief description.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: 19.8 Criticisms of Cryptocurrencies
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Cryptocurrencies are a new and potentially disruptive technology. The rapid
    growth of Bitcoin and other cryptocurrencies have also brought in a fair share
    of criticism. The main arguments against cryptocurrencies are summarised below.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '**Use in illegal transactions:** Cryptocurrencies bypass national boundaries
    and regulations. This makes them useful for making payments which are outside
    the scope of legal frameworks of nations. One such application would be payment
    for contraband substances. There are reports that such usage of Bitcoin has indeed
    been made.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '**High electricity consumption:** In a proof-of-work type cryptocurrency, the
    process of mining requires a huge amount of energy. Moreover, since the miners
    compete and there is only one winner, the energy consumption by the other miners
    is essentially wasted. This has led miners to relocate to locations with cheaper
    sources of energy. Nonetheless, considering energy itself to be a scarce resource,
    wastage of energy is undesirable.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '**Technical flaws:** There have been reports of hacks into exchanges where
    the hackers made away with a considerable sum. Even without hacking, a fork in
    a cryptocurrency can cause confusion and result in decrease of value. The burden
    of the loss for such events has fallen on individual owners of cryptocurrencies.
    Such technical issues dent user confidence.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '**Tendency towards centralisation:** A fundamental property of a cryptocurrency
    is that it is decentralised so that no single entity needs to be trusted. On the
    other hand, there has been an increasing tendency towards centralisation. The
    entry of miners with massive computational apparatus and the formation of mining
    pools have essentially shut out individuals from the process of mining. This has
    resulted in mining power being centralised in the hands of a few. Further, code
    maintenance and software updates are in practice also controlled by a small number
    of people.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '**Inadequate for retail payments:** Due to the rather long confirmation time
    of a cryptocurrency transaction, it becomes impractical to use these for making
    small purchases.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '**Not money:** In economics, money is something which should have three properties:
    a store of value, a medium of exchange and a unit of account. It has been alleged
    that cryptocurrencies have none of these properties, though some have stated that
    they at least serve as a medium of exchange.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '**Price volatility:** The exchange rates of cryptocurrencies against fiat currencies
    have varied quite a lot in the past. This has encouraged speculative purchase
    of cryptocurrencies which has sometimes led to losses for the investors. Some
    national regulatory agencies have issued investor alerts about cryptocurrencies.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '**Economic bubble/Ponzi scheme:** Several eminent personalities have mentioned
    that Bitcoin is an economic bubble which will burst sooner rather than later.
    There have also been criticisms that Bitcoin is a Ponzi scheme.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 19.9 Government Regulations
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Nations across the world have taken notice of the growth of Bitcoin and cryptocurrencies.
    The reactions have mostly been negative though the degree of hostility varies.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: The US Financial Crimes Enforcement Network (FinCEN) have established regulations
    for controlling activities related to cryptocurrencies. Miners who sell their
    generated coins are considered to be Money Service Businesses and are required
    by FinCEN to register and operate within the legal framework. Various US agencies
    have officially seized Bitcoins in the process, granting them some kind of a legal
    coginsance.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: China has been the home to some of the largest miners of Bitcoins. However,
    it is illegal to buy any real-world goods with any virtual currency. The People's
    Bank of China has prohibited Chinese financial institutions from using Bitcoins.
    Further, China has also banned trading in Bitcoin.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Due to the decentralised nature of cryptocurrencies, it is difficult to come
    up with a regulatory framework. It is possible, however, to criminalise the use
    of cryptocurrencies and shut down exchanges. This would constitute a de facto
    blanket ban of cryptocurrencies. The legal status of cryptocurrencies varies across
    nations. As of the date of this writing, an absolute ban applies in Algeria, Bolivia,
    Egypt, Iraq, Morocco, Nepal, Pakistan and United Arab Emirates. Some form of implicit
    ban applies in Bahrain, Bangladesh, China, Colombia, the Dominican Republic, Indonesia,
    Iran, Kuwait, Lesotho, Lithuania, Macau, Oman, Qatar, Saudi Arabia and Taiwan.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: There are some nations where cryptocurrency-related activities are legal. These
    include the European Union, the United States, Mexico, Japan, South Korea and
    others. There are other countries such as Canada and India where cryptocurrencies
    are not illegal, but there there is a banking ban.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: 19.10 Central Bank–issued Digital Currency
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Central banks of different countries have started exploring the idea of issuing
    digital currencies. Such a currency could be pegged to the national currency creating
    a stablecoin. The backbone for a central bank–issued digital currency would still
    be a blockchain. This blockchain would be maintained in a distributed form. However,
    only the central bank would have the authority to add new blocks and to create
    new amounts of the digital currency. This would lead to a centralised currency.
    Holders of the digital currency would have to trust the central bank. This is
    opposed to the trustless system of cryptocurrencies such as Bitcoin. Till date,
    there has been no concrete implementations of digital currencies by any central
    bank.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Digital currencies issued by central banks can make it easier to make cross-border
    payments. For example, Saudi Arabia and UAE have launched a pilot cryptocurrency
    for easier cross-border payments. The Central Bank of Singapore has launched projects
    to improve inter-bank payments and to facilitate bank users exchange currencies
    with each other. The Bank of Israel is actively considering the possibility of
    launching a digital currency.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: In 2017, a study entitled ‘Global Blockchain Benchmarking Study’ was conducted
    by the Cambridge Centre for Alternative Finance. The study found that central
    banks were very positive about adopting blockchain technology for some purpose
    within the next two years. Also, a number of central banks were enthusiastic about
    issuing their own digital currencies. The main reason for such enthusiasm is the
    potential for cost reductions in terms of transactions, settlements and reconciliation
    costs.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: From a national point of view, replacing physical cash with digital currency
    has an advantage. Cash transactions are anonymous and cannot be tracked. On the
    other hand, transactions made by digital currency are recorded on the blockchain
    and are auditable. This will lead to a widening of the tax base and possible prevention
    of untaxed transactions. On the flip side, it would also lead to a loss of privacy.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 19.11 Lightning Network
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A major problem with a proof-of-work cryptocurrency is scalability. The number
    of transactions that can be processed per second is very limited. For example,
    Bitcoin can process about seven transactions per second. Payment systems such
    as Visa can process about two thousand transactions per second. So, if Bitcoin
    is to become competitive with Visa, there must be some way of speeding up transaction
    settlements. Further, for small payments, such as for a cup of coffee, waiting
    several minutes for the relevant transaction to be confirmed is rather impractical.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: One proposed solution to this problem has been called the lightning network.
    The idea is *not* to use the blockchain to confirm each and every transaction.
    Suppose two entities transfer funds between themselves quite often. To do this,
    they create a payment channel. Such a channel is created by both of them depositing
    an agreed upon amount of cryptocurrency to a 2-out-of-2 multi-signature address.
    Such an address arises from a special type of signature scheme which requires
    the consent of both the parties for the amount to be spent. Such a payment channel
    is a transaction, but it is not immediately broadcast to the network. Once the
    payment channel is created, the two entities can issue transactions to each other
    which essentially redistribute the total amount in the payment channel between
    themselves. These transactions are scripted so that the previous transactions
    are invalidated. None of these transactions are broadcast to the network. At some
    point, both or one of the entities may wish to finalise the deal. The latest transaction
    is then broadcast to the network and confirmed on the blockchain. So, instead
    of all the micropayments that occurred on the payment channel, only one transaction
    gets confirmed on the blockchain.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: It is not feasible for every pair of entities to set up payment channels between
    themselves. Instead it is envisaged that there will be a network of such small
    micropayment channels. The two entities which wish to transact will be connected
    by an appropriate path of payment channels.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: This technology has the potential to speed up transaction processing to millions
    of transactions per second. It was initially proposed for Bitcoin. Subsequent
    work has led to development of lightning network for other cryptocurrencies. Note
    that transactions made on the payment channel are not confirmed on the blockchain.
    So, it is unlikely that large payments will be made using the lightning network.
    Rather, it is envisaged that small payments such as that of a cup of coffee will
    benefit from the speed of the lightning network.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: 19.12 Sidechain
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The concept of sidechains has been introduced to provide flexibility to a blockchain-based
    cryptocurrency. It also provides interoperability between different cryptocurrencies.
    Sidechains are also called childchains.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: To understand the notion, consider two separate cryptocurrencies – each operating
    with its independent blockchain. One of these chains is identified as the main
    chain, and the other chain is called a sidechain. Suppose it is required to transfer
    a certain amount from the main chain to the sidechain. To do this, an entity issues
    a transaction on the main chain where a payment is made to a specified address.
    This locks the amount on the main chain and the entity can no longer use this
    amount on the main chain. After a waiting period, an equivalent amount of cryptocurrency
    is released on the sidechain to the entity. This entity can now make payments
    on the sidechain. This essentially pegs the amount on the sidechain to the amount
    locked on the main chain. A similar procedure is adopted to transfer money from
    the sidechain to the mainchain. The two-way peg is enabled by a federation which
    is a group of servers acting as an intermediary between the main chain and the
    sidechain.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: Each sidechain has its own security and a breakdown of a sidechain does not
    affect the main chain. This makes sidechains a great way to experiment with new
    ideas. Further, sidechains can be launched for specific purposes such as to deal
    with transactions of only a specific type. Sidechains can also be used to enhance
    the capabilities of a blockchain. For example, the Bitcoin blockchain does not
    have support for smart contracts. There has been a sidechain to the main Bitcoin
    blockchain which allows smart contracts to be implemented.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: 19.13 Proof of Stake
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The process of mining a block is energy intensive. Miners simultaneously compete
    to create a new block. Only one miner is successful, while the efforts of the
    other miners are wasted. Further, as the difficulty of creating a new block is
    raised, miners have to put in ever increasing efforts to create a proof of work.
    So, proof-of-work-based cryptocurrencies are energy inefficient.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: Alternative approaches have been suggested to the problem of creating a new
    block. In a proof-of-work-based cryptocurrency, all nodes in the P2P network can
    participate in the block creation process. The node which first presents the required
    proof of work gets to add a new block to the blockchain. The alternative strategy
    is to allow only a subset of nodes to participate in the mining process. For example,
    entities which hold a certain amount of the cryptocurrency can only participate
    in the generation of the next block. The amount of cryptocurrency held by an entity
    is verifiable from the blockchain. The entity is considered to be a valid stakeholder
    in the cryptocurrency, and its holding of the cryptocurrency is a proof of its
    stake.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Using only the amount of cryptocurrency to determine the creation of a new block
    will lead to undesirable centralisation since only the wealthiest entity will
    get to add blocks to the blockchain. To alleviate this problem, a combination
    of age and wealth has been suggested to select the entity for adding a new block.
    Here age refers to the number of days the coins have been held.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Ouroboros is a cryptocurrency mechanism which uses proof of stake to elect an
    entity to add a new block. In this procedure, all entities which hold a certain
    minimum amount of the cryptocurrency has a chance of being elected. The probability
    of an entity being elected is proportional to the amount of cryptocurrency which
    it holds. Time is divided into slots, and in each slot an elected entity can add
    a new block to the blockchain. Simultaneously, all the stakeholders participate
    in the election of the entity which will be adding a block in the next slot. This
    election process is fairly complicated and requires a secure multiparty computation
    of random bits.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Algorand is a cryptocurrency which follows a method for block selection similar
    to proof-of-stake protocols. In particular, voting power is proportional to the
    amount of funds held. In each round, a random committee is selected which will
    decide the next block to be added to the blockchain. The selection of the committee
    is done by each entity doing a private computation and determining from the result
    whether it is part of the committee. No interaction is required at this step.
    The committee members exchange messages to determine the next block. The scheme
    introduces a notion called player replacability whereby the committee need not
    remain the same for all the messages. Theoretical basis for the scheme arises
    from secure consensus protocols for Byzantine fault tolerance.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 20
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Examples of Cryptocurrencies
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: Bitcoin was the first proposed cryptocurrency. Since then many other cryptocurrencies
    have been proposed. These are sometimes referred to as altcoins standing for alternative
    cryptocurrencies. We briefly discuss a few important cryptocurrencies.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: Our description of how cryptocurrency systems work has been based on Bitcoin.
    For the other cryptocurrencies, we briefly mention how their technology differs
    from Bitcoin.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: 20.1 Bitcoin
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Bitcoin was proposed in 2009 by an unknown person (or a group of persons) under
    the name of Satoshi Nakamoto (see Nakamoto, 2009). The first implementation was
    also released by Satoshi Nakamoto as an open source software. On 3 January 2009,
    the genesis block was mined by Satoshi. Hal Finney downloaded the Bitcoin software
    on its release date. On 12 January 2009, the first Bitcoin transaction was made
    when Hal Finney received 10 Bitcoins from Satoshi Nakamoto. During the early days,
    Nakamoto is estimated to have mined one million Bitcoins. He [¹](#fn1) disappeared
    in 2010\. Before disappearing he handed over the password of the code repository
    to Gavin Andresen. Later Andresen decided to decentralise control.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: Since its release, over the last decade, Bitcoin has grown from an obscure cryptocurrency
    to being a potentially breakthrough technology. As of January 2018, the size of
    the full Bitcoin blockchain was about 150 GB. Presently several million users
    use Bitcoin. The unit of the Bitcoin system is a Bitcoin. A Bitcoin is divisible.
    The smallest amount is 10^(−8) Bitcoin which is called a Satoshi.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: If the private key of a Bitcoin address is lost, then there is no way to spend
    the amount of Bitcoin associated with the address. In 2013, a person claimed to
    have lost 7,500 Bitcoins when he accidentally discarded a hard drive containing
    his private key. It is believed that about 20% of all Bitcoins has been lost.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: The monetory policy of Bitcoin has been described earlier. Successful mining
    of a block creates a certain amount of Bitcoins. Initially, this was 50 Bitcoins.
    After every 210,000 blocks (which takes about 4 years), the amount of Bitcoin
    created per block is halved. The total amount of Bitcoins that will ever be created
    is 21 million which will be reached around the year 2140\. The rate of supply
    of Bitcoin ensures that Bitcoin remains valuable.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: Client software to operate Bitcoin is called a wallet. These can operate in
    several ways. Full clients store the full copy of the blockchain and can perform
    the full validation checks. Due to the large size of the blockchain, it is not
    feasible to store the entire blockchain on computing devices which have limited
    memory. Lightweight clients are wallets which do not store the full blockchain,
    but interact with full clients for sending and receiving transactions. Consequently,
    lightweight wallets are easier to set up and operate on low-power, low-bandwidth
    devices such as smartphones. The trade-off is that such a wallet must trust the
    server. Wallets can as well be provided online by a third party. The credentials
    are stored with the online provider rather than on the user's device. This requires
    complete trust in the online provider. The Bitcoin Core is the best known implementation
    of the client software.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: Bitcoin has been forked several times. A hard fork on 1 August 2017 created
    a new cryptocurrency called the Bitcoin Cash. The goal of Bitcoin Cash was to
    allow larger block size so that the rate of transaction processing could be increased.
    Another hard fork created the Bitcoin Gold on 24 October 2017.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: Decentralisation is a cherished goal of Bitcoin. There has been, however, a
    tendency towards centralisation. One aspect of this is the creation of mining
    pools. The mining pools together contribute a large fraction of the computational
    power of the network. In 2013, about 75% of the hash rate of the network was controlled
    by six mining pools. More alarmingly, in 2014, the mining pool Ghash.io obtained
    51% of the hash rate giving them the power to launch a 51% attack (see Section
    18.13). Since then, the pool has voluntarily capped their hash rate at 39.99%
    for the benefit of the whole network. Other parts of the Bitcoin ecosystem, such
    as the maintenance of the software, are also controlled by a small set of entities.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: Bitcoin supposedly provides a measure of anonymity. This is due to the fact
    that the funds are associated with addresses, where the owners of the addresses
    are not required to be identified. Analysis of the transactions available on the
    blockchain, however, indicates holding patterns. Further, cryptocurrency exchanges
    can be required by law to collect personal information. Technically speaking,
    all Bitcoins are equivalent. The blockchain, on the other hand, records the history
    of each Bitcoin. Some users may refuse to accept Bitcoins coming from controversial
    transactions.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: A transaction in a Bitcoin is a description of transfer of coins from input
    to output addresses which is signed using the signing keys of the input addresses.
    While this is a very basic functionality, Bitcoin also provides for transactions
    to describe somewhat more complex conditions. For example, it is possible to create
    a multi-signature transaction, i.e. one which is signed by several entities.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: 20.2 Ethereum and Smart Contracts
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ethereum brought in a new innovation to the blockchain technology. At a bare
    bones level, a blockchain is a linked chain of blocks, where each block contains
    a list of transactions. A transaction essentially transfers cryptocurrency from
    a set of input addresses to a set of output addresses. Transactions are signed
    using the signing key of the sender. While Bitcoin transactions describe more
    general conditions, it does not go all the way.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: The pertinent question that is raised is how much more complex scenarios can
    be handled? For example, one may wish to describe a contract between two parties.
    Such a contract could be a simple thing like a small loan or it could even be
    the sale of a car. Further, the execution of a contract could depend on an event
    in the future such as the price of some share in a stock exchange. The main innovation
    of Ethereum is the ability to handle all such scenarios and more.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: To understand the capability of Ethereum, we need to step back for a moment
    and consider what it means to compute something. This was an important question
    in the early decades of the twentieth century. An answer was provided by Alan
    Turing who proposed a very simple model of computation which is now called a Turing
    machine. Turing also introduced the notion of universality and proposed the construction
    of a universal Turing machine which is capable of simulating any Turing machine.
    The intuitive notion of computation by itself is hard to define and so it cannot
    be formally proved that Turing machines can indeed compute all that may be intuitively
    considered to be computable. The Church–Turing thesis is the hypothesis that this
    is indeed the case, i.e. our intuitive notion of computation is exactly captured
    by a universal Turing machine.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: Turing machines are not the only possible models of computation. Alternative
    systems such as the lambda calculus and recursive functions have been proposed.
    All of these systems have been shown to be equivalent. In particular, this means,
    for example, that the lambda calculus system of rules can be used to simulate
    a universal Turing machine. More generally, a language consisting of rules to
    manipulate data is said to be Turing complete if it can be used to simulate a
    universal Turing machine and by extension any Turing machine.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: In view of the above, a theoretical goal for designing a language which can
    describe complex scenarios is to ensure that the language is Turing complete.
    Ethereum provides such a language (subject to some practical limitations). This
    allows Ethereum to describe contracts, and more generally, to describe autonomous
    agents of almost arbitrary complexity.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: Before describing Ethereum, let us consider the Bitcoin blockchain once more.
    A useful view of what happens is that of a state transition system. At any point
    of time, among other things, the blockchain provides a record of all the Bitcoins
    that have been generated so far. This information can be summarised as a state
    where the state is a list of addresses and the amount of Bitcoins held by each
    address. A block consists of a list of transactions which essentially transfers
    Bitcoins from one set of addresses to another set of addresses. After the creation
    of a new block, we obtain a new state. So, the processing of a list of transactions
    by the creation of a new block can be considered to be transition from one state
    to another.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum starts off with such a state transition view of the blockchain. States
    in Ethereum, however, are more complex than those of Bitcoin.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic object in Ethereum is an ‘account’ which consists of four items:
    a nonce; the account''s present Ether balance (Ether is a unit of currency in
    Ethereum); a program to describe a contract (which is optional); and the account''s
    storage. Each account has an address. Accounts are of two types, namely, user
    (or externally owned) account and contract account. A user account does not have
    any program, while contract accounts have associated programs. Each account has
    an address which is computed by applying a hash function to the address of the
    creator of the account along with the relevant nonce of the creator account.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: Interaction between accounts is enabled by passing messages from one account
    to another. Messages can be created by both user and contract accounts and can
    contain data. Further, if the recipient of a message is a contract account, then
    there is an option to return a response. In Ethereum, the term transaction is
    used to denote a signed message sent from a user account. The sending of a message
    from any account increments the nonce of the account. For a contract account,
    every time a message is received, the code is activated. This allows the contract
    account to read and write its internal storage and send other messages or even
    create new contracts.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: An Ethereum state is a snapshot of the set of accounts. A state transition takes
    place by the processing of a list of messages. Each message alters the values
    of the internal variables of one or more accounts. This alteration may be due
    to the execution of the code inside a contract account. Processing of a message
    may also lead to the creation of new accounts. So, a snapshot of the set of accounts
    after processing of the messages is the new state of the system.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: Let us now see how this state transition view is mapped to a blockchain. A block
    in the Ethereum blockchain contains a copy of the messages/transactions that have
    been processed as well as the most recent state. Along with this, it stores two
    other values, the block number and the difficulty. Blocks are chained together
    through a proof-of-work style mechanism using a hash function. This part is the
    same as the basic blockchain technology. Validating a block consists of several
    actions such as verifying timestamp, reference to the previous block, difficulty
    and other checks. One important check is to ensure that applying the messages
    in the present block to the state recorded in the previous block leads to the
    state recorded in the present block. Note that this validation step requires applying
    messages to the individual accounts which for contract accounts means running
    the program embedded in such accounts.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: The execution of contracts in Ethereum can also be initiated by external information.
    For example, one may describe a contract account to transfer a certain amount
    of money if the price of some share in a stock exchange reaches a certain value.
    Once such a contract is released to the network, mining nodes will check the relevant
    stock ticker and execute the code at the appropriate time in the future. It will
    not be required for the original creator of the account to initiate any further
    action. Such a provision can greatly facilitate the generation and execution of
    financial derivatives.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum operates in a P2P network in a manner similar to that of other distributed
    permissionless cryptocurrencies. Nodes introduce messages and transactions into
    the network. Miners collect together a set of such messages/transactions and compete
    with each other to create the next block to be inserted into the blockchain. Newly
    created blocks are propagated through the P2P network. Nodes maintain their private
    copies of the blockchain and follow the consensus algorithm of Ethereum for updating
    this copy. Before adding a new block to their private copies, nodes have to validate
    the block. Among other things, this constitutes running the programs for the relevant
    contract accounts. So, the programs for each contract account are executed on
    all the nodes of the network. While this can be considered to be a wastage of
    computational power, such independent executions of a contract program by the
    nodes essentially ensures that no trusted third party is required in the entire
    set-up.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum was proposed in late 2013 by Vitalik Buterin and the system started
    on 30 July 2015\. The currency of Ethereum is denoted as Ether. The system started
    with 72 million premined coins. Ethereum provides a monetory policy for the generation
    of Ether and a sophisticated incentive policy for execution of contracts so as
    to reimburse the cost of the miners who run the code for the contracts. Over the
    years, Ethereum has suffered its own problems such as the exploitation of a software
    flaw in a contract to steal the equivalent of about $50 million Ether. There have
    also been disputes leading to a hard fork of the blockchain.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: 20.3 Ripple and Payment Systems
  id: totrans-287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the present set-up, transferring funds across banks and across national boundaries
    is a difficult and time-consuming procedure. It can take up to several days to
    transfer funds and involve substantial commissions to the intermediaries involved
    in the process. A major innovation of Ripple is to harness the technology of distributed
    systems to provide an efficient and low-cost solution to the problem.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: Ripple is a payment system. Using Ripple, it is possible to transfer almost
    any kind of financial token. Such tokens could be fiat currencies, cryptocurrencies,
    frequent flier miles, etc. Ripple also provides an in-built cryptocurrency called
    XRP. A total of 100 billion XRP was created at the beginning by Ripple Lab, the
    creator of Ripple. There is no provision for creating any more XRP. Ripple Labs
    have slowly released XRP into the system.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: The Ripple technology is *not* based on blockchain. So, there is no concept
    of mining to create new currency. Ripple provides a kind of semi-permissioned
    and semi-decentralised system. Even though XRP was created by Ripple Labs and
    presently 55% is still held by them, it is arguably possible for the Ripple network
    to operate even if Ripple Labs shuts down.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: Users of the Ripple system hold accounts. Transactions consist of payments from
    a set of accounts to another set of accounts. Users can directly make payments
    to users they trust. Alternatively, the Ripple network attempts to build a line
    of trust between two users where two consecutive parties in the line have mutual
    trust. One of the major roles of XRP is to serve as the main liquidity holding
    in the network. An entity can convert its preferred token to XRP, the payment
    is made in XRP and at the receiving end, XRP is converted into the preferred token
    of the recipient. Another role of XRP is to secure the network against certain
    kinds of overloading attacks. Each transaction requires burning up a small amount
    of XRP. The amount by itself is so small that for a transaction it is an insignificant
    cost. However, if an entity tries to overload the system with a huge number of
    transactions, then the cost in XRP to such an entity will also be huge which serves
    as a deterrent.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: A ledger in Ripple is a record of the amount of currency in each user's account.
    Ripple follows a distributed system. Nodes in the network are servers running
    the Ripple server software. Banks and financial institutions join the Ripple network
    by becoming a node in the network. Each server maintains a copy of the ledger.
    The ledger is updated every few seconds using a consensus mechanism. The last-closed
    ledger is the most recent state of the ledger that has been ratified by the consensus
    mechanism. The open ledger is the one which is currently being confirmed. Once
    confirmed this becomes the last closed ledger. The history of all payments is
    available in the list of states of the ledgers that have been confirmed till date.
    For the purposes of approving payments, it is not required to keep the entire
    ledger history, though most nodes still do so.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: Ledger updation is done by the nodes following a consensus mechanism. Each node
    maintains a list of unique node list (UNL) which it consults. The set of UNL is
    not the set of all nodes in the network. It is sufficient that the node should
    trust the nodes in UNL as a whole. For this, individual trust in each node in
    UNL is not required. For example, if the UNL of a node includes a bank in the
    US and a bank in China, the node may assume that two such banks are unlikely to
    collude even if it may not trust the individual banks.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: Any server can broadcast transactions to be included in the next updation of
    the ledger. All the servers attempt to include every valid transaction when a
    new consensus round starts. The consensus protocol proceeds in several rounds.
    To start the protocol, each server takes all valid transactions it has received
    prior to the beginning of the consensus protocol which have not yet been applied.
    The server makes these transactions public as a candidate list of transactions.
    Each server then takes the union of the candidate sets of all the nodes in its
    UNL and votes on the transactions. A server decides to proceed with a transaction
    in the next round if the transaction receives a certain minimum percentage of
    approving votes. For the final round of consensus, a server decides to accept
    a transaction if the transaction is approved by at least 80% of the server's UNL.
    Finally, the server applies the accepted transactions to its copy of the open
    ledger, and the updated ledger becomes the last closed ledger.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: There are three crucial properties of the consensus protocol, namely correctness,
    agreement and termination. Correctness is shown by arguing that if the number
    of Byzantine nodes in the network is below a certain level, then no invalid transaction
    will be confirmed by the consensus protocol. Agreement refers to the fact that
    if the nodes start out with the same state of the ledger, then after the execution
    of the consensus protocol, all the nodes again have the same state of the ledger.
    Finally, it can be argued that the consensus protocol terminates and each valid
    transaction gets applied to the ledger within a finite amount of time. In practice,
    Ripple network is reported to be able to handle about 1,500 transactions per second,
    making it much faster than blockchain-based technologies such as Bitcoin or Ethereum.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: ¹Since the identity of Satoshi Nakamoto is unknown, use of the pronoun ‘he’
    is possibly inaccurate. We use it only for the sake of convenience.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 21
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Applications of Blockchain
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: The underlying technology behind Bitcoin and most other cryptocurrencies is
    blockchain. In this context, the blockchain is permissionless, trustless and distributed.
    The basic technology of blockchain, however, is amenable to other applications
    including permissioned and trusted scenarios. In this chapter, we briefly describe
    a few such applications.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: Since a blockchain essentially implements a ledger, any application which utilises
    a ledger can potentially benefit from the use of blockchain. Depending on the
    access control mechanism of the ledger, it is possible to realise an appropriate
    blockchain. The fundamental idea of implementing a ledger by a blockchain opens
    up immense potential for the blockchain technology.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: 21.1 Fintech Applications
  id: totrans-301
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have already discussed Ripple which provides a solution for making international
    payments in an efficient and low cost manner. Ripple, however, does not use a
    blockchain. We mention a few other financial technology solutions which have already
    been proposed. These have features which can also be used for making international
    payments.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: One of the leading investment banks, JPMorgan Chase & Co., has launched a product
    called Quorum, which is a permissioned blockchain. The design of Quorum is based
    upon Ethereum with some differences. The basic difference, of course, is that
    Quorum is a permissioned blockchain, meaning that not everybody can join the network.
    The nodes of the network are people who have been verified and authenticated by
    the network authority. A major consideration for banks is the privacy of transactions.
    Quorum provides support for both public and private transactions. The innovation
    is to support private transactions without breaking the blockchain. Another more
    technical difference is that unlike Ethereum, the consensus mechanism in Quorum
    uses voting.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: A recently formed company called R3 leads an industry consortium. R3 has launched
    a product called Corda which is a distributed ledger solution geared specifically
    towards the financial world. Corda does not use a blockchain. In this aspect,
    it is similar to Ripple, though the background technology for the two systems
    is different. The goal of Corda is to provide a platform with some basic services
    so that other services can be built on top of the platform in a manner which is
    compatible between the network participants.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: IBM Blockchain is a blockchain-based solution for the financial industry. This
    includes banking and in particular cross-border payments. MasterCard Blockchain
    is another solution for the payment industry.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: As a response to various distributed ledger technologies (blockchain or otherwise),
    the previous global leader in cross-border payments, SWIFT, has launched a new
    product called the Global Payment Initiative (GPI). This does not use distributed
    ledger and is instead built upon the existing SWIFT technology. In the coming
    years, it remains to be seen how the hugely lucrative market of international
    payment plays out.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: 21.2 Logistics Management
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Traditionally logistics requires intermediaries whose role is to verify, maintain
    and forward records. The presence of such intermediaries pushes up the cost and
    the delay in the processing of the paperwork. A prime example is the shipping
    industry. The processing of paperwork for international container shipping can
    take many days, resulting in major delays. The distributed ledger technology based
    upon blockchain has the potential to cut through the dense formalities and significantly
    speed up the entire logistics processing. IBM and Maersk have teamed up to develop
    a blockchain solution for the shipping industry. As competition, five ocean shipping
    lines and four terminal operators have teamed up to form the Global Shipping Business
    Network (GSBN) which will provide blockchain-based solution to the logistics management
    problem in the shipping industry.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: 21.3 Supply Chain Management
  id: totrans-309
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Today, leading companies run supply chain management and enterprise resource
    planning (ERP) software for managing their supply chains. These software allow
    products to be tracked from their origins to the final form. There are, however,
    periods when companies have limited visibilities of the products. Such scenarios
    arise due to gaps between different systems within a company as well as across
    companies. Existing technology provides mechanism for bridging such gaps, but,
    due to lack of complete synchronisation, it is possible that the same product
    appears to be at two places at the same time. This violates a basic requirement
    of inventory management.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: Over the years, global supply chains have become part of a huge ecosystem rather
    than being part of a vertically integrated company. Also, supply chains have become
    more dynamic with shorter product life cycles. These issues have accentuated the
    gaps in the existing software solutions for supply chain management.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: It is in this context that blockchain-based distributed ledger technology has
    the potential to deliver substantial benefits. The blockchain is to be used as
    a ledger for transactions which record movement of products. For one thing, this
    will prevent an item appearing simultaneously at two places. The visibility of
    all the parts and the entire product will be clear from the blockchain. Sharing
    the same blockchain with all entities of the supply chain ecosystem will eliminate
    the intercompany gaps. Further, a blockchain will provide immediate proof about
    how various goods were obtained and their compliance with necessary regulations.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: BHP, the largest mining company in the world, has announced that it will use
    blockchain to record movements of wellbore rock and fluid samples and to better
    secure the real-time data that are generated during delivery. IBM has also announced
    a blockchain-based solution for the supply chain industry.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: 21.4 Governance
  id: totrans-314
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A government is duty-bound to provide certain services to the citizens. Such
    services are to be provided in a transparent and accountable manner and at the
    same time ensure the enforcement of any possible service delivery guarantee. Examples
    of government services would include access to property records, birth/death/marriage
    registration, delivery of subsidies and access to information. All these require
    maintaining some kind of records by various governmental agencies. A typical bureaucratic
    process often delays the processing and access to information that may be required
    by citizens. It is in this aspect that blockchain-based digital technology provides
    very promising resolution. At a very broad level, uploading documents to the blockchain
    ensures their integrity, persistence and availability.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: While the idea of blockchain-based e-governance has a great deal of potential,
    till date there have been no significant implementations. One possible reason
    is that moving to a blockchain-based solution will be a huge technological step
    for both governmental offices and the citizens. There has to be significant preparatory
    work in the society before such a move can take place. Another reason is possible
    lack of interest in such a move from the government itself. While governments
    over the world are interested in cutting costs, unless forced they are unwilling
    to take steps which make governance accountable and transparent. Blockchain technology
    will indeed cut costs, but it will also at the same time introduce accountability
    and transparency.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
