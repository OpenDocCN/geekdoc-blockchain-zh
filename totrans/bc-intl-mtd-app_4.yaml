- en: © The Author(s), under exclusive license to Springer Nature Singapore Pte Ltd. 2021Z.
    Zheng et al. (eds.)Blockchain Intelligence[https://doi.org/10.1007/978-981-16-0127-9_4](https://doi.org/10.1007/978-981-16-0127-9_4)
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: ©作者（们），在Springer Nature新加坡私人有限公司独家授权下2021年Z. Zheng等（编辑）区块链智能[https://doi.org/10.1007/978-981-16-0127-9_4](https://doi.org/10.1007/978-981-16-0127-9_4)
- en: 4. Intelligence-Driven Optimization of Smart Contracts
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4. 智能驱动的智能合约优化
- en: 'Yuan Huang^([1](#Aff4)), Queping Kong^([1](#Aff4) [ ](#ContactOfAuthor2)),
    Nan Jia^([2](#Aff5) [ ](#ContactOfAuthor3)), Xiangping Chen^([3](#Aff6) [ ](#ContactOfAuthor4))
    and Zibin Zheng^([4](#Aff7), [5](#Aff8) [ ](#ContactOfAuthor5))(1)National Engineering
    Research Center of Digital Life, School of Data and Computer Science, Sun Yat-sen
    University, Guangzhou, China(2)School of Management Science and Engineering, Hebei
    GEO University, Shijiazhuang, China(3)Guangdong Key Laboratory for Big Data Analysis
    and Simulation of Public Opinion, School of Communication and Design, Sun Yat-sen
    University, Guangzhou, China(4)Sun Yat-sen University, Guangzhou, China(5)National
    Engineering Research Center of Digital Life, Sun Yat-sen University, Guangzhou,
    ChinaQueping KongEmail: [kongqp@mail2.sysu.edu.cn](mailto:kongqp@mail2.sysu.edu.cn)Nan JiaEmail:
    [jianan_0101@163.com](mailto:jianan_0101@163.com)Xiangping Chen (Corresponding
    author)Email: [chenxp8@mail.sysu.edu.cn](mailto:chenxp8@mail.sysu.edu.cn)Zibin ZhengEmail:
    [zhzibin@mail.sysu.edu.cn](mailto:zhzibin@mail.sysu.edu.cn)'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '黄元^([1](#Aff4))，孔曲平^([1](#Aff4) [ ](#ContactOfAuthor2))，贾南^([2](#Aff5) [ ](#ContactOfAuthor3))，陈祥平^([3](#Aff6)
    [ ](#ContactOfAuthor4))和郑子宾^([4](#Aff7), [5](#Aff8) [ ](#ContactOfAuthor5))（1）数字生活国家工程研究中心，中山大学数据科学与计算机学院，广州，中国（2）河北地质大学管理与工程学院，石家庄，中国（3）中山大学舆论大数据分析与仿真广东省重点实验室，广州，中国（4）中山大学，广州，中国（5）数字生活国家工程研究中心，中山大学，广州，中国曲平孔Email:
    [kongqp@mail2.sysu.edu.cn](mailto:kongqp@mail2.sysu.edu.cn)贾南Email: [jianan_0101@163.com](mailto:jianan_0101@163.com)陈祥平（通讯作者）Email:
    [chenxp8@mail.sysu.edu.cn](mailto:chenxp8@mail.sysu.edu.cn)郑子宾Email: [zhzibin@mail.sysu.edu.cn](mailto:zhzibin@mail.sysu.edu.cn)'
- en: Abstract
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we present an overview on how smart contracts could be optimized
    by intelligence-driven approaches. We empirically study the repetitiveness of
    smart contracts via cluster analysis and try to extract differentiated codes from
    the similar contracts. Differentiated codes are defined as the source codes except
    the repeated ones in two similar smart contracts, usually illustrating how a software
    feature is implemented or a programming issue is solved. Then, a differentiated
    code might be used to guide the update of a smart contract in its next version.
    Finally, we apply syntax and semantic similarities to discover its similar smart
    contracts from more than 120,000 smart contracts, and recommend the differentiated
    codes to the target smart contracts.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们概述了如何通过智能驱动的方法来优化智能合约。我们通过聚类分析实证研究了智能合约的重复性，并尝试从相似的合约中提取不同化的代码。不同化代码被定义为在两个相似的智能合约中的重复之外的源代码，通常说明软件特性是如何实现的或编程问题是如何解决的。然后，这些不同化代码可能被用来指导智能合约下一个版本的更新。最后，我们应用语法和语义相似性从超过120,000个智能合约中发现其相似的智能合约，并向目标智能合约推荐不同化代码。
- en: 4.1 Overview
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1 概述
- en: 'Blockchain serves as a public ledger and transactions stored in blockchain
    are nearly impossible to tamper (Nakamoto [2009](#CR21)). Its purpose is to solve
    the trust problems of both sides of the transaction in a decentralized environment,
    which can greatly improve transaction efficiency and reduce costs (Dinh et al.
    [2018](#CR9); Zheng et al. [2018](#CR32)). Blockchain technology allows to establish
    contracts using cryptography and to replace third parties that have been necessary
    to establish trust in the past (Zheng et al. [2017](#CR33)). The smart contract
    is a computerized transaction protocol that executes the terms of a contract (Nick
    [2008](#CR22)). With the increasing popularity of blockchain technology, smart
    contracts are applied in various domains (Christidis and Devetsikiotis [2016](#CR7);
    Juels et al. [2016](#CR17); Norta [2015](#CR23)): from finance, game to healthcare.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '区块链作为公共账本，存储在区块链中的交易几乎不可能被篡改（Nakamoto [2009](#CR21)）。其目的是解决分布式环境中双方交易的信任问题，这可以大大提高交易效率并降低成本（Dinh
    et al. [2018](#CR9)；Zheng et al. [2018](#CR32)）。区块链技术允许使用密码学建立合同，并替代过去建立信任所必需的第三方（Zheng
    et al. [2017](#CR33)）。智能合约是一种计算机化的交易协议，执行合同的条款（Nick [2008](#CR22)）。随着区块链技术的日益普及，智能合约已应用于各个领域（Christidis
    and Devetsikiotis [2016](#CR7)；Juels et al. [2016](#CR17)；Norta [2015](#CR23)):
    从金融、游戏到医疗保健。'
- en: The difficulty of implementing smart contracts lies in how to express and write
    legal contracts through programming languages. Low-quality smart contracts may
    lead to unclear definitions of rights and obligations and become vulnerable. Loi
    et al. discovered that 8833 out of 19,366 existing Ethereum contracts are vulnerable
    (Luu et al. [2016](#CR19)). Smart contracts are executed as transactions on the
    blockchain; the input, output, and contract states of the network are all visible.
    As a result, smart contracts with security vulnerabilities may cause financial
    losses. Famous attacks including selfish mining attack (Sapirshtein et al. [2017](#CR28))
    and DAO attack (Norta [2015](#CR23)) have caused loss of million dollars. Some
    researchers noticed the difficulties in implementing smart contracts and proposed
    to specify and model smart contract before implementation (Frantz and Nowostawski
    [2016](#CR10); He et al. [2018](#CR13)). In this chapter, we observe that most
    of the smart contracts on the Ethereum are highly similar, as they share lots
    of repetitive source code. Meanwhile, we notice that “personalized code” exists
    between the similar smart contracts, referred to as differentiated code. Differentiated
    code is defined as the source code except the repeated code in two similar contract
    smarts, which usually illustrates how a software feature is implemented or a programming
    issue is solved (Huang et al. [2017](#CR14)).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 实现智能合约的难度在于如何通过编程语言表达和编写法律合同。低质量的智能合约可能导致权利和义务的定义不明确，并变得脆弱。Loi等人发现，现有的19,366个以太坊合约中有8833个是脆弱的（Luu
    et al. [2016](#CR19)）。智能合约作为区块链上的交易执行；网络的输入、输出和合约状态都是可见的。因此，具有安全漏洞的智能合约可能造成经济损失。包括自私挖矿攻击（Sapirshtein
    et al. [2017](#CR28)）和DAO攻击（Norta [2015](#CR23)）在内的著名攻击造成了数百万美元的损失。一些研究人员注意到了实现智能合约的困难，并建议在实现之前指定和建模智能合约（Frantz
    and Nowostawski [2016](#CR10)；He et al. [2018](#CR13)）。在本章中，我们发现以太坊上的大多数智能合约非常相似，因为它们有很多重复的源代码。同时，我们注意到在类似智能合约之间存在“个性化代码”，称为差异化代码。差异化代码被定义为两个类似智能合约中重复代码之外的源代码，通常说明软件功能是如何实现的或编程问题是如何解决的（Huang
    et al. [2017](#CR14)）。
- en: Therefore, the differential codes in similar contracts can be used as candidate
    implementations for other smart contract updates. The following example shows
    a smart contract *C* [1] using throw in its initial version, which may cause additional
    gas consumption when exception throws. By searching its similar smart contract,
    we can observe that smart contract *C* [2] uses an alternative function revert(
    ) instead of throw, which can return the remaining gas to the user when exception
    throws.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，类似合同中的微分代码可以作为其他智能合约更新的候选实现。以下示例展示了智能合约*C* [1]在其初始版本中使用throw，这可能会在异常抛出时导致额外的气体消耗。通过搜索其类似的智能合约，我们可以观察到智能合约*C*
    [2]使用了替代函数revert( )而不是throw，当异常抛出时可以将剩余的气体返回给用户。
- en: Therefore, the differentiated code revert( ) (i.e., red font in contract *C*
    [2]) can be used to support the update of contract *C* [1] when releasing a new
    version (Fig. [4.1](#Fig1)).![../images/506524_1_En_4_Chapter/506524_1_En_4_Fig1_HTML.png](../images/506524_1_En_4_Chapter/506524_1_En_4_Fig1_HTML.png)
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，区分化的代码 revert( )（即合同*C* [2]中的红色字体）可以在发布新版本时用来支持合同*C* [1]的更新（图 [4.1](#Fig1)）。![../images/506524_1_En_4_Chapter/506524_1_En_4_Fig1_HTML.png](../images/506524_1_En_4_Chapter/506524_1_En_4_Fig1_HTML.png)
- en: Fig. 4.1
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1
- en: Overall framework of the smart contract update supporting
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约更新支持的整体框架
- en: In this chapter, we propose to an approach that use differentiated code to support
    the smart contract update. For a target smart contract, we firstly apply code
    syntactic and semantic similarities to discover the similar smart contracts from
    more than 120,000 smart contracts. Then, we compare the source code of the target
    smart contracts and the similar smart contracts to extract the differentiated
    code. At last, we recommend the differentiated code to the target smart contract,
    which might be used to support the update of the target smart contract. The case
    study shows that the differentiated code we recommended can exactly match the
    code change in evolving versions of 42 smart contracts. Encouraging experimental
    results demonstrated that differentiated codes can effectively support smart contract
    updates.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们提出了一种使用区分化代码支持智能合约更新的方法。对于一个目标智能合约，我们首先应用代码语法和语义相似性来发现与超过 120,000 个智能合约相似的智能合约。然后，我们将目标智能合约的源代码与相似智能合约的源代码进行比较，以提取区分化代码。最后，我们推荐将区分化代码推荐给目标智能合约，这可能会用来支持目标智能合约的更新。案例研究显示我们推荐的区分化代码可以精确匹配
    42 个智能合约在演进版本中的代码更改。鼓舞人心的实验结果表明，区分化代码可以有效地支持智能合约更新。
- en: The rest of this chapter is organized as follows. Section [4.2](#Sec2) describes
    the main method of smart contracts syntax and semantic similarities analysis.
    Section [4.3](#Sec6) presents the overall framework, while Section [4.4](#Sec9)
    provides case study. And Section [4.5](#Sec18) discusses treats to validity and
    related work for future studies.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的其余部分如下组织。第 [4.2](#Sec2) 节描述了智能合约语法和语义相似性分析的主要方法。第 [4.3](#Sec6) 节介绍了整体框架，而第
    [4.4](#Sec9) 节提供案例研究。第 [4.5](#Sec18) 节讨论了未来研究的有效性和相关工作。
- en: 4.2 Smart Contracts Similarity Analysis
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2 智能合约相似性分析
- en: 4.2.1 Syntax Similarity Analysis
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.1 语法相似性分析
- en: In fact, detecting the similar smart contracts is a code clone detection problem
    (Jiang et al. [2018](#CR16); Yue et al. [2018](#CR31)). There are many ways to
    detect code clone. One of the representative methods is to compare the similarity
    of abstract syntax trees of the source code of smart contracts, namely, tree-based
    method (Baxter et al. [1998](#CR3)). This method firstly calculates the subtrees’
    similarity, and then calculates entire trees’ similarity. The tree-based method
    can achieve an exponential time complexity (Roy et al. [2009](#CR27)), which is
    not suitable for using in our scenario.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，检测相似智能合约是一个代码克隆检测问题（Jiang 等 [2018](#CR16); Yue 等 [2018](#CR31))。检测代码克隆有很多方法。其中一种代表方法是比较智能合约源代码的抽象语法树相似性，即基于树的方法（Baxter
    等 [1998](#CR3))。这种方法首先计算子树相似性，然后计算整个树相似性。基于树的方法可以实现指数时间复杂度（Roy 等 [2009](#CR27))，这不适合用于我们场景。
- en: The second representative method to detect code clone is based on the token
    sequences of code fragments, which is called token-based method (Wettel and Marinescu
    [2005](#CR29)). This method firstly generates token for each code line, and then
    calculates the syntax similarity by finding a longest matching token sequence
    of two code fragments. The token-based method achieves a time complexity of *O*(*n* × *m*)
    (Wettel and Marinescu [2005](#CR29)), and we apply it to calculate the code syntax
    similarity in this chapter.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 检测代码克隆的第二种代表方法是基于代码片段的令牌序列，称为基于令牌的方法（Wettel 和 Marinescu [2005](#CR29))。这种方法首先为每行代码生成令牌，然后通过找到两个代码片段的最长匹配令牌序列来计算语法相似性。基于令牌的方法达到时间复杂度
    *O*(*n* × *m*)（Wettel 和 Marinescu [2005](#CR29))，我们将其应用于本章计算代码语法相似性。
- en: Code Tokenizing
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 代码分词
- en: 'To obtain code syntax structure of a smart contract, we should first identify
    the syntax of each code line containing in the smart contract. In this chapter,
    code syntax is subdivided into 90 types (e.g., *MappingExpression*, *ModifierDeclaration*,
    *IfStatement*, *ForStatement*, *AssignmentExpression*, *ReturnStatement*). Our
    algorithm parses abstract syntax tree to obtain the syntactic types of each code
    line. It is worth noting that a single code line may contain multiple syntax types.
    For example, an if code line “if( _to == address( this) ) ” contains three syntax
    types: *IfStatement*, *BinaryExpression*, and *CallExpression*.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得智能合约的代码语法结构，我们首先应该识别出智能合约中每行代码的语法。在本章中，代码语法被细分为90种类型（例如，*MappingExpression*、*ModifierDeclaration*、*IfStatement*、*ForStatement*、*AssignmentExpression*、*ReturnStatement*）。我们的算法解析抽象语法树以获得每行代码的语法类型。值得注意的是，单行代码可能包含多种语法类型。例如，一个if代码行“if(
    _to == address( this) )”包含三种语法类型：*IfStatement*、*BinaryExpression*和*CallExpression*。
- en: Hash Sequence
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 散列序列
- en: For the source code from two smart contracts, we use tokens to mark each line
    of code, and each token type corresponds to a unique hash value (10 digits). If
    the code line contains multiple types of tokens, the hash value corresponding
    to the token of the code line is added to generate a new unique hash value. After
    this, each line of code is mapped to a hash value, so the source code of the smart
    contract corresponds to a hash sequence. Then, we use the hash sequence of the
    source code of the two smart contracts to calculate their syntactic similarity.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对于两个智能合约的源代码，我们使用代币标记每一行代码，每种代币类型对应一个唯一的散列值（10位数字）。如果代码行包含多种类型的代币，则该代码行的代币对应的散列值相加以生成新的唯一散列值。此后，每行代码都映射到一个散列值，因此智能合约的源代码对应一个散列序列。然后，我们使用两个智能合约的源代码散列序列来计算它们的语法相似度。
- en: Matching Algorithm
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配算法
- en: For two hash sequences from a pair of smart contracts, our goal is to find the
    longest matching subsequence from these two hash sequences, and use the longest
    matching subsequence to measure their syntactic similarity. We employ the algorithm
    proposed by Wettel and Marinescu ([2005](#CR29)) to look for the longest matching
    subsequence, while the difference is that we use abstract syntax tree to parse
    the code elements for obtaining the tokenization in this chapter, and Wettel et
    al. use regular expressions to identify the code elements.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一对智能合约的两个散列序列，我们的目标是找到这两个散列序列中最长的匹配子序列，并使用最长的匹配子序列来衡量它们的语法相似度。我们采用Wettel和Marinescu（[2005](#CR29)）提出的方法寻找最长的匹配子序列，不同之处在于我们在此章节中使用抽象语法树解析代码元素以获得本章的代币化，而Wettel等人使用正则表达式来识别代码元素。
- en: As shown in Algorithm [4.1](#FPar1), the matching algorithm consists of four
    steps. Firstly, we compare every hash in hash sequence 1 with every hash in hash
    sequence 2\. The result is stored in matrix *M*, and every matrix cell *M*[*i*,*j*]
    stores the result of the comparison between the relevant hash *i* and the relevant
    hash *j*. *M*[*i*,*j*] = 1 means the relevant hashes are matched (i.e., identical).
    Secondly, we look for the matched cells from upper left corner of the matrix.
    From the first matched cell, we will further expand to the first unmatched cell
    in the main diagonal direction. Consecutively matched cells form a subsequence.
    We continue to find all the subsequences in the matrix. Third, we check the interval
    between any two subsequences in the matrix. If the gap is smaller than a certain
    threshold *η*, we link these two subsequences to form a longer subsequence. Repeat
    the gap check in the same way until all the subsequences are traversed, and then
    we can finally find the longest subsequence. Fourth, dividing the length of the
    longest subsequence by the maximum length of hash sequence 1 and hash sequence
    2 is the syntactic similarity. It is worth noting that because the matrix is symmetric,
    we only need to use half of the matrix to find the longest subsequence.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如算法[4.1](#FPar1)所示，匹配算法由四个步骤组成。首先，我们将序列1中的每个散列与序列2中的每个散列进行比较。结果存储在矩阵*M*中，矩阵中的每个单元格*M*[*i*,*j*]存储相关散列*i*与相关散列*j*之间比较的结果。*M*[*i*,*j*]
    = 1意味着相关散列匹配（即，相同）。其次，我们从矩阵的左上角寻找匹配的单元格。从第一个匹配的单元格开始，我们将继续扩展到主对角线上第一个未匹配的单元格。连续匹配的单元格形成一个子序列。我们继续在矩阵中找到所有子序列。第三，我们检查矩阵中任意两个子序列之间的间隔。如果间隔小于某个阈值*η*，我们将这些子序列链接起来形成一个更长的子序列。以同样的方式重复检查间隔，直到遍历所有子序列，最后我们可以找到最长的子序列。第四，将最长子序列的长度除以散列序列1和散列序列2的最大长度，即为语法相似性。值得注意的是，由于矩阵是对称的，我们只需要使用矩阵的一半来找到最长的子序列。
- en: Algorithm 4.1 Syntax Matching Algorithm![../images/506524_1_En_4_Chapter/506524_1_En_4_Figc_HTML.png](../images/506524_1_En_4_Chapter/506524_1_En_4_Figc_HTML.png)
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 算法4.1 语法匹配算法![../images/506524_1_En_4_Chapter/506524_1_En_4_Figc_HTML.png](../images/506524_1_En_4_Chapter/506524_1_En_4_Figc_HTML.png)
- en: 4.2.2 Semantic Similarity Analysis
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.2 语义相似性分析
- en: Code syntax can catch the program similarity from a perspective of program logic,
    while code semantic can intuitionally catch the program similarity from the word-choices
    of the source code (Huang et al. [2018](#CR15)). For example, if the identifier
    of the code line contains the word “withdraw,” the code line can implement the
    extraction function. Therefore, to evaluate the similarity of two smart contracts,
    we can analyze their semantic similarity by analyzing the word choices included
    in the function prototypes of the two smart contracts.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 代码语法可以从程序逻辑的角度捕捉程序相似性，而代码语义可以直观地从源代码的词选择中捕捉程序相似性（Huang等人[2018](#CR15)）。例如，如果代码行的标识符包含单词“withdraw”，那么该代码行可以实现提取功能。因此，为了评估两个智能合约的相似性，我们可以通过分析两个智能合约函数原型中包含的词选择来分析它们的语义相似性。
- en: Code Preprocessing
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 代码预处理
- en: The source code of the smart contract is represented by a set of meaningful
    words, punctuation marks, and operation symbols. We can think of the source code
    of a smart contract as a text document. However, text documents are different
    from ordinary documents, which are not sentences but a set of random words and
    symbols. Therefore, we cannot employ the method in Oliva et al. ([2011](#CR24))
    to firstly calculate the semantic similarity of sentences, and then calculate
    the semantic similarity of two text documents. Instead, we use word embeddings
    (Mikolov et al. [2013](#CR20)) to vectorize each significative word, and then
    calculate the semantic similarity of two smart contracts.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约的源代码由一系列有意义的单词、标点符号和操作符号组成。我们可以将智能合约的源代码视为一篇文本文档。然而，文本文档与普通文档不同，它们不是句子，而是一组随机的单词和符号。因此，我们不能采用Oliva等人([2011](#CR24))的方法，首先计算句子的语义相似性，然后计算两个文本文档的语义相似性。相反，我们使用词嵌入（Mikolov等人[2013](#CR20)）将每个有意义的单词向量化，然后计算两个智能合约的语义相似性。
- en: 'Obviously, not all words in the smart contract source code play an active role
    in semantic similarity analysis, and some original words may weaken the semantics
    of the code. Therefore, a series of preprocess rules are applied: (1) split the
    camel-case words into single words, such as: ‘*giveRightVote*’ is divided into
    ‘*give*’, ‘*right*’, and ‘*vote*’; (2) filter out the function words in the source
    code, such as ‘*and*’, ‘*the*’, and ‘*an*’; (3) filter out the keywords of Solidity,
    such as ‘*mapping*’, ‘*public*’, ‘*function*’, ‘*if*’, ‘*modifier*’, and ‘*for*’;
    and (4) filter out the letters sequence which does not denote a word, such as
    ‘*tttt*’, ‘*hhhk*’, and ‘*kkkk*’.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，智能合约源代码中的所有词并非都在语义相似性分析中起积极作用，一些原始词可能会削弱代码的语义。因此，应用了一系列预处理规则：（1）将驼峰命名法单词拆分为单个单词，例如：“*giveRightVote*”拆分为“*give*”、“*right*”和“*vote*”；（2）过滤源代码中的功能词，例如“*and*”、“*the*”和“*an*”；（3）过滤掉Solidity的关键字，例如“*mapping*”、“*public*”、“*function*”、“*if*”、“*modifier*”和“*for*”；（4）过滤掉不表示单词的字母序列，例如“*tttt*”、“*hhhk*”和“*kkkk*”。
- en: Word embeddings are unsupervised word representations that only require large
    amounts of unlabeled text to learn (Mikolov et al. [2013](#CR20)). In this work,
    we collect the source code of the smart contract as a software engineering text.
    In order to reduce the vocabulary in the entire corpus, first, we apply stemming
    technology to segment the text. Since English verbs may appear in different tenses
    such as the past, future, and perfect tenses, we convert the verbs in different
    tenses into their original forms. Second, we filter out words that appear less
    than three times in the entire corpus.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 词嵌入是一种无需监督的词表示，只需要大量未标记的文本即可学习（Mikolov 等 [2013](#CR20)）。在本研究中，我们收集智能合约的源代码作为软件工程文本。为了减少整个语料库中的词汇量，首先，我们应用词干提取技术来分割文本。由于英语动词可能出现在不同的时态，如过去、未来和完成时态，我们将不同时态的动词转换为它们的原形。其次，我们过滤掉在整个语料库中出现次数少于三次的词。
- en: Code VectorizationTo obtain the vector representation of a word, we used the
    continuous skip-gram model to learn the word embedding of a central word (i.e.,
    *w* [*i*]) (Mikolov et al. [2013](#CR20)). It is well known that the required
    word embedding is an intermediate result of the continuous skip-gram model. Continuous
    skip-gram is effective at predicting the surrounding words in a context window
    of 2*k*+1 words (generally, *k*=2, and the window size is 5). The objective function
    of the skip-gram model aims at maximizing the sum of log probabilities of the
    surrounding context words conditioned on the central word (Mikolov et al. [2013](#CR20)):![
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 代码向量化为了获得一个词的向量表示，我们使用了连续跳过模型来学习中心词（即 *w* [*i*]）的词嵌入（Mikolov 等 [2013](#CR20)）。众所周知，所需的词嵌入是连续跳过模型的中间结果。连续跳过模型在预测2*k*+1个词的上下文窗口中的周围词方面是有效的（通常
    *k*=2，窗口大小为5）。跳过模型的目标函数旨在最大化以中心词为条件的周围上下文词的对数概率之和（Mikolov 等 [2013](#CR20)):![
- en: $$\displaystyle \begin{aligned} \sum_{i=1}^n \sum_{-k \leq j \leq k, j \neq
    0}\log p(w_{i+j}|w_i) \end{aligned} $$
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: $$\displaystyle \begin{aligned} \sum_{i=1}^n \sum_{-k \leq j \leq k, j \neq
    0}\log p(w_{i+j}|w_i) \end{aligned} $$
- en: '](../images/506524_1_En_4_Chapter/506524_1_En_4_Chapter_TeX_Equ1.png)(4.1)where
    *w* [*i*] and *w* [*i*+*j*] denote the central word and the context word, respectively,
    in a context window of length 2*k*+1 and *n* denotes the length of the word sequence.
    The term !['
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '](../images/506524_1_En_4_Chapter/506524_1_En_4_Chapter_TeX_Equ1.png)(4.1)其中
    *w* [*i*] '
- en: $$\log p(w_{i+j}|w_i)$$
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: $$\log p(w_{i+j}|w_i)$$
- en: '](../images/506524_1_En_4_Chapter/506524_1_En_4_Chapter_TeX_IEq1.png) is the
    conditional probability, defined using the softmax function:!['
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '](../images/506524_1_En_4_Chapter/506524_1_En_4_Chapter_TeX_IEq1.png)是条件概率，使用软最大化函数定义：!['
- en: $$\displaystyle \begin{aligned} \log p(w_{i+j}|w_i) = \frac{{\mathrm{exp}}(v_{w_{i+j}}^{\prime
    T} v_{w_i})}{\sum_{w \in W} {\mathrm{exp}}}(v_{w}^{\prime T} v_{w_i}) \end{aligned}
    $$
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: $$\displaystyle \begin{aligned} \log p(w_{i+j}|w_i) = \frac{{\mathrm{exp}}(v_{w_{i+j}}^{\prime
    T} v_{w_i})}{\sum_{w \in W} {\mathrm{exp}}}(v_{w}^{\prime T} v_{w_i}) \end{aligned}
    $$
- en: '](../images/506524_1_En_4_Chapter/506524_1_En_4_Chapter_TeX_Equ2.png)(4.2)where
    *v* [*w*] and !['
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '](../images/506524_1_En_4_Chapter/506524_1_En_4_Chapter_TeX_Equ2.png)(4.2)其中
    *v* [*w*] '
- en: $$v_{w}^{\prime }$$
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: $$v_{w}^{\prime }$$
- en: '](../images/506524_1_En_4_Chapter/506524_1_En_4_Chapter_TeX_IEq2.png) are the
    input and output vectors of a word *w* in the underlying neural model, and *W*
    is the vocabulary of all words. Intuitively, *p*(*w* [*i*+*j*]|*w* [*i*]) estimates
    the normalized probability of a word *w* [*i*+*j*] appearing in the context of
    a central word *w* [*i*] over all words in the vocabulary. Here, we employ negative
    sampling method (Mikolov et al. [2013](#CR20)) to compute this probability.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '](../images/506524_1_En_4_Chapter/506524_1_En_4_Chapter_TeX_IEq2.png) 是神经网络模型中单词
    *w* 的输入和输出向量，而 *W* 是所有单词的词汇表。直观地说，*p*(*w* [*i*+*j*]|*w* [*i*]) 估计了单词 *w* [*i*+*j*]
    在中心词 *w* [*i*] 的上下文中出现的归一化概率。在这里，我们采用负采样方法（Mikolov 等人 [2013](#CR20)）来计算这个概率。'
- en: After training the model, each word in the corpus is associated with the vector
    representation and forms a word dictionary. In order to obtain the semantic information
    of smart contracts, we first collect their preprocessing identifiers, and then
    determine the corresponding vector representation of each identifier from the
    dictionary. Subsequently, we sum the vectors of all identifiers in the smart contract
    dimension by dimension. Then, we can calculate the semantic similarity of any
    two smart contracts via the vectorial angle of their semantic vectors.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在训练模型后，语料库中的每个单词都与向量表示关联并形成一个词典。为了获得智能合约的语义信息，我们首先收集它们的前处理标识符，然后从词典中确定每个标识符对应的向量表示。随后，我们在智能合约维度上按维度累加所有标识符的向量。然后，我们可以通过它们语义向量的向量夹角计算任意两个智能合约的语义相似性。
- en: 4.2.3 Similarity Calculation of Smart Contracts
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.3 智能合约相似性计算
- en: For the given source code of a pair of smart contracts *C* [*n*] and *C* [*m*],
    our algorithm analyzes their code syntax to obtain the hash sequences, and extracts
    significative words to generate semantic vectors. After that, we calculate syntax
    similarity between the hash sequences of smart contracts *C* [*n*] and *C* [*m*].
    Meanwhile, we calculate the semantic similarity between *C* [*n*] and *C* [*m*].
    After obtaining the syntax and semantic similarities, we use Eq. ([4.3](#Equ3))
    to calculate a comprehensive similarity.![
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 对于给定的一对智能合约 *C* [*n*] 和 *C* [*m*] 的源代码，我们的算法分析它们的代码语法以获得哈希序列，并提取关键词生成语义向量。之后，我们计算智能合约
    *C* [*n*] 和 *C* [*m*] 的哈希序列之间的语法相似性。同时，我们计算 *C* [*n*] 和 *C* [*m*] 之间的语义相似性。在获得语法和语义相似性之后，我们使用式子
    ([4.3](#Equ3)) 计算综合相似性。![
- en: $$\displaystyle \begin{aligned} CompSimi = \alpha \cdot SyntSimi + \beta \cdot
    SemanSimi, \end{aligned} $$
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: $$\displaystyle \begin{aligned} CompSimi = \alpha \cdot SyntSimi + \beta \cdot
    SemanSimi, \end{aligned} $$
- en: '](../images/506524_1_En_4_Chapter/506524_1_En_4_Chapter_TeX_Equ3.png)(4.3)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '](../images/506524_1_En_4_Chapter/506524_1_En_4_Chapter_TeX_Equ3.png)(4.3)'
- en: Where, *CompSimi*, *SyntSimi*, and *SemanSimi* correspond to comprehensive,
    syntax, and semantic similarity, respectively; *α* plus *β* equal to 1.0.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，*CompSimi*, *SyntSimi*, 和 *SemanSimi* 分别对应于综合、语法和语义相似性；*α* 加 *β* 等于 1.0。
- en: 4.3 Differentiated Code Recommendation
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3 差异化代码推荐
- en: Based on the similarity calculation method, our method can retrieve many similar
    smart contracts for any target smart contract from the contract repository. However,
    given that there are more than 120,000 smart contracts in the contract repository,
    the retrieval efficiency of this method is very low. Therefore, we can first cluster
    smart contracts according to the comprehensive similarity, and then retrieve similar
    contracts to target smart contracts from closer clusters, which can significantly
    improve retrieval efficiency. Then, we can compare the source codes of similar
    smart contracts to obtain code differences, which can be used as distinguishing
    codes to support smart contract updates.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 基于相似性计算方法，我们的方法可以从合约库中为任何目标合约检索到许多类似的合约。然而，考虑到合约库中有超过 120,000 个智能合约，这种方法的检索效率非常低。因此，我们可以首先根据综合相似性对智能合约进行聚类，然后从更接近的簇中检索与目标合约类似的合约，这可以显著提高检索效率。接着，我们可以比较类似合约的源代码以获得代码差异，这些差异可以用作区分代码以支持智能合约的更新。
- en: 4.3.1 Similar Smart Contracts Clustering
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.1 类似智能合约的聚类
- en: To cluster the similar smart contracts, we employ K-means clustering (Hartigan
    and Wong [1979](#CR12)) in this chapter. The main idea behind K-means clustering
    is that given a specific parameter *K*, it will partition *n* instances into *K*
    clusters, and each instance belongs to the cluster with nearest mean.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了聚类相似的智能合约，我们在本章中使用了K-means聚类（Hartigan和Wong [1979](#CR12)）。K-means聚类背后的主要思想是，给定特定的参数*K*，它将*n*个实例划分为*K*个簇，每个实例属于最近的平均值的簇。
- en: When initializing K-means clustering, we should randomly select the *K* smart
    contract as the clustering center; then, according to the comprehensive similarity,
    when the center of the cluster is closest to the smart contract, each smart contract
    will be assigned to the cluster. Later, when a new smart contract is added to
    the cluster, it should update the cluster center iteratively. Finally, when the
    cluster centers remain unchanged, we stop the iteration.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当初始化K-means聚类时，我们应该随机选择*K*个智能合约作为聚类中心；然后，根据综合相似性，当簇中心最接近智能合约时，每个智能合约将被分配到簇。后来，当新的智能合约添加到簇中时，它应该迭代地更新簇中心。最后，当簇中心保持不变时，我们停止迭代。
- en: 4.3.2 Differentiated Code Extraction
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.2 差异化代码提取
- en: To support the update of a target smart contract, we need to extract the differentiated
    code from its similar smart contracts. Again, we apply the syntax matching algorithm
    (i.e., Algorithm [4.1](#FPar1)) to extract the differentiated code. Specifically,
    for target smart contract *C* [*n*] and its similar smart contract *C* [*m*],
    we can find the longest matching subsequence in matrix *M*[*i*,*j*]. On the one
    hand, we can identify the matched code statements of *C* [*n*] and *C* [*m*] according
    to the longest matching subsequence. On the other hand, the nonmatching code statements
    of *C* [*n*] and *C* [*m*] can be also identified by removing the matching ones
    in the longest matching subsequence in matrix *M*[*i*,*j*].
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持目标智能合约的更新，我们需要从其相似的智能合约中提取差异化代码。再次，我们应用语法匹配算法（即算法[4.1](#FPar1)）来提取差异化代码。具体来说，对于目标智能合约*C*
    [*n*]和其相似的智能合约*C* [*m*]，我们可以在矩阵*M*[*i*,*j*]中找到最长的匹配子序列。一方面，我们可以根据最长的匹配子序列确定*C*
    [*n*]和*C* [*m*]的匹配代码语句。另一方面，通过从矩阵*M*[*i*,*j*]中移除最长匹配子序列中的匹配语句，我们也可以确定*C* [*n*]和*C*
    [*m*]的非匹配代码语句。
- en: There are two types of nonmatching statements, that is, statements contained
    in smart contract *C* [*n*], but not in *C* [*m*] (case 1); or statements contained
    in smart contract *C* [*m*], but not in *C* [*n*] (case 2). When we try to use
    the differentiated code to support the update of smart contract *C* [*n*], the
    non-matching statements in case 2 can be used as differentiated code to recommend
    to smart contract *C* [*n*] for updating. In the same manner, the nonmatching
    statements in case 1 can be used as differentiated code to support the update
    of smart contract *C* [*m*].
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种不匹配的语句，即包含在智能合约*C* [*n*]中，但不包含在*C* [*m*]中的语句（情况1）；或者包含在智能合约*C* [*m*]中，但不包含在*C*
    [*n*]中的语句（情况2）。当我们试图使用差异化代码来支持智能合约*C* [*n*]的更新时，情况2中的不匹配语句可以用作差异化代码，推荐给智能合约*C*
    [*n*]以进行更新。同样地，情况1中的不匹配语句可以用作差异化代码，来支持智能合约*C* [*m*]的更新。
- en: 4.4 Case Study
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.4 案例研究
- en: 4.4.1 Dataset
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.1 数据集
- en: We downloaded 32,537 solidity files from Etherscan,^([1](#Fn1)) and each solidity
    file contains an average of 3.7 smart contracts (ranges from 0 to 36). There are
    a total of 120,389 smart contracts, which are stored in a local repository. And
    these smart contracts were released before March 24, 2018\. Table [4.1](#Tab1)
    shows the statistical characteristics of the dataset.Table 4.1
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从Etherscan下载了32,537个solidity文件，^([1](#Fn1))每个solidity文件平均包含3.7个智能合约（范围从0到36）。总共有120,389个智能合约，存储在本地仓库中。这些智能合约是在2018年3月24日之前发布的。表[4.1](#Tab1)显示了数据集的统计特性。表4.1
- en: Statistical characteristics of the dataset
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 数据集的统计特性
- en: '| Solidity files | # of contract (Min) | # of contract (Max) | Average | Contracts
    (Total) |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| Solidity文件 | 智能合约数量（最小） | 智能合约数量（最大） | 平均数 | 智能合约（总计） |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| 32,537 | 0 | 36 | 3.7 | 120,389 |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| 32,537 | 0 | 36 | 3.7 | 120,389 |'
- en: 4.4.2 Research Questions
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.2 研究问题
- en: 'With the purpose of analyzing our approach’s capability to recommend differentiated
    code to support smart contract update, we would like to answer the following research
    questions in our evaluation:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了分析我们方法推荐差异化代码以支持智能合约更新的能力，我们希望在我们的评估中回答以下研究问题：
- en: '**RQ1**:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**RQ1**:'
- en: Can the recommended differentiated code guide the developers in updating smart
    contract?
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 推荐的差异化代码能否引导开发者更新智能合约？
- en: '**RQ2**:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**RQ2**：'
- en: Does the choice of weight values (i.e., *α* and *β*) affect the performance
    of our approach?
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 权重值的选择（即*α*和*β*）会影响我们方法的表现吗？
- en: '**RQ3**:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**RQ3**：'
- en: What differentiated code can the developers obtain in the recommended smart
    contracts?
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者在推荐的智慧合约中可以获得什么样的差异化代码？
- en: In whole experiment, our approach is executed on Windows 7, with a quad-core
    3.3 GHz Intel Core i5 processor and 8 GB memory. The gap parameter *η* = 3 in
    whole experiment.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个实验中，我们的方法在Windows 7上运行，配备有四核3.3 GHz英特尔酷睿i5处理器和8GB内存。整个实验中，间隙参数*η*=3。
- en: 4.4.3 Evaluation Criteria
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.3 评估标准
- en: For **RQ1**, we want to evaluate whether the differentiated code in recommended
    smart contract can help developers in updating smart contract. To achieve this
    goal, we firstly collect the smart contracts with two versions (the earlier-released
    version is called target smart contract, and the later-released version is called
    evolving smart contract) in the dataset, and then apply the proposed method to
    recommend a number of similar smart contracts (called recommended smart contract)
    for the target smart contract. Finally, we determine whether the recommended smart
    contracts and the evolving smart contract involve the same code change (i.e.,
    differentiated code) when comparing with the target smart contract. If this is
    true, it can prove that the recommended smart contract can be used to guide future
    update of the target smart contract, as the code change in recommended smart contract
    is consistent with the ones in evolving version of the target smart contract.
    In order to determine whether a smart contract has two versions, we require that
    the two smart contracts should be in the same account (i.e., published by the
    same author). In addition, we also require that the similarity of the two smart
    contracts is equal to or greater than 0.7\. If both of the two conditions are
    met, the smart contract is regarded as having two versions.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 对于**RQ1**，我们想要评估推荐智能合约中的差异化代码是否可以帮助开发者更新智能合约。为了实现这一目标，我们首先收集数据集中的具有两个版本的智慧合约（早期发布的版本称为目标智能合约，后来发布的版本称为演变智能合约），然后应用提出的方法为目标智能合约推荐一些类似智慧合约（称为推荐智能合约）。最后，我们确定推荐智能合约和演变智能合约是否包含与目标智能合约相同的代码更改（即差异化代码）在与目标智能合约比较时。如果这是真的，它可以证明推荐的智慧合约可以用来指导目标智慧合约未来的更新，因为推荐智慧合约中的代码更改与目标智慧合约的演变版本中的代码更改一致。为了确定一个智慧合约是否有两个版本，我们要求这两个智慧合约应在同一个账户中（即由同一作者发布）。此外，我们还要求这两个智慧合约的相似度等于或大于0.7。如果这两个条件都满足，智慧合约被视为具有两个版本。
- en: For **RQ2**, we want to evaluate whether there is a tradeoff between *α* and
    *β* that can make the proposed method get a best result. To achieve this goal,
    we propose a parameter optimization method. Specifically, for each target smart
    contract in **RQ1**, the goal of our parameter optimization method is to improve
    the ranks of the recommended smart contracts in the recommendation list via gradually
    adjusting the values of *α* and *β*. Because only when the recommended smart contract
    appears in the top of the recommendation list, it means our algorithm works well
    and can further effectively provide reference for the developers.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 对于**RQ2**，我们想要评估是否存在一个*α*和*β*之间的权衡，能使所提出的方法获得最佳结果。为了实现这一目标，我们提出了一种参数优化方法。具体来说，对于**RQ1**中的每个目标智能合约，我们参数优化方法的目标是通过逐渐调整*α*和*β*的值，提高推荐智能合约在推荐列表中的排名。因为只有当推荐的智能合约出现在推荐列表的前面，这意味着我们的算法运行良好，并能进一步有效地为开发者提供参考。
- en: For **RQ3**, We try to quantitatively analyze the recommended smart contracts.
    We hope to understand what difference codes developers can obtain in the recommended
    smart contracts, and further determine whether the difference knowledge can be
    used to help developers update the version. In order to achieve this goal, we
    analyze and classify the difference codes in the recommended smart contracts based
    on experience.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 对于**RQ3**，我们试图定量分析推荐的智慧合约。我们希望了解开发者在推荐的智慧合约中可以获得什么样的代码差异，进而确定是否可以使用这些差异知识帮助开发者更新版本。为了实现这一目标，我们基于经验对推荐智慧合约中的差异代码进行分析分类。
- en: 4.4.4 Results Analysis
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.4 结果分析
- en: 4.4.4.1 **RQ1**
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.4.4.1 **RQ1**
- en: We found that a total number of 42 smart contracts have two versions. Due to
    the space limitation, Table [4.2](#Tab2) shows the information of part of the
    smart contracts. The *Name* column in Table [4.2](#Tab2) represents the contract
    name; the *Address* column represents the address of the smart contract in the
    blockchain. The *Address* consisted of a 40-bit hexadecimal number, also due to
    the space limitation, we only retained its first 5-bit in the Table [4.2](#Tab2).
    The *Block Height* column represents the height of the block that current smart
    contract locates in. The *Simi* column represents the code similarity between
    target smart contract and recommended smart contract (or target smart contract
    and evolving smart contract), and *Rank* column represents the similarity rank
    of the recommended smart contract in the recommended list via applying the proposed
    method.Table 4.2
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: The results of RQ1
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '|   | Target smart contracts | Recommended smart contracts | Evolving smart
    contracts |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
- en: '| No. | Name | Address | Block height | Name | Address | Block height | Simi
    | Rank | Name | Address | Block height | Simi |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | ---
    |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
- en: '| 1 | Owned | 0x2561b | 4,886,545 | Owned | 0x492a4 | 4,704,537 | 0.83 | 1
    | Owned | 0x14b0d | 4,887,631 | 0.83 |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
- en: '| 2 | ERC20 | 0x6c4fe | 4,928,600 | ABTokenBase | 0x007e7 | 4,547,466 | 0.89
    | 2 | ERC20 | 0x01b84 | 5,168,599 | 0.89 |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
- en: '| 3 | Token | 0x759a5 | 4,538,168 | Token | 0x273f5 | 4,494,277 | 0.8 | 3 |
    Token | 0x5d113 | 4,627,084 | 0.8 |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
- en: '| 4 | ERC20 | 0x37bda | 4,551,394 | ABTokenBase | 0x007e7 | 4,547,466 | 0.73
    | 3 | ERC20 | 0x1dfa4 | 4,685,008 | 0.73 |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
- en: '| 5 | USDGOLD | 0x00755 | 4,879,124 | FireLottoToken | 0x04939 | 4,713,248
    | 0.87 | 2 | ILoveYou | 0xaeda4 | 4,981,202 | 0.87 |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
- en: '| 6 | FengShuiCoin | 0x0661f | 5,158,332 | PI | 0x69124 | 4,649,999 | 0.78
    | 4 | FSRatCoin | 0x5ab63 | 5,158,430 | 0.78 |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
- en: '| 7 | BRM | 0xd7732 | 5,231,383 | MOT | 0x263c6 | 4,753,082 | 0.82 | 1 | BRM
    | 0x61d16 | 5,239,862 | 0.82 |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
- en: '| 8 | AbstractToken | 0xc25c2 | 4,967,169 | ERC20 | 0x003f7 | 4,508,340 | 0.89
    | 1 | ERC20 | 0x15adb | 4,971,923 | 0.89 |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
- en: '| 9 | ERC20Basic | 0x6c4fe | 4,928,600 | ERC20Basic | 0x0056A | 4,791,096 |
    0.8 | 1 | ERC20Basic | 0x01b84 | 5,168,599 | 0.8 |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
- en: '| 10 | VenusERC20 | 0xa723c | 4,837,227 | ELYTE | 0x05d37 | 4,506,864 | 0.84
    | 7 | VenusToken | 0x1e4e3 | 4,846,201 | 0.84 |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
- en: '| 11 | BIGCToken | 0xa6768 | 4,823,807 | TokenERC20 | 0x0445a | 4,526,508 |
    0.81 | 2 | BIGCToken | 0x574fa | 4,824,268 | 0.81 |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
- en: '| 12 | Token | 0x419ca | 4,209,736 | ERC20 | 0x01b6f | 4,135,914 | 0.75 | 3
    | ERC20 | 0x661Eb | 4,163,888 | 0.75 |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
- en: '| 13 | Token | 0xbca13 | 4,140,369 | ERC20Token | 0x03698 | 3,982,761 | 0.8
    | 1 | Token | 0xc14b3 | 4,177,015 | 0.8 |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
- en: '| 14 | Owned | 0xd32c2 | 4,424,760 | Managed | 0x259b0 | 4,343,542 | 0.94 |
    1 | Managed | 0x9a9f1 | 4,430,409 | 0.94 |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
- en: For a target smart contract, it may have the same name with its recommended
    smart contract and evolving smart contract, as the first target smart contract
    (i.e., Owned in Table [4.2](#Tab2)) shows. It is worth noting that although the
    target smart contract and the recommended smart contract have the same name, they
    are created by different accounts. Therefore, the contract (Owned, with address
    0x492a4) can be used as a recommended smart contract for the target smart contract
    (Owned, with address 0x2561b). In some cases, the target smart contract and its
    evolving smart contract have different names, as the second target smart contract
    (i.e., Owned) shows. We can determine the contract Owned is an evolving version
    of contract Managed because they are created by the same account and with a higher
    code similarity (i.e., 0.94). Moreover, the release time of contracts Owned and
    Managed can also confirm this fact, because the higher the block height, the later
    the contract releasing. Thus contract Owned is released later than contract Managed.
    Similarly, we require that the release time of the recommend smart contract should
    be earlier than the release time of the target smart contract. Because the developer
    of the target smart contract can only obtain references from previously released
    smart contracts.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个目标智能合约，它可能与其推荐智能合约和演化智能合约具有相同的名称，如表[4.2](#Tab2)中的第一个目标智能合约（即Owned）所示。值得注意的是，尽管目标智能合约和推荐智能合约具有相同的名称，但它们是由不同的账户创建的。因此，合约（Owned，地址为0x492a4）可以用作目标智能合约（Owned，地址为0x2561b）的推荐智能合约。在某些情况下，目标智能合约及其演化智能合约具有不同的名称，如第二个目标智能合约（即Owned）所示。我们可以确定合约Owned是合约Managed的演化版本，因为它们由同一个账户创建，并且代码相似度更高（即0.94）。此外，合约Owned和Managed的发布时间也可以证实这一点，因为区块高度越高，合约发布越晚。因此，合约Owned比合约Managed发布得更晚。类似地，我们要求推荐智能合约的发布时间应早于目标智能合约的发布时间。因为目标智能合约的开发者只能从之前发布的智能合约中获得参考。
- en: In Table [4.2](#Tab2), we can observe that there are some target smart contracts
    with overlapping name, that is, the first and the last target smart contracts,
    the 3rd and 5th smart contracts, the 4th and 13th, 14th smart contracts. Although
    these smart contracts have same name, they are created by different accounts and
    have different addresses. More importantly, they are different in source code.
    For example, we compare source code of the first and the last smart contracts,
    and find that the code similarity of these two smart contracts is less than 40%.
    Then, when applying the proposed approach to retrieve similar smart contracts
    for them, the obtained recommended smart contracts are also different.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在表[4.2](#Tab2)中，我们可以观察到一些具有重叠名称的目标智能合约，即第一个和最后一个目标智能合约，第三个和第五个智能合约，第四个和第十三个、第十四个智能合约。尽管这些智能合约具有相同的名称，但它们是由不同的账户创建的，并且具有不同的地址。更重要的是，它们的源代码不同。例如，我们比较第一个和最后一个智能合约的源代码，并发现这两个智能合约的代码相似度不到40%。然后，当将提出的方法应用于检索它们的类似智能合约时，获得的推荐智能合约也是不同的。
- en: We conclude that for RQ1, the proposed smart contracts of 42 target smart contracts
    are the same as their evolving smart contracts, and this discovery enables developers
    to use the suggested method to retrieve similar contracts to help them update
    their smart contracts in practice development.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得出结论，对于RQ1，所提出的42个目标智能合约与其演化的智能合约相同，这一发现使得开发者可以采用建议的方法来检索类似的合约，以帮助他们在实际开发中更新智能合约。
- en: 4.4.4.2 **RQ2**
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.4.4.2 **RQ2**
- en: In smart contract recommendation, we employ code syntactic and semantic information
    to measure the code similarity between smart contracts. We compute the comprehensive
    similarity according to Eq. ([4.3](#Equ3)). To tune the best values of *α* and
    *β*, we gradually increase their values from 0.1 to 0.9 (every time we increase
    threshold by 0.1). And we should make sure that *α* + *β* = 1 in every iteration.
    Our goal is to find a pair of *α* and *β* resulting in the best ranks of the recommended
    smart contracts in the recommendation list.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在智能合约推荐中，我们利用代码语法和语义信息来衡量智能合约之间的代码相似度。我们根据公式([4.3](#Equ3))计算综合相似度。为了调整*α*和*β*的最佳值，我们逐渐将它们的值从0.1增加到0.9（每次增加0.1的阈值）。并且我们应确保每次迭代的*α* + *β* = 1。我们的目标是找到一对*α*和*β*，使得推荐智能合约在推荐列表中的排名最佳。
- en: Figure [4.2](#Fig2) presents the detailed information to estimate the values
    of *α* and *β*. The vertical axis shows the total rank of the 42 recommended smart
    contracts when applying the proposed method, and the horizontal axis shows the
    value pairs of *α* and *β*. For example, (0.1, 0.9) represents the value of *α*
    equals 0.1 and *β* equals 0.9\. We can observe that the total rank of recommended
    smart contracts is improved with *α* incrementally increasing. When *α* equals
    0.9 and *β* equals 0.1, the total rank of recommended smart contracts achieves
    a best result in the recommendation list. This result shows that the code syntax
    plays a dominant role in the calculation of contract similarity.![../images/506524_1_En_4_Chapter/506524_1_En_4_Fig2_HTML.png](../images/506524_1_En_4_Chapter/506524_1_En_4_Fig2_HTML.png)
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图[4.2](#Fig2)展示了使用 proposed method 对 42 个推荐智能合约进行应用时详细信息以估算 *α* 和 *β* 的值。垂直轴显示应用
    proposed method 时 42 个推荐智能合约的总排名，水平轴显示 *α* 和 *β* 的值对。例如，（0.1, 0.9）表示 *α* 等于 0.1，*β*
    等于 0.9。我们可以观察到，随着 *α* 的逐渐增加，推荐智能合约的总排名得到提高。当 *α* 等于 0.9，*β* 等于 0.1 时，推荐智能合约的总排名在推荐列表中达到最佳结果。这一结果表明代码语法在计算合约相似性中起主导作用。![../images/506524_1_En_4_Chapter/506524_1_En_4_Fig2_HTML.png](../images/506524_1_En_4_Chapter/506524_1_En_4_Fig2_HTML.png)
- en: Fig. 4.2
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Fig. 4.2
- en: The effect of weight values
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 权重值的效果
- en: Table [4.3](#Tab3) shows the comparison of applying different metrics to measure
    the code similarity. When we only apply semantic information to calculate the
    code similarity, the recommended smart contracts can obtain a total rank of 172,
    and an average of 4.1; When we apply syntactic information alone, the recommended
    smart contracts can obtain a total rank of 148, and an average of 3.5\. When we
    combine these two metrics with a weight values of 0.9 and 0.1, the recommended
    smart contracts get a best total rank of 144, and an average of 3.4\.Table 4.3
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 表[4.3](#Tab3)展示了使用不同指标衡量代码相似性的比较。当我们只用语义信息来计算代码相似性时，推荐智能合约可以获得总排名 172，平均 4.1；当我们单独应用语法信息时，推荐智能合约可以获得总排名
    148，平均 3.5。当我们用权重值 0.9 和 0.1 结合这两个指标时，推荐智能合约在推荐列表中获得了最佳总排名 144，平均 3.4。表 4.3
- en: The comparison of different metrics
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 不同指标的比较
- en: '| Metrics | Sum ranks | Average ranks |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| 指标 | 总排名 | 平均排名 |'
- en: '| --- | --- | --- |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Semantic | 172 | 4.1 |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| 语义 | 172 | 4.1 |'
- en: '| Syntax | 148 | 3.5 |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| 语法 | 148 | 3.5 |'
- en: '| Syntax + Semantic (*α* = 0.9, *β* = 0.1) | 144 | 3.4 |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| 语法 + 语义 (*α* = 0.9, *β* = 0.1) | 144 | 3.4 |'
- en: We conclude RQ2 that a combination of syntactic and semantic information with
    weight values of 0.9 and 0.1 can make the recommended smart contracts get the
    best ranks. Therefore, we use *α* = 0.9 and *β* = 0.1 as default values in this
    study.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得出 RQ2 的结论，用权重值 0.9 和 0.1 结合语法和语义信息可以使推荐智能合约获得最佳排名。因此，在本研究中我们使用 *α* = 0.9
    和 *β* = 0.1 作为默认值。
- en: 4.4.4.3 **RQ3**
  id: totrans-113
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.4.4.3 **RQ3**
- en: We conducted an empirical analysis of the recommended smart contract and tried
    to see what different codes developers can obtain in the recommended smart contract.
    Table [4.4](#Tab4) shows 10 types of differentiated code on the 42 recommended
    smart contracts, where the red font indicates the differentiated code. It is worth
    noting that a recommended smart contract may involve more than one differentiated
    code for a target smart contract.Table 4.4
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对推荐智能合约进行了实证分析，并试图看看开发者可以在推荐智能合约中获得哪些不同的代码。表[4.4](#Tab4) 展示了在 42 个推荐智能合约上对
    10 种类型的不同代码，其中红色字体表示不同代码。值得注意的是，一个推荐智能合约可能涉及一个目标智能合约的多个不同代码。表 4.4
- en: Examples of differentiated code
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 不同代码示例
- en: '![../images/506524_1_En_4_Chapter/506524_1_En_4_Figa_HTML.png](../images/506524_1_En_4_Chapter/506524_1_En_4_Figa_HTML.png)![../images/506524_1_En_4_Chapter/506524_1_En_4_Figb_HTML.png](../images/506524_1_En_4_Chapter/506524_1_En_4_Figb_HTML.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![../images/506524_1_En_4_Chapter/506524_1_En_4_Figa_HTML.png](../images/506524_1_En_4_Chapter/506524_1_En_4_Figa_HTML.png)![../images/506524_1_En_4_Chapter/506524_1_En_4_Figb_HTML.png](../images/506524_1_En_4_Chapter/506524_1_En_4_Figb_HTML.png)'
- en: The red font indicates the differentiated code.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 红色字体表示已分化的代码。
- en: The first kind of differentiated code is Events. Events are similar to logging
    operations in object-oriented programming languages (such as Java), which is a
    convenient interface with EVM logging facilities. Events are a common programming
    practice of practical importance to collect EVM runtime information, as they can
    be used for assisting postmortem analysis (Zhu et al. [2015](#CR34)). In some
    cases, developers forget to insert Events to record the key runtime information
    of EVM, which may significantly increase the difficulty in failure diagnosis.
    In this sense, the differentiated code recommended by our method is an important
    reference for developers to add Events.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种不同的代码是事件（Events）。事件类似于面向对象编程语言（如Java）中的日志操作，这是一个与EVM日志设施方便接口的常见编程实践。事件是实际重要的编程实践，用于收集EVM运行时信息，因为它们可以用于辅助事后分析（Zhu等人[2015](#CR34)）。在某些情况下，开发人员忘记插入事件以记录EVM的关键运行时信息，这可能会显著增加故障诊断的难度。从这个意义上说，我们方法推荐的差异化代码为开发者添加事件提供了重要参考。
- en: Another kind of differentiated code is the self-destruct function. The self-destruct
    function can end the current execution. More importantly, the self-destruct function
    can destroy the current contract and transfer funds to the designated account.
    Therefore, when our method recommends the self-destruct function to the target
    smart contract, it can not only enhance the controllability of the smart contract
    life cycle but also increase the flexibility of the smart contract.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种不同的代码是自毁函数。自毁函数可以结束当前执行。更重要的是，自毁函数可以销毁当前合约并将资金转至指定账户。因此，当我们的方法向目标智能合约推荐自毁函数时，它不仅可以增强智能合约生命周期的可控性，还可以增加智能合约的灵活性。
- en: The third kind of differentiated code is the Modifier. Modifier can be used
    to easily change the behavior of functions, and they can automatically check a
    condition prior to execute the function. For example, the case 3 in Table [4.4](#Tab4)
    shows that the Modifier requires owner is msg.sender, if so, the smart contract
    executes the function that references the Modifier; if not, the smart contract
    throws an exception. Therefore, the Modifier recommended to the target smart contracts
    plays an important role to restrict access authority of the function in this case.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种不同的代码是修改器（Modifier）。修改器可用于轻松更改函数的行为，并且它们可以自动在执行函数之前检查条件。例如，表[4.4](#Tab4)中的案例3显示，修改器要求owner等于msg.sender，如果是，智能合约执行引用修改器的函数；如果不是，智能合约抛出异常。因此，针对目标智能合约推荐的修改器在此情况下对限制函数的访问权限发挥了重要作用。
- en: Another kind of differentiated code is rollback function optimization. Case
    4 in Table [4.4](#Tab4) shows that the throw is used in the target smart contract,
    while the revert( ) is used in the recommended smart contract. The throw can roll
    back all state changes, but consume the remaining gas. In contrast, revert( )
    can also roll back all state changes, but return remaining gas to the caller.
    In this sense, revert( ) is more user friendly, which is an optimized rollback
    function.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种不同的代码是回滚函数优化。表[4.4](#Tab4)中的案例4显示，目标智能合约中使用了throw，而推荐智能合约中使用了revert( )。throw可以回滚所有状态更改，但消耗剩余的燃料。相比之下，revert(
    )也可以回滚所有状态更改，但将剩余的燃料返回给调用者。从这个意义上说，revert( )对用户更友好，是一种优化的回滚函数。
- en: The fifth kind of differentiated code is the condition strengthening. Case 5
    in Table [4.4](#Tab4) shows that when satisfying the additional condition of “allowTransfer
    == true”, the if statement can be executed. This operation strengthens condition
    of the if statement, and can also help to avoid program vulnerability.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 第五种不同的代码是条件加强。表[4.4](#Tab4)中的案例5显示，当满足“allowTransfer == true”的额外条件时，if语句可以执行。此操作加强了if语句的条件，还可以帮助避免程序漏洞。
- en: The next three differentiated codes (i.e., from case 6 to 8) can be classified
    as code refactoring. For example, case 6 abstracts some program functions as parent
    contract Iowned, and then Owned inherits from Iowned. Case 7 changes the initial
    value of variable totalSupply. Case 6 adds the keyword indexed to modify the variables
    _prevOwner and _newOwner, which makes the variables indexable.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来三种不同的代码（即从案例6到8）可以归类为代码重构。例如，案例6将一些程序功能抽象为父合约Iowned，然后Owned从Iowned继承。案例7更改了变量totalSupply的初始值。案例6向修改变量_prevOwner和_newOwner的关键词indexed添加，使变量可索引。
- en: The remaining two different codes are related to variable declarations and function
    declarations. In these two cases, some variables and functions are recommended
    to the original target smart contract, and these variables and functions play
    different roles in the smart contract, so we cannot classify them more fine-grained.
    It should be noted that the self-destruct function (case 2) and Modifier (case
    3) are not included in the function declaration (case 10).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的两个不同代码与变量声明和函数声明有关。在这两种情况下，一些变量和函数推荐给原始目标智能合约，这些变量和函数在智能合约中扮演不同角色，所以我们无法对它们进行更细粒度的分类。应注意自毁函数（案例2）和修改器（案例3）并未包含在函数声明（案例10）中。
- en: We conclude RQ3 that most of the differentiated codes recommended by our method
    are useful for developers to update their smart contracts. The differentiated
    codes range from Events, self-destruct function, Modifier to Rollback function,
    etc. These differentiated codes can help the updated smart contracts increase
    the maintainability (e.g., Events), flexibility (e.g., self-destruct function),
    controllability of function behavior (e.g., Modifier), user-friendliness (e.g.,
    rollback function), reasonableness of code structure (e.g., case 6 to 8), etc.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得出RQ3的结论，我们方法推荐的大部分不同代码对开发者更新他们的智能合约是有用的。这些不同代码从事件、自毁函数、修改器到回滚函数等都有。这些不同代码可以帮助更新后的智能合约增加可维护性（例如，事件）、灵活性（例如，自毁函数）、功能行为的可控性（例如，修改器）、用户友好性（例如，回滚函数）、代码结构的合理性（例如，案例6至8）等。
- en: 4.4.5 Cluster Analysis
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.5 集群分析
- en: To further understand the effectiveness of our approach to support the smart
    contract update, we empirically study the clusters of smart contracts described
    in Sect. [4.5](#Sec18).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步理解我们支持智能合约更新的方法的有效性，我们实证研究了第[4.5](#Sec18)节中描述的智能合约集群。
- en: Considering there are more than 120,000 smart contracts in the repository, we
    set the number of clusters of K-means as 6000, that is, *K* = 6000\. In addition,
    we require that when the similarity between the smart contract and the central
    smart contract of the cluster is greater than 0.6, the smart contract is allowed
    to be added to the cluster. This is done to ensure that the smart contracts in
    the same cluster have a higher similarity. However, this constraint may result
    in some smart contracts that do not belong to any cluster.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到仓库中有超过120,000个智能合约，我们设置K-means的集群数量为6000，即*K*=6000。此外，我们要求当智能合约与集群的中心智能合约的相似度大于0.6时，允许将智能合约添加到集群中。这样做是为了确保同一集群中的智能合约具有更高的相似度。然而，这个约束可能导致一些不属于任何集群的智能合约。
- en: Figure [4.3](#Fig3) shows the first 600 clusters according to the number of
    smart contracts belonging to them. We can observe from the clusters that the largest
    number of cluster contains 2894 similar smart contracts, and the least number
    of clusters contains two similar smart contracts. There are 15,800 smart contracts
    that do not belong to any cluster. The result means that the remaining smart contracts
    (i.e., more than 104,000) can find at least one similar smart contract from the
    repository. This is an evidence that most smart contracts are similar in the data
    set, and they share many codes with similar syntax and semantics.![../images/506524_1_En_4_Chapter/506524_1_En_4_Fig3_HTML.png](../images/506524_1_En_4_Chapter/506524_1_En_4_Fig3_HTML.png)
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图[4.3](#Fig3)显示了根据它们所属的智能合约数量的前600个集群。从集群中我们可以观察到，最大的集群包含了2894个相似的智能合约，最小的集群包含了两个相似的智能合约。有15800个智能合约不属于任何集群。这个结果意味着剩余的智能合约（即超过104,000个）可以从仓库中找到至少一个相似的智能合约。这是大多数智能合约在数据集中相似的证据，它们与相似的语法和语义共享许多代码。![../images/506524_1_En_4_Chapter/506524_1_En_4_Fig3_HTML.png](../images/506524_1_En_4_Chapter/506524_1_En_4_Fig3_HTML.png)
- en: Fig. 4.3
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Fig. 4.3
- en: The first 600 smart contract clusters
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 前600个智能合约集群
- en: To further understand why there are so many similar smart contracts, we manually
    analyze the smart contracts in same cluster. The top reason causing the similar
    smart contracts is the implementation of the same “interface.” For example, to
    achieve the “issue currency,” the corresponding smart contracts should implement
    the “interface” of ERC20.^([2](#Fn2)) As a result, all the smart contracts with
    the “issue currency” function have similar source code.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步理解为何存在如此多的相似智能合约，我们手动分析了同一簇中的智能合约。导致相似智能合约的最主要原因是实现了相同的“接口”。例如，为了实现“发行货币”，相应的智能合约应实现ERC20的“接口”。^([2](#Fn2))
    因此，所有具有“发行货币”功能的智能合约都有相似的源代码。
- en: The second reason for similar smart contracts is code reuse. Since many smart
    contracts on Ethereum are open source, developers can retrieve smart contracts
    on demand and customize them based on the source code of existing smart contracts.
    Currently, smart contracts can only be used in some limited areas, such as finance,
    gaming, and social networking. The smart contracts in same field usually implement
    similar functionalities. For example, the finance-related smart contracts have
    the common functionalities, such as *transfer*, *allowance*, and *approve*. Then,
    developers can largely reuse the existing smart contracts for custom development
    in same field, which makes many smart contracts keep small code differences on
    the Ethereum.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 相似智能合约的第二个原因是代码复用。由于以太坊上的许多智能合约都是开源的，开发者可以按需获取智能合约并根据现有智能合约的源代码进行定制。目前，智能合约只能在一些有限的领域使用，如金融、游戏和社会网络。同一领域的智能合约通常实现相似的功能。例如，与金融相关的智能合约具有常见的功能，如*转账*、*授权*和*批准*。然后，开发者可以大量复用现有智能合约进行定制开发，这使得许多智能合约在以太坊上保持较小的代码差异。
- en: Since there are a large number of similar smart contracts in the repository,
    in most cases, our method can successfully retrieve similar smart contracts for
    the target smart contract, and further extract differentiated codes from similar
    smart contracts to support the target smart renewal of the contract.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 由于代码库中有大量相似的智能合约，在大多数情况下，我们的方法可以成功地找到与目标智能合约相似的智能合约，并从相似的智能合约中提取不同的代码，以支持目标智能合约的更新。
- en: 4.5 Discussion
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.5 讨论
- en: 4.5.1 Related Work
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.5.1 相关研究
- en: Smart contracts are applied in various domains, which have been studied by many
    researchers from various perspectives, such as concurrent programming (Dickerson
    et al. [2017](#CR8); Yu et al. [2017](#CR30)), security (Atzei et al. [2017](#CR1);
    Chen et al. [2017](#CR5); Grossman et al. [2018](#CR11); Kosba et al. [2016](#CR18)),
    and scheme (Bartoletti et al. [2017](#CR2); Chen et al. [2018](#CR6)). The most
    related works to this study are the ones that assist programmers in smart contract
    development.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约被应用于各个领域，这已经被许多从不同角度研究智能合约的学者们探讨过，如并发编程（Dickerson等人[2017](#CR8); Yu等人[2017](#CR30)）、安全（Atzei等人[2017](#CR1);
    Chen等人[2017](#CR5); Grossman等人[2018](#CR11); Kosba等人[2016](#CR18)）和方案（Bartoletti等人[2017](#CR2);
    Chen等人[2018](#CR6)）。与本研究最相关的工作是那些帮助程序员进行智能合约开发的工具。
- en: To facilitate collaborative development of smart contract, He et al. ([2018](#CR13))
    proposed SPESC, a specification language for smart contracts development. SPESC
    enables users to specify a smart contract in a similar form to a real-world contract,
    in which the obligations and rights of parties and the transaction rules of cryptocurrencies
    are clearly defined. In addition, SPESC can derive a program skeleton (or a program
    interface) in accordance with the contract terms and the account balance. Their
    preliminary study results demonstrate that SPESC can be easily learned and understood
    by both IT and non-IT users.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了促进智能合约的协同开发，He等人([2018](#CR13))提出了SPESC，一种用于智能合约开发的规范语言。SPESC允许用户以类似于现实世界合同的形式指定智能合约，在其中明确定义各方当事人的义务和权利以及加密货币的交易规则。此外，SPESC可以根据合同条款和账户余额生成程序骨架（或程序接口）。他们初步研究结果表明，SPESC可以很容易地被IT和非IT用户学习和理解。
- en: Frantz and Nowostawski ([2016](#CR10)) proposed a modeling approach that supports
    the semiautomated translation of human-readable contract representations into
    computational equivalents. They adapted ADICO (Ostrom [1995](#CR25)) for modeling
    smart contracts. From ADICO-based models, they also developed a code generator
    to derive partial source code. The ADICO format can specify a party’s obligations
    and rights.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Frantz和Nowostawski ([2016](#CR10)) 提出了一种建模方法，支持将可读的合同表示半自动翻译成计算等价物。他们为建模智能合约改编了ADICO（Ostrom
    [1995](#CR25)）。从基于ADICO的模型，他们还开发了一个代码生成器以导出部分源代码。ADICO格式可以指定当事人的义务和权利。
- en: 'Chen et al. ([2017](#CR4)) conducted an investigation on smart contract and
    revealed the gas-costly programming patterns. They identified seven gas-costly
    patterns, and divided them into two categories: useless-code related patterns,
    and loop-related patterns. They proposed and developed GASPER tool to discover
    gas-costly patterns in smart contract automatically, which can help programmers
    locate three representative patterns in practice development.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Chen等人 ([2017](#CR4)) 对智能合约进行了一项调查，并揭示了耗气编程模式。他们确定了七个耗气模式，并将它们分为两类：与无用代码相关的模式，以及与循环相关的模式。他们提出了并开发了GASPER工具，以自动发现智能合约中的耗气模式，该工具可以帮助程序员在实际开发中定位三个典型模式。
- en: Porru et al. ([2017](#CR26)) identified many challenges for blockchain-oriented
    software engineering, focusing on collaboration among large teams, testing activities,
    and specialized tools for the creation of smart contracts. Their study proposed
    new directions for the blockchain-oriented software engineering.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Porru等人 ([2017](#CR26)) 识别了面向区块链的软件工程面临的许多挑战，重点是大型团队之间的协作、测试活动以及为智能合约创建而专门的工具。他们的工作为面向区块链的软件工程提出了新的研究方向。
- en: Different from the mentioned studies, we are among the first to propose the
    differentiated code for smart contract development at the code level. Differentiated
    code plays a role of illustrating how a software feature is implemented and a
    programming issue is solved, hence the differentiated code can be reused by the
    programmers who want to update their smart contracts in the next version.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 与提到的研究不同，我们在首批提出面向智能合约开发的代码级差异化代码。差异化代码的作用是说明软件特性是如何实现的以及编程问题是如何解决的，因此，想要在下一个版本中更新他们的智能合约的程序员可以重用差异化代码。
