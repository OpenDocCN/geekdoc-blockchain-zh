- en: esting to most people, that is, the current state of ownership.
  prefs: []
  type: TYPE_NORMAL
- en: How It Works
  prefs: []
  type: TYPE_NORMAL
- en: 'Documenting ownership with the blockchain involves the following aspects:'
  prefs: []
  type: TYPE_NORMAL
- en: • Describing the transfer of ownership
  prefs: []
  type: TYPE_NORMAL
- en: • Maintaining the history of transfers
  prefs: []
  type: TYPE_NORMAL
- en: Describing the Transfer of Ownership
  prefs: []
  type: TYPE_NORMAL
- en: A *transaction* is the act of transferring ownership from one owner to someone
    else. The act of transferring ownership relies on data that descibe the
  prefs: []
  type: TYPE_NORMAL
- en: intended transfer. These data contain all information necessary to execute
  prefs: []
  type: TYPE_NORMAL
- en: the transfer of ownership. An example of data that describe an intended
  prefs: []
  type: TYPE_NORMAL
- en: transfer of ownership would be a bank transfer form that is used to request
  prefs: []
  type: TYPE_NORMAL
- en: a bank to make a money transfer on behalf of a customer. The bank transfer
  prefs: []
  type: TYPE_NORMAL
- en: form requires you to provide all information necessary to allow the bank to
  prefs: []
  type: TYPE_NORMAL
- en: make the transfer on your behalf. In a similar fashion, the information used
  prefs: []
  type: TYPE_NORMAL
- en: 'by the blockchain to describe a transaction are:'
  prefs: []
  type: TYPE_NORMAL
- en: • An identifier of the account that is to hand off ownership
  prefs: []
  type: TYPE_NORMAL
- en: to another account
  prefs: []
  type: TYPE_NORMAL
- en: • An identifier of the account that is to receive ownership
  prefs: []
  type: TYPE_NORMAL
- en: • The amount of the goods to be transferred
  prefs: []
  type: TYPE_NORMAL
- en: • The time the transaction is to be done
  prefs: []
  type: TYPE_NORMAL
- en: • A fee to be paid to the system for executing the
  prefs: []
  type: TYPE_NORMAL
- en: transaction
  prefs: []
  type: TYPE_NORMAL
- en: • A proof that the owner of the account that hands off
  prefs: []
  type: TYPE_NORMAL
- en: ownership indeed agrees with that transfer
  prefs: []
  type: TYPE_NORMAL
- en: Most of these data are familiar to anyone who has made a money transfer
  prefs: []
  type: TYPE_NORMAL
- en: with a bank. However, the analogy with a bank transfer ends when fees are
  prefs: []
  type: TYPE_NORMAL
- en: considered. Due to the fact that banks are centralized institutions, they main-
  prefs: []
  type: TYPE_NORMAL
- en: tain a central fee schedule that is applied to all customers. In contrast to
    that, the blockchain is a distributed system without any central point of control.
  prefs: []
  type: TYPE_NORMAL
- en: Hence, the blockchain cannot have a central fee schedule. When using the
  prefs: []
  type: TYPE_NORMAL
- en: '66'
  prefs: []
  type: TYPE_NORMAL
- en: '***Step 9 | Documenting Ownership***'
  prefs: []
  type: TYPE_NORMAL
- en: blockchain, each user has to tell the system in advance how much he or she is
  prefs: []
  type: TYPE_NORMAL
- en: willing to pay for having the transaction executed. The account that hands off
  prefs: []
  type: TYPE_NORMAL
- en: ownership also pays the transaction fee.
  prefs: []
  type: TYPE_NORMAL
- en: Maintaining the History of Transfers
  prefs: []
  type: TYPE_NORMAL
- en: Transaction data provide the mandatory information necessary to execute a
  prefs: []
  type: TYPE_NORMAL
- en: transfer of ownership as intended. Executing a transaction means making the
  prefs: []
  type: TYPE_NORMAL
- en: transfer of ownership happen as described by the transaction data. Executing
  prefs: []
  type: TYPE_NORMAL
- en: a transaction means adding the transaction data to a ledger. By adding transac-
  prefs: []
  type: TYPE_NORMAL
- en: tion data to a ledger, the transaction becomes part of the transaction history,
  prefs: []
  type: TYPE_NORMAL
- en: which is used to clarify ownership. When the ledger is used the next time
  prefs: []
  type: TYPE_NORMAL
- en: to clarify ownership by aggregating the transaction data it contains, the newly
  prefs: []
  type: TYPE_NORMAL
- en: added transaction will be included in the aggregation and hence will impact
    the
  prefs: []
  type: TYPE_NORMAL
- en: resulting state of ownership.
  prefs: []
  type: TYPE_NORMAL
- en: The blockchain maintains the whole history of all transactions that have ever
  prefs: []
  type: TYPE_NORMAL
- en: happened by storing their transaction data in the blockchain-data-structure
    in
  prefs: []
  type: TYPE_NORMAL
- en: the order in which they occurred. Any transaction not being part of that his-
  prefs: []
  type: TYPE_NORMAL
- en: tory is regarded as if it never happened. Hence, adding transaction data to
    the
  prefs: []
  type: TYPE_NORMAL
- en: blockchain-data-structure means making this transaction happen and allowing
  prefs: []
  type: TYPE_NORMAL
- en: it to influence the result of using the history in order to identify the current
    owner.
  prefs: []
  type: TYPE_NORMAL
- en: Why It Works
  prefs: []
  type: TYPE_NORMAL
- en: Since transaction data contain all the information about the account that
  prefs: []
  type: TYPE_NORMAL
- en: hands off ownership, the account that receives ownership, and the item and
  prefs: []
  type: TYPE_NORMAL
- en: the amount to be transferred, one can reconstruct ownership information
  prefs: []
  type: TYPE_NORMAL
- en: for each account as long as the whole history of transactions is available.
    As
  prefs: []
  type: TYPE_NORMAL
- en: a result, the whole history of all transaction data is sufficient to document
  prefs: []
  type: TYPE_NORMAL
- en: ownership.
  prefs: []
  type: TYPE_NORMAL
- en: Importance of Ordering
  prefs: []
  type: TYPE_NORMAL
- en: Aggregating transaction data is done for the purpose of recovering the current
  prefs: []
  type: TYPE_NORMAL
- en: state of ownership and clarifying ownership. It is important to recognize that
  prefs: []
  type: TYPE_NORMAL
- en: the order in which the transactions occurred must be preserved in order to
  prefs: []
  type: TYPE_NORMAL
- en: arrive at the identical result every time the data are aggregated. Changing
    the
  prefs: []
  type: TYPE_NORMAL
- en: order of transaction data will change the result of aggregating them. At first
  prefs: []
  type: TYPE_NORMAL
- en: glance, the result does not seem to change very much whether I receive a
  prefs: []
  type: TYPE_NORMAL
- en: payment of $50 from a friend first and transferred $50 afterward in order to
  prefs: []
  type: TYPE_NORMAL
- en: pay a bill or whether these two transactions occurred in the opposite order.
  prefs: []
  type: TYPE_NORMAL
- en: But what happens if my bank account does not contain any money at all and I
  prefs: []
  type: TYPE_NORMAL
- en: '***Blockchain Basics***'
  prefs: []
  type: TYPE_NORMAL
- en: '67'
  prefs: []
  type: TYPE_NORMAL
- en: am not allowed to overdraw it? In this case, my ability to pay my bill depends
  prefs: []
  type: TYPE_NORMAL
- en: on having received the payment from my friend first. Otherwise, the bank will
  prefs: []
  type: TYPE_NORMAL
- en: refuse to transfer the money to pay the bill due to a lack of funds. Hence,
    the
  prefs: []
  type: TYPE_NORMAL
- en: order in which transactions occur does indeed matter.
  prefs: []
  type: TYPE_NORMAL
- en: Integrity of the Transaction History
  prefs: []
  type: TYPE_NORMAL
- en: Without exaggeration, one can state that the history of transaction data is
  prefs: []
  type: TYPE_NORMAL
- en: the heart of any blockchain that manages ownership because it is the basis for
  prefs: []
  type: TYPE_NORMAL
- en: reconstructing the state of ownership. As a result, it is necessary to keep
    that history of data safe, complete, correct, and consistent in order to maintain
  prefs: []
  type: TYPE_NORMAL
- en: the integrity of the whole system and, as a result, be able to make true state-
  prefs: []
  type: TYPE_NORMAL
- en: ments regarding the current state of ownership. Hence, the blockchain needs
  prefs: []
  type: TYPE_NORMAL
- en: to provide security measures to ensure that only valid transaction data are
  prefs: []
  type: TYPE_NORMAL
- en: added to the blockchain-data-structure. Examining validity of transaction data
  prefs: []
  type: TYPE_NORMAL
- en: 'involves three aspects:'
  prefs: []
  type: TYPE_NORMAL
- en: • Formal correctness
  prefs: []
  type: TYPE_NORMAL
- en: • Semantic correctness
  prefs: []
  type: TYPE_NORMAL
- en: • Authorization
  prefs: []
  type: TYPE_NORMAL
- en: Formal Correctness
  prefs: []
  type: TYPE_NORMAL
- en: '*Formal correctness* means that the description of a transaction contains all
    required data and that the data are provided in the correct format.'
  prefs: []
  type: TYPE_NORMAL
- en: Semantic Correctness
  prefs: []
  type: TYPE_NORMAL
- en: '*Semantic correctness* focuses on the meaning of transaction data and their
    intended effect. Hence, validating semantic correctness requires knowledge'
  prefs: []
  type: TYPE_NORMAL
- en: of the business domain. Examining semantic correctness of transaction data is
  prefs: []
  type: TYPE_NORMAL
- en: 'often done based on business rules, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: • Ensuring that an account does not hand off more than it
  prefs: []
  type: TYPE_NORMAL
- en: currently owns
  prefs: []
  type: TYPE_NORMAL
- en: • Preventing double spending
  prefs: []
  type: TYPE_NORMAL
- en: • Limiting the amount of items that can be transferred in a
  prefs: []
  type: TYPE_NORMAL
- en: single transaction
  prefs: []
  type: TYPE_NORMAL
- en: • Limiting the number of transactions per user
  prefs: []
  type: TYPE_NORMAL
- en: • Limiting the total amount of items spent in a given time period
  prefs: []
  type: TYPE_NORMAL
- en: • Enforcing that an account keeps an item for a minimum
  prefs: []
  type: TYPE_NORMAL
- en: time period before it can be transferred further
  prefs: []
  type: TYPE_NORMAL
- en: '68'
  prefs: []
  type: TYPE_NORMAL
- en: '***Step 9 | Documenting Ownership***'
  prefs: []
  type: TYPE_NORMAL
- en: Authorization
  prefs: []
  type: TYPE_NORMAL
- en: Only the owner of the account who hands off ownership should be allowed
  prefs: []
  type: TYPE_NORMAL
- en: to advise the blockchain to execute a transaction on his or her behalf. As a
  prefs: []
  type: TYPE_NORMAL
- en: result, the blockchain requires every transaction to carry information that
  prefs: []
  type: TYPE_NORMAL
- en: proves that the owner of the account who hands off ownership indeed agrees
  prefs: []
  type: TYPE_NORMAL
- en: with that transfer.
  prefs: []
  type: TYPE_NORMAL
- en: Outlook
  prefs: []
  type: TYPE_NORMAL
- en: This step explained transactions and their role for clarifying ownership. The
  prefs: []
  type: TYPE_NORMAL
- en: following steps are mainly concerned with how the blockchain enforces that
  prefs: []
  type: TYPE_NORMAL
- en: only valid transaction data are added to the history and how the history is
  prefs: []
  type: TYPE_NORMAL
- en: protected from being manipulated or forged.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs: []
  type: TYPE_NORMAL
- en: • Transaction data provide the following information for
  prefs: []
  type: TYPE_NORMAL
- en: 'describing a transfer of ownership:'
  prefs: []
  type: TYPE_NORMAL
- en: • An identifier of the account who initiates the transaction
  prefs: []
  type: TYPE_NORMAL
- en: and is to transfer ownership to another account
  prefs: []
  type: TYPE_NORMAL
- en: • An identifier of that account that is to receive ownership
  prefs: []
  type: TYPE_NORMAL
- en: • The amount of the goods to be transferred
  prefs: []
  type: TYPE_NORMAL
- en: • The time the transaction is to be done
  prefs: []
  type: TYPE_NORMAL
- en: • A fee to be paid to the system for executing the
  prefs: []
  type: TYPE_NORMAL
- en: transaction
  prefs: []
  type: TYPE_NORMAL
- en: • A proof that the owner of the account who hands off
  prefs: []
  type: TYPE_NORMAL
- en: ownership agrees with that transfer
  prefs: []
  type: TYPE_NORMAL
- en: • The complete history of transaction data is an audit
  prefs: []
  type: TYPE_NORMAL
- en: trail that provides evidence of how people acquired and
  prefs: []
  type: TYPE_NORMAL
- en: handed off ownership.
  prefs: []
  type: TYPE_NORMAL
- en: • Any transaction not being part of that history is regarded
  prefs: []
  type: TYPE_NORMAL
- en: as if it never happened.
  prefs: []
  type: TYPE_NORMAL
- en: • A transaction is executed by adding it to the history of
  prefs: []
  type: TYPE_NORMAL
- en: transaction data and allowing it to influence the result of
  prefs: []
  type: TYPE_NORMAL
- en: aggregating them.
  prefs: []
  type: TYPE_NORMAL
- en: '***Blockchain Basics***'
  prefs: []
  type: TYPE_NORMAL
- en: '69'
  prefs: []
  type: TYPE_NORMAL
- en: • The order in which transaction data are added to the his-
  prefs: []
  type: TYPE_NORMAL
- en: tory must be preserved in order to yield identical results
  prefs: []
  type: TYPE_NORMAL
- en: when aggregating these data.
  prefs: []
  type: TYPE_NORMAL
- en: • In order to maintain integrity, only those transaction data
  prefs: []
  type: TYPE_NORMAL
- en: are added to the blockchain-data-structure that fulfill the
  prefs: []
  type: TYPE_NORMAL
- en: 'following three criteria:'
  prefs: []
  type: TYPE_NORMAL
- en: • Formal correctness
  prefs: []
  type: TYPE_NORMAL
- en: • Semantic correctness
  prefs: []
  type: TYPE_NORMAL
- en: • Authorization
  prefs: []
  type: TYPE_NORMAL
- en: '**S T E P**'
  prefs: []
  type: TYPE_NORMAL
- en: '10'
  prefs: []
  type: TYPE_NORMAL
- en: Hashing Data
  prefs: []
  type: TYPE_NORMAL
- en: Identifying data from their digital fingerprint
  prefs: []
  type: TYPE_NORMAL
- en: This step explains one of the most important base technologies of the
  prefs: []
  type: TYPE_NORMAL
- en: 'blockchain: hash values. It discusses important properties of cryptographic'
  prefs: []
  type: TYPE_NORMAL
- en: hash functions and introduces patterns of applying hash functions to data.
  prefs: []
  type: TYPE_NORMAL
- en: The Metaphor
  prefs: []
  type: TYPE_NORMAL
- en: Fingerprints are impressions of the friction ridges of all or any part of the
  prefs: []
  type: TYPE_NORMAL
- en: fingers of the human hand. They are considered to be able to identify humans
  prefs: []
  type: TYPE_NORMAL
- en: uniquely. They have been used to investigate crimes, identify offenders, and
    to
  prefs: []
  type: TYPE_NORMAL
- en: exonerate the innocent. This step introduces a concept for identifying data,
  prefs: []
  type: TYPE_NORMAL
- en: which can be seen as the digital equivalent to fingerprints. The concept is
  prefs: []
  type: TYPE_NORMAL
- en: called cryptographic hash value, and the blockchain makes extensive use of it.
  prefs: []
  type: TYPE_NORMAL
- en: Hence, understanding cryptographic hashing is mandatory for understanding
  prefs: []
  type: TYPE_NORMAL
- en: the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: The Goal
  prefs: []
  type: TYPE_NORMAL
- en: In the distributed peer-to-peer system, you will deal with a huge number
  prefs: []
  type: TYPE_NORMAL
- en: of transaction data. As a result, you will need to identify them uniquely and
  prefs: []
  type: TYPE_NORMAL
- en: compare them as quickly and as easily as possible. Hence, the goal is to iden-
  prefs: []
  type: TYPE_NORMAL
- en: tify transaction data and possibly any kind of data uniquely by their digital
  prefs: []
  type: TYPE_NORMAL
- en: fingerprints.
  prefs: []
  type: TYPE_NORMAL
- en: © Daniel Drescher 2017
  prefs: []
  type: TYPE_NORMAL
- en: D. Drescher, *Blockchain Basics*, DOI 10.1007/978-1-4842-2604-9_10
  prefs: []
  type: TYPE_NORMAL
- en: '72'
  prefs: []
  type: TYPE_NORMAL
- en: '***Step 10 | Hashing Data***'
  prefs: []
  type: TYPE_NORMAL
- en: How It Works
  prefs: []
  type: TYPE_NORMAL
- en: Hash functions are small computer programs that transform any kind of data
  prefs: []
  type: TYPE_NORMAL
- en: into a number of fixed lengths, regardless of the size of the [input data.1](index_split_001.html#76)
    Hash functions only accept one piece of data at any given time as input and create
    a
  prefs: []
  type: TYPE_NORMAL
- en: hash value based on the bits and bytes that make up the data. Hash values can
  prefs: []
  type: TYPE_NORMAL
- en: have leading zeros in order to provide the required length. There are many
  prefs: []
  type: TYPE_NORMAL
- en: different hash functions that differ among others with respect to the length
    of
  prefs: []
  type: TYPE_NORMAL
- en: the hash value they produce. An important group of hash functions is called
  prefs: []
  type: TYPE_NORMAL
- en: '*cryptographic hash functions*, which create digital fingerprints for any kind
    of data. Cryptographic hash functions have the following properties[2](index_split_001.html#76):'
  prefs: []
  type: TYPE_NORMAL
- en: • Providing hash values for any kind of data quickly
  prefs: []
  type: TYPE_NORMAL
- en: • Being deterministic
  prefs: []
  type: TYPE_NORMAL
- en: • Being pseudorandom
  prefs: []
  type: TYPE_NORMAL
- en: • Being one-way functions
  prefs: []
  type: TYPE_NORMAL
- en: • Being collision resistant
  prefs: []
  type: TYPE_NORMAL
- en: Providing Hash Values for Any Data Quickly
  prefs: []
  type: TYPE_NORMAL
- en: This property is actually a combination of two properties. First, the hash
  prefs: []
  type: TYPE_NORMAL
- en: function is able to calculate hash values for all kinds of data. Second, the
    hash function does its calculation quickly. These properties are important, as
    you
  prefs: []
  type: TYPE_NORMAL
- en: do not want the hash function to yield useless things like error messages or
  prefs: []
  type: TYPE_NORMAL
- en: to take a large amount of time to return the results.
  prefs: []
  type: TYPE_NORMAL
- en: Deterministic
  prefs: []
  type: TYPE_NORMAL
- en: Deterministic means that the hash function yields identical hash values for
  prefs: []
  type: TYPE_NORMAL
- en: identical input data. This means that any observed discrepancies of the hash
  prefs: []
  type: TYPE_NORMAL
- en: values of data must be solely caused by the discrepancies of the input data
    and
  prefs: []
  type: TYPE_NORMAL
- en: not by the internals of the hash function.
  prefs: []
  type: TYPE_NORMAL
- en: '1Weisstein, Eric W. Hash function. From MathWorld: [http://mathworld.wolfram.com/](http://mathworld.wolfram.com/HashFunction.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[HashFunction.html.](http://mathworld.wolfram.com/HashFunction.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '2Rogaway, Phillip, and Thomas Shrimpton. Cryptographic hash-function basics:
    definitions, implications, and separations for preimage resistance, second-preimage
    resistance, and collision resistance. In B. Roy and W. Meier (eds.), *Fast software
    encryption. FSE 2004\. Lecture* *Notes in Computer Science,* vol. 3017\. International
    Workshop on Fast Software Encryption.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Berlin Heidelberg: Springer, 2004\.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Blockchain Basics***'
  prefs: []
  type: TYPE_NORMAL
- en: '73'
  prefs: []
  type: TYPE_NORMAL
- en: Pseudorandom
  prefs: []
  type: TYPE_NORMAL
- en: Being pseudorandom means that the hash value returned by a hash function
  prefs: []
  type: TYPE_NORMAL
- en: changes unpredictably when the input data are changed. Even if the input data
  prefs: []
  type: TYPE_NORMAL
- en: were changed only a little bit, the resulting hash value will differ unpredictably.
  prefs: []
  type: TYPE_NORMAL
- en: To put it differently, the hash value of changed data must always be a surprise.
  prefs: []
  type: TYPE_NORMAL
- en: It should not be possible to predict the hash value based on the input data.
  prefs: []
  type: TYPE_NORMAL
- en: One-Way Function
  prefs: []
  type: TYPE_NORMAL
- en: A one-way function does not provide any way to trace its input values by its
  prefs: []
  type: TYPE_NORMAL
- en: outputs. Hence, being a one-way function means that it cannot be used the
  prefs: []
  type: TYPE_NORMAL
- en: other way around. To put it differently, it is impossible to recover the original
    input data based on the hash value. This means that hash values do not tell you
  prefs: []
  type: TYPE_NORMAL
- en: anything about the content of the input data in the same way as an isolated
  prefs: []
  type: TYPE_NORMAL
- en: fingerprint does not tell you anything about the person whose finger created
  prefs: []
  type: TYPE_NORMAL
- en: it. One-way functions are also said to be noninvertible.
  prefs: []
  type: TYPE_NORMAL
- en: Collision Resistant
  prefs: []
  type: TYPE_NORMAL
- en: A hash function is called collision resistant if it is very hard to find two
    or
  prefs: []
  type: TYPE_NORMAL
- en: more distinct pieces of data for which it yields the identical hash value. Or,
    to put it differently, if the chance to receive an identical hash value for distinct
    pieces of data is small, then the hash function is collision resistant. In this
    case, you can consider the hash values created by the hash function as being unique
  prefs: []
  type: TYPE_NORMAL
- en: and hence being usable to identify data. If you obtained an identical hash value
    for different pieces of data, you would face a hash collision. A hash collision
  prefs: []
  type: TYPE_NORMAL
- en: is the digital equivalent to having two people with identical fingerprints.
    Being collision resistant is mandatory for hash values to be usable as digital
    fingerprints. How collision resistant hash functions work internally is beyond
    the
  prefs: []
  type: TYPE_NORMAL
- en: scope of this book, but you can be assured that huge effort has been spent on
  prefs: []
  type: TYPE_NORMAL
- en: reducing their risk to produce hash collisions.
  prefs: []
  type: TYPE_NORMAL
- en: Trying It Out Yourself
  prefs: []
  type: TYPE_NORMAL
- en: This section will help you become comfortable with applying hash functions
  prefs: []
  type: TYPE_NORMAL
- en: by guiding you through a simple example. For this purpose, I refer to the
  prefs: []
  type: TYPE_NORMAL
- en: accompanying website that provides a tool for creating hash values of simple
  prefs: []
  type: TYPE_NORMAL
- en: 'text data: [http://www.blockchain-basics.com/HashFunctions.html](http://www.blockchain-basics.com/HashFunctions.html).'
  prefs: []
  type: TYPE_NORMAL
- en: When you open that webpage in your Internet browser, you will see an input
  prefs: []
  type: TYPE_NORMAL
- en: box and an output box, as shown in Figure [10-1](index_split_001.html#78). Type
    the text Hello World!
  prefs: []
  type: TYPE_NORMAL
- en: in the input box on the left-hand side and click the button with the label
  prefs: []
  type: TYPE_NORMAL
- en: “Calculate Hash Value” located below the text field. Make sure that you type
  prefs: []
  type: TYPE_NORMAL
- en: Hello World! exactly in the input box, otherwise you will get results that differ
    from those shown in Figure [10-1\.](index_split_001.html#78)
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-78_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](index-78_2.png)'
  prefs: []
  type: TYPE_IMG
- en: '74'
  prefs: []
  type: TYPE_NORMAL
- en: '***Step 10 | Hashing Data***'
  prefs: []
  type: TYPE_NORMAL
- en: '**Figure 10-1\.** Calculating hash values of a short text'
  prefs: []
  type: TYPE_NORMAL
- en: As a result of clicking the button, the output box on the right-hand side will
  prefs: []
  type: TYPE_NORMAL
- en: present the hash value of the input text calculated with four different hash
  prefs: []
  type: TYPE_NORMAL
- en: functions. Hash values are often regarded as hash numbers since they use
  prefs: []
  type: TYPE_NORMAL
- en: not only the digits 0 to 9 but also the letters A to F, which represent the
  prefs: []
  type: TYPE_NORMAL
- en: values 11 to 16 in order to express numerical values. Those numbers are
  prefs: []
  type: TYPE_NORMAL
- en: called *hexadecimal numbers*. Computer scientists love them for reasons I do
    not want discuss here. Notice that the hash values differ due to the different
  prefs: []
  type: TYPE_NORMAL
- en: implementation details of the hash functions that produce them. These values
  prefs: []
  type: TYPE_NORMAL
- en: are taken for granted, since we do not want to lose ourselves in the wide
  prefs: []
  type: TYPE_NORMAL
- en: topic of implementation of hash functions.
  prefs: []
  type: TYPE_NORMAL
- en: Cryptographic hash values are quite long and therefore hard to read or to
  prefs: []
  type: TYPE_NORMAL
- en: compare for the human eye. However, in the course of this step, you will
  prefs: []
  type: TYPE_NORMAL
- en: compare different ways of hashing data, which involves reading and comparing
  prefs: []
  type: TYPE_NORMAL
- en: hash values. Doing so with cryptographic hash values will quickly become
  prefs: []
  type: TYPE_NORMAL
- en: a tedious task. Hence, for didactical reasons, I use a shortened version of
  prefs: []
  type: TYPE_NORMAL
- en: the SHA256 cryptographic hash value in the remainder of this step. You can
  prefs: []
  type: TYPE_NORMAL
- en: reproduce all hash values by using the tool provided on the accompanying
  prefs: []
  type: TYPE_NORMAL
- en: 'website: [www.blockchain-basics.com/Hashing.html.](http://www.blockchain-basics.com/Hashing.html)'
  prefs: []
  type: TYPE_NORMAL
- en: When you open that website in your Internet browser, you will see an input box
  prefs: []
  type: TYPE_NORMAL
- en: for simple texts, a button with an arrow that points to an output box, as shown
  prefs: []
  type: TYPE_NORMAL
- en: in Figure [10-2](index_split_001.html#78). When you click the button with the
    arrow, the output box will present the shortened hash value of the text provided
    in the input box.
  prefs: []
  type: TYPE_NORMAL
- en: '**Figure 10-2\.** Calculating the shortened hash value of a text'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-79_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '***Blockchain Basics***'
  prefs: []
  type: TYPE_NORMAL
- en: '75'
  prefs: []
  type: TYPE_NORMAL
- en: Patterns of Hashing Data
  prefs: []
  type: TYPE_NORMAL
- en: So far you have learned that a piece of data can be used as input for a hash
  prefs: []
  type: TYPE_NORMAL
- en: function, which in turn yields the hash value of that data. This implies that
    each independent piece of data has its own unique cryptographic hash value. But
  prefs: []
  type: TYPE_NORMAL
- en: what would you do if you were asked to provide one single hash value for a
  prefs: []
  type: TYPE_NORMAL
- en: bunch of independent pieces of data? Remember, hash functions only accept
  prefs: []
  type: TYPE_NORMAL
- en: one piece of data at a given time. There is no hash function that accepts a
  prefs: []
  type: TYPE_NORMAL
- en: bunch of independent data at once, but, in reality, we often need one single
  prefs: []
  type: TYPE_NORMAL
- en: hash value for a large collection of data. In particular, the blockchain-data-
  prefs: []
  type: TYPE_NORMAL
- en: structure has to deal with many transaction data at once and requires one
  prefs: []
  type: TYPE_NORMAL
- en: single hash value for all of them. How do you deal with this task?
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer is to utilize one of the following patterns in applying hash functions
    to data:'
  prefs: []
  type: TYPE_NORMAL
- en: • Independent hashing
  prefs: []
  type: TYPE_NORMAL
- en: • Repeated hashing
  prefs: []
  type: TYPE_NORMAL
- en: • Combined hashing
  prefs: []
  type: TYPE_NORMAL
- en: • Sequential hashing
  prefs: []
  type: TYPE_NORMAL
- en: • Hierarchical hashing
  prefs: []
  type: TYPE_NORMAL
- en: Independent Hashing
  prefs: []
  type: TYPE_NORMAL
- en: Independent hashing means applying the hash function to each piece of data
  prefs: []
  type: TYPE_NORMAL
- en: independently. Figure [10-3 illustrates this concept b](index_split_001.html#79)y
    calculating the shortened hash value of two distinct words separately.
  prefs: []
  type: TYPE_NORMAL
- en: '**Figure 10-3\.** Schematic illustration of hashing different data independently'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-80_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '76'
  prefs: []
  type: TYPE_NORMAL
- en: '***Step 10 | Hashing Data***'
  prefs: []
  type: TYPE_NORMAL
- en: The white boxes that each contain a word represent the data to be hashed
  prefs: []
  type: TYPE_NORMAL
- en: and the gray circles exhibit the corresponding hash values. The arrows that
  prefs: []
  type: TYPE_NORMAL
- en: point from the boxes to the circles schematically illustrate the transformation
  prefs: []
  type: TYPE_NORMAL
- en: of data into hash values. As one can see in Figure [10-3,](index_split_001.html#79)
    the distinct words yield different hash values.
  prefs: []
  type: TYPE_NORMAL
- en: Repeated Hashing
  prefs: []
  type: TYPE_NORMAL
- en: You have learned that hash functions transform any arbitrary piece of data
  prefs: []
  type: TYPE_NORMAL
- en: into a hash value. A hash value itself can be considered a piece of data. Hence,
    it should be possible to provide a hash value as input to a hash function and
  prefs: []
  type: TYPE_NORMAL
- en: calculate its hash value too. And this in fact works! Repeated hashing is the
  prefs: []
  type: TYPE_NORMAL
- en: repeated application of a hash function to its own outcome. Figure [10-4](index_split_001.html#80)
  prefs: []
  type: TYPE_NORMAL
- en: illustrates the concept by calculating the shortened hash value repeatedly.
  prefs: []
  type: TYPE_NORMAL
- en: The text Hello World! yields the hash value 7F83B165, which in turn yields
  prefs: []
  type: TYPE_NORMAL
- en: the shortened hash value of 45A47BE7\.
  prefs: []
  type: TYPE_NORMAL
- en: '**Figure 10-4\.** Calculating hash values repeatedly'
  prefs: []
  type: TYPE_NORMAL
- en: Combined Hashing
  prefs: []
  type: TYPE_NORMAL
- en: The goal of combined hashing is to get a single hash value for more than one
  prefs: []
  type: TYPE_NORMAL
- en: piece of data in one attempt. Combining all independent pieces of data into
  prefs: []
  type: TYPE_NORMAL
- en: one piece of data and calculating its hash value afterward is the way to achieve
    this. This is in particular useful if you want to create one single hash value
    for a collection of data that is available at a given time. Since combining data
    costs computing power, time, and memory space, combined hashing should only be
  prefs: []
  type: TYPE_NORMAL
- en: used when the individual pieces of data are small. Another drawback of com-
  prefs: []
  type: TYPE_NORMAL
- en: bined hashing is that the hash values of the individual pieces of data are not
  prefs: []
  type: TYPE_NORMAL
- en: available since only the combined data are handed over to the hash function.
  prefs: []
  type: TYPE_NORMAL
- en: Figure [10-5 depicts the concept of combined hashing.](index_split_001.html#81)
    The individual words are first combined into one word with a letter space between
    them and the resulting phrase is hashed afterward. The resulting hash value shown
    in Figure [10-5](index_split_001.html#81)
  prefs: []
  type: TYPE_NORMAL
- en: is consequently identical to the first hash value in Figure [10-4](index_split_001.html#80).
    Note that the
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-81_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '***Blockchain Basics***'
  prefs: []
  type: TYPE_NORMAL
- en: '77'
  prefs: []
  type: TYPE_NORMAL
- en: hash value of the combined data critically depends on the way the data are
  prefs: []
  type: TYPE_NORMAL
- en: combined. In Figure [10-4,](index_split_001.html#80) the two words were combined
    by writing them next to each other with a letter space between them, which consequently
    yields
  prefs: []
  type: TYPE_NORMAL
- en: Hello World! Sometimes specific symbols such as the plus sign (+) or hashtag
  prefs: []
  type: TYPE_NORMAL
- en: sign (#) are used to mark the point where the data are connected, which, as
    a
  prefs: []
  type: TYPE_NORMAL
- en: result, influences the resulting hash value.
  prefs: []
  type: TYPE_NORMAL
- en: '**Figure 10-5\.** Combining data and subsequently calculating the hash value
    Sequential Hashing'
  prefs: []
  type: TYPE_NORMAL
- en: The goal of sequential hashing is the incremental update of a hash value as
  prefs: []
  type: TYPE_NORMAL
- en: new data arrive. This is achieved by using combined and repeated hashing at
  prefs: []
  type: TYPE_NORMAL
- en: the same time. The existing hash value is combined with new data and is then
  prefs: []
  type: TYPE_NORMAL
- en: handed over to the hash function in order to get the updated hash value.
  prefs: []
  type: TYPE_NORMAL
- en: Sequential hashing is in particular useful if you want to maintain a single
    hash value over time and update it as soon as new data arrive. An advantage of
    this
  prefs: []
  type: TYPE_NORMAL
- en: type of hashing is that at any given point in time you have a hash value whose
  prefs: []
  type: TYPE_NORMAL
- en: evolution can be traced back to the arrival of new data.
  prefs: []
  type: TYPE_NORMAL
- en: Figure [10-6](index_split_001.html#82) illustrates the concept of sequential
    hashing by starting with hashing the word Hello individually, which yields the
    shortened hash value
  prefs: []
  type: TYPE_NORMAL
- en: 185F8DB3\. Once new data represented by the word World! arrive, it is
  prefs: []
  type: TYPE_NORMAL
- en: combined with the existing hash value and provided as input to a hash func-
  prefs: []
  type: TYPE_NORMAL
- en: tion. The hash value 5795A986 is the shortened hash value of the input text
  prefs: []
  type: TYPE_NORMAL
- en: World! 185F8DB3\.
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-82_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](index-82_2.png)'
  prefs: []
  type: TYPE_IMG
- en: '78'
  prefs: []
  type: TYPE_NORMAL
- en: '***Step 10 | Hashing Data***'
  prefs: []
  type: TYPE_NORMAL
- en: '**Figure 10-6\.** Calculating hash values sequentially'
  prefs: []
  type: TYPE_NORMAL
- en: Hierarchical Hashing
  prefs: []
  type: TYPE_NORMAL
- en: Figure [10-7 illustrates the concept of hierar](index_split_001.html#82)chical
    hashing.
  prefs: []
  type: TYPE_NORMAL
- en: '**Figure 10-7\.** Calculating hash values hierarchically'
  prefs: []
  type: TYPE_NORMAL
- en: The application of combined hashing to a pair of hash values forms a small
  prefs: []
  type: TYPE_NORMAL
- en: hierarchy of hash values with a single value on its top. Similar to combined
  prefs: []
  type: TYPE_NORMAL
- en: hashing, the idea of hierarchical hashing is the creation of one single hash
  prefs: []
  type: TYPE_NORMAL
- en: value for a collection of data. Hierarchical hashing is more efficient because
    it combines hash values that are always of fixed size instead of the original
    data
  prefs: []
  type: TYPE_NORMAL
- en: that could be of any size. Additionally, hierarchical hashing only combines
    two
  prefs: []
  type: TYPE_NORMAL
- en: hash values in every step, while combined hashing will combine as many data
  prefs: []
  type: TYPE_NORMAL
- en: as you provide in one attempt.
  prefs: []
  type: TYPE_NORMAL
- en: '***Blockchain Basics***'
  prefs: []
  type: TYPE_NORMAL
- en: '79'
  prefs: []
  type: TYPE_NORMAL
- en: Outlook
  prefs: []
  type: TYPE_NORMAL
- en: This step was devoted to the concept of hash functions. Step [11 illustrates](http://dx.doi.org/10.1007/978-1-4842-2604-9_11)
  prefs: []
  type: TYPE_NORMAL
- en: how hash values are used in real life and highlights how the blockchain
  prefs: []
  type: TYPE_NORMAL
- en: uses them.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs: []
  type: TYPE_NORMAL
- en: • Hash functions transform any kind of data into a number
  prefs: []
  type: TYPE_NORMAL
- en: of fixed length, regardless of the size of the input data.
  prefs: []
  type: TYPE_NORMAL
- en: • There are many different hash functions that differ among
  prefs: []
  type: TYPE_NORMAL
- en: others with respect to the length of the hash value they
  prefs: []
  type: TYPE_NORMAL
- en: produce.
  prefs: []
  type: TYPE_NORMAL
- en: • Cryptographic hash functions are an important group of
  prefs: []
  type: TYPE_NORMAL
- en: hash functions that create digital fingerprints for any kind
  prefs: []
  type: TYPE_NORMAL
- en: of data.
  prefs: []
  type: TYPE_NORMAL
- en: • Cryptographic hash functions exhibit the following
  prefs: []
  type: TYPE_NORMAL
- en: 'properties:'
  prefs: []
  type: TYPE_NORMAL
- en: • Provide hash values for any kind of data quickly
  prefs: []
  type: TYPE_NORMAL
- en: • Deterministic
  prefs: []
  type: TYPE_NORMAL
- en: • Pseudorandom
  prefs: []
  type: TYPE_NORMAL
- en: • One-way usage
  prefs: []
  type: TYPE_NORMAL
- en: • Collision resistant
  prefs: []
  type: TYPE_NORMAL
- en: • Application of hash functions to data can be accomplished
  prefs: []
  type: TYPE_NORMAL
- en: 'by using the following patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: • Repeated hashing
  prefs: []
  type: TYPE_NORMAL
- en: • Independent hashing
  prefs: []
  type: TYPE_NORMAL
- en: • Combined hashing
  prefs: []
  type: TYPE_NORMAL
- en: • Sequential hashing
  prefs: []
  type: TYPE_NORMAL
- en: • Hierarchical hashing
  prefs: []
  type: TYPE_NORMAL
- en: '**S T E P**'
  prefs: []
  type: TYPE_NORMAL
- en: '11'
  prefs: []
  type: TYPE_NORMAL
- en: Hashing in the
  prefs: []
  type: TYPE_NORMAL
- en: Real World
  prefs: []
  type: TYPE_NORMAL
- en: A tale of comparing data and creating
  prefs: []
  type: TYPE_NORMAL
- en: computational puzzles
  prefs: []
  type: TYPE_NORMAL
- en: '[Step 10](http://dx.doi.org/10.1007/978-1-4842-2604-9_10) introduced cryptographic
    hash functions and discussed different patterns of applying hash functions to
    data. S[tep 10 ma](http://dx.doi.org/10.1007/978-1-4842-2604-9_10)y have appeared
    to be a dry intellectual exercise, but it is actually of highly practical relevance.
    Hence, this step focuses on the application of hash functions and hash values
    in the real'
  prefs: []
  type: TYPE_NORMAL
- en: world. It considers major use cases of hash functions in real life and explains
  prefs: []
  type: TYPE_NORMAL
- en: the idea behind them. This step also sketches why these use cases work out
  prefs: []
  type: TYPE_NORMAL
- en: as intended. Finally, this step points out where the blockchain uses hash values.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing Data
  prefs: []
  type: TYPE_NORMAL
- en: Because it is the most straightforward use case of hash values, comparing data
  prefs: []
  type: TYPE_NORMAL
- en: based on their hash values is considered first.
  prefs: []
  type: TYPE_NORMAL
- en: The Goal
  prefs: []
  type: TYPE_NORMAL
- en: The goal is to compare data (e.g., files or transaction data) without comparing
  prefs: []
  type: TYPE_NORMAL
- en: their content piece by piece and to make comparing any kind of data, regard-
  prefs: []
  type: TYPE_NORMAL
- en: less of their size and content, as easy as comparing two numbers.
  prefs: []
  type: TYPE_NORMAL
- en: © Daniel Drescher 2017
  prefs: []
  type: TYPE_NORMAL
- en: D. Drescher, *Blockchain Basics*, DOI 10.1007/978-1-4842-2604-9_11
  prefs: []
  type: TYPE_NORMAL
- en: '82'
  prefs: []
  type: TYPE_NORMAL
- en: '***Step 11 | Hashing in the Real World***'
  prefs: []
  type: TYPE_NORMAL
- en: The Idea
  prefs: []
  type: TYPE_NORMAL
- en: Instead of comparing data by explicitly comparing their content piece by piece,
  prefs: []
  type: TYPE_NORMAL
- en: you compare their cryptographic hash values.
  prefs: []
  type: TYPE_NORMAL
- en: How It Works
  prefs: []
  type: TYPE_NORMAL
- en: You calculate and compare the cryptographic hash value of all data under
  prefs: []
  type: TYPE_NORMAL
- en: consideration. If all of the cryptographic hash values differ, all the data
  prefs: []
  type: TYPE_NORMAL
- en: under consideration differ as well. If two or more of the cryptographic hash
  prefs: []
  type: TYPE_NORMAL
- en: values are identical, their corresponding input data ar[e also identical.1](index_split_001.html#85)
  prefs: []
  type: TYPE_NORMAL
- en: Why It Works
  prefs: []
  type: TYPE_NORMAL
- en: Comparing data by comparing their cryptographic hash values works due to
  prefs: []
  type: TYPE_NORMAL
- en: collision resistance of cryptographic hash functions.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting Changes in Data
  prefs: []
  type: TYPE_NORMAL
- en: The idea of comparing data based on their hash values can be easily extended
  prefs: []
  type: TYPE_NORMAL
- en: to the case of detecting changes.
  prefs: []
  type: TYPE_NORMAL
- en: The Goal
  prefs: []
  type: TYPE_NORMAL
- en: The goal is to determine whether data (e.g., a file or transaction data) that
    is supposed to stay unchanged was changed after a certain date or after sending
  prefs: []
  type: TYPE_NORMAL
- en: it to someone or after it was stored in a database.
  prefs: []
  type: TYPE_NORMAL
- en: The Idea
  prefs: []
  type: TYPE_NORMAL
- en: Comparing the cryptographic hash value of the data under consideration that
  prefs: []
  type: TYPE_NORMAL
- en: was created in the past with a newly created cryptographic hash value of the
  prefs: []
  type: TYPE_NORMAL
- en: same data is the key in identifying changes. If both hash values are identical,
    the data were not changed after the time at which the old hash value was created.
  prefs: []
  type: TYPE_NORMAL
- en: How It Works
  prefs: []
  type: TYPE_NORMAL
- en: You create the cryptographic hash value of the data that are supposed to stay
  prefs: []
  type: TYPE_NORMAL
- en: unchanged. When you need to verify whether the data were changed at a
  prefs: []
  type: TYPE_NORMAL
- en: later time, you create the cryptographic hash value of the data again. You then
  prefs: []
  type: TYPE_NORMAL
- en: compare the newly created hash value with the hash value that was created
  prefs: []
  type: TYPE_NORMAL
- en: 1Tsudik, Gene. Message authentication with one-way hash functions. *ACM SIGCOMM*
  prefs: []
  type: TYPE_NORMAL
- en: '*Computer Communication Review* 22.5 (1992): 29–38\.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Blockchain Basics***'
  prefs: []
  type: TYPE_NORMAL
- en: '83'
  prefs: []
  type: TYPE_NORMAL
- en: in the past. If both hash values are identical, the data were not changed after
  prefs: []
  type: TYPE_NORMAL
- en: the first hash value was created. Otherwise, the data have been changed in
  prefs: []
  type: TYPE_NORMAL
- en: the meantime. The same idea can be applied when sending data to someone.
  prefs: []
  type: TYPE_NORMAL
- en: If you create the hash value of the data before they are sent and the receiver
  prefs: []
  type: TYPE_NORMAL
- en: creates the hash value of the data he or she receives, both the sender and the
  prefs: []
  type: TYPE_NORMAL
- en: receiver compare both hash values. If both hash values are identical, the data
  prefs: []
  type: TYPE_NORMAL
- en: were not altered in the course of the transfer.
  prefs: []
  type: TYPE_NORMAL
- en: Why It Works
  prefs: []
  type: TYPE_NORMAL
- en: Detecting changes in data is actually a process of comparing data with them-
  prefs: []
  type: TYPE_NORMAL
- en: selves before and after certain events, such as lapses of time, storing to or
  prefs: []
  type: TYPE_NORMAL
- en: retrieval from a database, or sending them through a network. Detecting
  prefs: []
  type: TYPE_NORMAL
- en: changes in data that are supposed to stay unchanged works due to collision
  prefs: []
  type: TYPE_NORMAL
- en: resistance of cryptographic hash functions.
  prefs: []
  type: TYPE_NORMAL
- en: Referring to Data in a Change-Sensitive
  prefs: []
  type: TYPE_NORMAL
- en: Manner
  prefs: []
  type: TYPE_NORMAL
- en: Comparing data and detecting changes based on their hash values can be con-
  prefs: []
  type: TYPE_NORMAL
- en: sidered basic use cases of hash values. A slightly more advanced application
  prefs: []
  type: TYPE_NORMAL
- en: case of hash values is hash references, which are introduced in the following.
  prefs: []
  type: TYPE_NORMAL
- en: The Goal
  prefs: []
  type: TYPE_NORMAL
- en: The goal is to refer to data (e.g., transaction data) that are stored somewhere
  prefs: []
  type: TYPE_NORMAL
- en: else (e.g., on a hard disk or in a database) and ensure that the data have remain
    unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: The Idea
  prefs: []
  type: TYPE_NORMAL
- en: The idea is to combine the cryptographic hash value of the data being stored
  prefs: []
  type: TYPE_NORMAL
- en: with information about the place where the data are located. If the data were
  prefs: []
  type: TYPE_NORMAL
- en: changed, both pieces of information would no longer be consistent and hence
  prefs: []
  type: TYPE_NORMAL
- en: the hash reference would become invalid.
  prefs: []
  type: TYPE_NORMAL
- en: How It Works
  prefs: []
  type: TYPE_NORMAL
- en: References to data are the digital equivalent to cloakroom tickets. Cloakroom
  prefs: []
  type: TYPE_NORMAL
- en: tickets point to the physical location at which your jacket is stored in the
  prefs: []
  type: TYPE_NORMAL
- en: cloakroom. You use the cloakroom ticket for retrieving your jacket later
  prefs: []
  type: TYPE_NORMAL
- en: 'on. References to data in computers work the same way: they are pieces of'
  prefs: []
  type: TYPE_NORMAL
- en: data that refer to other data. Computer programs use references in order to
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-87_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '84'
  prefs: []
  type: TYPE_NORMAL
- en: '***Step 11 | Hashing in the Real World***'
  prefs: []
  type: TYPE_NORMAL
- en: remember the place where the data have been stored and to retrieve them
  prefs: []
  type: TYPE_NORMAL
- en: later on. Hash references are a specific kind of reference that utilize the
    power of cryptographic hash values. For simplicity, you could think of hash references
    as cloakroom tickets that display hash values instead of ordinary numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Hash references refer to other data, and they additionally verify that the data
  prefs: []
  type: TYPE_NORMAL
- en: being referred to were not changed since the reference was created. In the
  prefs: []
  type: TYPE_NORMAL
- en: case where the data being referred have been changed, the reference no lon-
  prefs: []
  type: TYPE_NORMAL
- en: ger allows retrieval of the data. In this case, the hash reference is deemed
    broken or invalid. This is similar to having a cloakroom ticket that points to
    a coat hook that no longer carries your jacket. In this case, the cloakroom attendant
  prefs: []
  type: TYPE_NORMAL
- en: can no longer hand over your jacket.
  prefs: []
  type: TYPE_NORMAL
- en: The whole idea of hash reference is to protect its users from retrieving data
  prefs: []
  type: TYPE_NORMAL
- en: that have been changed accidently due to technical errors or intentionally by
  prefs: []
  type: TYPE_NORMAL
- en: someone else without informing you about that. Hence, hash references are
  prefs: []
  type: TYPE_NORMAL
- en: used in all occasions where data are supposed to stay unchanged once created.
  prefs: []
  type: TYPE_NORMAL
- en: A Schematic Illustration
  prefs: []
  type: TYPE_NORMAL
- en: The blockchain heavily depends on hash references. Hence, understanding
  prefs: []
  type: TYPE_NORMAL
- en: them is crucial for understanding the blockchain and for comprehending the
  prefs: []
  type: TYPE_NORMAL
- en: 'following steps of this book. For this reason, the following three figures
    serve two purposes: First, they schematically illustrate the functioning of hash
    references. Second, they introduce a pictorial representation of hash references'
  prefs: []
  type: TYPE_NORMAL
- en: that is used in the following steps when illustrating the functioning of the
  prefs: []
  type: TYPE_NORMAL
- en: blockchain-data-structure.
  prefs: []
  type: TYPE_NORMAL
- en: Figure [11-1 illustrates the functioning of hash r](index_split_001.html#87)eferences
    schematically by presenting a valid hash reference. The gray circle labeled R1
    represents a valid
  prefs: []
  type: TYPE_NORMAL
- en: hash reference. The white box represents some data that are supposed to
  prefs: []
  type: TYPE_NORMAL
- en: stay unchanged. The arrow that goes from the circle to the box depicts the
  prefs: []
  type: TYPE_NORMAL
- en: functioning of the hash reference. The arrow points from the reference to the
  prefs: []
  type: TYPE_NORMAL
- en: data it refers to.
  prefs: []
  type: TYPE_NORMAL
- en: '**Figure 11-1\.** Schematic illustration of a valid hash reference'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-88_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](index-88_2.png)'
  prefs: []
  type: TYPE_IMG
- en: '***Blockchain Basics***'
  prefs: []
  type: TYPE_NORMAL
- en: '85'
  prefs: []
  type: TYPE_NORMAL
- en: Figure [11-2](index_split_001.html#88) illustrates the symbolic representation
    of a broken or invalid hash reference.
  prefs: []
  type: TYPE_NORMAL
- en: '**Figure 11-2\.** Schematic illustration of an invalid hash reference'
  prefs: []
  type: TYPE_NORMAL
- en: The black box containing a modified greeting represents data that were altered
  prefs: []
  type: TYPE_NORMAL
- en: after the reference was created. The gray circle still represents the originally
    created hash reference. The jacked arrow that points from the circle to the
  prefs: []
  type: TYPE_NORMAL
- en: altered box highlights that the hash reference R1 is broken, it no longer allows
    access to retrieve the data because they have been changed in the meantime.
  prefs: []
  type: TYPE_NORMAL
- en: Figure [11-3](index_split_001.html#88) illustrates the situation when a new
    hash reference was created after the data were changed. This situation is depicted
    by a black box representing altered data, a black circle representing a newly
    created hash reference, and the straight arrow pointing from the circle to the
    box.
  prefs: []
  type: TYPE_NORMAL
- en: '**Figure 11-3\.** Schematic illustration of a newly created hash reference
    after altering the data being referred'
  prefs: []
  type: TYPE_NORMAL
- en: '86'
  prefs: []
  type: TYPE_NORMAL
- en: '***Step 11 | Hashing in the Real World***'
  prefs: []
  type: TYPE_NORMAL
- en: Why It Works
  prefs: []
  type: TYPE_NORMAL
- en: The key point of hash references is the fact that they utilize cryptographic
  prefs: []
  type: TYPE_NORMAL
- en: hash values, which can be seen as unique fingerprints of data. Hence, it is
    very unlikely to have two different pieces of data that have an identical hash
    value.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, a broken hash reference is considered to be evidence that the data
  prefs: []
  type: TYPE_NORMAL
- en: were altered after the hash reference was created.
  prefs: []
  type: TYPE_NORMAL
- en: Storing Data in a Change-Sensitive Manner
  prefs: []
  type: TYPE_NORMAL
- en: The idea of referring to data based on their hash values can be extended
  prefs: []
  type: TYPE_NORMAL
- en: further. A natural extension of that idea is storing data in a change-sensitive
  prefs: []
  type: TYPE_NORMAL
- en: manner.
  prefs: []
  type: TYPE_NORMAL
- en: The Goal
  prefs: []
  type: TYPE_NORMAL
- en: The goal is to store a large amount of data e.g., transaction data that are
  prefs: []
  type: TYPE_NORMAL
- en: supposed to stay unchanged. Any changes to these data are to be detected
  prefs: []
  type: TYPE_NORMAL
- en: quickly and easily.
  prefs: []
  type: TYPE_NORMAL
- en: The Idea
  prefs: []
  type: TYPE_NORMAL
- en: Cloakroom tickets point to coat hooks that carry jackets. This is simple and
  prefs: []
  type: TYPE_NORMAL
- en: straightforward. But what precludes you from putting a cloakroom ticket in
  prefs: []
  type: TYPE_NORMAL
- en: the pocket of another jacket and storing that second jacket in the cloakroom
  prefs: []
  type: TYPE_NORMAL
- en: as well? As a result, the latter cloakroom ticket points to a jacket that contains
    a cloakroom ticket, which in turn points to another jacket. Actually you can
  prefs: []
  type: TYPE_NORMAL
- en: create long and complicated chains of jackets that have cloakroom tickets
  prefs: []
  type: TYPE_NORMAL
- en: in their pockets, which point to other jackets, which also have a cloakroom
  prefs: []
  type: TYPE_NORMAL
- en: ticket in their pockets, and so on and so forth. In a similar fashion, one can
  prefs: []
  type: TYPE_NORMAL
- en: store data together with hash references that point to other data, which in
  prefs: []
  type: TYPE_NORMAL
- en: turn store hash reference that refer to further data, and so on and so forth.
  prefs: []
  type: TYPE_NORMAL
- en: If any of the data or hash references is changed after their creation, all the
  prefs: []
  type: TYPE_NORMAL
- en: hash references are broken. Since broken hash references serve as evidence
  prefs: []
  type: TYPE_NORMAL
- en: that data were changed after the reference was created, the whole construct
  prefs: []
  type: TYPE_NORMAL
- en: stores data in a change-sensitive manner.
  prefs: []
  type: TYPE_NORMAL
- en: How It Works
  prefs: []
  type: TYPE_NORMAL
- en: There are two classical patterns of using hash references in order to store
  prefs: []
  type: TYPE_NORMAL
- en: 'data in a change-sensitive manner:'
  prefs: []
  type: TYPE_NORMAL
- en: • The chain
  prefs: []
  type: TYPE_NORMAL
- en: • The tree
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-90_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '***Blockchain Basics***'
  prefs: []
  type: TYPE_NORMAL
- en: '87'
  prefs: []
  type: TYPE_NORMAL
- en: The Chain
  prefs: []
  type: TYPE_NORMAL
- en: A chain of linked data, also called a linked list, [2](index_split_001.html#90)
    is formed when each piece of data also contains a hash reference to another piece
    of data. Such a structure is useful for storing and linking data together that
    are not fully available at one given point in time but instead arrive step by
    step in an ongoing fashion. Figure [11-4 illustrates this idea b](index_split_001.html#90)y
    using the symbols introduced above.
  prefs: []
  type: TYPE_NORMAL
- en: The creation of such a chain starts with the piece of data labeled Data 1 and
  prefs: []
  type: TYPE_NORMAL
- en: the creation of the hash reference R1\. Being the first piece of data, Data
    1
  prefs: []
  type: TYPE_NORMAL
- en: does not contain any hash reference. When new data arrive, they are put
  prefs: []
  type: TYPE_NORMAL
- en: together with the hash reference that points to Data 1\. The hash reference
  prefs: []
  type: TYPE_NORMAL
- en: R2 refers to the newly arrived data and the hash reference R1\. The hash
  prefs: []
  type: TYPE_NORMAL
- en: reference R3, which refers to Data 3 and the hash reference R2, is created
  prefs: []
  type: TYPE_NORMAL
- en: in a similar fashion.
  prefs: []
  type: TYPE_NORMAL
- en: '**Figure 11-4\.** Data linked together in a chain-like fashion'
  prefs: []
  type: TYPE_NORMAL
- en: Hash reference R3 is all you need in order to access all the data in the chain
  prefs: []
  type: TYPE_NORMAL
- en: in the reverse order of their arrival. The reference R3 is also called the **head**
    **of the chain** because it refers to the most currently added piece of data.
    It is important not to mix up the term “**head**” (that is the most currently
    added piece of data) with the term “**header**”, which will be intr[oduced in
    Step 14](http://dx.doi.org/10.1007/978-1-4842-2604-9_14)
  prefs: []
  type: TYPE_NORMAL
- en: when we discuss the blockchain-data-structure.
  prefs: []
  type: TYPE_NORMAL
- en: The Tree
  prefs: []
  type: TYPE_NORMAL
- en: Figure [11-5 illustrates ho](index_split_001.html#91)w transaction data can
    be linked together with hash references in a tree-like fashion.
  prefs: []
  type: TYPE_NORMAL
- en: '2Cormen, Thomas H. *Introduction to algorithms* (3rd ed.). Cambridge: MIT Press,
    2009\.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-91_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '88'
  prefs: []
  type: TYPE_NORMAL
- en: '***Step 11 | Hashing in the Real World***'
  prefs: []
  type: TYPE_NORMAL
- en: '**Figure 11-5\.** Data linked together in a tree-like fashion'
  prefs: []
  type: TYPE_NORMAL
- en: Such a structure is also called a Merkle tree[3](index_split_001.html#91) because
    a computer scientist named Merkle proposed it and it looks like a tree that was
    turn upside down.
  prefs: []
  type: TYPE_NORMAL
- en: It is very useful for grouping many distinct pieces of data that are available
  prefs: []
  type: TYPE_NORMAL
- en: at the same time and to make them accessible via a single hash reference.
  prefs: []
  type: TYPE_NORMAL
- en: In order to create the tree illustrated in Figure [11-5,](index_split_001.html#91)
    you start with the four transaction data represented by the boxes at the bottom
    of the figure. At first
  prefs: []
  type: TYPE_NORMAL
- en: the hash references to the individual transaction data are created (R1 to R4),
  prefs: []
  type: TYPE_NORMAL
- en: which are grouped together in a pair-wise fashion afterward. Subsequently,
  prefs: []
  type: TYPE_NORMAL
- en: hash references to the pairs of hash references are created (R12 and R34).
  prefs: []
  type: TYPE_NORMAL
- en: This procedure is repeated until you eventually arrive at a single hash refer-
  prefs: []
  type: TYPE_NORMAL
- en: ence, which is also called the root of the Merkle tree (labeled R).
  prefs: []
  type: TYPE_NORMAL
- en: Why It Works
  prefs: []
  type: TYPE_NORMAL
- en: The explained data structures store data in a change-sensitive fashion because
  prefs: []
  type: TYPE_NORMAL
- en: they connect and combine data with hash references. These references get
  prefs: []
  type: TYPE_NORMAL
- en: broken when the data they refer to are changed after the references were
  prefs: []
  type: TYPE_NORMAL
- en: created. Hence, observing a broken reference in such a construct is proof that
  prefs: []
  type: TYPE_NORMAL
- en: some of the data were changed after the structure was created. Otherwise,
  prefs: []
  type: TYPE_NORMAL
- en: it could be concluded that the whole construct has not been changed since
  prefs: []
  type: TYPE_NORMAL
- en: it was created.
  prefs: []
  type: TYPE_NORMAL
- en: 3Merkle, Ralph C. Protocols for Public Key Cryptosystems. *IEEE Symposium on
    Security and* *Privacy* 122 (1980).
  prefs: []
  type: TYPE_NORMAL
- en: '***Blockchain Basics***'
  prefs: []
  type: TYPE_NORMAL
- en: '89'
  prefs: []
  type: TYPE_NORMAL
- en: Causing Time-Consuming Computations
  prefs: []
  type: TYPE_NORMAL
- en: Hash values are not only useful for making basic file operations such as com-
  prefs: []
  type: TYPE_NORMAL
- en: paring, referring and storing data secure and efficient. Hash values can also
  prefs: []
  type: TYPE_NORMAL
- en: be used to allow computers to challenge other computers with elaborate
  prefs: []
  type: TYPE_NORMAL
- en: puzzles. While this may sound a bit odd it will turn out that this usage of
    hash values is one of the most important concept of the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: The Goal
  prefs: []
  type: TYPE_NORMAL
- en: For reasons that will become understandable in later steps of this book, you
  prefs: []
  type: TYPE_NORMAL
- en: may need to create puzzles that require computational resources in order to
  prefs: []
  type: TYPE_NORMAL
- en: be solved. It should not be possible to solve these puzzles based on knowl-
  prefs: []
  type: TYPE_NORMAL
- en: edge or data stored somewhere or by means of thinking, like an IQ test or a
  prefs: []
  type: TYPE_NORMAL
- en: knowledge test. The only way to solve these puzzle is by sheer computational
  prefs: []
  type: TYPE_NORMAL
- en: power and hard computational work.
  prefs: []
  type: TYPE_NORMAL
- en: The Idea
  prefs: []
  type: TYPE_NORMAL
- en: A combination lock is a specific lock that requires a unique sequence of num-
  prefs: []
  type: TYPE_NORMAL
- en: bers in order for it to be opened. If you do not know the sequence that opens
  prefs: []
  type: TYPE_NORMAL
- en: the lock, you would systematically try all possible combinations until you
  prefs: []
  type: TYPE_NORMAL
- en: eventually arrived at the unique combination that opens the lock. This proce-
  prefs: []
  type: TYPE_NORMAL
- en: dure is guaranteed to open the lock, but it is time-consuming. Systematically
  prefs: []
  type: TYPE_NORMAL
- en: trying all possible combinations has nothing to do with knowledge or intel-
  prefs: []
  type: TYPE_NORMAL
- en: lectual reasoning. The approach of opening a combination lock is based on
  prefs: []
  type: TYPE_NORMAL
- en: sheer diligence and hard work. Hash puzzles are computational puzzles that
  prefs: []
  type: TYPE_NORMAL
- en: can be seen as the digital equivalent to the task of opening a combination lock
  prefs: []
  type: TYPE_NORMAL
- en: by trial and error.
  prefs: []
  type: TYPE_NORMAL
- en: How It Works
  prefs: []
  type: TYPE_NORMAL
- en: Elements of a hash puzzle are[4:](index_split_001.html#92)
  prefs: []
  type: TYPE_NORMAL
- en: • Given data that have to be kept unchanged
  prefs: []
  type: TYPE_NORMAL
- en: • Data that can be freely changed, the so-called nonce
  prefs: []
  type: TYPE_NORMAL
- en: • The hash function to be applied
  prefs: []
  type: TYPE_NORMAL
- en: • Restrictions on the hash value of the combined hashing,
  prefs: []
  type: TYPE_NORMAL
- en: also called the difficulty level
  prefs: []
  type: TYPE_NORMAL
- en: 4Back, Adam. Hashcash—a denial of service counter-measure. 2002\. [http://www.hashcash.](http://www.hashcash.org/papers/hashcash.pdf)
  prefs: []
  type: TYPE_NORMAL
- en: '[org/papers/hashcash.pdf](http://www.hashcash.org/papers/hashcash.pdf).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-93_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '90'
  prefs: []
  type: TYPE_NORMAL
- en: '***Step 11 | Hashing in the Real World***'
  prefs: []
  type: TYPE_NORMAL
- en: Figure [11-6](index_split_001.html#93) illustrates the setting of the hash puzzle.
    Combined hashing is applied to the data and the nonce. The resulting hash value
    has to fulfill the
  prefs: []
  type: TYPE_NORMAL
- en: given restrictions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Figure 11-6\.** Schematic illustration of a hash puzzle'
  prefs: []
  type: TYPE_NORMAL
- en: Hash puzzles can only be solved by trial and error. This requires guessing a
  prefs: []
  type: TYPE_NORMAL
- en: nonce, calculating the hash value of the combined data with the required hash
  prefs: []
  type: TYPE_NORMAL
- en: function, and evaluating the resulting hash value based on the restrictions.
    If
  prefs: []
  type: TYPE_NORMAL
- en: the hash value satisfies the restrictions, you will have solved the hash puzzle;
    otherwise, you would continue with another nonce until you eventually solve
  prefs: []
  type: TYPE_NORMAL
- en: the puzzle. The nonce that, when combined with the given data, yields a hash
  prefs: []
  type: TYPE_NORMAL
- en: value that satisfies the restrictions is called the solution. You always have
    to present that particular nonce when claiming that you solved a hash puzzle.
  prefs: []
  type: TYPE_NORMAL
- en: An Illustrative Example
  prefs: []
  type: TYPE_NORMAL
- en: Let’s consider a real hash puzzle for illustrating its functioning. In S[tep
    10 y](http://dx.doi.org/10.1007/978-1-4842-2604-9_10)ou saw that the shortened
    hash value of Hello World! is 7F83B165\. But what data
  prefs: []
  type: TYPE_NORMAL
- en: combined with Hello World! would yield a shortened hash value with three
  prefs: []
  type: TYPE_NORMAL
- en: 'leading zeros? So the hash puzzle is: Find the nonce that combined with Hello'
  prefs: []
  type: TYPE_NORMAL
- en: World! yields a shortened hash value that starts with three leading zeros.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s get our hands dirty and try some nonce. Table [11-1](index_split_001.html#94)
    shows the nonce, the text to be hashed, and the resulting shortened hash value.
    As you can see,
  prefs: []
  type: TYPE_NORMAL
- en: the nonce 614 solves the hash puzzle, which implies that starting with a nonce
  prefs: []
  type: TYPE_NORMAL
- en: 0 and incrementing sequentially by 1 you would need 615 steps to find the
  prefs: []
  type: TYPE_NORMAL
- en: solution. If the restriction were to find a hash value with one leading zero,
    you would have solved it already after four steps, since Hello World! 3 yields
    a
  prefs: []
  type: TYPE_NORMAL
- en: hash value with one leading zero.
  prefs: []
  type: TYPE_NORMAL
- en: '***Blockchain Basics***'
  prefs: []
  type: TYPE_NORMAL
- en: '91'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 11-1\.** Nonces for Solving a Hash Puzzle'
  prefs: []
  type: TYPE_NORMAL
- en: '**Nonce**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Text to Be Hashed**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Output**'
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: Hello World! 0
  prefs: []
  type: TYPE_NORMAL
- en: 4EE4B774
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: Hello World! 1
  prefs: []
  type: TYPE_NORMAL
- en: 3345B9A3
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: Hello World! 2
  prefs: []
  type: TYPE_NORMAL
- en: '72040842'
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: Hello World! 3
  prefs: []
  type: TYPE_NORMAL
- en: 02307D5F
  prefs: []
  type: TYPE_NORMAL
- en: …
  prefs: []
  type: TYPE_NORMAL
- en: '613'
  prefs: []
  type: TYPE_NORMAL
- en: Hello World! 613
  prefs: []
  type: TYPE_NORMAL
- en: E861901E
  prefs: []
  type: TYPE_NORMAL
- en: '614'
  prefs: []
  type: TYPE_NORMAL
- en: Hello World! 614
  prefs: []
  type: TYPE_NORMAL
- en: '**00068A3C**'
  prefs: []
  type: TYPE_NORMAL
- en: '615'
  prefs: []
  type: TYPE_NORMAL
- en: Hello World! 615
  prefs: []
  type: TYPE_NORMAL
- en: 5EB7483F
  prefs: []
  type: TYPE_NORMAL
- en: You can try this y[ourself at www.blockchain-basics.com/HashPuzzle.](http://www.blockchain-basics.com/HashPuzzle.html)
  prefs: []
  type: TYPE_NORMAL
- en: '[html](http://www.blockchain-basics.com/HashPuzzle.html).'
  prefs: []
  type: TYPE_NORMAL
- en: The Difficulty Level
  prefs: []
  type: TYPE_NORMAL
- en: Requiring the hash value to fulfill a certain restriction is the core of the
    hash puzzle. Hence, neither the restriction nor its description is arbitrary.
    Instead, the restriction used by hash puzzles is standardized so that computers
    can
  prefs: []
  type: TYPE_NORMAL
- en: challenge other computers with hash puzzles. In the context of hash puzzles,
  prefs: []
  type: TYPE_NORMAL
- en: the restrictions are often called *difficulty* or *difficulty* *level*, respectively.
    The difficulty is expressed as a natural number and refers to the number of leading
  prefs: []
  type: TYPE_NORMAL
- en: zeros the hash value has to have. Hence, a difficulty of 1 means that the hash
  prefs: []
  type: TYPE_NORMAL
- en: value has to have (at least) one leading zero, while a difficulty of 10 means
    that the hash value has to have at least 10 leading zeros. The higher the difficulty
  prefs: []
  type: TYPE_NORMAL
- en: level, the more leading zeros are required and the more complicated the hash
  prefs: []
  type: TYPE_NORMAL
- en: puzzle is. The more complicated the hash puzzle is, the more computational
  prefs: []
  type: TYPE_NORMAL
- en: power or time are needed to solve it.
  prefs: []
  type: TYPE_NORMAL
- en: Why It Works
  prefs: []
  type: TYPE_NORMAL
- en: The functioning of hash puzzles critically depends on the fact that hash
  prefs: []
  type: TYPE_NORMAL
- en: functions are one-way functions. It is not possible to solve a hash puzzle by
  prefs: []
  type: TYPE_NORMAL
- en: inspecting the restrictions that the hash value has to fulfill and applying
    the
  prefs: []
  type: TYPE_NORMAL
- en: hash function in the opposite direction afterward (i.e., going from the desired
  prefs: []
  type: TYPE_NORMAL
- en: output to the required input). Hash puzzles can only be solved by trial and
  prefs: []
  type: TYPE_NORMAL
- en: error, which consumes a lot of computing power and hence a lot of time and
  prefs: []
  type: TYPE_NORMAL
- en: energy. The level of difficulty directly influences the number of trials needed
  prefs: []
  type: TYPE_NORMAL
- en: on average for finding the solution, which in turn influences the computational
  prefs: []
  type: TYPE_NORMAL
- en: resources or the time needed to find the solution.
  prefs: []
  type: TYPE_NORMAL
- en: '92'
  prefs: []
  type: TYPE_NORMAL
- en: '***Step 11 | Hashing in the Real World***'
  prefs: []
  type: TYPE_NORMAL
- en: Hash functions are deterministic and quickly produce hash values for any kind
  prefs: []
  type: TYPE_NORMAL
- en: of data. Hence, once a solution is found, it is easy to verify that the data
    combined with the nonce indeed yield a hash value that satisfies the restrictions.
    If the calculated value does not satisfy the restriction, the hash function cannot
  prefs: []
  type: TYPE_NORMAL
- en: be blamed because the deviation is only caused by the fact that the puzzle has
  prefs: []
  type: TYPE_NORMAL
- en: not been solved.
  prefs: []
  type: TYPE_NORMAL
- en: ■ **Note** In the context of the blockchain, hash puzzles are often called *proof
    of work*, as their solution proves that someone has done the work necessary to
    solve it.
  prefs: []
  type: TYPE_NORMAL
- en: Usage of Hashing in the Blockchain
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the blockchain, hashing is used in the following instances:'
  prefs: []
  type: TYPE_NORMAL
- en: • Storing transaction data in a change-sensitive manner
  prefs: []
  type: TYPE_NORMAL
- en: • As a digital fingerprint of transaction data
  prefs: []
  type: TYPE_NORMAL
- en: • As a way to incur computational costs for changing the
  prefs: []
  type: TYPE_NORMAL
- en: blockchain-data-structure
  prefs: []
  type: TYPE_NORMAL
- en: Outlook
  prefs: []
  type: TYPE_NORMAL
- en: This step explained major use cases of hash values and sketched their usage
  prefs: []
  type: TYPE_NORMAL
- en: in the blockchain. The next steps will discuss in greater detail the way hashing
    is utilized by the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs: []
  type: TYPE_NORMAL
- en: '• Hash values can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: • To compare data
  prefs: []
  type: TYPE_NORMAL
- en: • To detect whether data that were supposed to stay
  prefs: []
  type: TYPE_NORMAL
- en: unchanged have been altered
  prefs: []
  type: TYPE_NORMAL
- en: • To refer to data in a change-sensitive manner
  prefs: []
  type: TYPE_NORMAL
- en: • To store a collection of data in a change-sensitive manner
  prefs: []
  type: TYPE_NORMAL
- en: • To create computationally expensive tasks
  prefs: []
  type: TYPE_NORMAL
- en: '**S T E P**'
  prefs: []
  type: TYPE_NORMAL
- en: '12'
  prefs: []
  type: TYPE_NORMAL
- en: Identifying and
  prefs: []
  type: TYPE_NORMAL
- en: Protecting User
  prefs: []
  type: TYPE_NORMAL
- en: Accounts
  prefs: []
  type: TYPE_NORMAL
- en: A gentle introduction to cryptography
  prefs: []
  type: TYPE_NORMAL
- en: Besides hash functions, the blockchain uses another base technology exten-
  prefs: []
  type: TYPE_NORMAL
- en: 'sively: asymmetric cryptography. It is the foundation for identifying users
    in the blockchain and protecting their property. Cryptography is often considered'
  prefs: []
  type: TYPE_NORMAL
- en: complicated and hard to understand. Hence, this step focuses on introducing
  prefs: []
  type: TYPE_NORMAL
- en: cryptography in a gentle way that is easy to comprehend and sufficient for
  prefs: []
  type: TYPE_NORMAL
- en: understanding the security concept of the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: The Metaphor
  prefs: []
  type: TYPE_NORMAL
- en: Long before e-mails, facsimiles, telephones, and chat apps were invented,
  prefs: []
  type: TYPE_NORMAL
- en: people used conventional mail to send messages. Along with its modern
  prefs: []
  type: TYPE_NORMAL
- en: competitors, conventional mail still exists and is still used by many people.
  prefs: []
  type: TYPE_NORMAL
- en: Conventional letters are still delivered by postal employees, who deliver let-
  prefs: []
  type: TYPE_NORMAL
- en: ters by putting them in the mailboxes of the addressees. Mailboxes functioning
  prefs: []
  type: TYPE_NORMAL
- en: like trapdoors. By design, it is easy to insert a letter through the letter
    slot, but
  prefs: []
  type: TYPE_NORMAL
- en: © Daniel Drescher 2017
  prefs: []
  type: TYPE_NORMAL
- en: D. Drescher, *Blockchain Basics*, DOI 10.1007/978-1-4842-2604-9_12
  prefs: []
  type: TYPE_NORMAL
- en: '94'
  prefs: []
  type: TYPE_NORMAL
- en: '***Step 12 | Identifying and Protecting User Accounts***'
  prefs: []
  type: TYPE_NORMAL
- en: it is very hard to pull a letter out that way because taking out letters is
    sup-
  prefs: []
  type: TYPE_NORMAL
- en: posed to be done only by the addressee who owns the key necessary to open
  prefs: []
  type: TYPE_NORMAL
- en: the mailbox. This concept has been used for a very long time and we still use
    a
  prefs: []
  type: TYPE_NORMAL
- en: similar concept when we send an e-mail to an e-mail address, when we send a
  prefs: []
  type: TYPE_NORMAL
- en: message in the latest chat app, or when we transfer money to a bank account.
  prefs: []
  type: TYPE_NORMAL
- en: In all these cases, the security concept is based on a separation of two kinds
  prefs: []
  type: TYPE_NORMAL
- en: 'of information: first, publicly known information that serves as an address
    to a trapdoor-like box; and second, private information that serves as the key
    for'
  prefs: []
  type: TYPE_NORMAL
- en: opening the box and accessing the things it contains. The blockchain applies
  prefs: []
  type: TYPE_NORMAL
- en: the same concept when protecting private data. Hence, keeping this metaphor
  prefs: []
  type: TYPE_NORMAL
- en: in mind may provide some guidance on your way in learning about the world
  prefs: []
  type: TYPE_NORMAL
- en: of cryptography.
  prefs: []
  type: TYPE_NORMAL
- en: The Goal
  prefs: []
  type: TYPE_NORMAL
- en: The goal is to identify owners and property uniquely and to ensure that only
  prefs: []
  type: TYPE_NORMAL
- en: the lawful owner can access his or her property.
  prefs: []
  type: TYPE_NORMAL
- en: The Challenge
  prefs: []
  type: TYPE_NORMAL
- en: The blockchain is a peer-to-peer system that is open to everyone. Everyone
  prefs: []
  type: TYPE_NORMAL
- en: can connect and contribute computational resources or submit new transac-
  prefs: []
  type: TYPE_NORMAL
- en: tion data to the system. However, it is not desirable for everyone to access
    the property assigned to the accounts managed by the blockchain. A constituting
  prefs: []
  type: TYPE_NORMAL
- en: characteristic of private property is its exclusiveness. The right to transfer
  prefs: []
  type: TYPE_NORMAL
- en: ownership to another account is restricted to the owner of the account who
  prefs: []
  type: TYPE_NORMAL
- en: hands off ownership. Hence, the challenge of the blockchain is to protect the
  prefs: []
  type: TYPE_NORMAL
- en: property assigned to the accounts without restricting the open architecture
  prefs: []
  type: TYPE_NORMAL
- en: of the distributed system.
  prefs: []
  type: TYPE_NORMAL
- en: The Idea
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea is to treat accounts like mailboxes: everyone can transfer property
    to'
  prefs: []
  type: TYPE_NORMAL
- en: it, but only the owner of the account can access the things that are collected
  prefs: []
  type: TYPE_NORMAL
- en: inside. The major characteristic of a mailbox is that its location is known
    and
  prefs: []
  type: TYPE_NORMAL
- en: hence anyone can put something in but only the owner can open it with a
  prefs: []
  type: TYPE_NORMAL
- en: key. The duality of a public mailbox, on the one hand, and a privately held
    key,
  prefs: []
  type: TYPE_NORMAL
- en: '***Blockchain Basics***'
  prefs: []
  type: TYPE_NORMAL
- en: '95'
  prefs: []
  type: TYPE_NORMAL
- en: 'on the other hand, has an equivalent in the digital world: public-private-key'
  prefs: []
  type: TYPE_NORMAL
- en: encryption. One uses public keys for identifying accounts to which everyone
  prefs: []
  type: TYPE_NORMAL
- en: can transfer ownership, while access is restricted to those who possess the
  prefs: []
  type: TYPE_NORMAL
- en: corresponding private keys. [1](index_split_001.html#98)
  prefs: []
  type: TYPE_NORMAL
- en: A Short Detour to Cryptography
  prefs: []
  type: TYPE_NORMAL
- en: In order to help you understand cryptography, I will discuss the following
  prefs: []
  type: TYPE_NORMAL
- en: 'aspects:'
  prefs: []
  type: TYPE_NORMAL
- en: • The major idea of cryptography
  prefs: []
  type: TYPE_NORMAL
- en: • Terminology
  prefs: []
  type: TYPE_NORMAL
- en: • Symmetric cryptography
  prefs: []
  type: TYPE_NORMAL
- en: • Asymmetric cryptography
  prefs: []
  type: TYPE_NORMAL
- en: The Major Idea of Cryptography
  prefs: []
  type: TYPE_NORMAL
- en: The major idea of cryptography is to protect data from being accessed by
  prefs: []
  type: TYPE_NORMAL
- en: unauthorized people. It is the digital equivalent to door locks or bank safes,
  prefs: []
  type: TYPE_NORMAL
- en: which also protect their content from being accessed by unauthorized people.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to locks and keys in the physical world, cryptography also uses keys
    to
  prefs: []
  type: TYPE_NORMAL
- en: protect data.
  prefs: []
  type: TYPE_NORMAL
- en: Terminolog[y2](index_split_001.html#98)
  prefs: []
  type: TYPE_NORMAL
- en: The digital equivalent to closing a lock is encryption, while the digital equivalent
    to opening a lock is decryption. Hence, when talking about protecting data by
  prefs: []
  type: TYPE_NORMAL
- en: using cryptography, we use the terms encryption and decryption for protect-
  prefs: []
  type: TYPE_NORMAL
- en: ing data and unprotecting data, respectively. Encrypted data are called cypher
  prefs: []
  type: TYPE_NORMAL
- en: text. Cypher text looks like a useless pile of letters and figures to everyone
  prefs: []
  type: TYPE_NORMAL
- en: who does not know how to decrypt it. However, cypher text is indeed useful
  prefs: []
  type: TYPE_NORMAL
- en: but only for those who possess the key necessary to decrypt it. Decrypted
  prefs: []
  type: TYPE_NORMAL
- en: cypher text is identical to the original data that have been encrypted. Hence,
  prefs: []
  type: TYPE_NORMAL
- en: 'the whole round trip through cryptography can be summed up as: start with'
  prefs: []
  type: TYPE_NORMAL
- en: some data, produce cypher text by encrypting the original data with a cryp-
  prefs: []
  type: TYPE_NORMAL
- en: tographic key, preserve the cypher text or send it to someone, and finally
  prefs: []
  type: TYPE_NORMAL
- en: recover the original data by decrypting the cypher text with a cryptographic
  prefs: []
  type: TYPE_NORMAL
- en: key. Figure [12-1](index_split_001.html#99) illustrates the basic functioning
    of cryptography.
  prefs: []
  type: TYPE_NORMAL
- en: '1Nakamoto, Satoshi. Bitcoin: A peer-to-peer electronic cash system. 2008\.
    [https://bitcoin.](https://bitcoin.org/bitcoin.pdf)'
  prefs: []
  type: TYPE_NORMAL
- en: '[org/bitcoin.pdf](https://bitcoin.org/bitcoin.pdf).'
  prefs: []
  type: TYPE_NORMAL
- en: '2See Van Tilborg, Henk, and Sushil Jajodia, eds. *Encyclopedia of cryptography
    and security*. New York: Springer Science & Business Media, 2014\.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-99_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](index-99_2.png)'
  prefs: []
  type: TYPE_IMG
- en: '96'
  prefs: []
  type: TYPE_NORMAL
- en: '***Step 12 | Identifying and Protecting User Accounts***'
  prefs: []
  type: TYPE_NORMAL
- en: '**Figure 12-1\.** Schematic illustration of basic cryptographic concepts and
    their terminology What happens if someone tries to decrypt cypher text by using
    an incorrect'
  prefs: []
  type: TYPE_NORMAL
- en: key? The result is a useless pile of numbers, letters, and signs that do not
  prefs: []
  type: TYPE_NORMAL
- en: reveal any of the data that were encrypted.
  prefs: []
  type: TYPE_NORMAL
- en: Symmetric Cryptography
  prefs: []
  type: TYPE_NORMAL
- en: For many years people utilized methods of cryptography where the identical
  prefs: []
  type: TYPE_NORMAL
- en: key was used to do both the encrypting and decrypting of data. Hence, every-
  prefs: []
  type: TYPE_NORMAL
- en: one who was able to encrypt data with such a key was automatically able to
  prefs: []
  type: TYPE_NORMAL
- en: decrypt cypher text created with that key as well. Since the identical key was
  prefs: []
  type: TYPE_NORMAL
- en: used for both methods, this was called symmetric cryptography. Figure [12-2](index_split_001.html#99)
  prefs: []
  type: TYPE_NORMAL
- en: illustrates the basic functioning of symmetric cryptography where the identi-
  prefs: []
  type: TYPE_NORMAL
- en: cal key is used to encrypt and to decrypt a short greeting.
  prefs: []
  type: TYPE_NORMAL
- en: '**Figure 12-2\.** Schematic illustration of symmetric cryptography'
  prefs: []
  type: TYPE_NORMAL
- en: However, it turned out that having one key for encryption and decryption
  prefs: []
  type: TYPE_NORMAL
- en: was not always desirable. As a result, asymmetric cryptography was invented.
  prefs: []
  type: TYPE_NORMAL
- en: Asymmetric Cryptography
  prefs: []
  type: TYPE_NORMAL
- en: Asymmetric cryptography always uses two complementary keys. But there
  prefs: []
  type: TYPE_NORMAL
- en: 'is a trick to this: cypher text created with one of these keys can only be'
  prefs: []
  type: TYPE_NORMAL
- en: decrypted with the other key and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure [12-3 illustrates the encr](index_split_001.html#100)yption-decryption
    round trip for asymmetric cryptography. You can view this figure in the following
    way: The upper part of'
  prefs: []
  type: TYPE_NORMAL
- en: Figure [12-3 illustrates encr](index_split_001.html#100)yption, while the lower
    part illustrates decryption.
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-100_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '***Blockchain Basics***'
  prefs: []
  type: TYPE_NORMAL
- en: '97'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two keys: a white key and a black key. Together they form the pair'
  prefs: []
  type: TYPE_NORMAL
- en: of corresponding keys. The original message is encrypted with the black key,
  prefs: []
  type: TYPE_NORMAL
- en: which yields cypher text represented by the black box containing white let-
  prefs: []
  type: TYPE_NORMAL
- en: ters. The original message can also be encrypted with the second key, which
  prefs: []
  type: TYPE_NORMAL
- en: yields different cypher text represented by the white box containing black
  prefs: []
  type: TYPE_NORMAL
- en: letters. For didactical reasons, the colors of the boxes representing cypher
  prefs: []
  type: TYPE_NORMAL
- en: text and the colors of the keys used to produce them are identical in order
    to
  prefs: []
  type: TYPE_NORMAL
- en: 'highlight their relation: The black key yields black cypher text, while the
    white key produces white cypher text.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Figure 12-3\.** Schematic illustration of asymmetric cryptography'
  prefs: []
  type: TYPE_NORMAL
- en: The lower part of Figure [12-3](index_split_001.html#100) illustrates how decryption
    works in asymmetric cryptography. Black cypher text can only be decrypted with
    the white key and
  prefs: []
  type: TYPE_NORMAL
- en: vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: The trick to asymmetric cryptography is that you can never decrypt cypher
  prefs: []
  type: TYPE_NORMAL
- en: text with the key that was used to create it. The decision on which key to
  prefs: []
  type: TYPE_NORMAL
- en: use for encryption and which to use for decryption is up to you. You can
  prefs: []
  type: TYPE_NORMAL
- en: switch the roles of the keys as you like for every new piece of data you want
  prefs: []
  type: TYPE_NORMAL
- en: to encrypt, but you always have to keep both keys for doing both encryption
  prefs: []
  type: TYPE_NORMAL
- en: and decryption. If you have only one of the keys, your power is limited. While
  prefs: []
  type: TYPE_NORMAL
- en: you can always create cypher text by applying your key to data, you cannot
  prefs: []
  type: TYPE_NORMAL
- en: decrypt it because you are missing the complementary key. However, you can
  prefs: []
  type: TYPE_NORMAL
- en: decrypt cypher text that was created with the corresponding complementary
  prefs: []
  type: TYPE_NORMAL
- en: 'key. An isolated key is like a one-way street: You can drive down the street'
  prefs: []
  type: TYPE_NORMAL
- en: '98'
  prefs: []
  type: TYPE_NORMAL
- en: '***Step 12 | Identifying and Protecting User Accounts***'
  prefs: []
  type: TYPE_NORMAL
- en: but you can never drive back on the identical street. Due to the asymmetric
  prefs: []
  type: TYPE_NORMAL
- en: distribution of their cryptographic power, the two keys allow you to separate
  prefs: []
  type: TYPE_NORMAL
- en: the group of people who are able to create cypher text from those who can
  prefs: []
  type: TYPE_NORMAL
- en: decrypt it.
  prefs: []
  type: TYPE_NORMAL
- en: Asymmetric Cryptography in the Real World
  prefs: []
  type: TYPE_NORMAL
- en: 'Using asymmetric cryptography in real life consists of two major steps:'
  prefs: []
  type: TYPE_NORMAL
- en: • Creating and distributing the keys
  prefs: []
  type: TYPE_NORMAL
- en: • Using the keys
  prefs: []
  type: TYPE_NORMAL
- en: Creating and Distributing the Keys
  prefs: []
  type: TYPE_NORMAL
- en: When using asymmetric cryptography in real life, you would give the two keys
  prefs: []
  type: TYPE_NORMAL
- en: specific names in order to highlight each one’s role. Typically these keys are
  prefs: []
  type: TYPE_NORMAL
- en: called the private key and public key. For that reason, asymmetric cryptography
  prefs: []
  type: TYPE_NORMAL
- en: is called public-private-key cryptography. However, there are no such things
  prefs: []
  type: TYPE_NORMAL
- en: as the private key and public key in asymmetric cryptography per se because
  prefs: []
  type: TYPE_NORMAL
- en: you know that you can encrypt data and decrypt cypher text with each of
  prefs: []
  type: TYPE_NORMAL
- en: them. It is the role that is assigned to these keys that makes them private
    or
  prefs: []
  type: TYPE_NORMAL
- en: public. The public key is given to everyone, regardless of their trustworthiness.
  prefs: []
  type: TYPE_NORMAL
- en: Literally anyone can have a copy of the public key. However, the private key
    is
  prefs: []
  type: TYPE_NORMAL
- en: kept safe and private.
  prefs: []
  type: TYPE_NORMAL
- en: Hence, the first steps to be performed in any application of asymmetric cryp-
  prefs: []
  type: TYPE_NORMAL
- en: 'tography are:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Create a pair of complementary keys by using crypto-
  prefs: []
  type: TYPE_NORMAL
- en: graphic software
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Give one key the name public key
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Give the other key the name private key
  prefs: []
  type: TYPE_NORMAL
- en: 4\. Keep the private key for yourself
  prefs: []
  type: TYPE_NORMAL
- en: 5\. Give your public key to everyone else
  prefs: []
  type: TYPE_NORMAL
- en: Using the Keys
  prefs: []
  type: TYPE_NORMAL
- en: There are two general ways to use the pair of keys, which differ in the direc-
  prefs: []
  type: TYPE_NORMAL
- en: 'tion to which the data flows:'
  prefs: []
  type: TYPE_NORMAL
- en: • Public to private
  prefs: []
  type: TYPE_NORMAL
- en: • Private to public
  prefs: []
  type: TYPE_NORMAL
- en: '***Blockchain Basics***'
  prefs: []
  type: TYPE_NORMAL
- en: '99'
  prefs: []
  type: TYPE_NORMAL
- en: Public to Private
  prefs: []
  type: TYPE_NORMAL
- en: By using the keys in this way, the information flows from the public key, where
  prefs: []
  type: TYPE_NORMAL
- en: it is encrypted, to the private key, where it is decrypted. This usage of the
    two complementary keys is similar to a mailbox, where everyone can put letters
    in
  prefs: []
  type: TYPE_NORMAL
- en: but only the owner can open it. It is the straightforward usage of asymmetric
  prefs: []
  type: TYPE_NORMAL
- en: cryptography because it fits our intuition about privacy and publicity in the
  prefs: []
  type: TYPE_NORMAL
- en: same way as our address and our mailbox is public but its content is private.
  prefs: []
  type: TYPE_NORMAL
- en: Hence, this way of using asymmetric cryptography is all about sending infor-
  prefs: []
  type: TYPE_NORMAL
- en: mation in a secured fashion to the owner of the private key. It works because
  prefs: []
  type: TYPE_NORMAL
- en: everyone can create cypher text with the public key, but only the owner of the
  prefs: []
  type: TYPE_NORMAL
- en: private key can decrypt the cypher text and read the message.
  prefs: []
  type: TYPE_NORMAL
- en: Private to Public
  prefs: []
  type: TYPE_NORMAL
- en: By using the keys in this way, the information flows from the private key, where
    it is encrypted, to the public key, where it is decrypted. This way of using the
    two keys is similar to a public news board or public notice board where everyone
    who has a copy of the public key can read messages but only the owner
  prefs: []
  type: TYPE_NORMAL
- en: of the private key can create messages. Hence, this way of using asymmetric
  prefs: []
  type: TYPE_NORMAL
- en: cryptography is all about proving authorship. It works because everyone can
  prefs: []
  type: TYPE_NORMAL
- en: use the public key to decrypt cypher text that was created with the corre-
  prefs: []
  type: TYPE_NORMAL
- en: sponding private key. The fact that cypher text created with the private key
  prefs: []
  type: TYPE_NORMAL
- en: can only be decrypted with the corresponding public key serves as proof that
  prefs: []
  type: TYPE_NORMAL
- en: the owner of the corresponding private key has encrypted the message.
  prefs: []
  type: TYPE_NORMAL
- en: Asymmetric Cryptography in the Blockchain
  prefs: []
  type: TYPE_NORMAL
- en: 'The blockchain uses asymmetric cryptography in order to achieve two goals:'
  prefs: []
  type: TYPE_NORMAL
- en: • Identifying accounts
  prefs: []
  type: TYPE_NORMAL
- en: • Authorizing transactions
  prefs: []
  type: TYPE_NORMAL
- en: Identifying Accounts
  prefs: []
  type: TYPE_NORMAL
- en: The blockchain needs to identify users or user accounts, respectively, in order
  prefs: []
  type: TYPE_NORMAL
- en: to maintain the mapping between owner and property. The blockchain uses
  prefs: []
  type: TYPE_NORMAL
- en: the public-to-private approach of asymmetric cryptography for identifying
  prefs: []
  type: TYPE_NORMAL
- en: user accounts and transferring ownership between them. Account numbers
  prefs: []
  type: TYPE_NORMAL
- en: in the blockchain are actually public cryptographic keys. Hence, transaction
  prefs: []
  type: TYPE_NORMAL
- en: data use the public cryptographic keys for identifying the accounts involved
    in
  prefs: []
  type: TYPE_NORMAL
- en: the transfer of ownership. In this regard, the blockchain treats user accounts
  prefs: []
  type: TYPE_NORMAL
- en: 'similar to mailboxes: They have a publicly known address and everyone is able'
  prefs: []
  type: TYPE_NORMAL
- en: to send messages to them.
  prefs: []
  type: TYPE_NORMAL
- en: '100'
  prefs: []
  type: TYPE_NORMAL
- en: '***Step 12 | Identifying and Protecting User Accounts***'
  prefs: []
  type: TYPE_NORMAL
- en: Authorizing Transactions
  prefs: []
  type: TYPE_NORMAL
- en: Transaction data always have to include a piece of data that serves as proof
  prefs: []
  type: TYPE_NORMAL
- en: that the owner of the account who hands off ownership indeed agrees with
  prefs: []
  type: TYPE_NORMAL
- en: the described transfer of ownership. The flow of information implied by this
  prefs: []
  type: TYPE_NORMAL
- en: agreement starts at the owner of the account who hands off ownership and
  prefs: []
  type: TYPE_NORMAL
- en: is supposed to reach everyone who inspects the transaction data. This kind of
  prefs: []
  type: TYPE_NORMAL
- en: information flow is similar to that implied by the private-to-public use case
    of asymmetric cryptography. The owner of the account who hands off ownership creates
    some cypher text with his or her private key. All others can verify this proof
    of agreement by using the public cryptographic key, which happens
  prefs: []
  type: TYPE_NORMAL
- en: to be the number of the account that hands off ownership. The details of this
  prefs: []
  type: TYPE_NORMAL
- en: procedure, which is called digital signature, will be explained in more detail
    in the next step.
  prefs: []
  type: TYPE_NORMAL
- en: Outlook
  prefs: []
  type: TYPE_NORMAL
- en: This step explained the concept of asymmetric cryptography and how it is
  prefs: []
  type: TYPE_NORMAL
- en: used as public-private-key cryptography in real life. Furthermore, this step
  prefs: []
  type: TYPE_NORMAL
- en: explained that cryptographic public keys are used in the blockchain to iden-
  prefs: []
  type: TYPE_NORMAL
- en: tify user accounts. Furthermore, the lawful owner authorizes transactions by
  prefs: []
  type: TYPE_NORMAL
- en: creating a digital signature that can be traced back to his or her private cryp-
  prefs: []
  type: TYPE_NORMAL
- en: tographic key. The next step explains this concept in more detail, as this usage
    of asymmetric cryptography is less intuitive than the identification of accounts
    by public keys.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs: []
  type: TYPE_NORMAL
- en: • The major goal of cryptography is to protect data from
  prefs: []
  type: TYPE_NORMAL
- en: being accessed by unauthorized people.
  prefs: []
  type: TYPE_NORMAL
- en: '• The major cryptographic activities are:'
  prefs: []
  type: TYPE_NORMAL
- en: '• Encryption: Protecting data by turning them into cypher'
  prefs: []
  type: TYPE_NORMAL
- en: text by utilizing a cryptographic key
  prefs: []
  type: TYPE_NORMAL
- en: '• Decryption: Turning cypher text back into useful data'
  prefs: []
  type: TYPE_NORMAL
- en: by utilizing a matching cryptographic key
  prefs: []
  type: TYPE_NORMAL
- en: • Asymmetric cryptography always uses two complemen-
  prefs: []
  type: TYPE_NORMAL
- en: 'tary keys: cypher text created with one of these keys can'
  prefs: []
  type: TYPE_NORMAL
- en: only be decrypted with the other key and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: '***Blockchain Basics***'
  prefs: []
  type: TYPE_NORMAL
- en: '101'
  prefs: []
  type: TYPE_NORMAL
- en: • When utilizing asymmetric cryptography in real life, these
  prefs: []
  type: TYPE_NORMAL
- en: keys are typically called the public key and private key in
  prefs: []
  type: TYPE_NORMAL
- en: order to highlight their role. The public key is shared with
  prefs: []
  type: TYPE_NORMAL
- en: everyone, while the private key is kept secret. For this
  prefs: []
  type: TYPE_NORMAL
- en: reason, asymmetric cryptography is also called public-
  prefs: []
  type: TYPE_NORMAL
- en: private-key cryptography.
  prefs: []
  type: TYPE_NORMAL
- en: • There are two classical use cases of public and private
  prefs: []
  type: TYPE_NORMAL
- en: 'keys:'
  prefs: []
  type: TYPE_NORMAL
- en: • Everyone uses the public key to encrypt data that can
  prefs: []
  type: TYPE_NORMAL
- en: only be decrypted by the owner of the corresponding
  prefs: []
  type: TYPE_NORMAL
- en: private key. This is the digital equivalent to a public
  prefs: []
  type: TYPE_NORMAL
- en: mailbox where everyone can put letters in but only
  prefs: []
  type: TYPE_NORMAL
- en: the owner can open it.
  prefs: []
  type: TYPE_NORMAL
- en: • The owner of the private key uses it to encrypt data
  prefs: []
  type: TYPE_NORMAL
- en: that can be decrypted by everyone who possesses the
  prefs: []
  type: TYPE_NORMAL
- en: corresponding public key. This is the digital equivalent
  prefs: []
  type: TYPE_NORMAL
- en: to a public notice board that proves authorship.
  prefs: []
  type: TYPE_NORMAL
- en: • The blockchain uses asymmetric cryptography in order
  prefs: []
  type: TYPE_NORMAL
- en: 'to achieve two goals:'
  prefs: []
  type: TYPE_NORMAL
- en: '• Identifying accounts: User accounts are public'
  prefs: []
  type: TYPE_NORMAL
- en: cryptographic keys.
  prefs: []
  type: TYPE_NORMAL
- en: '• Authorizing transactions: The owner of the account'
  prefs: []
  type: TYPE_NORMAL
- en: who hands off ownership creates a piece of cypher
  prefs: []
  type: TYPE_NORMAL
- en: text with the corresponding private key. This piece of
  prefs: []
  type: TYPE_NORMAL
- en: cypher text can be verified by using the corresponding
  prefs: []
  type: TYPE_NORMAL
- en: public key, which happens to be the number of the
  prefs: []
  type: TYPE_NORMAL
- en: account that hands off ownership.
  prefs: []
  type: TYPE_NORMAL
- en: '**S T E P**'
  prefs: []
  type: TYPE_NORMAL
- en: '13'
  prefs: []
  type: TYPE_NORMAL
- en: Authorizing
  prefs: []
  type: TYPE_NORMAL
- en: Transactions
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing the digital equivalent to
  prefs: []
  type: TYPE_NORMAL
- en: handwritten signatures
  prefs: []
  type: TYPE_NORMAL
- en: Step [12](http://dx.doi.org/10.1007/978-1-4842-2604-9_12) provided a gentle
    introduction to asymmetric cryptography. It also pointed out that the blockchain
    uses public cryptographic keys as account
  prefs: []
  type: TYPE_NORMAL
- en: numbers and utilizes the public-to-private approach of asymmetric cryptog-
  prefs: []
  type: TYPE_NORMAL
- en: raphy for transferring ownership among accounts. However, that was only
  prefs: []
  type: TYPE_NORMAL
- en: half of the story. The blockchain needs to ensure that only the lawful owner
  prefs: []
  type: TYPE_NORMAL
- en: can transfer his or her property to other accounts. This is the point were
  prefs: []
  type: TYPE_NORMAL
- en: the concept of authorization enters the scene. Hence, this step explains how
  prefs: []
  type: TYPE_NORMAL
- en: asymmetric cryptography is used within the blockchain for authorizing trans-
  prefs: []
  type: TYPE_NORMAL
- en: actions. In particular, this step is devoted to the concept of digital signatures,
    which utilize the private-to-public approach of asymmetric cryptography.
  prefs: []
  type: TYPE_NORMAL
- en: The Metaphor
  prefs: []
  type: TYPE_NORMAL
- en: 'Handwritten signatures serve an important purpose: they state agreement with'
  prefs: []
  type: TYPE_NORMAL
- en: the content of a document and agree with its execution. The reason why we
  prefs: []
  type: TYPE_NORMAL
- en: accept handwritten signatures as evidence for agreement is the uniqueness of
  prefs: []
  type: TYPE_NORMAL
- en: each person’s handwriting. Every human being has his or her own characteristic
  prefs: []
  type: TYPE_NORMAL
- en: © Daniel Drescher 2017
  prefs: []
  type: TYPE_NORMAL
- en: D. Drescher, *Blockchain Basics*, DOI 10.1007/978-1-4842-2604-9_13
  prefs: []
  type: TYPE_NORMAL
- en: '104'
  prefs: []
  type: TYPE_NORMAL
- en: '***Step 13 | Authorizing Transactions***'
  prefs: []
  type: TYPE_NORMAL
- en: way of writing his or her name. Hence, when we identify a name being written
    in
  prefs: []
  type: TYPE_NORMAL
- en: a specific way, we conclude that the person who writes his or her name in that
  prefs: []
  type: TYPE_NORMAL
- en: particular way has indeed produced that handwritten signature, and, as a result,
    we can conclude that this person has agreed with the content of the document
  prefs: []
  type: TYPE_NORMAL
- en: and its implementation. This step explains the concept of stating agreement
    with transactions in an electronic ledger that is similar to handwritten signatures.
    This concept is crucial for the security of individual transactions in the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: The Goal
  prefs: []
  type: TYPE_NORMAL
- en: It is important to ensure that only the owner of an account can transfer
  prefs: []
  type: TYPE_NORMAL
- en: the property associated with it to other accounts. Every attempt to access
  prefs: []
  type: TYPE_NORMAL
- en: an account and its associated property by any person other than the lawful
  prefs: []
  type: TYPE_NORMAL
- en: owner should be identified as unauthorized and should be rejected.
  prefs: []
  type: TYPE_NORMAL
- en: The Challenge
  prefs: []
  type: TYPE_NORMAL
- en: The peer-to-peer system under consideration is open to everyone. Hence,
  prefs: []
  type: TYPE_NORMAL
- en: everyone may create transactions and can submit them to the system.
  prefs: []
  type: TYPE_NORMAL
- en: Transaction data are the foundation of describing and clarifying ownership.
  prefs: []
  type: TYPE_NORMAL
- en: Only the lawful owner of an account should be able to transfer property or
  prefs: []
  type: TYPE_NORMAL
- en: ownership rights associated with his or her account to another account. The
  prefs: []
  type: TYPE_NORMAL
- en: challenge of the blockchain is to maintain its openness while restricting the
  prefs: []
  type: TYPE_NORMAL
- en: transfer of ownership to the lawful owner.
  prefs: []
  type: TYPE_NORMAL
- en: The Idea
  prefs: []
  type: TYPE_NORMAL
- en: The main idea of ensuring that only the lawful owner can transfer ownership
    is
  prefs: []
  type: TYPE_NORMAL
- en: 'to utilize a digital security measure that is equivalent to handwritten signatures
    and serves the same purpose: identifying an account, stating the agreement of'
  prefs: []
  type: TYPE_NORMAL
- en: its owner with the content of specific transaction data, and approving its execution
    by allowing the data to be added to the history of transaction data.
  prefs: []
  type: TYPE_NORMAL
- en: A Short Detour to Digital Signatures
  prefs: []
  type: TYPE_NORMAL
- en: Digital signatures are the equivalent of handwritten signatures. They utilize
  prefs: []
  type: TYPE_NORMAL
- en: cryptographic hashing and the private-to-public information flow of asym-
  prefs: []
  type: TYPE_NORMAL
- en: metric cryptography. The following short example illustrates the three major
  prefs: []
  type: TYPE_NORMAL
- en: 'elements of digital signatures:'
  prefs: []
  type: TYPE_NORMAL
- en: • Creating a signature
  prefs: []
  type: TYPE_NORMAL
- en: • Verifying data by using the signature
  prefs: []
  type: TYPE_NORMAL
- en: • Identifying fraud by using the signature
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-107_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '***Blockchain Basics***'
  prefs: []
  type: TYPE_NORMAL
- en: '105'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Signature
  prefs: []
  type: TYPE_NORMAL
- en: Let’s say I want to send a Hello World! greeting to the world in an authorized
  prefs: []
  type: TYPE_NORMAL
- en: way. Hence, I create a message that contains the greeting and a corresponding
  prefs: []
  type: TYPE_NORMAL
- en: digital signature. Figure [13-1](index_split_001.html#107) depicts the whole
    process of signing data digitally.
  prefs: []
  type: TYPE_NORMAL
- en: The process starts with the white box in the top left area of Figure [13-1 that](index_split_001.html#107)
  prefs: []
  type: TYPE_NORMAL
- en: contains the greeting. I create the hash value of the greeting, which is 7F83B165,
    and encrypt it with my private key. The cypher text of the greeting’s hash value
    (the black box containing white letters) is my digital signature of the greeting.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is unique with respect to two aspects: First, it can be traced back to me'
  prefs: []
  type: TYPE_NORMAL
- en: uniquely because I created it with my unique private key. Second, it is unique
  prefs: []
  type: TYPE_NORMAL
- en: regarding the text of the greeting because it is based on the digital fingerprint
    of the greeting. Both the greeting and the digital signature are put together
    in a file (the gray box), which is my digitally signed message to the world.
  prefs: []
  type: TYPE_NORMAL
- en: '**Figure 13-1\.** Schematic illustration of creating a digital signature'
  prefs: []
  type: TYPE_NORMAL
- en: Verifying Data by Using the Signature
  prefs: []
  type: TYPE_NORMAL
- en: The message, that is, my greeting together with the digital signature, is sent
  prefs: []
  type: TYPE_NORMAL
- en: to the whole world. Everyone can verify that I authorized this message by
  prefs: []
  type: TYPE_NORMAL
- en: utilizing my public key. Figure [13-2](index_split_001.html#108) illustrates
    the process of verifying the message by using the digital signature. The process
    starts with the greeting. At
  prefs: []
  type: TYPE_NORMAL
- en: first the recipient of the message calculates the hash value of the greeting
    by
  prefs: []
  type: TYPE_NORMAL
- en: himself, which yields the value 7F83B165\. Then the recipient of my message
  prefs: []
  type: TYPE_NORMAL
- en: decrypts the attached cypher text (the digital signature) with my public key.
  prefs: []
  type: TYPE_NORMAL
- en: Doing so yields the value 7F83B165, which is the hash value of that version
  prefs: []
  type: TYPE_NORMAL
- en: of the greeting I wanted to send to the world. Comparing both hash values
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-108_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](index-108_2.png)'
  prefs: []
  type: TYPE_IMG
- en: '106'
  prefs: []
  type: TYPE_NORMAL
- en: '***Step 13 | Authorizing Transactions***'
  prefs: []
  type: TYPE_NORMAL
- en: completes the verification. Since both hash values are identical, the recipient
  prefs: []
  type: TYPE_NORMAL
- en: correctly concludes, first, that the message was signed by me, because he was
  prefs: []
  type: TYPE_NORMAL
- en: able to decrypt the signature with my public key, and second, that the greet-
  prefs: []
  type: TYPE_NORMAL
- en: ing text found in the message is indeed the one I wanted to send because the
  prefs: []
  type: TYPE_NORMAL
- en: decrypted cypher text is identical with the hash value of the greeting in the
  prefs: []
  type: TYPE_NORMAL
- en: message.
  prefs: []
  type: TYPE_NORMAL
- en: '**Figure 13-2\.** Using a digital signature to verify a message'
  prefs: []
  type: TYPE_NORMAL
- en: Identifying Fraud by Using the Signature
  prefs: []
  type: TYPE_NORMAL
- en: Figure [13-3 illustrates ho](index_split_001.html#108)w the digital signature
    points out a forged greeting.
  prefs: []
  type: TYPE_NORMAL
- en: '**Figure 13-3\.** Using a digital signature to identify fraud'
  prefs: []
  type: TYPE_NORMAL
- en: '***Blockchain Basics***'
  prefs: []
  type: TYPE_NORMAL
- en: '107'
  prefs: []
  type: TYPE_NORMAL
- en: Figure [13-3](index_split_001.html#108) shows the message that arrived in my
    friend’s mailbox. Note the change of the greeting text. Some hacker replaced the
    exclamation mark with
  prefs: []
  type: TYPE_NORMAL
- en: a question mark and hence changed the whole tone of the greeting. This is
  prefs: []
  type: TYPE_NORMAL
- en: not the way I wanted to greet the world. Fortunately, the digital signature
    will point out to everyone that the message has been altered against my will.
  prefs: []
  type: TYPE_NORMAL
- en: At first the recipient of the message will create the hash value of the greeting
    by himself, which yields the value 8A0B7C66\. Then the recipient of my message
  prefs: []
  type: TYPE_NORMAL
- en: decrypts the digital signature with my public key. Doing so yields 7F83B165,
  prefs: []
  type: TYPE_NORMAL
- en: which is the hash value of the version of the greeting I wanted to send to the
  prefs: []
  type: TYPE_NORMAL
- en: world. Comparing both hash values reveals that they are not identical. This
  prefs: []
  type: TYPE_NORMAL
- en: clearly points out that the greeting in the message is not the greeting I wanted
    to send to the world. Hence, everyone concludes that I did not authorize this
  prefs: []
  type: TYPE_NORMAL
- en: message, and, therefore, no one will make me responsible for its content.
  prefs: []
  type: TYPE_NORMAL
- en: How It Works
  prefs: []
  type: TYPE_NORMAL
- en: 'Digital signatures in the blockchain fulfill the following requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: • They state agreement of the owner of the account who
  prefs: []
  type: TYPE_NORMAL
- en: hands off ownership with specific transaction data.
  prefs: []
  type: TYPE_NORMAL
- en: • They are unique for the whole content of transaction
  prefs: []
  type: TYPE_NORMAL
- en: data in order to prevent it from being used to authorize
  prefs: []
  type: TYPE_NORMAL
- en: other transactions without the agreement of its author.
  prefs: []
  type: TYPE_NORMAL
- en: • Only the owner of the account who hands off ownership
  prefs: []
  type: TYPE_NORMAL
- en: can create such a signature.
  prefs: []
  type: TYPE_NORMAL
- en: • They are easy to verify by everyone.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two use cases of digital signatures in the blockchain:'
  prefs: []
  type: TYPE_NORMAL
- en: • Signing a transaction
  prefs: []
  type: TYPE_NORMAL
- en: • Verifying a transaction
  prefs: []
  type: TYPE_NORMAL
- en: Signing a Transaction
  prefs: []
  type: TYPE_NORMAL
- en: In order to create a digital signature for a transaction, the owner of the
  prefs: []
  type: TYPE_NORMAL
- en: 'account who hands off ownership performs the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Describes the transaction with all necessary informa-
  prefs: []
  type: TYPE_NORMAL
- en: tion such as the involved account numbers, amount being
  prefs: []
  type: TYPE_NORMAL
- en: transferred, and so on except the signature itself as it is
  prefs: []
  type: TYPE_NORMAL
- en: not yet available.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Create the cryptographic hash value of the transaction
  prefs: []
  type: TYPE_NORMAL
- en: data.
  prefs: []
  type: TYPE_NORMAL
- en: '108'
  prefs: []
  type: TYPE_NORMAL
- en: '***Step 13 | Authorizing Transactions***'
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Encrypt the hash value of the transaction with the private
  prefs: []
  type: TYPE_NORMAL
- en: key of the account that hands off ownership.
  prefs: []
  type: TYPE_NORMAL
- en: 4\. Add the cypher text created in point 3 to the transaction
  prefs: []
  type: TYPE_NORMAL
- en: as its digital signature.
  prefs: []
  type: TYPE_NORMAL
- en: Verifying a Transaction
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to verify a transaction, the following steps must be performed:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Create the hash value of the transaction data to be veri-
  prefs: []
  type: TYPE_NORMAL
- en: fied except the signature itself.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Decrypt the digital signature of the transaction under
  prefs: []
  type: TYPE_NORMAL
- en: consideration with the account number that hands off
  prefs: []
  type: TYPE_NORMAL
- en: ownership.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Compare the hash value of step [1](http://dx.doi.org/10.1007/978-1-4842-2604-9_1)
    with the value gained in step [2\.](http://dx.doi.org/10.1007/978-1-4842-2604-9_2)
    If both are identical, the transaction is authorized by the owner of the private
    key that corresponds to the
  prefs: []
  type: TYPE_NORMAL
- en: account that hands off ownership, otherwise it is not.
  prefs: []
  type: TYPE_NORMAL
- en: Why It Works
  prefs: []
  type: TYPE_NORMAL
- en: 'Digital signatures of transaction data are a combination of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: • Cryptographic hash values of transaction data
  prefs: []
  type: TYPE_NORMAL
- en: • Cypher text that can be traced back to the correspond-
  prefs: []
  type: TYPE_NORMAL
- en: ing private key of an account
  prefs: []
  type: TYPE_NORMAL
- en: Due to the fact that cryptographic hash values can be considered digital fin-
  prefs: []
  type: TYPE_NORMAL
- en: gerprints, they are unique for each transaction. A constituting property of
  prefs: []
  type: TYPE_NORMAL
- en: public-private-key cryptography is that cypher text created with one key can
  prefs: []
  type: TYPE_NORMAL
- en: only be decrypted with the corresponding key. The association of both keys
  prefs: []
  type: TYPE_NORMAL
- en: is unique. Hence, a successful decryption of cypher text with a specific public
  prefs: []
  type: TYPE_NORMAL
- en: key serves as proof that it was created with the corresponding private key.
  prefs: []
  type: TYPE_NORMAL
- en: Both concepts combined are used to create cypher text that can be traced
  prefs: []
  type: TYPE_NORMAL
- en: back uniquely to one specific transaction data and to one specific private
  prefs: []
  type: TYPE_NORMAL
- en: key in one process. This property make digital signatures suitable to serve
    as
  prefs: []
  type: TYPE_NORMAL
- en: proof that the owner of the private key that was used to create the digital
  prefs: []
  type: TYPE_NORMAL
- en: signature indeed agrees with the content of the transaction.
  prefs: []
  type: TYPE_NORMAL
- en: '***Blockchain Basics***'
  prefs: []
  type: TYPE_NORMAL
- en: '109'
  prefs: []
  type: TYPE_NORMAL
- en: Outlook
  prefs: []
  type: TYPE_NORMAL
- en: This step completes the process of how the blockchain protects ownership
  prefs: []
  type: TYPE_NORMAL
- en: on the level of individual transaction data. As a result, transactions and their
    purpose to transfer and prove ownership are safe and secure. However, it is
  prefs: []
  type: TYPE_NORMAL
- en: important to ensure that transaction data are not only secured on the indi-
  prefs: []
  type: TYPE_NORMAL
- en: vidual level. There is still a need to store the whole history of transaction
    data in a secure way. The next steps will explain in more detail how to achieve
    this.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs: []
  type: TYPE_NORMAL
- en: • Handwritten signatures on documents state the agree-
  prefs: []
  type: TYPE_NORMAL
- en: ment of their authors with the content of the signed
  prefs: []
  type: TYPE_NORMAL
- en: documents and authorize their implementation.
  prefs: []
  type: TYPE_NORMAL
- en: • The evidential power of handwritten signatures is based
  prefs: []
  type: TYPE_NORMAL
- en: on the uniqueness of the handwriting.
  prefs: []
  type: TYPE_NORMAL
- en: • Digital signatures are the digital equivalent to handwrit-
  prefs: []
  type: TYPE_NORMAL
- en: ten signatures.
  prefs: []
  type: TYPE_NORMAL
- en: '• Digital signatures serve two purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: • Identify its author uniquely
  prefs: []
  type: TYPE_NORMAL
- en: • State agreement of its author with the content of a
  prefs: []
  type: TYPE_NORMAL
- en: document and authorize its execution
  prefs: []
  type: TYPE_NORMAL
- en: • In the blockchain, digital signatures of transactions are
  prefs: []
  type: TYPE_NORMAL
- en: cryptographic hash values of transaction data encrypted
  prefs: []
  type: TYPE_NORMAL
- en: with the private key that corresponds to the account that
  prefs: []
  type: TYPE_NORMAL
- en: hands off ownership.
  prefs: []
  type: TYPE_NORMAL
- en: • Digital signatures in the blockchain can be trace back
  prefs: []
  type: TYPE_NORMAL
- en: uniquely to one specific private key and to one specific
  prefs: []
  type: TYPE_NORMAL
- en: transaction in one process.
  prefs: []
  type: TYPE_NORMAL
- en: '**S T E P**'
  prefs: []
  type: TYPE_NORMAL
- en: '14'
  prefs: []
  type: TYPE_NORMAL
- en: Storing
  prefs: []
  type: TYPE_NORMAL
- en: Transaction
  prefs: []
  type: TYPE_NORMAL
- en: Data
  prefs: []
  type: TYPE_NORMAL
- en: Building and maintaining a history of
  prefs: []
  type: TYPE_NORMAL
- en: transaction data
  prefs: []
  type: TYPE_NORMAL
- en: Based on the previous five steps, you should now be able to trace ownership
  prefs: []
  type: TYPE_NORMAL
- en: based on the whole history of transaction data and to describe individual
  prefs: []
  type: TYPE_NORMAL
- en: transfers of ownership in a secure way by authorizing transactions with digital
  prefs: []
  type: TYPE_NORMAL
- en: signatures and identifying user accounts uniquely. However, I have not spent
  prefs: []
  type: TYPE_NORMAL
- en: any time discussing how to store all the transaction data that make up the
  prefs: []
  type: TYPE_NORMAL
- en: transaction history in a secure fashion. This is the point where the block-
  prefs: []
  type: TYPE_NORMAL
- en: chain-data-structure enters the discussion. This step introduces the block-
  prefs: []
  type: TYPE_NORMAL
- en: chain-data-structure and explains how it is constructed.
  prefs: []
  type: TYPE_NORMAL
- en: © Daniel Drescher 2017
  prefs: []
  type: TYPE_NORMAL
- en: D. Drescher, *Blockchain Basics*, DOI 10.1007/978-1-4842-2604-9_14
  prefs: []
  type: TYPE_NORMAL
- en: '112'
  prefs: []
  type: TYPE_NORMAL
- en: '***Step 14 | Storing Transaction Data***'
  prefs: []
  type: TYPE_NORMAL
- en: The Metaphor
  prefs: []
  type: TYPE_NORMAL
- en: Do you remember the last time you visited a library and used one of the tra-
  prefs: []
  type: TYPE_NORMAL
- en: ditional card catalogs? Library catalogs are registers of all of the books owned
    by a library. Some traditional libraries still use card catalogs for managing
    their inventory. Each card in one of these catalogs represents one book, and the
  prefs: []
  type: TYPE_NORMAL
- en: card displays the major information about that book, such as the name of the
  prefs: []
  type: TYPE_NORMAL
- en: author, the title of the book, the date of publication, and the location of
    the
  prefs: []
  type: TYPE_NORMAL
- en: book within the library such as floor, room, shelf, and rack number. In order
  prefs: []
  type: TYPE_NORMAL
- en: to identify books, the catalog cards often contain unique reference numbers
  prefs: []
  type: TYPE_NORMAL
- en: that are also displayed on the books’ spines. Most libraries maintain more than
  prefs: []
  type: TYPE_NORMAL
- en: one card catalog, which differ with respect to the criterion used to order the
  prefs: []
  type: TYPE_NORMAL
- en: cards. For example, in an author catalog, the cards are sorted alphabetically
  prefs: []
  type: TYPE_NORMAL
- en: according to the names of authors, while in a title catalog the cards are sorted
    alphabetically according to the titles. One could also come up with an ordering
    catalog whose cards are sorted according the order in which the books
  prefs: []
  type: TYPE_NORMAL
- en: where added to the library. This step explains how the blockchain stores
  prefs: []
  type: TYPE_NORMAL
- en: transaction data in a way that is similar to a library with an ordering catalog.
  prefs: []
  type: TYPE_NORMAL
- en: The Goal
  prefs: []
  type: TYPE_NORMAL
- en: The goal of the blockchain is to maintain the whole history of transaction data
  prefs: []
  type: TYPE_NORMAL
- en: in an ordered fashion.
  prefs: []
  type: TYPE_NORMAL
- en: The Challenge
  prefs: []
  type: TYPE_NORMAL
- en: The challenge is to store all transaction data that have ever happened in a
    way
  prefs: []
  type: TYPE_NORMAL
- en: that preserves the order in which the transactions happened and in a way that
  prefs: []
  type: TYPE_NORMAL
- en: quickly and easily detects any changes made to the data. Detecting changes
  prefs: []
  type: TYPE_NORMAL
- en: quickly is important since it is the basis to prevent manipulation or forgery
    of the transaction history.
  prefs: []
  type: TYPE_NORMAL
- en: The Idea
  prefs: []
  type: TYPE_NORMAL
- en: The idea is to create a library of transaction data and to maintain an ordering
  prefs: []
  type: TYPE_NORMAL
- en: catalog, which preserves the order in which transactions were added to the
  prefs: []
  type: TYPE_NORMAL
- en: library. In order to detect any changes made either to the ordering catalog
  prefs: []
  type: TYPE_NORMAL
- en: or to the individual transaction data, the data must be stored in a change-
  prefs: []
  type: TYPE_NORMAL
- en: sensitive manner by using hash references.
  prefs: []
  type: TYPE_NORMAL
- en: '***Blockchain Basics***'
  prefs: []
  type: TYPE_NORMAL
- en: '113'
  prefs: []
  type: TYPE_NORMAL
- en: Transforming a Book into a Blockchain-Data-
  prefs: []
  type: TYPE_NORMAL
- en: Structure
  prefs: []
  type: TYPE_NORMAL
- en: This section explains how to turn a book into a small library with an ordering
    catalog, which turns out to be a simplified version of the blockchain-data-structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting Point: A Book'
  prefs: []
  type: TYPE_NORMAL
- en: For many centuries, written information was preserved on unwieldy spools of
  prefs: []
  type: TYPE_NORMAL
- en: parchment, which were called scrolls. Nowadays, we are used to having writ-
  prefs: []
  type: TYPE_NORMAL
- en: 'ten information preserved in codices: hardback-bound bundles of numbered'
  prefs: []
  type: TYPE_NORMAL
- en: pages, which we call books. Because books are so commonplace, we may take
  prefs: []
  type: TYPE_NORMAL
- en: 'their innovation for granted. Some of their important properties include:'
  prefs: []
  type: TYPE_NORMAL
- en: '• Storing content: Books store content on their pages.'
  prefs: []
  type: TYPE_NORMAL
- en: '• Ordering: The sentences on the pages as well as the pages'
  prefs: []
  type: TYPE_NORMAL
- en: within the book are kept in order.
  prefs: []
  type: TYPE_NORMAL
- en: '• Connecting pages: Pages are physically connected via the'
  prefs: []
  type: TYPE_NORMAL
- en: book spine and logically connected via their content and
  prefs: []
  type: TYPE_NORMAL
- en: the page numbers.
  prefs: []
  type: TYPE_NORMAL
- en: As a result of these properties, we can browse through books forward and
  prefs: []
  type: TYPE_NORMAL
- en: backward by moving pages or we can jump directly to specific pages by utiliz-
  prefs: []
  type: TYPE_NORMAL
- en: ing the page numbers. Let’s see what we could achieve if we changed some of
  prefs: []
  type: TYPE_NORMAL
- en: these properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'Transformation 1: Making Page Dependency Explicit'
  prefs: []
  type: TYPE_NORMAL
- en: Figure [14-1](index_split_001.html#115) exhibits a schematic illustration of
    two pages from a very simple book. Each page contains a top margin that presents
    the page number and a
  prefs: []
  type: TYPE_NORMAL
- en: content area that carries only one word.
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-115_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '114'
  prefs: []
  type: TYPE_NORMAL
- en: '***Step 14 | Storing Transaction Data***'
  prefs: []
  type: TYPE_NORMAL
- en: '**Figure 14-1\.** A schematic illustration of book pages'
  prefs: []
  type: TYPE_NORMAL
- en: 'The page numbers serve an important purpose: You can find out whether'
  prefs: []
  type: TYPE_NORMAL
- en: someone removed a page from the book by verifying that the page numbers
  prefs: []
  type: TYPE_NORMAL
- en: continue without leaving out a number. Imagine you are currently reading page
  prefs: []
  type: TYPE_NORMAL
- en: number 42 of our simplified book. What page number should the preceding
  prefs: []
  type: TYPE_NORMAL
- en: 'page have? This is very simple: The preceding page should have the number 41,'
  prefs: []
  type: TYPE_NORMAL
- en: which equals 42 minus 1\. In order to verify that indeed no one has removed
  prefs: []
  type: TYPE_NORMAL
- en: the preceding page, we compare the number being displayed on the preceding
  prefs: []
  type: TYPE_NORMAL
- en: page with the expected page number, which is the number of the current page
  prefs: []
  type: TYPE_NORMAL
- en: minus 1\. If both numbers are equal, we can conclude that the preceding page
  prefs: []
  type: TYPE_NORMAL
- en: has not been removed.
  prefs: []
  type: TYPE_NORMAL
- en: Why do we know that the number of the preceding page should equal the
  prefs: []
  type: TYPE_NORMAL
- en: current page’s number minus 1? The answer is that we assume that all books
  prefs: []
  type: TYPE_NORMAL
- en: follow the convention of labeling the pages consecutively with natural numbers.
  prefs: []
  type: TYPE_NORMAL
- en: But what if that assumption is not true because the author or the publisher
    of
  prefs: []
  type: TYPE_NORMAL
- en: the book decided to use a different page numbering schema (e.g., by only using
  prefs: []
  type: TYPE_NORMAL
- en: even numbers or multiples of three)? In this case, our approach of verifying
  prefs: []
  type: TYPE_NORMAL
- en: that the preceding page has not been removed fails. In order to make it easy
    to
  prefs: []
  type: TYPE_NORMAL
- en: verify that no page has been removed from the book, we could point out the
  prefs: []
  type: TYPE_NORMAL
- en: connection of each page to its predecessor explicitly. Figure [14-2 sho](index_split_001.html#116)ws
    how this is done in our simple book. Each page not only exhibits its own number
    but
  prefs: []
  type: TYPE_NORMAL
- en: also exhibits the number of its preceding page. This page numbering schema
  prefs: []
  type: TYPE_NORMAL
- en: makes the dependency between any page and its preceding page explicit. The
  prefs: []
  type: TYPE_NORMAL
- en: explicit referencing of the preceding page makes verifying that no page has
    been removed very easy since it does not rely on implicit assumptions anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-116_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](index-116_2.png)'
  prefs: []
  type: TYPE_IMG
- en: '***Blockchain Basics***'
  prefs: []
  type: TYPE_NORMAL
- en: '115'
  prefs: []
  type: TYPE_NORMAL
- en: '**Figure 14-2\.** Book pages with explicit reference to their preceding pages
    Transformation 2: Outsourcing the Content'
  prefs: []
  type: TYPE_NORMAL
- en: The pages of our book contain the content and the information necessary to
  prefs: []
  type: TYPE_NORMAL
- en: 'maintain their ordering: the page numbers. We can make our book handier'
  prefs: []
  type: TYPE_NORMAL
- en: by outsourcing the content and let it solely focus on the task of maintain-
  prefs: []
  type: TYPE_NORMAL
- en: ing the order. Figure [14-3](index_split_001.html#116) shows how the pages of
    our schematic book look after we outsourced the content. The pages no longer contain
    any content,
  prefs: []
  type: TYPE_NORMAL
- en: instead they contain reference numbers that point to the content, which can
  prefs: []
  type: TYPE_NORMAL
- en: be stored wherever we want (e.g., in a box, on a shelf, or somewhere else).
  prefs: []
  type: TYPE_NORMAL
- en: '**Figure 14-3\.** Book pages with reference values to the outsourced content'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-117_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '116'
  prefs: []
  type: TYPE_NORMAL
- en: '***Step 14 | Storing Transaction Data***'
  prefs: []
  type: TYPE_NORMAL
- en: 'The achievement of this step is the following: We turned our book into a small'
  prefs: []
  type: TYPE_NORMAL
- en: library. The book that once stored content and page numbers together has
  prefs: []
  type: TYPE_NORMAL
- en: been turned into a catalog, whose sole purpose is maintaining the order of the
  prefs: []
  type: TYPE_NORMAL
- en: content while the content is stored on separated pages that are identified by
  prefs: []
  type: TYPE_NORMAL
- en: unique reference numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Transformation 3: Replacing Page Numbers'
  prefs: []
  type: TYPE_NORMAL
- en: Our book that is now an ordering catalog maintains the order of its pages in
  prefs: []
  type: TYPE_NORMAL
- en: 'two distinct ways: First, by the physical location of the pages within the
    book'
  prefs: []
  type: TYPE_NORMAL
- en: fixated in the book spine; second, by the page numbers and the explicit refer-
  prefs: []
  type: TYPE_NORMAL
- en: encing of the preceding page. Due to the fact that the physical construction
    of
  prefs: []
  type: TYPE_NORMAL
- en: the book preserves the order of the pages, we can experiment with a different
  prefs: []
  type: TYPE_NORMAL
- en: page numbering schema. We can actually replace the natural numbers used to
  prefs: []
  type: TYPE_NORMAL
- en: label the pages with reference numbers. Figure [14-4](index_split_001.html#117)
    shows the result of this transformation. For example, the page previously carrying
    the page number
  prefs: []
  type: TYPE_NORMAL
- en: 42 is now identified with the page reference number 8118E736\. In a similar
  prefs: []
  type: TYPE_NORMAL
- en: fashion, the page that previously carried the page number 41 is now identified
  prefs: []
  type: TYPE_NORMAL
- en: with the page reference number B779E800\. Notice that the references to the
  prefs: []
  type: TYPE_NORMAL
- en: preceding page have been updated as well. The page with the reference num-
  prefs: []
  type: TYPE_NORMAL
- en: ber 8118E736 contains the correct reference number to its preceding page.
  prefs: []
  type: TYPE_NORMAL
- en: '**Figure 14-4\.** Book pages using reference numbers as page numbers'
  prefs: []
  type: TYPE_NORMAL
- en: '***Blockchain Basics***'
  prefs: []
  type: TYPE_NORMAL
- en: '117'
  prefs: []
  type: TYPE_NORMAL
- en: 'Transformation 4: Creating Reference Numbers'
  prefs: []
  type: TYPE_NORMAL
- en: In the previous transformation, we replaced page numbers in our book with
  prefs: []
  type: TYPE_NORMAL
- en: reference numbers. However, I have not discussed how they would be created.
  prefs: []
  type: TYPE_NORMAL
- en: The best way to create unique reference numbers is to use cryptographic
  prefs: []
  type: TYPE_NORMAL
- en: hash values. Hence, we can identify pages in our catalog as well as the corre-
  prefs: []
  type: TYPE_NORMAL
- en: sponding content pages with their cryptographic hash values, which are digital
  prefs: []
  type: TYPE_NORMAL
- en: fingerprints of their content. For simplicity, both Figure [14-3 and Figur](index_split_001.html#116)e
    [14-4](index_split_001.html#117)
  prefs: []
  type: TYPE_NORMAL
- en: use shortened hash values. (You can verify the results by using the tool pro-
  prefs: []
  type: TYPE_NORMAL
- en: '[vided at www.blockchain-basics.com/Hashing.html.) F](http://www.blockchain-basics.com/Hashing.html)or
    example, the content page that contains the word Hello is identified by the shortened
    hash'
  prefs: []
  type: TYPE_NORMAL
- en: value of Hello that is 185F8DB3\. The reference value of our book pages are
  prefs: []
  type: TYPE_NORMAL
- en: calculated based on their content, which is the content reference number and
  prefs: []
  type: TYPE_NORMAL
- en: the reference number of the preceding page. For example, the page reference
  prefs: []
  type: TYPE_NORMAL
- en: number B779E800 is the hash value of 011C01C1 185F8DB3\.
  prefs: []
  type: TYPE_NORMAL
- en: 'Transformation 5: Getting Rid of the Book Spine'
  prefs: []
  type: TYPE_NORMAL
- en: Our ordering catalog is an unusual book because each of its pages contains its
  prefs: []
  type: TYPE_NORMAL
- en: own reference number, the reference number of the preceding page, and the
  prefs: []
  type: TYPE_NORMAL
- en: reference number of the corresponding content page. However, our ordering
  prefs: []
  type: TYPE_NORMAL
- en: catalog is still a traditional book whose pages are fixated in the book spine.
  prefs: []
  type: TYPE_NORMAL
- en: What happens if we get rid of the book spine and turn our ordering book
  prefs: []
  type: TYPE_NORMAL
- en: into a pile of loose pages? By doing so we destroy the physical connection of
  prefs: []
  type: TYPE_NORMAL
- en: the pages and as a result we lose the physical ordering of our pages as well.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, the ordering of the pages is not completely lost. Every page con-
  prefs: []
  type: TYPE_NORMAL
- en: tains the reference number of its preceding page. As a result, we can move
  prefs: []
  type: TYPE_NORMAL
- en: from page to page backward by following the page reference numbers to the
  prefs: []
  type: TYPE_NORMAL
- en: preceding page. If we keep the last page of the ordering catalog separated,
    we
  prefs: []
  type: TYPE_NORMAL
- en: can always browse through all pages in reverse order.
  prefs: []
  type: TYPE_NORMAL
- en: 'Goal Achieved: Appreciating the Result'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s summarize what we have achieved in this example. We turned a classi-
  prefs: []
  type: TYPE_NORMAL
- en: cal book into two physically unordered piles of loose pages that are linked
  prefs: []
  type: TYPE_NORMAL
- en: together with unique reference numbers. One pile of pages contains the
  prefs: []
  type: TYPE_NORMAL
- en: content, while the other pile of pages maintains the ordering. For simplicity,
  prefs: []
  type: TYPE_NORMAL
- en: we refer to the latter pile of pages as an ordering catalog. Each page of the
  prefs: []
  type: TYPE_NORMAL
- en: ordering catalog contains the reference number to its preceding page and
  prefs: []
  type: TYPE_NORMAL
- en: the reference number of the corresponding content page. As a result, we
  prefs: []
  type: TYPE_NORMAL
- en: have separated ordering from storing information and the logical location
  prefs: []
  type: TYPE_NORMAL
- en: (the order) from the physical location of the pages. Due to the fact that we
  prefs: []
  type: TYPE_NORMAL
- en: used hash values as reference numbers, everyone can verify their correctness
  prefs: []
  type: TYPE_NORMAL
- en: '118'
  prefs: []
  type: TYPE_NORMAL
- en: '***Step 14 | Storing Transaction Data***'
  prefs: []
  type: TYPE_NORMAL
- en: by simply recalculating them. Since the pages of the ordering catalog are no
  prefs: []
  type: TYPE_NORMAL
- en: longer fixated on a book spine, we can only browse through it backward in a
  prefs: []
  type: TYPE_NORMAL
- en: page-by-page fashion by following the page reference numbers that point to
  prefs: []
  type: TYPE_NORMAL
- en: the preceding page. For easy reference, Table [14-1 summarizes the pr](index_split_001.html#119)operties
    of our book before and after the transformations.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 14-1\.** Comparing the Book Before and After the Transformation'
  prefs: []
  type: TYPE_NORMAL
- en: '**Property**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Book**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Transformed Book**'
  prefs: []
  type: TYPE_NORMAL
- en: Storing content
  prefs: []
  type: TYPE_NORMAL
- en: On the pages themselves
  prefs: []
  type: TYPE_NORMAL
- en: On separate content pages
  prefs: []
  type: TYPE_NORMAL
- en: Each content page is identified
  prefs: []
  type: TYPE_NORMAL
- en: by a unique reference number
  prefs: []
  type: TYPE_NORMAL
- en: Ordering content
  prefs: []
  type: TYPE_NORMAL
- en: 'Physically: Based on the location'
  prefs: []
  type: TYPE_NORMAL
- en: 'Logically: Via an ordering catalog'
  prefs: []
  type: TYPE_NORMAL
- en: of the pages within the book
  prefs: []
  type: TYPE_NORMAL
- en: that contains reference values
  prefs: []
  type: TYPE_NORMAL
- en: 'Logically: Based on the page'
  prefs: []
  type: TYPE_NORMAL
- en: to the content pages
  prefs: []
  type: TYPE_NORMAL
- en: numbers
  prefs: []
  type: TYPE_NORMAL
- en: Connecting pages
  prefs: []
  type: TYPE_NORMAL
- en: 'Physically: By fixating pages in the'
  prefs: []
  type: TYPE_NORMAL
- en: 'Logically: Via reference numbers'
  prefs: []
  type: TYPE_NORMAL
- en: book spine
  prefs: []
  type: TYPE_NORMAL
- en: 'Logically: Based on page numbers'
  prefs: []
  type: TYPE_NORMAL
- en: Browsing through
  prefs: []
  type: TYPE_NORMAL
- en: Forward
  prefs: []
  type: TYPE_NORMAL
- en: 'Backward only: By following'
  prefs: []
  type: TYPE_NORMAL
- en: the pages
  prefs: []
  type: TYPE_NORMAL
- en: Backward
  prefs: []
  type: TYPE_NORMAL
- en: the reference numbers to the
  prefs: []
  type: TYPE_NORMAL
- en: preceding page
  prefs: []
  type: TYPE_NORMAL
- en: Jumping to pages directly by using
  prefs: []
  type: TYPE_NORMAL
- en: page numbers
  prefs: []
  type: TYPE_NORMAL
- en: The Blockchain-Data-Structure
  prefs: []
  type: TYPE_NORMAL
- en: What is the blockchain-data-structure? Actually, you already know the answer
  prefs: []
  type: TYPE_NORMAL
- en: because the preceding example developed a simplified blockchain-data-struc-
  prefs: []
  type: TYPE_NORMAL
- en: ture. However, we used different terminology. This section finishes the analogy
  prefs: []
  type: TYPE_NORMAL
- en: by linking the elements of the transformed book with the terminology used in
  prefs: []
  type: TYPE_NORMAL
- en: the context of the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our transformed book consists of:'
  prefs: []
  type: TYPE_NORMAL
- en: • A mental unit consisting of a page of the ordering catalog
  prefs: []
  type: TYPE_NORMAL
- en: and its corresponding content page
  prefs: []
  type: TYPE_NORMAL
- en: • A pile of loose pages called the ordering catalog
  prefs: []
  type: TYPE_NORMAL
- en: • A pile of loose pages that contain the content
  prefs: []
  type: TYPE_NORMAL
- en: • Page reference numbers for identifying and linking pages
  prefs: []
  type: TYPE_NORMAL
- en: of the ordering catalog
  prefs: []
  type: TYPE_NORMAL
- en: • Content reference numbers for identifying and linking
  prefs: []
  type: TYPE_NORMAL
- en: content pages
  prefs: []
  type: TYPE_NORMAL
- en: '***Blockchain Basics***'
  prefs: []
  type: TYPE_NORMAL
- en: '119'
  prefs: []
  type: TYPE_NORMAL
- en: For easy reference Table [14-2 at the end of this section summarizes the r](index_split_001.html#120)esults
    by comparing the elements of our simplified book after transformation with
  prefs: []
  type: TYPE_NORMAL
- en: elements of the blockchain-data-structure.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 14-2\.** Comparing the Transformed Book with the Blockchain-Data-Structure
    **Transformed Book**'
  prefs: []
  type: TYPE_NORMAL
- en: '[**Blockchain-Data-Structure1**](index_split_001.html#120)'
  prefs: []
  type: TYPE_NORMAL
- en: A page in the ordering catalog
  prefs: []
  type: TYPE_NORMAL
- en: A block header
  prefs: []
  type: TYPE_NORMAL
- en: The whole ordering catalog
  prefs: []
  type: TYPE_NORMAL
- en: The chain of block headers
  prefs: []
  type: TYPE_NORMAL
- en: The reference number of a page in the
  prefs: []
  type: TYPE_NORMAL
- en: The cryptographic hash value of a block
  prefs: []
  type: TYPE_NORMAL
- en: ordering catalog
  prefs: []
  type: TYPE_NORMAL
- en: header
  prefs: []
  type: TYPE_NORMAL
- en: The reference number to the preceding page
  prefs: []
  type: TYPE_NORMAL
- en: The cryptographic hash value of the
  prefs: []
  type: TYPE_NORMAL
- en: preceding block header
  prefs: []
  type: TYPE_NORMAL
- en: Content
  prefs: []
  type: TYPE_NORMAL
- en: Transaction data
  prefs: []
  type: TYPE_NORMAL
- en: A content page
  prefs: []
  type: TYPE_NORMAL
- en: A Merkle tree containing transaction data
  prefs: []
  type: TYPE_NORMAL
- en: Reference to the content page
  prefs: []
  type: TYPE_NORMAL
- en: The root of the Merkle tree that contains
  prefs: []
  type: TYPE_NORMAL
- en: transaction data
  prefs: []
  type: TYPE_NORMAL
- en: The mental unit of a page of the ordering
  prefs: []
  type: TYPE_NORMAL
- en: One block of the blockchain-data-structure
  prefs: []
  type: TYPE_NORMAL
- en: catalog and its corresponding content page
  prefs: []
  type: TYPE_NORMAL
- en: The whole ordering catalog and all content
  prefs: []
  type: TYPE_NORMAL
- en: The blockchain-data-structure
  prefs: []
  type: TYPE_NORMAL
- en: pages together
  prefs: []
  type: TYPE_NORMAL
- en: The Mental Unit of a Page of the Ordering Catalog
  prefs: []
  type: TYPE_NORMAL
- en: and Its Corresponding Content Page
  prefs: []
  type: TYPE_NORMAL
- en: The mental unit of a page of the ordering catalog and its corresponding con-
  prefs: []
  type: TYPE_NORMAL
- en: tent page relates to one block in the blockchain-data-structure. All these
  prefs: []
  type: TYPE_NORMAL
- en: blocks together form the blockchain-data-structure. It is important to point
  prefs: []
  type: TYPE_NORMAL
- en: out that the unit of ordering page and corresponding content page is only a
  prefs: []
  type: TYPE_NORMAL
- en: mental unit because the pages of the ordering catalog and the content pages
  prefs: []
  type: TYPE_NORMAL
- en: are physically distinct entities. The former refer to the latter via hash refer-
  prefs: []
  type: TYPE_NORMAL
- en: ences, which as a result constitutes the mental unity.
  prefs: []
  type: TYPE_NORMAL
- en: Ordering Catalog
  prefs: []
  type: TYPE_NORMAL
- en: The ordering catalog of our transformed book equates to the chain of block
  prefs: []
  type: TYPE_NORMAL
- en: headers in the blockchain-data-structure. Each page of the ordering catalog
  prefs: []
  type: TYPE_NORMAL
- en: equates to a single block header in the blockchain-data-structure. Since the
  prefs: []
  type: TYPE_NORMAL
- en: '1Nakamoto, Satoshi. Bitcoin: A peer-to-peer electronic cash system. 2008\.
    [https://](https://bitcoin.org/bitcoin.pdf)'
  prefs: []
  type: TYPE_NORMAL
- en: '[bitcoin.org/bitcoin.pdf](https://bitcoin.org/bitcoin.pdf).'
  prefs: []
  type: TYPE_NORMAL
- en: '120'
  prefs: []
  type: TYPE_NORMAL
- en: '***Step 14 | Storing Transaction Data***'
  prefs: []
  type: TYPE_NORMAL
- en: block headers are connected with one another via references in a linear fash-
  prefs: []
  type: TYPE_NORMAL
- en: ion, like the links of a chain, they form a chain of block headers. Similar
    to
  prefs: []
  type: TYPE_NORMAL
- en: our ordering catalog, the chain of block headers does not store transaction
  prefs: []
  type: TYPE_NORMAL
- en: data directly, but only stores hash references to the corresponding transac-
  prefs: []
  type: TYPE_NORMAL
- en: tion data. This is the point where the mental unit of the ordering catalog and
  prefs: []
  type: TYPE_NORMAL
- en: content becomes important.
  prefs: []
  type: TYPE_NORMAL
- en: Content Pages
  prefs: []
  type: TYPE_NORMAL
- en: The content of the transformed book is equivalent to the transaction data
  prefs: []
  type: TYPE_NORMAL
- en: being maintained by the blockchain. They are specific to our application area
  prefs: []
  type: TYPE_NORMAL
- en: that is managing ownership. There are no content pages in real-world block-
  prefs: []
  type: TYPE_NORMAL
- en: chain applications; I made up the term content pages for didactical reasons.
  prefs: []
  type: TYPE_NORMAL
- en: Real-world blockchain applications store the content data (e.g., transaction
  prefs: []
  type: TYPE_NORMAL
- en: data) directly in a database, and we refer to them as Merkle trees, whose roots
  prefs: []
  type: TYPE_NORMAL
- en: are stored in block headers.
  prefs: []
  type: TYPE_NORMAL
- en: Catalog Page Reference Numbers
  prefs: []
  type: TYPE_NORMAL
- en: The page reference numbers of our transformed book used to identify pages
  prefs: []
  type: TYPE_NORMAL
- en: of the ordering catalog equate to cryptographic hash values of individual block
  prefs: []
  type: TYPE_NORMAL
- en: headers in the blockchain-data-structure. They are called block hash or pre-
  prefs: []
  type: TYPE_NORMAL
- en: vious block’s hash, respectively. They are used to identify each block header
  prefs: []
  type: TYPE_NORMAL
- en: uniquely and to refer to the previous block header. The actual referencing
  prefs: []
  type: TYPE_NORMAL
- en: from one block header to its predecessor is done by hash reference.
  prefs: []
  type: TYPE_NORMAL
- en: Content Reference Numbers
  prefs: []
  type: TYPE_NORMAL
- en: The content reference numbers in our transformed book used to identify
  prefs: []
  type: TYPE_NORMAL
- en: content pages equate to hash references in the chain of block headers that
  prefs: []
  type: TYPE_NORMAL
- en: point to the associated transaction data. To be more specific, the content ref-
  prefs: []
  type: TYPE_NORMAL
- en: erence number that is stored in a block header is the root of a Merkle tree
  prefs: []
  type: TYPE_NORMAL
- en: of the transaction data being stored in a database. This is the point where
    the
  prefs: []
  type: TYPE_NORMAL
- en: mental unit of the ordering catalog (block header) and its corresponding con-
  prefs: []
  type: TYPE_NORMAL
- en: tent (Merkle tree with transaction data) are constituted.
  prefs: []
  type: TYPE_NORMAL
- en: Storing Transactions in the Blockchain-Data-
  prefs: []
  type: TYPE_NORMAL
- en: Structure
  prefs: []
  type: TYPE_NORMAL
- en: Figure [14-5](index_split_001.html#122) summarizes what you have learned by
    schematically depicting a blockchain-data-structure that stores four transactions.
    The illustration given
  prefs: []
  type: TYPE_NORMAL
- en: in Figure [14-5 sho](index_split_001.html#122)ws a simplified blockchain-data-structure
    that consists of
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-122_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '***Blockchain Basics***'
  prefs: []
  type: TYPE_NORMAL
- en: '121'
  prefs: []
  type: TYPE_NORMAL
- en: two blocks labeled BLOCK 1 and BLOCK 2\. In order to emphasize the men-
  prefs: []
  type: TYPE_NORMAL
- en: tal nature of the blocks, they are drawn with dashed lines. Both blocks con-
  prefs: []
  type: TYPE_NORMAL
- en: tain block headers labeled Block Header 1 and Block Header 2, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: BLOCK 1 is the very first block in this data structure, hence, it does not have
  prefs: []
  type: TYPE_NORMAL
- en: a preceding block, and, consequently, Block Header 1 does not contain any ref-
  prefs: []
  type: TYPE_NORMAL
- en: erence to a preceding block header. Since BLOCK 2 has a predecessor, Block
  prefs: []
  type: TYPE_NORMAL
- en: Header 2 maintains a hash reference to its preceding block header labeled as
  prefs: []
  type: TYPE_NORMAL
- en: B1\. The depicted blockchain-data-structure maintains hash reference to two
  prefs: []
  type: TYPE_NORMAL
- en: distinct Merkle trees whose roots are labeled R12 and R34, respectively. The
  prefs: []
  type: TYPE_NORMAL
- en: labels of the Merkle roots already give us an indication of the transaction
    data they contain (e.g., the Merkle tree with the root R12 contains the first
    two
  prefs: []
  type: TYPE_NORMAL
- en: transactions labeled as Transaction 1 and Transaction 2 and their correspond-
  prefs: []
  type: TYPE_NORMAL
- en: ing hash references R1 and R2 that point to them).
  prefs: []
  type: TYPE_NORMAL
- en: If you joined a distributed peer-to-peer system that maintained a blockchain-data-structure,
    as shown in Figure [14-5](index_split_001.html#122), you would receive all transaction
    data, all hash reference values, and all block headers. Based on these data, your
    local computer would create the blockchain-data-structure including the hash references
    that
  prefs: []
  type: TYPE_NORMAL
- en: point to data stored on your local computer. Equipped with these data and the
  prefs: []
  type: TYPE_NORMAL
- en: reference to the most current block header, you could browse through the
  prefs: []
  type: TYPE_NORMAL
- en: history of all transaction data that were ever submitted to the system since
  prefs: []
  type: TYPE_NORMAL
- en: its creation in reverse order, which in our case is just four transactions.
    Note that the reference to the most currently added block header is called the
  prefs: []
  type: TYPE_NORMAL
- en: '**head** of the blockchain-data-structure because it is the place where the
    next block will be added. Sometimes both the most currently added block header'
  prefs: []
  type: TYPE_NORMAL
- en: and the reference that points to it is called the head of the blockchain-data-
  prefs: []
  type: TYPE_NORMAL
- en: structure. In Figure 14-5 the reference labeled B2 is the head of the block-
  prefs: []
  type: TYPE_NORMAL
- en: 'chain-data-structure. It is important not to mix the terms “head” and “header”:'
  prefs: []
  type: TYPE_NORMAL
- en: The blockchain-data-structure consists of many blocks that each has its own
  prefs: []
  type: TYPE_NORMAL
- en: header, but the whole blockchain-data-structure has only one head.
  prefs: []
  type: TYPE_NORMAL
- en: '**Figure 14-5\.** A simplified blockchain-data-structure containing four transactions'
  prefs: []
  type: TYPE_NORMAL
- en: '122'
  prefs: []
  type: TYPE_NORMAL
- en: '***Step 14 | Storing Transaction Data***'
  prefs: []
  type: TYPE_NORMAL
- en: ■ **Caution** The blockchain-data-structure discussed in this step and illustrated
    in Figure [14-5](index_split_001.html#122)
  prefs: []
  type: TYPE_NORMAL
- en: has been simplified for didactical reasons. Many details regarding the information
    stored in the block headers have been left out deliberately. Some of them will
    be covered in the next steps as you complete your understanding of the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: Outlook
  prefs: []
  type: TYPE_NORMAL
- en: This step introduced the blockchain-data-structure and explained its con-
  prefs: []
  type: TYPE_NORMAL
- en: struction. The way in which the blockchain-data-structure makes extensive
  prefs: []
  type: TYPE_NORMAL
- en: use of hash references makes it a very change-sensitive data store. The next
  prefs: []
  type: TYPE_NORMAL
- en: step explains that property in more detail, as it is the key to understanding
  prefs: []
  type: TYPE_NORMAL
- en: how the blockchain is made secure.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs: []
  type: TYPE_NORMAL
- en: • The blockchain-data-structure is a specific kind of data
  prefs: []
  type: TYPE_NORMAL
- en: structure that is made up of ordered units called blocks.
  prefs: []
  type: TYPE_NORMAL
- en: • Each block of the blockchain-data-structure consists of a
  prefs: []
  type: TYPE_NORMAL
- en: block header and a Merkle tree that contains transaction
  prefs: []
  type: TYPE_NORMAL
- en: data.
  prefs: []
  type: TYPE_NORMAL
- en: • The blockchain-data-structure consists of two major data
  prefs: []
  type: TYPE_NORMAL
- en: 'structures: an ordered chain of block headers and Merkle'
  prefs: []
  type: TYPE_NORMAL
- en: trees.
  prefs: []
  type: TYPE_NORMAL
- en: • One can imagine the ordered chain of block headers as being
  prefs: []
  type: TYPE_NORMAL
- en: the digital equivalent to an old-fashioned library card catalog,
  prefs: []
  type: TYPE_NORMAL
- en: where the individual catalog cards are sorted according to
  prefs: []
  type: TYPE_NORMAL
- en: the order in which they were added to the catalog.
  prefs: []
  type: TYPE_NORMAL
- en: • Having each block header referencing its preced-
  prefs: []
  type: TYPE_NORMAL
- en: ing block header preserves the order of the individual
  prefs: []
  type: TYPE_NORMAL
- en: block headers and blocks, respectively, that make up the
  prefs: []
  type: TYPE_NORMAL
- en: blockchain-data-structure.
  prefs: []
  type: TYPE_NORMAL
- en: • Each block header in the blockchain-data-structure is
  prefs: []
  type: TYPE_NORMAL
- en: identified by its cryptographic hash value and contains a
  prefs: []
  type: TYPE_NORMAL
- en: hash reference to its preceding block header and a hash
  prefs: []
  type: TYPE_NORMAL
- en: reference to the application-specific data whose order it
  prefs: []
  type: TYPE_NORMAL
- en: maintains.
  prefs: []
  type: TYPE_NORMAL
- en: • The hash reference to the application-specific data is
  prefs: []
  type: TYPE_NORMAL
- en: typically the root of a Merkle tree that maintains hash
  prefs: []
  type: TYPE_NORMAL
- en: references to the application-specific data.
  prefs: []
  type: TYPE_NORMAL
- en: '**S T E P**'
  prefs: []
  type: TYPE_NORMAL
- en: '15'
  prefs: []
  type: TYPE_NORMAL
- en: Using the Data
  prefs: []
  type: TYPE_NORMAL
- en: Store
  prefs: []
  type: TYPE_NORMAL
- en: Chaining blocks of data
  prefs: []
  type: TYPE_NORMAL
- en: 'Step [14 intr](http://dx.doi.org/10.1007/978-1-4842-2604-9_14)oduced the blockchain-data-structure.
    It turns out that the blockchain-data-structure consists of two major components:
    an ordered chain of'
  prefs: []
  type: TYPE_NORMAL
- en: block headers and Merkle trees containing transaction data. This data structure
  prefs: []
  type: TYPE_NORMAL
- en: was invented with the goal of storing transaction data in a secure fashion.
    But
  prefs: []
  type: TYPE_NORMAL
- en: what does storing data in a secure fashion mean in this context? Answering
  prefs: []
  type: TYPE_NORMAL
- en: this question is the purpose of this step. This step points out the consequences
    of changing data in the blockchain and it illustrates how the blockchain-data-structure
    detects changes. Furthermore, this step highlights the power of hash
  prefs: []
  type: TYPE_NORMAL
- en: references when storing data in a change-sensitive manner. Finally, this step
    explains how to add new blocks to the blockchain-data-structure in a correct way.
  prefs: []
  type: TYPE_NORMAL
- en: The Metaphor
  prefs: []
  type: TYPE_NORMAL
- en: Knitting is the craft of turning yarn into a textile or fabric by creating a
  prefs: []
  type: TYPE_NORMAL
- en: sequence of multiple interlocking loops of yarn, the so-called stitches. When
  prefs: []
  type: TYPE_NORMAL
- en: produced manually, the sizes of knitting stitches vary significantly. Hence,
    during the process of knitting, it is sometimes necessary to correct individual
    stitches.
  prefs: []
  type: TYPE_NORMAL
- en: In order to correct a knitting stitch located somewhere in the fabric, one has
  prefs: []
  type: TYPE_NORMAL
- en: © Daniel Drescher 2017
  prefs: []
  type: TYPE_NORMAL
- en: D. Drescher, *Blockchain Basics*, DOI 10.1007/978-1-4842-2604-9_15
  prefs: []
  type: TYPE_NORMAL
- en: '124'
  prefs: []
  type: TYPE_NORMAL
- en: '***Step 15 | Using the Data Store***'
  prefs: []
  type: TYPE_NORMAL
- en: to rip out all of its succeeding stitches in reverse order starting from the
    end of the row until one eventually arrives at the stitch to be corrected. After
    the stitch under consideration has been corrected, one has to re-create all its
  prefs: []
  type: TYPE_NORMAL
- en: succeeding stitches. Since this procedure is quite elaborate, it is important
    to ensure that all stitches fulfill the quality requirements when they are created
  prefs: []
  type: TYPE_NORMAL
- en: the first time. This step explains that using the blockchain-data-structure
    is
  prefs: []
  type: TYPE_NORMAL
- en: 'very similar to knitting: Adding a new block at the end of the blockchain-data-'
  prefs: []
  type: TYPE_NORMAL
- en: structure is easy, while changing data located somewhere in the chain is quite
  prefs: []
  type: TYPE_NORMAL
- en: elaborate. With this metaphor in mind, you should easily be able to understand
  prefs: []
  type: TYPE_NORMAL
- en: how the blockchain-data-structure detects changes, on the one hand, and how
  prefs: []
  type: TYPE_NORMAL
- en: data are added and changed correctly, on the other hand.
  prefs: []
  type: TYPE_NORMAL
- en: Adding New Transactions
  prefs: []
  type: TYPE_NORMAL
- en: In order to understand how to add new transactions to an existing block-
  prefs: []
  type: TYPE_NORMAL
- en: chain-data-structure in an orderly way, let’s consider a simple example.
  prefs: []
  type: TYPE_NORMAL
- en: Figure [15-1](index_split_001.html#126) illustrates the initial situation of
    a blockchain-data-structure that consist of one block only. The existing blockchain-data-structure
    only maintains two transactions. Transaction 3 and Transaction 4 at the bottom
    of
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure [15-1](index_split_001.html#126) are not yet added to the blockchain-data-structure.
    The steps to be performed in order to add new transaction data are:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Create a new Merkle tree that contains all new transac-
  prefs: []
  type: TYPE_NORMAL
- en: tion data to be added, as shown in Figure [15-2\.](index_split_001.html#126)
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Create a new block header (Block Header 2) that con-
  prefs: []
  type: TYPE_NORMAL
- en: tains both the hash reference (B1) that points to the
  prefs: []
  type: TYPE_NORMAL
- en: header of its preceeding block (Block Header 1) and the
  prefs: []
  type: TYPE_NORMAL
- en: root of the Merkle tree that contains the new transaction
  prefs: []
  type: TYPE_NORMAL
- en: data (R34), as shown in Figure [15-3\.](index_split_001.html#127)
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Create a new hash reference (B2) to the new block
  prefs: []
  type: TYPE_NORMAL
- en: header, as shown in Figure [15-4,](index_split_001.html#127) and declare it
    the the new **head** of the updated blockchain-data-structure.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that the reference that points to the most
  prefs: []
  type: TYPE_NORMAL
- en: currently added piece of data in a chain is also called the
  prefs: []
  type: TYPE_NORMAL
- en: '**head** of the whole chain (see Step [11](http://dx.doi.org/10.1007/978-1-4842-2604-9_11)).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-126_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](index-126_2.png)'
  prefs: []
  type: TYPE_IMG
- en: '***Blockchain Basics***'
  prefs: []
  type: TYPE_NORMAL
- en: '125'
  prefs: []
  type: TYPE_NORMAL
- en: '**Figure 15-1\.** Initial situation: Two new transactions (Transaction 3 and
    Transaction 4) should be added to the existing blockchain-data-structure'
  prefs: []
  type: TYPE_NORMAL
- en: '**Figure 15-2\.** [Step 1](http://dx.doi.org/10.1007/978-1-4842-2604-9_1):
    Creating a new Merkle tree that contains the new transactions'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-127_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](index-127_2.png)'
  prefs: []
  type: TYPE_IMG
- en: '126'
  prefs: []
  type: TYPE_NORMAL
- en: '***Step 15 | Using the Data Store***'
  prefs: []
  type: TYPE_NORMAL
- en: '**Figure 15-3\.** [Step 2](http://dx.doi.org/10.1007/978-1-4842-2604-9_2):
    Create a new block header that contains both the hash reference to its preceding
    header and the root of the Merkle tree that contains the new transaction data
    **Figure 15-4\.** [Step 3](http://dx.doi.org/10.1007/978-1-4842-2604-9_3): Create
    a new hash reference that points to the new block header, which is now the new
    head of the whole updated blockchain-data-structure'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-128_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '***Blockchain Basics***'
  prefs: []
  type: TYPE_NORMAL
- en: '127'
  prefs: []
  type: TYPE_NORMAL
- en: Detecting Changes
  prefs: []
  type: TYPE_NORMAL
- en: The step depicted in Figure [15-4 ser](index_split_001.html#127)ves as the initial
    situation for studying the impact of changing data that are already part of the
    blockchain-data-structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'I will discuss the following cases:'
  prefs: []
  type: TYPE_NORMAL
- en: • Changing the content of transaction data
  prefs: []
  type: TYPE_NORMAL
- en: • Changing a reference in the Merkle tree
  prefs: []
  type: TYPE_NORMAL
- en: • Replacing a transaction
  prefs: []
  type: TYPE_NORMAL
- en: • Changing the Merkle root
  prefs: []
  type: TYPE_NORMAL
- en: • Changing a block header reference
  prefs: []
  type: TYPE_NORMAL
- en: Changing the Content of Transaction Data
  prefs: []
  type: TYPE_NORMAL
- en: Figure [15-5](index_split_001.html#128) illustrates what happens if we change
    Transaction 2\. This transaction is part of a Merkle tree, which consists of hash
    references. By changing some
  prefs: []
  type: TYPE_NORMAL
- en: properties of the Transaction 2 (e.g., the amount of goods being transferred
  prefs: []
  type: TYPE_NORMAL
- en: or the account that receives ownership), one also changes its fingerprint or
    its cryptographic hash value, respectively. As a result, the hash reference R2
    that
  prefs: []
  type: TYPE_NORMAL
- en: pointed to the original transaction data is broken. It detects that the transaction
    data it originally referred were changed in the meantime and hence violates the
  prefs: []
  type: TYPE_NORMAL
- en: rules of staying unchanged. As a result, the whole blockchain-data-structure
    is
  prefs: []
  type: TYPE_NORMAL
- en: invalid.
  prefs: []
  type: TYPE_NORMAL
- en: '**Figure 15-5\.** Changing the details of a transaction invalidates the hash
    reference that pointed to the original data, which invalidates the whole data
    structure'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-129_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '128'
  prefs: []
  type: TYPE_NORMAL
- en: '***Step 15 | Using the Data Store***'
  prefs: []
  type: TYPE_NORMAL
- en: Changing a Reference in the Merkle Tree
  prefs: []
  type: TYPE_NORMAL
- en: Figure [15-6](index_split_001.html#129) illustrates what happens if one not
    only changes details of a transaction but also changes the hash reference that
    points to the updated trans-
  prefs: []
  type: TYPE_NORMAL
- en: action. The updated hash reference (R2) is valid as it correctly points to the
  prefs: []
  type: TYPE_NORMAL
- en: new transaction data. However, the updated hash reference is part of a Merkle
  prefs: []
  type: TYPE_NORMAL
- en: tree whose root is a hash reference as well. The root of the Merkle tree (R12)
  prefs: []
  type: TYPE_NORMAL
- en: points to a piece of data that contains the hash references R1 and R2\. The
  prefs: []
  type: TYPE_NORMAL
- en: latter one has been changed in order to be consistent with the manipulated
  prefs: []
  type: TYPE_NORMAL
- en: version of Transaction 2\. Hence, the cryptographic hash value of the piece
  prefs: []
  type: TYPE_NORMAL
- en: of data containing the updated version of R2 changes as well, which in turn
  prefs: []
  type: TYPE_NORMAL
- en: invalidates the root of the Merkle tree R12\.
  prefs: []
  type: TYPE_NORMAL
- en: '**Figure 15-6\.** Changing a transaction and its hash reference in the Merkle
    tree invalidates the root of the Merkle tree, which invalidates the whole data
    structure'
  prefs: []
  type: TYPE_NORMAL
- en: Replacing a Transaction
  prefs: []
  type: TYPE_NORMAL
- en: Figure [15-7](index_split_001.html#130) considers the case of replacing a whole
    transaction instead of only manipulating details of an existing transaction and
    updating its hash reference.
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-130_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '***Blockchain Basics***'
  prefs: []
  type: TYPE_NORMAL
- en: '129'
  prefs: []
  type: TYPE_NORMAL
- en: '**Figure 15-7\.** Replacing a transaction and its hash reference in the Merkle
    tree invalidates the root of the Merkle tree, which invalidates the whole data
    structure'
  prefs: []
  type: TYPE_NORMAL
- en: When you compare Figure [15-6](index_split_001.html#129) with Figure [15-7](index_split_001.html#130),
    you can only find minor difference regarding the name of the transaction and its
    hash reference.
  prefs: []
  type: TYPE_NORMAL
- en: Concerning the consequences, both illustrations are identical. In both cases
  prefs: []
  type: TYPE_NORMAL
- en: the root of the Merkle tree R12 will be invalid due to changes that happened
  prefs: []
  type: TYPE_NORMAL
- en: within the Merkle tree. As a result, we find that changing a transaction or
  prefs: []
  type: TYPE_NORMAL
- en: replacing a transaction will have the same impact on the blockchain-data-
  prefs: []
  type: TYPE_NORMAL
- en: structure. The manipulation will be detected in both cases and will invalidate
  prefs: []
  type: TYPE_NORMAL
- en: the whole data structure.
  prefs: []
  type: TYPE_NORMAL
- en: ■ **Note** Changing or replacing data in the blockchain-data-structure will
    have identical results as both have identical effects on hash references.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the Merkle Root
  prefs: []
  type: TYPE_NORMAL
- en: Figure [15-8 illustrates](index_split_001.html#131) what happens if a whole
    Merkle tree, including its root, is changed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-131_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '130'
  prefs: []
  type: TYPE_NORMAL
- en: '***Step 15 | Using the Data Store***'
  prefs: []
  type: TYPE_NORMAL
- en: '**Figure 15-8\.** Changing a Merkle tree invalidates the hash reference that
    points to the block header that contains it, which in turn invalidates the whole
    data structure'
  prefs: []
  type: TYPE_NORMAL
- en: The root of the manipulated Merkle tree (R12) is part of a block header
  prefs: []
  type: TYPE_NORMAL
- en: (Block Header 1). The change of the Merkle root changes the cryptographic
  prefs: []
  type: TYPE_NORMAL
- en: hash value of Block Header 1, which in turn causes the hash reference that
  prefs: []
  type: TYPE_NORMAL
- en: points to it (B1) to be invalid. The hash reference B1 that maintains the con-
  prefs: []
  type: TYPE_NORMAL
- en: nection or serves as a link from Block Header 2 to Block Header 1 becomes
  prefs: []
  type: TYPE_NORMAL
- en: invalid as it detects the change. As a result, the whole blockchain-data-struc-
  prefs: []
  type: TYPE_NORMAL
- en: ture becomes invalid.
  prefs: []
  type: TYPE_NORMAL
- en: Changing a Block Header Reference
  prefs: []
  type: TYPE_NORMAL
- en: Figure [15-9](index_split_001.html#132) illustrates what happens if not only
    a whole Merkle tree but also the hash reference to the manipulated block header
    is changed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-132_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '***Blockchain Basics***'
  prefs: []
  type: TYPE_NORMAL
- en: '131'
  prefs: []
  type: TYPE_NORMAL
- en: '**Figure 15-9\.** Changing a hash reference within a block header invalidates
    the hash reference that points to the manipulated block header, which in turn
    invalidates the whole data structure'
  prefs: []
  type: TYPE_NORMAL
- en: If the hash reference (B1) to the manipulated block header (Block Header 1)
  prefs: []
  type: TYPE_NORMAL
- en: 'is changed, the following happens: Starting with hash reference B1, all hash
    references that point toward the manipulated data are consistent and valid since'
  prefs: []
  type: TYPE_NORMAL
- en: they were adjusted to the performed manipulation. However, the manipulated
  prefs: []
  type: TYPE_NORMAL
- en: hash reference B1 is part of Block Header 2 and hence its cryptographic hash
  prefs: []
  type: TYPE_NORMAL
- en: value changes, which in turn invalidates the hash reference B2 that pointed
    to
  prefs: []
  type: TYPE_NORMAL
- en: the original data block header containing the original version of the hash ref-
  prefs: []
  type: TYPE_NORMAL
- en: erence B1\. As a result, the whole blockchain-data-structure is invalid as well.
  prefs: []
  type: TYPE_NORMAL
- en: Changing Data Orderly
  prefs: []
  type: TYPE_NORMAL
- en: After this discussion of the many approaches to manipulate the blockchain-data-
  prefs: []
  type: TYPE_NORMAL
- en: structure, which all yielded an invalid data structure, it is time to illustrate
    what needs to be done to change or update the blockchain-data-structure orderly.
  prefs: []
  type: TYPE_NORMAL
- en: Figure [15-10 illustrates ho](index_split_001.html#133)w to change the blockchain-data-structure
    in the correct way.
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-133_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '132'
  prefs: []
  type: TYPE_NORMAL
- en: '***Step 15 | Using the Data Store***'
  prefs: []
  type: TYPE_NORMAL
- en: '**Figure 15-10\.** Changing a transaction orderly includes changing all subsequent
    hash references'
  prefs: []
  type: TYPE_NORMAL
- en: If we consider changing or updating some details of Transaction 2, we have
  prefs: []
  type: TYPE_NORMAL
- en: 'to subsequently update the whole sequence of hash references: R2, R12, B1,'
  prefs: []
  type: TYPE_NORMAL
- en: and B2\. This means that all hash references, starting with the one that directly
    points to the manipulated data and ending with the hash reference that points
  prefs: []
  type: TYPE_NORMAL
- en: to the most recent block header as well as all hash references in between
  prefs: []
  type: TYPE_NORMAL
- en: them, need to be changed and updated so that they reflect the changes of
  prefs: []
  type: TYPE_NORMAL
- en: their targets. This is quite an elaborate task. And it is an elaborate process
  prefs: []
  type: TYPE_NORMAL
- en: on purpose. All of this work is necessary to keep the whole blockchain-data-
  prefs: []
  type: TYPE_NORMAL
- en: structure consistent and to keep its integrity. All other attempts to change
  prefs: []
  type: TYPE_NORMAL
- en: or manipulate data that are part of the blockchain-data-structure will cause
  prefs: []
  type: TYPE_NORMAL
- en: invalid hash references, which in turn will invalidate the whole data structure.
  prefs: []
  type: TYPE_NORMAL
- en: Intended vs. Unintended Changes
  prefs: []
  type: TYPE_NORMAL
- en: The preceding discussion showed that the blockchain-data-structure pur-
  prefs: []
  type: TYPE_NORMAL
- en: 'sues a radical all-or-nothing approach when it comes to changing its data:'
  prefs: []
  type: TYPE_NORMAL
- en: One either changes the whole data structure completely from the point that
  prefs: []
  type: TYPE_NORMAL
- en: causes the change until the head of the whole chain or one better leave it all
  prefs: []
  type: TYPE_NORMAL
- en: unchanged in the first place. All other half-hearted, halfway through, or par-
  prefs: []
  type: TYPE_NORMAL
- en: tial changes will leave the whole blockchain-data-structure in an inconsistent
  prefs: []
  type: TYPE_NORMAL
- en: state, which will be detected easily and quickly. This is due to the properties
    of hash references, where the blockchain-data-structure does not differentiate
  prefs: []
  type: TYPE_NORMAL
- en: between intended or unintended changes. Actually there are no such things
  prefs: []
  type: TYPE_NORMAL
- en: as intended or unintended changes in the blockchain. These words refer to a
  prefs: []
  type: TYPE_NORMAL
- en: valuation of the motives or the person who caused a change. But the block-
  prefs: []
  type: TYPE_NORMAL
- en: chain-data-structure values neither the motives nor the person who causes an
  prefs: []
  type: TYPE_NORMAL
- en: '***Blockchain Basics***'
  prefs: []
  type: TYPE_NORMAL
- en: '133'
  prefs: []
  type: TYPE_NORMAL
- en: inconsistency. The blockchain only cares about correctness and consistency
  prefs: []
  type: TYPE_NORMAL
- en: of all its hash references. If one of them is invalid, the whole data structure
    is invalid, regardless of who or what caused that change or why it was made. And
  prefs: []
  type: TYPE_NORMAL
- en: this property makes the blockchain-data-structure very valuable.
  prefs: []
  type: TYPE_NORMAL
- en: Outlook
  prefs: []
  type: TYPE_NORMAL
- en: This step illustrated in great detail how the blockchain-data-structure deals
  prefs: []
  type: TYPE_NORMAL
- en: with changes of its data. It turned out that the blockchain-data-structure is
  prefs: []
  type: TYPE_NORMAL
- en: very change sensitive. It pursues a radical all-or-nothing approach when it
  prefs: []
  type: TYPE_NORMAL
- en: comes to changing its data. The next step explains how this property can be
  prefs: []
  type: TYPE_NORMAL
- en: used to make data unchangeable, which makes the blockchain-data-structure
  prefs: []
  type: TYPE_NORMAL
- en: the perfect candidate for storing data in an unreliable and untrustworthy
  prefs: []
  type: TYPE_NORMAL
- en: environment.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs: []
  type: TYPE_NORMAL
- en: • The steps to be performed in order to add new transac-
  prefs: []
  type: TYPE_NORMAL
- en: 'tion data to the blockchain-data-structure are:'
  prefs: []
  type: TYPE_NORMAL
- en: • Create a new Merkle tree that contains all new
  prefs: []
  type: TYPE_NORMAL
- en: transaction data to be added.
  prefs: []
  type: TYPE_NORMAL
- en: • Create a new block header that contains both a hash
  prefs: []
  type: TYPE_NORMAL
- en: reference to its preceding header and the root of the
  prefs: []
  type: TYPE_NORMAL
- en: Merkle tree that contains the new transaction data.
  prefs: []
  type: TYPE_NORMAL
- en: • Create a hash reference to the new block header,
  prefs: []
  type: TYPE_NORMAL
- en: which is now the current head of the blockchain-
  prefs: []
  type: TYPE_NORMAL
- en: data-structure.
  prefs: []
  type: TYPE_NORMAL
- en: • Changing data in the blockchain-data-structure requires
  prefs: []
  type: TYPE_NORMAL
- en: renewing all hash references starting with the one that
  prefs: []
  type: TYPE_NORMAL
- en: directly points to the manipulated data and ending with
  prefs: []
  type: TYPE_NORMAL
- en: the head of the whole blockchain-data-structure as well
  prefs: []
  type: TYPE_NORMAL
- en: as all hash references in between them.
  prefs: []
  type: TYPE_NORMAL
- en: • The blockchain-data-structure pursues a radical all-or-
  prefs: []
  type: TYPE_NORMAL
- en: 'nothing approach when it comes to changing its data:'
  prefs: []
  type: TYPE_NORMAL
- en: One either changes the whole data structure completely
  prefs: []
  type: TYPE_NORMAL
- en: starting from the point that causes the change until the
  prefs: []
  type: TYPE_NORMAL
- en: head of the whole chain or one better leave it unchanged
  prefs: []
  type: TYPE_NORMAL
- en: in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: '134'
  prefs: []
  type: TYPE_NORMAL
- en: '***Step 15 | Using the Data Store***'
  prefs: []
  type: TYPE_NORMAL
- en: • All half-hearted, halfway through, or partial changes will
  prefs: []
  type: TYPE_NORMAL
- en: leave the whole blockchain-data-structure in an inconsis-
  prefs: []
  type: TYPE_NORMAL
- en: tent state, which will be detected easily and quickly.
  prefs: []
  type: TYPE_NORMAL
- en: • Changing the blockchain-data-structure completely is a
  prefs: []
  type: TYPE_NORMAL
- en: very elaborate process on purpose.
  prefs: []
  type: TYPE_NORMAL
- en: • The high sensitivity of the blockchain-data-structure
  prefs: []
  type: TYPE_NORMAL
- en: regarding changes is due to the properties of hash
  prefs: []
  type: TYPE_NORMAL
- en: references.
  prefs: []
  type: TYPE_NORMAL
- en: '**S T E P**'
  prefs: []
  type: TYPE_NORMAL
- en: '16'
  prefs: []
  type: TYPE_NORMAL
- en: Protecting the
  prefs: []
  type: TYPE_NORMAL
- en: Data Store
  prefs: []
  type: TYPE_NORMAL
- en: Discovering the power of immutability
  prefs: []
  type: TYPE_NORMAL
- en: Step [15](http://dx.doi.org/10.1007/978-1-4842-2604-9_15) concluded with the
    finding that the blockchain-data-structure stores data in a change-sensitive manner.
    Any alteration of data stored in the blockchain-data-structure will stand out
    and require an elaborate process for
  prefs: []
  type: TYPE_NORMAL
- en: incorporating it into the existing structure. This step explains how that prop-
  prefs: []
  type: TYPE_NORMAL
- en: erty can be used to prepare the history of transaction data to be shared
  prefs: []
  type: TYPE_NORMAL
- en: and distributed in an untrustworthy environment without having to fear that
  prefs: []
  type: TYPE_NORMAL
- en: dishonest members of a peer-to-peer system can manipulate its content for
  prefs: []
  type: TYPE_NORMAL
- en: its own advantage.
  prefs: []
  type: TYPE_NORMAL
- en: The Metaphor
  prefs: []
  type: TYPE_NORMAL
- en: Let’s assume I want to pretend to be a member of a prestigious aristocratic
  prefs: []
  type: TYPE_NORMAL
- en: family. How could I achieve that? Forging my family tree could do that. For
  prefs: []
  type: TYPE_NORMAL
- en: example, I could make up an aristocratic grandfather and connect myself to
  prefs: []
  type: TYPE_NORMAL
- en: him with a forged family tree. Will this suffice to convince others from my
  prefs: []
  type: TYPE_NORMAL
- en: fake aristocratic roots? Well, this fake will be quickly uncovered since family
  prefs: []
  type: TYPE_NORMAL
- en: trees rarely exist in isolation; instead, they are connected and interwoven
    with other family trees via family relationships. Hence, if none of the family
    trees
  prefs: []
  type: TYPE_NORMAL
- en: © Daniel Drescher 2017
  prefs: []
  type: TYPE_NORMAL
- en: D. Drescher, *Blockchain Basics*, DOI 10.1007/978-1-4842-2604-9_16
  prefs: []
  type: TYPE_NORMAL
- en: '136'
  prefs: []
  type: TYPE_NORMAL
- en: '***Step 16 | Protecting the Data Store***'
  prefs: []
  type: TYPE_NORMAL
- en: of the established aristocratic families have a reference or relation to my
    fic-
  prefs: []
  type: TYPE_NORMAL
- en: tional grandfather, my fictional family history will be quickly discovered as
    fake.
  prefs: []
  type: TYPE_NORMAL
- en: In order to get my fictional family accepted, I would need to forge the family
  prefs: []
  type: TYPE_NORMAL
- en: documents of some of the established aristocratic families by embedding ref-
  prefs: []
  type: TYPE_NORMAL
- en: erences to my fictional family tree in their family history. But even this may
    not suffice. Real people have real lives and leave their footprints in our world.
    But my fictional grandfather never really lived. Hence, I have to make up his
    life in order to make the fake appear real. This implies that I have to invent
    the entire life of my fictional grandfather, including his childhood as well as
    his education and career history. Additionally, the supporting documents would
    also need to
  prefs: []
  type: TYPE_NORMAL
- en: be faked, such as the birth certificate, school registration documents, school
  prefs: []
  type: TYPE_NORMAL
- en: certificates, university degrees, professional certifications, memberships,
    and
  prefs: []
  type: TYPE_NORMAL
- en: so on. Schools, universities, and employers maintain records of their students
  prefs: []
  type: TYPE_NORMAL
- en: and employees and publish almanacs and photographs of social events. Hence,
  prefs: []
  type: TYPE_NORMAL
- en: it would be necessary to manipulate their documents as well in order to make
  prefs: []
  type: TYPE_NORMAL
- en: my fictional grandfather a former member of these institutions. Since manipu-
  prefs: []
  type: TYPE_NORMAL
- en: lating all these documents would be complicated and costly, I probably would
  prefs: []
  type: TYPE_NORMAL
- en: decide to stay with my real but nonaristocratic family history.
  prefs: []
  type: TYPE_NORMAL
- en: This intellectual game illustrates that forging the past is possible but extremely
    expensive, since it requires rewriting and forging large parts of history in
  prefs: []
  type: TYPE_NORMAL
- en: order to embed the fake information into many documents and references of
  prefs: []
  type: TYPE_NORMAL
- en: the true history. The costs of doing so are prohibitively high; hence, it is
    much easier and less expensive to stick with the truth. This step explains how
    the
  prefs: []
  type: TYPE_NORMAL
- en: blockchain utilizes this finding in order to protect its history of transaction
  prefs: []
  type: TYPE_NORMAL
- en: data from being forged.
  prefs: []
  type: TYPE_NORMAL
- en: The Goal
  prefs: []
  type: TYPE_NORMAL
- en: It is important that the whole history of transaction data maintained by the
  prefs: []
  type: TYPE_NORMAL
- en: blockchain always represents the truth and therefore makes it a trustworthy
  prefs: []
  type: TYPE_NORMAL
- en: source for clarifying ownership-related matters.
  prefs: []
  type: TYPE_NORMAL
- en: The Challenge
  prefs: []
  type: TYPE_NORMAL
- en: The blockchain is a purely distributed peer-to-peer system that is open to
  prefs: []
  type: TYPE_NORMAL
- en: everyone. Hence, there is a risk that dishonest peers could manipulate or
  prefs: []
  type: TYPE_NORMAL
- en: forge the history of transaction data for their own advantage. The challenge
    is
  prefs: []
  type: TYPE_NORMAL
- en: to keep the system open to everyone yet protect the history of transaction
  prefs: []
  type: TYPE_NORMAL
- en: data from being forged or manipulated.
  prefs: []
  type: TYPE_NORMAL
- en: '***Blockchain Basics***'
  prefs: []
  type: TYPE_NORMAL
- en: '137'
  prefs: []
  type: TYPE_NORMAL
- en: The Idea
  prefs: []
  type: TYPE_NORMAL
- en: Distinguishing honest from dishonest nodes in an open system in advance is
  prefs: []
  type: TYPE_NORMAL
- en: hard or even impossible. Hence, in order to protect the history of transac-
  prefs: []
  type: TYPE_NORMAL
- en: tions from being manipulated by dishonest nodes, we want to prevent anyone
  prefs: []
  type: TYPE_NORMAL
- en: from manipulating the history in the first place. If no one can change the his-
  prefs: []
  type: TYPE_NORMAL
- en: tory of transaction data, regardless of whether it is honest or dishonest, we
  prefs: []
  type: TYPE_NORMAL
- en: do not have to fear that it can be manipulated at all. Hence, making the history
    of transaction data unchangeable in the first place solves the problem. As a
  prefs: []
  type: TYPE_NORMAL
- en: result, the system can stay open to everyone and no one has to worry about
  prefs: []
  type: TYPE_NORMAL
- en: dishonest nodes manipulating the history of transactions.
  prefs: []
  type: TYPE_NORMAL
- en: A Short Detour to Immutability
  prefs: []
  type: TYPE_NORMAL
- en: Immutability means that something cannot be changed. Data that are immu-
  prefs: []
  type: TYPE_NORMAL
- en: table cannot be changed once they have been created or written. For that
  prefs: []
  type: TYPE_NORMAL
- en: reason, these data are also called read-only data. Their whole benefit is solely
    presenting information for reading or presentation purposes. This fact is particularly
    desirable if one needs to give data to others and hence loses control
  prefs: []
  type: TYPE_NORMAL
- en: on how the data are used. Handing over immutable data is an effective way
  prefs: []
  type: TYPE_NORMAL
- en: of preventing changes or manipulation of data. Driver’s licenses, passports,
  prefs: []
  type: TYPE_NORMAL
- en: and educational certificates are examples of immutable objects in real life.
  prefs: []
  type: TYPE_NORMAL
- en: Authorities produce them in order to document something and their only
  prefs: []
  type: TYPE_NORMAL
- en: legible use is to be shown and to be read.
  prefs: []
  type: TYPE_NORMAL
- en: 'How It Works: The Big Picture'
  prefs: []
  type: TYPE_NORMAL
- en: The main idea used by the blockchain to make the transaction history immu-
  prefs: []
  type: TYPE_NORMAL
- en: table is to make changing it prohibitively costly and make those costs deter
  prefs: []
  type: TYPE_NORMAL
- en: everyone from changing it. Making the history of transaction data immutable
  prefs: []
  type: TYPE_NORMAL
- en: 'has three elements:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Storing the history of transaction data in a way that even
  prefs: []
  type: TYPE_NORMAL
- en: the smallest manipulation of its content stands out and
  prefs: []
  type: TYPE_NORMAL
- en: becomes noticeable.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Enforcing that embedding a manipulation in the transac-
  prefs: []
  type: TYPE_NORMAL
- en: tion history requires rewriting a huge part of it.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Making adding, writing, or rewriting of data to the history
  prefs: []
  type: TYPE_NORMAL
- en: computationally expensive.
  prefs: []
  type: TYPE_NORMAL
- en: '138'
  prefs: []
  type: TYPE_NORMAL
- en: '***Step 16 | Protecting the Data Store***'
  prefs: []
  type: TYPE_NORMAL
- en: Making Manipulations Stand Out
  prefs: []
  type: TYPE_NORMAL
- en: The blockchain-data-structure that stores data in a change-sensitive manner
  prefs: []
  type: TYPE_NORMAL
- en: fulfills the first element. As a result, one cannot silently manipulate data
    that are part of the blockchain-data-structure and hope that no one will notice
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Any change will stand out with a huge “noise” caused by breaking hash refer-
  prefs: []
  type: TYPE_NORMAL
- en: ences that become invalid as a result of changing the data they refer to.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcing Rewriting the History for Embedding
  prefs: []
  type: TYPE_NORMAL
- en: Changes
  prefs: []
  type: TYPE_NORMAL
- en: The blockchain-data-structure also fulfills the second element because it pur-
  prefs: []
  type: TYPE_NORMAL
- en: 'sues a radical all-or-nothing approach when it comes to changing its data:'
  prefs: []
  type: TYPE_NORMAL
- en: One either changes the data structure starting from the point that causes the
  prefs: []
  type: TYPE_NORMAL
- en: change until the head of the whole chain or one better leave it unchanged in
  prefs: []
  type: TYPE_NORMAL
- en: the first place.
  prefs: []
  type: TYPE_NORMAL
- en: Making Adding Data Computationally Expensive
  prefs: []
  type: TYPE_NORMAL
- en: The third element is for those who are not afraid to rewrite large parts of
  prefs: []
  type: TYPE_NORMAL
- en: the blockchain-data-structure in the course of having a manipulation embed-
  prefs: []
  type: TYPE_NORMAL
- en: ded in the transaction history. But as soon as writing or rewriting the block-
  prefs: []
  type: TYPE_NORMAL
- en: chain-data-structure incurs huge computational costs, people will think twice
  prefs: []
  type: TYPE_NORMAL
- en: about whether changing it was a good idea in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: The blockchain-technology-suite makes the content of the blockchain-data-
  prefs: []
  type: TYPE_NORMAL
- en: structure immutable by incurring significant computational costs for every
  prefs: []
  type: TYPE_NORMAL
- en: block being written, rewritten, or added to the blockchain-data-structure. The
  prefs: []
  type: TYPE_NORMAL
- en: computational costs are incurred by hash puzzles that are unique for each
  prefs: []
  type: TYPE_NORMAL
- en: block header. [1](index_split_001.html#139) As a result, one either accepts
    the whole cost of changing the data structure from the point that causes the change
    until the head of the
  prefs: []
  type: TYPE_NORMAL
- en: chain by solving a hash puzzle for every block header involved or it is better
  prefs: []
  type: TYPE_NORMAL
- en: to leave it unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: '1Nakamoto, Satoshi. Bitcoin: A peer-to-peer electronic cash system. 2008\.
    [https://bitcoin.](https://bitcoin.org/bitcoin.pdf)'
  prefs: []
  type: TYPE_NORMAL
- en: '[org/bitcoin.pdf](https://bitcoin.org/bitcoin.pdf).'
  prefs: []
  type: TYPE_NORMAL
- en: '***Blockchain Basics***'
  prefs: []
  type: TYPE_NORMAL
- en: '139'
  prefs: []
  type: TYPE_NORMAL
- en: 'How It Works: The Details'
  prefs: []
  type: TYPE_NORMAL
- en: The procedure to add a new block to the blockchain-data-structure, as dis-
  prefs: []
  type: TYPE_NORMAL
- en: '[cussed in Step 15,](http://dx.doi.org/10.1007/978-1-4842-2604-9_15) is not
    computationally expensive because it only requires adding the hash reference that
    points to the current head of the chain to the'
  prefs: []
  type: TYPE_NORMAL
- en: new block header and declaring it as the new head of the chain. The challenge
  prefs: []
  type: TYPE_NORMAL
- en: of making the blockchain-data-structure immutable is to make adding a new
  prefs: []
  type: TYPE_NORMAL
- en: block a computationally expensive task. The following aspects need to be con-
  prefs: []
  type: TYPE_NORMAL
- en: 'sidered in the course of achieving this:'
  prefs: []
  type: TYPE_NORMAL
- en: • Compulsory data of block headers
  prefs: []
  type: TYPE_NORMAL
- en: • The process of creating a new block header
  prefs: []
  type: TYPE_NORMAL
- en: • Validation rules for block headers
  prefs: []
  type: TYPE_NORMAL
- en: Compulsory Data
  prefs: []
  type: TYPE_NORMAL
- en: Every block header of the blockchain-data-structure has to carry at least the
  prefs: []
  type: TYPE_NORMAL
- en: following data[2:](index_split_001.html#140)
  prefs: []
  type: TYPE_NORMAL
- en: • The root of a Merkle tree containing transaction data
  prefs: []
  type: TYPE_NORMAL
- en: • A hash reference to the header of the preceding block
  prefs: []
  type: TYPE_NORMAL
- en: • The difficulty level of the hash puzzle
  prefs: []
  type: TYPE_NORMAL
- en: • The time when solving the hash puzzle started
  prefs: []
  type: TYPE_NORMAL
- en: • The nonce that solves the hash puzzle
  prefs: []
  type: TYPE_NORMAL
