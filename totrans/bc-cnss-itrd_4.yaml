- en: protocol rules as there is no other strategy that would result in a better outcome.
    Each
  prefs: []
  type: TYPE_NORMAL
- en: participant is better off by just sticking to the rules of the network.
  prefs: []
  type: TYPE_NORMAL
- en: If the other miners don’t switch their strategy, an attacker has no incentive
    to switch
  prefs: []
  type: TYPE_NORMAL
- en: their own strategy. Neither player can increase their payoffs by switching to
    a different strategy if the other player doesn’t switch their strategy. This means
    that in Bitcoin if all other miners are honest, an adversary has no incentive
    to change their strategy and try to perform malicious mining.
  prefs: []
  type: TYPE_NORMAL
- en: Incentive mechanisms such as block reward and transaction fees in Bitcoin
  prefs: []
  type: TYPE_NORMAL
- en: discourage malicious behavior. These incentives encourage participants to behave
  prefs: []
  type: TYPE_NORMAL
- en: according to the protocol, which not only results in the creation of new bitcoins,
    that is, network progress is guaranteed, but also the security of the network
    is maintained.
  prefs: []
  type: TYPE_NORMAL
- en: Since 2009, the Bitcoin network has attracted so much investment in the form
    of
  prefs: []
  type: TYPE_NORMAL
- en: mining farms and Bitcoin businesses, exchanges, and services that network participants
  prefs: []
  type: TYPE_NORMAL
- en: will benefit more by protecting the network rather than destroying it. They
    gain by
  prefs: []
  type: TYPE_NORMAL
- en: protecting the network. Even attackers cannot gain much. Imagine if some adversary
  prefs: []
  type: TYPE_NORMAL
- en: managed to find a way to move all coins owned by Satoshi Nakamoto into another
  prefs: []
  type: TYPE_NORMAL
- en: account. There probably is no incentive for an attacker to do so, because the
    moment it
  prefs: []
  type: TYPE_NORMAL
- en: '235'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 5 BloCkChain Consensus
  prefs: []
  type: TYPE_NORMAL
- en: happens, the Bitcoin almost certainly will become worthless, because this event
    would
  prefs: []
  type: TYPE_NORMAL
- en: imply that the very cryptography that protects the network has been broken (assuming
  prefs: []
  type: TYPE_NORMAL
- en: that real Satoshi is not alive or has lost his private keys irrecoverably).
  prefs: []
  type: TYPE_NORMAL
- en: i have a feeling that satoshi is not moving his coins because that can cause
    Bitcoin
  prefs: []
  type: TYPE_NORMAL
- en: to lose its value drastically.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, even if an adversary somehow gains 51% of the network hash power,
  prefs: []
  type: TYPE_NORMAL
- en: taking over the entire network may not be beneficial anymore. Why? Because the
    best
  prefs: []
  type: TYPE_NORMAL
- en: course of action in such a situation for the adversary is to keep mining silently
    with some reasonable hash power to gain economic incentives (earn bitcoins) just
    like others on
  prefs: []
  type: TYPE_NORMAL
- en: the network, instead of utilizing the entire 51% hash power announcing the attack
    to the
  prefs: []
  type: TYPE_NORMAL
- en: world. That would just diminish the Bitcoin value almost entirely, and any gains
    by the
  prefs: []
  type: TYPE_NORMAL
- en: attacker would be worthless. Therefore, attackers do not have incentive to take
    over the
  prefs: []
  type: TYPE_NORMAL
- en: Bitcoin network, perhaps apart from some mishaps that occurred due to human
    errors
  prefs: []
  type: TYPE_NORMAL
- en: and compromised keys. This is the elegance and beauty of Bitcoin that even attackers
    do
  prefs: []
  type: TYPE_NORMAL
- en: not gain by attacking the network. All participants gain by just playing by
    the rules. The dominant strategy for miners is to be honest.
  prefs: []
  type: TYPE_NORMAL
- en: For the very first time in distributed computing, a network is created which
    does not
  prefs: []
  type: TYPE_NORMAL
- en: rely on any trusted third party and is permissionless, yet it doesn’t let any
    attacker take over the network. Here, I remember something, which is not directly
    relevant to Bitcoin,
  prefs: []
  type: TYPE_NORMAL
- en: but helps to feel what many distributed computing experts might feel about Bitcoin
  prefs: []
  type: TYPE_NORMAL
- en: when they first realize how elegant it is.
  prefs: []
  type: TYPE_NORMAL
- en: '*It could not be true but it was true.*'
  prefs: []
  type: TYPE_NORMAL
- en: —Mikhael Gromov
  prefs: []
  type: TYPE_NORMAL
- en: '[www.ams.org/notices/201003/201003FullIssue.pdf](http://www.ams.org/notices/201003/201003FullIssue.pdf)'
  prefs: []
  type: TYPE_NORMAL
- en: With the advent of Bitcoin and novel combination of cryptography, distributed
  prefs: []
  type: TYPE_NORMAL
- en: computing, and economics, a new field of study has emerged, called Cryptoeconomics
  prefs: []
  type: TYPE_NORMAL
- en: or Cryptonomics. This is depicted in Figur[e 5-7\.](#p254)
  prefs: []
  type: TYPE_NORMAL
- en: '236'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-254_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 5 BloCkChain Consensus
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 5-7\.** Fusion of distributed computing, economics, and*'
  prefs: []
  type: TYPE_NORMAL
- en: '*cryptography – Bitcoin*'
  prefs: []
  type: TYPE_NORMAL
- en: We can also think of the fork resolution mechanism as a **Schelling point**
    solution. This is a game theory concept where a focal point or also called Schelling
    point is a solution that people choose by default in the absence of communication.
    Similarly, in the proof of work fork resolution mechanism, due to the longest
    (strongest) chain rule, nodes tend to choose the longest chain as a canonical
    chain to add the block that they’ve received without
  prefs: []
  type: TYPE_NORMAL
- en: any communication or direction from other nodes. This concept of cooperating
    without
  prefs: []
  type: TYPE_NORMAL
- en: communication was introduced by Thomas Schelling in his book *The Strategy of
    Conflict*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Similarities Between PoW and Traditional BFT**'
  prefs: []
  type: TYPE_NORMAL
- en: Fundamentally, all consensus algorithms strive toward achieving safety and liveness
  prefs: []
  type: TYPE_NORMAL
- en: 'properties. Either deterministic or probabilistic, basically all consensus
    algorithms have three main properties: agreement, validity, and termination. We
    have introduced these'
  prefs: []
  type: TYPE_NORMAL
- en: terms before. The question arises in Nakamoto consensus of whether we can redefine
  prefs: []
  type: TYPE_NORMAL
- en: these properties in a way which is closer to the blockchain world. The answer
    is yes;
  prefs: []
  type: TYPE_NORMAL
- en: agreement, validity, and liveness properties can be mapped to Nakamoto consensus–
  prefs: []
  type: TYPE_NORMAL
- en: specific properties of common prefix, chain quality, and chain growth, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: These terms were first introduce[d in https://eprint.iacr.org/2014/765.pdf](https://eprint.iacr.org/2014/765.pdf)
    [7].
  prefs: []
  type: TYPE_NORMAL
- en: '237'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 5 BloCkChain Consensus
  prefs: []
  type: TYPE_NORMAL
- en: '**Common Prefix**'
  prefs: []
  type: TYPE_NORMAL
- en: This property implies that all honest nodes will share the same large common
    prefix.
  prefs: []
  type: TYPE_NORMAL
- en: '**Chain Quality**'
  prefs: []
  type: TYPE_NORMAL
- en: This property means that the blockchain contains a certain required level of
    correct
  prefs: []
  type: TYPE_NORMAL
- en: blocks created by honest miners. If the chain quality is compromised, then the
    validity
  prefs: []
  type: TYPE_NORMAL
- en: property of the protocol cannot be guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: '**Chain Growth**'
  prefs: []
  type: TYPE_NORMAL
- en: This property means that new correct blocks are constantly added to the blockchain
  prefs: []
  type: TYPE_NORMAL
- en: regularly.
  prefs: []
  type: TYPE_NORMAL
- en: These properties can be seen as the equivalent of traditional consensus properties
  prefs: []
  type: TYPE_NORMAL
- en: in the Nakamoto world. Here, the common prefix is an agreement property, the
    chain
  prefs: []
  type: TYPE_NORMAL
- en: quality is a validity property, and chain growth can be seen as a liveness property.
  prefs: []
  type: TYPE_NORMAL
- en: '**PoW As State Machine Replication**'
  prefs: []
  type: TYPE_NORMAL
- en: A proof of work blockchain can be seen as a state machine replication mechanism
    where
  prefs: []
  type: TYPE_NORMAL
- en: first a leader is elected who proposes a sequence of transactions batched in
    a block.
  prefs: []
  type: TYPE_NORMAL
- en: Second, the finalized (mined) block is broadcast to other nodes via a gossip
    protocol,
  prefs: []
  type: TYPE_NORMAL
- en: which is accepted and appended into their local blockchains, achieving log replication.
  prefs: []
  type: TYPE_NORMAL
- en: We can think of it as if the leader is proposing an order and all nodes updating
    their log (local blockchain) based on this order of transactions set in the block.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s first see the leader election algorithm and replication algorithm in detail.
  prefs: []
  type: TYPE_NORMAL
- en: '**Leader Election Algorithm**'
  prefs: []
  type: TYPE_NORMAL
- en: A node that solves the proof of work puzzle is elected to finalize and broadcast
    its
  prefs: []
  type: TYPE_NORMAL
- en: candidate block. The leader in proof of work is elected as a function of computational
  prefs: []
  type: TYPE_NORMAL
- en: power of the mining node. There is no voting required from other nodes as opposed
  prefs: []
  type: TYPE_NORMAL
- en: to other traditional BFT protocols. Also, unlike traditional BFT protocols,
    the leader is rotated every block. This approach has been used in later blockchain
    BFT protocols
  prefs: []
  type: TYPE_NORMAL
- en: as well where the leader is rotated every block to thwart any attempts to sabotage
  prefs: []
  type: TYPE_NORMAL
- en: (compromise) the leader. Also, in traditional BFT protocols, usually the primary
    or
  prefs: []
  type: TYPE_NORMAL
- en: '238'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 5 BloCkChain Consensus
  prefs: []
  type: TYPE_NORMAL
- en: leader is only changed when the primary fails, but in PoW a leader is elected
    every block.
  prefs: []
  type: TYPE_NORMAL
- en: Leader election in PoW is based on computational power; However, several techniques
  prefs: []
  type: TYPE_NORMAL
- en: have been used in other permissioned blockchains, from simply randomly choosing
  prefs: []
  type: TYPE_NORMAL
- en: a leader or simple rotation formula to complex means such as verifiable random
  prefs: []
  type: TYPE_NORMAL
- en: functions. We will cover these techniques in Chapter [8 in detail.](https://doi.org/10.1007/978-1-4842-8179-6_8)
  prefs: []
  type: TYPE_NORMAL
- en: The leader election formula is simply the same PoW formula that we have already
  prefs: []
  type: TYPE_NORMAL
- en: covered in the section “How PoW Works.” A soon as any miner solves the proof
    of work, it
  prefs: []
  type: TYPE_NORMAL
- en: immediately is elected as a leader and earns the right to broadcast its newly
    mined block.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, the miner is also awarded 6.25 BTC. This reward halves every
    four years.
  prefs: []
  type: TYPE_NORMAL
- en: At the leader election stage, the miner node has successfully solved the PoW
    puzzle,
  prefs: []
  type: TYPE_NORMAL
- en: and now the log replication can start.
  prefs: []
  type: TYPE_NORMAL
- en: '**Log Replication**'
  prefs: []
  type: TYPE_NORMAL
- en: The log replication or block replication to achieve consistency among nodes
    is achieved
  prefs: []
  type: TYPE_NORMAL
- en: by broadcasting the newly mined block to other nodes via a gossip dissemination
  prefs: []
  type: TYPE_NORMAL
- en: 'protocol. The key differences between a normal log and a blockchain log are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: • It is append-only and immutable.
  prefs: []
  type: TYPE_NORMAL
- en: • Each new batch of transactions (block) has a hash of the previous
  prefs: []
  type: TYPE_NORMAL
- en: block, thus linking it in a so-called proof of work chain or hash chain
  prefs: []
  type: TYPE_NORMAL
- en: or chain of blocks or blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: • The blocks (content in the log) are verifiable from the previous block.
  prefs: []
  type: TYPE_NORMAL
- en: • Each block contains transactions and a block header. This structure
  prefs: []
  type: TYPE_NORMAL
- en: was discussed in detail in Chapt[er 4\.](https://doi.org/10.1007/978-1-4842-8179-6_4)
  prefs: []
  type: TYPE_NORMAL
- en: When a new block is broadcast, it is validated and verified by each honest node
    on
  prefs: []
  type: TYPE_NORMAL
- en: the network before it is appended to the blockchain. Log replication after leader
    election can be divided into three steps.
  prefs: []
  type: TYPE_NORMAL
- en: '**New Block Propagation**'
  prefs: []
  type: TYPE_NORMAL
- en: A block is broadcast using the gossip protocol. We can visualize the block propagation
  prefs: []
  type: TYPE_NORMAL
- en: mechanism in Figur[e 5-8\. N](#p257)otice that node 1 has sent a message, for
    example, a new block, to node 2, which is then sent to nodes 4, 14, and 13 by
    node 2\. A similar pattern
  prefs: []
  type: TYPE_NORMAL
- en: can be seen in the network for other nodes too.
  prefs: []
  type: TYPE_NORMAL
- en: '239'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-257_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 5 BloCkChain Consensus
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 5-8\.** Gossip protocol in Bitcoin*'
  prefs: []
  type: TYPE_NORMAL
- en: This type of propagation ensures that eventually all nodes get the message with
  prefs: []
  type: TYPE_NORMAL
- en: high probability. Moreover, this pattern does not overwhelm a single node with
    the
  prefs: []
  type: TYPE_NORMAL
- en: requirement of broadcasting a message to all nodes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Block Validation**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Block validation can be seen as the state transition function (STF). This **block
    validation** **function** has the following high-level rules:'
  prefs: []
  type: TYPE_NORMAL
- en: • The block is syntactically correct.
  prefs: []
  type: TYPE_NORMAL
- en: • The block header hash is less than the network difficulty target.
  prefs: []
  type: TYPE_NORMAL
- en: • The block timestamp is not more than two hours in future.
  prefs: []
  type: TYPE_NORMAL
- en: • The block size is correct.
  prefs: []
  type: TYPE_NORMAL
- en: • All transactions are valid within the block.
  prefs: []
  type: TYPE_NORMAL
- en: • It is referring to the previous hash.
  prefs: []
  type: TYPE_NORMAL
- en: The protocol specifies very precise rules, details of which can be found a[t
    https://](https://en.bitcoin.it/wiki/Protocol_rules)
  prefs: []
  type: TYPE_NORMAL
- en: '[en.bitcoin.it/wiki/Protocol_rules](https://en.bitcoin.it/wiki/Protocol_rules);
    however, the preceding list is a high-level list of block validation checks a
    node performs.'
  prefs: []
  type: TYPE_NORMAL
- en: '240'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-258_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 5 BloCkChain Consensus
  prefs: []
  type: TYPE_NORMAL
- en: '**Append to the Blockchain**'
  prefs: []
  type: TYPE_NORMAL
- en: The block is finally inserted into the blockchain by the nodes. When appending
    to the
  prefs: []
  type: TYPE_NORMAL
- en: blockchain, it may happen that those nodes may have received two valid blocks.
    In that
  prefs: []
  type: TYPE_NORMAL
- en: case, a fork will occur, and nodes will have to decide which chain to append
    the block to.
  prefs: []
  type: TYPE_NORMAL
- en: We can visualize this concept in Figur[e 5-9\.](#p258)
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 5-9\.** Proof of work as state machine replication*'
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in Figur[e 5-9](#p258), proof of work as a state machine replication
    consists of two main operations: leader election through proof of work and then
    replication via a gossip'
  prefs: []
  type: TYPE_NORMAL
- en: protocol and receiving node’s block validation and insertion mechanism. After
    proof
  prefs: []
  type: TYPE_NORMAL
- en: of work on a node, if the proof of work is valid, then the block is treated
    the same as if it has been received from another node and eventually inserted
    into the local blockchain
  prefs: []
  type: TYPE_NORMAL
- en: database after validation.
  prefs: []
  type: TYPE_NORMAL
- en: A component that chooses which chain is conclusive in case of a conflict is
    called a
  prefs: []
  type: TYPE_NORMAL
- en: fork handler which embodies fork resolution rules on how to handle a fork.
  prefs: []
  type: TYPE_NORMAL
- en: '241'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 5 BloCkChain Consensus
  prefs: []
  type: TYPE_NORMAL
- en: '**Fork Resolution**'
  prefs: []
  type: TYPE_NORMAL
- en: Fork resolution can be seen as a fault tolerance mechanism in Bitcoin. Fork
    resolution
  prefs: []
  type: TYPE_NORMAL
- en: rules ensure that only the chain that has the most work done to produce it is
    the one
  prefs: []
  type: TYPE_NORMAL
- en: that is always picked up by the nodes when inserting a new block. When a valid
    block
  prefs: []
  type: TYPE_NORMAL
- en: arrives for the same height, then the fork resolution mechanism allows the node
    to
  prefs: []
  type: TYPE_NORMAL
- en: ignore the shorter chain and add the block only to the longest chain. Also note
    that this is not always the case that the longest chain has the most work done;
    it could happen
  prefs: []
  type: TYPE_NORMAL
- en: that a shorter chain may have the most computational hash power behind it, that
    is, the
  prefs: []
  type: TYPE_NORMAL
- en: accumulated proof of work, and in that case, that chain will be selected.
  prefs: []
  type: TYPE_NORMAL
- en: We can calculate the accumulated proof of work by first calculating the difficulty
    of
  prefs: []
  type: TYPE_NORMAL
- en: a particular block, say B, then we can use the following formula. The difficulty
    of a block can be defined as finding how much harder it is to find a valid proof
    of work nonce for
  prefs: []
  type: TYPE_NORMAL
- en: this specific block B in comparison to the difficulty of a genesis block.
  prefs: []
  type: TYPE_NORMAL
- en: '*Genesis*'
  prefs: []
  type: TYPE_NORMAL
- en: ( 216)×2562)
  prefs: []
  type: TYPE_NORMAL
- en: '*block’s difficulty* *target* ='
  prefs: []
  type: TYPE_NORMAL
- en: '*B’s difficulty target*'
  prefs: []
  type: TYPE_NORMAL
- en: '*B’s difficulty target*'
  prefs: []
  type: TYPE_NORMAL
- en: We can say that the accumulated proof of work for a chain is the sum of the
    difficulty
  prefs: []
  type: TYPE_NORMAL
- en: of all blocks in the chain. The chain that has most proof of work behind it
    will be chosen for a new block to be appended.
  prefs: []
  type: TYPE_NORMAL
- en: the longest chain rule was originally simply the chain with the highest number
  prefs: []
  type: TYPE_NORMAL
- en: of blocks. however, this simple rule was modified later, and the “longest” chain
  prefs: []
  type: TYPE_NORMAL
- en: became the chain with the most work done to create it, that is, the strongest
    chain.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, there is a *chainwork* value in the block which helps to identify
    the chain with the most work, that is, the correct “longest” or “strongest” chain.
  prefs: []
  type: TYPE_NORMAL
- en: For example, we use
  prefs: []
  type: TYPE_NORMAL
- en: bitcoin-cli getblockheader
  prefs: []
  type: TYPE_NORMAL
- en: 0000000000000000000811608a01b388b167d9c94c0c0870377657d524ff0003
  prefs: []
  type: TYPE_NORMAL
- en: For block 687731, we get
  prefs: []
  type: TYPE_NORMAL
- en: '242'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 5 BloCkChain Consensus
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '"result": {'
  prefs: []
  type: TYPE_NORMAL
- en: '"hash":'
  prefs: []
  type: TYPE_NORMAL
- en: '"0000000000000000000811608a01b388b167d9c94c0c0870377657d524ff0003",'
  prefs: []
  type: TYPE_NORMAL
- en: '"confirmations": 1,'
  prefs: []
  type: TYPE_NORMAL
- en: '"height": 687731,'
  prefs: []
  type: TYPE_NORMAL
- en: '"version": 547356676,'
  prefs: []
  type: TYPE_NORMAL
- en: '"versionHex": "20a00004",'
  prefs: []
  type: TYPE_NORMAL
- en: '"merkleroot":'
  prefs: []
  type: TYPE_NORMAL
- en: '"73f4a59b854ed2d6597b56e6bc499a7e0b8651376e63e0825dbcca3b9dde61ae",'
  prefs: []
  type: TYPE_NORMAL
- en: '"time": 1623786185,'
  prefs: []
  type: TYPE_NORMAL
- en: '"mediantime": 1623781371,'
  prefs: []
  type: TYPE_NORMAL
- en: '"nonce": 2840970250,'
  prefs: []
  type: TYPE_NORMAL
- en: '"bits": "170e1ef9",'
  prefs: []
  type: TYPE_NORMAL
- en: '"difficulty": 19932791027262.74,'
  prefs: []
  type: TYPE_NORMAL
- en: '**"chainwork": "00000000000000000000000000000000000000001eb7091803**'
  prefs: []
  type: TYPE_NORMAL
- en: '**0b922df7533fd4",**'
  prefs: []
  type: TYPE_NORMAL
- en: '"nTx": 2722,'
  prefs: []
  type: TYPE_NORMAL
- en: '"previousblockhash":'
  prefs: []
  type: TYPE_NORMAL
- en: '"00000000000000000000f341e0046c6d82979fdfa09ab324a0e8ffbabd22815d"'
  prefs: []
  type: TYPE_NORMAL
- en: '},'
  prefs: []
  type: TYPE_NORMAL
- en: '"error": null,'
  prefs: []
  type: TYPE_NORMAL
- en: '"id": null'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: Notice the chainwork value when converted to a decimal results in an extremely
  prefs: []
  type: TYPE_NORMAL
- en: large number, 6663869462529529036756\. This is the amount of work behind this
    head of
  prefs: []
  type: TYPE_NORMAL
- en: the chain.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several types of forks that can occur in the Bitcoin blockchain:'
  prefs: []
  type: TYPE_NORMAL
- en: • Regular fork
  prefs: []
  type: TYPE_NORMAL
- en: • Hard fork
  prefs: []
  type: TYPE_NORMAL
- en: • Soft fork
  prefs: []
  type: TYPE_NORMAL
- en: • Byzantine fork
  prefs: []
  type: TYPE_NORMAL
- en: '243'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-261_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 5 BloCkChain Consensus
  prefs: []
  type: TYPE_NORMAL
- en: '**Regular fork**'
  prefs: []
  type: TYPE_NORMAL
- en: A fork can naturally occur in the Bitcoin blockchain when two miners competing
  prefs: []
  type: TYPE_NORMAL
- en: to solve the proof of work happen to solve it almost at the same time. As a
    result, two
  prefs: []
  type: TYPE_NORMAL
- en: new blocks are added to the blockchain. Miners will keep working on the longest
    chain
  prefs: []
  type: TYPE_NORMAL
- en: that they are aware of, and soon the shorter chain with so-called orphan blocks
    will be
  prefs: []
  type: TYPE_NORMAL
- en: ignored.
  prefs: []
  type: TYPE_NORMAL
- en: The diagram in Figur[e 5-10](#p261) shows how consensus finality is impacted
    by forks.
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 5-10\.** Impact of forking on consensus finality*'
  prefs: []
  type: TYPE_NORMAL
- en: Due to the forking possibility, consensus is probabilistic. When the fork is
    resolved,
  prefs: []
  type: TYPE_NORMAL
- en: previously accepted transactions are rolled back, and the longest (strongest)
    chain
  prefs: []
  type: TYPE_NORMAL
- en: prevails.
  prefs: []
  type: TYPE_NORMAL
- en: The probability of these regular forks is quite low. A split of one block can
    occur
  prefs: []
  type: TYPE_NORMAL
- en: almost every two weeks and is quickly resolved when the next block arrives,
    referring
  prefs: []
  type: TYPE_NORMAL
- en: to the previous one as a parent. The probability of occurrence of a two-block
    split is
  prefs: []
  type: TYPE_NORMAL
- en: exponentially lower, which is almost once in 90 years. The probability of occurrence
    of a four-block temporary fork is once in almost 700,000,000 years.
  prefs: []
  type: TYPE_NORMAL
- en: '**Hard fork**'
  prefs: []
  type: TYPE_NORMAL
- en: A hard fork occurs due to changes in the protocol, which are incompatible with
    the
  prefs: []
  type: TYPE_NORMAL
- en: existing rules. This essentially creates two chains, one running on the old
    rules and the new one on new rules.
  prefs: []
  type: TYPE_NORMAL
- en: We can visualize how a hard fork behaves in Figur[e 5-11\.](#p262)
  prefs: []
  type: TYPE_NORMAL
- en: '244'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-262_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](index-262_2.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 5 BloCkChain Consensus
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 5-11\.** Hard fork*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Soft fork**'
  prefs: []
  type: TYPE_NORMAL
- en: A soft fork occurs when changes in the protocol are backward compatible. It
    means
  prefs: []
  type: TYPE_NORMAL
- en: that there is no need to update all the clients; even if not all the clients
    are upgraded, the chain is still one. However, any clients that do not upgrade
    won’t be able to operate using the new rules. In other words, old clients will
    still be able to accept the new blocks.
  prefs: []
  type: TYPE_NORMAL
- en: This concept can be visualized in the diagram in Figure [5-12\.](#p262)
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 5-12\.** Soft fork*'
  prefs: []
  type: TYPE_NORMAL
- en: '245'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-263_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 5 BloCkChain Consensus
  prefs: []
  type: TYPE_NORMAL
- en: '**Byzantine fork**'
  prefs: []
  type: TYPE_NORMAL
- en: A Byzantine fork or malicious fork can occur in scenarios where an adversary
    may try
  prefs: []
  type: TYPE_NORMAL
- en: to create a new chain and succeeds in imposing its own version of the chain.
  prefs: []
  type: TYPE_NORMAL
- en: With this, we complete our discussion on forks.
  prefs: []
  type: TYPE_NORMAL
- en: A core feature of proof of work consensus is the Sybil resistance mechanism
  prefs: []
  type: TYPE_NORMAL
- en: which ensures that creating many new identities and using them is prohibitively
  prefs: []
  type: TYPE_NORMAL
- en: computationally complex. Let’s explore this concept in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: '**Sybil Resistance**'
  prefs: []
  type: TYPE_NORMAL
- en: A Sybil attack occurs when an attacker creates multiple identities, all belonging
    to them to subvert the network relying on voting by using all those identities
    to cast vote in
  prefs: []
  type: TYPE_NORMAL
- en: their favor. Imagine if an attacker creates more nodes than the entire network,
    then the
  prefs: []
  type: TYPE_NORMAL
- en: attacker can skew the network in their favor.
  prefs: []
  type: TYPE_NORMAL
- en: A Sybil attack can be visualized in Figure [5-13](#p263), where an attacker
    is controlling more Sybil nodes than the network.
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 5-13\.** Sybil attack*'
  prefs: []
  type: TYPE_NORMAL
- en: Proof of work makes it prohibitively expensive for an attacker to use multiple
    nodes
  prefs: []
  type: TYPE_NORMAL
- en: controlled by them to participate in the network because each node will have
    to do
  prefs: []
  type: TYPE_NORMAL
- en: computationally complex work in order to be part of the network. Therefore,
    an attacker
  prefs: []
  type: TYPE_NORMAL
- en: controlling a large number of nodes will not be able to influence the network.
  prefs: []
  type: TYPE_NORMAL
- en: '246'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 5 BloCkChain Consensus
  prefs: []
  type: TYPE_NORMAL
- en: '**Significance of Block Timestamp**'
  prefs: []
  type: TYPE_NORMAL
- en: The Bitcoin network with its heterogenous geographically dispersed nodes running
  prefs: []
  type: TYPE_NORMAL
- en: on the Internet appears to be an asynchronous network. This appears to be the
    case
  prefs: []
  type: TYPE_NORMAL
- en: because there is no upper bound on the processor speeds and no upper bound on
    the
  prefs: []
  type: TYPE_NORMAL
- en: message delay. Usually, in traditional BFT consensus protocols, there is no
    reliance on
  prefs: []
  type: TYPE_NORMAL
- en: a global physical clock, and network assumptions are usually partially synchronous
  prefs: []
  type: TYPE_NORMAL
- en: networks. However, in Bitcoin all blocks have a timestamp field, which is populated
    by
  prefs: []
  type: TYPE_NORMAL
- en: the local node which mined the block. This is part of the block validation process
    where
  prefs: []
  type: TYPE_NORMAL
- en: a block is accepted only if its timestamp is less than or equal to the median
    of the last 11
  prefs: []
  type: TYPE_NORMAL
- en: blocks. Also, timestamps are vital for maintaining block frequency, difficulty
    retargeting, and network difficulty calculations. From this point of view, we
    can think of the Bitcoin network as loosely synchronous, where loose clock synchrony
    is required for the network
  prefs: []
  type: TYPE_NORMAL
- en: to make progress and ensure liveness.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the Bitcoin network is not partially synchronous because we defined
  prefs: []
  type: TYPE_NORMAL
- en: partially synchronous and its variations earlier, and the Bitcoin network doesn’t
    seem to fit in any of those definitions. It is synchronous in the sense that blocks
    have a timestamp generated from the local node on which the block was produced;
    however, from a
  prefs: []
  type: TYPE_NORMAL
- en: processor delay perspective, it is almost asynchronous. Also, in the block validation
  prefs: []
  type: TYPE_NORMAL
- en: mechanism, one of the rules requires that a block is produced within roughly
    the last
  prefs: []
  type: TYPE_NORMAL
- en: two hours (median of the previous 11 blocks), making Bitcoin an “almost synchronous”
  prefs: []
  type: TYPE_NORMAL
- en: system. This is so because timestamps are essential for the proper functioning
    of the
  prefs: []
  type: TYPE_NORMAL
- en: Bitcoin system; however, due to large communication and processor delay tolerance,
    it
  prefs: []
  type: TYPE_NORMAL
- en: can be thought of as a loosely synchronous system.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, as timestamps are required only for proper functioning of
    the
  prefs: []
  type: TYPE_NORMAL
- en: limited part of the system, that is, the difficulty calculations, and block
    validation and are not a requirement for achieving consensus (i.e., by choosing
    a leader by solving
  prefs: []
  type: TYPE_NORMAL
- en: proof of work – mining), then from that point of view it is an asynchronous
    system, given that processor and communication delays have no defined upper bounds,
    except that
  prefs: []
  type: TYPE_NORMAL
- en: messages will reach nodes eventually with a probabilistic guarantee of a gossip
    protocol.
  prefs: []
  type: TYPE_NORMAL
- en: In Bitcoin blocks, timestamps are not 100% accurate but enough to secure the
    proof
  prefs: []
  type: TYPE_NORMAL
- en: of work mechanism. Originally, Satoshi envisioned a combination of a system
    clock, a
  prefs: []
  type: TYPE_NORMAL
- en: median of other servers’ clocks, and NTP servers for clock adjustment. However,
    NTP
  prefs: []
  type: TYPE_NORMAL
- en: was never implemented, and the median of other nodes’ clock remained as the
    primary
  prefs: []
  type: TYPE_NORMAL
- en: source for clock adjustment in the network.
  prefs: []
  type: TYPE_NORMAL
- en: '247'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 5 BloCkChain Consensus
  prefs: []
  type: TYPE_NORMAL
- en: Block timestamps not only serve to provide some variation for the block hash,
    which
  prefs: []
  type: TYPE_NORMAL
- en: is useful in proof of work, but also helps to protect against blockchain manipulation
  prefs: []
  type: TYPE_NORMAL
- en: where an adversary could try to inject an invalid block in the chain. When a
    Bitcoin node connects to another node, it receives the timestamp in UTC format
    from it. The receiving
  prefs: []
  type: TYPE_NORMAL
- en: node then calculates the offset of the received time from the local system clock
    and
  prefs: []
  type: TYPE_NORMAL
- en: stores it. The network adjusted time is then calculated as the local UTC system
    clock plus the median offset from all connected nodes.
  prefs: []
  type: TYPE_NORMAL
- en: There are two rules regarding timestamps in Bitcoin blocks. A valid timestamp
  prefs: []
  type: TYPE_NORMAL
- en: must be greater than the median timestamp of the previous 11 blocks. It should
    also
  prefs: []
  type: TYPE_NORMAL
- en: be less than the median timestamp calculated based on the time received from
    other
  prefs: []
  type: TYPE_NORMAL
- en: connected nodes (i.e., network adjusted time) plus two hours. However, this
    network
  prefs: []
  type: TYPE_NORMAL
- en: time adjustment must never be more than 70 minutes from the local system clock.
  prefs: []
  type: TYPE_NORMAL
- en: The conclusion is that Bitcoin is in fact secure only under a synchronous network
  prefs: []
  type: TYPE_NORMAL
- en: model. More precisely, it is a lockstep-free synchrony where there exists some
    known
  prefs: []
  type: TYPE_NORMAL
- en: finite time bound, but execution is not in lockstep.
  prefs: []
  type: TYPE_NORMAL
- en: '**A Caveat**'
  prefs: []
  type: TYPE_NORMAL
- en: The order of transaction is not consensus driven. Each miner picks up a transaction
    in
  prefs: []
  type: TYPE_NORMAL
- en: a hardcoded order within the client, and indeed there have been some attacks
    that can
  prefs: []
  type: TYPE_NORMAL
- en: result in transaction censorship or ignoring or reordering. Consensus is achieved
    in fact on the block, and that is also not through voting; once a miner has solved
    PoW, it just
  prefs: []
  type: TYPE_NORMAL
- en: simply wins the right to append a new block to the chain. Of course, it will
    be validated by other nodes when they receive it, but there is no real agreement
    or voting mechanism
  prefs: []
  type: TYPE_NORMAL
- en: after the mined block has been broadcast by the successful miner. There is no
    voting
  prefs: []
  type: TYPE_NORMAL
- en: or consensus which agrees on this new block; the miner who is the elected leader
    and
  prefs: []
  type: TYPE_NORMAL
- en: because they solved PoW has won the right to add a new block. Other nodes just
    accept
  prefs: []
  type: TYPE_NORMAL
- en: it if it passes the *valid()* predicate.
  prefs: []
  type: TYPE_NORMAL
- en: So, the caveat here is that when a candidate block is created by picking up
  prefs: []
  type: TYPE_NORMAL
- en: transactions from the transaction pool, they are picked up in a certain order
    which a
  prefs: []
  type: TYPE_NORMAL
- en: miner can influence. For example, some miners may choose not to include transactions
  prefs: []
  type: TYPE_NORMAL
- en: without any fee and only include those which are paying fee. Fair for the miner
  prefs: []
  type: TYPE_NORMAL
- en: perhaps, but unfair for the user and the overall Bitcoin system! However, eventually
    all
  prefs: []
  type: TYPE_NORMAL
- en: transactions will be added, even those without a fee, but they might be considered
    only
  prefs: []
  type: TYPE_NORMAL
- en: after some considerable time has elapsed since their inclusion in the transaction
    pool.
  prefs: []
  type: TYPE_NORMAL
- en: If they’ve aged, then they’ll be eventually included. Moreover, under the assumption
  prefs: []
  type: TYPE_NORMAL
- en: '248'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 5 BloCkChain Consensus
  prefs: []
  type: TYPE_NORMAL
- en: that usually there is a majority of honest miners always in the network, the
    transactions are expected to be picked up in a reasonable amount of time in line
    with the protocol
  prefs: []
  type: TYPE_NORMAL
- en: specification.
  prefs: []
  type: TYPE_NORMAL
- en: Let us now see what is that order.
  prefs: []
  type: TYPE_NORMAL
- en: The transactions are picked up from the transaction pool based on its priority,
    which
  prefs: []
  type: TYPE_NORMAL
- en: 'is calculated using the following formula [8]:'
  prefs: []
  type: TYPE_NORMAL
- en: '*sum*( *input value in base*'
  prefs: []
  type: TYPE_NORMAL
- en: '*units*'
  prefs: []
  type: TYPE_NORMAL
- en: × *input age*)
  prefs: []
  type: TYPE_NORMAL
- en: '*priority* ='
  prefs: []
  type: TYPE_NORMAL
- en: '*size in by*'
  prefs: []
  type: TYPE_NORMAL
- en: '*ttes*'
  prefs: []
  type: TYPE_NORMAL
- en: Σ( *v* × )
  prefs: []
  type: TYPE_NORMAL
- en: '*i*'
  prefs: []
  type: TYPE_NORMAL
- en: '*a*'
  prefs: []
  type: TYPE_NORMAL
- en: '*p*'
  prefs: []
  type: TYPE_NORMAL
- en: '*i*'
  prefs: []
  type: TYPE_NORMAL
- en: '='
  prefs: []
  type: TYPE_NORMAL
- en: '*s*'
  prefs: []
  type: TYPE_NORMAL
- en: It is of concern that the ordering of transactions is not fair and leads to
    front running and other relevant attacks. We will discuss fair ordering in Chapter
    [10](https://doi.org/10.1007/978-1-4842-8179-6_10).
  prefs: []
  type: TYPE_NORMAL
- en: '**PoW As a Solution to Byzantine Generals Problem**'
  prefs: []
  type: TYPE_NORMAL
- en: This has been described by Satoshi Nakamoto himself in a post [5]. I will describe
    the
  prefs: []
  type: TYPE_NORMAL
- en: logic here in a concise way.
  prefs: []
  type: TYPE_NORMAL
- en: Remember in the Byzantine generals problem, the problem is to agree on an attack
  prefs: []
  type: TYPE_NORMAL
- en: time in the presence of treacherous generals and the possibility of captured
    messengers.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of proof of work, we can consider miners as generals where the understanding
  prefs: []
  type: TYPE_NORMAL
- en: between generals is that any general can announce the attack time and the attack
    time
  prefs: []
  type: TYPE_NORMAL
- en: heard first is accepted as the authoritative time to attack. The problem however
    is that
  prefs: []
  type: TYPE_NORMAL
- en: if two generals propose different times almost simultaneously, it could happen
    due to
  prefs: []
  type: TYPE_NORMAL
- en: messaging delays where some generals receive one of the attack times first,
    and some
  prefs: []
  type: TYPE_NORMAL
- en: others receive the other attack time first, resulting in disagreement. In order
    to solve this problem, each general who receives an attack time starts to solve
    a complex math puzzle.
  prefs: []
  type: TYPE_NORMAL
- en: When a general solves this math puzzle (proof of work), it broadcasts that to
    the network.
  prefs: []
  type: TYPE_NORMAL
- en: When other generals receive it, they switch to this new time.
  prefs: []
  type: TYPE_NORMAL
- en: All generals are allowed to propose a time, but only one of the proposed times
    will
  prefs: []
  type: TYPE_NORMAL
- en: eventually be accepted as valid by all generals.
  prefs: []
  type: TYPE_NORMAL
- en: For a proposed time to be valid, the condition is that each general must solve
    a
  prefs: []
  type: TYPE_NORMAL
- en: mathematical puzzle and attach it with the proposed time message; if other generals
  prefs: []
  type: TYPE_NORMAL
- en: receive this message and see that the solution to the math puzzle is valid,
    they accept
  prefs: []
  type: TYPE_NORMAL
- en: '249'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 5 BloCkChain Consensus
  prefs: []
  type: TYPE_NORMAL
- en: that time. This mathematical puzzle serves two purposes; first, it is a proof
    that the
  prefs: []
  type: TYPE_NORMAL
- en: general is honest as they have solved the math puzzle, and, second, it stops
    the generals from proposing too many times in quick succession, which will result
    in disagreement
  prefs: []
  type: TYPE_NORMAL
- en: and confusion between the generals. We can see that this mechanism can be seen
  prefs: []
  type: TYPE_NORMAL
- en: as a solution to the Byzantine generals problem; however, with a compromise,
    that
  prefs: []
  type: TYPE_NORMAL
- en: temporary disagreement is acceptable.
  prefs: []
  type: TYPE_NORMAL
- en: Bitcoin poW is a probabilistic consensus algorithm. the big question now arises
  prefs: []
  type: TYPE_NORMAL
- en: whether deterministic consensus can be achieved when the number of nodes is
  prefs: []
  type: TYPE_NORMAL
- en: unknown and in the presence of Byzantine nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s revisit the validity, agreement, and termination properties defined
    at the
  prefs: []
  type: TYPE_NORMAL
- en: start of this chapter in the light of what we have learned so far about the
    proof of work algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: We can see clearly now that PoW is not a classical deterministic Byzantine consensus
  prefs: []
  type: TYPE_NORMAL
- en: algorithm. It is a protocol with probabilistic properties.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s revisit the properties now.
  prefs: []
  type: TYPE_NORMAL
- en: '**Agreement**'
  prefs: []
  type: TYPE_NORMAL
- en: An agreement property is probabilistic. This is the case because it can happen
    that two
  prefs: []
  type: TYPE_NORMAL
- en: different miners produce a valid block almost simultaneously, and some nodes
    add a
  prefs: []
  type: TYPE_NORMAL
- en: block from one miner and some other nodes from another. Eventually, however,
    the
  prefs: []
  type: TYPE_NORMAL
- en: longest (strongest) chain rule will ensure that the chain with less proof of
    work behind
  prefs: []
  type: TYPE_NORMAL
- en: it is pruned and the longest chain prevails. This will result in previously
    accepted
  prefs: []
  type: TYPE_NORMAL
- en: transactions to be rolled back; thus, the agreement is probabilistic.
  prefs: []
  type: TYPE_NORMAL
- en: '**Validity – Predicate Based**'
  prefs: []
  type: TYPE_NORMAL
- en: This is a deterministic property agreement where honest nodes only accept those
    blocks
  prefs: []
  type: TYPE_NORMAL
- en: which are valid. Formally, we can say that if a correct process p eventually
    decides on b, then v must satisfy the application-specific valid() predicate.
    We discussed the validity predicate, that is, the block validation criteria, in
    detail earlier in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '250'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 5 BloCkChain Consensus
  prefs: []
  type: TYPE_NORMAL
- en: '**Termination**'
  prefs: []
  type: TYPE_NORMAL
- en: Termination is a probabilistic property. It is only achieved eventually due
    to the possibility of natural forks. This is because in the case of forks, the
    fork must be resolved in order to finally terminate a consensus process on the
    block. As there is a possibility that a previously accepted block is rolled back
    in favor of the heaviest/longest chain, the termination can only be guaranteed
    probabilistically. Usually, in order to ensure with high probability
  prefs: []
  type: TYPE_NORMAL
- en: the finality of the transactions, in practice six confirmations are traditionally
    required.
  prefs: []
  type: TYPE_NORMAL
- en: This means that the block is at least six blocks deeper in the chain, which
    means that the possibility of a rollback is so low that it can never happen or
    happen once in a millennia.
  prefs: []
  type: TYPE_NORMAL
- en: With this, we complete our discussion on proof of work.
  prefs: []
  type: TYPE_NORMAL
- en: '**PoW Concerns**'
  prefs: []
  type: TYPE_NORMAL
- en: There are several concerns regarding PoW, including attacks and extreme energy
  prefs: []
  type: TYPE_NORMAL
- en: consumption.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we discuss some of the attacks that can be carried out
    against the
  prefs: []
  type: TYPE_NORMAL
- en: proof of work consensus, which adversely affects the Bitcoin network.
  prefs: []
  type: TYPE_NORMAL
- en: '**51% Attack**'
  prefs: []
  type: TYPE_NORMAL
- en: A 51% attack on Bitcoin can occur when more than 50% of the mining hash power
    is
  prefs: []
  type: TYPE_NORMAL
- en: controlled by an adversary.
  prefs: []
  type: TYPE_NORMAL
- en: Table [5-3](#p268) shows a list of actions that an adversary can possibly try
    to take after taking over more than 50% hash power of the network.
  prefs: []
  type: TYPE_NORMAL
- en: '***Table 5-3\.** List of actions by adversary*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Attack**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Possibility**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Explanation**'
  prefs: []
  type: TYPE_NORMAL
- en: Censor transactions
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes'
  prefs: []
  type: TYPE_NORMAL
- en: Can ignore transactions
  prefs: []
  type: TYPE_NORMAL
- en: Coin stealing
  prefs: []
  type: TYPE_NORMAL
- en: 'no'
  prefs: []
  type: TYPE_NORMAL
- en: Controlled by a private key
  prefs: []
  type: TYPE_NORMAL
- en: Double-spend
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes'
  prefs: []
  type: TYPE_NORMAL
- en: Can create a private off-chain fork and exclude the block
  prefs: []
  type: TYPE_NORMAL
- en: which contains previously spent transaction
  prefs: []
  type: TYPE_NORMAL
- en: Change protocol
  prefs: []
  type: TYPE_NORMAL
- en: 'no'
  prefs: []
  type: TYPE_NORMAL
- en: a protocol cannot be changed as valid nodes will simply
  prefs: []
  type: TYPE_NORMAL
- en: ignore the invalid blocks
  prefs: []
  type: TYPE_NORMAL
- en: '251'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 5 BloCkChain Consensus
  prefs: []
  type: TYPE_NORMAL
- en: Note that some attacks are still impossible, while the most detrimental to a
    system
  prefs: []
  type: TYPE_NORMAL
- en: are possible, such as double-spend.
  prefs: []
  type: TYPE_NORMAL
- en: '**Selfish Mining**'
  prefs: []
  type: TYPE_NORMAL
- en: This type of attack occurs when a miner who has found a block keeps it a secret
    instead
  prefs: []
  type: TYPE_NORMAL
- en: of announcing it and keeps building on top of it privately. Imagine the attacker
    has
  prefs: []
  type: TYPE_NORMAL
- en: managed to create another block. Now the attacker has two blocks in their private
  prefs: []
  type: TYPE_NORMAL
- en: forked chain. At this point, the attacker waits for someone else to find a block.
    When
  prefs: []
  type: TYPE_NORMAL
- en: the attacker sees this new block, they release their two-block chain. Because
    other
  prefs: []
  type: TYPE_NORMAL
- en: miners are honest and abiding by the longest chain rule, they will accept this
    new chain
  prefs: []
  type: TYPE_NORMAL
- en: being the longest. Now the block that was mined by someone else is orphaned
    despite
  prefs: []
  type: TYPE_NORMAL
- en: spending resources on it, but that work is wasted. The attacker could also wait
    for a
  prefs: []
  type: TYPE_NORMAL
- en: longer chain to be created, albeit mostly by luck, but if the attacker manages
    to create
  prefs: []
  type: TYPE_NORMAL
- en: such a private fork which is longer than the honest chain, then the attacker
    can release
  prefs: []
  type: TYPE_NORMAL
- en: that as soon as some other block is announced. Now when the nodes see this new
  prefs: []
  type: TYPE_NORMAL
- en: longest chain, according to the rules, they will start mining on top of this
    new longer
  prefs: []
  type: TYPE_NORMAL
- en: chain and orphaning the other chains, which could just be one block shorter
    than the
  prefs: []
  type: TYPE_NORMAL
- en: attacker’s chain. All the work that has gone into creating the honest chain
    is now wasted, and the attacker gets the rewards, instead of other miners who
    did the work on the
  prefs: []
  type: TYPE_NORMAL
- en: honest chain.
  prefs: []
  type: TYPE_NORMAL
- en: '**Race Attack**'
  prefs: []
  type: TYPE_NORMAL
- en: This attack can occur in a situation where the adversary can make a payment
    to one
  prefs: []
  type: TYPE_NORMAL
- en: beneficiary and then a second one to themselves or someone else. Now if the
    first
  prefs: []
  type: TYPE_NORMAL
- en: payment is accepted by the recipient after zero confirmations, then it could
    happen that
  prefs: []
  type: TYPE_NORMAL
- en: the second transaction is mined and accepted in the next block, and the first
    transaction could remain unmined. As a result, the first recipient may never get
    their payment.
  prefs: []
  type: TYPE_NORMAL
- en: '**Finney Attack**'
  prefs: []
  type: TYPE_NORMAL
- en: The Finney attack can occur when a recipient of a payment accepts the payment
    with
  prefs: []
  type: TYPE_NORMAL
- en: zero confirmations. It is a type of double-spend attack where an attacker creates
    two
  prefs: []
  type: TYPE_NORMAL
- en: transactions. The first of these transactions is a payment to the recipient
    (victim) and
  prefs: []
  type: TYPE_NORMAL
- en: the second to themselves. However, the attacker does not broadcast the first
    transaction; instead, they include the second transaction in a block and mine
    it. Now at this point,
  prefs: []
  type: TYPE_NORMAL
- en: '252'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 5 BloCkChain Consensus
  prefs: []
  type: TYPE_NORMAL
- en: the attacker releases the first transaction and pays for the goods. The merchant
    does not wait here for the confirmations and accepts the payment. Now the attacker
    broadcasts
  prefs: []
  type: TYPE_NORMAL
- en: the premined block with the second transaction that pays to themselves. This
    invalidates
  prefs: []
  type: TYPE_NORMAL
- en: the first transaction as the second transaction takes precedence over the first
    one.
  prefs: []
  type: TYPE_NORMAL
- en: '**Vector76 Attack**'
  prefs: []
  type: TYPE_NORMAL
- en: This attack is a combination of Finney and race attacks. This attack is powerful
    enough to reverse a transaction even if it has one confirmation.
  prefs: []
  type: TYPE_NORMAL
- en: '**Eclipse Attack**'
  prefs: []
  type: TYPE_NORMAL
- en: This attack attempts to obscure a node’s correct view of the network, which
    can lead to
  prefs: []
  type: TYPE_NORMAL
- en: disruption to service, double-spend attacks, and waste of resources. There are
    several
  prefs: []
  type: TYPE_NORMAL
- en: solutions to fix the issue, which have been implemented in Bitcoin. More details
    can be
  prefs: []
  type: TYPE_NORMAL
- en: 'found here: [https://cs-people.bu.edu/heilman/eclipse/.](https://cs-people.bu.edu/heilman/eclipse/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**ESG Impact**'
  prefs: []
  type: TYPE_NORMAL
- en: ESG metrics represent an overall picture of environmental, social, and governance
  prefs: []
  type: TYPE_NORMAL
- en: concerns. These metrics are used as a measure to assess a company’s exposure
    to
  prefs: []
  type: TYPE_NORMAL
- en: environmental, social, and governance risks. They are used by investors to make
  prefs: []
  type: TYPE_NORMAL
- en: investment decisions. Investors may not invest where ESG risks are higher and
    may
  prefs: []
  type: TYPE_NORMAL
- en: prefer companies where ESG risk is low.
  prefs: []
  type: TYPE_NORMAL
- en: Proof of work has been criticized for consuming too much energy. It is true
    that
  prefs: []
  type: TYPE_NORMAL
- en: currently at the time of writing, the total energy consumption of the Bitcoin
    blockchain is more than the entire country of Pakistan [9].
  prefs: []
  type: TYPE_NORMAL
- en: There are environmental, social, and governance concerns (ESG concerns) that
    have
  prefs: []
  type: TYPE_NORMAL
- en: been the cause of low interest from savvy mainstream investors. Nonetheless,
    Bitcoin
  prefs: []
  type: TYPE_NORMAL
- en: largely can be seen as a success despite its ESG concerns.
  prefs: []
  type: TYPE_NORMAL
- en: Not only has Bitcoin been criticized for its high energy consumption but often
  prefs: []
  type: TYPE_NORMAL
- en: seen as a vehicle for criminal activities, where Bitcoin has been accepted as
    a mode of
  prefs: []
  type: TYPE_NORMAL
- en: payment for illicit drugs and other criminal activities.
  prefs: []
  type: TYPE_NORMAL
- en: A centralization problem is also a concern where some powerful miners with mining
  prefs: []
  type: TYPE_NORMAL
- en: farms take up most of the hash rate of the Bitcoin network. The ASICs that are
    used to
  prefs: []
  type: TYPE_NORMAL
- en: build these mining farms are produced only by a few manufacturers, which means
    that
  prefs: []
  type: TYPE_NORMAL
- en: this is also a highly centralized space. Moreover, a crackdown [13] on Bitcoin
    mining
  prefs: []
  type: TYPE_NORMAL
- en: '253'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 5 BloCkChain Consensus
  prefs: []
  type: TYPE_NORMAL
- en: could also result in more centralization, where only the most powerful miners
    may
  prefs: []
  type: TYPE_NORMAL
- en: be able to withstand this crackdown and survive, resulting in only a few surviving
    and
  prefs: []
  type: TYPE_NORMAL
- en: powerful miners at the end.
  prefs: []
  type: TYPE_NORMAL
- en: There are however points in favor of Bitcoin. Bitcoin can be used as a cross-border
  prefs: []
  type: TYPE_NORMAL
- en: remittance mechanism for migrant families. It can also be used as a mode of
    payment in
  prefs: []
  type: TYPE_NORMAL
- en: struggling economies. It can serve the unbanked population, which is estimated
    to be 1.7
  prefs: []
  type: TYPE_NORMAL
- en: billion [12]. Bitcoin serves as a vehicle for financial inclusion.
  prefs: []
  type: TYPE_NORMAL
- en: We could think of scenarios where the heat produced by Bitcoin mining farms
    may
  prefs: []
  type: TYPE_NORMAL
- en: be used to heat up water and eventually homes. Even electricity could be generated
  prefs: []
  type: TYPE_NORMAL
- en: and fed back into the electricity grid by using thermoelectric generators due
    to
  prefs: []
  type: TYPE_NORMAL
- en: thermoelectric effect. Of course, economics and engineering need to be worked
    out;
  prefs: []
  type: TYPE_NORMAL
- en: however, this idea can work.
  prefs: []
  type: TYPE_NORMAL
- en: '*Thermoelectric power generator, any of a class of solid-state devices that*'
  prefs: []
  type: TYPE_NORMAL
- en: '*either convert heat directly into electricity or transform electrical energy*'
  prefs: []
  type: TYPE_NORMAL
- en: '*into thermal power for heating or cooling. Such devices are based on ther-*'
  prefs: []
  type: TYPE_NORMAL
- en: '*moelectric effects involving interactions between the flow of heat and of*'
  prefs: []
  type: TYPE_NORMAL
- en: '*electricity through solid bodies. [11]*'
  prefs: []
  type: TYPE_NORMAL
- en: — *Encyclopaedia Britannica*, March 1, 2007, [www.britannica.com/](http://www.britannica.com/technology/thermoelectric-power-generator)
  prefs: []
  type: TYPE_NORMAL
- en: '[technology/thermoelectric-power-generator](http://www.britannica.com/technology/thermoelectric-power-generator)'
  prefs: []
  type: TYPE_NORMAL
- en: Payment systems and in fact any system require electricity to run. Bitcoin is
    criticized
  prefs: []
  type: TYPE_NORMAL
- en: of consuming too much energy; however, this is the price paid for the strength
    of the
  prefs: []
  type: TYPE_NORMAL
- en: system. The network difficulty rate is so high now that even many attackers
    colluding
  prefs: []
  type: TYPE_NORMAL
- en: together won’t be able to generate enough hash power to launch a 51% attack.
    So yes,
  prefs: []
  type: TYPE_NORMAL
- en: electricity is consumed, but in return there are benefits. In addition to the
    security of Bitcoin, there are other benefits such as
  prefs: []
  type: TYPE_NORMAL
- en: • Bitcoin can be used in suppressed regimes.
  prefs: []
  type: TYPE_NORMAL
- en: • Borderless payments.
  prefs: []
  type: TYPE_NORMAL
- en: • Bank the unbanked.
  prefs: []
  type: TYPE_NORMAL
- en: • Smooth cross-border remittance.
  prefs: []
  type: TYPE_NORMAL
- en: • Alternative payment system which doesn’t have any intermediary.
  prefs: []
  type: TYPE_NORMAL
- en: • Payments without a middleman.
  prefs: []
  type: TYPE_NORMAL
- en: '254'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 5 BloCkChain Consensus
  prefs: []
  type: TYPE_NORMAL
- en: In summary, Bitcoin, despite its energy consumption and not living up to its
    original
  prefs: []
  type: TYPE_NORMAL
- en: philosophy of One CPU = One Vote, still can be seen as a successful project
    with many
  prefs: []
  type: TYPE_NORMAL
- en: benefits.
  prefs: []
  type: TYPE_NORMAL
- en: '**Variants of PoW**'
  prefs: []
  type: TYPE_NORMAL
- en: There are two types of proof of work algorithms depending on the hardware it
    is
  prefs: []
  type: TYPE_NORMAL
- en: 'intended to run on:'
  prefs: []
  type: TYPE_NORMAL
- en: • CPU-bound PoW
  prefs: []
  type: TYPE_NORMAL
- en: • Memory-bound PoW
  prefs: []
  type: TYPE_NORMAL
- en: '**CPU-Bound PoW**'
  prefs: []
  type: TYPE_NORMAL
- en: These puzzles run at the speed of the processor. CPU-bound PoW refers to a type
    of PoW
  prefs: []
  type: TYPE_NORMAL
- en: where the processing required to find the solution to the cryptographic hash
    puzzle is
  prefs: []
  type: TYPE_NORMAL
- en: directly proportional to the calculation speed of the CPU or hardware such as
    ASICs.
  prefs: []
  type: TYPE_NORMAL
- en: Because ASICs have dominated Bitcoin PoW and provide somewhat undue advantage
  prefs: []
  type: TYPE_NORMAL
- en: to the miners who can afford to use ASICs, this CPU-bound PoW is seen as shifting
  prefs: []
  type: TYPE_NORMAL
- en: toward centralization. Moreover, mining pools with extraordinary hash power
    can shift
  prefs: []
  type: TYPE_NORMAL
- en: the balance of power toward them. Therefore, memory-bound PoW algorithms have
  prefs: []
  type: TYPE_NORMAL
- en: been introduced, which are ASIC resistant and are based on memory-oriented design
  prefs: []
  type: TYPE_NORMAL
- en: instead of CPU.
  prefs: []
  type: TYPE_NORMAL
- en: '**Memory-Bound PoW**'
  prefs: []
  type: TYPE_NORMAL
- en: Memory-bound PoW algorithms rely on system RAM to provide PoW. Here, the
  prefs: []
  type: TYPE_NORMAL
- en: performance is bound by the access speed of the memory or the size of the memory.
  prefs: []
  type: TYPE_NORMAL
- en: This reliance on memory also makes these PoW algorithms ASIC resistant. Equihash
    is
  prefs: []
  type: TYPE_NORMAL
- en: one of the most prominent memory-bound PoW algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: There are other improvements and variations of proof of work, which we will
  prefs: []
  type: TYPE_NORMAL
- en: introduce in Chapter [8](https://doi.org/10.1007/978-1-4842-8179-6_8).
  prefs: []
  type: TYPE_NORMAL
- en: '255'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 5 BloCkChain Consensus
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we covered blockchain consensus:'
  prefs: []
  type: TYPE_NORMAL
- en: • Proof of work is the first blockchain consensus introduced with
  prefs: []
  type: TYPE_NORMAL
- en: Bitcoin, which is also a solution to the Byzantine generals problem.
  prefs: []
  type: TYPE_NORMAL
- en: • Blockchain consensus can be divided into two categories, the
  prefs: []
  type: TYPE_NORMAL
- en: Nakamoto consensus and the traditional BFT based.
  prefs: []
  type: TYPE_NORMAL
- en: • Traditional BFT is deterministic, whereas Nakamoto consensus is
  prefs: []
  type: TYPE_NORMAL
- en: probabilistic.
  prefs: []
  type: TYPE_NORMAL
- en: • Proof of work in Bitcoin is a Sybil resistance mechanism, a double-
  prefs: []
  type: TYPE_NORMAL
- en: spending prevention mechanism, and a solution to the Byzantine
  prefs: []
  type: TYPE_NORMAL
- en: generals problem.
  prefs: []
  type: TYPE_NORMAL
- en: • Proof of work can be seen in the light of game theory where the
  prefs: []
  type: TYPE_NORMAL
- en: protocol is a Nash equilibrium, and the dominant strategy for all
  prefs: []
  type: TYPE_NORMAL
- en: players is to be honest.
  prefs: []
  type: TYPE_NORMAL
- en: • Proof of work is effectively a Byzantine fault–tolerant protocol.
  prefs: []
  type: TYPE_NORMAL
- en: • Proof of work is a state machine replication protocol where a mined
  prefs: []
  type: TYPE_NORMAL
- en: block is announced and replicated to other nodes via a gossip
  prefs: []
  type: TYPE_NORMAL
- en: protocol.
  prefs: []
  type: TYPE_NORMAL
- en: • Proof of work consumes high energy, and there are ESG concerns;
  prefs: []
  type: TYPE_NORMAL
- en: however, there are benefits as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**Bibliography**'
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Proof of work originally introduced in: Cynthia Dwork and Moni'
  prefs: []
  type: TYPE_NORMAL
- en: Naor. Pricing via processing or combatting junk mail. In Ernest
  prefs: []
  type: TYPE_NORMAL
- en: F. Brickell, editor, Advances in Cryptology – CRYPTO ’92, 12th
  prefs: []
  type: TYPE_NORMAL
- en: Annual International Cryptology Conference, Santa Barbara,
  prefs: []
  type: TYPE_NORMAL
- en: California, USA, August 16–20, 1992, Proceedings, volume
  prefs: []
  type: TYPE_NORMAL
- en: 740 of Lecture Notes in Computer Science, pages 139–147\.
  prefs: []
  type: TYPE_NORMAL
- en: Springer, 1992\.
  prefs: []
  type: TYPE_NORMAL
- en: '256'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 5 BloCkChain Consensus
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Okun, Michael. Distributed computing among unacquainted
  prefs: []
  type: TYPE_NORMAL
- en: processors in the presence of Byzantine failures. Hebrew
  prefs: []
  type: TYPE_NORMAL
- en: University of Jerusalem, 2005\.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. [https://bitcoin.org/bitcoin.pdf](https://bitcoin.org/bitcoin.pdf)
  prefs: []
  type: TYPE_NORMAL
- en: 4\. [www.cs.yale.edu/publications/techreports/tr1332.pdf](http://www.cs.yale.edu/publications/techreports/tr1332.pdf)
  prefs: []
  type: TYPE_NORMAL
- en: 5\. [https://satoshi.nakamotoinstitute.org/emails/](https://satoshi.nakamotoinstitute.org/emails/cryptography/11/)
  prefs: []
  type: TYPE_NORMAL
- en: '[cryptography/11/](https://satoshi.nakamotoinstitute.org/emails/cryptography/11/)'
  prefs: []
  type: TYPE_NORMAL
- en: 6\. [https://hal.inria.fr/hal-01445797/document](https://hal.inria.fr/hal-01445797/document)
  prefs: []
  type: TYPE_NORMAL
- en: 7\. These terms were first introduced in [https://eprint.iacr.](https://eprint.iacr.org/2014/765.pdf)
  prefs: []
  type: TYPE_NORMAL
- en: '[org/2014/765.pdf](https://eprint.iacr.org/2014/765.pdf)'
  prefs: []
  type: TYPE_NORMAL
- en: 8\. [https://en.bitcoin.it/wiki/Miner_fees#Priority_](https://en.bitcoin.it/wiki/Miner_fees#Priority_transactions)
  prefs: []
  type: TYPE_NORMAL
- en: '[transactions](https://en.bitcoin.it/wiki/Miner_fees#Priority_transactions)'
  prefs: []
  type: TYPE_NORMAL
- en: 9\. Digiconomist[:](https://digiconomist.net/bitcoin-energy-consumption/)
  prefs: []
  type: TYPE_NORMAL
- en: '[https://digiconomist.net/bitcoin-energy-](https://digiconomist.net/bitcoin-energy-consumption/)'
  prefs: []
  type: TYPE_NORMAL
- en: '[consumption/](https://digiconomist.net/bitcoin-energy-consumption/)'
  prefs: []
  type: TYPE_NORMAL
- en: 10\. [www.hashcash.org](http://www.hashcash.org)
  prefs: []
  type: TYPE_NORMAL
- en: 11\. Strohl, G. Ralph and Harpster, Joseph W. "Thermoelectric
  prefs: []
  type: TYPE_NORMAL
- en: power generator." Encyclopedia Britannica, Mar. 1, 2007,
  prefs: []
  type: TYPE_NORMAL
- en: '[www.britannica.com/technology/thermoelectric-power-](http://www.britannica.com/technology/thermoelectric-power-generator)'
  prefs: []
  type: TYPE_NORMAL
- en: '[generator](http://www.britannica.com/technology/thermoelectric-power-generator).
    Accessed June 25, 2021\.'
  prefs: []
  type: TYPE_NORMAL
- en: 12\. [https://globalfindex.worldbank.org/sites/globalfindex/](https://globalfindex.worldbank.org/sites/globalfindex/files/chapters/2017
    Findex full report_chapter2.pdf)
  prefs: []
  type: TYPE_NORMAL
- en: '[files/chapters/2017%20Findex%20full%20report_](https://globalfindex.worldbank.org/sites/globalfindex/files/chapters/2017
    Findex full report_chapter2.pdf)'
  prefs: []
  type: TYPE_NORMAL
- en: '[chapter2.pdf](https://globalfindex.worldbank.org/sites/globalfindex/files/chapters/2017
    Findex full report_chapter2.pdf)'
  prefs: []
  type: TYPE_NORMAL
- en: 13\. [www.coindesk.com/bitcoin-slips-37k-china-](http://www.coindesk.com/bitcoin-slips-37k-china-vicecrackdown-mining)
  prefs: []
  type: TYPE_NORMAL
- en: '[vicecrackdown-mining](http://www.coindesk.com/bitcoin-slips-37k-china-vicecrackdown-mining)'
  prefs: []
  type: TYPE_NORMAL
- en: 14\. Introduction to the Distributed Systems channel by Chris
  prefs: []
  type: TYPE_NORMAL
- en: 'Coloh[an: www.distributedsystemscourse.com](http://www.distributedsystemscourse.com)'
  prefs: []
  type: TYPE_NORMAL
- en: '15\. Bitcoin blockchain consensus[: https://youtu.be/f1ZJPEKeTEY](https://youtu.be/f1ZJPEKeTEY)'
  prefs: []
  type: TYPE_NORMAL
- en: '257'
  prefs: []
  type: TYPE_NORMAL
- en: '**CHAPTER 6**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Early Protocols**'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I introduce early protocols. First, we start with a background
    on
  prefs: []
  type: TYPE_NORMAL
- en: distributed transactions and relevant protocols, such as the two-phase commit.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we’ll continue our journey, look at the agreement protocols, and
    conclude
  prefs: []
  type: TYPE_NORMAL
- en: the chapter with some fundamental results in distributed computing. This chapter
  prefs: []
  type: TYPE_NORMAL
- en: introduces early consensus algorithms such as those presented in the works of
    Lamport
  prefs: []
  type: TYPE_NORMAL
- en: et al., Ben-Or et al., and Toueg et.al. It is helpful to understand these fundamental
    ideas before continuing our voyage toward more complex and modern protocols.
  prefs: []
  type: TYPE_NORMAL
- en: '**Introduction**'
  prefs: []
  type: TYPE_NORMAL
- en: In my view, the 1980s was the golden age for innovation and discovery in distributed
  prefs: []
  type: TYPE_NORMAL
- en: computing. Many fundamental problems, algorithms, and results such as the Byzantine
  prefs: []
  type: TYPE_NORMAL
- en: generals problem, FLP impossibility result, partial synchrony, and techniques
    to
  prefs: []
  type: TYPE_NORMAL
- en: circumvent FLP impossibility were discovered during the late 1970s and 1980s.
    Starting
  prefs: []
  type: TYPE_NORMAL
- en: from Lamport’s phenomenal paper “Time, Clocks, and the Ordering of Events in
    a
  prefs: []
  type: TYPE_NORMAL
- en: Distributed System” to the Byzantine generals problem and then Schneider’s state
  prefs: []
  type: TYPE_NORMAL
- en: machine replication paper, one after another, there were most significant contributions
  prefs: []
  type: TYPE_NORMAL
- en: made to the consensus problem and generally in distributed computing.
  prefs: []
  type: TYPE_NORMAL
- en: Consensus can be defined as a protocol for achieving agreement. A high-level
    list of
  prefs: []
  type: TYPE_NORMAL
- en: major contributions is described as follows.
  prefs: []
  type: TYPE_NORMAL
- en: In his seminal paper in 1978, “Time, Clocks, and Ordering of Events in a Distributed
  prefs: []
  type: TYPE_NORMAL
- en: System”, Lamport described how to order events using synchronized clocks in
    the
  prefs: []
  type: TYPE_NORMAL
- en: absence of faults. Then in 1980, the paper “Reaching Agreement in the Presence
    of
  prefs: []
  type: TYPE_NORMAL
- en: Faults” posed the question if agreement can be reached in an unreliable distributed
  prefs: []
  type: TYPE_NORMAL
- en: system. It was proven that agreement is achievable if the number of faulty nodes
    in a
  prefs: []
  type: TYPE_NORMAL
- en: distributed system is less than one-third of the total number of processes,
    i.e. n>=3f+1, where n is the number of total nodes and f is the number of faulty
    processors. In the
  prefs: []
  type: TYPE_NORMAL
- en: paper “The Byzantine Generals Problem” in 1982, Lamport et al. showed that agreement
  prefs: []
  type: TYPE_NORMAL
- en: '259'
  prefs: []
  type: TYPE_NORMAL
- en: © Imran Bashir 2022
  prefs: []
  type: TYPE_NORMAL
- en: I. Bashir, *Blockchain Consensus*, [https://doi.org/10.1007/978-1-4842-8179-6_6](https://doi.org/10.1007/978-1-4842-8179-6_6#DOI)
  prefs: []
  type: TYPE_NORMAL
- en: CHapTer 6 early proToCols
  prefs: []
  type: TYPE_NORMAL
- en: is solvable using oral messages if more than two-thirds of the generals are
    loyal. In 1982, the paper “The Byzantine generals strike again” by Danny Dolev
    showed that unanimity
  prefs: []
  type: TYPE_NORMAL
- en: is achievable if less than one-third of the total number of processors are faulty
    and more than one-half of the network’s connectivity is available.
  prefs: []
  type: TYPE_NORMAL
- en: Unanimity is a requirement where if all initial values of the processes are
    the same,
  prefs: []
  type: TYPE_NORMAL
- en: say v, then all processes decide on that value v. This is strong unanimity.
    However,
  prefs: []
  type: TYPE_NORMAL
- en: a weaker variant called weak unanimity only requires this condition to hold
    if all
  prefs: []
  type: TYPE_NORMAL
- en: processes are correct; in other words, no processes are faulty.
  prefs: []
  type: TYPE_NORMAL
- en: The paper also provided the first proof that the distributed system must have
    3 *f* + 1
  prefs: []
  type: TYPE_NORMAL
- en: nodes to tolerate *f* faults. However, the celebrated FLP result appeared a
    little later which proved that deterministic asynchronous consensus is not possible
    even if a single
  prefs: []
  type: TYPE_NORMAL
- en: process is crash faulty. FLP impossibility implies that safety and liveness
    of a consensus protocol cannot be guaranteed in an asynchronous network.
  prefs: []
  type: TYPE_NORMAL
- en: Lamport’s algorithm was for a synchronous setting and assumed that eventually
    all
  prefs: []
  type: TYPE_NORMAL
- en: the messages will be delivered. Moreover, it wasn’t fault tolerant because a
    single failure will halt the algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: After the FLP impossibility result appeared, attempts started to circumvent
    it and
  prefs: []
  type: TYPE_NORMAL
- en: solve the consensus problem nevertheless. The intuition behind circumventing
    FLP is to
  prefs: []
  type: TYPE_NORMAL
- en: relax some stricter requirements of timing and determinism.
  prefs: []
  type: TYPE_NORMAL
- en: Ben-Or proposed the earliest algorithms to sacrifice some level of determinism
    to
  prefs: []
  type: TYPE_NORMAL
- en: circumvent FLP. As FLP impossibility implies that under asynchrony, there will
    always
  prefs: []
  type: TYPE_NORMAL
- en: be an execution that does not terminate, one way of avoiding that is to try
    and make
  prefs: []
  type: TYPE_NORMAL
- en: termination probabilistic. So that instead of deterministic termination, probabilistic
  prefs: []
  type: TYPE_NORMAL
- en: termination is used. The intuition behind these algorithms is to use the “common
    coin”
  prefs: []
  type: TYPE_NORMAL
- en: approach, where a process randomly chooses its values if it doesn’t receive
    messages
  prefs: []
  type: TYPE_NORMAL
- en: from other nodes. In other words, a process is allowed to select a value to
    vote on if
  prefs: []
  type: TYPE_NORMAL
- en: it doesn’t receive a majority of votes on the value from the rest of the processes.
    This
  prefs: []
  type: TYPE_NORMAL
- en: means that eventually more than half of the nodes will end up voting for the
    same value.
  prefs: []
  type: TYPE_NORMAL
- en: However, this algorithm’s communication complexity increases exponentially with
    the
  prefs: []
  type: TYPE_NORMAL
- en: number of nodes. Later, another approach that achieved consensus in a fixed
    number
  prefs: []
  type: TYPE_NORMAL
- en: of rounds was proposed by Rabin. These proposals required 5 *f* + 1 and 10 *f*
    + 1 rounds, respectively, as compared to the 3 *f* + 1 lower bound commonly known
    today.
  prefs: []
  type: TYPE_NORMAL
- en: '260'
  prefs: []
  type: TYPE_NORMAL
- en: CHapTer 6 early proToCols
  prefs: []
  type: TYPE_NORMAL
- en: Consensus protocols that relax timing (synchrony) requirements aim to provide
    safety
  prefs: []
  type: TYPE_NORMAL
- en: under all circumstances and liveness only when the network is synchronous. A
    significant
  prefs: []
  type: TYPE_NORMAL
- en: breakthrough was the work of Dwork, Lynch, and Stockmeyer, which for the first
    time
  prefs: []
  type: TYPE_NORMAL
- en: introduced a more realistic idea of partial synchrony. This model is more practical
    as it captures how real distributed systems behave. More precisely, distributed
    systems can be asynchronous for arbitrary periods but will eventually return to
    synchrony long enough for the system
  prefs: []
  type: TYPE_NORMAL
- en: to make a decision and terminate. This paper introduced various combinations
    of processor and network synchrony and asynchrony and proved the lower bounds
    for such scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note** We discussed partial synchrony in detail in Cha[pter 3\.](https://doi.org/10.1007/978-1-4842-8179-6_3)'
  prefs: []
  type: TYPE_NORMAL
- en: Table [6-1](#p277) shows the summary of results from the DLS88 paper showing
    a minimum number of processors for which a fault-tolerant consensus protocol exists.
  prefs: []
  type: TYPE_NORMAL
- en: '***Table 6-1\.** Minimum number of processors for which a fault-tolerant consensus*'
  prefs: []
  type: TYPE_NORMAL
- en: '*protocol exists*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Type of Fault**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Synchronous Asynchronous Partially Synch Comms and Processor**'
  prefs: []
  type: TYPE_NORMAL
- en: Fail-stop
  prefs: []
  type: TYPE_NORMAL
- en: f
  prefs: []
  type: TYPE_NORMAL
- en: Na
  prefs: []
  type: TYPE_NORMAL
- en: 2f + 1
  prefs: []
  type: TYPE_NORMAL
- en: omission
  prefs: []
  type: TYPE_NORMAL
- en: f
  prefs: []
  type: TYPE_NORMAL
- en: Na
  prefs: []
  type: TYPE_NORMAL
- en: 2f + 1
  prefs: []
  type: TYPE_NORMAL
- en: authenticated Byzantine f
  prefs: []
  type: TYPE_NORMAL
- en: Na
  prefs: []
  type: TYPE_NORMAL
- en: 3f + 1
  prefs: []
  type: TYPE_NORMAL
- en: Byzantine
  prefs: []
  type: TYPE_NORMAL
- en: 3f + 1
  prefs: []
  type: TYPE_NORMAL
- en: Na
  prefs: []
  type: TYPE_NORMAL
- en: 3f + 1
  prefs: []
  type: TYPE_NORMAL
- en: This paper introduced the DLS algorithm which solved consensus under partial
  prefs: []
  type: TYPE_NORMAL
- en: synchrony.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some major results are listed as follows, starting from the 1980s:'
  prefs: []
  type: TYPE_NORMAL
- en: • Lamport showed in LPS 82 that under a synchronous setting, n > 2f
  prefs: []
  type: TYPE_NORMAL
- en: with authentication and n > 3f are at least required with oral messages.
  prefs: []
  type: TYPE_NORMAL
- en: • The FLP result in 1982 showed that even with a single crash failure,
  prefs: []
  type: TYPE_NORMAL
- en: consensus is impossible under asynchrony, and at least n > 3f are
  prefs: []
  type: TYPE_NORMAL
- en: required for safety.
  prefs: []
  type: TYPE_NORMAL
- en: • Ben-Or in 1983 proposed a randomized solution under asynchrony.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s go through distributed transaction which is a major concept in distributed
  prefs: []
  type: TYPE_NORMAL
- en: systems.
  prefs: []
  type: TYPE_NORMAL
- en: '261'
  prefs: []
  type: TYPE_NORMAL
- en: CHapTer 6 early proToCols
  prefs: []
  type: TYPE_NORMAL
- en: '**Distributed Transactions**'
  prefs: []
  type: TYPE_NORMAL
- en: A distributed transaction is a sequence of events spread across multiple processes.
    A
  prefs: []
  type: TYPE_NORMAL
- en: transaction either concludes with a commit or abort. If committed, all events
    are executed, and the output is generated, and if aborted, the transaction halts
    without complete
  prefs: []
  type: TYPE_NORMAL
- en: execution. A transaction is atomic if it executes and commits fully; otherwise,
    it rolls back with no effect. In other words, atomic transactions either execute
    in full or not at all.
  prefs: []
  type: TYPE_NORMAL
- en: There are four properties that a transaction must satisfy, commonly known as
    the
  prefs: []
  type: TYPE_NORMAL
- en: 'ACID consistency model:'
  prefs: []
  type: TYPE_NORMAL
- en: '• **Atomicity**: Either the transaction events fully execute or not at all.'
  prefs: []
  type: TYPE_NORMAL
- en: '• **Consistency**: If a transaction commits, it results in a valid'
  prefs: []
  type: TYPE_NORMAL
- en: (consistent) state of the system. It satisfies some invariants.
  prefs: []
  type: TYPE_NORMAL
- en: '• **Isolation**: Unless the transaction is committed, no effects are visible.'
  prefs: []
  type: TYPE_NORMAL
- en: '• **Durability**: A transaction once committed has a permanent effect.'
  prefs: []
  type: TYPE_NORMAL
- en: One point to note here is that consistency is guaranteed much easily in monolithic
  prefs: []
  type: TYPE_NORMAL
- en: architectures. In contrast, consistency is not immediate in distributed architectures,
    and distributed architectures rely on so-called eventual consistency. Eventual
    consistency
  prefs: []
  type: TYPE_NORMAL
- en: means that all nodes in a system eventually (at some point in time in future)
    synchronize and agree on a consistent state of the system. ACID properties must
    hold even if some
  prefs: []
  type: TYPE_NORMAL
- en: nodes (processes) fail.
  prefs: []
  type: TYPE_NORMAL
- en: Atomicity, isolation, and durability are easier to achieve in monolithic architectures,
  prefs: []
  type: TYPE_NORMAL
- en: but achieving these properties in distributed settings becomes more challenging.
  prefs: []
  type: TYPE_NORMAL
- en: A two-phase commit protocol is used to achieve atomicity across multiple processes.
  prefs: []
  type: TYPE_NORMAL
- en: Replicas should be consistent with one another. Atomic commit protocols are
    in fact
  prefs: []
  type: TYPE_NORMAL
- en: a kind of consensus mechanism because in transaction commit protocols nodes
    must
  prefs: []
  type: TYPE_NORMAL
- en: come to an agreement to either commit if all is well or roll back in case something
    goes
  prefs: []
  type: TYPE_NORMAL
- en: wrong. Imagine if a transaction is expected to be committed on all nodes in
    a distributed system (a network), then either it must commit on all or none to
    maintain replica
  prefs: []
  type: TYPE_NORMAL
- en: consistency. We cannot have a situation where a transaction succeeds on some
    nodes
  prefs: []
  type: TYPE_NORMAL
- en: and not on others, leading to an inconsistent distributed system. This is where
    atomic
  prefs: []
  type: TYPE_NORMAL
- en: commit comes in. It can be seen fundamentally as a consensus algorithm because
  prefs: []
  type: TYPE_NORMAL
- en: this protocol requires an agreement between all nodes in a network. However,
    there
  prefs: []
  type: TYPE_NORMAL
- en: '262'
  prefs: []
  type: TYPE_NORMAL
- en: CHapTer 6 early proToCols
  prefs: []
  type: TYPE_NORMAL
- en: are fundamental differences between atomic commit and consensus. In consensus,
  prefs: []
  type: TYPE_NORMAL
- en: one or more nodes propose a value, and nodes decide on one of the values using
    the
  prefs: []
  type: TYPE_NORMAL
- en: consensus algorithm. This is usually achieved by majority consensus. In contrast,
    in
  prefs: []
  type: TYPE_NORMAL
- en: an atomic commit protocol, all nodes are required to vote whether they commit
    or
  prefs: []
  type: TYPE_NORMAL
- en: abort the transaction. In consensus algorithms, there can be multiple values
    proposed
  prefs: []
  type: TYPE_NORMAL
- en: out of which one can be agreed upon, whereas in atomic commit the protocol must
  prefs: []
  type: TYPE_NORMAL
- en: commit if all nodes vote to commit; otherwise, even if one node doesn’t agree,
    then the
  prefs: []
  type: TYPE_NORMAL
- en: transaction must be aborted by all nodes. A major distinction between atomic
    commit
  prefs: []
  type: TYPE_NORMAL
- en: and consensus is that in consensus algorithms, faults (crashed nodes) are tolerated
    due
  prefs: []
  type: TYPE_NORMAL
- en: to the quorum availability rule, whereas in atomic commit even if one node fails,
    the
  prefs: []
  type: TYPE_NORMAL
- en: transaction must abort on all nodes. To handle crashed nodes, a complete and
    strongly
  prefs: []
  type: TYPE_NORMAL
- en: accurate failure detector is used, which is implemented using a timeout mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the ACID consistency model, another common consistency model
  prefs: []
  type: TYPE_NORMAL
- en: used in databases is the BASE model. BASE stands for basically available (BA),
    soft
  prefs: []
  type: TYPE_NORMAL
- en: state (S), and eventually consistent (E). The databases using the BASE consistency
  prefs: []
  type: TYPE_NORMAL
- en: model ensure availability by replicating data across nodes in the system. As
    the model
  prefs: []
  type: TYPE_NORMAL
- en: does not provide immediate consistency, the data values could change over time,
  prefs: []
  type: TYPE_NORMAL
- en: which results in eventual consistency. In the BASE model, consistency is only
    achieved
  prefs: []
  type: TYPE_NORMAL
- en: eventually. However, it offers high availability, which is useful in many online
    services where immediate and strong consistency requirements are somewhat loose,
    like social
  prefs: []
  type: TYPE_NORMAL
- en: networks and online video platforms. From a CAP theorem perspective, the BASE
    model
  prefs: []
  type: TYPE_NORMAL
- en: sacrifices consistency and favors high availability.
  prefs: []
  type: TYPE_NORMAL
- en: Now we discuss the two-phase commit which is a famous commit protocol,
  prefs: []
  type: TYPE_NORMAL
- en: achieving atomicity.
  prefs: []
  type: TYPE_NORMAL
- en: '**Two-Phase Commit**'
  prefs: []
  type: TYPE_NORMAL
- en: A two-phase commit (2PC) is an atomic commit protocol to achieve atomicity.
    It was
  prefs: []
  type: TYPE_NORMAL
- en: first published in a paper by Lampson and Sturgis in 1979\. A two-phase commit
    enables
  prefs: []
  type: TYPE_NORMAL
- en: updating multiple databases in a single transaction and committing/aborting
    atomically.
  prefs: []
  type: TYPE_NORMAL
- en: As the name suggests, it works in two phases. The first phase is the vote collection
  prefs: []
  type: TYPE_NORMAL
- en: phase in which a coordinator node collects votes from each node participating
    in
  prefs: []
  type: TYPE_NORMAL
- en: the transaction. Each participant node either votes yes or no to either commit
    the
  prefs: []
  type: TYPE_NORMAL
- en: transaction or abort the transaction. When all votes are collected, the coordinator
  prefs: []
  type: TYPE_NORMAL
- en: '263'
  prefs: []
  type: TYPE_NORMAL
- en: CHapTer 6 early proToCols
  prefs: []
  type: TYPE_NORMAL
- en: (transaction manager) starts the second phase, called the decision phase. In
    the decision phase, the coordinator commits the transaction if it has received
    all yes votes from other nodes; otherwise, it aborts the transaction. Any node
    that had voted yes to commit
  prefs: []
  type: TYPE_NORMAL
- en: the transaction waits until it receives the final decision from the coordinator
    node. If it receives no from the coordinator, it will abort the transaction; otherwise,
    it will commit the transaction. Nodes that voted no immediately terminate the
    transaction without
  prefs: []
  type: TYPE_NORMAL
- en: waiting to receive a decision from the coordinator. When a transaction is aborted,
    any
  prefs: []
  type: TYPE_NORMAL
- en: changes made are rolled back. The changes are made permanent after committing
    at
  prefs: []
  type: TYPE_NORMAL
- en: nodes that said yes when they receive a commit decision from the coordinator.
    Any
  prefs: []
  type: TYPE_NORMAL
- en: changes made by the transaction are not permanent, and any locks are released
    after
  prefs: []
  type: TYPE_NORMAL
- en: a write operation is performed. All participants send the acknowledgment back
    to
  prefs: []
  type: TYPE_NORMAL
- en: the coordinator after they’ve received the decision from the coordinator. As
    a failure
  prefs: []
  type: TYPE_NORMAL
- en: handling mechanism, a logging scheme is used in two-phase commits. In this scheme,
  prefs: []
  type: TYPE_NORMAL
- en: all messages are written to a local stable storage before they are sent out
    to the recipients in the network. When the coordinator fails (crashes), it writes
    its decision to the local disk in the log, and when it recovers, it sends its
    decision to other nodes. If no decision was made before the crash, then it simply
    aborts the transaction. When a node fails
  prefs: []
  type: TYPE_NORMAL
- en: (other than the coordinator node), the coordinator waits until it times out,
    and a decision is made to abort the transaction for all.
  prefs: []
  type: TYPE_NORMAL
- en: Figur[e 6-1 sho](#p281)ws the two-phase commit protocol in action. Here, the
    client (application) starts the transaction as usual and performs a usual read/write
    operation
  prefs: []
  type: TYPE_NORMAL
- en: on the database nodes, that is, on the transaction participant nodes. After
    a normal
  prefs: []
  type: TYPE_NORMAL
- en: transaction execution on each participant, when the client is ready to commit
    the
  prefs: []
  type: TYPE_NORMAL
- en: transaction, the coordinator starts the first phase, that is, the prepare phase.
    It sends the prepare request to all nodes and asks them whether they can commit
    or not. If the
  prefs: []
  type: TYPE_NORMAL
- en: participants reply with a yes, it means that they are willing and ready to commit
    the
  prefs: []
  type: TYPE_NORMAL
- en: transaction, then the coordinator starts the second phase called the commit
    phase. This
  prefs: []
  type: TYPE_NORMAL
- en: is when the coordinator sends out the commit decision, and the transaction is
    finally
  prefs: []
  type: TYPE_NORMAL
- en: committed, and a commit actually takes place. If any of the participant nodes
    replies to
  prefs: []
  type: TYPE_NORMAL
- en: the prepare request with a no, then the coordinator sends out the abort request
    in phase
  prefs: []
  type: TYPE_NORMAL
- en: two, and all nodes abort accordingly. Note that after the first phase, there
    is a decision point where the coordinator decides whether to commit or abort.
    The action after the
  prefs: []
  type: TYPE_NORMAL
- en: decision phase is either commit or abort, based on the yes or no received from
    the
  prefs: []
  type: TYPE_NORMAL
- en: participants.
  prefs: []
  type: TYPE_NORMAL
- en: '264'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-281_1.png)'
  prefs: []
  type: TYPE_IMG
- en: CHapTer 6 early proToCols
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 6-1\.** The two-phase commit algorithm – a successful scenario*'
  prefs: []
  type: TYPE_NORMAL
- en: The two-phase commit is a blocking algorithm because if the coordinator goes
  prefs: []
  type: TYPE_NORMAL
- en: down after the “prepare” phase but before sending out its decision, other nodes
    have
  prefs: []
  type: TYPE_NORMAL
- en: no way of finding out what has been decided by the coordinator. Now they are
    stuck
  prefs: []
  type: TYPE_NORMAL
- en: in an uncertain state where they have agreed earlier to commit by saying yes/ok
    in the
  prefs: []
  type: TYPE_NORMAL
- en: prepare phase but are now waiting to hear the final decision from the coordinator.
    Nodes
  prefs: []
  type: TYPE_NORMAL
- en: cannot either commit or abort on their own after responding yes in the prepare
    phase
  prefs: []
  type: TYPE_NORMAL
- en: because it will violate the atomicity property. The protocol in this situation
    blocks until the coordinator recovers. This means that the two-phase commit algorithm
    is not fault
  prefs: []
  type: TYPE_NORMAL
- en: tolerant if the coordinator or a participant fails. In other words, 2PC is not
    partition
  prefs: []
  type: TYPE_NORMAL
- en: tolerant.
  prefs: []
  type: TYPE_NORMAL
- en: More precisely, if the coordinator crashes just after the prepare phase before
    sending
  prefs: []
  type: TYPE_NORMAL
- en: the decision, other nodes then have no idea what decision is made by the coordinator.
  prefs: []
  type: TYPE_NORMAL
- en: At this stage, participants cannot commit or abort, and the protocol is blocked
    until the coordinator comes back online and participants receive the decision.
    The coordinator is
  prefs: []
  type: TYPE_NORMAL
- en: a single point of failure in this protocol. There are ways to overcome this
    problem using a consensus mechanism or total order broadcast protocol. The commit
    protocol can use
  prefs: []
  type: TYPE_NORMAL
- en: consensus to elect a new coordinator.
  prefs: []
  type: TYPE_NORMAL
- en: Also, note that if we remove the second phase and hence no rolling back, it
    becomes
  prefs: []
  type: TYPE_NORMAL
- en: a one-phase commit, that is, the primary/backup replication. Sounds familiar?
    We
  prefs: []
  type: TYPE_NORMAL
- en: discussed this in Chapter [3\.](https://doi.org/10.1007/978-1-4842-8179-6_3)
  prefs: []
  type: TYPE_NORMAL
- en: '265'
  prefs: []
  type: TYPE_NORMAL
- en: CHapTer 6 early proToCols
  prefs: []
  type: TYPE_NORMAL
- en: '**Three-Phase Commit**'
  prefs: []
  type: TYPE_NORMAL
- en: As we saw in the two-phase commit, it is not fault tolerant and blocks until
    the failed
  prefs: []
  type: TYPE_NORMAL
- en: coordinator recovers. If the coordinator or a participant fails in the commit
    phase, the
  prefs: []
  type: TYPE_NORMAL
- en: protocol cannot recover reliably. Even when the coordinator is replaced or recovers,
    it
  prefs: []
  type: TYPE_NORMAL
- en: cannot proceed to process the transaction reliably from where the failure occurred.
    The
  prefs: []
  type: TYPE_NORMAL
- en: three-phase commit solves this problem by introducing a new pre-commit intermediate
  prefs: []
  type: TYPE_NORMAL
- en: phase. After receiving a yes from all the participants, the coordinator moves
    to this
  prefs: []
  type: TYPE_NORMAL
- en: intermediate phase. Unlike 2PC, here, the coordinator does not immediately broadcast
  prefs: []
  type: TYPE_NORMAL
- en: commit; instead, it sends a pre-commit first, which indicates the intention
    to commit
  prefs: []
  type: TYPE_NORMAL
- en: the transaction. When participants receive the pre-commit message, they reply
    with the
  prefs: []
  type: TYPE_NORMAL
- en: ack messages. When the coordinator receives this ack from all participants,
    it sends the
  prefs: []
  type: TYPE_NORMAL
- en: commit message and proceeds as in the two-phase commit. If a participant fails
    before
  prefs: []
  type: TYPE_NORMAL
- en: sending back a message, the coordinator can still decide to commit the transaction.
    If the coordinator crashes, the participants can still agree to abort or commit
    the transaction.
  prefs: []
  type: TYPE_NORMAL
- en: This is so because no actual commit or abort has taken place yet. The participants
    now
  prefs: []
  type: TYPE_NORMAL
- en: have another chance to decide by checking that if they have seen a pre-commit
    from the
  prefs: []
  type: TYPE_NORMAL
- en: coordinator, they commit the transaction accordingly. Otherwise, the participants
    abort
  prefs: []
  type: TYPE_NORMAL
- en: the transaction, as no commit message has been seen from the coordinator.
  prefs: []
  type: TYPE_NORMAL
- en: This process can be visualized in Figur[e 6-2\.](#p283)
  prefs: []
  type: TYPE_NORMAL
- en: '266'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-283_1.png)'
  prefs: []
  type: TYPE_IMG
- en: CHapTer 6 early proToCols
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 6-2\.** Three-phase commit protocol*'
  prefs: []
  type: TYPE_NORMAL
- en: Roughly speaking, commit protocols can be seen as agreement protocols because
  prefs: []
  type: TYPE_NORMAL
- en: participants need to decide whether to accept the value proposed by the coordinator
  prefs: []
  type: TYPE_NORMAL
- en: or not. Of course, it is a simple protocol and not fault tolerant, but it does
    achieve an agreement among parties; hence, it can be seen as a consensus mechanism.
    Moreover,
  prefs: []
  type: TYPE_NORMAL
- en: we can say that validity is achieved because a participant proposes a final
    agreed-upon
  prefs: []
  type: TYPE_NORMAL
- en: value. Also, termination is guaranteed because every participant makes progress.
    If there are no failures, eventually all participants respond to the coordinator,
    and the protocol moves forward and, finally, both phases end. Strictly speaking,
    however, distributed
  prefs: []
  type: TYPE_NORMAL
- en: commit protocols are not consensus protocols.
  prefs: []
  type: TYPE_NORMAL
- en: Now, after this introduction to the most straightforward consensus protocols
    or
  prefs: []
  type: TYPE_NORMAL
- en: distributed commit protocols (depending on how you look at them), let us focus
    on
  prefs: []
  type: TYPE_NORMAL
- en: some early fault-tolerant consensus protocols that provide the foundation of
    what we see
  prefs: []
  type: TYPE_NORMAL
- en: today as consensus protocols in various distributed systems and blockchains.
  prefs: []
  type: TYPE_NORMAL
- en: '267'
  prefs: []
  type: TYPE_NORMAL
- en: CHapTer 6 early proToCols
  prefs: []
  type: TYPE_NORMAL
- en: '**Oral Message Algorithm**'
  prefs: []
  type: TYPE_NORMAL
- en: The oral message (OM) algorithm was proposed to solve the Byzantine generals
  prefs: []
  type: TYPE_NORMAL
- en: problem in the “Byzantine Generals Problem” paper in 1982 by Lamport et.al.
    This
  prefs: []
  type: TYPE_NORMAL
- en: recursive algorithm runs under the synchronous network model. It assumes a collection
  prefs: []
  type: TYPE_NORMAL
- en: of N generals where all generals are connected as a complete graph. One general
    is
  prefs: []
  type: TYPE_NORMAL
- en: the “commander” responsible for starting the protocol. Other generals (N – 1)
    called
  prefs: []
  type: TYPE_NORMAL
- en: “lieutenants” orally pass around the message they receive. The commander knows
    that
  prefs: []
  type: TYPE_NORMAL
- en: at most f generals will be faulty (traitors) and starts the consensus algorithm
    with a
  prefs: []
  type: TYPE_NORMAL
- en: known value of f. There is also a default value, either “retreat” or “attack.”
    The intuition behind this algorithm is that you tell others what message you received
    on receiving
  prefs: []
  type: TYPE_NORMAL
- en: every message. The participants accept the majority decision, which ensures
    the safety
  prefs: []
  type: TYPE_NORMAL
- en: property of the algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: There are two *interactive consistency* requirements that need to be met called
    IC1
  prefs: []
  type: TYPE_NORMAL
- en: 'and IC2:'
  prefs: []
  type: TYPE_NORMAL
- en: '1\. **IC1**: All loyal lieutenants obey the same order.'
  prefs: []
  type: TYPE_NORMAL
- en: '2\. **IC2**: If the commanding general is loyal, then every loyal'
  prefs: []
  type: TYPE_NORMAL
- en: lieutenant obeys its order.
  prefs: []
  type: TYPE_NORMAL
- en: Some assumptions about the system model are
  prefs: []
  type: TYPE_NORMAL
- en: 1\. The absence of message can be detected. This is due to
  prefs: []
  type: TYPE_NORMAL
- en: synchronous communication.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Every sent message is delivered correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. The receiver of the message knows who sent it.
  prefs: []
  type: TYPE_NORMAL
- en: An oral message is a message whose contents are under complete control of the
  prefs: []
  type: TYPE_NORMAL
- en: sender. The sender can send any possible message.
  prefs: []
  type: TYPE_NORMAL
- en: There is no solution to the Byzantine generals problem unless more than two-thirds
  prefs: []
  type: TYPE_NORMAL
- en: of generals are loyal. For example, if there are three generals and one is a
    traitor, then there is no solution to BGP if oral messages are used. Formally
  prefs: []
  type: TYPE_NORMAL
- en: '• **Lemma 1**: There is no solution to the Byzantine generals problem for'
  prefs: []
  type: TYPE_NORMAL
- en: 3m + 1 generals with > m traitors.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, if n <= 3m, then a Byzantine agreement is not possible. The
    algorithm
  prefs: []
  type: TYPE_NORMAL
- en: is recursive.
  prefs: []
  type: TYPE_NORMAL
- en: '268'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-285_1.png)'
  prefs: []
  type: TYPE_IMG
- en: CHapTer 6 early proToCols
  prefs: []
  type: TYPE_NORMAL
- en: '**Algorithm**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Base case: OM(0)**'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. The commander broadcasts a proposed value to every lieutenant.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Every lieutenant accepts the received value. If no value is received,
  prefs: []
  type: TYPE_NORMAL
- en: then it uses the DEFAULT value, either set to retreat or attack, at
  prefs: []
  type: TYPE_NORMAL
- en: the start of the algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: '**With traitor(s): OM(m), where m > 0**'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. The commander sends the proposed value to every lieutenant.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Every lieutenant runs OM(m-1) and acts as the commander to
  prefs: []
  type: TYPE_NORMAL
- en: send the value received in step 1 to all the other lieutenants.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Each lieutenant maintains a vector from which it uses the majority
  prefs: []
  type: TYPE_NORMAL
- en: value out of the values received.
  prefs: []
  type: TYPE_NORMAL
- en: The base case and OM(1) case are depicted in Figure [6-3](#p285).
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 6-3\.** OM base case vs. OM(1) case, where the commander is the traitor*'
  prefs: []
  type: TYPE_NORMAL
- en: We can also visualize the case where a lieutenant is the traitor as shown in
    Figur[e 6-4\.](#p286)
  prefs: []
  type: TYPE_NORMAL
- en: '269'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-286_1.png)'
  prefs: []
  type: TYPE_IMG
- en: CHapTer 6 early proToCols
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 6-4\.** OM case with M=1 where a lieutenant is a traitor*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can formally describe the algorithm as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Base case**'
  prefs: []
  type: TYPE_NORMAL
- en: OM(0)- base case
  prefs: []
  type: TYPE_NORMAL
- en: DEFAULT := Default value
  prefs: []
  type: TYPE_NORMAL
- en: Commander C broadcasts its proposed value to all Lieutenants
  prefs: []
  type: TYPE_NORMAL
- en: 'For i = 1 : N – 1 do'
  prefs: []
  type: TYPE_NORMAL
- en: Li stores the value from C in an array as Vi
  prefs: []
  type: TYPE_NORMAL
- en: Vi = DEFAULT if no value received
  prefs: []
  type: TYPE_NORMAL
- en: Li accepts Vi
  prefs: []
  type: TYPE_NORMAL
- en: End for
  prefs: []
  type: TYPE_NORMAL
- en: '**Case with f > 0, OM(m)**'
  prefs: []
  type: TYPE_NORMAL
- en: Commander C broadcast its value to all lieutenants
  prefs: []
  type: TYPE_NORMAL
- en: 'For I = 1 : n-1 do'
  prefs: []
  type: TYPE_NORMAL
- en: Li stores the value from commander as vi
  prefs: []
  type: TYPE_NORMAL
- en: Vi = default if no value received from the commander
  prefs: []
  type: TYPE_NORMAL
- en: Li runs OM(m-1) now as commander to send the value vi to other N – 2
  prefs: []
  type: TYPE_NORMAL
- en: Lieutenants
  prefs: []
  type: TYPE_NORMAL
- en: End for
  prefs: []
  type: TYPE_NORMAL
- en: '270'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-287_1.png)'
  prefs: []
  type: TYPE_IMG
- en: CHapTer 6 early proToCols
  prefs: []
  type: TYPE_NORMAL
- en: 'For I = 1 : N – 1 do'
  prefs: []
  type: TYPE_NORMAL
- en: 'For j = 1 : N – 1 AND j ≠ i do'
  prefs: []
  type: TYPE_NORMAL
- en: Li stores the value received from Lj as vj
  prefs: []
  type: TYPE_NORMAL
- en: Vj = default if no value received
  prefs: []
  type: TYPE_NORMAL
- en: End for
  prefs: []
  type: TYPE_NORMAL
- en: Li chooses majority from {v1, v2, v3, , , , vn-1}
  prefs: []
  type: TYPE_NORMAL
- en: End for
  prefs: []
  type: TYPE_NORMAL
- en: As you may have noticed, this algorithm, while it works, is not very efficient
    due
  prefs: []
  type: TYPE_NORMAL
- en: to the number of messages required to be passed around. More precisely, from
    a
  prefs: []
  type: TYPE_NORMAL
- en: communication complexity perspective, this algorithm is exponential in the number
  prefs: []
  type: TYPE_NORMAL
- en: of traitors. If there are no traitors, as in the base case, then its constant,
    *O*(1), otherwise its *O*( *mn*), which means that it grows exponentially with
    the number of traitors, which makes it impractical for a large number of *n*.
  prefs: []
  type: TYPE_NORMAL
- en: Using the space-time diagram, we can visualize the base case as shown in Figure
    [6-5](#p287).
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 6-5\.** Oral message protocol – base case – with no traitors*'
  prefs: []
  type: TYPE_NORMAL
- en: We can also visualize the m > 0 case where the commander is the traitor sending
  prefs: []
  type: TYPE_NORMAL
- en: conflicting messages to lieutenants in Figur[e 6-6\.](#p288)
  prefs: []
  type: TYPE_NORMAL
- en: '271'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-288_1.png)'
  prefs: []
  type: TYPE_IMG
- en: CHapTer 6 early proToCols
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 6-6\.** Oral message protocol case where m =1, the commander is a
    traitor*'
  prefs: []
  type: TYPE_NORMAL
- en: In the digital world, commanders and lieutenants represent processes, and the
  prefs: []
  type: TYPE_NORMAL
- en: communication between these processes is achieved by point-to-point links and
  prefs: []
  type: TYPE_NORMAL
- en: physical channels.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have discussed the case with oral messages using no cryptography;
  prefs: []
  type: TYPE_NORMAL
- en: however, another solution with signed messages is also possible where digital
    signatures
  prefs: []
  type: TYPE_NORMAL
- en: are used to guarantee the integrity of the statements. In other words, the use
    of oral
  prefs: []
  type: TYPE_NORMAL
- en: messages does not allow the receiver to ascertain whether the message has been
    altered
  prefs: []
  type: TYPE_NORMAL
- en: or not. However, digital signatures provide a data authentication service that
    enables
  prefs: []
  type: TYPE_NORMAL
- en: receiving processes to check whether the message is genuine (valid) or not.
  prefs: []
  type: TYPE_NORMAL
- en: Based on whether oral messages are used, or digital signatures have been used,
  prefs: []
  type: TYPE_NORMAL
- en: Table [6-1](#p277), earlier in this chapter, summarizes the impossibility results
    under various system models.
  prefs: []
  type: TYPE_NORMAL
- en: '**Signed Message Solution to Byzantine Generals Problem**'
  prefs: []
  type: TYPE_NORMAL
- en: The main issue with the oral message algorithm is that it needs 3 *t* + 1 (also
    denoted as 3 *f* + 1) nodes to tolerate *t* (also denoted as *f*) failures, which
    is expensive in terms of computational resources required. It is also difficult
    because traitors can lie about what other nodes said. The time complexity of this
    algorithm is *O*( *nm*).
  prefs: []
  type: TYPE_NORMAL
- en: '272'
  prefs: []
  type: TYPE_NORMAL
- en: CHapTer 6 early proToCols
  prefs: []
  type: TYPE_NORMAL
- en: There is a signed solution to BGP which was proposed in the same BGP paper by
  prefs: []
  type: TYPE_NORMAL
- en: 'Lamport, Shostak, and Pease. It uses digital signatures to sign the messages.
    Here are the additional assumptions under this model:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. The signature of a loyal general cannot be forged, and any
  prefs: []
  type: TYPE_NORMAL
- en: modification of the general’s messages is detectable.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Anyone can verify the authenticity of the general’s signature.
  prefs: []
  type: TYPE_NORMAL
- en: Under this model, each lieutenant maintains a vector of signed orders received.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the commander sends the signed messages to the lieutenants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generally, the algorithm works like this:'
  prefs: []
  type: TYPE_NORMAL
- en: A lieutenant receives an order from either a commander or other lieutenants
    and
  prefs: []
  type: TYPE_NORMAL
- en: saves it in the vector that he maintains after verifying the message's authenticity.
    If there are less than m signatures on the order, the lieutenant adds a signature
    to the order
  prefs: []
  type: TYPE_NORMAL
- en: (message) and relays this message to other lieutenants who have not seen it
    yet. When a
  prefs: []
  type: TYPE_NORMAL
- en: lieutenant does not receive any newer messages, he chooses the value from the
    vector as
  prefs: []
  type: TYPE_NORMAL
- en: a decision consensus value.
  prefs: []
  type: TYPE_NORMAL
- en: The lieutenants can detect that the commander is a traitor by using signed
  prefs: []
  type: TYPE_NORMAL
- en: messages because the commander's signature appears on two different messages.
    Our
  prefs: []
  type: TYPE_NORMAL
- en: assumptions under this model are that signatures are unforgeable, and anyone
    can verify
  prefs: []
  type: TYPE_NORMAL
- en: the signature's authenticity. This implies that the commander is a traitor because
    only he could have signed two different messages.
  prefs: []
  type: TYPE_NORMAL
- en: Formally, the algorithm is described as follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Algorithm: For n generals and m traitor generals where *n* > 0\. In this algorithm,
    each lieutenant *i* keeps a set *Vi* of properly signed messages it has received
    so far. When the commander is honest, then the set *Vi* contains only a single
    element.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Algorithm SM(m)**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Initialization:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Vi* = { }, that is, empty'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Commander
  prefs: []
  type: TYPE_NORMAL
- en: '*C* sends the signed message (value) to every'
  prefs: []
  type: TYPE_NORMAL
- en: lieutenant.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. For each *i*
  prefs: []
  type: TYPE_NORMAL
- en: 'a. If lieutenant *i* receives a message of the form *v* : 0 from the'
  prefs: []
  type: TYPE_NORMAL
- en: commander and has not yet received any message (order) from
  prefs: []
  type: TYPE_NORMAL
- en: the commander, that is, *Vi* is empty, then
  prefs: []
  type: TYPE_NORMAL
- en: '273'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-290_1.png)'
  prefs: []
  type: TYPE_IMG
- en: CHapTer 6 early proToCols
  prefs: []
  type: TYPE_NORMAL
- en: i. Set *Vi* = { *v*}.
  prefs: []
  type: TYPE_NORMAL
- en: 'ii. It sends the message *v* : 0 : *i* to every other lieutenant.'
  prefs: []
  type: TYPE_NORMAL
- en: 'b. If lieutenant *i* receives a message like *v* : 0 : *j* 1\. … *jk* and *v*
    is not in the set, *Vi*, then'
  prefs: []
  type: TYPE_NORMAL
- en: i. *Vi* = *Vi* + { *v*}, that is, add *v* to *Vi*.
  prefs: []
  type: TYPE_NORMAL
- en: 'ii. If *k* < *m*, then send message *v* : 0 : *j* 1… *jk* : *i* to every lieutenant
    other than *j* 1… *jk*.'
  prefs: []
  type: TYPE_NORMAL
- en: 3\. For each *i*
  prefs: []
  type: TYPE_NORMAL
- en: a. When no more messages received by lieutenant *i*, then it obeys
  prefs: []
  type: TYPE_NORMAL
- en: the order (message) via the function *choice* ( *Vi*), which obtains
  prefs: []
  type: TYPE_NORMAL
- en: a single order from a set of orders. *Choice*( *V*) = *retreat* if set *V* is
    empty or it consists of more than one element. If there is only a
  prefs: []
  type: TYPE_NORMAL
- en: single element *v* in set *V*, then *choice*( *V*) = *v*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, *v* : *i* is the value *v* signed by general *i*, and *v* : *i* : *j*
    is the message *v* : *i* counter signed by general *j*. Each general *i* maintains
    a set *Vi* which contains all orders received.'
  prefs: []
  type: TYPE_NORMAL
- en: The diagram in Figur[e 6-7 vis](#p290)ualizes a traitor commander scenario.
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 6-7\.** Example of a signed message protocol with SM(1) – traitor*'
  prefs: []
  type: TYPE_NORMAL
- en: '*commander*'
  prefs: []
  type: TYPE_NORMAL
- en: '274'
  prefs: []
  type: TYPE_NORMAL
- en: CHapTer 6 early proToCols
  prefs: []
  type: TYPE_NORMAL
- en: With signed messages, it’s easy to detect if a commander is a traitor because
    its
  prefs: []
  type: TYPE_NORMAL
- en: signature would appear on two different orders, and by the assumption of unforgeable
  prefs: []
  type: TYPE_NORMAL
- en: signature, we know that only the commander could have signed the message.
  prefs: []
  type: TYPE_NORMAL
- en: Formally, for any *m*, the algorithm *SM*( *m*) solves the Byzantine generals
    problem if there are at most *m* traitors. The lieutenants maintain a vector of
    values and run a choice function to retrieve the order *choice* { *attack*, *retreat*}.
    Timeouts are used to ascertain if no more messages will arrive. Also, in step
    2, lieutenant *i* ignores any message *v* that is already in the set *Vi*.
  prefs: []
  type: TYPE_NORMAL
- en: This algorithm has message complexity *O*( *nm* + 1), and it requires *m* +
    1 number of rounds. This protocol works for *N* ≥ *m* + 2\.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast with the oral message protocol, the signed message protocol is more
  prefs: []
  type: TYPE_NORMAL
- en: resilient against faults; here, if at least two generals are loyal in three
    generals, the problem is solvable. In the oral message, even if there is a single
    traitor in three generals, the problem is unsolvable.
  prefs: []
  type: TYPE_NORMAL
- en: '**DLS Protocols Under Partial Synchrony**'
  prefs: []
  type: TYPE_NORMAL
- en: After the FLP impossibility result, one of the ways that researchers introduced
    to
  prefs: []
  type: TYPE_NORMAL
- en: circumvent the FLP impossibility is to use the partial synchrony network model.
    There
  prefs: []
  type: TYPE_NORMAL
- en: are some important concepts presented in this paper, such as rotating coordinators,
  prefs: []
  type: TYPE_NORMAL
- en: consensus, termination under partial synchrony, and implementation of the round-based
  prefs: []
  type: TYPE_NORMAL
- en: mechanism. We discussed various models, including partial synchrony, in Chapter
    [3\.](https://doi.org/10.1007/978-1-4842-8179-6_3)
  prefs: []
  type: TYPE_NORMAL
- en: The paper describes four algorithms for crash-stop, omissions, Byzantine,
  prefs: []
  type: TYPE_NORMAL
- en: and authenticated Byzantine faults under partial synchrony. The key idea in
    these
  prefs: []
  type: TYPE_NORMAL
- en: algorithms is that the agreement and validity are always satisfied, whereas
    termination is guaranteed when the system stabilizes, that is, has good episodes
    of synchrony.
  prefs: []
  type: TYPE_NORMAL
- en: A basic round model is introduced where protocol execution is divided into rounds
  prefs: []
  type: TYPE_NORMAL
- en: of message exchange and local computations. Each round comprises a send step,
    a
  prefs: []
  type: TYPE_NORMAL
- en: receive step, and a computation step. In addition, the basic round model assumes
    a
  prefs: []
  type: TYPE_NORMAL
- en: round, called the global stabilization round, during which or after correct
    processes
  prefs: []
  type: TYPE_NORMAL
- en: receive all messages sent from correct processes.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, algorithm 2 is presented, a consensus algorithm for Byzantine
  prefs: []
  type: TYPE_NORMAL
- en: faults with authentication. It assumes a network model with partially synchronous
  prefs: []
  type: TYPE_NORMAL
- en: communications and processors that can be Byzantine. This model is also adopted
    for
  prefs: []
  type: TYPE_NORMAL
- en: most, if not all, blockchain networks.
  prefs: []
  type: TYPE_NORMAL
- en: '275'
  prefs: []
  type: TYPE_NORMAL
- en: CHapTer 6 early proToCols
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm achieves strong unanimity for a set V with an arbitrary value
    under
  prefs: []
  type: TYPE_NORMAL
- en: Byzantine faults with authentication.
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm progresses in phases. Each phase *k* consists of four consecutive
  prefs: []
  type: TYPE_NORMAL
- en: rounds, from 4 *k* – 3 to 4 *k*. Each phase has a unique coordinator c which
    leads the phase.
  prefs: []
  type: TYPE_NORMAL
- en: A simple formula *k* = *i* ( *mod n*) is used to select the coordinator from
    all processes, where *k* is the phase, *i* is the process number, and *n* is the
    total number of processes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each process maintains some variables:'
  prefs: []
  type: TYPE_NORMAL
- en: • A local variable PROPER, which contains a set of values that the
  prefs: []
  type: TYPE_NORMAL
- en: process knows to be proper.
  prefs: []
  type: TYPE_NORMAL
- en: • A local variable ACCEPTABLE, which contains value v that process
  prefs: []
  type: TYPE_NORMAL
- en: p has found to be acceptable. Note that a value v is acceptable to
  prefs: []
  type: TYPE_NORMAL
- en: process p if p does not have a lock on any value except possibly v.
  prefs: []
  type: TYPE_NORMAL
- en: Also, value v is proper.
  prefs: []
  type: TYPE_NORMAL
- en: • A local variable LOCK which keeps the locked value. A process may
  prefs: []
  type: TYPE_NORMAL
- en: lock a value in a phase if it believes that some process may decide on
  prefs: []
  type: TYPE_NORMAL
- en: this value. Initially, no value is locked. A phase number is associated
  prefs: []
  type: TYPE_NORMAL
- en: with every lock. In addition, a proof of acceptability of the locked
  prefs: []
  type: TYPE_NORMAL
- en: value is also associated with every lock. Proof of acceptability is in the
  prefs: []
  type: TYPE_NORMAL
- en: form of a set of signed messages sent by *n* − *t* processes, indicating
  prefs: []
  type: TYPE_NORMAL
- en: that the locked value is acceptable and proper, that is, it is in their
  prefs: []
  type: TYPE_NORMAL
- en: PROPER sets at the start of the given phase.
  prefs: []
  type: TYPE_NORMAL
- en: '**Algorithm** *N* ≥ 3 *t* + 1 – **Byzantine faults with authentication**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Trying phase k**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Rounds:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Round 1: Round 4k – 3**'
  prefs: []
  type: TYPE_NORMAL
- en: Each process including the current coordinator sends an authenticated list of
    all its
  prefs: []
  type: TYPE_NORMAL
- en: acceptable values to the current coordinator. Processes use the message format
    *E*( *list*, *k*), where *E* is an authentication function, *k* is the phase,
    and *list* is all acceptable values.
  prefs: []
  type: TYPE_NORMAL
- en: '**Round 2: Round 4k – 2**'
  prefs: []
  type: TYPE_NORMAL
- en: The current coordinator chooses a value to propose. If a value is to be proposed
  prefs: []
  type: TYPE_NORMAL
- en: by the coordinator, the coordinator must have received at least *n* – *t* responses
    from the processes suggesting that this value is acceptable and proper at phase
    *k*. If there is more than one possible value that the coordinator may propose,
    then it will choose one
  prefs: []
  type: TYPE_NORMAL
- en: arbitrarily.
  prefs: []
  type: TYPE_NORMAL
- en: '276'
  prefs: []
  type: TYPE_NORMAL
- en: CHapTer 6 early proToCols
  prefs: []
  type: TYPE_NORMAL
- en: The coordinator broadcasts a message of the form *E*( *lock*, *v*, *k*, *proof*),
    where the *proof* is composed of the set of signed messages *E*( *list*, *k*)
    received from the *n* − *t* processes that found *v* acceptable and proper.
  prefs: []
  type: TYPE_NORMAL
- en: '**Round 3: Round 4k – 1**'
  prefs: []
  type: TYPE_NORMAL
- en: If any process receives an *E*( *lock*, *v*, *k*, *proof*) message, it validates
    the proof to ascertain that *n* − *t* processors do find *v* acceptable and proper
    at phase *k*. If the proof is valid, it locks *v*, associating the phase number
    *k* and the message *E*( *lock*, *v*, *k*, *proof*) with the lock, and sends an
    acknowledgment to the current coordinator. In this
  prefs: []
  type: TYPE_NORMAL
- en: case, the processes release any earlier lock placed on *v*. If the coordinator
    receives acknowledgments from at least 2 *t* + 1 processors, then it decides on
    the value *v*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Round 4: Round 4k**'
  prefs: []
  type: TYPE_NORMAL
- en: This is where locks are released. Processes broadcast messages of the form
  prefs: []
  type: TYPE_NORMAL
- en: '*E*( *lock v*, *h*, *proof*), indicating that they have a lock on value *v*
    with associated phase *h* and the associated proof and that a coordinator sent
    the message at phase *h*, which caused the lock to be placed. If any process has
    a lock on some value *v* with associated phase *h* and receives a properly signed
    message *E*( *lock*, *w*, *h*’, *proof*′) with *w* ≠ *v* and *h*′ ≥ *h*, then
    the process releases its lock on *v*. This means that if a most recent properly
    signed message is received by a process indicating a lock on some value which
    is different from'
  prefs: []
  type: TYPE_NORMAL
- en: its locally locked value and the phase number is either higher or equal to the
    current
  prefs: []
  type: TYPE_NORMAL
- en: phase number, then it will release the lock from the local locked value.
  prefs: []
  type: TYPE_NORMAL
- en: '**Notes**'
  prefs: []
  type: TYPE_NORMAL
- en: Assuming that the processes are correct, two different values cannot be locked
    in the
  prefs: []
  type: TYPE_NORMAL
- en: same phase because the correct coordinator will never send conflicting messages
    which
  prefs: []
  type: TYPE_NORMAL
- en: may suggest locks on two different values.
  prefs: []
  type: TYPE_NORMAL
- en: This algorithm achieves consistency, strong unanimity, and termination under
  prefs: []
  type: TYPE_NORMAL
- en: partial synchrony, with Byzantine faults and authentication, where *n* ≥ 3 *t*
    + 1\.
  prefs: []
  type: TYPE_NORMAL
- en: Authenticated Byzantine means that failures are arbitrary, but messages can
    be signed
  prefs: []
  type: TYPE_NORMAL
- en: with unforgeable digital signatures.
  prefs: []
  type: TYPE_NORMAL
- en: Consistency means no two different processes decide differently. Termination
    means
  prefs: []
  type: TYPE_NORMAL
- en: every process eventually decides. Unanimity has two flavors, strong unanimity
    and weak
  prefs: []
  type: TYPE_NORMAL
- en: unanimity. Strong unanimity requires that if all processes have the same initial
    value
  prefs: []
  type: TYPE_NORMAL
- en: v and if any correct process decides, then it only decides on v. Weak unanimity
    means
  prefs: []
  type: TYPE_NORMAL
- en: that if all processes have the same initial value v and all processes are correct,
    then if any process decides, it decides on v. In other words, strong unanimity
    means that if all initial values are the same, for example, v, then v is the only
    common decision. Under weak
  prefs: []
  type: TYPE_NORMAL
- en: unanimity, this condition is expected to hold only if all processes are correct.
  prefs: []
  type: TYPE_NORMAL
- en: '277'
  prefs: []
  type: TYPE_NORMAL
- en: CHapTer 6 early proToCols
  prefs: []
  type: TYPE_NORMAL
- en: '**Ben-Or Algorithms**'
  prefs: []
  type: TYPE_NORMAL
- en: The Ben-Or protocol was introduced in 1983\. It is named after its author Michael
    Ben-
  prefs: []
  type: TYPE_NORMAL
- en: Or. This was the first protocol that solved the consensus problem with probabilistic
  prefs: []
  type: TYPE_NORMAL
- en: termination under a model with a strong adversary. The Ben-Or algorithm proposed
  prefs: []
  type: TYPE_NORMAL
- en: how to circumvent an FLP result and achieve consensus under asynchrony. There
    are
  prefs: []
  type: TYPE_NORMAL
- en: two algorithms proposed in the paper. The first algorithm tolerates *t* < *n*/2
    crash failures, and the second algorithm tolerates *t* < *n*/5 for Byzantine failures.
    In other words, with *N* > 2 *t* it tolerates crash faults and achieves an agreement,
    and with *N* > 5 *t* the protocol tolerates Byzantine faults and reaches an agreement.
    The protocol achieves consensus
  prefs: []
  type: TYPE_NORMAL
- en: under the conditions described earlier, but the expected running time of the
    protocol
  prefs: []
  type: TYPE_NORMAL
- en: is exponential. In other words, it requires exponential running time to terminate
    in the
  prefs: []
  type: TYPE_NORMAL
- en: worst case because it can require multiple rounds to terminate. It can however
    terminate
  prefs: []
  type: TYPE_NORMAL
- en: in constant time if the value of *t* is very small, that is, *O*(√ *n*).
  prefs: []
  type: TYPE_NORMAL
- en: This protocol works in asynchronous rounds. A round simulates time because all
  prefs: []
  type: TYPE_NORMAL
- en: messages are tagged with a round number, and because of this, processes can
    figure out
  prefs: []
  type: TYPE_NORMAL
- en: which messages belong to which round even if they arrive asynchronously. A process
  prefs: []
  type: TYPE_NORMAL
- en: ignores any messages for previous rounds and holds messages for future rounds
    in a
  prefs: []
  type: TYPE_NORMAL
- en: buffer. Each round has two phases or subrounds. The first is the proposal (suggestion)
  prefs: []
  type: TYPE_NORMAL
- en: phase, where each process p transmits its value v and waits until it receives
    from other
  prefs: []
  type: TYPE_NORMAL
- en: '*n* − *t* processes. In the second phase, called the decision (ratification)
    phase, the protocol checks if a majority is observed and takes that value; otherwise,
    it flips a coin. If a certain threshold of processes sees the same majority value,
    then the decision is finalized. In'
  prefs: []
  type: TYPE_NORMAL
- en: case some other value is detected as a majority, then the processor switches
    to that
  prefs: []
  type: TYPE_NORMAL
- en: value. Eventually, the protocol manages to terminate because at some point all
    processes
  prefs: []
  type: TYPE_NORMAL
- en: will flip the coin correctly and reach the majority value. You may have noticed
    that this protocol only considers binary decision values, either a 0 or 1\. Another
    important aspect to keep in mind is that the protocol cannot wait indefinitely
    for all processes to respond because they could be unavailable (offline).
  prefs: []
  type: TYPE_NORMAL
- en: This algorithm works only for binary consensus. There are two variables that
    need
  prefs: []
  type: TYPE_NORMAL
- en: to be managed in the algorithm, a value which is either 0 or 1 and phase (p),
    which
  prefs: []
  type: TYPE_NORMAL
- en: represents the stage where the algorithm is currently at. The algorithm proceeds
    in
  prefs: []
  type: TYPE_NORMAL
- en: rounds, and each round has two subrounds or phases.
  prefs: []
  type: TYPE_NORMAL
- en: '278'
  prefs: []
  type: TYPE_NORMAL
- en: CHapTer 6 early proToCols
  prefs: []
  type: TYPE_NORMAL
- en: Note that each process has its own coin. This class of algorithms that utilize
    such
  prefs: []
  type: TYPE_NORMAL
- en: coin scheme is called local coin algorithms. Local coin tossing is implemented
    using a
  prefs: []
  type: TYPE_NORMAL
- en: random number generator that outputs binary numbers. Each process tosses its
    own
  prefs: []
  type: TYPE_NORMAL
- en: coin and outputs 0 or 1, each with probability ½. The coin is tossed by a process
    to pick a new local value if a majority was not found.
  prefs: []
  type: TYPE_NORMAL
- en: '**The algorithm for benign faults/crash faults only – non-Byzantine:**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each process p executes the following algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Process p: Initial value x = 0 or 1'
  prefs: []
  type: TYPE_NORMAL
- en: '**0:** set r = 1'
  prefs: []
  type: TYPE_NORMAL
- en: '**--First subround or phase – proposal phase**'
  prefs: []
  type: TYPE_NORMAL
- en: '**1:** Broadcast (1, r, x) to all processes including itself'
  prefs: []
  type: TYPE_NORMAL
- en: '**2:** Wait until messages of type (1,r,*) are received from n - t processes.'
  prefs: []
  type: TYPE_NORMAL
- en: '**2(a):** If > n /2 messages received have the same value v, then'
  prefs: []
  type: TYPE_NORMAL
- en: '**--second subround or phase – decision phase**'
  prefs: []
  type: TYPE_NORMAL
- en: '**2(b):** Broadcast the message (2, r, v, D) to all processes'
  prefs: []
  type: TYPE_NORMAL
- en: including itself.
  prefs: []
  type: TYPE_NORMAL
- en: '**2(c):** else broadcast the message (2, r, ?) to all processes'
  prefs: []
  type: TYPE_NORMAL
- en: including itself.
  prefs: []
  type: TYPE_NORMAL
- en: '**3:** Wait until messages of type (2, r, *) arrive from n - t processes.'
  prefs: []
  type: TYPE_NORMAL
- en: '**3(a):** If there is 1 D type messages (2, r, v, D), then vote v i.e'
  prefs: []
  type: TYPE_NORMAL
- en: set x = v
  prefs: []
  type: TYPE_NORMAL
- en: '**3(b):** If there are > t, D type messages then decide v.'
  prefs: []
  type: TYPE_NORMAL
- en: '**3(c):** Else set x = 0 or 1 each with probability 1/2 by doing the'
  prefs: []
  type: TYPE_NORMAL
- en: coinflip
  prefs: []
  type: TYPE_NORMAL
- en: '**4:** Start the next round by setting r = r + 1 and go to 1\.'
  prefs: []
  type: TYPE_NORMAL
- en: Here, r is the round number; x is the initial preference or value proposed by
    the
  prefs: []
  type: TYPE_NORMAL
- en: process; 1 is the first subround, round, or phase of the main round; 2 is the
    second
  prefs: []
  type: TYPE_NORMAL
- en: subround, round, or phase of the main round; * can be 0 or 1; ? represents no
  prefs: []
  type: TYPE_NORMAL
- en: majority observed; N is the number of nodes (processes); D is an indication
    of approval
  prefs: []
  type: TYPE_NORMAL
- en: (ratification) – in other words, it is an indication that the process has observed
    a majority of the same value – t is the number of faulty nodes; v is the value;
    and coinflip() is a
  prefs: []
  type: TYPE_NORMAL
- en: uniform random number generator that generates either 0 or 1\.
  prefs: []
  type: TYPE_NORMAL
- en: We can visualize this protocol in the diagram shown in Figure [6-8](#p296).
  prefs: []
  type: TYPE_NORMAL
- en: '279'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-296_1.png)'
  prefs: []
  type: TYPE_IMG
- en: CHapTer 6 early proToCols
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 6-8\.** Ben-Or crash fault tolerant only agreement protocol – (non-Byzantine)*
    If *n* > 2 *t*, the protocol guarantees with probability 1 that all processes
    will eventually decide on the same value, and if all processes start with the
    value *v*, then within one round all processes will decide on *v*. Moreover, if
    in some round a process decides on *v* after receiving more than *t* D type messages,
    then all other processes will decide on *v* within the next round.'
  prefs: []
  type: TYPE_NORMAL
- en: The protocol described earlier works for crash faults; for tolerating Byzantine
    faults,
  prefs: []
  type: TYPE_NORMAL
- en: slight modifications are required, which we describe next.
  prefs: []
  type: TYPE_NORMAL
- en: '280'
  prefs: []
  type: TYPE_NORMAL
- en: CHapTer 6 early proToCols
  prefs: []
  type: TYPE_NORMAL
- en: '**The Ben-Or algorithm for Byzantine faults:**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each process p executes the following algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Process p: Initial value x = 0 or 1'
  prefs: []
  type: TYPE_NORMAL
- en: '**0:** set r = 1'
  prefs: []
  type: TYPE_NORMAL
- en: '**--First subround or phase – proposal phase**'
  prefs: []
  type: TYPE_NORMAL
- en: '**1:** Broadcast (1, r, x) to all processes including itself'
  prefs: []
  type: TYPE_NORMAL
- en: '**2:** Wait until messages of type (1,r,*) are received from N - t processes.'
  prefs: []
  type: TYPE_NORMAL
- en: '**2(a):** If more than (N + t)/2 messages have the same value v, then'
  prefs: []
  type: TYPE_NORMAL
- en: '**--second subround or phase – decision phase**'
  prefs: []
  type: TYPE_NORMAL
- en: '**2(b):** Broadcast the message (2, r, v, D) to all processes'
  prefs: []
  type: TYPE_NORMAL
- en: including itself.
  prefs: []
  type: TYPE_NORMAL
- en: '**2(c):** else Broadcast the message (2, r, ?) to all processes'
  prefs: []
  type: TYPE_NORMAL
- en: including itself.
  prefs: []
  type: TYPE_NORMAL
- en: '**3:** Wait until messages of type (2, r, *) arrive from n - t processes.'
  prefs: []
  type: TYPE_NORMAL
- en: '**3(a):** If there are at least t + 1 D type messages (2, r, v, D), then'
  prefs: []
  type: TYPE_NORMAL
- en: vote v i.e set x = v
  prefs: []
  type: TYPE_NORMAL
- en: '**3(b):** If there are more than (n + t)/2 D type messages then decide v.'
  prefs: []
  type: TYPE_NORMAL
- en: '**3(c):** Else set x to 0 or 1 each with probability 1/2 by doing the'
  prefs: []
  type: TYPE_NORMAL
- en: coinflip
  prefs: []
  type: TYPE_NORMAL
- en: '**4:** Start the next round by setting r = r + 1 and go to 1\.'
  prefs: []
  type: TYPE_NORMAL
- en: Here, r is the round number; x is the initial preference or value proposed by
    the
  prefs: []
  type: TYPE_NORMAL
- en: process; 1 is the first subround, round, or phase of the main round; 2 is the
    second
  prefs: []
  type: TYPE_NORMAL
- en: subround, round, or phase of the main round; * can be 0 or 1; ? represents no
  prefs: []
  type: TYPE_NORMAL
- en: majority observed; N is the number of nodes (processes); D is an indication
    of approval
  prefs: []
  type: TYPE_NORMAL
- en: (ratification) – in other words, it is an indication that the process has observed
    a majority of the same value – t is the number of faulty nodes; v is the value;
    and coinflip() is a
  prefs: []
  type: TYPE_NORMAL
- en: uniform random number generator that generates either 0 or 1\.
  prefs: []
  type: TYPE_NORMAL
- en: We can visualize this protocol in Figure [6-9](#p298).
  prefs: []
  type: TYPE_NORMAL
- en: '281'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-298_1.png)'
  prefs: []
  type: TYPE_IMG
- en: CHapTer 6 early proToCols
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 6-9\.** Ben-Or Byzantine agreement protocol*'
  prefs: []
  type: TYPE_NORMAL
- en: In the first subround or phase of the protocol, every process broadcasts its
    proposed
  prefs: []
  type: TYPE_NORMAL
- en: '*n* + *t*'
  prefs: []
  type: TYPE_NORMAL
- en: preferred value and awaits *n* − *t* messages. If more than
  prefs: []
  type: TYPE_NORMAL
- en: processes agree, then a
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: majority is achieved, and the preferred value is set accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: In the second subround or phase of the protocol, if a majority is observed in
    the first
  prefs: []
  type: TYPE_NORMAL
- en: subround, then an indication of majority is broadcast (2, *r*, *v*, *D*); otherwise,
    if no majority (?) was observed in the first subround, then no majority is broadcast.
    The protocol then
  prefs: []
  type: TYPE_NORMAL
- en: waits for *n* – *t* confirmations. If at least *t* + 1 confirmations of a majority
    of either 0 or 1
  prefs: []
  type: TYPE_NORMAL
- en: are observed, then the preferred value is set accordingly. Here, only the preferred
    value *n* + *t*
  prefs: []
  type: TYPE_NORMAL
- en: is set, but no decision is made. A decision is made by p if more than
  prefs: []
  type: TYPE_NORMAL
- en: confirmations
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: '*n* + *t*'
  prefs: []
  type: TYPE_NORMAL
- en: are received, only then the value is decided. If neither *t* + 1 confirmations
    nor
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: confirmations are received, then the coin is flipped to choose a uniform random
    value,
  prefs: []
  type: TYPE_NORMAL
- en: either 0 or 1\.
  prefs: []
  type: TYPE_NORMAL
- en: '282'
  prefs: []
  type: TYPE_NORMAL
- en: CHapTer 6 early proToCols
  prefs: []
  type: TYPE_NORMAL
- en: Note that, by waiting for *n* – *t* messages, the Byzantine fault case where
    Byzantine processes maliciously decide not to vote is handled. This is because
    in the presence of t faults, at least n is honest. In the second subround, *t*
    + 1 confirmations of a majority value *n* + *t*
  prefs: []
  type: TYPE_NORMAL
- en: mean that at least one honest process has observed a majority. In the case of
  prefs: []
  type: TYPE_NORMAL
- en: ', it'
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: means a value has been observed by a majority.
  prefs: []
  type: TYPE_NORMAL
- en: So, in summary, if *n* > 5 *t*, this protocol guarantees with probability 1
    that all processes will eventually decide on the same value, and if all processes
    start with the
  prefs: []
  type: TYPE_NORMAL
- en: value v, then within one round all processes will decide on *v*. Moreover, if
    in some round ( *n* + *t*)
  prefs: []
  type: TYPE_NORMAL
- en: an honest process decides on v after receiving more than
  prefs: []
  type: TYPE_NORMAL
- en: D type messages, then
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: all other processes will decide on v within the next round.
  prefs: []
  type: TYPE_NORMAL
- en: '*Note that I have used t to denote faulty processes, which is in line with
    the original* *paper on the subject. However, in literature f is also widely used
    to denote faults, either* *Byzantine or crash. So, t + 1 or f + 1 means the same
    thing, as t and f denote the same thing.*'
  prefs: []
  type: TYPE_NORMAL
- en: Now the question arises as to how this protocol achieves an agreement, validity,
    and
  prefs: []
  type: TYPE_NORMAL
- en: termination. Let’s try to answer these questions.
  prefs: []
  type: TYPE_NORMAL
- en: An agreement is possible because at most one value can be in a majority in the
    first
  prefs: []
  type: TYPE_NORMAL
- en: phase (subround) of the main round. If some process observes the *t* + 1 D type
    message (ratification message of the form (2, r, v, D)), then every process observes
    at least one ratification message of the form (2, r, v, D). Finally, if every
    process sees a ratification message of the form (2, r, v, D), then every process
    votes for value v (accepts value v)
  prefs: []
  type: TYPE_NORMAL
- en: in the first subround (phase) of r + 1 and decides on v in the second subround
    (phase)
  prefs: []
  type: TYPE_NORMAL
- en: unless it has decided already.
  prefs: []
  type: TYPE_NORMAL
- en: Validity is possible because if all processes vote for (accept) their common
    value v in
  prefs: []
  type: TYPE_NORMAL
- en: a round, then all processes broadcast (2, r, v, D) and decide in the second
    subround of
  prefs: []
  type: TYPE_NORMAL
- en: the round. Also, note that the preferred value of only one of the processes
    is broadcast in the first subround of the round.
  prefs: []
  type: TYPE_NORMAL
- en: The reason why Ben-Or terminates is because eventually the majority of the
  prefs: []
  type: TYPE_NORMAL
- en: nonfaulty processes will flip a coin to achieve the same random value. This
    majority
  prefs: []
  type: TYPE_NORMAL
- en: value is then observed by the honest processes, which then propagate the D type
  prefs: []
  type: TYPE_NORMAL
- en: message (ratification message) with the majority value. Eventually, honest processes
    will receive the D type message (ratification message), and the protocol will
    terminate.
  prefs: []
  type: TYPE_NORMAL
- en: Also, note that the reason why two subrounds are required is because in the
    first
  prefs: []
  type: TYPE_NORMAL
- en: phase the number of preferred value proposals is reduced to at most one, and
    then in the
  prefs: []
  type: TYPE_NORMAL
- en: second subround, a simple majority vote is sufficient to make the decision.
    It is possible to design a consensus algorithm with only one round, but that will
    require a minimum
  prefs: []
  type: TYPE_NORMAL
- en: '283'
  prefs: []
  type: TYPE_NORMAL
- en: CHapTer 6 early proToCols
  prefs: []
  type: TYPE_NORMAL
- en: number of processes to be 3 *f* + 1\. With two rounds under asynchrony, the
    2 *f* + 1 lower bound is met.
  prefs: []
  type: TYPE_NORMAL
- en: The Ben-Or algorithms described earlier do not use any cryptographic primitives
  prefs: []
  type: TYPE_NORMAL
- en: and assume strong adversary. However, a lot of work has also been carried out
  prefs: []
  type: TYPE_NORMAL
- en: where an asynchronous Byzantine agreement is studied under the availability
    of
  prefs: []
  type: TYPE_NORMAL
- en: cryptographic primitives. Of course, under this model the adversary is assumed
    to be
  prefs: []
  type: TYPE_NORMAL
- en: always computationally bounded. Some prominent early protocols under this model
  prefs: []
  type: TYPE_NORMAL
- en: are described earlier, such as the signed message protocol and the DLS protocol
    for the
  prefs: []
  type: TYPE_NORMAL
- en: authenticated Byzantine failure model. There are other algorithms that process
    coin
  prefs: []
  type: TYPE_NORMAL
- en: tosses cooperatively or, in other words, use global or shared coin tossing mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: A shared coin or global coin is a pseudorandom coin that produces the same result
    at
  prefs: []
  type: TYPE_NORMAL
- en: all processes in the same round. This attribute immediately implies that convergence
    is
  prefs: []
  type: TYPE_NORMAL
- en: much faster in the case of shared coin–based mechanisms. A similar technique
    was first
  prefs: []
  type: TYPE_NORMAL
- en: used in Rabin’s algorithm [14] utilizing cryptographic techniques which reduced
    the
  prefs: []
  type: TYPE_NORMAL
- en: expected time to the constant number of rounds.
  prefs: []
  type: TYPE_NORMAL
- en: After this basic introduction to early consensus protocols, I’ll now introduce
    early
  prefs: []
  type: TYPE_NORMAL
- en: replication protocols, which of course are fundamentally based on consensus,
    but can be
  prefs: []
  type: TYPE_NORMAL
- en: classified as replication protocols rather than just consensus algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: We saw earlier, in Chapt[er 3](https://doi.org/10.1007/978-1-4842-8179-6_3),
    that replication allows multiple replicas to achieve consistency in a distributed
    system. It is a method to provide high availability in a
  prefs: []
  type: TYPE_NORMAL
- en: distributed system. There are different models including primary backup replication
  prefs: []
  type: TYPE_NORMAL
- en: and active replication. You can refer to Chapt[er 3 t](https://doi.org/10.1007/978-1-4842-8179-6_3)o
    read more about state machine replication and other techniques.
  prefs: []
  type: TYPE_NORMAL
- en: '**Consensus Using Failure Detectors**'
  prefs: []
  type: TYPE_NORMAL
- en: We discussed failure detectors and its different classes earlier in Chapt[er
    3\. H](https://doi.org/10.1007/978-1-4842-8179-6_3)ere, we present the outline
    of an algorithm called the *Chandra-Toueg consensus protocol* to solve consensus
    using an eventually strong ⋄ *S* failure detector, which is the weakest failure
    detector for solving consensus [10]. Recall that an eventually strong failure
    detector
  prefs: []
  type: TYPE_NORMAL
- en: satisfies strong completeness and eventual weak accuracy properties.
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: This protocol considers an asynchronous network model with *f*
  prefs: []
  type: TYPE_NORMAL
- en: '*n*'
  prefs: []
  type: TYPE_NORMAL
- en: <  2 , that is, with at
  prefs: []
  type: TYPE_NORMAL
- en:  *n* +1
  prefs: []
  type: TYPE_NORMAL
- en: least
  prefs: []
  type: TYPE_NORMAL
- en: correct processes. Less than *n*/2 failed process assumption allows processes
  prefs: []
  type: TYPE_NORMAL
- en:  2 
  prefs: []
  type: TYPE_NORMAL
- en: to wait to receive majority responses regardless of what the failure detector
    is suspecting.
  prefs: []
  type: TYPE_NORMAL
- en: '284'
  prefs: []
  type: TYPE_NORMAL
- en: CHapTer 6 early proToCols
  prefs: []
  type: TYPE_NORMAL
- en: The protocol works in rounds under asynchrony with a rotating coordinator. The
  prefs: []
  type: TYPE_NORMAL
- en: protocol uses reliable broadcast which ensures that any message broadcast is
    either not
  prefs: []
  type: TYPE_NORMAL
- en: received (delivered) at all by any process or exactly once by all honest processes.
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm works as follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each process maintains some variables:'
  prefs: []
  type: TYPE_NORMAL
- en: • Estimate of the decision value – proposed value
  prefs: []
  type: TYPE_NORMAL
- en: • State
  prefs: []
  type: TYPE_NORMAL
- en: • Process’s current round number
  prefs: []
  type: TYPE_NORMAL
- en: • Last round in which the process updated its estimate (preference)
  prefs: []
  type: TYPE_NORMAL
- en: Until the state is decided, the processes go through multiple incrementing
  prefs: []
  type: TYPE_NORMAL
- en: asynchronous rounds each divided into four phases or subrounds, and coordinators
    are
  prefs: []
  type: TYPE_NORMAL
- en: rotated until a decision is reached. Coordinators are chosen in a round-robin
    fashion
  prefs: []
  type: TYPE_NORMAL
- en: 'using the formula ( *r mod n*) + 1, where *r* is the current round number,
    and *n* is the total number of processes:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. All processes send their estimate (preference) to the current
  prefs: []
  type: TYPE_NORMAL
- en: coordinator using a message of type (process id, current round
  prefs: []
  type: TYPE_NORMAL
- en: number, estimate, round number when the sender updated its
  prefs: []
  type: TYPE_NORMAL
- en: estimate).
  prefs: []
  type: TYPE_NORMAL
- en:  *n* +1
  prefs: []
  type: TYPE_NORMAL
- en: 2\. The current coordinator waits to collect a majority  2 
  prefs: []
  type: TYPE_NORMAL
- en: estimates and chooses the proposed value with the most recent
  prefs: []
  type: TYPE_NORMAL
- en: (largest) value of the last updated round as its estimate and then
  prefs: []
  type: TYPE_NORMAL
- en: proposes the new estimate to all processes.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Each process waits for the new proposal (estimate) from the
  prefs: []
  type: TYPE_NORMAL
- en: current coordinator or for the failure detector to suspect the
  prefs: []
  type: TYPE_NORMAL
- en: current coordinator. If it receives a new estimate, it updates its
  prefs: []
  type: TYPE_NORMAL
- en: preference, updates the last round variable to the current round,
  prefs: []
  type: TYPE_NORMAL
- en: and sends the ack message to the current coordinator. Otherwise,
  prefs: []
  type: TYPE_NORMAL
- en: it sends *nack*, suspecting that the current coordinator has crashed.
  prefs: []
  type: TYPE_NORMAL
- en: '285'
  prefs: []
  type: TYPE_NORMAL
- en: CHapTer 6 early proToCols
  prefs: []
  type: TYPE_NORMAL
- en:  *n* +1
  prefs: []
  type: TYPE_NORMAL
- en: 4\. The current coordinator waits for the 
  prefs: []
  type: TYPE_NORMAL
- en: – that is, a majority of
  prefs: []
  type: TYPE_NORMAL
- en: 2 
  prefs: []
  type: TYPE_NORMAL
- en: replies from processes, either *ack* or *nack*. If the current coordinator
  prefs: []
  type: TYPE_NORMAL
- en:  *n* +1
  prefs: []
  type: TYPE_NORMAL
- en: receives a majority of acks, meaning 
  prefs: []
  type: TYPE_NORMAL
- en: has accepted its
  prefs: []
  type: TYPE_NORMAL
- en: 2 
  prefs: []
  type: TYPE_NORMAL
- en: estimate, then the estimate is locked, and the coordinator does a
  prefs: []
  type: TYPE_NORMAL
- en: reliable broadcast of the decide message (decided value).
  prefs: []
  type: TYPE_NORMAL
- en: • Finally, any undecided process that delivers a value via the reliable
  prefs: []
  type: TYPE_NORMAL
- en: broadcast accepts and decides on that value.
  prefs: []
  type: TYPE_NORMAL
- en: Note that there are other algorithms in the paper [10] as well, but I have described
  prefs: []
  type: TYPE_NORMAL
- en: here only the one that solves consensus using an eventually strong failure detector.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s see how agreement, validity, and termination requirements are met.
  prefs: []
  type: TYPE_NORMAL
- en: The **agreement** is satisfied. Let’s think about a scenario where it is possible
    that two coordinators broadcast, and some processes end up accepting a value from
    the first
  prefs: []
  type: TYPE_NORMAL
- en: coordinator and some from the other. This will violate the agreement because,
    here,
  prefs: []
  type: TYPE_NORMAL
- en: two processes are deciding differently, that is, two different values are both
    chosen.
  prefs: []
  type: TYPE_NORMAL
- en: However, this cannot occur because for the first coordinator to send a decision,
    it must
  prefs: []
  type: TYPE_NORMAL
- en: have received enough acknowledgments (acks) from the majority of the processes.
  prefs: []
  type: TYPE_NORMAL
- en: All subsequent coordinators looking for the majority will see an overlap with
    the
  prefs: []
  type: TYPE_NORMAL
- en: previous one. The estimate will be the most recent one. As such, any two coordinators
  prefs: []
  type: TYPE_NORMAL
- en: broadcasting the decision are sending out the same decision.
  prefs: []
  type: TYPE_NORMAL
- en: '**Validity** is also satisfied because every estimate is some process’s input
    value. The protocol design does not allow generating any new estimates.'
  prefs: []
  type: TYPE_NORMAL
- en: The protocol eventually **terminates** because the failure detector, an eventually
  prefs: []
  type: TYPE_NORMAL
- en: strong failure detector, will eventually stop suspecting some correct process,
    which
  prefs: []
  type: TYPE_NORMAL
- en: will eventually become the coordinator. With the new coordinator, in some round,
    all
  prefs: []
  type: TYPE_NORMAL
- en: correct processes will wait to receive this new coordinator’s estimate and will
    respond
  prefs: []
  type: TYPE_NORMAL
- en: with enough ack messages. When the coordinator collects the majority of ack
    messages,
  prefs: []
  type: TYPE_NORMAL
- en: it will send its decided estimate to all, and all processes will terminate.
    Note that if
  prefs: []
  type: TYPE_NORMAL
- en: some process ends up waiting for a response from an already terminated process,
    it
  prefs: []
  type: TYPE_NORMAL
- en: will also eventually get the message by retransmission through other correct
    nodes and
  prefs: []
  type: TYPE_NORMAL
- en: eventually decide and terminate. For example, suppose a process gets stuck waiting
  prefs: []
  type: TYPE_NORMAL
- en: for messages from a crashed coordinator. Eventually, due to the strong completeness
  prefs: []
  type: TYPE_NORMAL
- en: property of the eventually strong failure detector, the failed coordinator will
    be
  prefs: []
  type: TYPE_NORMAL
- en: suspected, ensuring progress.
  prefs: []
  type: TYPE_NORMAL
- en: '286'
  prefs: []
  type: TYPE_NORMAL
- en: CHapTer 6 early proToCols
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter covered early protocols that provide a solid foundation for most
    of the
  prefs: []
  type: TYPE_NORMAL
- en: consensus research done today. With the advent of blockchains, many of these
    protocols
  prefs: []
  type: TYPE_NORMAL
- en: inspired the development of new blockchain age protocols, especially for permissioned
  prefs: []
  type: TYPE_NORMAL
- en: blockchains. For example, Tendermint is based on the DLS protocol, that is,
    algorithm 2
  prefs: []
  type: TYPE_NORMAL
- en: from the DLS paper.
  prefs: []
  type: TYPE_NORMAL
- en: We did not discuss every algorithm in this chapter, but this chapter should
    provide
  prefs: []
  type: TYPE_NORMAL
- en: readers with a solid foundation to build on further. To circumvent FLP impossibility,
  prefs: []
  type: TYPE_NORMAL
- en: randomness can be introduced into the system by either assuming the randomized
  prefs: []
  type: TYPE_NORMAL
- en: model or local coin flips at the processes. The first proposal that assumes
    a randomized
  prefs: []
  type: TYPE_NORMAL
- en: model (also called fair scheduling, randomized scheduling) mechanism is by Bracha
  prefs: []
  type: TYPE_NORMAL
- en: and Toueg [17]. Algorithms based on the second approach where processes are
    provided
  prefs: []
  type: TYPE_NORMAL
- en: with a local coin flip operation were first proposed by Ben-Or [2], which is
    the first
  prefs: []
  type: TYPE_NORMAL
- en: randomized consensus protocol. The first approach to achieve the expected constant
  prefs: []
  type: TYPE_NORMAL
- en: number of rounds by using the shared coin (global coin) approach implemented
    using
  prefs: []
  type: TYPE_NORMAL
- en: digital signatures and a trusted dealer is published in Rabin [14]. Protocols
    utilizing
  prefs: []
  type: TYPE_NORMAL
- en: failure detectors were proposed by Chandra and Toueg [15]. An excellent survey
    of
  prefs: []
  type: TYPE_NORMAL
- en: randomized protocols for asynchronous consensus is by Aspnes [16].
  prefs: []
  type: TYPE_NORMAL
- en: Randomized protocols are a way to circumvent an FLP result, but can we refute
    the
  prefs: []
  type: TYPE_NORMAL
- en: FLP impossibility result altogether? Sounds impossible, but we’ll see in Chapter
    [9](https://doi.org/10.1007/978-1-4842-8179-6_9) that refuting the FLP result
    might be possible.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover classical protocols such as PBFT, which is
    seen as a
  prefs: []
  type: TYPE_NORMAL
- en: natural progression from the viewstamped replication (VR) protocol, which we
    will also
  prefs: []
  type: TYPE_NORMAL
- en: introduce in the next chapter. While VR dealt with crash faults only, PBFT also
    dealt with Byzantine faults. We’ll cover other protocols, too, such as Paxos,
    which is the foundation of most if not all consensus protocols. Almost all consensus
    algorithms utilize the
  prefs: []
  type: TYPE_NORMAL
- en: fundamental ideas presented in Paxos in one way or another.
  prefs: []
  type: TYPE_NORMAL
- en: '**Bibliography**'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Impossibility of distributed consensus with one faulty process
  prefs: []
  type: TYPE_NORMAL
- en: J. Assoc. Computer. Mach., 32 (No. 2) (1985), pp. 374–382\.
  prefs: []
  type: TYPE_NORMAL
- en: '2\. M. Ben-Or: Another advantage of free choice: Completely'
  prefs: []
  type: TYPE_NORMAL
- en: asynchronous agreement protocols.
  prefs: []
  type: TYPE_NORMAL
- en: '287'
  prefs: []
  type: TYPE_NORMAL
- en: CHapTer 6 early proToCols
  prefs: []
  type: TYPE_NORMAL
- en: 3\. L. Lamport, R. Shostak, M. Pease, the Byzantine Generals
  prefs: []
  type: TYPE_NORMAL
- en: problem, ACM Transactions on Programming Languages and
  prefs: []
  type: TYPE_NORMAL
- en: Systems, vol. 4 (no. 3) (1982), pp. 382–401, July 1982\.
  prefs: []
  type: TYPE_NORMAL
- en: 4\. Lampson, Butler, and Howard E. Sturgis. “Crash recovery in a
  prefs: []
  type: TYPE_NORMAL
- en: distributed data storage system.” (1979).
  prefs: []
  type: TYPE_NORMAL
- en: 5\. Skeen, D., 1981, April. Nonblocking commit protocols. In
  prefs: []
  type: TYPE_NORMAL
- en: Proceedings of the 1981 ACM SIGMOD international conference
  prefs: []
  type: TYPE_NORMAL
- en: on Management of data (pp. 133–142).
  prefs: []
  type: TYPE_NORMAL
- en: 6\. Dwork, C., Lynch, N., and Stockmeyer, L., 1988\. Consensus in the
  prefs: []
  type: TYPE_NORMAL
- en: presence of partial synchrony. Journal of the ACM (JACM), 35(2),
  prefs: []
  type: TYPE_NORMAL
- en: pp. 288–323\.
  prefs: []
  type: TYPE_NORMAL
- en: 7\. G. Bracha, “Asynchronous Byzantine agreement protocols,” Inf.
  prefs: []
  type: TYPE_NORMAL
- en: Comput., 1987\.
  prefs: []
  type: TYPE_NORMAL
- en: 8\. S. Toueg, “Randomized Byzantine agreements,” in PODC, 1984\.
  prefs: []
  type: TYPE_NORMAL
- en: 9\. G. Bracha and S. Toueg, “Resilient consensus protocols,” in
  prefs: []
  type: TYPE_NORMAL
- en: PODC, 1983\.
  prefs: []
  type: TYPE_NORMAL
- en: 10\. Chandra, T.D. and Toueg, S., 1996\. Unreliable failure detectors for
  prefs: []
  type: TYPE_NORMAL
- en: reliable distributed systems. Journal of the ACM (JACM), 43(2),
  prefs: []
  type: TYPE_NORMAL
- en: pp. 225–267\.
  prefs: []
  type: TYPE_NORMAL
- en: 11\. Martin Kleppmann’s lectures on distributed computing –
  prefs: []
  type: TYPE_NORMAL
- en: Kleppmann, M., 2018\. Distributed systems[. www.cl.cam.ac.uk/](https://www.cl.cam.ac.uk/teaching/2021/ConcDisSys/dist-sys-notes.pdf)
  prefs: []
  type: TYPE_NORMAL
- en: '[teaching/2021/ConcDisSys/dist-sys-notes.pdf](https://www.cl.cam.ac.uk/teaching/2021/ConcDisSys/dist-sys-notes.pdf)'
  prefs: []
  type: TYPE_NORMAL
- en: '12\. Distributed Algorithms: A Verbose Tour – by Fourre Sigs.'
  prefs: []
  type: TYPE_NORMAL
- en: '13\. Lindsey Kuper – lectures on distributed systems[: https://](https://youtube.com/playlist?list=PLNPUF5QyWU8PydLG2cIJrCvnn5I_exhYx)'
  prefs: []
  type: TYPE_NORMAL
- en: '[youtube.com/playlist?list=PLNPUF5QyWU8PydLG2cIJrCv](https://youtube.com/playlist?list=PLNPUF5QyWU8PydLG2cIJrCvnn5I_exhYx)'
  prefs: []
  type: TYPE_NORMAL
- en: '[nn5I_exhYx](https://youtube.com/playlist?list=PLNPUF5QyWU8PydLG2cIJrCvnn5I_exhYx)'
  prefs: []
  type: TYPE_NORMAL
- en: 14\. Rabin, M.O., 1983, November. Randomized Byzantine generals.
  prefs: []
  type: TYPE_NORMAL
- en: In 24th annual symposium on foundations of computer science
  prefs: []
  type: TYPE_NORMAL
- en: (sfcs 1983) (pp. 403–409). IEEE.
  prefs: []
  type: TYPE_NORMAL
- en: '288'
  prefs: []
  type: TYPE_NORMAL
- en: CHapTer 6 early proToCols
  prefs: []
  type: TYPE_NORMAL
- en: 15\. Chandra, T.D. and Toueg, S., 1996\. Unreliable failure detectors for
  prefs: []
  type: TYPE_NORMAL
- en: reliable distributed systems. Journal of the ACM (JACM), 43(2),
  prefs: []
  type: TYPE_NORMAL
- en: pp. 225–267\.
  prefs: []
  type: TYPE_NORMAL
- en: 16\. Aspnes, J., 2003\. Randomized protocols for asynchronous
  prefs: []
  type: TYPE_NORMAL
- en: consensus. *Distributed Computing*, *16*(2), pp. 165–175\.
  prefs: []
  type: TYPE_NORMAL
- en: 17\. Bracha, G. and Toueg, S., 1985\. Asynchronous consensus
  prefs: []
  type: TYPE_NORMAL
- en: and broadcast protocols. *Journal of the ACM (JACM)*, *32*(4),
  prefs: []
  type: TYPE_NORMAL
- en: pp. 824–840\.
  prefs: []
  type: TYPE_NORMAL
- en: '289'
  prefs: []
  type: TYPE_NORMAL
- en: '**CHAPTER 7**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Classical Consensus**'
  prefs: []
  type: TYPE_NORMAL
- en: Consensus and replication protocols that appeared in the 1980s have made profound
  prefs: []
  type: TYPE_NORMAL
- en: contributions in consensus protocol research. Early replication protocols like
  prefs: []
  type: TYPE_NORMAL
- en: viewstamped replication provided deep insights into how fault-tolerant replication
    can
  prefs: []
  type: TYPE_NORMAL
- en: be designed and implemented. Around the same time, Paxos was introduced, which
  prefs: []
  type: TYPE_NORMAL
- en: offered a practical protocol with rigorous formal specification and analysis.
    In 1999,
  prefs: []
  type: TYPE_NORMAL
- en: the first practical Byzantine fault–tolerant protocol was introduced. This chapter
    covers these classical protocols in detail, their design, how they work, and how
    they provide
  prefs: []
  type: TYPE_NORMAL
- en: safety and liveness guarantees. Moreover, some ideas on how and if we can use
    them in
  prefs: []
  type: TYPE_NORMAL
- en: the blockchain are also presented. Additionally, recently developed protocols
    such as
  prefs: []
  type: TYPE_NORMAL
- en: RAFT are also discussed, which builds on previous classical protocols to construct
    an
  prefs: []
  type: TYPE_NORMAL
- en: easy-to-understand consensus protocol.
  prefs: []
  type: TYPE_NORMAL
- en: '**Viewstamped Replication**'
  prefs: []
  type: TYPE_NORMAL
- en: A viewstamped replication approach to replicate among peers was introduced by
    Brian
  prefs: []
  type: TYPE_NORMAL
- en: Oki and Barbara Liskov in 1988\. This is one of the most fundamental mechanisms
    to
  prefs: []
  type: TYPE_NORMAL
- en: achieve replication to guarantee consistency (consistent view) over replicated
    data. It
  prefs: []
  type: TYPE_NORMAL
- en: works in the presence of crash faults and network partitions; however, it is
    assumed that eventually nodes recover from crashes, and network partitions are
    healed. It is also a
  prefs: []
  type: TYPE_NORMAL
- en: consensus algorithm because to achieve consistency over replicated data, nodes
    must
  prefs: []
  type: TYPE_NORMAL
- en: agree on a replicated state.
  prefs: []
  type: TYPE_NORMAL
- en: Viewstamped replication has two primary purposes. One is to provide a distributed
  prefs: []
  type: TYPE_NORMAL
- en: system which is coherent enough that the clients see that as if they are communicating
  prefs: []
  type: TYPE_NORMAL
- en: with a single server. The other one is to provide state machine replication.
    State machine replication requires that all replicas start in the same initial
    state and operations are deterministic. With these requirements (assumptions),
    we can easily see that if all
  prefs: []
  type: TYPE_NORMAL
- en: replicas execute the same sequence of operations, then they will end up in the
    same
  prefs: []
  type: TYPE_NORMAL
- en: '291'
  prefs: []
  type: TYPE_NORMAL
- en: © Imran Bashir 2022
  prefs: []
  type: TYPE_NORMAL
- en: I. Bashir, *Blockchain Consensus*, [https://doi.org/10.1007/978-1-4842-8179-6_7](https://doi.org/10.1007/978-1-4842-8179-6_7#DOI)
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 7 ClassiCal Consensus
  prefs: []
  type: TYPE_NORMAL
- en: state. Of course, the challenge here is to ensure that operations execute in
    the same order at all replicas even in the event of failures. So, in summary the
    protocol provides fault tolerance and consistency. It is based on a primary backup
    copy technique.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three subprotocols in the viewstamped replication (VR) protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '• **Normal operation protocol**: Handles client requests and achieves'
  prefs: []
  type: TYPE_NORMAL
- en: replication under normal conditions
  prefs: []
  type: TYPE_NORMAL
- en: '• **View change protocol**: Handles primary failure and starts a new view'
  prefs: []
  type: TYPE_NORMAL
- en: with a new primary
  prefs: []
  type: TYPE_NORMAL
- en: '• **Replica recovery protocol**: Handles rejoining of a failed replica that'
  prefs: []
  type: TYPE_NORMAL
- en: has now recovered
  prefs: []
  type: TYPE_NORMAL
- en: VR is inspired by the two-phase commit protocol, but unlike the two-phase commit,
  prefs: []
  type: TYPE_NORMAL
- en: it’s a failure-resilient protocol and does not block if the primary (coordinator
    in 2PC
  prefs: []
  type: TYPE_NORMAL
- en: terminology) or replicas fail. The protocol is reliable and ensures availability
    if no more than f replicas are faulty. It uses replica groups of 2f + 1 and tolerates
    crash failures under asynchrony with f+1 quorum sizes.
  prefs: []
  type: TYPE_NORMAL
- en: Every replica maintains a state which contains information such as configuration,
    replica number, current view, current status – normal or view change or recovering,
    assigned op
  prefs: []
  type: TYPE_NORMAL
- en: number to the latest request, log containing entries which contain the requests
    received
  prefs: []
  type: TYPE_NORMAL
- en: so far with their op numbers, and the client table which consists of the most
    recent client request, with status if it has been executed or not and associated
    result for that request.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see how the normal operation works in VR. First, let’s see the list of
    variables
  prefs: []
  type: TYPE_NORMAL
- en: 'and their meanings:'
  prefs: []
  type: TYPE_NORMAL
- en: '• **op**: Client operation'
  prefs: []
  type: TYPE_NORMAL
- en: '• **c**: Client ID'
  prefs: []
  type: TYPE_NORMAL
- en: '• **s**: Number assigned to the request'
  prefs: []
  type: TYPE_NORMAL
- en: '• **v**: View number known to the client'
  prefs: []
  type: TYPE_NORMAL
- en: '• **m**: Message received from the client'
  prefs: []
  type: TYPE_NORMAL
- en: '• **n**: The op number assigned to the request'
  prefs: []
  type: TYPE_NORMAL
- en: '• **i**: Nonprimary replica'
  prefs: []
  type: TYPE_NORMAL
- en: '• **x**: Result'
  prefs: []
  type: TYPE_NORMAL
- en: '292'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 7 ClassiCal Consensus
  prefs: []
  type: TYPE_NORMAL
- en: '**Protocol Steps**'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. A client sends a request message of the form <REQUEST op, c, s,
  prefs: []
  type: TYPE_NORMAL
- en: v> message to the primary replica.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. When received by the primary
  prefs: []
  type: TYPE_NORMAL
- en: a. It increments the op number.
  prefs: []
  type: TYPE_NORMAL
- en: b. It adds the request message at the end of the log.
  prefs: []
  type: TYPE_NORMAL
- en: c. It sends a <PREPARE m, v, n> to other replicas.
  prefs: []
  type: TYPE_NORMAL
- en: '3\. When replicas receive the prepare message, they do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: a. The prepare message is only accepted if all previous requests preceding the
  prefs: []
  type: TYPE_NORMAL
- en: op number in the prepare message have entries in their log.
  prefs: []
  type: TYPE_NORMAL
- en: b. Otherwise, they wait until the missing entries are updated – via state
  prefs: []
  type: TYPE_NORMAL
- en: transfer.
  prefs: []
  type: TYPE_NORMAL
- en: c. They append the request to their log.
  prefs: []
  type: TYPE_NORMAL
- en: d. They send the <PREPAREOK v, n, i> message to the primary replica.
  prefs: []
  type: TYPE_NORMAL
- en: 4\. The primary waits for f PREPAREOK messages from other replicas;
  prefs: []
  type: TYPE_NORMAL
- en: when received, it
  prefs: []
  type: TYPE_NORMAL
- en: a. Considers the operation to be committed
  prefs: []
  type: TYPE_NORMAL
- en: b. Executes any pending operations
  prefs: []
  type: TYPE_NORMAL
- en: c. Executes the latest operation
  prefs: []
  type: TYPE_NORMAL
- en: d. Sends the message <REPLY v, s, x> to the client
  prefs: []
  type: TYPE_NORMAL
- en: 5\. After the commit, the primary replica informs other replicas about
  prefs: []
  type: TYPE_NORMAL
- en: the commit.
  prefs: []
  type: TYPE_NORMAL
- en: 6\. Other replicas execute it after appending it in their log but only
  prefs: []
  type: TYPE_NORMAL
- en: after executing any pending operations.
  prefs: []
  type: TYPE_NORMAL
- en: This process is visualized in Figur[e 7-1\.](#p309)
  prefs: []
  type: TYPE_NORMAL
- en: '293'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-309_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 7 ClassiCal Consensus
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 7-1\.** VR protocol – normal operation*'
  prefs: []
  type: TYPE_NORMAL
- en: When the primary fails, the view change protocol initiates. Failure is indicated
    by
  prefs: []
  type: TYPE_NORMAL
- en: 'timeout at replicas:'
  prefs: []
  type: TYPE_NORMAL
- en: '• **v**: View number'
  prefs: []
  type: TYPE_NORMAL
- en: '• **l**: Replica’s log/new log'
  prefs: []
  type: TYPE_NORMAL
- en: '• **k**: The op number of the latest known committed request that the'
  prefs: []
  type: TYPE_NORMAL
- en: replica is aware of
  prefs: []
  type: TYPE_NORMAL
- en: '• **I**: Replica identifier'
  prefs: []
  type: TYPE_NORMAL
- en: '**View Change**'
  prefs: []
  type: TYPE_NORMAL
- en: 'A view change protocol works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. When a replica suspects the primary of failure, it
  prefs: []
  type: TYPE_NORMAL
- en: a. Increments its view number
  prefs: []
  type: TYPE_NORMAL
- en: b. Changes its status to view change
  prefs: []
  type: TYPE_NORMAL
- en: c. Sends a <DOVIEWCHANGE v, l, k, i> message to the primary of the
  prefs: []
  type: TYPE_NORMAL
- en: next view
  prefs: []
  type: TYPE_NORMAL
- en: 2\. When the new primary gets f+1 of the DOVIEWCHANGE
  prefs: []
  type: TYPE_NORMAL
- en: message, it
  prefs: []
  type: TYPE_NORMAL
- en: '294'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-310_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 7 ClassiCal Consensus
  prefs: []
  type: TYPE_NORMAL
- en: a. Chooses the most recent log in the message and picks that as its new log
  prefs: []
  type: TYPE_NORMAL
- en: b. Sets the op number to that of the latest entry in the new log
  prefs: []
  type: TYPE_NORMAL
- en: c. Changes its status to normal
  prefs: []
  type: TYPE_NORMAL
- en: d. Sends the <STARTVIEW v, l, k> message to other replicas, indicating the
  prefs: []
  type: TYPE_NORMAL
- en: completion of the view change process
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Now the new primary
  prefs: []
  type: TYPE_NORMAL
- en: a. Sequentially executes any unexecuted committed operations
  prefs: []
  type: TYPE_NORMAL
- en: b. Sends a reply to the client
  prefs: []
  type: TYPE_NORMAL
- en: c. Starts accepting new client requests
  prefs: []
  type: TYPE_NORMAL
- en: 4\. Other replicas upon receiving the startview message
  prefs: []
  type: TYPE_NORMAL
- en: a. Replace their log with the one in the message
  prefs: []
  type: TYPE_NORMAL
- en: b. Set their op number to the one in the latest entry in the log
  prefs: []
  type: TYPE_NORMAL
- en: c. Set their view number to what is in the message
  prefs: []
  type: TYPE_NORMAL
- en: d. Change their status to normal
  prefs: []
  type: TYPE_NORMAL
- en: e. Send PREPAREOK for uncommitted messages
  prefs: []
  type: TYPE_NORMAL
- en: The view change protocol repeats if even a new primary fails.
  prefs: []
  type: TYPE_NORMAL
- en: Figur[e 7-2 vis](#p310)ualizes this process.
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 7-2\.** View change in VR*'
  prefs: []
  type: TYPE_NORMAL
- en: '295'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 7 ClassiCal Consensus
  prefs: []
  type: TYPE_NORMAL
- en: The key safety requirement here is that all committed operations make it to
    the next
  prefs: []
  type: TYPE_NORMAL
- en: views with their order preserved.
  prefs: []
  type: TYPE_NORMAL
- en: VR is not discussed with all intricate details on purpose, as we focus more
    on
  prefs: []
  type: TYPE_NORMAL
- en: mainstream protocols. Still, it should give you an idea about the fundamental
    concepts
  prefs: []
  type: TYPE_NORMAL
- en: introduced in VR, which play an essential role in almost all replication and
    consensus
  prefs: []
  type: TYPE_NORMAL
- en: protocols, especially PBFT, Paxos, and RAFT. When you read the following sections,
  prefs: []
  type: TYPE_NORMAL
- en: you will see how PBFT is an evolved form of VR and other similarities between
    VR and
  prefs: []
  type: TYPE_NORMAL
- en: different protocols introduced in this chapter. When you read the section on
    RAFT, you
  prefs: []
  type: TYPE_NORMAL
- en: will find good resemblance between VR and RAFT.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at Paxos first, undoubtedly the most influential and fundamental
  prefs: []
  type: TYPE_NORMAL
- en: consensus protocol.
  prefs: []
  type: TYPE_NORMAL
- en: '**Paxos**'
  prefs: []
  type: TYPE_NORMAL
- en: Leslie Lamport discovered Paxos. It was proposed first in 1988 and then later
    more
  prefs: []
  type: TYPE_NORMAL
- en: formally in 1998\. It is the most fundamental distributed consensus algorithm
    which
  prefs: []
  type: TYPE_NORMAL
- en: allows consensus over a value under unreliable communications. In other words,
    Paxos
  prefs: []
  type: TYPE_NORMAL
- en: is used to build a reliable system that works correctly, even in the presence
    of faults.
  prefs: []
  type: TYPE_NORMAL
- en: Paxos made state machine replication more practical to implement. A version
    of Paxos
  prefs: []
  type: TYPE_NORMAL
- en: called multi-Paxos is commonly used to implement a replicated state machine.
    It runs
  prefs: []
  type: TYPE_NORMAL
- en: under a message-passing model with asynchrony. It tolerates fewer than *n*/2
    crash faults, that is, it meets the lower bound of 2 *f* + 1\.
  prefs: []
  type: TYPE_NORMAL
- en: Earlier consensus mechanisms did not handle safety and liveness separately.
  prefs: []
  type: TYPE_NORMAL
- en: The Paxos protocol takes a different approach to solving the consensus problem
    by
  prefs: []
  type: TYPE_NORMAL
- en: separating the safety and liveness properties.
  prefs: []
  type: TYPE_NORMAL
- en: There are three roles that nodes in a system running the Paxos protocol can
  prefs: []
  type: TYPE_NORMAL
- en: 'undertake. A single process may assume all three roles:'
  prefs: []
  type: TYPE_NORMAL
- en: '• **Proposer**: Proposes values to be decided. An elected proposer acts'
  prefs: []
  type: TYPE_NORMAL
