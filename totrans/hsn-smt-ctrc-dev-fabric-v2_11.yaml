- en: Chapter 7\. Building Supply Chain DApps with Hyperledger Fabric
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Part III](part03.xhtml#developing_smart_contracts_with_hyperle), you learned
    how to develop, deploy, and test chaincode in Hyperledger Fabric. In this chapter,
    we will put all this information together to design and build a simple supply
    chain blockchain application called Pharma Ledger Network (PLN). This project
    will give you a taste of how blockchain enables global business transactions with
    greater transparency, streamlined supplier onboarding, better response to disruptions,
    and a secure environment. Specifically, the PLN project illustrates how blockchain
    can help manufacturers, wholesalers, and other supply chain members like pharmacies
    deliver medical supplies.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will help you achieve the following practical goals:'
  prefs: []
  type: TYPE_NORMAL
- en: Designing a blockchain supply chain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing chaincode as a smart contract
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compiling and deploying Fabric chaincode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running and testing the smart contract
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing an application with Hyperledger Fabric through the SDK
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing a Blockchain Supply Chain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The traditional supply chain usually lacks transparency and reliable reporting.
    Large organizations have built their own systems to enable global control of their
    daily operations while recording transactions between suppliers and distributors
    in real time. However, many small companies lack that information and have limited
    visibility to trace their products at any given moment. That means, in their entire
    supply chain product process flow (from production to consumption), the transparency
    from upstream to downstream is very limited. This could lead to inaccurate reports
    and a lack of interoperability.
  prefs: []
  type: TYPE_NORMAL
- en: By design, the blockchain is a shared-ledger, transparent, immutable, and secure
    decentralized system. It is considered a good solution for traditional supply
    chain industries at registering, controlling, and transferring assets. Indeed,
    the popularity of blockchain and its adoption, in part, stems from its use in
    supply chain systems around the world.
  prefs: []
  type: TYPE_NORMAL
- en: A smart contract, which defines a business function, can be deployed in blockchain
    and then accessed by multiple parties in the blockchain network. Each member in
    the blockchain will be assigned unique identifiers to sign and verify the blocks
    they add to the blockchain. During the life cycle of the supply chain, when authorized
    members in a consortium network invoke a smart contract function, the state data
    will be updated, after which current assets’ status and the transaction data will
    become a permanent record in the ledger. Likewise, the processes related to assets
    can be easily and quickly moved from one step to another. The digital transactions
    in the ledger can be tracked, shared, and queried by all supply chain participants
    in real time. It provides organizations with new opportunities to correct problems
    within their supply chain system as it revolves around a single source of truth.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we discuss a simple supply chain system and build our PLN use
    case. It will provide a good foundation for analyzing and implementing an application
    based on Hyperledger Fabric. We will analyze the business process workflow, identify
    the organizations in the network, and then design the consortium network. We’ll
    also define a smart contract function that each organization will perform.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Supply Chain Workflow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s take a look at organizations in the PLN business scenario, as shown in
    [Figure 7-1](#organizations_in_the_pln). For demonstration purposes, we simplified
    the pharma ledger process, as it can be much more complex in the real world
  prefs: []
  type: TYPE_NORMAL
- en: '![Organizations in the PLN](Images/HLF_0701.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-1\. Organizations in the PLN
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Our PLN process is divided into the following three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: A manufacturer makes equipment and ships it to the wholesaler.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A wholesaler distributes the equipment to the pharmacy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The pharmacy, as a consumer, receives the equipment, and the supply chain workflow
    is completed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Defining a Consortium
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we can see from the process workflow, our PLN involves three organizations:
    manufacturer, wholesaler, and pharmacy. These three entities will join together
    to build a consortium network to carry out the supply chain business. The consortium
    members can create users, invoke smart contracts, and query blockchain data. [Table 7-1](#the_pln_consortium)
    depicts the organizations and users in the PLN consortium.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 7-1\. The PLN consortium
  prefs: []
  type: TYPE_NORMAL
- en: '| Organization name | User | MSP | Peer |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Manufacturer | Bob | Org1MSP | *peer0.org1.example.com* |'
  prefs: []
  type: TYPE_TB
- en: '| Wholesaler | Alice | Org2MSP | *peer0.org2.example.com* |'
  prefs: []
  type: TYPE_TB
- en: '| Pharmacy | Eve | Org3MSP | *peer0.org3.example.com* |'
  prefs: []
  type: TYPE_TB
- en: In our PLN consortium, each of the three organizations has a user, an MSP, and
    a peer. For the manufacturer organization, we have a user called Bob as an application
    user. Org1MSP is an MSP ID to load the MSP definition. We define AnchorPeers with
    the hostname peer0.org1.example.com to gossip communication across. Similarly,
    the wholesaler is the second organization, Alice is its application user, and
    its MSP ID is Org2MSP. Finally, Eve is the pharmacy organization user with Org3MSP.
  prefs: []
  type: TYPE_NORMAL
- en: With the organizations identified, we can define our Hyperledger Fabric network
    topology, as shown in [Figure 7-2](#fabric_network_topology_for_the_pln_con).
  prefs: []
  type: TYPE_NORMAL
- en: '![Fabric network topology for the PLN consortium](Images/HLF_0702.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-2\. Fabric network topology for the PLN consortium
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Since installing and deploying PLN in multiple physical nodes may not be within
    the scope of this chapter, we define one peer with four organizations, representing
    the manufacturer, wholesaler, pharmacy, and orderer nodes.
  prefs: []
  type: TYPE_NORMAL
- en: The channel *plnchannel* provides a private communications mechanism used by
    the orderer and the other three organizations to execute and validate the transactions.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing the PLN Life Cycle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we mentioned in the previous section, the PLN life cycle has three steps:
    the manufacturer makes equipment and ships to the wholesaler; the wholesaler distributes
    the equipment to the pharmacy; and finally, the pharmacy receives the equipment.
    The entire process can be traced by equipment ID. Let’s look at this in more detail.'
  prefs: []
  type: TYPE_NORMAL
- en: A piece of equipment with equipment ID 2000.001 was made by a manufacturer on
    Jan 1, with equipment and other attributes and values, as shown in [Figure 7-3](#equipment_attributes_and_their_values_f).
  prefs: []
  type: TYPE_NORMAL
- en: '![Equipment attributes and their values for the manufacturer](Images/HLF_0703.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-3\. Equipment attributes and their values for the manufacturer
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Equipment attributes and values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here we define a unique identification equipment number to represent equipment.
    Each equipment item is owned by an equipment owner at a certain period of time.
    In our case, we define three owner types: manufacturer, wholesaler, and pharmacy.'
  prefs: []
  type: TYPE_NORMAL
- en: When a manufacturer makes a piece of equipment and records it in the PLN, the
    transaction result shows the equipment with a unique identification number of
    2000.001 in the ledger. The current owner is GlobalEquipmentCorp. The current
    owner type and previous one are the same—manufacturer. The equipment was made
    on Jan 1, 2021\. The `lastUpdated` entry is the date when the transaction was
    recorded in the PLN.
  prefs: []
  type: TYPE_NORMAL
- en: After a few weeks, the manufacturer ships the equipment to the wholesaler, and
    the equipment state will change, including ownership, previous and current owner
    type, and last update. Let’s take a look at which equipment states change, as
    shown in [Figure 7-4](#equipment_state_changes_for_the_wholesa).
  prefs: []
  type: TYPE_NORMAL
- en: '![Equipment state changes for the wholesaler](Images/HLF_0704.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-4\. Equipment state changes for the wholesaler
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Equipment state changes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the most significant changes is that the equipment is now owned by GlobalWholesalerCorp.
    The previous owner type is the manufacturer. The last updated date has also changed.
  prefs: []
  type: TYPE_NORMAL
- en: After one month, the pharmacy finally receives this equipment order. The ownership
    is now transferred from the wholesaler to the pharmacy, as shown in [Figure 7-5](#updated_equipment_values_for_the_pharma).
    The supply chain flow can be considered closed.
  prefs: []
  type: TYPE_NORMAL
- en: '![Updated equipment values for the pharmacy](Images/HLF_0705.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-5\. Updated equipment values for the pharmacy
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Equipment at the hand of the pharmacy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With the same equipment identity, the peer organization can trace the equipment’s
    entire history of transaction records by looking up the equipment number.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Transactions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you’ve seen, the entire life cycle has three steps. Originating from the
    manufacturer, the equipment moves from wholesaler to pharmacy. As such, as a result
    of making a piece of equipment, the wholesaler distributes and the pharmacy receives
    the transaction. With all of this design and analysis, we can now start to write
    our PLN smart contract.
  prefs: []
  type: TYPE_NORMAL
- en: Writing Chaincode as a Smart Contract
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have discussed how equipment state and attributes change during the life
    cycle of a transaction, as the equipment moves among parties in our Pharma Ledger
    Network. As discussed in [Part III](part03.xhtml#developing_smart_contracts_with_hyperle),
    in Hyperledger Fabric, a smart contract is a program that implements the business
    logic and manages the world state of a business object during its life cycle.
    During deployment, this contract will be packaged into the chaincode and installed
    on each endorsing peer that runs in a secured Docker container. The Hyperledger
    Fabric smart contract can be programmed in Go, JavaScript, Java, and Python.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will write a smart contract implementation for our PLN by
    using JavaScript. All of the PLN code for this chapter is available in the book’s
    GitHub repository. Also, we use Fabric v2.1.0 and Fabric CA v1.4.7 throughout
    the entire project.
  prefs: []
  type: TYPE_NORMAL
- en: Project Structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To start our PLN smart contract development, first we need to create our smart
    contract project. Since we have three organizations, all peers must agree and
    approve of the new version of the smart contract that will be installed and deployed
    to the network. For our PLN, we will assume they are all the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The *package.json* file defines the two most important fabric libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The *fabric-contract-api* provides the contract interface. It has two critical
    classes that every smart contract needs to use, `Contract` and `Context`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`Contract` has `beforeTransaction`, `afterTransaction`, `unknownTransaction`,
    and `createContext` methods that are optional and overridable in the subclass.
    You can specify the JavaScript explicit contract class name by using its superclass
    to initialize itself.'
  prefs: []
  type: TYPE_NORMAL
- en: The `Context` class provides the transactional context for every transactional
    invocation. It can be overridden for additional application behavior to support
    smart contract execution.
  prefs: []
  type: TYPE_NORMAL
- en: Contract Class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our pharma ledger contract implementation will extend from the default built-in
    contract class from the *fabric-contract-api* library. Let’s first define `PharmaLedgerContract`
    with a constructor: `org.pln.PharmaLedgerContract` gives a very descriptive name
    with a unique namespace for our contract. The unique contract namespace is important
    to avoid conflict when a shared system has many contracts from different users
    and operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Transaction Logic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we discussed, `PharmaLedgerContract` will need three business functions
    to move the equipment owner from the manufacturer to the wholesaler, and finally
    pharmacy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The manufacturer will be initialized, and an equipment entry is created. As
    you will notice, these functions accept a context as the default first parameter
    with equipment-related arguments (`manufacturer`, `equipmentNumber`, `equipmentName`,
    `ownerName`) from client input. When `makeEquipment` is called, the function expects
    four equipment attributes from the client and assigns it to new equipment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: At the end of `makeEquipment`, `ctx.stub.putState` will store the equipment’s
    initial state value with the equipment number key on the ledger. The equipment
    JSON data will be stringified using `JSON.stringify`, then converted to a buffer.
    The buffer conversion is required by the shim API to communicate with the peer.
  prefs: []
  type: TYPE_NORMAL
- en: The function uses the JavaScript new `Date` to get the current date time and
    assign it to the `lastUpdated` date time. When transaction data is submitted,
    each peer will validate and commit a transaction.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the equipment record is created by the manufacturer, the wholesaler and
    pharmacy will just need to update ownership to track the current owner. Both functions
    are similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the `wholesalerDistribute` function, we query current equipment ledger data
    by calling `ctx.stub.getState(equipmentNumber)`. Once data returns, we need to
    make sure `equipmentAsBytes` is not empty and `equipmentNumber` is a valid number.
    Since ledger data is in JSON string byte format, that data needs to convert encoded
    data to a readable JSON format by using `Buffer.from().toString('utf8')`. We then
    verify that the current equipment owner type is the manufacturer by using the
    returned data.
  prefs: []
  type: TYPE_NORMAL
- en: Once all these conditions are met, `ctx.stub.putState` is called again. The
    equipment owner state would be updated to the wholesaler with the current timestamp.
    But as an immutable transaction log, all historical changes of the world state
    will permanently store in the ledger. We will define the `queryHistoryByKey` function
    to query all this data in the next step.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `pharmacyReceived` function is similar to `wholesalerDistribute`, so it
    needs to validate that the current owner is the wholesaler and then transfer ownership
    to the pharmacy before updating the equipment record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: After we implement all three equipment business functions, the ledger still
    needs a query function to search current equipment data, and a query history function
    to get all of the historical records.
  prefs: []
  type: TYPE_NORMAL
- en: '`ChaincodeStub` is implemented by the *fabric-shim* library and provides `GetState`
    and `GetHistoryForKey` functions. In our case, the query definition is straightforward:
    we just need to call `ctx.stub.getState` to get the corresponding result.'
  prefs: []
  type: TYPE_NORMAL
- en: '`GetHistoryForKey` returns all historical transaction key values across time.
    We can iterate through these records and convert them to a JSON byte array and
    send the data back as a response. The timestamp tells us when the equipment state
    was updated. Each record contains a related transaction ID and a timestamp:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: That is all for the smart contract function we will implement for our PLN. Next,
    we will compile and deploy the Fabric chaincode.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling and Deploying Fabric Chaincode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have now successfully written our PLN chaincode using JavaScript. Before
    deploying our contract, we need to set up the Fabric network.
  prefs: []
  type: TYPE_NORMAL
- en: To get started with Hyperledger Fabric, we first need to meet some prerequisites.
    We assume you have already installed the software covered in [Part II](part02.xhtml#introduction_to_hyperledger_projects).
    If you haven’t already done so, please install that first.
  prefs: []
  type: TYPE_NORMAL
- en: Install Prerequisites
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before advancing any further, we need to install the following third-party
    tools:'
  prefs: []
  type: TYPE_NORMAL
- en: Linux (Ubuntu)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Git](https://git-scm.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[cURL](https://curl.haxx.se/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Docker and Docker Compose: Docker version 17.06.2-ce or greater is required.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go version 1.14.*x*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Node.js runtime and npm: Node.js version 8 is supported (from 8.9.4 and higher).
    Node.js version 10 is supported (from 10.15.3 and higher).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To set up a network, we generate crypto material for an organization by using
    Cryptogen, create a consortium, and then bring up PLN with Docker Compose. Let’s
    first set up our project.
  prefs: []
  type: TYPE_NORMAL
- en: Review the Project Structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have defined all setup scripts and configuration files for our PLN project;
    the source code can be found on the book’s GitHub page. The project structure
    is organized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Let’s take a look at important configurations.
  prefs: []
  type: TYPE_NORMAL
- en: Cryptogen
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Four crypto configurations are in the *cryptogen* folder for orderer and the
    other three peer organizations. `OrdererOrgs` defines ordering nodes and creates
    an organization definition. `PeerOrgs` defines peers, organization, and managing
    peer nodes.
  prefs: []
  type: TYPE_NORMAL
- en: As we know, running components in the network requires a CA. The Fabric Cryptogen
    tool will use those four crypto configuration files to generate the required X.509
    certificates for all organizations.
  prefs: []
  type: TYPE_NORMAL
- en: 'For `OrdererOrgs`, we define the following crypto configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'For `PeerOrgs`, we define the following crypto configuration for `Org1` (manufacturer).
    The other two orgs are similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We set `EnableNodeOUs` to `true`, which enables the identity classification.
  prefs: []
  type: TYPE_NORMAL
- en: Configtx
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The *configtx.yaml* file will generate `OrdererSystemChannelGenesis` and related
    artifacts by *configtx.yaml* configuration. In the *configtx.yaml* `Organizations`
    section, we define `OrdererOrg` and the other three peer organizations—`Org1`,
    `Org2`, and `Org3`, representing manufacturer, wholesaler, and pharmacy, respectively.
    Each organization will define its `Name`, `ID`, `MSPDir`, and `AnchorPeers`. `MSPDir`
    describes Cryptogen-generated output MSP directories. `AnchorPeers` specifies
    the peer node’s host and port. It updates transactions based on peer policy for
    communication between network organizations and finds all active participants
    of the channel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `Organization Policies` section defines who needs to approve the organization
    resource. In PLN, we use signature policies. For example, we define the `Org2
    Readers` policy next, which allows `Org2` admin, peer, and client to access the
    resource in this node and allows peers to do only transaction endorsement. You
    can define your own policy per your application’s needs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Profiles` section defines how to generate `PharmaLedgerOrdererGenesis`,
    including order configuration and organizations in the PLN consortiums:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Docker
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *docker* folder contains the Docker Compose configuration file, *docker-compose-pln-net.yaml*.
    The Docker Compose tool uses this configuration file to initialize the Fabric
    runtime environment. It defines volumes, networks, and services.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our PLN project, we define our network name as `pln`. We first need to specify
    the Docker runtime environment variable for each organization service. For example,
    we define our blockchain network name as `${COMPOSE_PROJECT_NAME}_pln`. When we
    assign the environment variable `COMPOSE_PROJECT_NAME` a `net` value, the network
    name will be `net_pln`. The container pulls the orderer images as well from *hyperledger/fabric-peer**.*
    The volume configuration maps the directories where MSP, TLS, and other organization
    Fabric parts are used in the environment settings. Finally, `working_dir` sets
    the working directory for the peer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Install Binaries and Docker Images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have reviewed important configurations in order to run the PLN network.
    The *net-pln.sh* script will bring up the PLN network, but we first need to download
    and install Fabric binaries to your system. Under the root project folder is a
    file called *loadFabric.sh*, run the following command to load Fabric binaries
    and configs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This will install the Hyperledger Fabric platform-specific binaries and config
    files into the */bin* and */config* directories under the project. For this project,
    we use the current latest production releases: Fabric v2.1.0 and Fabric CA v1.4.7\.
    Run `docker images -a` to check installed Fabric images.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Make sure all of the scripts in the project are executable. For example, you
    can run `chmod +x loadFabric.sh` to make it executable.
  prefs: []
  type: TYPE_NORMAL
- en: It is now time to start our PLN network.
  prefs: []
  type: TYPE_NORMAL
- en: Start the PLN Network
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we mentioned before, to start the PLN network, we need to complete the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Generate peer organization certificates by using the Cryptogen tool. Here is
    the command for `Org1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The generated output is stored in the *organizations* folder.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create orderer organization identities by using Cryptogen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Generate a common connection profile (CCP) for `Org1`, `Org2`, and `Org3`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*ccp-generate.sh* is under the *organizations* folder. It uses *ccp-template.json*
    and *ccp-template.yaml* files as templates; it defines placeholder variables for
    the org name, peer port, CA port, and CA PEM certificates. By passing these defined
    variables, we can generate org connection files when running *ccp-generate.sh*.
    And *ccp-generate.sh* will also copy generated connection files to the *peer orgs*
    folder:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Each peer web client will use these connection files to connect to the Fabric
    network.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create the consortium and generate an orderer system channel genesis block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`configtxgen` reads the *configtx.yaml* profile and generates the *genesis.block*
    file under the *system-genesis-block* folder.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Bring up the peer and orderer nodes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The *docker-compose* file is defined under *docker/docker-compose-pln-net.yaml*.
    The command will pull the latest Fabric orderer and peer images, build the orderer
    and peer images, and start the services we defined in the *.yaml* file. Run the
    following `docker-compose` command to bring up the peer and orderer nodes:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s bring up the PLN network. Open a terminal window and run *net-pln.sh*
    under the *pharma-ledger-network* folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see the following success log:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have four organizations, including three peers and one orderer, that are
    running in the *net_pln* network. In the next step, we will use the script to
    create a PLN channel for all orgs.
  prefs: []
  type: TYPE_NORMAL
- en: Monitor the PLN Network
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Fabric images in the PLN network are Docker based. During project development
    or the production life cycle, you may encounter many errors. Log monitoring is
    one of the most important things to do from a DevOps standpoint for troubleshooting
    the code. It will help troubleshoot and find the root cause much easier and faster.
  prefs: []
  type: TYPE_NORMAL
- en: 'Logspout is an open source container log tool for monitoring Docker logs. It
    collects Docker’s logs from all nodes in your cluster to be aggregated into one
    place. In our PLN project, we will use Logspout to monitor channel creation, smart
    contract installation, and other actions. Navigate to the *pharma-ledger-network*
    folder and open a new terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Run the following command from the *net-pln.sh* script and start the Logspout
    tool for the containers running on the PLN network *net_pln*:\
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the script logic to bring up the Logspout tool; it pulls *gliderlabs/logspout*
    images by passing the PLN network name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This terminal window will now show the PLN network container output for the
    remainder of the project development.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you run into trouble during this process, check the Logspout terminal window
    to see errors.
  prefs: []
  type: TYPE_NORMAL
- en: Create a PLN Channel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create the channel, we will use the `configtxgen` CLI tool to generate a
    genesis block, and then we’ll use peer channel commands to join a channel with
    other peers. Creating a PLN channel requires several steps. All this script logic
    can be found in *scripts/createChannel.sh*:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Generate a channel configuration transaction file. In the *createChannel.sh*
    script, we define the `createChannelTxn` function. The critical command in this
    function is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `configtxgen` tool reads the profile `PharmaLedgerChannel` section from
    *configtx.yaml*, which defines channel-related configuration to generate the transaction
    and genesis block. It then generates the *plnchannel.tx* file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create an `AnchorPeer` configuration transaction file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we define the `createAncorPeerTxn` function. Similar to the previous
    step, we have defined the different organizational identities in *configtx.yaml*.
    The `configtxgen` tool reads the `PharmaLedgerChannel` organizational configuration
    and generates peer configuration transaction files:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After `createAncorPeerTxn` runs, we should see the *Org1MSPanchors.tx*, *Org2MSPanchors.tx*,
    and *Org3MSPanchors.tx* transaction files generated.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create a channel by using the `peer channel` command. The `createChannel` function
    uses the `peer channel create` command to create our PLN channel. When the command
    is issued, it will submit the channel creation transaction to the ordering service.
    The ordering service will check channel creation policy permissions defined in
    *configtx.yaml*. Only admin users can create a channel. The `setGlobalVars` function
    *scripts/utils.sh* will allow us to set the peer organization as the admin user.
    We use `Org1` as an admin to create our channel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The commands are as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`setGlobalVars` in *scripts/utils.sh* has the following logic for setting `Org1`
    as an admin user. We can also use this function to set other peer organizations
    as admin users:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After our PLN channel has been created, we can join all peers into this channel.
    `joinMultiPeersToChannel` in the *createChannel.sh* script will join all three
    peer orgs into our PLN channel by running the `peer channel join` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When peer organizations join a channel, they need to be assigned as admin users
    by calling the `setGlobalVars` function and passing the `$ORG` parameter to it.
    The `peer channel join` command will use *genesis.block* to join peer orgs to
    the channel. Once the peer is joined to the channel, it can attend channel ledger
    block creation when receiving ordering service transaction submission.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'As the last step in the channel creation process, we need to select at least
    one peer as an anchor peer. An anchor peer’s main role is private data and service
    discovery. The endpoints of the anchor peer are fixed. Other peer nodes belonging
    to different members can communicate with the anchor peers to discover all existing
    peers on a channel. To update an anchor peer, we set a selected peer as an admin
    user and issue a `peer channel update` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can use *net-pln.sh* to create the PLN channel by running the following
    command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once channel creation is completed, you should see the following log:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To see the related container information, you can check the Logspout terminal
    window that we opened earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Running and Testing the Smart Contract
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need to package a smart contract before we can install it to the channel.
    Navigate to the manufacturer contract folder directory and run the `npm install`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This will install the *pharmaledgercontract* node dependency under *node_modules*.
  prefs: []
  type: TYPE_NORMAL
- en: Install the Smart Contract
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we can start installing our smart contract by running the following *deploySmartContract.sh*
    script:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `peer lifecycle chaincode package` command will package our smart contract.
    We assign the manufacturer as an administrator user to run the package command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Install the chaincode on all peer orgs as an admin with the `peer lifecycle
    chaincode install` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When the chaincode package is installed, you will see messages similar to the
    following printed in your terminal:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After we install the smart contract, we need to query whether the chaincode
    is installed. We can query the `packageID` by using the `peer lifecycle chaincode
    queryinstalled` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the command completes successfully, you will see logs similar to the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With the returned package ID, we can now approve the chaincode definition for
    the manufacturer by using `approveForMyOrg`, which calls the `peer lifecycle chaincode
    approveformyorg` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can check whether channel members have approved the same chaincode definition
    by using `checkOrgsCommitReadiness`, which runs the `peer lifecycle chaincode
    checkcommitreadiness` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As expected, we should see approvals for `Org1MSP` as `true`; the other two
    orgs are `false`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The endorsement policy requires a set of majority organizations to endorse
    a transaction before it can commit the chaincode. We continue to run the `peer
    lifecycle chaincode approveformyorg` command for `Org2` and `Org3`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If all commands execute successfully, all three orgs will approve the chaincode
    installation:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we know for sure that the manufacturer, wholesaler, and pharmacy have
    all approved the *pharmaledgercontract* chaincode, we commit the definition. We
    have the required majority of organizations (three out of three) to commit the
    chaincode definition to the channel. Any of the three organizations can commit
    the chaincode to the channel by using the `peer lifecycle chaincode commit` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will use `peer lifecycle chaincode querycommitted` to check the chaincode
    commit status:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we’ve completed the chaincode deployment steps, let’s deploy the *pharmaledgercontract*
    chaincode in our PLN network by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the command is successful, you should see the following response in the
    last few lines:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After the chaincode is installed, we can start to invoke and test the chaincode
    methods for *pharmaledgercontract*.
  prefs: []
  type: TYPE_NORMAL
- en: Test the Smart Contract
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have created *invokeContract.sh* for this project. It defines an invocation
    method for `makeEquipment`, `wholesalerDistribute`, `pharmacyReceived`*,* and
    a query function. Now we can start testing our smart contract for these functions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Call the `makeEquipment` chaincode method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We pass `manufacturer`, `equipmentNumber`, `equipmentName`, and `ownerName`
    as arguments. The script basically calls `peer chaincode invoke` commands by passing
    related function arguments:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will see logs similar to the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After invoking `makeEquipment`, we can run a query function to verify the ledger
    result. The query function uses the `peer chaincode query` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Issue the following script command to query equipment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The query should return current equipment state data:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Continue to invoke the remaining equipment functions for the wholesaler and
    pharmacy:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once equipment ownership is moved to the pharmacy, the supply chain reaches
    its final state. We can issue `queryHistoryByKey` from the `peer chaincode query`
    command. Let’s check equipment historical data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can see the following output in the terminal:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: All of the transaction history records are displayed as output. We have tested
    our smart contract, and it works as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Developing an Application with Hyperledger Fabric Through the SDK
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We just deployed our Pharma Ledger Network in the Fabric network. The next step
    is to build a Pharma Ledger client application to interact with the smart contract
    function in the network. Let’s take a moment to examine the application architecture.
  prefs: []
  type: TYPE_NORMAL
- en: At the beginning of our PLN network section, we generated a CCP for `Org1`,
    `Org2`, and `Org3`. We will use these connection files to connect to our PLN network
    for each peer org. When the manufacturer application’s user Bob submits a `makeEquipment`
    transaction to the ledger, the pharma-ledger process flow starts. Let’s quickly
    examine how our application works ([Figure 7-6](#how_the_pln_application_works)).
  prefs: []
  type: TYPE_NORMAL
- en: '![How the PLN application works](Images/HLF_0706.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-6\. How the PLN application works
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The manufacturer web user Alice connects to the Fabric network through a wallet.
    A wallet provides users an authorized identity that will be verified by the blockchain
    network to ensure access security. The Fabric SDK then submits a `makeEquipment`
    transaction proposal to *peer0.org1.example.com*. Endorsing peers verify the signature,
    simulate the proposal, and invoke the `makeEquipment` chaincode function with
    required arguments.
  prefs: []
  type: TYPE_NORMAL
- en: The transaction is initiated after the proposal response is sent back to the
    SDK. The application collects and verifies the endorsements until the endorsement
    policy of the chaincode is satisfied with producing the same result. The client
    then broadcasts the transaction proposal and proposal response to the ordering
    service.
  prefs: []
  type: TYPE_NORMAL
- en: The ordering service orders them chronologically by channel, creates blocks,
    and delivers the blocks of transactions to all peers on the channel. The peers
    validate transactions to ensure that the endorsement policy is satisfied and to
    ensure that no changes have occurred to the ledger state since the proposal response
    was generated by the transaction execution. After successful validation, the block
    is committed to the ledger, and world states are updated for each valid transaction.
  prefs: []
  type: TYPE_NORMAL
- en: You now understand the transaction end-to-end workflow. It is time to start
    building our pharma-ledger client application. [Figure 7-7](#the_application_client_project_structur)
    shows the application client project structure. The same folder structure is available
    for the wholesaler and pharmacy.
  prefs: []
  type: TYPE_NORMAL
- en: '![The application client project structure](Images/HLF_0707.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-7\. The application client project structure
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We use *express.js* to build our node application. Let’s review some important
    files.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *package.json* file defines two Fabric-related dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '*app.js* defines all entry points for the manufacturer, and `addUser` will
    add a client user for the manufacturer, which in our case is Bob. `makeEquipment`
    will create equipment records when the manufacturer is an owner. `queryByKey`
    and `queryHistoryByKey` are common functions for all three orgs. The wholesaler
    and pharmacy will have similar functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '`addUser` will call `walletsService` to add a user. Let’s take a look at `addToWallet(user)`
    in `walletsService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '`newFileSystemWallet` will create a wallet for an input user (Bob) under the
    provided filesystem directory. Next, we find the user certificate and `privateKey`
    and generate an X.509 certificate to be stored in the wallet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The wallet calls key class methods to manage the `X509WalletMixin.createIdentity`*,*
    which is used to create an Org1MSP identity using X.509 credentials. The function
    needs three inputs: `mspid`, the certificate, and the private key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Users from the manufacturer will call the `equipmentService makeEquipment`
    function. Before any user can call any of the smart contract functions, it needs
    to be authorized. To authorize user access to the blockchain, we need to follow
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Find the user wallet created by adding a user function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Load the connection profile associated with the user. Then the wallet will
    be used to locate and connect to a gateway:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once a gateway is connected to a channel, we can find our *pharmaLedgerContract*
    with a unique namespace when creating a contract:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Submit the `makeEquipment` chain code invocation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To verify that equipment records are stored in the blockchain, we can use Fabric
    query functions to retrieve the result. The following code shows how we can submit
    a `query` or `queryHistory` function to get equipment results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s bring up a manufacturer, create the user Bob, and then submit a transaction
    to our PLN blockchain. Navigate to the *pharma-ledger-network/organizations/manufacturer/application*
    folder and run `npm install`. When we start the application, we also make sure
    to update the client IP address in *plnClient.js* under *public/js*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the manufacturer, we define the application port as 30000:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: Make sure this port is open, or you can change it to another available port
    number under the `app.js` line.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open a browser and enter `**http://your-machine-public-ip:30000**`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will see the screen shown in [Figure 7-8](#adding_a_user_to_the_wallet_for_the_man).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Adding a user to the wallet for the manufacturer](Images/HLF_0708.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 7-8\. Adding a user to the wallet for the manufacturer
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: The default page is *addToWallet*. Since we have added any user to the wallet
    so far, you can’t submit `makeEquipment` and query history transactions at this
    moment. You have to add a user to the wallet. Let’s add Bob as a manufacturer
    user, as shown in [Figure 7-9](#new_user_left_parenthesisbobright_paren).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![New user (Bob) is added](Images/HLF_0709.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 7-9\. New user (Bob) is added
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: With the user wallet set up, the application can now connect to our PLN and
    interact with the chaincode. Click MakeEquipment on the left menu, enter all required
    equipment information, and submit the request ([Figure 7-10](#adding_equipment_to_the_pln_network)).
    The success response will be returned from the blockchain.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Adding equipment to the PLN network](Images/HLF_0710.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 7-10\. Adding equipment to the PLN network
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: We can now query equipment data in the PLN network by equipment number. [Figure 7-11](#query_equipment_on_pln_network)
    shows the result.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Query equipment on PLN network](Images/HLF_0711.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 7-11\. Query equipment on PLN network
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: Now open two other terminal windows, which will bring up node servers for the
    wholesaler and pharmacy, respectively. Navigate *to /pharma-ledger-network/organizations/wholesaler/contract**.*
    Run `npm install` to install the smart contract dependency first.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make sure to update the base URL to [*http://your-machine-public-ip:30001*](http://your-machine-public-ip:30001)
    in *plnClient.js*. Then navigate back to the *pharma-ledger-network/organizations/wholesaler/application*
    folder and run the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add Alice as a wholesaler user ([Figure 7-12](#adding_a_user_left_parenthesisalicerigh))
    and submit a `wholesalerDistribute` request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Adding a user (Alice) to the wholesaler](Images/HLF_0712.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 7-12\. Adding a user (Alice) to the wholesaler
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Follow the same steps by bringing up the pharmacy node server and add Eve as
    a pharmacy user ([Figure 7-13](#adding_a_user_left_parenthesiseveright)). Submit
    a `pharmacyReceived` request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Adding a user (Eve) to the pharmacy](Images/HLF_0713.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 7-13\. Adding a user (Eve) to the pharmacy
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: Now the pharma ledger supply chain flow ends. Bob, Alice, and Eve can query
    equipment data and trace the entire supply chain process by querying historical
    data. Simply go to any user, and on the Query History page, search equipment `**2000.002**`,
    and you should see all query history results, as shown in [Figure 7-14](#querying_equipment_historical_data).
  prefs: []
  type: TYPE_NORMAL
- en: '![Querying equipment historical data](Images/HLF_0714.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-14\. Querying equipment historical data
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to build supply chain DApps with Hyperledger
    Fabric. We have introduced, among other things, how to define a consortium, analyze
    the Pharma Ledger Network life cycle, and trace the equipment’s entire transaction
    history. We spent a lot of time writing chaincode as a smart contract, including
    the logic for the manufacturer, wholesaler, and pharmacy. After setting up a pharma
    ledger Fabric network environment, we installed and deployed our smart contract
    to blockchain step by step.
  prefs: []
  type: TYPE_NORMAL
- en: We tested a smart contract function through a command-line script to make sure
    that all functions we defined work as expected. With this work completed, we started
    to work on a UI page, where you learned how to add users into a wallet and connect
    to the Fabric blockchain through SDK. We also built UI pages for the manufacturer,
    wholesaler, and pharmacy, allowing users in these organizations to submit related
    requests to invoke the smart contract in the PLN blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see that it is quite a lot of work to build the end-to-end Hyperledger
    Fabric application. So we hope you are not tired because in the next chapter we
    will explore another exciting topic: deploying Hyperledger Fabric on the cloud.'
  prefs: []
  type: TYPE_NORMAL
