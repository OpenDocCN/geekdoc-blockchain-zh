- en: © The Author(s), under exclusive license to APress Media, LLC, part of Springer
    Nature 2022J. T. GeorgeIntroducing Blockchain Applications[https://doi.org/10.1007/978-1-4842-7480-4_11](https://doi.org/10.1007/978-1-4842-7480-4_11)
  prefs: []
  type: TYPE_NORMAL
- en: 11. Engineering Based on Models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Joseph Thachil George^([1](#Aff2)  )(1)Rome, Italy
  prefs: []
  type: TYPE_NORMAL
- en: Engineering-based models is an application development technique that prioritizes
    the creation of models or abstractions that are more closely related to specific
    domain notions than computational or algorithmic principles. This technique boosts
    productivity by optimizing system compatibility, simplifies the design process,
    and fosters individual and team communication and collaboration on the system.
  prefs: []
  type: TYPE_NORMAL
- en: Models allow technical and non-technical stakeholders to have the same vision
    and understanding, as well as promote and encourage interaction between them.
    Models also help with project planning by providing a clearer view of the system
    to be built and enabling for managing projects based on objective criteria.
  prefs: []
  type: TYPE_NORMAL
- en: 11.1 Model-Driven Approach to Blockchain
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In recent years, the notion of blockchain has acquired great traction in practice
    and research, as it offers a practical solution to the problems of anonymity and
    accountability in dispersed situations involving numerous parties that must share
    data and cooperate securely. However, the influence of business core network and
    configuration on successfully using blockchain technology remains largely unknown
    to date. This book offers a model-driven method that captures the features of
    current blockchain-driven business networks by combining an ontology with a layer
    model.
  prefs: []
  type: TYPE_NORMAL
- en: The levels help describe such networks in detail. The Blockchain Business Network
    Ontology (BBO) is also introduced, which formalizes the ideas and characteristics
    of the various components of a blockchain network. I demonstrate the usefulness
    of this work by assessing and applying it to a real-world blockchain use case.
  prefs: []
  type: TYPE_NORMAL
- en: To develop the blockchain business model, you need to have the approach of *model-driven
    engineering*.
  prefs: []
  type: TYPE_NORMAL
- en: 11.2 Model-Driven Development
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By bringing together diverse viewpoints with varied degrees of abstraction,
    a model-based method aids in the understanding of a system. “A client is able
    to build on a model that includes a system’s features and characteristics, which
    can then be used to completely rebuild the system in this context.” Following
    a model-driven architecture or design helps in a variety of ways to comprehend
    and describe a system.^([1](#Fn1))
  prefs: []
  type: TYPE_NORMAL
- en: The links between the various parts, as well as their descriptions, contribute
    to a broad knowledge of the system, while also assisting in the development of
    scalable solutions, because a model is built on a well-defined nomenclature and
    taxonomy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To make the development of a system easier, an architectural frame may be used
    to mix and modify multiple models and explanatory levels.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automat may be used for a group of formalized metamodels, which can then be
    merged and converted into models with a greater degree of information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical standards are a necessary basis for expanding model-based effort acceptability
    and implementation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 11.2.1 The Blockchain Layer Model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Creating various models that specifically address diverse elements of a larger
    system aids in the development of a thorough knowledge of that system or phenomena.
    “Various levels of abstraction may be examined using these models, which can then
    be overlaid onto each other or whose information transmitted to other levels in
    order to comprehend the full scope of a concept.”¹
  prefs: []
  type: TYPE_NORMAL
- en: As a result, three fundamental layers (see Figure [11-1](#Fig1)) have been defined
    to make it easier to describe blockchain-driven networks in a sound and comprehensive
    manner. These layers include everything from a business model perspective to a
    code-based viewpoint. All of these levels are essential because we anticipate
    blockchain technology to have a unique impact on each of them.
  prefs: []
  type: TYPE_NORMAL
- en: Because the layers are interrelated, the technological implementation has an
    impact on the network composition, which has an effect on the business model.
    Figure [11-1](#Fig1) is an example of layered blockchain.![../images/520777_1_En_11_Chapter/520777_1_En_11_Fig1_HTML.jpg](../images/520777_1_En_11_Chapter/520777_1_En_11_Fig1_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11-1
  prefs: []
  type: TYPE_NORMAL
- en: Blockchain layers
  prefs: []
  type: TYPE_NORMAL
- en: In order to create a model-driven method for defining blockchain transactions
    and blocks layers, you’ll see how to build on these foundations with the help
    of models and metamodels.
  prefs: []
  type: TYPE_NORMAL
- en: 11.2.2 Models and Metamodels
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This section covers the fundamental ideas that underpin MDE, such as system,
    model, metamodel, as well as their relationships.
  prefs: []
  type: TYPE_NORMAL
- en: The *system* is defined in the context of MDE as “a general notion for denoting
    a software application, software platform, or other software artefact.” ^([2](#Fn2))
    A system can also be built up of various subsystems, as illustrated in Figure
    [11-2](#Fig2), and it can interact with other systems. (Systems may interact with
    other systems.)
  prefs: []
  type: TYPE_NORMAL
- en: 'A model is an abstraction of phenomena in the real world: a metamodel is a
    further abstraction, which highlights properties of the model itself. A model
    conforms to its metamodel in the same way that a computer program conforms to
    the grammar of the programming language in which it is written.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Domains where metamodels are used:'
  prefs: []
  type: TYPE_NORMAL
- en: A schema for semantic data that needs to be exchanged or stored
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A language that supports a particular method or process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A language to express additional semantics to existing information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following sections cover the details of models and metamodels.![../images/520777_1_En_11_Chapter/520777_1_En_11_Fig2_HTML.jpg](../images/520777_1_En_11_Chapter/520777_1_En_11_Fig2_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11-2
  prefs: []
  type: TYPE_NORMAL
- en: System definition
  prefs: []
  type: TYPE_NORMAL
- en: 11.2.3 The Model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *model* depicts a system that might or might not exist today or in the future.
    It’s a term of reference considered valid as an example or prototype and worthy
    of imitation.
  prefs: []
  type: TYPE_NORMAL
- en: 'A model is worth considering since it includes the following details:'
  prefs: []
  type: TYPE_NORMAL
- en: A model can be a collection of assertions about the device/system which goes
    into the investigation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A model is the simplest version of a system that was formed with a specific
    goal in mind, and it should be capable of answering queries in place of the actual
    system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A model is a simplified edition of a system that was formed with a particular
    objective in mind, and it can reply to the queries for the real program.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A model, on the other hand, is a system in and of itself, with its own identity,
    complexity, constituents, linkages, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: In particular, while considering a model of a model, you must keep in mind that
    one of them serves as a model of a model and, as a result, is a *system*. In summary,
    “model” is a system that helps describe and provide answers to the system under
    study without having to look at it directly, as shown in Figure [11-3](#Fig3).![../images/520777_1_En_11_Chapter/520777_1_En_11_Fig3_HTML.jpg](../images/520777_1_En_11_Chapter/520777_1_En_11_Fig3_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11-3
  prefs: []
  type: TYPE_NORMAL
- en: Relationships between a model and a system
  prefs: []
  type: TYPE_NORMAL
- en: There is also a relationship between the model and the system. With the help
    of models, you can design a system. By looking at models, you can understand how
    the system works. On the other hand, you can make a number of models based on
    the system architecture. That is the reason you can say that a model is a simplified
    edition of a system, and it is formed with a particular goal in the mind.¹
  prefs: []
  type: TYPE_NORMAL
- en: 11.2.4 The Metamodel
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *metamodel* is a type of model that specifies the architecture of a modeling
    language, based on prior research. However, the following facts must be understood
    from Figure [11-4](#Fig4).![../images/520777_1_En_11_Chapter/520777_1_En_11_Fig4_HTML.jpg](../images/520777_1_En_11_Chapter/520777_1_En_11_Fig4_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11-4
  prefs: []
  type: TYPE_NORMAL
- en: Relationships between a metamodel and a model
  prefs: []
  type: TYPE_NORMAL
- en: We can say that the modeling language will be a set of models, as defined by
    the relationship *Element Of*  between *model* and *modeling language* (or a model
    is an element of a modeling language).
  prefs: []
  type: TYPE_NORMAL
- en: We can also say that this approach draws its rules from the distinction between
    the concept of a model and that of a metamodel.
  prefs: []
  type: TYPE_NORMAL
- en: 'A UML model  is a representation that captures the important aspects of everything
    you want to model, from a certain point of view and under certain limitations.
    A model is structured in diagrams (UML diagrams), which represent the graphic
    means of expression. The model consists of three basic parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Classifiers** **:** They describe a set of objects. An object is an individual
    entity with a state and relationships with other objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Events (Events):** They describe a set of possible occurrences. An occurrence
    is something that happens and has consequences within the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Actions (Behaviors**): They describe a set of possible executions. An execution
    represents the fulfillment of an algorithm in accordance with a set of rules*.*^([3](#Fn3))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UML diagrams, on the other hand, contain graphic elements that represent elements
    of the model. For example, two associated classes defined within a package diagram
    are two types of classifiers and are represented by two rectangular symbols and
    a link representing the association symbol.
  prefs: []
  type: TYPE_NORMAL
- en: 11.3 Building the Metamodel and Model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'How to build the first metamodel is a well-known and recurrent metamodel problem.
    The official OMG specification describes the semantics of UML by breaking down
    the architecture in the package. Within each package, the elements of the model
    are defined in the following terms in a semiformal way:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Abstract-syntax** **:** Presented, through class diagrams expressed with
    the UML notation, the UML metamodel, its concepts (i.e. meta-classes), and its
    relationships and constraints. To these are added parts of text written in natural
    language (English).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Connotation** **:** Provided in natural language, it includes the description
    of elements that make up the UML metamodel and their relationships.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Formedness rules** **:** The rules and constraints to define models that
    are valid. These are expressed using both a formal language, OCL, and natural
    language.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The complexity of the UML metamodel is managed by organizing it into three
    packages: Foundation, Behavioral Elements, and Model Management. The first two
    are further decomposed into packages, each of which contains semantically related
    elements. Here is a brief description of each package:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Behavioral Elements** **:** This package specifies the structure needed to
    define the dynamic behaviors of a model. It consists of five subpackages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Foundation:** This package represents the language infrastructure that specifies
    the structure static modeling. It is divided into three subpackages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Model Management:** This package defines, among others, the model, package
    and subsystem necessary to organize different models and to group together elements
    that have features in common.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 11.4 A Modeling Language’s Category
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'According to professionals, there are some other ways you can define modeling
    languages. They say a modeling language may be divided into two types: specific
    and domain-specific. They are differentiated by a higher number of generic constructs,
    which facilitates their application in a variety of areas.'
  prefs: []
  type: TYPE_NORMAL
- en: Because they provide comprehensive collection of structures and marking for
    defining and explaining software applications based on the object-oriented paradigm,
    or any type of system as defined by the system engineering discipline, UML and
    SysML are popular instances of specific and domain specific.¹
  prefs: []
  type: TYPE_NORMAL
- en: DSLs, on the other hand, typically use a smaller set of structures or ideas
    that are more directly connected to the application area. Because a DSL is defined
    using domain concepts, it is typically easier to understand, grasp, validate,
    and interact with, facilitating collaboration between developers and domain specialists.
    Some argue that DSLs can improve productivity, dependability, reliability, and
    portability.¹
  prefs: []
  type: TYPE_NORMAL
- en: Yet, there are also drawbacks to adopting a DSL, such as the expense of learning,
    creating, and sustaining a contemporary language, as well as the production tools
    needed to use it.![../images/520777_1_En_11_Chapter/520777_1_En_11_Fig5_HTML.jpg](../images/520777_1_En_11_Chapter/520777_1_En_11_Fig5_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11-5
  prefs: []
  type: TYPE_NORMAL
- en: Modeling language
  prefs: []
  type: TYPE_NORMAL
- en: Others, argue that, because of the high quality and complexity of today’s language
    workstations, tool support is no longer a significant obstacle.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, findings suggest that software language engineers would not even
    evaluate their native languages, implying that additional study in the subject
    of software language processes, especially in the development of design, implementation,
    and assessment, is necessary.¹
  prefs: []
  type: TYPE_NORMAL
- en: As illustrated in Figure [11-6](#Fig6), a modeling language may be classified
    by its software architecture attributes and organized by one or more views.![../images/520777_1_En_11_Chapter/520777_1_En_11_Fig6_HTML.jpg](../images/520777_1_En_11_Chapter/520777_1_En_11_Fig6_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11-6
  prefs: []
  type: TYPE_NORMAL
- en: Categorizing a modeling language and the perspectives that go with it
  prefs: []
  type: TYPE_NORMAL
- en: 11.5 Designing a Metamodel for CPSs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CPSs are complicated systems that monitor and regulate the physical environment
    while also assisting humans in their duties.
  prefs: []
  type: TYPE_NORMAL
- en: CPS are networked hybrid systems that combine software and hardware. As programmers,
    engineers, and scientists collaborate to build and implement such systems, they
    run into obstacles. Experts from many fields must comprehend the system in order
    to collaborate, regardless of their field.
  prefs: []
  type: TYPE_NORMAL
- en: We suggest a cyber-physical systems metamodel and an educational research method
    that programmers, engineers, and scientists can use, reuse, and modify for new
    applications of cyber-physical systems.
  prefs: []
  type: TYPE_NORMAL
- en: Data scientists and programmers utilize this metamodel to build a cyber-physical
    system that provides M1 system models that are understandable across fields. The
    metamodel includes both smart things and humans, which are often present in any
    cyber-physical system’s design. It uses a composite architecture to enable the
    creation of cyber-physical systems with smart elements like leaf nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 11.6 CPS Metamodel Examples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Transportation**: System for air traffic control and transportation management.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Health, medical:** Medical gadgets, health monitoring systems, telerobotic
    surgical-systems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Manufacturing**: Automobiles, airplanes, factory automation systems, chemical
    process tracking, autonomous robotic spaces, and industry networks are all examples
    of industrial networks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Environmental**: Farming, environmental, and geological systems are all examples
    of environmental science systems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Aerospace**: Space exploration systems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Buildings**: Assistive living and smart places in everyday life.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Public environment**: Intelligent water supply networks and emergency management.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cyber-physical public systems**: These are CPSs that also consider human
    understanding, technological capabilities, and sociocultural factors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *meta-object facility* is introduced in the following section, backed by
    a base-metamodel for cyber-physical systems.
  prefs: []
  type: TYPE_NORMAL
- en: 11.6.1 Meta-Object Facility
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The meta-object facility is a standard for model-driven engineering of the Object
    Management Group. This comes from the UML language; Object Management Group needed
    a metamodeling architecture to define UML.^([4](#Fn4))
  prefs: []
  type: TYPE_NORMAL
- en: It uses object-modeling methods to define any form of metadata. Even though
    it is usually associated with UML, it is independent from it.
  prefs: []
  type: TYPE_NORMAL
- en: To specify any type of metadata, MOF uses object modeling techniques. Even though
    it is sometimes confused with UML, it is not the same thing.
  prefs: []
  type: TYPE_NORMAL
- en: We use the stereotype mechanism of UML to create and expand intelligent objects
    on the CPS metamodel. M1-defined classes can be extended and reused utilizing
    the metamodel as a basis. A system is represented by these classes. The top-level
    design of an application on M1 is referred to as top-level design.
  prefs: []
  type: TYPE_NORMAL
- en: A *system-of-systems* (SoS) is a combination of a finite set of independent
    and operable constituent systems that are networked together for a length of time
    in order to achieve a higher purpose. An SoS integrates CSs.![../images/520777_1_En_11_Chapter/520777_1_En_11_Fig7_HTML.jpg](../images/520777_1_En_11_Chapter/520777_1_En_11_Fig7_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11-7
  prefs: []
  type: TYPE_NORMAL
- en: A categorization of a modeling language and the perspectives that go with it
  prefs: []
  type: TYPE_NORMAL
- en: A *constituent system* includes a computer network (the cybersystem), a controlled
    item (the physical system), and perhaps human interaction.
  prefs: []
  type: TYPE_NORMAL
- en: 'An SoS could be:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Directed SoS:** An SoS having a centralized purpose and ownership of all
    CSs. A collection of control systems in an unmanned rocket is an example.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![../images/520777_1_En_11_Chapter/520777_1_En_11_Fig8_HTML.jpg](../images/520777_1_En_11_Chapter/520777_1_En_11_Fig8_HTML.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-8
  prefs: []
  type: TYPE_NORMAL
- en: An SoS integrates a CS
  prefs: []
  type: TYPE_NORMAL
- en: '![../images/520777_1_En_11_Chapter/520777_1_En_11_Fig9_HTML.jpg](../images/520777_1_En_11_Chapter/520777_1_En_11_Fig9_HTML.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-9
  prefs: []
  type: TYPE_NORMAL
- en: An SoS
  prefs: []
  type: TYPE_NORMAL
- en: '**Recognized SoS** **:** CSs are owned independently, but there are cooperative
    agreements among the owners to achieve a common goal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Collaboration SoS** **:** Volunteer interactions among independent CSs with
    the objective of achieving a goal that benefits the individual CS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Virtual SoS** **:** Core alignment and lack of a primary purpose.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each CS has an interface based on which services are made available to other
    CSs, such as Reliable Interface (RUI), which serves as a CS’s interface via which
    the CS’s services are made available to other CSs.
  prefs: []
  type: TYPE_NORMAL
- en: 'RUIs are made up of the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: Relied Upon Message Interface (RUMI)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Relied Upon Physical Interface (RUPI)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![../images/520777_1_En_11_Chapter/520777_1_En_11_Fig10_HTML.jpg](../images/520777_1_En_11_Chapter/520777_1_En_11_Fig10_HTML.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-10
  prefs: []
  type: TYPE_NORMAL
- en: SOS and CS
  prefs: []
  type: TYPE_NORMAL
- en: '![../images/520777_1_En_11_Chapter/520777_1_En_11_Fig11_HTML.jpg](../images/520777_1_En_11_Chapter/520777_1_En_11_Fig11_HTML.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-11
  prefs: []
  type: TYPE_NORMAL
- en: RUMI and RUPI
  prefs: []
  type: TYPE_NORMAL
- en: 11.7 Review Questions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: “Model-driven engineering is a software development approach that emphasizes
    the creation of models or abstractions that are closer to specific domain notions
    than computational or algebraic concepts.” Is this statement correct or incorrect?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 2.The modeling language is established by which of the following?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: By a collection of all possible models that correspond to the metamodel in issue,
    which is referred to as a metamodel.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: b.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: By a metamodel, which is a collection of models that adhere to the metamodel
    in question.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: c.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: By the metamodel, which is a collection of all feasible models that adhere to
    a certain metastate.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: d.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: None of the above.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 3.Which of the following statements is correct for *event*?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Virtual SoS is characterized by the absence of a core goal and central alignment.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: b.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Virtual SoS has a lack of purpose and central alignment.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: c.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Virtual SoS is characterized by a lack of focus and alignment.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: d.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: All of these.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '4.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: “Metamodels include UML and the Common Warehouse metamodel.” Is this statement
    correct or incorrect?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 11.8 Review Answers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Answer: Correct, Model-driven engineering is a software development methodology
    that focuses on the construction of models or abstractions that are more closely
    related to specific domain concepts than computational or algebraic concepts.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Answer: A, A collection of all possible models that correspond to the metamodel
    in issue is referred to as a metamodel.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '3.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Answer: A, A virtual SoS is characterized by the absence of a core goal and
    central alignment.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '4.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Answer: Correct, UML and the Common Warehouse Metamodel are examples of metamodels.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 11.9 Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ever since humans started using computers, researchers have worked to raise
    the level of abstraction. Model-driven engineering (MDE) is the natural continuation
    of this trend, as well as a promising approach to address complexity of platforms
    and the inability of third-generation languages to alleviate this complexity and
    express dominance concepts effectively.
  prefs: []
  type: TYPE_NORMAL
- en: The Model-Driven Engineering (MDE) is at the top of the hierarchy and therefore
    the most abstract. It is recognized as a software engineering paradigm and considers
    models not only as supporting documentation, but also as a central focus of development
    in any engineering discipline and application domain. Model-Driven Development
    (MDD) is slightly lower in the hierarchy than MDE. This approach focuses on the
    disciplines of analysis, design, implementation, and requirements.
  prefs: []
  type: TYPE_NORMAL
- en: The concrete MDD approaches tend to define modeling languages to specify the
    system under study at different levels of abstraction. Model-Based Testing (MBT)
    is focused on the automation of the testing discipline. Testing models are used
    to represent the desired behavior of the system under study. Model-Driven Architecture
    (MDA) is an approach proposed by OMG and is mainly focused on the definition of
    models and their transformations.
  prefs: []
  type: TYPE_NORMAL
- en: To create an effective block chain application, systems must first be modeled.
    The previously-mentioned technique must be included when modeling systems. When
    you apply blockchain technology in the distributed system, as part of the modeling
    of distributed systems, you also need to model the blockchain layers in order
    to have a clear picture of the system architecture and systems of systems (SoS)
    functionality. All these models can be done with the help of the BLOCKLY 4SOS
    modeling technique.
  prefs: []
  type: TYPE_NORMAL
- en: As a part of model driven engineering, you need to consider BLOCKLY 4SOS to
    model SOS systems. The next chapter explains the BLOCKLY 4SOS.
  prefs: []
  type: TYPE_NORMAL
