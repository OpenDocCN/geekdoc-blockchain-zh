- en: © Bikramaditya Singhal, Gautam Dhameja, Priyansu Sekhar Panda 2018Bikramaditya Singhal,
    Gautam Dhameja and Priyansu Sekhar PandaBeginning Blockchain[https://doi.org/10.1007/978-1-4842-3444-0_2](A440588_1_En_2_Chapter_split_000.xhtml)
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: © 比克拉马迪亚·辛格尔，高塔姆·达梅贾，普里亚尼斯库·塞卡·潘达 2018比克拉马迪亚·辛格尔，高塔姆·达梅贾和普里亚尼斯库·塞卡·潘达区块链入门[https://doi.org/10.1007/978-1-4842-3444-0_2](A440588_1_En_2_Chapter_split_000.xhtml)
- en: 2. How Blockchain Works
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2. 区块链是如何工作的
- en: Bikramaditya Singhal^(1 ), Gautam Dhameja² and Priyansu Sekhar Panda¹(1)Bangalore,
    Karnataka, India(2)Berlin, Berlin, GermanyWe stand at the edge of a new digital
    revolution. Blockchain probably is the biggest invention since the Internet itself!
    It is the most promising technology for the next generation of Internet interaction
    systems and has received extensive attention from many industry sectors as well
    as academia. Today, many organizations have already realized that they needed
    to be blockchain ready to sustain their positions in the market. We already looked
    at a few use cases in Chapter [1](A440588_1_En_1_Chapter.xhtml), but the possibilities
    are limitless. Though blockchain is not a silver bullet for all business problems,
    it has started to impact most business functions and their technology implementations.To
    be able to solve some real-world business problems using blockchain, we actually
    need a fine-grained understanding of what it is and how it works. For this, it
    needs to be understood through different perspectives such as business, technical,
    and legal viewpoints. This chapter is an effort to get into the nuts and bolts
    of blockchain technology and get a complete understanding of how it works.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 比克拉马迪亚·辛格尔^(1 )，高塔姆·达梅贾^(2 )，普里亚尼斯库·塞卡·潘达^(1 )（1）班加罗尔，卡纳塔克邦，印度（2）柏林，柏林，德国我们正站在一场新的数字革命边缘。区块链或许是自互联网本身以来最大的发明！它是下一代互联网交互系统最具前景的技术，并已引起许多行业部门以及学术界的广泛关注。今天，许多组织已经意识到他们需要准备好区块链以维持其在市场中的地位。我们在第[1](A440588_1_En_1_Chapter.xhtml)章中已经看了一些用例，但可能性无穷无尽。尽管区块链不是解决所有商业问题的银弹，但它已经开始影响大多数商业功能及其技术实施。为了能够使用区块链解决一些现实世界的商业问题，我们实际上需要对区块链的本质和运作方式有一个精细的了解。为此，需要从商业、技术和法律等多个视角来理解区块链。本章将努力深入探讨区块链技术的核心细节，并全面了解其运作方式。
- en: Laying the Blockchain Foundation
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 奠定区块链基础
- en: Blockchain is not just a technology, it is mostly coupled with business functions
    and use cases. In its cryptocurrency implementations, it is also interwoven with
    economic principles. In this section, we will mainly focus on its technical aspects.
    Technically, blockchain is a brilliant amalgamation of the concepts from cryptography,
    game theory, and computer science engineering, as shown in Figure [2-1](A440588_1_En_2_Chapter_split_000.xhtml#Fig1).![A440588_1_En_2_Fig1_HTML.jpg](Images/A440588_1_En_2_Fig1_HTML.jpg)Figure
    2-1Blockchain at its coreLet us take a look at what role these components play
    in the blockchain system at a high level and dig deeper into the fundamentals
    eventually. Before that, let us quickly revisit how the traditional centralized
    systems worked. The traditional approach was that there would be a centralized
    entity that would maintain just one transaction/modification history. This was
    to exercise concurrency control over the entire database and inject trust into
    the system through intermediaries. What was the problem with such a stable system
    then? A centralized system has to be trusted, whether those involved are honest
    or not! Also, cost due to intermediaries and the transaction time could be greater
    for obvious reasons. Now think about the centralization of power; having full
    control of the entire system enables the centralized authorities to do almost
    anything they want.Now, let us look at how blockchain addresses these issues due
    to centralized intermediaries by using cryptography, game theory, and computer
    science concepts. Irrespective of the use case, the transactions are secured using
    cryptography. Using cryptography, it can be ensured that a valid user is initiating
    the transaction and no one can forge a fraudulent transaction. This means, cryptographically
    it can be ensured that Alice in no way can make a transaction on behalf of Bob
    by forging his signature. Now, what if a node or a user tries to launch a double-spend
    attack (e.g., one has just ten bucks and tries to pay the same to multiple people)?
    Pay close attention here—despite not having sufficient funds, one can still initiate
    a double-spend, which is cryptographically correct. The only way to prevent double-spend
    is for every node to be aware of all the transactions. Now this leads to another
    interesting problem. Since every node should maintain the transaction database,
    how can they all agree on a common database state? Again, how can the system stay
    immune to situations where one or more computing nodes deliberately attempt to
    subvert the system and try to inject a fraudulent database state? The majority
    of such problems come under the umbrella of the Byzantine Generals’ Problem (described
    later). Well, it gained even more popularity because of blockchain, but it has
    been there for ages. If you look at the data center solutions, or distributed
    database solutions, the Byzantine Generals’ Problem is an obvious and common problem
    that they deal with to remain fault tolerant. Such situations and their solution
    actually come from game theory. The field of game theory provides a radically
    different approach to determine how a system will behave. The techniques in game
    theory are arguably the most sophisticated and realistic ones. They usually never
    consider if a node is honest, malicious, ethical, or has any other such characteristics
    and believe that the participants act according to the advantage they get, not
    by moral values. The sole purpose of game theory in blockchain is to ensure that
    the system is stable (i.e., in Nash Equilibrium) with consensus among the participants.There
    are different kinds of business problems and situations with varying degrees of
    complexities. So, the underlying crypto and game theoretic consensus protocols
    could be different in different use cases. However, the general principle of maintaining
    a consistent log or database of verified transactions is the same. Though the
    concepts of cryptography and game theory have been around for quite some time
    now, it is the computer science piece that stitches these bits and pieces together
    through data structures and peer-to-peer network communication technique. Obviously,
    it is the “smart software engineering” that is needed to realize any logical or
    mathematical concepts in the digital world. It is then the computer science engineering
    techniques that incorporate cryptography and game theoretic concepts into an application,
    enabling decentralized and distributed computing among the nodes with data structure
    and network communication components.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链不仅仅是一项技术，它大多与商业功能和用例相结合。在其加密货币实现中，它还与经济原则交织在一起。在本节中，我们将主要关注其技术方面。从技术上讲，区块链是将密码学、博弈论和计算机科学工程的概念巧妙结合在一起的一个杰作，如图[2-1](A440588_1_En_2_Chapter_split_000.xhtml#Fig1)所示。![A440588_1_En_2_Fig1_HTML.jpg](Images/A440588_1_En_2_Fig1_HTML.jpg)图2-1区块链的核心让我们从高层次上看看这些组件在区块链系统中的作用，并最终深入到基本原理。在此之前，让我们快速回顾一下传统集中式系统是如何工作的。传统的方法是，将有一个集中的实体来维护一个交易/修改历史。这是为了对整个数据库进行并发控制，并通过中介注入信任。那么这样一个稳定的系统有什么问题呢？一个集中式系统必须被信任，无论涉及的人是否诚实！此外，由于中介和交易时间造成的成本可能更大。现在想想权力的集中；拥有整个系统的完全控制权，使集中式权威能够做几乎任何他们想做的事情。现在，让我们来看看区块链是如何利用密码学、博弈论和计算机科学概念解决这些由于集中式中介而产生的问题的。无论用例如何，交易都使用密码学进行保护。利用密码学，可以确保一个有效的用户正在发起交易，没有人能伪造欺诈性交易。这意味着，从密码学上可以确保爱丽丝绝对不能通过伪造鲍勃的签名来代表他进行交易。那么，如果一个节点或用户试图发起双重支付攻击（例如，一个人只有10美元，却试图付给多个人）会怎样？在这里仔细注意——尽管资金不足，仍然可以发起双重支付，这在密码学上是正确的。防止双重支付的唯一方法是让每个节点都知道所有的交易。现在，这导致了一个有趣的问题。既然每个节点都应该维护交易数据库，他们如何达成对共同数据库状态的共识？再次，系统如何对一种或多种计算节点故意试图破坏系统并尝试注入欺诈性数据库状态的情况保持免疫？绝大多数这类问题都属于拜占庭将军问题（稍后描述）。嗯，它因为区块链而变得更加流行，但它已经存在很长时间了。如果你看看数据中心解决方案，或分布式数据库解决方案，拜占庭将军问题是它们为保持容错性而处理的明显和常见问题。这些情况和它们的解决方案实际上来自博弈论。博弈论领域提供了一种截然不同的方法来确定系统将如何行为。博弈论中的技术是有争议的最复杂和最现实的技术。它们通常从不考虑一个节点是否诚实、恶意、道德或有其他任何特征，并相信参与者根据他们获得的优势行动，而不是根据道德价值观。博弈论在区块链中的唯一目的是确保系统稳定（即纳什均衡）并获得参与者之间的共识。不同的商业问题和情况有不同的复杂程度。因此，不同用例下的底层密码学和博弈论共识协议可能会有所不同。然而，保持一致的经过验证的交易日志或数据库的原则是相同的。尽管密码学和博弈论的概念已经存在很长时间了，但正是计算机科学部分通过数据结构和点对点网络通信技术将这些零散的部分缝合在一起。显然，实现数字世界中任何逻辑或数学概念所需的“智能软件工程”是必不可少的。然后，计算机科学工程技术将密码学和博弈论概念融入应用程序中，使用数据结构和网络通信组件使节点之间实现去中心化和分布式计算。
- en: Cryptography
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 密码学
- en: 'Cryptography is the most important component of blockchain. It is certainly
    a research field in itself and is based on advanced mathematical techniques that
    are quite complex to understand. We will try to develop a solid understanding
    of some of the cryptographic concepts in this section, because different problems
    may require different cryptographic solutions; one size never fits all. You may
    skip some of the details or refer to them as and when needed, but it is the most
    important component to ensure security in the system. There have been many hacks
    reported on wallets and exchanges due to weaker design or poor cryptographic implementations.Cryptography
    has been around for more than two thousand years now. It is the science of keeping
    things confidential using encryption techniques. However, confidentiality is not
    the only objective. There are various other usages of cryptography as mentioned
    in the following list, which we will explore later:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 密码学是区块链最重要的组成部分。它当然是一个自身的研究领域，并且基于先进的数学技术，这些技术相当复杂难以理解。我们将在本节中尝试深入了解一些密码学概念，因为不同的问题可能需要不同的密码学解决方案；一种尺寸从未适合所有人。您可能可以跳过一些详细信息或按需参考，但这是确保系统安全的最重要组成部分。由于设计薄弱或密码学实现不当，钱包和交易所已经报道了许多黑客攻击。密码学已经有两千多年的历史了。它是使用加密技术保持事物机密的科学。然而，机密性并不是唯一的目标。密码学的各种其他用途如以下列表所示，我们将在稍后探索：
- en: 'Confidentiality : Only the intended or authorized recipient can understand
    the message. It can also be referred to as privacy or secrecy.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机密性：只有预期的或授权的接收者才能理解信息。它也可以被称为隐私或秘密。
- en: 'Data Integrity : Data cannot be forged or modified by an adversary intentionally
    or by unintended/accidental errors. Though data integrity cannot prevent the alteration
    of data, it can provide a means of detecting whether the data was modified.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据完整性：数据不能被对手有意或因无意/意外错误而伪造或修改。尽管数据完整性不能防止数据的更改，但它可以提供一种检测数据是否被修改的方法。
- en: 'Authentication : The authenticity of the sender is assured and verifiable by
    the receiver.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证：发送者的真实性得到保证，并可以被接收者验证。
- en: 'Non-repudiation : The sender, after sending a message, cannot deny later that
    they sent the message. This means that an entity (a person or a system) cannot
    refuse the ownership of a previous commitment or an action.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可否认性：发送者发送信息后，不能否认他们发送了该信息。这意味着一个实体（一个人或一个系统）不能拒绝先前的承诺或行为的所有权。
- en: 'Any information in the form of a text message, numeric data, or a computer
    program can be called plaintext. The idea is to encrypt the plaintext using an
    encryption algorithm and a key that produces the ciphertext. The ciphertext can
    then be transmitted to the intended recipient, who decrypts it using the decryption
    algorithm and the key to get the plaintext.Let us take an example. Alice wants
    to send a message (m) to Bob. If she just sends the message as is, any adversary,
    say, Eve can easily intercept the message and the confidentiality gets compromised.
    So, Alice wants to encrypt the message using an encryption algorithm (E) and a
    secret key (k) to produce the encrypted message called “ciphertext.” An adversary
    has to be aware of both the algorithm (E) and key (k) to intercept the message.
    The stronger the algorithm and the key, the more difficult it is for the adversary
    to attack. Note that it would always be desirable to design blockchain systems
    that are at least provably secure. What this means is that a system must resist
    certain types of feasible attacks by adversaries.The common set of steps for this
    approach can be represented as shown in Figure [2-2](A440588_1_En_2_Chapter_split_000.xhtml#Fig2).![A440588_1_En_2_Fig2_HTML.jpg](Images/A440588_1_En_2_Fig2_HTML.jpg)Figure
    2-2How Cryptography works in generalBroadly, there are two kinds of cryptography:
    symmetric key and asymmetric key (a.k.a. public key) cryptography. Let us look
    into these individually in the following sections.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 任何以文本消息、数字数据或计算机程序形式存在的信息都可以称为明文。想法是使用加密算法和密钥生成密文。然后可以将密文传输给预期接收者，接收者使用解密算法和密钥解密以获取明文。
- en: Symmetric Key Cryptography
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对称密钥加密
- en: 'In the previous section we looked at how Alice can encrypt a message and send
    the ciphertext to Bob. Bob can then decrypt the ciphertext to get the original
    message. If the same key is used for both encryption and decryption, it is called
    symmetric key cryptography. This means that both Alice and Bob have to agree on
    a key (k) called “shared secret” before they exchange the ciphertext. So, the
    process is as follows:Alice—the Sender:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们了解了 Alice 如何加密一条消息并将密文发送给 Bob。Bob 然后可以解密密文以获取原始消息。如果加密和解密使用相同的密钥，这被称为对称密钥加密。这意味着
    Alice 和 Bob 必须就一个称为“共享密钥”的密钥（k）达成一致，然后才能交换密文。所以，过程如下：Alice—发送者：
- en: Encrypt the plaintext message m using encryption algorithm E and key k to prepare
    the ciphertext c
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用加密算法 E 和密钥 k 加密明文消息 m 以准备密文 c
- en: c = E(k, m)
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: c = E(k, m)
- en: Send the ciphertext c to Bob
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将密文 c 发送给 Bob
- en: 'Bob—the Receiver:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Bob—接收者：
- en: Decrypt the ciphertext c using decryption algorithm D and the same key k to
    get the plaintext m
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用相同的密钥 k 和解密算法 D 解密密文 c 以获取明文 m
- en: m = D( k, c )
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: m = D(k, c)
- en: 'Did you just notice that the sender and receiver used the same key (k)? How
    do they agree on the same key and share it with each other? Obviously, they need
    a secure distribution channel to share the key. It typically looks as shown in
    Figure [2-3](A440588_1_En_2_Chapter_split_000.xhtml#Fig3).![A440588_1_En_2_Fig3_HTML.jpg](Images/A440588_1_En_2_Fig3_HTML.jpg)Figure
    2-3Symmetric cryptographySymmetric key cryptography is used widely; the most common
    uses are secure file transfer protocols such as HTTPS, SFTP, and WebDAVS. Symmetric
    cryptosystems are usually faster and more useful when the data size is huge.Please
    note that symmetric key cryptography exists in two variants: stream ciphers and
    block ciphers. We will discuss these in the following sections but we will look
    at Kerchoff’s principle and XOR function before that to be able to understand
    how the cryptosystems really work.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Kerckhoff’s Principle and XOR Function
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Kerckhoff’s principle states that a cryptosystem should be secured even if everything
    about the system is publicly known, except the key. Also, the general assumption
    is that the message transmission channel is never secure, and messages could easily
    be intercepted during transmission. This means that even if the encryption algorithm
    E and decryption algorithm D are public, and there is a chance that the message
    could be intercepted during transmission, the message is still secure due to a
    shared secret. So, the keys must be kept secret in a symmetric cryptosystem.The
    XOR function is the basic building block for many encryption and decryption algorithms.
    Let us take a look at it to understand how it enables cryptography. The XOR, otherwise
    known as “Exclusive OR” and denoted by the symbol ⊕, can be represented by the
    following truth table (Table [2-1](A440588_1_En_2_Chapter_split_000.xhtml#Tab1)).Table
    2-1XOR Truth Table
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '| A | B | A ⊕ B |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 0 |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 | 1 |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
- en: '| 0 | 1 | 1 |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 0 |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
- en: 'The XOR function has the following properties, which are important to understand
    the math behind cryptography:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'Associative: A ⊕ (B ⊕ C) = (A ⊕ B) ⊕ C'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Commutative: A ⊕ B = B ⊕ A'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Negation: A ⊕ 1 = Ā'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Identity: A ⊕ A = 0'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using these properties, it would now make sense how to compute the ciphertext
    “c” using plaintext “m” and the key “k,” and then decrypt the ciphertext “c” with
    the same key “k” to get the plaintext “m.” The same XOR function is used for both
    encryption and decryption.m ⊕ k = c and c ⊕ k = mThe previous example is in its
    simplest form to get the hang of encryption and decryption. Notice that it is
    very simple to get the original plaintext message just by XORing with the key,
    which is a shared secret and only known by the intended parties. Everyone may
    know that the encryption or decryption algorithm here is XOR, but not the key.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Stream Ciphers vs. Block Cipher
  id: totrans-35
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Stream cipher and block cipher algorithms differ in the way the plaintext is
    encoded and decoded.Stream ciphers convert one symbol of plaintext into one symbol
    of ciphertext. This means that the encryption is carried out one bit or byte of
    plaintext at a time. In a bit by bit encryption scenario, to encrypt every bit
    of plaintext, a different key is generated and used. So, it uses an infinite stream
    of pseudorandom bits as the key and performs the XOR operation with input bits
    of plaintext to generate ciphertext. For such a system to remain secure, the pseudorandom
    keystream generator has to be secure and unpredictable. Stream ciphers are an
    approximation of a proven perfect cipher called “the one-time pad,” which we will
    discuss in a little while.How does the pseudorandom keystream get generated in
    the first place? They are typically generated serially from a random seed value
    using digital shift registers. Stream ciphers are quite simple and faster in execution.
    One can generate pseudorandom bits offine and decrypt very quickly, but it requires
    synchronization in most cases.We saw that the pseudorandom number generator that
    generates the key stream is the central piece here that ensures the quality of
    security—which stands to be its biggest disadvantage. The pseudorandom number
    generator has been attacked many times in the past, which led to deprecation of
    stream ciphers. The most widely used stream cipher is RC4 (Rivest Cipher 4) for
    various protocols such as SSL, TLS, and Wi-Fi WEP/WPA etc. It was revealed that
    there were vulnerabilities in RC4, and it was recommended by Mozilla and Microsoft
    not to use it where possible.Another disadvantage  is that all information in
    one bit of input text is contained in its corresponding one bit of ciphertext,
    which is a problem of low diffusion. It could have been more secured if the information
    of one bit was distributed across many bits in the ciphertext output, which is
    the case with block ciphers. Examples of stream ciphers are one-time pad, RC4,
    FISH, SNOW, SEAL, A5/1, etc.Block cipher on the other hand is based on the idea
    of partitioning the plaintext into relatively larger blocks of fixed-length groups
    of bits, and further encoding each of the blocks separately using the same key.
    It is a deterministic algorithm with an unvarying transformation using the symmetric
    key. This means when you encrypt the same plaintext block with the same key, you’ll
    get the same result.The usual sizes of each block are 64 bits, 128 bits, and 256
    bits called block length, and their resulting ciphertext blocks are also of the
    same block length. We select, say, an r bits key k to encrypt every block of length
    n, then notice here that we have restricted the permutations of the key k to a
    very small subset of 2^r. This means that the notion of “perfect cipher” does
    not apply. Still, random selection of the r bits secret key is important, in the
    sense that more randomness implies more secrecy.To encrypt or decrypt  a message
    in block cipher cryptography, we have to put them into a “mode of operation” that
    defines how to apply a cipher’s single-block operation repeatedly to transform
    amounts of data larger than a block. Well, the mode of operation is not just to
    divide the data into fixed sized blocks, it has a bigger purpose. We learned that
    the block cipher is a deterministic algorithm. This means that the blocks with
    the same data, when encrypted using the same key, will produce the same ciphertext—quite
    dangerous! It leaks a lot of information. The idea here is to mix the plaintext
    blocks with the just created ciphertext blocks in some way so that for the same
    input blocks, their corresponding Ciphertext outputs are different. This will
    become clearer when we get to the DES and AES algorithms in the following sections.Note
    that different modes of operations result in different properties being achieved
    that add to the security of the underlying block cipher. Though we will not get
    into the nitty-gritty of modes of operations, here are the names of a few for
    your reference: Electronic Codebook (ECB), Cipher Block Chaining (CBC), Cipher
    Feedback (CFB), Output Feedback (OFB), and Counter (CTR).Block ciphers  are a
    little slow to encrypt or decrypt, compared with the stream ciphers. Unlike stream
    ciphers where error propagation is much less, here the error in one bit could
    corrupt the whole block. On the contrary, block ciphers have the advantage of
    high diffusion, which means that every input plaintext bit is diffused across
    several ciphertext symbols. Examples of block ciphers are DES, 3DES, AES, etc.NoteA
    deterministic algorithm is an algorithm that, given a particular input, will always
    produce the same output.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 流加密算法和块加密算法在明文信息的编码和解码方式上有所不同。流加密算法将明文的一个符号转换成密文的一个符号。这意味着加密是逐比特或逐字节地进行的。在逐比特加密的情况下，为了加密明文的每一个比特，会生成并使用不同的密钥。因此，它使用无限长的伪随机比特流作为密钥，并与明文的输入比特进行异或操作来生成密文。为了保持这样的系统安全，伪随机密钥流生成器必须足够安全且不可预测。流加密是对一种已证明完美的加密算法——“一次性密码本”的一种近似，我们稍后会讨论到它。伪随机密钥流是如何生成的呢？它们通常是基于随机种子值，使用数字移位寄存器逐个生成。流加密相对简单且执行速度快。可以在离线时生成伪随机比特，并快速解密，但在大多数情况下，它需要同步。我们了解到，生成密钥流的伪随机数生成器是确保安全性的关键部分——这也是其最大的缺点。伪随机数生成器在过去已经被攻击过很多次，这导致了流加密的弃用。最广泛使用的流加密算法是RC4（Rivest
    Cipher 4），它用于SSL、TLS和Wi-Fi WEP/WPA等众多协议。后来发现RC4存在漏洞，Mozilla和微软建议尽可能不要使用它。另一个缺点是，输入文本的一个比特中的所有信息都包含在其对应的密文比特中，这是扩散性低的问题。如果信息的一个比特在密文输出中分散到多个比特，它可能会有更高的安全性，这在块加密中是这种情况。流加密的例子有一次性密码本、RC4、FISH、SNOW、SEAL、A5/1等。另一方面，块加密是基于将明文划分为相对较大的固定长度比特组，并使用相同的密钥分别对每个块进行编码的理念。它是一种使用对称密钥的不变变换确定性算法。这意味着当你用相同的密钥加密相同的明文块时，你会得到相同的结果。每个块的常见大小是64位、128位和256位，称为块长度，其生成的密文块也是相同的长度。我们选择一个r位的密钥k来加密每个长度为n的块，然后注意到我们将密钥k的排列限制在2^r的一个非常小的子集上。这意味着“完美加密”的概念不适用。然而，选择r位秘密密钥的随机性很重要，因为更多的随机性意味着更多的机密性。为了在块加密密码学中加密或解密消息，我们必须将它们放入一个“操作模式”，它定义了如何将加密的一次块操作反复应用于大于一个块的数据量。嗯，操作模式不仅仅是将数据划分为固定大小的块，它还有更大的作用。我们了解到块加密是一种确定性算法。这意味着具有相同数据的块，当使用相同的密钥加密时，将产生相同的密文——非常危险！它会泄露很多信息。这里的想法是以某种方式将明文块与刚刚创建的密文块混合，使得对于相同的输入块，它们的对应密文输出是不同的。当我们接下来讨论DES和AES算法时，这将变得更清晰。请注意，不同的操作模式会导致实现不同的属性，从而增加基础块加密的安全性。虽然我们不会深入探讨操作模式的细节，但这里有一些供您参考的操作模式名称：电子密码本（ECB）、密文块链式（CBC）、密文反馈（CFB）、输出反馈（OFB）和计数器（CTR）。与流加密相比，块加密在加密或解密方面要慢一些。与流加密中错误传播较少的情况不同，这里的每一个比特错误都可能导致整个块损坏。相反，块加密具有高扩散性的优点，这意味着每个输入明文比特都分散在几个密文符号中。块加密的例子有DES、3DES、AES等。
- en: One-Time Pad
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 一次性密钥
- en: It is a symmetric stream cipher where the plaintext, the key, and the ciphertext
    are all bit strings. Also, it is completely based on the assumption of a “purely
    random” key (and not pseudorandom), using which it could achieve “perfect secrecy.”
    Also, as per the design, the key can be used only once. The problem with this
    is that the key should be at least as long as the plaintext. It means that if
    you are encrypting a 1GB file, the key would also be 1GB! This gets impractical
    in many real-world cases.Example:Table 2-2Example Encryption Using XOR Function
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个对称流密码，其中明文、密钥和密文都是位串。此外，它完全基于“完全随机”的密钥（而非伪随机）假设，使用它可以实现“完美保密”。另外，根据设计，密钥只能使用一次。这个问题是密钥至少应与明文一样长。这意味着如果你要加密一个1GB的文件，密钥也将是1GB!这在许多实际情况下是不切实际的。示例：表2-2使用异或函数的加密示例
- en: '| PlainText | 1 | 0 | 0 | 1 | 1 | 1 | 0 | 0 | 1 | 0 | 1 | 0 | 1 | 1 | 0 | 1
    | 1 | 0 |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 纯文本 | 1 | 0 | 0 | 1 | 1 | 1 | 0 | 0 | 1 | 0 | 1 | 0 | 1 | 1 | 0 | 1 | 1 |
    0 |'
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | ---
    | --- | --- | --- | --- | --- | --- |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | ---
    | --- | --- | --- | --- | --- | --- |'
- en: '| Key | 0 | 1 | 0 | 0 | 1 | 1 | 0 | 1 | 1 | 1 | 0 | 0 | 1 | 0 | 1 | 0 | 1 |
    1 |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 密钥 | 0 | 1 | 0 | 0 | 1 | 1 | 0 | 1 | 1 | 1 | 0 | 0 | 1 | 0 | 1 | 0 | 1 |
    1 |'
- en: '| Ciphertext | 1 | 1 | 0 | 1 | 0 | 0 | 0 | 1 | 0 | 1 | 1 | 0 | 0 | 1 | 1 |
    1 | 0 | 1 |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| 密文 | 1 | 1 | 0 | 1 | 0 | 0 | 0 | 1 | 0 | 1 | 1 | 0 | 0 | 1 | 1 | 1 | 0 |
    1 |'
- en: You can refer to the XOR truth table in the previous section to find how ciphertext
    is generated by XOR-ing plaintext with the key. Notice that the plaintext, the
    key, and the ciphertext are all 18 bits long.Here, the receiver upon receipt of
    the ciphertext can simply XOR again with the key and get the plaintext. You can
    try it on your own with Table [2-2](A440588_1_En_2_Chapter_split_000.xhtml#Tab2)
    and you will get the same plaintext.The main problem with this one-time pad is
    more of practicality, rather than theory. How do the sender and receiver agree
    on a secret key that they can use? If the sender and the receiver already have
    a secure channel, why do they even need a key? If they do not have a secure channel
    (that is why we use cryptography), then how can they share the key securely? This
    is called the “key distribution problem.”The solution is to approximate the one-time
    pad by using a pseudorandom number generator (PRNG). This is a deterministic algorithm
    that uses a seed value to generate a sequence of random numbers that are not truly
    random; this in itself is an issue. The sender and the receiver have to have the
    same seed value for this system to work. Sharing that seed value is way better
    compared with sharing the entire key; just that it has to be secured. It is susceptible
    to compromise by someone who knows the algorithm as well as the seed.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以参考前一部分的异或真值表来找出如何通过将明文与密钥异或来生成密文。注意明文、密钥和密文都是18位长。在这里，接收者在收到密文后可以简单地再次与密钥异或得到明文。你可以用自己的表[2-2](A440588_1_En_2_Chapter_split_000.xhtml#Tab2)试试，你会得到相同的明文。这种一次性密钥的主要问题是实践性，而不是理论性。发送者和接收者如何就一个他们可以使用的秘密密钥达成一致？如果发送者和接收者已经有了一个安全的通道，他们还需要密钥吗？如果他们没有安全的通道（这就是我们使用密码学的原因），那么他们如何安全地共享密钥？这被称为“密钥分发问题”。
- en: Data Encryption Standard
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 数据加密标准
- en: The Data Encryption Standard (DES) is a symmetric block cipher technique. It
    uses 64-bit block size with a 64-bit key for encryption and decryption. Out of
    the 64-bit key, 8 bits are reserved for parity checks and technically 56 bits
    is the key length. It has been proven that it is vulnerable to brute force attack
    and could be broken in less than a day. Given Moore’s law, it could be broken
    a lot quicker in the future, so its usage has been deprecated quite a bit because
    of the key length. It was very popular and was being used in banking applications,
    ATMs, and other commercial applications, and more so in hardware implementations
    than software. We give a high-level description of the DES encryption in this
    section.In symmetric cryptography, a large number of block ciphers use a design
    scheme known as a “Feistel cipher”  or “Feistel network.” A Feistel cipher consists
    of multiple rounds to process the plaintext with the key, and every round consists
    of a substitution step followed by a permutation step. The more the number of
    rounds, the more secure it could be but encryption/decryption gets slower. The
    DES is based on a Feistel cipher with 16 rounds. A general sequence of steps in
    the DES algorithm is shown in Figure [2-4](A440588_1_En_2_Chapter_split_000.xhtml#Fig4).![A440588_1_En_2_Fig4_HTML.jpg](Images/A440588_1_En_2_Fig4_HTML.jpg)Figure
    2-4DES cryptographyLet us first talk about the key generator and then we will
    get into the encryption part.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 数据加密标准（DES）是一种对称块加密技术。它使用64位的块大小和64位的密钥进行加密和解密。在64位密钥中，8位用于奇偶校验，技术上56位是密钥长度。已经证明它容易受到暴力攻击，并且可能在不到一天的时间内被破解。考虑到摩尔定律，未来它可能会更快地被破解，因此由于密钥长度，其使用已经被大大废弃。它曾经非常流行，并被用于银行应用、ATM和其他商业应用中，尤其是在硬件实现中而不是软件。我们在此部分提供一个高级描述DES加密。在对称密码学中，大量块加密使用一种称为“费斯特征密码”或“费斯特征网络”的设计方案。费斯特征密码由多个轮次处理明文和密钥，每一轮都包括一个替换步骤后跟一个置换步骤。轮次越多，它可能越安全，但加密/解密速度会变慢。DES基于16轮的费斯特征密码。DES算法的一般步骤序列如图[2-4](A440588_1_En_2_Chapter_split_000.xhtml#Fig4)所示。![A440588_1_En_2_Fig4_HTML.jpg](Images/A440588_1_En_2_Fig4_HTML.jpg)图2-4DES加密让我们先谈谈密钥生成器，然后我们再进入加密部分。
- en: As mentioned before, the key is also 64 bits long. Since 8 bits are used as
    parity bits (more precisely, bit number 8, 16, 24, 32, 40, 48, 56, and 64), only
    56 bits are used for encryption and decryption.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正如前面提到的，密钥也是64位长。由于8位用于奇偶校验位（更准确地说，是第8位、第16位、第24位、第32位、第40位、第48位、第56位和第64位），因此只有56位用于加密和解密。
- en: After parity removal, the 56-bit key is divided into two blocks, each of 28
    bits. They are then bit-wise left shifted in every round. We know that the DES
    uses 16 rounds of Feistel network. Note here that every round takes the previous
    round’s left-shifted bit block and then again left shifts by one bit in the current
    round.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在去除奇偶校验位之后，56位的密钥被分成两个28位的块。然后在每一轮中，它们以位为单位向左移动。我们知道DES使用16轮费斯特征网络。注意这里，每一轮都取上一轮左移的位块，然后在当前轮再次左移一位。
- en: Both the left-shifted 28-bit blocks are then combined through a compression
    mechanism that outputs a 48-bit key called subkey that gets used for encryption.
    Similarly, in every round, the two 28-bit blocks from the previous round get left
    shifted again by one bit and then clubbed and compressed to the 48-bit key. This
    key is then fed to the encryption function of the same round.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后通过压缩机制将两个左移的28位块结合起来，输出一个48位密钥，称为子密钥，用于加密。同样，在每一轮中，前一轮的两个28位块再次左移一位，然后组合并压缩成48位密钥。这个密钥随后被输入到该轮的加密函数中。
- en: 'Let us now look at how DES uses the Feistel cipher  rounds for encryption:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看DES是如何使用费斯特征网络轮对进行加密的：
- en: First, the plaintext input is divided into 64 bit blocks. If the number of bits
    in the message is not evenly divisible by 64, then the last block is padded to
    make it a 64-bit block.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，明文输入被分成64位块。如果消息中的位数不能被64整除，那么最后一个块将被填充以使其成为一个64位块。
- en: Every 64-bit input data block goes through an initial permutation (IP) round.
    It simply permutes, i.e., rearranges all the 64-bit inputs in a specific pattern
    by transposing the input blocks. It has no cryptographic significance as such,
    and its objective is to make it easier to load plaintext/ciphertext into DES chips
    in byte-sized format.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个64位的输入数据块都要经过一个初始置换（IP）轮。它通过交换输入块中的输入位来重新排列所有64位输入，以特定的模式进行置换。它本身并没有实际的加密意义，其目的是为了将明文/密文以字节格式更容易地加载到DES芯片中。
- en: After the IP round, the 64-bit block gets divided into two 32-bit blocks, a
    left block (L) and a right block (R). In every round, the blocks are represented
    as L[i] and R[i], where the subscript “I” denotes the round. So, the outcomes
    of IP round are denoted as L[0] and R[0].
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在IP轮之后，64位块被分成两个32位块，一个左块（L）和一个右块（R）。在每一轮中，块被表示为L[i]和R[i]，其中下标“I”表示轮次。所以，IP轮的结果表示为L[0]和R[0]。
- en: 'Now the Feistel rounds start. The first round takes L[0] and R[0] as input
    and follows the following steps:'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，Feistel轮开始。第一轮取L[0]和R[0]作为输入，并按照以下步骤进行：
- en: 'The right side 32-bit block (R) comes as is to the left side and the left side
    32-bit block (L) goes through an operation with the key k of that round and the
    right side 32-bit block (R) as shown following:'
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 右侧的32位块（R）直接送到左侧，左侧的32位块（L）通过与该轮的密钥k和右侧的32位块（R）进行操作如下：
- en: L[i] = R[i] −1
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: L[i] = R[i] -1
- en: R[i] = L[i] −1 ⊕ F(R[i] −1, K[i]) where “I” is the round number
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: R[i] = L[i] -1 ⊕ F(R[i] -1, K[i]) 其中“I”是轮数
- en: The F() is called the “Cipher Function” that is actually the core part of every
    round. There are multiple steps or operations that are bundled together in this
    F() operation.
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: F()被称为“密码函数”，实际上是每一轮的核心部分。在这个F()操作中有多个步骤或操作被捆绑在一起。
- en: In the first step  , operation of the 32-bit R-block is expanded and permuted
    to output a 48-bit block.
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第一步，32位R块的操作被扩展并置换以输出一个48位块。
- en: In the second step, this 48-bit block is then XORed with the 48-bit subkey supplied
    by the key generator of the same round.
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第二步，这个48位块然后与同一轮密钥生成器提供的48位子密钥进行异或。
- en: In the third step, this 48-bit XORed output is fed to the substitution box to
    reduce the bits back to 32 bits. The substitution operation in this S-box is the
    only nonlinear operation in DES and contributes significantly to the security
    of this algorithm.
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第三步，这个48位的异或输出被送入置换盒，将比特减少到32位。这个S盒中的置换操作是DES中唯一的非线性操作，对算法的这种安全性贡献很大。
- en: In the fourth step, the 32-bit output of the S-box is fed to the permutation
    box (P-box), which is just a permutation operation that outputs a 32-bit block,
    which is actually the final output of F() cipher function.
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第四步中，S-盒的32位输出被送入置换盒（P-盒），这只是一个置换操作，输出一个32位块，这实际上是F()密码函数的最终输出。
- en: The output of F() is then XORed with the 32-bit L-block, which is input to this
    round. This XORed output then becomes the final R-block output of this round.
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: F()的输出然后与32位L块进行异或，这是本轮的输入。这个异或输出然后成为本轮的最终R块输出。
- en: Refer to Figure [2-5](A440588_1_En_2_Chapter_split_000.xhtml#Fig5) to understand
    the various operations that take place in every round.
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参考图[2-5](A440588_1_En_2_Chapter_split_000.xhtml#Fig5)以了解每一轮中发生的各种操作。
- en: '![A440588_1_En_2_Fig5_HTML.jpg](Images/A440588_1_En_2_Fig5_HTML.jpg)Figure
    2-5Round function of DES'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '![A440588_1_En_2_Fig5_HTML.jpg](Images/A440588_1_En_2_Fig5_HTML.jpg)图2-5 DES的轮函数'
- en: The previously discussed Feistel round gets repeated 16 times, where the output
    of one round is fed as the input to the following round.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 之前讨论的Feistel轮重复16次，其中每一轮的输出作为下一轮的输入。
- en: Once all the 16 rounds are over, the output of the 16th round is again swapped
    such that the left becomes the right block and vice versa.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦所有16轮都结束，第16轮的输出又被交换，使得左边的变成右块，反之亦然。
- en: Then the two blocks are clubbed to make a 64-bit block and passed through a
    permutation operation, which is the inverse of the initial permutation function
    and that results in the 64-bit ciphertext output.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，这两个块组合成一个64位块，并通过一个置换操作，这是初始置换函数的逆操作，结果是64位密文输出。
- en: We looked at how the DES algorithm really works. The decryption also works a
    similar way in the reverse order. We will not get into those details, but leave
    it to you to explore.Let us conclude with the limitations of the DES. The 56-bit
    key length was susceptible to brute force attack and the S-boxes used for substitution
    in each round were also prone to cryptanalysis attack because of some inherent
    weaknesses. Because of these reasons, the Advanced Encryption Standard (AES) has
    replaced the DES to the extent possible. Many applications now choose AES over
    DES.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解了DES算法是如何真正工作的。解密也是以相反的顺序类似地工作。我们不会深入了解那些细节，但留给你去探索。让我们总结一下DES的局限性。56位的密钥长度容易受到暴力攻击，而用于每一轮替换的S盒也容易受到密码分析攻击，因为有一些固有的弱点。正因为这些原因，高级加密标准（AES）尽可能地取代了DES。现在许多应用程序都选择AES而不是DES。
- en: Advanced Encryption Standard
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 高级加密标准
- en: 'Like DES, the AES algorithm is also a symmetric block cipher but is not based
    on a Feistel network. The AES uses a substitution-permutation network in a more
    general sense. It not only offers greater security, but also offers greater speed!
    As per the AES standards, the block size is fixed at 128 bits and allows a choice
    of three keys: 128 bits, 192 bits, and 256 bits. Depending on the choice of the
    key, AES is named as AES-128, AES-192, and AES-256.In AES, the number of encryption
    rounds depend on the key length. For AES-128, there are ten rounds; for AES-192,
    there are 12 rounds; and for AES-256, there are 14 rounds. In this section, our
    discussion is limited to key length 128 (i.e., AES-128), as the process is almost
    the same for other variants of AES. The only thing that changes is the “key schedule,”
    which we will look into later in this section.Unlike DES, AES encryption rounds
    are iterative and operate an entire data block of 128 bits in every round. Also,
    unlike DES, the decryption is not very similar to the encryption process in AES.To
    understand the processing steps in every round, consider the 128-bit block as
    16 bytes where individual bytes are arranged in a 4 × 4 matrix as shown:![A440588_1_En_2_Figa_HTML.jpg](Images/A440588_1_En_2_Figa_HTML.jpg)This
    4 × 4 matrix of bytes as shown is referred to as state array . Please note that
    every round consumes an input state array and produces an output state array.The
    AES also uses another piece of jargon called “word” that needs to be defined before
    we go further. Whereas a byte consists of eight bits, a word consists of four
    bytes, that is, 32 bits. The four bytes in each column of the state array form
    32-bit words and can be called state words . The state array can be shown as follows:![A440588_1_En_2_Figb_HTML.jpg](Images/A440588_1_En_2_Figb_HTML.jpg)Also,
    every byte can be represented with two hexadecimal numbers. Example: if the 8-bit
    byte is {00111010}, it could be represented as “3A” in Hex notation. “3” represents
    the left four bits “0011” and “A” represents the right four bits “1010.”Now to
    generalize each round, processing in each round happens at byte level and consists
    of byte-level substitution followed by word-level permutation, hence it is a substitution-permutation
    network. We will get to further details when we discuss the various operations
    in each round. The overall encryption and decryption process of AES can be represented
    in Figure [2-6](A440588_1_En_2_Chapter_split_000.xhtml#Fig6).![A440588_1_En_2_Fig6_HTML.jpg](Images/A440588_1_En_2_Fig6_HTML.jpg)Figure
    2-6AES cryptographyIf you paid close attention to Figure [2-6](A440588_1_En_2_Chapter_split_000.xhtml#Fig6),
    you would have noticed that the decryption process is not just the opposite of
    encryption. The operations in the rounds are executed in a different order! All
    steps of the round function—SubBytes, ShiftRows, MixColumns, AddRoundKey—are invertible.
    Also, notice that the rounds are iterative in nature. Round 1 through round 9
    have all four operations, and the last round excludes only the “MixColumns” operation.
    Let us now build a high-level understanding of each operation that takes place
    in a round function.SubBytes : This is a substitution step. Here, each byte is
    represented as two hexadecimal digits. As an example, take a byte {00111010} represented
    with two hexadecimal digits, say {3A}. To find its substitution values, refer
    to the S-box lookup table (16 × 16 table) to find the corresponding value for
    3-row and A-column. So, for {3A}, the corresponding substituted value would be
    {80}. This step provides the nonlinearity in the cipher.ShiftRows : This is the
    transformation step and is based upon the matrix representation of the state array.
    It consists of the following shift operations:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 像DES一样，AES算法也是一种对称分组密码，但它不是基于Feistel网络。AES使用的是更广义上的替换-排列网络。它不仅提供了更高的安全性，还提供了更快的速度！根据AES标准，块大小固定为128位，可以选择三种密钥：128位、192位和256位。根据密钥的选择，AES被称为AES-128、AES-192和AES-256。在AES中，加密轮数取决于密钥长度。对于AES-128，有十轮；对于AES-192，有12轮；对于AES-256，有14轮。在本节中，我们的讨论限于密钥长度128（即AES-128），因为其他AES变体的过程几乎相同。唯一变化的是“密钥调度”，我们将在本节后面进行探讨。与DES不同，AES加密轮次是迭代的，每轮操作整个128位数据块。此外，与DES不同，AES的解密过程与加密过程不太相似。为了了解每轮的处理步骤，请将128位块视为16个字节，其中每个字节按4×4矩阵排列如下所示：![A440588_1_En_2_Figa_HTML.jpg](Images/A440588_1_En_2_Figa_HTML.jpg)这个4×4的字节矩阵被称为状态数组。请注意，每轮都消耗一个输入状态数组并生成一个输出状态数组。AES还使用了一个术语“字”，我们需要在进一步讨论之前对其进行定义。字节由八个位组成，而字由四个字节组成，即32位。状态数组中每列的四个字节形成32位的字，可以称为状态字。状态数组可以表示如下：![A440588_1_En_2_Figb_HTML.jpg](imgs/A440588_1_En_2_Figb_HTML.jpg)另外，每个字节可以用两个十六进制数表示。例如：如果8位字节是{00111010}，它可以用“3A”在十六进制表示法中表示。"3"代表左边的四个位“0011”，“A”代表右边的四个位“1010”。现在，为了概括每一轮，每一轮的处理都是在字节级别进行，包括字节级别的替换和字级别排列，因此它是一个替换-排列网络。当我们讨论每轮的各种操作时，将详细介绍这些细节。AES的整体加密和解密过程可以在图2-6中表示。![A440588_1_En_2_Fig6_HTML.jpg](imgs/A440588_1_En_2_Fig6_HTML.jpg)图2-6AES加密如果仔细观察图2-6，你会注意到解密过程不仅仅是加密的相反。轮次中的操作顺序不同！轮次函数的所有步骤——SubBytes、ShiftRows、MixColumns、AddRoundKey——都是可逆的。同时，请注意轮次是迭代性质的。第1轮到第9轮都有四个操作，最后一轮只省略了“MixColumns”操作。现在让我们建立对每轮函数中发生每个操作的高级理解。SubBytes：这是一个替换步骤。在这里，每个字节用两个十六进制数字表示。例如，假设有一个字节{00111010}用两个十六进制数字表示，比如{3A}。为了找到其替换值，参考S-盒查找表（16×16表格）以找到3行和A列对应的值。所以，对于{3A}，相应的替换值将是{80}。这一步为密码提供了非线性特性。ShiftRows：这是一个变换步骤，基于状态数组的矩阵表示。它包括以下移位操作：
- en: No circular shifting of the first row, and remains as is
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一行不进行旋转，保持原样
- en: Circularly shifting of the second row by one byte to the left
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将第二行向左旋转一位字节
- en: Circularly shifting of the third row by two bytes to the left
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将第三行向左旋转两位字节
- en: Circularly shifting of the fourth row (last row) by three bytes to the left
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将第四行（最后一行）向左旋转三位字节
- en: 'It can be represented as shown:![A440588_1_En_2_Figc_HTML.jpg](Images/A440588_1_En_2_Figc_HTML.jpg)MixColumns
    : It is also a transformation step where all the four columns of the state are
    multiplied with a fixed polynomial (C[x]) and get transformed to new columns.
    In this process, each byte of a column is mapped to a new value that is a function
    of all four bytes in the column. This is achieved by the matrix multiplication
    of state as shown:![A440588_1_En_2_Figd_HTML.jpg](Images/A440588_1_En_2_Figd_HTML.jpg)The
    matrix multiplication is as usual, but the AND products are XORed. Let us see
    one of the examples to understand the process. Byte 0’ is calculated as shown:Byte
    0’ = (2 . Byte0) ⊕ (3 . Byte1) ⊕ Byte3 ⊕ Byte4It is important to note that this
    MixColumns step, along with the ShiftRows step, provide the necessary diffusion
    property (information from one byte gets diffused to multiple bytes) to the cipher.AddRoundKey:
    This is again a transformation step where the 128-bit round key is bitwise XORed
    with 128 bits of state in a column major order. So, the operation takes place
    column-wise, meaning four bytes of a word state column with one word of the round
    key. In the same way we represented the 128-bit plaintext block, the 128-bit key
    should also be represented in the same 4 × 4 matrix as shown here:![A440588_1_En_2_Fige_HTML.jpg](Images/A440588_1_En_2_Fige_HTML.jpg)128-bit
    keyThis operation affects every bit of a state. Now, recollect that there are
    ten rounds, and each round has its own round key. Since there is an “AddRoundKey”
    step before the rounds start, effectively there are eleven (10 + 1) AddRoundKey
    operations. In one round, all 128-bits of subkey, that is, all four words of subkey,
    are used to XOR with the 128-bit input data block. So, in total, we require 44
    key words, w[0] through w[43]. This is why the 128-bit key has to go through a
    key expansion operation, which we will get to in a little while.Note here that
    the key word [w[0], w[1], w[2], w[3]] gets XORed with the initial input block
    before the round-based processing begins. The remaining 40 word-keys, w[4] through
    w[43], get used four words at a time in each of the ten rounds.AES Key Expansion:
    The AES key expansion algorithm takes as input a 128-bit cipher key (four-word
    key) and produces a schedule of 44 key words from it. The idea is to design this
    system in such a way that a one-bit change in the key would significantly affect
    all the round keys.The key expansion operation is designed such that each grouping
    of a four-word key produces the next grouping of a four-word key in a four-word
    to four-word basis. It is easy to explain this with a pictorial representation,
    so here we go:![A440588_1_En_2_Fig7_HTML.jpg](Images/A440588_1_En_2_Fig7_HTML.jpg)Figure
    2-7AES key expansionWe will quickly run through the operations that take place
    for key expansion by referring to the diagram:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以用以下方式表示：![A440588_1_En_2_Figc_HTML.jpg](Images/A440588_1_En_2_Figc_HTML.jpg)MixColumns：这也是一个转换步骤，其中状态的四列都乘以一个固定的多项式（C[x]），并转换成新的列。在这个过程中，每一列的字节映射到一个新值，这个值是列中所有四个字节的一个函数。这通过状态的矩阵乘法实现，如下所示：![A440588_1_En_2_Figd_HTML.jpg](Images/A440588_1_En_2_Figd_HTML.jpg)矩阵乘法像往常一样，但异或积是异或运算。让我们看一个例子来理解这个过程。字节0’的计算如下：Byte
    0’ = (2 . Byte0) ⊕ (3 . Byte1) ⊕ Byte3 ⊕ Byte4需要注意的是，这个MixColumns步骤，连同ShiftRows步骤，为密码提供了必要的扩散性质（一个字节的信息扩散到多个字节）。AddRoundKey：这又是一个转换步骤，其中128位轮密钥与状态的128位按列优先顺序进行位异或运算。所以，操作是按列进行的，意味着一个单词状态列的四个字节与一个轮密钥的单词进行异或。就像我们表示128位明文块一样，128位密钥也应该以同样的4
    × 4矩阵表示，如下所示：![A440588_1_En_2_Fige_HTML.jpg](Images/A440588_1_En_2_Fige_HTML.jpg)128位密钥这个操作影响一个状态的每一个比特。现在，回想一下，有十个轮次，每个轮次都有自己的轮密钥。由于在轮次开始前有一个“AddRoundKey”步骤，实际上有十一个（10
    + 1）AddRoundKey操作。在一个轮次中，所有128位的子密钥，即所有四个子密钥的单词，都与128位的输入数据块进行异或。因此，总共我们需要44个密钥单词，从w[0]到w[43]。这就是为什么128位密钥必须通过密钥扩展操作的原因，我们稍后会了解到这一点。注意，这里的密钥单词[w[0],
    w[1], w[2], w[3]]在与初始输入块进行异或之前，在基于轮次的处理开始之前。剩下的40个单词密钥，从w[4]到w[43]，在每个轮次中以四个单词一次的方式使用。AES密钥扩展：AES密钥扩展算法输入一个128位密钥（四单词密钥）并产生44个密钥单词的调度。这个算法的目的是设计这个系统，使得密钥的一位变化会显著影响所有的轮密钥。密钥扩展操作设计为每个四单词密钥的分组产生下一个四单词密钥的分组，基于四个单词到四个单词的基础。用图解来解释这个很容易，所以让我们来看看：![A440588_1_En_2_Fig7_HTML.jpg](Images/A440588_1_En_2_Fig7_HTML.jpg)图2-7AES密钥扩展我们可以通过参考这个图来快速了解密钥扩展过程中发生的操作：
- en: The initial 128-bit key is [w[0], w[1], w[2], w[3]] arranged in four words.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始的128位密钥是[w[0], w[1], w[2], w[3]]，安排成四个单词。
- en: 'Take a look at the expanded word now: [w[4], w[5], w[6], w[7]]. Notice that
    w[5] depends on w[4] and w[1]. This means that every expanded word depends on
    the immediately preceding word, i.e., w[i] – 1 and the word that is four positions
    back, i.e., w[i] – 4 . Test the same for w[6] as well. As you can see, just a
    simple XOR operation is performed here.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在看看扩展后的单词：`w[4]`、`w[5]`、`w[6]`、`w[7]`。注意`w[5]`依赖于`w[4]`和`w[1]`。这意味着每个扩展单词都依赖于紧邻的前一个单词，即`w[i]
    - 1`，以及四个位置前的单词，即`w[i] - 4`。也试试`w[6]`。正如你所看到的，这里只进行了一个简单的异或操作。
- en: Now, what about w[4]? Or, any other position that is a multiple of four, such
    as w[8] or w[12]? For these words, a more complex function denoted as “g” is used.
    It is basically a three-step function. In the first step, the input four-word
    block goes through circular left shift by one byte. For example [w[0], w[1], w[2],
    w[3]] becomes [w[1], w[2], w[3], w[0]]. In the second step, the four bytes input
    word (e.g., [w[1], w[2], w[3], w[0]]) is taken as input and byte substitution
    is applied on each byte using S-box. Then, in the third step, the result of step
    2 is XORed with something called round constant denoted as Rcon[ ]. The round
    constant is a word in which the right-most three bytes are always zero. For example,
    [x, 0, 0, 0]. This means that the purpose of Rcon[ ] is to just perform XOR on
    the left-most byte of the step 2 output key word. Also note that the Rcon[ ] is
    different for each round. This way, the final output of the complex function “g”
    is generated, which is then XORed with w[i] – 4 to get w[i] where “I” is a multiple
    of 4.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 那么`w[4]`呢？或者，任何其他四个位置的倍数，比如`w[8]`或`w[12]`？对于这些单词，使用了一个更复杂的函数，称为“g”。它基本上是一个三步函数。第一步，输入的四字块进行循环左移一个字节。例如，`[w[0],
    w[1], w[2], w[3]]` 变成了 `[w[1], w[2], w[3], w[0]]`。第二步，将四个字节的输入单词（例如，`[w[1], w[2],
    w[3], w[0]]`）作为输入，并对每个字节应用S盒进行字节替换。然后，在第三步，将第二步的结果与称为轮常数`Rcon[]`的某个东西进行异或。轮常数是一个右三个字节总是为零的字符串。例如，`[x,
    0, 0, 0]`。这意味着`Rcon[]`的目的是 just perform XOR on the left-most byte of the step
    2 output key word。还要注意，每个回合的`Rcon[]`都不同。这样，复杂函数“g”的最终输出就生成了，然后与`w[i] - 4`进行异或，得到`w[i]`，其中“I”是4的倍数。
- en: This is how the key expansion takes place in AES.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这就是AES中密钥扩展的过程。
- en: The output state array of the last round is rearranged back to form the 128-bit
    ciphertext block. Similarly, the decryption process takes place in a different
    order, which we looked at in the AES process diagram. The idea was to give you
    a heads-up on how this algorithm works at a high level, and we will restrict our
    discussion to just the encryption process in this section.The AES algorithm is
    standardized by the NIST (National Institute of Standards and Technology)  . It
    had the limitation of long processing time. Assume that you are sending just a
    1 megabyte file (8388608 bits) by encrypting with AES. Using a 128-bit AES algorithm,
    the number of steps required for this encryption will be 8388608/128 = 65536 on
    this same number of data blocks! Using a parallel processing approach, AES efficiency
    can be increased, but is still not very suitable when you are dealing with large
    data.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一轮的输出状态数组重新排列，形成128位密文块。同样，解密过程的顺序不同，我们在AES过程图中看到了这一点。目的是让你了解这个算法在高层是如何工作的，在本节中，我们将限制我们的讨论仅涉及加密过程。高级加密标准（AES）由美国国家标准与技术研究院（NIST）制定。它有一个处理时间长的局限性。假设你通过AES加密发送一个仅1兆字节（8388608位）的文件。使用128位的AES算法，这个加密所需的步骤数为8388608/128
    = 65536个数据块！采用并行处理方法，可以提高AES的效率，但当处理大量数据时仍然不太适用。
- en: Challenges in Symmetric Key Cryptography
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 对称密钥加密技术面临的挑战
- en: 'There are some limitations in symmetric key cryptography. A few of them are
    listed as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 对称密钥加密技术存在一些局限性。其中一些局限性如下：
- en: The key must be shared by the sender and receiver before any communication.
    It requires a secured key establishment mechanism in place.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在通信之前，发送方和接收方必须共享密钥。这需要一个安全的密钥建立机制。
- en: The sender and receiver must trust each other, as they use the same symmetric
    key. If a receiver is hacked by an attacker or the receiver deliberately shared
    the key with someone else, the system gets compromised.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送方和接收方必须相互信任，因为它们使用相同的对称密钥。如果接收方被攻击者黑客攻击，或者接收方故意将密钥与他人分享，系统将受到威胁。
- en: A large network of, say, n nodes require key n(n–1)/2 key pairs to be managed.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比如说，一个由n个节点的大型网络需要管理n(n-1)/2密钥对。
- en: It is advisable to keep changing the key for each communication session.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建议每个通信会话都更换一次密钥。
- en: Often a trusted third party is needed for effective key management, which itself
    is a big issue.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常需要一个可信赖的第三方来进行有效的密钥管理，这本身就是一个大问题。
- en: Cryptographic Hash Functions
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 密码学哈希函数
- en: 'Hash functions are the mathematical functions that are the most important cryptographic
    primitives and are an integral part of blockchain data structure. They are widely
    used in many cryptographic protocols, information security applications such as
    Digital Signatures and message authentication codes (MACs)  . Since it is used
    in asymmetric key cryptography, we will discuss it here prior to getting into
    asymmetric cryptography. Please note that the concepts covered in this section
    may not be in accordance with the academic text books, and a little biased toward
    the blockchain ecosystem.Cryptographic hash functions are a special class of hash
    functions that are apt for cryptography, and we will limit our discussion pertaining
    to it only. So, a cryptographic hash function is a one-way function that converts
    input data of arbitrary length and produces a fixed-length output. The output
    is usually termed “hash value” or “message digest.” It can be represented as shown
    Figure [2-8](A440588_1_En_2_Chapter_split_000.xhtml#Fig8).![A440588_1_En_2_Fig8_HTML.jpg](Images/A440588_1_En_2_Fig8_HTML.jpg)Figure
    2-8Hash function in its basic formFor the hash functions to serve their design
    purpose and be usable, they should have the following core properties:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希函数是数学函数中最重要的密码学原语，是区块链数据结构的一个组成部分。它们在许多密码学协议、信息安全应用（如数字签名和消息认证码（MACs））中得到广泛使用。由于它用于非对称密钥加密，我们将在讨论非对称加密之前先讨论它。请注意，本节涵盖的概念可能与学术教材不符，且偏向于区块链生态系统。密码学哈希函数是一类适合密码学的哈希函数，我们将限制我们讨论与此相关的内容。因此，一个密码学哈希函数是一个单向函数，它将任意长度的输入数据转换为固定长度的输出。输出通常被称为“哈希值”或“消息摘要”。它可以表示为如图[2-8](A440588_1_En_2_Chapter_split_000.xhtml#Fig8)所示。![A440588_1_En_2_Fig8_HTML.jpg](Images/A440588_1_En_2_Fig8_HTML.jpg)图2-8哈希函数的基本形式为了使哈希函数能够发挥其设计目的并可用，它们应具有以下核心属性：
- en: Input can be any string of any size, but the output is of fixed length, say,
    a 256-bit output or a 512-bit output as examples.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入可以是任何大小任意字符串，但输出是固定长度，例如，256位输出或512位输出等。
- en: The hash value should be efficiently computable for any given message.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哈希值应当对于任何给定的消息能够有效计算。
- en: It is deterministic, in the sense that the same input when provided to the same
    hash function produces the same hash value every time.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是确定性的，意思是当相同的输入提供给相同的哈希函数时，每次都会产生相同的哈希值。
- en: It is infeasible (though not impossible!) to invert and generate the message
    from its hash value, except trying for all possible messages.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从其哈希值反向推导和生成消息是不可行的（尽管不是不可能的！）除非尝试所有可能的消息。
- en: Any small change in the message should greatly influence the output hash, just
    so no one can correlate the new hash value with the old one after a small change.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息的任何小变化都应该极大地影响输出哈希，以确保没有人能够在消息进行小变化后的新哈希值与旧哈希值之间建立关联。
- en: 'Apart from the aforementioned core properties, they should also meet the following
    security properties to be considered as a cryptographic protocol:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 除了上述核心属性外，它们还应满足以下安全属性，才能被视为一种密码学协议：
- en: 'Collision resistance: It implies that it is infeasible to find two different
    inputs, say, X and Y, that hash to the same value.![A440588_1_En_2_Figf_HTML.jpg](Images/A440588_1_En_2_Figf_HTML.jpg)This
    makes the hash function H() collision resistant because no one can find X and
    Y, such that H(X) = H(Y). Note that this hash function is a compression function,
    as it compresses a given input to fixed sized output that is shorter than the
    input. So, the input space is too large (anything of any size) compared with the
    output space, which is fixed. If the output is a 256-bit hash value, then the
    output space can have a maximum of 2^(256) values, and not beyond that. This implies
    that a collision must exist. However, it is extremely difficult to find that collision.
    As per the theory of “the birthday paradox,” we can infer that it should be possible
    to find a collision by using the square root of the output space. So, by taking
    2^(128) + 1 inputs, it is highly likely to find a collision; but that is an extremely
    huge number to compute, which is quite infeasible!Let us now discuss where this
    property could be useful. In the majority of online storage, cloud file storage,
    blob storage, App Stores, etc., the property “collision resistance” is widely
    used to ensure the integrity of the files. Example: someone computes the message
    digest of a file and uploads to cloud storage. Later when they download the file,
    they could just compute the message digest again and cross-check with the old
    one they have. This way, it can be ensured if the file was corrupted because of
    some transmission issues or possibly due to some deliberate attempts. It is due
    to the property of collision resistance that no one can come up with a different
    file or a modified file that would hash to the same value as that of the original
    file.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 碰撞阻力：它意味着找到两个不同的输入，比如X和Y，它们散列到同一个值是不切实际的。![A440588_1_En_2_Figf_HTML.jpg](Images/A440588_1_En_2_Figf_HTML.jpg)这使得散列函数H()具有碰撞阻力，因为没有人能找到X和Y，使得H(X)
    = H(Y)。请注意，这个散列函数是一个压缩函数，因为它将给定的输入压缩到固定大小的输出，这个输出比输入短。所以，输入空间太大（任何大小的事物）与输出空间相比，输出空间是固定的。如果输出是一个256位的散列值，那么输出空间最多可以有2^(256)个值，不会超过这个范围。这暗示必须存在一个碰撞。然而，找到这个碰撞是非常困难的。根据“生日悖论”的理论，我们可以推断，通过使用输出空间的平方根，应该可以找到一个碰撞。所以，通过取2^(128)
    + 1个输入，很可能会找到一个碰撞；但这是一个非常巨大的数字，计算起来非常不切实际！现在让我们讨论一下这种属性可能会有什么用处。在大多数在线存储、云文件存储、块存储、应用商店等地方，都广泛使用“碰撞阻力”这一属性来确保文件的完整性。例如：有人计算文件的Message
    Digest并上传到云存储。后来当他们下载文件时，他们可以再次计算Message Digest并进行核对。这样，可以确保文件是否因传输问题或可能因故意的尝试而损坏。正是由于碰撞阻力的属性，没有人能提出一个不同的文件或一个修改过的文件，它散列的值与原始文件相同。
- en: 'Preimage resistance: This property means that it is computationally impossible
    to invert a hash function; i.e., finding the input X from the output H(X) is infeasible.
    Therefore, this property can also be called “hiding” property. Pay close attention
    here; there is another subtle aspect to this situation. Note that when X can be
    anything in the world, this property is easily achieved. However, if there are
    just a limited number of values that X can take, and that is known to the adversary,
    they can easily compute all possible values of X and find which one hashes to
    the outcome.Example: A laboratory decided to prepare the message digests for the
    successful outcome of an experiment so that any adversary who gets access to the
    results database cannot make any sense of it because what is stored in the system
    are hashed outputs. Assume that there can only be three possible outcomes of the
    experiment such as OP111, OP112, and OP113, out of which only one is successful,
    say, OP112\. So, the laboratory decides to hash it, compute H(OP112), and store
    the hashed values in the system. Though an adversary cannot find OP112 from H(OP112),
    they can simply hash all the possible outcomes of the experiment, i.e., H(OP111),
    H(OP112), and H(OP113) and see that only H(OP112) is matching with what is stored
    in the system. Such a situation is certainly vulnerable! This means that, when
    the input to a hash function comes from a limited space and does not come from
    a spread-out distribution, it is weak. However, there is a solution to it as follows:Let
    us take an input, say “X” that is not very spread out, just like the outcomes
    of the experiment we just discussed with a few possible values. If we can concatenate
    that with another random input, say “r,” that comes from a probability distribution
    with high min entropy, then it will be difficult to find X from H(r || X). Here,
    high min entropy means that the distribution is very spread out and there is no
    particular value that is likely to occur. Assume that “r” was chosen from 256-bit
    distribution. For an adversary to get the exact value of “r” that was used along
    with input, there is a success probability of 1/2^(256), which is almost impossible
    to achieve. The only way is to consider all the possible values of this distribution
    one by one—which is again practically impossible. The value “r” is also referred
    to as “nonce.” In cryptography, a nonce is a random number that can be used only
    once.Let us now discuss where this property of preimage resistance could be useful.
    It is very useful in committing to a value, so “commitment” is the use case here.
    This can be better explained with an example. Assume that you have participated
    in some sort of betting or gambling event. Say you have to commit to your option,
    and declare it as well. However, no one should be able to figure out what you
    are betting on, and you yourself cannot deny later on what you bet on. So, you
    leverage the preimage resistance property of Hash Function. You take a hash of
    the choice you are betting on, and declare it publicly. No one can invert the
    hash function and figure out what you are betting on. Also, you cannot later say
    that your choice was different, because if you hash a different choice, it will
    not match what you have declared publicly. It is advisable to use a nonce “r”
    the way we explained in the previous paragraph to design such systems.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预像抵抗性：这一特性意味着从计算角度来看，对一个哈希函数进行逆向工程是不可能的；也就是说，从输出 H(X) 找到输入 X 是不可行的。因此，这一特性也可以被称为“隐藏”特性。在这里要注意，这种情况还有一个微妙的方面。请注意，当
    X 可以是世界上任何东西时，这个特性很容易实现。然而，如果 X 只能取有限几个值，并且这个值被对手所知道，他们可以很容易地计算出 X 的所有可能值，找出哪个值能散列出特定的结果。示例：一个实验室决定为实验的成功结果准备消息摘要，这样任何获取到结果数据库访问权限的对手都无法理解其中的内容，因为系统中存储的是散列后的输出。假设实验只有三个可能的结果，比如
    OP111、OP112 和 OP113，其中只有一个是成功的，比如说 OP112。因此，实验室决定对它进行散列，计算 H(OP112)，并在系统中存储散列值。尽管对手不能从
    H(OP112) 找到 OP112，但他们可以简单地对实验的所有可能结果进行散列，即 H(OP111)、H(OP112) 和 H(OP113)，并看到只有
    H(OP112) 与系统中存储的值相匹配。这种情况当然是非常脆弱的！这意味着，当一个哈希函数的输入来自一个有限的取值空间，并且不是来自一个分散的分布时，它是脆弱的。然而，有一个解决办法，如下所述：
- en: 'Second preimage resistance: This property is slightly different from “collision
    resistant.” It implies that given an input X and its hash H(X), it is infeasible
    to find Y, such that H(X) = H(Y). Unlike in collision-resistant property, here
    the discussion is for a given X, which is fixed. This implies that if a hash function
    is collision resistant already, then it is second preimage resistant also.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二原像抗性：这一属性与“碰撞抗性”略有不同。它意味着，在给定输入X及其哈希H(X)的情况下，找到Y使得H(X) = H(Y)是不可行的。与碰撞抗性属性不同，这里讨论的是给定的X，它是固定的。这表明如果一个哈希函数已经是碰撞抗性的，那么它也是第二原像抗性的。
- en: 'There is another derived property from the properties mentioned that is quite
    useful in Bitcoin. Let us look into it from a technical point of view and learn
    how Bitcoin leverages it for mining when we hit Chapter [3](A440588_1_En_3_Chapter.xhtml).
    The name of this property is “puzzle friendliness.” This name implies that there
    is no shortcut to the solution and the only way to get to the solution is to traverse
    through all the possible options in the input space. We will not try to define
    it here but will directly try to understand what it really means. Let us consider
    this example: H(r || X) = Z, where “r” is chosen from a distribution with high
    min entropy, “X” is the input concatenated with “r,” and “Z” is the hashed output
    value. The property means that it is way too hard for an adversary to find a value
    “Y” that exactly hashes to “Z.” That is, H(r´ || Y) = Z, where r´ is a part of
    the input chosen in the same randomized way as “r.” What this means is that, when
    a part of the input is substantially randomized, it is hard to break the hash
    function with a quick solution; the only way is to test with all possible random
    values.In the previous example, if “Z” is an n-bits output, then it has taken
    just one value out of 2^n possible values. Note carefully that a part of your
    input, say “r,” is from a high min-entropy distribution, which has to be appended
    with your input X. Now comes the interesting part of designing a search puzzle.
    Let’s say Z is an n-bits output and is a set of 2^n possible values, not just
    an exact value. You are asked to find a value of r such that when hashed appended
    with X, it falls within that output set of 2^n values; then it forms a search
    puzzle. The idea is to find all possible values of r till it falls withing the
    range of Z. Note here that the size of Z has limited the output space to a smaller
    set of 2^n possible values. The smaller the output space, the harder is the problem.
    Obviously, if the range is big, it is easier to find a value in it and if the
    range is quite narrow with just a few possibilities, then finding a value within
    that range is tough. This is the beauty of the “r,” called the “nonce” in the
    input to hash function. Whatever random value of r you take, it will be concatenated
    with “X” and will go through the same hash function, again and again, till you
    get the right nonce value “r” that satisfies the required range for Z, and there
    are absolutely no shortcuts to it except for trying all possible values!Note that
    for an n-bit hash value output, an average effort of 2^n is needed to break preimage
    and second preimage resistance, and 2^n/2 for collision resistance.We discussed
    various fundamental and security properties of hash functions. In the following
    sections we will see some important hash functions and dive deeper as applicable.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个从前面提到的属性派生出来的另一个非常有用的属性，这在比特币中相当重要。让我们从技术角度深入探讨一下，当我们进入第[3](A440588_1_En_3_Chapter.xhtml)章时，看看比特币是如何利用它进行挖矿的。这个属性的名字叫“谜题友好性”。这个名称暗示了解决问题没有捷径，唯一的方法是遍历输入空间中的所有可能选项。我们在这里不会尝试定义它，而是直接尝试理解它的真正含义。让我们考虑这样一个例子：H(r
    || X) = Z，其中“r”从一个具有高最小熵的分布中选择，“X”是与“r”连接的输入，“Z”是哈希输出值。这个属性的意思是，对于一个敌手来说，找到一个精确哈希到“Z”的值“Y”是非常困难的。即，H(r'
    || Y) = Z，这里r'是输入的一部分，像“r”一样以随机方式选择。这意味着，当输入的一部分被大大随机化时，用快速解决方案破解哈希函数是非常困难的；唯一的方法是测试所有可能的随机值。在前一个例子中，如果“Z”是一个n位输出，那么它只是2^n可能值中的一个。注意，你的输入的一部分，比如“r”，来自一个高最小熵分布，必须与你的输入X连接。现在来看看设计搜索谜题的有趣部分。假设Z是一个n位输出，是一组2^n可能的值，而不仅仅是确切的值。你被要求找到一个r的值，当它与X一起哈希时，它落在这个2^n值的输出集合中；然后它形成了一个搜索谜题。想法是找到所有可能的r值，直到它落入了Z的范围。注意这里，Z的大小将输出空间限制在了2^n可能的值的一个较小的集合中。输出空间越小，问题越难。显然，如果范围很大，找到其中的一个值就越容易，如果范围相当狭窄，只有少数可能性，那么在这个范围内找到一个值就很难。这是输入到哈希函数中的“r”的美丽之处，它被称为“nonce”。无论你取什么随机值r，它将与“X”连接，并多次通过同一个哈希函数，直到你得到满足Z所需范围的正确的nonce值“r”，除了尝试所有可能的值，没有其他的捷径！注意，对于一个n位哈希值输出，平均需要2^n的努力来破坏预图像和第二预图像阻力，以及2^n/2来破坏碰撞阻力。我们讨论了各种哈希函数的基本和安全属性。在接下来的章节中，我们将看到一些重要的哈希函数，并尽可能深入探讨。
- en: A Heads-up on Different Hash Functions
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 不同哈希函数的概述
- en: One of the oldest hash functions or compression function is the MD4 hash function.
    It belongs to the message digest (MD) family. Other members of the MD family are
    MD5 and MD6, and there are many other variants of MD4 such as RIPEMD. The MD family
    of algorithms produce a 128-bit message digest by consuming 512-bit blocks. They
    were widely used as checksums to verify data integrity. Many file servers or software
    repositories used to provide a precomputed MD5 checksum, which the users could
    check against the file they downloaded. However, there were a lot of vulnerabilities
    found in the MD family and it was deprecated.Another such hash function family
    is the Secure Hash Algorithm (SHA) family. There are basically four algorithms
    in this family, such as SHA-0, SHA-1, SHA-2, and SHA-3\. The first algorithm proposed
    in this family was named SHA, but newer versions were coming with security fixes
    and updates, so a retronym was applied to it and it was made SHA-0\. It was found
    to have a serious yet undisclosed security flaw and was discontinued. Later, SHA-1
    was proposed as a replacement to SHA-0\. SHA-1 had an extra computational step
    that addressed the problem in SHA-0\. Both SHA-0 and SHA-1 were 160-bit hash functions
    that consumed 512-bit block sizes. SHA-1 was designed by the National Security
    Agency (NSA)  to use it in the digital signature algorithm (DSA)  . It was used
    quite a lot in many security tools and Internet protocols such as SSL, SSH, TSL,
    etc. It was also used in version control systems such as Mercurial, Git, etc.
    for consistency checks, and not really for security. Later, around 2005, cryptographic
    weaknesses were found in it and it was deprecated after the year 2010\. We will
    get into SHA-2 and SHA-3 in detail in the following sections.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 最早的哈希函数或压缩函数之一是MD4哈希函数。它属于消息摘要（MD）系列。MD系列的其它成员有MD5和MD6，还有许多MD4的其他变体，如RIPEMD。MD系列算法通过消耗512位块产生一个128位的消息摘要。它们被广泛用作校验和，以验证数据完整性。许多文件服务器或软件仓库过去常常提供一个预计算的MD5校验和，用户可以将其与下载的文件进行比对。然而，在MD系列中发现了许多漏洞，因此它被弃用。另一个这样的哈希函数系列是安全哈希算法（SHA）系列。这个系列基本上有四个算法，如SHA-0、SHA-1、SHA-2和SHA-3。这个系列中提出的第一个算法被称为SHA，但后来随着安全修复和更新，出现了新的版本，因此给它起了一个后缀，变成了SHA-0。被发现存在一个严重但未公开的安全漏洞，因此被废弃。后来，SHA-1被提出作为SHA-0的替代品。SHA-1有一个额外的计算步骤，解决了SHA-0的问题。SHA-0和SHA-1都是160位哈希函数，块大小为512位。SHA-1是由美国国家安全局（NSA）设计，用于数字签名算法（DSA）。它在许多安全工具和互联网协议（如SSL、SSH、TSL等）中得到了广泛应用。它还在Mercurial、Git等版本控制系统中用于一致性检查，并非真正用于安全。后来，大约在2005年，发现了它的密码学弱点，并在2010年之后被弃用。我们将在接下来的章节中详细介绍SHA-2和SHA-3。
- en: SHA-2
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: SHA-2
- en: 'It belongs to the SHA family of hash functions, but itself is a family of hash
    functions. It has many SHA variants such as SHA-224, SHA-256, SHA-384, SHA-512,
    SHA-512/224, and SHA-512/256\. SHA-256 and SHA-512 are the primitive hash functions
    and the other variants are derived from them. The SHA-2 family of hash functions
    are widely used in applications such as SSL, SSH, TSL, PGP, MIME, etc.SHA-224
    is a truncated version of SHA-256 with a different initial value or initialization
    vector (IV). Note that the SHA variants with different truncations applied can
    produce the same bit length hash outputs, hence different initialization vectors
    are applied in different SHA variants to be able to properly differentiate them.
    Now coming back to the SHA-224 computation, it is a two-step process. First, SHA-256
    value is computed with a different IV compared with the default one used in SHA-256\.
    Second, the resulting 256-bit hash value is truncated to 224-bit; usually the
    224 bits from left are kept, but the choice is all yours.SHA-384 is a truncated
    version of SHA-512, just the way SHA-224 is a truncated version of SHA-256\. Similarly,
    both 512/224 and SHA-512/256 are truncated versions of SHA-512\. Are you wondering
    why this concept of “truncation” exists? Note that truncation is not just limited
    to the ones we just mentioned, and there can be various other variants as well.
    The primary reasons for truncation could be as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 它属于SHA家族的哈希函数，但本身就是一个哈希函数家族。它有许多SHA变体，如SHA-224、SHA-256、SHA-384、SHA-512、SHA-512/224和SHA-512/256。SHA-256和SHA-512是最基础的哈希函数，其他变体都来源于此。SHA-2家族的哈希函数在SSL、SSH、TSL、PGP、MIME等应用程序中广泛使用。SHA-224是SHA-256的一个截断版本，具有不同的初始值或初始化向量（IV）。请注意，具有不同截断应用的SHA变体可以产生相同位长的哈希输出，因此不同SHA变体中应用不同的初始化向量，以便能够正确地区分它们。现在回到SHA-224的计算，它是一个两步过程。首先，使用与SHA-256中默认的不同的IV计算SHA-256值。其次，将结果的256位哈希值截断为224位；通常保留左边的224位，但选择权在你。SHA-384是SHA-512的截断版本，正如SHA-224是SHA-256的截断版本一样。同样，512/224和SHA-512/256也都是SHA-512的截断版本。你可能会想知道为什么存在“截断”这个概念？请注意，截断不仅限于我们刚才提到的那些，还可能存在其他各种变体。截断的主要原因可能如下：
- en: Some applications require a message digest with a certain length that is different
    from the default ones.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些应用程序需要特定长度的消息摘要，与默认的长度不同。
- en: 'Irrespective of the SHA-2 variant we are using, we can select a truncation
    level depending on what security property we want to sustain. Example: Considering
    today’s state of computing power, when collision resistance is necessary, we should
    keep at least 160 bits and when only preimage-resistance is necessary, we should
    keep at least 80 bits. The security property such as collision resistance decreases
    with truncation, but it should be chosen such that it would be computationally
    infeasible to find a collision.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无论我们使用的是SHA-2的哪个变体，我们都可以根据我们希望维持的安全属性选择一个截断级别。示例：考虑到当今的计算能力，当需要抗碰撞性时，我们应该至少保留160位，而当只需要抗预图像性时，我们应该至少保留80位。这样的安全属性如抗碰撞性会随着截断而降低，但应该选择这样，即找到一个碰撞在计算上是不切实际的。
- en: 'Truncation also helps maintain the backward compatibility with older applications.
    Example: SHA-224 provides 112-bit security that can match the key length of triple-DES
    (3DES).'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 截断也有助于与较旧的应用程序保持向后兼容。例如：SHA-224提供112位的安全性，可以与三DES（3DES）的密钥长度相匹配。
- en: Talking about efficiency, SHA-256 is based on a 32-bit word and SHA-512 is based
    on a 64-bit word. So, on a 64-bit architecture, SHA-512 and all its truncated
    variants can be computed faster with a better level of security compared with
    SHA-1 or other SHA-256 variants.Table [2-3](A440588_1_En_2_Chapter_split_000.xhtml#Tab3)
    is a tabular representation taken from the NIST paper that represents SHA-1 and
    different SHA-2 algorithms properties in a nutshell.Table 2-3SHA-1 & SHA-2 Hash
    Function in a Nutshell![A440588_1_En_2_Figg_HTML.jpg](Images/A440588_1_En_2_Figg_HTML.jpg)As
    a rule of thumb, it is advisable not to truncate when not necessary. Certain hash
    functions tolerate truncation and some don’t, and it also depends on how you are
    using it and in what context.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 谈到效率，SHA-256是基于32位单词的，而SHA-512是基于64位单词的。因此，在64位架构上，与SHA-1或其他SHA-256变体相比，SHA-512及其所有截断变体可以更快地计算，并且具有更高的安全性。[表2-3](A440588_1_En_2_Chapter_split_000.xhtml#Tab3)是从NIST论文中摘取的表格，简要代表了SHA-1和不同SHA-2算法的特性。表2-3SHA-1
    & SHA-2 哈希函数一览！[A440588_1_En_2_Figg_HTML.jpg](Images/A440588_1_En_2_Figg_HTML.jpg)一般来说，如果没有必要，建议不要截断。某些哈希函数可以容忍截断，而有些则不行，这也取决于您的使用方式和上下文。
- en: SHA-256 and SHA-512
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: SHA-256 和 SHA-512
- en: 'As mentioned already, SHA-256 belongs to the SHA-2 family of hash functions,
    and this is the one used in Bitcoins! As the name suggests, it produces a 256-bit
    hash value, hence the name. So, it can provide 2^(128)-bit security as per the
    birthday paradox.Recall that the hash functions take arbitrary length input and
    produce a fixed size output. The arbitrary length input is not fed as is to the
    compression function and is broken into fixed length blocks before it is fed to
    the compression function. This means that a construction method is needed that
    can iterate through the compression function by constructing fixed-sized input
    blocks from arbitrary length input data and produce a fixed length output. There
    are various types of construction methods such as Merkle-Damgård construction,
    tree construction, and sponge construction. It is proven that if the underlying
    compression function is collision resistant, then the overall hash function with
    any construction method should also be collision resistant.The construction method
    that SHA-256 uses is the Merkle-Damgård construction, so let us see how it works
    in Figure [2-9](A440588_1_En_2_Chapter_split_000.xhtml#Fig9).![A440588_1_En_2_Fig9_HTML.jpg](Images/A440588_1_En_2_Fig9_HTML.jpg)Figure
    2-9Merkle-Damgård construction for SHA-256Referring to the diagram, the following
    steps (presented at a high level) are executed in the order specified to compute
    the final hash value:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，SHA-256属于SHA-2哈希函数家族，这个函数用于比特币！正如其名，它产生一个256位的哈希值，因此得名。所以，根据生日悖论，它可以提供2^(128)位的安全性。回想一下，哈希函数接受任意长度的输入并生成固定大小的输出。任意长度的输入不是直接输入到压缩函数中的，而是在输入到压缩函数之前被分成固定长度的块。这意味着需要一种构建方法，可以通过从任意长度的输入数据构建固定大小的输入块，并通过压缩函数迭代并生成固定长度的输出。有各种类型的构建方法，如Merkle-Damgård构建、树构建和吸水构建。已证明，如果底层压缩函数是抗碰撞的，那么使用任何构建方法的整个哈希函数也应该是抗碰撞的。SHA-256使用的构建方法是Merkle-Damgård构建，让我们看看它是如何工作的，如图[2-9](A440588_1_En_2_Chapter_split_000.xhtml#Fig9)所示。![A440588_1_En_2_Fig9_HTML.jpg](Images/A440588_1_En_2_Fig9_HTML.jpg)图2-9SHA-256的Merkle-Damgård构建根据图表，以下步骤（以高层次呈现）按照指定顺序执行以计算最终哈希值：
- en: As you can see in the diagram, the message is first divided into 512-bit blocks.
    When the message is not an exact multiple of 512 bits (which is usually the case),
    the last block falls short of bits, hence it is padded to make it 512 bits.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如您在图中看到的，消息首先被划分为512位的块。当消息不是512位的整数倍（这通常是情况），最后一个块的字节数不足，因此需要填充以使其达到512位。
- en: The 512-bit blocks are further divided into 16 blocks of 32-bit words (16 ×
    32 = 512).
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 512位块进一步分为16个32位单词的块（16 × 32 = 512）。
- en: Each block goes through 64 rounds of round function where each 32-bit word goes
    through a series of operations. The round functions are a combination of some
    common functions such as XOR, AND, OR, NOT, Bit-wise Left/Right Shift, etc. and
    we will not get into those details in this book.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个块都要经历64轮轮函数，其中每个32位单词都要经历一系列操作。轮函数是XOR、AND、OR、NOT、位左/右移等常见函数的组合，我们在这本书中不会详细介绍这些内容。
- en: Similar to SHA-256, the steps and the operations are quite similar in SHA-512,
    as SHA-512 also uses Merkle-Damgård construction. The major difference is that
    there are 80 rounds of round functions in SHA-512 and the word length is 64 bits.
    The block size in SHA-512 is 1024 bits, which gets further divided into 16 blocks
    of 64-bit words The output message digest is 512 bits in length, that is, eight
    blocks of 64-bit words. While SHA-512 was gaining momentum, and started being
    used in many applications, a few people turned to the SHA-3 algorithm to be future
    ready. SHA-3 is just a different approach to hashing and not a real replacement
    to SHA-256 or SHA-512, though it allows tuning. We will learn a few more details
    about SHA-3 in the following sections.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 与SHA-256相似，SHA-512的步骤和操作也非常相似，因为SHA-512也使用了Merkle-Damgård构造。主要区别在于SHA-512中有80个轮函数，词长为64位。SHA-512的块大小为1024位，进一步分为16个64位词的块。消息摘要的输出长度为512位，即八个64位词的块。当SHA-512开始势头强劲，并被许多应用程序采用时，有少数人开始转向SHA-3算法以应对未来。SHA-3只是散列的一种不同方法，并不是SHA-256或SHA-512的真正替代，尽管它允许调整。我们将在接下来的章节中了解更多关于SHA-3的详细信息。
- en: RIPEMD
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: RIPEMD
- en: RACE Integrity Primitives Evaluation Message Digest (RIPEMD) hash function is
    a variant of the MD4 hash function with almost the same design considerations.
    Since it is used in Bitcoins, we will have a brief discussion on it.The original
    RIPEMD was of 128 bits, later RIPEMD-160 was developed. There exist 128-, 256-,
    and 320-bit versions of this algorithm, called RIPEMD-128, RIPEMD-256, and RIPEMD-320,
    respectively, but we will limit our discussion to the most popular and widely
    used RIPEMD-160.RIPEMD-160 is a cryptographic hash function whose compression
    function is based on the Merkle–Damgård construction. The input is broken into
    512-bit blocks and padding is applied when the input bits are not a multiple of
    512\. The 160-bit hash value output is usually represented as 40-digit hexadecimal
    numbers.The compression function is made up of 80 stages, made up of two parallel
    lines of five rounds of 16 steps each (5 × 16 = 80). The compression function
    works on sixteen 32-bit words (512-bit blocks).NoteBitcoin uses both SHA-256 and
    RIPEMD-160 hashes together for address generation. RIPEMD-160 is used to further
    shorten the hash value output of SHA-256 to 160 bits.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: RACE完整性原语评估消息摘要（RIPEMD）散列函数是MD4散列函数的变体，设计考虑几乎相同。因为它在Bitcoins中使用，所以我们将在这里简要讨论它。最初的RIPEMD为128位，后来开发了RIPEMD-160。这个算法的128位、256位和320位版本分别称为RIPEMD-128、RIPEMD-256和RIPEMD-320，但我们将在最受欢迎且广泛使用的RIPEMD-160上限制我们的讨论。RIPEMD-160是一种基于Merkle-Damgård构造的密码散列函数。输入被分成512位块，当输入位不是512的倍数时应用填充。160位的散列值输出通常表示为40位十六进制数。压缩函数由80个阶段组成，由两条并行的五轮16步的线路组成（5×16=80）。压缩函数对十六个32位的词（512位块）进行操作。注意：Bitcoin用于生成地址时同时使用SHA-256和RIPEMD-160散列。RIPEMD-160用于进一步将SHA-256的散列值输出缩短至160位。
- en: SHA-3
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: SHA-3
- en: 'In 2015, the Keccak (pronounced as “ket-chak”) algorithm was standardized by
    the NIST as the SHA-3\. Note that the purpose was not really to replace the SHA-2
    standard, but to complement and coexist with it, though one can choose SHA-3 over
    SHA-2 in some situations.Since both SHA-1 and SHA-2 were based on Merkle-Damgård
    construction, a different approach to hash function was desirable. So, not using
    Merkle-Damgård construction was one of the criteria set by the NIST. This was
    because the new design should not suffer from the limitations of Merkle-Damgård
    construction such as multicollision. Keccak, which became SHA-3, used a different
    construction method called sponge construction.In order to make it backward compatible,
    it was required that SHA-3 should be able to produce variable length outputs such
    as 224, 256, 384, and 512 bits and also other arbitrary length outputs. This way
    SHA-3 became a family of cryptographic hash functions such as SHA3-224, SHA3-256,
    SHA3-384, SHA3 -512, and two extendable-output functions (XOFs), called SHAKE128
    and SHAKE256\. Also, SHA-3 had to have a tunable parameter (capacity) to allow
    a tradeoff between security and performance. Since SHAKE128 and SHAKE256 are XOFs,
    their output can be extended to any desired length, hence the name.The following
    diagram (Figure [2-10](A440588_1_En_2_Chapter_split_000.xhtml#Fig10)) shows how
    SHA-3 (Keccak algorithm) is designed at a high level.![A440588_1_En_2_Fig10_HTML.jpg](Images/A440588_1_En_2_Fig10_HTML.jpg)Figure
    2-10Sponge construction for SHA-3A series of steps that take place for SHA-3 are
    as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 2015年，Keccak（发音为“ket-chak”）算法被NIST标准化为SHA-3。请注意，目的并不是真的要取代SHA-2标准，而是要与之互补共存，尽管在某些情况下可以选择SHA-3而不是SHA-2。由于SHA-1和SHA-2都是基于Merkle-Damgård构造的，因此需要一种不同的哈希函数方法。因此，不使用Merkle-Damgård构造是NIST设定的标准之一。这是因为新设计不应受到Merkle-Damgård构造的限制，如多碰撞。Keccak，即SHA-3，使用了一种不同的构造方法，称为吸收构造。为了使其向后兼容，要求SHA-3能够生成可变长度的输出，如224、256、384和512位，以及其他任意长度的输出。这样SHA-3就成为了一组加密哈希函数，如SHA3-224、SHA3-256、SHA3-384、SHA3-512以及两个可扩展输出函数（XOFs），称为SHAKE128和SHAKE256。此外，SHA-3必须有一个可调整的参数（容量），以允许在安全和性能之间进行权衡。由于SHAKE128和SHAKE256是XOFs，它们的输出可以扩展到任何所需的长度，因此得名。以下图表（图[2-10](A440588_1_En_2_Chapter_split_000.xhtml#Fig10)）展示了SHA-3（Keccak算法）的高级设计方式。![A440588_1_En_2_Fig10_HTML.jpg](Images/A440588_1_En_2_Fig10_HTML.jpg)图2-10
    SHA-3的吸收构造一系列在SHA-3中发生的过程如下：
- en: As you can see in Figure [2-10](A440588_1_En_2_Chapter_split_000.xhtml#Fig10),
    the message is first divided into blocks (x[i]) of size r bits. If the input data
    is not a multiple of r bits, then padding is required. If you are wondering about
    this r, do not worry, we will get to it in a little while. Now, let us focus on
    how this padding happens. For a message block x[i] which is not a multiple of
    r and has some message m in it, padding happens as shown in the following:x[i]
    = m || P 1 {0}* 1“P” is a predetermined bit string followed by 1 {0}* 1, which
    means a leading and trailing 1 and some number of zeros (could be no zero bits
    also) that can make x[i] a multiple of r. Table [2-4](A440588_1_En_2_Chapter_split_000.xhtml#Tab4)
    shows the various values of P.Table 2-4Padding in SHA-3 variants![A440588_1_En_2_Figh_HTML.jpg](Images/A440588_1_En_2_Figh_HTML.jpg)
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正如图[2-10](A440588_1_En_2_Chapter_split_000.xhtml#Fig10)所示，消息首先被划分为大小为r位的块(x[i])。如果输入数据不是r位的倍数，那么需要进行填充。关于这个r，你可能会好奇，但不用担心，我们稍后会讲解。现在，让我们关注填充是如何发生的。对于一个不是r倍数的消息块x[i]，并且里面有一些消息m，填充的发生如下所示：x[i]
    = m || P 1 {0}* 1“P”是一个预先确定的位串，后面跟着1 {0}* 1，这意味着一个前导和后导1以及一些零（也可能没有零位），这可以使x[i]成为r的倍数。表[2-4](A440588_1_En_2_Chapter_split_000.xhtml#Tab4)展示了P的各种值。表2-4
    SHA-3变体中的填充！[A440588_1_En_2_Figh_HTML.jpg](Images/A440588_1_En_2_Figh_HTML.jpg)
- en: 'As you can see in Figure [2-10](A440588_1_En_2_Chapter_split_000.xhtml#Fig10),
    there are broadly two phases to SHA-3 sponge construction: the first one is the
    “Absorbing” phase for input, and the second one is the “Squeezing” phase for output.
    In the Absorbing phase, the message blocks (x[i]) go through various operations
    of the algorithm and in the Squeezing phase, the output of configurable length
    is computed. Notice that for both of these phases, the same function called “Kecaak-f”
    is used.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正如图[2-10](A440588_1_En_2_Chapter_split_000.xhtml#Fig10)所示，SHA-3吸收构造大致分为两个阶段：第一个阶段是输入的“吸收”阶段，第二个阶段是输出的“压缩”阶段。在吸收阶段，消息块（x[i]）经历算法的各种操作，而在压缩阶段，计算出可配置长度的输出。注意，对于这两个阶段，都使用了同一个名为“Kecaak-f”的函数。
- en: For the computation of SHA3-224, SHA3-256, SHA3-384, SHA3 -512, which is effectively
    a replacement of SHA-2, only the first bits of the first output block y[0] are
    used with required level of truncation.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 SHA3-224、SHA3-256、SHA3-384、SHA3-512 的计算，这是 SHA-2 的有效替换，只使用第一个输出块 y[0] 的前几位进行所需的截断级别。
- en: The SHA-3 is designed to be tunable for its security strength, input, and output
    sizes with the help of tuning parameters.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SHA-3 设计为可调整其安全强度、输入和输出大小，这要归功于调节参数。
- en: As you can see in the diagram, “b” represents the width of the state and requires
    that r + c = b. Also, “b” depends on the exponent “ℓ” such that b = 25 × 2^ℓ
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正如您在图中所看到的，“b”代表状态的宽度，并且要求 r + c = b。另外，“b”取决于指数“ℓ”，即 b = 25 × 2^ℓ
- en: Since “ℓ” can take on values between 0 and 6, “b”can have widths {25, 50, 100,
    200, 400, 800 and 1600}. It is advisable not to use the smallest two values of
    “b” in practice as they are just there to analyze and perform cryptanalysis on
    the algorithm.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于“ℓ”可以取0到6的值，“b”可以有宽度 {25, 50, 100, 200, 400, 800 和 1600}。建议不要在实际中使用“b”的最小两个值，因为它们只是为了分析和对算法进行密码分析。
- en: In the equation r + c = b, the “r” that we see is what we used to preprocess
    the message and divided into blocks of length “r.” This is called the “bit rate.”
    Also, the parameter “c” is called the capacity that just has to satisfy the condition
    r + c = b ∈ {25, 50, 100, 200, 400, 800, 1600} and get computed. This way “r”
    and “c” are used as tuning parameters to trade off between security and performance.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在方程 r + c = b 中，我们看到的“r”是我们用来预处理消息并划分为长度为“r”的块所用的。这称为“比特率”。另外，参数“c”称为容量，只需满足
    r + c = b ∈ {25, 50, 100, 200, 400, 800, 1600} 并计算得出。这样“r”和“c”就被用作在安全和性能之间进行权衡的调节参数。
- en: 'For SHA-3, the exponent value ℓ is fixed to be “6,” so the value of b is 1600
    bits. For this given b = 1600, two bit-rate values are permissible: r = 1344 and
    r = 1088\. This leads to two distinct values of “c.” So, for r = 1344, c = 256
    and for r = 1088, c = 512.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 SHA-3，指数值 ℓ 被固定为“6”，所以 b 的值为 1600 位。对于给定的 b = 1600，两个比特率值是允许的：r = 1344 和
    r = 1088。这导致两个不同的“c”值。所以，当 r = 1344 时，c = 256，当 r = 1088 时，c = 512。
- en: 'Let us now look at the core engine of this algorithm, i.e. Keccak-f, which
    is also called “Keccak-f Permutation.” There are “n” rounds in each Keccak-f,
    where “n” is computed as: n = 12 + 2ℓ. Since the value of ℓ is 6 for SHA-3, there
    will be 24 rounds in each Keccak-f. Every round takes “b” bits (r + c) input and
    produces the same number of “b” bits as output.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在让我们看看该算法的核心引擎，即 Keccak-f，也称为“Keccak-f 置换”。每个 Keccak-f 中有“n”轮，其中“n”计算为：n =
    12 + 2ℓ。由于 SHA-3 中 ℓ 的值为 6，每个 Keccak-f 将有 24 轮。每一轮都接受“b”位（r + c）的输入并产生同样数量的“b”位输出。
- en: In each round, the input “b” is called a state. This state array “b” can be
    represented as a three-dimensional (3-D) array b = (5 x 5 × w), where word size
    w = 2^ℓ. So, w = 64 bits, which means 5 × 5 = 25 words of 64 bits each. Recall
    that ℓ = 6 for SHA-3, so b = 5 × 5 x 64 = 1600\. The 3-D array can be shown as
    in Figure [2-11](A440588_1_En_2_Chapter_split_000.xhtml#Fig11).![A440588_1_En_2_Fig11_HTML.jpg](Images/A440588_1_En_2_Fig11_HTML.jpg)Figure
    2-11State array representationin SHA-3
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每个轮次中，输入“b”被称为状态。这个状态数组“b”可以表示为一个三维（3-D）数组 b = (5 x 5 × w)，其中词大小 w = 2^ℓ。所以，w
    = 64 位，这意味着 5 × 5 = 25 个 64 位单词。回想一下，对于 SHA-3，ℓ = 6，所以 b = 5 × 5 x 64 = 1600。三维数组可以如图
    [2-11](A440588_1_En_2_Chapter_split_000.xhtml#Fig11) 所示展示！[A440588_1_En_2_Fig11_HTML.jpg](Images/A440588_1_En_2_Fig11_HTML.jpg)图
    2-11 SHA-3 中的状态数组表示
- en: Each round consists of a sequence of five steps and the state array gets manipulated
    in each of those steps as shown in Figure [2-12](A440588_1_En_2_Chapter_split_000.xhtml#Fig12).![A440588_1_En_2_Fig12_HTML.jpg](Images/A440588_1_En_2_Fig12_HTML.jpg)Figure
    2-12The five steps in each SHA-3 round
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个轮次由一个由五个步骤组成的序列组成，状态数组在每个步骤中都如 图 [2-12](A440588_1_En_2_Chapter_split_000.xhtml#Fig12)
    所示被操作！[A440588_1_En_2_Fig12_HTML.jpg](Images/A440588_1_En_2_Fig12_HTML.jpg)图 2-12每个
    SHA-3 轮次的五个步骤
- en: 'Without getting into much detail into each of the five steps, let us quickly
    learn what they do at a high level:'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不过多详细介绍每个五个步骤，让我们快速了解它们在高级别上做什么：
- en: 'Theta (θ) step: It performs the XOR operation to provide minor diffusion.'
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: θ（Theta）步骤：它执行异或操作以提供轻微扩散。
- en: 'Rho (ρ) step: It performs bitwise rotation of each of the 25 words.'
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: ρ（Rho）步骤：它对每个 25 个单词执行位旋转。
- en: 'Pi (π) step: It performs permutation of each of the 25 words.'
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: π（Pi）步骤：它对每个 25 个单词执行置换。
- en: 'Chi (χ) step: In this step, bits are replaced by combining those with their
    two subsequent bits in their rows.'
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: χ（Chi）步骤：在这个步骤中，位是通过将它们与其后续的两个位在行中结合来替换的。
- en: 'Iota (ι) step: It XORs a round constant into one word of the state to break
    the symmetry.'
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Iota（ι）步骤：它将一个轮常数XOR到一个状态字中，以打破对称性。
- en: The last round of Keccak-f produces the y[0] output, which is enough for SHA-2
    replacement mode, i.e., the output with 224, 256, 384, and 512 bits. Note that
    the least significant bits of y[0] are used for the desired length output. In
    case of variable length output, along with y[0], other output bits of y[1], y[2],
    y[3]… can also be used.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Keccak-f的最后一轮产生了y[0]输出，这对于SHA-2替换模式来说已经足够了，即224、256、384和512位的输出。注意y[0]的最不重要位用于所需长度的输出。在可变长度输出的情况下，除了y[0]之外，y[1]、y[2]、y[3]…的其它输出位也可以使用。
- en: When it comes to the real-life implementation of SHA-3, it is found that its
    performance is good in software (though not as good as SHA-2) and is excellent
    in hardware (better than SHA-2).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论SHA-3的实际实现时，发现其在软件中的表现良好（虽然不如SHA-2），在硬件中表现卓越（优于SHA-2）。
- en: Applications of Hash Functions
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 哈希函数的应用
- en: 'The cryptographic hash functions have many different usages in different situations.
    Following are a few example use cases:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 密码学哈希函数在不同的情况下有许多不同的用途。以下是一些示例用例：
- en: Hash functions are used in verifying the integrity and authenticity of information.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哈希函数用于验证信息的完整性和真实性。
- en: Hash functions can also be used to index data in hash tables. This can speed
    up the process of searching. Instead of the whole data, if we search based on
    the hashes (assuming the much shorter hash value compared with the whole data),
    then it should obviously be faster.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哈希函数还可以用来在哈希表中索引数据。这可以加快搜索过程。我们不是根据整个数据搜索，而是根据哈希值（假设与整个数据相比，哈希值要短得多）进行搜索，那么显然会更快。
- en: They can be used to securely authenticate the users without storing the passwords
    locally. Imagine a situation where you do not want to store passwords on the server,
    obviously because if an adversary hacks on to the server, they cannot get the
    password from their stored hashes. Every time a user tries to log in, hash of
    the punched in password is calculated and matched against the stored hash. Secured,
    isn’t it?
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以用来安全地验证用户，而不需要在本地存储密码。想象一个你不希望在服务器上存储密码的情况，显然是因为如果敌手黑进服务器，他们无法从存储的哈希值中获取密码。每次用户尝试登录时，输入密码的哈希值会被计算出来并与存储的哈希值进行匹配。安全，不是吗？
- en: Since hash functions are one-way functions, they can be used to implement PRNG.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于哈希函数是一对一函数，它们可以用来实现伪随机数生成器（PRNG）。
- en: Bitcoin uses hash functions as a proof of work (PoW) algorithm. We will get
    into the details of it when we hit the Bitcoin chapter.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比特币使用哈希函数作为工作量证明（PoW）算法。当我们涉及到比特币章节时，我们将详细介绍它。
- en: Bitcoin also uses hash functions to generate addresses to improve security and
    privacy.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比特币还使用哈希函数生成地址以提高安全和隐私。
- en: The two most important applications are digital signatures and in MACs such
    as hash-based message authentication codes (HMACs).
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个最重要的应用是数字签名和基于哈希的消息认证码（HMACs）的MACs。
- en: Understanding the working and the properties of the hash functions, there can
    be various other use cases where hash functions can be used.NoteThe Internet Engineering
    Task Force (IETF) adopted version 3.0 of the SSL (SSLv3) protocol in 1999, renamed
    it to Transport Layer Security (TLS) version 1.0 (TLSv1) protocol and defined
    it in RFC 2246\. SSLv3 and TLSv1 are compatible as far as the basic operations
    are concerned.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 理解哈希函数的工作原理和属性，可以有各种各样的其他用例可以使用哈希函数。注：互联网工程任务组（IETF）在1999年采用了SSL（SSLv3）协议的3.0版本，将其重命名为传输层安全（TLS）协议1.0版本（TLSv1），并在RFC
    2246中定义了它。SSLv3和TLSv1在基本操作方面是兼容的。
- en: Code Examples of Hash Functions
  id: totrans-147
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 哈希函数的代码示例
- en: 'Following are some code examples of different hash functions. This section
    is just intended to give you a heads-up on how to use the hash functions programatically.
    Code examples are in Python but would be quite similar in different languages;
    you just have to find the right library functions to use.# -*- coding: utf-8 -*-import
    hashlib# hashlib module is a popular module to do hashing in python#Constructors
    of md5(), sha1(), sha224(), sha256(), sha384(), and sha512() present in hashlibmd=hashlib.md5()md.update("The
    quick brown fox jumps over the lazy dog")print md.digest()print "Digest Size:",
    md.digest_size, "\n", "Block Size: ", md.block_size# Comparing digest of SHA224,
    SHA256,SHA384,SHA512print "Digest SHA224", hashlib.sha224("The quick brown fox
    jumps over the lazy dog").hexdigest()print "Digest SHA256", hashlib.sha256("The
    quick brown fox jumps over the lazy dog").hexdigest()print "Digest SHA384", hashlib.sha384("The
    quick brown fox jumps over the lazy dog").hexdigest()print "Digest SHA512", hashlib.sha512("The
    quick brown fox jumps over the lazy dog").hexdigest()# All hashoutputs are unique#
    RIPEMD160 160 bit hashing exampleh = hashlib.new(''ripemd160'')h.update("The quick
    brown fox jumps over the lazy dog")h.hexdigest()#Key derivation Alogithm:#Native
    hashing algorithms are not resistant against brutefore attack.#Key deviation algorithms
    are used for securing password hashing.import hashlib, binasciialgorithm=''sha256''password=''HomeWifi''salt=''salt''
    # salt is random data that can be used as an additional input to a one-way functionnu_rounds=1000key_length=64
    #dklen is the length of the derived keydk = hashlib.pbkdf2_hmac(algorithm,password,
    salt, nu_rounds, dklen=key_length)print ''derieved key: '',dkprint ''derieved
    key in hexadeximal :'', binascii.hexlify(dk)# Check properties for hashimport
    hashlibinput = "Sample Input Text"for i in xrange(20):    # add the iterator to
    the end of the text    input_text = input + str(i)        # show the input and
    hash result    print input_text, '':'',  hashlib.sha256(input_text).hexdigest()'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些不同哈希函数的代码示例。本节旨在为您提供关于如何程序化使用哈希函数的预警。代码示例是用 Python 编写的，但在不同的语言中会非常相似；你只需要找到正确的库函数来使用。
- en: MAC and HMAC
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MAC 和 HMAC
- en: 'HMAC is a type of MAC (message authentication code)  . As the name suggests,
    a MAC’s purpose is to provide message authentication using Symmetric Key and message
    integrity using hash functions. So, the sender sends the MAC along with the message
    for the receiver to verify and trust it. The receiver already has the key K (as
    symmetric key cryptography is being used, so both sender and receiver have agreed
    on it already); they just use it to compute the MAC of the message and check it
    against the MAC that was sent along with the message.In its simplest form, MAC
    = H(key || message). HMAC is actually a technique to turn the hash functions into
    MACs. In HMAC, the hash functions can be applied multiple times along with the
    key and its derived keys. HMACs are widely used in RFID-based systems, TLS, etc.
    In SSL/TLS (HTTPS is TTP within SSL/TLS), HMAC is used to allow client and server
    to verify and ensure that the exchanged data has not been altered during transmission.
    Let us take a look at a few of the important MAC strategies that are widely used:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希消息验证码（HMAC）是一种验证码。正如其名，验证码的目的是使用对称密钥和哈希函数提供消息验证和完整性。因此，发送方会发送验证码和消息供接收方验证和信任。接收方已经拥有密钥K（因为使用了对称密钥加密，所以发送方和接收方已经就它达成一致）；他们只是使用它来计算消息的验证码，并与发送的消息一起发送的验证码进行比对。在它的最简单形式中，验证码
    = H(密钥 || 消息)。HMAC实际上是一种将哈希函数转换为验证码的技术。在HMAC中，哈希函数可以多次与密钥及其派生密钥一起使用。HMAC在RFID系统、TLS等广泛使用。在SSL/TLS（HTTPS是SSL/TLS内部的一个传输层安全协议）中，HMAC用于允许客户端和服务器验证并确保在传输过程中交换的数据没有被篡改。让我们来看几个广泛使用的重要验证码策略：
- en: 'MAC-then-Encrypt: This technique requires the computation of MAC on the cleartext,
    appending it to the data, and then encrypting all of that together. This scheme
    does not provide integrity of the ciphertext. At the receiving end, the message
    decryption has to happen first to be able to check the integrity of the message.
    It ensures the integrity of the plaintext, however. TLS uses this scheme of MAC
    to ensure that the client-server communication session is secured.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证码后加密：这种技术要求在明文上计算验证码，将其附加到数据上，然后一起进行加密。这个方案不能提供密文的完整性。在接收端，必须先进行消息解密才能检查消息的完整性。它确保了明文的完整性，然而。TLS使用这种验证码方案来确保客户端-服务器通信会话的安全。
- en: 'Encrypt-and-MAC: This technique requires the encryption and MAC computation
    of the message or the cleartext, and then appending the MAC at the end of the
    encrypted message or ciphertext. Notice that MAC is computed on the cleartext,
    so integrity of the cleartext can be assured but not of the ciphertext, which
    leaves scope for some attacks. Unlike the previous scheme, integrity of the cleartext
    can be verified. SSH (Secure Shell)uses this MAC scheme.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 先加密后验证：这种技术要求对消息或明文进行加密和验证码计算，然后将验证码附加到加密的消息或密文末尾。注意，验证码是在明文上计算的，因此可以确保明文的完整性，但不能确保密文的完整性，这为某些攻击留下了可能性。与之前的方案不同，明文的完整性可以被验证。SSH（安全外壳）使用这种验证码方案。
- en: 'Encrypt-then-MAC: This technique requires that the cleartext needs to be encrypted
    first, and then compute the MAC on the ciphertext. This MAC of the ciphertext
    is then appended to the ciphertext itself. This scheme ensures integrity of the
    ciphertext, so it is possible to first check the integrity and if valid then decrypt
    it. It easily filters out the invalid ciphertexts, which makes it efficient in
    many cases. Also, since MAC is in ciphertext, in no way does it reveal information
    about the plaintext. It is usually the most ideal of all schemes and has wider
    implementations. It is used in IPsec.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 先加密后验证：这种技术要求明文首先进行加密，然后在对密文进行验证。这个密文的验证码随后被附加到密文本身。这个方案确保了密文的完整性，因此可以先检查其完整性，如果有效再进行解密。这种方法可以轻易地过滤掉无效的密文，因此在许多情况下都是高效的。另外，由于验证码是在密文而非明文上，所以不会透露关于明文的信息。这通常是所有方案中最理想的，并且应用更广泛。它被用于IPsec。
- en: Asymmetric Key Cryptography
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 非对称密钥加密
- en: 'Asymmetric key cryptography, also known as “public key cryptography,” is a
    revolutionary concept introduced by Diffie and Hellman. With this technique, they
    solved the problem of key distribution in a symmetric cryptography system by introducing
    digital signatures. Note that asymmetric key cryptography does not eliminate the
    need for symmetric key cryptography. They usually complement each other; the advantages
    of one can compensate for the disadvantages of the other.Let us see a practical
    scenario to understand how such a system would work. Assume that Alice wants to
    send a message to Bob confidentially so that no one other than Bob can make sense
    of the message, then it would require the following steps:Alice—The Sender:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 不对称密钥加密，也称为“公钥加密”，是由Diffie和Hellman引入的革命性概念。通过引入数字签名，他们使用这种技术解决了对称加密系统中的密钥分发问题。注意不对称密钥加密并没有消除对称密钥加密的需要。它们通常相互补充；一个的优点可以补偿另一个的缺点。
- en: Encrypt the plaintext message m using encryption algorithm E and the public
    key Puk[Bob] to prepare the ciphertext c.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用加密算法E和鲍勃的公钥Puk[Bob]加密明文消息m，准备密文c。
- en: c = E(Puk[Bob], m )
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: c = E(Puk[Bob], m )
- en: Send the ciphertext c to Bob.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将密文c发送给鲍勃。
- en: 'Bob—The Receiver:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 鲍勃——接收者：
- en: Decrypt the ciphertext c using decryption algorithm D and its private key Prk[Bob]
    to get the original plaintext m.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用解密算法D及其私钥Prk[Bob]解密密文c，以得到原始明文m。
- en: m = D(Prk[Bob], c)
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: m = D(Prk[Bob], c)
- en: 'Such a system can be represented as shown in Figure [2-13](A440588_1_En_2_Chapter_split_000.xhtml#Fig13).![A440588_1_En_2_Fig13_HTML.jpg](Images/A440588_1_En_2_Fig13_HTML.jpg)Figure
    2-13Asymmetric cryptography for confidentialityNotice that the public key should
    be kept in a public repository accessible to everyone and the private key should
    be kept as a well-guarded secret. Public key cryptography also provides a way
    of authentication. The receiver, Bob, can verify the authenticity of the origin
    of the message m in the same way.![A440588_1_En_2_Fig14_HTML.jpg](Images/A440588_1_En_2_Fig14_HTML.jpg)Figure
    2-14Asymmetric cryptography for authenticationIn the example in Figure [2-14](A440588_1_En_2_Chapter_split_000.xhtml#Fig14),
    the message was prepared using Alice’s private key, so it could be ensured that
    it only came from Alice. So, the entire message served as a digital signature.
    Note that both confidentiality and authentication are desirable. To facilitate
    this, public key encryption has to be used twice. The message should first be
    encrypted with the sender’s private key to provide a digital signature. Then it
    should be encrypted with the receiver’s public key to provide confidentiality.
    It can be represented as:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如图[2-13](A440588_1_En_2_Chapter_split_000.xhtml#Fig13)所示，这样的系统可以表示如下![A440588_1_En_2_Fig13_HTML.jpg](Images/A440588_1_En_2_Fig13_HTML.jpg)2-13
    不对称加密用于保密注意，公钥应保存在可以向所有人公开的公共仓库中，而私钥应作为严格保密的秘密保存。公钥加密也提供了一种认证方式。接收者鲍勃可以以同样的方式验证消息m的真实性。![A440588_1_En_2_Fig14_HTML.jpg](Images/A440588_1_En_2_Fig14_HTML.jpg)2-14
    不对称加密用于认证在图[2-14](A440588_1_En_2_Chapter_split_000.xhtml#Fig14)的示例中，消息是使用爱丽丝的私钥准备的，因此可以确保它只来自爱丽丝。所以，整个消息起到了数字签名的作用。注意，保密和认证都是可取的。为了实现这一点，公钥加密必须使用两次。消息首先应使用发送者的私钥加密以提供数字签名。然后，它应该使用接收者的公钥加密以提供保密性。它可以表示为：
- en: c = E[Puk [Bob] , E(Prk [Alice] , m)]
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: c = E[Puk [Bob] , E(Prk [Alice] , m)]
- en: m = D[Puk [Alice] , D(Prk [Bob] , c)]
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: m = D[Puk [Alice] , D(Prk [Bob] , c)]
- en: 'As you can see, the decryption happens in just its reverse order. Notice that
    the public key cryptography is used four times here: twice for encryption and
    twice for decryption. It is also possible that the sender may sign the message
    by applying the private key to just a small block of data derived from the message
    to be sent, and not to the whole message. In the real world, App stores such as
    Google Play or Apple App Store require that the software apps should be digitally
    signed before they get published.We looked at the uses of the two keys in asymmetric
    cryptography, which can be summarized as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，解密是按相反的顺序进行的。注意，公钥加密在这里被使用了四次：两次用于加密，两次用于解密。发送者可能通过将私钥应用于从要发送的消息中提取的小块数据来签署消息，而不是对整个消息应用。在现实世界中，像Google
    Play或Apple App Store这样的App商店要求在软件App发布之前，它们应该被数字签名。我们探讨了不对称加密中两个密钥的用途，可以总结如下：
- en: Public keys are known and accessible to everyone. They can be used to encrypt
    the message or to verify the signatures.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公钥是众所周知的，并可供每个人访问。它们可以用来加密消息或验证签名。
- en: Private keys are extremely private to individuals. They are used to decrypt
    the message or to create signatures.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 私钥对个人来说非常私密。它们用来解密消息或创建签名。
- en: In asymmetric or public key cryptography, there is no key distribution problem,
    as exchanging the agreed upon key is no longer needed. However, there is a significant
    challenge with this approach. How would one ensure that the public key they are
    using to encrypt the message is really the public key of the intended recipient
    and not of an intruder or eavesdropper? To solve this, the notion of a trusted
    third party called public key infrastructure (PKI) is introduced. Through PKIs,
    the authenticity of public keys is assured by the process of attestation or notarization
    of user identity. The way PKIs operate is that they provide verified public keys
    by embedding them in a security certificate by digitally signing them.The public
    key encryption scheme can also be called one-way function or a trapdoor function.
    This is because encrypting a plaintext using the public key “Puk” is easy, but
    the other direction is practically impossible. No one really can deduce the original
    plaintext from the encrypted ciphertext without knowing the secret or private
    key “Prk,” which is actually the trapdoor information. Also, in the context of
    just the keys, they are mathematically related but it is computationally not feasible
    to find one from the other.We discussed the important objectives of public key
    cryptography such as key establishment, authentication and non-repudiation through
    digital signatures, and confidentiality through encryption. However, not all public
    key cryptography algorithms may provide all these three characteristics. Also,
    the algorithms are different in terms of their underlying computational problem
    and are classified accordingly. Certain algorithms such as RSA are based on integer
    factorization scheme because it is difficult to factor large numbers. Certain
    algorithms are based on the discrete logarithm problems in finite fields such
    as Diffie–Hellman key exchange (DH) and DSA. A generalized version of discrete
    logarithm problems is elliptic curve (EC) public key schemes. The Elliptic Curve
    Digital Signature Algorithm (ECDSA) is an example of it. We will cover most of
    these algorithms in the following section.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在非对称或公钥加密中，不存在密钥分发问题，因为不再需要交换事先约定的密钥。然而，这种方法有一个显著的挑战。一个人如何确保他们用来加密消息的公钥真的是预期接收者的公钥，而不是入侵者或窃听者的呢？为了解决这个问题，引入了一个可信的第三方，称为公钥基础设施（PKI）。通过PKI，通过数字签名将验证过的公钥嵌入安全证书中，从而确保公钥的真实性。PKI的操作方式是提供经过验证的公钥。公钥加密方案也可以称为单向函数或陷门函数。这是因为使用公钥“Puk”加密明文“Ptm”是容易的，但反向操作在实际中是不可能的。没有人能够不
    knowledge of the secret or private key “Prk”（实际上是需要泄露的信息）从加密的密文“Ctm”中推导出原始明文“Ptm”。此外，就密钥本身而言，它们在数学上是相关的，但通过计算找到一个从另一个是不切实际的。我们讨论了公钥加密的重要目标，如密钥建立、通过数字签名进行身份验证和非否认，以及通过加密实现机密性。然而，并非所有公钥加密算法都可能提供这三种特性。此外，这些算法在所基于的计算问题上有所不同，并相应地分类。某些算法，如RSA，基于整数分解方案，因为大数的分解是困难的。某些算法基于有限域中的离散对数问题，如Diffie-Hellman密钥交换（DH）和DSA。离散对数问题的泛化版本是椭圆曲线（EC）公钥方案。椭圆曲线数字签名算法（ECDSA）是其一个例子。我们将在下一节中介绍这些算法的大部分内容。
- en: RSA
  id: totrans-169
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: RSA
- en: RSA algorithm, named after Ron Rivest, Adi Shamir, and Leonard Adleman is possibly
    one of the most widely used cryptographic algorithms. It is based on the practical
    difficulty of factoring very large numbers. In RSA, plaintext and ciphertext are
    integers between 0 and n − 1 for some n.We will discuss the RSA scheme from two
    aspects. First is generation of key pairs and second, how the encryption and decryption
    works. Since modular arithmetic provides the mechanism for key generation, let
    us quickly look at it.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 名为RSA的算法，以Ron Rivest、Adi Shamir和Leonard Adleman的名字命名，可能是最广泛使用的加密算法之一。它基于分解非常大的数是实际困难的。在RSA中，明文和密文是某些n（n为大于1的整数）之间的整数。我们将从两个方面讨论RSA方案：首先是密钥对的生成，其次是加密和解密的工作原理。由于模运算提供了密钥生成的机制，让我们快速了解一下。
- en: Modular Arithmetic
  id: totrans-171
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 模运算
- en: 'Let m be a positive integer called modulus. Two integers a and b are congruent
    modulo m if:a ≡ b (mod m), which implies a − b = m . k for some integer k.Example:
    if a ≡ 16 (mod 10) then a can have the following solutions:a = . . ., −24, − 14,
    −4, 6, 16, 26, 36, 46Any of these numbers subtracted by 16 is divisible by 10\.
    For example, −24 −16 = −40, which is divisible by 10\. Note that a ≡ 36 (mod 10)
    can also have the same solutions of a.As per the Quotient-Remainder theorem, only
    a unique solution of “a” exists that satisfies the condition: 0 ≤ a < m. In the
    example a ≡ 16 (mod 10), only the value 6 satisfies the condition 0 ≤ 6 < 10\.
    This is what will be used in the encryption/decryption process of RSA algorithm.Let
    us now look at the Inverse Midulus. If b is an inverse to a modulo m, then it
    can be represented as:a b ≡ 1 (mod m), which implies that a b − 1 = m . k for
    some integer k.Example: 3 has inverse 7 modulo 10 since3 · 7 = 1 (mod 10) => 21
    − 1 = 20, which is divisible by 10.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Generation of Key Pairs
  id: totrans-173
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'As discussed already, a key pair of private and public keys is needed for any
    party to participate in asymmetric crypto-communication. In the RSA scheme, the
    public key consists of (e, n) where n is called the modulus and e is called the
    public exponent. Similarly, the private key consists of (d, n), where n is the
    same modulus and d is the private exponent.Let us see how these keys get generated
    along with an example:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Generate a pair of two large prime numbers p and q. Let us take two small prime
    numbers as an example here for the sake of easy understanding. So, let the two
    primes be p = 7 and q = 17.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compute the RSA modulus (n) as n = pq. This n should be a large number, typically
    a minimum of 512 bits. In our example, the modulus (n) = pq = 119.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find a public exponent e such that 1 < e < (p − 1) (q − 1) and there must be
    no common factor for e and (p − 1) (q − 1) except 1. It implies that e and (p
    − 1) (q − 1) are coprime. Note that there can be multiple values that satisfy
    this condition and can be taken as e, but any one should be taken.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our example, (p − 1) (q − 1) = 6 × 16 = 96\. So, e can be relatively prime
    to and less than 96\. Let us take e to be 5.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now the pair of numbers (e, n) form the public key and should be made public.
    So, in our example, the public key is (5, 119).
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Calculate the private exponent d using p, q, and e considering the number d
    is the inverse of e modulo (p − 1) (q − 1). This implies that d when multiplied
    by e is equal to 1 modulo (p − 1) (q − 1) and d < (p − 1) (q − 1). It can be represented
    as:'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: e d = 1 mod (p − 1) (q − 1)
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Note that this multiplicative inverse is the link between the private key and
    the public key. Though the keys are not derived from each other, there is a relation
    between them.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our example, we have to find d such that the above equation is satisfied.
    Which means, 5 d = 1 mod 96 and also d < 96.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Solving for multiple values of d (can be calculated using the extended version
    of Euclid’s algorithm), we can see that d = 77 satisfies our condition. See the
    math: 77 × 5 = 385 and 385 − 1 = 384 is divisible by 96 because 4 × 96 + 1 = 385'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 求解多个d值（可以使用欧几里得算法的扩展版本计算），我们可以看到d=77满足我们的条件。看数学：77×5=385且385−1=384能被96整除因为4×96+1=385
- en: We can conclude that the in our example, the private key will be (77, 119).
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以得出结论，在我们这个例子中，私钥将会是(77, 119)。
- en: Now you have got your key pairs!
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在你已经得到了你的密钥对！
- en: Encryption/Decryption Using Key Pair
  id: totrans-187
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用密钥对进行加密/解密
- en: 'Once the keys are generated, the process of encryption and decryption are fairly
    simple. The math behind them is as follows:Encrypting the plaintext message m
    to get the ciphertext message c is as follows:c = m . e (mod n) given the public
    key (e, n) and the plaintext message m.Decrypting the ciphertext message c to
    get the plaintext message m is as follows:m = c . d (mod n) given the private
    key (d, n) and the ciphertext c.Note that RSA scheme is a block cipher where the
    input is divided into small blocks that the RSA algorithm can consume. Also, the
    plaintext and the ciphertext are all integers from 0 to n − 1 for some integer
    n that is known to both sender and receiver. This means that the input plaintext
    is represented as integer, and when that goes through RSA and becomes ciphertext,
    they are again integers but not the same ones as input; we encrypted them remember?
    Now, considering the same key pairs from the previous example, let us go through
    the steps to understand how it works practically:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦生成了密钥，加密和解密的过程就相当简单了。背后的数学如下：给定公钥（e, n）和明文消息m，加密明文消息m得到密文消息c的过程如下：c = m .
    e (mod n)。给定私钥（d, n）和密文c，解密密文消息c得到明文消息m的过程如下：m = c . d (mod n)。注意RSA方案是一个块加密方案，其中输入被划分为小块，RSA算法可以处理。另外，明文和密文都是从0到n
    - 1的整数，对于某个整数n，发送者和接收者都知道。这意味着输入的明文被表示为整数，当它通过RSA并变成密文时，它们又是整数，但不是输入的同一个整数；我们记得我们加密过它们吗？现在，考虑到前一个例子中的同样的密钥对，让我们通过步骤了解它是如何实际工作的：
- en: The sender wants to send a text message to the receiver whose public key is
    known and is say (e, n).
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送者想要给拥有已知公钥的接收者发送一条文本消息，比如说公钥是(e, n)。
- en: The sender breaks the text message into blocks that can be represented as a
    series of numbers less than n.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送者将文本消息分解为可以表示为小于n的一系列数字的块。
- en: The ciphertext equivalents of plaintext can be found using c = m e (mod n).
    If the plaintext (m) is 19 and the public key is (5, 119) with e = 5 and n = 119,
    then the ciphertext c will be 195(mod 119) = 2, 476, 099 (mod 119) = 66, which
    is the remainder and 20,807 is the quotient, which we do not use. So, c = 66
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用明文c = m e (mod n)找到密文等价物。如果明文(m)是19，公钥是(5, 119)，e=5，n=119，那么密文c将会是195(mod
    119) = 2, 476, 099 (mod 119) = 66，这是余数，20,807是商，我们不使用。所以，c = 66
- en: When the ciphertext 66 is received at the receiver’s end, it needs to be decrypted
    to get the plaintext using m = c d (mod n).
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当接收者在接收端收到密文66时，它需要使用m = c d (mod n)来解密得到明文。
- en: The receiver already has the private key (d, n) with d = 77 and n = 119, and
    received the ciphertext c = 66 by the sender. So, the receiver can easily retrieve
    the plaintext using these values as m = 6,677(mod 119) = 19
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接收者已经拥有私钥（d, n），其中d=77，n=119，并且收到了发送者的密文c=66。所以，接收者可以轻松地用这些值恢复出明文m = 6,677(mod
    119) = 19
- en: 'For the modular arithmetic calculations, there are many online calculators
    that you can play around with, such as: [http://comnuan.com/cmnn02/cmnn02008/](http://comnuan.com/cmnn02/cmnn02008/)'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于模运算计算，网上有许多可以使用的计算器，例如：[http://comnuan.com/cmnn02/cmnn02008/](http://comnuan.com/cmnn02/cmnn02008/)
- en: We looked at the math behind RSA algorithm. Now we know that n (supposed to
    be a very large number) is publicly available. Though it is public, factoring
    this large number to get the prime numbers p and q is extremely difficult. The
    RSA scheme is based on this practical difficulty of factoring large numbers. If
    p and q are not large enough, or the public key e is small, then the strength
    of RSA goes down. Currently, RSA keys are typically between 1024 and 2048 bits
    long. Note that the computational overhead of the RSA cryptography increases with
    the size of the keys.In situations where the amount of data is huge, it is advisable
    to use a symmetric encryption technique and share the key using an asymmetric
    encryption technique such as RSA. Also, we looked at one of the aspects of RSA,
    that is, for encryption and decryption. However, it can also be used for authentication
    through digital signature. Just to give a high-level idea, one can take the hash
    of the data, sign it using their own private key, and share it along with the
    data. The receiver can check with the sender’s public key and ensure that it was
    the sender who sent the data, and not someone else. This way, in addition to secure
    key transport, the public key encryption method RSA also offers authentication
    using a digital signature. Note here that a different algorithm called digital
    signature algorithm (DSA) can also be used in such situations that we will learn
    about in the following section.RSA is widely being used with HTTPS on web browsers,
    emails, VPNs, and satellite TV. Also, many commercial applications or the apps
    in app stores are also digitally signed using RSA. SSH also uses public key cryptography;
    when you connect to an SSH server, it broadcasts a public key that can be used
    to encrypt data to be sent to that server. The server can then decrypt the data
    using its private key.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们研究了RSA算法背后的数学原理。现在我们知道，n（假设是一个非常大的数字）是公开可用的。尽管它是公开的，但将这个大数分解以获取素数p和q是非常困难的。RSA方案就是基于分解大数的这个实际困难。如果p和q不够大，或者公钥e较小，那么RSA的强度就会下降。目前，RSA密钥通常是1024到2048位长。请注意，RSA加密的计算开销随着密钥大小的增加而增加。在数据量巨大的情况下，建议使用对称加密技术，并通过RSA等非对称加密技术共享密钥。此外，我们还研究了RSA的一个方面，即加密和解密。然而，它也可以通过数字签名用于认证。
    just to give a high-level idea, one can take the hash of the data, sign it using
    their own private key, and share it along with the data. The receiver can check
    with the sender’s public key and ensure that it was the sender who sent the data,
    and not someone else. This way, in addition to secure key transport, the public
    key encryption method RSA also offers authentication using a digital signature.
    Note here that a different algorithm called digital signature algorithm (DSA)
    can also be used in such situations that we will learn about in the following
    section. RSA广泛应用于Web浏览器、电子邮件、VPN和卫星电视上的HTTPS。此外，许多商业应用程序或应用商店中的应用也使用RSA进行数字签名。SSH也使用公钥加密；当你连接到一个SSH服务器时，它会广播一个可以用来加密发送到该服务器数据的对公钥。然后，服务器可以使用其私钥来解密数据。
- en: Digital Signature Algorithm
  id: totrans-196
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 数字签名算法
- en: 'The DSA was designed by the NSA as part of the Digital Signature Standard (DSS)
    and standardized by the NIST. Note that its primary objective is to sign messages
    digitally, and not encryption. Just to paraphrase, RSA is for both key management
    and authentication whereas DSA is only for authentication. Also, unlike RSA, which
    is based on large-number factorization, DSA is based on discrete logarithms. At
    a high level, DSA is used as shown in Figure [2-15](A440588_1_En_2_Chapter_split_000.xhtml#Fig15).![A440588_1_En_2_Fig15_HTML.jpg](Images/A440588_1_En_2_Fig15_HTML.jpg)Figure
    2-15Digital Signature Algorithm (DSA)As you can see in Figure [2-15](A440588_1_En_2_Chapter_split_000.xhtml#Fig15),
    the message is first hashed and then signed because it is more secured compared
    with signing and then hashing it. Ideally, you would like to verify the authenticity  before
    doing any other operation. So, after the message is signed, the signed hash is
    tagged with the message and sent to the receiver. The receiver can then check
    the authenticity and find the hash. Also, hash the message to get the hash again
    and check if the two hashes match. This way, DSA provides the following security
    properties:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: DSA是由NSA设计的，作为数字签名标准（DSS）的一部分，并由NIST标准化。请注意，其主要目的是数字签名，而非加密。简单重述一下，RSA既用于密钥管理也用于认证，而DSA只用于认证。另外，与基于大数因式分解的RSA不同，DSA基于离散对数。在较高层次上，DSA的使用如图[2-15](A440588_1_En_2_Chapter_split_000.xhtml#Fig15)所示。![A440588_1_En_2_Fig15_HTML.jpg](Images/A440588_1_En_2_Fig15_HTML.jpg)图2-15
    数字签名算法（DSA）正如你在图[2-15](A440588_1_En_2_Chapter_split_000.xhtml#Fig15)中所看到的，消息首先被哈希然后签名，因为这比先签名后哈希更安全。理想情况下，你希望在进行其他任何操作之前验证消息的真实性。所以，消息被签名后，签名的哈希被附在消息上发送给接收者。接收者可以检查消息的真实性并找到哈希值。另外，对消息再次哈希以获取哈希值，并检查两个哈希值是否匹配。这样，DSA提供了以下安全特性：
- en: 'Authenticity: Signed by private key and verified by public key'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 真实性：由私钥签名，由公钥验证
- en: 'Data integrity: Hashes will not match if the data is altered.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据完整性：如果数据被更改，哈希值将不匹配。
- en: 'Non-repudiation: Since the sender signed it, they cannot deny later that they
    did not send the message. Non-repudiation is a property that is most desirable
    in situations where there are chances of a dispute over the exchange of data.
    For example, once an order is placed electronically, a purchaser cannot deny the
    purchase order if non-repudiation is enabled in such a situation.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可否认性：由于发送者已经签名，他们后期不能否认他们没有发送消息。在可能存在数据交换争议的情况下，不可否认性是最受欢迎的属性。例如，一旦电子方式下订单被放置，如果在这种情况下启用了不可否认性，购买者就不能否认购买订单。
- en: 'A typical DSA  scheme consists of three algorithms: (1) key generation, (3)
    signature generation, and (3) signature verification.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的DSA方案包括三个算法：（1）密钥生成，（3）签名生成，（3）签名验证。
- en: Elliptic Curve Cryptography
  id: totrans-202
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 椭圆曲线密码学
- en: 'Elliptic curve cryptography (ECC) actually evolved from Diffie-Hellman cryptography.
    It was discovered as an alternative mechanism for implementing public key cryptography.
    It actually refers to a suite of cryptographic protocols and is based on the discrete
    logarithm problem, as in DSA. However, it is believed that the discrete logarithmic
    problem is even harder when applied to the points on an elliptic curve. So, ECC
    offers greater security for a given key size. A 160-bit ECC key is considered
    to be as secured as a 1024-bit RSA key. Since smaller key sizes in ECC can provide
    greater security and performance compared with other public key algorithms, it
    is widely used in small embedded devices, sensors, and other IoT devices, etc.
    There are extremely efficient hardware implementations available for ECC.ECC is
    based on a mathematically related set of numbers on an elliptic curve over finite
    fields. Also, it has nothing to do with ellipses! Mathematically, an elliptic
    curve satisfies the following mathematical equation:y² = x³ + ax + b, where 4
    a³ + 27 b² ≠ 0With different values of “a” and “b”, the curve takes different
    shapes as shown in the following diagram:![A440588_1_En_2_Figi_HTML.jpg](Images/A440588_1_En_2_Figi_HTML.jpg)There
    are several important characteristics of elliptic curves that are used in cryptography,
    such as:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 椭圆曲线密码学（ECC）实际上是从迪菲-赫尔曼密码学演变而来的。它被发现是实现公钥密码学的替代机制。它实际上指的是一套密码学协议，并且是基于与DSA相同的离散对数问题。然而，当应用于椭圆曲线上的点时，人们认为离散对数问题甚至更难。所以，ECC为给定的密钥大小提供了更高的安全性。一个160位的ECC密钥被认为与一个1024位的RSA密钥一样安全。由于ECC中的较小密钥尺寸可以提供比其他公钥算法更高的安全性和性能，因此它广泛应用于小型嵌入式设备、传感器和其他物联网设备等。对于ECC有极其高效的硬件实现。ECC是基于有限域上椭圆曲线的一组数学相关的数。另外，它与椭圆无关！从数学角度来看，椭圆曲线满足以下数学方程：y²
    = x³ + ax + b，其中4 a³ + 27 b² ≠ 0随着“a”和“b”的不同值，曲线呈现出不同的形状，如下面的插图所示：![A440588_1_En_2_Figi_HTML.jpg](Images/A440588_1_En_2_Figi_HTML.jpg)椭圆曲线在密码学中使用有几个重要的特性，例如：
- en: They are horizontally symmetrical. i.e., what is below the X-axis is a mirror
    image of what is above the X-axis. So, any point on the curve when reflected over
    the X-axis still remains on the curve.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是水平对称的。即，曲线下方的X轴是对上方X轴的镜像。因此，曲线上的任何点在关于X轴反射后仍然保持在曲线上。
- en: Any nonvertical line can intersect the curve in at most three places.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何非垂直线最多与曲线相交于三个地方。
- en: If you consider two points P and Q on the elliptic curve and draw a line through
    them, the line may exactly cross the curve at one more places. Let us call it
    (− R). If you draw a vertical line through (− R), it will cross the curve at,
    say, R, which is a reflection of the point (− R). Now, the third property implies
    that P + Q = R. This is called “point addition,” which means adding two points
    on an elliptic curve will lead you to another point on the curve. Refer to the
    following diagram for a pictorial representation of these three properties.![A440588_1_En_2_Figj_HTML.jpg](Images/A440588_1_En_2_Figj_HTML.jpg)
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你考虑椭圆曲线上的两个点P和Q，并通过它们画一条线，这条线可能正好在曲线上一处再相交。让我们称它为（-R）。如果你通过（-R）画一条垂直线，它将穿过曲线，比如说R，这是点（-R）的镜像。现在，第三个性质意味着P
    + Q = R。这被称为“点加法”，意味着在椭圆曲线上添加两个点将引导你到达曲线上的另一个点。请参考下面的插图，这些插图表示了这三个性质的图示。![A440588_1_En_2_Figj_HTML.jpg](Images/A440588_1_En_2_Figj_HTML.jpg)
- en: So, you can apply point addition to any two points on the curve. Now, in the
    previous bullet-point, we did point addition of P and Q (P + Q) and found − R
    and then ultimately arrived at R. Once we arrive at R, we can then draw a line
    from P to R and see that the line intersects the graph again at a third point.
    We can then take that point and move along a vertical line until it intersect
    the graph again. This becomes the point addition for points P and R. This process
    with a fixed P and the resulting point can continue as long as we want, and we
    will keep getting new points on the curve.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所以，你可以对曲线上的任意两个点应用点加法。现在，在前一个项目点中，我们对P和Q进行了点加法（P + Q），找到了-R，然后最终到达了R。一旦我们到达R，我们就可以从P到R画一条线，并看到这条线再次在图上与第三个点相交。然后我们可以取这个点，沿着一条垂直线移动，直到它再次与图相交。这成为了P和R的点加法。这个固定P的过程和结果点可以继续进行，直到我们想要多久，我们将继续得到曲线上的新点。
- en: Now, instead of two points P and Q, what if we apply the operation to the same
    point P, i.e., P and P (called “point doubling”). Obviously, infinite numbers
    of lines are possible through P, so we will only consider the tangential line.
    The tangent line will cross the curve in one more point and a vertical line from
    there will cross the curve again to get to the final value. It can be shown as
    follows:![A440588_1_En_2_Figk_HTML.jpg](Images/A440588_1_En_2_Figk_HTML.jpg)
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，如果我们对同一个点P应用操作，即P和P（称为“点加倍”）。显然，通过P可以有无数条直线，所以我们只考虑切线。切线将在曲线上再交叉一个点，从那里垂直线将再次交叉曲线以达到最终值。这可以表示如下：![A440588_1_En_2_Figk_HTML.jpg](Images/A440588_1_En_2_Figk_HTML.jpg)
- en: It is evident that we can apply point doubling “n” number of times to the initial
    point and every time it will lead us to a different point on the curve. The first
    time we applied point doubling to the point P, it took us to the resulting point
    2P as you can see in the diagram. Now, if the same is repeated “n” number of times,
    we will reach a point on the curve as shown in the following diagram:![A440588_1_En_2_Figl_HTML.jpg](Images/A440588_1_En_2_Figl_HTML.jpg)
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 很明显，我们可以将点加倍应用“n”次到初始点，每次都会使我们到达曲线上的不同点。第一次将点加倍应用到点P时，它使我们到达了结果点2P，正如你在图中看到的那样。现在，如果同样的操作重复“n”次，我们将到达曲线上的一个点，如下面的图所示：![A440588_1_En_2_Figl_HTML.jpg](Images/A440588_1_En_2_Figl_HTML.jpg)
- en: In the aforementioned scenario, when the initial and final point is given, there
    is no way one can say that the point doubling was applied “n” number of times
    to reach the final resulting point except trying for all possible “n” one by one.
    This is the discrete logarithm problem for ECC, where it states that given a point
    G and Q, where Q is a multiple of G, find “d” such that Q = d G. This forms the
    one-way function with no shortcuts. Here, Q is the public key and d is the private
    key. Can you extract private key d from public key Q? This is the elliptic curve
    discrete logarithm problem, which is computationally difficult to solve.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在前述场景中，当给出初始点和最终点时，没有办法可以说点加倍被应用了“n”次来达到最终的 resulting point，除非尝试所有的可能的“n”。这是ECC的离散对数问题，它指出，给定一个点G和Q，其中Q是G的倍数，找到“d”使得Q
    = dG。这形成了一个没有捷径的一向函数。在这里，Q是公钥，d是私钥。你能从公钥Q中提取私钥d吗？这是椭圆曲线的离散对数问题，计算上难以解决。
- en: Further to this, the curve should be defined over a finite field and not take
    us to infinity! This means the “max” value on the X-axis has to be limited to
    some value, so just roll the values over when we hit the maximum. This value is
    represented as P (not the P used in the graphs here) in the ECC cryptosystem and
    is called "modulo” value, and it also defines the key size, hence the finite field.
    In many implementations of ECC, a prime number for “P” is chosen.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，曲线应该定义在一个有限域上，而不是带我们到无穷大！这意味着X轴上的“最大”值必须限制在某个值，所以当达到最大值时， just roll the values
    over。这个值用P表示（在这里图表中没有使用的P），在ECC密码系统中称为“模”值，它也定义了密钥大小，因此是有限域。在ECC的许多实现中，选择了“P”的质数。
- en: Increased size of “P” results in more usable values on the curve, hence more
    security.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增加“P”的大小会在曲线上提供更多的可用值，从而提供更多的安全性。
- en: We observed that point addition and point doubling form the basis for finding
    the values that are used for encryption and decryption.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们观察到点加法和点加倍构成了寻找用于加密和解密值的基。
- en: 'So, in order to define an ECC, the following domain parameters need to be defined:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，为了定义一个ECC，需要定义以下域参数：
- en: 'The Curve Equation: y² = x³ + ax + b, where 4 a³ + 27 b² ≠ 0'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 曲线方程：y² = x³ + ax + b，其中 4a³ + 27b² ≠ 0
- en: 'P: The prime number, which specifies the finite field that the curve will be
    defined over (modulo value)'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'P: 指定曲线定义域（模值）上的有限域的质数'
- en: 'a and b: Coefficients that define the elliptic curve'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'a 和 b: 定义椭圆曲线的系数'
- en: 'G: Base point or the generator point on the curve. This is the point where
    all the point operations begin and it defines the cyclic subgroup.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'G: 曲线上的基点或生成点。这是所有点操作开始的地方，它定义了循环子群。'
- en: 'n: The number of point operations on the curve until the resultant line is
    vertical. So, it is the order of G, i.e., the smallest positive number such that
    nG = ∞. It is normally prime.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'n: 曲线上的点操作次数，直到结果线变为垂直线。因此，它是G的阶，即最小的正数，使得nG = ∞。它通常是质数。'
- en: 'h: It is called “cofactor,” which is equal to the order of the curve divided
    by n. It is an integer value and usually close to 1.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: h：它被称为“cofactor”，等于曲线的阶除以 n。这是一个整数值，通常接近 1。
- en: Note that ECC is a great technique to generate the keys, but is used alongside
    other techniques for digital signatures and key exchange. For example, Elliptic
    Curve Diffie-Hellman (ECDH) is quite popularly used for key exchange and ECDSA
    is used for digital signatures.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，ECC 是一种很好的生成密钥技术，但数字签名和密钥交换通常与其他技术一起使用。例如，椭圆曲线 Diffie-Hellman（ECDH）在密钥交换中相当流行，而
    ECDSA 用于数字签名。
- en: Elliptic Curve Digital Signature Algorithm
  id: totrans-222
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 椭圆曲线数字签名算法
- en: 'The ECDSA is a type of DSA that uses ECC for key generation. As the name suggests,
    its purpose is digital signature, and not encryption. ECDSA can be a better alternative
    to RSA in terms of smaller key size, better security, and higher performance.
    It is one of the most important cryptographic components used in Bitcoins!We already
    looked at how digital signatures are used to establish trust between the sender
    and receiver. Since authenticity of the sender and integrity of the message can
    be verified through digital signatures, two unknown parties can transact with
    each other. Note that the sender and the receiver have to agree on the domain
    parameters before engaging in the communication.There are broadly three steps
    to ECDSA: key generation, signature generation, and signature verification.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: ECDSA是一种使用ECC进行密钥生成的DSA类型。正如其名所示，它的目的是数字签名，而非加密。在较小的密钥尺寸、更好的安全性和更高的性能方面，ECDSA可以是RSA的一个更好的选择。它是比特币中使用的重要密码学组件之一！我们已经了解了数字签名如何用于在发送方和接收方之间建立信任。由于可以通过数字签名验证发送方的真实性和消息的完整性，因此两个未知方可以相互交易。请注意，在开始通信之前，发送方和接收方必须就域参数达成一致。
- en: Key Generation
  id: totrans-224
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 密钥生成
- en: 'Since the domain parameters (P, a, b, G, n, h) are preestablished, the curve
    and the base point are known by both parties. Also, the prime P that makes it
    a finite field is also known (P is usually 160 bits and can be greater as well).
    So, the sender, say, Alice does the following to generate the keys  :'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 由于域参数（P, a, b, G, n, h）是预先设定的，因此曲线和基点双方都知道。此外，使它成为有限域的素数 P 也知道（P 通常是 160 位，也可以更大）。所以，比如说，Alice
    作为发送方，会执行以下操作来生成密钥：
- en: Select a random integer d in the interval [1, n − 1]
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择一个随机整数 d，范围在 [1, n − 1] 内
- en: Compute Q = d G
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算 Q = d G
- en: Declare Q is the public key and keep d as the private key.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明 Q 是公钥，将 d 作为私钥保存。
- en: Signature Generation
  id: totrans-229
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 签名生成
- en: 'Once the keys are generated, Alice, the sender, would use the private key “d”
    to sign the message (m). So, she would perform the following steps in the order
    specified to generate the signature:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦密钥生成，发送方Alice会使用私钥“d”来签署消息（m）。因此，她会按照指定的顺序执行以下步骤来生成签名：
- en: Select a random number k in the interval [1, n − 1]
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择一个随机数 k，范围在 [1, n − 1] 内
- en: Compute k.G and find the new coordinates (x[1], y[1]) and find r = x[1] mod
    n
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算 k.G 并找到新的坐标 (x[1], y[1]) 并找到 r = x[1] mod n
- en: If r = 0, then start all over again
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 r = 0，则重新开始
- en: Compute e = SHA-1 (m)
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算 e = SHA-1 (m)
- en: Compute s = k ^(−1) (e + d . r) mod n
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算 s = k ^(−1) (e + d . r) mod n
- en: If s = 0, then start all over again from the first step
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 s = 0，则从第一步开始重新再来
- en: Alice’s signature for the message (m) would now be (r, s)
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Alice 对消息（m）的签名现在将是 (r, s)
- en: Signature Verification
  id: totrans-238
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 签名验证
- en: 'Let us say Bob is the receiver here and has access to the domain parameters
    and the public key Q of the sender Alice. As a security measure, Bob should first
    verify that the data he has, which is the domain parameters, the signature, and
    Alice’s public key Q are all valid. To verify Alice’s signature on the message
    (m), Bob would perform the following operations in the order specified:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 Bob 是这里的接收方，并且可以访问发送方 Alice 的域参数和公钥 Q。作为一种安全措施，Bob 应该首先验证他拥有的数据，即域参数、签名和
    Alice 的公钥 Q 都是有效的。为了验证 Alice 对消息（m）的签名，Bob 将按照指定的顺序执行以下操作：
- en: Verify that r and s are integers in the interval [1, n − 1]
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证 r 和 s 是否是 [1, n − 1] 区间内的整数
- en: Compute e = SHA-1 (m)
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算 e = SHA-1 (m)
- en: Compute w = s ^(−1) mod n
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算 w = s ^(−1) mod n
- en: Compute u[1] = e w mod n, and u[2] = r w mod n
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算 u[1] = e w mod n，并 u[2] = r w mod n
- en: Compute X = u[1] G + u[2] G, where X represents the coordinates, say (x[2],
    y[2])
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算 X = u[1] G + u[2] G，其中 X 表示坐标，比如说 (x[2], y[2])
- en: Compute v = x[1] mod n
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算 v = x[1] mod n
- en: Accept the signature if r = v, otherwise reject it
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 r = v，则接受签名，否则拒绝它
- en: In this section, we looked at the math behind ECDSA. Recollect that we used
    a random number while generating the key and the signature. It is extremely important
    to ensure that the random numbers generated are actually cryptographically random.
    In many use cases, 160-bit ECDSA is used because it has to match with the SHA-1
    hash function.Out of so many use cases, ECDSA is used in digital certificates.
    In its simplest form, a digital certificate is a public key, bundled with the
    device ID and the certificate expiration date. This way, certificates enable us
    to check and confirm to whom the public key belongs and the device is a legitimate
    member of the network under consideration  . These certificates are very important
    to prevent “impersonation attack” in key establishment protocols. Many TLS certificates
    are based on ECDSA key pair and this usage continues to grow.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了ECDSA背后的数学原理。回想一下，我们在生成密钥和签名时使用了随机数。确保生成的随机数实际上是密码学上的随机数至关重要。在许多应用场景中，使用160位的ECDSA是因为它需要与SHA-1哈希函数匹配。在众多应用场景中，ECDSA被用于数字证书。在其最简单形式中，数字证书包含一个公钥，以及设备ID和证书到期日期。这样，证书使我们能够验证公钥属于谁以及设备是否是所考虑网络中的合法成员。这些证书对于防止密钥建立协议中的“伪装攻击”非常重要。许多TLS证书基于ECDSA密钥对，这种使用持续增长。
- en: Code Examples of Assymetric Key Cryptography
  id: totrans-248
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 非对称密钥加密的代码示例
- en: 'Following are some code examples of different public ley algorithms. This section
    is just intended to give you a heads-up on how to use different algorithms programatically.
    Code examples are in Python but would be quite similar in different languages;
    you just have to find the right library functions to use.# -*- coding: utf-8 -*-import
    Cryptofrom Crypto.PublicKey import RSAfrom Crypto import Randomfrom hashlib import
    sha256# Function to generate keys with default lenght 1024def generate_key(KEY_LENGTH=1024):    random_value=
    Random.new().read    keyPair=RSA.generate(KEY_LENGTH,random_value)    return keyPair#Generate
    Key for ALICE and BOBbobKey=generate_key()aliceKey=generate_key()#Print Public
    Key of Alice and Bob. This key could sharedalicePK=aliceKey.publickey()bobPK=bobKey.publickey()print
    "Alice''s Public Key:", alicePKprint "Bob''s Public Key:", bobPK#Alice wants to
    send a secret message to Bob. Lets create a dummy message for Alicesecret_message="Alice''s
    secret message to Bob"print "Message",  secret_message# Function to generate a
    signaturedef generate_signature(key,message):    message_hash=sha256(message).digest()    signature=key.sign(message_hash,'''')    return
    signature# Lets generate a signature for secret messagealice_sign=generate_signature(aliceKey,secret_message)#
    Before sending message in network, encrypt message using the Bob''s public key...encrypted_for_bob  =
    bobPK.encrypt(secret_message, 32)  # Bob decrypts secret message using his own
    private key...decrypted_message   = bobKey.decrypt(encrypted_for_bob)print "Decrypted
    message:", decrypted_message# Bob will use the following function to verify the
    signature from Alice using her public keydef verify_signature(message,PublicKey,signature):    message_hash=sha256(message).digest()    verify
    = PublicKey.verify(message_hash,signature)    return verify# bob is verifying
    using decrypted message and alice''s public keyprint "Is alice''s signature for
    decrypted message valid?", verify_signature(decrypted_message,alicePK, alice_sign)The
    ECDSA Algorithmimport ecdsa# SECP256k1 is the Bitcoin elliptic curvesigningKey
    = ecdsa.SigningKey.generate(curve=ecdsa.SECP256k1)# Get the verifying keyverifyingKey
    = signingKey.get_verifying_key()# Generate The signature of a messagesignature
    = signingKey.sign(b"signed message")# Verify the signature is valid or invalid
    for a messageverifyingKey.verify(signature, b"signed message") # True. Signature
    is valid# Verify the signature is valid or invalid for a messageassert verifyingKey.verify(signature,
    b"message") # Throws an error. Signature is invalid for message'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些不同公开密钥算法的一些代码示例。本节只是为了给你一个如何不同算法编程的预警。代码示例是用Python编写的，但在不同的语言中会非常相似；你只需要找到正确的库函数来使用。
- en: Diffie-Hellman Key Exchange
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Diffie-Hellman密钥交换
- en: 'We already looked at symmetric key cryptography in the previous sections. Recollect
    that sharing the secret between the sender and the receiver is a very big challenge.
    As a rule of thumb, we are now aware that the the communication channel is always
    insecure. There could always be an Eve trying to intercept your message while
    it is being transmitted by using various different kinds of attacks. So, the technique
    of DH was developed for securely exchanging the cryptographic keys. Obviously,
    you must be wondering how secure key exchange is possible when the communication
    channel itself is insecured. Well, later in this section you will see that the
    DH technique is not really sharing the entire secret key between two parties,
    rather it is about creating the key together. At the end of the day, what is important
    is that the sender and the receiver both have the same key. However, keep in mind
    that it is not asymmetric key cryptography, as encryption/decrytion does not take
    place during the exchange. In fact, it was the base upon which asymmetric key
    cryptography was later designed. The reason we are looking at this technique now
    is because a lot of math that we already studied in the previous section is useful
    here.Let us first try to understand the concept at a high level  before getting
    into the mathematical explanation. Take a look at the following (Figure [2-16](A440588_1_En_2_Chapter_split_001.xhtml#Fig16)),
    where a simple explanation of DH algorithm is presented with colors.![A440588_1_En_2_Fig16_HTML.jpg](Images/A440588_1_En_2_Fig16_HTML.jpg)Figure
    2-16Diffie-Hellman key exchange illustrationNotice that only the yellow color
    was shared between the two parties in the first step, which may represent any
    other color or a randon number. Both parties then add their own secret to it and
    make a mixture  . That mixture is again shared through the same insecured channel.
    Respective parties then add their secret to it and form their final common secret.
    In this example with colors, observe that the common secrets are the combination
    of same sets of colors. Let us now look at the actual mathematical steps that
    take place for the generation of keys:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在之前的章节中了解了对称密钥加密技术。回忆一下，将秘密密钥在发送者和接收者之间共享是一个非常大的挑战。作为一个经验法则，我们现在知道，通信通道始终是不安全的。总是可能有伊娃试图在消息传输过程中拦截你的信息，使用各种不同的攻击方式。所以，DH技术是为了安全地交换加密密钥而开发的。显然，你可能想知道在不安全的通信通道中如何实现安全的密钥交换。好吧，在本节的后面，你将看到DH技术实际上并不是在两个方之间共享整个秘密密钥，而是关于一起创建密钥。归根结底，重要的是发送者和接收者都有相同的密钥。然而，要记住的是，这并不是非对称密钥加密，因为密钥交换过程中并不进行加密/解密。实际上，这是我们后来设计非对称密钥加密的基础。我们现在研究这个技术的原因是因为我们已经在上一节中学到的很多数学知识在这里是有用的。在我们深入数学解释之前，首先尝试从高层次理解这个概念。看看下面的图（图[2-16](A440588_1_En_2_Chapter_split_001.xhtml#Fig16)），其中用颜色简单地解释了DH算法。![A440588_1_En_2_Fig16_HTML.jpg](Images/A440588_1_En_2_Fig16_HTML.jpg)图2-16Diffie-Hellman密钥交换说明请注意，在第一步中，只有黄色颜色被双方共享，这可能代表任何其他颜色或一个随机数。双方然后将自己的秘密加到里面，进行混合。这个混合物再次通过同一个不安全的通道共享。各方再将自己的秘密加到里面，形成他们最终的公共密钥。在这个用颜色举例的例子中，观察到公共密钥是相同颜色集合的组合。现在让我们看看生成密钥时实际发生的数学步骤：
- en: Alice and Bob agree on P = 23 and G = 9
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 艾丽丝和鲍勃同意P=23和G=9。
- en: Alice chooses private key a = 4, computes 9⁴ mod 23 = 6 and sends it to Bob
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 艾丽丝选择私钥a=4，计算9⁴模23=6并发送给鲍勃。
- en: Bob chooses private key b = 3, computes 9³ mod 23 = 16 and sends it to Alice
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 鲍勃选择私钥b=3，计算9³模23=16并发送给艾丽丝。
- en: Alice computes 16⁴ mod 23 = 9
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 艾丽丝计算16⁴模23=9。
- en: Bob computes 6³ mod 23 = 9
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 鲍勃计算6³模23=9。
- en: 'If you follow through these steps, you will find that both Alice and Bob are
    able to generate the same secret key at their ends that can be used for encryption/decryption.
    We used small numbers in this example for easy understanding, but large prime
    numbers are used in real-world use cases. To understand it better, let us go through
    the following code snippet and see how DH algorithm can be implemented in a simple
    way:/* Program to calculate the Keys for two parties using Diffie-Hellman Key
    exchange algorithm */// function to return value of a ^ b mod Plong long int power(long
    long int a, long long int b, long long int P){    if (b == 1)        return a;    else        return
    (((long long int)pow(a, b)) % P);}//Main program for DH Key computationint main(){    long
    long int P, G, x, a, y, b, ka, kb;    // Both the parties agree upon the public
    keys G and P    P = 23; // A prime number P is taken    printf("The value of P
    : %lld\n", P);    G = 9; // A primitve root for P, G is taken    printf("The value
    of G : %lld\n\n", G);    // Alice will choose the private key a    a = 4; // a
    is the chosen private key    printf("The private key a for Alice : %lld\n", a);    x
    = power(G, a, P); // gets the generated key    // Bob will choose the private
    key b    b = 3; // b is the chosen private key    printf("The private key b for
    Bob : %lld\n\n", b);    y = power(G, b, P); // gets the generated key    // Generating
    the secret key after the exchange of keys    ka = power(y, a, P); // Secret key
    for Alice    kb = power(x, b, P); // Secret key for Bob    printf("Secret key
    for the Alice is : %lld\n", ka);    printf("Secret Key for the Bob is : %lld\n",
    kb);    return 0;}NoteWhile the discrete logarithm problem is traditionally used
    (the x^y mod p), the general process can be modified to use elliptic curve cryptography
    as well.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遵循这些步骤，你会发现Alice和Bob都能在他们各自的一端生成相同的秘密密钥，该密钥可用于加密/解密。我们在这个例子中使用了小数字以便理解，但在实际应用中使用大素数。为了更好地理解，让我们通过以下代码片段来看看DH算法如何以简单的方式实现：/*
    使用Diffie-Hellman密钥交换算法计算两个方之间的密钥 */// 返回 a^b mod P 的值long long int power(long
    long int a, long long int b, long long int P){    if (b == 1)        return a;    else        return
    (((long long int)pow(a, b)) % P);}// DH密钥计算的主程序int main(){    long long int P,
    G, x, a, y, b, ka, kb;    // 双方同意公开密钥G和P    P = 23; // 选取一个素数P    printf("P的值：%lld\n",
    P);    G = 9; // 选取P的一个原根G    printf("G的值：%lld\n\n", G);    // Alice会选择私钥a    a
    = 4; // a是选择的私钥    printf("Alice的私钥a：%lld\n", a);    x = power(G, a, P); // 生成密钥    //
    Bob会选择私钥b    b = 3; // b是选择的私钥    printf("Bob的私钥b：%lld\n\n", b);    y = power(G,
    b, P); // 生成密钥    // 在交换密钥后生成密钥   ka = power(y, a, P); // Alice的密钥    kb = power(x,
    b, P); // Bob的密钥    printf("Alice的密钥是：%lld\n", ka);    printf("Bob的密钥是：%lld\n",
    kb);    return 0;}注意虽然传统上使用离散对数问题（x^y mod p），但一般过程可以修改以使用椭圆曲线加密。
- en: Symmetric vs. Asymmetric Key Cryptography
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对称密钥加密与非对称密钥加密
- en: We looked at various aspects and types of both symmetric and asymmetric key
    algorithms. Obviously, their design goals and implications are different. Let
    us have a comparative analysis so that we use the right one at the right place.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们研究了对称和非对称密钥算法的各个方面和类型。显然，它们的设计目标和含义是不同的。让我们进行比较分析，以便在正确的地方使用正确的算法。
- en: Symmetric key cryptography is also referred to as private key cryptography.
    Similarly, asymmetric key cryptography is also called public key cryptography.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对称密钥加密也被称为私钥加密。同样，非对称密钥加密也被称为公钥加密。
- en: Key exchange or distribution in symmetric key cryptography is a big headache,
    unlike asymmetric key cryptography.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在对称密钥加密中，密钥交换或分发是一个大问题，与非对称密钥加密不同。
- en: Asymmetric encryption  is quite compute-intensive because the length of the
    keys is usually large. Hence, the process of encryption and decryption is slower.
    On the contrary, symmetric encryption is faster.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非对称加密相当计算密集，因为密钥的长度通常很大。因此，加密和解密的过程较慢。相反，对称加密较快。
- en: Symmetric key cryptography is appropriate for long messages because the speed
    of encryption/decryption is fast. Asymmetric key cryptography is appropriate for
    short messages, and the speed of encryption/decryption is slow.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对称密钥加密适用于长消息，因为加密/解密的速度快。非对称密钥加密适用于短消息，加密/解密的速率慢。
- en: In symmetric key cryptography, symbols in plaintext and ciphertext are permuted
    or substituted. In asymmetric key cryptography, plaintext and ciphertext are treated
    as integers.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在对称密钥加密中，明文和密文中的符号会被置换或替换。而在非对称密钥加密中，明文和密文被视为整数。
- en: In many situations, when symmetric key is used for encryption and decryption,
    asymmetric key technique is used to share and agree upon the key used in encryption.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在很多情况下，当使用对称密钥进行加密和解密时，非对称密钥技术用来共享和商定用于加密的密钥。
- en: Asymmetric key cryptography finds its strongest application in untrusted environments,
    when parties involved have no prior relationship. Since the unknown parties do
    not get any prior opportunity to establish shared secret keys with each other,
    sharing of sensitive data is secured through public key cryptography.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非对称密钥加密技术在不可信环境中应用最为广泛，当参与方之间没有先前的关系时。由于未知方之间没有先前的机会建立共享密钥，因此通过公钥加密技术来安全地共享敏感数据。
- en: Symmetric cryptographic techniques do not provide a way for digital signatures,
    which are only possible through asymmetric cryptography.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对称加密技术无法实现数字签名，而数字签名只能通过非对称加密技术来实现。
- en: Another good case is the number of keys required among a group of nodes to communicate
    with each other. How many keys do you think would be needed among, say, 100 participants
    when symmetric key cryptography  is needed? This problem of finding the keys needed
    can be approached as a complete graph problem with order 100\. Like each vertex
    requires 99 connected edges to connect with everyone, every participant would
    need 99 keys to establish secured connections with all other nodes.So, in total,
    the keys needed would be 100 * (100 − 1)/2 = 4,950\. It can be generalized for
    “n” number of participants as n * (n − 1)/2 keys in total. With an increased number
    of participant, it becomes a nightmare! However, in the case of asymmetric key
    cryptography, each participant would just need two keys (one private and one public).
    For a network of 100 participants, total keys needed would be just 200\. Table
    [2-5](A440588_1_En_2_Chapter_split_001.xhtml#Tab5) shows some sample data to give
    you an analogy on the increased number of keys needed when the number of participants
    increases.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个很好的例子是节点之间进行通信所需的密钥数量。如果你认为在对称密钥加密 needed? This problem of finding the keys
    needed can be approached as a complete graph problem with order 100\. Like each
    vertex requires 99 connected edges to connect with everyone, every participant
    would need 99 keys to establish secured connections with all other nodes.So, in
    total, the keys needed would be 100 * (100 − 1)/2 = 4,950\. It can be generalized
    for “n” number of participants as n * (n − 1)/2 keys in total. With an increased
    number of participant, it becomes a nightmare! However, in the case of asymmetric
    key cryptography, each participant would just need two keys (one private and one
    public). For a network of 100 participants, total keys needed would be just 200\.
    Table [2-5](A440588_1_En_2_Chapter_split_001.xhtml#Tab5) shows some sample data
    to give you an analogy on the increased number of keys needed when the number
    of participants increases.
- en: Table 2-5Key Requirements Comparison for Symmetric and Asymmetric Key Techniques![A440588_1_En_2_Figm_HTML.jpg](Images/A440588_1_En_2_Figm_HTML.jpg)
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2-5 对称和非对称密钥技术密钥需求比较![A440588_1_En_2_Figm_HTML.jpg](Images/A440588_1_En_2_Figm_HTML.jpg)
- en: Game Theory
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 博弈论
- en: 'Game Theory is a certainly quite an old concept and is being used in many real-life
    situations to solve complex problems. The reason we are covering this topic at
    a high level is because it is used in Bitcoins and many other blockchain solutions.
    It was formally introduced by John von Neumann to study economic decisions. Later,
    it was more popularized by John Forbes Nash Jr because of his theory of “Nash
    Equilibrium,” which we will look into shortly. Let us first understand what game
    theory is.Game theory is a theory on games, where the games are not just what
    children play. Most are situations where two or more parties are involved with
    some strategic behavior. Examples: A cricket tournament is a game, two conflicting
    parties in a court of law with lawyers and juries is a game, two siblings fighting
    over an ice cream is a game, a political election is a game, a traffic signal
    is also a game. Another example: Say you applied for a blockchain job and you
    are selected and offered a job offer with some salary, but you reject the offer,
    thinking there is a huge gap in the demand and supply and chances are good they
    will revise the offer with a higher salary. You must be thinking now, what is
    not a game? Well, in real situations, almost everything is a game. So, a “game”
    can be defined as a situation involving a “correlated rational choice.” What it
    means is that the prospects available for any player are dependent not only on
    their own choices, but also on the choices that others make in a given situation.
    In other words, if your fate is impacted by the actions of others, then you are
    in a game. So what is game theory?Game theory is a study of strategies involved
    in complex games. It is the art of making the best move, or opting for a best
    strategy in a given situation based on the objective. To do so, one must understand
    the strategy of the opponent and also what the opponent thinks your move is going
    to be. Let us take a simple example: There are two siblings, one elder and the
    other younger. Now, there are two ice creams in the fridge, one is orange flavor
    and the other is mango flavor. The elder one wants to eat the orange flavor, but
    knows if he opts for that, then the younger one would cry for the same orange.
    So, he opts for the mango flavored ice cream and it turns out as expected, the
    younger one wants the same. Now, the elder one pretends to have sacrificed the
    mango flavored ice cream and gives it to the younger one and eats the orange one
    himself. Look at the situation: this is a win-win for both the parties, as this
    was the objective of the elder one. If the elder one wanted, he could simply have
    fought with the younger kid and got the orange one if that was his objective.
    In the second case, the elder one would strategize where to hit so that the younger
    kid is not injured much but enough so that he gives up on the orange flavored
    ice cream. This is game theory: what is your objective and what should be your
    best move?One more example: more on a business side this time. Imagine that you
    are a vendor supplying vegetables to a town. There are, say, three ways to get
    to the town, out of which one is a regular route in the sense that everyone goes
    by that route, maybe because it is shorter and better. One day, you see that the
    regular route has been blocked because of some repair activity and in no way can
    you go by that route. You are now left with two other routes. One of those is
    a short route to the destination town but is a little narrow. The other one is
    a little longer route but wide enough. Here, you have to make a strategy as to
    which route of the two you need to go by. The situation may be such that there
    is heavy traffic on the roads and many people would try to get through the shortest
    route. This can lead to heavy congestion on that route and can cause a huge delay.
    So, you decided to take the longer route to reach the town on time, but at the
    cost of few extra dollars spent on fuel. You are sure you can easily get compensated
    for that if you arrive on time and sell your vegetables early at a good price.
    This is game theory: what is your best move for the objective you have in mind,
    which is usually finding an optimal solution.In many situations, the role that
    you play and your objective both play a vital role in formulating the strategy.
    Example: If you are an organizer of a sport event, and not a participant in the
    competition, then you would formulate a strategy where your objective could be
    that you want the participants to play by the rules and follow the protocol. This
    is because you do not care who wins at the end, you are just an organizer. On
    the other hand, a participant would strategize the winning moves by taking into
    account the strengths and weaknesses of the opponent, and the rules imposed by
    the organizer because there could be penalties if you break the rules. Now, let
    us consider this situation with you playing the role of the organizer. You should
    consider if there could be a situation where a participant breaks a rule and loses
    one point but injures the opponent so much that they cannot compete any longer.
    So, you have to take into account what the participants can think and set your
    rules accordingly.Let us try to define game theory once again based on what we
    learned from the previous examples. It is the method of modeling real-life situations
    in the form of a game and analyzing what the best strategy or move of a person
    or an entity could be in a given situation for a desired outcome. Concepts from
    game theory are widely used in almost every aspect of life, such as politics,
    social media, city planning, bidding, betting, marketing, distributed storage,
    distributed computing, supply chains, and finance, just to name a few. Using game
    theoretic concepts, it is possible to design systems where the participants play
    by the rules without assuming emotional or moral values of them. If you want to
    go beyond just building a proof of concept and get your product or solution to
    production, then you should prioritize game theory as one of the most important
    elements. It can help you build robust solutions and lets you test those with
    different interesting scenarios. Well, many people already think in game theoretic
    perspectives without knowing it is game theory. However, if you are equipped with
    the many tools and techniques from game theory, it definitely helps.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏理论无疑是一个相当古老的概念，并且被用在许多现实生活中的情况来解决复杂问题。我们之所以以高级别覆盖这个话题，是因为它被用于比特币和许多其他区块链解决方案中。这个理论最初是由约翰·冯·诺伊曼引入，用于研究经济决策。后来，由于约翰·福布斯·纳什
    Jr 的“纳什均衡”理论而更加普及，我们稍后会深入了解。首先，让我们了解一下游戏理论是什么。游戏理论是关于游戏的理论，这里的游戏不仅仅是孩子们玩的东西。大多数情况下，都是涉及两个或更多方的战略行为。例如：板球锦标赛是一个游戏，法庭上两个冲突的当事方和律师、陪审团是一个游戏，两个兄弟姐妹为冰淇淋争吵是一个游戏，政治选举是一个游戏，交通信号灯也是一个游戏。另一个例子：假设你申请了一份区块链工作，你被选中并提供了工作机会和一定的薪水，但你拒绝了这份工作，认为需求和供应之间存在巨大差距，他们很可能会提高薪水。你现在可能会想，什么不是游戏？好吧，在现实情况下，几乎一切都是游戏。所以，“游戏”可以定义为涉及“相关理性选择”的情况。这意味着任何玩家的前景不仅取决于他们自己的选择，还取决于其他人给出的情况中的选择。换句话说，如果你的命运受到其他人行为的影响，那么你就在一个游戏中。那么游戏理论是什么？游戏理论是研究涉及复杂游戏中的策略。它是根据目标在给定情况下做出最佳移动或选择最佳策略的艺术。为此，一个人必须理解对手的策略以及对手认为你的下一步是什么。让我们举一个简单的例子：有两个兄弟姐妹，一个哥哥和一个弟弟。现在，冰箱里有两块冰淇淋，一个是橙味，另一个是芒果味。哥哥想吃橙味的冰淇淋，但他知道如果他选择那个，弟弟也会要求吃同样的橙味。因此，他选择吃芒果味的冰淇淋，结果如他所料，弟弟想要同样的。现在，哥哥假装牺牲了芒果味的冰淇淋并给了弟弟，自己吃了橙味的。看看这个情况：这对双方来说都是一个双赢的局面，因为这是哥哥的目标。如果哥哥想要，他可以简单地与弟弟争吵并得到橙味的冰淇淋，如果那是他的目标。在第二种情况下，哥哥会考虑在哪里打击，以便弟弟不会受到严重伤害，但足够让他放弃橙味的冰淇淋。这是游戏理论：你的目标是什么，你应该采取的最佳行动是什么？还有一个例子：这次更多地从商业角度出发。想象你是一个向镇上供应蔬菜的供应商。有三种到达镇上的方式，其中一种是常规路线，因为这条路可能更短更好，大家都走这条路。有一天，你看到常规路线因为一些维修活动而被封锁，你无论如何都不能走那条路。你现在只剩下两条路可走。其中一条是到达目的地的短路，但比较窄。另一条是稍长的路，但足够宽。在这种情况下，你必须制定策略，决定走哪两条路。情况可能是有大量的交通在道路上，很多人会试图通过最短路线。这可能导致该路线的交通严重拥堵，并造成巨大的延误。所以，你决定走较长的路，以便按时到达镇上，但代价是燃油多花了一些美元。你确信如果你准时到达并早点以好价格卖出你的蔬菜，你可以很容易地得到补偿。这是游戏理论：对于你心中的目标，你的最佳行动是什么，通常是为了找到一个最优解决方案。在许多情况下，你所扮演的角色和你的目标都在制定策略中起着重要作用。例如：如果你是一个体育活动的组织者，而不是比赛的参与者，那么你的目标可能是希望参与者遵守规则并遵循协议。这是因为你不关心最后谁赢，你只是个组织者。另一方面，参与者会考虑对手的强项和弱点以及组织者制定的规则，从而制定获胜的策略，因为如果你违反规则，可能会受到惩罚。现在，让我们考虑你扮演组织者角色的情况。你应该考虑是否可能存在一种情况，即一名参与者违反规则失去一分，但伤害对手如此之大，以至于他们无法再参赛。所以，你必须考虑参与者可能怎么想，并相应地制定你的规则。让我们再次尝试根据我们从前面例子中学到的知识来定义游戏理论。这是以游戏的形式建模现实生活情况的方法，并分析在给定情况下一个人或实体的最佳策略或移动。几乎生活的每个方面都广泛使用了游戏理论的概念，比如政治、社交媒体、城市规划、竞标、赌博、营销、分布式存储、分布式计算、供应链和金融，这只是举几个例子。使用游戏理论的概念，可以设计出参与者遵守规则的系统，而不假设他们的情感或道德价值。如果你想超越只是构建一个概念证明，并将你的产品或解决方案投入生产，那么你应该将游戏理论作为最重要的元素之一。它可以帮助你建立健壮的解决方案，并让你在不同的有趣场景下进行测试。嗯，许多人已经在用游戏理论的视角思考问题，而不知道那就是游戏理论。然而，如果你掌握了游戏理论的许多工具和技术
- en: Nash Equilibrium
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 纳什均衡
- en: In the previous section, we looked at different examples of games. There are
    many ways to classify games, such as cooperative/noncooperative games, symmetric/asymmetric
    games, zero-sum/non-zero-sum games, simultaneous/sequential games, etc. More generally,
    let us focus on the cooperative/noncooperative perspective here, because it is
    related to the Nash equilibrium.As the name suggests, the players cooperate with
    each other and can work together to form an alliance in cooperative games. Also,
    there can be some external force applied to ensure cooperative behavior among
    the players. On the other hand, in noncooperative games, the players compete as
    individuals with no scope to form an alliance. The participants just look after
    their own interests. Also, no external force is available to enforce cooperative
    behavior.Nash equilibrium  states that, in any noncooperative games where the
    players know the strategies of each other, there exists at least one equilibrium
    where all the players play their best strategies to get the maximum profits and
    no side would benefit by changing their strategies. If you know the strategies
    of other players and you have your own strategy as well, if you cannot benefit
    by changing your own strategy, then this is the state of Nash equilibrium. Thus,
    each strategy in a Nash equilibrium is a best response to all other strategies
    in that equilibrium.Note that a player may strategize to win as an individual
    player, but not to defeat the opponent by ensuring the worst for the opponents.
    Also, any game when played repeatedly may eventually fall into the Nash equilibrium.In
    the following section, we will look at the “prisoner”s dilemma” to get a concrete
    understanding of the Nash equilibrium  .
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们探讨了不同类型的游戏案例。游戏的分类方法有很多，比如合作/非合作游戏、对称/不对称游戏、零和/非零和游戏、同时/序贯游戏等。更一般地说，让我们在这里关注合作/非合作的角度，因为这和纳什均衡有关。顾名思义，在合作游戏中，玩家之间相互合作，可以联合起来形成一个联盟。此外，可能会有外部力量介入以确保玩家之间的合作行为。另一方面，在非合作游戏中，玩家作为个体竞争，没有机会结成联盟。参与者只关心自己的利益。此外，没有外部力量可以强制执行合作行为。纳什均衡指出，在任何非合作游戏中，如果玩家知道彼此的策略，至少存在一个均衡点，在这个均衡点上，所有玩家都采取最佳策略以获得最大利润，任何玩家改变策略都不会获得额外的好处。如果你知道其他玩家的策略，同时也有自己的策略，如果你不能通过改变自己的策略来获益，那么这就是纳什均衡的状态。因此，纳什均衡中的每一个策略都是对均衡中其他所有策略的最佳反应。注意，一个玩家可能策略性地作为个体获胜，但并不是通过确保对手最差的情况来打败对手。另外，任何游戏如果反复玩下去，最终可能都会达到纳什均衡。在下一节中，我们将通过“囚徒困境”来具体理解纳什均衡。
- en: Prisoner’s Dilemma
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 囚徒困境
- en: 'Many games in real life can also be non-zero-sum games. Prisoner’s dilemma
    is one such example, which can be broadly categorized as a symmetric game. This
    is because, if you change the identities of the players (e.g., if two players
    “A” and “B” are playing, then “A” becomes “B” and “B” becomes “A”), and also the
    strategies do not change, then the payoff remains the same. This is what a symmetric
    game is.Let us start directly with an example. Assume that there are two guys,
    Bob and Charlie, who are caught by the cops for selling drugs independently, say
    in different locations. They are kept in two different cells for interrogation.
    They were then toldd that they would be sentenced to jail for two years for this
    crime. Now, the cops somehow suspect that these two guys could also be involved
    in the robbery that just happened last week. If they did not do the robbery, then
    it is two years of imprisonment anyway. So, the cops have to strategize a way
    to get to the truth. So here is what they do.The cops go to Bob and give him a
    choice, a good choice that goes like this. If Bob confesses his crime and Charlie
    does not, then his punishment would go down from two years to just one year and
    Bob gets five years. However, if Bob denies and Charlie confesses, then Bob gets
    five years and Charlie gets just one year. Also, if both confess, then both get
    three years of imprisonment. Similarly, the same choice is given to Charlie as
    well. What do you think they are going to do? This situation is called the prisoner’s
    dilemma.Both Bob and Charlie  are in two different cells. They cannot talk to
    each other and conclude with the situation where they both deny and get two years
    in jail (just for the drug dealing case), which seems to be the global optimum
    in this situation. Well, even if they could talk to each other, they may not really
    trust each other.What would go through Bob’s mind now? He has two choices, confess
    or deny. He knows that Charlie would choose what is best for him, and he himself
    is no different. If he denies and Charlie confesses, then he is in trouble by
    getting five years of jail and Charlie gets just one year of jail. He certainly
    does not want to get into this situation.If Bob confesses, then Charlie has two
    choices: confess or deny. Now Bob thinks that if he confesses, then whatever Charlie
    does, he is not getting more than three years. Let us state these scenarios for
    Bob.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 许多现实生活中的游戏也可以是非零和游戏。囚徒困境就是这样一个例子，它可以被广泛地归类为对称游戏。这是因为，如果你改变了玩家的身份（例如，如果两个玩家“A”和“B”在玩，那么“A”变成了“B”，“B”变成了“A”），而且策略也没有改变，那么回报保持不变。这就是对称游戏。让我们从一个例子开始。假设有两个家伙，鲍勃（Bob）和查理（Charlie），他们因独立销售毒品被捕，地点不同。他们被关在两个不同的牢房里接受审讯。他们被告知，他们将因为这个罪行被判入狱两年。现在，警察们怀疑这两个家伙可能也参与了上周刚刚发生的抢劫案。如果没有抢劫，他们还是要被判两年监狱。所以，警察们必须制定一个策略来找出真相。所以他们做了这样的事情。警察去见鲍勃，给他一个选择，一个很好的选择，如下所述。如果鲍勃承认他的罪行而查理不承认，那么他的刑罚将从两年减少到只有一年，鲍勃将获得五年。然而，如果鲍勃否认而查理承认，那么鲍勃将获得五年，查理只有一年。另外，如果两人都承认，那么两人都将被判入狱三年。同样，同样的选择也给了查理。你们认为他们会怎么做？这种情况被称为囚徒困境。鲍勃和查理都在两个不同的牢房里。他们不能互相交谈，得出他们都否认并因贩毒案件被判两年监狱的情况（在这种情况中这似乎是全局最优解），嗯，即使他们能互相交谈，他们可能也不会真正信任对方。现在鲍勃的脑海中会想些什么呢？他有两个选择，承认或否认。他知道查理会选择对他最好的选项，他自己也不例外。如果他否认而查理承认，那么他将面临五年的监狱困境，而查理只有一年的监狱。他当然不希望陷入这种情况。如果鲍勃承认，那么查理有两个选择：承认或否认。现在鲍勃认为，如果他承认，无论查理做什么，他不会得到超过三年的刑期。让我们为鲍勃陈述这些情况。
- en: Bob confesses and Charlie denies—Bob gets one year, Charlie gets five years
    (best case given Bob confesses)
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 鲍勃承认而查理否认——鲍勃一年，查理五年（考虑到鲍勃承认的情况下最好的情况）
- en: Bob confesses and Charlie also confesses—Both Bob and Charlie get three years
    (worst case given Bob confesses)
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 鲍勃承认，查理也承认——鲍勃和查理都三年（考虑到鲍勃承认的情况下最坏的情况）
- en: This situation is called Nash equilibrium where each party has taken the best
    move, given the choices of the other party. This is definitely not the global
    optimum, but represents the best move as an individual. Now, if you look at this
    situation  as an outsider, you would say both should deny and get two years. But
    when you play as a participant in the game, Nash equilibrium is what you would
    eventually fall into. Note that this is the most stable stage where you changing
    your decision does not benefit you at all. It can be pictorially represented as
    shown in Figure [2-17](A440588_1_En_2_Chapter_split_001.xhtml#Fig17).![A440588_1_En_2_Fig17_HTML.jpg](Images/A440588_1_En_2_Fig17_HTML.jpg)Figure
    2-17Prisoner’s dilemma—payoff matrix
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况被称为纳什均衡，其中每个参与者都采取了考虑到其他参与者选择的最佳行动。这绝对不是全局最优的，但代表了个人的最佳行动。现在，如果你作为一个旁观者来看待这种情况，你可能会说他们都应该否认，然后被判两年。但当你作为游戏参与者参与时，纳什均衡是最终会陷入的。请注意，这是最稳定的阶段，在这个阶段，改变你的决定对你没有任何好处。如图2-17所示，这可以形象地表示出来。![A440588_1_En_2_Fig17_HTML.jpg](Images/A440588_1_En_2_Fig17_HTML.jpg)图2-17囚徒困境——支付矩阵
- en: Byzantine Generals’ Problem
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 拜占庭将军问题
- en: 'In the previous section, we looked at different examples of games and learned
    a few game theory concepts. Now we will discuss a specific problem from the olden
    days that is still widely used to solve many computer science as well as real-life
    problems.The Byzantine Generals’ Problem was a problem faced by the Byzantine
    army while attacking a city. The situation was straightforward yet very difficult
    to deal with. To put it simply, the situation was that several army factions commanded
    by separate generals surrounded a city to win over it. The only chance of victory
    is when all the generals attack the city together. However, the problem is how
    to reach a consensus. This implies that either all the generals should attack
    or all of them should retreat. If some of them attack and some retreat, then chances
    are greater they would lose the battle. Let us take an example with numbers to
    be able to understand the situation better.Let us assume a situation where there
    are five factions of the Byzantine army surrounding a city. They would attack
    the city if at least three out of five generals are willing to attack, but retreat
    otherwise. If there is a traitor among the generals, what he can do is vote for
    attack with the generals willing to attack and vote for retreat with the generals
    willing to retreat. He can do so because the army is dispersed in factions  ,
    which makes centralized coordination difficult. This can result in two generals
    attacking the city and getting outnumbered and defeated. There could be more complicated
    issues with such a situation:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们研究了不同类型的游戏，并学习了一些博弈论的概念。现在，我们将讨论一个来自古老时代的问题，这个问题至今仍被广泛用于解决许多计算机科学和现实生活中的问题。拜占庭将军问题曾是拜占庭军队在攻城时遇到的问题。这个情形虽然简单，但很难处理。简单地说，情况是这样的：几个由不同将军指挥的军队包围了一个城市，以期攻克它。取得胜利的唯一机会是所有将军一起进攻。然而，问题是如何达成共识。这意味着要么所有将军都进攻，要么他们都撤退。如果他们中的一些人进攻而另一些撤退，那么他们很可能会在战斗中失利。让我们通过一个数字例子来更好地理解这个情况。假设有一个拜占庭军队的五支部队包围了一个城市。如果至少有三个将军愿意进攻，他们就会进攻城市，否则就会撤退。如果将军中有叛徒，他可以投赞成进攻的将军一票，投赞成撤退的将军一票。他可以这样做的原因是，军队分散在各个部队中，这使得集中协调变得困难。这可能导致两个将军进攻城市，被敌人数量压制并击败。在这种情况下可能会有更复杂的问题：
- en: What if there is more than one traitor?
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有多个叛徒会怎样？
- en: How would the message coordination between generals take place?
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将军之间的信息协调将如何进行？
- en: What if a messenger is caught/killed/bribed by the city commander?
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果信使被城市指挥官抓住/杀死/贿赂会怎样？
- en: What if a traitor general forges a different message and fools other generals?
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个叛徒将军伪造了一条不同的信息，并愚弄了其他将军会怎样？
- en: How to find the generals who are honest and who are traitors?
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何找出诚实的将军和叛徒？
- en: As you can see, there are so many challenges that need to be addressed for a
    coordinated attack on the city. It can be pictorially represented as in Figure
    [2-18](A440588_1_En_2_Chapter_split_001.xhtml#Fig18).![A440588_1_En_2_Fig18_HTML.jpg](Images/A440588_1_En_2_Fig18_HTML.jpg)Figure
    2-18Byzantine army attacking the cityThere are numerous scenarios in real life
    that are analogous to the Byzantine Generals’ Problem  . How a group of people
    reach consensus on some voting agenda or how to maintain the consistent state
    of a distributed or decentralized database, or maintaining the consistent state
    of blockchain copies across nodes in a network are a few examples similar to the
    Byzantine Generals’ Problem. Note, however, that the solutions to these different
    problems could be quite different in different situations. We will look at how
    Bitcoin solves the Byzantine Generals’ Problem later in this book.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，对于协调一致地攻击城市，有许多挑战需要解决。这可以像图[2-18](A440588_1_En_2_Chapter_split_001.xhtml#Fig18)那样，用图片表示。![A440588_1_En_2_Fig18_HTML.jpg](Images/A440588_1_En_2_Fig18_HTML.jpg)图2-18拜占庭军队攻击城市现实生活中有许多场景与拜占庭将军问题类似。一群人如何就某些投票议程达成共识，或者如何保持分布式或去中心化数据库的一致状态，或者保持网络中区块链副本的一致状态，都是与拜占庭将军问题类似的例子。然而，请注意，这些不同问题的解决方案在不同的情况下可能会有很大的不同。我们将在本书的后部分探讨比特币如何解决拜占庭将军问题。
- en: Zero-Sum Games
  id: totrans-287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 零和游戏
- en: 'A zero-sum game in game theory is quite straightforward. In such games, one
    player’s gain is equivalent to another player’s loss. Example: One wins exactly
    the same amount as the opponent loses, which means choices by players can neither
    increase nor decrease the available resources in a given situation.Poker, Chess,
    Go, etc. are a few examples of zero-sum games. To generalize even more, the games
    where only one person wins and the opponent loses, such as tennis, badminton,
    etc. are also zero-sum games. Many financial instruments such as swaps, forwards,
    and options can also be described as zero-sum instruments.In many real-life situations,
    gains and losses are difficult to quantify. So, zero-sum games are less common
    compared with non-zero-sum games. Most financial transactions or trades and the
    stock market  are non-zero-sum games. Insurance, however, is a field where a zero-sum
    game plays an important role. Just think about how the insurance schemes might
    work. We pay an insurance premium to the insurance companies to guard against
    some difficult situations such as accidents, hospitalization, death, etc. Thinking
    that we are insured, we live a peaceful life and we are fairly compensated by
    the insurance companies when we face such tough situations. There is certainly
    a financial backup that helps us survive. Note that everyone who pays the premium
    does not meet with accident or get hospitalized, and the ones who do need a lot
    of money compared with the premium they pay. You see, things are quite balanced
    here, even considering the operational expenses of the insurance company. Again,
    the insurance company may invest the premium we pay and get some return on that.
    Still, this is a zero-sum game.Just to give you a different example, if there
    is one open position for which an interview drive is happening, then the candidate
    who qualifies actually does it at the cost of others’ disqualification. This is
    also a zero-sum game.You may ask if there is any use in studying about zero-sum
    games  . Just being aware of a zero-sum situation is quite useful in understanding
    and devising a strategy for any complex problem. We can analyze if we can practically
    gain in a given situation in which the transactions are taking place.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在博弈论中，零和游戏是非常直接的。在这样的游戏中，一方的收益等于另一方的损失。例子：一个人赢得的正好是另一个人输掉的相同金额，这意味着玩家的选择不能增加或减少给定情况下的可用资源。扑克、国际象棋、围棋等都是零和游戏的几个例子。更进一步泛化，只有一个人赢了，对手输了的游戏，如网球、羽毛球等也是零和游戏。许多金融工具，如掉期、远期和期权，也可以被描述为零和工具。在许多现实生活中的情况下，收益和损失很难量化。因此，零和游戏相比非零和游戏要少见得多。大多数金融交易或贸易以及股市都是非零和游戏。然而，保险是一个零和游戏发挥重要作用的领域。想想保险方案可能是如何运作的。我们向保险公司支付保险费，以防范一些困难的情况，如事故、住院、死亡等。认为我们有保险，我们过着平静的生活，当面临这些艰难的情况时，我们得到了保险公司的相当补偿。确实有一个经济后盾帮助我们生存。请注意，支付保险费的每个人并不一定会遇到事故或住院，而那些确实需要的人相对于他们支付的保险费需要更多的钱。你看，这里的事情是相当平衡的，即使考虑到保险公司的运营费用。再次，保险公司可能会投资我们支付的保险费并从中获得一些回报。尽管如此，这仍然是一个零和游戏。
    just to give you a different example, if there is one open position for which
    an interview drive is happening, then the candidate who qualifies actually does
    it at the cost of others’ disqualification. This is also a zero-sum game. 你可能会问，研究零和游戏有什么用。仅仅是意识到零和情况在理解和制定任何复杂问题的策略上非常有用。我们可以分析我们是否可以在给定情况下实际获得收益，其中正在发生交易。
- en: Why to Study Game Theory
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为什么要研究博弈论
- en: Game theory is a revolutionary interdisciplinary phenomenon bringing together
    psychology, economics, mathematics, philosophy, and an extensive mix of various
    other academic areas.We say that game theory is related to real-world problems.
    However, the problems are limitless. Are the game theoretic concepts limitless
    as well? Certainly! We use game theory every day, knowingly or unknowingly, because
    we always use our brains to take the best strategic action, given a situation.
    Don’t we? If that is so, why study game theory?Well, there are numerous examples
    in game theory that help us think differently. There are some theories developed
    such as Nash Equilibrium that relate to many real-life situations. In many real-world
    situations, the participants or the players are faced with a decision matrix similar
    to that of a “prisoner’s dilemma  .” So, learning these concepts not only helps
    us formulate the problems in a more mathematical way, but also enables us to make
    the best move. It lets us identify aspects that each participant should consider
    before choosing a strategic action in any given interaction. It tells us to identify
    the type of game first; who are the players, what are their objectives or goals,
    what could be their actions, etc., to be able to take the best action. Much decision-making
    in real life involves different parties; game theory provides the basis for rational
    decision-making.The Byzantine Generals’ Problem  that we studied in the previou
    section is widely used in distributed storage solutions and data centers to maintain
    data consistency across computing nodes.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 博弈论是一个革命性的跨学科现象，它将心理学、经济学、数学、哲学以及各种其他学术领域汇集在一起。我们说博弈论与现实世界问题相关。然而，问题无穷无尽。博弈论的概念也是无穷无尽的吗？当然！我们每天都在有意识或无意识地使用博弈论，因为我们总是用大脑采取最佳的战略行动，给定一个情境。不是吗？如果是这样，为什么还要研究博弈论呢？嗯，博弈论中有许多例子可以帮助我们以不同的方式思考。有一些理论被开发出来，如纳什均衡，与许多现实生活情境相关。在许多现实世界的情境中，参与者或玩家面临的是类似于“囚徒困境”的决策矩阵。所以，学习这些概念不仅可以帮助我们用更数学的方式制定问题，还可以让我们做出最佳举动。它让我们在每一个给定的互动中识别出每个参与者应该考虑的战略行动的方面。它告诉我们首先要识别游戏的类型；参与者是谁，他们的目标或目标是什么，他们可能采取哪些行动等等，以便能够采取最佳行动。现实生活中的大部分决策都涉及不同的各方；博弈论提供了理性决策的基础。我们在上一节研究的拜占庭将军问题在分布式存储解决方案和数据中心中广泛使用，以在计算节点之间保持数据一致性。
- en: Computer Science Engineering
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算机科学工程
- en: As mentioned already, it is clever engineering with the concepts from computer
    science that stitches the components of cryptography, game theory, and many others
    to build a blockchain. In this section, we will learn some of the important computer
    science components that are used in blockchain.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 正如已经提到的，运用计算机科学的概念巧妙地编织了密码学、博弈论等众多组件来构建区块链。在本节中，我们将学习一些在区块链中使用的重要的计算机科学组件。
- en: The Blockchain
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 区块链
- en: As we will see, a blockchain is actually a blockchain data structure; in the
    sense that it is a chain of blocks linked together. When we say a block, it can
    mean just a single transaction or multiple transactions clubbed together. We will
    start our discussion with hash pointers, which is the basic building block of
    blockchain data structure.A hash pointer is a cryptographic hash pointing to a
    data block, where the hash pointer is the hash of the data block itself (Figure
    [2-19](A440588_1_En_2_Chapter_split_001.xhtml#Fig19)). Unlike linked lists that
    point to the next block so you can get to it, hash pointers point to the previous
    data block and provide a way to verify that the data has not been tampered with.![A440588_1_En_2_Fig19_HTML.jpg](Images/A440588_1_En_2_Fig19_HTML.jpg)Figure
    2-19Hash pointer for a block of transactionsThe purpose of the hash pointer is
    to build a tamper resistant blockchain that can be considered as a single source
    of truth. How does blockchain achieve this objective? The way it works is that
    the hash of the previous block is stored in the current block header, and the
    hash of the current block with its block header will be stored in the next block’s
    header. This creates the blockchain as we can see in Figure [2-20](A440588_1_En_2_Chapter_split_001.xhtml#Fig20).![A440588_1_En_2_Fig20_HTML.jpg](Images/A440588_1_En_2_Fig20_HTML.jpg)Figure
    2-20Blocks in a blockchain linked through hash pointersAs we can observe, every
    block points to its previous block, known as “the parent block.”  Every new block
    that gets added to the chain becomes the parent block for the next block to be
    added. It goes all the way to the first block that gets created in the blockchain,
    which is called “the genesis block.”  In such a design where blocks are linked
    back with hashes, it is practically infeasible for someone to alter data in any
    block. We already looked at the properties of hash functions, so we understand
    that the hashes will not match if the data is altered. What if someone changes
    the hash as well? Let us focus on Figure [2-21](A440588_1_En_2_Chapter_split_001.xhtml#Fig21)
    to understand how it is not possible to alter the data in any way.![A440588_1_En_2_Fig21_HTML.jpg](Images/A440588_1_En_2_Fig21_HTML.jpg)Figure
    2-21Any attempt in changing Header or Block content breaks the entire chain. Assume
    that you altered the data in block-1234. If you do so, the hash that is stored
    in the block header of block-1235 would not match.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将要看到的，区块链实际上是一种区块链数据结构；从某种意义上说，它是由链接在一起的区块组成的链。当我们说一个区块时，它可能只是一个单独的交易或者多个交易组合在一起。我们将从哈希指针开始我们的讨论，这是区块链数据结构的基本构建块。哈希指针是一种加密哈希，指向一个数据块，其中哈希指针是数据块本身的哈希（图[2-19](A440588_1_En_2_Chapter_split_001.xhtml#Fig19)）。与指向下一个块以便你可以找到它的链表不同，哈希指针指向前一个数据块并提供了一种验证数据是否被篡改的方法。![A440588_1_En_2_Fig19_HTML.jpg](Images/A440588_1_En_2_Fig19_HTML.jpg)图2-19交易区块的哈希指针哈希指针的目的是构建一个抗篡改的区块链，可以被认为是单一的真实来源。区块链是如何实现这个目标的？它的工作方式是，将前一个块的哈希存储在当前块的头部，并将当前块及其块头
    的哈希存储在下一个块的头部。这样就形成了我们可以看到的区块链（图[2-20](A440588_1_En_2_Chapter_split_001.xhtml#Fig20)）。![A440588_1_En_2_Fig20_HTML.jpg](Images/A440588_1_En_2_Fig20_HTML.jpg)图2-20通过哈希指针链接的区块链区块正如我们所观察到的，每个区块都指向其前一个区块，称为“父区块”。每一个添加到链中的新区块都成为下一个要添加的区块的父区块。一直到最后一个在区块链中创建的区块，称为“创世区块”。在这种通过哈希链接回的区块设计中，实际上对于某人来说篡改任何区块中的数据是不切实际的。我们已经查看了哈希函数的特性，所以我们知道如果数据被篡改，哈希将不匹配。如果有人还改变了哈希呢？让我们关注图[2-21](A440588_1_En_2_Chapter_split_001.xhtml#Fig21)
    来了解这是如何不可能以任何方式篡改数据的。![A440588_1_En_2_Fig21_HTML.jpg](Images/A440588_1_En_2_Fig21_HTML.jpg)图2-21任何试图改变头部或区块内容的行为都会破坏整个链。假设你篡改了区块-1234中的数据。如果你这样做，存储在区块-1235的头部中的哈希将不匹配。
- en: What if you also change the hash stored in the block header of block-1235 so
    that it perfectly matches the altered data. In other words, you hash the data
    block-1234 after you alter it and replace that new hash with the one stored in
    block header of block-1235\. After you do this, the hash of the block-1235 changes
    (because block-1235 means the data and the header together) and it does not match
    with the one stored in the block header of block-1236.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你还改变了存储在区块-1235的头部中的哈希，使其与篡改后的数据完全匹配。换句话说，你在篡改后对数据块-1234进行哈希处理，并将其新的哈希替换为存储在区块-1235的头部中的那个。在你这样做之后，区块-1235的哈希（因为区块-1235意味着数据和头部一起）会发生变化，并且它与存储在区块-1236的头部中的那个不匹配。
- en: One has to keep doing this all the way till the final or the most recent hash.
    Since everyone or many in the network already have a copy of the blockchain along
    with the most recent hash, in no way is it possible to hack into the majority
    of the systems and change all the hashes at a time.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须一直重复这个过程，直到最终的或者最新的散列值。由于网络中的每个人或许多人已经拥有区块链以及最新散列值的副本，所以不可能同时入侵大多数系统并更改所有散列值。
- en: This makes it a tamper-proof blockchain data structure.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这使得它成为一种防篡改的区块链数据结构。
- en: This clearly means that each block can be uniquely identified by its hash. To
    calculate this hash, you can use either the SHA2 or SHA3 family of hash functions
    that we discussed in the cryptography section. If you use SHA-256 to hash the
    blocks, it would produce a 256-bit hash output such as:000000000000000a73b6a2af7bad40ec3fc2a83dafd76ef15f3d1b71a7132765Notice
    that there are only 64 characters in it. Since the hashed output is represented
    using hexadecimal characters, and every hex digit can be represented using four
    bits, the output is 64 × 4 = 256 bits. You would usually see that the 256-bit
    hashed output is represented using the 64 hex characters in many places.The structure
    of a block, that is, block size, the data and header sections, number of transactions
    in a block, etc., is something that you should decide while designing a blockchain
    solution. For existing blockchains such as Bitcoin, Ethereum, or Hyperledger,
    the structure is already defined and you have to understand that to build on top
    of these platforms. We will take a closer look at the Bitcoin and Ethereum blockchains
    later in this book.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这明确表示每个区块可以通过其散列值唯一标识。要计算这个散列值，你可以使用我们在密码学部分讨论的SHA2或SHA3散列函数家族。如果你使用SHA-256散列区块，它将产生一个256位的散列输出，例如：000000000000000a73b6a2af7bad40ec3fc2a83dafd76ef15f3d1b71a7132765请注意，其中只有64个字符。由于散列输出使用十六进制字符表示，而每个十六进制数字可以用四个位表示，所以输出是64×4=256位。你通常会在很多地方看到256位散列输出使用64个十六进制字符表示。区块的结构，即区块大小、数据和头部部分、区块中的交易数量等，是在设计区块链解决方案时你应该决定的事情。对于现有的区块链，如比特币、以太坊或超级账本，结构已经定义好，你必须理解这些才能在这些平台上进行构建。我们将在本书的后面部分更详细地查看比特币和以太坊的区块链。
- en: Merkle Trees
  id: totrans-299
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 默克尔树
- en: 'A Merkle tree is a binary tree of cryptographic hash pointers, hence it is
    a binary hash tree. It is named so after its inventor Ralph Merkle. It is another
    useful data structure being used in blockchain solutions such as Bitcoin. Merkle
    trees are constructed by hashing paired data (usually transactions at the leaf
    level), then again hashing the hashed outputs all the way up to the root node,
    called the Merkle root. Like any other tree, it is constructed bottom-up. In Bitcoin,
    the leaves are always transactions of a single block in a blockchain. We will
    discuss in a little while the advantages of using Merkle trees, so you can decide
    for yourself if the leaves would be transactions or a group of transactions in
    blocks. A typical Merkle tree can be represented as in Figure [2-22](A440588_1_En_2_Chapter_split_001.xhtml#Fig22).![A440588_1_En_2_Fig22_HTML.jpg](Images/A440588_1_En_2_Fig22_HTML.jpg)Figure
    2-22Merkle tree  representationSimilar to the hash pointer data structure, the
    Merkle tree  is also tamper-proof. Tampering at any level in the tree would not
    match with the hash stored at one level up in the hierarchy, and also till the
    root node. It is really difficult for an adversary to change all the hashes in
    the entire tree. It also ensures the integrity of the order of transactions. If
    you change just the order of the transactions, then also the hashes in the tree
    till the Merkle root will change.Here is a situation. The Merkle tree is a binary
    tree and there should be an even number of items at the leaf level. What if there
    are an odd number of items? One good solution would be to duplicate the last transaction
    hash. Since it is the hash we are duplicating, it would mean just the same transaction
    and not create any issue such as double-spend or repeated transactions. That way,
    it is possible to balance the tree.In the blockchain we discussed, if we were
    to find a transaction through its hash, or check if a transaction had happened
    in the past, how would we get to that transaction? The only way is to keep traversing
    till you encounter the exact block that matches the hash of the transaction. This
    is a case where a Merkle tree can help a great deal.Merkle trees  provide a very
    efficient way to verify if a specific transaction belongs to a particular block.
    If there are “n” transactions in a Merkle tree (leaf items), then this verification
    takes just Log (n) time as shown in Figure [2-23](A440588_1_En_2_Chapter_split_001.xhtml#Fig23).![A440588_1_En_2_Fig23_HTML.jpg](Images/A440588_1_En_2_Fig23_HTML.jpg)Figure
    2-23Verification in Merkle treeTo verify if a transaction or any other leaf item
    belongs to a Merkle tree, we do not need all items and the whole tree. Rather,
    a subset of it is needed as we can see in the diagram in Figure [2-23](A440588_1_En_2_Chapter_split_001.xhtml#Fig23).
    One can just start with the transaction to verify along with its sibling (it is
    a binary tree so there would be one sibling leaf item), calculate the hash of
    those two, and see if it matches their parent hash. Then continue with that parent
    hash and its sibling  at that level and hash them together to get their parent
    hash. Continuing this process all the way to the top root hash is the quickest
    possible way for transaction verification (just Log (n) time for n items). In
    the figure, only the solid rectangles are required and the dotted rectangles can
    be just computed, provided the solid rectangle data. Since there are eight transaction
    elements (n = 8), only three computations (log2 8 = 3) would be required for verification.Now,
    how about a hybrid of both blockchain data structure and Merkle tree? Imagine
    a situation in a blockchain where each block has a lot of transactions. Since
    it is a blockchain, the hash of the previous block is already there; now, including
    the Merkle root of all the transactions in a block can help in quicker verification
    of the transactions. If we have to verify a transaction that is claimed to be
    from, say, block-22456, we can get the transactions of that block, verify the
    Merkle tree, and confirm quickly if that transaction is valid. We already saw
    that verifying a transaction is quite easy and fast with Merkle trees. Though
    blocks in the blockchain are tamper resistant and do not provide even the slightest
    scope to change anything in a block, the Merkle tree also ensures that the order
    of transactions is preserved.In a typical blockchain setting, there could be many
    situations where a node (for simplicity sake, assume any node that does not have
    the full blockchain data, i.e., a light node) has to verify if a certain transaction
    took place in the past. There are actually two things that need verification here:
    transaction as part of the block, and block as part of the blockchain. To do so,
    a node does not have to download all the transactions of a block  , it can simply
    ask the network for the information pertaining to the hash of the block and the
    hash of the transaction. The peers in the network who have the relevant information
    can respond with the Merkle path to that transaction. Well, you might ask how
    to trust the data that an unknown peer in the network is sharing with you. You
    already know that the hash functions are one-way. So in no way can an adversarial
    node forge transactions that would match a given hash value; it is even difficult
    to do so from transaction level till the Merkle root.The use of Merkle trees  is
    not limited to just blockchains: they are widely used in many other applications
    such as BitTorrent, Cassandra—an NoSQL database, Apache Wave, etc.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: Example Code Snippet for Merkletree
  id: totrans-301
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例代码片段：默克尔树
- en: 'This section is just intended to give you a heads-up on how to code up a Merkle
    tree at its most basic level. Code examples  are in Python but would be quite
    similar in different languages; you just have to find the right library functions
    to use.# -*- coding: utf-8 -*-from hashlib import sha256class MerkelTree(object):    def
    __init__(self):        pass            def chunks(self,transaction,n):        #This
    function yeilds "n" number of transaction at time        for i in range (0, len(transaction),number):            yield
    transaction[i:i+2]    def merkel_tree(self,transactions):        #Here we will
    find the merkel tree hash of all transactions passed to this fuction        #Problem
    is solved using recursion techqiue        # Given a list of transactions, we concatinate
    the hashes in groups of two and compute        # the hash of the group, then keep
    the hash of group. We repeat this step till        # we reach a single hash        sub_tree=[]        for
    i in chunks(transactions,2):            if len(i)==2:                hash = sha256(str(i[0]+i[1])).hexdigest()            else:                hash
    = sha256(str(i[0]+i[0])).hexdigest()            sub_tree.append(hash)        #
    When the sub_tree has only one hash then we reached our merkel tree hash.        #Otherwise,
    we call this fuction recursively        if len(sub_tree) == 1:            return
    sub_tree[0]        else:            return self.merkel_tree(sub_tree)if __name__==''__main__'':    mk=MerkelTree()    merkel_hash=
    mk.merkel_tree(["TX1","TX2","TX3","TX4","TX5","TX6"])    print merkel_hash'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 本节旨在为您提供一个关于如何以最基本的方式编写默克尔树的代码示例。代码示例使用Python编写，但在不同的语言中会非常相似；你只需要找到合适的库函数来使用。
- en: Putting It All Together
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 综合所有内容
- en: 'To get to this section, we covered all the necessary components of blockchain
    that can help us understand how it really works. After going through them, namely
    cryptography, game theory, and computer science engineering concepts, we must
    have developed a notion of how blockchains might work. Though these concepts have
    been around for ages, no one could ever imagine how the same old stuff can be
    used to build a transforming technology such as blockchain. Let us have a quick
    recap of some fundamentals we covered so far, and we will build further understanding
    on those concepts. So here they are:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 为了到达这一节，我们已经涵盖了区块链的所有必要组成部分，帮助我们了解它实际上是是如何工作的。在经历了它们，即密码学、博弈论和计算机科学工程概念之后，我们可能已经形成了一个关于区块链可能如何工作的概念。尽管这些概念已经存在了很长时间，但没有人能想象到同样的旧东西可以用来构建像区块链这样的变革性技术。让我们快速回顾一下我们到目前为止涵盖的一些基本概念，然后在这些概念上进一步建立理解。以下是它们的内容：
- en: Cryptographic functions are one-way and cannot be inverted. They are deterministic
    and produce the same output for a given input. Any changes to the input would
    produce a completely different output when hashed again.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密码学函数是单向的，不能被反转。它们是确定性的，给定一个输入会产生相同的输出。对输入的任何更改在再次哈希时会产生完全不同的输出。
- en: Using public key cryptography, digital signatures are possible. It helps in
    verifying the authenticity of the person/entity that has signed. Considering the
    private key is kept confidential, it is not feasible to forge a signature with
    someone else’s identity. Also, if someone has signed on any document or a transaction,
    they cannot later deny they did not.
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用公钥加密技术，可以实现数字签名。它有助于验证签署人的真实性。考虑到私钥是保密的，使用别人的身份伪造签名是不可能的。另外，如果有人已经在任何文件或交易上签字，他们
    later cannot deny they did not.
- en: Using game theoretic principles and best practices, robust systems can be designed
    that can sustain in most of the odd situations. Systems that can face the Byzantine
    Generals’ Problem need to be handled properly. Our approach to any system design
    should be such that the participants play by the rules to get the maximum payoff;
    deviating from the protocol should not really benefit them.
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用博弈论原则和最佳实践，可以设计出能在大多数异常情况下持续运行的健壮系统。能够面对拜占庭将军问题的系统需要妥善处理。我们对任何系统设计的方法应该是参与方遵守规则以获得最大回报；偏离协议实际上并不会给他们带来好处。
- en: The blockchain data structure, by using the cryptographic hashes, provides a
    tamper resistant chain of blocks. The usage of Merkle trees makes the transaction
    verification easier and faster.
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用加密哈希，区块链数据结构提供了一个防篡改的区块链。使用默克尔树使得交易验证更加容易和快速。
- en: 'With all these concepts in mind, let us now think of a real blockchain implementation.
    What problems can you think of that need to be addressed for such a decentralized
    system to work properly? Well, there are loads of them; some would be generic
    to most of the blockchain use cases and some would be specific to a few. Let us
    discuss at least some of the scenarios that need to be addressed:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 带着这些概念在脑海中，现在让我们考虑一个真实的区块链实现。你能想到哪些问题需要解决，才能使这样的去中心化系统正常工作？好吧，有很多问题；其中一些可能对大多数区块链用例都通用，而另一些可能只针对少数特定用例。让我们至少讨论一些需要解决的场景：
- en: Who would maintain the distributed ledger of transactions? Should all the participants
    maintain, or only a few would do? How about the computing nodes that are not powerful
    enough to process transactions or do not have enough storage space to accommodate
    the entire history of transactions?
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 谁将维护交易的去中心化账本？所有参与者都应该维护，还是只有少数人？那么计算能力不足或没有足够存储空间来容纳交易完整历史的节点呢？
- en: How is it possible to maintain a single consistent state of the distributed
    ledger? Network latency, packet drops, deliberate hacking attempts, etc. are inevitable.
    How would the system survive all these?
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何可能保持分布式账本的一致状态？网络延迟、数据包丢失、故意的黑客攻击等都是不可避免的。系统如何承受所有这些挑战？
- en: Who would validate or invalidate the transactions? Would only a few authorized
    nodes validate, or all the nodes together would reach a consensus? What if some
    of the nodes are not available at a given time?
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 谁将验证或否定交易？只有少数授权节点验证，还是所有节点一起达成共识？如果有些节点在特定时间不可用怎么办？
- en: What if some computing nodes deliberately want to subvert the system or try
    to reject some of the transactions?
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一些计算节点故意想破坏系统或试图拒绝某些交易怎么办？
- en: How would you upgrade the system when there is no centralized entity to take
    the responsibility? In a decentralized network, what if a few computing nodes
    upgrade themselves and the rest don’t?
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当没有中央实体负责时，你将如何升级系统？在一个去中心化网络中，如果有一些计算节点升级了自己而其余节点没有呢？
- en: There are in fact a lot more concerns that need to be addressed apart from the
    ones just mentioned. For now we will leave you with those thoughts, but most of
    those queries should be clarified by the end of this chapter.Let us start with
    some basic building blocks of a blockchain system that may be required to design
    any decentralized solution.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，除了刚才提到的内容，还有很多问题需要解决。现在我们将留给你这些问题，但本章结束时应该会澄清大部分这些问题。让我们先从区块链系统可能需要的几个基本构建块开始，以设计任何去中心化解决方案。
- en: Properties of Blockchain Solutions
  id: totrans-316
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 区块链解决方案的特性
- en: So far, we have only learned the technical aspects of blockchain solutions to
    understand how blockchains might work. In this section, we will learn some of
    the desired properties of blockchains.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只学习了区块链解决方案的技术方面，以了解区块链可能如何工作。在本节中，我们将学习一些区块链期望的属性。
- en: Immutability
  id: totrans-318
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 不可变性
- en: It is the most desired property to maintain the atomicity of the blockchain
    transactions. Once a transaction is recorded, it cannot be altered. If the transactions
    are broadcast to the network, then almost everyone has a copy of it. With time,
    when more and more blocks are added to the blockchain, the immutability increases
    and after a certain time, it becomes completely immutable. For someone to alter
    the data of so many blocks in a series is not practically feasible because they
    are cryptographically secured. So, any transaction that gets logged remains forever
    in the system.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 它是保持区块链交易原子性的最理想属性。一旦交易被记录，就无法更改。如果交易被广播到网络，那么几乎每个人都会有它的副本。随着时间的推移，当越来越多的区块被添加到区块链时，其不可变性会增加，在一定时间后，它就变得完全不可变。要更改这么多区块的数据是不切实际的，因为它们是经过加密保护的。所以，任何被记录的交易都永远保存在系统中。
- en: Forgery Resistant
  id: totrans-320
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 抵御伪造
- en: A decentralized solution where the transactions are public is prone to different
    kinds of attacks. Attempts at forgery are the most obvious of all, especially
    when you are transacting anything of value. Cryptographic hash and digital signatures
    can be used to ensure the system is forgery resistant. We already learned that
    it is computationally infeasible to forge someone else’s signature. If you make
    a transaction and sign a hash of it, no one can alter the transaction later and
    say you signed a different transaction. Also, you cannot later claim you never
    did the transaction, because it is you who signed it.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 去中心化的解决方案，其中交易是公开的，容易受到各种攻击。尝试伪造是最明显的，尤其是当你交易任何有价值的东西时。可以使用加密散列和数字签名来确保系统抵御伪造。我们已经了解到，伪造他人的签名在计算上是不切实际的。如果你进行一笔交易并签署它的散列值，后来没有人可以更改交易并说你签署了一笔不同的交易。此外，你不能后来声称你从未进行过交易，因为是你签署的。
- en: Democratic
  id: totrans-322
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 民主
- en: Any peer-to-peer decentralized system should be democratic by design (may not
    be fully applicable to the private blockchain, which we will park for later).
    There should not be any entity in the system that is more powerful than the others.
    Every participant should have equal rights in any situation, and decisions are
    made when the majority reaches a consensus.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 任何点对点的去中心化系统都应该在设计上是民主的（可能不适用于私有的区块链，这个问题我们稍后再讨论）。系统中不应该有比其他实体更强大的存在。在任何情况下，每个参与者都应享有平等的权利，当大多数达到共识时，做出决定。
- en: Double-Spend Resistant
  id: totrans-324
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 抵御双重支付
- en: 'Double-spend attacks are quite common in monetary as well as nonmonetary transactions.
    In a cryptocurrency setting, a double-spend attempt is when you try to spend the
    same amount to multiple people. Example: You have $100 in your account and you
    pay $90 to two or more parties is a type of double-spend. This is a little different
    when it comes to cryptocurrency such as Bitcoin where there is no notion of a
    closing balance. Input to a transaction (when you are paying to someone) is the
    output of another transaction where you have received at least the amount you
    are paying through this transaction. Assume Bob received $10 from Alice some time
    back in a transaction. Today if Bob wants to pay Charlie $8, then the transaction
    in which he received $10 from Alice would be the input to transact with Charlie.
    So, Bob cannot use the same input (Alice’s $10 paid to him) multiple times to
    pay to other people and double-spend. Just to give you a different example: if
    someone owns some land and sells the same piece of land to two people.In a centralized
    system it is quite easy to prevent double-spend because the central authority
    is aware of all the transactions. A blockchain solution should also be immune
    to such double-spend attacks. While cryptography ensures authenticity of a transaction,
    it cannot help prevent double-spend. Because, technically, both a normal transaction
    and a double-spend transaction are genuine. So, the only way possible to prevent
    double-spend is to be aware of all the transactions. If we are aware of all transactions
    that happened in the past, we can figure out if a transaction is an attempt to
    double-spend. So, the nodes that would validate the transactions should definitely
    be accessible to the whole blockchain data since the genesis block.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 双重支付攻击在货币和非货币交易中相当常见。在加密货币环境中，双重支付尝试是指你尝试将相同金额支付给多个人。例如：你的账户里有100美元，你向两个或更多方支付90美元是一种双重支付。这在加密货币（如比特币）中略有不同，因为比特币中没有结余的概念。交易的输入（当你支付给某人时）是另一个交易的输出，你在该交易中至少收到了你要支付的金额。假设鲍勃之前从爱丽丝那里收到了10美元，今天鲍勃想付给查理8美元，那么他从爱丽丝那里收到10美元的交易将是与查理交易的基础。所以，鲍勃不能多次使用相同的输入（爱丽丝支付给他的10美元）来支付给其他人以实现双重支付。给你一个不同的例子：如果有人拥有一块土地，并将同一块土地卖给两个人。在集中式系统中，防止双重支付相当容易，因为中央机构了解所有交易。区块链解决方案也应该对这种双重支付攻击免疫。虽然密码学确保了交易的真实性，但它无法帮助防止双重支付。因为从技术上讲，正常交易和双重支付交易都是真实的。所以，防止双重支付的唯一方法就是要知道所有的交易。如果我们了解过去发生的所有交易，我们可以判断一个交易是否是双重支付的尝试。因此，验证交易的节点应该能够访问整个区块链数据，从创世区块开始。
- en: Consistent State of the Ledger
  id: totrans-326
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 账本的一致状态
- en: The properties we just discussed ensure that the ledger is consistent throughout,
    to some extent. Imagine a situation when some nodes deliberately want a transaction
    to not go through and to get rejected. Or, if somehow some nodes are not in sync
    with the ledger and hence not aware of a few transactions that took place while
    they were offline, then to them a transaction may look like fraudulent. So, how
    to ensure consensus among the participants is something that needs to be handled
    very carefully. Recollect the Byzantine Generals’ Problem. The right kind of consensus
    suitable for a given situation plays the most important role to ensure stability
    of a decentralized solution. We will learn different consensus mechanisms later
    in this book.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚讨论的属性确保了账本在某种程度上是一致的。想象一种情况，一些节点故意希望一个交易不通过并被拒绝。或者，如果一些节点以某种方式与账本不同步，因此在离线时没有注意到一些已经发生的交易，那么对他们来说，一个交易可能看起来是欺诈的。所以，如何确保参与者之间的共识是需要非常小心处理的事情。回想一下拜占庭将军的问题。适合特定情况的正确共识在确保去中心化解决方案的稳定性方面起着最重要的作用。我们将在本书的后面学习不同的共识机制。
- en: Resilient
  id: totrans-328
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Resilient（弹性）
- en: The network should be resilient enough to withstand temporary node failures,
    unavailability of some computing nodes at times, network latency and packet drops,
    etc.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 网络应当足够弹性，以承受临时的节点故障、某些计算节点的暂时不可用、网络延迟和数据包丢失等情况。
- en: Auditable
  id: totrans-330
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 可审计
- en: A blockchain is a chain of blocks that are linked together through hashes. Since
    the transaction blocks are linked back till the genesis block, auditability already
    exists and we have to ensure that it does not break at any cost. Also, if one
    wants to verify whether a transaction took place in the past, then such verification
    should be quicker.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链是由通过哈希链接在一起的块组成的链。由于交易块一直追溯到创世块，可审计性已经存在，我们无论如何都要确保它不会断裂。此外，如果有人想验证过去是否发生了交易，那么这样的验证应该更快。
- en: Blockchain Transactions
  id: totrans-332
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 区块链交易
- en: 'When we say blockchain, we mean a blockchain of transactions, right? So it
    starts from a transaction and then the transaction goes through a series of steps
    and ultimately resides in the blockchain. Since blockchain is a peer-to-peer phenomenon,
    if you are dealing with a use case that has a lot of transactions taking place
    every second, you may not want to flood the whole network with all transactions.
    Obviously when an individual or an entity is making a transaction, they just have
    to broadcast it to the whole network. Once that happens, it has to be validated
    by multiple nodes. Upon validation, it has to again get broadcast to the whole
    network for the transaction to get included in the blockchain. Now, why not a
    transaction chain instead of a blockchain? It may make sense to some extent if
    your business case does not involve a lot of transactions. However, if there are
    a huge number of transactions every second, then hashing them at transaction level,
    keeping a trail of it, and broadcasting that to the network can make the system
    unstable. You may want a certain number of transactions to be grouped in a block
    and broadcast that block. Broadcasting individual transactions can become a costly
    affair. Another good reason for a blockchain instead of a transaction chain is
    to prevent Sybil Attack. In Chapter [3](A440588_1_En_3_Chapter.xhtml), you will
    learn in more detail how the PoW mining algorithm is used and one node is chosen
    at random that could propose a block. If it was not the case, people might create
    replicas of their own node to subvert the system.In its most simplified form,
    the blockchain transactions go through the following steps to get into the blockchain:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们提到区块链时，我们是指交易区块链，对吧？所以它始于一个交易，然后这个交易通过一系列步骤，最终存储在区块链上。由于区块链是一种点对点现象，如果你处理的用例每秒钟发生大量交易，你可能不希望用所有交易淹没整个网络。显然，当个人或实体进行交易时，他们只需将交易广播到整个网络。一旦发生这种情况，它必须由多个节点验证。验证后，它再次广播到整个网络，以便将交易包含在区块链中。那么，为什么不是交易链而是区块链呢？如果你的业务案例不涉及大量交易，从某种程度上说，使用交易链可能是有意义的。然而，如果每秒钟有大量交易，那么在交易级别对它们进行哈希处理，保留它们的踪迹，并将它们广播到网络，可能会使系统不稳定。你可能希望将一定数量的交易分组在一个块中，并广播这个块。单独广播交易可能会变得代价高昂。阻止赛百味攻击的另一个好理由是使用区块链而不是交易链。在第[3](A440588_1_En_3_Chapter.xhtml)章中，你将详细了解如何使用PoW挖掘算法，并随机选择一个节点提出一个块。如果不是这样，人们可能会创建他们自己的节点的复制品，以颠覆系统。在最简化的形式中，区块链交易通过以下步骤进入区块链：
- en: Every new transaction gets broadcast to the network so that all the computing
    nodes are aware of that fact at the time it took place (to ensure the system is
    double-spend resistant) .
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个新交易都广播到网络，以便所有计算节点在交易发生时知道这一事实（确保系统抵抗双重支付）。
- en: Transactions may get validated by the nodes to accept or reject by checking
    the authenticity.
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交易可能由节点验证以接受或拒绝，通过检查其真实性。
- en: The nodes may then group multiple transactions into blocks to share with the
    other nodes in the network.
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点可以将多个交易分组成块，并与网络中的其他节点分享。
- en: Here comes the difficult situation. Who would propose the block of transactions
    that they have grouped individually? Broadly speaking, the generation of new blocks
    should be controlled but not in a centralized fashion, and the mechanism should
    be such that every node is given equal priority. Every node agreeing upon a block
    is called the consensus, but there are different algorithms to achieve the same
    objective, depending on your use case. We will discuss different consensus mechanisms
    in the following section.
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在出现了困难的情况。谁会提出他们单独分组的交易块呢？总的来说，新块的生成应该受到控制，但不应以集中式方式进行，并且应该让每个节点具有平等的优先级。每个节点同意的块称为共识，但根据你的用例，有不同的算法来实现同一目标。我们将在下一节讨论不同的共识机制。
- en: Though there is no notion of a global time due to network latency, packet drops,
    and geographic locations, such a system still works because the blocks are added
    one after another in an order. So, we can consider that the blocks are time stamped
    in the order they arrive and get added in the blockchain.
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然由于网络延迟、数据包丢失和地理位置等因素，没有全球统一的时间概念，但这样的系统仍然有效，因为区块是按顺序一个接一个地添加的。所以，我们可以认为区块是按照它们到达的顺序进行时间戳标记，并添加到区块链中的。
- en: Once the nodes in the network unanimously accept a block, then that block gets
    into the blockchain and it includes the hash of the block that was created right
    before it. So this extends the blockchain by one block.
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦网络中的节点一致接受了一个区块，那么这个区块就会被添加到区块链中，并且它包括紧接在其之前的区块的哈希值。所以这样就通过一个区块 extend 了区块链。
- en: We already discussed the blockchain data structure and the Merkle trees, so
    we understand their value now. Recollect that when a node would like to validate
    a transaction, it can do so more efficiently by the Merkle path. The other nodes
    in the network do not have to share the full block of data to justify proof of
    membership of a transaction in a block. Technically speaking, memory efficient
    and computer-friendly data structures such as “Bloom filters” are widely used
    in such scenarios to test the membership.Also, note that for a node to be able
    to validate a transaction, it should ideally have the whole blockchain data (transactions
    along with their metadata) locally. You should select an efficient storage mechanism
    that the nodes will adopt based on your use case.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了区块链数据结构和默克尔树，所以现在理解了它们的价值。回忆一下，当一个节点想要验证一笔交易时，它可以通过默克尔路径更有效地完成。网络中的其他节点不需要共享完整的数据块来证明一个事务属于某个区块的成员资格。从技术上讲，像“布隆过滤器”这样的内存高效且对计算机友好的数据结构，在这种场景下广泛用来测试成员资格。另外，请注意，为了使一个节点能够验证一笔交易，它理想情况下应该拥有整个区块链数据（包括事务及其元数据）的本地副本。你应该根据你的用例选择一个高效的存储机制，节点将基于这个机制进行存储。
- en: Distributed Consensus Mechanisms
  id: totrans-341
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分布式共识机制
- en: 'When the nodes are aware of the entire history of transactions by having a
    local copy of the full blockchain data to prevent double-spend, and they can verify
    the authenticity of a transaction through digital signatures, what is the use
    of consensus? Imagine the presence of one or more malicious nodes. Can’t they
    say an invalid transaction is a valid one, or vice versa? Recollect the Byzantine
    Generals’ Problem, which is most likely to occur in many decentralized systems.
    To overcome such issues, we need a proper consensus mechanism in place.So far
    in our discussion, the one thing that is not clear yet is who proposes the block.
    Obviously, not every node should propose a block to the rest of the nodes at the
    same time because it is only going to create a mess; forget about the consistent
    state of the ledger. On the other hand, had it been the case with just transactions
    without grouping them into blocks, you could argue that if every transaction gets
    broadcast to the whole network and every node in the network casts a vote on those
    individual transactions, it would only complicate the system and lead to poor
    performance.So, grouping transactions into blocks is important for obvious reasons
    and consensus is required on a block by block basis. The best strategy for this
    problem is that only one block should propose a block at a time and the rest of
    the nodes should validate the transactions in the block and add to their blockchains
    if transactions are valid. We know that every node maintains its own copy of the
    ledger and there is no centralized source to sync from. So, if any one node proposes
    a block and the rest of the nodes agree on it, then all those nodes add that block
    to their respective blockchains. In such a design, you would prefer that there
    are at least a few minutes of gap in block creation and it should not be the case
    where multiple blocks arrive at the same time. Now the question is: who might
    be that lucky node to propose a block? This is the trickiest part and can lead
    to proper consensus; we will discuss this aspect under different consensus mechanisms.These
    consensus mechanisms actually come from game theory. Your system should be designed
    such that the nodes get the most benefit if they play by the rules. One of the
    aspects to ensure the nodes behave honestly is to reward for honest behavior and
    punish for fraudulent activities. However, there is a catch here. In a public
    blockchain such as Bitcoin, one can have many different public identities and
    they are quite anonymous. It gets really difficult to punish such identities because
    they have a choice to avoid that punishment by creating new identities for themselves.
    On the other hand, rewarding them works great, because even if someone has multiple
    identities, they can happily reap the rewards given to them. So, it depends on
    your business case: if the identities are anonymous, then punishing them may not
    work, but may work well if the identities are not anonymous. You may want to consider
    this reward/punish aspect despite having a great mechanism to select a node that
    would propose the next block. This is because you would never know in advance
    if the node selected is a malicious node or an honest one. Keep in mind the term
    mining that we may be using quite often, and it would mean generating new blocks.The
    goal of consensus is also to ensure that the network is robust enough to sustain
    various types of attacks. Irrespective of the types of consensus algorithms one
    may choose depending on the use case, it has to fall into the Byzantine fault
    tolerant consensus mold to be able to get accepted. Let us now learn some of the
    consensus mechanisms pertaining to the blockchain scenarios that we may be able
    to use in different situations.'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 当节点通过拥有完整区块链数据的本地副本来了解所有交易的历史，以防止双重花费，并且它们可以通过数字签名来验证交易的 authenticity，那么共识机制有什么用？想象一下存在一个或多个恶意节点的情况。他们不能说一个无效的交易是有效的，或者相反吗？回顾一下拜占庭将军问题，这在许多去中心化系统中是最有可能发生的。为了克服这些问题，我们需要有一个适当的共识机制。到目前为止，在我们讨论中还没有明确的是谁提出区块。显然，不应该让每个节点同时向其他节点提出区块，因为这只会造成混乱；更不用说账本的一致状态了。另一方面，如果只是交易而不将它们分组到区块中，你可能会认为，如果将每个交易广播到整个网络，并且网络中的每个节点对那些单独的交易进行投票，这将只会使系统复杂化并导致性能下降。所以，将交易分组到区块中是有明显原因的，并且需要在区块层面上进行共识。解决这个问题最好的策略是，一次只能有一个区块提出区块，其余节点应验证区块中的交易，如果交易有效，则将其添加到他们的区块链中。我们知道，每个节点都维护其自己的账本副本，并且没有集中的源可以从中同步。所以，如果任何一个节点提出了一个区块并且其他节点同意，那么所有这些节点都会将该区块添加到它们的
    respective 区块链中。在这种设计中，您会希望块创建之间至少有几分钟的间隔，而不应该出现多个块同时到达的情况。现在的问题是：可能是那个幸运的节点来提出一个区块？这是最棘手的部分，也可能导致正确的共识；我们将在不同的共识机制下讨论这个问题。这些共识机制实际上来自博弈论。您的系统应该设计成这样，如果节点遵守规则，它们会获得最大的好处。确保节点诚实行为的一个方面是通过奖励诚实行为和惩罚欺诈活动。然而，这里有一个问题。在像比特币这样的公共区块链中，可以有多种不同的公共身份，它们相当匿名。惩罚这些身份真的很难，因为它们可以选择通过创建新的身份来避免惩罚。另一方面，奖励它们效果很好，因为即使有人有多个身份，他们也可以高兴地获得给予他们的奖励。所以，这取决于你的业务案例：如果身份是匿名的，那么惩罚可能行不通，但如果身份不是匿名的，可能会很好地工作。您可能需要考虑这个奖励/惩罚方面，即使您有一个很好的机制来选择下一个区块的节点。这是因为您永远不知道预先选定的节点是恶意节点还是诚实节点。请记住我们可能经常使用的术语挖掘，它意味着生成新块。共识的目标也是确保网络足够健壮，能够承受各种类型的攻击。无论一个人可能选择的共识算法类型如何，它必须落入拜占庭容错共识模式才能被接受。现在让我们学习一些适用于区块链场景的共识机制，我们可能在不同情况下可以使用。
- en: Proof of Work
  id: totrans-343
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 工作量证明
- en: 'The PoW consensus mechanism has been around for a long time now. However, the
    way it was used in Bitcoin along with other concepts made it even more popular.
    We will discuss this consensus mechanism at its basic level and look at how it
    is implemented in Bitcoin in Chapter [3](A440588_1_En_3_Chapter.xhtml).The idea
    behind the PoW algorithm is that certain work is done for a block of transactions
    before it gets proposed to the whole network. A PoW is actually a piece of data
    that is difficult to produce in terms of computation and time, but easy to verify.
    One of the old usages of PoW  was to prevent email spams. If a certain amount
    of work is to be done before one can send an email, then spamming a lot of people
    would require a lot of computation to be performed. This can help prevent email
    spams. Similarly, in blockchain as well, if some amount of compute-intensive work
    is to be performed before producing a block, then it can help in two ways: one
    is that it will definitely take some time and the second is, if a node is trying
    to inject a fraudulent transaction in a block, then rejection of that block by
    the rest of the nodes will be very costly for the one proposing the block. This
    is because the computation performed to get the PoW will have no value.Just think
    about proposing a block without much of effort vs. doing some hard work to be
    able to propose a block. If it was with almost no effort, then proposing a node
    with a fraudulent transaction and getting rejected would not have been a big concern.
    People may just keep proposing such blocks with a hope that one may get through
    and make it to the blockchain sometime. On the contrary, doing some hard work
    to propose a block prevents a node from injecting a fraudulent transaction in
    a subtle way.Also, the difficulty of the work should be adjustable so that there
    is a control over how fast the blocks can get generated. You must be thinking,
    if we are talking about some work that requires some computation and time, what
    kind of work must it be? It is very simple yet tricky work. An example would help
    here. Imagine a problem where you have to find a number which, if you hash, the
    hashed output  would start with the alphabet “a.” How would you do it? We have
    learned about the hash functions and know that there are no shortcuts to it. So
    you would just keep guessing (maybe take any number and keep incrementing by one)
    the numbers and keep hashing them to see if that fits the bill. If the difficulty
    level needs to be increased, then one can say it starts with three consecutive
    “a”s. Obviously, finding a solution for something like “axxxxxxx” is easier to
    find compared with “aaaxxxxx” because the latter is more constrained.In the example
    just given, if multiple different nodes are working to solve such a computational
    puzzle  , then you will never know which node would solve it first. This can be
    leveraged to select a random node (this time it is truly random because there
    is no algorithm behind it) that solves the puzzle and proposes the block. It is
    extremely important to note that in case of public blockchains, the nodes that
    are investing their computing resources have to be rewarded for honest behavior  ,
    else it would be difficult to sustain such a system.'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 工作量证明（PoW）共识机制已经存在很长时间了。然而，它在比特币中的使用以及与其他概念的结合使其变得更加流行。我们将在第[3](A440588_1_En_3_Chapter.xhtml)章讨论这个共识机制的基础知识，并查看它是如何在比特币中实现的。PoW算法的背后思想是，在将区块提交给整个网络之前，对交易区块进行一定的工作。PoW实际上是一段难以通过计算和时间产生的数据，但易于验证。PoW的旧用途之一是防止电子邮件垃圾邮件。如果发送一封电子邮件之前需要完成一定的工作，那么发送大量电子邮件垃圾将会需要大量的计算。这有助于防止电子邮件垃圾邮件。同样，在区块链中，如果要在产生一个区块之前执行一些计算密集型的工作，那么它可以帮助两种方式：一是它肯定会花费一些时间，二是，如果一个节点试图在区块中注入一个欺诈交易，那么该区块被其他节点拒绝将会对提出区块的节点造成很大的损失。这是因为为了获得PoW而进行的计算将没有价值。想想轻松提出一个区块与为了能够提出区块而做一些艰苦的工作的区别。如果几乎不费力，那么提出一个带有欺诈交易的区块并且被拒绝就不会是一个大问题。人们可能只是继续提出这样的区块，希望其中一个可能成功并最终进入区块链。相反，为了提出一个区块而做一些艰苦的工作可以防止节点以一种微妙的方式注入欺诈交易。此外，工作的难度应该是可调整的，以便控制区块生成的速度。你们可能想，如果我们谈论的是需要一些计算和时间的工作，那它必须是什么样的工作呢？这是非常简单但又棘手的工作。这里有一个例子。想象一个问题，你需要找到一个数字，当你对它进行哈希时，哈希输出会以字母“a”开头。你会怎么做？我们已经学习了哈希函数，并知道没有捷径可走。所以你会一直猜测（也许随便取一个数字，然后不断加一）数字，并不断对它们进行哈希，以看看是否符合要求。如果需要增加难度级别，那么可以说它以三个连续的“a”开头。显然，“axxxxxxx”这样的解决方案比“aaaxxxxx”更容易找到，因为后者更有约束性。在刚才给出的例子中，如果有多个不同的节点在解决这样的计算难题，那么你永远不知道哪个节点会先解决它。这可以利用来选择一个随机节点（这次它真的是随机的，因为没有算法）解决难题并提出区块。非常重要的一点是，在公共区块链中，投入计算资源的节点必须因诚实行为而得到奖励，否则很难维持这样的系统。
- en: Proof of Stake
  id: totrans-345
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 权益证明 (Proof of Stake, PoS)
- en: The Proof of Stake (PoS) algorithm is another consensus algorithm that is quite
    popular for distributed consensus. However, what is tricky about it is that it
    isn’t about mining, but is about validating blocks of transactions. There are
    no mining rewards due to generation of new coins, there are only transaction fees
    for the miners (more accurately validators, but we will keep using ‘miners’ so
    it gets easier to explain).In PoS systems, the validators have to bond their stake
    (mortgage the amount of cryptocurrency thay would like to keep at stake) to be
    able to participate in validating the transactions. The probability of a validator
    producing a block is proportional to their stake; the more the amount at stake,
    the greater is their chance to validate a new block of transactions. A miner only
    needs to prove they own a certain percentage of all coins available at a certain
    time in a given currency system. For example, if a miner owns 2% of all Ether
    (ETH) in the Ethereum network, they would be able to mine 2% of all transactions
    across Ethereum. Accordingly, who gets to create the new block of transaction
    is decided, and it varies based on the PoS algorithm you are using. Yes, there
    are variants of PoS algorithm such as naive PoS, delegated PoS, chain-based PoS,
    BFT-style PoS, and Casper PoS, to name a few. Delegated PoS (DPOS) is used by
    Bitshares and Casper PoS is being developed to be used in Ethereum.Since the creator
    of a block in a PoS system is deterministic (based on the amount at stake), it
    works much faster compared with PoW systems. Also, since there are no block rewards
    and just transaction fees, all the digital currencies need to be created in the
    beginning and their total amount is fixed all through.The PoS  systems may provide
    better protection against malicious attacks because executing an attack would
    risk the entire amount at stake. Also, since it does not require burning a lot
    of electricity and consuming CPU cycles, it gets priority over PoW systems where
    applicable.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 权益证明（PoS）算法是另一种流行的分布式共识算法。然而，它的复杂之处在于，它并非关于挖矿，而是关于验证交易区块。由于新币的生成，没有挖矿奖励，只有矿工（更准确地说是验证者，但我们将继续使用“矿工”这个词，以便更容易解释）的交易费用。在PoS系统中，验证者必须抵押他们的权益（抵押他们希望保持在权益中的加密货币金额）才能参与验证交易。验证者产生区块的概率与他们权益的比例成正比；质押的金额越多，他们验证新区块交易的机会就越大。矿工只需证明他们拥有特定时间内给定货币系统中所有货币的一定比例。例如，如果一个矿工拥有以太坊网络中所有以太币（ETH）的2%，他们就能挖掘以太坊2%的所有交易。相应地，根据您使用的PoS算法，决定谁来创建新的交易区块。是的，PoS算法有多种变体，如简单的PoS、委托PoS、基于链的PoS、BFT风格的PoS和Casper
    PoS等。委托PoS（DPOS）被Bitshares使用，而Casper PoS正在开发中，计划用于以太坊。由于在PoS系统中块的创建者是确定性的（基于权益金额），它比PoW系统快得多。此外，由于没有区块奖励，只有交易费用，所有数字货币都需要在开始时创建，并且总金额是固定的。PoS系统可能提供更强的恶意攻击防护，因为执行攻击会冒着整个质押金额的风险。另外，由于它不需要燃烧大量电力和消耗CPU周期，因此在适用的情况下优先于PoW系统。
- en: PBFT
  id: totrans-347
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 实用拜占庭容错算法 (Practical Byzantine Fault Tolerance, PBFT)
- en: PBFT is the acronym for the Practical Byzantine Fault Tollerance algorithm,
    one of the many consensus algorithms that one can consider for their blockchain
    use case. Out of so many blockchain initiatives, Hyperledger, Stellar, and Ripple
    are the ones that use PBFT consensus.PBFT is also an algorithm that is not used
    to generate mining rewards, similar to PoS algorithms. However, the technicalities
    in their respective implementations are different. The inner working of PBFT is
    beyond the scope of this book, but at a high level, requests are broadcast to
    all participating nodes that have their own replicas or internal states. When
    nodes receive a request, they perform the computation based on their internal
    states. The outcome of the computation is then shared with all other nodes in
    the system. So, every node is aware of what other nodes are computing. Considering
    their own computation results along with the ones received from ther nodes, they
    make a decision  and commit to a final value, which is again shared across the
    nodes. At this moment, every node is aware of the final decision of all other
    nodes. Then they all respond with their final decisions and, based on the majority,
    the final consensus is achieved. This is demonstrated in Figure [2-24](A440588_1_En_2_Chapter_split_001.xhtml#Fig24).![A440588_1_En_2_Fig24_HTML.jpg](Images/A440588_1_En_2_Fig24_HTML.jpg)Figure
    2-24PBFT consensus approachPBFT  can be efficient compared with other consensus
    algorithms, based on the effort required. However, anonymity in the system may
    be compromised because of the way this algorithm is designed. It is one of the
    most widely used algorithms for consensus even in non-blockchain environments  .
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: PBFT是实用拜占庭容错算法（Practical Byzantine Fault Tolerance）的缩写，这是一种可以考虑用于区块链用例的众多共识算法之一。在众多的区块链项目中，Hyperledger、Stellar和Ripple采用PBFT共识。PBFT也是一种不用于生成挖矿奖励的算法，与PoS算法类似。然而，它们各自实现的技术细节是不同的。PBFT的内部工作原理超出了本书的范围，但在高层次上，请求会被广播到所有拥有自己副本或内部状态的参与节点。当节点接收到请求时，它们会基于自己的内部状态执行计算。计算的结果随后与系统中的所有其他节点分享。所以，每个节点都知道其他节点正在计算什么。考虑到自己的计算结果以及从其他节点接收到的结果，它们做出决定并承诺最终值，这再次在节点之间共享。此刻，每个节点都知道其他所有节点的最终决定。然后，它们全部回应自己的最终决定，基于大多数节点，最终达成共识。这在图[2-24](A440588_1_En_2_Chapter_split_001.xhtml#Fig24)中有所展示。![A440588_1_En_2_Fig24_HTML.jpg](Images/A440588_1_En_2_Fig24_HTML.jpg)图2-24
    PBFT共识方法 PBFT与其他共识算法相比，根据所需的努力程度，可能是有效率的。然而，由于这种算法的设计方式，系统中的匿名性可能会受到妥协。即使在不属于区块链环境的系统中，这也是最广泛使用的共识算法之一。
- en: Blockchain Applications
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 区块链应用
- en: While we looked at the nuts and bolts of blockchain throughout this chapter,
    it is also important that we look at how it is being used in building blockchain
    solutions. There are applications being built that treat blockchain as a backend
    database behind a web server, and there are applications that are completely decentralized
    with no centralized server. Bitcoin blockchain, for example, is a blockchain application
    where there is no server to send a request to! Every transaction is broadcast
    to the entire network. However, it is possible that a web application is built
    and hosted in a centralized web server, and that makes Bitcoin blockchain updates
    when required. Take a look at Figure [2-25](A440588_1_En_2_Chapter_split_001.xhtml#Fig25)
    where a Bitcoin node broadcasts the transactions to the nodes that are reachable
    at a given point in time.![A440588_1_En_2_Fig25_HTML.jpg](Images/A440588_1_En_2_Fig25_HTML.jpg)Figure
    2-25Bitcoin blockchain nodesFrom a software application perspective, every node
    is self-sufficient and maintains its own copies of the blockchain database. Considering
    Bitcoin blockchain as a benchmark, the blockchain applications with no centralized
    servers appear to be the purest decentralized applications and most of them fall
    under the “public blockchain” category. Usually for such public blockchains, usage
    of resources from cloud service providers such as Microsoft Azure, IBM Bluemix,
    etc. are not quite popular yet. For most of the private blockchains, however,
    the cloud service providers have started to gain popularity. To give you an analogy,
    there could be one or more web applications for different departments or actors,
    all of them having their own Blockchin backends and still the blockchains are
    in sync with each other. In such a setting, though technical decentralization
    is achieved, politically it could still be centralized. Even though control or
    governance is enforced, the system is still able to maintain transparency and
    trust because of the accessibility to single source of truth. Take a look at Figure
    [2-26](A440588_1_En_2_Chapter_split_001.xhtml#Fig26)  , which may resemble most
    of the blockchain POCs or applications being built on blockchain where blockchains
    are hosted by some cloud service provider by consuming their blockchain-as-a-Service
    (BaaS) offering.![A440588_1_En_2_Fig26_HTML.jpg](Images/A440588_1_En_2_Fig26_HTML.jpg)Figure
    2-26Cloud-powered blockchain systemIt may not be necessary that all the departments
    have their own different web application. One web application can handle requests
    from multiple different actors in the system with proper access controm mechanisms.
    It might be a good idea that all the actors in the system have their own copies
    of blockchains. Having a local copy of blockchain not only helps maintain transparency
    in the system, but also may help generate data-driven insights with ready access
    to data all the time. The different “blockchains” maintained by different actors
    in the system are consistent by design, thanks to consensus algorithms such as
    PoW, PoS, etc. Most of the private blockchains prefer any consensus algorithm
    other than PoW to mitigate heavy resource consumption, and save electricity and
    computing power as much possible. The PoS consensus mechanism is quite common
    when it comes to private or consortium blockchains. Since blockchain is disrupting
    many aspects of businesses, and there was no better way of enabling transparency
    among them, creating a blockchain solution in the cloud with a “pay as you use”
    model is gaining momentum. Cloud services are helping businesses leapfrog in their
    blockchain-enabled digital transformation journey with minimal upfront investments.There
    are also decentralized applications (DApps) being built on Ethereum blockchain
    networks  . These applications could be permissioned on private Ethereum or could
    be permissionless on a public Ethereum network. Also, these applications could
    be for different use cases on the same public Ethereum network. Though we will
    cover the Ethereum-specific  details later in this book, just look at Figure [2-27](A440588_1_En_2_Chapter_split_001.xhtml#Fig27)
    for a high-level understanding of how those applications might look.![A440588_1_En_2_Fig27_HTML.jpg](Images/A440588_1_En_2_Fig27_HTML.jpg)Figure
    2-27DApps on Ethereum networkAs discussed already in previous sections, developing
    blockchain applications is only limited by your imagination. Pure blockchain native
    applications could be built. Applications that treat blockchain as just a backend
    are also being built, and there are hybrid applications that are also being built
    that use the legacy applications and use blockchain for some specific purpose
    only. So far, blockchain scalability is one of the biggest concerns. Though the
    scalability itself is in research, let us learn some of the scalability techniques.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，虽然我们一直在关注区块链的细节，但同样重要的是，我们需要了解区块链解决方案是如何构建的。有些应用程序将区块链视为Web服务器后面的后端数据库，而有些则是完全去中心化的，没有中心服务器。例如，比特币区块链就是一个没有服务器可以发送请求的区块链应用程序！每一个交易都被广播到整个网络。然而，在必要的时候，一个基于中心化Web服务器的Web应用程序也可以被构建出来，并更新比特币区块链。请参阅图[2-25](A440588_1_En_2_Chapter_split_001.xhtml#Fig25)，其中一个比特币节点在给定时间点向可达节点广播交易。![A440588_1_En_2_Fig25_HTML.jpg](Images/A440588_1_En_2_Fig25_HTML.jpg)图2-25比特币区块链节点从软件应用程序的角度来看，每一个节点都是自给自足的，并维护着自己的区块链数据库副本。考虑到比特币区块链作为一个基准，没有中心服务器的区块链应用程序似乎是最纯粹的去中心化应用程序，其中大部分属于“公共区块链”类别。通常，对于这样的公共区块链，使用来自云服务提供商（如微软Azure、IBM
    Bluemix等）的资源并不太受欢迎。然而，对于大多数私有区块链，云服务提供商已经开始变得受欢迎。打个比喻，可能有多个面向不同部门或参与者的Web应用程序，它们都有自己的区块链后端，而区块链仍然彼此同步。在这种设置中，尽管技术上实现了去中心化，但政治上仍然可能是中心化的。尽管实施了控制或治理，但由于可以访问单一的真实数据源，系统仍然能够保持透明度和信任。请参阅图[2-26](A440588_1_En_2_Chapter_split_001.xhtml#Fig26)，这可能类似于大多数在云服务提供商上运行的区块链POC或应用程序，这些区块链通过使用他们的区块链即服务（BaaS）产品来托管。![A440588_1_En_2_Fig26_HTML.jpg](Images/A440588_1_En_2_Fig26_HTML.jpg)图2-26基于云的区块链系统并不是所有的部门都需要有自己的不同Web应用程序。一个Web应用程序可以处理系统中多个不同参与者的请求，并通过适当的访问控制机制处理。让所有系统中的参与者都有自己的区块链副本可能是个好主意。拥有区块链的本地副本不仅有助于维护系统的透明度，而且可能有助于随时访问数据，从而生成数据驱动的洞察。系统中的不同参与者维护的“区块链”由于设计上的共识算法（如PoW、PoS等）而保持一致。大多数私有区块链都选择除PoW之外的共识算法，以减轻资源消耗，节省电力和计算能力。在私有或联盟区块链中，PoS共识机制相当常见。由于区块链在业务方面的颠覆性影响，并且没有更好的方法来在他们之间实现透明度，因此基于“按使用付费”模式的云计算区块链解决方案正在逐渐流行。云服务帮助企业在区块链启用的数字化转型之旅中实现飞跃，而无需大量的前期投资。还有基于以太坊区块链网络的去中心化应用程序（DApps）。这些应用程序可能是私有的以太坊，也可能是公共以太坊网络上的无权限应用程序。此外，这些应用程序可能是同一公共以太坊网络上的不同用例。虽然我们将在本书的后面详细介绍以太坊特定的细节，但请查看图[2-27](A440588_1_En_2_Chapter_split_001.xhtml#Fig27)以了解这些应用程序可能的外观。![A440588_1_En_2_Fig27_HTML.jpg](Images/A440588_1_En_2_Fig27_HTML.jpg)图2-27以太坊网络上的DApps如前所述，开发区块链应用程序仅受您想象力的限制。可以构建纯粹的基于区块链的原生应用程序。将区块链视为只是后端的应用程序也在被构建，还有正在被构建的混合应用程序，它们使用遗留应用程序，并仅将区块链用于特定目的。到目前为止，区块链的可扩展性是最重要的问题之一。尽管可扩展性本身还在研究中，让我们学习一些可扩展性技术。
- en: Scaling Blockchain
  id: totrans-351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 区块链扩容
- en: We looked at blockchain from a historic perspective and how it proves to be
    one of the most disruptive technologies as of today. While exploring it technically
    in this chapter, we learned about the scalability issues inherent to most of the
    Blockchin flavors. By design, blockchains are difficult to scale and thus a research
    area in academia and for some innovation-driven corporates. If you look at the
    Bitcoin adoption, it is not being used to replace fiat currencies due to the inherent
    scalability challenges. You cannot buy a coffee using Bitcoin and wait for an
    hour for the transaction to settle. So, Bitcoins are being used as an asset class
    for investers to invest in. A Bitcoin blockchain network is not capable of accommodating
    as many transactions as that of Visa or MasterCard, as of today.Recollect the
    consensus protocols we have studied so far, such as PoW of Bitcoins or Ethereum,
    or PoS and other BFT consensus of some other blockchain flavors such as Multichain,
    Hyperledger, Ripple, or Tendermint. All of these consensus algorithms’ primary
    objective is Byzantine fault tolerance. By design, every node (at least the full
    nodes) in a blockchain network maintains its own copy of the entire blockchain,
    validates all transactions and blocks, serves requests from other nodes in the
    network, etc. to achieve decentralization, which becomes a bottleneck for scalability.
    Look at the irony here—we add more servers in a centralized system for scalability,
    but the same does not apply in a decentralized system because with more number
    of nodes, the latency only increases. While the level of decentralization could
    increase with a greater number of nodes in a decentralized network, the number
    of transactions in the network also increases, which leads to increased requirements
    of computing and storage resources. Keep in mind that this situation is applicable
    more on public blockchains and less so for private blockchains. Private blockchains
    could easily scale compared with the public ones because the controlling entities
    could define and set node specifications with high computation power and more
    bandwidth. Also, there could be certain tasks offloaded from blockchain and computed
    off-chain that could help the system scale well.In this chapter, we will learn
    some of the generic scaling techniques, and discuss Bitcoin- and Ethereum-specific
    scaling techniques in their respective chapters. Please keep in mind that all
    scaling techniques may not apply to all kinds of blockchain flavors or use cases.
    The best way is to understand the techniques technically and use the best possible
    one in a given situation.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从历史的角度审视了区块链，并发现它是最具颠覆性的技术之一。在本章中，我们从技术角度探讨了区块链的扩容问题，这是大多数区块链平台的固有难题。区块链的设计本质上难以扩容，因此成为学术界和一些以创新为导向的企业的研究课题。如果你看看比特币的普及情况，它的普及并不是用来替代法定货币，而是由于其扩容问题。你不能用比特币买咖啡，然后等一个小时让交易结算。因此，比特币被用作投资者的一种资产类别。比特币区块链网络目前无法容纳像维萨或万事达卡那样多的交易。回顾我们之前学过的共识协议，比如比特币或以太坊的工作量证明（PoW），或者其他一些区块链平台如Multichain、Hyperledger、Ripple或Tendermint的工作量证明（PoS）和其他拜占庭容错（BFT）共识。所有这些共识算法的首要目标是拜占庭容错。区块链网络中的每个节点（至少是完整节点）都维护着区块链的完整副本，验证所有交易和区块，响应网络中其他节点的请求等，以实现去中心化，这成为了扩容的瓶颈。在这里看到讽刺的地方——我们在集中式系统中增加更多服务器来实现扩容，但在去中心化系统中，同样的方法不适用，因为节点越多，延迟只会增加。虽然去中心化程度可以通过增加去中心化网络中的节点数量来提高，但网络中的交易数量也会增加，这导致了计算和存储资源需求的增加。请记住，这种情况更适用于公共区块链，而不适用于私有区块链。与公共区块链相比，私有区块链可以更容易地扩容，因为控制实体可以定义并设置具有高计算能力和更多带宽的节点规格。此外，将某些任务从区块链卸载并在链外计算可能有助于系统扩容。在本章中，我们将学习一些通用的扩容技术，并在各自的章节中讨论比特币和以太坊特定的扩容技术。请记住，并非所有扩容技术都适用于所有类型的区块链平台或用例。最佳方法是技术上理解这些技术，并在给定情况下使用最合适的一个。
- en: Off-Chain Computation
  id: totrans-353
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 离链计算
- en: Off-chain computation is one of the most promising techniques to scale blockchain
    solutions. The idea is to limit the usage of blockchain and do the heavy lifting
    outside of it, and only store the outcomes on blockchain. Keep in mind that there
    is no standard definition of how the off-chain computation should happen. It is
    heavily dependent on the situation and the people trying to address it. Also,
    different blockchain flavors may require different approaches for off-chain computation.
    At a high level, it is like another layer on top of blockchain that does heavy,
    compute-intensive work and wisely uses the blockchain. Obviously, you may not
    be able to retain all the characteristics of blockchain by doing computations
    off-chain, but it is also true that you may not need blockchain for all kinds
    of computing requirements and may use it only for specific pain points.The off-chain
    computations could be on a sidechain, could be distributed among a random group
    of nodes, or could be centralized as well. The side chains are independent of
    the main blockchain. It not only helps scale the blockchain well, it also isolates
    damages to the sidechain and prevents the main blockchain from any damages from
    a sidechain. One such example sidechain is the “Lightning Network” for Bitcoins
    that should help in faster execution of transactions with minimal fee; that will
    support micropayments as well. Another example of a sidechain for Bitcoins is
    “Zerocash,” whose primary objective is not really scalability, but privacy. If
    you are using Zerocash for Bitcoin transactions, you cannot be tracked and your
    privacy is preserved. We will limit our discussion to the generic scalability
    techniques and not get into a detailed discussion of Bitcoin scalability in this
    book.One obvious question that might come up at the moment is how people would
    check the authenticity of the transactions if they are sent off-chain. First,
    to create a valid transaction, you do not need a blockchain. We learned in the
    “Cryptography” section in this chapter about the assymetric key cryptography that
    is used by the blockchain system. To make a transaction, you have to be the owner
    of a private key so you can sign the transaction. Once the transaction is created,
    there are advantages when it gets into the blockchain. Double-spend is not possible
    with Bitcoin blockchain, and there are other advantages, too. For now, the only
    objective is to get you on board with the fact that you can create a transaction
    as long as you own the private key for your account.Bitcoin blockchains are a
    stateless blockchain, in the sense that they do not maintain the state of an account.
    Everything in Bitcoin blockchain is present in the form of a transaction. To be
    able to make a transaction, you have to consume a previous transaction and there
    is no notion of “closing balance” for an account, as such. On the contrary, Ethereum
    blockchain is a “stateful” one! The blocks in Ethereum blockchain contain information
    regaring the state of the entire block where account balance is also a part. The
    state information takes up significant space when every node in the network maintains
    it. This situation is valid for other blockchains as well that are stateful.Let’s
    take an example to understand this better. Alice and Bob are two parties having
    multiple transactions between each other. Let’s say they usually have 50 monetary
    transactions in a month. In a stateful blockchain, all these individual transactions
    would have their state information, and that will be maintained by all the nodes.
    To address this challenge, the concept of “state channels” is introduced. The
    idea is to update the blockchain with the final outcome, say, at the end of the
    month or when a certain transaction threshold is reached, and not with each and
    every transaction.State channels are essentially a two-way communication channel
    between users, objects, or services. This is done with absolute security by using
    cryptographic techniques. Just to get a heads-up on how it works, take a look
    at Figure [2-28](A440588_1_En_2_Chapter_split_001.xhtml#Fig28).![A440588_1_En_2_Fig28_HTML.jpg](Images/A440588_1_En_2_Fig28_HTML.jpg)Figure
    2-28State channels for off-chain computationNotice that the off-chain state channels
    are mostly private and confined among a group of participants. Keep in mind that
    the state of blockchain for the participants needs to be locked as the first step.
    Either it could be a MultiSig scheme or a smart contract-based locking. After
    locking, the participants make transactions among each other that are cryptographically
    secured. All transactions are cryptographically signed, which makes them verifiable
    and these transactions are not immediately submitted to the blockchain. As discussed,
    these state channels could have a predefined lifespan, or could be bound to the
    amount of transactions being carried out in terms of volume/quantity or any other
    quantifiable measure. So, the final outcome of the transactions gets settled on
    the blockchain and that unlocks the state as the final step.State channels could
    be very differently implemented in different use cases, and their implementations
    are actually left to the developers. It is certainly a way forward and is one
    of the most critical components for mainstream adoption of blockchain applications.
    For Bitcoin, the Lightning Network was designed for off-chain computation and
    to make the payments transaction faster. Similarly, the “Raiden Network” was designed
    for Ethereum blockchain. There are many other such developments to make micropayments
    faster and more feasible on blockchain networks.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 链下计算是扩展区块链解决方案最有前景的技术之一。其基本思想是限制区块链的使用，在区块链之外完成繁重的工作，只将结果存储在区块链上。要记住，目前还没有关于链下计算应如何进行的标准定义。它严重依赖于具体情况和尝试解决问题的人。此外，不同的区块链版本可能需要不同的链下计算方法。在较高层次上，链下计算就像是区块链之上的另一层，它执行繁重、计算密集型的任务，并明智地使用区块链。显然，通过链下计算你可能无法保留区块链的所有特性，但同样真实的是，对于各种计算需求，你也许并不需要区块链，并且可能只针对特定的痛点使用它。链下计算可以在侧链上进行，可以分散在随机的一组节点之间，也可以是集中的。侧链独立于主区块链。它不仅能很好地扩展区块链，还能隔离侧链上的损害，并防止主区块链受到侧链的任何损害。侧链的一个例子是“闪电网络”，它应该能够以极低的费用快速执行交易，并支持微支付。另一个针对比特币的侧链例子是“零现金”，其首要目标并不是可扩展性，而是隐私。如果你用零现金进行比特币交易，你就无法被追踪，你的隐私将得到保护。我们将把讨论限于通用的扩展技术，而不深入讨论本书中的比特币扩展性。
- en: Sharding Blockchain State
  id: totrans-355
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分片区块链状态
- en: Sharding is one of the scalability techniques that has been there for ages and
    has been a more sought-after topic for databases. People used this technique differently
    in different use cases to address specific scalability challenges. Before we understand
    how it could be used in scaling blockchain as well, let us first understand what
    it means.Disk read/write has always been a bottleneck when dealing with huge data
    sets. When the data is partitioned  across multiple disks, the read/write could
    be performed in parallel and latency decreases significantly. This technique is
    called sharding. Take a look at Figure [2-29](A440588_1_En_2_Chapter_split_001.xhtml#Fig29).![A440588_1_En_2_Fig29_HTML.jpg](Images/A440588_1_En_2_Fig29_HTML.jpg)Figure
    2-29Database sharding  exampleNotice in Figure [2-29](A440588_1_En_2_Chapter_split_001.xhtml#Fig29)
    how horizontal partitioning is done to distribute a 300GB database table into
    three shards of 100GB each and stored on separate server instances. The same concept
    is also applicable for blockchain, where the overall blockchain state is divided
    into different shards that contain their own substates. Well, it is definitely
    not as easy as sharding a database with just doing horizontal partitioning.So,
    how does sharding really work in the context of blockchain? The idea is that the
    nodes wouln’t be required to download and keep a copy of the entire blockchain  .
    Instead, they would download and keep the portions (shards) relevant to them.
    By doing so, they get to process only those transactions that are relevant to
    the data they store, and parallel execution of transactions is possible. So, when
    a transaction occurs, it is routed to only specific nodes depending on which shards
    they affect. If you look at it from a different lens, all the nodes are not required
    to do all sorts of calculations and verifications for each and every transaction.
    A mechanism or a protocol could be defined for communication between shards when
    more than one shard is required to process any specific transactions. Please keep
    in mind that different blockchains might have different variants of sharding.To
    give you an example, you might choose a specific sharding technique for a given
    situation. One example could be where shards are required to have multiple unique
    accounts  in them. In other words, each unique account is in one shard (more applicable
    for Ethereum style blockchains that are stateful), and it is very easy for the
    accounts in one shard to transact among themselves. Obviously, one more level
    extraction at a shard level is required for sharding to work, and the nodes could
    keep only a subset of the information.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 分片是多年来一直存在的可扩展性技术之一，并且一直备受数据库领域的关注。人们在不同的用例中用这种技术来解决具体的可扩展性挑战。在我们了解它如何用于扩展区块链之前，首先让我们来了解一下它的含义。在处理大数据集时，磁盘读/写一直是一个瓶颈。当数据跨多个磁盘进行分区时，读/写可以并行进行，延迟显著降低。这种技术称为分片。请查看图[2-29](A440588_1_En_2_Chapter_split_001.xhtml#Fig29)。![A440588_1_En_2_Fig29_HTML.jpg](Images/A440588_1_En_2_Fig29_HTML.jpg)图2-29数据库分片示例请注意图[2-29](A440588_1_En_2_Chapter_split_001.xhtml#Fig29)中如何进行水平分区，将一个300GB的数据库表分为三个100GB的片段，并存储在不同的服务器实例上。这个概念也适用于区块链，其中整个区块链状态被划分为不同的片段，包含它们自己的子状态。嗯，这绝对不像只是做水平分区来分片数据库那么简单。那么，在区块链上下文中，分片实际上是如何工作的呢？想法是节点无需下载并保留整个区块链的副本。相反，它们将下载并保留与它们相关的部分（片段）。这样做的话，它们只能处理与它们存储的数据相关的交易，并且可以并行执行交易。所以，当一个交易发生时，它会被路由到只影响特定分片的特定节点。如果你从不同的角度来看，所有节点都不需要对每个交易进行所有
    sorts 的计算和验证。当需要处理特定交易时，可以定义一个分片之间的通信机制或协议。请记住，不同的区块链可能有不同的分片变体。举个例子，你可能为特定情况选择一个特定的分片技术。一个例子可能是需要分片中包含多个唯一账户的情况。换句话说，每个唯一账户在一个分片（更适合具有状态的以太坊式区块链）中，分片中的账户互相交易非常容易。显然，为了使分片工作，需要在分片级别进行额外的提取，节点可以只保留信息的子集。
- en: Summary
  id: totrans-357
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we took a deep dive into the core fundamentals of cryptography,
    game theory, and computer science engineering. The concepts learned would help
    you design your own blockchain solution that may have some specific needs. Blockchain
    is definitely not a silver bullet for all sorts of problems. However, for the
    ones where blockchain is required, it is highly likely that different flavors
    of blockchain solutions would be needed with different design constructs.We learned
    different cryptographic techniques to secure transactions and the usefulness of
    hash functions. We looked at how game theory could be used to design robust solutions.
    We also learned some of the core computer science fundamentals such as blockchain
    data structure and Merkle trees. Some of the concepts were supplimented with example
    code snippets to give you a jump start on your blockchain assignments.In the next
    chapter, we will learn about Bitcoin as a blockchain use case, and how exactly
    it works.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了密码学、博弈论和计算机科学与工程的核心基础知识。学到的概念将帮助您设计自己的区块链解决方案，该方案可能有一些特定的需求。区块链绝非解决所有问题的灵丹妙药。然而，在需要区块链的情况下，很可能会需要不同设计结构的多种区块链解决方案。我们学习了不同的密码学技术来保障交易的安全性以及散列函数的实用性。我们探讨了博弈论如何用来设计健壮的解决方案。我们还学习了诸如区块链数据结构和默克尔树等计算机科学的基本原理。部分概念通过示例代码片段进行了补充，以帮助您在区块链作业中取得快速进展。在下一章中，我们将学习比特币作为区块链用例的具体运作方式。
- en: References
  id: totrans-359
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考文献
- en: 'New Directions in CryptographyDiffie, Whitfield; Hellman, Martin E., “New Directions
    in Cryptography,” IEEE Transactions on Information Theory, Vol IT-22, No 6, [https://ee.stanford.edu/~hellman/publications/24.pdf](https://ee.stanford.edu/~hellman/publications/24.pdf)
    , November, 1976.Kerckhoff’s PrincipleCrypto-IT Blog, “Kerckhoff’s Principle,”
    [www.crypto-it.net/eng/theory/kerckhoffs.html](http://www.crypto-it.net/eng/theory/kerckhoffs.html)
    .Block Cipher, Stream Cipher and Feistel Cipher[http://kodu.ut.ee/~peeter_l/teaching/kryptoi05s/streamkil.pdf](http://kodu.ut.ee/~peeter_l/teaching/kryptoi05s/streamkil.pdf)
    .[www.cs.utexas.edu/~byoung/cs361/lecture45.pdf](http://www.cs.utexas.edu/~byoung/cs361/lecture45.pdf)
    .[www.cs.man.ac.uk/~banach/COMP61411.Info/CourseSlides/Wk2.1.DES.pdf](http://www.cs.man.ac.uk/~banach/COMP61411.Info/CourseSlides/Wk2.1.DES.pdf)
    .[https://engineering.purdue.edu/kak/compsec/NewLectures/Lecture3.pdf](https://engineering.purdue.edu/kak/compsec/NewLectures/Lecture3.pdf)
    .Digital Encryption Standard (DES)[www.facweb.iitkgp.ernet.in/~sourav/DES.pdf](http://www.facweb.iitkgp.ernet.in/~sourav/DES.pdf)
    .Advanced Encryption Standard (AES)[www.facweb.iitkgp.ernet.in/~sourav/AES.pdf](http://www.facweb.iitkgp.ernet.in/~sourav/AES.pdf)
    .AES Standard ReferenceNational Institute of Standards and Technology (NIST),
    “Announcing the Advanced Encryption Standard (AES),” Federal Information Processing
    Standards Publication 197, [http://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.197.pdf](http://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.197.pdf)
    , November 26, 2001.Secured Hash StandardNational Institute of Standards and Technology
    (NIST), “Announcing the Advanced Encryption Standard (AES),” Federal Information
    Processing Standards Publication 197, [http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf](http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf)
    , November 26, 2001.SHA-3 Standard: Permutation-Based Hash and Extendable-Output
    FunctionsNIST, “Announcing DraftFederl Information Processing Standard (FIPS)
    202, SHA-3 Standard: Permutation-Based Hash and Extendable-Output Functions, and
    Draft Revision of the Applicability Clause of FIPS 180-4, Secure Hash Standard,
    and Request for Comments,” [https://csrc.nist.gov/News/2014/Draft-FIPS-202,-SHA-3-Standard-and-Request-for-Com](https://csrc.nist.gov/News/2014/Draft-FIPS-202,-SHA-3-Standard-and-Request-for-Com)
    , May 28, 2014.SHA-3Paar, Christof, Pelzl, Jan, “SHA-3 and the Hash Function Keccak,”
    Understanding Cryptography—A Textbook for Students and Practitioners, (Springer,
    2010), [https://pdfs.semanticscholar.org/8450/06456ff132a406444fa85aa7b5636266a8d0.pdf](https://pdfs.semanticscholar.org/8450/06456ff132a406444fa85aa7b5636266a8d0.pdf)
    .RSA AlgorithmKaliski, Burt, “The Mathematics of the RSA Public-Key Cyptosystem,”
    RSA Laboratories, [www.mathaware.org/mam/06/Kaliski.pdf](http://www.mathaware.org/mam/06/Kaliski.pdf)
    .Milanov, Evgeny, “The RSA Algorithm,” [https://sites.math.washington.edu/~morrow/336_09/papers/Yevgeny.pdf](https://sites.math.washington.edu/~morrow/336_09/papers/Yevgeny.pdf)
    . June 3, 2009.Game TheoryPinkasovitch, Arthur, “Why Is Game Theory Useful in
    Business?,” Investopedia, [www.investopedia.com/ask/answers/09/game-theory-business.asp](http://www.investopedia.com/ask/answers/09/game-theory-business.asp)
    , December 19, 2017.Proof of Stake AlgorithmButerin, Vitalik, “A Proof of Stake
    Design Philosophy,” Medium, [https://medium.com/@VitalikButerin/a-proof-of-stake-design-philosophy-506585978d51](https://medium.com/@VitalikButerin/a-proof-of-stake-design-philosophy-506585978d51)
    , December 30, 2016.Ray, James, “Proof of Stake FAQ,” Ethereum Wiki, [https://github.com/ethereum/wiki/wiki/Proof-of-Stake-FAQ](https://github.com/ethereum/wiki/wiki/Proof-of-Stake-FAQ)
    .Enabling blockchain Innovations with Pegged SidechainsBack, Adam, Corallo, Matt,
    Dash Jr, Luke, et al., “Enabling blockchain Innovations with Pegged Sidechains,”
    [https://blockstream.com/sidechains.pdf](https://blockstream.com/sidechains.pdf)
    .'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
