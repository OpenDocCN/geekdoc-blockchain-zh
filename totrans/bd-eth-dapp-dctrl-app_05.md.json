["```\npragma solidity ^0.4.24;\n\nimport \"./Listing5_8_SimpleCoin.sol\";\nimport \"./Listing6_4_Ownable.sol\";\n\ninterface ReleasableToken {\n    function mint(address _beneficiary, uint256 _numberOfTokens) external;\n    function release() external;\n    function transfer(address _to, uint256 _amount) external;\n}\n\ncontract ReleasableSimpleCoin is ReleasableToken, SimpleCoin { \n    bool public released = false;\n\n    modifier canTransfer() { \n        if(!released) {\n            revert();\n        }\n\n        _;\n    }\n\n    constructor(uint256 _initialSupply) \n        SimpleCoin(_initialSupply) public {} \n\n    function release() onlyOwner public { \n        released = true;\n    }\n\n    function transfer(address _to, uint256 _amount) \n        canTransfer public { \n        super.transfer(_to, _amount);\n    }\n\n    function transferFrom(address _from, address _to, \n        uint256 _amount) \n        canTransfer public returns (bool) {\n        super.transferFrom(_from, _to, _amount);\n    }  \n}\n\ncontract FundingLimitStrategy{\n    function isFullInvestmentWithinLimit(uint256 _investment, \n        uint256 _fullInvestmentReceived)     \n        public view returns (bool);\n}\n\ncontract CappedFundingStrategy is FundingLimitStrategy {\n    uint256 fundingCap;\n\n    constructor(uint256 _fundingCap) public {\n        require(_fundingCap > 0);\n        fundingCap = _fundingCap;\n    }\n\n    function isFullInvestmentWithinLimit(uint256 _investment, \n        uint256 _fullInvestmentReceived) \n        public view returns (bool) {\n\n        bool check = _fullInvestmentReceived + _investment < fundingCap; \n        return check;\n    }\n}\n\ncontract UnlimitedFundingStrategy is FundingLimitStrategy {\n    function isFullInvestmentWithinLimit(uint256 _investment, \n        uint256 _fullInvestmentReceived) \n        public view returns (bool) {\n        return true;\n    }\n}\n\ncontract SimpleCrowdsale is Ownable {\n    uint256 public startTime;\n    uint256 public endTime; \n    uint256 public weiTokenPrice;\n    uint256 public weiInvestmentObjective;\n\n    mapping (address => uint256) public investmentAmountOf;\n    uint256 public investmentReceived;\n    uint256 public investmentRefunded;\n\n    bool public isFinalized;\n    bool public isRefundingAllowed; \n\n    ReleasableToken public crowdsaleToken; \n\n    FundingLimitStrategy internal fundingLimitStrategy;\n\n    constructor(uint256 _startTime, uint256 _endTime, \n     uint256 _weiTokenPrice, uint256 _etherInvestmentObjective) \n     payable public\n    {\n        require(_startTime >= now);\n        require(_endTime >= _startTime);\n        require(_weiTokenPrice != 0);\n        require(_etherInvestmentObjective != 0);\n\n        startTime = _startTime;\n        endTime = _endTime;\n        weiTokenPrice = _weiTokenPrice;\n        weiInvestmentObjective = _etherInvestmentObjective \n            * 1000000000000000000;\n\n        crowdsaleToken = createToken();\n        isFinalized = false;\n        fundingLimitStrategy = createFundingLimitStrategy();\n    } \n\n    event LogInvestment(address indexed investor, uint256 value);\n    event LogTokenAssignment(address indexed investor, uint256 numTokens);\n    event Refund(address investor, uint256 value);\n\n    function invest() public payable {\n        require(isValidInvestment(msg.value)); \n\n        address investor = msg.sender;\n        uint256 investment = msg.value;\n\n        investmentAmountOf[investor] += investment; \n        investmentReceived += investment; \n\n        assignTokens(investor, investment);\n        emit LogInvestment(investor, investment);\n    }\n\n    function createToken() \n        internal returns (ReleasableToken) {\n            return new ReleasableSimpleCoin(0);\n        }\n\n    function createFundingLimitStrategy() \n        internal returns (FundingLimitStrategy);\n\n    function isValidInvestment(uint256 _investment) \n        internal view returns (bool) {\n        bool nonZeroInvestment = _investment != 0;\n        bool withinCrowsalePeriod = now >= startTime && now <= endTime; \n\n        return nonZeroInvestment && withinCrowsalePeriod\n           && fundingLimitStrategy.isFullInvestmentWithinLimit(\n           _investment, investmentReceived);\n    }\n\n    function assignTokens(address _beneficiary, \n        uint256 _investment) internal {\n\n        uint256 _numberOfTokens = calculateNumberOfTokens(_investment); \n\n        crowdsaleToken.mint(_beneficiary, _numberOfTokens);\n    }\n\n    function calculateNumberOfTokens(uint256 _investment) \n        internal returns (uint256) {\n        return _investment / weiTokenPrice; \n    }\n\n    function finalize() onlyOwner public {\n        if (isFinalized) revert();\n\n        bool isCrowdsaleComplete = now > endTime; \n        bool investmentObjectiveMet = investmentReceived \n           >= weiInvestmentObjective;\n\n        if (isCrowdsaleComplete)\n        {     \n            if (investmentObjectiveMet)\n                crowdsaleToken.release();\n            else \n                isRefundingAllowed = true;\n            isFinalized = true;\n        }               \n    }\n\n    function refund() public {\n        if (!isRefundingAllowed) revert();\n\n        address investor = msg.sender;\n        uint256 investment = investmentAmountOf[investor];\n        if (investment == 0) revert();\n        investmentAmountOf[investor] = 0;\n        investmentRefunded += investment;\n        emit Refund(msg.sender, investment);\n\n        if (!investor.send(investment)) revert();\n    }    \n}\n\ncontract TranchePricingCrowdsale is SimpleCrowdsale  {\n\n    struct Tranche {\n        uint256 weiHighLimit;\n        uint256 weiTokenPrice;\n    }\n\n    mapping(uint256 => Tranche) public trancheStructure;\n    uint256 public currentTrancheLevel;\n\n    constructor(uint256 _startTime, uint256 _endTime, \n     uint256 _etherInvestmentObjective) \n     SimpleCrowdsale(_startTime, _endTime,\n        1, _etherInvestmentObjective)\n     payable public\n    {\n        trancheStructure[0] = Tranche(3000 ether, 0.002 ether);\n        trancheStructure[1] = Tranche(10000 ether, 0.003 ether);\n        trancheStructure[2] = Tranche(15000 ether, 0.004 ether);\n        trancheStructure[3] = Tranche(1000000000 ether, 0.005 ether);\n\n        currentTrancheLevel = 0;\n    } \n\n    function calculateNumberOfTokens(uint256 investment) \n        internal returns (uint256) {\n        updateCurrentTrancheAndPrice();\n        return investment / weiTokenPrice; \n    }\n\n    function updateCurrentTrancheAndPrice() \n        internal {\n        uint256 i = currentTrancheLevel;\n\n        while(trancheStructure[i].weiHighLimit < investmentReceived) \n            ++i;\n\n        currentTrancheLevel = i;\n\n        weiTokenPrice =\n           trancheStructure[currentTrancheLevel].weiTokenPrice;\n    }\n}\n\ncontract FixedPricingCrowdsale is SimpleCrowdsale {     \n\n    constructor(uint256 _startTime, uint256 _endTime, \n     uint256 _weiTokenPrice, uint256 _etherInvestmentObjective)\n     SimpleCrowdsale(_startTime, _endTime, \n     _weiTokenPrice, _etherInvestmentObjective)\n\n     payable public  {\n    }\n\n    function calculateNumberOfTokens(uint256 investment) \n        internal returns (uint256) {\n        return investment / weiTokenPrice;\n    }    \n}\n\ncontract UnlimitedFixedPricingCrowdsale is FixedPricingCrowdsale {\n\n    constructor(uint256 _startTime, uint256 _endTime, \n     uint256 _weiTokenPrice, uint256 _etherInvestmentObjective)\n     FixedPricingCrowdsale(_startTime, _endTime, \n     _weiTokenPrice, _etherInvestmentObjective)\n     payable public  {\n    }\n\n    function createFundingLimitStrategy() \n        internal returns (FundingLimitStrategy) {\n\n        return new UnlimitedFundingStrategy(); \n    }\n}\n\ncontract CappedFixedPricingCrowdsale is FixedPricingCrowdsale {\n\n    constructor(uint256 _startTime, uint256 _endTime, \n     uint256 _weiTokenPrice, uint256 _etherInvestmentObjective)\n     FixedPricingCrowdsale(_startTime, _endTime, \n     _weiTokenPrice, _etherInvestmentObjective)\n     payable public  {\n    }\n\n    function createFundingLimitStrategy() \n        internal returns (FundingLimitStrategy) {\n\n        return new CappedFundingStrategy(10000); \n    }\n}\n\ncontract UnlimitedTranchePricingCrowdsale is TranchePricingCrowdsale {\n\n    constructor(uint256 _startTime, uint256 _endTime, \n     uint256 _etherInvestmentObjective)\n     TranchePricingCrowdsale(_startTime, _endTime, \n     _etherInvestmentObjective)\n     payable public  {\n    }\n\n    function createFundingLimitStrategy() \n        internal returns (FundingLimitStrategy) {\n\n        return new UnlimitedFundingStrategy(); \n    }\n}\n\ncontract CappedTranchePricingCrowdsale is TranchePricingCrowdsale {\n\n    constructor(uint256 _startTime, uint256 _endTime, \n     uint256 _etherInvestmentObjective)\n     TranchePricingCrowdsale(_startTime, _endTime, \n     _etherInvestmentObjective)\n     payable public  {\n    }\n\n    function createFundingLimitStrategy() \n        internal returns (FundingLimitStrategy) {\n\n        return new CappedFundingStrategy(10000); \n    }\n}\n```"]