- en: Chapter 6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Blockchain Implementation Using Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Saugata Dutta
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Galgotias University, India
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Kavita Saini
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Galgotias University, India
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ABSTRACT
  prefs: []
  type: TYPE_NORMAL
- en: This chapter covers an introductory overview of blockchain using Python code.
    This chapter will give a basic understanding of using Python codes in development
    of blockchain. The chapter throws light on beginner-level blockchain creation
    which will help in understanding developing an advance blockchain project using
    Python codes. This chapter covers basic building blocks which will help in creating
    various functions and methods to enhance the blockchain in terms of security.
    This will also help students in creating advanced level of Python program in creating
    better mining algorithms, better queue management, enhanced and secured transactions,
    consensus algorithm, wallets, and accounts.
  prefs: []
  type: TYPE_NORMAL
- en: PREFACE
  prefs: []
  type: TYPE_NORMAL
- en: The motivation for this writing is originally triggered for my passion into
    network security and data leak prevention. Due to innovation of latest technology
    and at the same time rise in breach of digital security, there are greater needs
    for a technology which has high rate of data security, tamper proof and data leak
    prevention. With a hope to achieve this success, blockchain technology claim to
    produce a same effect of data security, needless to say that using this technology,
    data tampering is immutable where the entire information is stored in blocks and
    hashed. The use of this technology is not restricted only to cryptocurrencies
    but being used in other industries like logistics, supply chain, healthcare and
    so on. This chapter discuss an introduction to blockchain using python code. The
    change in the outlook and market trends due to the usage of this technology which
    is future proof with high level of data security without the involvement of any
    central authority.
  prefs: []
  type: TYPE_NORMAL
- en: It is my interest to find out those latest trends in blockchain technology,
    future developments and a platform to use in various platforms. In reality, the
    success credit goes to everyone who was involved to make this writing a success.
  prefs: []
  type: TYPE_NORMAL
- en: INTRODUCTION TO BLOCKCHAIN
  prefs: []
  type: TYPE_NORMAL
- en: Blockchain can be said as a public ledger which is distributed across systems
    irrespective of geographical locations. The ledger is stored and updated across
    many systems across the world. The man behind the blockchain technology is Satoshi
    Nakamoto. The white paper of blockchain was submitted in 2009 where the technology
    exhibits peer to peer, decentralization, consensus algorithm and use of technology
    without the intervention of any third party. Initially the technology was exclusively
    meant for bitcoin but on later stage the functionality extended to every line
    of business with its attribute of high security, append only, decentralized network
    and most importantly does not require any third party approval (Jena et al., 2019).
    The usage of currency is not new and had been in vogue since medieval period.
    The common method of transactions during ancient times were barter method, as
    the settlements were done in exchange of items of same corresponding value like
    metals, precious stones etc. Advent of development, the transactions took a drastic
    change with introduction of coins and notes. The centralized authority is responsible
    for generation of these currencies and has full control over it. The government,
    regulatory body has a strong hold on these currencies and has full authority on
    circulation. These currencies are fixed and doesn’t decline with period. During
    recent times, introduction of floating currencies made transactions easy and quite
    faster. However these transactions which involves, record keeping, identification
    and verification, transfers are centrally managed. Information technology has
    made life easy with users to execute transaction at any point in time but however
    the cyber threat is a challenge. The vulnerabilities are still there and has already
    made a footprint of losses globally. The transactions are centrally managed and
    non-visible. Data and transactions can be modified, tampered, spoofed with well
    orchestration of IT vulnerabilities and loop holes. In fact the data can be a
    threat from an internal traitor as well. There are various other factors and ways
    of violating critical data which is centrally managed. The Blockchain technology
    which during its manifestation stage introduced Bitcoin to start a parallel economy
    claim to solve these problems. Blockchain uses decentralized and distributed network
    along with distributed ledger which doesn’t require any intervention of third
    party or centralized authority to approve or manage. Bitcoins currency is said
    to be the mother of cryptocurrencies and was the first currency introduced using
    the blockchain technology (Jena et al., 2020). The ledger copy of bitcoin is already
    shared among the nodes and each nodes holds the same copy of this distributed
    ledger. The sender uses private and public key to sign and encrypt the transaction
    to send to a receiver. These transactions can be authenticated with the public
    key by anyone but can only be deciphered with the sender’s private key. A group
    of people known as “Miners” known for validating transactions and accumulate these
    transactions with other transactions into a block for which they are paid some
    rewards. This process is also known as mining. After the mining process, once
    the block is generated and the shared ledger is updated to all nodes, the receiver
    is said to have received the amount. These transactions are transparent and cannot
    be modified or tampered. Bitcoin, digital cryptocurrencies invention was an innovation,
    however the blockchain technology has evolved these years with different types
    of consumptions. Industries has started finding ways to use this secured technologies
    in various forms such that the data remains secured, un-tampered, decentralize
    and no control of any party. Ethereum, an open source cryptocurrency and blockchain
    platform, has progressed in use of smart contracts, in fact an inventor. The use
    of smart contracts has been accepted and used by mass and granted as an acceptable
    tools where one can create self-executable contracts on a blockchain platform.
    These contracts has no intervention or control of any parties(Kumari & Saini,
    2019). Proof of stake discovery has made easy in creation of blocks. The validators
    are selected on the basis of more mining power or currency they hold to validate
    block transactions. This has few advantages over the traditional proof of work
    algorithm like saving on power consumptions which is the most common issues and
    more secured in terms of 51% attack. Proof of stake validators doesn’t receives
    reward while they are given transaction fee. The next achievement in the field
    of blockchain technology is scaling. As the blockchain transactions increases
    there are performance degradation and storage related issues. In order to counter
    these issues various ways are being explored like sharding, sidechains, proof
    of stake, block compressions, hybrid consensus etc. (Kavita, 2018). Thus blockchain
    is an evolving technology which deals with the transactions in a secured way with
    the use of decentralized networking, hashing, and cryptography including reward
    mechanism. Blockchain can be said as a digital disruption and a new innovative
    foundation for researchers, scientist and engineers. There are few significant
    components of successful blockchain operations such as appropriate trustworthiness
    standards for individual transactions, robust cryptographic and hashing mechanism,
    system preparedness and reward mechanism to motivate miners (Saini et al., 2018).
  prefs: []
  type: TYPE_NORMAL
- en: BLOCKCHAIN DESIGN
  prefs: []
  type: TYPE_NORMAL
- en: Blockchain as the name says, it’s a chain of blocks. Blockchain is a distributed
    ledger built from a chain of blocks. A block consists of multiple transactions
    and block header. Block header are used to differentiate blocks and helps in creating
    the chain.
  prefs: []
  type: TYPE_NORMAL
- en: A block header consists of
  prefs: []
  type: TYPE_NORMAL
- en: '• Timestamp: The time stamp specifies the time of block creation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '• Version: Specifies the version number of the blockchain'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '• Merkle Root: Blocks are connected with each other through hash values. Every
    block will have transactions. It can be one transactions or thousands and there
    should be a root hash of the block. This is achieved by Merkle tree. A tree will
    have root, branches and leaves. The end nodes are called leaves, the nodes in
    between roots and leaves are called branches and in the top is roots. Imagine
    having a block consists of 8 transactions. So calculating hash of each transactions
    will have eight hashes. So we will calculate hash value of first and second, third
    and fourth, fifth and sixth and so on till eighth. Here we will combine the hash
    of first, second, third and fourth and then fifth, sixth, seventh and eighth.
    Finally we will combine a hash of first to eighth which will be the root hash
    or merkle root.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| Figure 1\. Merkle root |'
  prefs: []
  type: TYPE_TB
- en: '| ![Figure978-1-7998-8367-8.ch006.f01](i/ch006.f01.png) |'
  prefs: []
  type: TYPE_TB
- en: '• Difficulty Target: It is a number which controls the time taken to add a
    new block to the chain'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '• Nonce: Nonce which is “number only used once” is added to the hashed block
    and when it is rehashed meets the criteria of difficulty target.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '• Previous Hash: Hash of the previous block'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are some critical components of blockchain functioning.
  prefs: []
  type: TYPE_NORMAL
- en: 'Genesis Block: The first block is known as genesis block. The previous hash
    value of genesis block is 0 as it is the first block.'
  prefs: []
  type: TYPE_NORMAL
- en: '| Figure 2\. Connected blocks in blockchain |'
  prefs: []
  type: TYPE_TB
- en: '| ![Figure978-1-7998-8367-8.ch006.f02](i/ch006.f02.png) |'
  prefs: []
  type: TYPE_TB
- en: 'Cryptography: It means secret writing. Here the sender encrypts the message
    with a public key. The encrypted data also known as cipher text cannot be read
    unless decrypted. The encrypted data is decrypted at receivers end with a private
    key.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Digital Signature: It is used for authentication and integrity sometimes. If
    a data is sent, it must be authenticated from the right user. Here the data is
    encrypted with the sender’s private key and re-encrypted with receiver’s public
    key. At the receiver end it is decrypted with receiver’s private key and re-decrypted
    using sender’s public key.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Hashing: Hash is a function which takes any random length of data and converts
    into a fixed length output. This is used to check the integrity of the data, if
    changed, the fixed output data value will change.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consensus: As blockchain is a distributed ledger and each node will have a
    copy of this ledger. When a block is added, all nodes should come to consensus
    that all have the same copy of the blockchain. So with a consensus algorithm,
    nodes can agree on a particular state of blockchain. On the basis of consensus
    algorithm, it can be decided which node can add the block in the blockchain.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Proof of Work: The node which solves the mathematical puzzle, will add the
    block to the blockchain and in return will receive some rewards. The nodes are
    usually mining nodes. The mathematical puzzle requires lots of power and time
    and requires specific hardware to solve this puzzle. Once the puzzle is won, the
    block can be added to the chain. This whole procedure is known as Proof of work.'
  prefs: []
  type: TYPE_NORMAL
- en: So to sum up, blockchain works in the principle of adding blocks in chain which
    are connected to each other through hashing mechanism. In blockchain, data cannot
    be manipulated and cannot be tampered with. The block consists of transactional
    data and block header which stores timestamp, version, merkle root, difficulty
    target, nonce and previous hash (Dutta & Saini, 2019). The reason it is said to
    be secured because if the data is modified, the hash value will change. So let’s
    assume there are four blocks and data is modified on the second block, as soon
    as the same is done the hash value of the second block is changed which will affect
    the third block. The third block hash value needs to be regenerated which again
    affect the hash will value of the next block that is fourth. This continues to
    go on. As the number of blocks in the blockchain is humungous, it is nearly impractical
    to change all corresponding blocks because of proof of work, which requires a
    mathematical puzzle to be solved to generate a block and takes a certain period
    of time. Blockchain is also said to be a trustless technology in terms that there
    is no central control or authority. As an example a transaction in blockchain,
    A as sender and B as receiver. A sends some coins to B. The transaction to miners
    will be digital address of B, digital signature, public key and amount. Hence
    this transactions along with other transactions are mined. The difficulty target
    may be the number of 0’s to be measured valid. A nonce number is added in the
    block and are tried randomly until the miners find a valid hash which satisfies
    the consensus criteria. The miner who wins this race is said to be successfully
    mined the block. The block is then added to the chain for which the miner is rewarded.
  prefs: []
  type: TYPE_NORMAL
- en: PYTHON LIBRARIES FOR BLOCKCHAIN
  prefs: []
  type: TYPE_NORMAL
- en: In order to create a blockchain code using python, there are many libraries
    that needs to be imported. Python libraries consists of literals, built in functions
    and exceptions. It is a library of modules which can be used in python code when
    one requires it. “json” is an inbuilt package in python to work with json data
    similarly “string” package consists constants, classes and various strings operations
    which will works once it is imported in the Python file. As an example, “crypto”
    and “crypto.Hash” packages can be used to sign and hash the transactions.
  prefs: []
  type: TYPE_NORMAL
- en: '| Figure 3\. Python libraries |'
  prefs: []
  type: TYPE_TB
- en: '| ![Figure978-1-7998-8367-8.ch006.f03](i/ch006.f03.png) |'
  prefs: []
  type: TYPE_TB
- en: STARTING WITH BLOCK AND TRANSACTION CLASS
  prefs: []
  type: TYPE_NORMAL
- en: The blockchain is a chain which can be attributed as a list. The elements in
    the list are separated by comma. One can access elements of the list while the
    index starts with 0\. The blocks will hold values and each block will be connected
    by hash. Blocks will store transaction values. The first block is the genesis
    block which has no previous hash. The block class will have attributes and will
    have couple of arguments. Self is always required to represent the instance of
    the class, index, previous hash of the block, transaction items of the block,
    nonce and time. Time function will provide the current time. The constructor body
    will have instance attributes for example the transactions instance attribute
    is created by calling self.transactions in the constructor and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '| Figure 4\. Block class |'
  prefs: []
  type: TYPE_TB
- en: '| ![Figure978-1-7998-8367-8.ch006.f04](i/ch006.f04.png) |'
  prefs: []
  type: TYPE_TB
- en: In this chapter, a simple example of financial transaction between a sender
    and recipient is illustrated. A transaction class is created where an amount is
    sent to receivers address.
  prefs: []
  type: TYPE_NORMAL
- en: '| Figure 5\. Transaction class |'
  prefs: []
  type: TYPE_TB
- en: '| ![Figure978-1-7998-8367-8.ch006.f05](i/ch006.f05.png) |'
  prefs: []
  type: TYPE_TB
- en: Time variable is created to store the transaction time. Parameters like sender,
    receiver and amount are actually stored in the instance variables. Here we create
    a dictionary object which will have all these four variables such that it can
    be accessed from a single point.
  prefs: []
  type: TYPE_NORMAL
- en: '| Figure 6\. Dictionary object |'
  prefs: []
  type: TYPE_TB
- en: '| ![Figure978-1-7998-8367-8.ch006.f06](i/ch006.f06.png) |'
  prefs: []
  type: TYPE_TB
- en: As genesis is the primary block, there is a check if sender is the creator of
    the first transaction in genesis block and some value is assigned in the identity
    field else the address of the sender is assigned. This dictionary object will
    be signed by the private key of the sender with built in SHA algorithm. A method
    named tx_signature is created.
  prefs: []
  type: TYPE_NORMAL
- en: '| Figure 7\. Signature method |'
  prefs: []
  type: TYPE_TB
- en: '| ![Figure978-1-7998-8367-8.ch006.f07](i/ch006.f07.png) |'
  prefs: []
  type: TYPE_TB
- en: A transaction queue can be declared where transactions can be appended here.
    This is a global list variable.
  prefs: []
  type: TYPE_NORMAL
- en: '| Figure 8\. Transaction Queue |'
  prefs: []
  type: TYPE_TB
- en: '| ![Figure978-1-7998-8367-8.ch006.f08](i/ch006.f08.png) |'
  prefs: []
  type: TYPE_TB
- en: An example of a digital crypto transaction is as follows, here the sender named
    John has transferred an amount of 2 coins to Ria. Here the public key of Ria is
    addressed. Tx_signature method is invoked to get the senders private key while
    it is signed by calling the method, once the transaction object is created.
  prefs: []
  type: TYPE_NORMAL
- en: '| Figure 9\. Transaction example |'
  prefs: []
  type: TYPE_TB
- en: '| ![Figure978-1-7998-8367-8.ch006.f09](i/ch006.f09.png) |'
  prefs: []
  type: TYPE_TB
- en: 'More transactions can be added to the transactions queue. As an example below:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Figure 10\. Transactions |'
  prefs: []
  type: TYPE_TB
- en: '| ![Figure978-1-7998-8367-8.ch006.f10](i/ch006.f10.png) |'
  prefs: []
  type: TYPE_TB
- en: USER CLASS
  prefs: []
  type: TYPE_NORMAL
- en: The user class generates public and private keys with the help of built in python
    RSA algorithm. The values are kept in the instance variable and should not be
    lost as it holds the key. The public key is utilized as an identity for users.
    A property named identity is declared which returns the public key as an HEX representation.
  prefs: []
  type: TYPE_NORMAL
- en: '| Figure 11\. User class |'
  prefs: []
  type: TYPE_TB
- en: '| ![Figure978-1-7998-8367-8.ch006.f11](i/ch006.f11.png) |'
  prefs: []
  type: TYPE_TB
- en: 'Multiple users can be created as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Figure 12\. Users |'
  prefs: []
  type: TYPE_TB
- en: '| ![Figure978-1-7998-8367-8.ch006.f12](i/ch006.f12.png) |'
  prefs: []
  type: TYPE_TB
- en: CREATING THE FIRST GENESIS TRANSACTION
  prefs: []
  type: TYPE_NORMAL
- en: Genesis block is the first block in the blockchain which does not contains any
    previous hash. A block class is created and be as “block-user0”. An example of
    a transaction is taken, where Joseph transfers 2.0 coins to Lara. Initially a
    global variable is declared which is the hash of the last block, keeping in mind
    that every block stores hash of previous block. The previous block hash and Nonce
    is none in the first block of the blockchain always (Dutta & Saini, 2021a). As
    the block is ready with transaction, it is hashed and hash value is stored in
    the global variable “l_hash”. This value will be referred by the miner for mining
    process.
  prefs: []
  type: TYPE_NORMAL
- en: '| Figure 13\. First genesis transaction |'
  prefs: []
  type: TYPE_TB
- en: '| ![Figure978-1-7998-8367-8.ch006.f13](i/ch006.f13.png) |'
  prefs: []
  type: TYPE_TB
- en: CREATING AND LISTING THE BLOCKCHAIN
  prefs: []
  type: TYPE_NORMAL
- en: A list variable is created to store the entire blockchain “lst_val”. The entire
    contents of the blockchain can be displayed by creating a method called “disp_bchain”.
    The contents will increase in due course of time, but considering as an example,
    this method list the number of blocks and the contents. A “for” loop is created
    for iteration and values are temporarily stored in the variable “temp_bl”. All
    transactions are retrieved from iteration in “for” loop and display all transactions
    eventually.
  prefs: []
  type: TYPE_NORMAL
- en: '| Figure 14\. Creating and displaying the blockchain |'
  prefs: []
  type: TYPE_TB
- en: '| ![Figure978-1-7998-8367-8.ch006.f14](i/ch006.f14.png) |'
  prefs: []
  type: TYPE_TB
- en: ADDING THE BLOCKS TO THE CHAIN
  prefs: []
  type: TYPE_NORMAL
- en: Adding the block to the blockchain will use append to the list variable “lst_val”.
    The genesis block is now attached in the chain and blockchain contents are displayed
    when the function “disp_bchain” is called.
  prefs: []
  type: TYPE_NORMAL
- en: '| Figure 15\. Append the list variable |'
  prefs: []
  type: TYPE_TB
- en: '| ![Figure978-1-7998-8367-8.ch006.f15](i/ch006.f15.png) |'
  prefs: []
  type: TYPE_TB
- en: For the block class “block-user”, an instance is created. Five transactions
    are selected. Miners validates and confirms transactions before it is added in
    the blockchain. This process holds true when the hash created by the sender equals
    to the hash calculated by miner using public key of sender. The index of the last
    transaction is increased such that the next miner can start with the next transaction
    to validate. Here in theis example five transactions are added, hashed and mined
    with difficulty level of 2\. The block created is added to the blockchain and
    the global variable “l_hash” is re-initialize for next use.
  prefs: []
  type: TYPE_NORMAL
- en: '| Figure 16\. Adding blocks to the blockchain |'
  prefs: []
  type: TYPE_TB
- en: '| ![Figure978-1-7998-8367-8.ch006.f16](i/ch006.f16.png) |'
  prefs: []
  type: TYPE_TB
- en: MINERS AND MINING
  prefs: []
  type: TYPE_NORMAL
- en: Mining is a significant process in public blockchain. The validation and verification
    of transactions and adding those transactions in the block is done by miners (Dutta
    & Saini, 2021b). A digest is generated for proof of work in mining process.
  prefs: []
  type: TYPE_NORMAL
- en: '| Figure 17\. SHA 256 hash |'
  prefs: []
  type: TYPE_TB
- en: '| ![Figure978-1-7998-8367-8.ch006.f17](i/ch006.f17.png) |'
  prefs: []
  type: TYPE_TB
- en: SHA 256 is a hash function which can take any inputs and produces a 256 bits
    output. If there is integrity of the data. This function takes message and produces
    hexadecimal digest output. One can develop own mining function like generate a
    hash of a message which can start with two “1s”. The difficulty level specification
    relies on the number of “1s”. If the difficulty level is 3 then the prefix of
    “1s” will be three e.g. “111”, while if the difficult level is 2 then the prefix
    of “1s” will any change in the input, the output will change. This is also a one
    way process because one cannot generate the input from the output. SHA 256 is
    best suited for checking the two e.g. “11”. In this example, difficulty level
    of 2 is specified which means the prefix should have two “1s”.
  prefs: []
  type: TYPE_NORMAL
- en: '| Figure 18\. Mining function |'
  prefs: []
  type: TYPE_TB
- en: '| ![Figure978-1-7998-8367-8.ch006.f18](i/ch006.f18.png) |'
  prefs: []
  type: TYPE_TB
- en: Here the message and the difficulty levels are two parameters for mining and
    the difficulty level is greater than and equal to “2”. The variable “j” is added
    with new numbers and added to the message and the digest value changes. If the
    digest value condition is satisfied, the loop will end returning the digest value.
  prefs: []
  type: TYPE_NORMAL
- en: SCOPE
  prefs: []
  type: TYPE_NORMAL
- en: Here in this chapter, an introductory overview of blockchain is covered using
    python code. This chapter will give you a basic understanding of using python
    codes in further development of a blockchain project. The chapter throws light
    on basic blockchain creation using python codes and will help you in developing
    advance blockchain development. You can add various other functions and methods
    to enhance the blockchain in terms of security. Using advanced level of python
    you can create better mining algorithms, better queue management, enhanced and
    secured transactions, consensus algorithm, wallets and accounts. This chapter
    doesn’t include interface for clients, server implementation, mining interface,
    rewards distribution and other enhanced features to run a blockchain project and
    is beyond the scope of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: ACKNOWLEDGMENT
  prefs: []
  type: TYPE_NORMAL
- en: The success and final outcome of this chapter required a lot of guidance and
    assistance from many people and I am extremely privileged to have got this. All
    that I have done is only due to such supervision and assistance and I am extremely
    thankful to them.
  prefs: []
  type: TYPE_NORMAL
- en: REFERENCES
  prefs: []
  type: TYPE_NORMAL
- en: 6Dutta & Saini. (2019). Evolution of Blockchain Technology in Business Applications.
    Journal of Emerging Technologies and Innovative Research, 6(9), 240-244.
  prefs: []
  type: TYPE_NORMAL
- en: '7Dutta, S., & Saini, K. (2021a). Securing Data: A Study on Different Transform
    Domain Techniques. WSEAS Transactions on Systems And Control, 16. 10.37394/23203.2021.16.8'
  prefs: []
  type: TYPE_NORMAL
- en: 8Dutta, S., & Saini, K. (2021b). Statistical Assessment of Hybrid Blockchain
    for SME Sector. WSEAS Transactions on Systems And Control, 16. 10.37394/23203.2021.16.6
  prefs: []
  type: TYPE_NORMAL
- en: 1Jena, Shanmugam, Dhanaraj, & Saini. (2019). Recent Advances and Future Research
    Directions in Edge Cloud Framework. International Journal of Engineering and Advanced
    Technology, 9(2). 10.35940/ijeat.B3090.129219
  prefs: []
  type: TYPE_NORMAL
- en: '2Jena, S. R., Shanmugam, R., Saini, K., & Kumar, S. (2020). Cloud Computing
    Tools: Inside Views and Analysis. International Conference on Smart Sustainable
    Intelligent Computing and Applications under ICITETM2020, 382-391.'
  prefs: []
  type: TYPE_NORMAL
- en: '4Kavita. (2018). A Future’s Dominant Technology Blockchain: Digital Transformation.
    IEEE International Conference on Computing, Power and Communication Technologies
    2018 (GUCON 2018). 10.1109/GUCON.2018.8675075'
  prefs: []
  type: TYPE_NORMAL
- en: 3Kumari, K., & Saini, K. (2019). CFDD (CounterFeit Drug Detection) using Blockchain
    in the Pharmaceutical Industry. International Journal of Engineering Research
    & Technology, 8(12), 591-594.
  prefs: []
  type: TYPE_NORMAL
- en: '5Saini, K., Agarwal, V., Varshney, A., & Gupta, A. (2018). E2EE For Data Security
    For Hybrid Cloud Services: A Novel Approach. IEEE International Conference on
    Advances in Computing, Communication Control and Networking (IEEE ICACCCN 2018).
    10.1109/ICACCCN.2018.8748782'
  prefs: []
  type: TYPE_NORMAL
