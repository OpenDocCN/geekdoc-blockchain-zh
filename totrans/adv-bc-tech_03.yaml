- en: © The Author(s), under exclusive license to Springer Nature Switzerland AG 2022Y.
    Maleh et al. (eds.)Advances in Blockchain Technology for Cyber Physical SystemsInternet
    of ThingsTechnology, Communications and Computing[https://doi.org/10.1007/978-3-030-93646-4_3](https://doi.org/10.1007/978-3-030-93646-4_3)
  prefs: []
  type: TYPE_NORMAL
- en: Blockchain-Based Medical Records System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Nisarg Soni^([1](#Aff7)), Saurav Tayal^([1](#Aff7)), Tarun Kumar Singh^([1](#Aff7))
    and Gourinath Banda^([1](#Aff7) [ ](#ContactOfAuthor4))(1)Indian Institute of
    Technology Indore, Simrol, Madhya Pradesh, IndiaGourinath Banda (Corresponding
    author)Email: [gourinath@iiti.ac.in](mailto:gourinath@iiti.ac.in)KeywordsElectronic
    medical recordsBlockchainIPFSEthereum'
  prefs: []
  type: TYPE_NORMAL
- en: 1 Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Medical record management is a problem as old as medicine itself. Transfer and
    sharing of data between all the involved entities have always been the crucial
    components of the medical industry. Each entity involved in this process relies
    on non-tampered and complete data for the complete system to work. Along with
    interoperability, there is a confidentiality concern associated with protecting
    individual records from data leaks as health is a compassionate and private aspect
    of life.
  prefs: []
  type: TYPE_NORMAL
- en: The onset of technology brought electronic solutions to traditional paper-based
    systems. However, these systems are based on a centralized architecture, that
    is, client-server architecture. In such systems, data and functionality is served
    by a single server to multiple clients via the internet. All the client data and
    logic reside on the server. These systems have associated drawbacks like a single
    point of attack and failure where any attack or failure on the server would compromise
    the entire system. There is also an issue of centralization of power where the
    entity in control over the server controls all data and access to it. A better
    solution to the drawbacks would be decentralization. Decentralized systems are
    more robust against failures and attacks, without the centralization of power
    over the system. Blockchain is a distributed ledger. It is a decentralized system,
    and it is useful in targeting the problems associated with centralization.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter proposes a system that allows the interoperable exchange of medical
    records with proper authorization. This system ensures that a user of the system
    must ask for a patient’s permission to view and upload their medical records.
    To achieve this, we deploy smart contracts on the blockchain network. Through
    the use of the deployed smart contract, a patient can grant read and write permissions
    to different entities, namely, hospitals and insurance agencies. The use of blockchain
    ensures that the authorization mechanism is tamper-proof.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is organized into eight sections. The first section describes the
    importance of medical records and how a blockchain-based decentralized approach
    is better than the current centralized ones for their storage. Section two explains
    the concepts used in the solution like blockchain, cryptographic techniques, InterPlanetary
    File System (IPFS), and the patient lifecycle for visiting the hospital. Section
    three discusses some related works done in the field. Section four describes the
    proposed solution architecture. Section five explains some key implementation
    details, and section six details the various read/write workflows. Finally, sections
    seven and eight discuss our proposed solution analysis and the conclusion and
    the future work, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 2 Related Works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Earlier attempts at electronic health records (EHRs) were based on centralized
    systems with a centralized access control mechanism where the patients had little
    to no say over access control of their data. Such systems first had an in-house
    centralized data storage like in the hospital or the clinic itself, which did
    not improve any security or privacy compared with earlier pen-and-paper systems.
    Over time, cloud-based storage took over and provided more security for the stored
    data. However, they still were centralized solutions and made the hospitals and
    the authorities the data owner instead of the patient, who should have been the
    actual owner of the data.
  prefs: []
  type: TYPE_NORMAL
- en: Ying et al. [[1](#CR1)] proposed a policy preserving EHR systems based on CP-ABE
    to allow secure sharing of EHR data over the cloud. Though this allowed for more
    secure storage and health data sharing, it was still wholly a centralized solution.
    No kind of decentralization was explored in the solution.
  prefs: []
  type: TYPE_NORMAL
- en: Liang et al. [[2](#CR2)] used blockchain to maintain the health data’s integrity
    and allow secure access control. Their solution uses a cloud-based database to
    store health-related data, data requests from healthcare providers and insurance
    companies, data access records, and data access control policy. In their solution,
    the health data collected from the user’s wearable devices and the data obtained
    from healthcare providers is processed to create a hashed data entry which is
    then uploaded to the blockchain network. Also, a decentralized permission management
    protocol is used to process each data access request, for the user’s personal
    health data, from healthcare providers and health insurance companies. It is in
    the hands of the data owner to provide permission if they want. These access control
    policies ensure stability as they are stored on the blockchain in a decentralized
    manner. Besides that, every time an access request is made and any access activity
    is done, the blockchain, a distributed ledger, is used to record that activity.
    This record can be used for further auditing or investigation. In this case, though
    the blockchain provides security and integrity, the actual data is stored in a
    centralized database in the cloud, which brings a lot of problems, as already
    discussed.
  prefs: []
  type: TYPE_NORMAL
- en: Vijayakumar et al. [[3](#CR3)] used hyperledger fabric blockchain to store all
    the health data in a decentralized manner. In their solution, the various nodes
    are connected to form the blockchain network such that the data is distributed
    among the nodes. This gives each node the responsibility and the opportunity to
    handle its data which makes the solution patient-centric and gives the control
    of the data in the user’s hands. The blockchain is a distributed ledger that allows
    organizations to store medical information. As the data is stored in the blockchain
    in a decentralized manner, it allows for trust to be created among the participants
    of this network. By integrating hyperledger fabric, all medical information is
    recorded in an untamperable manner and any medical organization that has added
    the details can be tracked easily. Every transaction is stored in the blockchain
    and all the medical details of an individual that have ever been recorded can
    be accessed using query tools. They have discussed the issues associated with
    centralized systems and tried to overcome them through their decentralized solution.
    This allows integrity and security of data, but their solution suffers from the
    issues of storing large amounts of data on the blockchain itself.
  prefs: []
  type: TYPE_NORMAL
- en: Dubovitskaya et al. [[4](#CR4)] created a patient-centric blockchain-based EHR
    (electronic health record) data management system. They propose a permissioned
    blockchain-based system for EHR data sharing and integration. Their solution makes
    use of the hyperledger fabric blockchain. Each hospital acts as a node in the
    blockchain network with its integrated EHR system. These hospital nodes together
    form up the blockchain network. Patients and doctors are connected using a web-based
    interface. This interface is used to initiate transactions to share EHR. In this
    solution, a hybrid data management system is used. In this hybrid approach, only
    the management metadata is stored on the chain. An off-chain cloud-based storage,
    Health Insurance Portability and Accountability Act-compliant is used to store
    the EHR data. This data is also encrypted before storing. The shared EHR data
    is secured using digital signatures and public key infrastructure–based asymmetric
    encryption. In this solution, a distributed ledger is used as a shared immutable
    and transparent history of all the actions performed by the users; these actions
    include defining access control policies and sharing, accessing, and modifying
    the data, and though the data is stored in a secured manner using various encryption
    schemes, however, the storage is still a centralized one.
  prefs: []
  type: TYPE_NORMAL
- en: Sun et al. [[5](#CR5)] discuss a blockchain-based framework for electronic medical
    records sharing with fine-grained access control. They have proposed a distributed
    electronic medical records system with a search feature to easily find the records
    using blockchain and smart contract technology. In this solution, firstly, the
    electronic medical data that is obtained undergoes a hash calculation. The corresponding
    hash value obtained is then stored on the blockchain. This is done to ensure the
    authenticity and integrity of data. Then, the InterPlanetary File System (IPFS)
    stores encrypted electronic medical record data. Then the Ethereum blockchain
    is used to store the encrypted keyword index information of the medical records.
    Besides that, keyword search is implemented using a smart contract deployed in
    the Ethereum blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, they use an attribute-based encryption scheme to decrypt encrypted
    electronic medical records and access only by the attributes meeting the access
    policy. This solution uses blockchain and smart contracts to maintain security
    and integrity and IPFS for secure decentralized storage of data. This solution
    makes the storage and access control as decentralized as possible using IPFS,
    blockchain, and smart contracts. Still, the access control system is doctor-centric,
    wherein the doctor or the medical practitioner provides access control to various
    entities, even the patients themselves.
  prefs: []
  type: TYPE_NORMAL
- en: Our solution makes use of Ethereum and smart contracts to allow secure access
    control and IPFS for secure data storage besides using various encryption schemes
    to encrypt the data before storage and sharing. But our solution is completely
    patient-centric. All the power of access control is in the patient’s hands, and
    no one can access any kind of data without the patient’s approval. All this access
    control is encoded into the smart contract and, once deployed, cannot be tampered
    with in any way.
  prefs: []
  type: TYPE_NORMAL
- en: 3 Concepts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Blockchain
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Blockchain burst onto the scene when it was introduced in 2008 in a whitepaper
    by Satoshi Nakamoto, “Bitcoin: A Peer-to-Peer Electronic Cash System.” He introduced
    a revolutionary new cryptocurrency named Bitcoin, wherein blockchain formed the
    underlying decentralized technology of the newly introduced currency. Blockchain
    is essentially a data structure wherein blocks are added one after the other and
    every new block is linked to the previous block through its cryptographic hash,
    forming a blockchain chain.'
  prefs: []
  type: TYPE_NORMAL
- en: The top-most block on the blockchain defines the state of the blockchain at
    any given instance. Blockchain acts as a distributed ledger system. It consists
    of a connected peer-to-peer network of users. This distributed ledger is replicated
    over the whole network on every peer’s system. It consists of transactions that
    are stored together in a block. As more transactions are carried out, they are
    grouped in a new block which is then added to the blockchain. To add a block to
    the blockchain, it must be confirmed by the majority of the peers that form the
    network through what is called a consensus protocol. Every peer sees and confirms
    the current state of the blockchain, and the state that is confirmed by the majority
    is accepted. These peers act according to the consensus algorithm, which allows
    choosing a peer who then adds a block to the blockchain and thus modifies the
    state of the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: The cryptographic linking of blocks ensures that the blockchain system is tamper-proof.
    To create a malicious transaction, a user would need to control the systems of
    more than half of the total peers connected to the network. Since a blockchain
    network can have millions of peers, it is practically impossible for a malicious
    entity to achieve its intentions. This makes sure that the blockchain cannot be
    corrupted.
  prefs: []
  type: TYPE_NORMAL
- en: Transactions are created by accounts owned by anonymous users on the network.
    Their account addresses identify these accounts. Two keys – a private key and
    a public key – are associated with each account. These keys can be stored and
    managed with a wallet [[6](#CR6)]. There are several types of hardware and software
    wallets available. Users can access their accounts using their private key. The
    private key and the public key help create asymmetrically encrypted messages that
    could be sent to the network and create verifiable transactions.
  prefs: []
  type: TYPE_NORMAL
- en: The data stored on a blockchain is visible to everyone but cannot be changed
    or tampered with in any way. The distributed nature of blockchain combined with
    cryptography’s power creates a resilient system against attacks while maintaining
    data privacy and sharing. Thus, the transparency, accountability, and immutability
    associated with the data stored on the blockchain solve the problems of data privacy
    and security related to centralized systems, and the sensitivity of medical records
    necessitate these traits. These traits make blockchain a suitable system for storing
    and managing electronic medical records.
  prefs: []
  type: TYPE_NORMAL
- en: Early cryptocurrencies used blockchain only for recording transactions as a
    distributed ledger, but Ethereum [[7](#CR7)] took it a step further by introducing
    an application layer over the simple blockchain, allowing users to write and execute
    code. Ethereum thus not only stores transactions but can also run scripts, making
    it a distributed computation technology instead of just a ledger. This gave rise
    to the concepts of smart contracts and distributed apps that are at the forefront
    of decentralized technology trying to solve centralization problems and are discussed
    in more detail ahead in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Cryptography Techniques
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This section discusses symmetric and asymmetric cryptography techniques, which
    form the basis of security in our system.
  prefs: []
  type: TYPE_NORMAL
- en: Symmetric Cryptography
  prefs: []
  type: TYPE_NORMAL
- en: Symmetric cryptography or private key encryption makes use of a single secret
    key which is used to encrypt and decrypt data. It ensures that the data cannot
    be decrypted using some other key. Advanced Encryption Standard (AES) is a widely
    used symmetric encryption technique. Good key management is important when using
    this technique.
  prefs: []
  type: TYPE_NORMAL
- en: Asymmetric Cryptography
  prefs: []
  type: TYPE_NORMAL
- en: In asymmetric cryptography or public key encryption, a pair of keys – public
    and private – are used. The public key is distributed, while the private key is
    only known to the encryption initiator and is kept secret. Data once encrypted
    with the public key can only be decrypted with the associated private key. Asymmetric
    cryptography is heavily used in blockchain technology. RSA is one such common
    cryptography technique. It is based on the computational complexity involved in
    factorizing a large integer obtained from two large prime integers. Elliptic curve
    cryptography (ECC) is also a public key encryption technique better than RSA as
    it offers faster computation times and more robust encryption.
  prefs: []
  type: TYPE_NORMAL
- en: IPFS (InterPlanetary File System)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: IPFS [[8](#CR8)] is a peer-to-peer, content-addressed, version-controlled file
    system. This system is decentralized by nature; thus, no single entity has control
    over it. The files in IPFS are replicated over the network of IPFS nodes. Their
    content identifies the files in an IPFS. Instead of identifying data by their
    storage location, called location addressing as done by URLs in today’s internet,
    IPFS uses the content itself in the form of a hash to identify the files in the
    IPFS system; this is called content-based addressing. Thus, IPFS uses a content
    ID (CID) or hash of the content, which represents the content itself, to address
    that data or file over the network. This allows data and files to be stored and
    served from anywhere by anyone.
  prefs: []
  type: TYPE_NORMAL
- en: It works by taking a file and cryptographically hashing it to obtain a small
    and reproducible representation of that file which ensures that every file has
    its unique hash, which can then be used to address the file. This CID is generated
    using Merkel-Tree Directed Acyclic Graphs (DAGs). Merkle DAGs allow distinctively
    identifying all content on IPFS as every data block part of the DAG has its unique
    hash, making the data tamper-proof as altering anything in the data would change
    the hash. Our solution uses IPFS to store all the medical records data.
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ethereum is a blockchain technology that also provides smart contracts integration.
    Ethereum uses Ether (ETH) as its cryptocurrency for transactions. It is a capable
    and robust blockchain platform to implement a decentralized medical records system.
    In the provided solution, smart contracts are used for access control of data,
    and to store the encrypted content ID (CID) or hash of the user data stored on
    the IPFS network. This is a unique feature of Ethereum [[9](#CR9)] to create and
    run decentralized applications (dApps) and smart contracts [[10](#CR10)]. Smart
    contracts are programs that can be used to describe legal documents, assets, and
    agreements and other services between different parties without the involvement
    of a middleman. They are essentially the code running over a distributed network
    known as the Ethereum Virtual Machine. These contracts are tamper-proof, ensuring
    that all the data they hold cannot be manipulated by any parties involved. They
    are visible to anyone who is connected to the Ethereum network.
  prefs: []
  type: TYPE_NORMAL
- en: Patient’s Lifecycle
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In general, a visit to the hospital begins with the patient going to the hospital
    and the hospital requesting the patient to share their previous records, which
    the hospital then uses for diagnosis, treatment, etc.
  prefs: []
  type: TYPE_NORMAL
- en: After providing the treatment, the hospital generates new records for the patient,
    including test results, prescriptions, bills, etc. These records are shared with
    the patient, who is then required to store them safely along with the patient’s
    previous records, if any.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the patient is required to settle the insurance claim about the current
    visit. For this, the insurance company requests the patient to share their medical
    bills and settle claims after due processing. This completes the life cycle for
    a patient’s visit to the hospital.
  prefs: []
  type: TYPE_NORMAL
- en: Every patient has numerous visits to the hospital, each involving all the functions
    described above, which make the process difficult and prone to issues. To solve
    these problems in a decentralized manner, we propose the solution described in
    the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 4 Proposed Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The solution architecture (Fig. [1](#Fig1)) shows the various entities, namely,
    patients (P), hospitals (H), and insurance agencies (A) (on the left) and technologies
    (on the right) that come about to form the solution.![](../images/513458_1_En_3_Chapter/513458_1_En_3_Fig1_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 1
  prefs: []
  type: TYPE_NORMAL
- en: Proposed solution architecture
  prefs: []
  type: TYPE_NORMAL
- en: The technological tools used are blockchain [[11](#CR11)], IPFS [[12](#CR12)],
    and an application interface. This application interface connects directly to
    the Ethereum blockchain and the IPFS storage to implement a secure, private, and
    transparent system which is the main focal point of this solution.
  prefs: []
  type: TYPE_NORMAL
- en: The application interface allows the patients to control which entity can access
    their records. The patient is the most powerful entity in the entire solution
    architecture, which is one of the big unique selling points of this solution as
    it gives the power in the patient’s hands. The hospitals have the ability to add
    new records for the patients and to access their previous records. The insurance
    agencies have the functionality of being able to see the records and settle insurance
    claims. The patient controls these functionalities of hospitals and insurance
    agencies through an authorization mechanism implemented through blockchain transactions.
  prefs: []
  type: TYPE_NORMAL
- en: When authorized by a patient *P* [*i*] ∈ *P*, the hospital *H* [*j*] ∈ *H* stores
    the records generated for the patient’s current hospital visit (v) on the decentralized
    storage solution IPFS. The records stored on the IPFS are encrypted symmetrically
    with an identity number *k* [*Pi*] of the patient *P* [*i*]. After storage, the
    location or the hash of the record *q* [*v*] for the current hospital visit (v)
    is returned by the IPFS.
  prefs: []
  type: TYPE_NORMAL
- en: Let *D* [*v*] be the record generated due to the patient’s current visit to
    the hospital, and AES be a symmetric cryptography function that takes data *D*
    [*k*] and a key *k* [*Pi*], and returns the encrypted data. Thus, the encrypted
    records are
  prefs: []
  type: TYPE_NORMAL
- en: '!['
  prefs: []
  type: TYPE_NORMAL
- en: $$ {e}_v=\mathrm{AES}\left({D}_v, {k}_{Pi}\right) $$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/513458_1_En_3_Chapter/513458_1_En_3_Chapter_TeX_Equa.png)'
  prefs: []
  type: TYPE_NORMAL
- en: If *U* is a functionality provided by IPFS, which takes a piece of data, uploads
    it onto IPFS, and returns a hash or CID, then
  prefs: []
  type: TYPE_NORMAL
- en: '!['
  prefs: []
  type: TYPE_NORMAL
- en: $$ {q}_v=U\ \left({e}_v\right) $$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/513458_1_En_3_Chapter/513458_1_En_3_Chapter_TeX_Equb.png)'
  prefs: []
  type: TYPE_NORMAL
- en: This location or hash *q* [*v*] of records is then added to a file that contains
    details of every hospital visit for the patient in an object in JSON (JavaScript
    Object Notation) format hereafter referred to as the master file ![
  prefs: []
  type: TYPE_NORMAL
- en: $$ {M}_{Pi}^{\prime } $$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/513458_1_En_3_Chapter/513458_1_En_3_Chapter_TeX_IEq1.png) of the
    patient *P* [*i*]. An object *J* [*v*] is created for every hospital visit which
    contains an identifier (name) of hospital *H* [*j*], the date of visit *σ* [*v*],
    the insurance settlement status *δ* [*v*], and the content hash *q* [*v*] (also
    called location hash and content Id) of the stored record.'
  prefs: []
  type: TYPE_NORMAL
- en: '!['
  prefs: []
  type: TYPE_NORMAL
- en: $$ {J}_v=\left({H}_j,{\sigma}_v,{\delta}_v,{q}_v\right) $$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/513458_1_En_3_Chapter/513458_1_En_3_Chapter_TeX_Equc.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Let the current master file be a set of all such *J* [*k*], where *k* = 1*,*
    2*,* 3*,* …*, n* for *n* number of hospital visits,
  prefs: []
  type: TYPE_NORMAL
- en: '!['
  prefs: []
  type: TYPE_NORMAL
- en: $$ {M}_{Pi}^{\prime }=\left\{{J}_1,{J}_2,{J}_3,\dots, {J}_n\right\} $$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/513458_1_En_3_Chapter/513458_1_En_3_Chapter_TeX_Equd.png)After
    adding the data *J* [*v*] to *M* [*Pi*], the new master file, *M* [*P*] ^(*t*),
    will be!['
  prefs: []
  type: TYPE_NORMAL
- en: $$ {M}_{Pi}^{\prime }=\left\{{J}_1,{J}_2,{J}_3,\dots, {J}_n,{J}_v\right\} $$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/513458_1_En_3_Chapter/513458_1_En_3_Chapter_TeX_Eque.png)This newly
    generated master file !['
  prefs: []
  type: TYPE_NORMAL
- en: $$ {M}_{Pi}^{\prime } $$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/513458_1_En_3_Chapter/513458_1_En_3_Chapter_TeX_IEq2.png) is then
    stored on IPFS after symmetric encryption with the identity number *K* [*P*].
    This returns a new location for the master file itself.!['
  prefs: []
  type: TYPE_NORMAL
- en: $$ E=\mathrm{AES}\left({M}_{Pi}^{\prime }, {K}_{Pi}\right)\vspace*{-10pt} $$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/513458_1_En_3_Chapter/513458_1_En_3_Chapter_TeX_Equf.png)!['
  prefs: []
  type: TYPE_NORMAL
- en: $$ Q=U\ (E) $$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/513458_1_En_3_Chapter/513458_1_En_3_Chapter_TeX_Equg.png)'
  prefs: []
  type: TYPE_NORMAL
- en: This location (*Q*) of the master file is then encrypted using asymmetric encryption
    (RSA) and the result (*L*) is stored onto the blockchain via a transaction. The
    various read/write access control functionalities are also managed through several
    blockchain transactions.
  prefs: []
  type: TYPE_NORMAL
- en: RSA takes a piece of data *Q* and a public key *α* [*Pi*] of the patient *P*
    [*i*] and returns an encrypted value.
  prefs: []
  type: TYPE_NORMAL
- en: '!['
  prefs: []
  type: TYPE_NORMAL
- en: $$ L=\mathrm{RSA}\left(Q,\kern0.5em {\alpha}_{Pi}\right) $$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/513458_1_En_3_Chapter/513458_1_En_3_Chapter_TeX_Equh.png)'
  prefs: []
  type: TYPE_NORMAL
- en: This asymmetrically encrypted hash *L* can only be decoded by the secret private
    key of the patient, which is known only to the patient.
  prefs: []
  type: TYPE_NORMAL
- en: The writing functionality is controlled through the patient’s authorization.
    It is limited to the hospital, wherein they can add new records for patients and
    the insurance company, which can settle insurance claims for the patient’s bill
    incurred at the hospital visit. The read functionality is for all the entities,
    but the authorization is again in the patient’s hands. Whenever an entity wishes
    to view the records, the application obtains the records through the blockchain
    and the IPFS, and then presents them on the user interface.
  prefs: []
  type: TYPE_NORMAL
- en: In each read operation, the encrypted location is first decoded by the patient
    using their private key and then shared with the reader entity by symmetrically
    encrypting the decrypted location again using the reader’s public key and sharing
    via the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: 5 Implementation Details
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following section contains the details of the two major components of the
    system: a patient smart contract and the structure of a patient master file.'
  prefs: []
  type: TYPE_NORMAL
- en: Smart Contract Solidity Implementation Pseudo Code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: contract Medicaladdress private owner;string private medicalLocationHash;address
    public reader;address public writer;map(address => string) public readHash;map(address
    => bool) public canWrite;function RevokeRead(address memory readerAddress) publicreadHash[readerAddress]
    = "";function Read(address memory readerAddress) public viewreturns (string memory)return
    readHash[readerAddress];function Write(string memory locationHash,address memorywriterAddress)
    publicrequire(canWrite[writerAddress] == true,"You do not have write permission");medicalLocationHash
    = locationHash;canWrite[writerAddress] = false;function AcquireReadPermission(address
    memoryreaderAddress) publicreader = readerAddress;function AcquireWritePermission(address
    memorywriterAddress) publicwriter = writerAddress;reader = writerAddress;function
    GrantWritePermission(string memoryencryptedLocationHash) publicrequire(owner ==
    msg.sender, "You can not grantwrite permission");require(bytes(writer).length
    != 0, "No writer!");GrantReadPermission(encryptedLocationHash);canWrite[writer]
    = true;writer = "";function GrantReadPermission(string memoryencryptedLocationHash)
    publicrequire(owner == msg.sender, "You can not grantread permission");require(bytes(reader).length
    != 0, "No reader!");readHash[reader] = encryptedLocationHash;reader = "";function
    CheckWritePermission(address memorywriterAddress) public viewreturns (bool)return
    canWrite[writerAddress];function ViewLocationHash() public view returns (stringmemory)return
    medicalLocationHash;function ViewReader() public view returns (stringmemory)return
    reader;function ViewWriter() public view returns (stringmemory)return writer;
  prefs: []
  type: TYPE_NORMAL
- en: Structure of the Patient Master File
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '{patientName,patientDOB,patientSex,[visitOne : {hospitalName,dateOfVisit,claimSettlementStatus,dataOfVisit},visitTwo
    : {hospitalName,dateOfVisit,claimSettlementStatus,dataOfVisit} ...]}'
  prefs: []
  type: TYPE_NORMAL
- en: 6 Workflows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two main operations that the entities in the proposed system perform.
    These are reading the records and writing the records.
  prefs: []
  type: TYPE_NORMAL
- en: Read Operation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The read operation is universal in the system which all the entities can perform.
    In it, various entities can search and access the records of a patient when authorized
    by the respective owner of the records. The read operation is a single-time process.
    When authorized, an entity can access the records only once and is required to
    obtain permission from the owner of the records every time they wish to access
    them again (Fig. [2](#Fig2)).![](../images/513458_1_En_3_Chapter/513458_1_En_3_Fig2_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 2
  prefs: []
  type: TYPE_NORMAL
- en: Read operation
  prefs: []
  type: TYPE_NORMAL
- en: The read operation begins with the hospital (or insurance company) searching
    for the patient in the application user interface and requesting their permission
    to view their records. This action stores the address of the hospital in a variable
    in the smart contract. Now, the patient grants the read permission. This first
    fetches the CID (Content Id), stored in a variable in the smart contract, of the
    master file stored on the IPFS. This CID, which was encrypted with the patient’s
    public key can now be decrypted using their private key. This private key is never
    stored anywhere and is generated using a secret passphrase known only to the patient.
    Now, this decrypted CID of the master file is encrypted using the hospital’s public
    key. This newly encrypted CID is now stored in the smart contract by the patient,
    through a transaction, in the form of a mapping that associates the hospital’s
    public with this CID. This makes sure that now when the hospital goes on to access
    the records, only the hospital with the specific address which was granted permission
    by the patient can do so.
  prefs: []
  type: TYPE_NORMAL
- en: Now the hospital proceeds to view the patient’s records. This is done through
    a smart contract interaction wherein the mapping variable is read. This matches
    the hospital’s address and returns the CID stored in the mapping. This CID was
    encrypted using the hospital’s public key and thus now can only be decrypted using
    their private key. The hospital decrypts the CID by generating their private key
    using their secret passphrase. This decrypted CID is now used to fetch the master
    file from the IPFS. Any of the previous records can now be brought using their
    CID stored in the master file. The obtained records are decrypted further as they
    were encrypted using symmetric encryption using the patient’s unique ID number.
    So, the unique ID number is used to decrypt the records, and they are finally
    displayed on the application interface for the hospital/insurance company to view.
  prefs: []
  type: TYPE_NORMAL
- en: For the patients, read operation is quite simple as they have complete access
    control in their hands. A patient can see their records directly with a click
    in the application interface. The CID is obtained from the smart contract, which
    is owned and controlled by the patient and hence does not require any permission.
    The master file is then obtained from this CID from IPFS, and any record which
    the patient wishes to see is read from its CID stored in the master file.
  prefs: []
  type: TYPE_NORMAL
- en: Write Operation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The write operation is wherein the hospital writes the records generated and
    the insurance company settles the bill generated at the patient’s visit to the
    hospital. The patient is not allowed to do any kind of write operation.
  prefs: []
  type: TYPE_NORMAL
- en: For the write operation, the hospital first searches for the patient in the
    application interface and requests the patient to be allowed to add new records.
    This authorization mechanism is written into the blockchain smart contract and
    thus cannot be tampered with. When the hospital asks for the write permission,
    it sends its address as a parameter to the smart contract where a mapping is then
    stored between the username and a Boolean value of true or false, which indicates
    if the username is allowed to write to the smart contract or not. After the hospital
    makes the write request, the patient logs into their account and grants the write
    permission wherein a call to the smart contract is created, which updates the
    mapping of the hospital’s username to be true; this authorization can only be
    issued by the owner of the smart contract, that is, the patient. Now the hospital
    is ready to add new records for the patient (Fig. [3](#Fig3)).![](../images/513458_1_En_3_Chapter/513458_1_En_3_Fig3_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 3
  prefs: []
  type: TYPE_NORMAL
- en: Write operation for hospital
  prefs: []
  type: TYPE_NORMAL
- en: Once the permission is granted, the application interface on the hospital side
    redirects to a form wherein all details regarding the patient’s visit can be filled
    and any photos or documents can be attached. When the hospital submits the record,
    it is first encrypted with symmetric encryption using the patient’s unique ID
    number as the key and then stored on the IPFS, which returns the CID associated
    with this stored record. Now the master file is fetched from the IPFS. This CID
    of the stored record is added to the master file and other details like the date
    of visit and the hospital’s name and the insurance settlement status in a JavaScript
    object and the master file is in JSON format. Now, this master file is stored
    on IPFS and a CID is obtained. This CID of the master file is then encrypted using
    the patient’s public key and stored in the smart contract. This completes the
    write operation for the hospital. Note that a write operation permission grant
    comes with the permission to read records inherently.
  prefs: []
  type: TYPE_NORMAL
- en: For the insurance company, the permission requesting and allowing procedure
    is similar to that of the hospital. The difference is that when allowed by the
    patient, the hospital is redirected to a record page wherein they can add a new
    record. In contrast, the insurance company is redirected to a settle claim page
    wherein they can simply view and settle the insurance claim for the patient. The
    insurance claim settlement status is saved as a mapping of true or false in the
    master file in an object pertaining to that visit. When the insurance company
    settles the claim, the mapping is made to be true and the claim is expected to
    have been settled. This changing of mapping generates a new CID when the changed
    master file is stored on IPFS. This new CID is stored in the smart contract, encrypted
    with the patient’s public key. This completes the write operation for the insurance
    company (Fig. [4](#Fig4)).![](../images/513458_1_En_3_Chapter/513458_1_En_3_Fig4_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 4
  prefs: []
  type: TYPE_NORMAL
- en: Write operation for insurance company
  prefs: []
  type: TYPE_NORMAL
- en: 7 Analysis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Security and Accessibility
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In our solution, we have used blockchain and IPFS for the storage of data, combined
    with various encryption schemes at every step. The blockchain allows secure, untameable
    recording of transactions and integrated with smart contract functionality. It
    produces one of the most efficient and secure systems to date. The system is more
    transparent due to the public ledger, more secure as it is a distributed system
    without any central point of failure, and more accessible and interoperable as
    it is always available, for anyone, anywhere around the world.
  prefs: []
  type: TYPE_NORMAL
- en: IPFS as the storage solution, a distributed system like blockchain, provides
    similar accessibility and interoperability benefits. The content addressing feature
    of IPFS provides integrity and security to the system, ensuring that the data
    is not changed or tampered with.
  prefs: []
  type: TYPE_NORMAL
- en: Encryption schemes are used for secure storage and sharing of data. The patient
    data is symmetrically encrypted with a key known to the patient and the location
    of the data is again asymmetrically encrypted with a private key of the patient.
    And every time it is shared, it is encrypted such that only the person who has
    been allowed by the patient can decrypt and access the data.
  prefs: []
  type: TYPE_NORMAL
- en: The use of blockchain, IPFS, and encryption techniques at every step of data
    storage and sharing makes the data almost impossible to tamper with in any way
    and makes the system more secure, accessible, and interoperable.
  prefs: []
  type: TYPE_NORMAL
- en: Privacy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our solution has privacy-aware access control with the patient at its center.
    From data generation, to storage and sharing, every step has access control in
    the hands of the patient. We have stored the data using a combination of symmetric
    and asymmetric encryption techniques with keys decided and owned by the patient,
    making the patient the real owner of their data. Giving the power of access control
    in the hands of patients, through untamperable smart contract code, makes our
    solution completely patient-centric. No one can access or use any kind of data
    belonging to a person without their explicit permission. To gain access to data,
    any entity needs the decrypted CID and the unique patient ID, which only resides
    with and can be managed by the patient. Thus, patient privacy and data ownership
    are the main USP of our solution and are ensured in the strictest ways possible.
  prefs: []
  type: TYPE_NORMAL
- en: 8 Conclusion and Future Work
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter examined and developed a system for applying blockchain technology
    in maintaining medical health records more securely and privately than the current
    systems permit. Blockchain is the technology at the forefront of the current decentralization
    revolution, which aims to provide more security and privacy to every field that
    uses technological solutions. Medical records is one field that is in dire need
    of such revolutionary solutions, given the sensitivity and importance of such
    records. Our solution of electronic medical records based on blockchain improves
    security, accessibility, and interoperability, over traditional records-keeping
    systems, all at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Future Work
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The current version of the application uses Ethereum for blockchain purposes.
    The time and cost associated with each Ethereum transaction is very high due to
    the large network of nodes that come to a consensus over each transaction, and
    at the current growth of the technology, these costs and time are bound to increase
    more so in the future. This high cost reduces the feasibility of the current solution.
    A different blockchain technology that uses a different consensus algorithm might
    help reduce these costs. The balance between costs and decentralization needs
    to be assessed to find the most optimal solution for these other blockchain technologies.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from that, the current solution uses asymmetric encryption based on RSA
    keys derived from a passphrase that needs to be remembered by the entity. Remembering
    the passphrase along with having strong passphrases is essential in keeping data
    secure in the application. However, remembering such passphrases becomes challenging,
    so encryption techniques like biometric encryption could improve the solution
    and make it easier to use. Effectiveness with different encryption techniques
    without compromising security needs to be assessed to reach the most optimal solution.
  prefs: []
  type: TYPE_NORMAL
- en: Also, the current solution provides complete functional support for the previously
    listed entities, that is, patient, hospitals, and insurance agencies. However,
    this solution can be further extended to providing bulk data for research purposes
    and keeping patients in control of their data.
  prefs: []
  type: TYPE_NORMAL
