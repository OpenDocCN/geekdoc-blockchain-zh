- en: consortium chains), the lower bound is 2F + 1, where F is the number
  prefs: []
  type: TYPE_NORMAL
- en: of faults.
  prefs: []
  type: TYPE_NORMAL
- en: • In proof of work–based blockchains, it is the <50% of the hash power.
  prefs: []
  type: TYPE_NORMAL
- en: '**Finality**'
  prefs: []
  type: TYPE_NORMAL
- en: • Finality occurs when a transaction is considered irrevocable
  prefs: []
  type: TYPE_NORMAL
- en: and permanent. This event can be a certain number of blocks, a
  prefs: []
  type: TYPE_NORMAL
- en: time interval, or a step (phase) in the execution of a consensus
  prefs: []
  type: TYPE_NORMAL
- en: algorithm. For example, in Bitcoin it is usually six blocks after
  prefs: []
  type: TYPE_NORMAL
- en: which a transaction is considered irrevocable, and in permissioned
  prefs: []
  type: TYPE_NORMAL
- en: blockchains using BFT protocols, the moment the transaction is
  prefs: []
  type: TYPE_NORMAL
- en: committed, it is considered irrevocably final.
  prefs: []
  type: TYPE_NORMAL
- en: '176'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 4 BloCkChain
  prefs: []
  type: TYPE_NORMAL
- en: '**Immutability**'
  prefs: []
  type: TYPE_NORMAL
- en: • Blockchains are immutable, which means that once a record has
  prefs: []
  type: TYPE_NORMAL
- en: made it to the ledger, it can never be removed.
  prefs: []
  type: TYPE_NORMAL
- en: '**Append Only**'
  prefs: []
  type: TYPE_NORMAL
- en: • New records can only be appended to the blockchain. New records
  prefs: []
  type: TYPE_NORMAL
- en: cannot be inserted in between previously existing records. For
  prefs: []
  type: TYPE_NORMAL
- en: example, a new block can only be added after the last final block, not
  prefs: []
  type: TYPE_NORMAL
- en: in between other blocks.
  prefs: []
  type: TYPE_NORMAL
- en: • Formally, if a block b’ is inserted after a block b, then a new block b”
  prefs: []
  type: TYPE_NORMAL
- en: can only be inserted after b’ and not before b’ or b.
  prefs: []
  type: TYPE_NORMAL
- en: '**Tamper Resistant/Proof**'
  prefs: []
  type: TYPE_NORMAL
- en: • It is practically impossible to remove or rearrange finalized blocks in
  prefs: []
  type: TYPE_NORMAL
- en: a blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: • It is arguable whether a blockchain is tamper resistant or tamper-
  prefs: []
  type: TYPE_NORMAL
- en: proof, but for all practical purposes, the probability that some
  prefs: []
  type: TYPE_NORMAL
- en: adversary can remove or rearrange blocks or transactions becomes
  prefs: []
  type: TYPE_NORMAL
- en: almost zero. This guarantee is good enough for all practical purposes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Validity**'
  prefs: []
  type: TYPE_NORMAL
- en: • Only valid transactions and blocks are appended to the blockchain
  prefs: []
  type: TYPE_NORMAL
- en: '**Termination Guarantee of Blockchain Operations: get(), append(), verify()**'
  prefs: []
  type: TYPE_NORMAL
- en: • Eventually, all the operations will terminate with a result.
  prefs: []
  type: TYPE_NORMAL
- en: '**Order**'
  prefs: []
  type: TYPE_NORMAL
- en: • If a block x happens before block y and block y happens before block z,
  prefs: []
  type: TYPE_NORMAL
- en: then block x happens before block z and forms a transitive relationship.
  prefs: []
  type: TYPE_NORMAL
- en: • In practice, this is a chronologically ordered chain of blocks.
  prefs: []
  type: TYPE_NORMAL
- en: • It is an ordered ledger.
  prefs: []
  type: TYPE_NORMAL
- en: '177'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 4 BloCkChain
  prefs: []
  type: TYPE_NORMAL
- en: '**Verifiable**'
  prefs: []
  type: TYPE_NORMAL
- en: • All transactions and blocks in a blockchain are verifiable and adhere
  prefs: []
  type: TYPE_NORMAL
- en: to a validity predicate specific to the blockchain. Anyone can verify
  prefs: []
  type: TYPE_NORMAL
- en: the validity of a transaction.
  prefs: []
  type: TYPE_NORMAL
- en: Consensus-specific properties are discussed in more detail in Chapter [5](https://doi.org/10.1007/978-1-4842-8179-6_5).
  prefs: []
  type: TYPE_NORMAL
- en: Some other properties include programmability (smart contract support), encrypted
  prefs: []
  type: TYPE_NORMAL
- en: ledger and anonymity for confidentiality and user privacy, and unanimity for
    allowing
  prefs: []
  type: TYPE_NORMAL
- en: unanimous decisions on appending new blocks.
  prefs: []
  type: TYPE_NORMAL
- en: A blockchain can also be seen as a state machine replication protocol. A blockchain
  prefs: []
  type: TYPE_NORMAL
- en: and a state machine appear to be the same; however, there’s a subtle difference.
    In a
  prefs: []
  type: TYPE_NORMAL
- en: state machine, only the latest state is stored in the log, whereas in a blockchain
    state
  prefs: []
  type: TYPE_NORMAL
- en: machine, the entire history is stored and available when queried.
  prefs: []
  type: TYPE_NORMAL
- en: Bitcoin and blockchains have outpaced the growth of the Internet. Thousands
    of
  prefs: []
  type: TYPE_NORMAL
- en: users are using Bitcoin daily. On average, about 200,000 transactions are processed
    on
  prefs: []
  type: TYPE_NORMAL
- en: Bitcoin daily. On Ethereum, roughly more than a million transactions are processed
  prefs: []
  type: TYPE_NORMAL
- en: daily, and the interest is growing. Contrary to a reasonable belief held by
    some, I think it is not correct to say that the Bitcoin experiment has failed.
    It has accomplished what it set out to achieve, peer-to-peer digital cash. That’s
    what it is and is being used as a digital cash platform today. Bitcoin also stimulated
    further innovation, and platforms
  prefs: []
  type: TYPE_NORMAL
- en: like Ethereum and now the latest blockchains like Polkadot and Cardano have
    emerged.
  prefs: []
  type: TYPE_NORMAL
- en: With such a level of growth, in the next eight to ten years, I believe almost
    all financial services will run on a blockchain, including some central bank digital
    currencies.
  prefs: []
  type: TYPE_NORMAL
- en: '**How Blockchain Works**'
  prefs: []
  type: TYPE_NORMAL
- en: At times, there are subtle differences in the way a blockchain works at a micro
    level;
  prefs: []
  type: TYPE_NORMAL
- en: 'however, at a high level all blockchains principally work the same. In the
    following, I list seven key steps that show how a blockchain works:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. A transaction occurs between two or more users.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. The transaction is broadcast to the network.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. The transaction is validated and added to the transaction pools.
  prefs: []
  type: TYPE_NORMAL
- en: '178'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-197_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 4 BloCkChain
  prefs: []
  type: TYPE_NORMAL
- en: 4\. A proposed block is created by adding transactions to it by miners.
  prefs: []
  type: TYPE_NORMAL
- en: 5\. Miners race to solve the proof of work to win the right to insert their
  prefs: []
  type: TYPE_NORMAL
- en: block into the blockchain, or a consensus mechanism runs to agree
  prefs: []
  type: TYPE_NORMAL
- en: on the transactions. Usually, miners run a proof of work type of
  prefs: []
  type: TYPE_NORMAL
- en: consensus mechanism to win the right to add a block. In consortium
  prefs: []
  type: TYPE_NORMAL
- en: or private chains, usually a variant of traditional Byzantine or
  prefs: []
  type: TYPE_NORMAL
- en: crash fault–tolerant algorithm runs, which by voting achieves the
  prefs: []
  type: TYPE_NORMAL
- en: agreement on a block which is then inserted into the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: 6\. If a miner wins the right, it inserts the block in its local chain and
  prefs: []
  type: TYPE_NORMAL
- en: broadcasts that block to the network.
  prefs: []
  type: TYPE_NORMAL
- en: 7\. Other nodes accept it if valid, and the process starts again.
  prefs: []
  type: TYPE_NORMAL
- en: This process can be visualized in Figur[e 4-3\.](#p197)
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 4-3\.** How a blockchain works*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Anatomy of a Blockchain**'
  prefs: []
  type: TYPE_NORMAL
- en: A blockchain is composed of blocks, where each block is linked to its previous
    block
  prefs: []
  type: TYPE_NORMAL
- en: except the first genesis block. The blockchain term was used by Satoshi Nakamoto
    in
  prefs: []
  type: TYPE_NORMAL
- en: his Bitcoin code for the first time. Even though now it is used as one word,
    in his original Bitcoin code it was written as two separate words, “block chain.”
    It can be visualized as a chain of blocks, as shown in Figure [4-4](#p198).
  prefs: []
  type: TYPE_NORMAL
- en: '179'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-198_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](index-198_2.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 4 BloCkChain
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 4-4\.** Generic structure of a blockchain*'
  prefs: []
  type: TYPE_NORMAL
- en: Other structures such as DAGs, hash graphs, and Merkle trees are now used in
    some
  prefs: []
  type: TYPE_NORMAL
- en: distributed ledgers instead of the usual block-based model in modern blockchains.
    For
  prefs: []
  type: TYPE_NORMAL
- en: example, Avalanche uses DAGs for storage instead of a linear block-based structure.
  prefs: []
  type: TYPE_NORMAL
- en: We will cover these in detail when we discuss consensus protocols specific to
    these
  prefs: []
  type: TYPE_NORMAL
- en: blockchains (distributed ledgers) in Chapter [8](https://doi.org/10.1007/978-1-4842-8179-6_8).
  prefs: []
  type: TYPE_NORMAL
- en: '**Block**'
  prefs: []
  type: TYPE_NORMAL
- en: A block consists of a block header and transactions. A block header is composed
    of
  prefs: []
  type: TYPE_NORMAL
- en: several fields. A generic depiction is shown in Figure [4-5](#p198).
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 4-5\.** Generic block structure*'
  prefs: []
  type: TYPE_NORMAL
- en: '180'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 4 BloCkChain
  prefs: []
  type: TYPE_NORMAL
- en: Later in this chapter, in the section on blockchains, where I introduce Bitcoin
  prefs: []
  type: TYPE_NORMAL
- en: and other blockchains, I will discuss a more detailed design of blocks specific
    to
  prefs: []
  type: TYPE_NORMAL
- en: that blockchain. However, the structure is fundamentally like a block header
    and
  prefs: []
  type: TYPE_NORMAL
- en: transactions, pointing to the previous block by including the hash of the last
    header
  prefs: []
  type: TYPE_NORMAL
- en: block in the current block header, thus creating a verifiable linked list.
  prefs: []
  type: TYPE_NORMAL
- en: '**Platforms**'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will describe two major blockchain platforms, Bitcoin and
    Ethereum.
  prefs: []
  type: TYPE_NORMAL
- en: '**Bitcoin**'
  prefs: []
  type: TYPE_NORMAL
- en: Bitcoin was invented in 2008 as the first blockchain by Satoshi Nakamoto. However,
    it is
  prefs: []
  type: TYPE_NORMAL
- en: believed to be a pseudonym as the identity of Satoshi Nakamoto is shrouded in
    mystery.
  prefs: []
  type: TYPE_NORMAL
- en: After the introduction of Bitcoin, Satoshi remained active for some time but
    left the
  prefs: []
  type: TYPE_NORMAL
- en: community abruptly. Since then, no contact has been made by him.
  prefs: []
  type: TYPE_NORMAL
- en: We discussed the prehistory and attempts to create digital cash and document
  prefs: []
  type: TYPE_NORMAL
- en: timestamping system before in this chapter. In this section, I will jump straight
    into
  prefs: []
  type: TYPE_NORMAL
- en: technical details.
  prefs: []
  type: TYPE_NORMAL
- en: Bitcoin is a peer-to-peer electronic cash system that solved the double-spending
  prefs: []
  type: TYPE_NORMAL
- en: problem without requiring a trusted third party. Furthermore, Bitcoin has this
    fantastic
  prefs: []
  type: TYPE_NORMAL
- en: property called “inclusive accountability,” which means that anyone on the Bitcoin
  prefs: []
  type: TYPE_NORMAL
- en: network can verify claims of possession of electronic cash, that is, the Bitcoin.
    This
  prefs: []
  type: TYPE_NORMAL
- en: property makes Bitcoin a transparent and verifiable electronic cash system.
  prefs: []
  type: TYPE_NORMAL
- en: The Bitcoin network is composed of nodes. There are three types of nodes in
    a
  prefs: []
  type: TYPE_NORMAL
- en: 'Bitcoin network: miner nodes, full nodes, and light nodes. Miner nodes perform
    mining'
  prefs: []
  type: TYPE_NORMAL
- en: and keep a full copy of the chain. Bitcoin is a loosely coupled network composed
    of
  prefs: []
  type: TYPE_NORMAL
- en: nodes. All nodes communicate with each other using a peer-to-peer gossip protocol.
  prefs: []
  type: TYPE_NORMAL
- en: '**Bitcoin Node and Architecture**'
  prefs: []
  type: TYPE_NORMAL
- en: In practical terms, a node in a distributed system runs the distributed algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, in Bitcoin, a node runs the software client called Bitcoin Core.
    It can run on several types of hardware, including Intel and ARM processors. Also,
    the supported
  prefs: []
  type: TYPE_NORMAL
- en: operating systems are Mac OS, Linux, and Windows.
  prefs: []
  type: TYPE_NORMAL
- en: '181'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-200_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 4 BloCkChain
  prefs: []
  type: TYPE_NORMAL
- en: There are primarily three different types of nodes in the Bitcoin network. Full
    nodes
  prefs: []
  type: TYPE_NORMAL
- en: keep the entire history of the blockchain. Miner nodes keep the whole history
    and
  prefs: []
  type: TYPE_NORMAL
- en: participate in mining to add new blocks to the blockchain. Finally, light nodes
    do not
  prefs: []
  type: TYPE_NORMAL
- en: keep a copy of the entire blockchain. Instead, they only download the block
    headers
  prefs: []
  type: TYPE_NORMAL
- en: and use a method called simple payment verification to validate the authenticity
    of the
  prefs: []
  type: TYPE_NORMAL
- en: transactions. The Bitcoin node architecture is shown in Figure [4-6](#p200).
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 4-6\.** Bitcoin node architecture*'
  prefs: []
  type: TYPE_NORMAL
- en: When a node starts up, it discovers other nodes using a process called node
  prefs: []
  type: TYPE_NORMAL
- en: discovery. In this process, the node first connects to the seed nodes, which
    are trusted
  prefs: []
  type: TYPE_NORMAL
- en: bootstrap nodes maintained by the core developers. After this initial connection,
  prefs: []
  type: TYPE_NORMAL
- en: further connections are made. At one point, there are x connections alive with
    other
  prefs: []
  type: TYPE_NORMAL
- en: peers. There is also spam protection built in the Bitcoin protocol, where a
    points-based
  prefs: []
  type: TYPE_NORMAL
- en: reputation system scores the nodes based on the connection attempts it is trying
    to
  prefs: []
  type: TYPE_NORMAL
- en: make. If a node sends excessive messages to another node, its reputation score
    goes
  prefs: []
  type: TYPE_NORMAL
- en: above a threshold of 100 points, and it gets blocked for 24 hours. The node
    discovery
  prefs: []
  type: TYPE_NORMAL
- en: and handshake between nodes rely on several protocol messages. A list is shown
    in the
  prefs: []
  type: TYPE_NORMAL
- en: following with their explanations. In Figur[e 4-7, y](#p202)ou can visualize
    how node handshake and message exchange occurs.
  prefs: []
  type: TYPE_NORMAL
- en: '182'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 4 BloCkChain
  prefs: []
  type: TYPE_NORMAL
- en: Some of the most used protocol messages and an explanation of them are listed
    as
  prefs: []
  type: TYPE_NORMAL
- en: 'follows:'
  prefs: []
  type: TYPE_NORMAL
- en: • **Version:** This is the first message that a node sends out to the network,
  prefs: []
  type: TYPE_NORMAL
- en: advertising its version and block count. The remote node then replies
  prefs: []
  type: TYPE_NORMAL
- en: with the same information, and the connection is then established.
  prefs: []
  type: TYPE_NORMAL
- en: • **Verack:** This is the response of the version message accepting the
  prefs: []
  type: TYPE_NORMAL
- en: connection request.
  prefs: []
  type: TYPE_NORMAL
- en: • **Inv:** This is used by nodes to advertise their knowledge of blocks and
  prefs: []
  type: TYPE_NORMAL
- en: transactions.
  prefs: []
  type: TYPE_NORMAL
- en: • **Getdata:** This is a response to inv, requesting a single block or
  prefs: []
  type: TYPE_NORMAL
- en: transaction identified by its hash.
  prefs: []
  type: TYPE_NORMAL
- en: • **Getblocks:** This returns an inv packet containing the list of all blocks
  prefs: []
  type: TYPE_NORMAL
- en: starting after the last known hash or 500 blocks.
  prefs: []
  type: TYPE_NORMAL
- en: • **Getheaders:** This is used to request block headers in a
  prefs: []
  type: TYPE_NORMAL
- en: specified range.
  prefs: []
  type: TYPE_NORMAL
- en: • **Tx:** This is used to send a transaction as a response to the getdata
  prefs: []
  type: TYPE_NORMAL
- en: protocol message.
  prefs: []
  type: TYPE_NORMAL
- en: • **Block:** This sends a block in response to the getdata protocol
  prefs: []
  type: TYPE_NORMAL
- en: message.
  prefs: []
  type: TYPE_NORMAL
- en: • **Headers:** This packet returns up to 2000 block headers as a reply to
  prefs: []
  type: TYPE_NORMAL
- en: the getheaders request.
  prefs: []
  type: TYPE_NORMAL
- en: • **Getaddr:** This is sent as a request to get information about
  prefs: []
  type: TYPE_NORMAL
- en: known peers.
  prefs: []
  type: TYPE_NORMAL
- en: • **Addr:** This provides information about nodes on the network. It
  prefs: []
  type: TYPE_NORMAL
- en: contains the number of addresses and address list in the form of an
  prefs: []
  type: TYPE_NORMAL
- en: IP address and port number.
  prefs: []
  type: TYPE_NORMAL
- en: • **Ping:** This message is used to confirm if the TCP/IP network
  prefs: []
  type: TYPE_NORMAL
- en: connection is active.
  prefs: []
  type: TYPE_NORMAL
- en: • **Pong:** This message is the response to a ping message confirming
  prefs: []
  type: TYPE_NORMAL
- en: that the network connection is live.
  prefs: []
  type: TYPE_NORMAL
- en: We can see these messages in use in Figur[e 4-7\.](#p202)
  prefs: []
  type: TYPE_NORMAL
- en: '183'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-202_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 4 BloCkChain
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 4-7\.** Node discovery and handshake diagram + header and block*'
  prefs: []
  type: TYPE_NORMAL
- en: '*synchronization*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Cryptography in Bitcoin**'
  prefs: []
  type: TYPE_NORMAL
- en: Cryptography plays a vital role in the Bitcoin blockchain. The entire security
    of
  prefs: []
  type: TYPE_NORMAL
- en: the Bitcoin blockchain is indeed based on cryptography. Although we discussed
  prefs: []
  type: TYPE_NORMAL
- en: cryptography in Chapt[er 2, I w](https://doi.org/10.1007/978-1-4842-8179-6_2)ill
    now describe which cryptographic protocols are used in Bitcoin and how.
  prefs: []
  type: TYPE_NORMAL
- en: '**Public Keys and Private Keys**'
  prefs: []
  type: TYPE_NORMAL
- en: Private keys prove the ownership of bitcoins and users use them to authorize
    a payment
  prefs: []
  type: TYPE_NORMAL
- en: by signing the transactions with the private key.
  prefs: []
  type: TYPE_NORMAL
- en: The SHA-256 hash function is used in a proof of work algorithm. There is also
    a
  prefs: []
  type: TYPE_NORMAL
- en: Base58 encoder in the Bitcoin client, which is used to encode the addresses
    in a readable format in Bitcoin.
  prefs: []
  type: TYPE_NORMAL
- en: '184'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-203_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 4 BloCkChain
  prefs: []
  type: TYPE_NORMAL
- en: Wallets in Bitcoin are used to store cryptographic keys. Wallets sign transactions
  prefs: []
  type: TYPE_NORMAL
- en: using private keys. Private keys are generated by randomly choosing a 256-bit
  prefs: []
  type: TYPE_NORMAL
- en: number provided by the wallet. A Bitcoin client includes a standard wallet called
  prefs: []
  type: TYPE_NORMAL
- en: nondeterministic wallet.
  prefs: []
  type: TYPE_NORMAL
- en: '**Addresses and Accounts**'
  prefs: []
  type: TYPE_NORMAL
- en: Users are represented by accounts in Bitcoin. The Bitcoin address generation
    process is
  prefs: []
  type: TYPE_NORMAL
- en: shown in Figure [4-8](#p203).
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 4-8\.** Bitcoin address generation*'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. In the first step, we have a randomly generated ECDSA private key.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. The public key is derived from the ECDSA private key.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. The public key is hashed using the SHA-256 cryptographic hash
  prefs: []
  type: TYPE_NORMAL
- en: function.
  prefs: []
  type: TYPE_NORMAL
- en: 4\. The hash generated in step 3 is hashed using the RIPEMD-160
  prefs: []
  type: TYPE_NORMAL
- en: hash function.
  prefs: []
  type: TYPE_NORMAL
- en: 5\. The version number is prefixed to the RIPEMD-160 hash
  prefs: []
  type: TYPE_NORMAL
- en: generated in step 4\.
  prefs: []
  type: TYPE_NORMAL
- en: 6\. The result produced in step 5 is hashed using the SHA-256
  prefs: []
  type: TYPE_NORMAL
- en: cryptographic hash function.
  prefs: []
  type: TYPE_NORMAL
- en: '185'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-204_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 4 BloCkChain
  prefs: []
  type: TYPE_NORMAL
- en: 7\. SHA-256 is applied again.
  prefs: []
  type: TYPE_NORMAL
- en: 8\. The first 4 bytes of the result produced from step 7 is the address
  prefs: []
  type: TYPE_NORMAL
- en: checksum.
  prefs: []
  type: TYPE_NORMAL
- en: 9\. This checksum is appended to the RIPEMD-160 hash generated
  prefs: []
  type: TYPE_NORMAL
- en: in step 4\.
  prefs: []
  type: TYPE_NORMAL
- en: 10\. The resultant byte string is encoded into a Base58-encoded string
  prefs: []
  type: TYPE_NORMAL
- en: by applying the Base58 encoding function.
  prefs: []
  type: TYPE_NORMAL
- en: 11\. Finally, the result is a typical Bitcoin address.
  prefs: []
  type: TYPE_NORMAL
- en: '**Transactions and UTXO Model**'
  prefs: []
  type: TYPE_NORMAL
- en: Transactions are the fundamental unit of operation in Bitcoin. Every transaction
    is
  prefs: []
  type: TYPE_NORMAL
- en: composed of at least one input and output. An unspent transaction output (UTXO)
    is the
  prefs: []
  type: TYPE_NORMAL
- en: basic unit of bitcoin transactions. The transaction inputs refer to the previous
    transaction’s UTXOs. The transaction output represents the transfer of ownership
    of unspent values.
  prefs: []
  type: TYPE_NORMAL
- en: The account balance in bitcoin for an account is the sum of all unspent outputs
    belonging to that account. Therefore, UTXO always must have equal inputs and outputs.
  prefs: []
  type: TYPE_NORMAL
- en: A bitcoin transaction consumes inputs and creates outputs with specified values.
  prefs: []
  type: TYPE_NORMAL
- en: Every input is an output from a previous transaction. This transaction model
    is shown in
  prefs: []
  type: TYPE_NORMAL
- en: Figur[e 4-9\.](#p204)
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 4-9\.** Bitcoin transaction UTXO model*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Bitcoin transaction life cycle is described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: • A user creates a transaction.
  prefs: []
  type: TYPE_NORMAL
- en: • The transaction is signed by the owner(s) using the private key.
  prefs: []
  type: TYPE_NORMAL
- en: '186'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 4 BloCkChain
  prefs: []
  type: TYPE_NORMAL
- en: • The transaction is broadcast to the network using the gossip protocol.
  prefs: []
  type: TYPE_NORMAL
- en: • All nodes verify the transaction and place it in their transaction pools.
  prefs: []
  type: TYPE_NORMAL
- en: • Miner nodes bundle up these transactions into a candidate block.
  prefs: []
  type: TYPE_NORMAL
- en: • Mining starts and one of the miners that solves the proof of work
  prefs: []
  type: TYPE_NORMAL
- en: problem wins the right to announce its block and earn bitcoins as
  prefs: []
  type: TYPE_NORMAL
- en: a reward.
  prefs: []
  type: TYPE_NORMAL
- en: • Once the block is broadcast to the network, it is propagated across
  prefs: []
  type: TYPE_NORMAL
- en: the entire Bitcoin network.
  prefs: []
  type: TYPE_NORMAL
- en: • After six confirmations (six blocks), the transaction is considered
  prefs: []
  type: TYPE_NORMAL
- en: irrevocably final; however, it is possible to accept transactions even
  prefs: []
  type: TYPE_NORMAL
- en: after the first confirmation.
  prefs: []
  type: TYPE_NORMAL
- en: A transaction is made up of several fields. Table [4-1](#p205) shows all fields
    and their description.
  prefs: []
  type: TYPE_NORMAL
- en: '***Table 4-1\.** Bitcoin transaction*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Field**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Description**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Size**'
  prefs: []
  type: TYPE_NORMAL
- en: Version no
  prefs: []
  type: TYPE_NORMAL
- en: Currently 1
  prefs: []
  type: TYPE_NORMAL
- en: 4 bytes
  prefs: []
  type: TYPE_NORMAL
- en: Flag
  prefs: []
  type: TYPE_NORMAL
- en: Witness data indicator
  prefs: []
  type: TYPE_NORMAL
- en: optional 2-byte array
  prefs: []
  type: TYPE_NORMAL
- en: in-counter
  prefs: []
  type: TYPE_NORMAL
- en: number of inputs
  prefs: []
  type: TYPE_NORMAL
- en: 1–9 bytes
  prefs: []
  type: TYPE_NORMAL
- en: list of inputs
  prefs: []
  type: TYPE_NORMAL
- en: inputs
  prefs: []
  type: TYPE_NORMAL
- en: Many inputs
  prefs: []
  type: TYPE_NORMAL
- en: out-counter
  prefs: []
  type: TYPE_NORMAL
- en: number of outputs
  prefs: []
  type: TYPE_NORMAL
- en: 1–9 bytes
  prefs: []
  type: TYPE_NORMAL
- en: list of outputs
  prefs: []
  type: TYPE_NORMAL
- en: outputs list
  prefs: []
  type: TYPE_NORMAL
- en: Many outputs
  prefs: []
  type: TYPE_NORMAL
- en: Witnesses
  prefs: []
  type: TYPE_NORMAL
- en: list of witnesses
  prefs: []
  type: TYPE_NORMAL
- en: Variable
  prefs: []
  type: TYPE_NORMAL
- en: lock_time
  prefs: []
  type: TYPE_NORMAL
- en: Block height or timestamp until transaction is pending
  prefs: []
  type: TYPE_NORMAL
- en: 4 bytes
  prefs: []
  type: TYPE_NORMAL
- en: Transactions are of two types. On-chain transactions are native to the Bitcoin
  prefs: []
  type: TYPE_NORMAL
- en: network, and off-chain transactions are performed outside the blockchain network.
  prefs: []
  type: TYPE_NORMAL
- en: On-chain transactions occur on the blockchain network and are validated on-chain
  prefs: []
  type: TYPE_NORMAL
- en: by network participants, whereas off-chain transactions use payment channels
    or
  prefs: []
  type: TYPE_NORMAL
- en: '187'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 4 BloCkChain
  prefs: []
  type: TYPE_NORMAL
- en: sidechains to perform transactions. On-chain transactions are slower, have privacy
  prefs: []
  type: TYPE_NORMAL
- en: issues, and are not scalable. Off-chain mechanisms aim to solve these issues.
    One prime
  prefs: []
  type: TYPE_NORMAL
- en: example is the Bitcoin lightning network, which provides faster payments.
  prefs: []
  type: TYPE_NORMAL
- en: '**Bitcoin Script and Miniscript**'
  prefs: []
  type: TYPE_NORMAL
- en: A Bitcoin script is a non-Turing complete, stack-based language which is used
    to
  prefs: []
  type: TYPE_NORMAL
- en: describe how bitcoins should be transferred. The scripts are evaluated from
    left to right in a LIFO stack. Scripts are composed of two components, elements
    and operations, as
  prefs: []
  type: TYPE_NORMAL
- en: shown in Figure [4-10\. E](#p207)lements represent data such as digital signatures,
    and operations are the actions that are performed by the script. Operations are
    coded as opcodes.
  prefs: []
  type: TYPE_NORMAL
- en: Opcodes include operational categories such as flow control, stack operations,
    bitwise
  prefs: []
  type: TYPE_NORMAL
- en: logical operations, arithmetic, cryptography operations, and lock time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some common opcodes are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: • **OP_CHECKSIG:** Takes a signature and a public key and verifies
  prefs: []
  type: TYPE_NORMAL
- en: the transaction’s ECDSA signature. If correct, then 1 is returned,
  prefs: []
  type: TYPE_NORMAL
- en: otherwise 0\.
  prefs: []
  type: TYPE_NORMAL
- en: • **OP_DUP:** Takes the top item on the stack and duplicates it.
  prefs: []
  type: TYPE_NORMAL
- en: • **OP_HASH160:** Calculates the SHA-256 and then RIPEMD 160-bit
  prefs: []
  type: TYPE_NORMAL
- en: hash of the input.
  prefs: []
  type: TYPE_NORMAL
- en: • **OP_EQUAL:** Checks the equality of the top two items on the stack.
  prefs: []
  type: TYPE_NORMAL
- en: Outputs TRUE if equal, otherwise FALSE, on the stack.
  prefs: []
  type: TYPE_NORMAL
- en: • **OP_VERIFY:** Checks if the top item on the stack is false; if it is, the
  prefs: []
  type: TYPE_NORMAL
- en: script terminates and outputs failure.
  prefs: []
  type: TYPE_NORMAL
- en: • **OP_EQUALVERIFY:** First runs OP_EQUAL and then OP_VERIFY.
  prefs: []
  type: TYPE_NORMAL
- en: • **OP_RETURN:** Terminates the script, outputs fail, and marks the
  prefs: []
  type: TYPE_NORMAL
- en: transaction invalid.
  prefs: []
  type: TYPE_NORMAL
- en: • **OP_ADD:** Takes two inputs and performs sum operation.
  prefs: []
  type: TYPE_NORMAL
- en: A script is a combination of a locking script called ScriptPubKey and an unlocking
  prefs: []
  type: TYPE_NORMAL
- en: script called ScriptSig, as shown in Figure [4-10\. O](#p207)utputs are locked
    by ScriptPubKey, which contains the unlocking conditions for the output. In other
    words, locking means
  prefs: []
  type: TYPE_NORMAL
- en: giving bitcoins to someone, and unlocking means consuming the received bitcoins.
  prefs: []
  type: TYPE_NORMAL
- en: '188'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-207_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](index-207_2.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 4 BloCkChain
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 4-10\.** Bitcoin script (unlocking + locking) diagram*'
  prefs: []
  type: TYPE_NORMAL
- en: There are several types of scripts in Bitcoin. The most common is Pay-to-Public-Key-
  prefs: []
  type: TYPE_NORMAL
- en: Hash (P2PKH), which is used to send a transaction to a bitcoin address. The
    format of
  prefs: []
  type: TYPE_NORMAL
- en: 'this script is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'ScriptPubKey: OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG'
  prefs: []
  type: TYPE_NORMAL
- en: 'ScriptSig: <sig> <pubKey>'
  prefs: []
  type: TYPE_NORMAL
- en: Both ScriptPubKey and ScriptSig are combined and executed, as shown in
  prefs: []
  type: TYPE_NORMAL
- en: Figur[e 4-11\.](#p207)
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 4-11\.** Bitcoin P2PKH script execution*'
  prefs: []
  type: TYPE_NORMAL
- en: While the bitcoin script is the original method of transferring payments, and
    it works
  prefs: []
  type: TYPE_NORMAL
- en: well, it is not much flexible. There is a language developed for bitcoin which
    supports
  prefs: []
  type: TYPE_NORMAL
- en: development of smart contracts. The language is called **Ivy**. A solution to
    make writing scripts easier and in a more structured way is the bitcoin **miniscript**.
  prefs: []
  type: TYPE_NORMAL
- en: '189'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-208_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 4 BloCkChain
  prefs: []
  type: TYPE_NORMAL
- en: '**Blocks and Blockchain**'
  prefs: []
  type: TYPE_NORMAL
- en: A blockchain is composed of blocks. Blocks are composed of a block header and
  prefs: []
  type: TYPE_NORMAL
- en: transactions. A block header consists of several fields. The first block in
    the Bitcoin
  prefs: []
  type: TYPE_NORMAL
- en: blockchain is called the genesis block, which doesn’t link back to any block,
    being the
  prefs: []
  type: TYPE_NORMAL
- en: first block. It is usually hardcoded in the software clients.
  prefs: []
  type: TYPE_NORMAL
- en: We can see a complete visualization of blocks, block headers, transactions,
    and
  prefs: []
  type: TYPE_NORMAL
- en: scripts in Figure [4-12](#p208).
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 4-12\.** A visualization of a Bitcoin blockchain, blocks, block headers,*'
  prefs: []
  type: TYPE_NORMAL
- en: '*transactions, and scripts*'
  prefs: []
  type: TYPE_NORMAL
- en: The FLM[1 im](#p208)possibility states that Byzantine consensus is not possible
    if an *n*
  prefs: []
  type: TYPE_NORMAL
- en: adversary can control more than nodes. In the case of the PKI setup, this lower
    bound
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: does not hold. It turns out that Bitcoin circumvents FLM impossibility. In proof
    of work
  prefs: []
  type: TYPE_NORMAL
- en: environments, a Byzantine agreement is possible without the PKI [2s](#p208)etup.
  prefs: []
  type: TYPE_NORMAL
- en: '1 After the authors’ names: Fischer, Lynch, and Merritt – [https://groups.csail.mit.edu/tds/](https://groups.csail.mit.edu/tds/papers/Lynch/FischerLynchMerritt-dc.pdf)'
  prefs: []
  type: TYPE_NORMAL
- en: '[papers/Lynch/FischerLynchMerritt-dc.pdf](https://groups.csail.mit.edu/tds/papers/Lynch/FischerLynchMerritt-dc.pdf)'
  prefs: []
  type: TYPE_NORMAL
- en: 2 Public Key Infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: '190'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 4 BloCkChain
  prefs: []
  type: TYPE_NORMAL
- en: '**Mining**'
  prefs: []
  type: TYPE_NORMAL
- en: Mining is the process by which new coins are added to the Bitcoin blockchain.
    This
  prefs: []
  type: TYPE_NORMAL
- en: process secures the network and incentivizes the users who spend resources to
    protect
  prefs: []
  type: TYPE_NORMAL
- en: the network. More details on the specifics are in Chapter [5; ho](https://doi.org/10.1007/978-1-4842-8179-6_5)wever,
    now I will touch upon the mining hardware. When Bitcoin was introduced, it was
    easy to mine with
  prefs: []
  type: TYPE_NORMAL
- en: CPUs, which quickly increased the difficulty, leading to miners using GPUs.
    Shortly
  prefs: []
  type: TYPE_NORMAL
- en: after the successful adoption of GPUs, FPGAs emerged as a mechanism to further
    speed
  prefs: []
  type: TYPE_NORMAL
- en: up SHA-256 hashing. Soon, these were outperformed by ASICs, and now ASICs are
    a
  prefs: []
  type: TYPE_NORMAL
- en: prevalent mechanism to mine Bitcoin. However, solo mining where individual users
    use
  prefs: []
  type: TYPE_NORMAL
- en: mining hardware to mine is also not much profitable due to exorbitant mining
    difficulty.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, mining farms comprising thousands of ASICs are commonly used now. Also,
  prefs: []
  type: TYPE_NORMAL
- en: mining pools are common where multiple users collectively solve the hash puzzle
    to
  prefs: []
  type: TYPE_NORMAL
- en: earn rewards proportionate to their contribution.
  prefs: []
  type: TYPE_NORMAL
- en: '**Bitcoin As a Platform**'
  prefs: []
  type: TYPE_NORMAL
- en: Other than electronic cash, Bitcoin as a platform can be used for several use
    cases. For
  prefs: []
  type: TYPE_NORMAL
- en: example, it can be used as a timestamping service or a general ledger to store
    some
  prefs: []
  type: TYPE_NORMAL
- en: information permanently. In addition, we can use the OP_RETURN instruction to
    store
  prefs: []
  type: TYPE_NORMAL
- en: data, which can store up to 80 bytes of arbitrary data. Other use cases such
    as smart
  prefs: []
  type: TYPE_NORMAL
- en: property, smart assets, and blocks as a source of randomness also transpired.
  prefs: []
  type: TYPE_NORMAL
- en: The desire to use Bitcoin for different purposes also resulted in techniques
    to
  prefs: []
  type: TYPE_NORMAL
- en: enhance Bitcoin, resulting in colored coins, rootstock, Omni layer, and counterparty
  prefs: []
  type: TYPE_NORMAL
- en: projects. While Bitcoin did what it intended to do and a lot more in the form
    of
  prefs: []
  type: TYPE_NORMAL
- en: innovations mentioned earlier, the fundamental limitation in Bitcoin protocols
    meant
  prefs: []
  type: TYPE_NORMAL
- en: that all flexible new protocols would have to be built on top of Bitcoin. There
    is no
  prefs: []
  type: TYPE_NORMAL
- en: inherent flexibility in Bitcoin to perform all these different tasks. Therefore,
    there was a need felt to do more than just cryptocurrency on Blockchain. This
    ambition motivated
  prefs: []
  type: TYPE_NORMAL
- en: the invention of Ethereum, the first general-purpose blockchain platform that
    supported
  prefs: []
  type: TYPE_NORMAL
- en: smart contracts.
  prefs: []
  type: TYPE_NORMAL
- en: '191'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 4 BloCkChain
  prefs: []
  type: TYPE_NORMAL
- en: '**Ethereum**'
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum was introduced in 2014 in a whitepaper by Vitalik Buterin. Ethereum
  prefs: []
  type: TYPE_NORMAL
- en: introduced a platform on which users can run arbitrary code in the form of smart
  prefs: []
  type: TYPE_NORMAL
- en: contracts. To thwart the denial-of-service attacks caused by infinite loops
    in code, the
  prefs: []
  type: TYPE_NORMAL
- en: concept of metered execution was also introduced. Metered executions require
    that
  prefs: []
  type: TYPE_NORMAL
- en: for every operation performed on the blockchain, a fee is charged, which is
    paid in
  prefs: []
  type: TYPE_NORMAL
- en: Ether, the native currency of the Ethereum blockchain. With smart contracts,
    Ethereum
  prefs: []
  type: TYPE_NORMAL
- en: opened a whole new world of generic platforms where the operations are no longer
  prefs: []
  type: TYPE_NORMAL
- en: limited to only bitcoin-style value transfer transactions, but users can execute
    any type of diverse business logic on-chain due to Ethereum’s Turing complete
    design. Ethereum is
  prefs: []
  type: TYPE_NORMAL
- en: currently the most used blockchain platform for smart contracts.
  prefs: []
  type: TYPE_NORMAL
- en: Today’s Internet is centralized, which is dominated by large companies. The
    Internet
  prefs: []
  type: TYPE_NORMAL
- en: that we use today is called Web 2\. Ethereum is developed with the vision of
    Web3, where
  prefs: []
  type: TYPE_NORMAL
- en: anyone can participate in the network without any reliance on a third party.
    In the Web
  prefs: []
  type: TYPE_NORMAL
- en: 2 model, big service providers currently provide services in return for personal
    data;
  prefs: []
  type: TYPE_NORMAL
- en: however, in Web3, anyone can participate without giving up their personal information
  prefs: []
  type: TYPE_NORMAL
- en: in exchange for services. However, with decentralized applications (DApps),
    anyone can
  prefs: []
  type: TYPE_NORMAL
- en: provide any service which any user on the network can use, and no one can block
    your
  prefs: []
  type: TYPE_NORMAL
- en: access to the service.
  prefs: []
  type: TYPE_NORMAL
- en: '**Ethereum Network**'
  prefs: []
  type: TYPE_NORMAL
- en: An Ethereum network is composed of loosely coupled nodes which exchange messages
  prefs: []
  type: TYPE_NORMAL
- en: via a gossip protocol.
  prefs: []
  type: TYPE_NORMAL
- en: A high-level visualization of the Ethereum network is shown in Figure [4-13\.](#p211)
  prefs: []
  type: TYPE_NORMAL
- en: '192'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-211_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 4 BloCkChain
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 4-13\.** Ethereum network high-level overview*'
  prefs: []
  type: TYPE_NORMAL
- en: Nodes run client software which is an implementation of the Ethereum blockchain
  prefs: []
  type: TYPE_NORMAL
- en: protocol described in the yellow paper to enable any user to participate on
    the network.
  prefs: []
  type: TYPE_NORMAL
- en: A node is composed of different components, as shown in Figur[e 4-14](#p212).
  prefs: []
  type: TYPE_NORMAL
- en: '193'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-212_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 4 BloCkChain
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 4-14\.** Ethereum node architecture*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three main types of nodes in the Ethereum network:'
  prefs: []
  type: TYPE_NORMAL
- en: • Full node
  prefs: []
  type: TYPE_NORMAL
- en: • Light node
  prefs: []
  type: TYPE_NORMAL
- en: • Archive node
  prefs: []
  type: TYPE_NORMAL
- en: Full nodes store the entire chain data and validate blocks, transactions, and
    states.
  prefs: []
  type: TYPE_NORMAL
- en: Light nodes only store the block headers and verify the data against state roots
    present
  prefs: []
  type: TYPE_NORMAL
- en: in the block headers. Light nodes are suitable for resource-constrained devices,
    such as
  prefs: []
  type: TYPE_NORMAL
- en: mobile devices. Archive nodes include everything that is in a full node but
    also builds
  prefs: []
  type: TYPE_NORMAL
- en: an archive of historical states. Miner nodes are a full node but also perform
    mining
  prefs: []
  type: TYPE_NORMAL
- en: operation and participate in proof of work consensus.
  prefs: []
  type: TYPE_NORMAL
- en: '194'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-213_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 4 BloCkChain
  prefs: []
  type: TYPE_NORMAL
- en: A new Ethereum node joining the network uses hardcoded bootstrap nodes
  prefs: []
  type: TYPE_NORMAL
- en: as an initial entry point into the network from where the further discovery
    of other
  prefs: []
  type: TYPE_NORMAL
- en: nodes begins.
  prefs: []
  type: TYPE_NORMAL
- en: RLPx is a TCP-based transport protocol. It enables secure communication between
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum nodes by using the Elliptic Curve Integrated Encryption Scheme (ECIES)
    for
  prefs: []
  type: TYPE_NORMAL
- en: handshaking and key exchange.
  prefs: []
  type: TYPE_NORMAL
- en: DEVP2P or the wire protocol negotiates an application session between two
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum nodes that have been discovered and have established a secure channel
  prefs: []
  type: TYPE_NORMAL
- en: using RLPx.
  prefs: []
  type: TYPE_NORMAL
- en: After discovering and establishing a secure transport channel and negotiating
    an
  prefs: []
  type: TYPE_NORMAL
- en: application session, the nodes exchange messages using “capability protocols,”
    for
  prefs: []
  type: TYPE_NORMAL
- en: example, eth (versions 62, 63, and 64), Light Ethereum Subprotocol (LES), Whisper,
  prefs: []
  type: TYPE_NORMAL
- en: and Swarm. These capability protocols or application subprotocols enable different
  prefs: []
  type: TYPE_NORMAL
- en: application-level communications, for example, eth for block synchronization.
  prefs: []
  type: TYPE_NORMAL
- en: The node discovery protocol and other relevant protocols are shown in Figure
    [4-15](#p213).
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 4-15\.** Node discovery and other protocols*'
  prefs: []
  type: TYPE_NORMAL
- en: '195'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 4 BloCkChain
  prefs: []
  type: TYPE_NORMAL
- en: '**Cryptography in Ethereum**'
  prefs: []
  type: TYPE_NORMAL
- en: Like any other blockchain, Ethereum’s security relies on cryptography. Ethereum
    uses
  prefs: []
  type: TYPE_NORMAL
- en: 'cryptography throughout the blockchain and node design:'
  prefs: []
  type: TYPE_NORMAL
- en: • AES CTR is used in RLP handshake and subsequent P2P messaging.
  prefs: []
  type: TYPE_NORMAL
- en: It is also used in a keystore as AES CTR 128-bit cipher.
  prefs: []
  type: TYPE_NORMAL
- en: • Digital signatures in Ethereum clients use the SECP256K1 curve.
  prefs: []
  type: TYPE_NORMAL
- en: It is used in ECDSA signatures for transaction signing, ECDH key
  prefs: []
  type: TYPE_NORMAL
- en: exchanges, and for generating a shared key before the RLP P2P
  prefs: []
  type: TYPE_NORMAL
- en: handshake.
  prefs: []
  type: TYPE_NORMAL
- en: • SCRYPT and PBKDF2 are used as key derivation functions in the
  prefs: []
  type: TYPE_NORMAL
- en: keystore.
  prefs: []
  type: TYPE_NORMAL
- en: • The KECCAK-256 hash function is used in the proof of work
  prefs: []
  type: TYPE_NORMAL
- en: algorithm for mining and solidity language.
  prefs: []
  type: TYPE_NORMAL
- en: • The Elliptic Curve Integrated Encryption Scheme (ECIES) is used in
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum.
  prefs: []
  type: TYPE_NORMAL
- en: if the terms mentioned earlier sound unfamiliar, refer to Chapter [2](https://doi.org/10.1007/978-1-4842-8179-6_2)
    where we covered cryptography in detail.
  prefs: []
  type: TYPE_NORMAL
- en: '**Accounts and Addresses**'
  prefs: []
  type: TYPE_NORMAL
- en: A Bitcoin model is based on transactions, whereas Ethereum is based on accounts.
  prefs: []
  type: TYPE_NORMAL
- en: Accounts are part of the Ethereum state and keep an intrinsic balance and transaction
  prefs: []
  type: TYPE_NORMAL
- en: count. 160-bit long addresses identify accounts. An account is how a user interacts
    with
  prefs: []
  type: TYPE_NORMAL
- en: the blockchain. A transaction signed by an account is verified and broadcast
    to the
  prefs: []
  type: TYPE_NORMAL
- en: network, which results in a state transition on the blockchain once executed.
    There are
  prefs: []
  type: TYPE_NORMAL
- en: two types of accounts, contract accounts (CAs) and externally owned accounts
    (EOAs).
  prefs: []
  type: TYPE_NORMAL
- en: EOAs are associated with a human user, whereas CAs have no intrinsic association
  prefs: []
  type: TYPE_NORMAL
- en: with a user.
  prefs: []
  type: TYPE_NORMAL
- en: '196'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 4 BloCkChain
  prefs: []
  type: TYPE_NORMAL
- en: A world state is a mapping between addresses and account states. An account
    state
  prefs: []
  type: TYPE_NORMAL
- en: consists of the fields shown in Table [4-2](#p215).
  prefs: []
  type: TYPE_NORMAL
- en: '***Table 4-2\.** Account state*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Element**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Description**'
  prefs: []
  type: TYPE_NORMAL
- en: nonce
  prefs: []
  type: TYPE_NORMAL
- en: number of transactions originated from an address or, in the case of smart contracts,
  prefs: []
  type: TYPE_NORMAL
- en: the number of contracts created by an account
  prefs: []
  type: TYPE_NORMAL
- en: Balance
  prefs: []
  type: TYPE_NORMAL
- en: number of Wei owned by this address
  prefs: []
  type: TYPE_NORMAL
- en: Storageroot 256-bit hash of the root node of the Merkle patricia trie, which
    encodes the storage contents of the account
  prefs: []
  type: TYPE_NORMAL
- en: codehash
  prefs: []
  type: TYPE_NORMAL
- en: hash of the associated eVM code (bytecode)
  prefs: []
  type: TYPE_NORMAL
- en: '**Transactions and Executions**'
  prefs: []
  type: TYPE_NORMAL
- en: Transactions in Ethereum are signed instructions which once executed result
    in a
  prefs: []
  type: TYPE_NORMAL
- en: message call or contract creation (new account with associated code) on the
    blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fundamentally, there are two types of transactions, **message call** and **contract
    creation**, but over time for easier understanding, three types are now usually
    defined:'
  prefs: []
  type: TYPE_NORMAL
- en: • Value transfer transactions
  prefs: []
  type: TYPE_NORMAL
- en: • Contract creation transactions
  prefs: []
  type: TYPE_NORMAL
- en: • Contract execution transactions
  prefs: []
  type: TYPE_NORMAL
- en: A transaction consists of several fields. Each transaction is part of the transaction
  prefs: []
  type: TYPE_NORMAL
- en: trie, the root of which is stored in the block header in the block. When a transaction
    is executed, a receipt is returned which can be used as a verification for the
    transaction
  prefs: []
  type: TYPE_NORMAL
- en: execution.
  prefs: []
  type: TYPE_NORMAL
- en: A transaction, either a message call or a contract creation, includes the common
  prefs: []
  type: TYPE_NORMAL
- en: fields shown in Table [4-3](#p216).
  prefs: []
  type: TYPE_NORMAL
- en: '197'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 4 BloCkChain
  prefs: []
  type: TYPE_NORMAL
- en: '***Table 4-3\.** Transaction structure*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Element**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Description**'
  prefs: []
  type: TYPE_NORMAL
- en: nonce
  prefs: []
  type: TYPE_NORMAL
- en: number of transactions sent by the sender
  prefs: []
  type: TYPE_NORMAL
- en: gasprice
  prefs: []
  type: TYPE_NORMAL
- en: number of Wei to be paid per unit of gas for the execution of the transaction
  prefs: []
  type: TYPE_NORMAL
- en: gaslimit
  prefs: []
  type: TYPE_NORMAL
- en: Maximum amount of gas that is expected to be used for executing a transaction.
    it is
  prefs: []
  type: TYPE_NORMAL
- en: paid up front and cannot be increased later
  prefs: []
  type: TYPE_NORMAL
- en: to
  prefs: []
  type: TYPE_NORMAL
- en: the 160-bit address of the message call’s (value transfer, contract execution)
    recipient
  prefs: []
  type: TYPE_NORMAL
- en: or for a contract creation transaction
  prefs: []
  type: TYPE_NORMAL
- en: value
  prefs: []
  type: TYPE_NORMAL
- en: number of Wei to be transferred to the message call’s recipient. in the case
    of contract
  prefs: []
  type: TYPE_NORMAL
- en: creation, it is the endowment (number of Wei) for the newly created contract
    account
  prefs: []
  type: TYPE_NORMAL
- en: (smart contract)
  prefs: []
  type: TYPE_NORMAL
- en: V, r, S
  prefs: []
  type: TYPE_NORMAL
- en: Values corresponding to the signature of the transaction used to determine the
    sender
  prefs: []
  type: TYPE_NORMAL
- en: of the transaction
  prefs: []
  type: TYPE_NORMAL
- en: init
  prefs: []
  type: TYPE_NORMAL
- en: (in the case of contract creation transaction) an unlimited size byte array
    specifying
  prefs: []
  type: TYPE_NORMAL
- en: the eVM code for the contract account (smart contract) initialization procedure
  prefs: []
  type: TYPE_NORMAL
- en: data
  prefs: []
  type: TYPE_NORMAL
- en: (in the case of message call transaction) an unlimited size byte array specifying
    the
  prefs: []
  type: TYPE_NORMAL
- en: input data of the message call
  prefs: []
  type: TYPE_NORMAL
- en: A transaction takes several steps in the Ethereum blockchain. A high-level
  prefs: []
  type: TYPE_NORMAL
- en: 'transaction flow is described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. First, a transaction is created. It can either be a contract creation
  prefs: []
  type: TYPE_NORMAL
- en: transaction or a message call.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. The transaction is signed using ECDSA, verified, and broadcast to
  prefs: []
  type: TYPE_NORMAL
- en: the network.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. The transaction is propagated via a gossip protocol and picked up
  prefs: []
  type: TYPE_NORMAL
- en: by miners and other nodes to populate their transaction pools.
  prefs: []
  type: TYPE_NORMAL
- en: 4\. Miners create a candidate block by adding transactions to it and
  prefs: []
  type: TYPE_NORMAL
- en: start the mining process.
  prefs: []
  type: TYPE_NORMAL
- en: 5\. A miner who solves the proof of work announces its block to the
  prefs: []
  type: TYPE_NORMAL
- en: network.
  prefs: []
  type: TYPE_NORMAL
- en: 6\. Other nodes receive the block, validate it, and append it to their
  prefs: []
  type: TYPE_NORMAL
- en: blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: '198'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 4 BloCkChain
  prefs: []
  type: TYPE_NORMAL
- en: '**Blocks and Blockchain**'
  prefs: []
  type: TYPE_NORMAL
- en: Blocks in Ethereum are composed of a block header and transactions. A blockchain
  prefs: []
  type: TYPE_NORMAL
- en: consists of blocks, which contain transactions.
  prefs: []
  type: TYPE_NORMAL
- en: Like any other blockchain, blocks are the main building blocks of Ethereum.
    An
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum block consists of the block header, the list of transactions, and the
    list of
  prefs: []
  type: TYPE_NORMAL
- en: ommer block headers. A block header also consists of several elements. All these
  prefs: []
  type: TYPE_NORMAL
- en: elements in a block are shown in Tables [4-4 and 4-5 w](#p217)ith a description.
  prefs: []
  type: TYPE_NORMAL
- en: '***Table 4-4\.** Block structure*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Element**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Description**'
  prefs: []
  type: TYPE_NORMAL
- en: Block header
  prefs: []
  type: TYPE_NORMAL
- en: header of the block
  prefs: []
  type: TYPE_NORMAL
- en: list of transactions
  prefs: []
  type: TYPE_NORMAL
- en: Series of transactions included in the block
  prefs: []
  type: TYPE_NORMAL
- en: list of ommer block
  prefs: []
  type: TYPE_NORMAL
- en: list of uncle or ommer headers. an uncle block is a child of a parent but
  prefs: []
  type: TYPE_NORMAL
- en: headers
  prefs: []
  type: TYPE_NORMAL
- en: doesn’t have any child blocks. they are valid but stale blocks which do not
  prefs: []
  type: TYPE_NORMAL
- en: make it to the main chain but do earn a reward for their participation
  prefs: []
  type: TYPE_NORMAL
- en: The block header structure is described in Ta[ble 4-5\.](#p217)
  prefs: []
  type: TYPE_NORMAL
- en: '***Table 4-5\.** Block header structure*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Element**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Type**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Description**'
  prefs: []
  type: TYPE_NORMAL
- en: parent hash
  prefs: []
  type: TYPE_NORMAL
- en: hash
  prefs: []
  type: TYPE_NORMAL
- en: keccak 256-bit hash of the parent block’s header
  prefs: []
  type: TYPE_NORMAL
- en: ommers hash
  prefs: []
  type: TYPE_NORMAL
- en: hash
  prefs: []
  type: TYPE_NORMAL
- en: keccak 256-bit hash of the list of ommers
  prefs: []
  type: TYPE_NORMAL
- en: Beneficiary
  prefs: []
  type: TYPE_NORMAL
- en: address
  prefs: []
  type: TYPE_NORMAL
- en: 160-bit recipient address for mining reward
  prefs: []
  type: TYPE_NORMAL
- en: State root
  prefs: []
  type: TYPE_NORMAL
- en: hash
  prefs: []
  type: TYPE_NORMAL
- en: keccak 256-bit hash of the root node of the transaction trie
  prefs: []
  type: TYPE_NORMAL
- en: transaction root hash
  prefs: []
  type: TYPE_NORMAL
- en: keccak 256-bit hash of the root node of the transaction trie
  prefs: []
  type: TYPE_NORMAL
- en: receipts root
  prefs: []
  type: TYPE_NORMAL
- en: hash
  prefs: []
  type: TYPE_NORMAL
- en: keccak 256-bit hash of the root node of the transaction receipts trie,
  prefs: []
  type: TYPE_NORMAL
- en: which contains receipts of all transactions included in the block
  prefs: []
  type: TYPE_NORMAL
- en: logs bloom
  prefs: []
  type: TYPE_NORMAL
- en: Variable
  prefs: []
  type: TYPE_NORMAL
- en: Bloom filter composed logger address and log topics
  prefs: []
  type: TYPE_NORMAL
- en: Difficulty
  prefs: []
  type: TYPE_NORMAL
- en: integer
  prefs: []
  type: TYPE_NORMAL
- en: Difficulty level of the current block
  prefs: []
  type: TYPE_NORMAL
- en: number
  prefs: []
  type: TYPE_NORMAL
- en: integer
  prefs: []
  type: TYPE_NORMAL
- en: total number of all previous blocks
  prefs: []
  type: TYPE_NORMAL
- en: ( *continued*)
  prefs: []
  type: TYPE_NORMAL
- en: '199'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 4 BloCkChain
  prefs: []
  type: TYPE_NORMAL
- en: '***Table 4-5\.*** ( *continued*)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Element**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Type**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Description**'
  prefs: []
  type: TYPE_NORMAL
- en: Gas limit
  prefs: []
  type: TYPE_NORMAL
- en: integer
  prefs: []
  type: TYPE_NORMAL
- en: limit set on the gas consumption per block
  prefs: []
  type: TYPE_NORMAL
- en: Gas used
  prefs: []
  type: TYPE_NORMAL
- en: integer
  prefs: []
  type: TYPE_NORMAL
- en: total gas consumed by all transactions included in the block
  prefs: []
  type: TYPE_NORMAL
- en: timestamp
  prefs: []
  type: TYPE_NORMAL
- en: integer
  prefs: []
  type: TYPE_NORMAL
- en: Unix epoch timestamp
  prefs: []
  type: TYPE_NORMAL
- en: extra
  prefs: []
  type: TYPE_NORMAL
- en: Variable
  prefs: []
  type: TYPE_NORMAL
- en: an optional free field for storing extra data
  prefs: []
  type: TYPE_NORMAL
- en: Mixhash
  prefs: []
  type: TYPE_NORMAL
- en: integer
  prefs: []
  type: TYPE_NORMAL
- en: Computational effort proof
  prefs: []
  type: TYPE_NORMAL
- en: nonce
  prefs: []
  type: TYPE_NORMAL
- en: integer
  prefs: []
  type: TYPE_NORMAL
- en: Combined with Mixhash to prove computational effort
  prefs: []
  type: TYPE_NORMAL
- en: basefeepergas
  prefs: []
  type: TYPE_NORMAL
- en: integer
  prefs: []
  type: TYPE_NORMAL
- en: (post eip-1559) records the protocol calculated fee required for a
  prefs: []
  type: TYPE_NORMAL
- en: transaction to be included in the block
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum uses a new data structure called Merkle Patricia trie to store and
    organize
  prefs: []
  type: TYPE_NORMAL
- en: transactions and relevant data. It is a combination of Patricia and Merkle trees
    with novel properties.
  prefs: []
  type: TYPE_NORMAL
- en: There are four tries used in Ethereum to organize data such as transactions,
    state,
  prefs: []
  type: TYPE_NORMAL
- en: receipts, and contract storage.
  prefs: []
  type: TYPE_NORMAL
- en: '**Transaction Trie**'
  prefs: []
  type: TYPE_NORMAL
- en: Each Ethereum block contains the root of a transaction trie, which is composed
    of
  prefs: []
  type: TYPE_NORMAL
- en: transactions.
  prefs: []
  type: TYPE_NORMAL
- en: '**World State Trie**'
  prefs: []
  type: TYPE_NORMAL
- en: A state trie is a key-value mapping from user addresses to an account state.
    Also called
  prefs: []
  type: TYPE_NORMAL
- en: the world state trie, this trie has its root referred in the block. A state
    trie is composed of account states.
  prefs: []
  type: TYPE_NORMAL
- en: '**Transaction Receipts Trie**'
  prefs: []
  type: TYPE_NORMAL
- en: Transaction receipts store results of transaction execution and include information
    such
  prefs: []
  type: TYPE_NORMAL
- en: as status, logs, and events. Each block contains a transaction receipts trie.
    A transaction receipts trie consists of transaction receipts.
  prefs: []
  type: TYPE_NORMAL
- en: '200'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-219_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 4 BloCkChain
  prefs: []
  type: TYPE_NORMAL
- en: '**Account Storage Trie**'
  prefs: []
  type: TYPE_NORMAL
- en: This trie has its root as a storage root in the account state. It stores smart
    contract code and relevant data.
  prefs: []
  type: TYPE_NORMAL
- en: Figur[e 4-16 sho](#p219)ws all tries including the block structure.
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 4-16\.** Block and tries*'
  prefs: []
  type: TYPE_NORMAL
- en: Transactions within the blocks are executed using the Ethereum virtual machine,
  prefs: []
  type: TYPE_NORMAL
- en: which we describe next.
  prefs: []
  type: TYPE_NORMAL
- en: '**Mining in Ethereum**'
  prefs: []
  type: TYPE_NORMAL
- en: In contrast with Bitcoin, mining in Ethereum is ASIC (application-specific integrated
  prefs: []
  type: TYPE_NORMAL
- en: circuit) resistant.
  prefs: []
  type: TYPE_NORMAL
- en: ASIC-based, special-purpose, efficient, and extremely fast hardware is built
    for
  prefs: []
  type: TYPE_NORMAL
- en: performing Bitcoin mining. These devices have only one specific job, and that
    is to run
  prefs: []
  type: TYPE_NORMAL
- en: hash function SHA-256 repeatedly and extremely fast.
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum uses proof of work; however, the consensus is memory-hard, which
  prefs: []
  type: TYPE_NORMAL
- en: makes building ASICs difficult due to large memory requirements. The protocol
    is called
  prefs: []
  type: TYPE_NORMAL
- en: ETHASH, which generates a large direct acyclic graph (DAG) to be used by miners.
  prefs: []
  type: TYPE_NORMAL
- en: '201'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 4 BloCkChain
  prefs: []
  type: TYPE_NORMAL
- en: DAG grows and shrinks according to the network difficulty level; however, over
    time, it
  prefs: []
  type: TYPE_NORMAL
- en: has increased up to roughly about 4 GB in size. As this DAG consumes large memory,
  prefs: []
  type: TYPE_NORMAL
- en: building ASICs with such large memory is prohibitively hard, thus making ETHASH
    an
  prefs: []
  type: TYPE_NORMAL
- en: ASIC-resistant algorithm. We will explain ETHASH in more detail in Chapter [8\.](https://doi.org/10.1007/978-1-4842-8179-6_8)
  prefs: []
  type: TYPE_NORMAL
- en: '**Ethereum Virtual Machine and Smart Contracts**'
  prefs: []
  type: TYPE_NORMAL
- en: The Ethereum virtual machine (EVM) is the core working horse of the Ethereum
  prefs: []
  type: TYPE_NORMAL
- en: blockchain. It is a 256-bit register stack with a depth of 1024 items. It is
    designed to run the smart contract code compiled into bytecode. Smart contracts
    are usually written in a
  prefs: []
  type: TYPE_NORMAL
- en: domain-specific language (DSL) called Solidity; however, there are other languages,
    such
  prefs: []
  type: TYPE_NORMAL
- en: as Vyper, which developers can also use to write smart contract code.
  prefs: []
  type: TYPE_NORMAL
- en: We can define a **smart contract** as a secure and unstoppable computer program
  prefs: []
  type: TYPE_NORMAL
- en: representing an automatically executable and enforceable agreement. Smart contracts
  prefs: []
  type: TYPE_NORMAL
- en: do not necessarily need a blockchain; however, a blockchain is the most natural
    platform
  prefs: []
  type: TYPE_NORMAL
- en: for running smart contracts. This is so because a blockchain provides all security
  prefs: []
  type: TYPE_NORMAL
- en: guarantees that make smart contracts secure, unstoppable, automatically executable,
  prefs: []
  type: TYPE_NORMAL
- en: and enforceable.
  prefs: []
  type: TYPE_NORMAL
- en: EVM is designed to be Turing complete; however, it is bound by a gas limit,
    which
  prefs: []
  type: TYPE_NORMAL
- en: means that its execution is metered and paid for in the so-called gas fee denominated
  prefs: []
  type: TYPE_NORMAL
- en: in ether. This mechanism allows for any arbitrary code execution but with the
    safety
  prefs: []
  type: TYPE_NORMAL
- en: 'that the execution will halt when the gas runs out, preventing infinite executions
    due to loops or malicious code. EVM executes bytecode composed of **opcodes**
    that cost gas on a per-operation basis. There are around 150 opcodes categorized
    into several groups:'
  prefs: []
  type: TYPE_NORMAL
- en: arithmetic opcodes, memory manipulating opcodes, and program flow–related opcodes.
  prefs: []
  type: TYPE_NORMAL
- en: A complete list is available in the Ethereum yellow paper.
  prefs: []
  type: TYPE_NORMAL
- en: The consensus in Ethereum is proof of work based, which we will cover in detail
    in
  prefs: []
  type: TYPE_NORMAL
- en: Chapt[er 8\.](https://doi.org/10.1007/978-1-4842-8179-6_8)
  prefs: []
  type: TYPE_NORMAL
- en: the ethereum 1.0 blockchain will continue to evolve according to its road map
    and
  prefs: []
  type: TYPE_NORMAL
- en: will eventually become a shard in phase 1 of ethereum 2.0\.
  prefs: []
  type: TYPE_NORMAL
- en: '202'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 4 BloCkChain
  prefs: []
  type: TYPE_NORMAL
- en: With this, we complete our brief discussion on the two most prominent and
  prefs: []
  type: TYPE_NORMAL
- en: pioneering blockchain platforms. More modern blockchain platforms, such as Polkadot,
  prefs: []
  type: TYPE_NORMAL
- en: Cardano, Solana, Avalanche, and Ethereum 2.0, will be introduced when we discuss
    their
  prefs: []
  type: TYPE_NORMAL
- en: respective consensus protocols in Chapter [8\.](https://doi.org/10.1007/978-1-4842-8179-6_8)
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs: []
  type: TYPE_NORMAL
- en: • A blockchain is a peer-to-peer, cryptographically secure, append-
  prefs: []
  type: TYPE_NORMAL
- en: only, immutable, and tamper-proof shared distributed ledger
  prefs: []
  type: TYPE_NORMAL
- en: composed of temporally ordered and publicly verifiable transactions.
  prefs: []
  type: TYPE_NORMAL
- en: • Origins of the blockchain can be found in previous attempts to create
  prefs: []
  type: TYPE_NORMAL
- en: digital cash and digital timestamping of documents.
  prefs: []
  type: TYPE_NORMAL
- en: • A blockchain is a distributed system.
  prefs: []
  type: TYPE_NORMAL
- en: • Blockchains are primarily of two types, permissioned and public.
  prefs: []
  type: TYPE_NORMAL
- en: • Blockchains have many cross-industry use cases, including but by no
  prefs: []
  type: TYPE_NORMAL
- en: means limited to government, finance, medical, supply chain, and
  prefs: []
  type: TYPE_NORMAL
- en: technology.
  prefs: []
  type: TYPE_NORMAL
- en: • Blockchains provide several benefits, such as cost saving,
  prefs: []
  type: TYPE_NORMAL
- en: transparency, and data sharing.
  prefs: []
  type: TYPE_NORMAL
- en: • Various technologies such as public key cryptography, hash
  prefs: []
  type: TYPE_NORMAL
- en: functions, and Merkle trees have provided foundations for building
  prefs: []
  type: TYPE_NORMAL
- en: security of the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: • From the CAP theorem’s perspective, permissioned blockchains are
  prefs: []
  type: TYPE_NORMAL
- en: CP systems, whereas public chains are AP systems.
  prefs: []
  type: TYPE_NORMAL
- en: • A blockchain ledger abstraction has several properties along with
  prefs: []
  type: TYPE_NORMAL
- en: get(), append(), and verify() operations.
  prefs: []
  type: TYPE_NORMAL
- en: • Bitcoin is the first blockchain invented by Satoshi Nakamoto.
  prefs: []
  type: TYPE_NORMAL
- en: • Ethereum is the first smart contract blockchain platform proposed by
  prefs: []
  type: TYPE_NORMAL
- en: Vitalik Buterin.
  prefs: []
  type: TYPE_NORMAL
- en: • Bitcoin and Ethereum are the most prominent platforms.
  prefs: []
  type: TYPE_NORMAL
- en: '203'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 4 BloCkChain
  prefs: []
  type: TYPE_NORMAL
- en: • Ethereum will become a shard of Ethereum 2.0\.
  prefs: []
  type: TYPE_NORMAL
- en: • Modern blockchain platforms are focusing on the heterogenous
  prefs: []
  type: TYPE_NORMAL
- en: multichain architecture where multiple chains interoperate and
  prefs: []
  type: TYPE_NORMAL
- en: form an ecosystem of blockchains cooperating and interoperating
  prefs: []
  type: TYPE_NORMAL
- en: together, which serve multiple use cases.
  prefs: []
  type: TYPE_NORMAL
- en: '**Bibliography**'
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Bashir, I., 2020\. Mastering blockchain: a deep dive into'
  prefs: []
  type: TYPE_NORMAL
- en: distributed ledgers, consensus protocols, smart contracts, DApps,
  prefs: []
  type: TYPE_NORMAL
- en: cryptocurrencies, Ethereum, and more.
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Wood, G., 2014\. Ethereum: A secure decentralised generalised'
  prefs: []
  type: TYPE_NORMAL
- en: transaction ledger. Ethereum project yellow paper, 151(2014),
  prefs: []
  type: TYPE_NORMAL
- en: pp. 1–32\.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Raynal, M., 2018\. Fault-Tolerant Message-Passing Distributed
  prefs: []
  type: TYPE_NORMAL
- en: Systems (p. 459). Springer.
  prefs: []
  type: TYPE_NORMAL
- en: '4\. Nakamoto, S., 2008\. Bitcoin: A peer-to-peer electronic'
  prefs: []
  type: TYPE_NORMAL
- en: cash system.
  prefs: []
  type: TYPE_NORMAL
- en: 5\. Bitg[old:](https://unenumerated.blogspot.com/2005/12/bit-gold.html)
  prefs: []
  type: TYPE_NORMAL
- en: '[https://unenumerated.blogspot.com/2005/12/bit-](https://unenumerated.blogspot.com/2005/12/bit-gold.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[gold.html](https://unenumerated.blogspot.com/2005/12/bit-gold.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 6\. David Chaum’s blind signatures paper is available
  prefs: []
  type: TYPE_NORMAL
- en: 'her[e: https://sceweb.sce.uhcl.edu/yang/teaching/](https://sceweb.sce.uhcl.edu/yang/teaching/csci5234WebSecurityFall2011/Chaum-blind-signatures.PDF)'
  prefs: []
  type: TYPE_NORMAL
- en: '[csci5234WebSecurityFall2011/Chaum- blind- signatures.PDF](https://sceweb.sce.uhcl.edu/yang/teaching/csci5234WebSecurityFall2011/Chaum-blind-signatures.PDF)'
  prefs: []
  type: TYPE_NORMAL
- en: 7\. Haber, S. and Stornetta, W.S., 1990, August. How to time-stamp a
  prefs: []
  type: TYPE_NORMAL
- en: digital document. In *Conference on the Theory and Application of*
  prefs: []
  type: TYPE_NORMAL
- en: '*Cryptography* (pp. 437–455). Springer, Berlin, Heidelberg.'
  prefs: []
  type: TYPE_NORMAL
- en: '8\. B-money published here: [www.weidai.com/bmoney.txt](http://www.weidai.com/bmoney.txt)'
  prefs: []
  type: TYPE_NORMAL
- en: 9\. Dwork and Naor email spam combatting was published in Pricing
  prefs: []
  type: TYPE_NORMAL
- en: 'via Processing or Combatting Junk M[ail: www.iacr.org/cryptodb/](https://www.iacr.org/cryptodb/data/paper.php?pubkey=1268)'
  prefs: []
  type: TYPE_NORMAL
- en: '[data/paper.php?pubkey=1268](https://www.iacr.org/cryptodb/data/paper.php?pubkey=1268)'
  prefs: []
  type: TYPE_NORMAL
- en: '204'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 4 BloCkChain
  prefs: []
  type: TYPE_NORMAL
- en: 10\. Hashcash for email spam combatting publishe[d in www.hashcash.](http://www.hashcash.org/papers/hashcash.pdf)
  prefs: []
  type: TYPE_NORMAL
- en: '[org/papers/hashcash.pdf](http://www.hashcash.org/papers/hashcash.pdf)'
  prefs: []
  type: TYPE_NORMAL
- en: '11\. Reusable proof of work by Hal Finney published her[e: https://](https://cryptome.org/rpow.htm)'
  prefs: []
  type: TYPE_NORMAL
- en: '[cryptome.org/rpow.htm](https://cryptome.org/rpow.htm)'
  prefs: []
  type: TYPE_NORMAL
- en: 12\. Gupta, S., Hellings, J., and Sadoghi, M., 2021\. Fault-Tolerant
  prefs: []
  type: TYPE_NORMAL
- en: Distributed Transactions on Blockchain. *Synthesis Lectures on*
  prefs: []
  type: TYPE_NORMAL
- en: '*Data Management*, *16*(1), pp. 1–268\.'
  prefs: []
  type: TYPE_NORMAL
- en: '13\. A complete list of Bitcoin opcodes is available her[e: https://](https://en.bitcoin.it/wiki/Script)'
  prefs: []
  type: TYPE_NORMAL
- en: '[en.bitcoin.it/wiki/Script](https://en.bitcoin.it/wiki/Script)'
  prefs: []
  type: TYPE_NORMAL
- en: '14\. Documentation on Ivy is available her[e: https://docs.ivylang.](https://docs.ivylang.org/bitcoin/)'
  prefs: []
  type: TYPE_NORMAL
- en: '[org/bitcoin/](https://docs.ivylang.org/bitcoin/)'
  prefs: []
  type: TYPE_NORMAL
- en: '15\. More details on the miniscript are available here: [http://](http://bitcoin.sipa.be/miniscript/)'
  prefs: []
  type: TYPE_NORMAL
- en: '[bitcoin.sipa.be/miniscript/](http://bitcoin.sipa.be/miniscript/)'
  prefs: []
  type: TYPE_NORMAL
- en: '16\. More on FLM impossibility here: [https://](https://decentralizedthoughts.github.io/2019-08-02-byzantine-agreement-is-impossible-for-$n-slash-leq-3-f$-is-the-adversary-can-easily-simulate/)'
  prefs: []
  type: TYPE_NORMAL
- en: '[decentralizedthoughts.github.io/2019- 08- 02- byzantine-](https://decentralizedthoughts.github.io/2019-08-02-byzantine-agreement-is-impossible-for-$n-slash-leq-3-f$-is-the-adversary-can-easily-simulate/)'
  prefs: []
  type: TYPE_NORMAL
- en: '[agreement- is- impossible- for- $n- slash- leq- 3- f$- is- the-](https://decentralizedthoughts.github.io/2019-08-02-byzantine-agreement-is-impossible-for-$n-slash-leq-3-f$-is-the-adversary-can-easily-simulate/)'
  prefs: []
  type: TYPE_NORMAL
- en: '[adversary- can- easily- simulate/](https://decentralizedthoughts.github.io/2019-08-02-byzantine-agreement-is-impossible-for-$n-slash-leq-3-f$-is-the-adversary-can-easily-simulate/)'
  prefs: []
  type: TYPE_NORMAL
- en: 17\. Fischer, M.J., Lynch, N.A., and Merritt, M., 1986\. Easy impossibility
  prefs: []
  type: TYPE_NORMAL
- en: proofs for distributed consensus problems. *Distributed*
  prefs: []
  type: TYPE_NORMAL
- en: '*Computing*, *1*(1), pp. 26–39\.'
  prefs: []
  type: TYPE_NORMAL
- en: '205'
  prefs: []
  type: TYPE_NORMAL
- en: '**CHAPTER 5**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Blockchain Consensus**'
  prefs: []
  type: TYPE_NORMAL
- en: Blockchain consensus is the core element of a blockchain, which ensures the
    integrity
  prefs: []
  type: TYPE_NORMAL
- en: and consistency of the blockchain data. Blockchain being a distributed system,
    in
  prefs: []
  type: TYPE_NORMAL
- en: the first instance, it may appear that we can apply traditional distributed
    consensus
  prefs: []
  type: TYPE_NORMAL
- en: protocols, such as Paxos or PBFT, to address the agreement and total order requirements
  prefs: []
  type: TYPE_NORMAL
- en: in a blockchain. However, this can only work in consortium chains where participants
  prefs: []
  type: TYPE_NORMAL
- en: are known and limited in number. In public chains, traditional consensus protocols
  prefs: []
  type: TYPE_NORMAL
- en: cannot work due to the permissionless environment. However, in 2008 a new class
    of
  prefs: []
  type: TYPE_NORMAL
- en: consensus algorithms emerged, which relied on proof of work to ensure random
    leader
  prefs: []
  type: TYPE_NORMAL
- en: election by solving a mathematical puzzle. The elected leader wins the right
    to append
  prefs: []
  type: TYPE_NORMAL
- en: to the blockchain. This is the so-called Nakamoto consensus protocol. This algorithm
  prefs: []
  type: TYPE_NORMAL
- en: for the very first time solved the problem of consensus in a permissionless
    public
  prefs: []
  type: TYPE_NORMAL
- en: environment with many anonymous participants.
  prefs: []
  type: TYPE_NORMAL
- en: We have already discussed distributed consensus from a traditional perspective
  prefs: []
  type: TYPE_NORMAL
- en: in Chapter [3](https://doi.org/10.1007/978-1-4842-8179-6_3). In this chapter,
    we will cover what blockchain consensus is, how the traditional protocols can
    be applied to a blockchain, how proof of work works, how it was developed, and
    what the blockchain consensus requirements are, and we will analyze
  prefs: []
  type: TYPE_NORMAL
- en: blockchain consensus such as proof of work through the lens of distributed consensus.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we’ll see how the requirements of consensus may change depending upon
    the type
  prefs: []
  type: TYPE_NORMAL
- en: of blockchain in use. For example, for public blockchains proof of work might
    be a better idea, whereas for permissioned blockchains BFT-style protocols may
    work better.
  prefs: []
  type: TYPE_NORMAL
- en: '207'
  prefs: []
  type: TYPE_NORMAL
- en: © Imran Bashir 2022
  prefs: []
  type: TYPE_NORMAL
- en: I. Bashir, *Blockchain Consensus*, [https://doi.org/10.1007/978-1-4842-8179-6_5](https://doi.org/10.1007/978-1-4842-8179-6_5#DOI)
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 5 BloCkChain Consensus
  prefs: []
  type: TYPE_NORMAL
- en: '**Background**'
  prefs: []
  type: TYPE_NORMAL
- en: Distributed consensus has always been a fundamental problem in distributed systems.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, in blockchain it plays a vital role in ensuring the integrity of
    the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two broad classes of algorithms that have emerged as a result of
    the last almost 45 years of research on distributed consensus:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Leader-based traditional distributed consensus or permissioned
  prefs: []
  type: TYPE_NORMAL
- en: consensus
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Nakamoto and post-Nakamoto consensus or permissionless consensus
  prefs: []
  type: TYPE_NORMAL
- en: Leader-based protocols work on the principle of voting where nodes in a distributed
  prefs: []
  type: TYPE_NORMAL
- en: system vote to perform an operation. These protocols are usually deterministic
    and
  prefs: []
  type: TYPE_NORMAL
- en: have been researched since the 1970s. Some such protocols include Paxos, PBFT,
    and
  prefs: []
  type: TYPE_NORMAL
- en: RAFT. Another different type of class emerged in 2008 with Bitcoin, which relied
    on the proof of work type of crypto puzzle. This type of protocol is probabilistic
    where a participant wins the right to append a new block to the blockchain by
    solving the proof of work.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, in the blockchain world, Byzantine fault–tolerant protocols are used,
  prefs: []
  type: TYPE_NORMAL
- en: especially because these blockchains are expected to either run publicly or
    in a
  prefs: []
  type: TYPE_NORMAL
- en: consortium environment where malicious attacks are a reality. Perhaps not so
    much
  prefs: []
  type: TYPE_NORMAL
- en: on consortium chains where the participants are known, but still due to the
    nature of
  prefs: []
  type: TYPE_NORMAL
- en: the enterprise applications that run on these platforms, it’s best to consider
    a Byzantine fault–tolerant model. Applications related to finance, health, egovernance,
    and many
  prefs: []
  type: TYPE_NORMAL
- en: other use cases run on consortium chains; therefore, it is necessary to ensure
    protection against any arbitrary faults including even active adversaries.
  prefs: []
  type: TYPE_NORMAL
- en: There are pros and cons of both approaches. Traditional BFT protocols or their
  prefs: []
  type: TYPE_NORMAL
- en: variants in the blockchain provide stronger consistency as compared to proof
    of work–
  prefs: []
  type: TYPE_NORMAL
- en: type algorithms, which can only offer eventual consistency. However, proof of
    work
  prefs: []
  type: TYPE_NORMAL
- en: consensus is much more scalable as compared to traditional BFT protocols. See
    a
  prefs: []
  type: TYPE_NORMAL
- en: comparison in Ta[ble 5-1 b](#p226)etween BFT and PoW consensus.
  prefs: []
  type: TYPE_NORMAL
- en: '208'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 5 BloCkChain Consensus
  prefs: []
  type: TYPE_NORMAL
- en: '***Table 5-1\.** Traditional BFT vs. Nakamoto consensus*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Property**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Traditional BFT**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Nakamoto**'
  prefs: []
  type: TYPE_NORMAL
- en: agreement
  prefs: []
  type: TYPE_NORMAL
- en: Deterministic
  prefs: []
  type: TYPE_NORMAL
- en: eventual
  prefs: []
  type: TYPE_NORMAL
- en: termination
  prefs: []
  type: TYPE_NORMAL
- en: Deterministic
  prefs: []
  type: TYPE_NORMAL
- en: probabilistic
  prefs: []
  type: TYPE_NORMAL
- en: energy consumption
  prefs: []
  type: TYPE_NORMAL
- en: low
  prefs: []
  type: TYPE_NORMAL
- en: Very high
  prefs: []
  type: TYPE_NORMAL
- en: sybil resistance
  prefs: []
  type: TYPE_NORMAL
- en: 'no'
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes'
  prefs: []
  type: TYPE_NORMAL
- en: Finality
  prefs: []
  type: TYPE_NORMAL
- en: immediate
  prefs: []
  type: TYPE_NORMAL
- en: probabilistic
  prefs: []
  type: TYPE_NORMAL
- en: Consistency
  prefs: []
  type: TYPE_NORMAL
- en: stronger
  prefs: []
  type: TYPE_NORMAL
- en: Weaker (eventual)
  prefs: []
  type: TYPE_NORMAL
- en: Communication pattern
  prefs: []
  type: TYPE_NORMAL
- en: Broadcast
  prefs: []
  type: TYPE_NORMAL
- en: epidemic
  prefs: []
  type: TYPE_NORMAL
- en: throughput (tps)
  prefs: []
  type: TYPE_NORMAL
- en: higher
  prefs: []
  type: TYPE_NORMAL
- en: low
  prefs: []
  type: TYPE_NORMAL
- en: scalability
  prefs: []
  type: TYPE_NORMAL
- en: lower (10–100 nodes)
  prefs: []
  type: TYPE_NORMAL
- en: higher (1000s of nodes)
  prefs: []
  type: TYPE_NORMAL
- en: Forking
  prefs: []
  type: TYPE_NORMAL
- en: none
  prefs: []
  type: TYPE_NORMAL
- en: possible
  prefs: []
  type: TYPE_NORMAL
- en: identity
  prefs: []
  type: TYPE_NORMAL
- en: known
  prefs: []
  type: TYPE_NORMAL
- en: anonymous (pseudonymous)
  prefs: []
  type: TYPE_NORMAL
- en: network
  prefs: []
  type: TYPE_NORMAL
- en: peer to peer
  prefs: []
  type: TYPE_NORMAL
- en: peer to peer
  prefs: []
  type: TYPE_NORMAL
- en: order
  prefs: []
  type: TYPE_NORMAL
- en: temporal
  prefs: []
  type: TYPE_NORMAL
- en: temporal
  prefs: []
  type: TYPE_NORMAL
- en: Formal rigor (correctness proofs, etc.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes'
  prefs: []
  type: TYPE_NORMAL
- en: Mostly nonexistent
  prefs: []
  type: TYPE_NORMAL
- en: Fault tolerance
  prefs: []
  type: TYPE_NORMAL
- en: 1/3, <=33%
  prefs: []
  type: TYPE_NORMAL
- en: <=25% computing power*
  prefs: []
  type: TYPE_NORMAL
- en: '>50% computing power'
  prefs: []
  type: TYPE_NORMAL
- en: number of clients
  prefs: []
  type: TYPE_NORMAL
- en: Many
  prefs: []
  type: TYPE_NORMAL
- en: Many
  prefs: []
  type: TYPE_NORMAL
- en: Another point to keep in mind is the distinction between a broadcast problem
    and
  prefs: []
  type: TYPE_NORMAL
- en: a consensus problem. Consensus is a decision problem, whereas broadcast is a
    delivery
  prefs: []
  type: TYPE_NORMAL
- en: problem. The properties of both are the same but with slightly different definitions.
  prefs: []
  type: TYPE_NORMAL
- en: These properties include agreement, validity, integrity, and termination. In
    essence,
  prefs: []
  type: TYPE_NORMAL
- en: broadcast and consensus are interrelated and deeply connected problems as it
    is
  prefs: []
  type: TYPE_NORMAL
- en: possible to implement one from the other.
  prefs: []
  type: TYPE_NORMAL
- en: We will be focusing more on a consensus problem instead of a broadcast problem.
  prefs: []
  type: TYPE_NORMAL
- en: '209'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 5 BloCkChain Consensus
  prefs: []
  type: TYPE_NORMAL
- en: '**Blockchain Consensus**'
  prefs: []
  type: TYPE_NORMAL
- en: A blockchain consensus protocol is a mechanism that allows participants in a
  prefs: []
  type: TYPE_NORMAL
- en: blockchain system to agree on a sequence of transactions even in the presence
    of faults.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, consensus algorithms ensure that all parties agree on a single
    source of
  prefs: []
  type: TYPE_NORMAL
- en: truth even if some parties are faulty.
  prefs: []
  type: TYPE_NORMAL
- en: There are some properties that are associated with blockchain consensus. The
  prefs: []
  type: TYPE_NORMAL
- en: properties are almost the same as standard distributed consensus but with a
    slight
  prefs: []
  type: TYPE_NORMAL
- en: variation.
  prefs: []
  type: TYPE_NORMAL
- en: As a standard, there are safety and liveness properties. The safety and liveness
    properties change depending on the type of blockchain. First, we define the safety
    and liveness
  prefs: []
  type: TYPE_NORMAL
- en: properties for a permissioned/consortium blockchain and then for a public blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: '**Traditional BFT**'
  prefs: []
  type: TYPE_NORMAL
- en: There are several properties that we can define for traditional BFT consensus,
    which are
  prefs: []
  type: TYPE_NORMAL
- en: commonly used in a permissioned blockchain. There are various variants, for
    example,
  prefs: []
  type: TYPE_NORMAL
- en: Tendermint, that are used in a blockchain. We covered traditional BFT in detail
    in
  prefs: []
  type: TYPE_NORMAL
- en: Chapt[er 3; ho](https://doi.org/10.1007/978-1-4842-8179-6_3)wever, in this section
    we will redefine that in the context of a blockchain and especially permissioned
    blockchain. Most of the properties remain the same as
  prefs: []
  type: TYPE_NORMAL
- en: public permissionless consensus; however, the key difference is between deterministic
  prefs: []
  type: TYPE_NORMAL
- en: and probabilistic termination and agreement.
  prefs: []
  type: TYPE_NORMAL
- en: '**Agreement**'
  prefs: []
  type: TYPE_NORMAL
- en: No two honest processes decide on a different block. In other words, no two
    honest
  prefs: []
  type: TYPE_NORMAL
- en: processes commit different blocks at the same height.
  prefs: []
  type: TYPE_NORMAL
- en: '**Validity**'
  prefs: []
  type: TYPE_NORMAL
- en: If an honest process decides on a block *b*, then b satisfies the application-specific
    validity predicate *valid ()*. Also, the block b agreed must be proposed by some
    honest node.
  prefs: []
  type: TYPE_NORMAL
- en: '**Termination**'
  prefs: []
  type: TYPE_NORMAL
- en: Every honest process decides. After GST, every honest process continuously
  prefs: []
  type: TYPE_NORMAL
- en: commits blocks.
  prefs: []
  type: TYPE_NORMAL
- en: Agreement and validity are safety properties, whereas termination is a liveness
    property.
  prefs: []
  type: TYPE_NORMAL
- en: '210'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 5 BloCkChain Consensus
  prefs: []
  type: TYPE_NORMAL
- en: '**Integrity**'
  prefs: []
  type: TYPE_NORMAL
- en: A process must decide at most once in a consensus round.
  prefs: []
  type: TYPE_NORMAL
- en: Other properties can include the following.
  prefs: []
  type: TYPE_NORMAL
- en: '**Chain Progress (Liveness)**'
  prefs: []
  type: TYPE_NORMAL
- en: A blockchain must keep growing by continuously appending new blocks to it after
    GST.
  prefs: []
  type: TYPE_NORMAL
- en: '**Instant Irrevocability**'
  prefs: []
  type: TYPE_NORMAL
- en: Once a transaction has made it to the block and the block is finalized, the
    transaction
  prefs: []
  type: TYPE_NORMAL
- en: cannot be removed.
  prefs: []
  type: TYPE_NORMAL
- en: '**Consensus Finality**'
  prefs: []
  type: TYPE_NORMAL
- en: Finality is deterministic and immediate. Transactions are final as soon as they’ve
    made it to the block, and blocks are final as soon as they’ve been appended to
    the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: While there are many blockchain consensus algorithms now, Nakamoto consensus
  prefs: []
  type: TYPE_NORMAL
- en: is the first blockchain protocol introduced with Bitcoin, which has several
    novel
  prefs: []
  type: TYPE_NORMAL
- en: properties. Indeed, it is not a classical Byzantine algorithm with deterministic
    properties; instead, it has probabilistic features.
  prefs: []
  type: TYPE_NORMAL
- en: '**Nakamoto Consensus**'
  prefs: []
  type: TYPE_NORMAL
- en: The Nakamoto or PoW consensus can be characterized with several properties.
    It is
  prefs: []
  type: TYPE_NORMAL
- en: commonly used in public blockchains, for example, Bitcoin.
  prefs: []
  type: TYPE_NORMAL
- en: '**Agreement**'
  prefs: []
  type: TYPE_NORMAL
- en: Eventually, no two honest processes decide on a different block.
  prefs: []
  type: TYPE_NORMAL
- en: '**Validity**'
  prefs: []
  type: TYPE_NORMAL
- en: If an honest process decides on a block b, then b satisfies the application-specific
    validity predicate valid (). Also, the transactions within the block satisfy the
    application-specific validity predicate valid(). In other words, only valid and
    correct transactions make it
  prefs: []
  type: TYPE_NORMAL
- en: to the block, and only correct and valid blocks make it to the blockchain. Only
    valid
  prefs: []
  type: TYPE_NORMAL
- en: '211'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 5 BloCkChain Consensus
  prefs: []
  type: TYPE_NORMAL
- en: transactions and blocks are accepted by the nodes. Also, mining nodes (miners)
    will only
  prefs: []
  type: TYPE_NORMAL
- en: accept the valid transactions. In addition, the decided value must be proposed
    by some
  prefs: []
  type: TYPE_NORMAL
- en: honest process.
  prefs: []
  type: TYPE_NORMAL
- en: '**Termination**'
  prefs: []
  type: TYPE_NORMAL
- en: Every honest process eventually decides.
  prefs: []
  type: TYPE_NORMAL
- en: Agreement and validity are safety properties, whereas termination is a liveness
  prefs: []
  type: TYPE_NORMAL
- en: property.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note** in public blockchain networks, an economic incentive is usually associated'
  prefs: []
  type: TYPE_NORMAL
- en: with the consensus properties so that participants who are working toward
  prefs: []
  type: TYPE_NORMAL
- en: ensuring the safety and liveness of the network are economically incentivized
  prefs: []
  type: TYPE_NORMAL
- en: to do so.
  prefs: []
  type: TYPE_NORMAL
- en: Remember we discussed randomized algorithms earlier in Chapt[er 3](https://doi.org/10.1007/978-1-4842-8179-6_3),
    where termination is guaranteed probabilistically. Randomized protocols are used
    to
  prefs: []
  type: TYPE_NORMAL
- en: circumvent FLP impossibility. Usually, the termination property is made probabilistic
  prefs: []
  type: TYPE_NORMAL
- en: to achieve an agreement to circumvent FLP impossibility. However, with the Bitcoin
  prefs: []
  type: TYPE_NORMAL
- en: blockchain, the agreement property is made probabilistic instead of termination.
    Here,
  prefs: []
  type: TYPE_NORMAL
- en: the safety property is somewhat sacrificed because in the Bitcoin blockchain,
    it is
  prefs: []
  type: TYPE_NORMAL
- en: allowed that temporarily a fork can occur, and when the fork is resolved, some
    previously finalized transactions are rolled back. This is due to the longest
    chain rule.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few other properties which we describe now.
  prefs: []
  type: TYPE_NORMAL
- en: '**Consensus Finality**'
  prefs: []
  type: TYPE_NORMAL
- en: With two correct processes p1 and p2, if p1 appends a block b to its local blockchain
  prefs: []
  type: TYPE_NORMAL
- en: before another block b’, then no other correct node appends b’ before b.
  prefs: []
  type: TYPE_NORMAL
- en: For a proof of work blockchain point of view, we can further carve out some
  prefs: []
  type: TYPE_NORMAL
- en: properties.
  prefs: []
  type: TYPE_NORMAL
- en: '212'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 5 BloCkChain Consensus
  prefs: []
  type: TYPE_NORMAL
- en: '**Chain Progress (Liveness)**'
  prefs: []
  type: TYPE_NORMAL
- en: A blockchain must keep growing steadily by new blocks continuously being appended
    to
  prefs: []
  type: TYPE_NORMAL
- en: it every n interval. N can be a predefined time interval defined by the protocol.
  prefs: []
  type: TYPE_NORMAL
- en: '**Consistent/Consistency**'
  prefs: []
  type: TYPE_NORMAL
- en: The blockchain must eventually heal a forked chain to arrive at a single longest
    chain. In other words, everyone must see the same history.
  prefs: []
  type: TYPE_NORMAL
- en: '**Eventual Irrevocability**'
  prefs: []
  type: TYPE_NORMAL
- en: The probability of a transaction being rolled back decreases with more blocks
    appended
  prefs: []
  type: TYPE_NORMAL
- en: to the blockchain. This is a crucial property from end users’ point of view
    as this
  prefs: []
  type: TYPE_NORMAL
- en: property gives confidence to the users that after their transaction has been
    made part
  prefs: []
  type: TYPE_NORMAL
- en: of a block and it’s been finalized and accepted, then new blocks being added
    to the
  prefs: []
  type: TYPE_NORMAL
- en: blockchain further ensure that the transaction is permanently and irrevocably
    part of the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: Table [5-1](#p226) shows some key differences between traditional BFT and Nakamoto
    consensus.
  prefs: []
  type: TYPE_NORMAL
- en: Now we turn our attention to system models, which are necessary to describe
    as
  prefs: []
  type: TYPE_NORMAL
- en: they capture the assumption that we make about the environment in which blockchain
  prefs: []
  type: TYPE_NORMAL
- en: consensus protocols will operate.
  prefs: []
  type: TYPE_NORMAL
- en: '**System Model**'
  prefs: []
  type: TYPE_NORMAL
- en: Blockchain consensus protocols assume a system model under which they guarantee
    the
  prefs: []
  type: TYPE_NORMAL
- en: safety and liveness properties. Here, I describe two system models, which are
    generally
  prefs: []
  type: TYPE_NORMAL
- en: applicable to public and permissioned blockchain systems, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '**Public Blockchain System Model (Permissionless)**'
  prefs: []
  type: TYPE_NORMAL
- en: A blockchain is a distributed system where nodes communicate via message passing.
  prefs: []
  type: TYPE_NORMAL
- en: The broadcast protocol is usually probabilistic in the case of a public blockchain
    where
  prefs: []
  type: TYPE_NORMAL
- en: transactions (messages) are disseminated by utilizing a gossip-style protocol.
  prefs: []
  type: TYPE_NORMAL
- en: '213'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 5 BloCkChain Consensus
  prefs: []
  type: TYPE_NORMAL
- en: Usually, the network model is asynchronous as there is no bound on the processor
  prefs: []
  type: TYPE_NORMAL
- en: delay or communication delay, especially because a public blockchain system
    is most
  prefs: []
  type: TYPE_NORMAL
- en: likely to be heterogenous and geographically dispersed. Nodes do not know each
    other,
  prefs: []
  type: TYPE_NORMAL
- en: nor do they know how many total nodes are there in the system. Nodes can arbitrarily
  prefs: []
  type: TYPE_NORMAL
- en: join and drop off the network. Anyone can join by simply running the protocol
    software
  prefs: []
  type: TYPE_NORMAL
- en: on the network.
  prefs: []
  type: TYPE_NORMAL
- en: '**Consortium Blockchain System Model (Permissioned)**'
  prefs: []
  type: TYPE_NORMAL
- en: In this model, blockchain nodes communicate via message passing. A broadcast
  prefs: []
  type: TYPE_NORMAL
- en: protocol is usually a one-to-all communication within the consensus protocol.
    For
  prefs: []
  type: TYPE_NORMAL
- en: example, in PBFT the leader broadcasts its proposal in one go to all replicas,
    instead
  prefs: []
  type: TYPE_NORMAL
- en: of sending it to a few, and then those other nodes send it to other nodes, as
    we saw
  prefs: []
  type: TYPE_NORMAL
- en: in gossip dissemination. Moreover, the network model is partially synchronous.
  prefs: []
  type: TYPE_NORMAL
- en: More precisely, blockchain consensus protocols are modelled under an eventually
  prefs: []
  type: TYPE_NORMAL
- en: synchronous model where after an unknown GST the system is guaranteed to make
  prefs: []
  type: TYPE_NORMAL
- en: progress.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s turn our attention to the first blockchain consensus protocol and
    explore
  prefs: []
  type: TYPE_NORMAL
- en: 'how it works: the proof of work protocol or Nakamoto consensus.'
  prefs: []
  type: TYPE_NORMAL
- en: '**First Blockchain Consensus**'
  prefs: []
  type: TYPE_NORMAL
- en: The proof of work consensus algorithm or Nakamoto consensus was first introduced
  prefs: []
  type: TYPE_NORMAL
- en: with the Bitcoin blockchain in 2008\. It is fundamentally a leader election
    algorithm
  prefs: []
  type: TYPE_NORMAL
- en: where a mandatory and random waiting time is imposed between leader elections.
    This
  prefs: []
  type: TYPE_NORMAL
- en: also serves as a Sybil attack mechanism. One of the weaknesses in traditional
    distributed consensus protocols is that they need each participant to be known
    and identifiable in
  prefs: []
  type: TYPE_NORMAL
- en: the protocol. For example, in PBFT all participants must be known and identifiable.
    This
  prefs: []
  type: TYPE_NORMAL
- en: limitation (albeit useful in consortium chains) makes BFT-style protocols somewhat
  prefs: []
  type: TYPE_NORMAL
- en: unsuitable for public chains. This is so because an attacker can create multiple
  prefs: []
  type: TYPE_NORMAL
- en: identities and can use those multiple nodes/identities to vote in their favor.
    This is the so-called Sybil attack. If somehow we can make creating and then using
    that identity
  prefs: []
  type: TYPE_NORMAL
- en: on a blockchain an expensive operation, then such a setup can thwart any Sybil
    attack
  prefs: []
  type: TYPE_NORMAL
- en: attempts and will prevent an attacker from taking over the network by creating
    multiple
  prefs: []
  type: TYPE_NORMAL
- en: fake identities.
  prefs: []
  type: TYPE_NORMAL
- en: '214'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 5 BloCkChain Consensus
  prefs: []
  type: TYPE_NORMAL
- en: the term sybil attack is coined after a book named *Sybil* published in 1973,
    where the main character in the book named sybil Dorsett has multiple personality
  prefs: []
  type: TYPE_NORMAL
- en: disorder.
  prefs: []
  type: TYPE_NORMAL
- en: The first proof of work was introduced by Dwork and Naor in 1992 [1]. This work
    was
  prefs: []
  type: TYPE_NORMAL
- en: done to combat junk emails whereby associating a computational cost, that is,
    pricing
  prefs: []
  type: TYPE_NORMAL
- en: functions, with sending emails results in creating a type of access control
    mechanism
  prefs: []
  type: TYPE_NORMAL
- en: where access to resources can only be obtained by computing a moderately hard
  prefs: []
  type: TYPE_NORMAL
- en: function which prevents excessive use. Proof of work has also been proposed
    in Adam
  prefs: []
  type: TYPE_NORMAL
- en: Back’s Hashcash proposal [10].
  prefs: []
  type: TYPE_NORMAL
- en: The key intuition behind proof of work in a blockchain is to universally slow
  prefs: []
  type: TYPE_NORMAL
- en: down the proposals for all participants, which achieves two goals. First, it
    allows all
  prefs: []
  type: TYPE_NORMAL
- en: participants to converge on a common consistent view, and, second, it makes
    Sybil
  prefs: []
  type: TYPE_NORMAL
- en: attacks very expensive, which helps with the integrity of the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: It has been observed that it is impossible (impossibility results) to achieve
    an
  prefs: []
  type: TYPE_NORMAL
- en: agreement in a network where participants are anonymous even if there is only
    one
  prefs: []
  type: TYPE_NORMAL
- en: Byzantine node [2]. This is due to the Sybil attack, which can create arbitrarily
    many
  prefs: []
  type: TYPE_NORMAL
- en: identities to game the system in attackers’ favor by voting many times. If there
    is a way to prevent such attacks, only then there is some guarantee that the system
    will work
  prefs: []
  type: TYPE_NORMAL
- en: as expected; otherwise, the attacker can create arbitrarily many identities
    to attack the system. This problem was solved practically by proof of work consensus
    or Nakamoto
  prefs: []
  type: TYPE_NORMAL
- en: consensus [3]. Before Bitcoin, the use of moderately hard puzzles to assign
    identities in an anonymous network was first suggested by Aspnes [4]. However,
    the solution that
  prefs: []
  type: TYPE_NORMAL
- en: Aspnes introduced requires authenticated channels, whereas in Bitcoin unauthenticated
  prefs: []
  type: TYPE_NORMAL
- en: communication is used, and puzzles are noninteractive and publicly verifiable.
  prefs: []
  type: TYPE_NORMAL
- en: So even in the presence of the abovementioned impossibility results in classical
  prefs: []
  type: TYPE_NORMAL
- en: literature, Nakamoto consensus emerged, which for the first time showed that
    consensus
  prefs: []
  type: TYPE_NORMAL
- en: can be achieved in a permissionless model.
  prefs: []
  type: TYPE_NORMAL
- en: Remember we discussed random oracles in Chapter [3](https://doi.org/10.1007/978-1-4842-8179-6_3).
    In proof of work, hash functions are used to instantiate random oracles. Since
    the output of hash functions
  prefs: []
  type: TYPE_NORMAL
- en: is sufficiently long and random, an adversary cannot predict future hashes or
    can
  prefs: []
  type: TYPE_NORMAL
- en: cause hash collisions. These properties make SHA-256 a good choice to use it
    as a hash
  prefs: []
  type: TYPE_NORMAL
- en: function in the proof of work mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: '215'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-233_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 5 BloCkChain Consensus
  prefs: []
  type: TYPE_NORMAL
- en: The key requirement in a blockchain is to totally order the transactions. If
    all
  prefs: []
  type: TYPE_NORMAL
- en: participants are known and the scale is limited to a few nodes, then we can
    use
  prefs: []
  type: TYPE_NORMAL
- en: traditional consensus like BFT; however, with thousands of unknown nodes, traditional
  prefs: []
  type: TYPE_NORMAL
- en: BFT cannot be used. The proof of work consensus mechanism addresses this issue.
  prefs: []
  type: TYPE_NORMAL
- en: There is a scalability vs. performance trade-off [6] that comes up when comparing
  prefs: []
  type: TYPE_NORMAL
- en: traditional BFT with PoW, as shown in Figur[e 5-1\.](#p233)
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 5-1\.** Performance vs. scalability*'
  prefs: []
  type: TYPE_NORMAL
- en: The proof of work or Nakamoto consensus protocol is a Byzantine fault–tolerant
  prefs: []
  type: TYPE_NORMAL
- en: protocol because it can tolerate arbitrary faults. It can be seen as an **eventual
    Byzantine** **agreement** mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: '**How PoW Works**'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s first define some of the requirements of PoW. Indeed, proof of work was
    originally
  prefs: []
  type: TYPE_NORMAL
- en: introduced in Bitcoin without any rigorous documentation or proofs of correctness.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, for clarity and easier understanding, we will list some of the requirements
    (almost retrospectively) and see if PoW fulfills those requirements and how:'
  prefs: []
  type: TYPE_NORMAL
- en: '• **Consistency**: New blocks are replicated to all nodes.'
  prefs: []
  type: TYPE_NORMAL
- en: '• **Linked with previous block**: A log is maintained in such a way that'
  prefs: []
  type: TYPE_NORMAL
- en: each new entry is linked with the previous entry forming a chain.
  prefs: []
  type: TYPE_NORMAL
- en: '• **Permissionless and open participation**: Nodes can join without any'
  prefs: []
  type: TYPE_NORMAL
- en: access control and can leave without notice.
  prefs: []
  type: TYPE_NORMAL
- en: '216'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 5 BloCkChain Consensus
  prefs: []
  type: TYPE_NORMAL
- en: • Partition tolerance.
  prefs: []
  type: TYPE_NORMAL
- en: • Geographically dispersed.
  prefs: []
  type: TYPE_NORMAL
- en: • Thousands of nodes allowed where anyone anywhere in the world
  prefs: []
  type: TYPE_NORMAL
- en: can download a client and become part of the network by running
  prefs: []
  type: TYPE_NORMAL
- en: the client.
  prefs: []
  type: TYPE_NORMAL
- en: • Highly adversarial environment, so Byzantine fault tolerance is of
  prefs: []
  type: TYPE_NORMAL
- en: prime importance.
  prefs: []
  type: TYPE_NORMAL
- en: • Heterogenous where a number of different types of computers and
  prefs: []
  type: TYPE_NORMAL
- en: hardware devices can join.
  prefs: []
  type: TYPE_NORMAL
- en: • Asynchronous in the sense that there is no bound on the CPU or
  prefs: []
  type: TYPE_NORMAL
- en: communication delays, just an eventual guarantee that messages are
  prefs: []
  type: TYPE_NORMAL
- en: expected to reach all nodes with high probability.
  prefs: []
  type: TYPE_NORMAL
- en: The question is, how do you design a consensus protocol for such a difficult
  prefs: []
  type: TYPE_NORMAL
- en: environment? Yet, Bitcoin PoW has stood the test of time, and apart from some
    limited
  prefs: []
  type: TYPE_NORMAL
- en: and carefully orchestrated attacks and some inadvertent bugs, largely the Bitcoin
  prefs: []
  type: TYPE_NORMAL
- en: network has been running without any issues for the last 13 years. How? I’ll
    explain now.
  prefs: []
  type: TYPE_NORMAL
- en: '**Pedagogical Explanation of PoW**'
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a scenario where a node has proposed a block and has broadcast it to
    the network.
  prefs: []
  type: TYPE_NORMAL
- en: The nodes that receive it can do either of two things. Either they can accept
    the block
  prefs: []
  type: TYPE_NORMAL
- en: and append it to a local blockchain, or they can reject it if the block is not
    valid. Now also imagine the block is indeed valid, then the receiving nodes can
    simply accept it and agree on the proposed block. Imagine there is only a proposer
    node ever in the entire system,
  prefs: []
  type: TYPE_NORMAL
- en: and that node is honest and trustworthy. This means that there is no real consensus
  prefs: []
  type: TYPE_NORMAL
- en: required; the proposer node simply proposes new blocks, and nodes agree to it,
    resulting
  prefs: []
  type: TYPE_NORMAL
- en: in an eventual total order of blocks containing transactions. But this is a
    centralized system with a trusted third party that, if it stays honest, as a leader,
    can drive the whole system because everyone trusts it. What if it turned malicious,
    then it’s a problem?
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps, we can allow other nodes to propose as well, to take away control from
    that
  prefs: []
  type: TYPE_NORMAL
- en: single node, which is not trustworthy. Imagine that we now have two nodes proposing
  prefs: []
  type: TYPE_NORMAL
- en: valid blocks and broadcasting them on the network. Now there is a problem; some
    of
  prefs: []
  type: TYPE_NORMAL
- en: the receiving nodes will add one block and then the other. Some wouldn’t know
    which
  prefs: []
  type: TYPE_NORMAL
- en: '217'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 5 BloCkChain Consensus
  prefs: []
  type: TYPE_NORMAL
- en: one to accept or which to reject. Proposals are made at the same time, and now
    nodes
  prefs: []
  type: TYPE_NORMAL
- en: don’t know which block to insert; perhaps, they will insert both. Now some nodes
    have
  prefs: []
  type: TYPE_NORMAL
- en: inserted blocks from proposer 1 and the others from proposer 2 only and some
    from
  prefs: []
  type: TYPE_NORMAL
- en: both. As you can imagine, there is no consensus here.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine another scenario where two nodes simultaneously announce a block; now
  prefs: []
  type: TYPE_NORMAL
- en: the receiving nodes will receive two blocks, and instead of one chain, there
    are now two
  prefs: []
  type: TYPE_NORMAL
- en: chains. In other words, there are two logs and histories of events. Two nodes
    proposed a
  prefs: []
  type: TYPE_NORMAL
- en: block at the same time; all nodes added two blocks. Now it is no longer a single
    chain, it is a tree, with two branches. This is called a fork. In other words,
    if nodes learn about two different blocks pointing to the same parent at the same
    time, then the blockchain forks
  prefs: []
  type: TYPE_NORMAL
- en: into two chains.
  prefs: []
  type: TYPE_NORMAL
- en: Now in order to resolve this, we can allow nodes to pick the longest chain of
    blocks
  prefs: []
  type: TYPE_NORMAL
- en: at that time that they know of and add the new block to that chain and ignore
    the other
  prefs: []
  type: TYPE_NORMAL
- en: branch. If it so happens that there are two or more branches somehow with the
    same
  prefs: []
  type: TYPE_NORMAL
- en: height (same length), then just pick up randomly one of the chains and add the
    new block
  prefs: []
  type: TYPE_NORMAL
- en: to it. This way, we can resolve this fork. Now all nodes, knowing this rule
    that only the longest chain is allowed to have new blocks, will keep building
    the longest chain. In the case of two or more same height chains, then just randomly
    add the block to any of these.
  prefs: []
  type: TYPE_NORMAL
- en: So far, so good! This scheme appears to work. A node decides to add the new
    block into a
  prefs: []
  type: TYPE_NORMAL
- en: randomly chosen chain and propagates that decision to others, and other nodes
    add that
  prefs: []
  type: TYPE_NORMAL
- en: same block to their chains. Over time, the longest chain takes over, and the
    shorter chain is ignored because no new blocks are added to it, because it’s not
    the longest chain.
  prefs: []
  type: TYPE_NORMAL
- en: But now there is another problem. Imagine a situation where a node randomly
  prefs: []
  type: TYPE_NORMAL
- en: chooses one chain after a fork, adds a block to it, propagates that decision
    to others,
  prefs: []
  type: TYPE_NORMAL
- en: other nodes add as well, and, at this point, some nodes due to latency don’t
    hear about
  prefs: []
  type: TYPE_NORMAL
- en: the decision. Some nodes add the block they heard from another node to one of
    its
  prefs: []
  type: TYPE_NORMAL
- en: chains, another one does the opposite, and this cycle repeats. Now you can clearly
    see
  prefs: []
  type: TYPE_NORMAL
- en: that there are two chains, both getting new blocks. There is no consensus. There
    is a
  prefs: []
  type: TYPE_NORMAL
- en: livelock situation where nodes can keep adding to both chains.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, let’s think about what the fundamental reason is and why this
  prefs: []
  type: TYPE_NORMAL
- en: livelock is occurring. The reason is that blocks are generating too fast, and
    other nodes receive many different blocks from different nodes, some quickly,
    some delayed. This
  prefs: []
  type: TYPE_NORMAL
- en: asynchrony results in a livelock. The solution? Slow it down! Give nodes time
    to converge to one chain! Let’s see how.
  prefs: []
  type: TYPE_NORMAL
- en: '218'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 5 BloCkChain Consensus
  prefs: []
  type: TYPE_NORMAL
- en: We can introduce a random waiting period, which will make miners to arbitrarily
    sleep
  prefs: []
  type: TYPE_NORMAL
- en: for some time and then mine. The key insight here is that the livelock (continuous
    fork)
  prefs: []
  type: TYPE_NORMAL
- en: problem can be resolved by introducing a variable speed timer at each node.
    When a node
  prefs: []
  type: TYPE_NORMAL
- en: adds a new block to its chain, it stops its timer and sends it to other nodes.
    Other nodes are waiting for their timers to expire, but during that waiting time,
    if they hear about this new block from another node, they simply stop their timers
    and add this new block and
  prefs: []
  type: TYPE_NORMAL
- en: reset the timers and start waiting again. This way, there will only be one block
    added to the chain, instead of two. If the timers are long enough, then chances
    of forking and livelocking decrease significantly. Another thing to note here
    is that if there are many nodes in the system, then there is a higher chance that
    some timer will expire soon, and as we keep
  prefs: []
  type: TYPE_NORMAL
- en: adding more and more nodes, the probability of such occurrences increases because
  prefs: []
  type: TYPE_NORMAL
- en: timers are random and there are many nodes now. In order to avoid the same livelock
  prefs: []
  type: TYPE_NORMAL
- en: situations, we need to increase the sleeping time of these timers as we add
    more nodes,
  prefs: []
  type: TYPE_NORMAL
- en: so that the probability of adding a block by nodes quickly is decreased to such
    a level that only one node will eventually succeed to add a new block to their
    chain and will announce that to the network. Also, the waiting period ensures
    with high probability that forks will be resolved during this waiting time. It
    is enough time to ensure complete propagation of a new valid block so that no
    other block for the same height can be proposed.
  prefs: []
  type: TYPE_NORMAL
- en: Bitcoin chooses this timeout period based on the rate of block generation of
    2016
  prefs: []
  type: TYPE_NORMAL
- en: blocks, which is roughly two weeks. As the block generation should be roughly
    a single
  prefs: []
  type: TYPE_NORMAL
- en: block every ten minutes, if the protocol observes that the block generation
    has been
  prefs: []
  type: TYPE_NORMAL
- en: faster in the last two weeks, then it increases the timeout value, resulting
    in slower
  prefs: []
  type: TYPE_NORMAL
- en: generation of blocks. If the protocols observe that the block generation has
    been slower, then it decreases the timeout value. Now one problem in this timeout
    mechanism is
  prefs: []
  type: TYPE_NORMAL
- en: that if a single node turns malicious and always manages to somehow make its
    timer
  prefs: []
  type: TYPE_NORMAL
- en: expire earlier than other nodes, this node will end up creating a block every
    time. Now
  prefs: []
  type: TYPE_NORMAL
- en: the requirement becomes to build a timer which is resistant to such cheating.
    One
  prefs: []
  type: TYPE_NORMAL
- en: way of doing this is to build a trusted mechanism with some cryptographic security
  prefs: []
  type: TYPE_NORMAL
- en: guarantees to act as a secure enclave in which the timer code runs. This way,
    due to
  prefs: []
  type: TYPE_NORMAL
- en: cryptographic guarantees, the malicious node may not be able to trick the time
    into
  prefs: []
  type: TYPE_NORMAL
- en: always expiring first.
  prefs: []
  type: TYPE_NORMAL
- en: This technique is used in the PoET (proof of elapsed time) algorithm used in
  prefs: []
  type: TYPE_NORMAL
- en: Hyperledger Intel Sawtooth blockchain. We will discuss this in Chapt[er 8\.](https://doi.org/10.1007/978-1-4842-8179-6_8)
  prefs: []
  type: TYPE_NORMAL
- en: '219'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 5 BloCkChain Consensus
  prefs: []
  type: TYPE_NORMAL
- en: Another way, the original way, Nakamoto designed the algorithm is to make
  prefs: []
  type: TYPE_NORMAL
- en: computers do a computationally complex task which takes time to solve – just
    enough
  prefs: []
  type: TYPE_NORMAL
- en: to be able to solve it almost every ten minutes. Also, the task is formulated
    in such a
  prefs: []
  type: TYPE_NORMAL
- en: way that nodes cannot cheat, except to try to solve the problem. Any deviation
    from
  prefs: []
  type: TYPE_NORMAL
- en: the method of solving the problem will not help, as the only way to solve the
    problem
  prefs: []
  type: TYPE_NORMAL
- en: is to try every possible answer and match it with the expected answer. If the
    answer
  prefs: []
  type: TYPE_NORMAL
- en: matches with the expected answer, then the problem is solved; otherwise, the
    computer
  prefs: []
  type: TYPE_NORMAL
- en: will have to try the next answer and keep doing that in a brute-force manner
    until the
  prefs: []
  type: TYPE_NORMAL
- en: answer is found. This is a brilliant insight by Satoshi Nakamoto which ensures
    with
  prefs: []
  type: TYPE_NORMAL
- en: high probability that computers cannot cheat, and timers only expire almost
    every ten
  prefs: []
  type: TYPE_NORMAL
- en: minutes, giving one of the nodes the right to add its block to the blockchain.
    This is the so-called proof of work, meaning a node has done enough work to demonstrate
    that it
  prefs: []
  type: TYPE_NORMAL
- en: has spent enough computational power to solve the math problem to earn the right
    to
  prefs: []
  type: TYPE_NORMAL
- en: insert a new block to the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: Proof of work is based on cryptographic hash functions. It requires that for
    a block
  prefs: []
  type: TYPE_NORMAL
- en: to be valid, its hash must be less than a specific value. This means that the
    hash of the block must start with a certain number of zeroes. The only way to
    find such a hash is to
  prefs: []
  type: TYPE_NORMAL
- en: repeatedly try each possible hash and see if it matches the criterion; if not,
    then try again until one node finds such a hash. This means that in order to find
    a valid hash, it takes roughly ten minutes, thus introducing just enough delay
    which results in resolving forks
  prefs: []
  type: TYPE_NORMAL
- en: and convergence on one chain while minimizing the chance of one node winning
    the
  prefs: []
  type: TYPE_NORMAL
- en: right to create a new block every time.
  prefs: []
  type: TYPE_NORMAL
- en: Now it is easy to see that proof of work is a mechanism to introduce waiting
    time
  prefs: []
  type: TYPE_NORMAL
- en: between block creation and ensuring that only one leader eventually emerges,
    which can
  prefs: []
  type: TYPE_NORMAL
- en: insert the new block to the chain.
  prefs: []
  type: TYPE_NORMAL
- en: So, it turns out that PoW is not, precisely speaking, a consensus algorithm;
    it is a
  prefs: []
  type: TYPE_NORMAL
- en: consensus facilitation algorithm which, due to slowing down block generations,
    allows
  prefs: []
  type: TYPE_NORMAL
- en: nodes to converge to a common blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: Now as we understand the intuition behind the proof of work mechanism, next
    we
  prefs: []
  type: TYPE_NORMAL
- en: will describe how exactly the proof of work algorithm works in Bitcoin.
  prefs: []
  type: TYPE_NORMAL
- en: '220'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 5 BloCkChain Consensus
  prefs: []
  type: TYPE_NORMAL
- en: '**PoW Formula**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The PoW consensus process can be described with the help of a formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '*SHAd* 256( *nonce* || *Block heade*'
  prefs: []
  type: TYPE_NORMAL
- en: '*r*) ≤ *target*'
  prefs: []
  type: TYPE_NORMAL
- en: where *SHAd* 256 represents a SHA-256 hash twice. In other words, double
  prefs: []
  type: TYPE_NORMAL
- en: SHA-256 means the hash of the hash of the input. A block header consists of
    Version,
  prefs: []
  type: TYPE_NORMAL
- en: hashPrevBlock, hashMerkleRoot, Time, Bits (difficulty target), and Nonce. Nonce
    is an
  prefs: []
  type: TYPE_NORMAL
- en: arbitrary number that is repeatedly changed and fed into the proof of work algorithm
    to
  prefs: []
  type: TYPE_NORMAL
- en: see if it results in a value which is less than or equal to the difficulty target.
  prefs: []
  type: TYPE_NORMAL
- en: The target value is calculated from the mining difficulty which changes every
    2016
  prefs: []
  type: TYPE_NORMAL
- en: blocks, which is equivalent to roughly two weeks. If miners are mining too fast
    – let’s say every eight minutes, they manage to generate a block instead of ten
    minutes – it means
  prefs: []
  type: TYPE_NORMAL
- en: there is too much hash power; therefore, as a regulation mechanism, the difficulty
    goes
  prefs: []
  type: TYPE_NORMAL
- en: up. If miners are producing blocks over the course of the previous 2016 blocks
    too slowly, say 1 block every 12 minutes, then it is slower than expected; therefore,
    the difficulty is regulated down. Let’s go through some formulas.
  prefs: []
  type: TYPE_NORMAL
- en: First, Bitcoin’s difficulty formula calculates the new difficulty for the next
    2016 blocks based on the rate of block generation of the previous 2016 blocks.
    The formula is
  prefs: []
  type: TYPE_NORMAL
- en: ( *previous difficulty*
  prefs: []
  type: TYPE_NORMAL
- en: × 2016×10 *minutes*)
  prefs: []
  type: TYPE_NORMAL
- en: '*New difficulty* = ( *time t* *ook* *to m* *ine* *most* *recent* 2016 *blocks*)
    This formula basically regulates the blockchain to produce new blocks roughly
    at a'
  prefs: []
  type: TYPE_NORMAL
- en: mean rate of ten minutes.
  prefs: []
  type: TYPE_NORMAL
- en: Now in order to calculate the target, first calculate the difficulty using the
    following
  prefs: []
  type: TYPE_NORMAL
- en: 'formula:'
  prefs: []
  type: TYPE_NORMAL
- en: ( *possible* *target* )
  prefs: []
  type: TYPE_NORMAL
- en: '*difficulty* = ( *current target*'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the target is calculated using the following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: ( *possible* *target* )
  prefs: []
  type: TYPE_NORMAL
- en: '*target* ='
  prefs: []
  type: TYPE_NORMAL
- en: ( *difficulty*)
  prefs: []
  type: TYPE_NORMAL
- en: '221'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 5 BloCkChain Consensus
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have established how the target value is calculated, let’s see what
  prefs: []
  type: TYPE_NORMAL
- en: miners do and how they find a hash which satisfies the preceding equation, that
    is, the
  prefs: []
  type: TYPE_NORMAL
- en: value obtained after hashing the block is less than the target value. In other
    words, the block hash must match a specific pattern where the hash starts with
    a certain number
  prefs: []
  type: TYPE_NORMAL
- en: of zeroes. This is also known as the partial hash inversion problem. This problem
    is to
  prefs: []
  type: TYPE_NORMAL
- en: find a partial preimage to the double SHA-256 hash function, which can only
    be found (if
  prefs: []
  type: TYPE_NORMAL
- en: ever) by trying different inputs one by one until one of the inputs works.
  prefs: []
  type: TYPE_NORMAL
- en: Fundamentally, Bitcoin mining is the process of finding a nonce that, when
  prefs: []
  type: TYPE_NORMAL
- en: concatenated with a block and hashed twice using the sha-256 hash function,
  prefs: []
  type: TYPE_NORMAL
- en: produces a number which starts with a specific number of zeroes.
  prefs: []
  type: TYPE_NORMAL
- en: So, what do miners do?
  prefs: []
  type: TYPE_NORMAL
- en: '**Task of Miners**'
  prefs: []
  type: TYPE_NORMAL
- en: In the Bitcoin blockchain network, when new transactions are executed by a user
    they
  prefs: []
  type: TYPE_NORMAL
- en: are broadcast to all nodes on the network via a peer-to-peer gossip protocol.
    These
  prefs: []
  type: TYPE_NORMAL
- en: 'transactions end up in transaction pools of nodes. Miners perform several tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: • Miners maintain transaction pools. They listen for incoming
  prefs: []
  type: TYPE_NORMAL
- en: transactions and keep those in their pools.
  prefs: []
  type: TYPE_NORMAL
- en: • They also listen for new blocks and append any new valid blocks
  prefs: []
  type: TYPE_NORMAL
- en: to their chain. This is of course not only the task for a miner, other
  prefs: []
  type: TYPE_NORMAL
- en: nonmining nodes also simply synchronize the blocks.
  prefs: []
  type: TYPE_NORMAL
- en: • Create a candidate block by picking up transactions from the
  prefs: []
  type: TYPE_NORMAL
- en: transaction pool.
  prefs: []
  type: TYPE_NORMAL
- en: • Find a nonce by trying every nonce which when concatenated with
  prefs: []
  type: TYPE_NORMAL
- en: the block and the previous hash results in a number which is less
  prefs: []
  type: TYPE_NORMAL
- en: than the target as per formula 3 earlier.
  prefs: []
  type: TYPE_NORMAL
- en: '222'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 5 BloCkChain Consensus
  prefs: []
  type: TYPE_NORMAL
- en: • Broadcast the newly mined block to the network.
  prefs: []
  type: TYPE_NORMAL
- en: • Fetch the reward by receiving Coinbase on the address that the miner
  prefs: []
  type: TYPE_NORMAL
- en: wants to send the reward to.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what a candidate block contains and how it is created.
  prefs: []
  type: TYPE_NORMAL
- en: A potentially valid candidate block and eventually a valid block contain several
  prefs: []
  type: TYPE_NORMAL
- en: elements, which are listed in Table [5-2](#p240).
  prefs: []
  type: TYPE_NORMAL
- en: '***Table 5-2\.** Block elements*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Size**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Description**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data Type**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Explanation**'
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: Version
  prefs: []
  type: TYPE_NORMAL
- en: integer
  prefs: []
  type: TYPE_NORMAL
- en: Block version
  prefs: []
  type: TYPE_NORMAL
- en: '32'
  prefs: []
  type: TYPE_NORMAL
- en: prev_block
  prefs: []
  type: TYPE_NORMAL
- en: Character
  prefs: []
  type: TYPE_NORMAL
- en: the hash value of the previous block header
  prefs: []
  type: TYPE_NORMAL
- en: '32'
  prefs: []
  type: TYPE_NORMAL
- en: merkle_root
  prefs: []
  type: TYPE_NORMAL
- en: Character
  prefs: []
  type: TYPE_NORMAL
- en: Merkle root hash of all transaction in block
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: timestamp
  prefs: []
  type: TYPE_NORMAL
- en: unsigned integer
  prefs: []
  type: TYPE_NORMAL
- en: time of block creation in unix time format
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: bits
  prefs: []
  type: TYPE_NORMAL
- en: unsigned integer
  prefs: []
  type: TYPE_NORMAL
- en: n[etwork difficulty target for the block](https://en.bitcoin.it/wiki/Difficulty)
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: nonce
  prefs: []
  type: TYPE_NORMAL
- en: unsigned integer
  prefs: []
  type: TYPE_NORMAL
- en: nonce for this block
  prefs: []
  type: TYPE_NORMAL
- en: 1+
  prefs: []
  type: TYPE_NORMAL
- en: txn_count
  prefs: []
  type: TYPE_NORMAL
- en: Variable integer
  prefs: []
  type: TYPE_NORMAL
- en: total number of transactions
  prefs: []
  type: TYPE_NORMAL
- en: variable
  prefs: []
  type: TYPE_NORMAL
- en: txns
  prefs: []
  type: TYPE_NORMAL
- en: tx[ ]
  prefs: []
  type: TYPE_NORMAL
- en: transactions
  prefs: []
  type: TYPE_NORMAL
- en: The diagram in Figur[e 5-2 sho](#p241)ws how transactions from a transaction
    pool (bottom left of the figure) are picked up and a Merkle tree is created, the
    root of which is included in the candidate block. Finally, double (SHA-256) is
    computed for the block for a
  prefs: []
  type: TYPE_NORMAL
- en: comparison against the target.
  prefs: []
  type: TYPE_NORMAL
- en: '223'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-241_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 5 BloCkChain Consensus
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 5-2\.** Transaction pool transactions to the Merkle tree and candidate
    block* A nonce is a number from 1 to 232 – 1, that is, a 32-bit unsigned integer
    which gets'
  prefs: []
  type: TYPE_NORMAL
- en: included in the block. Using this nonce in each iteration of checking if the
    resultant
  prefs: []
  type: TYPE_NORMAL
- en: number is less than the target is what’s called a mining. If the resultant number
    is less than the target, then it’s a block mined and it’s valid, which is then
    broadcast to the
  prefs: []
  type: TYPE_NORMAL
- en: network.
  prefs: []
  type: TYPE_NORMAL
- en: The nonce field in a block being an unsigned integer, there are only 232 nonces
    to
  prefs: []
  type: TYPE_NORMAL
- en: try. As such, miners can run out of them quite quickly. In other words, it means
    that
  prefs: []
  type: TYPE_NORMAL
- en: there are roughly four billion nonces to try which miners can quickly perform
    given the
  prefs: []
  type: TYPE_NORMAL
- en: powerful mining hardware available. It also is very easy even for a normal computer
    to
  prefs: []
  type: TYPE_NORMAL
- en: quickly check.
  prefs: []
  type: TYPE_NORMAL
- en: This of course can create an issue where no one is able to find the required
    nonce
  prefs: []
  type: TYPE_NORMAL
- en: which produces the required hash. Even if miners try again, they will try the
    same thing
  prefs: []
  type: TYPE_NORMAL
- en: again with the same results. At this stage, we can use other attributes of the
    block and use them as a variable and keep modifying the block until the hash of
    the block is less than
  prefs: []
  type: TYPE_NORMAL
- en: the target, that is, *SHAd* 256( *Block header* ‖ *nonce* ) < *Target*.
  prefs: []
  type: TYPE_NORMAL
- en: '224'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 5 BloCkChain Consensus
  prefs: []
  type: TYPE_NORMAL
- en: Now after going through all these iterations, what if the valid nonce is not
    found?
  prefs: []
  type: TYPE_NORMAL
- en: At this point, miners will have to increase the search space somehow. For this,
    they can
  prefs: []
  type: TYPE_NORMAL
- en: 'modify the block somewhat to get a different hash. They can do several things:'
  prefs: []
  type: TYPE_NORMAL
- en: • Drop the transactions, add new transactions, or pick up a new set of
  prefs: []
  type: TYPE_NORMAL
- en: transactions. This modification will recalculate the Merkle root, and
  prefs: []
  type: TYPE_NORMAL
- en: hence the header, and as a result, the hash will be different.
  prefs: []
  type: TYPE_NORMAL
- en: • Modify the timestamp slightly (in the range of two hours; otherwise,
  prefs: []
  type: TYPE_NORMAL
- en: it’s an invalid block). It can be done simply by adding just a
  prefs: []
  type: TYPE_NORMAL
- en: second, which will result in a different header and consequently a
  prefs: []
  type: TYPE_NORMAL
- en: different hash.
  prefs: []
  type: TYPE_NORMAL
- en: • Modify Coinbase via unused *ScriptSig*, where you can put any
  prefs: []
  type: TYPE_NORMAL
- en: arbitrary data. This will change the Merkle root and hence the header
  prefs: []
  type: TYPE_NORMAL
- en: and consequently the hash.
  prefs: []
  type: TYPE_NORMAL
- en: And miners can keep modifying with different variations until they reach
  prefs: []
  type: TYPE_NORMAL
- en: '*SHAd* 256( *Block header* ‖ *nonce* ) < *target*, which means that they’ve
    found a valid nonce that solves the proof of work.'
  prefs: []
  type: TYPE_NORMAL
- en: The discovery of the valid hash is based on the concept known as *partial hash*
  prefs: []
  type: TYPE_NORMAL
- en: '*inversion*.'
  prefs: []
  type: TYPE_NORMAL
- en: Proof of work has some key properties. Formally, we list them as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '**Properties of PoW**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Proof of work has five properties: completeness, computationally complex, dynamic
    cost'
  prefs: []
  type: TYPE_NORMAL
- en: adjustment, quick verification, and progress free.
  prefs: []
  type: TYPE_NORMAL
- en: '**Completeness**'
  prefs: []
  type: TYPE_NORMAL
- en: This property implies that proofs produced by the prover are verifiable and
    acceptable
  prefs: []
  type: TYPE_NORMAL
- en: by the verifier.
  prefs: []
  type: TYPE_NORMAL
- en: '**Computationally Complex – Difficult to Compute – Slow Creation**'
  prefs: []
  type: TYPE_NORMAL
- en: The creation of proof of work is slow but not intractable. Creating proofs requires
  prefs: []
  type: TYPE_NORMAL
- en: spending considerable computational resources and takes a considerable amount
  prefs: []
  type: TYPE_NORMAL
- en: of time.
  prefs: []
  type: TYPE_NORMAL
- en: '225'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 5 BloCkChain Consensus
  prefs: []
  type: TYPE_NORMAL
- en: '**Auto-adjustable Cost – Dynamic Cost**'
  prefs: []
  type: TYPE_NORMAL
- en: This is the elegance of this protocol. First, PoW is difficult to compute. It
    takes
  prefs: []
  type: TYPE_NORMAL
- en: considerable effort to generate proof of work. Roughly, it is more than quintillions
    of
  prefs: []
  type: TYPE_NORMAL
- en: hashes that are checked per second on the Bitcoin network to solve the proof
    of work.
  prefs: []
  type: TYPE_NORMAL
- en: Second, the parameters are adjustable, which means that even if blocks are produced
  prefs: []
  type: TYPE_NORMAL
- en: faster or slower, no matter how much hash power is put in place or how much
    is
  prefs: []
  type: TYPE_NORMAL
- en: removed from the network, the block generation rate roughly remains ten minutes
    per
  prefs: []
  type: TYPE_NORMAL
- en: block. In the early days when the difficulty was one, blocks were still generated
    one per minute; now in 2022, even if the difficulty is roughly 25 tera hashes
    per second, still the protocol readjusts itself, and the block generation rate
    is still one per ten minutes. This is amazing and a testament to the robust design
    of the protocol. So, in summary if the
  prefs: []
  type: TYPE_NORMAL
- en: block generation in a period of 2016 blocks is taking more than ten minutes
    per block,
  prefs: []
  type: TYPE_NORMAL
- en: then in the next 2016 block period the difficulty will be readjusted to low.
    If the block generation is faster and taking less than ten minutes per block,
    for example, in case some bleeding-edge hardware is introduced for hashing in
    the network, then the difficulty
  prefs: []
  type: TYPE_NORMAL
- en: will go up for the next 2016 blocks. This is how a state of balance is maintained
    in the
  prefs: []
  type: TYPE_NORMAL
- en: network. Also note that many blocks are produced very quickly under ten minutes;
    some
  prefs: []
  type: TYPE_NORMAL
- en: take a lot longer than that, but the average is ten minutes. This is due to
    the probabilistic nature of the protocol.
  prefs: []
  type: TYPE_NORMAL
- en: '**Quick and Efficient Verification – Quick Verification**'
  prefs: []
  type: TYPE_NORMAL
- en: This property implies that proofs are very quick and efficient to verify. It
    should not be computationally complex to verify the proof. In the case of Bitcoin,
    it is simply running a SHA-256 hash function twice on the block with the nonce
    produced by the miner, and
  prefs: []
  type: TYPE_NORMAL
- en: if *SHAd* 256( *nonce* ‖ *block header*) ≤ *target*, then the block is valid.
    It only takes as long as it takes to generate SHA-256 hash and then compare, which
    both are very compute-efficient processes. The key idea here is that it should
    be computationally complex to
  prefs: []
  type: TYPE_NORMAL
- en: generate a block with a valid nonce; however, it should be easy for other nodes
    to verify its validity.
  prefs: []
  type: TYPE_NORMAL
- en: '**Progress Free**'
  prefs: []
  type: TYPE_NORMAL
- en: This property implies that the chance of solving the proof of work is proportional
    to the hash power contributed; however, it is still a chance, not a 100% guarantee
    that a miner
  prefs: []
  type: TYPE_NORMAL
- en: with the highest hash power will always win. In other words, miners with more
    hash
  prefs: []
  type: TYPE_NORMAL
- en: '226'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-244_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 5 BloCkChain Consensus
  prefs: []
  type: TYPE_NORMAL
- en: power get only proportional advantage, and miners with less power get proportional
  prefs: []
  type: TYPE_NORMAL
- en: compensation too and get lucky sometimes to find blocks before even miners with
    more
  prefs: []
  type: TYPE_NORMAL
- en: hash power.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, this means that every miner is in fact working on a different candidate
  prefs: []
  type: TYPE_NORMAL
- en: block to solve the proof of work. Miners are not working on the same block;
    they are not
  prefs: []
  type: TYPE_NORMAL
- en: trying to find a valid nonce for the same hash. This is because of several differences,
    such as transactions, version number, Coinbase differences, and other metadata
    differences,
  prefs: []
  type: TYPE_NORMAL
- en: which when hashed result in a totally different hash (SHA-256 twice). This means
    that
  prefs: []
  type: TYPE_NORMAL
- en: every miner is solving a different problem and solving a different part of the
    double
  prefs: []
  type: TYPE_NORMAL
- en: SHA-256 or conveniently written as *SHAd* 256 search space.
  prefs: []
  type: TYPE_NORMAL
- en: The progress free property can be visualized in Figur[e 5-3\. As sho](#p244)wn
    in Figure [5-3,](#p244)
  prefs: []
  type: TYPE_NORMAL
- en: miners are all working on their own candidate block, which is different from
    other blocks due to differences mentioned earlier. So, every nonce that the miners
    concatenate with
  prefs: []
  type: TYPE_NORMAL
- en: the block data to get the hash will result in a hash that no other miner is
    aware of. This gives some advantage to a miner with less power, where it can happen
    that the block
  prefs: []
  type: TYPE_NORMAL
- en: which this small miner is trying to find a valid nonce for manages to find the
    nonce that solves PoW before a miner with more hash power finds the valid nonce
    for their block.
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 5-3\.** Progress free property – each miner working on a different
    part of* *double (SHA-256) search space*'
  prefs: []
  type: TYPE_NORMAL
- en: '227'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-245_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 5 BloCkChain Consensus
  prefs: []
  type: TYPE_NORMAL
- en: This is another elegant property of PoW which ensures that miners with more
    hash
  prefs: []
  type: TYPE_NORMAL
- en: power may have some advantage, but it also means that a miner with less hash
    power
  prefs: []
  type: TYPE_NORMAL
- en: can be lucky in finding the nonce that works before the large miners. The key
    point is
  prefs: []
  type: TYPE_NORMAL
- en: miners are not working on the same block! If it were the same block every time,
    the most
  prefs: []
  type: TYPE_NORMAL
- en: powerful miner would’ve won. This is called the progress free property of Bitcoin
    PoW.
  prefs: []
  type: TYPE_NORMAL
- en: It is however possible that many miners collaboratively work on the same block
  prefs: []
  type: TYPE_NORMAL
- en: (same search space), hence dividing up the work between themselves. Imagine
    the
  prefs: []
  type: TYPE_NORMAL
- en: search space is 1 to 100 for a block, it may be divided in 10 different parts,
    then all miners can collectively work on a single block. This divides up the work,
    and all miners can
  prefs: []
  type: TYPE_NORMAL
- en: contribute and earn their share of the reward. This is called **pool mining**.
    Unlike **solo** **mining** where only one miner tries and the entire effort can
    be lost if it doesn’t find the nonce and tries again for the next block, in pool
    mining individual contribution is
  prefs: []
  type: TYPE_NORMAL
- en: not wasted.
  prefs: []
  type: TYPE_NORMAL
- en: This concept can be visualized in Figur[e 5-4\.](#p245)
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 5-4\.** Mining pool – many miners working on a single block (shad256*'
  prefs: []
  type: TYPE_NORMAL
- en: '*search space)*'
  prefs: []
  type: TYPE_NORMAL
- en: In Figur[e 5-4, ther](#p245)e are different miners working on the same hash
    search space produced by the same block. This way, the pool operators split the
    proof of work into
  prefs: []
  type: TYPE_NORMAL
- en: different pieces and distribute them to the miners in the pool. All miners work
    and put in 228
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 5 BloCkChain Consensus
  prefs: []
  type: TYPE_NORMAL
- en: the effort, and eventually one miner finds the block which is broadcast normally
    to the
  prefs: []
  type: TYPE_NORMAL
- en: Bitcoin network. The pool operator receives the block reward which is split
    between the
  prefs: []
  type: TYPE_NORMAL
- en: miners in proportion to the effort put in by the miners.
  prefs: []
  type: TYPE_NORMAL
- en: '**Probabilistic Aspects of Dynamic Parameters**'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s shed some light on the probabilistic aspects related to the property
    (dynamic
  prefs: []
  type: TYPE_NORMAL
- en: and auto-adjustable parameters), where I will explain what the average of ten
    minutes
  prefs: []
  type: TYPE_NORMAL
- en: means and what parameterization means.
  prefs: []
  type: TYPE_NORMAL
- en: In probability theory, a Bernoulli trial is an action that has two possible
    outcomes,
  prefs: []
  type: TYPE_NORMAL
- en: either success or failure. The probability of success or failure is fixed between
    trials.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in coin flips the probability of heads or tails is 50%. The outcome
    is also
  prefs: []
  type: TYPE_NORMAL
- en: independent. It is not the case that having three heads in a row will lead to
    a definite
  prefs: []
  type: TYPE_NORMAL
- en: head for the fourth time too. Similarly, in Bitcoin mining, the outcome of success
    or
  prefs: []
  type: TYPE_NORMAL
- en: failure, as shown in the following, remains independent and almost like coin
    flips
  prefs: []
  type: TYPE_NORMAL
- en: roughly 50% probabilistic. We can see this in the following formula.
  prefs: []
  type: TYPE_NORMAL
- en: 'Success and failure in mining can be written like the following two formulas:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Success* = *SHAd* 256( *nonce*|| *block heade*'
  prefs: []
  type: TYPE_NORMAL
- en: '*r* ) < *target*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Failure* = *SHAd* 256( *nonce*|| *block* *header* ) ≥ *target* PoW is almost
    like roll dicing, for example, if I have rolled the dice a few times, I'
  prefs: []
  type: TYPE_NORMAL
- en: cannot know when the next six will occur; it might be that I get six in the
    first attempt, may never get six, or get six after several rolls. Similarly, whether
    a single nonce has been tried to find the valid nonce or trillions and trillions
    of nonces have been tried, the mean time until a miner finds the valid nonce remains
    probabilistic. It doesn’t matter whether 100 million nonces have been tried or
    only one; the probability of finding the valid nonce remains the same. So trying
    millions of nonces doesn’t make it more likely to find the
  prefs: []
  type: TYPE_NORMAL
- en: valid nonce; even trying once or only a few times could find the valid nonce.
  prefs: []
  type: TYPE_NORMAL
- en: A Bernoulli trial iterated enough to achieve a continuous result instead of
    discrete
  prefs: []
  type: TYPE_NORMAL
- en: is called a Poisson process. Formally, we can say that a Poisson process is
    a sequence of discrete events, where events occur independently at a known constant
    average rate, but
  prefs: []
  type: TYPE_NORMAL
- en: the exact timing of events is random.
  prefs: []
  type: TYPE_NORMAL
- en: '229'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 5 BloCkChain Consensus
  prefs: []
  type: TYPE_NORMAL
- en: For example, movements in a stock price are a Poisson process. A Poisson process
  prefs: []
  type: TYPE_NORMAL
- en: 'has some properties:'
  prefs: []
  type: TYPE_NORMAL
- en: • Events are independent of each other, that is, no influence of an
  prefs: []
  type: TYPE_NORMAL
- en: outcome on some other.
  prefs: []
  type: TYPE_NORMAL
- en: • The rate of events per time period is constant.
  prefs: []
  type: TYPE_NORMAL
- en: • Two events cannot occur simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: The average time between events is known, but they are randomly spaced
  prefs: []
  type: TYPE_NORMAL
- en: (stochastic). In Bitcoin, of course, we know the time between two block generation
  prefs: []
  type: TYPE_NORMAL
- en: events is known, that is, roughly ten minutes, but the generations are randomly
    spaced.
  prefs: []
  type: TYPE_NORMAL
- en: The mean time for a new block is ten minutes on average. We can use a simple
  prefs: []
  type: TYPE_NORMAL
- en: formula to find out the meantime of finding the next block for a particular
    miner.
  prefs: []
  type: TYPE_NORMAL
- en: '*Next* *block* *mean t* *ime* ( *specific*'
  prefs: []
  type: TYPE_NORMAL
- en: '*minutes*'
  prefs: []
  type: TYPE_NORMAL
- en: ) =
  prefs: []
  type: TYPE_NORMAL
- en: '10'
  prefs: []
  type: TYPE_NORMAL
- en: '*fraction* *of* *hash p*'
  prefs: []
  type: TYPE_NORMAL
- en: '*oower* *controlled by the* *miner*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Probability of an Attacker Catching Up**'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we answer the question of what the probability is of an attacker
    to mine enough blocks to take over the chain. Suppose an attacker has some mining
    power, say
  prefs: []
  type: TYPE_NORMAL
- en: q. A seller waits for z confirmation (z blocks) before accepting the payment,
    and the
  prefs: []
  type: TYPE_NORMAL
- en: honest chain hash rate is denoted by p.
  prefs: []
  type: TYPE_NORMAL
- en: 'The probability of an attacker catching up *qz* can be calculated as shown
    follows: *z*'
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en:  
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: '*q* ='
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: 1
  prefs: []
  type: TYPE_NORMAL
- en: ≤ _
  prefs: []
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: '*z*'
  prefs: []
  type: TYPE_NORMAL
- en: '*if p q*'
  prefs: []
  type: TYPE_NORMAL
- en: '*q*'
  prefs: []
  type: TYPE_NORMAL
- en:   *if p q* 
  prefs: []
  type: TYPE_NORMAL
- en:  *p* 
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: 
  prefs: []
  type: TYPE_NORMAL
- en: where
  prefs: []
  type: TYPE_NORMAL
- en: '*q* = *attacker’s hash r* *ate*'
  prefs: []
  type: TYPE_NORMAL
- en: '*p* = *honest hash rate*'
  prefs: []
  type: TYPE_NORMAL
- en: '*z* = *blocks to catc*'
  prefs: []
  type: TYPE_NORMAL
- en: '*h up*'
  prefs: []
  type: TYPE_NORMAL
- en: '230'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 5 BloCkChain Consensus
  prefs: []
  type: TYPE_NORMAL
- en: This means that if the honest hash rate is less than the attacker’s hash rate,
    then the
  prefs: []
  type: TYPE_NORMAL
- en: probability of an attacker catching up is one, and if the honest hash rate is
    more than the *q z*
  prefs: []
  type: TYPE_NORMAL
- en:  
  prefs: []
  type: TYPE_NORMAL
- en: attacker’s hash rate, then the probability of catching up is   .
  prefs: []
  type: TYPE_NORMAL
- en:  *p* 
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we formally write the proof of work algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: '**PoW Algorithm**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Formally, we can write the entire proof of work algorithm as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '1: nonce := 0'
  prefs: []
  type: TYPE_NORMAL
- en: '2: hashTarget := nBits'
  prefs: []
  type: TYPE_NORMAL
- en: '3: hash := null'
  prefs: []
  type: TYPE_NORMAL
- en: '4: while (true) {'
  prefs: []
  type: TYPE_NORMAL
- en: '5: SHA256(SHA256(blockheader || nonce))'
  prefs: []
  type: TYPE_NORMAL
- en: '6: if (hash ≤ hashTarget) {'
  prefs: []
  type: TYPE_NORMAL
- en: '7: append to blockchain'
  prefs: []
  type: TYPE_NORMAL
- en: '8: else'
  prefs: []
  type: TYPE_NORMAL
- en: '9: nonce := nonce + 1'
  prefs: []
  type: TYPE_NORMAL
- en: '10: }'
  prefs: []
  type: TYPE_NORMAL
- en: '11: }'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding algorithm, the nonce is initialized as zero. The hash target
    which
  prefs: []
  type: TYPE_NORMAL
- en: is the difficulty target of the network is taken from the *nBits* field of the
    candidate block header. The hash is initialized to null. After that, an infinite
    loop runs, which first concatenates the block header and the nonce and runs SHA-256
    twice on it to produce
  prefs: []
  type: TYPE_NORMAL
- en: the hash. Next, if the produced hash is less than the target hash, then it is
    accepted and appended to the blockchain; otherwise, the nonce is incremented and
    the process starts
  prefs: []
  type: TYPE_NORMAL
- en: again. If no nonce is found, then the algorithm tries the next block.
  prefs: []
  type: TYPE_NORMAL
- en: This process can be visualized in Figur[e 5-5\.](#p249)
  prefs: []
  type: TYPE_NORMAL
- en: '231'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-249_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 5 BloCkChain Consensus
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 5-5\.** Proof of work*'
  prefs: []
  type: TYPE_NORMAL
- en: In Figur[e 5-5, the pr](#p249)evious block hash, transactions, and nonce are
    fed into a hash function to produce a hash which is checked against the target
    value. If it is less than
  prefs: []
  type: TYPE_NORMAL
- en: the target value, then it’s a valid hash and the process stops; otherwise, the
    nonce is
  prefs: []
  type: TYPE_NORMAL
- en: incremented, and the entire process repeats until the resultant hash is less
    than the
  prefs: []
  type: TYPE_NORMAL
- en: target, where the process stops.
  prefs: []
  type: TYPE_NORMAL
- en: '**Game Theory and Proof of Work**'
  prefs: []
  type: TYPE_NORMAL
- en: Game theory is the study of behaviors in strategic interactive situations where
    an
  prefs: []
  type: TYPE_NORMAL
- en: individual’s best course of action depends on the choice of others. Game theory
    models
  prefs: []
  type: TYPE_NORMAL
- en: represent real-life situations in an abstract manner. Game theory is useful
    in many
  prefs: []
  type: TYPE_NORMAL
- en: different fields, such as economics, biology, social science, finance, politics,
    computer science, and many more. For example, in economics, product launch decisions
    made
  prefs: []
  type: TYPE_NORMAL
- en: by businesses are influenced by their competitor’s choice of product and marketing
  prefs: []
  type: TYPE_NORMAL
- en: strategy. In computer networks, networked computers may compete for resources
    such
  prefs: []
  type: TYPE_NORMAL
- en: as bandwidth. A Nash equilibrium is used to study political competition. In
    politics,
  prefs: []
  type: TYPE_NORMAL
- en: politicians’ policies are influenced by announcements and promises made by their
  prefs: []
  type: TYPE_NORMAL
- en: opponents.
  prefs: []
  type: TYPE_NORMAL
- en: A game can be defined as a description of all strategic actions that a player
    may take
  prefs: []
  type: TYPE_NORMAL
- en: but without describing the likely outcome.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some entities in a game which are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '• **Players**: Strategic rational decision makers in a game'
  prefs: []
  type: TYPE_NORMAL
- en: '• **Actions**: Set of actions available to a player'
  prefs: []
  type: TYPE_NORMAL
- en: '• **Payoffs**: A payout to be received by a player for a particular outcome'
  prefs: []
  type: TYPE_NORMAL
- en: '232'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 5 BloCkChain Consensus
  prefs: []
  type: TYPE_NORMAL
- en: Games represent different strategic situations. There are some classical games
    such
  prefs: []
  type: TYPE_NORMAL
- en: as Bach or Stravinsky, prisoner’s dilemma, Hawk-Dove, and matching pennies.
    In games,
  prefs: []
  type: TYPE_NORMAL
- en: players are not aware of the actions of other players when making their own
    decisions;
  prefs: []
  type: TYPE_NORMAL
- en: such games are called **simultaneous move games**.
  prefs: []
  type: TYPE_NORMAL
- en: Games can be analyzed by creating a table where all possible actions of players
    and
  prefs: []
  type: TYPE_NORMAL
- en: payoffs are listed. This table is known as the **strategic form** of the game
    or **payoff matrix**.
  prefs: []
  type: TYPE_NORMAL
- en: A **Nash equilibrium** is a fundamental and powerful concept in game theory.
    In a
  prefs: []
  type: TYPE_NORMAL
- en: Nash equilibrium, each rational player chooses the best course of action in
    response
  prefs: []
  type: TYPE_NORMAL
- en: to the choice made by other players. Each player is aware of other players’
    equilibrium
  prefs: []
  type: TYPE_NORMAL
- en: strategies, and no player can make any gains by changing only their own strategy.
    In
  prefs: []
  type: TYPE_NORMAL
- en: short, any deviation from the strategy does not result in any gain for the deviant.
  prefs: []
  type: TYPE_NORMAL
- en: '**Prisoner’s Dilemma**'
  prefs: []
  type: TYPE_NORMAL
- en: In this simultaneous move game, two suspects of a crime are put into separate
    cells
  prefs: []
  type: TYPE_NORMAL
- en: without any way to communicate. If they both confess, then they both will be
    imprisoned
  prefs: []
  type: TYPE_NORMAL
- en: for three years each. If one of them confesses and acts as a witness against
    the other,
  prefs: []
  type: TYPE_NORMAL
- en: then charges against him will be dropped; however, the other suspect will get
    four years
  prefs: []
  type: TYPE_NORMAL
- en: in prison. If none of them confesses, then both will be sentenced to only one
    year in
  prefs: []
  type: TYPE_NORMAL
- en: prison. Now you can see that if both suspects cooperate and don’t confess, then
    it results in the best outcome for both. However, there is a big incentive of
    going free for both to not cooperate and act as a witness against the other. This
    game results in gains for both if they cooperate and don’t confess and results
    in only one year in prison each. Let’s name
  prefs: []
  type: TYPE_NORMAL
- en: these characters Alice and Bob for ease and see what possible outcomes there
    are in
  prefs: []
  type: TYPE_NORMAL
- en: this game.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four possible outcomes of this game:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Alice does not confess, and Bob does not confess.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Alice confesses, and Bob does not confess.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Alice does not confess, and Bob confesses.
  prefs: []
  type: TYPE_NORMAL
- en: 4\. Alice confesses, and Bob confesses.
  prefs: []
  type: TYPE_NORMAL
- en: If Alice and Bob can somehow communicate, then they can jointly decide to not
  prefs: []
  type: TYPE_NORMAL
- en: confess, which will result in only a one-year sentence each. However, the dominant
  prefs: []
  type: TYPE_NORMAL
- en: strategy here is to confess rather than don’t confess.
  prefs: []
  type: TYPE_NORMAL
- en: '233'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-251_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 5 BloCkChain Consensus
  prefs: []
  type: TYPE_NORMAL
- en: A **dominant strategy** is a strategy that results in the largest payoff regardless
    of the behaviors of other players in the game.
  prefs: []
  type: TYPE_NORMAL
- en: We can represent this in a payoff matrix form as shown in Figur[e 5-6\.](#p251)
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 5-6\.** Prisoner’s dilemma payoff matrix*'
  prefs: []
  type: TYPE_NORMAL
- en: Alice and Bob are both aware of this matrix and know that they both have this
    matrix
  prefs: []
  type: TYPE_NORMAL
- en: to choose from. Alice and Bob are players, “confess” and “don’t confess” are
    actions, and payoffs are prison sentences.
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of what Alice does or Bob does, the other player still confesses.
    Alice’s
  prefs: []
  type: TYPE_NORMAL
- en: strategy is that if Bob confesses, she should confess too because a one-year
    prison
  prefs: []
  type: TYPE_NORMAL
- en: sentence is better than three. If Bob does not confess, she should still confess
    because
  prefs: []
  type: TYPE_NORMAL
- en: she will go free. The same strategy is employed by Bob. The dominant strategy
    here is to
  prefs: []
  type: TYPE_NORMAL
- en: confess, regardless of what the other player does.
  prefs: []
  type: TYPE_NORMAL
- en: Both players confess and go to prison for three years each. This is because
    even if
  prefs: []
  type: TYPE_NORMAL
- en: Bob had somehow managed to tell Alice about his no confession strategy, Alice
    would
  prefs: []
  type: TYPE_NORMAL
- en: have still confessed and became a witness to avoid prison altogether. Similar
    is the case from Alice’s perspective. Therefore, the best outcome for both becomes
    “confession” in a
  prefs: []
  type: TYPE_NORMAL
- en: Nash equilibrium. This is written as { *confess*, *confess*}.
  prefs: []
  type: TYPE_NORMAL
- en: in the prisoner’s dilemma, there is a benefit of cooperation for both players,
    but the
  prefs: []
  type: TYPE_NORMAL
- en: possible incentive of going free for each player entices contest. When all players
    in
  prefs: []
  type: TYPE_NORMAL
- en: a game are rational, the best choice is to be in a nash equilibrium.
  prefs: []
  type: TYPE_NORMAL
- en: Game theory models are highly abstract; therefore, they can be used in many
  prefs: []
  type: TYPE_NORMAL
- en: different situations, once developed for a particular situation. For example,
    the
  prefs: []
  type: TYPE_NORMAL
- en: prisoner’s dilemma model can be used in many other areas. In network communications
  prefs: []
  type: TYPE_NORMAL
- en: where wireless network devices compete for bandwidth, energy supply, etc., there
    is a
  prefs: []
  type: TYPE_NORMAL
- en: need to regulate node behavior in such a way that all devices on the network
    can work
  prefs: []
  type: TYPE_NORMAL
- en: in harmony. Imagine a network where two cell towers working on the same frequency
  prefs: []
  type: TYPE_NORMAL
- en: in close vicinity can affect each other’s performance. One way to counter this
    problem
  prefs: []
  type: TYPE_NORMAL
- en: is to run both towers at low energy so that they don’t interfere with each other,
    but that 234
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 5 BloCkChain Consensus
  prefs: []
  type: TYPE_NORMAL
- en: will decrease the bandwidth of both the towers. If one tower increases its energy
    and
  prefs: []
  type: TYPE_NORMAL
- en: the other don’t, then the one that doesn’t loses and runs on lower bandwidth.
    So, the
  prefs: []
  type: TYPE_NORMAL
- en: dominant strategy here becomes to run towers at maximum power regardless of
    what
  prefs: []
  type: TYPE_NORMAL
- en: the other tower does, so that they achieve maximum possible gain. This result
    is like the prisoner’s dilemma where confession is the best strategy. Here, maximum
    power is the
  prefs: []
  type: TYPE_NORMAL
- en: best strategy.
  prefs: []
  type: TYPE_NORMAL
- en: Now in the light of the preceding explained concepts, we can analyze the Bitcoin
  prefs: []
  type: TYPE_NORMAL
- en: protocol from a game theoretic perspective.
  prefs: []
  type: TYPE_NORMAL
- en: '**PoW and Game Theory**'
  prefs: []
  type: TYPE_NORMAL
- en: We can think of Bitcoin as a distributed system with selfish players; nodes
    might be
  prefs: []
  type: TYPE_NORMAL
- en: trying to gain incentives without contributing or trying to gain more incentives
    than their fair share.
  prefs: []
  type: TYPE_NORMAL
- en: The Bitcoin protocol is a **Nash equilibrium** because no deviation from the
    protocol’s equilibrium strategy can result in a gain for the deviant. The protocol
    is designed in such a way that any deviation from the protocol is punished, and
    normal (good) behavior is
  prefs: []
  type: TYPE_NORMAL
- en: economically incentivized. The dominant strategy in Bitcoin is to mine according
    to the
  prefs: []
  type: TYPE_NORMAL
