- en: Blockchain Forum
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '© Springer Nature Switzerland AG 2021J. González Enríquez et al. (eds.)Business
    Process Management: Blockchain and Robotic Process Automation ForumLecture Notes
    in Business Information Processing428[https://doi.org/10.1007/978-3-030-85867-4_5](https://doi.org/10.1007/978-3-030-85867-4_5)'
  prefs: []
  type: TYPE_NORMAL
- en: An Empirical Evaluation of Smart Contract-Based Data Quality Assessment in Ethereum
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Marco Comuzzi^([1](#Aff12) [ ](#ContactOfAuthor1)), Cinzia Cappiello^([2](#Aff13) [ ](#ContactOfAuthor2))
    and Giovanni Meroni^([2](#Aff13) [ ](#ContactOfAuthor3))(1)Ulsan National Institute
    of Science and Technology, Ulsan, Republic of Korea(2)Politecnico di Milano, Milan,
    ItalyMarco Comuzzi (Corresponding author)Email: [mcomuzzi@unist.ac.kr](mailto:mcomuzzi@unist.ac.kr)Cinzia CappielloEmail:
    [cinzia.cappiello@polimi.it](mailto:cinzia.cappiello@polimi.it)Giovanni MeroniEmail:
    [giovanni.meroni@polimi.it](mailto:giovanni.meroni@polimi.it)'
  prefs: []
  type: TYPE_NORMAL
- en: Abstract
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The data carried by transaction payloads play a crucial role in smart contract-based
    blockchain systems. Therefore, blockchains should be equipped with mechanisms
    to control their data quality. In practice, however, such mechanisms are currently
    missing. While in our previous work we have proposed how data quality controls
    can be implemented as smart contracts, in this paper we focus specifically on
    the evaluation of their execution overhead (time and cost). Evaluating this overhead
    is crucial to understand in which situations the cost of controlling the data
    quality of transaction payloads can be sustained by a blockchain system. We have
    implemented in Ethereum two pseudo-real scenarios that cover all the types of
    data quality controls in blockchains that we defined in our previous work and
    evaluated for each of them the time and cost overhead. The results show that the
    overhead of control can be high particularly for controls involving oracles that
    fetch off-chain data and controls that require to correlate data from different
    transactions.
  prefs: []
  type: TYPE_NORMAL
- en: KeywordsBlockchainData qualityCostSmart contractEthereum
  prefs: []
  type: TYPE_NORMAL
- en: 1 Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Smart contract-enabled blockchains increasingly underpin the implementation
    of resilient and trustless distributed information systems. Examples of such systems
    are supply chain management platforms, open data registries, and electricity trading
    and billing platforms in smart grids [[12](#CR12)]. In these systems, the data
    carried by transactions payloads determine which data are stored in the distributed
    ledger and which application logic (smart contracts) is executed by all nodes
    of the network.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given the crucial role of transaction payloads, we would expect smart contract-enabled
    blockchains to be equipped with mechanisms that guarantee the data quality of
    these payloads, i.e., their fitness for use [[6](#CR6)]. For example, in a cold
    supply chain scenario, a sensor that reports a temperature reading greater than
    25% of the previous recorded value or that falls outside a range of admissible
    temperatures is transmitting an inaccurate value. Such an inaccuracy may indicate
    a fault in the sensor or a problem with the transportation process. In both cases,
    data quality assessment would highlight the anomalous value and trigger further
    analysis before it can be accepted. Therefore, mechanisms to implement data quality
    controls and to eventually discard low quality data should be implemented. So
    far, blockchains provide natively only some primitive mechanisms to guarantee
    such quality: in cryptocurrencies, transactions are validated by nodes receiving
    them only to check if users own the coins that are transferring [[2](#CR2)].'
  prefs: []
  type: TYPE_NORMAL
- en: As the quality of the data heavily influences the reliability of the applications
    that use them, data quality controls performed on-chain can significantly increase
    the users’ trust in blockchain applications. In our previous work [[7](#CR7)],
    we have proposed an approach to implement data quality controls on-chain using
    ad-hoc smart contracts in Ethereum. Specifically, the approach implements data
    quality smart contract templates addressing different quality aspects (i.e., dimensions)
    combining (i) the type of data required by data quality controls, e.g., whether
    a control requires a single value of a variable only or multiple time series of
    multiple variables, and (ii) the way in which these data are delivered to the
    blockchain, e.g., whether by one or multiple transactions.
  prefs: []
  type: TYPE_NORMAL
- en: A crucial concern when implementing data quality assessment for blockchains
    is to evaluate the *overhead* of its execution. Blockchains, particularly public
    ones, can have in fact a high cost and time overhead. For instance, users have
    to pay to use a public blockchain, such as in the form of transaction fees collected
    by miner nodes in systems that use proof-of-work consensus. The evaluation of
    the overhead of data quality assessment remains an open issue. In the case of
    ad-hoc smart contracts for data quality control considered in this paper, the
    overhead of data quality assessment can be a combination of the monetary cost
    of the fees required to execute the data quality assessment smart contracts, e.g.,
    the amount of gas required to run them in Ethereum, and the additional time that
    may be required to execute the data quality control, which impacts the time for
    a transaction to be mined into a block and, therefore, the system throughput.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this context, the contributions of this paper are: (i) To present in detail
    two pseudo-real scenarios of ad-hoc smart contracts for data quality assessment,
    which cover all the type of smart contract templates for data quality assessment
    identified by our previous research [[7](#CR7)]; (ii) To empirically evaluate
    the overhead (cost and time) of implementing data quality assessment using the
    two identified pseudo-real scenarios in Ethereum. The results obtained show that
    the overhead of control can be high particularly for controls involving oracles
    that fetch off-chain data and controls that require to correlate data from different
    transactions.'
  prefs: []
  type: TYPE_NORMAL
- en: The paper is organised as follows. Section [2](#Sec2) briefly surveys the related
    work in data quality on blockchain. Section [2](#Sec2) discusses the related work.
    Section [3](#Sec3) introduces the data quality model, summarising also our previous
    research. The scenarios and smart contracts considered in the evaluation are presented
    in detail in Sect. [4](#Sec6), while the results of the evaluation are discussed
    in Sect. [5](#Sec9). Conclusions are finally drawn in Sect. [6](#Sec10).
  prefs: []
  type: TYPE_NORMAL
- en: 2 Background and Related Work
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Data quality (DQ) is often defined as the capability of data to satisfy the
    users’ requirements [[6](#CR6)]. Being a multidimensional concept, DQ is evaluated
    taking different DQ *dimensions* into consideration. The most commonly used dimensions
    are *accuracy* – the degree with which data values are correct – *completeness*
    – measuring the degree with which required data are present in a dataset – *timeliness*
    – measuring the temporal validity of data – and *consistency* – measuring the
    degree with which data are valid according to defined rules, such as functional
    dependencies or business rules. The *metrics* used to evaluate DQ dimensions may
    vary depending on the type of data and data source. For instance, assessing the
    accuracy of strings requires a different metric than assessing the accuracy of
    numbers.
  prefs: []
  type: TYPE_NORMAL
- en: DQ assessments can be performed either *online* or *offline*. Online DQ assessments
    occur when new data are saved into a storage system. The objective in this case
    is to deal immediately with low-quality data, for instance, by rejecting them
    to avoid lowering the overall quality of the data in the storage system. Conversely,
    offline DQ assessments operate after the data have been stored, either periodically
    or when the storage system is queried. This paper focuses on the online assessment
    of the DQ quality of transaction payloads.
  prefs: []
  type: TYPE_NORMAL
- en: Second-generation blockchains, such as Ethereum and Hyperledger Fabric, support
    the so-called *smart contracts* [[10](#CR10)], executable code capturing, in a
    broad sense, how business is to be conducted among organizations, e.g., the transfer
    of digital assets after a condition is fulfilled. Nodes can invoke smart contracts
    by issuing transactions that specify the operation of the contract to be invoked
    and optional parameters in their payload. As far as incentives are concerned,
    when a new transaction is processed, the node that issued it is billed proportionally
    to the amount of data contained in the transaction and to the complexity of the
    invoked smart contract operation.
  prefs: []
  type: TYPE_NORMAL
- en: The research on the quality of blockchain applications focuses on *software
    quality*. For example, Atzei et al. [[3](#CR3)] classify code vulnerabilities
    in Ethereum smart contracts. Wohrer and Zdun [[11](#CR11)] outline security patterns
    for smart contracts. Bartoletti and Pompianu [[5](#CR5)] identify common programming
    patterns in Ethereum smart contracts based on the type of application.
  prefs: []
  type: TYPE_NORMAL
- en: Given their ability to store data in a consistent, immutable and persistent
    form across multiple nodes, blockchains often are seen as systems that can effectively
    improve data quality [[9](#CR9), [13](#CR13)]. However, blockchain research often
    assumes that the data stored in the blockchain are correct. While this assumption
    holds for data that are created from the blockchain itself (i.e., cryptocurrency),
    the quality of data created outside the blockchain may vary, and our work aims
    to guarantee that only reliable data are shared within a blockchain system. Thus,
    in the literature, the issue of data quality in blockchain research has not been
    explored in depth yet. Chen et al. [[9](#CR9)] argue that, in most application
    scenarios, the use of a blockchain alone may already increase data integrity and
    quality. This is supported by Azaria et al. [[4](#CR4)], who discuss the implementation
    of a medical record management system using blockchain, observing an improvement
    of both quality and quantity of the data stored for medical research. Casado-Vara
    et al. [[8](#CR8)] study data quality in blockchains for IoT applications. Despite
    the research cited above, a generic, application-independent approach to control
    data quality, which specifically takes into account the strengths and limitations
    of a blockchain, is still missing.
  prefs: []
  type: TYPE_NORMAL
- en: 3 Data Quality Assessment Model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section introduces a model of DQ controls in blockchains (Sect. [3.1](#Sec4))
    and then summarises our previous work on smart contract-based data quality assessment
    (Sect. [3.2](#Sec5)).
  prefs: []
  type: TYPE_NORMAL
- en: 3.1 Data Quality Controls in Blockchains
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As discussed in Sect. [2](#Sec2), DQ can be assessed using different DQ dimensions
    and each dimension can be associated with multiple assessment metrics. In a given
    context, the DQ assessment logic depends on the type of sources and on the type
    of data, and it may require additional metadata (e.g., expected values, consistency
    rules). Considering such information needs, in our previous work we defined four
    situations that may occur (see Fig. [1](#Fig1)):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Single variable, single value (SS): the quality assessment of a variable does
    not require additional data;'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Single variable, multiple values (SM): the quality evaluation of a value depends
    on the availability of one or more historical values of the same variable;'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Multiple variables, single value per variable (MS): the quality of a value
    relies on single values of a number of other variables;'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Multiple variables, multiple values per variable (MM): the quality of a value
    relies on multiple values of a number of other variables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![../images/509088_1_En_5_Chapter/509088_1_En_5_Fig1_HTML.png](../images/509088_1_En_5_Chapter/509088_1_En_5_Fig1_HTML.png)'
  prefs: []
  type: TYPE_IMG
- en: Fig. 1.
  prefs: []
  type: TYPE_NORMAL
- en: Dependencies among variables and values when assessing DQ. Reprinted from [[7](#CR7)].
  prefs: []
  type: TYPE_NORMAL
- en: These situations influence the way in which we model transactions and DQ controls,
    as described in the following.
  prefs: []
  type: TYPE_NORMAL
- en: As regards transactions, we consider proof-of-work blockchain systems that use
    a client-generated nonce to order transactions, such as Ethereum. Transactions
    are submitted by client applications to one node of a blockchain network. They
    carry data items, i.e., key-value pairs. Therefore, a transaction ![$$t=\langle
    n, [d_i], c \rangle $$](../images/509088_1_En_5_Chapter/509088_1_En_5_Chapter_TeX_IEq1.png)
    is defined by a nonce *n*, the set of data items ![$$d_i$$](../images/509088_1_En_5_Chapter/509088_1_En_5_Chapter_TeX_IEq2.png)
    that it carries, and a correlation id *c*. Each ![$$d_i$$](../images/509088_1_En_5_Chapter/509088_1_En_5_Chapter_TeX_IEq3.png)
    is the key associate to a value ![$$v_i$$](../images/509088_1_En_5_Chapter/509088_1_En_5_Chapter_TeX_IEq4.png).
    The nonce *n* is an incremental value specified by the issuer of the transaction,
    which is used to order transactions. A transaction is considered valid only if
    its nonce has not already been used by the same issuer, otherwise it is discarded.
    Also, a transaction is processed only after all the other transactions from the
    same issuer with nonce lower than the current one have been received. The correlation
    id *c* is required to match data items referring to the same instance of stateful
    data quality controls when multiple values are needed.
  prefs: []
  type: TYPE_NORMAL
- en: A *quality control* is defined as ![$$dqc=\langle logic, [input_j], action \rangle
    $$](../images/509088_1_En_5_Chapter/509088_1_En_5_Chapter_TeX_IEq5.png), where
    *logic* contains the assessment logic of the considered DQ dimensions, ![$$[input_j]$$](../images/509088_1_En_5_Chapter/509088_1_En_5_Chapter_TeX_IEq6.png)
    is the list of input parameters of the assessment logic, i.e., a list of data
    items and *action* defines the task to perform in case of poor quality. Input
    parameters are received as data items ![$$d_i$$](../images/509088_1_En_5_Chapter/509088_1_En_5_Chapter_TeX_IEq7.png)
    in transactions. Data quality controls can be *stateless* or *stateful*. In a
    stateless *dqc*, the data items ![$$input_j$$](../images/509088_1_En_5_Chapter/509088_1_En_5_Chapter_TeX_IEq8.png)
    are carried by a single transactions. Therefore, *dqc* can run as soon as this
    transaction is received. In a stateful *dqc*, the data items ![$$input_j$$](../images/509088_1_En_5_Chapter/509088_1_En_5_Chapter_TeX_IEq9.png)
    are carried by different transactions. Therefore, *dqc* can run only once all
    the transactions carried the required ![$$input_j$$](../images/509088_1_En_5_Chapter/509088_1_En_5_Chapter_TeX_IEq10.png)
    have been received.
  prefs: []
  type: TYPE_NORMAL
- en: Specifically, a new instance of a stateful quality control ![$$dqc_c$$](../images/509088_1_En_5_Chapter/509088_1_En_5_Chapter_TeX_IEq11.png)
    is created when the first data item ![$$d_i \in input_j$$](../images/509088_1_En_5_Chapter/509088_1_En_5_Chapter_TeX_IEq12.png)
    is carried by a transaction *t* with correlation id *c*. The correlation id *c*
    is required to match data items from different transactions referring to the same
    instance of a quality control. For instance, a *dqc* may check the precision of
    three consecutive pressure readings from a sensor, in which case a correlation
    id can be generated combining the sensor id and a reading’s timestamp^([1](#Fn1)).
    A *dqc* can be evaluated once a data item for each input parameter in transaction
    carrying the same correlation id *c* has been received. The evaluation can be
    either positive or negative. We say that a data item ![$$d_i$$](../images/509088_1_En_5_Chapter/509088_1_En_5_Chapter_TeX_IEq13.png)
    targets a *dqc* when it is required for its evaluation. For example, the quality
    control requiring a temperature value to be in a certain range is stateless, as
    it requires only data contained in the current transaction, while the aforementioned
    quality control requiring a temperature value not to be greater than 25% of the
    previous value is stateful, as it would require both the current transaction and
    the previous one.
  prefs: []
  type: TYPE_NORMAL
- en: The smart contract-based DQ assessment that we consider in this paper is not
    heavily affected by the application *logic* of DQ controls. The *action* to perform
    when poor quality is detected is to reject the transactions carrying low quality
    data (more nuanced policies to define actions are discussed in [[7](#CR7)]).
  prefs: []
  type: TYPE_NORMAL
- en: 3.2 Smart Contract-Based Data Quality Assessment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To make the paper self-contained, this section gives a brief overview of the
    approach described in [[7](#CR7)]. In a nutshell, in smart contract-based data
    quality assessment, the assessment of the DQ of transaction payloads is delegated
    to smart contracts created ad-hoc to run DQ controls. The *functional* smart contract,
    i.e., the one invoked by a transaction carrying a data item ![$$input_j$$](../images/509088_1_En_5_Chapter/509088_1_En_5_Chapter_TeX_IEq14.png)
    required by a DQ control *dqc*, is responsible for invoking the DQ smart contract
    implementing *dqc* before executing any other functional logic that uses the data
    item ![$$input_j$$](../images/509088_1_En_5_Chapter/509088_1_En_5_Chapter_TeX_IEq15.png)
    as parameters.
  prefs: []
  type: TYPE_NORMAL
- en: In this approach, the logic of DQ controls is implemented into functions of
    a smart contract. Since smart contracts can be invoked by all nodes of a blockchain,
    this solution enables every node to assess the quality of transaction payloads
    based on their specific needs, e.g., the DQ requirements of the client applications
    using them. DQ control functions are either stateless or stateful, depending on
    the type of DQ control that they implement. Stateful ones exploit the correlation
    id when necessary and require memory to store the values received by different
    transactions. Both types of functions can use oracles to fetch off-chain data
    required for the evaluation of DQ controls.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our previous work [[7](#CR7)] identifies a set of templates to support the
    implementation of data quality smart contracts, which serve four possible ways
    in which the data items required by a DQ control (see Fig. [2](#Fig2)) can be
    delivered to the blockchain:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Single transaction (ST): all the data required by a DQ control are contained
    in the payload of one individual transaction;'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ordered transactions (OT): the data required by a DQ control are contained
    in different transactions that are received by all nodes in the same order. This
    situation occurs when the transactions are sufficiently spaced in time, such that
    it is possible to assume^([2](#Fn2)) that all nodes will receive them in the same
    order in which they are originated;'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Interleaved transactions (IT): the data required by a DQ control are contained
    in different transactions that may not be received in the same order by all nodes.
    In this case, we assume that the transaction payloads also contain information
    required by a DQ smart contract to understand when all the data required have
    been received, such as a counter or a correlation id;'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Off-chain (Off): the data required by a DQ control are available off-chain
    and injected into the blockchain via an oracle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![../images/509088_1_En_5_Chapter/509088_1_En_5_Fig2_HTML.png](../images/509088_1_En_5_Chapter/509088_1_En_5_Fig2_HTML.png)'
  prefs: []
  type: TYPE_IMG
- en: Fig. 2.
  prefs: []
  type: TYPE_NORMAL
- en: Availability and correlation of data for quality assessment (using the multiple
    variables/single values configuration for presentation purpose; other configurations
    are similar). Reprinted from [[7](#CR7)].
  prefs: []
  type: TYPE_NORMAL
- en: Considering the dependencies described in Fig. [1](#Fig1), it is clear that
    the case of single variable, single value (SS) can only be associated with the
    single transaction (ST) scenario. Ordered transactions and interleaved transactions
    will be used when the assessment logic is based on multiple values, while the
    off-chain data could be used to retrieve single values of multiple variables.
  prefs: []
  type: TYPE_NORMAL
- en: 4 Two Scenarios for Data Quality Assessment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The two scenarios that we created for the DQ assessment overhead evaluation
    are discussed next. For each scenario, we have created a set of DQ control smart
    contract variants. These variants are classified according to the dimensions of
    the model presented in the previous section (Table [1](#Tab1) shows how the different
    combinations defined in the model are covered by the smart contract variants).Table
    1.
  prefs: []
  type: TYPE_NORMAL
- en: Distribution of DQ smart contract variants over the dimensions of the DQ model.
    Depending on the DQ dimensions assessed, one smart contract may belong to different
    categories.
  prefs: []
  type: TYPE_NORMAL
- en: '|   | (SS) Single var. | (SM) Single var. | (MS) Mult. var. | (MM) Mult. var.
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Single values | Mult. values | Single values | Mult. values |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **(ST) Single transactions** |   | SC1-1b |   | SC1-1a |'
  prefs: []
  type: TYPE_TB
- en: '| SC1-2c, SC1-2d |   | SC1-2a, SC1-2b |   |'
  prefs: []
  type: TYPE_TB
- en: '| **(OT) Ordered transactions** | N.A. |   |   | SC1-1c |'
  prefs: []
  type: TYPE_TB
- en: '|   | SC1-2c | SC1-2e | SC1-2a, SC1-2e |'
  prefs: []
  type: TYPE_TB
- en: '|   |   |   | SC2a, SC2b | SC2a, SC2c |'
  prefs: []
  type: TYPE_TB
- en: '| **(IT) Interleaved transactions** | N.A. | SC1-2d | SC1-2f | SC1-2b, SC1-2f
    |'
  prefs: []
  type: TYPE_TB
- en: '| **(Off) Off-chain data** | N.A. | N.A. | SC2c, SC2d | SC2b, SC2d |'
  prefs: []
  type: TYPE_TB
- en: '4.1 Scenario 1: Drugs Transportation'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the EU, the transportation of medicinal products for human use is regulated
    by the GDP Regulation C343/01, which states that *“it is the responsibility of
    the supplying wholesale distributor to protect medicinal products against breakage,
    adulteration and theft, and to ensure that temperature conditions are maintained
    within acceptable limits during transport...it should be possible to demonstrate
    that the medicines have not been exposed to conditions that may compromise their
    quality and integrity”*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Compliance with this regulation requires carriers to collect data during all
    the phases of transportation and to store these data in a secure and persistent
    way. We consider the case of drugs transported using thermally-insulated trucks
    equipped with sensors measuring their temperature. The quality of the products
    may in fact be altered if the storage temperature exceeds a certain range for
    a certain time. In such a scenario, blockchain supports the implementation of
    the monitoring system: if stored on a blockchain, the data collected from the
    trucks and warehouses can not be lost or tampered with, helping carriers to avoid
    liability for not meeting the required transportation standards or for hiding
    employee negligence.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this scenario, the assessment of the quality of sensor temperature readings
    concerns the following DQ dimensions: accuracy, timeliness, completeness, and
    precision. A boolean value is associated with each sensor reading for each dimension,
    indicating whether or not that reading satisfies the DQ requirements for that
    dimension. The DQ controls implemented for each dimension require additional DQ
    parameters (metadata), such as the range of admissible values for accuracy, the
    maximum delay acceptable for a temperature reading for timeliness, and a precision
    range for the precision DQ dimension. Note that the assessment of the accuracy
    and the timeliness require only the current sensor reading, whereas completeness
    and precision require also a set of previous sensor readings (the number of previous
    sensor readings to consider is an additional DQ parameter).'
  prefs: []
  type: TYPE_NORMAL
- en: The 11 variants of the DQ assessment smart contracts for this scenario are summarised
    below.
  prefs: []
  type: TYPE_NORMAL
- en: '**SC1-1**: Each transaction contains a batch of sensor readings and their timestamps.
    This is the first baseline scenario in which DQ assessment is not performed.'
  prefs: []
  type: TYPE_NORMAL
- en: '**SC1-1a** [(MM,ST)]: Each transaction contains a batch of sensor readings
    (MM), their timestamps, and the DQ parameters required to run the DQ controls.
    In this case, all the DQ controls find all the data items required inside one
    transaction (ST). All DQ dimensions are therefore immediately assessed when this
    transaction is mined into a new block.'
  prefs: []
  type: TYPE_NORMAL
- en: '**SC1-1b** [(SM,ST)]: Each transaction contains a batch of sensor readings
    and their timestamps (SM), while the DQ parameters required to run the DQ controls
    are immutably set when the smart contract is instantiated. In this case, all the
    DQ controls find all the required data items inside a transaction (ST). All the
    DQ dimensions are immediately assessed when the transaction is mined into a new
    block.'
  prefs: []
  type: TYPE_NORMAL
- en: '**SC1-1c** [(MM,OT)]: Each transaction contains a batch of sensor readings
    and their timestamps, while the DQ parameters required to run the DQ controls
    are sent in another transaction of a different kind, i.e., invoking another function
    of the DQ smart contract (MM). Therefore, all the DQ controls need to analyse
    both the current transaction containing sensor readings, and the last transaction
    received with values of the parameters. We assume that this transaction is received
    by all nodes before the one containing the batch of readings to be assessed (OT).
    All the DQ dimensions are immediately assessed when the transaction is mined in
    a new block.'
  prefs: []
  type: TYPE_NORMAL
- en: '**SC1-2**: Each transaction contains a single sensor reading and its timestamp.
    This is a second baseline scenario in which DQ assessment is not performed.'
  prefs: []
  type: TYPE_NORMAL
- en: '**SC1-2a** [(MS,ST),(MM,OT)]: Each transaction contains a single sensor reading,
    its timestamp, and the DQ parameters required to run the DQ controls (MS). In
    this case, accuracy and timeliness DQ controls find all the data items required
    in a transaction (ST). Conversely, completeness and precision DQ controls need
    to analyse also the previous transactions, which are sufficiently spaced in time
    to be received by all nodes in the same order (OT). All the DQ dimensions are
    immediately assessed when the transaction is mined in a new block.'
  prefs: []
  type: TYPE_NORMAL
- en: '**SC1-2b** [(MS,ST),(MM,IT)]: Each transaction contains a single sensor reading,
    its timestamp, a nonce (which is incremented every time a new transaction is submitted),
    and the DQ parameters required for the controls to operate. With respect to SC1b,
    this case does not take for granted that transactions may be mined in the same
    order as they were sent, and relies on the nonce to order the transactions (IT).
    Therefore, if a transaction is mined before the previous one, completeness and
    precision DQ controls are delayed until the previous transaction is mined (MM,
    IT). For accuracy and timeliness, DQ controls can be run as soon as a transaction
    is received (MS,ST).'
  prefs: []
  type: TYPE_NORMAL
- en: '**SC1-2c** [(SS,ST),(SM,OT)]: Each transaction contains a single sensor reading
    and its timestamp, while the DQ parameters required to run the DQ controls are
    immutably set when the smart contract is instantiated. In this case, the accuracy
    and timeliness DQ controls find all the data items that they require in a transaction
    (SS,ST). Conversely, the completeness and precision DQ controls need to analyse
    also the previous transactions, which we assume are mined in the correct order
    (SM,OT). All the DQ dimensions are immediately assessed when a transaction is
    mined into a new block.'
  prefs: []
  type: TYPE_NORMAL
- en: '**SC1-2d** [(SS,ST),(SM,IT)]: Each transaction contains a single sensor reading,
    its timestamp, and a nonce, while the DQ parameters required to run the DQ controls
    are immutably set when the smart contract is instantiated. As far as accuracy
    and timeliness are concerned, this variant is equivalent to SC1-2c (SS,ST). Regarding
    precision and completeness, and with respect to SC1e, this variant does not take
    for granted that transactions may be mined in the same order as they were sent
    (IT), and relies on the nonce to order the transactions. Therefore, if a transaction
    is mined before the previous one is, completeness and precision controls are delayed
    until the previous transaction is mined.'
  prefs: []
  type: TYPE_NORMAL
- en: '**SC1-2e** [(MS,OT),(MM,OT)]: Each transaction contains a single sensor reading
    and its timestamp, while the DQ parameters required for the DQ controls to run
    are sent in another transaction of a different kind. With respect to SC1-2d, the
    completeness and precision DQ controls also need to analyse the transactions containing
    the previous sensor readings. The data items required by the accuracy and timeliness
    DQ controls are all contained in a single transaction. We assume that transactions
    are received in the same order by all nodes (OT). All DQ dimensions are immediately
    assessed when the transaction is mined in a new block.'
  prefs: []
  type: TYPE_NORMAL
- en: '**SC1-2f** [(MS,IT),(MM,IT)]: Each transaction contains a single sensor reading,
    its timestamp, and a nonce, whereas the DQ parameters required to run the DQ controls
    are sent, together with a nonce and a timestamp, in another transaction of a different
    kind. This is the most complex variant, since it needs to correlate transactions
    of different kind (sensor readings and DQ parameters) that may not arrive in the
    right order. To this aim, the nonce is used to sort the transactions, whereas
    the timestamp of the sensor readings and the one of the parameters act as a correlation
    identifier. It is worth noting that DQ dimensions can be immediately assessed
    only if all the transactions are mined in the correct order, and only for the
    sensor readings that were performed before the last DQ parameters update. In all
    the other cases, DQ controls are delayed.'
  prefs: []
  type: TYPE_NORMAL
- en: '4.2 Scenario 2: Drugs Prescription'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: General practitioners (GP) prescribe dozens of medications every day to their
    patients. Patients have their clinical background and (possibly) a list of ongoing
    treatments, so it can be difficult for GPs to assess whether a new prescribed
    drug can cause them any harm, for instance because it is incompatible with an
    ongoing treatment.
  prefs: []
  type: TYPE_NORMAL
- en: We assume that prescriptions are recorded in a blockchain system invoking a
    function of a smart contract. Each new prescription contains the patient’s SSN
    and a prescribed drug. The DQ control functions of the smart contract, in this
    case, can be invoked manually by a GP for each prescription to check (i) if the
    patient SSN exists (Eligibility), and (ii) to verify whether there are any drugs
    already prescribed that are incompatible with the current prescription (Compatibility).
  prefs: []
  type: TYPE_NORMAL
- en: 'The 5 variants of the DQ control smart contracts for this scenario are summarized
    next:'
  prefs: []
  type: TYPE_NORMAL
- en: '**SC2**: This the baseline scenario in which DQ assessment is not performed.'
  prefs: []
  type: TYPE_NORMAL
- en: '**SC2a** [(MS,OT)(MM,OT)]: Both drug incompatibilities and eligible patients
    are stored on-chain. More in detail, each time a new patient is registered, a
    transaction containing the patient SSN is submitted. Similarly, when a new drug
    is introduced, another type of transaction containing the drug ID, its category
    and its incompatibilities is submitted. When a new prescription is created, another
    type of transaction containing the patient SSN and the drug being prescribed is
    submitted. Since all the information required by the DQ controls is available
    in the blockchain when this transaction is submitted, DQ controls are immediately
    performed once the transaction is mined.'
  prefs: []
  type: TYPE_NORMAL
- en: '**SC2b** [(MS,OT),(MM,Off)]: Eligible patients are stored on-chain, whereas
    drug incompatibilities are stored off-chain. With respect to SC2a, only transactions
    related with new patients and new prescriptions are submitted. Instead, the list
    of drugs, their categories and their incompatibilities are stored in an XML file
    published on an Internet-facing Web server. Therefore, whenever a new prescription
    is created, the smart contract must invoke an oracle that reads the XML file,
    retrieves the information related to the drug being prescribed, and notify this
    information to the smart contract. As a consequence, the eligibility control is
    immediately performed once a transaction is mined. Conversely, the compatibility
    control is on hold until the oracle calls back the smart contract providing to
    it the list of incompatibilities.'
  prefs: []
  type: TYPE_NORMAL
- en: '**SC2c** [(MS,Off),(MM,OT)] Eligible patients are stored off-chain, whereas
    drug incompatibilities are stored on-chain. With respect to SC2a, only transactions
    related to new drugs and new prescriptions are submitted. Instead, eligible patients
    are stored in an XML file published on an Internet-facing Web server. Therefore,
    whenever a new prescription is created, the smart contract must invoke an oracle
    that reads the XML file, finds if the patient is present in that file, and notifies
    that to the smart contract. As a consequence, the compatibility control is immediately
    performed once the transaction is mined. Conversely, the eligibility control is
    on hold until the oracle calls back the smart contract notifying it whether the
    patient exists or not.'
  prefs: []
  type: TYPE_NORMAL
- en: '**SC2d** [(MS,Off),(MM,Off)]: Both drug incompatibilities and eligible patients
    are stored off-chain. With respect to SC2a, only transactions related to new prescriptions
    are submitted. Instead, eligible patients and the list of drugs, their categories
    and their incompatibilities are stored in XML files published on an Internet-facing
    Web server. Therefore, whenever a new prescription is created, the smart contract
    must invoke an oracle that reads the XML files, finds if the patient is present
    in that file, retrieves the information related to the drug being prescribed,
    and notifies that to the smart contract. As a consequence, all DQ controls are
    on hold until the oracle calls back the smart contract notifying it if the patient
    exists and, if so, providing to it the list of incompatibilities.'
  prefs: []
  type: TYPE_NORMAL
- en: 5 Evaluation of Data Quality Assessment Overhead
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created a set of smart contracts implementing the DQ assessment variants
    discussed in the previous section in the Solidity language using the Remix IDE.
    The smart contracts have been deployed on the Ethereum Ropsten test network, which
    is an Ethereum public network where the Ether cryptocurrency is virtual, making
    smart contract invocations free of charge.
  prefs: []
  type: TYPE_NORMAL
- en: For Scenario 1, we simulated the behaviour of a sensor that performs a reading
    every 6 min. In particular, for SC1-1 and its variants, a transaction is submitted
    every 30 min, so a batch of 5 sensor readings is expected per transaction. Conversely,
    for SC1-2 and its variants, a transaction is submitted each time a sensor reading
    is performed. In addition, for SC1-2f, a transaction containing the updated DQ
    parameters is submitted every 30 min in order to trigger the DQ controls for the
    sensor readings received before that transaction. Finally, for SC1-2b, SC1-2d,
    and SC1-2f, we intentionally delayed the submission of 1 transaction out of 5
    for 12 min, in order to test the ability of the smart contracts to deal with interleaved
    transactions.
  prefs: []
  type: TYPE_NORMAL
- en: For Scenario 2, we consider 8 drugs that could be prescribed to 3 eligible patients.
    For SC2a and SC2b, before the drugs could be prescribed, a transaction is submitted
    for each patient (to notify to the smart contract that the patients are eligible).
    Additionally, for SC2a and SC2c, before the drugs could be prescribed, a transaction
    is submitted for each drug (to notify to the smart contract which drugs are incompatible
    with each other). Conversely, for SC2b, SC2c, and SC2d, we also relied on oracles
    to access off-chain data for checking the existence of a drug (SC2b and SC2d)
    and for retrieving the category to which the drug belongs and the drugs with which
    it is incompatible (SC2c and SC2d). These oracles have been implemented using
    Provable ([provable.​xyz](http://provable.xyz/)), an online service offering a
    library of functions that programmers can invoke to read data from an external
    source and push them inside smart contracts.
  prefs: []
  type: TYPE_NORMAL
- en: 'To evaluate the overhead of DQ smart contracts, we considered the following
    metrics:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Set-up gas.** The amount of gas needed to make the smart contract operational,
    which is a measure of both the complexity of the smart contract and the cost to
    deploy it. This metric, in fact, includes both the gas spent to deploy the smart
    contract, and the sum of the gas spent for invoking the functions that pass all
    the data required by the smart contract to perform the DQ assessments. For example,
    in SC1g the latter includes the gas spent to invoke the functions passing the
    DQ parameters, such as the expected temperature to compute the accuracy, whereas
    in SC2a it includes the gas spent to invoke the functions that store in the smart
    contract the eligible patients and the incompatibilities among drugs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Processing gas.** The amount of gas needed on average to store the data collected
    into a smart contract, which is a measure of both the complexity of the smart
    contract and the cost it requires to be executed. For example, in SC1g, it comprises
    the gas spent to submit a new batch of sensor readings. In SC2a, it comprises
    the gas spent to submit a new prescription.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Processing time**. The amount of time one has to wait before the data collected
    are stored in a smart contract. For this metric, both the arithmetic mean and
    the standard deviation are computed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DQ validation delay**. The amount of time one has to wait, once the data
    collected are stored in the smart contract, before their quality is assessed.
    For this metric, the arithmetic mean, the standard deviation, the absolute maximum
    and the absolute minimum are computed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Table 2.
  prefs: []
  type: TYPE_NORMAL
- en: Results of the experiments (time reported as mm:ss).
  prefs: []
  type: TYPE_NORMAL
- en: '| Smart contract | Set-up gas | Processing gas | Processing time | DQ validation
    delay |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Value | Increment | Value | Increment | AVG | Increment | STDEV | AVG | STDEV
    | MIN | MAX |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| SC1-1 | 482785 | N/A | 324958 | N/A | 01:00 | N/A | 01:16 | N/A | N/A | N/A
    | N/A |'
  prefs: []
  type: TYPE_TB
- en: '| SC1-1a | 1016659 | +111% | 333817 | +3% | 00:31 | –48% | 00:15 | 00:00 |
    00:00 | 00:00 | 00:00 |'
  prefs: []
  type: TYPE_TB
- en: '| SC1-1b | 1184398 | +145% | 346425 | +7% | 00:29 | –52% | 00:27 | 00:00 |
    00:00 | 00:00 | 00:00 |'
  prefs: []
  type: TYPE_TB
- en: '| SC1-1c | 1243773 | +158% | 346425 | +7% | 00:35 | –42% | 00:22 | 00:00 |
    00:00 | 00:00 | 00:00 |'
  prefs: []
  type: TYPE_TB
- en: '| SC1-2 | 401441 | N/A | 104387 | N/A | 00:17 | N/A | 00:08 | N/A | N/A | N/A
    | N/A |'
  prefs: []
  type: TYPE_TB
- en: '| SC1-2a | 838387 | +109% | 135331 | +30% | 00:45 | +165% | 00:43 | 00:00 |
    00:00 | 00:00 | 00:00 |'
  prefs: []
  type: TYPE_TB
- en: '| SC1-2b | 923172 | +130% | 140929 | +35% | 00:22 | +29% | 00:15 | 00:37 |
    01:54 | 00:00 | 06:35 |'
  prefs: []
  type: TYPE_TB
- en: '| SC1-2c | 1011508 | +152% | 147850 | +42% | 00:59 | +247% | 03:43 | 00:00
    | 00:00 | 00:00 | 00:00 |'
  prefs: []
  type: TYPE_TB
- en: '| SC1-2d | 1092466 | +172% | 152611 | +46% | 00:20 | +18% | 00:10 | 00:37 |
    01:52 | 00:00 | 06:27 |'
  prefs: []
  type: TYPE_TB
- en: '| SC1-2e | 1070942 | +167% | 147850 | +42% | 00:23 | +35% | 00:15 | 00:00 |
    00:00 | 00:00 | 00:00 |'
  prefs: []
  type: TYPE_TB
- en: '| SC1-2f | 1526459 | +280% | 132418 | +27% | 00:21 | +24% | 00:11 | 18:02 |
    08:38 | 06:48 | 30:40 |'
  prefs: []
  type: TYPE_TB
- en: '| SC2 | 2748971 | N/A | 184566 | N/A | 00:22 | N/A | 00:25 | N/A | N/A | N/A
    | N/A |'
  prefs: []
  type: TYPE_TB
- en: '| SC2a | 4342274 | +58% | 507400 | +175% | 01:17 | +250% | 01:37 | 00:00 |
    00:00 | 00:00 | 00:00 |'
  prefs: []
  type: TYPE_TB
- en: '| SC2b | 5251579 | +91% | 685506 | +271% | 00:24 | +9% | 00:19 | 00:26 | 00:17
    | 00:01 | 00:56 |'
  prefs: []
  type: TYPE_TB
- en: '| SC2c | 6112655 | +122% | 270056 | +46% | 00:28 | +27% | 00:29 | 00:06 | 00:13
    | 00:00 | 00:40 |'
  prefs: []
  type: TYPE_TB
- en: '| SC2d | 5249786 | +91% | 813988 | +341% | 00:36 | +64% | 00:26 | 00:33 | 00:14
    | 00:12 | 00:57 |'
  prefs: []
  type: TYPE_TB
- en: The code of the smart contracts is available at [https://​bitbucket.​org/​polimiisgroup/​dq-solidity](https://bitbucket.org/polimiisgroup/dq-solidity).
    To minimise the effects of congestion in the Ropsten test network, which causes
    significant variations in the time required for a transaction to be mined, we
    have repeated our measurements invoking the same smart contract functions in 7
    different days, 5 times during business days and 2 times during the weekend, when
    the traffic is lower according to the data that we collected. The performance
    that we report is the average of the performance values registered in these 7
    executions.
  prefs: []
  type: TYPE_NORMAL
- en: Table [2](#Tab2) shows the results of the experiment, and allows the comparison
    of each smart contract with its variants that implement the DQ controls discussed
    in Sect. [4](#Sec6).
  prefs: []
  type: TYPE_NORMAL
- en: The results regarding the processing time have to be carefully interpreted.
    In practice, we have seen that, while the processing time is highly variable depending
    on the network conditions (see the standard deviation values in Table  [2](#Tab2),
    which often are higher than the corresponding average), the impact of DQ controls
    on the processing time is negligible. That is, the processing time with and without
    DQ controls is normally comparable, and it follows the fluctuations of transaction
    processing time in the test network.
  prefs: []
  type: TYPE_NORMAL
- en: Concerning Scenario 1, the impact of DQ controls on the set-up gas is quite
    high, as it causes an increment ranging from 111% to 158% for SC1-1, and from
    109% to 280% for SC1-2\. Conversely, the impact of DQ controls on the processing
    gas is rather modest for SC1-1, as the increment ranges from 3% to 7%, while for
    SC1-2 is more substantial, as it ranges from 27% to 46%. It is worth noting that
    the DQ validation delay occurs only for SC1-2b, SC1-2d, and SC1-2f, as those are
    the only smart contracts that delay DQ controls in order to take into account
    interleaved transactions. In particular, for SC1-2b and SC1-2d the maximum delay
    corresponds to the difference between the time when the delayed transaction is
    mined and the time when the subsequent transaction is mined. Conversely, the minimum
    delay is 0 for transactions that are submitted before the time when the delayed
    one should have been submitted, and for those that are submitted after the delayed
    one was submitted. For SC1-2f, the maximum delay corresponds to the difference
    between the time when the first transaction after the last DQ parameters update
    is mined, and the time when the first transaction after the previous DQ parameters
    update is mined. Instead, the minimum delay corresponds to the difference between
    the time when the first transaction after the last DQ parameters update is mined,
    and the time when the last transaction before the last DQ parameters update is
    mined. Therefore, in SC1-2f, the DQ validation delay depends on the frequency
    of the DQ parameters updates.
  prefs: []
  type: TYPE_NORMAL
- en: Concerning Scenario 2, the impact of DQ controls on both the set-up gas and
    the processing gas is quite high, as it causes an increment ranging from 58% to
    122% for the former, and from 46% to 341% for the latter. It is worth noting that
    the DQ validation delay occurs only for SC2b, SC2c, and SC2d, as they require
    external data to be fetched by Provable. Also, the DQ validation time equates
    on average to the processing time. This can be explained by the way Provable is
    invoked. Indeed, when contacted, Provable retrieves the off-chain data and submits
    them to the contract by submitting a transaction that invokes a callback function
    of the smart contract. Therefore, for DQ controls to take place, two subsequent
    transactions must be submitted, one with the data to evaluate, and another with
    the off-chain metadata for the DQ validation algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, the results show that adding data quality controls to a smart contract
    has a considerable impact on both the gas used and the time-related performance
    to deploy and invoke it. The overhead in terms of gas used, in particular, is
    strictly related with the complexity of the code of the DQ control functions.
    Therefore, this overhead can be minimised by applying smart contract code optimisation
    techniques, e.g. [[1](#CR1)], which are not specific to DQ controls. The overhead
    increases dramatically in an unpredictable way if oracles are used to fetch off-chain
    data required by a DQ control. However, it is worth noting that, although the
    variants of SC2 that make use of Provable are the most expensive in terms of gas,
    the amount of patients and drugs in this experiment is rather small. In a real
    scenario, where the contract may have to deal with thousands of patients and drugs,
    it could become inconvenient or even impossible not to rely on off-chain data
    and oracles.
  prefs: []
  type: TYPE_NORMAL
- en: 6 Conclusions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have presented an empirical evaluation of smart contract-based DQ assessment
    of transaction payloads in Ethereum. For the evaluation, we have developed a set
    of variants of DQ assessment smart contracts covering different types of DQ controls
    and measured the overhead associated with their execution on the Ethereum Ropsten
    test network.
  prefs: []
  type: TYPE_NORMAL
- en: 'The obtained results show that if DQ controls do not rely on oracles, the time
    required to validate transactions is low. Conversely, the impact in terms of resources
    needed to execute the DQ controls can be quite high, especially when the smart
    contracts are deployed in a public blockchain that requires cryptocurrency to
    operate. DQ controls that rely on oracles have a high impact on the amount of
    required resources. In our experiments, they required double the time in respect
    of the situation without oracles. Indeed, accessing oracles requires to submit
    two subsequent transactions: one related to the smart contract invocation and
    one related to the oracle invocation.'
  prefs: []
  type: TYPE_NORMAL
- en: It is also worth noting that, the more DQ controls are resilient to network
    problems, such as interleaved transactions, the more expensive the smart contract
    will be and the more time it will take for DQ controls to be performed. Consequently,
    there is a trade-off between the accuracy of DQ controls and the time and cost
    required for such controls to operate.
  prefs: []
  type: TYPE_NORMAL
- en: We plan to extend this work in several ways. More scenarios and experiments
    can be implemented to evaluate the overhead more thoroughly, studying its variations
    for instance with the type of data quality control considered. More in general,
    existing data quality management methodologies can be extended to the case of
    blockchain as the core technology for implementing the application logic and/or
    storing data. The approach based on smart contracts can be tested also in other
    blockchains to check to what extent the results presented here can be generalized.
  prefs: []
  type: TYPE_NORMAL
- en: Acknowledgements
  prefs: []
  type: TYPE_NORMAL
- en: The authors thank Lorenzo Maria Bonelli for his help with the initial implementation
    of the smart contracts.
  prefs: []
  type: TYPE_NORMAL
- en: '© Springer Nature Switzerland AG 2021J. González Enríquez et al. (eds.)Business
    Process Management: Blockchain and Robotic Process Automation ForumLecture Notes
    in Business Information Processing428[https://doi.org/10.1007/978-3-030-85867-4_6](https://doi.org/10.1007/978-3-030-85867-4_6)'
  prefs: []
  type: TYPE_NORMAL
- en: Blockchain as a Countermeasure Solution for Security Threats of Healthcare Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Mubashar Iqbal^([1](#Aff12) [ ](#ContactOfAuthor1)) and Raimundas Matulevičius^([1](#Aff12) [ ](#ContactOfAuthor2))(1)Institute
    of Computer Science, University of Tartu, Tartu, EstoniaMubashar Iqbal (Corresponding
    author)Email: [mubashar.iqbal@ut.ee](mailto:mubashar.iqbal@ut.ee)Raimundas Matulevičius (Corresponding
    author)Email: [raimundas.matulevicius@ut.ee](mailto:raimundas.matulevicius@ut.ee)'
  prefs: []
  type: TYPE_NORMAL
- en: Abstract
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Healthcare industry is digitising its healthcare operations and generating huge
    amounts of sensitive medical data to make prompt and informed decisions in patients’
    health diagnosis and care. The healthcare industry is subjected to a variety of
    security threats *(e.g., data tampering, theft, and counterfeit drugs)*. Blockchain
    is gaining traction to address such security threats and improve data integrity
    by turning healthcare operations into decentralised, transparent, and immutable
    manners. However, there is conceptual ambiguity and semantic gaps about blockchain
    as a countermeasure solution for healthcare security threats. In this work, we
    use the web ontology language to create blockchain-based security ontology (HealthOnt)
    to remove conceptual ambiguity and semantic gaps. The HealthOnt offers coherent
    and formal information models that present blockchain as a countermeasure solution
    for security threats of traditional healthcare applications.
  prefs: []
  type: TYPE_NORMAL
- en: KeywordsBlockchainHealthcare applicationsSecurity threatsBlockchain countermeasuresSecurity
    risk management
  prefs: []
  type: TYPE_NORMAL
- en: 1 Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Healthcare applications are integrating technology infrastructure to empower
    patients and the entire healthcare sector. The change facilitates the healthcare
    sector to make more prompt and informed decisions using digital medical data.
    The medical data is sensitive, confidential, and indispensable that plays an essential
    role in patients’ health diagnosis, treatment and reduces medical mistakes. The
    growing medical data heighten the concerns to make it secure against various security
    threats (e.g., data tampering, theft, counterfeit drugs). Blockchain technology
    is emerging in healthcare to overcome such security challenges, enhance data integrity,
    and transform the transacting process into a decentralised, transparent, and immutable
    manner. For example, the study [[1](#CR1)] presents the blockchain-based healthcare
    application along with cloud computing to protect medical data from being tampered,
    theft, and unauthorised use.
  prefs: []
  type: TYPE_NORMAL
- en: Blockchain is a decentralised, distributed, and immutable ledger technology
    that operates over a peer-to-peer (P2P) network [[2](#CR2)]. A ledger contains
    a certain and verifiable record of every single transaction ever made [[1](#CR1)].
    Blockchain technology is making inroads to various sectors, with the healthcare
    sector leading the way [[3](#CR3)]. The success of blockchain-based applications
    is contingent on the medical data being accurate, verifiable, and untampered.
  prefs: []
  type: TYPE_NORMAL
- en: In healthcare, data is one of the most valuable assets. Healthcare applications
    suffer from various security threats [[4](#CR4)–[6](#CR6)] that could negate the
    confidentiality, integrity, and availability of medical data. The tampered medical
    data can cause major issues during the patient treatment process. Also, digital
    health records increase the risk of unauthorised access, information disclosure,
    and various internal and external threats. The study [[7](#CR7)] investigated
    the security of healthcare applications, and findings reveal that organisations
    do not adhere to best practices when designing healthcare applications. Moreover,
    the technology infrastructure is incompatible with providing security measures
    by design.
  prefs: []
  type: TYPE_NORMAL
- en: 'The advent of blockchain technology has opened several research areas within
    the healthcare sector to preserve medical data, ensure data integrity, patient
    ownership to his data, easy exchange of medical data, and seamless medical insurance
    claims. However, there is conceptual ambiguity and semantic gaps about blockchain
    as a countermeasure solution for traditional healthcare applications [[1](#CR1),
    [8](#CR8), [9](#CR9)]. Therefore, we build an ontology by investigating the security
    threats of traditional healthcare applications and how these security threats
    could be mitigated by utilising blockchain. The contribution of this work is twofold:'
  prefs: []
  type: TYPE_NORMAL
- en: A framework that explains the security threats and blockchain-based countermeasures
    to secure healthcare applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The construction of blockchain-based healthcare security ontology *(HealthOnt)*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We follow the security risk management (SRM) domain model [[10](#CR10), [11](#CR11)]
    and develop a framework to explore the security threats of traditional healthcare
    applications. The framework assists us in building a blockchain-based healthcare
    security ontology (HealthOnt). The HealthOnt could support the selection of blockchain
    to security experts when designing healthcare applications. Also, the HealthOnt
    encodes traditional healthcare applications’ information security into a dynamic
    ontology-based knowledge that can be extended, reused, or integrated with other
    security ontologies. The paper is structured as follows: Sect. [2](#Sec2) discusses
    the blockchain, research method, and related work. Section [3](#Sec6) presents
    the security risk analysis of healthcare applications and blockchain as a countermeasure
    solution. Section [4](#Sec12) gives an overview of ontology development. Section [5](#Sec13)
    is ontology evaluation, and Sect. [6](#Sec14) concludes the paper.'
  prefs: []
  type: TYPE_NORMAL
- en: 2 Background
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 2.1 Blockchain
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Blockchain creates a chain of blocks and removes trusted intermediaries from
    the transaction process. A unique cryptographic hash links each block to the one
    before it. Blockchain could be classified as permissionless (e.g., Ethereum) or
    permissioned (e.g., Hyperledger Fabric). A permissionless blockchain is fully
    decentralised and accessible to everyone. Contrarily, a permissioned blockchain
    is partially decentralised with restrictions on who can join and access the operations.
    Blockchain comprises consensus mechanisms (e.g., Proof of Work (PoW), Proof of
    Stake (PoS)) to maintain the ledger state. Smart contract in blockchain is a piece
    of code that autonomously executes when certain conditions meet. Smart contract
    eliminates trusted intermediaries, less human intervention, reduces enforcement
    cost, prevents malicious or unintentional security threats [[12](#CR12)].Table
    1.
  prefs: []
  type: TYPE_NORMAL
- en: Blockchain features
  prefs: []
  type: TYPE_NORMAL
- en: '| Feature | Detail |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Immutability | Once a record is added to the blockchain, it cannot be altered
    or deleted |'
  prefs: []
  type: TYPE_TB
- en: '| Decentralised | Blockchain does not have a centralised single governing authority
    or a person. A group of distributed nodes maintains the network |'
  prefs: []
  type: TYPE_TB
- en: '| Distributed | Operates over P2P network, and the participants’ nodes have
    the same power in the network that share distributed computational power |'
  prefs: []
  type: TYPE_TB
- en: '| Consensus | Helps to maintain the state and immutability of the ledger |'
  prefs: []
  type: TYPE_TB
- en: '| Provenance | Each activity is recorded on a blockchain that lets everyone
    verify its authenticity |'
  prefs: []
  type: TYPE_TB
- en: '| Tamper-evident | Blockchain detects any interference/tampering with the content
    |'
  prefs: []
  type: TYPE_TB
- en: '| Cryptography | Allows blocks to be securely connected, ensuring consistency
    and immutability of the data stored in the blockchain |'
  prefs: []
  type: TYPE_TB
- en: '| Distributed Access control | Blockchain-based access control provides decentralised
    and distributed resource authorisation |'
  prefs: []
  type: TYPE_TB
- en: '| Permissioning | Categorisation of certain actions to be performed only by
    certain participants |'
  prefs: []
  type: TYPE_TB
- en: '| Pseudonymous | Blockchain masks the user identity to not contain any identifiable
    information |'
  prefs: []
  type: TYPE_TB
- en: Blockchain has a variety of features (Table [1](#Tab1)) that makes it an irresistible
    and emerging technology in various applications domains. The features bring transparency,
    trust and tamper-resistance characteristics that are pillars of making the business
    and transactional procedures more secure, efficient and effective.
  prefs: []
  type: TYPE_NORMAL
- en: 2.2 Research Method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This paper aims to present an ontological framework based on the SRM domain
    model to show blockchain as a countermeasure to mitigate various security threats
    of traditional healthcare applications. In this case, a systematic literature
    review (SLR) is appropriate since it allows the systematic analysis of relevant
    literature. We followed the review guidelines of Kitchenham [[13](#CR13)] and
    specified the review protocol^([1](#Fn1)) to identify relevant papers and conduct
    this study.
  prefs: []
  type: TYPE_NORMAL
- en: The SRM domain model [[10](#CR10), [11](#CR11)] helps us to structure the knowledge
    of blockchain as a countermeasure solution. Among other SRM approaches [[15](#CR15)],
    the SRM domain model fulfils the criteria of ISO/IEC 27001 standard and explore
    three aspects *(e.g., assets-, risk-, and risk treatment-related)* during the
    early phases of information system development. The asset can be a system or business
    asset. The business asset has value and the system asset supports it. Security
    criteria (confidentiality - C, integrity - I, and availability - A) distinguish
    the security needs. The risk combines a risk event and impact. The risk event
    constitutes the threat and one or more vulnerabilities. The threat targets the
    system asset and exploits the vulnerability. The vulnerability is connected to
    the system assets and depicts their weaknesses. Impact harms the business asset
    and negates the security criteria. The risk treatment implements the security
    requirements as countermeasures to improve the system security.
  prefs: []
  type: TYPE_NORMAL
- en: 2.3 Related Work
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The research direction to secure healthcare applications by using blockchain
    is emerging. A few studies evaluated different security aspects of traditional
    healthcare applications and the role of blockchain to mitigate them.
  prefs: []
  type: TYPE_NORMAL
- en: Saha et al. [[1](#CR1)] review the blockchain-based healthcare solutions to
    protect from data tampering and data leakage. The study presents a comparative
    analysis of different literature studies of healthcare applications that use blockchain.
    The survey [[8](#CR8)] addresses the security and privacy concerns in healthcare.
    The authors explore the timeline of security attacks on medical data and various
    traditional security algorithms to defend against them. The traditional security
    algorithms are shown to be ineffective, and blockchain is used as an advanced
    architecture for the safe and secure execution of medical transactions and to
    maintain the security and privacy of digital medical records.
  prefs: []
  type: TYPE_NORMAL
- en: The study [[9](#CR9)] describes the fundamental principles of blockchain to
    address the security and privacy issues of traditional healthcare applications.
    The study also discusses the technical advantages of blockchain in healthcare
    (e.g., faster and easier interoperability). The [[16](#CR16)] presents the different
    use cases to address security and interoperability challenges of traditional healthcare
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Chukwu et al. [[17](#CR17)] perform a SLR to explore the trust, security and
    privacy constraints of traditional digital health records and how blockchain plays
    a role to overcome them. The study evaluated 61 articles to address the traditional
    healthcare applications security challenges and blockchain-enabled emerging trends
    in healthcare research. The SLR [[18](#CR18)] investigates the use cases and security
    challenges, including how blockchain can protect medical data from potential data
    loss, corruption or intentional security attacks. Jin et al. [[12](#CR12)] present
    blockchain in healthcare for secure and privacy-preserving medical data sharing.
    The study argues that blockchain’s tamper-evidence and decentralisation features
    could help build a secure medical data-sharing network.
  prefs: []
  type: TYPE_NORMAL
- en: The related works discuss the specific security aspect without addressing vulnerabilities,
    assets to protect, blockchain features, and not following any SRM domain model.
    In contrast, our study accumulates the security threats of traditional healthcare
    applications and how blockchain acts as a countermeasure solution to mitigate
    them. Moreover, we utilise the SRM domain model and develop an ontological framework
    that provides a dynamic knowledge base to facilitate the security of healthcare
    applications using blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: 3 Security Risk Analysis of Healthcare Applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We analyse the literature studies using the SRM domain model to build a framework
    (Table [2](#Tab2)) that presents the security threats, their vulnerabilities,
    assets to protect, and blockchain-based countermeasures. In this section, we only
    discuss the first five security threats from Table [2](#Tab2). The remaining security
    threats *(e.g., single-point failure, repudiation, insurance frauds, clinical
    trial fraud, tampering device settings, social engineering)* are discussed in
    [[14](#CR14)].
  prefs: []
  type: TYPE_NORMAL
- en: 3.1 Data Tampering
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The traditional approaches lack control over data security, which is a major
    concern for healthcare organisations because it can put patient’s lives at risk.
  prefs: []
  type: TYPE_NORMAL
- en: '**Vulnerabilities:** In traditional healthcare applications, the access control
    is managed by a designated authority/individual that could be error-prone. The
    *weak centralised access control* [[4](#CR4), [19](#CR19)–[21](#CR21)] describes
    a case when the healthcare application fails to restrict unauthorised access to
    the resources. The attacker compromises the security and performs unauthorised
    actions that negate the integrity of medical records and confidentiality of patient
    data. The attacker uses unauthorised access to gain elevated privileges, execute
    commands, or bypass the security mechanisms to tamper with medical data. Moreover,
    traditional healthcare applications often rely on manual techniques or third-party
    providers to perform data verification and validation. These techniques *lack
    the proper mechanisms to verify and validate the authenticity of data* [[2](#CR2),
    [22](#CR22), [23](#CR23)]. Consequently, the attacker can submit malicious content
    that the system can process and negate the integrity of medical records and confidentiality
    of patient data.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Countermeasures:** Blockchain allows smart contracts-based distributed access
    control [[24](#CR24)] that could regulate the users access to stored medical data.
    The system authenticates and identifies associated users according to their access
    rights deployed in a decentralised and distributed environment. Also, strong cryptographic
    primitives (e.g., attribute-based encryption) [[25](#CR25)] help to build fine-grained
    access control. The records are difficult to modify/delete because of the ledger
    redundancy and append-only structure [[26](#CR26)]. The healthcare applications
    on permissionless blockchain use PoW consensus to verify the executed transaction
    and data validation without requiring a third party before saving on the ledger
    [[22](#CR22)]. Moreover, using the SHA-256 hashing algorithm, blockchain computes
    a unique hash id of original data that can be used to verify the authenticity
    of data [[21](#CR21)]. Hyperledger fabric uses trusted authorised nodes to verify
    and validate the authenticity of data [[2](#CR2)]. Blockchain is tamper-evident
    [[20](#CR20), [21](#CR21)] and thus detects any unauthorised modifications. Blockchain
    builds strong audit trails in immutable ledgers by keeping a log of each performed
    action [[20](#CR20)] over time that could be used to verify and validate the authenticity
    of data.Table 2.'
  prefs: []
  type: TYPE_NORMAL
- en: Security risk analysis of traditional healthcare applications
  prefs: []
  type: TYPE_NORMAL
- en: '![../images/509088_1_En_6_Chapter/509088_1_En_6_Tab2_HTML.png](../images/509088_1_En_6_Chapter/509088_1_En_6_Tab2_HTML.png)'
  prefs: []
  type: TYPE_IMG
- en: 3.2 Data Theft
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In healthcare, data theft has been on the rise over the past ten years, in 2020
    reported 642 data thefts incidents [[5](#CR5)] only in the United States.
  prefs: []
  type: TYPE_NORMAL
- en: '**Vulnerabilities:** Databases are one of the most compromised assets [[8](#CR8)]
    and centralised databases have *improper security controls* to protect against
    insider or outsider threats [[25](#CR25), [26](#CR26)]. The threats imposed by
    this vulnerability include: i) abuse of elevated privileges, ii) unauthorised
    access, iii) backup storage exposure, iv) database injection, v) default database
    accounts and configurations, vi) malware and the vii) human factor [[5](#CR5),
    [8](#CR8)]. Overall it negates the integrity of the healthcare system and confidentiality
    of medical data.'
  prefs: []
  type: TYPE_NORMAL
- en: Similar to data tampering, the attacker can steal medical data due to *weak
    centralised access control* [[25](#CR25), [27](#CR27)] that leads the attacker
    to gain unauthorised access, elevated privileges, or bypass security mechanisms.
    As a result, it negates the confidentiality of medical data. Traditional healthcare
    applications use cryptography to save data securely and achieve information security
    objectives. However, it *lacks cryptographic control* [[27](#CR27)] over data
    since the centralised authority/individual is responsible for the administration
    of the database (keeping elevated privileges, encryption/decryption keys). If
    the security of the system is compromised, then the attacker can steal the medical
    data.
  prefs: []
  type: TYPE_NORMAL
- en: '**Countermeasures:** Blockchain works on a P2P-based distributed network where
    nodes behave both as a server and client to send and receive data directly with
    each other. This mechanism helps to protect the data leakage to unauthorised network
    users [[2](#CR2)]. The solution proposed in [[26](#CR26)] uses the voting process
    (e.g., QuorumChain algorithm) to determine which nodes are allowed to access certain
    types of data. The permissioned blockchains define permission settings to restrict
    data access only to authorised nodes [[21](#CR21), [27](#CR27)]. Similar to data
    tampering countermeasures, the strong cryptographic primitives (e.g., attribute-based
    encryption) [[25](#CR25)] and smart contracts-based distributed access control
    mechanism [[22](#CR22)] allows only authorised users to access medical data. The
    Ancile framework [[26](#CR26)] uses the proxy re-encryption to encrypt the data
    and store hashes data on/off-chain, [[25](#CR25)] suggests data obfuscation to
    protect data on/off-chain.'
  prefs: []
  type: TYPE_NORMAL
- en: 3.3 Medical Records Mishandling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Healthcare staff must ensure that medical records are kept private and safe.
    But medical records mishandling is one of the common HIPAA violations [[6](#CR6)].
  prefs: []
  type: TYPE_NORMAL
- en: '**Vulnerabilities:** The medical institutions control and manage the patient’s
    medical data where the non-relevant individuals can access it as well. Thus, patients
    have *weak control over their medical records* [[28](#CR28)]. Also, the patient
    is unaware of how his data is processed or with whom it is shared. In some cases,
    the individual from a medical institution involves in illegal medical data trade
    [[29](#CR29)] that negates the integrity and confidentiality of medical records.'
  prefs: []
  type: TYPE_NORMAL
- en: Hospitals and healthcare applications *rely on third-party* [[23](#CR23), [25](#CR25)]
    vendors (e.g., IT vendors, pharmacies, insurance companies, etc.) daily to perform
    their routine functions. These third-party vendors have access to the patient’s
    medical data. They could intentionally sell medical data to data brokers or become
    a source of data breach and negate the confidentiality of medical data.
  prefs: []
  type: TYPE_NORMAL
- en: Also, the medical data is managed by a designated authority/individual, and
    the system administration governs the system with elevated privileges. If any
    such point is compromised, the attacker can manipulate and negate the integrity
    of medical data without leaving the traces. Therefore, traditional healthcare
    applications *cannot guarantee the authenticity* [[23](#CR23)] of digital medical
    records.
  prefs: []
  type: TYPE_NORMAL
- en: '**Countermeasures:** The permission settings and distributed access control
    enable patients to handle their medical data [[19](#CR19), [30](#CR30)]. The blockchain
    performs data validation during the consensus process before saving on the ledger.
    For example, blockchain provides a transparent platform to define data validation
    rules which are agreed upon by decentralised and distributed network nodes [[31](#CR31)].
    Then, all the nodes follow those rules to validate the data. The blockchain-based
    applications detect and discard all the unauthorised changes [[30](#CR30)] if
    the majority of the network is honest (e.g., the adversary does not control 51%
    computing power). This process establishes a tamper-resistant environment [[32](#CR32)].'
  prefs: []
  type: TYPE_NORMAL
- en: 3.4 Counterfeit Drugs (Fake Medicine)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For years, the pharmaceutical supply chain has been struggling to monitor its
    products and avoid fake medicine. According [[19](#CR19), [28](#CR28)], 10–30%
    (worth $200 billion) of drugs sold worldwide each year are counterfeit.
  prefs: []
  type: TYPE_NORMAL
- en: '**Vulnerabilities:** Counterfeit drugs are on the rise, posing significant
    health risks. In pharmaceuticals, after manufacturing, drugs are moved from production
    stocks to wholesale distributors, which then move to retail firms. Customers purchase
    drugs from retailers. Due to *weak traceability controls* (e.g., ineffective data
    sharing, no traceable records) [[3](#CR3), [19](#CR19), [28](#CR28)] in the pharmaceutical
    supply chain, there is a risk of fake medicines being introduced during this process.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Countermeasures:** Blockchain offers a solution to enable pharmaceutical
    traceability, real-time access to data and supply chain validation by creating
    a log to track each step [[3](#CR3), [19](#CR19), [28](#CR28)]. For example, IBM
    Research uses blockchain to reduce or eliminate the drug counterfeiting problems
    in Kenya [[28](#CR28)] by using immutable and traceable logs at each stage of
    the pharmaceutical supply chain.'
  prefs: []
  type: TYPE_NORMAL
- en: 3.5 Man in the Middle (MitM) Attack
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: MitM attacks are rising in healthcare systems to gain sensitive information
    [[33](#CR33)].
  prefs: []
  type: TYPE_NORMAL
- en: '**Vulnerabilities:** The attacker can exploit the *weak controls of secure
    communication* [[4](#CR4)] in traditional healthcare applications and negate the
    integrity of communication assets. For example, not properly implementing (or
    having) cryptographic functionality or lack of fine-grained access control mechanism.
    Moreover, due to *lack of anonymisation of patient medical records* [[34](#CR34)]
    the medical data is associated directly with patient identity. The attacker can
    get the data to trigger a ransomware attack, publish it online or deny access
    to it.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Countermeasures:** The authors [[4](#CR4)] introduce the distributed interplanetary
    file system (IPFS) for storage along with blockchain and blockchain-based data
    encryption to reduce communication and computation overhead that establish a secure
    communication channel. Blockchain works on a P2P-based distributed network where
    nodes behave both as a server and client to exchange encrypted data directly with
    each other. This feature of blockchain makes it hard for an attacker to intercept
    communication or data analysis/sniffing [[2](#CR2), [19](#CR19)]. Blockchain maintains
    pseudo-anonymity, the patients and their medical data is linked with a public
    address. Also, the data processing on a blockchain is anonymous [[19](#CR19)]
    and blockchain anonymises the medical data to hide the actual identity [[34](#CR34)].'
  prefs: []
  type: TYPE_NORMAL
- en: 4 Healthcare Security Ontology
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ontology elaborates the meaning of concepts within a domain to overcome the
    consequences of a misunderstanding. The study [[35](#CR35)] illustrates the reasons
    that motivate the development of an ontology. For instance, ontology makes it
    possible to i) share a common understanding, ii) reuse of domain knowledge, iii)
    make domain assumptions explicit, iv) separate domain and operational knowledge,
    v) analyse domain knowledge.
  prefs: []
  type: TYPE_NORMAL
- en: 'HealthOnt is based on web ontology language (OWL) and WWW Consortium (W3C).
    OWL is a semantic web language to illustrate rich and complex knowledge about
    things and their relations [[36](#CR36)]. We use SPARQL (SPARQL Protocol and RDF
    Query Language) as a semantic query language [[37](#CR37)] to get results from
    an ontology. We utilise the **ontology construction method** [[38](#CR38)] that
    has five stages: i) Identify purpose & scope, ii) Building ontology, it includes
    capture, coding and integrating phases, iii) evaluation, iv) documentation, and
    v) guidelines. In [[39](#CR39)], we follow the same ontology construction method
    to explore and build an ontology for security threats of Corda-based financial
    applications.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Scope and Purpose:** The instructions provided in [[35](#CR35)] help us to
    define the scope and purpose of our ontology. The purpose is to build a knowledge
    base of blockchain-enabled countermeasures for healthcare applications. The scope
    covers the *domain of ontology* (e.g., blockchain as a countermeasure solution),
    *use of ontology* (e.g., SRM of healthcare applications), *questions that ontology
    answers* (e.g., what assets to protect, what are the threats, vulnerabilities,
    and countermeasures), *who will maintain the ontology?* (e.g., security experts).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Building Ontology:** We use Protege to capture and code domain knowledge
    (e.g., concepts and their relationships) into taxonomic classifications. The classifications
    refine the concepts belonging to assets, security threats, vulnerabilities, countermeasures,
    and blockchain features associated with countermeasures.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Assets Classification:*** Assets are classified as business and system assets
    (Fig. [1](#Fig1)). Security criteria is a constraint of business assets, and system
    assets support business assets. For example, business asset “MedicalRecord” has
    Constraint Integrity, and System assets “AccessControl” supports “MedicalRecord”.![../images/509088_1_En_6_Chapter/509088_1_En_6_Fig1_HTML.png](../images/509088_1_En_6_Chapter/509088_1_En_6_Fig1_HTML.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 1.
  prefs: []
  type: TYPE_NORMAL
- en: Business and system assets classification
  prefs: []
  type: TYPE_NORMAL
- en: The asset class definition explains sub-classes (e.g., BusinessAsset and SystemAsset)
    and restrictions “hasConstraint” and “supports”.![../images/509088_1_En_6_Chapter/509088_1_En_6_Figa_HTML.png](../images/509088_1_En_6_Chapter/509088_1_En_6_Figa_HTML.png)***Threats
    Classification:*** Security threats classification (Fig. [2](#Fig2)) is built
    upon the threats that are mitigated using blockchain. In traditional healthcare
    applications, security threats exploit vulnerabilities and target some system
    asset(s). Threat class has a restriction “exploits” on someValuesFrom the Vulnerability.
    Another restriction “targets” on someValuesFrom the SystemAsset.![../images/509088_1_En_6_Chapter/509088_1_En_6_Figb_HTML.png](../images/509088_1_En_6_Chapter/509088_1_En_6_Figb_HTML.png)![../images/509088_1_En_6_Chapter/509088_1_En_6_Fig2_HTML.png](../images/509088_1_En_6_Chapter/509088_1_En_6_Fig2_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 2.
  prefs: []
  type: TYPE_NORMAL
- en: Security threats classification
  prefs: []
  type: TYPE_NORMAL
- en: For example, in traditional healthcare applications, the attacker can trigger
    “DataTampering” threat by exploiting a vulnerability “ErrorProneAuthenticityOfData”
    or “WeakAccessControl”. The “DataTampering” threat targets the system assets (e.g.,
    AccessControl, HealthcareDatabase, or MedicalTransaction).
  prefs: []
  type: TYPE_NORMAL
- en: '***Vulnerabilities classification:*** This classification (Fig. [3](#Fig3))
    is built upon the weaknesses in healthcare applications that enable some security
    threats.![../images/509088_1_En_6_Chapter/509088_1_En_6_Fig3_HTML.png](../images/509088_1_En_6_Chapter/509088_1_En_6_Fig3_HTML.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 3.
  prefs: []
  type: TYPE_NORMAL
- en: Vulnerabilities classification
  prefs: []
  type: TYPE_NORMAL
- en: The vulnerability class definition explains various vulnerabilities that are
    characteristic of system assets and negates the security criteria of business
    assets.![../images/509088_1_En_6_Chapter/509088_1_En_6_Figc_HTML.png](../images/509088_1_En_6_Chapter/509088_1_En_6_Figc_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: For example, the weak implementation of access control presents a weakness that
    the attacker can exploit and get unauthorised access. A vulnerability “WeakAccessControl”
    is a characteristicOf “SystemAsset” (AccessControl, HealthcareDatabase) and negates
    some (Integrity or Confidentiality).
  prefs: []
  type: TYPE_NORMAL
- en: '***Countermeasures Classification:*** Countermeasures classification (Fig. [4](#Fig4))
    presents the counteract that mitigates the vulnerabilities and improves the security
    of the system. The countermeasures belong to the blockchain features.![../images/509088_1_En_6_Chapter/509088_1_En_6_Fig4_HTML.png](../images/509088_1_En_6_Chapter/509088_1_En_6_Fig4_HTML.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 4.
  prefs: []
  type: TYPE_NORMAL
- en: Countermeasures classification
  prefs: []
  type: TYPE_NORMAL
- en: Countermeasure class definition explains that it contains various countermeasures
    that belong to blockchain features and mitigates various vulnerabilities. For
    example, the countermeasure “DistributedAccessControlMechanism” belongs to the
    “DistributedAccessControl” feature and mitigates the “WeakAccessControl” vulnerability
    in traditional healthcare applications.![../images/509088_1_En_6_Chapter/509088_1_En_6_Figd_HTML.png](../images/509088_1_En_6_Chapter/509088_1_En_6_Figd_HTML.png)***Blockchain
    Feature Classification:*** Blockchain features classification (Fig. [5](#Fig5))
    presents the characteristics that are associated with blockchain-based countermeasures
    (Table [1](#Tab1)). For example, the countermeasure “DistributedAccessControlMechanism”
    belongs to the “DistributedAccessControl” blockchain feature.![../images/509088_1_En_6_Chapter/509088_1_En_6_Fige_HTML.png](../images/509088_1_En_6_Chapter/509088_1_En_6_Fige_HTML.png)![../images/509088_1_En_6_Chapter/509088_1_En_6_Fig5_HTML.png](../images/509088_1_En_6_Chapter/509088_1_En_6_Fig5_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 5.
  prefs: []
  type: TYPE_NORMAL
- en: Blockchain features classification
  prefs: []
  type: TYPE_NORMAL
- en: '**Documentation and Guidelines:** HealthOnt is accessible online (Table [3](#Tab3))
    and we use the Protege annotations to document the concepts & relationships. Also,
    we utilise the Protege OntoGraf plugin to generate classifications graphs and
    the Pellet reasoner to validate the consistency of our ontology.Table 3.'
  prefs: []
  type: TYPE_NORMAL
- en: HealthOnt resources
  prefs: []
  type: TYPE_NORMAL
- en: '| Resource | Resource URL |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| HealthOnt | [https://​mmisw.​org/​ont/​~mubashar/​HealthOnt](https://mmisw.org/ont/%257emubashar/HealthOnt)
    |'
  prefs: []
  type: TYPE_TB
- en: '| GitHub | [https://​github.​com/​mubashar-iqbal/​HealthOnt](https://github.com/mubashar-iqbal/HealthOnt)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Protege | [https://​protege.​stanford.​edu/​](https://protege.stanford.edu/)
    |'
  prefs: []
  type: TYPE_TB
- en: '| OntoGraf | [https://​protegewiki.​stanford.​edu/​wiki/​OntoGraf](https://protegewiki.stanford.edu/wiki/OntoGraf)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Pellet Reasoner | [https://​protegewiki.​stanford.​edu/​wiki/​Using_​Reasoners](https://protegewiki.stanford.edu/wiki/Using_Reasoners)
    |'
  prefs: []
  type: TYPE_TB
- en: 5 Ontology Evaluation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We use the task-based [[40](#CR40)] evaluation technique. This technique allows
    learning about HealthOnt applicability. The efficient evaluation technique contributes
    to the scientific value of an ontology. For instance, consider healthcare security
    experts working on a healthcare application or a healthcare organisation looking
    for viable solutions to address the security threats associated with medical data
    tampering and theft. Due to the conceptual ambiguity and semantic gaps, both the
    healthcare security experts and organisation are unaware of the blockchain’s countermeasures
    that could mitigate both security threats.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, HealthOnt supports the selection of blockchain to mitigate both
    security threats of traditional healthcare applications and determine what assets
    to protect. Also, HealthOnt can assist the conceptual design and technological
    implementation of both security threats. For example, HealthOnt helps to identify
    the vulnerabilities of security threats, assets (business and system assets) to
    protect, and blockchain-based countermeasures.
  prefs: []
  type: TYPE_NORMAL
- en: The SPARQL queries retrieve information from HealthOnt. The following code is
    required in the header of each SPARQL query to execute it successfully.![../images/509088_1_En_6_Chapter/509088_1_En_6_Figf_HTML.png](../images/509088_1_En_6_Chapter/509088_1_En_6_Figf_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: 'The SPARQL **Query #1** retrieves the security threats related to data tampering
    and theft, their vulnerabilities, and assets to protect. The query compiles results
    based on the defined relationships *(exploits and targets)*. For example, **Threat**
    (DataTampering) *exploits* **Vulnerability** (WeakAccessControl), and **Vulnerability**
    (WeakAccessControl) *targets* **SystemAsset** (AccessControl or HealthcareDatabase
    or MedicalTransaction). Similar results for DataTheft and other security threats
    (reference Table [2](#Tab2)).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Query# 1**![../images/509088_1_En_6_Chapter/509088_1_En_6_Figg_HTML.png](../images/509088_1_En_6_Chapter/509088_1_En_6_Figg_HTML.png)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The SPARQL **Query #2** retrieves the countermeasures and vulnerabilities that
    are associated with data tampering and theft. The query fetch results based on
    the relationship *(mitigates)*. For example, **Countermeasure** (DistributedAccessControl)
    *mitigates* **Vulnerability** (WeakAccessControl). Similar results for DataTheft
    and other security threats (reference Table [2](#Tab2)).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Query# 2**![../images/509088_1_En_6_Chapter/509088_1_En_6_Figh_HTML.png](../images/509088_1_En_6_Chapter/509088_1_En_6_Figh_HTML.png)**Ontology
    validation** is an important part to ensure the correctness of ontological knowledge
    and ontological reasoning meaning. We perform the qualitative assessment to validate
    the HealthOnt using the criteria of [[40](#CR40), [41](#CR41)] (Table [4](#Tab4)).Table
    4.'
  prefs: []
  type: TYPE_NORMAL
- en: HealthOnt validation
  prefs: []
  type: TYPE_NORMAL
- en: '| Criteria | Detail |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Accuracy | We utilise the scientific literature to define classes, properties,
    and individuals |'
  prefs: []
  type: TYPE_TB
- en: '| Adaptability | HealthOnt provides a conceptual foundation for a range of
    anticipated tasks (e.g., threats, vulnerabilities, and countermeasures) |'
  prefs: []
  type: TYPE_TB
- en: '| Clarity | Definitions related to HealthOnt concepts and relationships are
    documented |'
  prefs: []
  type: TYPE_TB
- en: '| Completeness | SRM domain model enables the richness and granularity of HealthOnt
    |'
  prefs: []
  type: TYPE_TB
- en: '| Computational efficiency | We use the Pellet reasoner to process the HealthOnt,
    and SPARQL for querying results. Pellet reasoner and SPARQL are fast and computationally
    efficient tools |'
  prefs: []
  type: TYPE_TB
- en: '| Conciseness | HealthOnt includes only essential terms and explains weak points
    in threats to validity |'
  prefs: []
  type: TYPE_TB
- en: '| Consistency | We use the Pellet reasoner to check HealthOnt consistency and
    avoid contradictions in ontology concepts and relationships |'
  prefs: []
  type: TYPE_TB
- en: '| Organisational fitness | We follow the well-defined ontology construction
    method. HealthOnt is available online, and it can be extended, reused, or integrated
    with other security ontologies |'
  prefs: []
  type: TYPE_TB
- en: 6 Discussion and Concluding Remarks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this work, we utilise the SRM domain model to build HealthOnt by exploring
    traditional healthcare applications security threats. We define the scope of our
    ontology and develop the classifications related to assets, security threats,
    vulnerabilities, countermeasures, and blockchain features. HealthOnt is publicly
    available and encodes the information into a dynamic ontology-based knowledge
    that can be extended, reused or integrated with other security ontologies. HealthOnt
    can support the iterative process of SRM and it is possible to update HealthOnt
    continuously when new security threats or countermeasures emerge. To assure the
    quality of empirical studies, we extended our discussion by overviewing the future
    work and threats to validity [[42](#CR42)].
  prefs: []
  type: TYPE_NORMAL
- en: '**Future Work:** During our research, we discover that the blockchain is considered
    to be a security tool for healthcare applications [[21](#CR21), [28](#CR28)].
    However, blockchain-based healthcare applications are not completely proven to
    protect data from various security threats. In fact, there are a number of ways
    to negate the security of blockchain-based applications [[43](#CR43), [44](#CR44)].
    In future work, we are extending HealthOnt by including the *security threats
    that could appear* in blockchain-based healthcare applications. Also, *ontology
    validation requires further work* to determine whether the correct ontology was
    developed and whether the ontology accurately models the real world for which
    it was developed. In correspondence, we will use the real-world case of traditional
    healthcare application to validate and demonstrate the applicability of HealthOnt.
    Furthermore, an evaluation based on ontology domain experts is required to perceive
    the significance of HealthOnt contribution, to derive what is missing, and to
    determine HealthOnt accuracy, comprehensiveness, and technical correctness.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Threats to Validity:** We address the threats to validity by [[42](#CR42)]
    mapping. The relevant threats are restricted time span, publication bias, subjective
    interpretation, and lack of expert evaluation. The ***restricted time-span***
    is that the researcher cannot predict other applicable studies beyond the time
    span. For example, blockchain is relatively new but continuously evolving. Therefore
    a wide variety of countermeasures will emerge in the future. The **publication
    bias** is that the related studies are more likely to report positive results
    than negative results. The threat of **subjective interpretation** exists since
    we might have different interpretations and opinions related to identified threats,
    vulnerabilities, and countermeasures. Moreover, a **lack of expert evaluation**
    may also lead to a subjective interpretation and erroneous conclusion. These threats
    and no validation using a real-world case of healthcare application raise the
    concerns related to **weak evaluation of ontology**. For instance, errors or limitations
    may be discovered when applying HealthOnt in real-world industrial settings. However,
    in our future work, we are focusing on overcoming these threats.'
  prefs: []
  type: TYPE_NORMAL
- en: Acknowledgement
  prefs: []
  type: TYPE_NORMAL
- en: This work was partially supported by the ERASMUS+ sectoral alliance program
    on *A Blueprint for sectoral cooperation on blockchain skill and development (CHAISE)*,
    under grant no. 621646-EPP-1-2020-1-FR-EPPKA2-SSA-B. The European Commission support
    for the production of this publication does not constitute endorsement of the
    contents which reflects the views only of the authors, and the Commission cannot
    be held responsible for any use which may be made of the information contained
    therein.
  prefs: []
  type: TYPE_NORMAL
- en: '© Springer Nature Switzerland AG 2021J. González Enríquez et al. (eds.)Business
    Process Management: Blockchain and Robotic Process Automation ForumLecture Notes
    in Business Information Processing428[https://doi.org/10.1007/978-3-030-85867-4_7](https://doi.org/10.1007/978-3-030-85867-4_7)'
  prefs: []
  type: TYPE_NORMAL
- en: Studying Bitcoin Privacy Attacks and Their Impact on Bitcoin-Based Identity
    Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Simin Ghesmati^([1](#Aff12), [2](#Aff13) [ ](#ContactOfAuthor1)), Walid Fdhila^([1](#Aff12),
    [3](#Aff14) [ ](#ContactOfAuthor2)) and Edgar Weippl^([1](#Aff12), [3](#Aff14) [ ](#ContactOfAuthor3))(1)SBA
    Research, Vienna, Austria(2)Vienna University of technology, Vienna, Austria(3)University
    of Vienna, Vienna, AustriaSimin Ghesmati (Corresponding author)Email: [sghesmati@sba-research.org](mailto:sghesmati@sba-research.org)Walid FdhilaEmail:
    [wfdhila@sba-research.org](mailto:wfdhila@sba-research.org)Edgar WeipplEmail:
    [eweippl@sba-research.org](mailto:eweippl@sba-research.org)'
  prefs: []
  type: TYPE_NORMAL
- en: Abstract
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Bitcoin blockchain was the first publicly verifiable, and distributed ledger,
    where it is possible for everyone to download and check the full history of all
    data records from the genesis block. These properties lead to the emergence of
    new types of applications and the redesign of traditional systems that no longer
    respond to current business needs (e.g., transparency, protection against censorship,
    decentralization). One particular application is the use of blockchain technology
    to enable decentralized and self-sovereign identities including new mechanisms
    for creating, resolving, and revoking them. The public availability of data records
    has, in turn, paved the way for new kinds of attacks that combine sophisticated
    heuristics with auxiliary information to compromise users’ privacy and deanonymize
    their identities. In this paper, we review and categorize Bitcoin privacy attacks,
    investigate their impact on one of the Bitcoin-based identity methods namely did:btcr,
    and analyze and discuss its privacy properties.
  prefs: []
  type: TYPE_NORMAL
- en: KeywordsDecentralized identifierDIDPrivacyBTCRBlockchainBitcoin
  prefs: []
  type: TYPE_NORMAL
- en: 1 Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Bitcoin blockchain [[1](#CR1)] is an immutable tamper-proof distributed ledger,
    where addresses are used as pseudonyms (hashes of public keys), and eventually
    associated with amounts of bitcoins that can be redeemed using the corresponding
    private keys. Besides cyrptocurrencies, blockchain technology has enabled a large
    number of new applications that range from coordinating and monitoring cross-organizational
    business processes [[2](#CR2)–[4](#CR4)] to designing new methods for distributed
    identity management [[5](#CR5), [6](#CR6)]. Business process automation, for example,
    requires that the different actors (e.g., customers, employees, business partners),
    resources, and services interact with each other in a trusted manner. This trustworthy
    communication, in turn, requires that entities can establish trusted communication
    channels, with certitude about the authenticity of the entities they are interacting
    with. In this regard, identity continues to play a primordial role as an enabler
    of such trustworthy communications. Identity is a collection of data, which defines
    the attributes of a subject, e.g., cryptographic material for establishing communication
    (public key), verification methods for proving identity ownership, or service
    endpoints. Traditional systems often relied on isolated, centralized or federated
    architectures to manage identities. While in an isolated model each third party
    service/business is itself the identity provider IDP (i.e., responsible for storing
    and managing identities data), centralized and federated models both delegate
    identity management to separate IDPs, that work in isolation or federation, respectively.
    However, recent breaches (e.g., 500 million Facebook accounts, and 700 million
    LinkedIn accounts leaked^([1](#Fn1))) exposed the limits of such systems and called
    for more decentralized models that give users control over their data. With the
    advent of blockchain, it became possible to create and resolve decentralized identifiers
    (DIDs) without having to rely on centralized authorities. This opened the door
    for a multitude of proposals (DID methods) that enable decentralized creation,
    resolution, update, and revocation of DIDs. It is noteworthy to point out that
    these DID methods rely on different blockchain technologies and architectural
    designs. One of the first proposed DID methods specifically use the Bitcoin blockchain
    and is called did:btcr [[7](#CR7)].
  prefs: []
  type: TYPE_NORMAL
- en: 'In our previous research [[8](#CR8)], we demonstrated how it is possible to
    combine sophisticated heuristics with auxiliary information (e.g. address tag
    databases) to correlate Bitcoin addresses with their corresponding real identities,
    which may put users’ privacy at risk. In this paper, we review and categorize
    privacy attacks on the Bitcoin blockchain, which not only may reveal the links
    between addresses and real-world identities, but also correlate between different
    identities. Next, we address Bitcoin privacy attacks’ impact on the DID method
    did:btcr. To this end, we adopted the terminology from RFC 6973 [[9](#CR9)]. The
    contributions of the paper are in two folds: (i) Categorizing Bitcoin privacy
    attacks, and (ii) Investigation of the privacy issues in did:btcr.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The remainder of the paper is organized as follows: In Sect. [2](#Sec2), we
    describe the main concepts, while in Sect. [3](#Sec6) we introduce the methodology,
    categorize Bitcoin privacy attacks and explain how they may impact users’ privacy.
    In Sect. [4](#Sec12), we investigate privacy issues in DiD BTCR method, and in
    Sect. [5](#Sec19), we conclude the paper and provide the future work.'
  prefs: []
  type: TYPE_NORMAL
- en: 2 Background
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 2.1 Bitcoin
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Bitcoin, transactions consist of input and output addresses. The input refers
    to the output of one of the previous transactions. A mining fee is often included
    as part of the transaction to increase its chance of being considered by miners.
    This explains why the sum of the inputs should always be larger than the sum of
    the outputs. Additionally, whenever the sum of the inputs plus the fee is larger
    than the amount that should be spent, a fresh address, namely a change address
    is created to send the remainder to the sender [[10](#CR10)]. Figure [1](#Fig1)
    illustrates a simplified form of Bitcoin transactions. In the first transaction,
    Alice (![$$A_1$$](../images/509088_1_En_7_Chapter/509088_1_En_7_Chapter_TeX_IEq1.png))
    sends the bitcoins to Bob (![$$B_1$$](../images/509088_1_En_7_Chapter/509088_1_En_7_Chapter_TeX_IEq2.png))
    and gets the remainder back to her change address (![$$A_2$$](../images/509088_1_En_7_Chapter/509088_1_En_7_Chapter_TeX_IEq3.png)).
    In the following transaction, Bob sends the bitcoins from his address (![$$B_1$$](../images/509088_1_En_7_Chapter/509088_1_En_7_Chapter_TeX_IEq4.png))
    to his another address (![$$B_2$$](../images/509088_1_En_7_Chapter/509088_1_En_7_Chapter_TeX_IEq5.png)),
    while additionally specifying an optional ![$$OP\_RETURN$$](../images/509088_1_En_7_Chapter/509088_1_En_7_Chapter_TeX_IEq6.png)
    output. ![$$OP\_RETURN$$](../images/509088_1_En_7_Chapter/509088_1_En_7_Chapter_TeX_IEq7.png)
    is an opcode that enables embedding a small amount of data within a transaction.![../images/509088_1_En_7_Chapter/509088_1_En_7_Fig1_HTML.png](../images/509088_1_En_7_Chapter/509088_1_En_7_Fig1_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 1.
  prefs: []
  type: TYPE_NORMAL
- en: Bitcoin transactions
  prefs: []
  type: TYPE_NORMAL
- en: Bitcoin is a publicly available ledger, and therefore, all the transaction details
    including sender’s and recipient’s addresses, the values of transactions, and
    corresponding timestamps remain visible and can be checked by anyone. Despite
    the nice properties of blockchain, it in turn, created a niche for attackers to
    exploit such available data for malicious purposes. Previous and ongoing research
    has identified several privacy issues that can reveal identities and effectively
    find the relationships between Bitcoin addresses and the corresponding identities
    [[11](#CR11)–[14](#CR14)].
  prefs: []
  type: TYPE_NORMAL
- en: 2.2 Decentralized Identifiers (DIDs)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Entities, including users and organizations, utilize global unique identifiers
    for a variety of use cases such as telephone numbers, ID numbers or URLs. These
    identifiers are often issued and managed by central authorities. Previous data
    breaches, however, diminished trust in such centralized architecture and called
    for decentralized management of identities, where users become their own identity
    providers. As a result, blockchain-based decentralized identifiers [[15](#CR15)]
    have been proposed, which rely on blockchain and additional cryptographic techniques
    to prove identifiers’ ownership without having to rely on a trusted entity.
  prefs: []
  type: TYPE_NORMAL
- en: 'A **decentralized identifier (DID)** is a string that includes three main parts:
    the scheme, the DID method, and the DID method identifier, which should be unique
    within the DID method. The syntax according to the W3C recommendation^([2](#Fn2))
    is as follows.'
  prefs: []
  type: TYPE_NORMAL
- en: '![$$Scheme:DID method:DID\_method\_ identifier$$](../images/509088_1_En_7_Chapter/509088_1_En_7_Chapter_TeX_IEq8.png)'
  prefs: []
  type: TYPE_IMG
- en: DIDs are usually associated with **DID documents**; i.e., documents that contain
    information about the verification methods (e.g. cryptographic public keys) and
    the service endpoints required to interact with the DID subjects. The DID subject
    is the entity that is identified by the DID, and can be a person, an object or
    an organization. In addition to the underlying infrastructure (e.g., Bitcoin,
    Ethereum), a **DID method** defines how DIDs are created, resolved, updated, and
    revoked.
  prefs: []
  type: TYPE_NORMAL
- en: While DIDs in conjunction with DID documents enable creating trustworthy communications
    (how to communicate with identity owners), **verifiable credentials (VCs)** represent
    information and claims about identity owners (e.g., name, age, diplomas) [[16](#CR16)].
    These credentials can be issued by different issuers (e.g., university, employer),
    and can be cryptographically verified by any third party without having to contact
    the corresponding issuers.
  prefs: []
  type: TYPE_NORMAL
- en: 2.3 BTCR
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The BTCR method [[7](#CR7)] uses the Bitcoin blockchain to manage DIDs. In
    did:btcr, DIDs are created using the transaction references *TXRef*, only known
    once transactions are confirmed. The following is an example of a did:btcr (adopted
    from [[7](#CR7)]), where did is the scheme part, btcr is the DID method part,
    and xyv2-xzpq-q9wa-p7t is the identifier which is the transaction reference. Transaction
    reference follows BIP 0136, which encodes transactions positions (including the
    chain, block height, and transaction index) in the Bitcoin blockchain:'
  prefs: []
  type: TYPE_NORMAL
- en: '![$$did:btcr:xyv2-xzpq-q9wa-p7t$$](../images/509088_1_En_7_Chapter/509088_1_En_7_Chapter_TeX_IEq9.png)'
  prefs: []
  type: TYPE_IMG
- en: As aforementioned, creating a DID using did:btcr is achieved by simply creating
    a Bitcoin transaction. This DID creation transaction may or not refer to a URL
    that holds a DID document using the ![$$OP\_RETURN$$](../images/509088_1_En_7_Chapter/509088_1_En_7_Chapter_TeX_IEq10.png)
    construct. The latter may be stored on a separate storage, e.g., third party server
    (at the time of writing, IPFS was not supported). In case, the first transaction
    does not specify an ![$$OP\_RETURN$$](../images/509088_1_En_7_Chapter/509088_1_En_7_Chapter_TeX_IEq11.png),
    a DID document by default is created from the transaction itself. Next operations
    on the DID (e.g. update transactions) must, however, specify ![$$OP\_RETURN$$](../images/509088_1_En_7_Chapter/509088_1_En_7_Chapter_TeX_IEq12.png),
    otherwise, the DID is considered revoked [[17](#CR17)]. An update operation for
    example, consists of updating the did document and creating new transaction that
    consumes all previous UTXOs, and that embeds the new link to the updated DID document
    in the ![$$OP\_RETURN$$](../images/509088_1_En_7_Chapter/509088_1_En_7_Chapter_TeX_IEq13.png).
  prefs: []
  type: TYPE_NORMAL
- en: Again, a DID document contains cryptographic material and methods for establishing
    communication with the DID controller. A verifiable credential issuer (e.g., a
    university) can then publish their DID, and use it to sign credentials (e.g. diplomas).
    A verifier (e.g., employer) can check the authenticity of the VC, by resolving
    the DID that issued the VC, and verifying that it was not revoked using the Bitcoin
    blockchain. Therefore, the verifier does not have to communicate with the issuer
    for checking the validity of a given VC, which helps avoid linkability.
  prefs: []
  type: TYPE_NORMAL
- en: 3 Bitcoin Privacy Attacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 3.1 Research Method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This section describes the methodology used for collecting and selecting relevant
    literature, which follows four main steps; (i) research questions identification
    (cf. Section [1](#Sec1)), (ii) literature search, (iii) literature selection,
    and (iv) data extraction. **Literature Search.** Collecting relevant literature
    was carried out through triangulation of a variety of search methods such as manual
    search and citation search. Scientific databases such as DBLP, IEEE xplore, ACM,
    usenix and Springer as well as top conferences in the fields of Distributed ledger
    technology and decentralized identity were searched. **Search Query.** The queries
    that were employed for searching relevant literature items include and combine
    the following keywords: “Bitcoin”, “blockchain”, “distributed ledger technology”,
    “DLT”, “privacy”, “attack(s)”, “anonymity”, “deanonymization”, “correlation” and
    “linkability”. Only papers from 2009 to 2021 were considered. **Literature Selection.**
    The search resulted in 479 papers, from which unrelated papers were dropped based
    on titles and abstracts. Another filtering round based on fast screening of remaining
    papers resulted in 14 papers that focus on privacy attacks in Bitcoin blockchain.
    Table [1](#Tab1) lists the venues that were identified ordered by their h5-index
    and h5-median.Table 1.'
  prefs: []
  type: TYPE_NORMAL
- en: Computer security and cryptography top publications
  prefs: []
  type: TYPE_NORMAL
- en: '|   | Publication | h5-index | h5-median | Publisher |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | ACM Symposium on Computer and Communications Security | 88 | 140 | ACM
    |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | IEEE Transactions on Information Forensics and Security | 86 | 118 |
    IEEE |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | USENIX Security Symposium | 80 | 129 | USENIX |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | IEEE Symposium on Security and Privacy | 74 | 142 | IEEE |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | Network and Distributed System Security Symposium (NDSS) | 71 | 111 |
    NDSS |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | International Conference on Theory and Applications of Cryptographic
    Techniques (EUROCRYPT) | 61 | 89 | SPRINGER |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | Computers & Security | 59 | 90 | ELSEVIER |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | IEEE Transactions on Dependable and Secure Computing | 54 | 77 | IEEE
    |'
  prefs: []
  type: TYPE_TB
- en: '| 9 | International Cryptology Conference (CRYPTO) | 52 | 87 | SPRINGER |'
  prefs: []
  type: TYPE_TB
- en: '| 10 | International Conference on Financial Cryptography and Data Security
    | 46 | 74 | SPRINGER |'
  prefs: []
  type: TYPE_TB
- en: '| 11 | International Conference on The Theory and Application of Cryptology
    and Information Security (ASIACRYPT) | 42 | 61 | SPRINGER |'
  prefs: []
  type: TYPE_TB
- en: '| 12 | Security and Communication Networks | 40 | 51 | Wiley |'
  prefs: []
  type: TYPE_TB
- en: '| 13 | Theory of Cryptography | 38 | 58 | SPRINGER |'
  prefs: []
  type: TYPE_TB
- en: '| 14 | ACM on Asia Conference on Computer and Communications Security | 37
    | 55 | ACM |'
  prefs: []
  type: TYPE_TB
- en: '| 15 | Proceedings on Privacy Enhancing Technologies | 35 | 55 |   |'
  prefs: []
  type: TYPE_TB
- en: '| 16 | IEEE European Symposium on Security and Privacy | 34 | 74 | IEEE |'
  prefs: []
  type: TYPE_TB
- en: '| 17 | Designs, Codes and Cryptography | 34 | 50 | SPRINGER |'
  prefs: []
  type: TYPE_TB
- en: '| 18 | European Conference on Research in Computer Security | 34 | 43 | SPRINGER
    |'
  prefs: []
  type: TYPE_TB
- en: '| 19 | IEEE Security & Privacy | 31 | 53 | IEEE |'
  prefs: []
  type: TYPE_TB
- en: '| 20 | Journal of Information Security and Applications | 31 | 40 | ELSEVIER
    |'
  prefs: []
  type: TYPE_TB
- en: A number of the selected studies have identified privacy attacks, which may
    reveal links between identities and the Bitcoin addresses. In the following, we
    categorize and explain the possible attacks that have been applied in the selected
    papers (Table [2](#Tab2)). Based on the paper purposes we categorized the selected
    papers in five categories including privacy challenges, classification, illicit
    activities (tracking Bitcoin usage in dark web, ransomware and ponzi schemes),
    link pseudonyms to IPs, and pattern detection (to find specific patterns related
    to users behavior in trading systems and remuneration pattern). Some of the papers
    proposed attacks not specific to Bitcoin. In this paper, we only consider analyzing
    privacy attacks in the Bitcoin blockchain as we only address Bitcoin privacy attacks
    in BTCR. Additionally, we employ the four main categories of privacy attacks as
    identified in [[18](#CR18)]; (i) heuristics, (ii) side channel attacks, (iii)
    flow analysis, and (iv) auxiliary information , which will be explained in next
    sections.Table 2.
  prefs: []
  type: TYPE_NORMAL
- en: Selected papers
  prefs: []
  type: TYPE_NORMAL
- en: '| Category | Paper | Year | Publication | Purpose | Blockchain |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Privacy challenges | [[19](#CR19)] | 2018 | IEEE S& P | Access privacy challenges
    | BTC, ZEC |'
  prefs: []
  type: TYPE_TB
- en: '| Classification | [[20](#CR20)] | 2014 | FC | User classification | BTC |'
  prefs: []
  type: TYPE_TB
- en: '| [[21](#CR21)] | 2020 | USENIX | Analysis tool | BTC, BCH, BSV, LTC, and ZEC
    |'
  prefs: []
  type: TYPE_TB
- en: '| Illicit activites | [[22](#CR22)] | 2018 | Computer & Security | Tracking
    ransomware |   |'
  prefs: []
  type: TYPE_TB
- en: '| [[23](#CR23)] | 2018 | IEEE S& P | Tracking ransomware | BTC |'
  prefs: []
  type: TYPE_TB
- en: '| [[24](#CR24)] | 2019 | NDSS | Crypto in dark web | BTC |'
  prefs: []
  type: TYPE_TB
- en: '| [[25](#CR25)] | 2020 | Asia CCS | MMM ponzi detection | BTC |'
  prefs: []
  type: TYPE_TB
- en: '| Link Pseudonyms to IPs | [[26](#CR26)] | 2014 | FC | Link Pseudonyms to IPs
    | BTC |'
  prefs: []
  type: TYPE_TB
- en: '| [[27](#CR27)] | 2014 | CCS | Link Pseudonyms to IPS | BTC |'
  prefs: []
  type: TYPE_TB
- en: '| [[28](#CR28)] | 2017 | FC | Clustering heuristics+network layer info | BTC
    |'
  prefs: []
  type: TYPE_TB
- en: '| [[11](#CR11)] | 2019 | EuroS& P | Link Pseudonyms to IPs | BTC, ZEC, XMR,
    Dash |'
  prefs: []
  type: TYPE_TB
- en: '| Pattern detection | [[12](#CR12)] | 2017 | EuroS& P | Remuneration detection
    | BTC |'
  prefs: []
  type: TYPE_TB
- en: '| [[13](#CR13)] | 2019 | CCS | Tracing trading transactions | BTC |'
  prefs: []
  type: TYPE_TB
- en: '| [[14](#CR14)] | 2019 | USENIX | Tracing trading transactions | ETH, BTC,
    LTC, BCH, Doge, Dash, ETC, ZEC |'
  prefs: []
  type: TYPE_TB
- en: 3.2 Bitcoin Blockchain Heuristics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Table [3](#Tab3) summarizes heuristics that were applied to the Bitcoin protocol
    to identify relationships between addresses (common input ownership, change address
    detection, address reuse, single input single output, and specific patterns).
    One of the heuristics (Cluster growth) prevents false positives [[10](#CR10),
    [21](#CR21)].Table 3.
  prefs: []
  type: TYPE_NORMAL
- en: Bitcoin blockchain heuristics
  prefs: []
  type: TYPE_NORMAL
- en: '|   | Multi-input | Change address | Address-reuse | Single in-single out |
    Cluster growth | Patterns |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|  [[20](#CR20)] | ![../images/509088_1_En_7_Chapter/509088_1_En_7_Figa_HTML.gif](../images/509088_1_En_7_Chapter/509088_1_En_7_Figa_HTML.gif)
    | ![../images/509088_1_En_7_Chapter/509088_1_En_7_Figb_HTML.gif](../images/509088_1_En_7_Chapter/509088_1_En_7_Figb_HTML.gif)
    |   |   |   |   |'
  prefs: []
  type: TYPE_TB
- en: '|  [[19](#CR19)] |   |   |   |   |   |   |'
  prefs: []
  type: TYPE_TB
- en: '|  [[21](#CR21)] | ![../images/509088_1_En_7_Chapter/509088_1_En_7_Figc_HTML.gif](../images/509088_1_En_7_Chapter/509088_1_En_7_Figc_HTML.gif)
    (excluding CoinJoin) | ![../images/509088_1_En_7_Chapter/509088_1_En_7_Figd_HTML.gif](../images/509088_1_En_7_Chapter/509088_1_En_7_Figd_HTML.gif)
    |   | ![../images/509088_1_En_7_Chapter/509088_1_En_7_Fige_HTML.gif](../images/509088_1_En_7_Chapter/509088_1_En_7_Fige_HTML.gif)
    |   |   |'
  prefs: []
  type: TYPE_TB
- en: '|  [[22](#CR22)] | ![../images/509088_1_En_7_Chapter/509088_1_En_7_Figf_HTML.gif](../images/509088_1_En_7_Chapter/509088_1_En_7_Figf_HTML.gif)
    | ![../images/509088_1_En_7_Chapter/509088_1_En_7_Figg_HTML.gif](../images/509088_1_En_7_Chapter/509088_1_En_7_Figg_HTML.gif)
    |   |   |   |   |'
  prefs: []
  type: TYPE_TB
- en: '|  [[23](#CR23)] | ![../images/509088_1_En_7_Chapter/509088_1_En_7_Figh_HTML.gif](../images/509088_1_En_7_Chapter/509088_1_En_7_Figh_HTML.gif)
    (excluding CoinJoin) |   |   |   |   |   |'
  prefs: []
  type: TYPE_TB
- en: '|  [[24](#CR24)] | ![../images/509088_1_En_7_Chapter/509088_1_En_7_Figi_HTML.gif](../images/509088_1_En_7_Chapter/509088_1_En_7_Figi_HTML.gif)
    (excluding CoinJoin) | ![../images/509088_1_En_7_Chapter/509088_1_En_7_Figj_HTML.gif](../images/509088_1_En_7_Chapter/509088_1_En_7_Figj_HTML.gif)
    |   |   | ![../images/509088_1_En_7_Chapter/509088_1_En_7_Figk_HTML.gif](../images/509088_1_En_7_Chapter/509088_1_En_7_Figk_HTML.gif)
    |   |'
  prefs: []
  type: TYPE_TB
- en: '|  [[25](#CR25)] |   |   |   |   |   |   |'
  prefs: []
  type: TYPE_TB
- en: '|  [[26](#CR26)] |   |   |   |   |   |   |'
  prefs: []
  type: TYPE_TB
- en: '|  [[27](#CR27)] |   |   |   |   |   |   |'
  prefs: []
  type: TYPE_TB
- en: '|  [[28](#CR28)] | ![../images/509088_1_En_7_Chapter/509088_1_En_7_Figl_HTML.gif](../images/509088_1_En_7_Chapter/509088_1_En_7_Figl_HTML.gif)
    | ![../images/509088_1_En_7_Chapter/509088_1_En_7_Figm_HTML.gif](../images/509088_1_En_7_Chapter/509088_1_En_7_Figm_HTML.gif)
    |   |   | ![../images/509088_1_En_7_Chapter/509088_1_En_7_Fign_HTML.gif](../images/509088_1_En_7_Chapter/509088_1_En_7_Fign_HTML.gif)
    |   |'
  prefs: []
  type: TYPE_TB
- en: '|  [[11](#CR11)] |   |   |   |   |   |   |'
  prefs: []
  type: TYPE_TB
- en: '|  [[12](#CR12)] |   |   |   |   |   | ![../images/509088_1_En_7_Chapter/509088_1_En_7_Figo_HTML.gif](../images/509088_1_En_7_Chapter/509088_1_En_7_Figo_HTML.gif)
    Remuneration profile |'
  prefs: []
  type: TYPE_TB
- en: '|  [[13](#CR13)] | ![../images/509088_1_En_7_Chapter/509088_1_En_7_Figp_HTML.gif](../images/509088_1_En_7_Chapter/509088_1_En_7_Figp_HTML.gif)
    |   |   |   |   |   |'
  prefs: []
  type: TYPE_TB
- en: '|  [[14](#CR14)] | ![../images/509088_1_En_7_Chapter/509088_1_En_7_Figq_HTML.gif](../images/509088_1_En_7_Chapter/509088_1_En_7_Figq_HTML.gif)
    |   | ![../images/509088_1_En_7_Chapter/509088_1_En_7_Figr_HTML.gif](../images/509088_1_En_7_Chapter/509088_1_En_7_Figr_HTML.gif)
    |   |   | ![../images/509088_1_En_7_Chapter/509088_1_En_7_Figs_HTML.gif](../images/509088_1_En_7_Chapter/509088_1_En_7_Figs_HTML.gif)
    Common relationship |'
  prefs: []
  type: TYPE_TB
- en: '**Multi/common Input Ownership.** The heuristic assumes that the inputs of
    a transaction are controlled by the same entity and associates all the inputs
    to one entity. Since the input of a transaction can only be redeemed by providing
    its signature, it is unlikely that different users join to create a transaction
    [[18](#CR18)]. Figure [2](#Fig2) illustrates the heuristic, where it is assumed
    that all the addresses (![$$A_1$$](../images/509088_1_En_7_Chapter/509088_1_En_7_Chapter_TeX_IEq14.png),
    ![$$A_2$$](../images/509088_1_En_7_Chapter/509088_1_En_7_Chapter_TeX_IEq15.png),
    ![$$A_3$$](../images/509088_1_En_7_Chapter/509088_1_En_7_Chapter_TeX_IEq16.png))
    are controlled by one entity (Alice). To prevent false positives, CoinJoin transactions
    are excluded in the analysis [[21](#CR21)]. CoinJoin [[29](#CR29)] is one of the
    most prominent mixing techniques that has been adopted in practice. In mixing
    techniques, users mix their unspent transaction outputs (UTXOs) with the other
    users’ UTXOs to obfuscate the relationships between the inputs and outputs. In CoinJoin.
    the users jointly create and sign a transaction to obfuscate the common input
    ownership heuristic. CoinJoin transactions should be created in the form of the
    equal-size output to prevent linking the input and output addresses which makes
    them distinguishable in the blockchain.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Change Address.** The heuristic assumes that the change address of a transaction
    is controlled by the owner of the inputs [[10](#CR10)]. The following is a list
    of common heuristics that are employed to identify change addresses.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Fresh address:* A fresh address output can be a change address if the other
    address appeared before in the blockchain [[10](#CR10)].'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Script types:* The only output with a similar script, if all the inputs have
    similar scripts (e.g., Pay-to-PubkeyHash (P2PKH), Pay-to-Script-Hash(P2SH)) can
    be a change address [[30](#CR30)].'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Same input and output:* An input address that is also an output address of
    a transaction can be a change address [[30](#CR30)].'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Optimal change:* An output that has a smaller amount than all the inputs can
    be a change address [[30](#CR30)].'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Round numbers:* The non-round number output value can be a change address
    [[30](#CR30), [31](#CR31)], since the payment amount is typically a round number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Wallet fingerprinting:* Wallets create transactions in a different manner,
    which can be used to reveal change addresses [[31](#CR31)] (e.g. the change output
    index, locktime behavior match [[30](#CR30)])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Peeling chain:* In the peeling chain transactions (transactions where a single
    address with large amounts pay small amounts to other addresses), the output that
    continues the peeling can be a change address [[30](#CR30)].'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![../images/509088_1_En_7_Chapter/509088_1_En_7_Fig2_HTML.png](../images/509088_1_En_7_Chapter/509088_1_En_7_Fig2_HTML.png)'
  prefs: []
  type: TYPE_IMG
- en: Fig. 2.
  prefs: []
  type: TYPE_NORMAL
- en: Multi/common input ownership heuristic
  prefs: []
  type: TYPE_NORMAL
- en: '**Address Reuse.** Whenever the same address is reused, it relates the current
    transaction to all the transactions that the address previously appeared in. This
    results in a possible correlation between all transactions enabled with the same
    address[[32](#CR32)]. There is also forced address reuse where the attacker pays
    a small amount of bitcoin to the used address of the target and follow the address
    in the blockchain to find other UTXOs belonging to the user if the target combines
    this UTXO to her other UTXOs in the following transactions [[31](#CR31)].'
  prefs: []
  type: TYPE_NORMAL
- en: '**Single Input Single Output.** The transaction with only one input and one
    output is considered as self-payment and the input and the output addresses can
    be associated with one entity. Indeed, in most cases, the payment transactions
    consist of multiple inputs and outputs [[21](#CR21)].'
  prefs: []
  type: TYPE_NORMAL
- en: '**Cluster Growth.** Clusters normally grow in small steps, and if applying
    a heuristic creates a large cluster, it would be as a result of false positives
    [[28](#CR28)].'
  prefs: []
  type: TYPE_NORMAL
- en: '**Specific Patterns.** New heuristics based on the patterns extracted from
    users and transaction behaviors can be employed. For instance, [[12](#CR12)] found
    remuneration patterns based on the analysis of their ground truth. In [[14](#CR14)],
    they found the common relationship between the addresses in the trading services,
    where receiving the coins from the same address or sending the coins to the same
    address can indicate a common social relationship.'
  prefs: []
  type: TYPE_NORMAL
- en: 3.3 Side Channel Attacks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The correlation of the information such as time, amount, network information,
    or the user’s behavior in the forked blockchains may be used to reveal users or
    transaction behaviors, thereby compromising their privacy. Table [4](#Tab4) summarizes
    such side channel attacks, which we explain in the following.
  prefs: []
  type: TYPE_NORMAL
- en: '**Time Correlation.** The attacker can correlate the time that a transaction
    is confirmed (considering appropriate thresholds) with the time that a user interacted
    with other services. In the table we provided the research [[13](#CR13), [14](#CR14)]
    that used this attack to find the transactions in the trading services and correlate
    them with the blockchain data to find the related transactions.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Amount Correlation.** The attacker can correlate the amount that has been
    transferred in blockchain with the amount that has been paid (either by fiat or
    other crypto currencies) in other services where the latter can be publicly seen
    via websites or application programming interfaces (APIs). In [[13](#CR13), [14](#CR14)],
    the public trades amounts available in trading services were used to find the
    corresponding transactions on the blockchain. The attacker can also obtain exchange
    rates of the fiat currency (if it is paid by fiat currencies) for the date and
    the time when the transaction is confirmed, and look it up in this interval.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Network Layer Information.** The propagation of transactions between nodes
    can reveal the data in the network layer. The research [[11](#CR11), [26](#CR26)–[28](#CR28)]
    indicated the possibility of linking the IP addresses of the nodes to the transactions.
    To this end, they connected to the Bitcoin nodes and listen to the network to
    find the original node that is the first who propagated the transaction. It is
    also mentioned that the access pattern can be used to relate the user to a cryptocurrency
    address. For instance, visiting a web page with a donation address and then performing
    a transaction and checking the confirmation in a block explorer can provide an
    access pattern to link the IP address to that transaction [[19](#CR19)].'
  prefs: []
  type: TYPE_NORMAL
- en: '**Cashing Out on Forks.** Cross-chain clustering can create a single chain
    clustering based on the information obtained from the forked chain cluster. This
    attack links the addresses in one chain based on the activity of those addresses
    in the forked chain [[21](#CR21)]. Researchers [[21](#CR21)] combined the Bitcoin
    and Bitcoin cash clusters and found that the privacy of almost 5% of the Bitcoin
    transactions is in danger based on their cash-out behaviors in the Bitcoin Cash.'
  prefs: []
  type: TYPE_NORMAL
- en: 3.4 Flow Analysis
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The attacker is able to trace the flow of the money by transaction graph, user
    graphs, and taint analysis. Table [4](#Tab4) lists the publications that applied
    the graphs for their analysis.
  prefs: []
  type: TYPE_NORMAL
- en: '**Transaction Graph.** In the transaction graph, the addresses are nodes and
    the transactions are edges, and the attacker can find predecessors and successors
    by this graph [[20](#CR20)]. Figure [3](#Fig3) illustrates a sample transaction
    graph where Alice holds 6 BTC, and sends 2 BTC from her address A[1] to Bob B[1]
    via transaction T[1], as she has 6 BTC in her address, she gets back 4 BTC in
    her change address A[2]. Bob then sends 3 BTC to Carol via transaction T[2] using
    2 BTC which he has previously received from the output of T[1] and 2 BTC from
    the output of another transaction. As can be seen, T[2] has two outputs by which
    Bob gets 1 BTC as his change (B[3]) and pays 3 BTC to Carol.![../images/509088_1_En_7_Chapter/509088_1_En_7_Fig3_HTML.png](../images/509088_1_En_7_Chapter/509088_1_En_7_Fig3_HTML.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 3.
  prefs: []
  type: TYPE_NORMAL
- en: Transaction graph, adopted from [[33](#CR33)]
  prefs: []
  type: TYPE_NORMAL
- en: '**Taint Analysis.** This analysis tracks the flow of the money from an address
    to another [[10](#CR10)]. It is defined as the percentage of the balance of the
    output address that comes from an input address [[18](#CR18)].'
  prefs: []
  type: TYPE_NORMAL
- en: '**User Graph.** In the user graph, users are nodes and the transactions are
    edges which creates the clusters [[20](#CR20)] (e.g. by using the heuristics),
    this graph can find the relationship between different users in the blockchain.Table
    4.'
  prefs: []
  type: TYPE_NORMAL
- en: Side channel attacks and flow analysis
  prefs: []
  type: TYPE_NORMAL
- en: '|   | Time correlation | Amount correlation | Network layer | Cashing out on
    forks | TX graph/User graph | Taint analysis |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|   |   |   | *Map IP to pseudonyms* | *Access pattern/*user behavior pattern
    |   |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|  [[20](#CR20)] |   |   |   |   |   | ![../images/509088_1_En_7_Chapter/509088_1_En_7_Figt_HTML.gif](../images/509088_1_En_7_Chapter/509088_1_En_7_Figt_HTML.gif)
    |   |'
  prefs: []
  type: TYPE_TB
- en: '|  [[19](#CR19)] |   |   | ![../images/509088_1_En_7_Chapter/509088_1_En_7_Figu_HTML.gif](../images/509088_1_En_7_Chapter/509088_1_En_7_Figu_HTML.gif)
    | ![../images/509088_1_En_7_Chapter/509088_1_En_7_Figv_HTML.gif](../images/509088_1_En_7_Chapter/509088_1_En_7_Figv_HTML.gif)
    |   |   |   |'
  prefs: []
  type: TYPE_TB
- en: '|  [[21](#CR21)] |   |   |   |   | ![../images/509088_1_En_7_Chapter/509088_1_En_7_Figw_HTML.gif](../images/509088_1_En_7_Chapter/509088_1_En_7_Figw_HTML.gif)
    (Combining BCH& BTC) | ![../images/509088_1_En_7_Chapter/509088_1_En_7_Figx_HTML.gif](../images/509088_1_En_7_Chapter/509088_1_En_7_Figx_HTML.gif)
    |   |'
  prefs: []
  type: TYPE_TB
- en: '|  [[22](#CR22)] |   |   |   |   |   | ![../images/509088_1_En_7_Chapter/509088_1_En_7_Figy_HTML.gif](../images/509088_1_En_7_Chapter/509088_1_En_7_Figy_HTML.gif)
    |   |'
  prefs: []
  type: TYPE_TB
- en: '|  [[23](#CR23)] |   | ![../images/509088_1_En_7_Chapter/509088_1_En_7_Figz_HTML.gif](../images/509088_1_En_7_Chapter/509088_1_En_7_Figz_HTML.gif)
    |   |   |   | ![../images/509088_1_En_7_Chapter/509088_1_En_7_Figaa_HTML.gif](../images/509088_1_En_7_Chapter/509088_1_En_7_Figaa_HTML.gif)
    |   |'
  prefs: []
  type: TYPE_TB
- en: '|  [[24](#CR24)] |   |   |   |   |   | ![../images/509088_1_En_7_Chapter/509088_1_En_7_Figab_HTML.gif](../images/509088_1_En_7_Chapter/509088_1_En_7_Figab_HTML.gif)
    | ![../images/509088_1_En_7_Chapter/509088_1_En_7_Figac_HTML.gif](../images/509088_1_En_7_Chapter/509088_1_En_7_Figac_HTML.gif)
    |'
  prefs: []
  type: TYPE_TB
- en: '|  [[25](#CR25)] |   |   |   |   |   |   |   |'
  prefs: []
  type: TYPE_TB
- en: '|  [[26](#CR26)] |   |   | ![../images/509088_1_En_7_Chapter/509088_1_En_7_Figad_HTML.gif](../images/509088_1_En_7_Chapter/509088_1_En_7_Figad_HTML.gif)
    |   |   |   |   |'
  prefs: []
  type: TYPE_TB
- en: '|  [[27](#CR27)] |   |   | ![../images/509088_1_En_7_Chapter/509088_1_En_7_Figae_HTML.gif](../images/509088_1_En_7_Chapter/509088_1_En_7_Figae_HTML.gif)
    |   |   |   |   |'
  prefs: []
  type: TYPE_TB
- en: '|  [[28](#CR28)] |   |   | ![../images/509088_1_En_7_Chapter/509088_1_En_7_Figaf_HTML.gif](../images/509088_1_En_7_Chapter/509088_1_En_7_Figaf_HTML.gif)
    |   |   | ![../images/509088_1_En_7_Chapter/509088_1_En_7_Figag_HTML.gif](../images/509088_1_En_7_Chapter/509088_1_En_7_Figag_HTML.gif)
    |   |'
  prefs: []
  type: TYPE_TB
- en: '|  [[11](#CR11)] |   |   | ![../images/509088_1_En_7_Chapter/509088_1_En_7_Figah_HTML.gif](../images/509088_1_En_7_Chapter/509088_1_En_7_Figah_HTML.gif)
    |   |   |   |   |'
  prefs: []
  type: TYPE_TB
- en: '|  [[12](#CR12)] |   | ![../images/509088_1_En_7_Chapter/509088_1_En_7_Figai_HTML.gif](../images/509088_1_En_7_Chapter/509088_1_En_7_Figai_HTML.gif)
    (BTC in $) |   |   |   |   |   |'
  prefs: []
  type: TYPE_TB
- en: '|  [[13](#CR13)] | ![../images/509088_1_En_7_Chapter/509088_1_En_7_Figaj_HTML.gif](../images/509088_1_En_7_Chapter/509088_1_En_7_Figaj_HTML.gif)
    | ![../images/509088_1_En_7_Chapter/509088_1_En_7_Figak_HTML.gif](../images/509088_1_En_7_Chapter/509088_1_En_7_Figak_HTML.gif)
    |   |   |   | ![../images/509088_1_En_7_Chapter/509088_1_En_7_Figal_HTML.gif](../images/509088_1_En_7_Chapter/509088_1_En_7_Figal_HTML.gif)
    |   |'
  prefs: []
  type: TYPE_TB
- en: '|  [[14](#CR14)] | ![../images/509088_1_En_7_Chapter/509088_1_En_7_Figam_HTML.gif](../images/509088_1_En_7_Chapter/509088_1_En_7_Figam_HTML.gif)
    | ![../images/509088_1_En_7_Chapter/509088_1_En_7_Figan_HTML.gif](../images/509088_1_En_7_Chapter/509088_1_En_7_Figan_HTML.gif)
    |   |   |   |   |   |'
  prefs: []
  type: TYPE_TB
- en: 3.5 Auxiliary Information
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The attacker can tag the addresses using several ways including searching on
    the Internet, interacting with the target, using service APIs, etc. The aforementioned
    heuristics, side-channel attacks, and flow analysis find the relationship between
    the addresses, therefore, if the attacker tag an address, he is able to tag other
    addresses related to this address. The attacker can not only tag the addresses
    but also in some cases, can obtain information about the locations, emails, usernames,
    and etc. Table [5](#Tab5) indicates the resources which have been used in the
    selected papers to tag the addresses. Some entities publish their addresses in
    forums, social networks, and websites. As can be seen in table [5](#Tab5), Bitcointalk,
    Reddit, Twitter are well-known resources to find Bitcoin addresses [[13](#CR13),
    [20](#CR20), [22](#CR22)]. Addresses published on the Websites, and addresses
    which can be queried in the search engines can identify the information about
    addresses. Services’ APIs also provide some additional information that can be
    related to the addresses (e.g. the information from trading services, such as
    Localbitcoins, Changelly, Shapeshift) [[13](#CR13), [14](#CR14), [20](#CR20)].
    Some attackers interact with services to obtain the addresses belonging to a specific
    service [[23](#CR23)], it is also called mystery shopper payment [[31](#CR31)]
    where the attacker pays a small amount and follows the address associated with
    the service in the blockchain. They are non-commercial and commercial databases
    that provide the address tags based on the ground truth, they found. Walletexplorer,
    Chainalysis, blockchain.info, and some of the researchers who published their
    address tags are examples of such databases that were used to tag the addresses
    [[14](#CR14), [23](#CR23), [25](#CR25)]. In table [5](#Tab5) the resources that
    the previous research utilized to tag the addresses are provided.Table 5.
  prefs: []
  type: TYPE_NORMAL
- en: Auxiliary information resources
  prefs: []
  type: TYPE_NORMAL
- en: '|   | Forums | Websites | Search engines | Social networks | Service APIs |
    Interacting | Address tags DB | others |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|  [[20](#CR20)] | ![../images/509088_1_En_7_Chapter/509088_1_En_7_Figao_HTML.gif](../images/509088_1_En_7_Chapter/509088_1_En_7_Figao_HTML.gif)
    BitcoinTalk,Bitcoin-OTC | ![../images/509088_1_En_7_Chapter/509088_1_En_7_Figap_HTML.gif](../images/509088_1_En_7_Chapter/509088_1_En_7_Figap_HTML.gif)
    Casasciusphysical coins | ![../images/509088_1_En_7_Chapter/509088_1_En_7_Figaq_HTML.gif](../images/509088_1_En_7_Chapter/509088_1_En_7_Figaq_HTML.gif)
    Google | ![../images/509088_1_En_7_Chapter/509088_1_En_7_Figar_HTML.gif](../images/509088_1_En_7_Chapter/509088_1_En_7_Figar_HTML.gif)
    Reddit | ![../images/509088_1_En_7_Chapter/509088_1_En_7_Figas_HTML.gif](../images/509088_1_En_7_Chapter/509088_1_En_7_Figas_HTML.gif)
    Mt.Gox |   | ![../images/509088_1_En_7_Chapter/509088_1_En_7_Figat_HTML.gif](../images/509088_1_En_7_Chapter/509088_1_En_7_Figat_HTML.gif)
    blockchain.info |   |'
  prefs: []
  type: TYPE_TB
- en: '|  [[19](#CR19)] |   |   |   |   |   |   |   |   |'
  prefs: []
  type: TYPE_TB
- en: '|  [[21](#CR21)] |   |   |   |   |   |   |   |   |'
  prefs: []
  type: TYPE_TB
- en: '|  [[22](#CR22)] |   | ![../images/509088_1_En_7_Chapter/509088_1_En_7_Figau_HTML.gif](../images/509088_1_En_7_Chapter/509088_1_En_7_Figau_HTML.gif)
    BleepingComputer,MalwareTips,2-spyware | ![../images/509088_1_En_7_Chapter/509088_1_En_7_Figav_HTML.gif](../images/509088_1_En_7_Chapter/509088_1_En_7_Figav_HTML.gif)
    Google,Yahoo | ![../images/509088_1_En_7_Chapter/509088_1_En_7_Figaw_HTML.gif](../images/509088_1_En_7_Chapter/509088_1_En_7_Figaw_HTML.gif)
    Reddit |   |   |   | ![../images/509088_1_En_7_Chapter/509088_1_En_7_Figax_HTML.gif](../images/509088_1_En_7_Chapter/509088_1_En_7_Figax_HTML.gif)
    ![$$^\dagger $$](../images/509088_1_En_7_Chapter/509088_1_En_7_Chapter_TeX_IEq17.png)
    |'
  prefs: []
  type: TYPE_TB
- en: '|  [[23](#CR23)] | ![../images/509088_1_En_7_Chapter/509088_1_En_7_Figay_HTML.gif](../images/509088_1_En_7_Chapter/509088_1_En_7_Figay_HTML.gif)
    BleepingComputer![$$^{\pm \pm }$$](../images/509088_1_En_7_Chapter/509088_1_En_7_Chapter_TeX_IEq18.png)
    | ![../images/509088_1_En_7_Chapter/509088_1_En_7_Figaz_HTML.gif](../images/509088_1_En_7_Chapter/509088_1_En_7_Figaz_HTML.gif)
    ID ransomware |   |   |   | ![../images/509088_1_En_7_Chapter/509088_1_En_7_Figba_HTML.gif](../images/509088_1_En_7_Chapter/509088_1_En_7_Figba_HTML.gif)
    ![$$^{\star \star }$$](../images/509088_1_En_7_Chapter/509088_1_En_7_Chapter_TeX_IEq19.png)
    | ![../images/509088_1_En_7_Chapter/509088_1_En_7_Figbb_HTML.gif](../images/509088_1_En_7_Chapter/509088_1_En_7_Figbb_HTML.gif)
    Chainalysis | ![../images/509088_1_En_7_Chapter/509088_1_En_7_Figbc_HTML.gif](../images/509088_1_En_7_Chapter/509088_1_En_7_Figbc_HTML.gif)
    Synthetic addr ![$$^{\dagger \dagger }$$](../images/509088_1_En_7_Chapter/509088_1_En_7_Chapter_TeX_IEq20.png)
    |'
  prefs: []
  type: TYPE_TB
- en: '|  [[24](#CR24)] |   |   | ![../images/509088_1_En_7_Chapter/509088_1_En_7_Figbd_HTML.gif](../images/509088_1_En_7_Chapter/509088_1_En_7_Figbd_HTML.gif)
    Ahmia,FreshOnions,Google |   |   |   | ![../images/509088_1_En_7_Chapter/509088_1_En_7_Figbe_HTML.gif](../images/509088_1_En_7_Chapter/509088_1_En_7_Figbe_HTML.gif)
    Walletexplorer, |   |'
  prefs: []
  type: TYPE_TB
- en: '|  [[25](#CR25)] | ![../images/509088_1_En_7_Chapter/509088_1_En_7_Figbf_HTML.gif](../images/509088_1_En_7_Chapter/509088_1_En_7_Figbf_HTML.gif)
    BitcoinTalk ![$$^\star $$](../images/509088_1_En_7_Chapter/509088_1_En_7_Chapter_TeX_IEq21.png)
    |   |   |   |   |   | ![../images/509088_1_En_7_Chapter/509088_1_En_7_Figbg_HTML.gif](../images/509088_1_En_7_Chapter/509088_1_En_7_Figbg_HTML.gif)
    Walletexplorer,blockchain.info |   |'
  prefs: []
  type: TYPE_TB
- en: '|  [[26](#CR26)] |   |   |   |   |   |   |   |   |'
  prefs: []
  type: TYPE_TB
- en: '|  [[27](#CR27)] |   |   |   |   |   |   |   |   |'
  prefs: []
  type: TYPE_TB
- en: '|  [[28](#CR28)] |   |   |   |   |   |   |   |   |'
  prefs: []
  type: TYPE_TB
- en: '|  [[11](#CR11)] |   |   |   |   |   |   |   |   |'
  prefs: []
  type: TYPE_TB
- en: '|  [[12](#CR12)] |   |   |   |   |   |   |   |   |'
  prefs: []
  type: TYPE_TB
- en: '|  [[13](#CR13)] | ![../images/509088_1_En_7_Chapter/509088_1_En_7_Figbh_HTML.gif](../images/509088_1_En_7_Chapter/509088_1_En_7_Figbh_HTML.gif)
    BitcoinTalk | ![../images/509088_1_En_7_Chapter/509088_1_En_7_Figbi_HTML.gif](../images/509088_1_En_7_Chapter/509088_1_En_7_Figbi_HTML.gif)
    Localbitcoins |   | ![../images/509088_1_En_7_Chapter/509088_1_En_7_Figbj_HTML.gif](../images/509088_1_En_7_Chapter/509088_1_En_7_Figbj_HTML.gif)
    Twitter | ![../images/509088_1_En_7_Chapter/509088_1_En_7_Figbk_HTML.gif](../images/509088_1_En_7_Chapter/509088_1_En_7_Figbk_HTML.gif)
    Localbitcoins |   | ![../images/509088_1_En_7_Chapter/509088_1_En_7_Figbl_HTML.gif](../images/509088_1_En_7_Chapter/509088_1_En_7_Figbl_HTML.gif)
    Walletexplorer, |   |'
  prefs: []
  type: TYPE_TB
- en: '|  [[14](#CR14)] |   |   |   |   | ![../images/509088_1_En_7_Chapter/509088_1_En_7_Figbm_HTML.gif](../images/509088_1_En_7_Chapter/509088_1_En_7_Figbm_HTML.gif)
    Changelly,Shapeshift |   | ![../images/509088_1_En_7_Chapter/509088_1_En_7_Figbn_HTML.gif](../images/509088_1_En_7_Chapter/509088_1_En_7_Figbn_HTML.gif)
    Walletexplorer,researchers data, |   |'
  prefs: []
  type: TYPE_TB
- en: '![$$^{\pm \pm }$$](../images/509088_1_En_7_Chapter/509088_1_En_7_Chapter_TeX_IEq22.png)Ransom
    addresses in Bleeping computer forum.'
  prefs: []
  type: TYPE_NORMAL
- en: '![$$^\dagger $$](../images/509088_1_En_7_Chapter/509088_1_En_7_Chapter_TeX_IEq23.png)
    Ransomware knowledge base, YouTube videos, reports from Counter Threat Units (CTU),
    Incident Responses (IR), and Security Operations Centers (SOC).'
  prefs: []
  type: TYPE_NORMAL
- en: '![$$^{\dagger \dagger }$$](../images/509088_1_En_7_Chapter/509088_1_En_7_Chapter_TeX_IEq24.png)
    By running ransomware binaries.'
  prefs: []
  type: TYPE_NORMAL
- en: '![$$^\star $$](../images/509088_1_En_7_Chapter/509088_1_En_7_Chapter_TeX_IEq25.png)
    Extracting Ponzi addresses, profile information, age, gender, location, ...'
  prefs: []
  type: TYPE_NORMAL
- en: '![$$^{\star \star }$$](../images/509088_1_En_7_Chapter/509088_1_En_7_Chapter_TeX_IEq26.png)
    Paying a small amount to ransom addresses.'
  prefs: []
  type: TYPE_NORMAL
- en: 4 BTCR Privacy Issues and Possible Countermeasures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we investigate the privacy of the method did:btcr based on
    the adopted criteria from RFC 6973 [[9](#CR9)] including surveillance, misattribution,
    correlation, identification, secondary use, and disclosure.
  prefs: []
  type: TYPE_NORMAL
- en: 4.1 Surveillance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Any kind of observation and monitoring of the users is considered as surveillance,
    whether the users are aware of the surveillance or not, it can influence the privacy
    of the user [[9](#CR9)]. In the previous section, we showed the possibility of
    monitoring users and linking the real-world identities to the Bitcoin addresses
    which tends to compromise users’ activities and their economic situations. The
    surveillance of DID in the Bitcoin blockchain can be investigated in different
    aspects. The auxiliary information can be obtained through the interactions with
    services using DIDs. The service is, therefore, able to follow the user’s activities
    and money flow in the blockchain using Bitcoin privacy attacks. For instance,
    a payment service where a user authenticates to the device using a DID and then
    pays using another Bitcoin address that belongs to her, associates the DID to
    that Bitcoin address. Furthermore, the privacy concerns that a user should take
    into account when using an immutable blockchain for creating DIDs have a significant
    role. A user who is aware of such problems can employ privacy-preserving techniques
    to protect herself against such privacy attacks. A previous research [[34](#CR34),
    [35](#CR35)] indicated a misconception in the privacy of the Bitcoin blockchain,
    which can result in serious problems for applications that use blockchain technology.
    Using Tor services [[15](#CR15)], mixing the UTXO before using it for DID BTCR
    [[8](#CR8)] to unlink the relationship between the BTCR UTXO and other UTXOs belonging
    to the user, and to prevent combining the revoked DID BTCR with other UTXOs in
    the future to spend the amount associated with the UTXO can be used as possible
    countermeasures to surveillance of the DID BTCR.
  prefs: []
  type: TYPE_NORMAL
- en: 4.2 Misattribution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Misattriubation is considered whenever a user’s data or communications are attributed
    to another, which can consequently affect the user’s reputation [[9](#CR9)]. Some
    of the indistinguishable mixing techniques such as PayJoin [[36](#CR36)] can relate
    the users’ UTXOs to someone else, using the common input ownership heuristic [[37](#CR37)].
    PayJoin [[36](#CR36)] is one of the successors of the CoinJoin technique, where
    a user creates a CoinJoin transaction by the recipient of the transaction. The
    recipient adds her coins as an input of the transaction which consequently increases
    the payment amount. Therefore, this technique does not require an equal-size output
    and it is indistinguishable in the blockchain. This would cause privacy problems
    for the users who are not aware of this issue when using PayJoin as a privacy
    technique or interacting with the service that implemented PayJoin (e.g., merchants,
    exchange). Therefore, using the Bitcoin blockchain for DIDs in did:btcr can put
    the users at the risk of such privacy misattribution. Providing information for
    the users to inform them from the possible misattribution by using specific mixing
    techniques such as PayJoin for the UTXOs that are used in BTCR can to some extent
    prevent this privacy problem.
  prefs: []
  type: TYPE_NORMAL
- en: 4.3 Correlation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Correlation is considered as the combination of different information, which
    relate to one user [[9](#CR9)]. We discuss the correlation in three different
    aspects including DIDs and DID documents correlation, time correlation, and network
    correlation. (i) Using the same DID or DID document for interacting with different
    services can help to trace and correlate user activities [[5](#CR5), [15](#CR15),
    [38](#CR38)]. Furthermore, using the same public keys in different DID documents
    can reveal the link between the corresponding DIDs, e.g., interactions with different
    services using the same DID while showing different VCs. Inversely, if different
    DIDs are used for each service while using the same DiD document, then those services
    can associate those multiple DIDs to the same user. Pairwise-unique DIDs that
    are issued on a per-relationship basis which can not be correlated to each other
    or single-use identifier that is discarded once it is exchanged can be used to
    mitigate this issue [[39](#CR39)]. Another issue is that the DID document contains
    methods for verification of the DID and the attributes including “also known as”
    and “controller” [[15](#CR15)]. Using “also known as”, it is possible to specify
    another identifier belonging to the same user. This can be useful for businesses
    that use multiple DIDs for their services but should be avoided if not required.
    Using “controller”, another entity can be specified, which is then allowed to
    change the DID document or to authenticate. This may reveal a relationship between
    the subject and the controller DiD if they are different. (ii) Considering the
    network layer correlation, the IP address of the entity can compromise the relationship
    of common controls, where an attacker can identify the link between different
    DIDs based on the IP address of the clients [[39](#CR39)]. Additionally, using
    traffic analysis by checking the access history to the DID documents, may help
    correlate IP addresses to the DID documents. Using TOR or proxy can provide additional
    privacy [[15](#CR15)] in this regard. (iii) Time correlation by employing the
    same service endpoints can be used to find the relationship of common controls
    [[39](#CR39)]. For instance, timing analysis can be used to correlate users’ activities
    whenever a user uses the same service endpoint in the DID documents. Sharing the
    service endpoints between a variety of DIDs that are controlled by the different
    entities [[15](#CR15)] can be considered as a possible countermeasure.
  prefs: []
  type: TYPE_NORMAL
- en: 4.4 Identification
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Identification is considered as relating the information to a specific user
    to derive her identity [[9](#CR9)]. Storing any type of personally identifiable
    information (PII) in the blockchain, even encrypted or hashed, has the potential
    to put the users’ privacy at risk, as they may be broken and be publicly accessible
    [[5](#CR5), [7](#CR7), [15](#CR15), [38](#CR38)]. Despite DID revocation support,
    the immutability property prevents deleting the logs of existing BTCR DIDs. Therefore,
    if the Bitcoin address associated to a DID is later spent with some other inputs
    without using mixing techniques (will also be considered as revoked), it can link
    the address used for DID to other addresses owned by the user, based on the common
    input ownership heuristic. Moreover, if a transaction in the BTCR (when it is
    revoked) contains a change address, it can be linked to the owner of the inputs.
    Thus, it is suggested to create the transactions without a change address. Not
    only Blockchain analysis can identify real-world identities and relate them to
    DIDs, but also metadata tracing in the DID documents can provide information in
    the identification of the entities. The visibility of the DID document can leak
    the metadata about the attributes [[6](#CR6)] and provide information about the
    service endpoints. In BTCR, the attacker can query the Bitcoin blockchain to identify
    all transactions with ![$$OP\_RETURN$$](../images/509088_1_En_7_Chapter/509088_1_En_7_Chapter_TeX_IEq27.png)
    that specify a link to a DID document, thus enabling access to metadata and associated
    service endpoints. To prevent any privacy leak, URLs to the service endpoints
    should not include any personal information (e.g. usernames). Usually, the DID
    documents are stored on servers. If the DID document is stored in the third-party
    server, the latter may identify the real DiD owner. If the DiD document is stored
    on a user own server, it becomes possible to correlate the user IP address with
    the DID document. In this case IPFS (The InterPlanetary File System)^([3](#Fn3))
    can be used as a countermeasure.
  prefs: []
  type: TYPE_NORMAL
- en: 4.5 Secondary Use
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Secondary use is considered as collecting the information about a user without
    her consent and using it for different purposes other than which the information
    was collected [[9](#CR9)]. We investigate secondary use in did:btcr in three aspects.
    (i) Read/resolve makes it possible to trace the DID use if it is accessed by third-party
    services (e.g., universal DID resolver, a naive implementation of Simplified Payment
    Verification (SPV) clients [[40](#CR40)], checking the DID on block explorers),
    in this case, the attacker can find the resolution pattern. To prevent third party
    services from collecting information about users, the latter may employ their
    own Bitcoin full nodes. (ii) The verifier is able to trace the transaction flow,
    check the history of the UTXOs (e.g. user activities), and if they are spent (accidentally
    or for changing the ownership, or revocation) monitor next transactions’ flow.
    The verifier can also see all the amounts associated with the address. (iii) a
    DID real identity can be compromised if used in services that require information
    about them or their activities (e.g. social networks).
  prefs: []
  type: TYPE_NORMAL
- en: 4.6 Disclosure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Disclosure is considered as exposure of information about a user which violates
    the confidentiality of the shared data [[9](#CR9)]. All the privacy attacks that
    were mentioned in the previous sections can be applied to the addresses that are
    used as DIDs in did:btcr. The users who are not familiar with the privacy issues
    in the Bitcoin blockchain may encounter some serious problem if their DIDs’ addresses
    link to their other addresses in the blockchain. This tends to lose privacy in
    their economic activities for the services that they are authenticated by DIDs.
    To create the first DID in BTCR, the user should provide an address, where she
    can buy from an exchange. The latter has access to information related to the
    owner (email address, etc.) or in some cases the real identity of the owner when
    KYC (know your customer) is applied. The user can use mixing techniques [[8](#CR8)]
    beforehand to obfuscate the relationship between the UTXO used in BTCR and the
    other UTXOs beloging to her. The BTCR updates are required to include the ![$$OP\_RETURN$$](../images/509088_1_En_7_Chapter/509088_1_En_7_Chapter_TeX_IEq28.png)
    field; therefore, the users can not utilize current mixing techniques to provide
    better privacy for their associated addresses. This makes the BTCR updates traceable
    in the Bitcoin blockchain. Thus, every update in BTCR not only reveals the public
    key of the previous DID but also indicates the update or changing the access control.
  prefs: []
  type: TYPE_NORMAL
- en: 5 Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this paper, we presented a review of Bitcoin privacy attacks, which we categorized
    into four main categories. Then, we investigated and analyzed six possible privacy
    threats to the DID method did:btcr. In particular, we showed how data analysis
    of Bitcoin public records, in combination with auxiliary information can be exploited
    using sophisticated heuristics, to reveal or correlate transactions, identities,
    or addresses of users. This information, in turn, may be used by malicious actors
    and cybercriminals to conduct, for example, extortion or ransomware attacks. This
    study has demonstrated that although BTCR provides some advantages such as protection
    against censorship, integrity, access and a degree of decentralization, it still
    lacks methods to deal with the privacy issues identified in this paper. Future
    research will consist on elaborating and developing new methods, or using existing
    privacy-enhancing techniques (e.g., mixing techniques, zero-knowledge proofs)
    to address the aforementioned privacy issues.
  prefs: []
  type: TYPE_NORMAL
- en: Acknowledgments
  prefs: []
  type: TYPE_NORMAL
- en: This research is based upon work partially supported by (1) SBA Research (SBA-K1);
    SBA Research is a COMET Center within the COMET – Competence Centers for Excellent
    Technologies Programme and funded by BMK, BMDW, and the federal state of Vienna.
    The COMET Programme is managed by FFG. (2) the FFG ICT of the Future project 874019
    dIdentity & dApps. (3) the FFG Basisprogramm Kleinprojekt 39019756 Decentralised
    Marketplace for Digital Identity.
  prefs: []
  type: TYPE_NORMAL
- en: '© Springer Nature Switzerland AG 2021J. González Enríquez et al. (eds.)Business
    Process Management: Blockchain and Robotic Process Automation ForumLecture Notes
    in Business Information Processing428[https://doi.org/10.1007/978-3-030-85867-4_8](https://doi.org/10.1007/978-3-030-85867-4_8)'
  prefs: []
  type: TYPE_NORMAL
- en: Enhancing Blockchain-Based Processes with Decentralized Oracles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Davide Basile^([1](#Aff12) [ ](#ContactOfAuthor1)), Valerio Goretti^([1](#Aff12) [ ](#ContactOfAuthor2)),
    Claudio Di Ciccio^([1](#Aff12) [ ](#ContactOfAuthor3)) and Sabrina Kirrane^([2](#Aff13) [ ](#ContactOfAuthor4))(1)Sapienza
    University of Rome, Rome, Italy(2)Vienna University of Economics and Business,
    Vienna, AustriaDavide BasileEmail: [basile.1810355@studenti.uniroma1.it](mailto:basile.1810355@studenti.uniroma1.it)Valerio GorettiEmail:
    [goretti.1811110@studenti.uniroma1.it](mailto:goretti.1811110@studenti.uniroma1.it)Claudio Di
    Ciccio (Corresponding author)Email: [claudio.diciccio@uniroma1.it](mailto:claudio.diciccio@uniroma1.it)Sabrina KirraneEmail:
    [sabrina.kirrane@wu.ac.at](mailto:sabrina.kirrane@wu.ac.at)'
  prefs: []
  type: TYPE_NORMAL
- en: Abstract
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The automation of business processes via blockchain-based systems allows for
    trust, reliability and accountability of execution. The link that connects modules
    that operate within the on-chain sphere and the off-chain world is key as processes
    often involve the handling of physical entities and external services. The components
    that create that link are named oracles. Numerous studies on oracles and their
    implementations are arising in the literature. Nevertheless, their availability,
    integrity and trust could be undermined if centralized architectures are adopted,
    as taking over an oracle could produce the effect of a supply-chain attack on
    the whole system. Solutions are emerging that overcome this issue by turning the
    architecture underneath the oracles into a distributed one. In this paper, we
    investigate the design and application of oracles, distinguishing their adoption
    for the in-flow or out-flow of information and according to the initiator of the
    exchange (hence, pull- or push-based).
  prefs: []
  type: TYPE_NORMAL
- en: KeywordsDecentralized applicationsBusiness process managementDistributed architectures
  prefs: []
  type: TYPE_NORMAL
- en: 1 Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since its inception, the technologies related to the blockchain world are constantly
    evolving. In particular, its decentralized aspect has offered a development environment
    for Decentralized Applications (DApp), where data integrity and consistency are
    crucial factors [[12](#CR12)]. However, applications developed on such platforms
    are unable to obtain information from the off-chain world, and cannot directly
    alter the outer world status [[3](#CR3), [5](#CR5)]. Therefore, intermediate components
    named oracles have been introduced to open up the blockchain to the real world [[18](#CR18),
    [25](#CR25)].
  prefs: []
  type: TYPE_NORMAL
- en: One of the usages in which DApps have shown potential is the coordination of
    business processes between multiple parties [[8](#CR8), [16](#CR16)]. Especially
    in this scenario, oracles represent the trusted link with external sources of
    information. The possibility of erroneous or counterfeit information can result
    in major financial implications for the various stakeholders [[13](#CR13), [23](#CR23)].
    By distributing and decentralizing the transmitted information, and using redundancy
    procedures, the likelihood of such problems is greatly reduced – which is also
    one of the driving factors at the core of blockchains. Indeed, decentralization
    increases the robustness and security of transmission operations by removing the
    problems associated with a single point of failure [[11](#CR11)].
  prefs: []
  type: TYPE_NORMAL
- en: This paper studies the effect of decentralizing blockchain oracle architectures
    in terms of availability, integrity and trust. In particular, we examine the design
    and the implementation of decentralized and centralized oracles for the Ethereum
    platform, categorized as per the patters described in [[18](#CR18)]. Unlike the
    typical scenario for oracles, we consider cases in which different off-chain sources
    retain separate parts of an information to be collected, or separate targets receive
    information from the blockchain. The proposed implementations are then evaluated
    in terms of both latency and costs.
  prefs: []
  type: TYPE_NORMAL
- en: The remainder of the paper is structured as follows. Section [2](#Sec2) presents
    the necessary background in terms of blockain platforms, the Ethereum ecosystem
    and the role of blockchain oracles. Section [3](#Sec5) introduces the motivating
    use case scenario used to guide our work. Section [4](#Sec6) sketches our blockchain
    oracle conceptual framework. Section [5](#Sec12) provides and overview of our
    performance evaluation, while Sect. [6](#Sec15) identifies open challenges and
    opportunities. Finally, we present our conclusions and plans for future work in
    Sect. [7](#Sec16).
  prefs: []
  type: TYPE_NORMAL
- en: 2 Background
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the following, we briefly present background information on blockchains,
    with a special focus on the Ethereum ecosystem, and blockchain oracles.
  prefs: []
  type: TYPE_NORMAL
- en: '2.1 Blockchain: Definition and Applications'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A blockchain is a protocol for the distributed management of a data structure
    in which transaction are stored sequentially in an append-only list (the ledger).
    Updates on the ledger are communicated via sequential blocks that are built and
    validated (i.e., mined), and then broadcasted among the nodes in the network.
    The ledger is replicated in all nodes of the network. Nodes agree on the inclusion
    of the next block information via consensus algorithms [[26](#CR26)]. Its decentralized,
    persistent and immutable characteristics make blockchain suitable for the needs
    of automated systems in which interactions between multiple untrusted parties
    are recorded [[10](#CR10)]. Such systems have long been primarily used for payments
    via cryptocurrency transactions, as their infrastructure allows for the storage
    and regulation of exchanges without the arbitration of external authoritative
    entities [[19](#CR19)].
  prefs: []
  type: TYPE_NORMAL
- en: With the advent of Ethereum [[5](#CR5)], second-generation blockchain platforms
    emerged as the blockchain turned from being mainly an e-cash distributed management
    system to a distributed programming platform at the basis of Decentralized Applications
    (DApps) [[17](#CR17)]. In particular, Ethereum enabled the deployment and run
    of smart contracts (i.e., stateful software artefacts exposing variables and callable
    methods) in the blockchain environment through the Ethereum Virtual Machine (EVM).
    The code of the deployed smart contract is stored into the blockchain itself.
    Every time a user interacts with a smart contract method, a new transaction is
    generated. As the code is executed by the EVM and not locally, users are required
    to pay fees (the so-called “gas”) as a compensation for the computational power
    used. The users can specify the maximum limit they would pay and the price per
    gas unit in terms of the Ethereum native cryptocurrency (Ether). The amount of
    gas to be paid is proportional to the complexity of the code and the operations
    involved.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that smart contracts can be invoked from the off-chain and, during the
    method execution, exchange messages within the on-chain spheres with other smart
    contracts. However, on-chain code cannot directly invoke off-chain programs for
    the sake of consistency and determinism. Ethereum smart contracts can emit so-called
    events [[7](#CR7)], namely developer-specified data fields included within transactions
    that typically mark relevant stages of the execution. Off-chain software artefacts
    can subscribe to such events to react to the signalled statuses.
  prefs: []
  type: TYPE_NORMAL
- en: The new capabilities unlocked an array of new application domains for blockchains,
    including sectors like insurance and music and areas such as the internet of things
    and cybersecurity [[1](#CR1), [20](#CR20)]. As emphasized by Tareq Ahram et al. [[23](#CR23)],
    a key application domain for blockchains is supply chain management. In this scenario,
    blockchains are used to record the data generated in every step of the supply
    chain, by creating an immutable history of the good produced or the service delivered.
    In this way, the blockchain can greatly facilitate the recording of assets and
    the tracking of invoices, payments and orders. The motivating use case scenario
    in Sect. [3](#Sec5) is rooted in this domain.Table 1.
  prefs: []
  type: TYPE_NORMAL
- en: Classification of oracles [[18](#CR18)]
  prefs: []
  type: TYPE_NORMAL
- en: '| Inform. flow direction |   | Information exchange initiator |'
  prefs: []
  type: TYPE_TB
- en: '|   | Pull | Push |'
  prefs: []
  type: TYPE_TB
- en: '| In | An on-chain component requires information from the outside word | An
    off-chain component initializes the procedure and sends data from outside the
    blockchain |'
  prefs: []
  type: TYPE_TB
- en: '| Out | An off-chain component requires information from the blockchain | An
    on-chain component initializes the procedure and sends data from the blockchain
    to the outside world |'
  prefs: []
  type: TYPE_TB
- en: '![../images/509088_1_En_8_Chapter/509088_1_En_8_Fig1_HTML.png](../images/509088_1_En_8_Chapter/509088_1_En_8_Fig1_HTML.png)'
  prefs: []
  type: TYPE_IMG
- en: Fig. 1.
  prefs: []
  type: TYPE_NORMAL
- en: BPMN diagram of the use case scenario
  prefs: []
  type: TYPE_NORMAL
- en: 2.2 Blockchain Oracles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The variety of DApps developed on the Ethereum blockchain has underlined the
    need to ensure the robustness, consistency and persistence of blockchain data
    by defining a structural context in which this technology is proposed as a closed
    and self-contained system unable to communicate with the outside world [[17](#CR17),
    [25](#CR25)]. The inability of smart contracts to access data that are not already
    stored on-chain can be a limiting factor for many application scenarios such as
    that of multi-party business processes. The solution to this problem comes in
    the form of oracles [[24](#CR24)]. An oracle can be seen as a bridge that allows
    for the communication between the on-chain and the off-chain world. The DApp should
    be able to trust the oracle in the same way as it does so with the information
    from within the blockchain. Reliability for oracles is key [[2](#CR2), [15](#CR15)].
    Moreover, an oracle has the arduous task of acting as a link between the blockchain
    application and different external entities, which may potentially be characterized
    by different technologies and mechanisms. Therefore, the designation and sharing
    of a well-defined protocol becomes fundamental for the proper functioning of the
    service. Mühlberger et al. [[18](#CR18)] describe oracle patterns that consider
    two dimensions: the information direction (inbound or outbound) and the initiator
    of the information exchange (pull- or push-based). Inbound oracles inject data
    into the blockchain from the outside, whereas outbound oracles transmit information
    from the blockchain to the outside. Pull-based oracles are such that the initiator
    is the recipient of the information, whereas with push-based oracles the initiator
    is the sender of the information. By combining the push-/pull-based and inbound/outbound
    classifications, they define four oracle design patterns. Table [1](#Tab1) summarizes
    these types of oracles: The pull-based inbound oracle (henceforth, *pull-in* oracle
    for simplicity) is used when an on-chain component starts the procedure and injects
    data from the real world. The push-based inbound (*push-in* for short) oracle
    is used by an off-chain component to send data to the blockchain. The pull-based
    outbound (*pull-out*) oracle is used when an off-chain component needs to retrieve
    data from the blockchain. Finally, the push-based outbound (*push-out*) oracle
    allows an on-chain component to transmit information outside the blockchain. In
    addition to the information direction, Beniiche [[3](#CR3)] categorizes existing
    oracle solutions according to the source of information (human, software or hardware)
    and on their centralized or decentralized architecture. In this paper, we are
    interested in the design and use of decentralized oracles that realize either
    of the above-mentioned four patterns in the context of a blockchain-based process
    execution.'
  prefs: []
  type: TYPE_NORMAL
- en: 3 Motivating Use Case Scenario
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Fig. [1](#Fig1) illustrates a multi-party order-to-cash business process involving
    a supply chain depicted as a BPMN collaboration diagram [[9](#CR9)]. We will use
    this process throughout the paper as a running example and pinpoint the employment
    of decentralized oracles. We recall that, according to the classification of Mühlberger et
    al. [[18](#CR18)], oracles are categorized as inbound or outbound, according to
    the direction of the information flow, and as pull-based or push-based, based
    on the initiator of the information exchange.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first part of the workflow, the supplier wants to verify the creditworthiness
    of the customer. This verification is based on the usage of a pull-in oracle.
    If the verification generates a positive result, the supplier places the order
    and it orders the shipment. If the verification fails, the order is refused. The
    decentralized architecture of the oracle allows for the retrieval of distributed
    information about the creditworthiness, as the customer has open accounts in multiple
    credit institutions. We assume the sensitive information about the customer to
    be properly protected from malicious treatment or leakage through the usage of
    existing privacy-preserving record-linkage techniques [[21](#CR21)]. Once the
    order is placed, and the product is handed to the courier, the shipment procedure
    starts. In the meantime, the supplier records the data of the purchase order into
    an external distributed database via a push-out oracle. The decentralized architecture
    of the oracle fits with the need to send data to a destination consisting of multiple
    nodes as the distributed database, in our scenario, resorts to physical instances.
    After that, the supplier registers the invoice in the blockchain. Meanwhile, the
    courier delivers the ordered product. At the customer’s side, a quality control
    specialist checks that the consigned goods conform with the standards. If so,
    a push-in oracle uses the blockchain as a notarization means to record that the
    delivery succeeded. Notice that this passage requires three actors to give their
    confirmation based on three distinct information bits: the courier (for the consignment),
    the quality control specialist (for the status of the consigned material) and
    the customer (for the receipt of the goods). The push-in oracle is thus decentralized
    as well, as it requires a confirmation from multiple parties. Finally, the banking
    system can unlock the payment. In response to the notification of the finalized
    handling of the order, the bank verifies that the invoice is stored on the blockchain.
    As a successive layer of security, it retrieves the data from multiple, physically
    distinct blockchain nodes – thereby employing a decentralized pull-based oracle.'
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we show a possible reference architecture for the
    decentralized version of the aforementioned oracle categories.![../images/509088_1_En_8_Chapter/509088_1_En_8_Fig2_HTML.png](../images/509088_1_En_8_Chapter/509088_1_En_8_Fig2_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 2.
  prefs: []
  type: TYPE_NORMAL
- en: Decentralized oracles architecture at large
  prefs: []
  type: TYPE_NORMAL
- en: 4 Decentralized Oracles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main limitation that characterizes centralized oracles is the presence of
    a unique operative unit that works in order to make the information flow between
    the blockchain and the outer environment. This particular aspect can cause several
    critical issues that put the entire production chain at risk. The first one is
    the problem of possibly having a single point of failure as the oracle could be
    the weak link for cyber attacks. It is interesting to notice that attacks in which
    a trusted software component is injected with malicious code fall under the name
    of (software) supply-chain attacks [[22](#CR22)]. Indeed, since the architecture
    provides only one operative unit, a potential malfunction determines the end of
    (trusted) communication and the potential loss of availability. Moreover, the
    centralization requires a greater guarantee of correctness of the transmitted
    information. The single component responsible for the communication cannot tolerate
    wrong or incoherent data.
  prefs: []
  type: TYPE_NORMAL
- en: Decentralized oracles, instead, resort to multiple independent components that
    send and receive information. In this case, the oracle becomes an information
    distribution network regulated by internal protocols such as an own consensus
    mechanism or incentivization strategies [[14](#CR14)]. It is possible to adopt
    different approaches to the question of oracles’ consensus. For example, some
    systems already on the market such as Gnosis^([1](#Fn1)) and Augur^([2](#Fn2))
    adopt a voting mechanism combined with human oracles. Other systems, such as Chainlink,^([3](#Fn3))
    propose a fully automated majority approach. The details on the management of
    those networks go beyond the scope of the paper. We refer to [[4](#CR4)] for an
    overview of the mechanisms underlying an envisioned decentralized oracle network.
  prefs: []
  type: TYPE_NORMAL
- en: Without loss of generality, we assume here a fair behavior of the oracles and
    an inner consensus algorithm based on the agreement of the totality of the involved
    components. In the remainder, we will show how decentralization can be applied
    to oracles.![../images/509088_1_En_8_Chapter/509088_1_En_8_Fig3_HTML.png](../images/509088_1_En_8_Chapter/509088_1_En_8_Fig3_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 3.
  prefs: []
  type: TYPE_NORMAL
- en: Sequence diagram of the interactions with a decentralized pull-in oracle
  prefs: []
  type: TYPE_NORMAL
- en: 4.1 Architecture Overview
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Regardless of the type under consideration, oracles can be split into two main
    tiers, as illustrated in Fig. [2](#Fig2). The on-chain tier manages the interaction
    between the oracle system and the on-chain world. It has a single software component
    inside, namely a full-fledged smart contract that can be seen as an entry point
    for decentralized applications that want to use that specific oracle system. The
    ways the DApp interacts with the on-chain tier is defined by the interaction protocol
    of the oracle itself. The off-chain tier is used to manage the interaction between
    the real world and the oracle. The two components of the oracle are able to communicate
    by sending data to each other. In the Ethereum ecosystem, when the on-chain tier
    sends data to the off-chain tier, it generates a new event containing the relevant
    information, which is caught in the off-chain tier. The off-chain tier can send
    data to the on-chain tier by using the methods exposed by the smart contract of
    the latter via a transaction with the necessary input. The decentralisation of
    the architecture takes place inside the off-chain tier, as multiple external modules
    interact with the on-chain world and operate independently, in order to retrieve
    data from the off-chain environment or send data to it.
  prefs: []
  type: TYPE_NORMAL
- en: In the following, we detail the design of our decentralized oracle architecture
    for each of the four categories described in [[18](#CR18)]. We will refer to the
    oracles’ on-chain components as on-chain oracles and to the components inside
    the off- chain tier as off-chain oracles for the sake of brevity.![../images/509088_1_En_8_Chapter/509088_1_En_8_Fig4_HTML.png](../images/509088_1_En_8_Chapter/509088_1_En_8_Fig4_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 4.
  prefs: []
  type: TYPE_NORMAL
- en: Sequence diagram of the interactions with a decentralized push-out oracle
  prefs: []
  type: TYPE_NORMAL
- en: 4.2 Decentralized Pull-in Oracle
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In a pull-in oracle, the interaction begins with the call from the smart contract
    implementing the process logic to the on-chain oracle, as depicted in the sequence
    diagram in Fig. [3](#Fig3). Considering the running example of Sect. [3](#Sec5),
    the purpose of the pull-in oracle is to connect the decentralized application
    with multiple credit institutions, in order to verify the creditworthiness of
    the customer – which is confirmed only if all credit institutes agree. The smart
    contract running the check activity interacts with the on-chain component of the
    oracle, generating a new request for verification. The on-chain component, then,
    emits a new event containing the data to be processed by the off-chain oracle
    (e.g., the customer personal information). At that point, the off-chain oracles
    catch the emission of the event, and they execute their business logic (e.g.,
    the creditworthiness verification) based on different data sources via dedicated
    API calls (the credit institutions). Once the off-chain oracles have obtained
    the result of their computation, they invoke the on-chain oracle callback method
    to return the answer via transactions. In our simplified consensus mechanism,
    we assume that when all the off-chain components have sent their answer to the
    on-chain smart contract, it uses the callback method of the decentralized application,
    in turn, to return the aggregate result.
  prefs: []
  type: TYPE_NORMAL
- en: 4.3 Decentralized Push-out Oracle
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Figure [4](#Fig4) illustrates the interactions that realize the information
    exchange via a decentralized push-out oracle. Unlike the pull-in oracle, the source
    of information lies within the blockchain, which is by its nature a decentralized
    system. The procedure for pushing out the information starts when the smart contract
    creates a new request for the outbound transfer of data. The on-chain oracle generates
    a new event that contains the data to be exposed. When the off-chain components
    catch the event, they all operate independently, invoking external APIs. In our
    scenario, the purchase order data are stored in an external distributed database.
    In order to update the database with new orders, the smart contract underpinning
    the activity execution employs a push-out oracle and every off-chain oracle interacts
    with a different instance of the distributed database.
  prefs: []
  type: TYPE_NORMAL
- en: 4.4 Decentralized Push-in Oracle
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![../images/509088_1_En_8_Chapter/509088_1_En_8_Fig5_HTML.png](../images/509088_1_En_8_Chapter/509088_1_En_8_Fig5_HTML.png)'
  prefs: []
  type: TYPE_IMG
- en: Fig. 5.
  prefs: []
  type: TYPE_NORMAL
- en: Sequence diagram of the interactions with a decentralized push-in oracle
  prefs: []
  type: TYPE_NORMAL
- en: Figure [5](#Fig5) depicts the transfer of information into a blockchain mediated
    by a decentralized push-in oracle. We assume an off-chain interface gathers data
    from various sources and sends it to the off-chain oracles. In turn, the off-chain
    oracles send the transaction with those data to the on-chain oracle, which is
    responsible for the collection of the different pieces of information, their aggregation
    and final communication with the smart contract. In our scenario, a decentralized
    push-in oracle is used to confirm that the delivery was successful, upon the notification
    from three different off-chain information providers, namely the carrier, the
    customer and the quality control specialist. Each of those information providers
    would interact with a dedicated off-chain oracle and a positive input from all
    of them would trigger the successful delivery confirmation to the smart contract.
  prefs: []
  type: TYPE_NORMAL
- en: 4.5 Decentralized Pull-out Oracle
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A decentralized pull-out oracle allows multiple external systems to retrieve
    on-chain information whenever required, as illustrated in Fig. [6](#Fig6). Without
    loss of generality, we assume the external systems to be collectively represented
    by an off-chain interface for the sake of readability, as in the case of push-in
    oracles. Our running example employs a decentralized pull-out oracle when the
    banking system retrieves the data related to the invoice, stored in the blockchain.
    A centralized oracle would obtain the information to return to the bank by accessing
    the blockchain through a single node. If that particular node was on an incoherent
    or corrupted fork of the blockchain, the retrieved information could be misleading.
  prefs: []
  type: TYPE_NORMAL
- en: The decentralized version of the oracle is used here to overcome the potential
    inconsistency of the blockchain data through its own decentralized nature, i.e.,
    by resorting to several independent components that watch the blockchain via different
    nodes. The process starts when the off-chain interface (invoked, e.g., by the
    banking system) requests data (e.g., the invoice information) to multiple off-chain
    oracles. Each of them generates a new query towards different nodes of the blockchain.
    In every node, the on-chain oracle would return the current response based on
    the local view of the blockchain, in turn given back to the requesting off-chain
    interface.![../images/509088_1_En_8_Chapter/509088_1_En_8_Fig6_HTML.png](../images/509088_1_En_8_Chapter/509088_1_En_8_Fig6_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 6.
  prefs: []
  type: TYPE_NORMAL
- en: Sequence diagram of the interaction with a decentralized pull-out oracle
  prefs: []
  type: TYPE_NORMAL
- en: 5 Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we briefly describe a proof-of-concept prototype implementing
    the decentralized oracle architectures, and report on the experiments we conducted
    with it to have a preliminary assesment of its performance in terms of execution
    costs and latency.
  prefs: []
  type: TYPE_NORMAL
- en: 5.1 Prototype and Experimental Setting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We implemented our system based on the Ethereum blockchain. We encoded the on-chain
    components of our prototype in Solidity, the most used language for Ethereum smart
    contracts at present. We resorted to Node.js scripts to implement the off-chain
    components and the Web3 library to let them interact with the blockchain, i.e.,
    for the subscription to event emissions and to send transactions to the blockchain.
    The produced code is openly available on GitHub.^([4](#Fn4))
  prefs: []
  type: TYPE_NORMAL
- en: 'To run our tests, we deployed the on-chain components of our prototype on Ropsten,^([5](#Fn5))
    an Ethereum public testnet, in order to execute the tests and obtain the needed
    information about latency and costs. The test phase took place through four different
    accounts used to deploy the smart contracts and send transactions from the off-chain
    components. The transactions involved in our experiments are identified by the
    interactions with the following contracts and can be retrieved via Etherscan:
    [0xd7c351Eb1DfaFC​f19bf47D3fe55a9D​761a274bd7](https://ropsten.etherscan.io/address/0xd7c351Eb1DfaFCf19bf47D3fe55a9D761a274bd7);
    [0xA6a80830855c81​b472A6aa9efb36bB​A0fF36A5e4](https://ropsten.etherscan.io/address/0xA6a80830855c81b472A6aa9efb36bBA0fF36A5e4);
    [0x7Cc2d01fb411b9​E59924f2Bc79002f​93E9A44ddB](https://ropsten.etherscan.io/address/0x7Cc2d01fb411b9E59924f2Bc79002f93E9A44ddB);
    [0xAF69860c860A00​d723fc0651f22637​aF3b1B0d6D](https://ropsten.etherscan.io/address/0xAF69860c860A00d723fc0651f22637aF3b1B0d6D).'
  prefs: []
  type: TYPE_NORMAL
- en: 5.2 Performance Tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using our proof-of-concept implementation, we have conducted a preliminary assessment
    of its performance in terms of latency and costs, in an attempt to have a rough
    estimation of the differences between centralized and decentralized oracle architectures.
    A fully-fledged comparative study is out of scope for this paper and we envision
    it as a relevant aim for future studies.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first important consideration that we made is about the outbound (pull
    and push) oracles. Although every on-chain computation requires the triggering
    of a transaction, we do not consider that transaction when measuring the performance
    of outbound oracles as they would not directly pertain to the oracle operations
    per se but rather to the pre-processing by the smart contract. Indeed, on-chain
    computation may be required to produce the data later retrieved by pull-out oracles,
    or for the production of the information to be transmitted off-chain by push-out
    oracles. However, from an abstract standpoint, this would depend on the kind of
    data treatments required rather than on the information exchange per se. In both
    cases, data is obtained by the off-chain components by catching the emission of
    an event, and this action has no cost for the oracle system. This aspect has two
    important consequences. First of all, interactions with outbound oracles do not
    necessarily involve any expenditure of gas. Furthermore, the transaction latency
    for these two kinds of oracles is irrelevant. The blockchain ecosystem does not
    affect in any way the global latency as no block mining is involved. However,
    we remark that blockchain is a distributed system and, as such, latency may occur
    from the information distribution itself within the network, aside from the block
    time or transaction latency. This is a crucial factor to consider for process-aware
    system designers implementing the operations on-chain: especially if numerous
    software components are involved, variable delays and possibly time-outs could
    affect the overall stability of the system.![../images/509088_1_En_8_Chapter/509088_1_En_8_Fig7_HTML.png](../images/509088_1_En_8_Chapter/509088_1_En_8_Fig7_HTML.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 7.
  prefs: []
  type: TYPE_NORMAL
- en: Latency measurement for the pull-in oracle
  prefs: []
  type: TYPE_NORMAL
- en: The inbound implementations can provide interesting quantitative information
    that can be used for a preliminary performance assessment about costs and latency.
    We quantify the spending of the oracles in gas units and its equivalent amount
    in Euros. The exchange rate considered at the time of the experiments is 495 Euros
    per Ether (ETH), while the average gas price considered for the ETH/gas conversion
    is 8 Gwei (0.000000008 ETH) per gas unit. Regarding the experiments on latency,
    our goal was to measure the time elapsed between the event that starts the interaction
    and the arrival at destination (i.e., the blockchain) of the information.
  prefs: []
  type: TYPE_NORMAL
- en: Figure [7](#Fig7) illustrates our time measurement scheme for the pull-in oracle.
    Considering our running example, the starter script represents the supplier’s
    request to verify the creditworthiness of the customer. The pull-in oracle begins
    its execution as soon as the starter script receives the mining receipt of its
    request – then we start the timer. At that point, the off-chain component is activated
    by the on-chain component, and after it has retrieved the requested data from
    the off-chain environment, it sends a transaction to the on-chain oracle with
    that information. The end time of the measurement corresponds with the instant
    in which the on-chain component terminates the computation of the received input.
    In a decentralized scheme, oracles employ separate off-chain components that work
    independently. Therefore, the information processing from the on-chain component
    can begin only when the latest off-chain component has transacted its data.![../images/509088_1_En_8_Chapter/509088_1_En_8_Fig8_HTML.png](../images/509088_1_En_8_Chapter/509088_1_En_8_Fig8_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 8.
  prefs: []
  type: TYPE_NORMAL
- en: Latency measurement for the decentralized push-in oracle
  prefs: []
  type: TYPE_NORMAL
- en: Figure [8](#Fig8) depicts our measurement scheme for the decentralized push-in
    oracle (used in our running example for the delivery confirmation). The start
    time corresponds with the first transaction being sent by one of the off-chain
    components. The end time elapses when the latest confirmation receipt is received
    confirming the sending of aggregate data from the on-chain component. Notice that
    there is only one initial transaction and one final receipt in the centralized
    case.
  prefs: []
  type: TYPE_NORMAL
- en: Table [2](#Tab2) reports on the experimental results. For each test we executed
    50 runs, totalling 200 runs (i.e., 100 for the centralized case and 100 for the
    decentralized case). Table [2](#Tab2)(a) shows the results of the experiments
    for the centralized implementations, reporting the mean, minimum and maximum values,
    and the standard deviation. As it turns out, the fastest implementation is that
    of the pull-in oracle, with a mean latency value of 18.24 s and a standard deviation
    of 15.23 s. The push-in oracle, instead, took 23.54 s on average with a standard
    deviation of 16.56 s. For as far as costs are concerned, the most expensive implementation
    is that of the pull-in oracle (with a mean of 42000.98 gas units, while the push-in
    oracle required 39505.47 units).
  prefs: []
  type: TYPE_NORMAL
- en: We evaluated the execution cost for oracles both in terms of the singular off-chain
    components (which we denote as Node 1, Node 2, and Node 3) and in terms of the
    whole oracle system. Considering the motivating scenario, both the pull-in and
    the push-in oracles employ three off-chain components that work independently.
    The cost of the single interaction is given by the sum of all the transaction
    costs, generated by each independent component (denoted as “C1”, ..., “Cn” in
    Figs. [7](#Fig7) and [8](#Fig8)). Table [2](#Tab2)(b) shows the results for the
    decentralized case. As it can be seen in the table, in both cases independent
    nodes of the same system determine different mean costs. The test shows that some
    nodes require on average more gas than others although they belong to the same
    oracle. In other words, the gas consumption of the three off-chain components
    is not balanced. This can be explained by the order whereby the off-chain nodes
    send their transaction to the on-chain component. Indeed, the on-chain component
    provides the decentralized application with the data when all the off-chain components
    have sent their transaction. By considering the single run, the last off-chain
    node that sends the transaction containing the data is the one that spends more.
    In this case, the code executed by the transaction has a higher computational
    complexity because it also includes the operations for the delivery of the data
    to the smart contract of the DApp. The slowest decentralized implementation is
    the pull-in oracle a mean of 34.56 s, while the push-in oracle takes 27.78 s on
    average. Concerning the costs, the tests show that 179175 units of gas are spent
    for the pull-in oracle and 115667 units of gas for the push-in one.Table 2.
  prefs: []
  type: TYPE_NORMAL
- en: Latency and cost test results
  prefs: []
  type: TYPE_NORMAL
- en: '![../images/509088_1_En_8_Chapter/509088_1_En_8_Tab2_HTML.png](../images/509088_1_En_8_Chapter/509088_1_En_8_Tab2_HTML.png)'
  prefs: []
  type: TYPE_IMG
- en: 6 Opportunities and Challenges
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the main aspects of the proposed decentralization architecture is availability.
    By decentralizing the structure of the oracle we eliminate a single point of failure.
    In the case of the centralization, if the unique control entity in charge of the
    information flow fails, the entire system oracle stops working and the communication
    ends. On the contrary, in the proposed decentralized architecture, there is no
    central authority, since every off-chain component interacts independently with
    the on-chain component, which is, in turn, deployed on a decentralized system
    (the blockchain). In this way, the risk of failure for the whole system is reduced.
  prefs: []
  type: TYPE_NORMAL
- en: Another aspect that is affected by the decentralization is the integrity of
    data. Multi-party processes that rely on oracles may need to perform complex operations
    involving significant amounts of resources, and they cannot tolerate faulty or
    altered data. The fact that the information is not maintained by only one entity
    decreases the risk of counterfeit data injection (as in the unlocking of funds
    upon the confirmation from multiple nodes that the invoice was registered). In
    this way, reliability and trust could be generated. Of course, it is necessary
    to define internal mechanisms so that an agreement between the different components
    can be achieved. This specific aspect can increase the complexity of the whole
    oracle system, thus the centralized version might be preferred in some scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: The centralized and the decentralized implementations allowed us to carry out
    a preliminary analysis of the performance (latency and costs) of the different
    kinds of architecture for the inbound oracles. As illustrated in Table [3](#Tab3),
    in all cases the decentralized prototypes require higher costs and cause more
    latency than their centralized version.Table 3.
  prefs: []
  type: TYPE_NORMAL
- en: Comparison table between centralized and decentralized implementations
  prefs: []
  type: TYPE_NORMAL
- en: '![../images/509088_1_En_8_Chapter/509088_1_En_8_Tab3_HTML.png](../images/509088_1_En_8_Chapter/509088_1_En_8_Tab3_HTML.png)'
  prefs: []
  type: TYPE_IMG
- en: This can be explained by the presence of multiple transactions in the case of
    the decentralized versions. Indeed, our use case involves the definition of three
    off-chain components each of which generates one transaction for every procedure.
    Unlike the centralized versions that defines only one transaction for every information
    exchange. In this way, the mean cost of the system grows with the number of off-chain
    components involved. Alternatively, a decentralized system could check the agreement
    between the off-chain components in the real world, whereby only one transaction
    containing the final data would be generated. Therefore, it could serve as a viable
    alternative. However, if the entity in charge of sending the final transaction
    fails, the whole system stops working with such a solution, and the single point
    of failure problem persists.
  prefs: []
  type: TYPE_NORMAL
- en: Regarding latency, the difference between the two architectures is less evident.
    In the case of the pull-in oracle, the centralized version mean result is of 18.24 s
    against the 34.56 s of the decentralized version. The push-in centralized version,
    instead, generates a mean result of 23.54 s, against the 27.78 s of the decentralized
    version.
  prefs: []
  type: TYPE_NORMAL
- en: 7 Conclusion and Future Work
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this paper, we investigated on the use and development of decentralized oracles
    as a means to enhance availability, integrity and trust of information exchanges
    between the blockchain and the outer environment in a business process context.
    We started with the design and development of on-chain components that communicate
    with the off-chain modules developed in a centralized version. Subsequently, we
    turned the oracles architecture into a decentralized one and compared it with
    the previous version. Our prototype was evaluated in terms of execution costs
    and latency.
  prefs: []
  type: TYPE_NORMAL
- en: In this paper, we have focused on the Ethereum blockchain in particular. Our
    study will be complemented with the development of oracles that are compatible
    with other blockchain platforms and then study the use of decentralized oracles
    for communication between multiple blockchains. Furthermore, the Solid Web^([6](#Fn6))
    has been recently proposed as a paradigm for web applications preserving data
    ownership and privacy. Reportedly, blockchain can be a key enabler of this novel
    paradigm [[6](#CR6)]. Therefore, we will study the adoption of decentralized oracles
    to link decentralized systems and information producers and consumers to the Solid
    Web. Moreover, in this paper we have devised the merge and consistency-check of
    information exchanged with multiple off-chain components as an on-chain operation.
    Though more robust, this approach could incur higher costs than a purely off-chain
    mechanism. Therefore, an analysis of the best suitable trade-offs in terms of
    load-balancing and security of the two solutions is part of our envisioned future
    work. Finally, we will conduct in-depth studies on the scalability and robustness
    of the architecture, with an investigation on potential threats to security.
  prefs: []
  type: TYPE_NORMAL
- en: Acknowledgments
  prefs: []
  type: TYPE_NORMAL
- en: The authors are grateful to the reviewers for their precious feedback. The work
    of C. Di Ciccio was partially funded by the MIUR under grant “Dipartimenti di
    eccellenza 2018–2022” of the Department of Computer Science at Sapienza and by
    the Sapienza research project “SPECTRA”.
  prefs: []
  type: TYPE_NORMAL
- en: '© Springer Nature Switzerland AG 2021J. González Enríquez et al. (eds.)Business
    Process Management: Blockchain and Robotic Process Automation ForumLecture Notes
    in Business Information Processing428[https://doi.org/10.1007/978-3-030-85867-4_9](https://doi.org/10.1007/978-3-030-85867-4_9)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Methods for Decentralized Identities: Evaluation and Insights'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Walid Fdhila^([1](#Aff12), [2](#Aff13) [ ](#ContactOfAuthor1)), Nicholas Stifter^([1](#Aff12),
    [2](#Aff13)), Kristian Kostal^([3](#Aff14)), Cihan Saglam^([4](#Aff15)) and Markus Sabadello^([4](#Aff15))(1)Secure
    Business Austria (SBA-Research), Vienna, Austria(2)University of Vienna, Wien,
    Austria(3)FIIT, Slovak University of Technology in Bratislava, Bratislava, Slovakia(4)DanubeTech
    GmbH, Wien, AustriaWalid FdhilaEmail: [wfdhila@sba-research.org.com](mailto:wfdhila@sba-research.org.com)'
  prefs: []
  type: TYPE_NORMAL
- en: Abstract
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Recent technological shifts have pressured businesses to reshape the way they
    operate and transact. At the hart of this restructuring, identity management established
    itself as an essential building block in both B2C and B2B business models. Trustworthy
    identities may refer to customers, businesses, suppliers or assets, and enable
    trusted communications between different actors. Unfortunately, traditional identity
    management systems rely on centralized architectures and trust in third party
    services. With the inception of blockchain technology, new methods for managing
    identity emerged, which promise better decentralization and self-sovereignty.
    This paper provides an evaluation of a selection of distributed identity methods,
    and analyzes their properties based on the categorization specified in the W3C
    recommendation rubric.
  prefs: []
  type: TYPE_NORMAL
- en: KeywordsBlockchainDistributed identitySelf-sovereign IdentityDID method
  prefs: []
  type: TYPE_NORMAL
- en: 1 Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In today’s internet, organizations such as Google, Facebook or Amazon centrally
    manage and control vast amounts of cross-correlating data about individuals and
    their identities. An already diminished trust in such centralized systems by its
    users is further brought into question, as recent breaches have exposed their
    private data on a massive scale, urging the need for new *decentralized* methods
    that give individuals full control back over their data.
  prefs: []
  type: TYPE_NORMAL
- en: By providing the necessary infrastructure and renewed interest in Byzantine
    Fault Tolerance (BFT) [[11](#CR11)], the advent of blockchain technology paved
    the way for such new decentralized methods for establishing trustworthy distributed
    identities that do not rely on a central entity serving as a single point of trust.
    This approach is called self-Sovereign Identity (SSI), in which entities or individuals
    become their own identity providers, thus creating and controlling one or multiple
    (i) decentralized identifiers (DIDs), and (ii) verifiable credentials (VCs) [[6](#CR6)].
    (i) A DID is a unique identifier, usually associated with a DID document (also
    called continuation document) that specifies cryptographic material, verification
    methods and services essential for proving ownership of the DID and trustworthy
    communication with the DID owner. (ii) Verifiable credentials are identity attributes
    and assertions about a specific subject issued by an identity provider. In contrast
    to traditional credentials, a relying party (third party service) can check the
    validity of a VC without having to interact with the issuer. A DID method, on
    the other hand, defines how a DID can be created, resolved, updated and revoked.
    Currently, there exist over one hundred DID methods that rely on different architectural
    designs or infrastructures. Therefore, developing a use case that employs decentralized
    identifiers requires a good understanding of the properties of such methods and
    what they offer in terms of governance, security or operation. In this paper,
    we provide a qualitative evaluation of six DID methods following the guidelines
    of the W3C DID method rubric.^([1](#Fn1))
  prefs: []
  type: TYPE_NORMAL
- en: The remainder of the paper is structured as follows. Section [2](#Sec2) introduces
    basic concepts, while Sect. [3](#Sec3) outlines the methodology. Section [4](#Sec6)
    evaluates the different DID methods, Sect. [5](#Sec13) discusses the results and
    concludes the paper.
  prefs: []
  type: TYPE_NORMAL
- en: 2 Background
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Decentralized Identifiers (DIDs).* DIDs are unique identifiers whose purpose
    is to ensure trustworthy and persistent communication channels between entities.
    In contrast to common identifiers such as URIs, phone numbers or social media
    identifiers, which are issued and controlled by third parties, DIDs enable individuals
    and organizations to issue and control their own identifiers. DIDs, as specified
    in the W3C recommendation draft^([2](#Fn2)), are strings that have the following
    format: ![$$did:{&lt;}did\_method{&gt;}: {&lt;}method\_specific\_identifier{&gt;}$$](../images/509088_1_En_9_Chapter/509088_1_En_9_Chapter_TeX_IEq1.png),
    where *did* is the prefix, ![$$did\_method$$](../images/509088_1_En_9_Chapter/509088_1_En_9_Chapter_TeX_IEq2.png)
    refers to the method specification that defines the precise operations for creating,
    resolving, updating and revoking specific DIDs, and ![$$method\_specific\_identifier$$](../images/509088_1_En_9_Chapter/509088_1_En_9_Chapter_TeX_IEq3.png)
    is a unique identifier within the method. An example of a DID created using the
    *btcr* method^([3](#Fn3)) on the Bitcoin blockchain would be: ![$$did:btcr:8kyt-fzzq-qpqq-ljsc-5l$$](../images/509088_1_En_9_Chapter/509088_1_En_9_Chapter_TeX_IEq4.png).'
  prefs: []
  type: TYPE_NORMAL
- en: '*DID Document.* Similar to DNS resolution where a URL is provided as an input
    and the corresponding IP address is returned as output, DID resolution takes the
    DID as input and returns a DID document as output. The latter contains, among
    others, cryptographic material (public keys for authentication, authorization,
    and interaction), verification methods for proving ownership of the DID, and service
    endpoints for enabling trusted communication with the subject, for instance to
    exchange verifiable credentials.'
  prefs: []
  type: TYPE_NORMAL
- en: '*DID Method.* The diversity in the blockchain ecosystem led to a plethora of
    different methods for creating and resolving DIDs. Although most of these methods
    comply with the W3C DID specification, each of them comes with specific properties
    and offers different guarantees depending on the underlying technology or governance
    framework. As such, each DID method specifies how corresponding DIDs are **c**reated,
    **r**esolved, **u**pdated and **d**eactivated (CRUD).'
  prefs: []
  type: TYPE_NORMAL
- en: 3 Methodology
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 3.1 DID Method Selection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At the time of writing, there exist over 100 DID methods that differ in various
    aspects such as (i) the underlying infrastructure (ii) governance, (iii) operation,
    and (iv) security. Unfortunately, a large number of these methods are either conceptual
    designs, unimplemented proposals or stale projects that are no longer maintained.
    Additionally, the focus is often placed on operational elements such as CRUD,
    while the remaining aspects of the method receive considerably less attention
    and documentation, rendering an evaluation difficult.
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on the authors’ expertise in the domain of SSI and their involvement
    in the implementation of the universal registrar and resolver for DIDs^([4](#Fn4))![$$^,$$](../images/509088_1_En_9_Chapter/509088_1_En_9_Chapter_TeX_IEq5.png)^([5](#Fn5)),
    a set of 6 DID methods, that cover different architectural designs, were selected
    and evaluated: (i) blockchain-based (ii) non blockchain-based, (iii) public permissioned,
    (iv) public permissionless and (v) pairwise DIDs. The selection, namely {did:btcr,
    did:v1, did:ethr, did:sov, did:web, did:peer} offers sufficient documentation
    and implementation details for a fair evaluation and covers approaches that are
    currently well received by the SSI community.'
  prefs: []
  type: TYPE_NORMAL
- en: 3.2 Evaluation Process
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this paper a qualitative evaluation is performed using the guidelines specified
    in the W3C DID method Rubric V1.0 (06 Jan. 2021)^([6](#Fn6)) and additional criteria
    derived from the principles of SSI [[8](#CR8)]. The paper, therefore, provides
    both a comprehensive and comparative study of the DID methods and for each evaluation
    criteria considers three overlapping dimensions as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: (i)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Network* is the underlying communication layer, i.e., how and with whom users
    need to communicate to invoke the operations of the method.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: (ii)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Registry* is a given instance of recorded state changes, managed according
    to the specification, using the communication layer.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: (iii)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Specification* is the governing document of the method that defines and outlines
    how a particular method implements the required and any optional components of
    the DID core specification.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Evaluation Criteria.* The criteria are grouped into four categories, each
    focusing on a specific aspect of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: (1)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Rulemaking* captures the degree of decentralization in the governance of the
    DID method. It covers who can define the rules and how they are defined with respect
    to each of the aforementioned dimensions. For instance, the economic interest
    behind a DID method can impact its centralization if the goal is to support the
    interest of a certain group.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: (2)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Operation* focuses on the CRUD operations and evaluates how the rules are
    executed. It also addresses the *openness* of the operation, i.e., whether it
    is restricted to a select group (permissioned) or open to participation by anyone
    (permissionless). Permissioned operation can impact the availability of the network
    to various participants, which affects inclusivity with regard to underserved
    or vulnerable populations. It may also expose the permission giver to legal ramifications.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: (3)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Security* covers potential attack vectors against both, the integrity and
    correctness, as well as the privacy and self-sovereignty of users, that can arise
    through the method design choices and employed technologies.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: (4)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Implementation* touches on aspects and challenges regarding an actual implementation
    and utilization of the corresponding DID method in practice.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The evaluation is conducted by five experts with diverse technical and theoretic
    backgrounds in distributed ledger technology in general and self-sovereign identity
    in particular. Some of the evaluators are also involved in standardization efforts
    by W3C for decentralized identifiers and verifiable credentials, in addition to
    projects for the implementation of a universal DiD registrar and resolver that
    supports around 50 DiD methods. As aforementioned, the selected DiD methods were
    chosen to cover different architectural designs and rely on various infrastructures
    that obey to different governance rules.
  prefs: []
  type: TYPE_NORMAL
- en: 4 Evaluated DID Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 4.1 did:btcr
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Description.** DID:btcr uses transactions on the Bitcoin blockchain for registering,
    updating and revoking identities. The DID corresponds to the transaction reference
    *TxRef*^([7](#Fn7)), which encodes details (i.e., chain, block height, transaction
    index and optionally outpoint index). The transaction can optionally include an
    ![$$OP\_RETURN$$](../images/509088_1_En_9_Chapter/509088_1_En_9_Chapter_TeX_IEq6.png)
    as part of the transaction outputs to refer to a DID document, otherwise, a default
    document is automatically created. ![$$OP\_RETURN$$](../images/509088_1_En_9_Chapter/509088_1_En_9_Chapter_TeX_IEq7.png)
    is a Bitcoin script opcode [[2](#CR2)], which can be used to embed up to 80 bytes
    of data in a transaction. Updating the DID is achieved by spending the current
    outpoint and setting the ![$$OP\_RETURN$$](../images/509088_1_En_9_Chapter/509088_1_En_9_Chapter_TeX_IEq8.png)
    with a reference to the updated DID document. Reading a DID requires a lookup
    of the *TrxRef* and following the chain of spending transactions until the last
    one with an unspent outpoint is reached. If the last transaction has no ![$$OP\_RETURN$$](../images/509088_1_En_9_Chapter/509088_1_En_9_Chapter_TeX_IEq9.png),
    it means the DID has been revoked.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Rule Making.** *Network and Registry.* For did:btcr, the network and registry
    are actually the same and correspond to the Bitcoin protocol. Changes to the protocol
    require drafting a Bitcoin Improvement Proposal (BIP) which is then openly discussed
    within the community. Therefore, participation in network governance is open and
    anyone can join, comment and contribute to open debate (open contribution). The
    process towards BIP acceptance follows the guidelines defined in BIP:2, where
    it is recommended that the acceptance of a BIP requires at least a ![$$95\%$$](../images/509088_1_En_9_Chapter/509088_1_En_9_Chapter_TeX_IEq10.png)
    acceptance rate by the miners of the last 2016 blocks, unless there is rationale.
    The deciding group is not closed and includes known and unknown entities/miners
    (breadth of authority). However, participation in governance cannot be considered
    fair, as miners with higher hash power have more influence in the decision making.
    In DID:btcr, although miners receive block rewards and transaction fees, the governance
    of the DID method itself is decentralized and therefore, established to the public
    good.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Specification.* The specification of the DID:btcr is created and maintained
    by a closed set of contributors. Comments and suggestions to the specification
    are open, but the decision lies within a closed and known set of people. Although
    participation in the specification governance requires time and effort, no incentives
    to the specification governing entity are defined, thus confirming prior conclusions
    on financial goals of the method, which is established for the public good without
    extracting rents or remunerations.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Operation.** As the Bitcoin blockchain is public and permissionless, where
    anyone can participate, read and write (transact) with the ledger, the operations
    of the did:btcr also do not require any permission. However, resolving a DID without
    relying on authoritative intermediaries requires operating a full node, which
    can prevent the use of resource constrained edge devices to directly resolve DIDs.
    For registering DIDs edge devices can be sufficient unless a continuation document
    is specified, which would require additional resources for hosting it (e.g., a
    server). Note that did:btcr supports the creation of both universal and paired
    DIDs. Although Bitcoin is public and, in principle, anyone can resolve a DID,
    it is also possible to create a default DID (without setting the ![$$OP\_RETURN$$](../images/509088_1_En_9_Chapter/509088_1_En_9_Chapter_TeX_IEq11.png)),
    which would make it indistinguishable from a normal transactions, and therefore
    can be used in a pairwise manner. It is possible for anyone to retrieve a cryptographic
    proof of the history of changes (transactions), thus theoretically enabling public
    auditability. However, referencing continuation documents that reside on mutable
    storage can hinder these benefits.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Security.** While relying on Bitcoin transactions as DIDs ensures integrity
    and persistence, referring to continuation documents raises concerns over censorship
    and mutability. It is possible for both the storage provider or a governing entity
    to censor the access to the server hosting the continuation document, rendering
    the resolution of the corresponding DID impossible without first updating it.
    Besides censorship, failure of the host server directly impacts the availability
    of the DID (for resolution) unless a caching mechanism is implemented. Integrity
    of a continuation document can be checked as it is signed with the transaction
    input key. However, a discrepancy between the specification document and the design
    decision document currendly renders it unclear which input key to use for signing
    the continuation documents, i.e., (i) the DID creation input key, or (ii) keys
    used for updates. The latter case would open up the possibility of claiming someone
    else’s DID under certain conditions [[4](#CR4)].'
  prefs: []
  type: TYPE_NORMAL
- en: '**Implementation.** One challenge with implementing btcr DIDs is that there
    is no single definitive, complete, and up-to-date specification. Implementers
    have to combine information from different sources, ask questions from the community,
    and analyze existing examples and code to build a compatible implementation. CRUD
    operations on btcr DIDs can be difficult when a continuation DID document is needed,
    since this requires access to a web server, in addition to access to the Bitcoin
    blockchain. For resolving btcr DIDs, the main challenge is “following the tip”,
    i.e., the process of looking up unspent outpoints of a transaction after a btcr
    DID has been updated or deactivated, which is not readily supported by all Bitcoin
    implementations. Finally, an aspect of btcr DIDs is that during creation, the
    actual DID only becomes fully known and stable after a transaction is mined in
    a block and sufficiently confirmed. This requires implementations to maintain
    some kind of internal state and monitoring process.'
  prefs: []
  type: TYPE_NORMAL
- en: 4.2 did:sov
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Description.** Sovrin is a private non-profit foundation and its DID method
    relies on a public permissioned blockchain specifically and exclusively targeted
    for self-sovereign identity [[10](#CR10)]. Sovrin’s technical underpinnings derive
    from Hyperledger’s Indy project and it employs the plenum protocol, which is an
    enhancement of RBFT (Redundant Byzantine Fault Tolerance) [[1](#CR1)].'
  prefs: []
  type: TYPE_NORMAL
- en: '**Rule Making.**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Network and Registry.* In did:sov, the network and the registry both correspond
    to the Sovrin network. Governance is restricted to a board of trustees (BoT) that
    decide on (i) how the network evolves, and (ii) approval of new stewards or governance
    proposals by the Sovrin governance framework working group (SGFWG). Stewards are
    independent entities (e.g., universities, organizations) responsible for endorsing
    transactions and writing to the ledger, and have to comply with the governance
    framework approved by the BoT. All governance documents are open to public review
    and comment, but the decision is ultimately restricted to a closed group (i.e.,
    the BoT). Similar to DNS governance, despite being a non-profit public organization,
    the Sovrin foundation collects fees and rents to ensure economic viability of
    the infrastructure. Additionally, although there exist several and different governance
    bodies within the Sovrin foundation (e.g., SGFWG, STGB, EAC) and any one can join,
    the ultimate governance approval remains under the BoT control. To be part of
    the BoT, one should first be nominated by the nomination/transition committee
    and then voted by the current BoT. Participating in governance is clearly restricted
    and requires modest costs in terms of efforts and time.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Specification.* The specification is governed by the Sovrin technical governance
    board through the Sovrin trust framework, and revisions (called controlled documents)
    should undergo the BoT approval.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Operation.** In contrast to did:btcr, while anyone can read from the Sovrin
    ledger, writing to it is permissioned and restricted to transaction endorsers
    (e.g., stewards). Sovrin publicly shares their annual financial reports, which
    can be checked by anyone, thus rendering its financial accountability transparent.
    To resolve DIDs, did:sov does not require implementing a full node, but can instead
    rely on state proofs making the use of edge devices with limited resources possible.
    However, registering a DID without relying on intermediaries is not possible as
    it has to be achieved through an endorser. Finally, the public nature of Sovrin
    enables anyone to retrieve a cryptographic proof of all changes to a DID document,
    making the system auditable.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Security.** In practice, did:sov is censorship resistant as it relies on
    a distributed network of nodes (stewards) from all over the world, responsible
    for accessing and writing to the ledger. As such, a user that is censored by a
    steward can readily register a DID using a different one. However, this does not
    prevent the BoT from issuing new endorsement policies that censor specific type
    of users, with which endorsers have to comply. The integrity of the ledger is
    maintained by the diverse stewards and observer nodes, and can also be publicly
    verified using for example anchored state proofs. Although confidentiality is
    not a required property, it is possible in did:sov to create pairwise DIDs that
    are not stored on the ledger. Besides, Sovrin also supports the creation of blinded
    DIDs using zero knowledge proofs. According to the Sovrin GDPR compliance policies,
    personal data may not be written to the ledger (data minimization), i.e., only
    public DIDs and the corresponding DID documents, credential definitions and revocation
    registries are stored on the ledger. Sovrin also uses software agents (e.g., edge
    agent, cloud agent) to store and manage credentials and keys, and communicate
    with other agents in a peer to peer fashion using the didcomm protocol.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Implementation.** This method was designed for Sovrin, which is widely known
    and has been used by many implementers and real-life projects. It has also implicitly
    been designed for other ledger instances of Hyperledger Indy. In practice however,
    applications and services building on top of these ledgers use custom identifier
    and discovery formats instead of actual DIDs and DID documents, which has made
    this DID method hard to understand. A DID method specification exists, but it
    is outdated. Implementations of sov DIDs therefore are currently mostly based
    on community knowledge and undocumented assumptions. The ledger itself offers
    basic operations such as NYM and ATTRIB that make it possible to build DIDs and
    DID documents on top. The shortcomings and confusion around implementing sov DIDs
    is expected to be solved with the arrival of the new Indy DID method.'
  prefs: []
  type: TYPE_NORMAL
- en: 4.3 did:ethr
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Description.** The did:ethr method is similar to did:btcr in that it also
    builds upon on a blockchain technology, in this case Ethereum. However, while
    Bitcoin employs a UTXO-based ledger design, Ethereum utilizes an account-based
    model and supports quasi-Turing complete *smart contracts* [[7](#CR7)]. did:ethr
    leverages these properties by mapping Ethereum (externally owned) account addresses,
    which are derived from the public key of an ECDSA Secp256k1 asymmetric key pair,
    to identities. An important design decision of did:ethr is that the creation of
    a DID does not necessitate submitting a transaction to the Ethereum network. Instead,
    any regularly generated externally owned account address is considered a DID.
    In addition, Ethereum’s smart contract functionality is used to realize a registry
    for CRUD operations and to allow for the delegation of control over an identity.
    Hereby, the smart-contract-based registry follows the preliminary ERC-1056 standard
    defined in Ethereum improvement proposal EIP-1056^([8](#Fn8)) and inherits desirable
    properties such as immutability, trustless execution and decentralization, from
    the underlying platform. While did:ethr appears to offer a lightweight and cost
    effective method for creating DIDs, the design choices introduce some unclear
    properties regarding the creation and revocation of DIDs that are never committed
    to through a transaction on the blockchain.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Rule Making.**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Network and Registry.* Similarly to did:btcr, the network and registry in
    this method are also provided through the underlying blockchain system. However,
    did:ethr relies on a registry that is governed by a smart contract which can publicly
    be interacted with through any Ethereum account or other smart contract code.
    In regard to rule making, the current smart-contract-based registry specification
    renders the functionality *immutable* as by the properties of the underlying ledger.
    However, it is unclear if the current draft ERC-1056 registry design will change
    to include some ability for governance once the draft is finalized. For the basic
    network (blockchain), while anyone can participate fully in principle, to be able
    to meaningfully partake in Ethereum’s consensus protocol requires significant
    hashrate and therefore financial resources. In practice high-hashrate proof of
    work blockchains such as Bitcoin and Ethereum present themselves more like networks
    where consensus is permissioned, as the average user has no realistic chance of
    influencing consensus decisions. In Ethereum, the governance authority is an open
    set of multiple parties and the process, in analogy to Bitcoin’s BIPs, is governed
    through Ethereum Improvement Proposals (EIPs). The operational costs of the registry
    are fully transparent because they are publicly visible on the blockchain, and
    the network costs such as mining rewards and hashrate can also be deduced from
    on-chain data.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Specification.* The did:ethr specification was initially created by uPort [[9](#CR9)],
    however it is not use-case specific or geared toward an extraction of rent and
    established as a public good. It is openly available in GitHub and is currently
    governed by the Decentralized Identity Foundation, however there is no reason
    to assume that this excludes others from actively participating. The smart contract
    code of the registry is also publicly available and can be checked against the
    deployed contract.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Operation.** The creation of ethr DIDs does not require any permission, special
    hardware requirements or even access to the full blockchain ledger, in particular
    if no transaction to the registry (e.g. for delegating control) is required. For
    some of the CRUD it can be necessary to interact with the on-chain smart contract
    through transactions that need to pay transaction fees to miners. These transaction
    costs are public and recorded in the blockchain. Overall the compensation to miners
    in Ethereum is highly transparent as all on-chain flows of cryptocurrency funds
    are publicly accessible. Reading the registry is possible for anyone (either through
    a light or full node or a third party service). The scheme is designed to be operational
    on different EVM compatible networks (e.g. Ethereum testnets, Rootstock etc.)
    and also allows to specify alternative registry addresses. Analogous to did:btcr,
    if all of the CRUD operations of the DID are performed through transactions, it
    is possible for anyone to retrieve cryptographic proof of these changes, enabling
    public auditability. On the other hand, if DIDs are not added to the registry
    through transactions, they can be used in a pairwise manner and also may offer
    some degree of privacy e.g., against metadata collection.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Security.** The advantage of did:ethr lies in the design of not having to
    commit to the DID in a transaction unless the owner desires so or wants to include
    properties such as delegating control of the DID to another address. This however
    means that a DID that has been deleted/revoked which has never used the registry
    can not be distinguished from one that is not revoked. Integrity is ensured through
    blockchain consensus and the use of established algorithms for asymmetric cryptography
    and hash functions. Users can create their DID trustlessly by generating a Secp256k1
    keypair. Utilization of the registry is trustless as long as the underlying ledger
    remains “permissionless”, i.e. transactions are not censored by miners and are
    economically viable. Updates to the DID in the registry are publicly visible and
    in principle personally identifying information could also be encoded in the DID
    entry, introducing potential privacy issues. DID resolution and reading the registry
    can be done with good confidentiality as blockchain state is publicly and anonymously
    accessible, either through running one’s own full or light Ethereum node or, with
    more trust assumptions, through the API of a third party provider. Similarly to
    the continuation documents in did:btcr, the method allows for “service endpoints”
    which can reference external, mutable resources such as URLs, thereby opening
    up potential concerns over censorship, persistence and privacy.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Implementation.** This method can render it cost effective for anyone to
    create DIDs, as the creation step only requires the generation of a cryptographic
    key pair, without having to perform blockchain transactions. Resolving ethr DIDs
    requires read operations against Ethereum or the respective Network in which the
    registry smart contract is located, which can however readily be achieved with
    any standard Ethereum tools and only incurs modest resource requirements. Once
    update and deactivate operations are necessitated, implementers need to be able
    to write to the blockchain, which requires appropriate infrastructure to be in
    place (similar to other blockchain-based DID methods) and is subject to transaction
    fees.'
  prefs: []
  type: TYPE_NORMAL
- en: 4.4 did:web
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: did:web is a method that uses domain names as identifiers. The DID is a URI
    that points to a DID document stored on a web host server and registered within
    a DNS registrar. To resolve the DID, a HTTP GET request on the HTTPS URL generated
    from the DID is required. Updating the DID is achieved by replacing/updating the
    DID document on the hosting location. Revocation occurs if the DID document is
    deleted from the web host.
  prefs: []
  type: TYPE_NORMAL
- en: '**Rule Making.**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Network and Registry.* Because the did:web method uses domain names to represent
    DIDs, both the DID network and registry correspond to the registries and registrars
    running the domain name servers. Therefore, evaluating governance aspects requires
    a thorough understanding on how such a traditional DNS system is governed. Governance
    of DNS is mainly the responsibility of the ICANN, a multistakeholder, private,
    non-profit organization that follows a bottom-up, consensus driven, model to coordinate
    the assignment of internet domain names and IP addresses [[5](#CR5)]. Although
    each DNS registry/registrar might have separate internal rules and is responsible
    for allocating/selling its corresponding domain names, ultimately they have to
    comply and fulfill the agreements and policies of ICANN. The DNS model combines
    both public and private economies. The ICANN itself is a non-profit organization
    that acts for the common good of the public, but extracts registration fees from
    registries, registrars and indirectly registrants, for covering the running costs
    of the organization. However, from the perspective of registry and registrars,
    they extract rents to enhance their profits.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Specification.* The specification is published by the credentials community
    group. Anyone can comment and raise issues through the specification GitHub repository,
    however, decision making is not clear and seems to be conducted by the specification
    authors.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Operation.** While anyone can read, writing to the registry/DNS server is
    permissioned. Creating a DID requires a subscription within a registrar/registry
    or a third party seller, in addition to a web host for storing the did document
    (except the case where users host their own web servers). As such, to resolve
    a DID using the did:web method without relying on intermediaries, a user has to
    be an accredited registry. Besides the fact that this does not seem as a practical
    solution, it will also require exceptional resources and has to follow and comply
    with complex procedures. Furthermore, while domain names are meant to be used
    universally (unless using local/private network and DNS server), DID documents
    are stored on web hosts with no means of cryptographically proving the history
    of their changes, thus rendering auditability almost impossible.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Security.** In did:web, censorship can happen at different levels: (i) the
    DNS or (ii) the web host. While a migration to a new web host would solve the
    latter scenario (against migration and update fees), the registry has still full
    control on removing or censoring specific DIDs. Although it is also possible to
    transfer the DID to another registrar, the registry (e.g., Verisign for .com)
    still has the power to deny the user request. In the current specification of
    did:web, it is not clear how integrity is addressed although a proposal to use
    hashlinks is suggested. Confidentiality, on the other hand, depends on whether
    or not the registration within the registrar is private. If not, the user has
    to reveal her basic information, thus giving registrars the ability to correlate
    the actual identity with the corresponding DID.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Implementation.** Resolving web DIDs only requires a simple HTTP GET operation,
    which can be readily achieved in any programming language or operating system.
    Creating, updating, and deactivating only require storing and updating a file
    on a web server.'
  prefs: []
  type: TYPE_NORMAL
- en: 4.5 did:v1
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Description.** Veres One^([9](#Fn9)) is a project specifically targeted at
    the creation and management of DIDs. The v1 specification was drafted by members
    of Digital Bazaar and is hosted/maintained by the W3C Credentials Community Group.
    It relies on custom distributed ledger technology, which is based on the “Continuity”^([10](#Fn10))
    BFT consensus protocol that appears specifically targeted for an application in
    Veres One. The Method is designed to extract rents and remuneration for its operators
    and it specifies a detailed governance structure for defining the relevant operational
    entities, governing bodies and how the method specification may be updated. At
    the time of writing, the collection of specification and design details regarding
    did:v1 presented itself challenging, as the documentation and code is spread over
    multiple GitHub repositories and websites and does not paint a coherent picture.
    Further, while the project management, governance and its goals are outlined,
    the presented structure is relatively complex and it is unclear how to readily
    verify if the project adheres to the specification and its claimed goals in practice.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Rule Making.**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Network and Registry.* v1 intends to use a public ledger where, in principle,
    anyone can create and resolve DIDs. To keep in line with GDPR compliance, some
    elements of the DID can exist off chain. While it is claimed that the network
    is permissionless, operational details suggest that this property may only extend
    toward the ability of reading the ledger. Specifically, the employed novel consensus
    protocol and its ability to support an open participation model has not yet received
    sufficient peer-review to allow for an objective evaluation. The cost for participating
    as a network node in the Veres One network is not fully clear, but there will
    be at least a modest cost involved.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Specification.* It appears that interested parties can contribute and participate,
    either by taking on a governance role, or commenting on the public GitHub repositories.
    However, ultimately control over the specification is held by the Veres One governing
    body and the entities controlling these repositories.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Operation.** The software necessary to run a client is open source, requires
    minimal resources and can query information from network nodes. For trustless
    DID resolution users would have to run a network node themselves. In regard to
    creating or updating DIDs (writing to the ledger) did:v1 follows a model where
    users pay an *accelerator fee* that is distributed among the maintainers and participants
    of the network. Hence, did:v1 offers a more restricted permissioned model similar
    to did:sov. However, it appears to be possible to circumvent accelerators by performing
    a proof-of-work or partaking in the protocol as a consensus node.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Security.** Within did:v1 it is currently unclear if the method can achieve
    its stated properties in a fully “permissionless” setting in practice, as the
    consensus protocol is not yet sufficiently analyzed. On the one hand, under the
    assumption that the ledger and its consensus protocol is fully permissionless,
    it can achieve censorship resistance. Public verifiability is also possible, however
    the method also supports external resources which may not be verifiable or could
    be censored. On the other hand, if consensus is only achieved by assuming a restricted
    set of participants, i.e., it is permissioned, it opens up the possibility of
    censorship. According to the method specification, GDPR compliance is achieved
    but it is not fully clear how this property is enforced in practice. More specifically,
    to be fully GDPR compliant consensus nodes need to verify that no personally identifiable
    data has been encoded in the DID, be it intentional or unintentionally. In relation
    to the right to be forgotten it may be necessary to delete entries in the blockchain’s
    history. However, secure redactable blockchains in the permissionless setting
    are still a subject of ongoing research [[3](#CR3)].'
  prefs: []
  type: TYPE_NORMAL
- en: '**Implementation.** The did:v1 method directly builds on JSON-LD and Linked
    Data Proofs, which can provide some familiarity for implementers. Resolving v1
    DIDs is straightforward, since each network node exposes an HTTP GET interface
    for retrieving a fully compliant DID document. One primary question that remains
    open is the future evolution and implementation of the Veres One ledger. This
    includes both, whether the envisioned technological goals that are laid out in
    the specification can be achieved in practice, as well as how governance and network
    participation (e.g., permissionless or permissioned) is then realized depending
    on these technologies.'
  prefs: []
  type: TYPE_NORMAL
- en: 4.6 did:peer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Description.** The core concept behind the did:peer specification hinges
    on the insight that there exist two categories of DIDs, namely *anywise DIDs*
    and *N-wise DIDs*. The former are intended to be used with an unknown number of
    parties whereas the latter are only intended to be known by exactly *N* enumerated
    participants, and the did:peer method addresses this type of DID. A *pairwise
    DID* is the special case where ![$$N\! = \!2$$](../images/509088_1_En_9_Chapter/509088_1_En_9_Chapter_TeX_IEq12.png).
    N-wise DIDs are only relevant to its corresponding members and aspects such as
    resolution should only concern the involved parties. Hence the bulk of interactions
    can be moved off-chain with the possibility of connecting back to a chain-based
    ecosystem if needed.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Rule Making.**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Network and Registry.* There are no specific networks for rule making, communications
    can go through any network channel. The decision on picking a specific network
    is up to the involved parties participating in did:peer and the registry is only
    at the peers, held locally. If the peers decide to change network picking and
    rules or registry, it is up to them. The creator of the DID is only one peer or
    a pair of peers which agrees on some rules, everything is peer-related. As the
    network and registry are created between a set of peers, it is only for the common
    good of those participants.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Specification.* The did:peer specification is openly available on Github where
    anyone can propose improvements or changes, however the board of contributors
    who can accept such changes seems to be a closed group. It does not appear that
    the specification is geared toward the extraction of rent and is for the public
    good.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Operation.** Anyone can, in principle, participate if she is a peer. However,
    the network or communication layer is visible only to peers participating in the
    operations if not otherwise decided by the involved peers. The registry is established
    between communicating peers and held locally, requiring little overhead or unnecessary
    data. The network and registry can be anything on what peers agree upon. and DIDs
    can be created and used contextually, between any set of parties. Auditability
    of operations depends on the concrete capabilities of the underlying registry
    and network that was agreed upon.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Security.** The corresponding DIDs in did:peer are generated in a securely
    random process. This prevents attackers from discovering patterns in peer DIDs
    that might undermine privacy. Normally, peer DIDs are not persisted in any central
    system, so there is no trove to protect. However, in communication with dynamic
    peers, there is a special layered mechanism which is used to persist others’ peer
    DID docs into backing storage which can be a ledger. Messages in this protocol
    are sent encrypted, by the specified format DIDComm’s encryption envelope. This
    gives strong guarantees about the confidentiality and integrity of exchanged data.
    As the communication is mainly between two peers the needed security measures
    are partially minimized from the network point of view.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Implementation.** Implementing peer DIDs takes some significant effort for
    implementers, since this DID method introduces a lot of new concepts that many
    developers will not be familiar with. On the other hand, the DID method renders
    it possible to progressively implement more features. Creation of a peer DID only
    requires generating a key pair, while other operations work via a peer-to-peer
    protocol between agents. It is not completely clear how peer DIDs currently fit
    in with other community developments, such as Hyperledger Aries and DIDComm.'
  prefs: []
  type: TYPE_NORMAL
- en: 5 Discussion and Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Blockchain technologies have opened up manifold opportunities toward realizing
    SSI systems that do not need to rely on centralized entities. While, in part,
    this is achieved through the intrinsic properties of these technologies, e.g.,
    immutability, resistance to censorship, and decentralization, the degree to which
    a DID method can be considered decentralized or secure also depends on many other
    aspects and design choices. One cannot assume that just because a DID method is
    based on blockchain technology implicitly renders it decentralized. Indeed, it
    is extremely important to consider all dimensions, i.e., (i) network, (ii) registry,
    and (iii) specification, and assess a method’s fundamental properties (e.g., governance,
    economic model or security) against each of these dimensions. Table [1](#Tab1)
    provides a comparative overview of the investigated methods. While *protection*
    determines a method’ resistance to censorship, *persistence* evaluates the longevity
    of decentralized identifiers. *Integrity* ensures that DiDs and the corresponding
    DiD documents have not been tampered with, and *confidentiality* means that the
    DiD method gives the option to protect DiDs or DiD Documents from unauthorized
    disclosure if required. Finally, *Decentralization* examines how decentralized
    is a DiD method by evaluating the decentralization of its underlying network,
    registry and specification governance, and operations. For example, our evaluation
    has shown that despite did:btcr relying on the decentralized Bitcoin network for
    creating DIDs, the corresponding DID documents are still hosted on mutable storage,
    thus hindering blockchain benefits and introducing new risks of censorship, availability
    and persistence. Similarly, while did:ethr also builds upon a public permissionless
    Blockchain (Ethereum), its design relies on an on-chain ERC-1056 smart contract
    to manage and govern the DID registry. By doing so, trust is shifted to both,
    the smart contract implementation as well as the underlying Ethereum blockchain.
    Note, that in both methods changes to the specification cannot prevent that operations
    on DIDs can also follow previous specification versions. Resolving them would
    hence require DID resolvers to maintain all previous resolution implementation
    versions. It is noteworthy to point out that most of the evaluated methods have
    a distinct lack of version control/migration mechanisms to prevent old DIDs from
    becoming unresolvable or obsolete. A clear definition on how to upgrade the method
    specification and assessment of its impact on the current implementation would
    clearly prove beneficial for introducing new features and mitigating security
    or performance issues.
  prefs: []
  type: TYPE_NORMAL
- en: There exist security, usability and scalability trade-offs between methods employing
    identity-specific ledgers and methods relying on public blockchains, and between
    the permissioned and permissionless operation of the underlying ledger. Identity-specific
    permissioned ledgers that rely on BFT-based consensus mechanism (e.g., Sovrin
    and Veres One) offer the advantage of better scalability and performance over
    traditional Blockchain designs (e.g., Bitcoin and Ethereum), however this comes
    at the cost of reduced decentralization and an increased risk of censorship by
    operators. This derives from the fact that the entities responsible for writing
    to the ledger have to comply with endorsement agreements that, in the end, might
    be changed by the governing entity, which to a certain extent is less decentralized
    and may serve specific interests.Table 1.
  prefs: []
  type: TYPE_NORMAL
- en: Comparative table of DID methods
  prefs: []
  type: TYPE_NORMAL
- en: '|   | RuleMaking | Operation | Security* |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Network     | Registry     | Specification     | Network     | Registry 
      | Pro     | Per     | Int     | Conf |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| did:btcr | ![$$\CIRCLE $$](../images/509088_1_En_9_Chapter/509088_1_En_9_Chapter_TeX_IEq13.png)
      ![$$\square $$](../images/509088_1_En_9_Chapter/509088_1_En_9_Chapter_TeX_IEq14.png)
    | ![$$\CIRCLE $$](../images/509088_1_En_9_Chapter/509088_1_En_9_Chapter_TeX_IEq15.png)
      ![$$\square $$](../images/509088_1_En_9_Chapter/509088_1_En_9_Chapter_TeX_IEq16.png)
    | ![$$\Circle $$](../images/509088_1_En_9_Chapter/509088_1_En_9_Chapter_TeX_IEq17.png)
    | ![$$\CIRCLE $$](../images/509088_1_En_9_Chapter/509088_1_En_9_Chapter_TeX_IEq18.png) 
    ![$$\square $$](../images/509088_1_En_9_Chapter/509088_1_En_9_Chapter_TeX_IEq19.png)
    | ![$$\CIRCLE $$](../images/509088_1_En_9_Chapter/509088_1_En_9_Chapter_TeX_IEq20.png) 
    ![$$\square $$](../images/509088_1_En_9_Chapter/509088_1_En_9_Chapter_TeX_IEq21.png)
    | ![$$+$$](../images/509088_1_En_9_Chapter/509088_1_En_9_Chapter_TeX_IEq22.png)
    | ![$$+$$](../images/509088_1_En_9_Chapter/509088_1_En_9_Chapter_TeX_IEq23.png)
    | ![$$+$$](../images/509088_1_En_9_Chapter/509088_1_En_9_Chapter_TeX_IEq24.png)
    | ± |'
  prefs: []
  type: TYPE_TB
- en: '| did:v1 | ![$$\RIGHTcircle ^\dagger $$](../images/509088_1_En_9_Chapter/509088_1_En_9_Chapter_TeX_IEq25.png)
    | ![$$\RIGHTcircle ^\dagger $$](../images/509088_1_En_9_Chapter/509088_1_En_9_Chapter_TeX_IEq26.png)
    | ![$$\Circle $$](../images/509088_1_En_9_Chapter/509088_1_En_9_Chapter_TeX_IEq27.png)
    | ![$$\RIGHTcircle ^\dagger $$](../images/509088_1_En_9_Chapter/509088_1_En_9_Chapter_TeX_IEq28.png)
    | ![$$\RIGHTcircle ^\dagger $$](../images/509088_1_En_9_Chapter/509088_1_En_9_Chapter_TeX_IEq29.png)
    | − | ± | ± | ![$$+^\dagger $$](../images/509088_1_En_9_Chapter/509088_1_En_9_Chapter_TeX_IEq30.png)
    |'
  prefs: []
  type: TYPE_TB
- en: '| did:ethr | ![$$\CIRCLE $$](../images/509088_1_En_9_Chapter/509088_1_En_9_Chapter_TeX_IEq31.png)
      ![$$\square $$](../images/509088_1_En_9_Chapter/509088_1_En_9_Chapter_TeX_IEq32.png)
    | ![$$N/A ^\dagger $$](../images/509088_1_En_9_Chapter/509088_1_En_9_Chapter_TeX_IEq33.png)
    | ![$$\RIGHTcircle $$](../images/509088_1_En_9_Chapter/509088_1_En_9_Chapter_TeX_IEq34.png)
    | ![$$\CIRCLE $$](../images/509088_1_En_9_Chapter/509088_1_En_9_Chapter_TeX_IEq35.png)
      ![$$\square $$](../images/509088_1_En_9_Chapter/509088_1_En_9_Chapter_TeX_IEq36.png)
    | ![$$\CIRCLE $$](../images/509088_1_En_9_Chapter/509088_1_En_9_Chapter_TeX_IEq37.png)
      ![$$\blacksquare $$](../images/509088_1_En_9_Chapter/509088_1_En_9_Chapter_TeX_IEq38.png)
    | ![$$+$$](../images/509088_1_En_9_Chapter/509088_1_En_9_Chapter_TeX_IEq39.png)
    | ![$$+$$](../images/509088_1_En_9_Chapter/509088_1_En_9_Chapter_TeX_IEq40.png)
    | ![$$+$$](../images/509088_1_En_9_Chapter/509088_1_En_9_Chapter_TeX_IEq41.png)
    | − |'
  prefs: []
  type: TYPE_TB
- en: '| did:sov | ![$$\RIGHTcircle $$](../images/509088_1_En_9_Chapter/509088_1_En_9_Chapter_TeX_IEq42.png)
      ![$$\blacksquare $$](../images/509088_1_En_9_Chapter/509088_1_En_9_Chapter_TeX_IEq43.png)
    | ![$$\RIGHTcircle $$](../images/509088_1_En_9_Chapter/509088_1_En_9_Chapter_TeX_IEq44.png) 
    ![$$\blacksquare $$](../images/509088_1_En_9_Chapter/509088_1_En_9_Chapter_TeX_IEq45.png)
    | ![$$\RIGHTcircle $$](../images/509088_1_En_9_Chapter/509088_1_En_9_Chapter_TeX_IEq46.png)
    | ![$$\RIGHTcircle $$](../images/509088_1_En_9_Chapter/509088_1_En_9_Chapter_TeX_IEq47.png)
      ![$$\blacksquare $$](../images/509088_1_En_9_Chapter/509088_1_En_9_Chapter_TeX_IEq48.png)
    | ![$$\RIGHTcircle $$](../images/509088_1_En_9_Chapter/509088_1_En_9_Chapter_TeX_IEq49.png) 
    ![$$\blacksquare $$](../images/509088_1_En_9_Chapter/509088_1_En_9_Chapter_TeX_IEq50.png)
    | − | ± | ![$$+$$](../images/509088_1_En_9_Chapter/509088_1_En_9_Chapter_TeX_IEq51.png)
    | ± |'
  prefs: []
  type: TYPE_TB
- en: '| did:web | ![$$\RIGHTcircle $$](../images/509088_1_En_9_Chapter/509088_1_En_9_Chapter_TeX_IEq52.png)
    | ![$$\RIGHTcircle $$](../images/509088_1_En_9_Chapter/509088_1_En_9_Chapter_TeX_IEq53.png)
    | ![$$\Circle $$](../images/509088_1_En_9_Chapter/509088_1_En_9_Chapter_TeX_IEq54.png)
    | ![$$\RIGHTcircle $$](../images/509088_1_En_9_Chapter/509088_1_En_9_Chapter_TeX_IEq55.png)
      ![$$\square $$](../images/509088_1_En_9_Chapter/509088_1_En_9_Chapter_TeX_IEq56.png)
    | ![$$\RIGHTcircle $$](../images/509088_1_En_9_Chapter/509088_1_En_9_Chapter_TeX_IEq57.png)
      ![$$\square $$](../images/509088_1_En_9_Chapter/509088_1_En_9_Chapter_TeX_IEq58.png)
    | − | − | − | ± |'
  prefs: []
  type: TYPE_TB
- en: '| did:peer | ![$$\CIRCLE $$](../images/509088_1_En_9_Chapter/509088_1_En_9_Chapter_TeX_IEq59.png)
    | ![$$\CIRCLE $$](../images/509088_1_En_9_Chapter/509088_1_En_9_Chapter_TeX_IEq60.png)
    | ![$$\Circle $$](../images/509088_1_En_9_Chapter/509088_1_En_9_Chapter_TeX_IEq61.png)
    | ![$$\RIGHTcircle ^\dagger $$](../images/509088_1_En_9_Chapter/509088_1_En_9_Chapter_TeX_IEq62.png)
    | ![$$\RIGHTcircle ^\dagger $$](../images/509088_1_En_9_Chapter/509088_1_En_9_Chapter_TeX_IEq63.png)
    | ± | − | − | ![$$+$$](../images/509088_1_En_9_Chapter/509088_1_En_9_Chapter_TeX_IEq64.png)
    |'
  prefs: []
  type: TYPE_TB
- en: '| *****Security - Pro: protection   Per: persistence   Int: integrity   Conf:
    confidentiality |'
  prefs: []
  type: TYPE_TB
- en: '| ![$$\CIRCLE $$](../images/509088_1_En_9_Chapter/509088_1_En_9_Chapter_TeX_IEq65.png)
      fully decentralized   ![$$\RIGHTcircle $$](../images/509088_1_En_9_Chapter/509088_1_En_9_Chapter_TeX_IEq66.png)
      partially decentralized   ![$$\Circle $$](../images/509088_1_En_9_Chapter/509088_1_En_9_Chapter_TeX_IEq67.png)
      centralized   ![$$N/A ^\dagger $$](../images/509088_1_En_9_Chapter/509088_1_En_9_Chapter_TeX_IEq68.png)
      not applicable |'
  prefs: []
  type: TYPE_TB
- en: '| Required resources:   ![$$\blacksquare $$](../images/509088_1_En_9_Chapter/509088_1_En_9_Chapter_TeX_IEq69.png)
      modest   ![$$\square $$](../images/509088_1_En_9_Chapter/509088_1_En_9_Chapter_TeX_IEq70.png)
      substantial |'
  prefs: []
  type: TYPE_TB
- en: '| ![$$\dagger $$](../images/509088_1_En_9_Chapter/509088_1_En_9_Chapter_TeX_IEq71.png)Not
    clear or well defined how method satisfies criteria at time of writing |'
  prefs: []
  type: TYPE_TB
- en: The selected methods interestingly rely on different economic models that range
    from non-profit organizations which extract rents from the DID methods to totally
    open and free (not considering network fees) community projects. This creates
    a trade-off between the sustainability and growth of the project and trust in
    the system. Indeed, participation in governance and maintenance often requires
    substantial efforts and time. Hence, a failure to consider aligning incentives
    or covering operational costs in the method’s economic model may lead to a stale
    project or to an outdated specification. On the other hand, incentives should
    not be aligned to only serve the economic interest of a specific entity, thus
    diminishing trust, openness, transparency and accountability of the system.
  prefs: []
  type: TYPE_NORMAL
- en: We hereby point out some of the challenges encountered while conducting this
    evaluation. First, the amount and quality of available documentation, as well
    as the discrepancy between some of the methods’ specifications and their actual
    corresponding implementations, introduced uncertainties on how to fairly evaluate
    specific properties of the method. Moreover, some of the specifications might
    have changed during and after the evaluation, thus requiring continuous revision
    of the evaluation. Finally, some of the constructs and goals of specific methods
    are difficult to verify in practice or have yet to be implemented, leaving an
    answer to whether or not they can achieve the promised guarantees unclear.
  prefs: []
  type: TYPE_NORMAL
- en: To conclude, there is no clear winner among the evaluated DID methods. Each
    comes with advantages and disadvantages, and the selection of a particular method
    heavily depends upon the use case (e.g., supply chain, KYC, automotive process)
    and desired properties. Some application areas may require scalable and private
    systems, while others can necessitate a focus on distribution and trust. Furthermore,
    while blockchain offers unique security and decentralization properties for DID
    methods, it does not prevent flawed specifications and governance designs from
    introducing vulnerabilities that could jeopardize potential benefits.
  prefs: []
  type: TYPE_NORMAL
- en: Acknowledgments
  prefs: []
  type: TYPE_NORMAL
- en: This research is based upon work partially supported by (1) the Christian-Doppler-Laboratory
    for Security and Quality Improvement in the Production System Lifecycle; The financial
    support by the Austrian Federal Ministry for Digital and Economic Affairs, the
    Nation Foundation for Research, Technology and Development and University of Vienna,
    Faculty of Computer Science, Security & Privacy Group is gratefully acknowledged;
    (2) SBA Research (SBA-K1); SBA Research is a COMET Center within the COMET – Competence
    Centers for Excellent Technologies Programme and funded by BMK, BMDW, and the
    federal state of Vienna. The COMET Programme is managed by FFG. (3) the FFG ICT
    of the Future project 874019 dIdentity & dApps. (4) the FFG Industrial PhD project
    878835 SmartDLP. (5) the U.S Department of Homeland Security Science and Technology
    Directorate’s Silicon Valley Innovation Program (SVIP) under OTA 70RSAT20T00000030\.
    Any opinions contained herein are those of the author(s) and do not necessarily
    reflect those of DHS S&T
  prefs: []
  type: TYPE_NORMAL
