- en: © The Author(s), under exclusive license to Springer Nature Singapore Pte Ltd. 2021Z.
    Zheng et al. (eds.)Blockchain Intelligence[https://doi.org/10.1007/978-981-16-0127-9_5](https://doi.org/10.1007/978-981-16-0127-9_5)
  prefs: []
  type: TYPE_NORMAL
- en: 5. Misbehavior Detection on Blockchain Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Weili Chen^([1](#Aff4) [ ](#ContactOfAuthor1)), Jiahui Cui^([1](#Aff4) [ ](#ContactOfAuthor2)),
    Xiongfeng Guo^([2](#Aff5) [ ](#ContactOfAuthor3)), Zhiguang Chen^([3](#Aff6) [ ](#ContactOfAuthor4))
    and Yutong Lu^([3](#Aff6) [ ](#ContactOfAuthor5))(1)School of Data and Computer
    Science, Sun Yat-sen University, Guangzhou, China(2)School of Data and Computer
    Science, National Engineering Research Center of Digital Life, Sun Yat-sen University,
    Guangzhou, China(3)School of Data and Computer Science, National Supercomputer
    Center in Guangzhou, Sun Yat-sen University, Guangzhou, ChinaWeili ChenEmail:
    [chenwli28@mail.sysu.edu.cn](mailto:chenwli28@mail.sysu.edu.cn)Jiahui CuiEmail:
    [cuijh6@mail2.sysu.edu.cn](mailto:cuijh6@mail2.sysu.edu.cn)Xiongfeng GuoEmail:
    [guoxf6@mail2.sysu.edu.cn](mailto:guoxf6@mail2.sysu.edu.cn)Zhiguang Chen (Corresponding
    author)Email: [zhiguang.chen@nscc-gz.cn](mailto:zhiguang.chen@nscc-gz.cn)Yutong LuEmail:
    [yutong.lu@nscc-gz.cn](mailto:yutong.lu@nscc-gz.cn)'
  prefs: []
  type: TYPE_NORMAL
- en: Abstract
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The prevalence of misbehaviors has resulted in considerable financial loss and
    thus has undermined public reputation of cryptocurrency, leading to hindrance
    to the progress of blockchain technology. To attack on this problem, this chapter
    discussed about several types of misbehaviors on blockchain and data mining as
    an approach for identification of misbehavior on blockchain. Two practical data
    mining models aiming at detecting Ponzi schemes and phishing scams on Ethereum
    are proposed and detailed evaluations are conducted.
  prefs: []
  type: TYPE_NORMAL
- en: 5.1 Overview
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Financial security has always been a hotspot in real-world currency system.
    While blockchain technology is bringing more and more cryptocurrencies with increasing
    market capitalization, it also attracts various scams due to its financial nature.
    With the proliferation of scams in the ecosystem, identification of these misbehaviors
    has been a matter of significance.
  prefs: []
  type: TYPE_NORMAL
- en: A recent research (Vasek and Moore [2015](#CR67)) has identified four types
    of scams in Bitcoin and found that $11 million worth of Bitcoin has been contributed
    to the scams, with at most $4 million back to the victims. However, scams in the
    Bitcoin ecosystem may just be the tip of the iceberg, because there are many other
    cryptocurrencies and a wide range of other illegal activities including money
    laundering (Moser et al. [2013](#CR53)), gambling (Tasca et al. [2018](#CR66)),
    and black marketing (Christin [2013](#CR20)). These misbehaviors in the ecosystem
    may hinder users’ acceptance and use of blockchain technology, and further hinder
    the development of the technology.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the field of misbehavior detection in blockchain, various approaches have
    been proposed for money laundering, phishing detection, and so on. The prime questions
    of misbehavior detection are: What types of misbehaviors are there on blockchain
    ecosystem? How do these misbehaviors work on blockchain? According to the report
    of *Chainalysis*, misbehaviors on blockchain are mainly divided into six categories:^([1](#Fn1))'
  prefs: []
  type: TYPE_NORMAL
- en: '**Money Laundering:** Money laundering in Bitcoin, which is based on the anonymity
    of Bitcoin, aims to conceal the original address of illegal gains. However, Bitcoin
    does not provide true anonymity because transactions are designed to involve pseudonymous
    addresses that allow researchers to link all transactions from a particular user
    all together. With better customer identification being encouraged by major Bitcoin
    exchanges, the mixing services (Bonneau et al. [2014](#CR7)) for Bitcoin has become
    an essential technology for money laundering.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scams:** Another consequence coming with the anonymity of cryptocurrencies
    is the proliferation of scams. The report from *Chainalysis* has identified six
    types of scams on cryptocurrency ecosystem: fake token sale, Ponzi scheme, phishing
    scam, reported investment scam, blackmail, and fake mixer, where the Ponzi scheme
    contributes to the vast majority of scam revenue.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ransomware:** With the prevalence of Ransomware as a Service (RaaS), hackers
    with less sophisticated hacking skills are able to conduct ransomware by using
    ransomware technology developed by other hackers. However, it is difficult to
    estimate the number of ransoms with blockchain analysis, since many companies
    prefer to pay ransom without reporting in consideration of their share market.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hacks:** More and more cryptocurrency hacks have occurred in recent years.
    Yet the $534 million Coincheck hack and the $473 Mt.Gox hack still account for
    the major portion of the gross financial loss. Hackers on blockchain are getting
    more sophisticated with increased use of mixing services and complicated scam
    strategies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Darknet Market:** The financial nature of cryptocurrency inevitably attracts
    darknet markets. While shops specializing in drugs account for the main part,
    other illegal categories including stolen credit card information and child sexual
    abuse material also exist in darknet market based on blockchain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Terroism Financing:** Terrorism financing based on cryptocurrency is presenting
    new challenges to authorities due to the decentralized and semi-anonymous nature
    of blockchain technology. Agents are not able to ban such transactions because
    there are no centralized authorities on blockchain. Besides, tracking the origins
    is also facing difficulty due to money laundering services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For national authorities, blockchain technology is very new and its decentralized,
    semi-anonymous nature makes legal system hard to cover cryptocurrency ecosystem.
    Therefore, identification of these misbehaviors is facing great difficulty.
  prefs: []
  type: TYPE_NORMAL
- en: To attack this critical challenge, diverse methods have been raised for different
    problems. Among these methods, we are most interested in employing data mining
    methods to encounter scam identification, and in this chapter we propose two approaches
    aiming at detecting Ponzi schemes and phishing schemes in blockchain ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rest of this chapter is organized as follows: Sect. [5.2](#Sec2) introduces
    data analysis as an approach for misbehavior detection in blockchain. Section
    [5.3](#Sec6) presents our achievement in recognizing Ponzi schemes on Ethereum.
    Section [5.4](#Sec23) shows an approach for phishing scam detection on Ethereum,
    and Sect. [5.5](#Sec39) concludes this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: 5.2 Data Analysis on Blockchain
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Nonetheless, the decentralized and anonymous nature of cryptocurrency makes
    the ecosystem rampant with crimes and has resulted in considerable financial loss
    for victims. But on the other hand, its transparent nature also distinguishes
    it from traditional forms of cash, which allows employing data mining methods
    on blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Data originated in blockchain can be roughly divided into two categories: on-chain
    data and off-chain data. The former refers to transactions recorded in blockchain
    ledger which is publicly accessible. The off-chain data usually refers to market
    parameters including trade prices and transaction records in major exchanges.
    Based on different analysis tools, the data analysis methods can be categorized
    into three groups: complex network analysis, data mining approach, and statistical
    methods.'
  prefs: []
  type: TYPE_NORMAL
- en: 5.2.1 Analysis Based on Complex Network
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Since the majority of data recorded on blockchain are transaction data, on-chain
    analysis methods are mainly interested in transactions. Among these studies, modeling
    the transactions into a graph database and studying the network with complex network
    technologies is the main approach (Chan and Olmsted [2017](#CR10); Lischke and
    Fabian [2016](#CR44)). There are various researches based on Bitcoin such as Bitcoin
    address study (Fleder et al. [2015](#CR27)) and tracking Bitcoin user activity
    using community detection (Remy et al. [2018](#CR61)). Things are more complicated
    on Ethereum due to the introduction of smart contracts: transaction could involve
    both users and smart contracts (Chen et al. [2018a](#CR15)).'
  prefs: []
  type: TYPE_NORMAL
- en: 5.2.2 Analysis Based on Data Mining Methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The rapidly increasing number of blockchain users and the publicly accessible
    characteristic are providing an unprecedented platform for data analysis. A clustering
    model considering both off-chain information and on-chain information has been
    proposed for Bitcoin addresses association (Ermilov et al. [2017](#CR26)). The
    effectiveness of various address clustering methods are evaluated in (Harrigan
    and Fretter [2016](#CR30)), and a modular framework is presented to visualize
    complex information extracted from the Bitcoin network (Spagnuolo et al. [2014](#CR64)).
    Trade analysis on blockchain is another attracting point for investors. There
    are several Bitcoin price prediction models constructed by using recursive neural
    network (RNN) and long short-term memory (LSTM) with common features extracted
    from on-chain information and off-chain information (Jang and Lee [2017](#CR33);
    McNally et al. [2018](#CR48)).
  prefs: []
  type: TYPE_NORMAL
- en: 5.2.3 Analysis Based on Statistic Tools
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The trading price of cryptocurrency of the off-chain information is of great
    significance. Time-series analysis is widely used in this area since the prices
    are directly presented in time series. Among aspects relating to trading price,
    detecting the determinants of it have aroused wide interests. Thus, manifold models
    have been introduced to study the main drivers, including VSM model (Georgoula
    et al. [2015](#CR29)), VECM model (Ciaian et al. [2016](#CR21)), ARDL method (Bouoiyour
    and Selmi [2015](#CR8)), wavelet coherence analysis (Kristoufek [2014](#CR43)),
    Copula method (Osterrieder et al. [2017](#CR57)), and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Still, blockchain supervision based on data analysis methods inevitably encounters
    obstacles due to decentralization and anonymity services. Unlike centralized system,
    we are not able to control the validation of transactions, nor could we easily
    track the origins of illegal behavior. But at least with proper tools, the publicly
    accessible blockchain ledger could provide us with unique insights into criminal
    patterns on blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: '5.3 Case Study: Ponzi Scheme Detection'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 5.3.1 Ponzi Scheme on Ethereum
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Among the many projects developed with the exploitation of blockchain technology,
    Ethereum is one of the most vigorous platforms. Ethereum is an open-source and
    decentralized platform with *Ether* as the cryptocurrency generated by Ethereum
    miners. A Turing-complete virtual machine, Ethereum Virtual Machine (EVM), is
    provided by Ethereum to execute *smart contracts*. A smart contract is a script
    released by Ethereum users which will be automatically executed by EVM when some
    preset conditions are met (Buterin [2014](#CR9); Szabo [1996](#CR65)), i.e., receiving
    a message call. The execution of smart contracts does not rely on trusted authorities
    and cannot be modified. Smart contracts can be applied in various domains including
    IoT, a collaboration of decentralized organizations, and even in criminal scenes
    (Christidis and Devetsikiotis [2016](#CR19); Juels et al. [2016](#CR34); Norta
    [2015](#CR56)). Blockchain platforms that support smart contracts are called the
    second-generation blockchain (CoinDesk [2017](#CR22)).
  prefs: []
  type: TYPE_NORMAL
- en: Any newborn technology inevitably contains vulnerabilities that can be exploited
    by adversary scams. For example, the development of email introduces a proliferation
    of spams. Blockchain, as a newly-introduced technology, also attracts considerable
    types of scams due to its decentralized, anonymous characteristics and the lack
    of regulation. Among the scams, a classic fraud, Ponzi scheme, also has its implementation
    on blockchain (Bartoletti et al. [2020](#CR6); Vasek and Moore [2015](#CR67)).
    Named after a notorious fraudster and carried out in the 1920s for the first time,
    the Ponzi scheme is a fraudulent investment operation that lures investors and
    generates profits for proceeding investors with funds from recent investors, instead
    of legitimate business activities or profits of financial trading (Wikipedia [2017](#CR69)).
  prefs: []
  type: TYPE_NORMAL
- en: The truth is that most of the people will lose their investment in Ponzi schemes,
    leading to the prohibition of Ponzi schemes in many countries. When it comes to
    blockchain technology, Ponzi schemes are making a considerable profit from those
    impulsive investors who want to participate in the blockchain technology and speculate
    in the blockchain marketing, yet with little knowledge of how the blockchain works
    (Stan Higgins [2015](#CR31); Keirns [2017](#CR37); MORRIS [2017](#CR52)). A recent
    study has found that more than 7 million USD has been collected during the period
    from September 2, 2013 to September 9, 2014 by a variety of scams in Bitcoin (Vasek
    and Moore [2015](#CR67)).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the field of Ethereum, many of the Ponzi schemes are concealed beneath *smart
    contracts* (Bartoletti et al. [2020](#CR6)). In other words, they are implemented
    as smart contracts deploying on Ethereum. These Ponzi schemes are referred to
    as *smart* Ponzi schemes and the corresponding smart contract *Ponzi scheme contract*.
    Among various implementations of Ponzi schemes, one focal property of Ponzi schemes
    is the need for continuous and long-term investment from victims. In that sense,
    a smart contract is an ideal approach to implementing Ponzi schemes. Once a smart
    contract is released on the Ethereum, it cannot be terminated by authorities and
    will permanently run on Ethereum. Most importantly, the promoter of a Ponzi scheme
    contract stays somewhat anonymous due to the semi-anonymity of blockchain technology.
    Figure [5.1](#Fig1) displays the propaganda picture of a typical smart Ponzi scheme.
    The propaganda words are as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Hello! My name is Rubixi! I’m new & verified pyramid smart contract on the Ethereum
    blockchain. When you send me 1 Ether, I will multiply the amount and send it back
    to your address when the balance is sufficient. My multiplier factor is dynamic
    (**min. x1.2 max. x3**), thus my payouts are accelerated and **guaranteed** for
    months to come![../images/506524_1_En_5_Chapter/506524_1_En_5_Fig1_HTML.png](../images/506524_1_En_5_Chapter/506524_1_En_5_Fig1_HTML.png)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 5.1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The propaganda picture of a smart Ponzi scheme (Rubixi). (Source: [https://​bitcoindtalk.​org/​index.​php?​topic=​1400536.​0](https://bitcoindtalk.org/index.php?topic=1400536.0))'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: According to the slogan, this smart contract looks pretty profitable and the
    payback period seems to be guaranteed. However, the real situation is far from
    the description. Through manual inspection, we found that 112 participants have
    joined the contract, while only 22 participants have gained revenue. Among them,
    the two participants with the highest profits received more than 40% of the benefits,
    and one of them was the creator of the contract. Unfortunately, most participants
    did not receive the promised profit.
  prefs: []
  type: TYPE_NORMAL
- en: The above example shows a successful Ponzi scheme instance and demonstrates
    the importance of detecting smart Ponzi schemes. Although some users clearly know
    the possible loss of participating in the Ponzi scheme (Moore et al. [2012](#CR51);
    Neisius and Clayton [2014](#CR55)), automated Ponzi scheme detection is still
    of great significance for the following reasons. (1) It is difficult for some
    people to understand how the blockchain works, which makes it a challenge for
    them to distinguish fraudulent on the blockchain. (2) For national authorities,
    blockchain technology is very new to them, which puts the blockchain in a gray
    area of a certain legal system (Elwell et al. [2013](#CR25)) and, to some extent,
    condones the development of scams. Therefore, developing automated smart Ponzi
    scheme detection technologies is a critical task.
  prefs: []
  type: TYPE_NORMAL
- en: 'Due to the semi-anonymous nature of the blockchain, detecting Ponzi scheme
    contracts on Ethereum is not an easy task. A Ponzi scheme contract is composed
    of the corresponding source code, so it is possible to manually check the contract
    code to determine whether it is a Ponzi scheme contract. However, difficulty also
    comes with this approach. That is, Ethereum does not require the creator of the
    smart contract to disclose the source code. In other words, only bytecode is necessary
    for a smart contract to release on Ethereum. In fact, among more than one million
    contracts running on Ethereum, there are only less than four thousand having verified
    source codes.^([2](#Fn2)) This makes it unrealistic to detect Ponzi scheme contracts
    from source code. Thus a variety of questions are raised: How many Ponzi scheme
    contracts are there on Ethereum? What are their characteristics? How much damage
    did they cause? To answer these questions, the first and foremost step is to answer
    the following question: How to detect Ponzi scam contracts without source codes?'
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we define the smart Ponzi scheme detection problem as a classification
    problem. In order to build an effective classification model, adequate smart contracts
    with *labels* and effective features excluding source code features are needed.
    Figure [5.2](#Fig2) illustrates the overall framework of the approach proposed
    in this book. As is shown, firstly 3071 verified smart contracts including normal
    transactions, fired transactions, and source codes are downloaded. Then the source
    codes are compiled to bytecodes which are publicly accessible on Ethereum. Besides,
    the bytecodes are disassembled to operation codes (see Sect. [5.3.2](#Sec8) for
    detailed information). Next, we extract account features from recorded transactions
    and code features from operational codes. In the end, an XGBoost classification
    model based on these features is proposed.![../images/506524_1_En_5_Chapter/506524_1_En_5_Fig2_HTML.png](../images/506524_1_En_5_Chapter/506524_1_En_5_Fig2_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 5.2
  prefs: []
  type: TYPE_NORMAL
- en: The framework of smart Ponzi schemes detection
  prefs: []
  type: TYPE_NORMAL
- en: 'A key contribution of this section is an experimental validation of the feasibility
    of detecting smart Ponzi schemes at the moment of its creation. Because we extracted
    code features from operation codes which are publicly accessible after the contract
    deployed. This result is of great significance because by using the model we can:
    (1) detect smart Ponzi schemes even if the source codes are intentionally hidden;
    (2) detect smart Ponzi schemes before it causes any damage; and (3) build a risk
    warning platform based on it.'
  prefs: []
  type: TYPE_NORMAL
- en: 5.3.2 Ethereum and Smart Contracts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since the Ethereum platform and its state transaction mechanism have already
    been introduced in Chap. [2](506524_1_En_2_Chapter.xhtml), this section briefly
    introduces the source code snippet of a Ponzi scheme contract. Besides, operation
    code, the mnemonic form of bytecode and the main source of features in our model,
    is introduced.
  prefs: []
  type: TYPE_NORMAL
- en: 5.3.2.1 A Source Code Snippet of a Smart Ponzi Scheme
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Generally, the smart contracts on Ethereum are written in high-level languages.
    Among the various high-level languages, *Solidity* is a contract-oriented, widely-used
    language, which plays a significant role in the Ethereum platform.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 5.1 The simplified Rubixi![../images/506524_1_En_5_Chapter/506524_1_En_5_Figc_HTML.png](../images/506524_1_En_5_Chapter/506524_1_En_5_Figc_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to better understand how to distinguish a Ponzi scheme from the solidity
    source code, we extracted the main part of the Rubixi contract code (Listing [5.1](#FPar1)),
    which determines that this contract is implementing the function of the Ponzi
    scheme. Generally speaking, a smart contract contains two components: function
    and data structure. The function can be called by transaction or message call
    from other accounts and contracts. The data structure is the part of the smart
    contract that stores data and may be updated at any time during the execution
    of the contract.'
  prefs: []
  type: TYPE_NORMAL
- en: Consider the contract source code of RUBIXI; lines 2-11 are data definitions,
    which are used to describe the current state of the contract. For example, the
    variable *balance* describes the current balance of the contract, and the data
    structure *Participant* describes the investment and addresses of investors participating
    in the Ponzi scheme. The function on line 14 runs only once when the contract
    is created.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function with no name in line 17, containing only a function call to *addPayout*,
    is called the *fallback function*. The *fallback function* is only called when
    an account transfers some Ethers without data to the contract address. *addPayout*,
    defined in line 19, is the core part implementing the main logic of Ponzi schemes:
    (1) Record the addresses and investments of the investors (lines 21–22); (2) calculate
    fees (line 28); (3) pay to previous investors when the contract balance meets
    certain conditions (lines 29–34).'
  prefs: []
  type: TYPE_NORMAL
- en: The array *participants* defined in line 12 records all the investors in order,
    including address (*msg.sender*) and payment (*payout=msg.value *pyramidMultiplier)/100*).
    Note that the propagated high profit (see Fig. [5.1](#Fig1)) is controlled by
    the variable *pyramidMultiplier*, which was first set to 300 (line 6), but then
    reduced to 200 (line 23) from the 10th participant and 150 (line 25) from the
    25th participant. Obviously, to attract early participants, the contract owner
    promised a higher profit for them. It is worth mentioning that *pyramidMultiplier*
    should be set to above 100 for the promised profit of participants.
  prefs: []
  type: TYPE_NORMAL
- en: Taking fees from participants is the main purpose of operating a Ponzi scheme.
    It can be seen clearly from the code snippet that Rubixi charges every investment
    10%, and the fees are collected by calling the function *collectAllFees* in line
    37\. The while loop from line 29 to line 34 tries to pay all the previous participants
    by their investment order until the balance is not enough. This piece of code
    clearly shows the logic of the contract payment, which obviously can be identified
    as a Ponzi scheme.
  prefs: []
  type: TYPE_NORMAL
- en: 'As seen from the code snippet, two kinds of transactions may occur to a smart
    contract: normal transactions and fired transactions. These transactions are publicly
    available and can be downloaded from ethereum.io^([3](#Fn3)) using the provided
    API.'
  prefs: []
  type: TYPE_NORMAL
- en: 5.3.2.2 Deploy a Contract
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As mentioned above, an Ethereum contract is a series of “Ethereum virtual machine
    code” or “EVM code” residing in the Ethereum blockchain. We call this *bytecode*
    of a contract. In order to write smart contracts conveniently, a high-level language
    is used (e.g., the *Solidity* language). Thus, to deploy a contract, the first
    thing to do is to compile the source code into EVM bytecode. The EVM bytecode
    is composed of a series of bytes. Each byte is an operation. For human readable,
    each operation corresponds with a mnemonic form. For example, the mnemonic form
    of EVM bytecode 0x10 is LT, which means less-than comparison. We call LT and such
    mnemonic form of EVM bytecode as *opcode*. The appendix of Ethereum yellow paper
    (Wood [2014](#CR70)) contains a complete list of the EVM bytecode and its mnemonic
    form, i.e., opcode. A disassembler^([4](#Fn4)) can be used to get the operation
    code of a contract from bytecode. Operation code consist of a series of *opcode*
    and *operand*. For example, the first five rows of the operation code in Rubixi
    are: *PUSH1 0x60; PUSH1 0x40; MSTORE; CALLDATASIZE; ISZERO*. *PUSH1* is an opcode,
    and *0x40* is an operand.'
  prefs: []
  type: TYPE_NORMAL
- en: To make the contract callable from other accounts, the bytecode of a smart contract
    should be deployed in the main Ethereum network. A special transaction targeted
    to the zero-account (the account with the address 0) creates a new contract. The
    bytecode of the contract provides as the payload of that transaction and will
    be executed; the result will be stored in the code field of the new contract account
    and be record permanently on the blockchain until the contract being killed by
    the creator. The address of the new contract will return to the creator, which
    can then be shared with the others.
  prefs: []
  type: TYPE_NORMAL
- en: 5.3.3 Data, Feature Extraction, and Classification Model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to establish an effective model to detect smart Ponzi schemes, 1382
    verified smart contracts were collected from the website [http://​etherscan.​io](http://etherscan.io).
    Reported by a previous study (Bartoletti et al. [2020](#CR6)), these smart contracts
    were inspected manually to check whether it is a smart Ponzi scheme or not. We
    recheck the results and tidy them as ground truth data in our model. Specifically,
    131 Ponzi scheme contracts and 1251 non-Ponzi scheme contracts were collected.
    To establish the model, we downloaded the corresponding data and extracted two
    categories of features from the data. This section provides an overview of the
    data and features. The feature extraction method is also introduced.
  prefs: []
  type: TYPE_NORMAL
- en: 5.3.3.1 Data
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Figure [5.2](#Fig2) illustrates the collection process of the two kinds of data
    stored on the Ethereum platform, including transactions and source codes. The
    transaction data contain normal transactions and fired transactions in form of
    JSON files. All these data were collected through the APIs provided by etherscan.io.^([5](#Fn5))
    Please visit our website^([6](#Fn6)) for more detailed information. It is worth
    noting that only the last 10000 transactions can be downloaded due to the limitation
    of ethescan.io. However, this limitation has only a little influence to our study
    and was ignored.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing the source code of smart contracts is able to make a considerable
    contribution to detecting the functions implemented by the contract. However,
    on Ethereum, open-source code is not compulsory, although it is suggested for
    public inspection. In order to build a practical Ponzi scheme detection model,
    we only rely on the publicly accessible bytecode stored on the Ethereum blockchain.
    For labeled smart contracts, we first compile the source code to bytecode through
    an Ethereum local client. Then disassemble tool is leveraged to get the operation
    code. Finally, we extract the opcodes from the operation code and count their
    occurrences.
  prefs: []
  type: TYPE_NORMAL
- en: 5.3.3.2 Account Features
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Due to the fraudulent nature of the Ponzi scheme contract, some characteristics
    can be used to identify these contracts. There are at least three characteristics
    that distinguish Ponzi scheme contracts from common smart contracts: (1) The Ponzi
    scheme contracts always send Ethers to the accounts that have invested in it.
    (2) Among the participants, some accounts will receive more payment than the investment,
    such as the creator of the contract. (3) The balance of the contract may always
    be in a low range because the Ponzi scheme is trying to maintain the impression
    of fast and high returns to attract new investors.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The intrinsic characteristics determine the behaviors of Ponzi schemes, which
    can assist us in detecting Ponzi scheme contracts. One of the representations
    of these behaviors is the Ether flow. We introduce the *Ether flow graph* extracted
    from transaction records to analyze such behavioral characteristics. Different
    from the commonly used cash flow graph, the Ether flow graph is leveraged to represent
    transactions between contracts and participants. These transactions have two directions:
    from participant to contract and from contract to participant. We denote the first
    direction as investment transactions and the second direction as payment transactions
    of the participant. Investment transactions are denoted by red circles and payment
    transactions are denoted by green triangles in the graph. The *x*-axis represents
    the time line, while the *y*-axis represents individual participants. The graph
    presents the transactions that each participant involved along the timeline. The
    corresponding Ether amounts in the transactions are reflected by the size of the
    circles or triangles. The transactions between the contract and a participant
    are arranged in a horizontal line in order of the transactions’ timestamps. Participants
    are ordered by the timestamp of their first transaction with the contract. Thus,
    the 0th participant is usually the creator of the contract. In general, an investment
    transaction should be followed by a payment transaction in normal economic activity,
    but it is not true in a smart Ponzi scheme.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figures [5.3](#Fig3) and [5.4](#Fig4) display the Ether flow graphs of two
    contracts: Rubixi and LooneyLottery. Rubixi is a typical smart Ponzi scheme and
    LooneyLottery^([7](#Fn7)) is a normal lottery game contract. The Ether flow graph
    of Rubixi contract (Fig. [5.3](#Fig3)) shows that the creator of the contract
    and its very early participants are winners of the game. There are almost 120
    participants involved in the contract, but most payments pertain to the first
    25 lucky participants. Notably, there is an abnormal behavior pertaining to the
    54th participant (presented as a gray-dashed line in the graph), as they sent
    only twice but received payments many times. This abnormal behavior occurs because
    there is a bug in the source code which can be used to change the owner of the
    contract and collect fees (Atzei et al. [2017](#CR4)).![../images/506524_1_En_5_Chapter/506524_1_En_5_Fig3_HTML.png](../images/506524_1_En_5_Chapter/506524_1_En_5_Fig3_HTML.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 5.3
  prefs: []
  type: TYPE_NORMAL
- en: The Ether flow graph of Rubixi (a typical Ponzi scheme contract)
  prefs: []
  type: TYPE_NORMAL
- en: '![../images/506524_1_En_5_Chapter/506524_1_En_5_Fig4_HTML.png](../images/506524_1_En_5_Chapter/506524_1_En_5_Fig4_HTML.png)'
  prefs: []
  type: TYPE_IMG
- en: Fig. 5.4
  prefs: []
  type: TYPE_NORMAL
- en: The Ether flow graph of LooneyLottery (a typical non-Ponzi scheme contract)
  prefs: []
  type: TYPE_NORMAL
- en: Significant discrepancy can be found between the two figures. On the one hand,
    there are more participants in Fig. [5.3](#Fig3). However, few interactions can
    be found between these participants and the contract. On the contrast, Fig. [5.4](#Fig4)
    illustrates that the contract involves less participants while there are significantly
    more investments. On the other hand, most payments in Fig. [5.3](#Fig3) pertain
    to the anterior participants but payments in Fig. [5.4](#Fig4) exhibit more randomness.
    These differences can be easily derived by the function of the contract. Thus,
    in turn, the account behavior can be used to classify smart contracts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Through inspecting the Ether flow graph of Rubixi, we can find that: (1) the
    payment transaction usually occurs after an investment transaction, which indicates
    that the contract usually pays to known accounts; (2) but many investment transactions
    have no followed payment transactions; and (3) some participants have more payment
    transactions than investment transactions. Based on these observations and characteristics,
    we extract seven key features in contracts as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Known rate (Kr):* the proportion of receivers who have invested before payment.
    A high *Kr* means the contract interact more with accounts already knew. We expect
    with very high Kr of smart Ponzi schemes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Balance (Bal):* the balance of the smart contract.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*N_investment (N_Inv):* the number of investments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*N_payment (N_pay):* the number of payments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Difference index (D_ind):* this index is used to measure the difference of
    counts between payment and investment for all participants in a contract. Suppose
    that there are *p* participants pertaining to the contract, *v* is a vector with
    length *p* and *m* [*i*] *and* *n* [*i*] denote the counts of investments and
    payments of the *i*th participant. To calculate the difference index, each element
    of the vector *v* is first computed by *v*[*i*] = *n* [*i*] − *m* [*i*], then!['
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: $$\displaystyle \begin{aligned}D\_ind=\left\{\begin{array}{ll} 0 &amp; if\ v=0\
    or\ p \leq 2;\\ s &amp; otherwise \end{array} \right. \end{aligned}$$
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](../images/506524_1_En_5_Chapter/506524_1_En_5_Chapter_TeX_Equa.png)where
    *s* is the skewness of vector *v*. For a smart Ponzi scheme contract, D_ind is
    usually negative, as many participants invest more and receive less.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Paid rate (Pr):* the proportion of investors who received at least one payment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*N_maxpay (N_max):* the maximum of counts of payments to participants.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Table [5.1](#Tab1) shows three statistics of the extracted features: mean,
    median, and standard deviation (SD). The table contains two parts: the upper part
    is the result of all Ponzi scheme contracts and the bottom part is non-Ponzi scheme
    contracts.Table 5.1'
  prefs: []
  type: TYPE_NORMAL
- en: Statistics of extracted account features
  prefs: []
  type: TYPE_NORMAL
- en: '|   | Kr | Bal | N_inv | N_pay | D_ind | Pr | N_max |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| *Ponzi scheme contracts* |'
  prefs: []
  type: TYPE_TB
- en: '| Mean | 0.89 | 4.65 | 56.84 | 92.49 | − 1.04 | 0.62 | 36.12 |'
  prefs: []
  type: TYPE_TB
- en: '| Median | 1.00 | 0.26 | 17.00 | 21.00 | − 0.65 | 0.66 | 11.00 |'
  prefs: []
  type: TYPE_TB
- en: '| Sd | 0.29 | 15.51 | 119.41 | 204.71 | 1.95 | 0.30 | 94.36 |'
  prefs: []
  type: TYPE_TB
- en: '| *Non-Ponzi scheme contracts* |'
  prefs: []
  type: TYPE_TB
- en: '| Mean | 0.49 | 22319.60 | 653.44 | 540.74 | − 0.51 | 0.43 | 237.95 |'
  prefs: []
  type: TYPE_TB
- en: '| Median | 0.50 | 0.10 | 6.50 | 4.00 | 0.00 | 0.40 | 2.00 |'
  prefs: []
  type: TYPE_TB
- en: '| Sd | 0.43 | 187549.23 | 3986.45 | 2195.42 | 6.05 | 0.41 | 1095.08 |'
  prefs: []
  type: TYPE_TB
- en: It can be seen from the table that there are significant differences in the
    statistics of these characteristics between Ponzi scheme contracts and non-Ponzi
    scheme contracts. For example, the average value of Known rage (Kr) is 0.89 in
    Ponzi schemes and only 0.49 in non-Ponzi schemes. The high Kr value of Ponzi scheme
    contracts means these contracts always pay to participants who have invested in
    them, which is the characteristic of a typical Ponzi scheme. As for balance (Bal),
    the median of the two contracts are very close, but the difference between standard
    derivation is very significant. The low standard derivation of Ponzi scheme contracts
    on Bal shows that the balance of most Ponzi scheme contracts is very low. On the
    other hand, the high standard derivation of non-Ponzi scheme contracts indicates
    that while the average balance of non-Ponzi scheme contracts is low, some contracts
    have relatively higher balance. Meanwhile, the median of the non-Ponzi scheme
    contracts balance is only 0.1, which means that half of the non-Ponzi scheme contracts
    have a balance less than 0.1\. In fact, many non-Ponzi scheme contracts have zero
    balance.
  prefs: []
  type: TYPE_NORMAL
- en: 5.3.3.3 Code Features
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Opcodes are significant in analyzing the latent problems of smart contracts,
    because it, to some extent, reflects the logic of smart contracts from the perspective
    of EVM code (Atzei et al. [2017](#CR4); Chen et al. [2017](#CR14)). Therefore,
    we expect that some features extracted from opcodes will be helpful in detecting
    latent Ponzi scheme contracts. In this book, we extracted the opcodes from bytecodes,
    which is publicly available on Ethereum, and counted their occurrence. As a result,
    64 different opcodes are found in the 1382 contracts’ operation codes.
  prefs: []
  type: TYPE_NORMAL
- en: Figure [5.5](#Fig5) shows the cloud graphs of opcodes in the aforementioned
    two smart contracts. Three most frequent opcodes, PUSH, DUP, and SWAP, are removed
    to make the graphs more easily seen. This is because EVM is stack-based, these
    opcodes appear frequently in every contract.![../images/506524_1_En_5_Chapter/506524_1_En_5_Fig5_HTML.png](../images/506524_1_En_5_Chapter/506524_1_En_5_Fig5_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 5.5
  prefs: []
  type: TYPE_NORMAL
- en: The opcode cloud of Rubixi (left) and LooneyLottery (right)
  prefs: []
  type: TYPE_NORMAL
- en: 'Although it is almost impossible to judge the type of smart contract by observing
    the word cloud graph of opcode, the word cloud graphs of the two contracts are
    still obviously different. Intuitively, there are at least two significant differences:
    Rubixi’s opcode set contains more judgments, while LooneyLottery’s opcode set
    contains more randomness. In fact, the first difference is obvious, because the
    Rubixi contract contains more JUMPI (7.8%) and the LooneyLottery contract contains
    more JUMP (2.6%). The difference between these instructions is that the former
    is the latter’s conditional version. Finding the second difference requires more
    observation. The LooneyLottery contract contains 4 TIMESTAMPs, and the Rubixi
    contains none. The reason for this difference is that the opcode TIMESTAMP is
    used to obtain the block’s timestamp, which is a commonly used instruction in
    the system to obtain random values. The above analysis shows that the opcode feature
    may be beneficial for detecting Ponzi scheme contracts.'
  prefs: []
  type: TYPE_NORMAL
- en: 5.3.3.4 Classification Model
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In order to use the above extracted features to distinguish Ponzi scheme contracts
    from non-Ponzi scheme contracts with high accuracy and low false positives, we
    use a commonly used machine learning algorithm XGBoost, which is proved to perform
    well in many problems (Chen and Guestrin [2016a](#CR12)). This subsection provides
    a simple introduction of XGBoost and its parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'XGBoost is short for “Extreme Gradient Boosting” and is an improved version
    of gradient tree boosting (Friedman [2001](#CR28)).^([8](#Fn8)) Unlike GBM, XGBoost
    introduced two important improvements: regularization and tree pruning. Basically,
    XGBoost provides regularization in the objective function, which is used to avoid
    overfitting in the tree-based model. Meanwhile, it changed the tree pruning method
    from stopping when a negative loss encountered to the post-pruning.'
  prefs: []
  type: TYPE_NORMAL
- en: Specifically, suppose there are *N* smart contracts in the dataset {(*x* [*i*],
    *y* [*i*]) | *i* = 1, 2, …, *N*}, where *x* [*i*] ∈ *R* ^(*d*) is the extracted
    features associated with the *i*th smart contract, *y* [*i*] ∈{0, 1} is the classification
    label, such that *y* [*i*] = 1 if and only if the smart contract is a verified
    Ponzi scheme contract. We use XGBoost aiming to minimize the following objective
    function:![
  prefs: []
  type: TYPE_NORMAL
- en: $$\displaystyle \begin{aligned} Obj(\theta) = L(\theta) + \Omega(\theta), \end{aligned}
    $$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/506524_1_En_5_Chapter/506524_1_En_5_Chapter_TeX_Equ1.png)(5.1)'
  prefs: []
  type: TYPE_NORMAL
- en: where *L* is the training loss function and Ω is the regulation term. The training
    loss function measures how predictive the model is on the training data and the
    regulation term penalizes the complexity of the model, which helps to avoid overfitting.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike traditional classification model which directly returns the class label,
    we train a logistic regression model for binary classification, which outputs
    a probability. Any contract with the predicted probability larger than 0.5 is
    considered as a Ponzi scheme contract. The corresponding logistic loss function
    is as follows:![
  prefs: []
  type: TYPE_NORMAL
- en: $$\displaystyle \begin{aligned} L(\theta) = \sum_i[y_i \mathrm{ln}(1+e^{-\hat{y}_i})+
    (1-y_i)\mathrm{ln}(1+e^{\hat{y}_i})]. \end{aligned} $$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/506524_1_En_5_Chapter/506524_1_En_5_Chapter_TeX_Equ2.png)(5.2)As
    for the regulation term, the first thing to do is redefining a tree that is convenient
    to measure the complexity. In XGBoost, a tree is a function that maps an instance
    to a leaf weight. Specifically,!['
  prefs: []
  type: TYPE_NORMAL
- en: '$$\displaystyle \begin{aligned} f(x) = \omega_{q(x)},\ \ \omega \in R^T,\ q\
    : R^d\rightarrow \ \{1,2,\ldots,T\}, \end{aligned} $$'
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/506524_1_En_5_Chapter/506524_1_En_5_Chapter_TeX_Equ3.png)(5.3)where
    *ω* is the leaf weight of the tree, *T* is the number of leafs, and *q* stands
    for the tree structure. The complexity of the tree is defined as!['
  prefs: []
  type: TYPE_NORMAL
- en: $$\displaystyle \begin{aligned} \Omega(f) = \gamma T + \frac{1}{2} \lambda\sum_{j=1}^T
    \omega_j^2, \end{aligned} $$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/506524_1_En_5_Chapter/506524_1_En_5_Chapter_TeX_Equ4.png)(5.4)'
  prefs: []
  type: TYPE_NORMAL
- en: where *γ* and *λ* are parameters of the model.
  prefs: []
  type: TYPE_NORMAL
- en: To ensemble trees, the objective function is rewritten as follows:![
  prefs: []
  type: TYPE_NORMAL
- en: $$\displaystyle \begin{aligned} Obj= \sum_{i=1}^n l(y_i,\hat{y}_i) + \sum_{k=1}^K\Omega(f_k),
    \end{aligned} $$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/506524_1_En_5_Chapter/506524_1_En_5_Chapter_TeX_Equ5.png)(5.5)'
  prefs: []
  type: TYPE_NORMAL
- en: where ![
  prefs: []
  type: TYPE_NORMAL
- en: $$\hat {y}_i = \sum _{k=1}^K f_k(x_i)$$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/506524_1_En_5_Chapter/506524_1_En_5_Chapter_TeX_IEq1.png), *K*
    is the number of trees.'
  prefs: []
  type: TYPE_NORMAL
- en: For the learning process, XGBoost introduces *additive training*, which starts
    from constant prediction and adds new function each time as follows:![
  prefs: []
  type: TYPE_NORMAL
- en: $$\displaystyle \begin{aligned} \hat{y}_i^{(0)} &amp;= 0 \\ \hat{y}_i^{(1)}
    &amp;= f_1(x_i) = \hat{y}_i^{(0)}+f_1(x_i) \\ \hat{y}_i^{(2)} &amp;= f_1(x_i)
    + f_2(x_i) = \hat{y}_i^{(1)} + f_2(x_i)\\ &amp; \cdots \\ \hat{y}_i^{(t)} &amp;=
    \sum_{k=1}^t f_k(x_i) = \hat{y}_i^{(t-1)} + f_t(x_i). \end{aligned} $$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/506524_1_En_5_Chapter/506524_1_En_5_Chapter_TeX_Equ6.png)(5.6)By
    applying the above equations, the objective function can be written as!['
  prefs: []
  type: TYPE_NORMAL
- en: $$\displaystyle \begin{aligned} Obj^{(t)} = \sum_{i=1}^n l(y_i,\hat{y}_i^{(t-1)}
    + f_t(x_i)) + \Omega(f_t) + constant, \end{aligned} $$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/506524_1_En_5_Chapter/506524_1_En_5_Chapter_TeX_Equ7.png)(5.7)'
  prefs: []
  type: TYPE_NORMAL
- en: and XGBoost aims to find the best *f* [*t*] to minimize this function at each
    step. To grow the tree, it tries to add the best split of a feature that maximizes
    *gain* on each leaf nodes. XGBoost adopts the post-pruning method, growing a tree
    to maximum depth and then recursively pruning all the leaf splits with negative
    gain.
  prefs: []
  type: TYPE_NORMAL
- en: 5.3.4 Experimental Results and Feature Analysis
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we present our experimental results. First, we describe the
    experiment settings and evaluation metrics. Then, the experiments based on the
    comparison of the two categories of extracted features are summarized. Finally,
    we analyze the importance of features.
  prefs: []
  type: TYPE_NORMAL
- en: 5.3.4.1 Experiment Setting
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'DatasetsIn order to compare the discriminative power of these two types of
    features, we used the following three kinds of features to conduct corresponding
    experiments: account, opcode, and the combination of both. For these three experiments,
    we used fivefold cross-validation to find the best parameters for the model. Then
    we divided the corresponding data into 80% as the training set and 20% as the
    test set, and we used the best parameters found to conduct ten experiments. The
    average result of the experiment is displayed in Table [5.2](#Tab2).Table 5.2'
  prefs: []
  type: TYPE_NORMAL
- en: A feature performance comparison
  prefs: []
  type: TYPE_NORMAL
- en: '| Features | Precision | Recall | F-score |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Account | 0.74 | 0.32 | 0.44 |'
  prefs: []
  type: TYPE_TB
- en: '| Opcode | 0.90 | 0.80 | 0.84 |'
  prefs: []
  type: TYPE_TB
- en: '| Account + opcode | 0.94 | 0.81 | 0.86 |'
  prefs: []
  type: TYPE_TB
- en: Evaluation Metrics
  prefs: []
  type: TYPE_NORMAL
- en: Different from the commonly used metrics of error rate in classification problems,
    we use three metrics, precision, recall, and F-score, to evaluate the performances
    of the model.
  prefs: []
  type: TYPE_NORMAL
- en: 5.3.4.2 Results Summary
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Table [5.2](#Tab2) summarizes the performances of the three kinds of features
    in detecting smart Ponzi schemes. Several conclusions can be conducted from the
    table. First of all, surprisingly, the account feature in this experiment is not
    effective. We expect that the account feature will have a good performance because
    in the above analysis we found that the two categories of contracts have significant
    differences in this regard. However, the low recall indicates that the model trained
    with only account features is unable to distinguish Ponzi scheme contracts from
    non-Ponzi scheme contracts. On the contrary, opcode features are very efficient
    in the classification. The reason for this result may be that many smart contracts
    are still experimental, which makes it difficult to detect their type from their
    behavior. In fact, many smart contracts have no transaction records. Another possible
    reason is that, compared to the opcode feature, the number of account features
    is too small. Besides, the corresponding metrics show that a model trained with
    only opcode features can be useful in Ponzi scheme contract detection. Finally,
    the performance of such a model can be improved by combining opcode features with
    account features.
  prefs: []
  type: TYPE_NORMAL
- en: 5.3.4.3 Feature Analysis
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To further understand the discriminative power of the extracted features, we
    display the ten most significant features in Fig. [5.6](#Fig6). The description
    of opcodes in the graph are summarized in Table [5.3](#Tab3).![../images/506524_1_En_5_Chapter/506524_1_En_5_Fig6_HTML.png](../images/506524_1_En_5_Chapter/506524_1_En_5_Fig6_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 5.6
  prefs: []
  type: TYPE_NORMAL
- en: The importance of the ten most significant features
  prefs: []
  type: TYPE_NORMAL
- en: Table 5.3
  prefs: []
  type: TYPE_NORMAL
- en: Opcode and its description
  prefs: []
  type: TYPE_NORMAL
- en: '| Opcode | Description |'
  prefs: []
  type: TYPE_TB
- en: '| GASLIMIT | Get the block’s gas limit |'
  prefs: []
  type: TYPE_TB
- en: '| EXP | Exponential operation. |'
  prefs: []
  type: TYPE_TB
- en: '| CALLDATALOAD | Get input data of current environment |'
  prefs: []
  type: TYPE_TB
- en: '| SLOAD | Load word from storage |'
  prefs: []
  type: TYPE_TB
- en: '| CALLER | Get caller address |'
  prefs: []
  type: TYPE_TB
- en: '| LT | Less-than comparision |'
  prefs: []
  type: TYPE_TB
- en: '| GAS | Get the amount of available gas |'
  prefs: []
  type: TYPE_TB
- en: '| MOD | Modulo remainder operation |'
  prefs: []
  type: TYPE_TB
- en: '| MSTORE | Save word to memory |'
  prefs: []
  type: TYPE_TB
- en: It can be seen clearly that the most important feature is GASLIMIT, which is
    an instruction used to obtain the gas limit of a block. In order to better understand
    why GASLIMIT is the most important feature, we first calculated the number of
    smart contracts that use this instruction. We found that 57% of Ponzi scheme contracts
    are using this instruction, while only 4% non-Ponzi scheme contracts are using
    it. Therefore, compared with non-Ponzi scheme contracts, Ponzi scheme contracts
    are more inclined to refer to the gas limit of the block. However, this conclusion
    is somehow against common sense because the Ponzi scheme logic does not need to
    obtain the gas limit of the block. In order to find the real reason, we selected
    the source codes of some Ponzi scheme contracts that use the GASLIMIT instruction
    to find out what kind of source codes will lead to this instruction. As a result,
    we found that these contracts usually use Oracle’s APIs, which results in the
    GASLIMIT opcode.
  prefs: []
  type: TYPE_NORMAL
- en: Another opcode worth noting is CALLER, which is an instruction used to get the
    caller’s address. Note that Ponzi scheme contracts need to record the addresses
    of investors in order to pay the money back to them in the future. The rest opcodes
    are mainly related to arithmetic operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, these instructions seem to reflect a special type of contract:
    these contracts have more payment transactions, need to remember the address of
    the caller, and are mainly composed of arithmetic calculations. As expected, Ponzi
    scheme contracts belong to this type of contract.'
  prefs: []
  type: TYPE_NORMAL
- en: For account features, only one feature (D_ind) is found in the top ten most
    important features. This is not a surprising result, because as analyzed in Sect.
    [5.3.3.2](#Sec13), the difference between Ponzi scheme contracts and non-Ponzi
    scheme contracts is very significant in this feature.
  prefs: []
  type: TYPE_NORMAL
- en: 5.3.4.4 Application
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In order to estimate the total number of Ponzi scheme contracts on Ethereum,
    a previous study has compared the similarity between their bytecodes to detect
    hidden Ponzi scheme contracts (Ponzi scheme contracts without publicly accessible
    source codes) (Bartoletti et al. [2020](#CR6)). Fifty four hidden Ponzi scheme
    contracts were discovered by the research. In order to verify the reliability
    of our method by comparing with the previous study, we used only code features
    to predict these 54 hidden Ponzi scheme contracts. The results show that 45 of
    54 contracts (83%) are classified as Ponzi scheme contracts by our model. In order
    to understand why the remaining 9 contracts were not recognized by our model,
    we manually checked their transaction records. The findings are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Two contracts actually have source codes.^([9](#Fn9)) They refer to the same
    project on github.^([10](#Fn10)) By reading the introduction page and checking
    the source codes, one can find that it is not a smart Ponzi scheme but a kind
    of game. Our model successfully excludes it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A contract^([11](#Fn11)) interacted with only the creator. Though we cannot
    say that it is not a smart Ponzi scheme, it seems more like a test-transaction-contract
    from the transaction records. Another contract,^([12](#Fn12)) which have 5 successful
    transactions but only one payment to an unacquainted address, is possibly not
    a smart Ponzi scheme as the balance is relatively large and the transaction pattern
    is not conformed to any kind of smart Ponzi schemes summarized in Bartoletti et
    al. ([2020](#CR6)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A contract,^([13](#Fn13)) which has only one transaction with amount large than
    0 (including normal and fired transactions) and all the fired transactions are
    function call from unknown accounts, cannot be a smart Ponzi scheme. A similar
    situation can be found in another contract.^([14](#Fn14))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The order of payments in the two contracts^([15](#Fn15)) is strange. There are
    only a few participants, but anterior participants receive payments later than
    posteriors, which indicates that they are probably not smart Ponzi schemes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last contract,^([16](#Fn16)) which has similar behavior with smart Ponzi
    schemes but more payments than investments, is hard to draw a conclusion.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These findings indicate that our model can detect Ponzi scheme contracts more
    accurately than comparing the similarity between bytecodes.
  prefs: []
  type: TYPE_NORMAL
- en: In order to estimate the number of Ponzi scheme contracts running on Ethereum,
    we first downloaded all the contracts created before May 7, 2017 (the same date
    range as in (Bartoletti et al. [2020](#CR6))). We obtained 280704 contracts in
    total. According to our proposed model, we extracted the corresponding opcode
    features from the bytecodes of these contracts and then used these features to
    make predictions. Our model found 386 Ponzi scheme contracts (including verified
    ones). Therefore, it is estimated that there may be 434 (386 × *precision* ÷ *recall*)
    Ponzi schemes running on Ethereum, accounting for 0.15% of the total number of
    contracts before May 7, 2017\. Figure [5.7](#Fig7) illustrates the number of Ponzi
    scheme contracts under each score (probabilities) predicted by the model. It can
    be seen that most of the contracts have high scores, indicating that the problem
    may be more serious than expected. In fact, only 191 Ponzi scheme contracts have
    been discovered in recent study (Bartoletti et al. [2020](#CR6)), which is a number
    much smaller than our estimate.![../images/506524_1_En_5_Chapter/506524_1_En_5_Fig7_HTML.png](../images/506524_1_En_5_Chapter/506524_1_En_5_Fig7_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 5.7
  prefs: []
  type: TYPE_NORMAL
- en: The number of detected smart Ponzi schemes and scores (probability)
  prefs: []
  type: TYPE_NORMAL
- en: 5.3.5 Related Work
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since the creation of Bitcoin, blockchain technology became a research hotspot.
    Three types of research can be found in the literature. The first type focuses
    on the underlying mechanism. Many consensus mechanisms were proposed, such as
    proof of stake (PoS) (King and Nadal [2012](#CR39)), practical byzantine fault
    tolerance (PBFT) (Hyperledger [2015](#CR32); Mazieres [2015](#CR47)), and ripple
    (Schwartz et al. [2014](#CR63)). Furthermore, some research focused on improving
    the existing mechanism (Decker et al. [2016](#CR24)). The second type discusses
    the application of blockchain technology. Since blockchain technology has many
    favorable characteristics, many applications can be found in finance service (Kondor
    et al. [2016](#CR42); Peters and Panayi [2016](#CR58)), Internet of Things (IoT)
    (Christidis and Devetsikiotis [2016](#CR19); Conoscenti et al. [2016](#CR23)),
    and social services (Namecoin [2014](#CR54)). The last but the most related type
    of work is data mining on blockchain. Thanks to the publicly accessible characteristic,
    blockchain provides an unprecedented opportunity for data analysis to answer various
    questions, for example, usage characteristic (Meiklejohn et al. [2016](#CR49);
    Ron and Shamir [2013](#CR62); Yelowitz and Wilson [2015](#CR71)) , anonymity (Androulaki
    et al. [2013](#CR2); Reid and Harrigan [2013](#CR60)), and economic behavior analysis
    (Kondor et al. [2014a](#CR40),[b](#CR41)). More information can be found in the
    survey (Zheng et al. [2017](#CR73)).
  prefs: []
  type: TYPE_NORMAL
- en: With the development of the Internet, online “high-yield” investment program
    (HYIP) has become a typical form of Ponzi schemes. A preliminary analysis was
    provided on economic aspects of it by using data collected from HYIP websites
    (Moore et al. [2012](#CR51)). More detailed research was conducted in (Neisius
    and Clayton [2014](#CR55)), where a model was set out to estimate the turnover
    and profits of HYIPs. Both papers focused on HYIPs which use centralized virtual
    currencies. The creation of blockchain technology makes cryptocurrency an ideal
    currency for scammers. In blockchain, the ledger records every transaction, and
    these transactions can be accessed publicly. Valuable data can thus be obtained
    by researchers to investigate scams on blockchain. Among different scams, Bitcoin
    is the most notable one (Christin [2013](#CR20); Moore and Christin [2013](#CR50);
    Moser et al. [2013](#CR53)). Marie Vasek and Tyler Moore provided an empirical
    analysis of Bitcoin-based scams (Vasek and Moore [2015](#CR67)). They found 32
    HYIPs and estimated more than 4 million USD involved. A recent study focused on
    the economic aspects of smart Ponzi schemes (Bartoletti et al. [2020](#CR6));
    they use *normalized Levenshtein distance* (Yujian and Bo [2017](#CR72)) as a
    measure of similarity between bytecodes to detect hidden smart Ponzi schemes.
    Different from their study, this work focused on finding a verifiable method to
    detect smart Ponzi schemes in bytecodes.
  prefs: []
  type: TYPE_NORMAL
- en: 5.3.6 Future Work
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Financial scams based on blockchain and cryptocurrency have become an important
    research problem. With the development of blockchain technology, Ponzi scheme
    is now under the veil of smart contracts. In the future, we are going to further
    this study in three aspects. Firstly, to extend the ground truth data and improve
    the classification model. As the number of smart contracts having source codes
    keep increasing every day, it is possible to extend the ground truth data by manually
    checking the source codes. With more ground truth data, more accurate and credible
    model can be developed. Secondly, to build a unified platform to evaluate and
    score every smart contract for every possible scam. We have noticed that there
    is an open-source project on Github to keep track of all the current Ethereum
    scams.^([17](#Fn17)) However, the website collects data by manual user reports
    and combines them. We are trying to establish a similar website focusing on detecting
    smart contracts by data mining methods. Thirdly, to study other kinds of scams.
    Except for smart Ponzi scheme, many other scams are taking the advantage of blockchain
    technology. It is necessary to study this question to promote the development
    of blockchain technology.
  prefs: []
  type: TYPE_NORMAL
- en: '5.4 Case Study: Phishing Scam Detection'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 5.4.1 Phishing Scams on Ethereum
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As for cryptocurrencies based on blockchain technology, financial security plays
    the role of a crucial foundation. However, the rapidly increasing fraud in the
    cryptocurrency system undoubtedly hinders the acceptance of users and the further
    application of blockchain technology, thereby hindering the development of blockchain
    technology. Therefore, identifying such scams becomes an important and urgent
    task, which has attracted great attention from researchers (Bartoletti et al.
    [2020](#CR6); Chen et al. [2018b](#CR16)). Among the many scams, phishing scams
    are a new form of online fraud. It was born with the widespread of online business
    (Liu and Ye [2001](#CR45)) and has now been found in the blockchain system. According
    to *Chainalysis*, more than 50% of cybercrime profits have come from phishing
    scams since 2017.^([18](#Fn18)) The phishing scams on Bee Token ICO^([19](#Fn19))
    has played a well-known role in blockchain scams. The scammers defrauded about
    $1 million in this incident in just 25 h. From this point of view, detecting phishing
    scams on the blockchain is an important and urgent challenge.
  prefs: []
  type: TYPE_NORMAL
- en: The traditional phishing frauds usually create a fake official website, and
    then lure users to log in to obtain the user’s private information, such as passwords.
    Therefore, the main approach to deal with traditional phishing fraud is to identify
    fake websites and warn users before logging in. On the other hand, phishing scams
    deployed on the blockchain have shown various new characteristics. Firstly, the
    cryptocurrency possessed by the user becomes the target of the new phishing scams,
    not private information. Under normal circumstances, phishing scammers will use
    a variety of methods to lure users to transfer money to a particular address,
    as happened in the Bee Token ICO incident. Besides, the cryptocurrency obtained
    from the fraud needs to be cashed out to fiat money through exchanges. Finally,
    all transaction records on the public blockchain are transparent and publicly
    accessible, thus providing a new data basis for detecting phishing fraud.
  prefs: []
  type: TYPE_NORMAL
- en: Based on these new characteristics of phishing scams on the blockchain, we propose
    a method to identify phishing scams on the blockchain, based on transaction records
    and machine learning technology. Such a method can be integrated into the blockchain
    wallet (i.e., tools for managing accounts and transactions on the blockchain)
    as a warning function to detect latent phishing scams and warn users before conducting
    transactions with unfamiliar accounts. The overall framework of the method is
    shown in Fig. [5.8](#Fig8), and the Ethereum platform is used to demonstrate the
    effectiveness of our method. In general, we first downloaded the transaction records
    on Ethereum from the Ethereum client Parity and then crawled all the phishing
    account information from Etherscan.io. Then we alleviate the problem of class
    imbalance in the machine learning field based on common sense and some machine
    learning methods. On this basis, we established a transaction graph based on transaction
    records and proposed a graph-based cascade feature extraction method. Next, we
    proposed a Dual-sampling Ensemble framework to detect suspect accounts. Finally,
    we compared the proposed method with other methods to demonstrate the effectiveness
    of our method. The performance of this model is evaluated under different parameters
    and the effectiveness of the features is also discussed.![../images/506524_1_En_5_Chapter/506524_1_En_5_Fig8_HTML.png](../images/506524_1_En_5_Chapter/506524_1_En_5_Fig8_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 5.8
  prefs: []
  type: TYPE_NORMAL
- en: The framework
  prefs: []
  type: TYPE_NORMAL
- en: In summary, we make the following major contributions in this section.
  prefs: []
  type: TYPE_NORMAL
- en: We propose a systematic approach to detect phishing scams in the blockchain
    ecosystem, and take Ethereum as an example to verify the effectiveness. The approach
    has good performance, which indicates that our method can be embedded into users’
    cryptocurrency wallets to provide users with a financial risk warning function.
    To accelerate the research in this field and promote the healthy development of
    blockchain technology, all relevant data and code will be released after the book
    is published.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We propose a graph-based cascade feature extraction method, which can conveniently
    extract rich transaction structure information and form a feature set with a good
    classification effect. Besides, it is very scalable and hard to evade according
    to the “six-degree separation” theorem.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We propose a new model integration algorithm, namely the Dual-sampling Ensemble
    algorithm, which can be used for classification problems with a high level of
    class imbalance. The evaluation results show the effectiveness of the algorithm.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.4.2 Background and Related Work
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Blockchain technology is a key support technology for cryptocurrencies such
    as Bitcoin.^([20](#Fn20)) A blockchain can be seen as a common ledger maintained
    between peers that do not need to trust each other (Zheng et al. [2017](#CR73)).
    The number of cryptocurrencies held by the user and transactions on the blockchain
    are recorded in this ledger. In this system, users are represented by a pair of
    public-private key pairs. The public key, which plays the role of an account like
    it is in the banking system, is a representation of the user in the blockchain,
    and is often referred to as an address. (In this chapter, we use the term address
    and account interchangeably.) In blockchain systems, transactions are messages
    sending from one account (the initiator’s address) to another (the receiver’s
    address) (Chen et al. [2018b](#CR16)). Typically, the initiator transfers a certain
    amount of cryptocurrency to the recipient. Transactions that occur over a period
    are packaged into blocks by peers and linked to the previous block through cryptography.
    Each block has a corresponding height (denoted as *blockNumber* in this chapter),
    increasing by 1 from 0\. The block height can be viewed as the time when the transaction
    took place. From this point of view, the height of the block can be regarded as
    the time when the transaction occurs, and the transaction on the block with a
    larger height occurs later than the transaction on the block with a smaller height.
  prefs: []
  type: TYPE_NORMAL
- en: Generally speaking, the Bitcoin system generates a new block in 10 min, while
    the time in Ethereum is about 15 s. Because of its support for smart contracts
    (Wood [2014](#CR70)), Ethereum is known as the second-generation blockchain technology,
    with *Ether* being the cryptocurrency it maintains. A smart contract is an executable
    script stored on the blockchain. Ethereum provides a Turing-complete virtual machine
    (Ethereum Virtual Machine) to support the execution of these scripts. The smart
    contracts are stored on the blockchain in the form of bytecodes. A smart contract
    starts to run when it receives a message call pointing to the contract address
    and terminates when a given condition is met. In fact, Ethereum has become the
    largest blockchain platform that supports smart contracts, and it is also one
    of the main targets for various cyberattacks against the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: In recent years, with the development of blockchain technology, financial security
    in the blockchain ecosystem has received extensive attention, and the identification
    of various fraudulent behaviors has become a research hotspot. In the Bitcoin
    ecosystem, (Vasek and Moore [2015](#CR67)) present the first empirical analysis
    of Bitcoin-based scams. The authors identify 192 scams and point out that at least
    13,000 distinct victims lost more than $11 million. (Vasek and Moore [2018](#CR68))
    analyze the supply and demand for Bitcoin-based Ponzi schemes, while (Bartoletti
    et al. [2018](#CR5)) establish an address identification model for Ponzi scheme
    in the Bitcoin ecosystem. Besides, (Chen et al. [2019a](#CR17)) show that there
    are market manipulation in the Bitcoin exchange Mt. Gox. In the Ethereum ecosystem,
    on the one hand, people are concerned with the identification of various scams,
    for example, smart Ponzi schemes (Bartoletti et al. [2020](#CR6); Chen et al.
    [2018b](#CR16)). On the other hand, since most smart contracts control certain
    digital assets, ensuring that there are no vulnerabilities in the smart contracts
    is an important part of Ethereum’s financial security (Kalra et al. [2018](#CR35)).
  prefs: []
  type: TYPE_NORMAL
- en: Phishing detection has been extensively studied in the past decades and many
    methods have been proposed (Abdelhamid et al. [2014](#CR1); Khonji et al. [2013](#CR38);
    Zouina and Outtaj [2017](#CR74)). However, there is seldom research on phishing
    fraud identification considering the characteristics of blockchain. Andryukhin
    ([2019](#CR3)) classifies the main types and schemes of phishing attacks on the
    blockchain project and suggests methods of protection against phishing attacks
    from the blockchain project side’s perspective. Unlike them, we are targeting
    the entire blockchain ecosystem and providing users with an early warning against
    phishing scams.
  prefs: []
  type: TYPE_NORMAL
- en: 5.4.3 Proposed Method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Identifying phishing accounts in the blockchain system faces two challenges:
    (1) we only have transaction records and know little about account functions and
    holder information; and (2) the number of phishing addresses is very few and other
    addresses are huge, identifying such a small group of accounts in the huge account
    set is like looking for a needle in the haystack. (The details of the data are
    described in Sect. [5.4.4](#Sec29).) To meet the challenges, the proposed method
    includes two parts, the cascade feature extraction method and the LightGBM-based
    Dual-sampling Ensemble algorithm.'
  prefs: []
  type: TYPE_NORMAL
- en: 5.4.3.1 Cascade Feature Extraction Method
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since transaction records are the only information we can use, and they give
    the accounts a natural graphical structure, to extract effective features, we
    first construct a transaction graph (TG) based on these transaction records. Specifically,
    *TG* = (*V*, *E*), where *V* is a set of nodes (all the addresses in the dataset)
    and *E* = {(*v* [*i*], *v* [*j*])|*v* [*i*], *v* [*j*] ∈ *V* } is a set of ordered
    edges. Each edge indicates that an address *V* [*i*] transfers a certain amount
    of Ether to another address *V* [*j*]. Each edge has two attributes: *blockNumber*
    and *amount*, representing the time when this edge emerges and the amount of the
    transaction. Please note that there may be multiple edges between two nodes in
    TG, depending on the number of transactions between the two related accounts.
    (We use account, address, and node interchangeably in the following.) Next, we
    introduce the proposed feature extraction method.'
  prefs: []
  type: TYPE_NORMAL
- en: Graph-based features have proven to be very effective in many identification
    problems (Chatzakou et al. [2017](#CR11); Ramalingam and Chinnaiah [2018](#CR59)).
    Thus, we propose a TG-based *cascade feature extraction* method for phishing account
    identification. The idea is as follows. Treat the transaction between accounts
    as a *friend* relationship, to judge the category of an account, we can use not
    only the information of the account, but also the information of its friends,
    even the information of its friends’ friends, and so on. To explain more clearly,
    we first define several keywords related to a node.
  prefs: []
  type: TYPE_NORMAL
- en: '*Node data*: Node data is the transaction history of that node. Each transaction
    contains information about the time, direction, and amount of the transaction.
    The transaction time is denoted as *blockNumber*, which is an increasing integer.
    A transaction has two directions: *out* and *in*. The out-transactions of an account
    transfer Ether from the account to other accounts and the in-transactions of an
    account receive Ether from other accounts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Node features*: Node features are all kinds of information extracted from
    node data. In this chapter, we extract information through various statistical
    methods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*N-order friend*: A node’s 1-order friend is a node directly connected to the
    node (i.e., there are transactions between them). A node’s n-order friend is a
    node connected to the node with at least n-1 nodes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*N-order features*: The 0-order features of a node is the node features of
    that node. The n-order features are extracted in cascade from the n-order friends.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To explain how to achieve cascade feature extraction, we show the procedure
    of 2-order features extraction in Fig. [5.9](#Fig9). Suppose we need to compute
    the 2-order features of node *A*, which have 1-order friends *B, C* and 2-order
    friends *D, E, F, G, H*. In the figure, each undirected edge represents one or
    more transactions (regardless of the directions) between two nodes, and the counterparty
    of the 2-order friends is not shown. The procedure is divided into three stages.
    In the first stage, we compute a statistic (i.e., the gray rectangle) for each
    2-order friends by using its node data (i.e., the transaction history). The second
    stage needs to calculate a statistic for each 1-order friend by using the statistics
    computed in the first stage (not the node data of the 1-order friend). Similarly,
    in the last stage, we still calculate a statistic whose input comes from the second
    stage. This approach is very scalable. In fact, by increasing the order and using
    different statistic methods at different stages, we can extract rich information
    about how a node interacts with the entire network. It should be noted that the
    approach we describe here does not take into account the direction of the transaction.
    But, for phishing accounts, in-transactions and out-transactions are significantly
    different in meaning. Therefore, in this chapter, we extract features for two
    different directions respectively.![../images/506524_1_En_5_Chapter/506524_1_En_5_Fig9_HTML.png](../images/506524_1_En_5_Chapter/506524_1_En_5_Fig9_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 5.9
  prefs: []
  type: TYPE_NORMAL
- en: Example of 2-order feature extraction procedure
  prefs: []
  type: TYPE_NORMAL
- en: 'The node features are statistics of its node data. There are two *types* of
    data: transaction amount and transaction times (i.e., *block*Number). In order
    to distinguish the nature of the transaction, statistics are made in different
    *directions* (i.e., *out*-transactions or *in*-transactions). For convenience,
    we name these features as *direction_type_method*. For example, a feature *in_block_std*
    of a node indicates the standard deviation (i.e., the method *sd*) for the transaction
    time (i.e., the type of data *block*) of all in-transactions (i.e., the transaction
    direction *in*). For the transaction time, we compute only the transaction time
    span (denoted as *ptp*) and its standard deviation (denoted as *sd*). For the
    transaction amount, we calculated the sum, the maximum, the minimum, the mean,
    and the standard deviation (i.e., *sd*). In addition, there are statistics unrelated
    to transaction amount: *count*, *unique*, and *unique_ratio*. They represent the
    number of transactions (i.e., *count*), the number of counterparties (i.e., *unique*),
    and the ratio of the two (i.e., *unique*∕*count*). By doing so, we obtained 19
    features (i.e., 2 × 1 × (2 + 5 + 2) + 1).'
  prefs: []
  type: TYPE_NORMAL
- en: 'For simplicity, in this study, we extract only 1-order network features. As
    mentioned, the direction of the transaction is important in identifying phishing
    scams. Thus, considering the transaction direction, the 1-order friends of a node
    can be divided into *from* friends and *to* friends. In simple terms, when there
    is a transfer transaction from node *A* to node *B*, we call node *B* a *from*
    friend of node *A* and node *A* a *to* friend of node *B*. Specifically, the 1-order
    network features are named as *friend_direction_statistic2_statistic1*. For example,
    the *from_in_mean_max* feature is calculated as follows: we first compute the
    maximum (i.e., *max*) of the *in*-transaction amounts for each *from* friend.
    Then, we compute the *mean* of all statistics in the previous stage. Similarly,
    to compute *to_out_std_sum*, we first compute the *sum* of all the *out*-transaction
    amounts for each *to* friend. Then, we compute the standard deviation (i.e., *sd*)
    of all statistics in the previous stage. By doing so, we can obtain 200 features
    (i.e., 2 × 2 × 2 × 5 × 5). Please note that we did not take time into account
    in the 1-order network feature extraction.'
  prefs: []
  type: TYPE_NORMAL
- en: 5.4.3.2 Dual-Sampling Ensemble Method
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Identifying phishing scams is essentially establishing a classification model
    of addresses. But the phishing account identification faces a class imbalance
    problem. To build a useful suspect identification model, we propose a Dual-sampling
    Ensemble method, an identification framework integrated with many base models
    trained by sampling examples and features.
  prefs: []
  type: TYPE_NORMAL
- en: The base models play a central role in the identification framework. Many mature
    classification algorithms can be used as base models, such as logistic regression
    (LR), support vector machine (SVM), and decision tree (DT). Among these models,
    the gradient boosting decision tree (GBDT) obtained good results in many problems.
    There are several different variants of GBDT, including XGBoost (Chen and Guestrin
    [2016b](#CR13)) and LightGBM (Ke et al. [2017](#CR36)), which are widely used
    and generally accepted. In the phishing detection problem, we found that LightGBM
    is more efficient, thus we select it as our base model.
  prefs: []
  type: TYPE_NORMAL
- en: Given the supervised training set *X* = {(*x* [*i*], *y* [*i*]), *i* = 1, 2,
    ⋯ , *n*}, LightGBM integrates a number of K regression trees ![
  prefs: []
  type: TYPE_NORMAL
- en: $$f(x)=\frac {1}{K}\sum _{i=1}^Th_i(x) $$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/506524_1_En_5_Chapter/506524_1_En_5_Chapter_TeX_IEq2.png) to approximate
    a certain function *f* ^∗(*x*) that minimizes the expected value of a specific
    loss function *L*(*y*, *f*(*x*)). In each iteration of GBDT, assume that the strong
    learner obtained by the previous iteration is *h* [*t*−1](*x*), the loss function
    is *L*(*f*(*x*), *h* [*t*−1](*x*)), then the aim for the current iteration is
    to find a week learner using CART regression tree model which is denoted as *h*
    [*t*](*x*), to minimize the formula *L*(*f*(*x*), *h* [*t*−1](*x*) + *h* [*t*](*x*)).
    Suppose in iteration *t*, the negative gradient for sample *i* can be represented
    as !['
  prefs: []
  type: TYPE_NORMAL
- en: $$r_{ti}=\frac {\partial L(y_i,h_{t-1}(x_i))}{\partial h_{t-1}(x_i)}.$$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/506524_1_En_5_Chapter/506524_1_En_5_Chapter_TeX_IEq3.png) By using
    the Log-likelihood loss as loss function*L*(*y*, *h*(*x*)) = *log*(1 + *exp*(−*yh*(*x*))),
    where *y* ∈ [−1, 1], we can simplify the negative gradient of sample as below:!['
  prefs: []
  type: TYPE_NORMAL
- en: $$\displaystyle \begin{aligned}r_{ti}=-\frac{\partial L(y_i,h_{t-1}(x_i))}{\partial
    h_{t-1}(x_i)}=\frac{y_i}{1+exp(y_ih(x_i))},\end{aligned}$$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/506524_1_En_5_Chapter/506524_1_En_5_Chapter_TeX_Equb.png)'
  prefs: []
  type: TYPE_NORMAL
- en: where *i* = 1, 2, ⋯ , *m*.
  prefs: []
  type: TYPE_NORMAL
- en: By using the formula, LightGBM chooses to remove these small gradient samples
    from the training set to make the model pay more attention to those samples which
    cause great loss. This technique is called Gradient-based One-Side Sampling (GOSS)
    (Ke et al. [2017](#CR36)). When constructing the CART regression tree, LightGBM
    binds the mutual exclusion features so that the number of features (the leaves)
    can be greatly reduced.
  prefs: []
  type: TYPE_NORMAL
- en: Inspired by *EasyEnsemble* (Liu et al. [2008](#CR46)), we propose a Dual-sampling
    Ensemble algorithm to solve the class imbalance problem in the phishing scam identification.
    The pseudocode is shown in Algorithm [5.1](#FPar2).
  prefs: []
  type: TYPE_NORMAL
- en: Algorithm 5.1 The Dual-sampling Ensemble algorithm![../images/506524_1_En_5_Chapter/506524_1_En_5_Figd_HTML.png](../images/506524_1_En_5_Chapter/506524_1_En_5_Figd_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: The idea behind the Dual-sampling Ensemble is simple. Similar to *EasyEnsemble*
    (Liu et al. [2008](#CR46)), we reduce the class imbalance by sampling the majority
    example set (i.e., negative examples). The difference is that we also sample the
    features of the examples in the training set since we can obtain a large number
    of features by using the cascade feature extraction method. This dual-sampling
    method allows the base models to have better heterogeneity.
  prefs: []
  type: TYPE_NORMAL
- en: 5.4.4 Data Collection and Preparation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 5.4.4.1 Data Collection
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We launch an Ethereum client, Parity,^([21](#Fn21)) on our server to download
    the ledger of Ethereum. By using Parity, we obtained all the Ethereum blocks before
    January 3, 2019 (to be exact, from block height 0 to block height 7,000,000).
    By analyzing the transactions obtained, we get 43,783,194 accounts, among which
    1,564,580 accounts controlled by smart contracts.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most important tasks in establishing a phishing scam identification
    model is to find enough phishing account examples. Fortunately, etherscan.io provides
    several tags for Ethereum addresses, and by crawling the website, we obtain all
    the addresses labeled with Phishing.^([22](#Fn22)) These addresses are used in
    some verified phishing scams. In this way, we obtain 1,683 phishing addresses.
    We call these phishing addresses as *positive* examples and the rest as *negative*
    examples.
  prefs: []
  type: TYPE_NORMAL
- en: 5.4.4.2 Data Cleaning
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After getting all the data, we found that the class was very imbalanced. The
    class imbalance ratio, i.e., the ratio of the size of the majority class (negative
    examples) to minority class (positive examples), exceeds 26,000\. Given that some
    addresses are not phishing addresses, we recommend that some obvious negative
    examples (i.e., non-phishing addresses) be eliminated before model training in
    order to build a more effective model. To this end, we (1) filter transaction
    records involving a smart contract address, (2) eliminate addresses with less
    than 10 or more than 1000 transaction records, and (3) ignore all transactions
    that appear before block height 2 million.
  prefs: []
  type: TYPE_NORMAL
- en: The above selection method is based on the following facts. First of all, smart
    contracts are usually composed of complex logical structures, so they are not
    very suitable for phishing fraud. According to the data collected, smart contracts
    account for only a small percentage (i.e., 2.6%) of phishing addresses, and these
    accounts are usually related to tokens. Therefore, in this preliminary study,
    we removed the smart contract for simplicity. Second, we expect to learn the transaction
    behavior characteristics of phishing addresses in this research. Under this consideration,
    addresses with too few transaction records are not conducive to our study. On
    the other hand, an address with an excessive number of transactions usually means
    that the account is a cryptocurrency wallet or other type of account. In fact,
    there are more than 70% of accounts which have more than 1000 transaction records,
    but only one account is labeled as a phishing address. Finally, we found that
    all the phishing addresses were active after August 2, 2016\. According to the
    analysis of initial activity time, the possible reason for this phenomenon is
    that in the early stage of Ethereum, there were relatively few phishing scams,
    and even fewer phishing scams were recorded during that period. Therefore, we
    proposed to build the model based on records after block height of 2 million (i.e.,
    2016-08-02). These filtering rules allow the model to focus on learning the characteristics
    of phishing scams.
  prefs: []
  type: TYPE_NORMAL
- en: 5.4.5 Experiment Result and Analysis
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 5.4.5.1 Experiment Settings
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We downloaded all of Ethereum’s transaction data from its inception to January
    3, 2019 (i.e., from block height 0 to block height 7,000,000). By using the filter
    rules in Sect. [5.4.4.2](#Sec31), we ended up with 7,795,044 transaction records.
    There are 534,820 addresses, 323 of which are phishing addresses. The following
    experiments are based on this data set. In order to reflect the effectiveness
    of the model more accurately and avoid the contingency caused by the partitioning
    of train and test sets, the experiment adopts the evaluation method of k-fold
    cross-validation. Specifically, we set the parameter k=5\. To accurately evaluate
    the model, we select four metrics: precision, recall, F1, and AUC, which is commonly
    used in classification problems.'
  prefs: []
  type: TYPE_NORMAL
- en: 5.4.5.2 Method Comparison
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In order to verify that our proposed model is more suitable for this problem,
    we compared the single-model LightGBM, Support Vector Machine (SVM), decision
    tree (DT), and their Dual-sampling Ensemble (DE+) models. SVM and DT are considered
    efficient in many classification problems of class imbalance (Chen et al. [2019b](#CR18)).
    Thus, we chose it as the baseline of our model. To compare the performance of
    these methods, we set the feature sampling rate to 70%, and the number of base
    models to 1600 (i.e., balance ensemble). Table [5.4](#Tab4) shows the results.
    As can be seen, in these single-models, SVM performs poorly, LightGBM and DT have
    certain performance, but they are obviously of no practical value. On the contrary,
    after adopting the ensemble strategy, the performance of each model is significantly
    improved, especially LightGBM and DT (i.e., DElightGBM and DEDT). This result
    shows that the ensemble method is a good choice when facing the class imbalance.
    It is worth noting that the proposed model (i.e., DElightGBM) performs well on
    all metrics (i.e., all larger than 0.8). It means that the proposed model can
    be deployed in a real wallet for real-time warnings.Table 5.4
  prefs: []
  type: TYPE_NORMAL
- en: The performance comparison
  prefs: []
  type: TYPE_NORMAL
- en: '![../images/506524_1_En_5_Chapter/506524_1_En_5_Figa_HTML.png](../images/506524_1_En_5_Chapter/506524_1_En_5_Figa_HTML.png)'
  prefs: []
  type: TYPE_IMG
- en: The bold values give the best performance for each metric
  prefs: []
  type: TYPE_NORMAL
- en: 5.4.5.3 Example Sampling Effect Analysis
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Evaluating the impact of example sampling on the model is essentially selecting
    the number of base models. Table [5.5](#Tab5) shows the four evaluation metrics
    of the framework DElightGBM with different numbers of base models. (We set the
    feature sampling rate to 70%, and the parameters of each model are randomly selected
    around the optimal parameters.) It can be seen that with the increase in the number
    of base models, all the metrics obtained different degrees of promotion. When
    the number of base models reaches 800 (i.e., half balance ensemble), three metrics
    (i.e., *precision*, *F1*, and *AUC*) reach the maximum. However, the *recall*
    keeps going up, and it reaches its maximum when the number of base models is 1600
    (i.e., balance ensemble). This result indicates that the level of class imbalance
    is a very important factor affecting the performance of base models. From the
    experimental results, half balance ensemble seems to be a good choice. To make
    the model more practical, however, we would prefer to find all potential phishing
    scams (i.e., higher *recall*) at the expense of precision. Therefore, we propose
    the use of the balance ensemble for phishing scam detection.Table 5.5
  prefs: []
  type: TYPE_NORMAL
- en: The effect of example sampling (with LightGBM)
  prefs: []
  type: TYPE_NORMAL
- en: '| #models | Precision | Recall | F1 | AUC |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0.0789 | 0.0991 | 0.0879 | 0.549 |'
  prefs: []
  type: TYPE_TB
- en: '| 100 | 0.7583 | 0.3993 | 0.5232 | 0.6947 |'
  prefs: []
  type: TYPE_TB
- en: '| 800 | **0**.**9288** | 0.7368 | **0**.**8217** | **0**.**8274** |'
  prefs: []
  type: TYPE_TB
- en: '| 1000 | 0.826 | 0.7585 | 0.7908 | 0.8206 |'
  prefs: []
  type: TYPE_TB
- en: '| 1600 | 0.8196 | **0**.**805** | 0.805 | 0.8097 |'
  prefs: []
  type: TYPE_TB
- en: The bold values give the best performance for each metric
  prefs: []
  type: TYPE_NORMAL
- en: 5.4.5.4 Feature Sampling Evaluation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Next, we analyze the effect of feature sampling by setting different sampling
    ratios. To eliminate the effect of the number of base models, it is uniformly
    set at 1600\. Table [5.6](#Tab6) shows the evaluation results. In general, the
    feature sampling method has a certain influence on the final results; however,
    as compared with example sampling, its influence is far less significant. From
    the perspective of the most preferred metric, *recall*, 0.8 is the best feature
    sampling ratio. Compared to using all the features (i.e., ratio=1), *recall* improved
    4.24%.Table 5.6
  prefs: []
  type: TYPE_NORMAL
- en: The effect of feature sampling
  prefs: []
  type: TYPE_NORMAL
- en: '![../images/506524_1_En_5_Chapter/506524_1_En_5_Figb_HTML.png](../images/506524_1_En_5_Chapter/506524_1_En_5_Figb_HTML.png)'
  prefs: []
  type: TYPE_IMG
- en: The bold values give the best performance for each metric
  prefs: []
  type: TYPE_NORMAL
- en: These results reveal a noteworthy phenomenon. It is not necessarily correct
    that the more features the model has, the better the performance. On the contrary,
    in the case that we can obtain a large number of features, a certain degree of
    feature sampling is conducive to obtaining a better model. This may be because
    feature sampling can make different base models view the object from different
    angles, so as to obtain better identification.
  prefs: []
  type: TYPE_NORMAL
- en: 5.4.5.5 Feature Analysis
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Since we adopted the method of cascading feature extraction, a large number
    of features were obtained. Figure [5.10](#Fig10) shows the top 15 important features
    in the model. Next, we analyze why some of these features are important.![../images/506524_1_En_5_Chapter/506524_1_En_5_Fig10_HTML.png](../images/506524_1_En_5_Chapter/506524_1_En_5_Fig10_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 5.10
  prefs: []
  type: TYPE_NORMAL
- en: The top 15 important features
  prefs: []
  type: TYPE_NORMAL
- en: '*in_block_std* is the standard deviation of *blockNumber* of all *in* transaction
    for a node. This feature reflects the intensity of in-transactions at a certain
    address. If there are a large number of in-transactions in a short period, the
    *blockNumber* of these transactions will be very close to each other, and thus
    the constructed *to_block_std* will be very small. This feature is much more important
    than the others, and its meaning is easy to understand. For a phishing address,
    a natural phenomenon is that the number of in-transactions increased suddenly
    within a period after the phishing began. However, with the phishing scam revealed,
    in-transactions become rare, or even non-existent. This leads to in-transactions
    are concentrated in a small period for a phishing address, and the feature can
    grasp this characteristic very well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*to_out_sum_median* is a typical 1-order network feature. It reflects the overall
    situation (i.e., *sum*) of all the *to* friends’ out-transactions. This feature
    is not as intuitive as the previous one and requires some explanation to understand
    its value. First of all, we can think of the median amount of *out* transaction
    of an address as an indicator of its financial strength. This is not difficult
    to understand, because the large median means that at least half of the address’s
    *out* transaction amounts are large, indicating that its financial strength is
    stronger. Second, for phishing addresses, *to* friends are the victims of the
    phishing scam. Thus, for phishing scams, this feature can be seen as an indication
    of the overall financial strength of all its victims.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*from_in_sum_min* is also an 1-order network feature. Different from the previous
    feature, this feature reflects the *in* transaction of the node’s *from* friend.
    It is relatively easy to understand why the feature is important. For phishing
    scams, money laundering is an important part before cashing out. Therefore, the
    *from* friend of the phishing address, which is usually the intermediate address
    used for money laundering, must exhibit behavior characteristics different from
    normal addresses. And, this type of features captures the difference effectively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The above analysis of the top three features shows that our feature engineering
    achieves good results, fully mining the characteristics of the node itself and
    different neighbors of the node.
  prefs: []
  type: TYPE_NORMAL
- en: 5.4.6 Conclusion and Future Work
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In blockchain ecosystems, various scams are rampant, which seriously threaten
    the financial security of users involved. In the future, we are going to further
    this study to other cybercrimes and set up a blockchain scam detection website
    to provide the phishing scam identification service in the form of API. Besides,
    to accelerate the research in this field, all relevant data and code will be released
    after the book is published.
  prefs: []
  type: TYPE_NORMAL
- en: 5.5 Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we focus our attention on misbehavior detection on blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: Specifically, in Sect. [5.3](#Sec6), we propose an approach to detect smart
    Ponzi schemes. Using the manually checked samples and XGBoost, a regression tree
    model based on extracted account features and code features is build. The experimental
    results indicate that the proposed model has high accuracy and can be used to
    detect latent smart Ponzi schemes in practice. The most significance result is
    that using our extracted code features that are publicly accessible in any running
    contract is enough to build a practical model for detecting Ponzi scheme contract
    at the moment of its creation. In addition, we estimate that there are more than
    400 smart Ponzi schemes on Ethereum, which are far more than the previous estimation.
  prefs: []
  type: TYPE_NORMAL
- en: In Sect. [5.4](#Sec23), we propose a systematic approach to detect phishing
    scams in the Ethereum ecosystem. First of all, by using the Parity client and
    crawl etherscan.io, we collect all transactions of the Ethereum blockchain and
    the labeled phishing addresses. Then, by using this data, we construct a transaction
    graph and propose a graph-based cascade feature extraction method, which helps
    us extract many useful features. Next, based on the extracted features and LightGBM,
    we propose a Dual-sampling Ensemble model to detect phishing suspects. Finally,
    we evaluate the model from many angles, and the results indicate the effectiveness
    of our model.
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, several types of misbehaviors and relating researches are discussed
    in this chapter. Besides, we proposed two data mining models to handle Ponzi scheme
    detection and phishing scam detection on Ethereum along with corresponding experiments.
    Furthermore, evaluation for both of the models is conducted from various angles
    and consistency is found between theoretical results and experimental results.
  prefs: []
  type: TYPE_NORMAL
