- en: 'Chapter 3: JavaScript ArchitectureUnderstanding JavaScript Architecture can
    be helpful when you are learning how to code. If you have a good understanding
    about how JavaScript works online, you are at an advantage.There are three types
    of JavaScript architecture. Typical, Framework based and Advanced.Typical JavaScript
    Application ArchitectureOrdinarily, JavaScript applications use the bottom-up
    approach. The User Interface is put at the center of development at all times.
    The User Interface and the server link directly to the code from behind.This JavaScript
    architecture is mostly used for simple programs like websites that don’t require
    intricate frameworks. It simply can’t keep up with more complex programs. It does
    allow you to interact with the screen, but it just does not have the capacity
    for a large scale application.SPAs or Single page applications make use of typical
    JavaScript Architecture. They can be updated easily and they are still in demand
    today. SPAs can only be used in a web browser, so they rely a lot on JavaScript.
    SPAs tend to be faster than mobile apps because the script that was used to build
    them only needs to be loaded once. From that point on its only job is to send
    data between the user and the server.Framework-Based ArchitectureAs time progressed,
    The capabilities of Typical application architecture were not able to keep up
    with the needs of programmers around the world. Thus Framework based Architecture
    was born. It is able to solve more complex problems because it makes use of either
    the MVC or the MVVM patterns.MVC stands for Model View Controller. It splits larger
    applications into different sections that all have distinct functions. Each section
    is equipped to handle different aspects of an application. The model represents
    everything data related. It gets its commands from the controller and then carries
    out the user’s input. The view controls everything User Interface related. It
    gets the input from the user and then presents the data from the model to the
    user.  The controller is the connection between the two. It processes and manipulates
    data from either side and then produces an output.There are different adaptations
    of MVC:HMVC–Which stands for Hierarchical Model view controller. It is essentially
    the same thing as MVC, but with layers and more capabilities It takes MVC and
    repeats it in different parts of the application. Having it in layers does wonders
    for app development. You can easily reuse the code and not have to worry about
    constant maintenance.MVA–Which stands for Model View Adapter. Usually data travels
    from the controller to the model, but with MVA the controller is the go-between
    and the Model and View must pass it. View and Model do not actually intersect.
    Here, the Controller acts as an adapter.MVP–Which stands for Model View Presenter.
    This one is slightly different from MVC. The presenter is in charge of all the
    data in the application. It sends that data to the model to process, receives
    it back and then passes it onto the View.MVVM–Stands for Model-View ViewModel
    and  is like an amalgamation of MVC and MVP because it borrows from their patterns.
    Data and information are completely separate from the User Interface. The controller
    is replaced by the Viewmodel which connects the Model and the View. The Viewmodel
    updates the Model every time it receives input and then adapts that data before
    sending it off to the View.The framework has a feature rich Runtime environment
    that renders and puts out the Application. We can liken the Runtime environment
    to a vessel. It consists of all the things we need to run JavaScript code. Namely:●     The
    Engine●     Web API’s●     Event loops●     Call back queue●     Micro task queueJavaScript
    EnginesEngines take the intricate code written in JavaScript and convert it into
    a code that the machine can understand. Each browser has its own engine. A few
    notable engines are V8, SpiderMonkey and JavaScript Core.V8No two engines are
    the same, they all run differently but ultimately do the same thing. In the V8
    engine, everything starts in the Parser. The Parser checks for syntax and semantics.
    Syntax is the structure that the code comes in and Semantics refers to what certain
    words and symbols in the code mean. The parser then analyzes and breaks the code
    down to make it into Abstract Syntax Tree(AST). AST is the representation of the
    source code in tree form. The AST then goes into the Interpreter. The Interpreter
    converts the AST into Byte Code. This is known as ignition. Sometimes code gets
    repeated up to one thousand times. When this happens, the Profiler checks for
    the code repetition and tries to optimize it. Once it gets the optimized code,
    it moves it on to the Compiler. The compiler in the V8 engine is called TurboFan.
    Turbofan releases the Byte Code in its most optimized form.SpiderMonkeySpiderMonkey  was
    actually the first engine and it was created in 1995\. The Mozilla foundation
    has kept it going and still makes use of it today. The engine converts the JavaScript
    code into ByteCode first and then sends it to the Interpreter and the JIT Compiler.
    JIT stands for Just in Time. The JIT Compiler optimizes the code and sends any
    unused code to the Garbage collector.Web API’sAPI stands for Application Programming
    Interface. It is an interface that gives the User a set of functions, while concealing
    the underlying mechanism of that function. Web API’s are not actually part of
    JavaScript. They are located in the browser, but they do give us access to the
    JavaScript Engine.Web API’s are comprised of:● A set timeout–Allows you to execute
    a block of code after a certain amount of time (defined by you) has passed● DOM
    API’s - Are made up of the interfaces that define how each of the elements in
    HTML function. That includes any supporting types and interfaces they may rely
    on.● Fetch–API Gives JavaScript access to manipulate requests and responses in
    the Call Stack●     Local storage–Lets JavaScript apps save important value pairs
    indefinitely●     Console–Registers any and all messages logged by JavaScript
    code● Location–Allows users of the browser to share their Geographical location
    at any given timeEvent LoopsJavaScript is a single threaded code. This means that
    it can only run one command at a time. These commands are synchronous because
    they run one after the other. This doesn’t always work in programming so there
    are ways to make JavaScript asynchronous. Things like Call stacks help to avoid
    any blocking that might happen in a synchronous thread.A Call stack is a mechanism
    used by the interpreter to keep track of functions and their place in any given
    script. It allows functions to run concurrently. When the script calls a function,
    the interpreter puts it in the call stack and then conducts the function.A Callback
    Queue is like a safe house where an unexecuted line of script stays until it’s
    time for it to run.The Event Loop’s job is to check the Call Stack and Callback
    Queue. If the Call Stack is empty, Event Loop will take the statement in the Callback
    Queue and push it to the Call Stack. It appears to be a pretty straightforward
    process, but there is something called the MicroTask Queue. The MicroTask queue
    is pretty much a carbon copy of the Callback Queue but it has a higher priority,
    which means that any functions in it will be executed first.MPAs or Multi Page
    applications are better built with Framework based architecture. They are obviously
    larger than Single Page Applications and take more time to build. Because it’s
    data heavy, a lot of information has to go back and forth between the browser
    and the server. This makes it slower than an SPA. Some developers use AJAX to
    lighten the load, but it’s still not as widely used because it’s simply too much
    to maintain.Advanced JavaScript ArchitectureEven though Framework Architecture
    has more capabilities than typical architecture, it still has its limits when
    it comes to constructing larger applications. The only way it could grow to accommodate
    larger apps would be through constant maintenance and development. MVC and MVVM
    patterns are convenient and allow for developers to reuse code, but they present
    problems in the framework. The User Interface became compromised because the controller
    was corresponding with the server while manipulating the view. The need for a
    more feature rich architecture arose, then Advanced JavaScript Architecture came
    to be. In this architecture the User interface and server correspondence work
    completely separately, so it is easy to keep up with any demands that larger apps
    might have.Data computation and User Interface are completely separate in this
    instance. The User Interface is no longer at the center, so the app becomes easier
    to manage and use.Universal ApplicationsFormally known as Isomorphic applications,
    they provide faster browser connection because there is less code. They work on
    both the client and server side, ensuring much easier engagement and less work
    for the programmer. The one downside is that they are quite hard to debug.'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 第三章：JavaScript 架构了解 JavaScript 架构对于学习编码时可能非常有帮助。如果你对 JavaScript 在线工作原理有较好的了解，你就有了优势。有三种类型的
    JavaScript 架构。典型的、基于框架的和高级的。典型的 JavaScript 应用程序架构通常使用自下而上的方法。用户界面始终处于开发的中心。用户界面和服务器直接链接到后台代码。这种
    JavaScript 架构通常用于不需要复杂框架的简单程序，比如不需要复杂框架的网站。它只能用于与屏幕交互，但对大规模应用程序来说不适用。单页面应用程序（SPAs）使用典型的
    JavaScript 架构。它们可以轻松更新，今天仍有需求。SPAs只能在 Web 浏览器中使用，因此它们在很大程度上依赖于 JavaScript。SPAs往往比移动应用程序更快，因为用于构建它们的脚本只需加载一次。从那时起，它的唯一工作就是在用户和服务器之间发送数据。基于框架的架构随着时间的推移，典型应用程序架构的能力无法满足全球程序员的需求。因此，基于框架的架构诞生了。它能够解决更复杂的问题，因为它使用
    MVC 或 MVVM 模式。MVC代表Model View Controller。它将更大的应用程序分割成不同的部分，每个部分都有不同的功能。每个部分都能处理应用程序的不同方面。模型代表与数据相关的所有内容。它从控制器获取命令，然后执行用户的输入。视图控制所有用户界面相关的内容。它获取用户的输入，然后将模型的数据呈现给用户。控制器是两者之间的连接。它处理和操作来自两边的数据，然后产生一个输出。MVC有不同的适应形式：HMVC-代表层次模型视图控制器。它本质上与MVC相同，但具有层和更多功能。它在应用程序的不同部分重复了MVC。分层为应用程序开发带来了奇迹。您可以轻松重用代码，而不必担心不断的维护。MVA-代表模型视图适配器。通常数据从控制器传递到模型，但使用MVA，控制器是连接器，模型和视图必须通过它传递。视图和模型实际上不相交。在这里，控制器充当适配器。MVP-代表模型视图显示器。这与MVC有些不同。演示者控制应用程序中的所有数据。它将这些数据发送到模型进行处理，然后将其发送回并传递到视图。MVVM-代表模型视图视图模型，类似于MVC和MVP的融合，因为它借用它们的模式。数据和信息与用户界面完全分离。控制器被视图模型替换，视图模型连接了模型和视图。视图模型在每次收到输入后更新模型，然后在将数据发送到视图之前调整该数据。该框架具有功能丰富的运行时环境，可以呈现和输出应用程序。我们可以将运行时环境比作一个容器。它包括运行JavaScript代码所需的所有内容。即：引擎、Web
    API、事件循环、回调队列、微任务队列。JavaScript 引擎引擎将编写的复杂JavaScript代码转换为机器可以理解的代码。每个浏览器都有自己的引擎。一些著名的引擎包括
    V8、SpiderMonkey和JavaScript Core。V8没有两个引擎是相同的，它们工作方式各不相同，但最终目标相同。在V8引擎中，一切都从解析器开始。解析器检查语法和语义。语法是代码的结构，而语义是代码中特定单词和符号的含义。解析器然后分析并将代码分解成抽象语法树（AST）。AST是以树形式表示源代码。然后将AST传输到解释器中。解释器将AST转换为字节代码。这称为点火。有时代码会重复一千次。发生这种情况时，性能分析器会检查代码重复，并尝试优化它。一旦获得优化的代码，它将其传输到编译器。V8引擎中的编译器称为TurboFan。TurboFan以最优化的形式释放字节代码。SpiderMonkey实际上是第一个引擎，创建于1995年。Mozilla
    基金会一直延续并且今天仍在使用它。该引擎首先将JavaScript代码转换为字节码，然后将其发送到解释器和即时编译器。即时编译器优化代码，并将任何未使用的代码发送到垃圾回收程序。API代表应用程序编程接口。它是一种为用户提供一组函数的接口，同时隐藏了该函数的底层机制。Web
    API 实际上并不是 JavaScript 的一部分。它们位于浏览器中，但它们确实使我们能够访问 JavaScript 引擎。Web API 由以下部分组成：·设置超时-允许您在一定时间后（由您定义）执行代码块。·DOM
    API-由定义 HTML 中每个元素的方式组成。这包括它们可能依赖的任何支持类型和接口。·获取-API允许JavaScript访问调用堆栈中的请求和响应。·本地存储-让JavaScript应用程序永久保存重要值对·控制台-记录JavaScript代码记录的所有消息·位置-允许浏览器用户随时分享其地理位置事件循环JavaScript是单线程代码。这意味着它一次只能运行一个命令。这些命令是同步的，因为它们一个接一个地运行。这在编程中并不始终适用，因此有办法使JavaScript异步。诸如调用堆栈之类的事物帮助避免同步线程中可能发生的任何阻塞。调用堆栈是解释器用于跟踪函数及其在给定脚本中的位置的机制。它允许函数并行运行。当脚本调用函数时，解释器将其放入调用堆栈，然后执行函数。回调队列就像安全房间，那里的未执行的脚本行会等待运行的时间。事件循环的工作是检查调用堆栈和回调队列。如果调用堆栈为空，事件循环将从回调队列中提取语句并将其推到调用堆栈。这似乎是一个非常简单直接的过程，但有一个叫做微任务队列的东西。微任务队列几乎是回调队列的复制品，但它具有更高的优先级，这意味着其中的任何函数将首先执行。MPAs或多页应用程序最好使用基于框架的架构来构建。它们显然比单页面应用程序更大，需要更多的构建时间。由于数据量大，必须在浏览器和服务器之间来回传输很多信息。这使得其比SPA慢。一些开发人员使用
    AJAX 来减轻负担，但由于维护困难，它仍然并未被广泛使用。尽管框架架构在构建普通架构方面具有更多的功能，但在构建更大的应用程序方面仍存在限制。它可以增加代码重用，但在框架方面会出现问题。用户界面因为控制器与服务器通信同时操纵视图而受到威胁。高级
    JavaScript 架构的需求随之出现。在这种架构中，用户界面和服务器通信完全分开，因此可以轻松应对更大的应用程序需求。在这种情况下，数据计算和用户界面完全分开。用户界面不再处于中心位置，因此应用程序变得更容易管理和使用。通用应用程序在连接速度更快，因为代码更少。它们在客户端和服务器端都能工作，确保程序员更轻松地进行交互并减少了开发工作量。唯一的缺点是它们很难调试。
