- en: © Santiago Palladino 2019S. PalladinoEthereum for Web Developers[https://doi.org/10.1007/978-1-4842-5278-9_8](https://doi.org/10.1007/978-1-4842-5278-9_8)
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: © Santiago Palladino 2019S. Palladino《面向 Web 开发者的以太坊》[https://doi.org/10.1007/978-1-4842-5278-9_8](https://doi.org/10.1007/978-1-4842-5278-9_8)
- en: 8. Scalability
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8. 可扩展性
- en: Santiago Palladino^([1](#Aff2) )(1)Ciudad Autónoma de Buenos Aires, Argentina
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Santiago Palladino^([1](#Aff2) )(1)阿根廷布宜诺斯艾利斯自治市
- en: In the previous chapter, we addressed user onboarding challenges, one of the
    two main issues for Ethereum mass adoption. The second of them, which we will
    tackle in this chapter, is scalability. The Ethereum network, as it is today,
    can handle about 15 transactions per second – and this throughput must be shared
    among all Ethereum applications globally. This has led to single applications
    cluttering the entire network due to a spike in their usage to the point of rendering
    all dapps unusable for brief periods. In this chapter, we will introduce state
    channels and sidechains, two of the most widely used scalability solutions.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们解决了用户入门挑战，这是以太坊大规模采用的两个主要问题之一。第二个问题是可扩展性，我们将在本章中讨论。以太坊网络，就目前而言，每秒可以处理约
    15 笔交易——而这个吞吐量必须在全球范围内的所有以太坊应用之间共享。这导致单个应用在使用量激增的情况下将整个网络拥塞，使得所有 dapp 在短时间内无法使用。在本章中，我们将介绍状态通道和侧链，这两种最广泛使用的可扩展性解决方案。
- en: What is Layer 2?
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是第二层？
- en: The Ethereum blockchain can be seen as a single global database, replicated
    across every node in the network, that needs to process every single transaction
    sent. This alone, without even considering block propagation times or proofs-of-work,
    already imposes a cap on the volume of transactions that can be processed.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊区块链可以看作是一个全球单一的数据库，复制到网络中的每个节点，需要处理每个发送的交易。仅仅这一点，甚至没有考虑块传播时间或工作证明，已经对可以处理的交易量施加了限制。
- en: '*The core limitation is that public blockchains like ethereum require every
    transaction to be processed by every single node in the network. (...) This is
    by design — it’s part of what makes public blockchains authoritative. Nodes don’t
    have to rely on someone else to tell them what the current state of the blockchain
    is. (...) This puts a fundamental limit on ethereum’s transaction throughput:
    it cannot be higher than what we are willing to require from an individual node.*'
  id: totrans-6
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*核心限制在于，像以太坊这样的公共区块链要求每个交易都由网络中的每个节点处理。(...) 这是设计之中的——这是使公共区块链具有权威性的一部分。节点无需依赖他人告诉他们区块链的当前状态。(...)
    这给以太坊的交易吞吐量设置了一个基本限制：它不能高于我们愿意要求单个节点的水平。*'
- en: ''
  id: totrans-7
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '—Josh Stark, “Making Sense of Ethereum’s Layer 2 Scaling Solutions: State Channels,
    Plasma, and Truebit”^([1](#Fn1))'
  id: totrans-8
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: —Josh Stark，《理解以太坊的第二层扩展解决方案：状态通道、Plasma 和 Truebit》^([1](#Fn1))
- en: But what if we do *not* require every transaction to be run through the whole
    network? For instance, a set of transactions, run between a small group of participants,
    could be processed on a separate network. And only after a certain period the
    resulting balances could be uploaded to the main Ethereum network.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们*不要求*每笔交易都通过整个网络运行会怎样呢？例如，一组交易，在一小群参与者之间运行，可以在一个单独的网络上处理。只有在一定的时间后，产生的余额才能上传到主要的以太坊网络。
- en: 'These parallel (or *side*) networks require certain security guarantees – otherwise,
    we could just use a regular database. The key here is that these networks can
    rely on the main network to act as a secure decentralized base layer, on top of
    which new consensus mechanisms are built. Hence, these scalability solutions are
    said to belong to a *layer 2*, since they are not built as part of the Ethereum
    protocol itself, but rather on top of it. Today, there are three main types of
    layer 2 solutions:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这些并行（或*侧*）网络需要某些安全保障 - 否则，我们可以只使用常规数据库。关键在于，这些网络可以依赖于主网络作为安全的去中心化基础层，上面可以构建新的共识机制。因此，这些可伸缩性解决方案被认为属于*第二层*，因为它们不是作为以太坊协议本身的一部分构建的，而是在其之上构建的。今天，有三种主要类型的第二层解决方案：
- en: '*Channels* are short-lived closed networks, typically between two participants,
    where they exchange multiple transactions between each other. Each party must
    acknowledge every transaction by signing it. To open the channel, they first must
    make a deposit on a smart contract on the Ethereum network. This contract can
    then validate their signatures to execute the payouts when needed.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*通道*是短暂的闭合网络，通常在两个参与者之间，在其中它们相互交换多个交易。每个参与方都必须通过签名来确认每笔交易。为了打开通道，他们首先必须在以太坊网络上的智能合约上存入押金。然后，该合约可以验证他们的签名，在需要时执行支付。'
- en: '*Sidechains* are parallel networks that use a different consensus algorithm
    than the main network, such as proof of authority or stake. These are usually
    bridged to the main network, allowing users to move assets between the sidechain
    and the main chain. A variant of sidechains are *plasma chains*, in which the
    good behavior of the sidechain can be fully enforced by a smart contract on the
    main network.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*侧链*是使用不同于主网络的共识算法的并行网络，例如权威证明或股权证明。这些通常与主网络桥接，允许用户在侧链和主链之间转移资产。侧链的一种变体是*Plasma链*，其中侧链的良好行为可以通过主网络上的智能合约完全执行。'
- en: '*External computation* solutions do not provide a higher transaction throughput,
    but they do allow for more interesting tasks to be performed in each transaction.
    They run computing-intensive tasks outside the main network, tasks that would
    be prohibitively expensive to run on the EVM, and then inject the result back.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*外部计算*解决方案并不提供更高的交易吞吐量，但它们确实允许在每个交易中执行更有趣的任务。它们在主网络之外运行计算密集型任务，这些任务在以太坊虚拟机上运行将是成本高昂的，并将结果注入回去。'
- en: In this chapter, we will explore the first two solutions. Today there are several
    teams working on implementations or new variations of each of them. We will mention
    some of them along the way, but not without making our own attempts at each solution
    first.^([2](#Fn2))
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨前两个解决方案。如今，有几个团队正在研究每个解决方案的实施或新的变体。我们将沿途提到其中一些，但在尝试每个解决方案之前，我们也会自己做些尝试。^([2](#Fn2))
- en: Channels
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通道
- en: Channels are a family of layer 2 scalability solutions that span many different
    variants from unidirectional payment channels to counterfactual generalized state
    channels. They can also be extrapolated to full channel networks instead of isolated
    peer-to-peer solutions.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 通道是一个涵盖了许多不同变体的第二层可扩展性解决方案家族，从单向支付通道到反事实广义状态通道。它们也可以推广到完整的通道网络，而不是孤立的点对点解决方案。
- en: We will begin with *payment channels*.^([3](#Fn3)) In payment channels, two
    or more participants open a channel by making an initial deposit on the main network
    and then perform multiple payments off-chain over the channel. These payments
    are then settled trustlessly on a smart contract on the main network.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从*支付通道*开始。^([3](#Fn3)) 在支付通道中，两个或更多参与者通过在主网络上进行初始存款来开启通道，然后在通道之外执行多笔支付。然后，这些支付会在主网络上的智能合约上被可信地结算。
- en: Unidirectional Payment Channels
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单向支付通道
- en: 'The easiest variant of payment channels are *unidirectional payment channels*.
    Here, there are two distinct parties involved: a recipient and a sender. These
    are usually a provider that collects multiple payments in exchange for a service
    provided over time and a user performing these payments. A good example of this
    is a player performing microtransactions in a game.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 支付通道的最简单变体是*单向支付通道*。在这里，有两个不同的参与方：接收方和发送方。通常是一个提供者，在一段时间内提供服务并收集多笔支付，以及执行这些支付的用户。这在游戏中进行微交易的玩家是一个很好的例子。
- en: How do Channels Work?
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 通道是如何工作的？
- en: Let’s suppose a scenario where a user needs to make several small purchases
    to a service provider. It does not matter what the service provider is offering,
    only that the user will need to perform *multiple payments to the same recipient
    over a period of time* and that the provider needs a proof of each small payment
    to continue providing the service.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设一个场景，用户需要向服务提供者进行多次小额购买。服务提供者提供什么并不重要，只要用户需要在一段时间内向同一接收方进行多笔支付，并且提供者需要每笔小额支付的证明来继续提供服务。
- en: If each and every one of these small payments is done as a transaction on the
    blockchain, the accumulated transaction gas fees would probably become considerable
    against the actual payments. Paying a 20-cent fee to the network for each 20-cent
    payment is not a good deal. Furthermore, since the service provider requires a
    proof after each payment, the confirmation times would constantly add significant
    delays to the service.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 'A solution could be to have a trusted third party collect a large initial deposit
    from the user and monitor the service being provided. The user then signs each
    of these *microtransactions* with their private key, acknowledging each of the
    payments to be made. After all micropayments have been made, the third party issues
    a single on-chain transaction that includes the total payout to the service provider
    and returns the remainder of the initial deposit to the user. Assuming both the
    user and the service provider trust this party, this can reduce all micropayments
    to just two transactions on the network: one for the deposit and the other for
    the payout.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: A *unidirectional payment channel* is an implementation of this solution using
    a smart contract as the trusted third party. The user is said to *open* a payment
    channel to the service provider as they deploy the payment channel contract with
    the initial deposit. The user sends each micropayment as a *signed message* directly
    to the service provider. These messages are not sent on the Ethereum network,
    but entirely off-chain via a separate protocol, such as HTTPS. When the service
    provider wants to cash out, they can submit the signed messages to the payment
    channel contract and collect their payments (Figure [8-1](#Fig1)).![../images/476252_1_En_8_Chapter/476252_1_En_8_Fig1_HTML.png](../images/476252_1_En_8_Chapter/476252_1_En_8_Fig1_HTML.png)
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8-1
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Flow diagram of a payment channel. The user first opens the channel with an
    initial 1 ETH deposit. Every time the user needs to make a micropayment to the
    service provider, they instead sign a message with the accumulated amount to be
    paid and send it off-chain. When the provider wants to cash out, they submit the
    latest signed message to the contract and receive their payout
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 支付通道的流程图。用户首先用初始的 1 ETH 存款打开通道。每当用户需要向服务提供商进行微支付时，他们会签署一条带有累积支付金额的消息并将其发送到链下。当提供商想要兑现时，他们会向合约提交最新签署的消息并收到他们的支付。
- en: Within a payment channel, most transactions happen completely off-chain, being
    sent directly from the user to the recipient. This is why channels are considered
    a *layer 2* solution, built on top of the main Ethereum network, the *layer 1*,
    while inheriting many of its security properties.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在支付通道内，大多数交易完全发生在链下，直接从用户发送到接收方。这就是为什么通道被认为是一个*第二层*解决方案，建立在主以太坊网络，即*第一层*之上，同时继承了许多其安全属性。
- en: Channels have some very interesting advantages over layer 1\. After a channel
    has been opened, any transaction sent through it has no gas fees, and once sent,
    they can also be considered to be instantly finalized, since there is no need
    to wait for any blocks to be mined to confirm it. Additionally, since transactions
    are exchanged within the two participants, they are entirely private until they
    are submitted to the blockchain.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 与第一层相比，通道具有一些非常有趣的优势。通道一旦打开，通过它发送的任何交易都没有 gas 费用，并且一旦发送，它们也可以被视为立即完成，因为无需等待任何区块被挖掘来确认它。此外，由于交易是在两个参与者之间交换的，因此在提交到区块链之前，它们完全是私密的。
- en: Implementing a Unidirectional Channel
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 实现单向通道
- en: To illustrate how a unidirectional payment channel works, we will implement
    one from scratch (Listing [8-1](#PC1)). Our payment channel will have a sender
    and a recipient, will hold the initial deposit by the sender, and will have a
    predetermined end time. After this specified end time, if the recipient has not
    collected their payment, the sender is allowed to withdraw the deposit. This mechanism
    is required to prevent the user deposit to be locked into the contract forever,
    if the service provider never submits the payment messages.// contracts/PaymentChannel.solpragma
    solidity ^0.5.0;import "openzeppelin-solidity/contracts/cryptography/ECDSA.sol";contract
    PaymentChannel {  using ECDSA for bytes32;  address payable sender;  address payable
    recipient;  uint256 endTime;  bool closed;  constructor(    address payable _recipient,
    uint256 _endTime  ) public payable {    sender = msg.sender;    recipient = _recipient;    endTime
    = _endTime;  }}Listing 8-1
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明单向支付通道的工作原理，我们将从零开始实现一个（见[8-1](#PC1)）。我们的支付通道将有一个发送者和一个接收者，将由发送者提供初始存款，并设定一个预定的结束时间。在指定的结束时间之后，如果接收者没有收取他们的付款，发送者将被允许取回存款。如果服务提供商从未提交付款消息，这个机制就是必需的，以防止用户存款永远被锁定在合约中。//
    contracts/PaymentChannel.solpragma solidity ^0.5.0;import "openzeppelin-solidity/contracts/cryptography/ECDSA.sol";contract
    PaymentChannel {  using ECDSA for bytes32;  address payable sender;  address payable
    recipient;  uint256 endTime;  bool closed;  constructor(    address payable _recipient,
    uint256 _endTime  ) public payable {    sender = msg.sender;    recipient = _recipient;    endTime
    = _endTime;  }}Listing 8-1
- en: Definition, state variables, and constructor for the unidirectional payment
    channel contract. We will be using the ECDSA library from openzeppelin-solidity@2.1
    to verify the signatures on the contract. Note that the constructor is payable,
    so the sender can make the initial deposit upon deployment
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 单向支付通道合约的定义、状态变量和构造函数。我们将使用openzeppelin-solidity@2.1中的ECDSA库来验证合约上的签名。请注意，构造函数是可支付的，因此发送者可以在部署时进行初始存款。
- en: Since most transactions in a payment channel occur off-chain, we will need to
    implement only two methods. The first method, close, will be called by the service
    provider to submit the sender’s signature with the payout, collect their funds,
    and close the channel (Listing [8-2](#PC2)).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 由于大多数支付通道中的交易发生在链下，我们只需要实现两个方法。第一个方法，close，将由服务提供商调用以提交发送者的带有支付的签名，收取他们的资金，并关闭通道（见[8-2](#PC2)）。
- en: Note
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We will require that the sender always signs messages for the total to be paid
    out to the recipient. This allows us to just submit a single signed message to
    the contract, instead of having to process multiple ones.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要求发送者始终签署消息以支付给接收者的总额。这使我们只需向合约提交一个已签名的消息，而不是处理多个消息。
- en: This method will only be callable by the recipient to prevent the sender from
    trying to prematurely close the channel with a message signed by them with zero
    value. Also, since the sender could sign a message for a total value greater than
    the deposit present in the channel, we need to limit the value transferred to
    the contract’s balance. It is up to the recipient to decide whether they will
    accept a payment note for more value than can be actually paid by the channel.^([4](#Fn4))
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法仅可由收款方调用，以防止发送方尝试使用他们签名的零值消息过早关闭通道。此外，由于发送方可以为大于通道中存款的总价值签署消息，因此我们需要限制转入合约余额的价值。由收款方决定是否接受比通道实际支付的更高价值的付款通知。^([4](#Fn4))
- en: 'After the payout to the recipient is done, all the remainder of the deposit
    is returned to the sender. Since the channel contract is of no further use at
    this point, we also destroy the contract to get a small gas refund.// contracts/PaymentChannel.solfunction
    close(  uint256 value, bytes memory signature) public {  require(msg.sender ==
    recipient);  bytes32 hash = keccak256(    abi.encodePacked(value, address(this))  ).toEthSignedMessage();  address
    signer = hash.recover(signature);  require(signer == sender);  uint256 funds =
    address(this).balance;  recipient.transfer(funds < value ? funds : value);  selfdestruct(sender);
    // destroys contract, sending funds to sender}Listing 8-2'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '向收款方支付完成后，剩余的存款全部返还给发送方。由于此时通道合约已无进一步用处，我们还将销毁合约以获得少量的燃气退款。// contracts/PaymentChannel.sol函数close(  uint256
    value, bytes memory signature) public {  require(msg.sender == recipient);  bytes32
    hash = keccak256(    abi.encodePacked(value, address(this))  ).toEthSignedMessage();  address
    signer = hash.recover(signature);  require(signer == sender);  uint256 funds =
    address(this).balance;  recipient.transfer(funds < value ? funds : value);  selfdestruct(sender);
    // 销毁合约，将资金发送给发送方}Listing 8-2'
- en: Closing the payment channel by the recipient. This requires submitting a signed
    message by the sender with the value to be transferred. Note that the signed message
    also includes the address of the contract to prevent replay attacks on other channels
    with the same sender
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 收款方关闭支付通道。这需要提交发送方签名的消息，其中包含要转移的价值。请注意，签名的消息还包括合约地址，以防止在具有相同发送方的其他通道上进行重放攻击。
- en: The second function to implement will correspond to the unhappy path, in which
    the recipient never calls the close function, and the sender terminates the contract
    after the predetermined end period (Listing [8-3](#PC3)).// contracts/PaymentChannel.solfunction
    forceClose() public {  require(now > endTime);  require(msg.sender == sender);  selfdestruct(sender);}Listing
    8-3
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现的第二个函数对应于不愉快的情况，即收款方从不调用关闭函数，而发送方在预定的结束期间终止合约（见[8-3](#PC3)）。// contracts/PaymentChannel.sol函数forceClose()
    public {  require(now > endTime);  require(msg.sender == sender);  selfdestruct(sender);}Listing
    8-3
- en: Forcefully closing the channel by the sender to recover the deposit if the recipient
    never cashes out
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果收款方从未兑现，则发送方强制关闭通道以恢复存款。
- en: This implementation can be modified to exchange ERC20 tokens instead of ETH,
    thus opening the door to *token payment channels*. Instead of making an initial
    deposit of ETH, the sender must transfer ERC20 tokens to the channel contract
    as a deposit. These tokens are then transferred again once the channel is closed.
    Refer to TokenPaymentChannel.sol in the code samples for an implementation.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实现可以修改为交换 ERC20 代币而不是 ETH，从而打开*代币支付通道*的大门。发送方不再需要存入 ETH 的初始押金，而是必须将 ERC20
    代币转移到通道合约作为押金。一旦通道关闭，这些代币就会再次转移。请参考代码示例中的 TokenPaymentChannel.sol 进行实现。
- en: Building a Payments App
  id: totrans-41
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 构建支付应用程序
- en: We will now use our contract to build a simple application, where a sender can
    set up a payment channel contract with a recipient, send multiple micropayments
    via a direct off-chain connection, and eventually settle. As in previous chapters,
    we will use create-react-app for boilerplate.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用我们的合约来构建一个简单的应用程序，在这个应用程序中，发送方可以与接收方建立支付通道合约，通过直接的离线连接发送多笔微支付，最终结算。与前几章一样，我们将使用
    create-react-app 作为样板。
- en: To keep the application simple, we will establish a connection between two browser
    windows opened on the same app in the same computer, one of them acting as a sender
    and the other as receiver. We will use *broadcast channels*^([5](#Fn5)) to pass
    messages between the two browser windows. In a real app, you will want to use
    a different method, such as *WebRTC data channels,*^([6](#Fn6)) along with a server
    to manage discovery among your users.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持应用程序的简单性，我们将在同一台计算机的同一应用程序中打开的两个浏览器窗口之间建立连接，其中一个充当发送方，另一个充当接收方。我们将使用*广播通道*^([5](#Fn5))在两个浏览器窗口之间传递消息。在真实的应用程序中，您会想要使用不同的方法，比如*WebRTC
    数据通道*^([6](#Fn6))以及一个服务器来管理用户之间的发现。
- en: 'We will make another simplification: instead of using Metamask, we will manage
    the accounts directly from the web application. This is to avoid difficulties
    with simulating two different accounts interacting with the same app on the same
    computer. We will call directly into ganache for sending transactions from both
    the sender and recipient accounts and for signing messages when needed.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将进行另一个简化：不使用 Metamask，而是直接从 Web 应用程序中管理帐户。这是为了避免在同一台计算机的同一应用程序中模拟两个不同帐户与相同应用程序交互时遇到的困难。我们将直接调用
    ganache 从发送方和接收方帐户发送交易，并在需要时签署消息。
- en: 'Our application will be built out of two main views: one for the sender and
    one for the recipient, both set up by a root App component. It will be the App’s
    responsibility to set up the web3 object and inject the sender and recipient addresses
    into the components. Refer to src/App.js in the code samples for its implementation.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序将由两个主要视图构建：一个为发送方，一个为接收方，都由一个根 App 组件设置。它将是 App 的责任来设置 web3 对象，并将发送方和接收方地址注入组件中。有关其实现，请参阅代码示例中的
    src/App.js。
- en: 'Let’s start with the Sender view. It will be the sender’s responsibility to
    open the channel by deploying the smart contract and making the initial deposit
    (Listing [8-4](#PC4)). When this is done, we will notify the recipient via the
    broadcast channel. We will communicate using a custom protocol where we identify
    different message types by an action parameter, with a value of CHANNEL_DEPLOYED
    in this case.// src/components/Sender.jsasync deployChannel(deposit) {  const
    { web3, sender, recipient } = this.props;  // Deploy the contract and transfer
    initial deposit  const from = sender;  const endTime = +(new Date()) +(300 * 1000);
    // 5 min from now  const channel = await PaymentChannel(web3)    .deploy({ arguments:
    [recipient, endTime] })    .send({ value: deposit.toString(), from, gas: 1e6 });  //
    Notify the recipient via the broadcast channel  const address = channel.options.address;  this.broadcastChannel.postMessage({    action:
    "CHANNEL_DEPLOYED", address  });  // Update sender state with deposit and channel
    object  this.setState({ channel, deposit, sent: BN(0) });}Listing 8-4'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们从发送者视角开始。开启通道将由发送者负责，通过部署智能合约并进行初始存款（见[8-4](#PC4)）。完成此操作后，我们将通过广播通道通知接收者。我们将使用自定义协议进行通信，在这种情况下，我们通过一个动作参数识别不同的消息类型，其值为CHANNEL_DEPLOYED。//
    src/components/Sender.jsasync deployChannel(deposit) {  const { web3, sender,
    recipient } = this.props;  // 部署合约并转移初始存款  const from = sender;  const endTime
    = +(new Date()) +(300 * 1000); // 5 min from now  const channel = await PaymentChannel(web3)    .deploy({
    arguments: [recipient, endTime] })    .send({ value: deposit.toString(), from,
    gas: 1e6 });  // 通过广播通道通知接收者  const address = channel.options.address;  this.broadcastChannel.postMessage({    action:
    "CHANNEL_DEPLOYED", address  });  // 使用存款和通道对象更新发送者状态  this.setState({ channel,
    deposit, sent: BN(0) });}8-4清单'
- en: Sender component function to deploy the payment channel contract, fund it, and
    notify the recipient of its deployment. The App component passes the web3 instance
    and the sender and recipient addresses as props. Here, PaymentChannel is a function
    that returns a new web3 contract instance, and BN is a BigNumber constructor
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 发送者组件函数，用于部署支付通道合约，资助它，并通知接收者已部署。应用组件将web3实例和发送者和接收者地址作为props传递。在这里，PaymentChannel是一个返回新的web3合约实例的函数，而BN是一个BigNumber构造函数。
- en: We will wire this function to a simple form (Figure [8-2](#Fig2)), where we
    ask the user to choose the amount of ETH they want to deposit on the channel.![../images/476252_1_En_8_Chapter/476252_1_En_8_Fig2_HTML.jpg](../images/476252_1_En_8_Chapter/476252_1_En_8_Fig2_HTML.jpg)
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将此函数连接到一个简单的表单（见[8-2](#Fig2)），在该表单中，我们要求用户选择要在通道上存入的ETH金额。![../images/476252_1_En_8_Chapter/476252_1_En_8_Fig2_HTML.jpg](../images/476252_1_En_8_Chapter/476252_1_En_8_Fig2_HTML.jpg)
- en: Figure 8-2
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-2
- en: Simple payment channel deployment form. The code for this form can be found
    in src/components/CreateChannel.js
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的支付通道部署表单。此表单的代码可以在src/components/CreateChannel.js中找到。
- en: 'Once the channel is deployed, our user should be able to send micropayments
    to the recipient^([7](#Fn7)) (Listing [8-5](#PC5)). This means signing messages
    (not sending transactions) that include the total amount of ETH to be paid out
    to the recipient once the channel is closed. These messages are sent to the recipient
    via the same broadcast channel using a different action identifier.// src/components/Sender.jsasync
    sendEth(value) {  const { web3, sender } = this.props;  const { sent, channel
    } = this.state;  // Calculate new accumulated ETH sent  const newSent = sent.plus(value);  //
    Sign it with the sender''s key  const signature = await signPayment(    web3,
    newSent, channel.options.address, sender  );  // Send the message to the recipient  this.broadcastChannel.postMessage({    action:
    "PAYMENT", sent: newSent.toString(), signature  });  // Update state with new
    total accumulated ETH sent  this.setState({ sent: newSent });}Listing 8-5'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '一旦通道部署完成，我们的用户应该能够向收件人发送微支付^([7](#Fn7))（见[8-5](#PC5)）。这意味着签署消息（而不是发送交易），其中包括了一旦通道关闭时要支付给收件人的总以太币金额。这些消息通过相同的广播通道以不同的操作标识符发送给收件人。//
    src/components/Sender.jsasync sendEth(value) {  const { web3, sender } = this.props;  const
    { sent, channel } = this.state;  // 计算新的累积以太币发送量  const newSent = sent.plus(value);  //
    使用发送者的密钥进行签名  const signature = await signPayment(    web3, newSent, channel.options.address,
    sender  );  // 将消息发送给收件人  this.broadcastChannel.postMessage({    action: "PAYMENT",
    sent: newSent.toString(), signature  });  // 使用新的累积以太币发送量更新状态  this.setState({
    sent: newSent });}Listing 8-5'
- en: Sender function to send a micropayment to the recipient. Each message carries
    the total amount of ETH to be paid out. The component needs to keep track of the
    total sent so far, so the micropayment amount chosen by the user is added to that
    value before being signed and sent
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 发件人功能，用于向收件人发送微支付。每条消息携带要支付的以太币总额。该组件需要跟踪到目前为止已发送的总量，因此用户选择的微支付金额会在签名和发送之前添加到该值中。
- en: 'The signature is calculated on the hash of the total value to pay and the channel’s
    address (Listing [8-6](#PC7)). Including the channel’s address in the signature
    prevents *replay attacks*, that is, reusing the same message in another channel
    opened by the same user.// src/contracts/PaymentChannel.jsasync function signPayment(web3,
    value, address, sender) {  const hash = web3.utils.soliditySha3(    { type: ''uint256'',
    value: value.toString() },    { type: ''address'', value: address }  );  const
    signature = await web3.eth.sign(hash, sender);  return signature;}Listing 8-6'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '签名是根据要支付的总值的哈希和通道地址计算的（见[8-6](#PC7)）。在签名中包含通道地址可以防止*重放攻击*，即在同一用户打开的另一个通道中重用相同的消息。//
    src/contracts/PaymentChannel.jsasync function signPayment(web3, value, address,
    sender) {  const hash = web3.utils.soliditySha3(    { type: ''uint256'', value:
    value.toString() },    { type: ''address'', value: address }  );  const signature
    = await web3.eth.sign(hash, sender);  return signature;}Listing 8-6'
- en: Signing each micropayment message using web3^([8](#Fn8))
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 web3 对每个微支付消息进行签名^([8](#Fn8))
- en: Similar to the channel deployment, this action is presented to the user in a
    simple form where they choose the amount to transfer (Figure [8-3](#Fig3)). We
    can also show some basic stats on the channel, such as its address, the total
    deposit, and how much ETH has been committed so far.![../images/476252_1_En_8_Chapter/476252_1_En_8_Fig3_HTML.jpg](../images/476252_1_En_8_Chapter/476252_1_En_8_Fig3_HTML.jpg)
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于通道部署，这个动作以一个简单的形式呈现给用户，在这个形式中，用户选择要转移的金额（图 [8-3](#Fig3)）。我们还可以显示有关通道的一些基本统计信息，如其地址、总存款和到目前为止已经承诺了多少
    ETH。
- en: Figure 8-3
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-3
- en: Presenting the user the channel information and requesting the value to send
    via the channel. The code for these components can be found in src/components/ChannelStats.js
    and src/components/SendEther.js
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 展示用户通道信息并请求通过通道发送的值。这些组件的代码可以在 src/components/ChannelStats.js 和 src/components/SendEther.js
    中找到。
- en: Note
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For the sake of brevity, we will skip the implementation of the forceClose call
    by the sender in this example.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁起见，在这个例子中，我们将跳过发送者在示例中调用 forceClose 的实现。
- en: We can now turn our focus to the recipient view. Within our app, the recipient
    needs to do nothing but monitor the sender’s actions until they decide to cash
    out. We will first install a listener for the sender’s messages to react upon
    them (Listing [8-7](#PC8)), calling different functions depending on the message
    action (Listing [8-8](#PC9)).// src/components/Recipient.jsconst bc = new BroadcastChannel('payments');bc.onmessage
    = (evt) => this.handleMessage(evt.data);this.broadcastChannel = bc;Listing 8-7
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以把重点转向接收者视图了。在我们的应用程序中，接收者除了监视发送者的操作之外什么也不需要做，直到他们决定兑现。我们将首先为发送者的消息安装一个监听器，以便对其做出反应（见列表
    [8-7](#PC8)），根据消息动作调用不同的函数（见列表 [8-8](#PC9)）。// src/components/Recipient.jsconst
    bc = new BroadcastChannel('payments');bc.onmessage = (evt) => this.handleMessage(evt.data);this.broadcastChannel
    = bc;Listing 8-7
- en: Initializing a new broadcast channel for receiving messages from the sender
    and adding an event handler. This code is part of the Recipient component constructor
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化一个新的广播通道以接收来自发送者的消息并添加事件处理程序。此代码是 Recipient 组件构造函数的一部分。
- en: // src/components/Recipient.jshandleMessage(data) {  const action = data.action;  switch
    (action) {    case "CHANNEL_DEPLOYED":      this.onChannelDeployed(data);      break;    case
    "PAYMENT":      this.onPaymentReceived(data);      break;    default:      console.error("Unexpected
    message", data);  }}Listing 8-8
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: // src/components/Recipient.jshandleMessage(data) {  const action = data.action;  switch
    (action) {    case "CHANNEL_DEPLOYED":      this.onChannelDeployed(data);      break;    case
    "PAYMENT":      this.onPaymentReceived(data);      break;    default:      console.error("Unexpected
    message", data);  }}Listing 8-8
- en: Delegating to different handler functions, discriminating on the message action
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 委托给不同的处理程序函数，根据消息动作进行区分。
- en: 'Let’s see first how the recipient should react to a new channel deployed (Listing
    [8-9](#PC10)). Besides updating its own state by adding a reference to the channel,
    the recipient should inspect the channel’s deposit to know up to how much the
    sender is able to pay. The recipient should also check that the contract deployed
    is indeed a payment channel. We can do that by checking that the bytecode deployed
    matches the code of the channel (Listing [8-10](#PC11)).// src/components/Recipient.jsasync
    onChannelDeployed(data) {  const { web3 } = this.props;  if (!await checkBytecode(web3,
    data.address)) {    console.error("Contract bytecode does not match");    return;  }  const
    deposit = await web3.eth.getBalance(data.address);  this.setState({    channel:
    PaymentChannel(web3, data.address),    deposit: BN(deposit),    received: BN(0)  });}Listing
    8-9'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 首先让我们看一下收件人应如何对部署的新通道做出反应（清单[8-9](#PC10)）。除了通过添加对通道的引用来更新自己的状态之外，收件人还应检查通道的存款以了解发送方能够支付的最大金额。收件人还应检查部署的合同确实是一个付款通道。我们可以通过检查部署的字节码是否与通道的代码匹配来做到这一点（清单[8-10](#PC11)）。//
    src/components/Recipient.js异步onChannelDeployed（数据）{  const { web3 } = this.props;  if（！await
    checkBytecode（web3，data.address））{    console.error（"合同字节码不匹配"）;    返回;  }  const
    deposit = await web3.eth.getBalance（data.address）;  这.setState（{    channel：PaymentChannel（web3，data.address），    存款：BN（存款），    received：BN（0）  }）;}清单
    8-9
- en: Recipient reacts to a new channel deployed by validating it, retrieving its
    deposit, and updating its own state. Here, PaymentChannel is a function that returns
    a web3 contract instance at the specified address
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 收件人通过验证新部署的通道来做出反应，检索其存款，并更新自己的状态。在这里，PaymentChannel是一个在指定地址返回web3合同实例的函数
- en: // src/components/Recipient.jsasync function checkBytecode(web3, address) {  const
    actual = await web3.eth.getCode(address);  const { compilerOutput } = Artifact;  const
    expected = compilerOutput.evm.deployedBytecode.object;  return actual === expected;}Listing
    8-10
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: // src/components/Recipient.js异步函数检查字节码（web3，地址）{  const actual = await web3.eth.getCode（地址）;  const
    { compilerOutput } = Artifact;  const expected = compilerOutput.evm.deployedBytecode.object;  return
    actual === expected;}清单 8-10
- en: Checking the bytecode deployed at an address against the one in the contract
    compiled Artifact. Note that we check against the deployedBytecode of the contract,
    not the bytecode, since the latter includes the constructor code that is not saved
    in the blockchain
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 验证地址部署的字节码与合同编译的字节码相匹配。请注意，我们检查合同的deployedBytecode，而不是字节码，因为后者包括未保存在区块链中的构造函数代码
- en: 'The other message the recipient has to process is a payment message. Here,
    we need to validate the sender’s signature and update the recipient state with
    the latest value transferred (Listing [8-11](#PC12)). We also need to save the
    associated signature, as we will need it to close the channel.// src/components/Recipient.jsonPaymentReceived(data)
    {  const sent = BN(data.sent);  const received = this.state.received;  if (this.verifyMessage(data)
    && sent.gt(received)) {    this.setState({      received: sent,      signature:
    data.signature    });  }}verifyMessage(data) {  const { web3, sender } = this.props;  const
    { channel } = this.state;  const signer = recoverPayment(    web3, data.sent,
    channel.options.address, data.signature  );  return areAddressesEqual(signer,
    sender);}Listing 8-11'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 收款方必须处理的另一条消息是支付消息。在这里，我们需要验证发送者的签名，并使用最新传输的值更新收款方状态（见列表 [8-11](#PC12)）。我们还需要保存关联的签名，因为我们将需要它来关闭通道。
- en: Recipient reacts to a payment message, updating the total ETH received and the
    corresponding signature. Validating each message implies recovering the signing
    address and checking it against the sender, since an invalid signature would yield
    a different signer address. We also discard any messages with a total payment
    less than the latest total
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 收款方对支付消息做出反应，更新收到的总 ETH 数量和相应的签名。验证每条消息意味着恢复签名地址并检查其与发送者是否匹配，因为无效的签名将产生不同的签名地址。我们还会丢弃任何总支付金额少于最新总额的消息。
- en: 'Recovering the sender’s signature can then be implemented using the recover
    method from the web3 library (Listing [8-12](#PC13)).// src/contracts/PaymentChannel.jsfunction
    recoverPayment(web3, value, address, signature) {  const hash = web3.utils.soliditySha3(    {
    type: ''uint256'', value: value.toString() },    { type: ''address'', value: address
    }  );  return web3.eth.accounts.recover(hash, signature);}Listing 8-12'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，可以使用 web3 库中的 recover 方法来实现恢复发送者的签名（见列表 [8-12](#PC13)）。
- en: Helper function to recover the signer of a payment message. Note that the hash
    over which the signature is recovered is calculated exactly like in the signPayment
    method
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 恢复支付消息签名者的辅助函数。请注意，签名恢复的哈希与 signPayment 方法中计算的完全相同。
- en: The recipient is shown the current state of the channel, the total ETH received,
    as well as the option to close the channel at any time (Figure [8-4](#Fig4)).![../images/476252_1_En_8_Chapter/476252_1_En_8_Fig4_HTML.jpg](../images/476252_1_En_8_Chapter/476252_1_En_8_Fig4_HTML.jpg)
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 收件人展示了通道的当前状态，总共接收到的以太币数量，以及随时关闭通道的选项（图 [8-4](#Fig4)）。![../images/476252_1_En_8_Chapter/476252_1_En_8_Fig4_HTML.jpg](../images/476252_1_En_8_Chapter/476252_1_En_8_Fig4_HTML.jpg)
- en: Figure 8-4
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-4
- en: Recipient interface with information on current balance and channel stats, including
    how much ETH has been sent via the channel
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 收件人接口，显示当前余额和通道状态信息，包括通过通道发送的以太币数量
- en: 'The last step to implement on the recipient is closing the channel by sending
    a transaction to the channel contract with the latest value and signature (Listing
    [8-13](#PC14)). This settles all micropayments by sending the accumulated value
    to the recipient and the remainder of the deposit back to the sender.// src/components/Recipient.jsasync
    closeChannel() {  const { web3, recipient } = this.props;  const { channel, signature,
    received } = this.state;  // Send closing transaction  await channel.methods.close(    received.toString(),
    signature  ).send({ from: recipient });  // Update the recipient''s balance  const
    balance = BN(await web3.eth.getBalance(recipient));  this.setState({ channel:
    null, balance });}Listing 8-13'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 收件人实现的最后一步是通过向通道合约发送带有最新值和签名的交易来关闭通道（参见 [8-13](#PC14)）。这将通过向收件人发送累积值并将存款余额返回给发送者来结算所有的微支付。
- en: Closing the channel by the recipient using the latest value and signature sent
    by the sender
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 收件人使用发送者发送的最新值和签名关闭通道
- en: After this method is called, the channel contract should be destroyed, and the
    recipient should have received the sum of all micropayments made by the sender.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 调用此方法后，频道合约应被销毁，并且收件人应该已经收到发送者所做的所有微支付的总和。
- en: Now that we have a working application built on top of unidirectional payment
    channels, it’s time to move into more interesting flavors of channels.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经建立了一个建立在单向支付通道之上的工作应用程序，是时候进入更有趣的通道变体了。
- en: Bidirectional Payment Channels
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 双向支付通道
- en: Another scenario for payment channels is that of two equal parties exchanging
    funds between each other. Instead of having a distinguished sender and a recipient,
    both participants in the channel can send and receive funds.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种支付通道的场景是两个相等的参与方之间互换资金。不再有区分发送者和接收者，通道中的每个参与者都可以发送和接收资金。
- en: This symmetry in the participants’ roles makes the channel implementation more
    difficult. Which of the two participants should be allowed to close the channel
    in this model? Since they are equals, they both should be allowed to do so, but
    this introduces a problem.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 参与者角色的对称性使得通道实现更加困难。在这个模型中，这两个参与者中的哪一个应该被允许关闭通道？由于他们是平等的，他们都应该被允许这样做，但这引入了一个问题。
- en: Let’s say Alice and Bob are exchanging microtransactions. At some point, Bob
    sends a very large payment through the channel to Alice, but before she can cash
    out, he submits an old message to the channel and closes it. The problem then
    is that a malicious participant can attempt to close the channel *at an older
    state* when it is convenient for them (Figure [8-5](#Fig5)).![../images/476252_1_En_8_Chapter/476252_1_En_8_Fig5_HTML.jpg](../images/476252_1_En_8_Chapter/476252_1_En_8_Fig5_HTML.jpg)
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 Alice 和 Bob 正在进行微交易。在某个时刻，Bob 通过通道向 Alice 发送了一笔非常大的付款，但在她能兑现之前，他向通道提交了一条旧消息并关闭了通道。然后问题是，恶意参与者可以在方便的时候尝试将通道关闭至*更早状态*（见图[8-5](#Fig5)）。![../images/476252_1_En_8_Chapter/476252_1_En_8_Fig5_HTML.jpg](../images/476252_1_En_8_Chapter/476252_1_En_8_Fig5_HTML.jpg)
- en: Figure 8-5
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-5
- en: Bidirectional payment channel scenario in which Bob attempts to close the channel
    with an older state, in detriment of Alice
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Bob 尝试使用更旧的状态关闭通道的双向支付通道场景，损害了 Alice
- en: Challenge Periods
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战期
- en: This situation is solved by adding a *challenge period* to the closure of the
    channel. When Bob requests the channel to be closed, it goes into a “closing”
    state for a fixed period of time. During this period, Alice can either confirm
    the closure of the channel, or she can submit a more recent state and start a
    new closing period (Figure [8-6](#Fig6)).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在通道关闭时添加*挑战期*来解决这种情况。当 Bob 请求关闭通道时，通道进入“关闭”状态一段固定时间。在此期间，Alice 可以确认通道关闭，或者她可以提交更近期的状态并开始新的关闭期（见图[8-6](#Fig6)）。
- en: If she fails to send any transaction to the channel during the challenge period,
    then the channel is closed and the payouts executed according to the state submitted
    by Bob. This last case is the equivalent of the recipient not submitting a message
    and having the sender run a forced close. So, adding a challenge period removes
    the need for having a predefined end time for the channel.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在挑战期内她未向通道发送任何交易，则通道关闭，并根据 Bob 提交的状态执行支付。这种情况等同于接收方未提交消息并导致发送方进行强制关闭。因此，添加挑战期可消除通道的预定义结束时间需求。
- en: Note
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Challenge periods are a very common mechanism in layer 2 solutions, not just
    channels, as we will see later in this chapter. These allow an action to be carried
    away unilaterally without having to collect confirmations from every other party,
    but still let them watch for unlawful behavior and act upon it.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 挑战期是第二层解决方案中非常常见的机制，不仅限于通道，正如我们将在本章后面看到的那样。这使得可以单方面执行一个动作，而无需从每个其他参与方收集确认，但仍然让它们注意到不法行为并采取行动。
- en: This mechanism requires the smart contract to recognize when a message is *more
    recent* than another. In other words, it requires adding a notion of *ordering*
    to the messages interchanged by Alice and Bob. In the previous example, this allows
    the channel to be able to verify that Alice’s message is more recent than Bob’s
    and hence discard Bob’s in favor of Alice’s.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这种机制要求智能合约识别一条消息是否比另一条消息*更新*。换句话说，它需要在Alice和Bob之间交换的消息中添加*排序*的概念。在先前的示例中，这使得通道能够验证Alice的消息比Bob的消息更新，并因此放弃Bob的消息而选择Alice的消息。
- en: 'This ordering is handled within the protocol by adding a counter or *nonce*
    to each message, which is increased with each message sent. Both parties should
    validate that the nonce is properly increased on each message: if one receives
    a signed message with a repeated nonce, they should immediately discard it.![../images/476252_1_En_8_Chapter/476252_1_En_8_Fig6_HTML.png](../images/476252_1_En_8_Chapter/476252_1_En_8_Fig6_HTML.png)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这种排序是通过在每条消息中添加一个计数器或*nonce*来处理的，该计数器随每条发送的消息增加。双方都应验证nonce在每条消息上是否正确增加：如果其中一方收到带有重复nonce的签名消息，他们应立即丢弃它。![../images/476252_1_En_8_Chapter/476252_1_En_8_Fig6_HTML.png](../images/476252_1_En_8_Chapter/476252_1_En_8_Fig6_HTML.png)
- en: Figure 8-6
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-6
- en: Continuation of the previous scenario. Alice sees that Bob attempted to submit
    an older state and submits S2 in response. After the challenge period ends, the
    contract executes the payouts according to the most recent state submitted, S2
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 继续前一个场景。Alice看到Bob试图提交一个旧状态，并提交S2作为回应。挑战期结束后，合约根据提交的最新状态S2执行支付。
- en: 'These challenge mechanics have an important drawback: parties in the channel
    cannot be offline for any longer than the length of the challenge period. In our
    Alice and Bob example, if the channel has a challenge period of a few hours, Bob
    could just submit the state that is convenient for him while Alice is offline,
    so when she comes back online, the channel would already be closed. On the other
    hand, extremely long challenge periods can lead to locked deposits for long periods
    of time, if Bob attempts to rightfully close the channel and Alice never accepts
    the closure. Choosing the correct challenge period will depend heavily on the
    use case where the channel is deployed.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这些挑战机制有一个重要的缺点：通道中的各方不能离线时间超过挑战期限的长度。在我们的Alice和Bob示例中，如果通道的挑战期限为几个小时，Bob可以在Alice离线时提交对他方便的状态，因此当她重新上线时，通道已经关闭。另一方面，极长的挑战期限可能导致存款长时间被锁定，如果Bob试图合理关闭通道而Alice从未接受关闭。选择正确的挑战期限将严重依赖通道部署的用例。
- en: Note
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As a complement to channels, there are *watchtower* services that can monitor
    a channel on behalf of the user in case they go offline and their counterpart
    attempts to unlawfully close the channel. These providers may demand a fee in
    exchange for their services proportional to the value locked in the channel.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 作为通道的补充，有*监视塔*服务，可以代表用户监视通道，以防他们离线并且他们的对方试图非法关闭通道。这些提供者可能会要求按通道中锁定的价值比例收取服务费。
- en: A Sample Exchange
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 一个样本交换
- en: 'To ensure incentives are aligned, Alice signs messages where the balance changes
    in favor of Bob and the other way around. A sample scenario, where both start
    with a deposit of 1 ETH, could be the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保激励是对齐的，Alice 签署了在余额对 Bob 有利变化的消息，反之亦然。一个示例场景，其中两者都以 1 ETH 的存款开始，可能是以下情况：
- en: Alice signs 0.4 ETH by signing balances (0.6, 1.4)^([9](#Fn9)) with nonce 1.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Alice 通过签署余额（0.6, 1.4）^([9](#Fn9)) 使用 nonce 1 签署了 0.4 ETH。
- en: Bob signs 0.3 ETH by signing balances (0.9, 1.1) with nonce 2.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bob 签署了 0.3 ETH，通过签署余额（0.9, 1.1），使用 nonce 2。
- en: Alice signs 0.1 ETH by signing balances (0.8, 1.2) with nonce 3.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Alice 通过签署余额（0.8, 1.2）使用 nonce 3 签署了 0.1 ETH。
- en: Alice signs 0.1 ETH by signing balances (0.7, 1.3) with nonce 4.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Alice 通过签署余额（0.7, 1.3）使用 nonce 4 签署了 0.1 ETH。
- en: 'Let’s go through some possible scenarios based on this set of messages:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们根据这组消息进行一些可能的情景分析：
- en: When the exchange ends, Bob rightfully picks the latest message signed by Alice
    and uses it to close the channel. Note that it never makes sense for him to pick
    nonce 3 over 4, since 4 has a balance more beneficial to him, as it corresponds
    to a payment made by Alice.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当交换结束时，Bob 正当地选择了由 Alice 签署的最新消息，并将其用于关闭通道。请注意，对他来说选择 nonce 3 而不是 4 永远没有意义，因为
    4 对他更有利，因为它对应了 Alice 的一次支付。
- en: 'Bob never signs another message and never closes the channel. In response,
    Alice uploads the last message that was beneficial to her: the last one signed
    by Bob (nonce 2). She has no reason to submit any of the more recent ones where
    she performs additional payments. Alternatively, she could also attempt to close
    the channel as if no messages were exchanged.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bob 没有签署另一条消息，也没有关闭通道。作为回应，Alice 上传了对她有利的最后一条消息：由 Bob 签署的最后一条（nonce 2）。她没有理由提交任何更近的消息，其中她进行了额外的支付。或者，她也可以尝试关闭通道，就好像没有交换过任何消息一样。
- en: Alice maliciously uploads the message with nonce 2 to try to close the channel.
    Bob should immediately submit a more recent message, preferably the one with nonce
    4.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Alice 恶意上传了具有 nonce 2 的消息，试图关闭通道。Bob 应立即提交更近的消息，最好是具有 nonce 4 的消息。
- en: Bob maliciously attempts to close the channel with the message with nonce 1,
    where the balance was most in his favor. Then, Alice should submit the message
    with nonce 2 in response, as it is a more beneficial situation to her. This takes
    us to the previous scenario, where Bob should submit nonce 4.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bob 恶意尝试关闭具有 nonce 1 的消息的通道，在该消息中，余额对他最有利。然后，Alice 应提交具有 nonce 2 的消息作为回应，因为这对她更有利。这将我们带回了之前的情景，Bob
    应提交 nonce 4。
- en: As we can see, by signing a message with increasing nonce with each micropayment,
    participants are then incentivized to always submit the latest message signed
    by their counterparty. This leads to the most recent message being used to close
    the channel.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，通过使用逐笔支付时递增的 nonce 对消息进行签名，参与者被激励始终提交其对方签署的最新消息。这导致最近的消息被用于关闭通道。
- en: Implementing a Bidirectional Channel
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 实现双向通道
- en: We will now implement a sample bidirectional state channel (Listing [8-14](#PC15)).
    In our implementation, any user can request the channel’s closure by providing
    a signed message by the other user. The payouts can then be executed either when
    the other party confirms it or when the challenge period ends.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将实现一个示例双向状态通道（见列表 [8-14](#PC15)）。在我们的实现中，任何用户都可以通过提供对方用户的签名消息来请求通道的关闭。然后可以在对方确认或挑战期结束时执行支付。
- en: Our channel will keep track of the balance of each user, initialized to the
    deposit that each of them made. The channel is created by one of the users and
    then joined by the second as they make their own deposit.^([10](#Fn10))contract
    BidirectionalPaymentChannel {  using ECDSA for bytes32;  uint256 constant closePeriod
    = 1 days;  address payable user1;  address payable user2;  uint256 balance1;  uint256
    balance2;  uint256 lastNonce;  uint256 closeTime;  address closeRequestedBy;  constructor(address
    payable _user2) public payable {    balance1 = msg.value;    user1 = msg.sender;    user2
    = _user2;  }  function join() public payable {    require(msg.sender == user2
    && balance2 == 0);    balance2 = msg.value;  }}Listing 8-14
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的通道将跟踪每个用户的余额，初始为他们各自存入的押金。通道由其中一个用户创建，然后由第二个用户加入，当他们自己存入押金时。^([10](#Fn10))contract
    BidirectionalPaymentChannel {  using ECDSA for bytes32;  uint256 constant closePeriod
    = 1 days;  address payable user1;  address payable user2;  uint256 balance1;  uint256
    balance2;  uint256 lastNonce;  uint256 closeTime;  address closeRequestedBy;  constructor(address
    payable _user2) public payable {    balance1 = msg.value;    user1 = msg.sender;    user2
    = _user2;  }  function join() public payable {    require(msg.sender == user2
    && balance2 == 0);    balance2 = msg.value;  }}列表 8-14
- en: Contract variables and initialization functions of our bidirectional state channel
    implementation. We are using the same ECDSA library as in the unidirectional implementation
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们双向状态通道实现的合约变量和初始化函数。我们使用的是与单向实现相同的 ECDSA 库。
- en: Having the setup ready, we can now look into the close function of our contract
    (Listing [8-15](#PC16)). This function is similar to the one from the unidirectional
    channel, in that it validates the user’s signature over the state. However, instead
    of executing the payout on the spot, it starts the challenge (or closing) period.function
    closeWithState(  uint256 newBalance1, uint256 newBalance2,  uint256 nonce, bytes
    memory signature) public {  // Check that sender is a user, state is sound, and  //
    the nonce is increased in case of a challenge  require(msg.sender == user1 ||
    msg.sender == user2);  require(nonce > lastNonce);  require(newBalance1 + newBalance2
    == address(this).balance);  // Validate that the signature belongs to the other
    user  bytes32 hash = keccak256(abi.encodePacked(    newBalance1, newBalance2,
    nonce, address(this)  )).toEthSignedMessageHash();  address signer = hash.recover(signature);  require(signer
    == user1 || signer == user2);  require(signer != msg.sender);  // Update balances,
    nonce, and start a challenge period  balance1 = newBalance1;  balance2 = newBalance2;  lastNonce
    = nonce;  closeRequestedBy = msg.sender;  closeTime = now;}Listing 8-15
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 准备就绪后，我们现在可以查看合同的关闭函数（见[8-15](#PC16)）。此函数与单向通道中的函数类似，因为它验证了用户对状态的签名。然而，与立即执行支付不同的是，它开始了挑战（或关闭）期。函数
    closeWithState(  uint256 newBalance1, uint256 newBalance2,  uint256 nonce, bytes
    memory signature) public {  // 检查发件人是否为用户，状态是否正常，如果挑战，则 nonce 是否增加  require(msg.sender
    == user1 || msg.sender == user2);  require(nonce > lastNonce);  require(newBalance1
    + newBalance2 == address(this).balance);  // 验证签名是否属于另一个用户  bytes32 hash = keccak256(abi.encodePacked(    newBalance1,
    newBalance2, nonce, address(this)  )).toEthSignedMessageHash();  address signer
    = hash.recover(signature);  require(signer == user1 || signer == user2);  require(signer
    != msg.sender);  // 更新余额、nonce，并开始挑战期  balance1 = newBalance1;  balance2 = newBalance2;  lastNonce
    = nonce;  closeRequestedBy = msg.sender;  closeTime = now;}见 8-15
- en: Closing function for the bidirectional state channel. It can be called by any
    of the participants, as long as they submit a message signed by the other user,
    with a more recent nonce than the last one submitted (if there was one)
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为双向状态通道关闭的结束函数。只要参与者之一提交了由另一用户签名的消息，并且其 nonce 比上一次提交的新（如果有的话），就可以调用该函数。
- en: Now we need to add a function to actually close the channel, callable either
    by the user who did not start the closure in the first place or after the challenge
    period ended (Listing [8-16](#PC17)).function confirmClose() public {  require(msg.sender
    == user1 || msg.sender == user2);  bool challengeEnded = closeTime != 0    &&
    closeTime + closePeriod > now;  require(closeRequestedBy != msg.sender || challengeEnded);  user2.send(balance2);  selfdestruct(user1);}Listing
    8-16
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要添加一个实际关闭通道的函数，可由未在首次发起关闭的用户或在挑战期结束后调用（见[8-16](#PC17)）。函数 confirmClose()
    public {  require(msg.sender == user1 || msg.sender == user2);  bool challengeEnded
    = closeTime != 0    && closeTime + closePeriod > now;  require(closeRequestedBy
    != msg.sender || challengeEnded);  user2.send(balance2);  selfdestruct(user1);}见
    8-16
- en: Effectively closing a bidirectional payment channel and executing the payouts
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 有效地关闭双向支付通道并执行支付。
- en: Note
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We are using send instead of transfer in confirmClose to protect against an
    attack. If user2 is a contract account instead of an EOA, it can be coded to revert
    on every incoming transaction. This would make it impossible for user1 to ever
    close the channel and recover the initial deposit, since the transfer call to
    user2 would fail, and revert the entire transaction. By using send, the sending
    of ETH may fail, but the close is allowed to succeed.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在confirmClose中使用send而不是transfer来防止攻击。如果user2是一个合约账户而不是EOA，它可以被编码为在每笔传入交易时回滚。这将使得user1无法关闭通道并恢复初始存款，因为对user2的转账调用将失败，并回滚整个交易。通过使用send，以太币的发送可能会失败，但关闭允许成功进行。
- en: Our implementation needs one last function to be complete. In case one of the
    users never signed any messages, the other needs to be able to request a closure,
    transferring the initial deposits back to each user (Listing [8-17](#PC18)). Otherwise,
    the funds of the user who created the channel in the first place could end up
    locked for good.function close() public {  require(msg.sender == user1 || msg.sender
    == user2);  require(closeTime == 0);  closeRequestedBy = msg.sender;  closeTime
    = now;}Listing 8-17
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的实现需要最后一个函数才能完成。如果其中一个用户从未签署任何消息，另一个用户需要能够请求关闭，并将初始存款退还给每个用户（见[8-17](#PC18)）。否则，首先创建通道的用户的资金可能会永久锁定。函数
    close() public {  require(msg.sender == user1 || msg.sender == user2);  require(closeTime
    == 0);  closeRequestedBy = msg.sender;  closeTime = now;}Listing 8-17
- en: Starting a channel closure from the initial state
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 从初始状态开始关闭通道
- en: Note that any user could still call closeWithState after close, in case a party
    maliciously attempted to close the channel on the initial state.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，任何用户仍然可以在关闭后调用closeWithState，以防某一方恶意尝试在初始状态下关闭通道。
- en: Optimizations and Extensions
  id: totrans-122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 优化和扩展
- en: 'The implementations we have reviewed so far of payment channels are relatively
    simple, but there is much room for improvement:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经审查过的支付通道实现相对简单，但仍有很大的改进空间：
- en: One possible optimization is having a *single contract* for managing all channels.
    Instead of deploying one contract per channel, each channel is actually a struct
    stored in a single payment channel contract. This greatly reduces the cost of
    creating a new channel, but at the expense of added complexity. Furthermore, it
    centralizes the funds of all participants in a single contract, opening the door
    for bugs that could let an attacker drain the funds from all channels simultaneously.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种可能的优化是使用*单一合约*来管理所有通道。与为每个通道部署一个合约相反，每个通道实际上是存储在单个支付通道合约中的结构。这大大降低了创建新通道的成本，但以增加的复杂性为代价。此外，它将所有参与者的资金集中在单个合约中，为可能使攻击者同时从所有通道中提取资金的错误打开了大门。
- en: Channels could also be modified to be reused. In our implementations, we required
    the channel to be closed to execute the payouts, but we could leave the channel
    open after a payout is executed. This allows for part of the funds to be withdrawn
    to be used in other applications, without having to destroy the channel contract.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通道也可以修改为可重用。在我们的实现中，我们要求在执行支付之前关闭通道，但在支付执行后可以保持通道开放。这允许部分资金被提取用于其他应用，而无需销毁通道合约。
- en: In the case of bidirectional channels, channel closure can be optimized by adding
    a special message, signed by both users, that signals the agreed finalization
    at a certain state. This message can be uploaded by any participant and does not
    require either a second transaction to confirm the closure or going through the
    challenge period.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于双向通道，可以通过添加由两个用户签署的特殊消息来优化通道关闭，该消息表示在某个状态下达成的协议完成。这条消息可以由任何参与者上传，并且不需要第二笔交易来确认关闭或经过挑战期。
- en: An interesting extension to channels is to increase the number of participants.
    While in all of our examples we explore peer-to-peer channels with two members,
    a larger number of users can be involved. Coordination may become more complex
    as the number of users increase, since messages may be required to be signed by
    several participants in the channel to be considered valid.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通道的一个有趣扩展是增加参与者的数量。尽管在我们的所有示例中，我们探讨了具有两个成员的点对点通道，但更多用户可以参与其中。随着用户数量的增加，协调可能会变得更加复杂，因为可能需要多个通道参与者签署消息才能被视为有效。
- en: State Channels
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 状态通道
- en: Payment channels can be seen as a specific case of a more general class of channels
    called *state channels* . Instead of having two parties exchanging signed messages
    regarding the state of balance to be paid out, state channels allow users to exchange
    messages regarding *any state*.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 支付通道可以看作是一种更普遍的通道类别的特例，称为*状态通道*。与两个方当事人交换有关待支付余额状态的签名消息不同，状态通道允许用户交换关于*任何状态*的消息。
- en: As an example, a simple game could be carried over a state channel. The players
    can sign messages on the state of the game, such as the placement of the pieces
    in a board. Moving a piece is done by sending signed messages with the move or
    the new configuration of the board.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 举例来说，一个简单的游戏可以通过状态通道进行。玩家可以在游戏状态上签署消息，例如棋盘上的棋子摆放。移动棋子通过发送带有移动或棋盘新配置的签名消息完成。
- en: State channels typically involve an initial deposit and a payout, much like
    payment channels. The conditions that rule the payout are defined by a game and
    can be enforced on-chain by a smart contract.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 状态通道通常涉及初始存款和支付，就像支付通道一样。规定支付条件的是游戏，并且可以由智能合约在链上执行。
- en: Coding a Game into a State Channel
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将游戏编码到状态通道中
- en: Turn-based games are an excellent use case for a state channel, since they have
    some useful properties. For one, all of the game state can be safely exchanged
    between messages and processed on-chain if needed. Also, at any point in time,
    it is well-defined which player should play next, and there can be no disputes
    regarding who made a move first. Furthermore, the game’s state is all that is
    needed to resolve a challenge, as they do not depend on any external state.^([11](#Fn11))
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 回合制游戏是状态通道的一个绝佳应用案例，因为它们具有一些有用的特性。首先，所有游戏状态都可以在消息之间安全地交换，并在需要时在链上处理。此外，在任何时刻，都很明确哪位玩家应该下一步行动，并且关于谁先行动的争论是不存在的。此外，游戏的状态是解决挑战所需的全部内容，因为它们不依赖于任何外部状态。^([11](#Fn11))
- en: 'Let’s use the tic-tac-toe game as an example. The state can be defined as a
    3x3 matrix with three possible values per cell: circle, cross, or empty. The rules
    of the game are easy to encode, as well as the winning (or draw) conditions.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以井字棋游戏为例。状态可以定义为一个3x3的矩阵，每个单元格有三个可能的值：圆圈、叉叉或空白。游戏规则容易编码，以及获胜（或平局）的条件。
- en: 'Here, players will exchange messages with their moves, which can only be placing
    down one of their tokens. However, unlike in payment channels, each move (i.e.,
    each message) is *beneficial to the player who plays (signs) it* and not to the
    recipient. This poses a major shift in mechanics: a player is no longer incentivized
    to post the latest state submitted by their opponent, but the last move made *by
    themselves*. Let’s see an example:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，玩家将通过他们的动作交换消息，每个动作只能是放下他们的一个标记。然而，与支付通道不同，每个动作（即每个消息）都对进行动作的玩家（签名者）有利，而不是对接收者有利。这带来了一个重大的机制转变：玩家不再被激励发布对手提交的最新状态，而是最后由自己做出的动作。让我们看一个例子：
- en: Alice plays X in the center, so she signs a message with only an X in the center
    and nonce 1, and sends it to Bob.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Alice在中间放置X，因此她签署了一个消息，只有中间有一个X和nonce 1，然后将其发送给Bob。
- en: Bob plays O in mid-right, signs with nonce 2, and sends it to Alice.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bob在中右角放置O，使用nonce 2签名，然后将其发送给Alice。
- en: Alice plays X in top-right, signs with nonce 3, and sends it to Bob.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Alice在右上角放置X，使用nonce 3签名，然后将其发送给Bob。
- en: Bob plays O in mid-left, signs with nonce 4, and sends it to Alice.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bob在中左角放置O，使用nonce 4签名，然后将其发送给Alice。
- en: Alice wins playing X in bottom-left, signs it with nonce 5, and sends it to
    Bob.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Alice在左下角放置X获胜，使用nonce 5签名，然后将其发送给Bob。
- en: 'The board would then look like the following, with subscripts noting the turn
    when each move was done:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，棋盘如下所示，下标表示每次移动的回合：
- en: '|   |   | X[3] |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '|   |   | X[3] |'
- en: '| --- | --- | --- |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| O[4] | X[1] | O[2] |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| O[4] | X[1] | O[2] |'
- en: '| X[5] |   |   |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| X[5] |   |   |'
- en: After the last step, Bob should sign the message received by Alice and send
    it back to her, so she can upload it on-chain and claim her prize. However, if
    Bob was a sore loser, he could refuse to do so. In that case, Alice must be able
    to just upload the last state signed by Bob (4) on-chain, along with her winning
    move, and have the state channel verify that she has won. Note that this requires
    that **the state channel must be able to verify that her move is indeed a valid
    and winning move**.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一步之后，鲍勃应该签署由爱丽丝收到的消息并将其发送回给她，这样她就可以将其上传到链上并要求奖励。然而，如果鲍勃是一个输不起的人，他可以拒绝这样做。在这种情况下，爱丽丝必须能够仅仅在链上上传由鲍勃签名的最后状态（4），以及她的获胜移动，并且让状态通道验证她已经赢得比赛。请注意，这要求**状态通道必须能够验证她的移动确实是有效且是获胜的移动**。
- en: Bob could also simply stall the game. For instance, when he receives message
    3 from Alice, as he notices that he is going to lose the game, he could choose
    to stop playing. In this scenario, Alice must be able to go on-chain with the
    last state signed by Bob (2), along with her following move (3), and *challenge*
    Bob to move. If he does not respond on-chain within an allotted time, then the
    state channel should declare Alice winner. Here, we are using challenge periods
    not just for closures but also for enforcing moves.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 鲍勃也可以简单地拖延比赛。例如，当他收到来自爱丽丝的消息 3 时，他注意到自己将输掉比赛时，他可以选择停止比赛。在这种情况下，爱丽丝必须能够在链上使用鲍勃的最后签名状态（2）以及她的后续移动（3），并*挑战*鲍勃移动。如果他在分配的时间内没有在链上作出回应，那么状态通道应该宣布爱丽丝为赢家。在这里，我们不仅使用挑战期限来进行关闭，还用于强制移动。
- en: 'As we said, the state channel must be able to *verify* that a move is valid
    on-chain. Let’s see a scenario where this need becomes clear: instead of stalling
    as he receives winning message 5 from Alice, Bob decides to ignore that message.
    He then challenges her to move on-chain with a spurious state. He takes Alice’s
    previous signed state (3) and submits a new state to the contract with the following
    invalid board:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所说，状态通道必须能够*验证*在链上的移动是否有效。让我们看一个清楚表明这种需求的场景：鲍勃决定忽略来自爱丽丝的获胜消息 5，而不是在他接收到该消息时停顿。然后，他挑战她在链上使用虚假状态进行移动。他取得了爱丽丝之前的签名状态（3），并向合约提交了一个带有以下无效棋盘的新状态：
- en: '| X[3] |   |   |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| X[3] |   |   |'
- en: '| --- | --- | --- |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '|   | X[1] | O[2] |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '|   | X[1] | O[2] |'
- en: '|   |   | O[4] |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '|   |   | O[4] |'
- en: If the state channel contract were not able to verify that his move is invalid
    (he changed the location of X[3]), then Alice would be forced to respond on-chain
    with a move on top of this invalid board.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果状态通道合约无法验证他的移动无效（他改变了 X[3] 的位置），那么爱丽丝将被迫在这个无效棋盘上作出链上的移动。
- en: Note
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'An alternative to having the state channel contract validate every transition
    is to have it accept all transitions by default, but accept proofs that a certain
    move was invalid. In some cases, verifying a proof that a transition is invalid
    can be much easier than verifying the transition itself. Chess is a good example:
    verifying checkmate can be prohibitively expensive in terms of gas usage. A way
    around this is allowing any player to claim checkmate and have the opponent prove
    that it is not the case by submitting any valid move.^([12](#Fn12)) This pattern
    is simply another form of challenge-response and follows the motto “*verify, don’t
    compute”* of smart contracts.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 使状态通道合约验证每个转换的替代方法是默认接受所有转换，但接受证明某个移动是无效的。在某些情况下，验证转换无效的证明可能比验证转换本身更容易。国际象棋是一个很好的例子：验证将军可能会在气体使用方面成本过高。解决这个问题的方法是允许任何玩家宣称将军，并让对手证明这不是事实，方法是提交任何有效的移动。^([12](#Fn12))
    这种模式只是挑战-响应的另一种形式，并遵循智能合约的座右铭“*验证，不计算*”。
- en: State channels are then inherently more complex than regular payment channels,
    since they require the logic of the game being played to verify state transitions.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 与常规支付通道相比，状态通道本质上更复杂，因为它们需要验证正在进行的游戏的逻辑以验证状态转换。
- en: Note
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Most of the optimizations described for payment channels also apply to state
    channels. For instance, it could be possible to run multiple instances of a game
    between two participants over a state channel, without requiring to close and
    open a new channel every time a rematch is desired. Also, a state channel could
    be set up so its deposits are ERC20 or even non-fungible ERC721 tokens - imagine
    a representing a trophy as a digital collectible!
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 对于支付通道描述的大多数优化也适用于状态通道。例如，可能可以在状态通道上的两个参与者之间运行多个游戏实例，而无需每次想要重新比赛时都关闭和打开新通道。此外，可以设置状态通道以使其存款为ERC20甚至非同质化的ERC721代币——想象一下将奖杯表示为数字收藏品！
- en: Generalized State Channels
  id: totrans-159
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 广义状态通道
- en: 'As we have seen, a state channel for a given game has two main responsibilities:
    managing the channel itself and validating the game’s transitions. This makes
    implementations more convoluted, as the logic for both responsibilities is intertwined.
    It also makes state channel contracts more expensive, as they need to include
    the logic on both the channel and the game.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，给定游戏的状态通道有两个主要责任：管理通道本身和验证游戏的转换。这使得实现更加复杂，因为两个责任的逻辑交织在一起。它还使状态通道合约更加昂贵，因为它们需要包含通道和游戏的逻辑。
- en: This has led to the development of *generalized state channels* frameworks.
    Generalized state channels are channels that manage the users’ deposits and allow
    new games or applications to be progressively *installed* on the channel. This
    effectively decouples the state channel logic from the application logic.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了*广义状态通道*框架的发展。广义状态通道是管理用户存款并允许新游戏或应用程序逐步*安装*到通道上的通道。这有效地将状态通道逻辑与应用程序逻辑分离开来。
- en: '*Generalized state channels move all of the on-chain stateful components for
    blockchain applications off-chain. Rather than require each application developer
    to build an entire state channel architecture from scratch, a generalized state
    channel generalized framework is one where state is deposited once and then be
    used by any application or set of applications afterwards.*'
  id: totrans-162
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 通用状态通道将区块链应用程序的所有链上状态组件移到链下。与要求每个应用程序开发者从头构建整个状态通道架构不同，通用状态通道的通用框架是一种其中状态只需存入一次，然后之后任何应用程序或一组应用程序都可以使用的框架。
- en: ''
  id: totrans-163
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '—Jeff Coleman, Liam Horne, and Li Xuanji, “Counterfactual: Generalized State
    Channels”^([13](#Fn13))'
  id: totrans-164
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: —Jeff Coleman、Liam Horne和Li Xuanji，《反事实：通用状态通道》^([13](#Fn13))
- en: This opens the door to a new level of channel reuse. Users can now play multiple
    instances of a game and even play multiple different games over the same channel,
    thus creating several subchannels within a single channel. Furthermore, we can
    build dependencies between these subchannels, such as triggering a payment channel
    only upon the resolution of a set of game subchannels.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这打开了一个新的通道复用级别。用户现在可以在同一个通道上玩多个游戏实例，甚至玩多个不同的游戏，从而在单个通道内创建几个子通道。此外，我们可以在这些子通道之间建立依赖关系，例如只有在一组游戏子通道解决后才触发支付通道。
- en: Generalized state channel solutions are heavily under development by different
    teams, though there is work toward a common standard to provide some degree of
    interoperability among them. Several of these implementations, such as the one
    from the Counterfactual team, rely on the concept of *counterfactual* actions.
    Here, the term *counterfactual* is used to refer to an action that any participant
    in the channel could take on-chain but it is actually not and causes participants
    to act as if it had actually happened.^([14](#Fn14)) Let’s see what this means.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 通用状态通道解决方案正在由不同团队积极开发，尽管有工作朝着提供一定程度的相互操作性的共同标准方向进行。其中一些实现，例如来自Counterfactual团队的实现，依赖于*反事实*行动的概念。在这里，“反事实”一词用来指代通道中的任何参与者都可以在链上采取的行动，但实际上并没有采取，这会导致参与者表现得好像它实际上已经发生过一样。^([14](#Fn14))
    让我们看看这意味着什么。
- en: In our tic-tac-toe state channel, we could say that Alice has *counterfactually*
    won if there is a state signed by both Alice and Bob with her winning the game.
    Both players know that any of them can submit the winning state to the smart contract
    on-chain to trigger the payouts at any time. However, they can also decide to
    keep playing a second match, knowing that Alice has already won the first and
    that it can be taken on-chain whenever needed. In other words, players are dealing
    with counterfactual state.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的井字游戏状态通道中，我们可以说如果有一个由Alice和Bob都签署的状态，显示Alice赢得了比赛，那么Alice已经*反事实地*赢得了比赛。两名玩家都知道他们中的任何一人都可以随时在链上提交获胜状态以触发支付。然而，他们也可以决定继续玩第二局比赛，知道Alice已经赢得了第一局，而且可以在需要时随时在链上进行。换句话说，玩家们正在处理反事实状态。
- en: 'Applications in a generalized state channel can be *counterfactually installed*:
    if all participants play nicely and a dispute never arises, then the application
    contract never needs to be actually created, and the entire game can be resolved
    off-chain. This is also known as *counterfactual instantiation* of a contract:
    a contract that could be deployed, but it is not.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在广义状态通道中，应用可以*反事实地安装*：如果所有参与者都表现良好，且争议从未发生过，那么应用合约就不需要实际创建，整个游戏都可以在链下解决。这也被称为合约的*反事实实例化*：一个可以部署但实际上未部署的合约。
- en: The fact that any player can go on-chain and enforce a certain action is enough
    to promote good off-chain behavior – as long as it is complemented with a set
    of penalizations for malicious players who force their opponents to waste gas
    going on-chain.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 任何玩家都可以在链上执行某个动作的事实足以促进良好的链下行为 —— 只要它与一组对恶意玩家施加惩罚的措施相辅相成，迫使对手浪费燃气上链。
- en: 'All in all, counterfactual generalized state channels provide an interesting
    framework that minimizes the number of on-chain actions and thus reduces the latency
    and gas fees that are incurred every time an action must be carried out on the
    Ethereum network. As an additional benefit, they also provide a layer of privacy
    over the participants’ actions: if no transactions except for the deposit and
    payouts are taken on-chain, then only the participants know what messages were
    exchanged via the state channel.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，反事实广义状态通道提供了一个有趣的框架，可以最小化链上操作的数量，从而减少了每次在以太坊网络上执行操作时产生的延迟和燃气费用。作为额外的好处，它们还为参与者的行为提供了一层隐私保护：如果除了存款和支付之外没有进行任何链上交易，那么只有参与者知道通过状态通道交换了哪些消息。
- en: Channel Networks
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通道网络
- en: 'Channels are useful solutions when it comes to settling payments or state within
    a fixed small set of participants (typically two). However, the solution falls
    short when we want to connect a dynamic set of members: for each user we want
    to transact with, we would need to go on-chain and open a new channel.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到在固定的小型参与者集合内解决支付或状态时，通道是有用的解决方案（通常是两个）。然而，当我们想要连接一个动态成员集合时，这个解决方案就显得不够了：对于我们想要与之进行交易的每个用户，我们都需要在链上打开一个新的通道。
- en: To solve this problem, there are protocols for establishing *virtual channels*
    between two peers, which leverage a path of channels that goes through multiple
    intermediaries. This effectively creates a network built from point-to-point connections,
    where any participant can connect to another as long as there is a valid path
    between the two, much like the Internet itself.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决这个问题，有协议可以在两个对等方之间建立*虚拟通道*，利用通过多个中间人的通道路径。这有效地创建了一个由点对点连接构成的网络，只要两者之间存在有效路径，任何参与者都可以连接到另一个参与者，就像互联网本身一样。
- en: Caution
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This section covers topics currently under heavy research and in ongoing development.
    Use it as a starting point to run your own up-to-date research if you are considering
    building on top of a state channel network.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: The easiest construction in networks comes once again from Bitcoin, which is
    *multi-hop payment channels*. This method allows to securely route payments through
    one or more intermediaries. For instance, Alice could send payments to an intermediary
    Ingrid with whom she has a payment channel set up and have Ingrid relay them to
    Bob (assuming that Ingrid had a channel with Bob as well). Due to how these channels
    are set up,^([15](#Fn15)) Ingrid has no way to take these funds for herself.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: This type of channels leads directly to a simple and effective network layout,
    a *hub-and-spoke channel network*, where multiple clients connect to a single
    hub that acts as an intermediary for all of them. This way, setting up a single
    channel with the hub allows a user to transact with anyone else on the network.
    On the other hand, it has the downside of being centralized and requiring the
    hub to be available.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: There are also several projects working on more interesting network layouts,
    such as the Raiden Network,^([16](#Fn16)) inspired by Bitcoin’s Lightning Network.
    The ultimate goal for these networks is to allow for any two participants to establish
    a shared channel, usually called a *virtual channel* or *metachannel*  , in a
    trustless manner. These need not to be just payment channels, but can be full
    generalized state channels, and can potentially run without active participation
    of the intermediaries on every exchange.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Sidechains
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At their most basic version, a *sidechain*  is a parallel Ethereum network that
    potentially runs a different consensus algorithm, such as *proof-of-authority,*
    and is connected to the main network by a *bridge*. Working on smaller sizes allows
    sidechains to achieve much higher throughputs than the main Ethereum network.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While it is technically possible for a sidechain to use proof-of-work, this
    is highly insecure. Remember that proof-of-work relies on an attacker being unable
    to produce more computing power than the rest of the network. Since sidechains
    tend to be small compared to the main network, their difficulty is also comparatively
    low, which makes it easier for an attacker to mount an attack on them. This is
    why most sidechains work with a closed set of miners or validators.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管技术上来说，侧链可以使用工作证明，但这是极不安全的。请记住，工作证明依赖于攻击者无法产生比网络其余部分更多的计算能力。由于侧链往往与主网络相比较小，它们的难度也相对较低，这使得攻击者更容易对它们发动攻击。这就是为什么大多数侧链与一组封闭的矿工或验证者一起工作的原因。
- en: Proof of Authority
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Proof of Authority
- en: In proof-of-authority, or PoA for short, there is a predefined set of nodes
    that act as *validators* for the blocks being added to the network. Validators
    are the PoA equivalent of miners in PoW, in that they add new blocks. Every certain
    number of seconds, each of these validators, taking turns, proposes a new block.
    These blocks are broadcasted to the other validators and need to be approved by
    a majority of them to be added to the blockchain. The set of validators can be
    changed over time, with some validators being voted out and new ones allowed into
    the set.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在权威证明，或简称 PoA 中，有一组预定义的节点充当添加到网络中的块的*验证者*。验证者是 PoA 中矿工的等价物，在其中它们添加新的块。每隔一定数量的秒数，这些验证者轮流提出一个新的块。这些块被广播给其他验证者，并且需要大多数验证者批准才能添加到区块链中。验证者的集合可以随时间变化，一些验证者被投票淘汰，新的验证者被允许加入集合。
- en: How the blocks are broadcasted, approved, and agreed upon depends on the specific
    *consensus* algorithm being used. Though there are many different consensus algorithms,
    such as Clique,^([17](#Fn17)) Aura,^([18](#Fn18)) Raft,^([19](#Fn19)) or Istanbul
    BFT,^([20](#Fn20)) they all share the same basic scheme outlined previously. Different
    algorithms may offer different guarantees against malicious actors or nodes dropping
    from the network, as well as different performance.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 区块是如何被广播、批准和达成共识的取决于所采用的具体*共识*算法。虽然有许多不同的共识算法，如 Clique，^([17](#Fn17)) Aura，^([18](#Fn18))
    Raft，^([19](#Fn19)) 或 Istanbul BFT，^([20](#Fn20)) 但它们都分享了先前概述的相同基本方案。不同的算法可能提供不同的保护措施，防止恶意行为者或节点从网络中掉落，以及不同的性能。
- en: Another component of a sidechain is the connection to a main network, often
    called *bridge*  . A bridge is a mechanism for users to move their assets between
    the main chain and the sidechain. As an example, a simple bridge could allow users
    to move their assets in a specific ERC20 from the main network to a sidechain
    by having the users lock their funds in a specific mainnet contract. Sidechain
    validators watch this contract and create the corresponding funds in the sidechain
    whenever they register a user locking funds on the main chain. We will implement
    this mechanism later in this chapter.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 侧链的另一个组成部分是与主网络的连接，通常称为*桥接*。桥接是用户在主链和侧链之间转移资产的机制。例如，一个简单的桥梁可以允许用户通过让用户将资金锁定在特定的主网合约中，将他们的资产从主网络转移到侧链。侧链验证者监视此合约，并在他们在主链上注册用户锁定资金时，在侧链中创建相应的资金。我们将在本章后期实施此机制。
- en: Security and Trust
  id: totrans-187
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 安全和信任
- en: The security of a vanilla PoA sidechain depends entirely on its validators.
    If a majority of them collude, they can effectively steal all user funds locked
    in the sidechain. Because of this, it is critical that the set of validators is
    composed of multiple different parties and are not all controlled by a single
    organization. A user should trust a PoA network only if he or she trusts a majority
    of the validator nodes.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 一个普通的PoA侧链的安全性完全取决于其验证者。如果他们中的大多数串通一气，他们可以有效地窃取锁定在侧链中的所有用户资金。因此，关键是验证者集合由多个不同方控制，并且不全由单一组织控制。用户只应该信任PoA网络，如果他或她信任大多数验证者节点。
- en: To disincentivize malicious behavior like this, some networks rely on proof-of-stake
    instead of proof-of-authority. In this scheme, the validator nodes are required
    to deposit (stake) a large amount of funds. If it is proven that they acted maliciously,
    then their stake is slashed as a penalty - though how this slashing is executed
    is another matter.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为了遏制此类恶意行为，一些网络依赖于**股权证明**而不是权威证明。在这个方案中，验证节点需要存入（抵押）大量资金。如果证明他们恶意行为，那么他们的抵押将被削减作为惩罚
    - 尽管如何执行这种惩罚是另一回事。
- en: It is important that the value a validator could gain by attacking the network
    is less than what he would lose in stake in order to keep the incentives in line.
    There are currently different approaches to proof-of-stake. However, from a user’s
    perspective, the experience is very similar to operating in a proof-of-authority
    network.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，验证者通过攻击网络可能获得的价值要少于他们因抵押而损失的价值，以保持激励的一致性。目前有不同的股权证明方法。然而，从用户的角度来看，体验与在权威证明网络中操作非常相似。
- en: Note
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Given that malicious validators may steal funds from users, the security guarantees
    from the sidechain are poorer than those of the main chain. This fact makes sidechains
    **not** to be considered layer 2 solutions under certain definitions. Nevertheless,
    there are constructs (such as Plasma, which we will see later) that allow the
    user to safeguard their assets by calling unlawful validator behavior on a main
    network contract.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于恶意验证者可能从用户那里窃取资金，与主链相比，侧链的安全保证较差。这个事实使得侧链**不**被认为是在某些定义下的第二层解决方案。尽管如此，还有一些构建（如
    Plasma，稍后我们将看到）允许用户通过调用主网络合约上的非法验证者行为来保护他们的资产。
- en: Deploying Our Own Chain
  id: totrans-193
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 部署我们自己的链
- en: To illustrate how a PoA network works,^([21](#Fn21)) we will manually set one
    up using the Geth Ethereum node client.^([22](#Fn22)) While Geth can run in the
    proof-of-work main Ethereum network, it can also be configured to run in PoA networks
    that use the Clique consensus algorithm (such as the Rinkeby testnet) and act
    as a validator node.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明 PoA 网络的工作原理，我们将使用 Geth 以太坊节点客户端手动设置一个。虽然 Geth 可以在工作量证明的主以太坊网络中运行，但也可以配置为在使用
    Clique 共识算法的 PoA 网络中运行（例如 Rinkeby 测试网络），并充当验证者节点。
- en: 'Let’s start by setting up three miner nodes, which will all run on the same
    computer. We will first create new accounts for each miner. For convenience, we
    will use the same password for all accounts, so create a file password.txt containing
    a random string to be used as password. Then, create the addresses by running
    the following for each of the three miners, replacing miner1 with miner2 and miner3.
    Make sure the password.txt file is in the path where the command is run.$ geth
    --datadir miner1 --password password.txt account new> Address: {8305ccac...58269a7d}'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们首先设置三个矿工节点，它们都将在同一台计算机上运行。我们将首先为每个矿工创建新的账户。为方便起见，我们将为所有账户使用相同的密码，因此创建一个包含随机字符串用作密码的文件
    password.txt。然后，为三个矿工中的每一个运行以下命令以创建地址，将 miner1 替换为 miner2 和 miner3。确保 password.txt
    文件位于运行该命令的路径中。$ geth --datadir miner1 --password password.txt account new> 地址:
    {8305ccac...58269a7d}'
- en: You should get three different addresses, which we will set up as the validators
    of this network (make sure to note them down). We will now create a *genesis*
    for our network. The genesis is the configuration for the network and will include
    which is the set of authorized validators, the consensus engine, the initial balances,
    the block gas limit, and so on. In geth, this information is compiled into a JSON
    configuration file which is used to bootstrap each node.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该获得三个不同的地址，我们将其设置为此网络的验证者（请确保记下这些地址）。我们现在将为我们的网络创建一个*创世块*。创世块是网络的配置，将包括哪些是经授权的验证者集合、共识引擎、初始余额、区块燃气限制等信息。在
    geth 中，这些信息被编译到一个 JSON 配置文件中，该文件用于引导每个节点。
- en: Geth includes a tool named puppeth that simplifies the creation of such a file.
    Simply run puppeth in the console, and answer the questions prompted (Listing
    [8-18](#PC20)). Give your network a name, create a new genesis, use clique proof-of-authority
    with 5-second blocks, and choose your miners as “accounts allowed to seal.” You
    should also pick a fourth account to be pre-funded or choose one of the existing
    validators to hold the initial ETH for your network.$ puppethPlease specify a
    network name to administer (no spaces, hyphens or capital letters please)> mysidechainWhat
    would you like to do? (default = stats) 1\. Show network stats 2\. Configure new
    genesis 3\. Track new remote server 4\. Deploy network components> 2What would
    you like to do? (default = create) 1\. Create new genesis from scratch 2\. Import
    already existing genesis> 1Specify your chain/network ID if you want an explicit
    one (default = random)> 1212Listing 8-18
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Geth 包含一个名为 puppeth 的工具，它简化了这样一个文件的创建。只需在控制台中运行 puppeth，并回答提示的问题（见列表 [8-18](#PC20)）。为你的网络命名，创建一个新的起源，使用
    5 秒区块的 Clique 共识机制，并选择你的矿工作为“允许封存的账户”。你还应该选择第四个账户作为预先资助，或选择现有验证器之一来持有你的网络的初始 ETH。$
    puppeth请指定一个网络名称以管理（请勿使用空格、连字符或大写字母）> mysidechain你想要做什么？（默认 = 统计） 1\. 显示网络统计信息 2\.
    配置新的起源 3\. 跟踪新的远程服务器 4\. 部署网络组件> 2你想要做什么？（默认 = 创建） 1\. 从头开始创建新的起源 2\. 导入已经存在的起源>
    1如果您想要明确指定您的链/网络 ID，请指定（默认 = 随机）> 1212列表 8-18
- en: Fragment of the Geth puppeth configuration wizard to set up a PoA network with
    id 1212\. You should have a new mysidechain.json genesis file after going through
    it
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Geth puppeth 配置向导的片段，用于设置带有 id 1212 的 PoA 网络。完成后，你应该有一个新的 mysidechain.json 起源文件
- en: Before starting our Geth nodes, we will set up a *bootnode*. A bootnode is a
    node in the network whose sole purpose is to aid in the discovery of other nodes.
    We will use it to simplify the communication between our miner nodes.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动我们的 Geth 节点之前，我们将设置一个 *bootnode*。bootnode 是网络中的一个节点，其唯一目的是帮助发现其他节点。我们将使用它来简化我们的矿工节点之间的通信。
- en: To set up a bootnode, we first need to create a boot key and use it to derive
    the bootnode *enode address* (Listing [8-19](#PC21)). The enode address is a unique
    identifier of a node in the decentralized network, followed by the IP address
    and port where the node can be found. We will then start the bootnode using the
    generated boot key and have it listen on local port 30100.^([23](#Fn23))$ bootnode
    -genkey boot.key$ bootnode -nodekey boot.key -writeaddress> c190f2af...ee34b40a$
    bootnode -nodekey boot.key -addr :30100Listing 8-19
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置一个 bootnode，我们首先需要创建一个 boot key 并使用它来派生 bootnode 的 *enode 地址*（见列表 [8-19](#PC21)）。enode
    地址是去中心化网络中节点的唯一标识符，后跟节点可以找到的 IP 地址和端口。然后，我们将使用生成的 boot key 启动 bootnode，并让它侦听本地端口
    30100。^([23](#Fn23))$ bootnode -genkey boot.key$ bootnode -nodekey boot.key -writeaddress>
    c190f2af...ee34b40a$ bootnode -nodekey boot.key -addr :30100列表 8-19
- en: Generating a boot key and running a bootnode
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 生成一个 boot key 并运行一个 bootnode
- en: Note
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We did not need to use the genesis configuration file for the bootnode, since
    the bootnode does need any information on whether the network is running a proof
    of work or authority or who the validators are. It only needs to know where the
    nodes are to share this information with the network.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要使用创世配置文件来启动引导节点，因为引导节点不需要任何关于网络是否运行工作证明或授权，或者验证器是谁的信息。它只需要知道节点在哪里，以便与网络共享此信息。
- en: Now that we have a bootnode running and a genesis configuration file, it is
    time to actually start the network. In three different terminals, start the three
    different Geth validator nodes (Listing [8-20](#PC22)), configured to mine (i.e.,
    seal) new blocks, and expose the JSON-RPC API locally over HTTP.geth \--datadir
    miner1 \--port 30201 \--rpc --rpcaddr localhost --rpcport 12001 \--rpcapi 'eth,personal'
    \--networkid 1212 \--gasprice 10000 \--unlock 8305ccac...58269a7d \--password
    password.txt \--mine \--bootnodes 'enode://c190f2af...ee34b40a@127.0.0.1:30100'Listing
    8-20
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经运行了一个引导节点并有了创世配置文件，是时候真正启动网络了。在三个不同的终端中，启动三个不同的Geth验证器节点（见[8-20](#PC22)），配置为挖矿（即，封装）新块，并在本地通过HTTP公开JSON-RPC
    API。geth \--datadir miner1 \--port 30201 \--rpc --rpcaddr localhost --rpcport
    12001 \--rpcapi 'eth,personal' \--networkid 1212 \--gasprice 10000 \--unlock 8305ccac...58269a7d
    \--password password.txt \--mine \--bootnodes 'enode://c190f2af...ee34b40a@127.0.0.1:30100'8-20
- en: Starting the Geth validator nodes using the genesis configuration and bootnode
    ID generated earlier. Run this command three times in different terminals, one
    for each validator, changing the unlocked address, datadir, port, and rpcport
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 使用之前生成的创世配置和引导节点ID启动Geth验证器节点。在不同的终端中运行此命令三次，每次一个验证器，更改解锁地址、数据目录、端口和rpc端口。
- en: Our network should be now running, sealing a new block every 5 seconds. Take
    a look at the logs from the three validators to see how they progress.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的网络现在应该在运行中，每5秒封装一个新块。查看三个验证器的日志，了解它们的进展情况。
- en: We can now spin up a new client node and connect to the existing network (Listing
    [8-21](#PC23)). Remember that even though the set of validators is limited, the
    network is still public and any node can connect to it. We can use its console
    to check how the latest block number increases every 5 seconds, running web3.eth.blockNumber.$
    geth \--datadir node1 --port 30204 \--rpc --rpcaddr localhost --rpcport 12004
    \--rpcapi 'eth,personal' \--networkid 1212 \--bootnodes 'enode://c190f2af...ee34b40a@127.0.0.1:30100'
    \consoleListing 8-21
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以启动一个新的客户端节点并连接到现有网络（见[8-21](#PC23)）。请记住，即使验证器的集合有限，网络仍然是公开的，任何节点都可以连接到它。我们可以使用它的控制台每5秒检查最新块号如何增加，运行web3.eth.blockNumber。$
    geth \--datadir node1 --port 30204 \--rpc --rpcaddr localhost --rpcport 12004
    \--rpcapi 'eth,personal' \--networkid 1212 \--bootnodes 'enode://c190f2af...ee34b40a@127.0.0.1:30100'
    \console8-21
- en: Spinning a new node to join the network, with a console enabled. Note that we
    are not authenticating this new node in any way, since the network is public for
    anyone to join
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 启动一个新节点加入网络，并启用控制台。请注意，我们没有以任何方式对这个新节点进行身份验证，因为网络是公开的，任何人都可以加入。
- en: Let’s now connect this network with an existing one, such as Rinkeby.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Building a Bridge
  id: totrans-210
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We will build a simple bridge, exclusively dependent on the validator accounts,
    using a contract deployed on both the main network and the sidechain, in addition
    to a script being run by each validator. In this model, the steps for a user moving
    into a sidechain and later exiting would be the following:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '1.'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The user transfers funds to the bridge contract on mainnet.
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The bridge contract retains the funds and emits an event.
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '3.'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The validators note the event, and each of them calls into the bridge contract
    on the sidechain side requesting to unlock the same amount of funds.
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '4.'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The user gets their funds in the sidechain and uses them to operate there.
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '5.'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the user wants to exit the sidechain, the same process is repeated by transferring
    the sidechain funds to the sidechain bridge contract and having the validators
    unlock them on the mainnet bridge contract.
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We will begin by building the bridge contract. This contract will have two
    main responsibilities: (1) accepting and locking user funds and (2) unlocking
    them at the request of the validators. Note that we will deploy two instances
    of the contract, one in each chain. The locking function on one chain will have
    its counterpart on the unlocking function of the other chain and vice versa.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this example, we are building a bridge that accepts ETH and dispenses the
    native currency of the sidechain on the other end. However, we could also build
    bridges that accept a certain ERC20 token on the main chain or even non-fungible
    ERC721 assets.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: To begin with, the bridge will need to know the validators’ addresses (Listing
    [8-22](#PC24)). We will also specify how many validators need to agree to release
    a user’s funds. In our scenario with three validators, we will release the funds
    with just two of them agreeing in case one of them drops.pragma solidity ^0.5.0;contract
    Bridge {  uint256 threshold;  mapping(address => bool) validators;  constructor(    uint256
    _threshold,    address[] memory _validators  ) public payable {    threshold =
    _threshold;    for (uint256 i = 0; i < _validators.length; i++) {      validators[_validators[i]]
    = true;    }  }}Listing 8-22
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，桥将需要知道验证者的地址（列表 [8-22](#PC24)）。我们还将指定多少个验证者需要同意释放用户的资金。在我们的场景中有三个验证者，如果其中一个验证者退出，我们只需要两个验证者同意即可释放资金。pragma
    solidity ^0.5.0;contract Bridge {  uint256 threshold;  mapping(address => bool)
    validators;  constructor(    uint256 _threshold,    address[] memory _validators  )
    public payable {    threshold = _threshold;    for (uint256 i = 0; i < _validators.length;
    i++) {      validators[_validators[i]] = true;    }  }}Listing 8-22
- en: Definition of the bridge contract, which is initialized with the validators’
    addresses
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 桥合约的定义，初始化时包含验证者的地址。
- en: Note that we are making the constructor payable. When deploying the contract
    in the sidechain, we need to seed this contract with the maximum amount of ETH
    we want to allow our users to transfer from the main network (Rinkeby in this
    case) to our sidechain, so the contract can unlock those funds when prompted by
    the validators.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意我们将构造函数设置为可支付。在侧链部署合约时，我们需要用主网络（在本例中为 Rinkeby）中允许用户转移的最大 ETH 金额来初始化该合约，这样合约就可以在验证者的提示下解锁这些资金。
- en: We will now go into the locking function (Listing [8-23](#PC25)), which is quite
    simple. We need to accept the sender’s funds, allowing them to specify a recipient
    address on the other end of the bridge, and emit an event. We will assign an autoincremental
    ID to each locking operation, so the validators can refer to it when unlocking
    on the other end.event Locked(uint256 id, uint256 amount, address recipient);uint256
    lastId;function lock(address recipient) public payable {  require(msg.value >
    0);  emit Locked(++lastId, msg.value, recipient);}Listing 8-23
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将进入锁定函数（列表 [8-23](#PC25)），这个函数相当简单。我们需要接受发送者的资金，允许他们指定桥的另一端的接收地址，并发出一个事件。我们将为每个锁定操作分配一个自增的
    ID，以便验证者在另一端解锁时可以参考它。事件 Locked(uint256 id, uint256 amount, address recipient);uint256
    lastId;function lock(address recipient) public payable {  require(msg.value >
    0);  emit Locked(++lastId, msg.value, recipient);}Listing 8-23
- en: Lock function of the bridge contract
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 桥合约的锁定函数
- en: Last but not least, we will work on the unlock function (Listing [8-24](#PC26)).
    This function will be called by the validators on the other end of the bridge.
    Each validator should authorize unlocking the funds that correspond to a locking
    operation that happened on the other end. Keep in mind that since there is no
    on-chain communication between both ends of the bridge, it is the validators responsibility
    to unlock the correct amount of funds to the address requested by the user.mapping(uint256
    => Request) requests;struct Request {  uint256 amount;  address payable recipient;  bool
    paid;  uint256 approveCount;  mapping(address => bool) approvedBy;}event Unlocked(uint256
    id, uint256 amount, address recipient);function unlock(  uint256 id, uint256 amount,
    address payable recipient) public {  Request storage request = requests[id];  require(validators[msg.sender]);  require(!request.approvedBy[msg.sender]);  require(request.recipient
    == address(0)    || request.recipient == recipient);  require(request.amount ==
    0 || request.amount == amount);  request.approveCount++;  request.approvedBy[msg.sender]
    = true;  request.recipient = recipient;  request.amount = amount;  if (request.approveCount
    >= threshold && !request.paid) {    request.paid = true;    recipient.transfer(amount);    emit
    Unlocked(id, amount, recipient);  }}Listing 8-24
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但并非最不重要的，我们将处理解锁功能（见[8-24](#PC26)）。这个函数将由桥的另一端的验证者调用。每个验证者都应该授权解锁与在另一端发生的锁定操作相对应的资金。请记住，由于桥的两端没有链上通信，因此验证者有责任将正确金额的资金解锁到用户请求的地址上。mapping(uint256
    => Request) requests;struct Request {  uint256 amount;  address payable recipient;  bool
    paid;  uint256 approveCount;  mapping(address => bool) approvedBy;}event Unlocked(uint256
    id, uint256 amount, address recipient);function unlock(  uint256 id, uint256 amount,
    address payable recipient) public {  Request storage request = requests[id];  require(validators[msg.sender]);  require(!request.approvedBy[msg.sender]);  require(request.recipient
    == address(0)    || request.recipient == recipient);  require(request.amount ==
    0 || request.amount == amount);  request.approveCount++;  request.approvedBy[msg.sender]
    = true;  request.recipient = recipient;  request.amount = amount;  if (request.approveCount
    >= threshold && !request.paid) {    request.paid = true;    recipient.transfer(amount);    emit
    Unlocked(id, amount, recipient);  }}列表 8-24
- en: Unlocking function of the token bridge. The first time a validator requests
    an unlock, we will create a new unlock request and then log an approval every
    time it is called again. When the required number of approvals is reached, the
    funds are unlocked
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 代币桥的解锁功能。当验证者第一次请求解锁时，我们将创建一个新的解锁请求，然后每次再次调用时记录一个批准。当达到所需数量的批准时，资金将被解锁。
- en: Caution
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This implementation allows a malicious validator to prevent a user’s funds from
    being unlocked. The validator could spam the bridge contract with spurious unlock
    requests for upcoming request IDs. This way, when the honest validators actually
    try to honor the unlock request, the parameters (such as amount or recipient)
    will not match and the operation will fail. We will ignore this attack, since
    the purpose of this bridge is to just illustrate basic usage. Nevertheless, this
    serves as a reminder that even the most simple implementations may be hiding security
    issues, and you should always work with reviewed and audited contracts.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now deploy this contract on both networks (Listing [8-25](#PC27)), using
    the set of validators we defined earlier and choosing a required threshold of
    two approvals for unlocking. Remember to also transfer a large amount of funds
    to the contract when deploying it on the sidechain, so it has funds to unlock
    when requested.const Web3 = require(''web3'');const Artifact = require(''../artifacts/Bridge.json'');const
    web3 = new Web3(PROVIDER_URL);const abi = Artifact.compilerOutput.abi;const data
    = Artifact.compilerOutput.evm.bytecode.object;const Bridge = new web3.eth.Contract(abi,
    null, { data });const bridge = await Bridge.deploy({  arguments: [THRESHOLD, VALIDATORS]}).send({  from:
    FROM, gas: 1e6, gasPrice: GAS_PRICE, value: VALUE});console.log("Bridge deployed
    at", bridge.options.address);Listing 8-25'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: 'Deployment script for the bridge contract. Run this twice with different PROVIDER_URLs:
    one for the Rinkeby Ethereum network and the other for the sidechain'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we need to set up the watcher scripts that will be run by each validator
    (Listing [8-26](#PC28)). These scripts will watch the bridge contract in one network
    for Locked events and execute the corresponding unlock on the other side.const
    Web3 = require(''web3'');const Artifact = require(''../artifacts/Bridge.json'');const
    abi = Artifact.compilerOutput.abi;const remoteWeb3 = new Web3(REMOTE_PROVIDER_URL);const
    localWeb3 = new Web3(LOCAL_PROVIDER_URL);const remoteBridge = new remoteWeb3.eth.Contract(abi,
    REMOTE);const localBridge = new localWeb3.eth.Contract(abi, LOCAL);remoteBridge.events.Locked().on(''data'',
    function(e) {  const { id, amount, recipient } = e.returnValues;  localBridge.methods    .unlock(id,
    amount, recipient)    .send({ from: VALIDATOR, gas: 1e6, gasPrice: GAS_PRICE });});localBridge.events.Locked().on(''data'',
    function(e) {  const { id, amount, recipient } = e.returnValues;  remoteBridge.methods    .unlock(id,
    amount, recipient)    .send({ from: VALIDATOR, gas: 1e6, gasPrice: GAS_PRICE });});Listing
    8-26'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '最后，我们需要设置监视器脚本，每个验证器都会运行它们（见列表[8-26](#PC28)）。这些脚本将在一个网络中监视桥接合约以查找已锁定的事件，并在另一侧执行相应的解锁。const
    Web3 = require(''web3'');const Artifact = require(''../artifacts/Bridge.json'');const
    abi = Artifact.compilerOutput.abi;const remoteWeb3 = new Web3(REMOTE_PROVIDER_URL);const
    localWeb3 = new Web3(LOCAL_PROVIDER_URL);const remoteBridge = new remoteWeb3.eth.Contract(abi,
    REMOTE);const localBridge = new localWeb3.eth.Contract(abi, LOCAL);remoteBridge.events.Locked().on(''data'',
    function(e) {  const { id, amount, recipient } = e.returnValues;  localBridge.methods    .unlock(id,
    amount, recipient)    .send({ from: VALIDATOR, gas: 1e6, gasPrice: GAS_PRICE });});localBridge.events.Locked().on(''data'',
    function(e) {  const { id, amount, recipient } = e.returnValues;  remoteBridge.methods    .unlock(id,
    amount, recipient)    .send({ from: VALIDATOR, gas: 1e6, gasPrice: GAS_PRICE });});列表
    8-26'
- en: 'Watcher script to be run on each validator. Note that we create two web3 instances:
    one connecting to the main network, where we listen for events on the remote end
    of the bridge, and the other to the local network, where we execute the unlock
    operations. We then do the converse, allowing funds to go from the sidechain back
    to the main network'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 每个验证器上运行的监视器脚本。请注意，我们创建了两个 web3 实例：一个连接到主网络，在那里我们监听桥接端的事件，另一个连接到本地网络，在那里我们执行解锁操作。然后我们反之亦然，允许资金从侧链返回到主网络。
- en: We can now run this script on each of the validator nodes (or at least on two
    of them). Once it is running, try calling the lock function in the Rinkeby end
    of the bridge. A few seconds later, you should have your funds ready to use on
    the chosen address in your sidechain.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在每个验证器节点上运行此脚本（或至少在其中两个上）。一旦它在运行，尝试在桥接的 Rinkeby 端调用锁定功能。几秒钟后，您应该可以在侧链中所选地址上使用您的资金。
- en: In an actual application, you need to decide how much of this complexity you
    want to expose to your users. As we have seen in Chapter [7](476252_1_En_7_Chapter.xhtml),
    onboarding is already troublesome enough, and adding another step requiring to
    send funds from one network to another is not a good idea.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，您需要决定要向用户公开多少这种复杂性。正如我们在第[7](476252_1_En_7_Chapter.xhtml)章中所看到的，入职已经足够麻烦了，再添加另一个需要将资金从一网络发送到另一网络的步骤并不是一个好主意。
- en: However, you can actually leverage an application-specific sidechain for improving
    onboarding. You can directly fund your users’ initial accounts on your sidechain
    or build a viral inviting scheme where existing users can invite new ones directly
    on the cheaper and faster sidechain. The bridge is then only used for advanced
    users who want to transfer value from or to the main network, but to an Ethereum
    neophyte the application simply runs smoothly and fast, without knowing how it
    is backed.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: A good example of this, already mentioned in the previous chapter, is the Burner
    Wallet.^([24](#Fn24)) This wallet operates on a proof-of-authority sidechain^([25](#Fn25))
    with four different teams acting as validators. Users are quickly onboarded by
    receiving a link with a pre-funded account on the sidechain and can easily transact
    with others thanks to low gas costs and 5-second blocks. For the most advanced
    users, there is an option to move the funds onto the main Ethereum network or
    even seed their burner wallets from their mainnet accounts.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Plasma Chains
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The state of the art in terms of layer 2 solutions at the time of this writing
    are plasma chains,^([26](#Fn26)) originally designed by Vitalik Buterin and Joseph
    Poon in 2017.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Plasma chains  are different from sidechains in that their security can be enforced
    by the main chain (or *parent chain*, in plasma terminology) and thus does not
    depend exclusively on the consensus mechanism of the sidechain. This means that
    if the set of validators on the child chain (called *plasma operators*) misbehaves,
    any user can build a cryptographic proof and take it to a smart contract on the
    main chain (called *root contract*). If there is no foul play, transactions on
    the child chain occur with the reduced gas cost and latency typical of a sidechain.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: However, this additional security comes at a cost. Whenever a user wants to
    exit the child chain (i.e., transfer their assets back to the main chain), they
    must go through a *challenge period*, similar to the one we saw in state channels.
    If a malicious validator creates a fake block where he stole a user’s assets and
    uses it to take over those assets in the main chain, the user can submit a fraud
    proof during this challenge period and regain their assets. As such, exiting a
    plasma chain is not instant and requires a user to wait a certain period of time.^([27](#Fn27))
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Also, since a smart contract needs to be able to process whether a set of transactions
    on the child chain was legitimate, the operations allowed on the child chain cannot
    be overly complex. In particular, no plasma implementations at the time of this
    writing support arbitrary smart contracts and only provide the means for exchanging
    assets between users. Research on this topic is done under *generalized plasma*
    implementations.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: On the flip side, plasma chains are designed for having a tree-like structure.
    The parent chain of a plasma chain can be *another* plasma chain, allowing for
    massive scalability by simply composing plasma chains within others. This means
    that if an application-specific plasma chain becomes overcrowded, it can simply
    spawn new children and move clusters of users to them.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: It is worth mentioning that plasma itself is not a specification but a framework
    for building scalable layer 2 infrastructure. This has led to the development
    of many different flavors of plasma by different teams, such as minimal viable
    plasma, plasma cash, plasma debit, or plasma prime.^([28](#Fn28)) It is most likely
    that by the time this book reaches your hands, there will be new major developments
    on this front.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Public blockchains like Bitcoin or Ethereum have traditionally sacrificed performance
    for trustlessness and security. While there are multiple efforts toward building
    Ethereum 2.0, which includes sharding mechanics that help the network scale, it
    is interesting to see many solutions sprouting that build on top of the existing
    infrastructure to solve the scalability problem.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: Some of the solutions presented in this chapter, such as early versions of plasma
    or state channels, are ready to use and in production today, helping real-life
    applications scale beyond the limits of the main Ethereum network.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: These solutions not only allow your application to achieve a higher transaction
    throughput, but they can also be used to provide a better user experience overall.
    Channels provide instant finality to peer-to-peer transactions if both parties
    behave appropriately instead of having to wait for a dozen confirmations. And
    sidechains can provide reliable block times much lower than the main network,
    with considerably lower gas fees.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'These techniques can even be combined: you can set up state channels between
    parties in a sidechain or even use channels as the actual asset being traded in
    a plasma chain.^([29](#Fn29)) The sky is the limit here.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: How you leverage these solutions and present them to (or hide them from) your
    users will depend on what you are building. Remember what your users need from
    your application, and use the building blocks available to you to create the best
    possible experience.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Happy coding!
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
