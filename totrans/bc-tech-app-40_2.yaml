- en: 2 Decentralized applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Decentralized applications (DApps) are application paradigms that combine on-chain
    application logic executed in the DL network with traditional application engineering
    approaches. The DL network assures trusted execution of the on-chain logic (i.e.,
    smart contracts) while Web, mobile, server-side, or embedded applications provide
    user and machine interfaces for the DApps.
  prefs: []
  type: TYPE_NORMAL
- en: DL networks differ in the applied technologies, as also in their organization
    and governance. These factors jointly contribute to the trust, performance, and
    scalability of a DL network. Smart contracts and off-chain applications adopt
    some of the known software engineering approaches. At the same time, a decentralized
    environment and immutable ledgers require certain adaptations.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from the key services provided by a DL network, DL ecosystems often accommodate
    additional distributed and support services, too. These services facilitate, for
    example, bulk decentralized and distributed storage, a combination of smart contracts
    and off-chain data sources, user-friendly naming of decentralized resources, or
    monitoring of a running DL network.
  prefs: []
  type: TYPE_NORMAL
- en: Decentralized application architects and developers rely on DL technologies
    and support services. However, for DApps productization, they require business-grade
    development and support ecosystems and third-party services in order to focus
    on application development. Productization of decentralized applications is a
    significant step towards broader adoption of these, still relatively novel, technologies
    and solutions.
  prefs: []
  type: TYPE_NORMAL
- en: 2.1 Decentralized trust - distribution vs. decentralization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Two related characteristics are required and contribute to decentralized trust
    in distributed ledger systems. These are:'
  prefs: []
  type: TYPE_NORMAL
- en: The distributed nature of ledgers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Their decentralized control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let us consider a simple database system that is installed on a computer. It
    is united/consolidated in a single instance and is thus not distributed. The system
    control is centralized in the hands of the system proprietor, who manages access
    rights for all the system users. Note that the proprietors can appoint another
    user to manage the system on their behalf. However, even in this case, they keep
    the right to override any of the users’ actions and still fully control the system.
    For performance or other reasons, the database system can be scaled over several
    computers. A distributed system topology enables many essential benefits, including
    redundancy, eliminating single points of failure, resilience to failures, or performance
    scalability. Modern cloud and network virtualization systems allow the highly
    efficient and scalable distribution of systems. However, the control of the entire
    system would remain centralized with the proprietor, and the access policies would
    remain very similar to the one in the consolidated implementation.
  prefs: []
  type: TYPE_NORMAL
- en: To disperse the administration (governance) of the system so that there is no
    single entity having control over the system, we need a different approach, that
    is, decentralization of control. Such a system has to be distributed as many instances
    are building the system. Unlike in the distributed and centralized database example,
    each instance is controlled by a different entity in a decentralized system. These
    can be, for example, users who install and run blockchain nodes or consortium
    partners who agree to commonly run a DL network and, therefore, all set up their
    node instances. De/centralization in DLs is, thus, more organizational in nature
    and not technical. However, the underlying technology has to provide a distributed
    system, which is a prerequisite for its decentralized governance. The actions
    in the system cannot be based on an arbitrary decision of a single proprietor
    but are based on a mutual consensus. The same consensus mechanism is implemented
    in every node instance. These mechanisms assure that all the actions can be conducted
    only in the pre-agreed way, even if some of the system participants act maliciously.
  prefs: []
  type: TYPE_NORMAL
- en: A DL system is distributed, by nature. If, in addition, we implement it in a
    way that facilitates decentralized governance, we get a decentralized trusted
    system. Unlike in centralized trusted systems, where we need to trust the system
    proprietor (e.g., a bank, holding a database with client account and balance information),
    in decentralized trusted systems, there is no central entity we would have to
    trust. The trust is assured by DL protocols, which are commonly open source and,
    hence, available for verification to anyone.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 2.1](#b_9783110681130-002_tab_001) shows that a consolidated topology,
    where the governance can only be centralized, provides only centralized trust.
    In distributed systems with centralized governance, no decentralized trust can
    be assured either. Only those systems, which are distributed and decentralized,
    can provide decentralized trust.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Tab. 2.1:Decentralized trust: relations between topology and governance of
    a communication system.'
  prefs: []
  type: TYPE_NORMAL
- en: '|  |  | Governance |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|  |  | Decentralized | Centralized |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Topology | Consolidated | Not applicable | Centralized trust |'
  prefs: []
  type: TYPE_TB
- en: '| Distributed | Decentralized trust | Centralized trust |'
  prefs: []
  type: TYPE_TB
- en: The decentralized trust in DLs is the fundament for the trusted exchange of
    transactions among system participants. Transactions are validated and immutably
    and non-refutably stored in a ledger as a part of a new chain block or a related
    data structure in other ledger architectures (see Section 1 for details). Trusted
    exchange of transactions is essential for cryptocurrencies and, hence, the immense
    proliferation of distributed ledger technology. However, modern DL platforms,
    apart from the trusted exchange of transactions, also enable trusted execution
    of programming code–smart contracts. Smart contracts are one of the key elements
    of decentralized applications, discussed in Section 2.4.
  prefs: []
  type: TYPE_NORMAL
- en: 2.2 DApp triplet
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The term decentralized application is not precisely defined. Despite being
    present for more than a decade now, DLs and blockchains are still evolving concepts
    and technologies, so terminology, too, is maturing along with the research, practical
    developments, new DL-based application domains, and use cases. In this book, we
    refer to DApps [[16](9783110681123_008192.xhtml#b_9783110681130-005_ref_016)]
    as decentralized software systems with three components. We call these three components,
    the DApp triplet (see [Fig. 2.1](#b_9783110681130-002_fig_001)):'
  prefs: []
  type: TYPE_NORMAL
- en: A decentralized overlay distributed ledger network for trusted exchange of transactions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The on-chain application logic that is executed in a trusted way in the overlay
    network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The off-chain application logic implemented outside of the overlay network that
    can utilize both the trusted exchange of transactions and the trusted execution
    of the on-chain application logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../graphic/converted/b_9783110681130-002_fig_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Fig. 2.1: DApp triplet: DL network, smart contracts, and off-chain applications.'
  prefs: []
  type: TYPE_NORMAL
- en: At a very high level, DApp architecture can be compared to modern Web applications,
    which comprise backend and frontend, and require a communication network that
    interconnects the two. In the backend, the application logic that requires, for
    example, big data storage or complex computations is usually implemented. The
    frontend part of the application is oriented more towards the client user interfaces
    or logic in the embedded systems in IoT. Backend exposes an application programming
    interface (API), for example REST API, to exchange JSON structured content between
    backend and frontend. Communication connectivity is assured via the Internet protocol
    (IP) networks.
  prefs: []
  type: TYPE_NORMAL
- en: In DApps, the backend is assured by the smart contracts, the application logic
    running on the DL network. It is therefore called the on-chain logic/application
    part, too. Frontend applications in DApp are Web, mobile, or embedded applications.
    They do not run on the DL network (thus the off-chain application part) but access
    the backend services through the APIs exposed by the DL network nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 2.3 DL networks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A DL network is an incarnation of a particular DL technology. The DL technology
    (DLT) is implemented in a network node, and interconnected nodes build the network.
    There can be many different networks based on the same DLT. [Figure 2.2](#b_9783110681130-002_fig_002)
    shows that the DL operation is a set of application layer protocols that resides
    on a traditional TCP/IP stack and builds an overlay network. Similar communication
    topology is found in, for example, peer-to-peer (P2P) content distribution systems.
    For example, some of the communication principles in Ethereum have been directly
    adopted from the existing P2P systems. Unlike in the client-server communication
    topology, there are no central entities in a distributed DL network. All the nodes/clients
    have equal roles in providing communication capabilities. Peer nodes make the
    topology resilient and scalable. A node is thus a piece of software. Other denominations
    for a node are possible, too. A DL node is frequently referred to as a client.
    A node runs the DL protocols such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Low-level P2P network protocols for node discovery, network formation, flow
    control, or encryption of the traffic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: High-level P2P communication protocols for node identity, session management,
    and data exchange between the nodes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Upper layer protocols for exchanging data for synchronizing the chain among
    the nodes, for example, block headers, and for exchanging transactions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protocols for building transactions, including hashing and message serialization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consensus protocols for mining nodes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Various node, network management, and service utilization protocols and APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../graphic/converted/b_9783110681130-002_fig_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Fig. 2.2: DL network reference model.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on the scope of activated capabilities, the nodes in a DL network can
    be divided roughly into three categories:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The full nodes: each node keeps a copy of the entire ledger and synchronizes
    it continuously. These nodes are essential for the distribution of the network.
    They assure the validity of the ledger and the security of the DL system. Maintaining
    a copy of the entire ledger (every block, every transaction, and all the meta-data
    for the ledger structure) might result in extensive storage requirements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The light nodes: do not keep a copy of the entire ledger. They may have just
    the last part of it or partial information, e.g., block headers but not the block
    content. Light nodes impose modest system requirements and enable faster ledger
    synchronization, if the nodes’ connectivity is intermittent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The mining nodes: can be full or light nodes. Their key characteristic is running
    the ledger consensus protocols (see Section 1 and 1.2.1 for more details) to participate
    in the ledger building process. Mining is not a mandatory function of every DL
    node. However, it is frequently implemented in the standard node software and
    can be arbitrarily enabled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The access nodes: can be full or light nodes. They expose APIs for off-chain
    applications to interact with the DL network (see Section 2.5.2 for more details).
    As in mining, exposing the API is not a mandatory function, either.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But our interest in DL networks reaches beyond the technical aspects. It also
    includes the network governance, performance, and all the settings, tweaks, and
    new developments to adapt the DLTs for new, challenging use cases.
  prefs: []
  type: TYPE_NORMAL
- en: 2.3.1 Network organization and governance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Network governance covers various elements of the control of network nodes
    and, in this way, the control over the entire network and its services. The governance
    is as important as the DL technology for two essential qualities of DL networks:'
  prefs: []
  type: TYPE_NORMAL
- en: Performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security or trust
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the governance of the network operation and the use of its services, two
    aspects need to be distinguished:'
  prefs: []
  type: TYPE_NORMAL
- en: Control of the network nodes and, thus, the control of the consensus process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User access to the network services, for example, creating accounts, transactions,
    or transferring funds to another account.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In a DL network, the governance approaches for the two aspects need not be
    the same. For example, network services might be available freely without special
    access control. In contrast, in the same network, the management of the existing
    nodes and installation of additional mining nodes might strictly be limited to
    the network proprietor only. This might cause a wrong impression in uninformed
    users about the network’s actual levels of trust and security. If the network
    control is centralized, we can trust the network only if we fully trust the network
    proprietor (just as in a traditional database example, given in [Section 2.1](#b_9783110681130-002_s_002_s_001)).
    No (un)restricted service access or claims about network distribution can eliminate
    the need for trust in a central entity. A valid question, in this case, would
    be: "*Do we really need a DL in this case?*"'
  prefs: []
  type: TYPE_NORMAL
- en: 2.3.1.1 Public, private, and consortium networks
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Section 2.1](#b_9783110681130-002_s_002_s_001) clarified that the distribution
    of entities in a DL network is the prerequisite for decentralized trust. A distributed
    system can be decentralized or not. The approach to decentralization in the network
    defines the level of trust one can have in such a network. Well-known public blockchain
    networks such as the Bitcoin and Ethereum networks (see Section 1.2) are highly
    distributed. At the same time, they impose no limitations on who can add new nodes
    to the network, create accounts and transactions, or participate in the mining
    process. Hence, they are decentralized, too.'
  prefs: []
  type: TYPE_NORMAL
- en: For illustration, there were an estimated 7,000-8,000 nodes in public Ethereum
    mainnet in 2021 [[17](9783110681123_008192.xhtml#b_9783110681130-005_ref_017),
    [18](9783110681123_008192.xhtml#b_9783110681130-005_ref_018)] and about 10,000
    publicly listed full nodes in the Bitcoin network [[19](9783110681123_008192.xhtml#b_9783110681130-005_ref_019)].
    It is difficult to estimate the number of miners, as they are mainly organized
    into mining pools. Besides, to participate in mining, a node does not have to
    be a full node, and most miners are not. Another estimate states that around 100,000
    separate mining nodes in Bitcoin were organized in mining pools in 2021\. A similar
    number was reported for the Ethereum mainnet, too.
  prefs: []
  type: TYPE_NORMAL
- en: A public DL network relies solely on the high level of decentralization and
    implemented security algorithms to ensure the consensus among the honest majority
    of nodes. This provides security to the network and excludes malicious nodes from
    the network. In public DL networks, both the network control and service access
    are unrestricted. Such a network is a prerequisite to set up trusted decentralized
    cryptocurrencies, which was the first motivation of many of the DLTs. There are
    many prominent examples of public DL networks, for example, Bitcoin and Ethereum.
  prefs: []
  type: TYPE_NORMAL
- en: A private DL network is distributed, but the governance of the nodes and network
    is centralized to a single system proprietor. It, therefore, does not provide
    any decentralized trust. Limited or unlimited user service access cannot compensate
    for this lack of decentralization. Sometimes, the privately controlled networks
    tend to be presented as being public, primarily to gain the trust in the cryptocurrencies
    they provide. In the current version 1.0 of the IOTA network, for example, they
    only become genuinely valid when the network Coordinator node confirms them. All
    Coordinator nodes are operated and controlled by the IOTA Foundation, which has,
    in the past, already utilized this to modify the transaction ledger.
  prefs: []
  type: TYPE_NORMAL
- en: In a private DL network, we can apply the same technology and even the same
    initial setting as a public network. For example, we can use the same network
    node software (e.g., the Geth client for Ethereum), select the same consensus
    algorithm, and apply the same chain genesis settings as in the private Ethereum
    mainnet. We would probably have a much lower number of nodes in our network, but
    the operation of both networks would be very similar. There would be, of course,
    a difference in the chain data, but this would be due to different service usage
    patterns and not different network operations. The key difference between the
    public and or private network would thus be in their governance, apart from the
    use, of course.
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, in private DL networks, we usually do not try to mimic the existent
    public ones. Instead, we apply different chain genesis settings or even changed
    DL protocols to improve network performance, vastly. The key benefit of a private
    DL network is that we can trim it for performance.
  prefs: []
  type: TYPE_NORMAL
- en: The challenge of centralized governance in public networks can, to a large extent,
    be limited in the consortium DL networks. Here, the network control is still not
    public, but it is also not limited to a single central entity. Usually, a consortium
    of partners is built, having a common objective – for example, a DApp that interconnects
    distributed energy resource prosumers, who do not necessarily trust each other
    but are interested in collaboration. Every consortium partner can set up nodes
    and participate in consensus decisions, so the control is now, to some extent,
    decentralized. It is still not as decentralized as in the public networks, but
    this might even not be needed. In a consortium network, we do not have anonymous
    participants in the network, so the outlaw can be penalized in other ways, for
    example, with exclusion from the partnership or with legal measures. Consortium-based
    DL network governance is widespread in financial or IoT business applications.
    Some of the prominent public DL networks have consortium-based network control
    and not a pubic one, as, for example, the Hedera public network (see [Section
    2.7.1.3](#b_9783110681130-002_s_002_s_007_s_001_s_003) for details).
  prefs: []
  type: TYPE_NORMAL
- en: 2.3.1.2 Permissioned and permissionless networks
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The public or private nature of a DL network is based on the mode of network
    access. It can be:'
  prefs: []
  type: TYPE_NORMAL
- en: Permissioned
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Permissionless
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In public networks, access to the network services is permissionless. This means
    that a new network user (usually a person) does not have to possess any dedicated
    rights to create new accounts, build and submit transactions, or even add new
    nodes to the network, including mining nodes. The participant thus remains anonymous
    and is identified only by his randomly created DL network addresses. The relation
    between the real users and their DL addresses does not have to be disclosed to
    participate in the network or utilize its services.
  prefs: []
  type: TYPE_NORMAL
- en: In a permissioned system, users are authorized to access the network services
    or participate in the network control. There are several benefits of permissioning
    in DL. Permissioned network control can enable better network performance and
    is easier to be managed. A permissioned network also does not require a cryptocurrency
    to incentivize the mining process, which positively affects transaction costs.
    All these benefits of permissioned network control reflect in the network services
    provided to the user. Besides, permissioned DL systems can facilitate compliance
    with regulations like GPRD.
  prefs: []
  type: TYPE_NORMAL
- en: The terms public and permissionless are often seen as synonymous. The public
    is then understood as having no formal identity (vs. permissioned, with identity).
    This might be true for many of the public DL networks, including Bitcoin and Ethereum.
    Nevertheless, a private or consortium-controlled network might provide permissionless
    public network services, too ([Fig. 2.3](#b_9783110681130-002_fig_003)). Operation
    of the network and user access to network services are two distinct aspects of
    network governance and do not have to apply different governance and permission
    principles. Thus, some of the DLT taxonomies [[20](9783110681123_008192.xhtml#b_9783110681130-005_ref_020)]
    discuss public-permissioned systems, where the best features of public, private,
    and permissioned are combined. An example of such a network is Corda.[¹](footnotes.xhtml#fn_1)
  prefs: []
  type: TYPE_NORMAL
- en: '![](../graphic/converted/b_9783110681130-002_fig_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Fig. 2.3: DL network taxonomy.'
  prefs: []
  type: TYPE_NORMAL
- en: Let us consider some analogies to illustrate various combinations of governance
    and permissions in controlling a network and access to services. Please note that
    all the following are examples of centralized systems where we need to trust,
    for example, the mobile operator that it does not, for example, intercept our
    communications. Such a trust cannot be assumed, so there are strict regulations
    and legislation for the mobile operators and service providers to assure neutrality,
    privacy, and quality of service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Mobile networks:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Network control: private – by the mobile operator; permissioned – only the
    mobile network operator manages and controls the network.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Service access: public – anyone can become a mobile network user. The access
    is non-discriminatory, even though it is not free.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Service access permission: permissioned – if a user has a subscription, that
    is, a post-paid plan.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Service access permission: permissionless – if a user has no subscription,
    pre-paid.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Open public WLAN:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Network control: private – by the WLAN provider; permissioned – the provider
    usually restricts access to the WLAN management system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Service access: public.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Service access permission: permissionless – no user credentials are needed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Airport public WLAN:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Network control: private – by the WLAN provider, permissioned.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Service access: public – anyone can register and then use the service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Service access permission: permissioned – users need some prior registration,
    for example, through a web page.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Company private WLAN:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Network control: private – by the company running the WLAN, permissioned.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Service access: private – only registered company employees can use the service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Service access permission: permissioned – users need a WLAN account provided
    by the WLAN administrators.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tab. 2.2:Permissioning approaches in public, consortium, and private DL networks.
  prefs: []
  type: TYPE_NORMAL
- en: '|  | Public | Consortium | Private |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **Network control and operation** |'
  prefs: []
  type: TYPE_TB
- en: '| Adding network nodes | Permissionless | Permissioned or limited to consortium
    members | Permissioned |'
  prefs: []
  type: TYPE_TB
- en: '| Mining and consensus | Permissionless | Limited to consortium members | Not
    possible |'
  prefs: []
  type: TYPE_TB
- en: '| **DL service access** |'
  prefs: []
  type: TYPE_TB
- en: '| Accounts and transactions | Permissionless | Permissioned or permissionless
    | Permissioned or permissionless |'
  prefs: []
  type: TYPE_TB
- en: '| Node API | Permissionless | Permissioned or permissionless | Permissioned
    or permissionless |'
  prefs: []
  type: TYPE_TB
- en: Various permission levels can be applied in a network (Table 2.2). Some of the
    activities might require registration and an appropriate permission level (e.g.,
    adding new full nodes). Some might be prohibited entirely (e.g., the mining).
    The others might require no special permissions by the user (e.g., creating accounts
    and issuing transactions).
  prefs: []
  type: TYPE_NORMAL
- en: 2.3.1.3 User and data privacy in DL networks
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Privacy is another challenging concept when DL networks and services are scrutinized.
    The permissionless nature of many known public DL networks might lead to the idea
    that anonymity and privacy are intrinsic features of (all) DL systems. We have
    to distinguish between [[21](9783110681123_008192.xhtml#b_9783110681130-005_ref_021)]:'
  prefs: []
  type: TYPE_NORMAL
- en: User privacy; and
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data privacy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In permissionless public networks, user privacy is assured. Anyone can create
    a new account in such a network and send and receive transactions from it. The
    network does not require any mapping between the user’s personal identity and
    the DL network account/address. Unless the user himself discloses the ownership
    of a particular account, this remains private and anonymous. This is frequently
    done when users register with an online crypto exchange to buy and sell cryptocurrencies
    for established fiat money, such as EUR or USD, and then conduct DL transactions
    to their other DL accounts.
  prefs: []
  type: TYPE_NORMAL
- en: However, the data about all the transactions related to these accounts is entirely
    transparent. A copy of the ledger and thus the entire content of the blocks and
    transactions are publically available, as this is the fundament for distribution
    and decentralization of the DL system. In such a network, data is not private
    at all. Anyone can follow all the incoming and outgoing transactions for any account
    or calculate the account balance.
  prefs: []
  type: TYPE_NORMAL
- en: The same limitations to data privacy apply in private and consortium-based networks,
    just that the access to data is not fully public but reduced to those in control
    of the network. Data privacy in DL networks can be assured, but appropriate techniques
    have to be adapted. One of them is zero-knowledge proof. See Section 3.1.1 for
    ZK-SNARK and other privacy-related approaches in DLT-based IoT solutions. Even
    with the transaction-related privacy that is enabled, transaction auditing is
    possible to comply with anti-money laundering or tax regulations, where disclosure
    is under the user’s control.
  prefs: []
  type: TYPE_NORMAL
- en: 2.3.2 Network performance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is challenging to be address DL performance systematically and in an ordinary
    way because it intertwines many divergent technologies, network implementation,
    performance criteria, or use-related expectations.
  prefs: []
  type: TYPE_NORMAL
- en: Transaction throughput (number of transactions per second, tps) and transaction
    confirmation latency (delay) are the two most straightforward performance metrics.
    However, it is difficult to compare even these two metrics among different DLTs
    or networks. Transaction throughput and latency of current DL systems cannot be
    compared to the figures of the centralized or traditional distributed database
    services [[22](9783110681123_008192.xhtml#b_9783110681130-005_ref_022)]. Often,
    much of the bad user experience can be related to misconceived perspectives or
    insufficient understanding of the underlying technology, or inappropriately chosen
    use cases for the DLT. Besides, it is impossible and unfair to judge the performance
    of a DLT based on (only) one network implementation. For example, the Ethereum
    technology performance cannot be estimated only on the quantitative experience
    (measurements), for example, the Ethereum mainnet. The same technology (same software)
    can be implemented in a private or consortium network. Different network sizes
    or settings assure dramatically different performance in terms of transaction
    throughput or latency. This is true for all DLT architectures, where different
    deployments are allowed.
  prefs: []
  type: TYPE_NORMAL
- en: It is often hard to obtain relevant and comparable performance results. Theoretical
    limits can be calculated. But realistic performance stress tests in live public
    networks are difficult to be executed, for example, due to transaction costs.
    Analyses of smaller private networks with the same DLT cannot fully mimic large
    distributed ones. Furthermore, some DLT and network providers are approaching
    performance aspects of their systems systematically and backed by research (Hyperledger
    Fabric [[23](9783110681123_008192.xhtml#b_9783110681130-005_ref_023)]) and tools
    (Caliper) ([Fig. 2.4](#b_9783110681130-002_fig_004)). Others provide transparent
    and detailed statistics about the network (see [Section 2.6.4](#b_9783110681130-002_s_002_s_006_s_004)).
    Some merely present impressive figures that cannot be replicated and lack transparent
    methodology.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../graphic/converted/b_9783110681130-002_fig_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Fig. 2.4: System for DL network performance evaluation.'
  prefs: []
  type: TYPE_NORMAL
- en: Apart from transaction throughput and latency, several other metrics become
    important with real-world network deployments and DApps. These include DL network
    energy consumption, resource requirements put on nodes (e.g., storage for the
    chain data) and off-chain clients (e.g., transaction generation-related encryption
    in constrained IoT devices), or transaction costs.
  prefs: []
  type: TYPE_NORMAL
- en: 2.3.2.1 Transaction throughput and latency
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Transaction throughput is the number of committed transactions in a given time
    interval. However, not every unit of the work process counts as a transaction,
    in this case. Only transactions that result in a state change should be considered.
    Examples of such transactions are transferring funds from one account to another
    in Bitcoin (BTC) or invoking a smart contract call via the transaction in Ethereum.
    The smart contract read requests are not executed with state-changing transactions,
    so they should be excluded from this metric. This is also true for the pass-through
    transactions, where the same transaction is passed among various smart contracts.
    It should be therefore counted as one. Invalid transactions rejected by the validating
    node and, thus, do not qualify for inclusion in the ledger should be excluded,
    too. This might seem obvious, but there are network performance reports where
    it is impossible to determine what actions were counted and what were not.
  prefs: []
  type: TYPE_NORMAL
- en: 'The overall transaction latency depends on times needed for:'
  prefs: []
  type: TYPE_NORMAL
- en: transaction generation, that is composing the data structure, calculating hashes
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: submission through an access node
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: propagation over the P2P network and validation of the transaction in the miner
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: block creation and the consensus in the network
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: extra time to reach a sufficient level of finality.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first two factors reflect the off-chain factors, such as the resources of
    the end device that is generating a transaction. The remaining factors reflect
    the network performance.
  prefs: []
  type: TYPE_NORMAL
- en: The theoretical limit for transaction throughput can be calculated from the
    average block time and the average number of transactions in a block. Block time
    distributions depend on the consensus algorithm. In PoW, the block time is a consequence
    of the current block difficulty and the overall hashing power of the network.
    The difficulty is automatically adapted to the changes in hashing power, but the
    jitter in block times is always present in PoW. The Proof of Authority (PoA),
    on the other hand, can provide very consistent block times because the target
    block times a setting in the PoA network genesis. Blocks in a blockchain carry
    a limited number of transactions. In the BTC network, the maximum block size is
    1 MB. With an average size of 500 B, the maximum number of transactions is about
    2,000 per block. A new block is produced about once every 10 min. This results
    in an average BTC network throughput of 3 tps. In Ethereum, the sum of gas (see
    [Section 2.3.2.3](#b_9783110681130-002_s_002_s_003_s_002_s_003) for gas and transaction
    costs) of all transactions in a block has to be less than the maximum gas (per
    block). In the Ethereum mainnet, with the maximum block size of 10,000,000 and
    minimum gas per transaction of 21,000 (or average gas 72,000), there can be up
    to 476 (138 for average size) transactions in a block. A new block is generated,
    on average, in 13 s. The maximum transaction throughput of the Ethereum mainnet
    is about 37 tps (10 tps for average size).
  prefs: []
  type: TYPE_NORMAL
- en: The block time cannot be simply reduced for better performance (both higher
    throughput and lower latency) without jeopardizing network convergence. If the
    consensus algorithms require broadcasting block creation information through the
    network (e.g., in PoW), the propagation delay depends on network size. Extensive
    network size is needed for high distribution and decentralization. If the block
    time were reduced close to or under the network propagation time, this would lead
    to constant forking at the end of the chain and, possibly, to network divergence.
  prefs: []
  type: TYPE_NORMAL
- en: The network transaction latency is the time needed for the state change caused
    by the transaction to be reflected across the network – the time difference between
    submitting a newly created transaction and confirming inclusion in the ledger.
    Two events have to be distinguished in the transaction lifecycle. A transaction
    is first confirmed by a miner when it is included in a newly mined block. However,
    it is not guaranteed that the block will become a part of the chain until the
    information is propagated and accepted by the network. This is when the transaction
    is finalized. In a network with only one mining node, confirmation and finalization
    occur at the same time. The network transaction latency is calculated per transaction,
    but we mainly provide statistics over several transactions, such as the average,
    maximum, minimum, and standard deviations.
  prefs: []
  type: TYPE_NORMAL
- en: Finality assures that the transactions cannot be arbitrarily changed or reversed
    after being validated and included in blocks. In DL networks with probabilistic
    finality (BTC, Ethereum), we cannot reach a 100% finality. Instead, the time for
    a transaction to be considered as finalized is the amount of time one has to wait
    for an appropriate guarantee. For sufficient finality, we, therefore, wait for
    confirmation of additional blocks (usually 2–10) to be appended after the one
    with our transaction. In DLT architectures with absolute (or deterministic) finality,
    once the block is confirmed, all transactions in a block are immediately considered
    finalized. For networks in which not every block is finalized, a useful metric
    is a delay between the latest finalized block and the current latest block. This
    number shows how much validators are lagging behind, agreeing on the correct chain
    [[24](9783110681123_008192.xhtml#b_9783110681130-005_ref_024)].
  prefs: []
  type: TYPE_NORMAL
- en: Public DL networks rely on different network topologies, which influence the
    network performance. Often, this is at the cost of decentralization and security.
    BTC and Ethereum are both highly distributed networks, with thousands of mining
    nodes, where network propagation is relevant for the consensus and performance.
    To reduce the effects of network propagation times and thus increase the odds
    for successful mining, mining pools apply more efficient protocols for information
    propagation within the pool. In Hedera Hashgraph, only ten mainnet nodes execute
    a form of virtual voting to reach a consensus on both the validity and the timestamp
    of every transaction. The voting selects a single miner to choose the next block.
    The community of nodes running Hashgraph then comes to an agreement, as a collective,
    on which transactions to add to the ledger. In the EOS[²](footnotes.xhtml#fn_2)
    blockchain network, the number of block producers is low, too. There are 21, which
    take turns in producing blocks in a round-robin fashion. Anyone can start his/her
    EOS node and, if voted for by the community, can become a block producer. To select
    these 21 block producers, users vote on a list of candidates (Delegated Proof
    of Stake (DPoS)).
  prefs: []
  type: TYPE_NORMAL
- en: 2.3.2.2 Resource consumption
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Running and using a DL network can mandate significant resource requirements,
    including computation, storage, and energy.
  prefs: []
  type: TYPE_NORMAL
- en: The PoW consensus mechanisms are known to be highly energy inefficient (see
    Section 1.2 for details). The hashing power provided by the mining nodes requires
    high computational capabilities (CPU, GPU, or dedicated hardware). The annualized
    energy consumption[³](footnotes.xhtml#fn_3) needed to run the BTC network is comparable
    to a mid-sized developed country. Therefore, it is not surprising that energy
    efficiency is one of the critical objectives of alternate consensus mechanisms.
    This is especially true for private and consensus governed networks, where the
    mining process is not monetarily incentivized or compensated.
  prefs: []
  type: TYPE_NORMAL
- en: The chain data size in BTC and Ethereum is hundreds of GB and is constantly
    growing. In a P2P file-sharing system, a network participant can keep and share
    only a small portion of the content, for example, only a specific version of the
    installation file for a popular Linux distribution. The participant does not have
    to share the entire content (all the installation files available) to be a meaningful
    member of the distributed network. In DL networks, on the other hand, one has
    to keep and share the entire distributed ledger because this is the only way to
    assure decentralization and trust in the system. This requires substantial dedicated
    storage for a full node. Large storage requirements deter many enthusiastic net
    citizens from setting up a reliable full public DL network node and contributing
    to the system’s decentralization. Large chain size also increases the bootstrap
    time needed for a new node to synchronize with the chain.
  prefs: []
  type: TYPE_NORMAL
- en: Communication requirements for a non-mining and mining node are rather diametric.
    The chain synchronization requires reliable but modest bitrate network connectivity
    for a network node. The average data for the regular synchronization of new blocks
    in the Ethereum is about 18 kB/s and about 10 kB/s in download [[25](9783110681123_008192.xhtml#b_9783110681130-005_ref_025)].
    Intermittent connectivity is essential for the off-chain applications, which may
    cease to run or run properly, with the chain unsynchronized due to temporary connectivity
    problems.
  prefs: []
  type: TYPE_NORMAL
- en: For overall network performance, the rapid dissemination of block-related information
    between the mining nodes is essential. Block propagation time can become the critical
    performance bottleneck in truly distributed networks with many participating mining
    nodes. Distributed communication protocols applied for this propagation are not
    the most efficient and are sensitive to any low-level communication-related propagation
    delay. Therefore, a capable, low-delay communication is recommended to interconnect
    the mining nodes. Many of the mining pools apply dedicated communication approaches
    to speed up the dissemination of mining information within the pool and, in this
    way, gain some advantage for the miners of their pool.
  prefs: []
  type: TYPE_NORMAL
- en: Other computer resource demands, for instance, memory and CPU power needed to
    run non-mining full network nodes or network access clients, are usually not very
    restrictive if we set these nodes on regular computers. However, with IoT devices,
    which are often constrained in computation and communication resources, this quickly
    becomes a problem. We review the details of the blockchain and IoT in Section
    3.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we would like to explain the gas, which is used to evaluate the
    resource consumption of smart contracts and transactions in Ethereum. Gas reflects
    both the size of a transaction (in bytes) and the complexity of the calculations
    during the smart contract execution. However, gas reflects only the complexity
    of state updates and smart contract execution. It does not reflect all the resources
    needed, for example, for validating a transaction and is thus unsuitable as an
    exact indicator of the overall network performance [[26](9783110681123_008192.xhtml#b_9783110681130-005_ref_026)].
  prefs: []
  type: TYPE_NORMAL
- en: 2.3.2.3 Transaction costs
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'DL networks adopt wildly divergent approaches to compensate the capital expenditures
    and operational costs (Table 2.3):'
  prefs: []
  type: TYPE_NORMAL
- en: Compensation as a reward for successful mining. This approach is the key compensation
    principle in large distributed public networks, e.g., BTC and Ethereum. Due to
    the immense costs of energy, financial rewards for miners are necessary. For a
    successfully created block, which is appended to the ledger, the miners newly
    create the agreed amount of cryptocurrency and register it to their accounts.
    Mining rewards are gradually decreased. This is a built-in function of the DL
    protocols.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compensation through transaction fees. In DL networks with public cryptocurrencies,
    the transaction fee is charged to the transaction sender. This is additional charge
    to the bounties for successful mining. For a long time, the mining rewards were
    higher than the transaction fees for a block. However, in Ethereum, the transaction
    fees for a block have already matched the mining reward. Various principles exist
    to determine the actual fee.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Participation in transaction validation. In some DLTs (e.g., IOTA), the transaction
    submitter must validate one or more transactions from other submitters. In this
    way, the load and the costs related to transactions are distributed directly to
    the senders.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No compensation through the DL network. This is convenient for private or consortium
    networks with a low distribution of the network nodes where the overall costs
    are not very high. The network providers seek other means for income, for example,
    charging other services based on the DL network or contributions from the consortium
    partners. In this approach, the transaction senders pay no fees.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no absolute value of acceptable transaction costs, as this varies from
    use case to use case. In decentralized finance (DeFi), application costs of several
    EUR or USD might be acceptable. On the other hand, in micropayments and microtransactions,
    even a fraction of a cent may be disputable and limiting for a successful use
    case. Apart from the absolute value, the volatility of the fees can be a problem.
  prefs: []
  type: TYPE_NORMAL
- en: Tab. 2.3:Transaction costs in various public DL networks.
  prefs: []
  type: TYPE_NORMAL
- en: '|  | Type of cost compensation | Key characteristics |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **Bitcoin** | Transaction fees based on transaction size in bytes | Fee depends
    on the fluctuations of cryptocurrency value |'
  prefs: []
  type: TYPE_TB
- en: '| **Ethereum** | Transaction fees based on gas | Fee depends on fluctuations
    of cryptocurrency value |'
  prefs: []
  type: TYPE_TB
- en: '| **Hedera** | Fees for network services API calls | Predefined rates set in
    fiat |'
  prefs: []
  type: TYPE_TB
- en: '| **Corda** | Annual participation + transactions fees | Predefined rates set
    in fiat |'
  prefs: []
  type: TYPE_TB
- en: '| **IOTA** | Participation in the validation process | The sender has to do
    the PoW for two previously unconfirmed transactions. |'
  prefs: []
  type: TYPE_TB
- en: Transaction fees in BTC need to reflect the transaction size in bytes. As the
    BTC block size is limited, miners may prefer smaller to large transactions. They
    are, therefore, motivated to prioritize the smaller ones. On the other hand, a
    transaction sender can prioritize a transaction with a higher fee. Many crypto
    wallets have already come up with built-in fee calculators.
  prefs: []
  type: TYPE_NORMAL
- en: The transaction fee in Ethereum is determined through gas and gas prices. Gas
    reflects resource consumption and, thus, the costs of processing a transaction.
    A transaction sender selects the gas price (value in Ether). The gas is multiplied
    by the gas price to calculate the fee of a particular transaction. It is more
    likely that miners will consider a transaction with a higher fee while building
    the next block.
  prefs: []
  type: TYPE_NORMAL
- en: As all the Hedera Hashgraph network services are available only through APIs,
    users cannot directly create and submit transactions. They would rather pay for
    the API calls instead of paying fees for transactions. The API pricing is transparent,[⁴](footnotes.xhtml#fn_4)
    and the fees are set in fiat. They vary according to the type of API call. The
    crypto transfer API call was priced in 2021 at 0.0001 USD, allowing micro-transactions
    (<0.01 USD) to be economically and technologically practical. A smart contract
    call or a creation of a file in the Hedera DL costs 0.05 USD.
  prefs: []
  type: TYPE_NORMAL
- en: 'A separate entity called Corda Network Foundation was set up to govern the
    development and networks in Corda. In Corda, the networks are semi-private and
    permissioned. A node must obtain a certificate from the network operator to join
    a network. A network operator would charge reasonable costs for providing network
    and administration services, which is paid by the Foundation. In Corda, the participants
    pay an annual participation fee and transaction fees. Transaction fees are charged
    for notarization provided by Corda Network notary and are structured in two different
    models: Pay-As-You-Go and Up-front package. The total fees depend on the number
    of transactions, but Corda provides a very transparent and predictable transaction
    pricing.'
  prefs: []
  type: TYPE_NORMAL
- en: IOTA replaces transaction fees paid in terms of MIOTA (or another digital asset,
    or fiat) with transaction fees paid in terms of hash power.[⁵](footnotes.xhtml#fn_5)
    The sender of a transaction has to establish the PoW for two previously unconfirmed
    transactions. This way, mining is distributed among transaction senders and not
    among dedicated mining nodes. In IOTA, transactions are then reinforced when other
    transactions reference them. Currently, transactions only become truly valid (finalized)
    when the network Coordinator, a special node operated by the IOTA Foundation,
    confirms them.
  prefs: []
  type: TYPE_NORMAL
- en: 2.3.3 Scalability
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We need to investigate the scalability in the context of two additional blockchain
    properties, all three together known as the blockchain scalability trilemma. This
    trilemma points out three essential properties of DL systems: decentralization,
    security, and scalability. Decentralization (see [Section 2.1](#b_9783110681130-002_s_002_s_001)
    for more details) refers to the diversification in ownership and control in the
    DL system. The degree of decentralization is not a binary attribute, and practical
    network implementations provide some level of decentralization between fully decentralized
    and (fully) centralized systems. Security includes network operation aspects that
    make the network robust and resilient to attacks (e.g., 51%, DoS). Scalability
    is about expanding the network in terms of additional nodes, and more importantly,
    increasing its performance.'
  prefs: []
  type: TYPE_NORMAL
- en: Decentralization, security, and scalability aspects cannot easily co-exist,
    so balancing them is needed ([Fig. 2.5](#b_9783110681130-002_fig_005)). For example,
    in an extensive public network, increased distribution and decentralization provide
    a higher level of trust but increase security risks from anonymous and possibly
    malicious network participants. Similarly, more centralized governance in a consortium-based
    network can be favorable to scale the network performance, but it reduces the
    (decentralized) trust.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../graphic/converted/b_9783110681130-002_fig_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Fig. 2.5: The scalability trilemma in the blockchain.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the extensive increase of users, performance and scalability issues of
    major PoW-based public blockchains has arisen. This has led to the research of
    novel DLTs and affected the development of the existing ones. Several approaches
    can be taken to facilitate scalability in blockchain systems. We discuss three
    scaling principles, which are being implemented in various forms and for different
    existing blockchain technologies:'
  prefs: []
  type: TYPE_NORMAL
- en: On-chain scaling solutions include modifications in the ledger (block size and
    structure, block times), consensus mechanism (see Section 1), or sharding of the
    network.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Off-chain scaling solutions attempt to facilitate transaction off-loading, that
    is, a trusted transaction exchange out of the main ledger, for example, with the
    state channels and oracles.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cross-chain scaling solutions where multiple DL networks are interconnected
    via gateways/relays to exchange transactions among various systems. Cross-chain
    solutions are a very novel research area. They not only contribute to the scalability
    of DL networks but are also crucial for DL interoperability.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2.3.3.1 Sharding
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Sharding is an on-chain method, where the DL network topology is divided into
    several smaller networks, called shards. Each shard contains a part of the network
    nodes. Different shards process transactions in the network. This reduces the
    number of transactions that have to be processed by each node and has two positive
    consequences:'
  prefs: []
  type: TYPE_NORMAL
- en: State sharding – nodes keep only data of their shard. This reduces the nodes’
    system requirements and reduces the bootstrap time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transaction sharding – transactions are distributed among different shards;
    they can be processed and verified in parallel. This increases the transaction
    throughput of the entire network. A reduced number of nodes in a shard accelerates
    the block propagation, too.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But such a change of network topology has several difficulties. For the performance
    increase obtained with sharding, we sacrifice decentralization and thus the trust
    in the system. Distribution is also reduced, so common DL network security risks
    (51% attack) become emphasized. Another problem is that of transactions originating
    in one and destined to another shard. These cross-shard transactions are more
    difficult to be processed. They require more communication and dedicated mechanisms
    to propagate between the shards. Therefore, the efficiency of sharing is strongly
    dependent on the statistical properties of the transactions and, thus, on a particular
    use case.
  prefs: []
  type: TYPE_NORMAL
- en: A modified sharding approach consists of the main chain (network) and multiple
    shard chains. Each shard periodically commits its state to the main chain. In
    this way, the trust in the shard data can be verified. The cross-shard transactions
    are processed via the main chain. The efficiency of this approach suffers enormously,
    if the number of cross-shard transactions increases and the main network becomes
    a bottleneck.
  prefs: []
  type: TYPE_NORMAL
- en: Research on sharding investigates how to allocate nodes into shards efficiently
    and how to protect decentralization and security. Most of the sharding development
    and implementation focuses on public DL networks, often, those with PoW consensus.
    In private or consortium networks, performance is increased, instead, by trimming
    the main network operation.
  prefs: []
  type: TYPE_NORMAL
- en: 2.3.3.2 Off-chain state channels
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: State channels are a complementary off-chain method that temporarily off-loads
    the transactions between two DL accounts from the DL network into a dedicated
    channel. State channels are also known as payment channels, if the transactions
    predominantly exchange value between accounts and not tokens or smart contract
    calls. They reduce the load of the main chain and thus improve the performance
    of the overall system. A channel is established, managed, and cleared through
    a smart contract in the main DL network, which serves as an arbiter. It can be
    established directly between the two accounts. A channel can have several hops
    through the state channel network in a dedicated off-chain network of state channel
    nodes, which build a layer on top of the DL network. As the transactions in the
    channel are not built into blocks, there is no latency due to block creation,
    and no transaction fees apply.
  prefs: []
  type: TYPE_NORMAL
- en: Two prominent examples of state channels are the Lightning Network[⁶](footnotes.xhtml#fn_6)
    for BTC and Raiden Network[⁷](footnotes.xhtml#fn_7) for Ethereum. The Lightning
    network is limited to BTC transactions. Apart from regular transactions, the Raiden
    network supports ERC20 tokens, too.
  prefs: []
  type: TYPE_NORMAL
- en: 2.3.3.3 Cross-chain swaps
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Cross-chain techniques, also known as the atomic swap, or cross-chain atomic
    swap, have a twofold role in DL network topology and operation:'
  prefs: []
  type: TYPE_NORMAL
- en: Scalability – they separate transaction exchange from a single common DL network
    into a set of interconnected networks. As the transactions are distributed into
    several networks, they can be processed in parallel. This increases the transaction
    throughput of the entire system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interoperability – unlike in sharding, cross-chain swapping can integrate networks
    based on different DLTs, so that the DL applications are no longer confined to
    their chains.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Its interoperability is even more disruptive than the contribution to scalability,
    as it is opening a range of new DL use cases. In this way, we will be able to
    assure protocol and semantic interoperability between BTC, Ethereum, and other
    DLT-based networks. Similarly, we could integrate, for example, a private and
    a public DL network into a hybrid topology. Through the cross-chain swap, the
    smart contract service flows in the private and in the public network remain synchronized,
    as if the entire platform were implemented in one network. Still, with two (or
    more) network types, we can now support different performance, security, and scalability
    requirements of the overall business logic.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-chain swaps are assured through elements called relays, bridges, and hubs,
    usually along with a dedicated DL for relaying. COSMOS[⁸](footnotes.xhtml#fn_8)
    is an ecosystem of connected blockchains. It utilizes a DL network based on the
    Tendermint Core with the Cosmos consensus mechanism. The Inter-Blockchain Communication
    (IBC) protocol is used to connect to other DL networks and applications. Polkadot,[⁹](footnotes.xhtml#fn_9)
    too, is a relaying blockchain. With a set of validators, it assures the security
    of the relaying chain, which links together various independent parachains. Collators
    are network elements that link to already running DL networks, including Ethereum.
    They package the parachain blocks and pass them to validators for verification.
  prefs: []
  type: TYPE_NORMAL
- en: 2.4 Smart contracts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Smart contracts are the second cornerstone of the DApp triplet (see [Section
    2.2](#b_9783110681130-002_s_002_s_002) for details). The term smart contract was
    coined in 1996, long before the appearance of the first blockchain networks, by
    Nick Szabo [[27](9783110681123_008192.xhtml#b_9783110681130-005_ref_027)]. He
    regards smart contracts as contractual closes, which are implemented in hardware
    and software in such a way as to make a breach of a contract prohibitively expensive.
    He pointed out vending machines and traditional payment or banking transaction
    systems as forerunners of modern DApps and smart contracts. Interestingly, from
    the principles in law, economic theory, and contractual conditions often found
    in practice, he outlined four basic objectives of the contract design [[27](9783110681123_008192.xhtml#b_9783110681130-005_ref_027)]:'
  prefs: []
  type: TYPE_NORMAL
- en: Observability – the ability to prove one’s or to observe other’s performance
    of the contract
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verifiability – proving to an arbitrator that a contract has been performed
    or breached
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Privity – minimizing the vulnerability to third parties and excluding them from
    the knowledge and control over the content and performance of the contract (privacy
    and confidentiality)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enforceability – minimizing the effort for enforcement, including self-enforcing
    protocols
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Szabo so well anticipated many of the findings, which, several years later,
    implemented his ideas in the BTC protocol and network that he is considered as
    one of the candidates for the real BTC inventor. The real inventor remains unknown
    and is still known only by the pseudonym Satoshi Nakamoto. At least to some extent,
    the four mentioned objectives are met in most of the current DLTs and networks
    that reach beyond the simple value transactions and enable DApp development (Ethereum,
    Hedera Hashgraph, and Hyperledger).
  prefs: []
  type: TYPE_NORMAL
- en: Smart contracts are neither smart nor binding in the sense of legal obligations.
    However, in business collaborations, they are typically used to enforce some type
    of agreement, so that all participants can be certain of the outcome, without
    an intermediary’s involvement [[28](9783110681123_008192.xhtml#b_9783110681130-005_ref_028)].
    Such an agreement, coded in the smart contract on-chain logic, has no central
    point of failure, can perform operations, hold value, and unlock it only if specific
    conditions are met [[29](9783110681123_008192.xhtml#b_9783110681130-005_ref_029),
    [30](9783110681123_008192.xhtml#b_9783110681130-005_ref_030)].
  prefs: []
  type: TYPE_NORMAL
- en: 2.4.1 Virtual machine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The execution environment for the smart contract code can be compared to a virtual
    machine, which is provided by the DL network. In fact, in Ethereum, this environment
    is called the Ethereum Virtual Machine (EVM).
  prefs: []
  type: TYPE_NORMAL
- en: Different virtual machines exist for the currently available DLTs. EVM is among
    the most popular ones. Some of the non-Ethereum DLTs adopted the EVM, too, despite
    having completely different ledger and consensus technologies from Ethereum. For
    example, Hedera provides an adaptation of EVM implementation for the Hedera Smart
    Contract Service. Sawtooth,[^(10)](footnotes.xhtml#fn_10) one of many Hyperledger
    projects, with its built-in Hyperledger Burrow,[^(11)](footnotes.xhtml#fn_11)
    can run Solidity smart contracts in the EVM for Hyperledger. This not just facilitates
    the reuse of smart contracts developed for Ethereum; using the same smart contract
    programming language and relying on a familiar smart contract execution environment
    can also be very favorable for the developer. They can rely on their preceding
    software and security engineering experience and reuse their existing codebase,
    making the development faster and more secure.
  prefs: []
  type: TYPE_NORMAL
- en: Other DL virtual machines take different approaches and use different smart
    contract programming languages. The smart contract code in Corda, for example,
    is written using Kotlin, a programming language from JetBrains that targets the
    Java Virtual Machine (JVM) and JavaScript. The virtual machine for contract execution
    and validation is an augmented and radically more restrictive version of the JVM,
    which enforces security requirements and deterministic execution. Smart contracts
    in EOS run WebAssembly, meaning that a wide variety of languages is supported.
    The chaincode in Hyperledger can be written in any programming language and is
    executed in containers. Currently, Golang, JavaScript (in NodeJS), and Java chaincode
    are supported. With the provided support for EVM, Hyperledger can also run Solidity
    smart contracts.
  prefs: []
  type: TYPE_NORMAL
- en: The distribution of a DL system does not scale the performance of a VM. Each
    node in the DL network (not just miners) executes the smart contract code. This
    ensures the consensus and, thus, trust in the results of the smart contract execution.
    All DL nodes repeat the same operation coded in a smart contract, and thus all
    run the same copy of the virtual machine. Smart contract processing capabilities
    of the whole network, therefore, remain limited to the capabilities of a particular
    node.
  prefs: []
  type: TYPE_NORMAL
- en: 2.4.2 Lifecycle
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A smart contract is a software product. Its lifecycle is being designed and
    developed, compiled, and deployed to the DL network. Finally, it is used as a
    part of a DApp. This is similar to any other software product. However, smart
    contract execution in the DL network imposes several specifics and limitations
    in smart contract software engineering related to development, performance, and
    security. We will discuss these in the following sections. The smart contract
    lifecycle is outlined in [Fig. 2.6](#b_9783110681130-002_fig_006). It is indicated
    in the figure that the management and several phases can be found in the lifecycle,
    too. However, these are not necessarily present, if the smart contract is very
    simple or software engineering is taken lightly. Omitting the verification and
    thoroughly planned and implemented management of smart contracts can have devastating
    security consequences. The figure refers to the lifecycle that is typical for
    the Ethereum-based DApps. Smart contracts in other DL platforms might have slightly
    different lifecycles. For example, in Hyperledger Fabric, no compilation of smart
    contract source code into BC native executable bytecode is needed, as the smart
    contracts are installed and run in containers.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../graphic/converted/b_9783110681130-002_fig_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Fig. 2.6: Smart contract lifecycle in Ethereum.'
  prefs: []
  type: TYPE_NORMAL
- en: Design, development, and source code verification produce the source code of
    a smart contract. In Ethereum, source code is usually coded in the Solidity language
    (see [Section 2.4.3](#b_9783110681130-002_s_002_s_004_s_003) for details on smart
    contract tools and languages). During the design and programming of the source
    code, different formal and runtime methods can be taken to verify the correctness
    of the smart contract code and minimize possible security flaws in the specification
    and code implementation.
  prefs: []
  type: TYPE_NORMAL
- en: The source code is then compiled to a version that can be deployed and executed
    in the DL system. In Ethereum, this is an Ethereum-specific binary format, called
    the EVM bytecode.
  prefs: []
  type: TYPE_NORMAL
- en: In Ethereum, the use of a deployed smart contract is defined by an Application
    Binary Interface (ABI) specification [[31](9783110681123_008192.xhtml#b_9783110681130-005_ref_031)].
    An ABI is an interface between external program modules and the smart contract
    bytecode. The bytecode and the ABI file are then sent off to the blockchain with
    a contract creation transaction. This special transaction is sent to an empty
    receiver BC address, with the EVM bytecode as data. The transaction sender is
    a valid Ethereum account. This account becomes the owner of the smart contract.
    Once the smart contract deployment transaction is added to the chain by validating
    nodes in the BC, the smart contract obtains a unique smart contract address. Now,
    transactions can be destined to the address of the newly deployed smart contract.
    A smart contract has its balance, some code, and some persistent storage to execute
    its operations. Another level of verification can be added after the deployment.
    We can now check for possible compilation flaws at the bytecode level or ensure
    that the deployed bytecode logic matches the source code.
  prefs: []
  type: TYPE_NORMAL
- en: In the Ethereum BC, the ABI stipulates the de facto mechanism for encoding/decoding
    data into/out of a smart contract, that is, how we call functions in a contract
    or pass and get data back. Slightly different approaches are taken in other distributed
    ledger architectures, for example, Hyperledger [[32](9783110681123_008192.xhtml#b_9783110681130-005_ref_032)].
    Other smart contracts in the network and the external (off-chain) applications
    call smart contract methods to read the smart contract parameters or send BC transactions
    to the smart contract to change its state. A smart contract can emit events filtered
    by the DL network nodes and can be passed to the external applications by a node.
    Different smart contracts in the same network reside within the same virtual machine.
    Their communication is straightforward and limited only by the access rights encoded
    in a smart contract. Off-chain applications need to have access to a valid DL
    account and an API to communicate with the DL node. For the Ethereum off-chain
    applications, several frontend JavaScript APIs are provided, including frontend
    programming libraries. An example is the Web3.js – Ethereum JavaScript API,[^(12)](footnotes.xhtml#fn_12)
    a collection of libraries that allows interacting with a local or remote Ethereum
    node using HTTP, IPC, or WebSocket.
  prefs: []
  type: TYPE_NORMAL
- en: It is very common for the traditional Web applications to access various resources
    on the Internet, using various protocols, for example, HTTP, HTTPS, WebSockets,
    WebRTC, RPC, and others. On the other hand, the smart contract execution environment
    limits the scope of the smart contract execution to the DL network. A smart contract
    can only call other smart contracts in the network but cannot access resources
    out of the DL.
  prefs: []
  type: TYPE_NORMAL
- en: The smart contract methods can be accessed in two ways by the DL network participants.
    Suppose an off-chain application or another smart contract requires, for example,
    a simple read of a smart contract parameter. In that case, this is done with a
    local invocation (occurring only in the local DL node) of the smart contract method.
    On the other hand, when a DL network participant needs to modify some state in
    the smart contract, the call must be initialized through a transaction sent to
    the smart contract address. This transaction can include a cryptocurrency for
    the smart contract and additional input parameters for the method call. Transactions
    have to be validated and included in the chain in the same way as non-smart contract
    transactions. Upon inclusion, the smart contract is executed, and the state (of
    the contract and the entire ledger) is updated accordingly. The smart contract’s
    bytecode, of course, remains unchanged. Any code changes of the deployed bytecode
    are impossible due to the DL’s immutable nature.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 2.7](#b_9783110681130-002_fig_007) shows a class diagram of a simple
    single-contract solution, which provides two methods, the promoteToAdmin, and
    poeCreate. The first expects a parameter hopefulAdmin with a value corresponding
    to the Ethereum address of the new administrator. The poeCreate method receives
    a hash value and contextual data about this hash. These methods are executed with
    the given parameters. If encoded conditions are met, the poeCreate method emits
    an event called poeCreated, which is intercepted by all the nodes in the blockchain
    network, and notifications are given to the off-chain applications that are subscribed
    to these events. The hash in the poeCreated event is indexed, so subscribers can
    request to be notified only of poeCreated events with a specific hash. The smart
    contract also includes a number variable called eventCount, which is publicly
    readable.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../graphic/converted/b_9783110681130-002_fig_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Fig. 2.7: Class diagram of a simple single-contract smart contract solution.'
  prefs: []
  type: TYPE_NORMAL
- en: 2.4.3 Smart contract programming
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most of the DL smart contract execution environments, including Ethereum, Hashgraph,
    and BTC, follow state machine replication on the *order-execute* principle. The
    consensus mechanism of these DLTs assures a clear order of the smart contract-invoking
    transactions before their execution. The ordered transactions are then executed
    sequentially on all peers, reflecting in the common change of the ledger/smart
    contract state. For this to happen, the execution of smart contracts (processing
    of all transactions address to a smart contract by the smart contract’s code)
    needs to be deterministic.
  prefs: []
  type: TYPE_NORMAL
- en: The requirement for deterministic execution places a strong limitation on what
    a smart contract can do. For example, using date or time functions, generating
    random values, or retrieving data from off-chain resources (e.g., external API
    calls) prevents deterministic execution. It is, therefore, very common that these
    DLTs use special smart contract programming languages to enforce the determinism
    even at the level of programming language. Suppose the deterministic scripting
    language used by the VM is Turing-complete. In that case, this essentially means
    that the types of smart contracts that the developers can design are limited only
    by their programming skills and creativity.
  prefs: []
  type: TYPE_NORMAL
- en: However, not all DL smart contract execution environments follow the order-execute
    principle. Hyperledger applies a different transaction lifecycle and, therefore,
    different smart contract execution and validation principle. It is called execute-order-validate
    [33]. The name indicates that a smart contract call, invoked by a transaction
    destined to a smart contract address, is first executed. The transactions to smart
    contracts can therefore be executed in any order, possibly, in parallel. A transaction
    need not be executed by every node in the network. After a transaction is executed,
    endorsement policies define which nodes need to agree on the result of a transaction,
    and then it is added to the ledger. This is the phase where transaction ordering
    occurs. The transaction validation, which happens last, is separated from the
    execution. During validation, each node has an ordered list of already executed
    transactions and can check if any of them is invalid, for example, due to double-spending.
  prefs: []
  type: TYPE_NORMAL
- en: The execute-order-validate approach has several relevant benefits. These are
    increased performance (not every node executes every smart contract), smart contract
    code privacy (only the endorsement nodes need to know the smart contract code),
    and the possibility of using general-purpose programming languages for smart contract
    development.
  prefs: []
  type: TYPE_NORMAL
- en: 2.4.3.1 Languages
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Various programming languages are applied to develop smart contracts, depending
    on the VM in the selected network. Some VMs support diverse programming languages
    for smart contracts and others stick to one.
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum uses deterministic programming languages Solidity (prevalent) and Vyper
    for smart contracts. Solidity, the most popular language[^(13)](footnotes.xhtml#fn_13)
    on Ethereum, was inspired by C++, Python, and JavaScript, and Vyper is based on
    Python. One can build smart contracts in JavaScript, C++, or Python. Still, because
    of the order-execute constraints and contexts related to the EVM, it is easier
    to have a language specifically for the task.
  prefs: []
  type: TYPE_NORMAL
- en: EOS[^(14)](footnotes.xhtml#fn_14) blockchain network supports WebAssembly (WASM)
    for smart contract programming, despite being an order-execute DL, too. WASM is
    not deterministic, so it is up to the programmer not to use any non-deterministic
    input like the time of a day or random number generator.
  prefs: []
  type: TYPE_NORMAL
- en: Hyperledger Fabric is the first blockchain system that runs smart contracts
    written in general-purpose programming languages, such as Go, Java, Node.js. The
    smart contract code is executed in containers.
  prefs: []
  type: TYPE_NORMAL
- en: 2.4.3.2 Tools and libraries
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: At the beginning of the DApp era, only a basic set of tools with limited functionality
    was available for the developers. Most of the tools were related to Ethereum and
    Solidity – the cornerstones of the pioneering DLT for DApps. The development tools
    were mostly desktop or online code editors, with added Solidity code highlighting
    and syntax checking. Some were linked to the Solidity compiler, while others left
    the compilation to other tools. Debugging was manual, and there were no or only
    very basic security validations available.
  prefs: []
  type: TYPE_NORMAL
- en: With the maturing of DApp ecosystems, new tools and frameworks appeared more
    integrated and provided broader functional scope. These tools support the development,
    validation and testing, and deployment of smart contracts. We are now approaching
    the development environments with similar maturity as those for, for example,
    long-established Web application development.
  prefs: []
  type: TYPE_NORMAL
- en: For Ethereum, dedicated frameworks (Truffle) and integrated development environments
    (IDE) (e.g., Remix) exist. Popular multi-purpose development environments (e.g.,
    VS Code) support coding, compilation, and security validation of Solidity code,
    too. These tools and frameworks can be integrated with code validators (MythX)
    or emulators (Ganache) for preliminary testing in emulated blockchain networks.
    The same tools can be used for smart contract development for Hedera Hashgraph
    because it implements Ethereum’s EVM and uses the Solidity for smart contract
    programming. The EOS ecosystem, too, sustains a broad set of development and testing
    tools[^(15)](footnotes.xhtml#fn_15) for their smart contacts. Integrated with
    various tools required for EOS in a unified graphical application, EOS Studio,
    for example, provides a powerful and easy-to-use environment for DApp development.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides, Solidity has some inbuilt libraries, which enhance the security or
    implement some of the common functionality frequently used by many smart contract
    developers in a systematic and proven way. This speeds up the development process
    and enhances security. However, the application of external libraries might contradict
    the desired simplicity of the smart contract code and introduce possible new risks
    with additional code in the library. Some of the libraries are:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Modular network: includes many modular libraries like ArrayUtils, Token, CrowdSale,
    Vesting, StringUtils, LinkedList, Wallet, and so on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OpenZeppelin:[^(16)](footnotes.xhtml#fn_16) provides role-based access control
    (library called Roles) and secure mathematical library (SafeMath) as well as other
    security-related libraries for smart contract programming for Ethereum (MerkleProof,
    ECDSA, Address, SafeERC20, Arrays)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'DApp-bin: was created by Ethereum and included libraries like DoublyLinkedList,
    StringUtils, IterableMapping, and so on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Various levels of code testing are essential for efficient and secure (see [Section
    2.4.4](#b_9783110681130-002_s_002_s_004_s_004) for more details) smart contracts.
    Several projects aim to formal verification of smart contracts, and a comprehensive
    list is being maintained [34]. Some of these tools operate at the source code
    level (i.e., the Solidity), whereas others operate at the compiled bytecode level.
    MythX[^(17)](footnotes.xhtml#fn_17) is a cloud-based smart contract security service.
    It performs security analysis remotely, accepting jobs and returning results via
    an API. It currently detects most weaknesses found in the SWC Registry. It, thus,
    covers assertions and property checking, byte-code safety, authorization controls,
    control flow, the correctness of ERC standard implementations, and various coding
    best practices for Solidity [35]. The analysis types include symbolic analysis,
    fuzzing (bytecode), Solidity code analysis, taint analysis, and static analysis.
    The MythX API has been integrated into many development frameworks, including
    Brownie, Truffle, Remix, and VC Studio. OYENTE [36] is another tool to analyze
    the Ethereum smart contracts code, based on symbolic execution. OYENTE takes two
    inputs, the Ethereum smart contract bytecode and Ethereum global state. It checks
    a contract against several known software weaknesses. Although the majority of
    the testing tools aim toward Ethereum and Solidity, other DL technology ecosystems
    address this issue, too. Chaincode scanner [37] is a static security checker for
    Hyperledger Fabric smart contracts. It takes a chaincode written in Go as input
    and checks it for nine vulnerability patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Other tools can facilitate the development and monitoring of the deployed smart
    contracts. Chain and block explorers are presented in [Section 2.6.4](#b_9783110681130-002_s_002_s_006_s_004).
    A valuable tool is the Hyperledger Caliper,[^(18)](footnotes.xhtml#fn_18) which
    is a part of the Hyperledger endeavors. The Hyperledger Caliper is a benchmarking
    tool, which allows users to measure the performance of a blockchain implementation
    with a set of predefined use cases. The Hyperledger Caliper produces reports containing
    several performance indicators, including resource utilization, transaction latency,
    and transactions per second (tps). Besides several Hyperledger DLTs, the Caliper
    benchmarks Ethereum-based networks, too.
  prefs: []
  type: TYPE_NORMAL
- en: The Hyperledger DL ecosystem (see [Section 2.7.1.2](#b_9783110681130-002_s_002_s_007_s_001_s_002))
    develops and promotes several business blockchain libraries. For example, Hyperledger
    Ursa[^(19)](footnotes.xhtml#fn_19) is a shared cryptographic library, which enables
    implementations to avoid duplicating other cryptographic work and increases security
    in the process.
  prefs: []
  type: TYPE_NORMAL
- en: 2.4.4 Smart contract security
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Smart contract security and the security of the related DApps are parts of a
    broader cybersecurity landscape ([Fig. 2.8](#b_9783110681130-002_fig_008)). They,
    therefore, share many known risks and vulnerabilities commonly found in other
    ICT systems and applications, too. Such common attack vectors are, for instance,
    attacks on the application clients, attacks on user-wallet credentials through
    phishing, dictionary attacks, or by exploiting bugs in hardware wallets. The same
    holds for the exploits of digital signatures, hash functions, or address vulnerabilities.
    Distributed denial of service (DDoS) attacks can target the DLT and DApp infrastructure,
    for example, the off-chain application parts or the auxiliary services, such as
    crypto exchanges and mining pools.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../graphic/converted/b_9783110681130-002_fig_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Fig. 2.8: Smart contract security and cybersecurity.'
  prefs: []
  type: TYPE_NORMAL
- en: However, in addition to the common cyber risks and vulnerabilities that affect
    DApps due to the decentralized and distributed nature of DLT, unknown, specific
    vulnerabilities and risks appear or become severely augmented. Possible attacks
    and new attack vectors comprise the governance and operation of the DL network,
    mining and consensus, tampering of transactions, and attacks on smart contracts.
    Various vectors are frequently combined into one attack area to gain control over
    the network, a part of the network, or individual nodes and then exploit this
    control to manipulate transactions. Some of the attack vectors might be extremely
    difficult and costly to execute. In truly decentralized DL networks, they might
    be practically almost infeasible. However, in more centralized (private) networks,
    the risks remain real. Many of the attack vectors are protocol- and implementation-specific
    and are not present in every variant of DLT, so the actual implementation of a
    DL network may mitigate or prevent some of the risks with, for instance, high
    decentralization, authorized nodes instead of anonymous ones, consensus mechanisms
    other than traditional PoW, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: While some of the defense mechanisms and mitigation techniques are already available
    in other ICT domains and readily available in modern software development lifecycles,
    others need to be newly developed or adapted to the DLT. This is not surprising.
    Most of the DLT platforms, tools, and smart contract programming languages are
    still in their infancy, often, fast-evolving and constantly changing the features.
    Hence, design flaws might exist in the DL platforms or smart contract languages.
    Along with DLT ecosystems, security approaches mature, too.
  prefs: []
  type: TYPE_NORMAL
- en: The immutable nature of a previously deployed smart contract code exposes vulnerabilities
    that could be easily mitigated in traditional software systems but can present
    severe risks in decentralized applications. As with any source code, even a thoroughly
    tested and validated smart contract might have bugs. Design flaws may exist in
    blockchain platforms or smart contract languages. Common Software Security Weaknesses
    (CWE) [38] may be amplified on blockchain platforms and in the related smart contract
    security [39]. Such weaknesses include improper behavioral workflow, access control
    or initialization, incorrect calculation and insufficiently random values, the
    inclusion of untrusted external functionalities (e.g., external libraries, smart
    contracts deployed by others), and improper exception handling and cryptographic
    understanding.
  prefs: []
  type: TYPE_NORMAL
- en: Key smart contract vulnerabilities stem from logical flows, bugs in the smart
    contract code, and under-optimized code patterns. Logical flows in the implementation
    of the contract, where, for example, a smart contract does not refund the initial
    deposit, lack of cryptography for user inputs to ensure fairness, or incentive
    misalignments [40], can be deliberate or caused by a misunderstanding of distributed
    ledger properties. In public DL networks, where cryptocurrencies and miner awards
    are part of the DApp execution, there is a risk of under-optimized smart contract
    code patterns that lead to unnecessary gas consumption [41]. Their research states
    that the two main reasons for this are useless code-related and loop-related patterns.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Ethereum, smart contract vulnerabilities arise from the Solidity language,
    the Ethereum or EVM blockchain platform, and a misunderstanding of common practices.
    In Hyperledger Fabric chaincode, vulnerabilities arise from almost identical points:
    the Go language, the blockchain platform, and a misunderstanding of common practices.'
  prefs: []
  type: TYPE_NORMAL
- en: 2.4.4.1 Smart contract weakness classification
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Smart Contract Weakness Classification and Test Cases Registry (SWC Registry)
    [39] is a comprehensive list of key security flaws in the Solidity smart contract
    code. It provides a checklist for smart contract programmers and many of the smart
    contract vulnerability detection tools. Possible vulnerabilities are labeled as
    SWC *x*, where *x* is the vulnerability index, for example, SWC 107.
  prefs: []
  type: TYPE_NORMAL
- en: Some common Solidity smart contract vulnerabilities include transaction-ordering
    dependence, timestamp dependence, mishandled exceptions, and reentrancy. Transaction-ordering
    dependence (SWC114) can be a problem if users have no control over the order of
    transaction execution. The order is up to miners. If there is more than one transaction
    that invoked the same contract, the order of those transactions can affect the
    new state of the blockchain. Timestamp dependence (SWC116) is related to smart
    contracts and includes conditions that are triggered by the block timestamp. Block
    timestamps are set by miners based on their local system time and can be unreliable
    or manipulated by an adversary. Mishandled exceptions (SWC104) target the contract
    that calls another contract. If any exception occurs in the called contract, it
    terminates and returns false, but it may not notify the caller contract. Reentrancy
    vulnerability (SWC107) is present when a contract calls another contract, and
    the current contract execution waits until the called contract finishes. This
    provides an opportunity for the adversary to exploit the intermediary state of
    the caller contract and call its methods, several times. Authorization through
    tx.origin (SWC115) could make a contract vulnerable if an authorized account calls
    into a malicious contract. A call could be made to the vulnerable contract that
    passes the authorization check since tx.origin returns the original sender of
    the transaction, the authorized account.
  prefs: []
  type: TYPE_NORMAL
- en: 2.4.4.2 Steps to securing smart contracts
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We can take two types of security measures to secure smart contracts – passive
    and active smart contract security. Both subsets are not exclusive or replacing
    one another but have to be seen as two independent cornerstones of smart contract
    security. Passive security measures entail smart contract architectures, software
    engineering techniques specific to the smart contract environment, or code reviews
    and verification (see [Section 2.4.3.2](#b_9783110681130-002_s_002_s_004_s_003_s_002)
    for tools and libraries for smart contract programming). Active measures occur
    during smart contract execution and refer to smart contract and method access
    control, active monitoring of the incoming smart contract transactions, and authorizing
    their actions.
  prefs: []
  type: TYPE_NORMAL
- en: 2.4.4.2.1 Updating and upgrading
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As discussed at the beginning of [Section 2.4.4](#b_9783110681130-002_s_002_s_004_s_004),
    the immutable nature of a previously deployed smart contract prevents the simple
    replacement of the existing code with an updated or upgraded version. Of course,
    we can always deploy the new version to the blockchain network. However, the original
    smart contract has to be rendered unusable, usually by disabling any transactions
    addressed to it. Consensys highlights several Ethereum Smart Contract Best Practices.
    To assure an effective upgrade path for bug fixes and improvements, they advise
    mechanisms to pause, freeze, or delay smart contract actions and mechanisms to
    migrate and transfer data and funds to the updated version of the smart contract.
    Two software engineering techniques[^(20)](footnotes.xhtml#fn_20) can be applied
    in case of an emergency, if relevant flaws are found after the deployment. Circuit
    Breakers pause or stop smart contract execution if certain conditions are met.
    They can be useful when new errors are discovered after the deployment. Most contract
    functionality may be therefore suspended, and the only action now active, is a
    withdrawal. We can either give certain trusted parties the ability to trigger
    the circuit breaker or have programmatic rules that automatically trigger certain
    breakers when certain conditions are met. Speed bumps delay or slow down contract
    actions, so that if malicious activities occur, there is time to recover.
  prefs: []
  type: TYPE_NORMAL
- en: 2.4.4.2.2 Modularization
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In modern software engineering, source code is usually split into modules. These
    modules are easier to handle and navigate than all of the lines of code contained
    in a single file. Modularization makes the management of software easier, including
    updates and upgrades. The code is reusable, and functions are separated. The bigger
    the code base gets, the more sense it makes to have a multi-contract architecture
    and the greater the security benefits to the service become.
  prefs: []
  type: TYPE_NORMAL
- en: However, modularization is not a common practice in smart contract development.
    Smart contract usage patterns in a large set of Ethereum-based DApps indicate
    that about 75% of Ethereum-based DApps apply very simple single contract architecture,
    meaning that the on-chain application logic consists of only one smart contract.
    The remaining DApps are multi-contract, on average comprising three smart contracts.
    Therefore, the efficient reuse is very limited, and the smart contract source
    code is mostly simply duplicated among different implementations. Single contract
    solutions may meet the functional demands of the users but often result in unmanageable
    decentralized applications when the requirements for updates arise.
  prefs: []
  type: TYPE_NORMAL
- en: The Diamond approach to upgradeable modular contracts has been proposed as the
    Ethereum Improvement Proposal (EIP) 2535.[^(21)](footnotes.xhtml#fn_21) This draft
    document proposes a proxy contract that supports using multiple logic contracts.
    These delegate contracts are called facets, and each facet supplies one or more
    functions. A dedicated function enables adding, replacing, or removing functions.
    Events are emitted upon changes in diamond functions, and a user can verify what
    version of the function is called. With this design approach, one can develop
    and incrementally improve the smart contract logic of a DApp over time. However,
    the design of smart contracts ownership, authentication, and authorization is
    not a part of this draft.
  prefs: []
  type: TYPE_NORMAL
- en: Modular contracts can be upgraded in a controlled manner. Several approaches
    can be taken, or auxiliary services can be used to do this, for example, a registry
    contract, delegate calls, or Ethereum Name Service (see [Section 2.6.3](#b_9783110681130-002_s_002_s_006_s_003)
    for name services).
  prefs: []
  type: TYPE_NORMAL
- en: 2.4.4.2.3 Example of modularized smart contract architecture for DApps
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Modular smart contract architecture requires a set of smart contracts to work
    together as the on-chain part of a decentralized application. Therefore, the security
    and access policy for the contract methods has to be carefully designed and planned.
    It makes sense to have a dedicated smart contract that handles access control
    and interaction permissions for all smart contracts in a decentralized application.
    This means that all security is centralized and offers a better overview than
    having access and security policies defined in every smart contract in the multi-contract
    architecture.
  prefs: []
  type: TYPE_NORMAL
- en: We can now separate the service-specific and service-agnostic functions into
    separate modules. Service-agnostic modules provide key platform functionalities
    required in any multi-contract solution. A directory module can serve as the single
    access point, that is, the only interface for the external users. It automates
    the dissemination of the addresses in other smart contract modules. If one of
    the contracts in the deployed system is upgraded and replaced, the directory reflects
    this change and transparently directs the remaining contracts to the updated address.
    An administration module provides common access control for all the smart contracts
    and methods in the solution.
  prefs: []
  type: TYPE_NORMAL
- en: Service-specific modules depend on the DApp objective and provide unique functions
    for service operation, for example, in the management of distributed energy resources
    (see Section 4.3.3.1) or car park reservation (see Section 4.2.2), or decentralized
    collaboration between robots (see Section 3.6).
  prefs: []
  type: TYPE_NORMAL
- en: Auxiliary modules provide additional functions relevant to service provisioning.
    However, their functions, such as loyalty tokens, asset tokenization, escrow service,
    or value collection, are common and relevant for other application verticals,
    too. Therefore, auxiliary modules can be provided system-wide and reused in various
    decentralized applications.
  prefs: []
  type: TYPE_NORMAL
- en: Modular architecture with a separate access administration module allows us
    the definition of various tenants. Although they all interact with multiple modules
    using the interface smart contract, they are only allowed to call some methods,
    while the other methods are restricted. Typically, the tenants in a decentralized
    application would be, for example, application owners, administrators, service
    providers, and service users.
  prefs: []
  type: TYPE_NORMAL
- en: 2.4.4.2.4 Secure multi-contract interactions
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The Diamond standard (see [Section 2.4.4.2.1](#b_9783110681130-002_s_002_s_004_s_004_s_002_s_001))
    proposes an upgradeable multi smart contract environment, but it does not include
    any security mechanics that would provide secure and reliable inter-smart contract
    interactions. We can extend this basic modularization with secure smart contract
    tunnels (SCT) [42]. Smart contract tunneling introduces twofold access control:
    per module (only registered modules can interact) and per user. The administrator
    tenant sets up the tunnels in the directory and administration modules. With the
    directory module, we can always assure that the method call was passed through
    an authorized module and that it originated from an authorized smart contract
    account. We use both the tx.origin value to verify that a transaction originated
    from an authorized source and msg.sender value to verify that the transaction
    was forwarded from an authorized source.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 2.9](#b_9783110681130-002_fig_009) depicts a tunnel set up between
    the interface contract and subsequent target smart contract. Only smart contracts,
    which are properly registered in the directory and authorized in the administration
    module, can access the target smart contract in our multi-contract solution. In
    addition, the transaction origin address in both interface and target smart contract
    can be checked to limit the access to the particular method, according to the
    tenant roles of a specific user. The unregistered smart contract cannot send transactions
    to the target.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../graphic/converted/b_9783110681130-002_fig_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Fig. 2.9: Smart contract tunneling for smart contract module access control.'
  prefs: []
  type: TYPE_NORMAL
- en: 2.5 Off-chain applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the decentralized application triplet (see [Section 2.2](#b_9783110681130-002_s_002_s_002)),
    DL network nodes assure all the blockchain-specific protocols for network operation
    and functions for interaction with other nodes in the network and on-chain smart
    contract execution. The Web, mobile, server-side, or embedded off-chain applications
    need to interface with these nodes to utilize the blockchain-specific features
    and services provided by the DL network.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, some of the network nodes expose blockchain APIs – usually JSON-RPC
    or REST interfaces – for software applications to interact with the DL network.
    We can enable the API for blockchain service access as an option on our node in
    a public permissionless network. Alternatively, we can rely on third-party APIs
    for public DL networks, provided as a service (see [Section 2.7.2.2](#b_9783110681130-002_s_002_s_007_s_002_s_002))
    for more efficient productization of decentralized applications. In permissioned
    networks adding nodes might be more restricted and limited to authorized users.
    The restrictions are motivated by network security and ledger data privacy, with
    some DL networks not allowing any nodes to be added at all. In these cases, the
    APIs are the only mechanism for external entities to participate or interact with
    the network. For example, to access Hedera services (see [Section 2.7.1.3](#b_9783110681130-002_s_002_s_007_s_001_s_003)
    and Section 1.4.), mirror nodes are used. One cannot run a mirror node in Hedera,
    but Hedera and community mirror nodes are available, with APIs for Hedera services.
  prefs: []
  type: TYPE_NORMAL
- en: The API endpoints in public networks commonly impose no access control to the
    off-chain applications. Lack of access control might seem surprising if we compare
    it to the API access in many other Web-based applications. Nevertheless, since
    the ledger is shared and available to all involved parties, there is no need to
    protect access to it. Blockchain account-related operations, which can lead to
    severe security vulnerabilities, are performed in the off-chain application parts.
    If we establish some access control for the node API, it is mainly to protect
    the node’s computing resources.
  prefs: []
  type: TYPE_NORMAL
- en: 2.5.1 Off-chain application examples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Off-chain applications utilize the established Web, mobile, server-side, or
    embedded applications technologies to provide user and machine interfaces for
    the DApps.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from the node APIs, blockchain ecosystems usually provide off-chain client
    libraries for different programming languages. These convenience libraries abstract
    much of the complexity of interacting with blockchain node APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Despite a remarkable resemblance between traditional and blockchain-enabled
    Web user interfaces, the blockchain backend introduces several usability problems.
    They are mostly related to the BC transaction latency. Therefore, users cannot
    always count on refresh rates and response times expected in traditional Web applications.
    Consequently, it is a good user interface design principle to notify the user
    when we await a longer response than expected due to the DL network interaction.
    For example, we can temporarily redirect a user to chain explorer (see [Section
    2.6.4](#b_9783110681130-002_s_002_s_006_s_004)) for live tracking of his transactions
    during that period.
  prefs: []
  type: TYPE_NORMAL
- en: Another blockchain backend effect on off-chain Web, server, or embedded applications
    arises from blockchain node API queries. We cannot form the node API requests
    as efficiently as in, for example, relational databases. Therefore, the number
    of requests to a remote API might become substantial, if the client application
    design does not consider this possibility. This can result in increased node-resource
    consumption and unnecessary communication load between the client-side application
    and the API. The latter might be especially challenging in communication-constrained
    embedded IoT blockchain applications.
  prefs: []
  type: TYPE_NORMAL
- en: 2.5.1.1 Client-side web applications
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Client-side Web applications run in browsers. Apart from the execution of client-side
    application logic, the browser must include a key wallet. A wallet enables the
    management of blockchain keys and identifications. It can be an integral part
    of a browser (e.g., Brave[^(22)](footnotes.xhtml#fn_22)) or a browser extension.
    Metamask[^(23)](footnotes.xhtml#fn_23) is a popular wallet extension for Ethereum-based
    networks. [Figure 2.10](#b_9783110681130-002_fig_010) shows the Metamask menu,
    where we can toggle between available Ethereum networks, including the Mainnet
    and various public test networks. With Metamask, we can also attach our browser
    to an Ethereum node running on the local computer or specify a URL to an arbitrary
    JSON-RPC node API. In this way, we can access, for example, private or consortium
    networks with the Ethereum DLT.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../graphic/converted/b_9783110681130-002_fig_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Fig. 2.10: Metamask wallet extension in a Web browser.'
  prefs: []
  type: TYPE_NORMAL
- en: A common convention in the Ethereum Web application ecosystem is for key management
    software to expose their API via a JavaScript object in the Web page. The EIP
    1193[^(24)](footnotes.xhtml#fn_24) formalizes an Ethereum Provider API to promote
    wallet interoperability. The API is designed to be minimal, event-driven, and
    agnostic of connectivity and RPC protocols. Its functionality can be extended
    by defining new RPC methods and message event types.
  prefs: []
  type: TYPE_NORMAL
- en: In the client-side application, developers apply client libraries for BC node
    API interactions, for example, Web3.js[^(25)](footnotes.xhtml#fn_25) for Ethereum
    Web applications, and create their application-specific programming logic. Web3.js
    is a collection of libraries that allows us to interact with a local or remote
    Ethereum node using HTTP, IPC, or WebSocket.
  prefs: []
  type: TYPE_NORMAL
- en: In this way, we can use all the available Web-interface technologies (HTML5,
    CSS, and JavaScript) or frontend frameworks to create rich, interactive, and modern
    Web user interfaces that utilize blockchain features. These user interfaces interact
    with live blockchain networks.
  prefs: []
  type: TYPE_NORMAL
- en: 2.5.1.2 Web-server or embedded application parts
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We must arrange the blockchain key management differently, if the software running
    in a server or an IoT device needs to interact with a blockchain node API. No
    human will toggle among the available blockchain networks or provide the wallet-access
    authorization credentials. Still, we might need a key store in such an application.
    Still, we usually set the DL network and the account information only during the
    initial configuration of the server-side application.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, the interactions with the BC node API are very similar to
    the ones in client-side Web applications. If we develop, for example, a Node.js
    backend application or IoT device software, we include the same Web3.js library
    (see [Section 2.5.1.1](#b_9783110681130-002_s_002_s_005_s_001_s_001)) for Ethereum
    Web applications. Off-chain application development for Ethereum is not limited
    to JavaScript. Web3.py[^(26)](footnotes.xhtml#fn_26) is a Python library for interacting
    with Ethereum. Originally, it was derived from Web3.js but has since evolved toward
    the needs of Python developers.
  prefs: []
  type: TYPE_NORMAL
- en: 2.5.1.3 Mobile applications
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A very similar approach is taken in mobile platforms, too. There are mobile
    Web browsers and mobile browser wallet plug-ins available. Metamask, for example,
    runs on Android and iOS, too. This facilitates access to the same Web-based blockchain
    application as for the desktop browsers.
  prefs: []
  type: TYPE_NORMAL
- en: Web3j.io[^(27)](footnotes.xhtml#fn_27) is a lightweight, reactive, type-safe
    library for Java, Android, Kotlin, and Scala, if we develop mobile applications
    that do not rely on browser functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 2.5.2 Distributed ledger node APIs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Blockchain node APIs range from pure REST APIs (e.g., Hyperledger Fabric) to
    JSON-RPC (e.g., Ethereum) with the usual connectivity methods including HTTP,
    WebSocket, and IPC. Not all of them are necessarily present in all DLTs or even
    in different node implementations for the same DL network. Approaches also differ
    in the set of features provided through the API. But they commonly offer information
    about the node client, blockchain network, blocks, and transactions, provide account
    management, and enable the creation and submission of new transactions.
  prefs: []
  type: TYPE_NORMAL
- en: 2.5.2.1 Ethereum JSON-RPC API
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Ethereum JSON-RPC API[^(28)](footnotes.xhtml#fn_28) is the API for Ethereum
    node implementations. Not all the implementations assure the same feature set.
    In [Tab. 2.4](#b_9783110681130-002_tab_004), we provide a brief comparison of
    connectivity methods in some of the dominant nodes. The combination of JSON-RPC
    and HTTP is common for all of them. IPC and WebSockets are supported only in some
    cases. Suppose we design a decentralized application, which specifically relies
    on, for example, a WebSocket connection, we must account for the possibility that
    not all network nodes will be configured for DL network access or that adaptations
    will be needed to migrate from one blockchain network to another.
  prefs: []
  type: TYPE_NORMAL
- en: Tab. 2.4:JSON-RPC support in various Ethereum node implementations.
  prefs: []
  type: TYPE_NORMAL
- en: '|  | Cpp-ETH | Go-ETH | Py-ETH | Parity | HL Besu |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **JSON-RPC 1.0** | + |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| **JSON-RPC 2.0** | + | + | + | + | + |'
  prefs: []
  type: TYPE_TB
- en: '| **HTTP** | + | + | + | + | + |'
  prefs: []
  type: TYPE_TB
- en: '| **IPC** | + | + |  | + |  |'
  prefs: []
  type: TYPE_TB
- en: '| **WebSocket** |  | + |  | + | + |'
  prefs: []
  type: TYPE_TB
- en: Ethereum JSON-RPC API has a single endpoint, for example, [http://localhost:8545](http://localhost:8545).
    The API method, along with the corresponding parameters, is embedded in a JSON
    structure submitted to this endpoint. The Ethereum JSON-RPC API enables selecting
    features and gives detailed information about network status, including number
    and details about the connected peers. Account management returns a list of addresses
    owned by the client. These accounts must be enabled when we start the node. The
    API provides detailed information about ledger synchronization, including block
    and transaction details. We can create, sign and send new transactions to the
    network. We could set and manage event filters used to track interactions with
    smart contracts in the network through the API, or manage the mining if it was
    enabled in the node.
  prefs: []
  type: TYPE_NORMAL
- en: 2.5.2.2 Hyperledger Fabric REST API
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Hyperledger Fabric nodes facilitate a RESTful API service. The CoreAPI[^(29)](footnotes.xhtml#fn_29)
    is composed of several endpoints, which reflect the APIs functionality. We select
    the appropriate HTTP method to choose between creating, reading, and deleting
    the selected resources.
  prefs: []
  type: TYPE_NORMAL
- en: The root endpoints are /block, /chain, /chaincode, /network, /registrar, and/transactions.
    We use /block API to retrieve the contents of various blocks from the blockchain
    and the /chain API for the current state of the network. The /chaincode endpoint
    is used to deploy, invoke, and query a target chaincode, that is, the Hyperledger
    Fabric smart contracts. It implements the JSON RPC 2.0 specification and must
    have the required fields supplied within the payload. The /network gives information
    about the network of peer nodes comprising the blockchain network. As the HLF
    networks are permissioned, the /registrar manages end-user registrations. We can
    use the /transactions/{UUID} endpoint to retrieve an individual transaction matching
    the UUID from the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: 2.5.2.3 Hyperledger Sawtooth REST API
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Hyperledger Sawtooth API[^(30)](footnotes.xhtml#fn_30) also relies on the proven
    RESTful service approach. It systematically utilizes HTTP status codes to provide
    detailed feedback about the execution of a particular API call.
  prefs: []
  type: TYPE_NORMAL
- en: 2.6 Distributed and support services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Several services extend the functions of the core DLT and its on-chain logic
    in smart contracts. These services are not mandatory for DL network and DApp operation
    but make it easier, provide more control, and facilitate architectural refinements,
    welcome by the users.
  prefs: []
  type: TYPE_NORMAL
- en: Decentralized blockchain storage facilitates large quantities of data that would
    be unsuitable or impractical for the storage limitations of a regular blockchain.
    Name services add an additional layer of addressing or naming in DLT. They abstract
    the immutable DL network addresses and enable user-friendly naming. These names
    can be remapped to new DL network addresses if, for example, a smart contract
    address has changed. For smart contracts to interact with off-chain external data
    sources, special trusted gateways called oracles are needed. Moreover, chain explorers
    help us examine and analyze the content of the distributed ledger in a live blockchain
    network. They aggregate and display data from network nodes in a human-readable
    and user-friendly way.
  prefs: []
  type: TYPE_NORMAL
- en: 2.6.1 DL-based storage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The core application of blockchain technologies, a distributed ledger, is just
    distributed, safe, and trustworthy data storage. As we discussed, this has many
    different uses in a variety of applications. However, many other applications
    require bulk data storage or file storage. This data cannot be written directly
    to the blockchain because it would greatly inflate the size of the ledger itself,
    hurting the performance of the chain in the long term.
  prefs: []
  type: TYPE_NORMAL
- en: There are several distributed blockchain-based storage solutions available,
    each with its characteristics [43]. Some core concepts are shared between them.
    These concepts are storage methods, replication, and incentives for hosts. Data
    is stored in a very similar way. Each file is split up into small pieces called
    shards. Each shard is encrypted before being stored on a machine that is part
    of the storage network (not the actual blockchain network). Only the locations
    and hashes of these shards are then stored on the blockchain network. Having relatively
    small and uniform pieces of data also helps improve storage and transmission efficiency.
    The machines that these shards are stored on eventually have many shards of data
    of identical size.
  prefs: []
  type: TYPE_NORMAL
- en: Another shared concept is data replication. The data needs to be protected in
    the case of network failures. This means all shards need to be replicated across
    several machines. The exact number of replicas varies, but 3 is, generally, the
    minimum used. Since the shards do not have an easily identifiable connection between
    them, there must be a mechanism to ensure that the data is sufficiently replicated
    across the network.
  prefs: []
  type: TYPE_NORMAL
- en: In traditional cloud storage infrastructure, files are stored with a company
    that can charge for the services provided. Public distributed systems are composed
    of many different small hosts and have no single entity to carry out actions like
    issuing invoices. Therefore, each distributed data storage system needs to have
    a way of rewarding the hosts of files. This varies from technology to technology,
    but some examples reward the owners with tokens or cryptocurrency that have value
    or give them more power to vote on the system.
  prefs: []
  type: TYPE_NORMAL
- en: Swarm[^(31)](footnotes.xhtml#fn_31) is Ethereum’s answer to blockchain-based
    storage and is designed to work in the Web3 ecosystem. Shards (called chunks in
    Swarm) of files are stored across multiple Swarm nodes, with a manifest stored
    in the main Ethereum blockchain network. Swarm nodes are just Ethereum nodes with
    an extra enabled mode of operation. They keep shards of files and make sure the
    shards are securely stored and accessible.
  prefs: []
  type: TYPE_NORMAL
- en: Files in the system can never actually be changed or deleted by the user. Instead,
    the user uploads a new file and changes the ENS reference to point to the new
    file. Swarm uses Ethereum’s cryptocurrency to charge users for storage and reward
    hosts.
  prefs: []
  type: TYPE_NORMAL
- en: IPFS[^(32)](footnotes.xhtml#fn_32) or Interplanetary File System is a more general
    distributed file system. It can be used together with various blockchain networks
    or can be even standalone. To access IPFS, a user must install an IPFS client.
    Once installed, users and applications can interact with IPFS with HTTP requests
    sent to this client. Protocol Labs, the organization behind IPFS, is also working
    on Filecoin, designed to be the incentivization layer, providing nodes with an
    economic incentive to host data reliably.
  prefs: []
  type: TYPE_NORMAL
- en: Storj[^(33)](footnotes.xhtml#fn_33) is designed to look and perform like object
    storage from traditional cloud providers, but with a decentralized backend. Applications
    generally interact with it via its S3-compatible API. It uses its blockchain-based
    system with STORJ tokens as an incentivization method.
  prefs: []
  type: TYPE_NORMAL
- en: 2.6.2 Oracles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The deterministic smart contract code is executed in a blockchain virtual machine.
    The execution is isolated from external, real-world environments, and the contract
    state is maintained and determined by actors inside the blockchain systems [44].
  prefs: []
  type: TYPE_NORMAL
- en: Despite the decentralized and trustless architectures of the blockchain systems,
    smart contracts on their own cannot access data from the external world. Oracles
    are needed to integrate smart contracts with the real world, if the non-deterministic
    smart contract code requires external information to make decisions. The real
    world, in this case, implies external software, hardware, or human actors and
    inputs they are providing to be used in the on-chain application parts. Software
    resources can be, for example, Web APIs from a weather data provider or real-time
    or historic price-pairs for financial applications. Hardware resources could be
    an IoT sensor device, contributing sensory inputs, or physical device identifiers,
    for example, RFID tag values, for a supply chain or a manufacturing management
    DApp. Human actors can provide inputs in the form of an answer to questions, their
    voting decisions, and the like.
  prefs: []
  type: TYPE_NORMAL
- en: Oracles collect and provide data feeds and input to smart contracts. On the
    blockchain, oracles are represented by smart contracts that serve data requests
    from other smart contracts. Oracles assure data attestation for these diverse
    off-chain sources and bring external data into the blockchain system in a trusted,
    verifiable way.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 2.11](#b_9783110681130-002_fig_011) depicts the high-level oracle architecture.
    Decentralized application (see [Section 2.2](#b_9783110681130-002_s_002_s_002))
    comprises a blockchain network with a smart contract execution environment, blockchain-aware
    user interfaces, and DApp smart contracts. Oracle is an intermediary between the
    smart contract environment and external resources. It can request data from external
    sources, receive external data feeds, or keep historical records data values.
    It assures the validity of these data and serves it to the DApp smart contracts
    when needed.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../graphic/converted/b_9783110681130-002_fig_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Fig. 2.11: High-level oracle architecture.'
  prefs: []
  type: TYPE_NORMAL
- en: There are two key trust models available to verify and validate the external
    data. In the centralized oracle trust model, only one node is used by the oracle
    solution to get data into a smart contract. Therefore, this node needs to be trusted.
    This model is appropriate for data in the external world that cannot be independently
    validated by multiple distributed parties, for instance, because the data has
    restricted access or is transient sensor data. Examples of centralized validations
    in oracles are, authenticity proofs (TLSNotary) for software oracles and trusted
    execution environments (TEE) for hardware oracles. The alternative is the decentralized
    oracle trust model. Here, the methods such as decentralized reputation, voting,
    or consensus-based decisions assure a common agreement about the external data
    source. Both models are used in practical oracle implementations to meet the distinguishing
    features of various external sources.
  prefs: []
  type: TYPE_NORMAL
- en: In any case, oracles are off-chain architecture components that could be points
    of failure in whole blockchain-based systems. Even if the DL network and the on-chain
    smart contract application are highly reliable and trustworthy, there is always
    a risk of oracles providing corrupt, malicious, or inaccurate data. Oracle security
    is, therefore, an emerging research area. Several oracle solutions have been proposed
    and implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Provable[^(34)](footnotes.xhtml#fn_34) is a blockchain agnostic oracle service
    for smart contracts and blockchain applications. It has been integrated with platforms
    like Ethereum, Rootstock, R3 Corda, Hyperledger Fabric, and EOS. It provides feeds
    to smart contracts from sources that include arbitrary URLs (any webpage or HTTP
    API endpoint), random results coming from external TEE compliant hardware, computation
    results from the Wolfram Alpha computational engine, or file content on the IPFS
    network. External data is delivered in a certified process, where authenticity
    proofs give transparency to the execution, and external audits verify that Provable
    code does what it should do.
  prefs: []
  type: TYPE_NORMAL
- en: To implement the Provable service, DApp developers and the users of such applications
    do not have to trust Provable. It acts as an untrusted intermediary. Optionally,
    a request to Provable can specify authenticity proof. Data providers do not have
    to modify their services to be compatible with blockchain protocols. Through Provable,
    smart contracts can access data from the existing Web sites or APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Town Crier[^(35)](footnotes.xhtml#fn_35) system leverages trusted hardware (Intel
    SGX) to provide a strong guarantee that data comes from an existing, trustworthy
    source. Town Crier (TC) obtains data from target websites specified in queries
    from application contracts and uses SGX to achieve its authenticity. If we trust
    SGX, data delivered by TC from a website to an application contract is guaranteed
    to be free from tampering. If we can trust the execution environment, we can trust
    that data delivered by TC from a website to an application smart contract is free
    from tampering.
  prefs: []
  type: TYPE_NORMAL
- en: Augur[^(36)](footnotes.xhtml#fn_36) is a P2P protocol for blockchain-based prediction
    markets, in which users receive payouts when they predict a winning outcome. The
    technology is predominantly used for betting applications. However, Augur acts
    as a decentralized oracle,[^(37)](footnotes.xhtml#fn_37) too. After the betting
    event has occurred, the outcome of the event is determined by Augur’s oracle.
    Results are determined by Augur’s oracle, which consists of profit-motivated reporters
    who report the actual, real-world outcome of the event. Reporters use a staking
    token (REP or reputation) to clarify disputes on outcomes of the prediction. Anyone
    who owns REP may participate in the reporting and disputing of outcomes. Users
    lock REP tokens in escrow, thereby staking them to assert the outcome of a particular
    created market. A specific incentive structure is incorporated in Augur’s platform
    that rewards reporting on correct outcomes and penalizes reporting on incorrect
    outcomes. This builds trust in the oracle data.
  prefs: []
  type: TYPE_NORMAL
- en: Chainlink[^(38)](footnotes.xhtml#fn_38) enables smart contracts on any blockchain
    to leverage extensive off-chain resources, such as tamperproof price data, verifiable
    randomness, external APIs, and much more. Various decentralized Chainlink oracle
    networks guarantee the authenticity of external input data and the resulting output
    events. The Chainlink network, for example, provides tamper-resistant and high-quality
    price feeds, furthering the growth of DeFi.
  prefs: []
  type: TYPE_NORMAL
- en: 2.6.3 Name services
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Given the immutable nature of blockchain technologies, accounts, data, and code
    cannot be changed or deleted. This means that whenever developers want to update
    a smart contract on a blockchain or a site hosted on Ethereum Swarm, they have
    to create a new one, which, of course, has a new unique identifier, that is, the
    Ethereum address. On the user side, the latest versions of a website or smart
    contract need to be always available at the same name, and this is preferred to
    be human-readable. Traditional systems use DNS to solve this issue, binding human-readable
    names to IP addresses and simplifying back-end migrations, load balancing, and
    geographical optimizations.
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum Name Service (ENS) fulfills many of the equivalent needs present in
    the Ethereum ecosystem. It binds human-readable names to hashes like Ethereum
    addresses and Swarm file identifiers. This is a key part of making DApps more
    accessible for regular users. ENS is a system of smart contracts, each responsible
    for its own subdomain. Several top-level smart contracts in the system (as for
    .eth and .test) that further smart contracts are registered as resolvers. A resolver
    could be registered with the .eth top-level smart contract with the name ethereum.eth,
    so any queries for it would first go to the .eth smart contract and then get directed
    to the ethereum.eth smart contract. This can be arbitrarily chained for ENS names
    like wallet.ethereum.eth. All interactions with the top-level domains in ENS are
    done strictly through the smart contracts and the methods they provide. This provides
    a high degree of transparency and trust. The cost of a .eth domain in 2021 was
    5 USD in ETH per year for 5-character names and longer, 160 USD for 4-character
    names, and 640 USD for 3-character names.
  prefs: []
  type: TYPE_NORMAL
- en: The process of registering a name on ENS takes five days and requires multiple
    time-sensitive transactions. When we want to register a name, a public auction
    is opened instead of the name simply being purchased. The name itself is hashed,
    so only people who know the name can participate in the auction. The auction lasts
    for 72 h and is followed by a reveal phase in which bidders must reveal their
    bids. If they do not, their funds are lost. The winner must pay an amount equivalent
    to the second-highest bid on top of their bid to get the name. Losers get their
    bids back.
  prefs: []
  type: TYPE_NORMAL
- en: The relation between the registry and resolvers is depicted in [Fig. 2.12](#b_9783110681130-002_fig_012).
    ENS can be queried[^(39)](footnotes.xhtml#fn_39) through the Etherscan chain explorer.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../graphic/converted/b_9783110681130-002_fig_012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Fig. 2.12: Ethereum Name System registry and resolvers.'
  prefs: []
  type: TYPE_NORMAL
- en: Apart from ENS, which names smart contracts, several DNS-like registrars are
    based on decentralized applications. These systems are completely independent
    of the traditional DNS and ICANN. Registration is managed directly by users, and
    name resolution is generally made through a browser extension. Unstoppable domains[^(40)](footnotes.xhtml#fn_40)
    manages the .crypto and .zil domains and are based on Ethereum technology. Namecoin[^(41)](footnotes.xhtml#fn_41)
    is a fork of BTC that focuses on storing and managing key-value pairs distributed
    securely. The key is a human-readable name and a value that is an address. It
    provides a DNS-like service for the .bit domain.
  prefs: []
  type: TYPE_NORMAL
- en: 2.6.4 Chain explorers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Chain explorers are tools used to examine and analyze the DL in a blockchain
    network. They aggregate and display data from network nodes in a human-readable
    and user-friendly way.
  prefs: []
  type: TYPE_NORMAL
- en: Given the application architecture considerations associated with chain explorers,
    these are generally Web applications with separate pages for viewing assets like
    accounts, transactions, and smart contracts. They also show important network
    statistics as well as an up-to-date feed of blocks and transactions.
  prefs: []
  type: TYPE_NORMAL
- en: Several similar tools are often available for the same network, mainly provided
    by a trusted first party, like the network operators, or by an unconnected third
    party, like an open-source project group. This is a great example of the openness
    of public blockchain-based DL networks.
  prefs: []
  type: TYPE_NORMAL
- en: Either way, they are useful as a second opinion into the state of the chain.
    The DApp will often provide links to these tools to give users a way to independently
    verify that the transactions did occur the way the application showed, providing
    an extra layer of trust. Since these DApps use a blockchain-based backend, chain
    explorers are, often, key in identifying and fixing issues.
  prefs: []
  type: TYPE_NORMAL
- en: Etherscan[^(42)](footnotes.xhtml#fn_42) is the most popular chain explorer for
    Ethereum. A snapshot of the user interface is given in [Fig. 2.13](#b_9783110681130-002_fig_013).
    A similar tool called Hyperledger Explorer[^(43)](footnotes.xhtml#fn_43) also
    exists for Hyperledger Fabric.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../graphic/converted/b_9783110681130-002_fig_013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Fig. 2.13: Etherscan – chain explorer for Ethereum.'
  prefs: []
  type: TYPE_NORMAL
- en: 2.7 Productization of DApps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When an enterprise considers adopting decentralized technologies in digitalization
    or aims to provide new DLT products or services to the market, selecting the underlying
    DLT platform is a strategic decision. During this adoption, investments in the
    ICT infrastructure and services might occur; acquisition and training of skillful
    personnel are needed, as are considerable investments in the DApp development.
    Therefore, the enterprises seek long-term and sustainable solutions and partnerships.
    For the appropriate strategical decision, one needs to evaluate and compare particular
    DLT products or technological platforms and the entire ecosystem. The apt choice
    can lead to faster adoption of technical solutions, decreased initial development
    and long-term progression expenditures, and reduced support costs. This then results
    in technological and business advantages and the generation of new sources of
    revenue.
  prefs: []
  type: TYPE_NORMAL
- en: Technological platform characteristics are, of course, vital. The characteristics
    of DL networks, for example, performance, governance, and scalability, depend
    on technical differences of the DL and details of network implementation (see
    [Section 2.3](#b_9783110681130-002_s_002_s_003)). Smart contract environments
    (see [Section 2.4](#b_9783110681130-002_s_002_s_004)) decisively define DApp design
    and functionalities. However, many additional aspects, apart from the platform,
    represent a DLT ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: A set of libraries and tools is expected for the development, facilitating the
    development and testing, monitoring networks, and validating the solutions. Developers
    need documentation and efficient support, both formal and informal. Some DLT ecosystems
    provide systematic training programs and certification.
  prefs: []
  type: TYPE_NORMAL
- en: A demonstrated ability to keep with a clear roadmap is a good guarantee that
    the DApp and the selected underlying DLT platform, tools, and libraries will improve,
    evolve and receive support in the future. It might also be relevant if a DLT ecosystem
    clearly anticipates steps, which make its operation green and energy-efficient.
  prefs: []
  type: TYPE_NORMAL
- en: A key decision factor should be the community gathered in the ecosystem. A successful
    ecosystem attracts and actively supports users and developers. A large, active
    community shows that the ecosystem encourages an open, collaborative culture.
    A community with a large global footprint also indicates the level of acceptance
    of the platform among users and developers. The communities should not be seen
    only as users or customers of the ecosystem but rather as the external innovators.
    This attitude proved to be successful, for example, in many open source projects.
    Therefore, some of the DLT ecosystems have clearly defined mechanisms for collaboration
    with academia and enterprises.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the number and scope of prominent use cases are other good indicators
    of what we can expect from a DLT ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: 2.7.1 DLT and DApp ecosystems
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here, we present a brief overview of some of the available DLT ecosystems. This
    is, by no means, a comprehensive study. There are many other ecosystems. Besides,
    many forks of the DLT platforms do not bring completely new and independent technological
    approaches but modify the existing protocols to achieve some improvements. Others
    might potentially bring interesting platform solutions in the future but are,
    at the moment, more at a level of concept proofing rather than business-grade
    DLT platforms. The selected ones are, in our opinion, relevant DLT ecosystems,
    which should always be considered as relevant alternatives for DLT selection.
    Bitcoin is not included in these comparisons. Despite being a DLT pioneer and
    the basis for a public DL network with the largest market capitalization cryptocurrency,
    it is not applicable for DApps.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 2.5](#b_9783110681130-002_tab_005) summarizes some of the key features
    of the selected DLT ecosystems. It can serve readers as the starting point to
    match the needs of their anticipated DApp with the matching DLT.'
  prefs: []
  type: TYPE_NORMAL
- en: Tab. 2.5:Comparison of selected DLT ecosystems.
  prefs: []
  type: TYPE_NORMAL
- en: '|  | Ethereum | Hyperledger | Hashgraph | Corda | IOTA |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **Managed by** | The Ethereum Foundation | The Linux Foundation | Hedera
    Governing Council | R3 | IOTA Foundation |'
  prefs: []
  type: TYPE_TB
- en: '| **Type** | Open community | Curated open community | Limited public input
    | Limited public input | Limited public input |'
  prefs: []
  type: TYPE_TB
- en: '| **Public networks** |'
  prefs: []
  type: TYPE_TB
- en: '| **Cryptocurrency** | ETH | / | HBAE | / | MIOTA |'
  prefs: []
  type: TYPE_TB
- en: '| **Governance** | Public | / | Centralized | Consortium | Centralized |'
  prefs: []
  type: TYPE_TB
- en: '| **Distribution** | Very high | / | Low | (not clear) | Unknown |'
  prefs: []
  type: TYPE_TB
- en: '| **Private networks** |'
  prefs: []
  type: TYPE_TB
- en: '| **Possible** | Yes | Yes | Yes | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| **DApp development** |'
  prefs: []
  type: TYPE_TB
- en: '| **DApp** **development** | Very good | Very good | Good | Good | Not applicable
    in v1.0 |'
  prefs: []
  type: TYPE_TB
- en: '| **User and developer communities** |'
  prefs: []
  type: TYPE_TB
- en: '| **Community** | Very large | Large | Relatively small | Financial institutions
    | Relatively small |'
  prefs: []
  type: TYPE_TB
- en: 2.7.1.1 Ethereum ecosystem
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Ethereum is an open-source chain-based DL ecosystem maintained by the Ethereum
    Foundation. In 2021, it continues to implement a well-thought roadmap towards
    Ethereum 2.0\. It includes important changes in DL protocols, such as moving from
    PoW to energy-efficient PoS consensus and addressing scalability problems of Ethereum
    public networks.
  prefs: []
  type: TYPE_NORMAL
- en: The Ethereum blockchain technology is deployed in a large and highly decentralized
    public network, called the mainnet. Anyone can add nodes, including mining nodes,
    to this network. In 2021, there were about 7,000–8,000 nodes in the mainnet. A
    major cryptocurrency is available in the Ethereum public network, making it appropriate
    for DeFi and IoT or other DApps. Private and consortium networks are possible
    with the Ethereum technology. They are often used to improve performance and privacy
    compared to the public network.
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum smart contracts are generally written in Solidity, but Vyper and Flint
    are also supported. A rich set of libraries, tools, development IDEs, and security
    validation tools exist for Ethereum decentralized application development. It
    has the largest developer community. Ethereum is the most popular platform for
    DApps, including IoT DL applications, with numerous convincing use cases.
  prefs: []
  type: TYPE_NORMAL
- en: 2.7.1.2 Hyperledger ecosystem
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Hyperledger ecosystem represents a suite of stable open-source frameworks,
    tools, and libraries for enterprise-grade blockchain deployments. It involves
    more than 250 teams and companies and is hosted by the Linux Foundation. The work
    is organized into projects, which develop different ledger technologies, comprehensive
    tools, and supporting libraries. The maturity of projects is clearly indicated,
    as well as their codependence.
  prefs: []
  type: TYPE_NORMAL
- en: Hyperledger’s DLs (Burrow, Fabric, Indy, Iroha, Sawtooth) primarily target private
    and consortium networks. Therefore, there are no public Hyperledger networks,
    and consequently, no public cryptocurrencies. Only the Hyperledger Besu, a Java-based
    Ethereum client implementation, can be attached to Ethereum networks. Since Hyperledger
    networks are meant to support the operations of various organizations, they are
    private or consortium-based. While multiple organizations might access the same
    ledger or even multiple ledgers having part of the data exposed to the public,
    these networks are still considered private. Different approaches to smart contract
    development are taken in HL, which depend on the selected ledger technology. Hyperledger
    supports various smart contract programming languages and engines. The most prominent
    and widely used programming languages are Solidity and Go. Extensive open-source
    documentation is available for all projects.
  prefs: []
  type: TYPE_NORMAL
- en: Each project has its team of collaborating organizations that vary from world-renowned
    ICT companies to small teams dedicated to the Hyperledger project development.
    Prominent Hyperledger use cases include logistics projects, financial projects,
    humanitarian and philanthropic projects.
  prefs: []
  type: TYPE_NORMAL
- en: 2.7.1.3 Hedera Hashgraph ecosystem
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Hashgraph is a patented DLT maintained by the Hedera Governing Council. The
    Hedera Governing Council consists of up to 39 term-limited and highly diversified
    organizations and enterprises. They reflect up to 11 unique industries, academia,
    and non-profits, globally. Council members are committed to governing software
    changes, while bringing stability and continued decentralization to the public
    network.
  prefs: []
  type: TYPE_NORMAL
- en: The Hedera public network is built on the Hashgraph distributed consensus algorithm.
    It allows for creating or exchanging value, proving identity, or verifying and
    authenticating important data. The public cryptocurrency HBAE is available. The
    cost of a cryptocurrency transaction can remain stable and low, allowing micro-transactions
    to be economically and technologically practical on Hedera. There are ten mainnet
    network nodes. Mirror nodes are used to access Hedera services. One cannot run
    a mirror node on Hedera, but there are Hedera and community mirror nodes available,
    with APIs for Hedera services. The Hedera network is managed by the Hedera Council
    and is thus not really decentralized. Hedera smart contracts are not immutable
    as, for example, in Ethereum. They can be changed if several parties designed
    by a smart contract developer agree.
  prefs: []
  type: TYPE_NORMAL
- en: From the application developers’ point of view, Hedera can be seen as a consortium-based
    service, exposing decentralized transaction capabilities through APIs rather than
    a truly decentralized ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: Prominent Hedera use cases include payments, tokenized assets, and managing
    credentials.
  prefs: []
  type: TYPE_NORMAL
- en: 2.7.1.4 Corda ecosystem
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Corda is an open-source DLT developed and maintained by the R3, a technology
    company that gained prominence in 2015 when a consortium of banks joined the initiative.
    A separate entity called the Corda Network Foundation was set up, using a not-for-profit
    legal entity type known as a Stichting to govern development and networks. This
    type is suited for governance activities and is able to act commercially, with
    limited liability but no shareholders, capital, or dividends.
  prefs: []
  type: TYPE_NORMAL
- en: Corda networks are private or consortium-based. Therefore, the decentralization
    depends on a particular case. A Corda network is a permissioned, publicly available
    P2P network of nodes. Each node represents a legal entity and runs the Corda software.
    A node must obtain a certificate from the network operator to join a network.
    This certificate maps a well-known node identity to a real-world legal identity
    and the corresponding public key. There is no public cryptocurrency in (public)
    Corda networks.
  prefs: []
  type: TYPE_NORMAL
- en: Smart contracts in Corda are agreements whose execution is both automatable
    by computer code working with human input and control, and whose rights and obligations,
    as expressed in legal prose, are legally enforceable. The smart contract code
    in Corda is written using Kotlin, and the virtual machine for contract execution
    and validation is an augmented and radically more restrictive version of the JVM.
    Rich, up-to-date, and well-structured documentation, including code examples,
    is available to the developers. A rich set of development and monitoring tools
    is available.
  prefs: []
  type: TYPE_NORMAL
- en: The Corda Enterprise is proven to meet the security, scalability, and support
    requirements of complex organizations and is now the de facto standard in financial
    services.
  prefs: []
  type: TYPE_NORMAL
- en: 2.7.1.5 IOTA ecosystem
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: IOTA is an open-sourced DLT developed by the IOTA Foundation. The Foundation
    has announced an ambitious roadmap towards the IOTA 2.0\. It will be a challenge
    to keep with it. The roadmap envisages a new DL network protocol suite, new wallet,
    and new library suite and is a major shift compared to version 1.0\. Version 2.0
    should remove the need for (centralized) Coordinator nodes, add smart contract
    protocol, and secure messaging and disposable self-identities. IOTA plans to standardize
    the key DL protocols and has announced collaboration with IEEE and OMG.
  prefs: []
  type: TYPE_NORMAL
- en: In the current version 1.0 of the IOTA network, the transactions are reinforced
    when other transactions reference them. However, they only become truly valid
    when the network Coordinator, a special node operated by the IOTA Foundation,
    confirms them. Due to IOTA’s unique ledger style, it has some unique properties.
    Theoretically, the transaction throughput increases, and the latency decreases
    as the number of nodes and users increases. The IOTA ledger is distributed, but
    the network is not decentralized because of the consensus, requiring Coordinator
    nodes.
  prefs: []
  type: TYPE_NORMAL
- en: There is a public main network and a public test network. IOTA networks use
    a public cryptocurrency, MIOTA. Transactions are essentially free, but the transaction
    sender must submit proof of work.
  prefs: []
  type: TYPE_NORMAL
- en: Support for smart contracts is in the alpha stage for v2.0 but is not available
    in current v1.0, which means that IOTA can only store and transmit data but not
    process it. This makes it, for the moment, not usable for building DApps. Therefore,
    IOTA has not attracted a large developer community. Developers would appreciate
    systematic documentation and clear guidance on how to participate in the IOTA
    network. Version 2.0 promises relevant improvements but takes immense effort to
    be finalized and brought to production grade.
  prefs: []
  type: TYPE_NORMAL
- en: 2.7.2 Deploying and accessing blockchain networks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: DApps require an underlying DL network (see [Sections 2.2](#b_9783110681130-002_s_002_s_002).
    and [2.3](#b_9783110681130-002_s_002_s_003)) for their operation. This can be
    a new, dedicated private or consortium network that we customize to our needs
    and construct from scratch. Nevertheless, it could also be an existing prominent
    public network, where we would like just to attach a couple of additional nodes
    to participate in blockchain network operations.
  prefs: []
  type: TYPE_NORMAL
- en: A scalable self-provisioned blockchain network is complex to set up and hard
    to manage. Each node operator needs to manually provision hardware, install software,
    create and manage certificates for access control, and configure networking components.
    This can be done as very basic editing of node configuration files, for example,
    the genesis file. Some manual tasks can be done instead with a CLI wizard, for
    example, Puppeth, which aids in creating a new Ethereum network. Lately, tools
    like Hyperledger Cello[^(44)](footnotes.xhtml#fn_44) – a blockchain provision
    and operation system – help use and manage blockchains more efficiently. It supports
    various infrastructures like bare-metal, virtual-machine platforms, and container
    cloud (e.g., Swarm, Kubernetes).
  prefs: []
  type: TYPE_NORMAL
- en: Once the blockchain network is running, one needs to monitor the infrastructure
    and adapt to change, continuously. Apart from self-hosted nodes, various Blockchain-as-a-Service
    (BaaS) providers facilitate efficient blockchain network node deployment and management.
    Most of the key players in cloud service provisioning, for example, Amazon, Microsoft,
    Alibaba, and IBM, provide some form of BaaS.
  prefs: []
  type: TYPE_NORMAL
- en: The off-chain DApp parts need to access the DL network node’s APIs ([Section
    2.2](#b_9783110681130-002_s_002_s_002) and [2.4.2](#b_9783110681130-002_s_002_s_004_s_002)).
    These APIs can be exposed in the nodes under our supervision or obtained from
    a dedicated service provider, for example, Infura. The latter assures reliable
    infrastructure connecting a user to the Ethereum public network. This is essential
    for the instant operation of the machine and user interfaces in the DApps. Relying
    on hosted APIs disengages the application developers completely from the DL network
    provisioning.
  prefs: []
  type: TYPE_NORMAL
- en: The content of a public ledger can always be obtained through network nodes.
    However, this might not be the most efficient structure for queries needed in
    the advanced DL data analyses. Therefore, public datasets of historical data from
    various DL networks placed in big data platforms make the analysis more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: 2.7.2.1 Blockchain-as-a-service
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: BaaS provides blockchain services in the cloud or edge computing environments,
    such as node and network deployment, system monitoring, and smart contracts analysis
    and testing. BaaS implementation outsources a major technical and operational
    overhead for deploying and accessing the BC network to the cloud service provider.
    BaaS providers offer adjusted pricing and instance types optimized to fit different
    blockchain use cases.[^(45)](footnotes.xhtml#fn_45) Based on these services, the
    developers can focus on the business code to explore how to apply the blockchain
    technology more appropriately to their business scenarios, without the bother
    of having to maintain and monitor the blockchain platform [45]. BaaS is improving
    the productivity of DApp development and initiates a broad adoption of blockchain
    technologies.[^(46)](footnotes.xhtml#fn_46)
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 2.6](#b_9783110681130-002_tab_006) summarizes the supported DLTs of
    some of the major BaaS providers. There are two dominant technologies – Hyperledger
    (Fabric) and Quorum. This is not surprising, since both are predominantly meant
    for private or consortium-based blockchain networks. Unlike the public networks,
    these networks are newly deployed, so we have to set up and manage all the network
    nodes. Hyperledger ecosystem is described in [Section 2.7.1.2](#b_9783110681130-002_s_002_s_007_s_001_s_002).'
  prefs: []
  type: TYPE_NORMAL
- en: Tab. 2.6:Supported DLTs of some BaaS providers.
  prefs: []
  type: TYPE_NORMAL
- en: '| BaaS providers | Supported DLT |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **Amazon Managed Blockchain** | Ethereum, Hyperledger Fabric |'
  prefs: []
  type: TYPE_TB
- en: '| **IBM Blockchain Platform** | Hyperledger Fabric |'
  prefs: []
  type: TYPE_TB
- en: '| **Microsoft Azure BaaS** | Quorum^(47) |'
  prefs: []
  type: TYPE_TB
- en: '| **Alibaba Cloud BaaS** | Ant, Hyperledger Fabric, Quorum |'
  prefs: []
  type: TYPE_TB
- en: '| **Oracle Blockchain Platform** | Hyperledger Fabric |'
  prefs: []
  type: TYPE_TB
- en: Quorum is an implementation of Ethereum tailored to permissioned enterprise
    blockchain networks. Therefore, it facilitates DApp development with Ethereum’s
    familiar tools and thus benefits from Ethereum’s ecosystem (see [Section 2.7.1.1](#b_9783110681130-002_s_002_s_007_s_001_s_001)).
    A Quorum node is derived from the public Ethereum client (Hyperledger Besu – the
    Ethereum compatible client, see [Section 2.7.1.2](#b_9783110681130-002_s_002_s_007_s_001_s_002)).
    It supports a set of additional consensus mechanisms designed with network performance
    (transaction latency and tps) in mind and enhanced with enterprise features for
    privacy.
  prefs: []
  type: TYPE_NORMAL
- en: 2.7.2.1.1 Amazon Managed Blockchain
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Amazon Managed Blockchain[^(47)](footnotes.xhtml#fn_47) is a fully managed service
    that makes it easy to join public networks or create and manage scalable private
    networks using the popular open-source frameworks Hyperledger Fabric and Ethereum.
  prefs: []
  type: TYPE_NORMAL
- en: Amazon Managed Blockchain allows us to join public networks (e.g., public Ethereum
    mainnet) or set up and manage scalable, permissioned private or consortium networks.
    The service eliminates the overhead required to create the network or join a public
    network and automatically scales up to meet the demands of thousands of applications
    running millions of transactions. Once our network is up and running, Managed
    Blockchain makes it easy to manage and maintain it. It manages authorization certificates
    and lets us easily invite new authorized members to join the network. This effectively
    transforms a private blockchain network into a consortium-based one. Managed Blockchain
    also monitors the network and automatically replaces poorly performing nodes.
    There are pre-built templates and a BaaS API available for quick node creation.
  prefs: []
  type: TYPE_NORMAL
- en: 2.7.2.1.2 IBM blockchain platform
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: IBM is a founding member of the Linux Foundation Hyperledger Project, collaborating
    to develop Hyperledger Fabric, so the focus on Hyperledger in IBM Blockchain Platform[^(48)](footnotes.xhtml#fn_48)
    is not surprising. IBM Blockchain Platform is a commercial distribution of Hyperledger
    Fabric and comes with SLAs and full-time support.
  prefs: []
  type: TYPE_NORMAL
- en: Enterprises can connect to nodes running in any environment (on-premises, public,
    or hybrid clouds) and easily connect a single peer to multiple industry networks.
    They can deploy only the blockchain components they need (Peer, Ordering Service,
    Certificate Authority) and manage all network components through a single console,
    no matter where they are deployed. There is no vendor lock-in, so companies maintain
    complete control of our identities, ledger, and smart contracts.
  prefs: []
  type: TYPE_NORMAL
- en: IBM Blockchain Platform is working together with the Hedera Consensus Service
    to increase interoperability, with the latter providing public consensus while
    a private blockchain network is based on Hyperledger Fabric. The leading use cases
    based on the IBM Blockchain platform are banking and financial markets, supply
    chain, health care, insurance, media, advertising, and government.
  prefs: []
  type: TYPE_NORMAL
- en: 2.7.2.1.3 Microsoft Azure BaaS
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Microsoft Azure BaaS[^(49)](footnotes.xhtml#fn_49) lets us create and configure
    consortium blockchain infrastructure and rapidly deploy fully managed blockchain
    networks. It facilitates the Quorum ledger using the Istanbul Byzantine Fault
    Tolerance (IBFT) consensus mechanism and will eventually support multiple blockchain
    platforms like Ethereum, Hyperledger Fabric, Corda, and Chaincode.
  prefs: []
  type: TYPE_NORMAL
- en: The service is comprised of three sets of products. Azure Blockchain Workbench
    is the foundation for building, governing and deploying fully managed blockchain
    networks and applications at scale. Azure Blockchain Service is a starting point
    for easy prototyping and simplified development with prebuilt networks and infrastructure.
    Azure Blockchain Development Kit is a comprehensive GitHub repository of developer
    blockchain content, including code samples and accelerators. Modular controls
    provide built-in governance for easy member onboarding, consortia management and
    codeless permissioning, and simplified policy enforcement. Blockchain data manager
    enables flexible, reliable, and scalable data streaming and application integration.
    In this way, users can monitor their smart contracts, react to transactions and
    events, and stream on-chain data to off-chain data stores to build the desired
    end-to-end solutions.
  prefs: []
  type: TYPE_NORMAL
- en: 2.7.2.1.4 Alibaba Cloud BaaS
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Alibaba Cloud BaaS[^(50)](footnotes.xhtml#fn_50) supports Hyperledger Fabric,
    Ant Blockchain technologies, and Quorum. It provides out-of-the-box services,
    including enhanced administrative functions to help us build an enterprise-ready
    blockchain network environment with ease and without concerns of complex configuration.
    It includes management of the smart contracts (chaincode) in the organization
    and the business, including the period of overwriting installation, creating instances,
    and updating. The platform allows us to create consortia, invite, and approve
    the participant involved in the business to join the consortium, and manage the
    business.
  prefs: []
  type: TYPE_NORMAL
- en: Alibaba Cloud BaaS integrates Alibaba Cloud Internet of Things (IoT) and anti-counterfeiting
    technologies to provide blockchain solutions for product traceability. Other notable
    use cases stem from supply chain finance, data assets sharing, and digital content
    ownership.
  prefs: []
  type: TYPE_NORMAL
- en: 2.7.2.1.5 Oracle blockchain platform
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Oracle Blockchain Platform[^(51)](footnotes.xhtml#fn_51) is a preassembled
    PaaS, which includes all the dependencies required to support a blockchain network:
    computing, storage, containers, identity services, event services, and management
    services. The blockchain network console supports integrated operations.'
  prefs: []
  type: TYPE_NORMAL
- en: It is based on the Hyperledger Fabric project from the Linux Foundation, but
    it extends the open-source version in many ways to meet the needs of enterprise
    environments. These include, for example, preassembled template-based provisioning,
    operations monitoring and zero-downtime managed patching and updates, enhanced
    security and identity management functions, and a set of HL Fabric APIs through
    REST calls for simpler transaction integration.[^(52)](footnotes.xhtml#fn_52)
  prefs: []
  type: TYPE_NORMAL
- en: Their use cases include large supply chains and trading networks, food safety,
    retail loyalty rewarding, and identity and voting applications.
  prefs: []
  type: TYPE_NORMAL
- en: 2.7.2.2 APIs interfacing public DL networks
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: BaaS ([Section 2.7.2.1](#b_9783110681130-002_s_002_s_007_s_002_s_001)) enables
    node deployments and display APIs for the off-chain applications to utilize the
    blockchain services. However, BaaS is predominantly meant for private blockchain
    networks. On the other hand, many uses solely rely on public blockchains, where
    the network infrastructure is already available. In such a case, reliable remote
    node services are crucial for user experience in any blockchain-enabled mobile
    application, blockchain-compatible browsers, and plug-ins for Web applications
    or blockchain development tools. The developers of these products can completely
    eliminate the need to install, run, and manage their network nodes for a user
    to access the public network.
  prefs: []
  type: TYPE_NORMAL
- en: Infura[^(53)](footnotes.xhtml#fn_53) focuses on instant, reliable infrastructure
    connecting us to Ethereum (mainnet and various test networks), Filecoin, and IPFS.
    Off-chain applications can connect to Ethereum and IPFS via JSON-RPC over HTTPS
    and WebSocket, where request–response times are up to 20 times faster than other
    services and self-hosted solutions. Infura network nodes are running on the latest
    network upgrades with a minimum 99.9% uptime guarantee. The service is provided
    with per request or subscription-based connections and has full-time access to
    expert support teams.
  prefs: []
  type: TYPE_NORMAL
- en: A dashboard gives direct insights into the app’s performance and API usage.
    This can be used to drill down into specific request methods or most active usage
    times to optimize the applications and better understand users.
  prefs: []
  type: TYPE_NORMAL
- en: Many leading blockchain-enabled products rely on Infura’s services, for example,
    mobile applications (Coinbase Wallet), blockchain-compatible browsers and plug-ins
    (Brave, Metamask, Opera), and blockchain tools (OpenZeppelin, Truffle).
  prefs: []
  type: TYPE_NORMAL
- en: Infura is dominant, but a few alternate providers are active in this service
    area. ZMOK[^(54)](footnotes.xhtml#fn_54) provides fast Ethereum nodes accessible
    through JSON-RPC API. A similar service for the Ethereum network and the IPFS
    is available with the Cloudflare Distributed Web Gateway.[^(55)](footnotes.xhtml#fn_55)
    QuikNode[^(56)](footnotes.xhtml#fn_56) serves elastic APIs and dedicated nodes.
    Apart from Ethereum, their API endpoints include BSC, Optimism, Bitcoin, xDAI,
    and Polygon. Pocket Network[^(57)](footnotes.xhtml#fn_57) is an inclusive relay
    network for API requests to major blockchains with a crypto-economic model. The
    requests are routed to available nodes pseudo-randomly, making them very redundant.
    Compared to single-service providers, Pocket Network is organized as a decentralized
    autonomous organization (DAO). Its mission is to ensure the sustainable decentralization
    of blockchain infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: 2.7.2.3 Public datasets for advanced blockchain data analytics
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Ledger data derived directly from the network nodes might not have the most
    efficient structure for queries needed in the advanced BC data analyses, utilization
    of big data, machine learning, or business intelligence mechanisms. For this purpose,
    Google BigQuery, for example, provides public datasets to access the historical
    data from various BC networks, including access to the on-chain transaction data
    and entire block history. The data is, therefore, immediately available in all
    the analysis methods and visualization tools in BigQuery. In 2021, there were
    nearly 50 public datasets[^(58)](footnotes.xhtml#fn_58) available in the Google
    Cloud Platform marketplace. They include most key public blockchain networks,
    for example, BTC, Ethereum, Ethereum Classic, Litecoin, Dash, Zcash, Monero, Cardano,
    NEO, etc. This data can be immediately applied in Google Cloud’s AI services and
    data analytics or simply structured and queried with SQL.
  prefs: []
  type: TYPE_NORMAL
- en: The analysis can, for instance, reveal the most popular collectibles (ERC721
    contracts) or tokens (ERC20 contracts), find zero-fee transactions, calculate
    balances of blockchain addresses, and so on.
  prefs: []
  type: TYPE_NORMAL
