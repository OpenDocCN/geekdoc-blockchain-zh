- en: 'Part II: An Introduction to Ethereum'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分：以太坊简介
- en: In this part of the book, I introduce one of the most important public blockchains
    today, Ethereum. In terms of market cap, Ethereum is second only to the Bitcoin
    blockchain. Since Ethereum was the first blockchain that pioneered the concept
    of smart contracts, many public and private blockchains today are compatible with
    Ethereum to leverage the Ethereum developer community. In that regard, Ethereum
    is not just a public blockchain. It is a protocol many other blockchains conform
    to.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的这一部分，我介绍了目前最重要的公共区块链之一，以太坊。从市值来看，以太坊仅次于比特币区块链。由于以太坊是第一个开创智能合约概念的区块链，因此许多公共和私有区块链现在都与以太坊兼容，以便利用以太坊开发者社区。从这个意义上说，以太坊不仅仅是一个公共区块链。它是许多其他区块链遵循的协议。
- en: Hence, for developers, it is important to understand how Ethereum works and
    how to write applications (i.e., smart contracts and decentralized applications)
    on it. The chapters in this part will discuss how to build Ethereum-compatible
    smart contracts and applications from the ground up. It is important to note that
    there are several Ethereum-compatible blockchains you can use to develop and deploy
    Ethereum applications, ESPECIALLY for applications optimized for specific business
    use cases.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于开发者来说，了解以太坊如何运作以及如何在以太坊上编写应用程序（即智能合约和去中心化应用程序）非常重要。本书这部分的章节将讨论如何从头开始构建与以太坊兼容的智能合约和应用程序。需要指出的是，有几种与以太坊兼容的区块链可供您用于开发和部署以太坊应用程序，尤其是针对特定业务用例优化的应用程序。
- en: Then, in [Part III](part3.xhtml#part03) of the book, I will further explore
    the inner workings and future plans of Ethereum.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的[第三部分](part3.xhtml#part03)中，我将进一步探讨以太坊的内部运作和未来计划。
- en: 4. Getting Started
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4. 入门
- en: While it is possible to write software programs for the Bitcoin blockchain,
    few people do because of the limited programming functionality supported on the
    Bitcoin network.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有可能为比特币区块链编写软件程序，但由于比特币网络上支持的编程功能有限，很少有人这样做。
- en: Ethereum is the first large-scale blockchain network that supports sophisticated
    application development. Ethereum’s ambition is to become the “world’s computer.”
    Through autonomous software programs, known as *smart contracts*, the Ethereum
    blockchain can be programmed to automatically execute transactions when certain
    conditions are met. To support this, Ethereum natively supports a Turing complete
    programming language (Solidity) and virtual machine (Ethereum Virtual Machine
    [EVM]), making it possible to program a wide range of applications.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊是第一个支持复杂应用开发的大型区块链网络。以太坊的野心是成为“世界电脑”。通过自主软件程序，称为*智能合约*，当满足某些条件时，以太坊区块链可以被编程来自动执行交易。为了支持这一点，以太坊内置了图灵完备编程语言（Solidity）和虚拟机（以太坊虚拟机[EVM]），这使得编程各种应用程序成为可能。
- en: For programmers, writing smart contract code to run on the Ethereum blockchain
    is the first step into the world of blockchain application development. As Ethereum
    continues to gain popularity and value, programming Ethereum applications has
    become a necessary and valuable skill.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 对于程序员来说，编写在以太坊区块链上运行的智能合约代码是进入区块链应用开发世界的第一步。随着以太坊不断受欢迎和价值增长，编程以太坊应用已经成为一种必要且宝贵的技能。
- en: In this chapter, we will start with a simple “Hello, World!” smart contract
    on Ethereum. We walk through the entire process to deploy and then interact with
    it on one of the Ethereum’s test networks using popular tools. This example aims
    to get you started with Ethereum as quickly as possible. The subsequent chapters
    will go deeper into those concepts and alternative tools.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将从以太坊上的一个简单的“Hello, World!”智能合约开始。我们通过使用流行的工具，完整地了解部署并在以太坊的一个测试网络上与之交互的过程。这个例子旨在让您尽快开始使用以太坊。后续章节将更深入地探讨这些概念和替代工具。
- en: '**Note**'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: It is often beneficial to develop your applications on an Ethereum-compatible
    blockchain rather than the Ethereum blockchain itself. You have seen the Second
    State DevChain as a clear example of a fast Ethereum-compatible blockchain. Later
    in this book, we will use the CyberMiles public blockchain as another Ethereum-compatible
    alternative for developers. The CyberMiles public blockchain is optimized for
    e-commerce applications. But at the same time, it is fully compatible with Ethereum
    languages and tools with faster execution speed, faster transaction confirmation
    time (10s), and much lower cost (1,000 times cheaper). You can learn more in [Chapter
    14](ch14.xhtml#ch14).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，与其在以太坊本身上开发应用程序，不如在以太坊兼容的区块链上开发应用程序更有益。您已经看到了Second State DevChain作为一个明显的快速以太坊兼容区块链的例子。在这本书的后面，我们将使用CyberMiles公共区块链作为另一个对开发者开放的以太坊兼容选择。CyberMiles公共区块链针对电子商务应用程序进行了优化。但同时，它与以太坊语言和工具完全兼容，执行速度更快，交易确认时间（10秒）更快，成本更低（便宜1000倍）。您可以在[第14章](ch14.xhtml#ch14)了解更多。
- en: The BUIDL Way
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: BUIDL方法
- en: In [Chapter 3](ch03.xhtml#ch03), I introduced you to the BUIDL open source integrated
    development environment (IDE). It works with all Ethereum-compatible blockchains
    including the Ethereum mainnet and testnet. Let’s set up BUIDL to work with Ethereum.
    Open the BUIDL web app at [http://buidl.secondstate.io/](http://buidl.secondstate.io/)
    and click the **Providers** tab in the lower-left corner of the browser window
    ([Figure 4.1](ch04.xhtml#ch04fig1)).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第三章](ch03.xhtml#ch03)中，我向您介绍了BUIDL开源集成开发环境（IDE）。它支持所有与以太坊兼容的区块链，包括以太坊主网和测试网。让我们设置BUIDL以配合以太坊工作。打开BUIDL网络应用[http://buidl.secondstate.io/](http://buidl.secondstate.io/)，并点击浏览器窗口左下角的**提供者**标签([图4.1](ch04.xhtml#ch04fig1))。
- en: '![image](Images/yuan_f04_01.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/yuan_f04_01.jpg)'
- en: '**Figure 4.1** Configuring BUIDL to work with the Ethereum mainnet'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**图4.1** 配置BUIDL以配合以太坊主网'
- en: Ethereum Mainnet
  id: totrans-15
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 以太坊主网
- en: You should configure the web3 and ES (Elasticsearch) providers to public Ethereum
    nodes, as shown below. Or you can launch the following URL to have everything
    auto-configured for Ethereum. [https://buidl.secondstate.io/eth](https://buidl.secondstate.io/eth)
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该配置web3和ES（Elasticsearch）提供者为公共以太坊节点，如下所示。或者你可以启动以下链接，让一切自动为您配置以太坊。[https://buidl.secondstate.io/eth](https://buidl.secondstate.io/eth)
- en: '*ES provider*: Set this to [https://eth.search.secondstate.io/](https://eth.search.secondstate.io/).
    The ES provider is a smart contract search engine that provides real-time data
    from the Ethereum network. You can learn more in [Chapter 11](ch11.xhtml#ch11).'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ES提供者**：将其设置为[https://eth.search.secondstate.io/](https://eth.search.secondstate.io/)。ES提供者是一个智能合约搜索引擎，它提供来自以太坊网络的实时数据。您可以在[第11章](ch11.xhtml#ch11)了解更多。'
- en: '*Web3 provider*: Set this to [https://mainnet.infura.io/](https://mainnet.infura.io/).
    This is a public Ethereum blockchain node provided by Infura. Infura requests
    regular users to register an API key in order to use their services. Please do
    so and set your own mainnet.infura.io URL with your API key here. Alternatively,
    you could use a community-provided web3 provider such as [https://main-rpc.linkpool.io/](https://main-rpc.linkpool.io/)
    or [https://eth.node.secondstate.io/](https://eth.node.secondstate.io/).'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Web3提供者**：将其设置为[https://mainnet.infura.io/](https://mainnet.infura.io/)。这是一个由Infura提供的公共以太坊区块链节点。Infura要求普通用户注册API密钥以使用他们的服务。请这样做，并使用您的API密钥在此处设置您自己的mainnet.infura.io网址。或者，您可以使用由社区提供的web3提供者，如[https://main-rpc.linkpool.io/](https://main-rpc.linkpool.io/)或[https://eth.node.secondstate.io/](https://eth.node.secondstate.io/)。'
- en: '*Chain ID*: Set this to 1 for the Ethereum mainnet.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**链ID**：将其设置为1，用于以太坊主网。'
- en: '*Custom Tx gas*: Check this box so that BUIDL uses the specified gas price
    when creating contracts and calling contract functions.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自定义Tx燃料**：勾选此框，以便BUIDL在创建合约和调用合约函数时使用指定的燃料价格。'
- en: '*Gas price*: Set this to 10000000000 (wei, or 10 Gwei) as the default gas price
    used by BUIDL. You can use the Ethereum Gas Tracker to see the current gas price
    on the network ([https://etherscan.io/gasTracker](https://etherscan.io/gasTracker)).
    The higher gas price you are willing to pay, the faster your transactions can
    be confirmed.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**燃料价格**：将其设置为10000000000（wei，或10 Gwei），作为BUIDL默认使用的燃料价格。您可以使用以太坊燃料跟踪器查看网络上的当前燃料价格([https://etherscan.io/gasTracker](https://etherscan.io/gasTracker))。您愿意支付更高的燃料价格，您的交易就可以更快地得到确认。'
- en: '*Gas limit*: Set this to 8000000, which is the current block gas limit for
    Ethereum.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**燃料限制**：将其设置为8000000，这是以太坊当前的区块燃料限制。'
- en: '**Note**'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: Since the Ethereum mainnet can be extremely congested from time to time, you
    should be prepared to pay a high gas price (as much as $10 USD just to deploy
    a contract or call a function), and you could wait hours for the transaction to
    confirm. I recommend that most developers develop and even deploy on much faster
    and cheaper blockchains such as the Ethereum Classic or CyberMiles.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 由于以太坊主网有时可能会非常拥堵，你应该准备支付高昂的燃料价格（部署合约或调用函数可能需要高达10美元），并且你可能需要等待数小时才能确认交易。我建议大多数开发者在像以太坊经典或CyberMiles这样更快且更便宜的区块链上进行开发，甚至部署。
- en: Now we have configured BUIDL to pay gas when deploying and calling smart contracts
    on Ethereum. BUIDL creates five random accounts for each user and then uses the
    default selected account to interact with the blockchain ([Figure 4.2](ch04.xhtml#ch04fig2)).
    So, you need an ETH balance in the default account. Just send some ETHs from your
    wallet or exchange accounts to your BUIDL default account. Or, you can use the
    + button next to Accounts to import an ETH account from other wallets.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经配置了BUIDL，在以太坊上部署和调用智能合约时会支付燃料费。BUIDL为每个用户创建五个随机账户，然后使用默认选择的账户与区块链交互([图4.2](ch04.xhtml#ch04fig2))。所以，你在默认账户中需要一个ETH余额。只需从你的钱包或交易所账户向你的BUIDL默认账户发送一些ETH。或者，你可以点击账户旁边的+按钮，从其他钱包导入一个ETH账户。
- en: '![image](Images/yuan_f04_02.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/yuan_f04_02.jpg)'
- en: '**Figure 4.2** Select a default account in BUIDL. You need an ETH balance in
    it to pay for gas.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**图4.2** 在BUIDL中选择一个默认账户。你需要在其中保持ETH余额以支付燃料费。'
- en: '**Note**'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: BUIDL has a built-in wallet that manages account private keys. However, BUIDL
    can only sign transactions and pay gas from its accounts. It is designed for application
    development. BUIDL is not a general-purpose wallet, and I do not recommend maintaining
    more than 0.1 ETH balance in it.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: BUIDL拥有一个内置的钱包，用于管理账户私钥。然而，BUIDL只能从其账户签名交易和支付燃料费。它旨在用于应用开发。BUIDL不是一个通用钱包，我不建议在其中保持超过0.1
    ETH的余额。
- en: That’s all you need in the contract tab. You can now write a smart contract,
    click the **Compile** and **Deploy to the chain** buttons to deploy it to Ethereum,
    and then use the BUIDL user interface (UI) to call any function on the deployed
    contract.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在合约标签页这就是你所需要的一切。现在你可以编写一个智能合约，点击**编译**和**部署到链上**按钮将其部署到以太坊，然后使用BUIDL用户界面（UI）调用已部署合约上的任何函数。
- en: 'Finally, on the dapp tab of BUIDL, you need to add `gasPrice` and `gas` parameters
    to all web3 transactions. You are safe to use BUIDL’s default `web3.ss` package
    here, as it contains all `web3.eth` objects and functions. Here is an example:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在BUIDL的dapp标签页中，你需要为所有的web3交易添加`gasPrice`和`gas`参数。在这里使用BUIDL的默认`web3.ss`包是安全的，因为它包含了所有的`web3.eth`对象和函数。这是一个例子：
- en: '[Click here to view code image](Images/ch04_images.xhtml#pro4_1)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**点击此处查看代码图片**([https://etc.search.secondstate.io/Images/ch04_images.xhtml#pro4_1](https://etc.search.secondstate.io/Images/ch04_images.xhtml#pro4_1))'
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: That’s it. You now have the default BUIDL example smart contract and dapp deployed
    on the Ethereum public blockchain.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。现在你已经将在以太坊公共区块链上部署了默认的BUIDL示例智能合约和dapp。
- en: Ethereum Classic Mainnet
  id: totrans-35
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 以太坊经典主网
- en: If you are not willing to pay $10 USD and wait hours for every contract call,
    you can use the Ethereum Classic blockchain to deploy your applications. The Ethereum
    Classic blockchain is one of the most reputable and stable blockchain networks
    in the world, and it is fully compatible with the Ethereum protocol. Its native
    cryptocurrency, ETC, costs a fraction of ETH. The Ethereum Classic blockchain
    is seldom congested, and hence a 10 Gwei gas price (pennies) typically results
    in transaction confirmation in less than a minute. To configure BUIDL to use the
    Ethereum Classic mainnet, use the following settings. Or you can launch the following
    URL to have everything auto-configured for Ethereum Classic. [https://buidl.secondstate.io/etc](https://buidl.secondstate.io/etc)
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不愿意为每次合约调用支付10美元并等待数小时，你可以使用以太坊经典区块链来部署你的应用程序。以太坊经典区块链是世界上最有声誉和稳定的区块链网络之一，它与以太坊协议完全兼容。其原生加密货币ETC只需ETH的一小部分。以太坊经典区块链很少拥堵，因此10
    Gwei的燃料价格（几美分）通常会在不到一分钟内确认交易。要配置BUIDL以使用以太坊经典主网，请使用以下设置。或者，你可以启动以下URL，让一切自动配置为以太坊经典。[https://buidl.secondstate.io/etc](https://buidl.secondstate.io/etc)
- en: '*ES provider* : Set this to [https://etc.search.secondstate.io/](https://etc.search.secondstate.io/).'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ES提供商**：将其设置为[https://etc.search.secondstate.io/](https://etc.search.secondstate.io/)。'
- en: '*Web3 provider* : Set this to [https://www.ethercluster.com/etc](https://www.ethercluster.com/etc).'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Web3提供商**：将其设置为[https://www.ethercluster.com/etc](https://www.ethercluster.com/etc)。'
- en: '*Chain ID*: Set this to 61 for the Ethereum Classic mainnet.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**链ID**：将此设置为61，用于以太坊经典主网。'
- en: '*Custom Tx gas*: Check this box.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自定义Tx gas**：勾选此框。'
- en: '*Gas Price*: Set this to 10000000000 (wei, or 10 Gwei) as the default gas price
    used by BUIDL.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Gas Price**：将此设置为10000000000（wei，或10 Gwei），作为BUIDL默认使用的燃料价格。'
- en: '*Gas Limit*: Set this to 8000000.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Gas Limit**：将此设置为8000000。'
- en: In addition, the current Ethereum Classic blockchain requires Solidity compiler
    version 0.4.2.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当前以太坊经典区块链需要Solidity编译器版本0.4.2。
- en: You must configure that for BUIDL by using URL parameter `/?s042` when launching
    BUIDL.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须通过在启动BUIDL时使用URL参数`/?s042`来为BUIDL配置此设置。
- en: Send some ETC to your BUIDL account as gas. You can now compile, deploy, and
    call your smart contract on the Ethereum Classic blockchain.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 向您的BUIDL账户发送一些ETC作为燃料。现在，您可以在以太坊经典区块链上编译、部署和调用您的智能合约。
- en: CyberMiles Mainnet
  id: totrans-46
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: CyberMiles Mainnet
- en: The CyberMiles public blockchain is an Ethereum-compatible blockchain that is
    much faster (a ten-second transaction confirmation time) and cheaper than both
    ETH and ETC. You can read more about it in [Chapter 14](ch14.xhtml#ch14). To configure
    BUIDL to use the CyberMiles mainnet, configure the following settings. Or you
    can launch the following URL to have everything auto-configured for CyberMiles.
    [https://buidl.secondstate.io/cmt](https://buidl.secondstate.io/cmt)
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 网络浏览器CyberMiles公共区块链是一个比以太坊更快（交易确认时间为十秒）且更便宜（比ETH和ETC都要便宜）的以太坊兼容区块链。您可以在第[14章](ch14.xhtml#ch14)中了解更多关于它的信息。要配置BUIDL以使用CyberMiles主网，请配置以下设置。或者您可以启动以下URL，让一切自动为您配置CyberMiles。
    [https://buidl.secondstate.io/cmt](https://buidl.secondstate.io/cmt)
- en: '*ES provider* : Set this to [https://cmt.search.secondstate.io/](https://cmt.search.secondstate.io/).'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ES提供者**：将其设置为 [https://cmt.search.secondstate.io/](https://cmt.search.secondstate.io/)。'
- en: '*Web3 provider* : Set this to [https://rpc.cybermiles.io:8545/](https://rpc.cybermiles.io:8545/).'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Web3提供者**：将其设置为 [https://rpc.cybermiles.io:8545/](https://rpc.cybermiles.io:8545/)。'
- en: '*Chain ID*: Set this to 18 for the CyberMiles mainnet.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**链ID**：将此设置为18，用于CyberMiles主网。'
- en: '*Custom Tx gas*: Check this box.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自定义Tx gas**：勾选此框。'
- en: '*Gas Price*: Set this to 5000000000 (wei, or 5 Gwei) as the default gas price
    used by BUIDL.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Gas Price**：将此设置为5000000000（wei，或5 Gwei），作为BUIDL默认使用的燃料价格。'
- en: '*Gas Limit*: Set this to 8000000.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Gas Limit**：将此设置为8000000。'
- en: Send some CMT to your BUIDL account as gas. You can now compile, deploy, and
    call your smart contract on the CyberMiles blockchain.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 向您的BUIDL账户发送一些CMT作为燃料。现在，您可以在CyberMiles区块链上编译、部署和调用您的智能合约。
- en: '**Note**'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: Ethereum, Ethereum Classic, and CyberMiles all have testnets for developers
    to try their applications without spending real money. However, from my experience,
    testnet tokens are difficult to come by, and the test dapps are difficult to share,
    as few users have testnet wallets or tokens. The testnet is also often unreliable
    and runs different software than the mainnet. For CyberMiles, the cost of transactions
    is less than 1 cent. It is a good choice even for development purposes.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊、以太坊经典和CyberMiles都为开发者提供了测试网，以无需花费真实货币就能尝试他们的应用程序。然而，根据我的经验，测试网代币难以获得，且测试dapp难以共享，因为很少有用户拥有测试网钱包或代币。测试网也常常不可靠，且与主网运行不同的软件。对于CyberMiles，交易费用不到1美分。即使是为了开发目的，这也是一个不错的选择。
- en: The Hard Way
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: The Hard Way
- en: The key benefit of BUIDL is that it is easy to use and allows fast development
    cycles. But it also hides some important concepts from the application developer.
    In this section, we will take a step back and use more traditional Ethereum developer
    tools to explain the concepts behind Ethereum.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: BUIDL的主要优点是易于使用并允许快速开发周期。但它也隐藏了一些对应用程序开发者重要的概念。在本节中，我们将退后一步，使用更传统的以太坊开发工具来解释以太坊背后的概念。
- en: Metamask Wallet
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Metamask 钱包
- en: The Metamask wallet is a Chrome browser extension to manage your Ethereum blockchain
    accounts. It stores and manages your private keys to those accounts on your computer
    (i.e., a wallet for private keys and, by extension, cryptocurrency stored in those
    accounts). For developers, Metamask is a great tool since it integrates with other
    development tools and allows you to interact with Ethereum accounts programmatically.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Metamask 钱包是Chrome浏览器的一个扩展程序，用于管理您的以太坊区块链账户。它将您的私钥（即钱包）存储在您的计算机上，以及存储在这些账户中的加密货币。对于开发者来说，Metamask是一个很好的工具，因为它与其他开发工具集成，并允许您以编程方式与以太坊账户互动。
- en: First, make sure you have the latest Google Chrome browser installed. You can
    get it at [https://www.google.com/chrome/](https://www.google.com/chrome/).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，请确保您已安装最新版本的Google Chrome浏览器。您可以在 [https://www.google.com/chrome/](https://www.google.com/chrome/)
    上获取它。
- en: Next, follow the instructions on the Metamask web site ([https://metamask.io/](https://metamask.io/))
    to install Metamask on your Chrome browser.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，按照 MetaMask 网站([https://metamask.io/](https://metamask.io/))的说明，在您的 Chrome
    浏览器上安装 MetaMask。
- en: Now, you should see the Metamask icon on your Chrome toolbar. Click it to bring
    up its UI. You should create a password for your Metamask wallet ([Figure 4.3](ch04.xhtml#ch04fig3)).
    This is important since your password protects your account’s private keys stored
    on this computer. Once you create the password, Metamask will give you a 12-word
    recovery phase. That is the only way for you to recover the password, so keep
    it safe!
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该在 Chrome 工具栏上看到 MetaMask 图标。点击它以打开其用户界面。你应该为你的 MetaMask 钱包创建一个密码([图 4.3](ch04.xhtml#ch04fig3))。这很重要，因为你的密码保护着存储在这台计算机上的账户私钥。一旦你创建了密码，MetaMask
    就会给你一个 12 词的恢复短语。这是你恢复密码的唯一方式，所以要妥善保管！
- en: '![image](Images/yuan_f04_03.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/yuan_f04_03.jpg)'
- en: '**Figure 4.3** Creating a password for your Metamask wallet'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 4.3** 为你的 MetaMask 钱包创建密码'
- en: For development purposes, select the top-left drop-down list in the Metamask
    UI, and select the Ropsten Test Network ([Figure 4.4](ch04.xhtml#ch04fig4)), which
    is an Ethereum public blockchain maintained for testing purposes.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 出于开发目的，在 MetaMask 用户界面的左上角选择下拉列表，选择 Ropsten 测试网络([图 4.4](ch04.xhtml#ch04fig4))，这是一个为测试目的而维护的以太坊公共区块链。
- en: '![image](Images/yuan_f04_04.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/yuan_f04_04.jpg)'
- en: '**Figure 4.4** Selecting the Ropsten testnet'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 4.4** 选择 Ropsten 测试网络'
- en: You will also need to create an account on the Ropsten testnet to store your
    ETH cryptocurrency there. Select the person icon at the top right of the Metamask
    UI, and select **Create Account** ([Figure 4.5](ch04.xhtml#ch04fig5), left). Metamask
    will create an account address and its associated private key for you. You can
    click an account in the UI and get its address in the clipboard or export its
    private key ([Figure 4.5](ch04.xhtml#ch04fig5), right). You can name this account
    so that you can access it in the Metamask UI later. You can also use Metamask
    to manage mainnet ETHs, which can be traded on exchanges for U.S. dollars. But
    to do that, you should make sure that your computer is physically secure since
    real money will be at stake.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要在 Ropsten 测试网络上创建一个账户来存储你的 ETH 加密货币。在 MetaMask 用户界面的右上角选择人物图标，选择**创建账户**([图
    4.5](ch04.xhtml#ch04fig5)，左)。MetaMask 将为你创建一个账户地址及其关联的私钥。你可以点击 UI 中的一个账户，将其地址复制到剪贴板或导出其私钥([图
    4.5](ch04.xhtml#ch04fig5)，右)。你可以给这个账户命名，这样你以后可以在 MetaMask UI 中访问它。你还可以使用 MetaMask
    管理主网 ETH，这些 ETH 可以在交易所交易换算成美元。但这样做时，你应该确保你的电脑物理安全，因为真实的货币将会涉及风险。
- en: '![image](Images/yuan_f04_05.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/yuan_f04_05.jpg)'
- en: '**Figure 4.5** Creating a new account on the Ropsten testnet and getting the
    account address'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 4.5** 在 Ropsten 测试网络上创建新账户并获取账户地址'
- en: Of course, you still need to fund your account with some Ropsten testnet ETH
    to use it. Go to the public Ropsten faucet ([http://faucet.ropsten.be:3001/](http://faucet.ropsten.be:3001/))
    and request 1 testnet ETH for your address! The Ropsten testnet ETH can be used
    only on the testnet. It is not traded in any exchanges and can disappear at any
    time when the Ropsten testnet is retired. Unlike the mainnet ETH, Ropsten ETH
    has zero monetary value.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你仍然需要用一些 Ropsten 测试网络 ETH 资助你的账户以使用它。前往公共 Ropsten 水龙头([http://faucet.ropsten.be:3001/](http://faucet.ropsten.be:3001/))，为你的地址请求
    1 个测试网络 ETH！Ropsten 测试网络 ETH 只能在测试网络上使用。它不会在任何交易所交易，并且当 Ropsten 测试网络退役时随时可能消失。与主网
    ETH 不同，Ropsten ETH 没有货币价值。
- en: Now you have set up Metamask and are ready to interact with your first Ethereum
    smart contract on the Ropsten testnet!
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经设置了 MetaMask，准备在 Ropsten 测试网络上与你的第一个以太坊智能合约互动！
- en: Remix
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Remix
- en: 'Remix the Ethereum IDE for developers to experience smart contracts on the
    Ethereum blockchain. Remix is completely web-based. Just go to its web site to
    load the web app: [http://remix.ethereum.org/](http://remix.ethereum.org/).'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Remix 是面向开发者的以太坊 IDE，让开发者能够体验以太坊区块链上的智能合约。Remix 完全是基于网页的。只需访问它的网站来加载网页应用：[:http://remix.ethereum.org/](http://remix.ethereum.org/)。
- en: '**Note**'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: The Remix IDE is similar to the contract tab in BUIDL, except that BUIDL does
    not require any external wallet like Metamask.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Remix IDE 与 BUIDL 合同标签页相似，只不过 BUIDL 不需要像 MetaMask 这样的外部钱包。
- en: In the code editor to the right, let’s enter a simple smart contract. The following
    is an example of the “Hello, World!” smart contract. It is written in a special
    JavaScript-like programming language known as Solidity.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在右侧的代码编辑器中，让我们输入一个简单的智能合约。以下是一个“Hello, World!”智能合约的示例。它是用一种特殊的JavaScript样式的编程语言Solidity编写的。
- en: '[Click here to view code image](Images/ch04_images.xhtml#pro4_2)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**点击此处查看代码图片](Images/ch04_images.xhtml#pro4_2)**'
- en: '[PRE1]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The “Hello, World!” smart contract has two key methods.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: “Hello, World!”智能合约有两个关键方法。
- en: The `sayHello()` method returns a greeting to its caller. The greeting is initially
    set to “Hello, World!” when the smart contract is deployed.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sayHello()`方法向其调用者返回一个问候。当智能合约部署时，问候被初始化为“Hello, World!”。'
- en: The `updateMessage()` method allows the method caller to change the greeting
    message from “Hello, World!” to another message.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`updateMessage()`方法允许调用者将问候从“Hello, World!”更改为另一条消息。'
- en: Hit the **Start to compile** button in the right panel to compile this contract
    ([Figure 4.6](ch04.xhtml#ch04fig6)). It will generate the bytecode and application
    binary interface (ABI) to be used later.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在右侧面板中点击**开始编译**按钮以编译此合约([图4.6](ch04.xhtml#ch04fig6))。它将生成稍后可用的字节码和应用程序二进制接口（ABI）。
- en: '![image](Images/yuan_f04_06.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/yuan_f04_06.jpg)'
- en: '**Figure 4.6** Compiling an Ethereum smart contract in Remix'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**图4.6** 在Remix中编译以太坊智能合约'
- en: Next, on the Run tab of Remix ([Figure 4.7](ch04.xhtml#ch04fig7)), you can connect
    Remix to your Metamask account via the Injected Web3 drop-down box. Remix will
    automatically detect your existing Metamask accounts. If your Ropsten address
    does not show up here, try logging out and then back into Remix.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在Remix的Run标签页([图4.7](ch04.xhtml#ch04fig7))中，您可以通过Injected Web3下拉框将Remix连接到您的MetaMask账户。Remix将自动检测您的现有MetaMask账户。如果您的Ropsten地址在这里没有显示，尝试退出然后重新登录Remix。
- en: '![image](Images/yuan_f04_07.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/yuan_f04_07.jpg)'
- en: '**Figure 4.7** Injecting Metamask into Remix'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**图4.7** 将MetaMask注入Remix'
- en: You should now see options to deploy the smart contract to the blockchain. Click
    the **Deploy** button to deploy the contract to the blockchain. Since you have
    selected a Ropsten address to inject into this Remix session, the contract will
    be deployed on the Ropsten testnet. At this time, Metamask will pop up and ask
    you to send a gas fee from your existing account address ([Figure 4.8](ch04.xhtml#ch04fig8)).
    The gas fee is required by the Ethereum network to pay for the network service
    required to deploy your contract.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您应该看到将智能合约部署到区块链的选项。点击**部署**按钮将合约部署到区块链。由于您已经选择了一个Ropsten地址注入到这个Remix会话中，因此合约将在Ropsten测试网上部署。此时，MetaMask将弹出，并要求您从现有账户地址发送燃料费([图4.8](ch04.xhtml#ch04fig8))。燃料费是以太坊网络为支付部署您合约所需的网络服务而收取的。
- en: '![image](Images/yuan_f04_08.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/yuan_f04_08.jpg)'
- en: '**Figure 4.8** Paying a gas fee to deploy the contract'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**图4.8** 支付部署合约的燃料费'
- en: After you submit the Metamask request, wait for a few minutes for the Ethereum
    network to confirm the deployment of your contract. The contract deployment address
    will be shown in the confirmation, and the deployed contract and its available
    functions will be available on the Run tab in Remix as well ([Figure 4.9](ch04.xhtml#ch04fig9)).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 提交MetaMask请求后，请等待几分钟，让以太坊网络确认您的合约部署。部署合约的地址将在确认信息中显示，您可以在Remix的Run标签页中查看已部署的合约及其可用功能([图4.9](ch04.xhtml#ch04fig9))。
- en: '![image](Images/yuan_f04_09.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/yuan_f04_09.jpg)'
- en: '**Figure 4.9** The contract is now deployed, and the available methods are
    shown.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**图4.9** 合约现已部署，显示了可用方法。'
- en: If you have already deployed the smart contract on the Ropsten testnet, you
    already know the deployed address of the contract. You can simply enter the contract
    address in the box next to the At Address button and click the button. This configures
    Remix to use an already-deployed contract. No gas fee is needed in this case.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经在Ropsten测试网上部署了智能合约，您已经知道合约的部署地址。您只需在At Address按钮旁边的框中输入合约地址，然后点击按钮即可。这样配置Remix以使用已经部署的合约。在这种情况下，无需支付燃料费。
- en: Once Remix is connected to your deployed contract, it shows the contract functions
    on the Run tab. You can enter a new greeting next to the updateMessage button
    and click the button to update the message. Since Ethereum network storage is
    required to store the updated message, you will again be prompted to pay a gas
    fee through Metamask.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Remix连接到你的部署合约，它会在运行标签页上显示合约函数。你可以在更新消息按钮旁边输入一个新的问候语，然后点击按钮更新消息。由于需要以太坊网络存储来存储更新后的消息，你将再次通过MetaMask被提示支付燃料费。
- en: Once the network confirms the message update, you will again see a confirmation
    message ([Figure 4.10](ch04.xhtml#ch04fig10)). After the `updateMessage()` method
    is confirmed, you can call `sayHello()` from Remix ([Figure 4.11](ch04.xhtml#ch04fig11)),
    and you will see the updated message. The `sayHello()` function does not alter
    the blockchain state. It can be executed by a local node connected to Remix and
    does not affect any other node on the network. It can be executed without any
    need for gas fees.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦网络确认了消息更新，你将再次看到一个确认信息([图4.10](ch04.xhtml#ch04fig10))。在`updateMessage()`方法被确认之后，你可以在Remix中调用`sayHello()`([图4.11](ch04.xhtml#ch04fig11))，然后你会看到更新后的消息。`sayHello()`函数不会改变区块链状态。它可以在连接到Remix的本地节点上执行，并且不会影响网络上的任何其他节点。它无需支付任何燃料费即可执行。
- en: '![image](Images/yuan_f04_10.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图像](Images/yuan_f04_10.jpg)'
- en: '**Figure 4.10** Calling the `updateMessage()` method'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**图4.10** 调用`updateMessage()`方法'
- en: '![image](Images/yuan_f04_11.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图像](Images/yuan_f04_11.jpg)'
- en: '**Figure 4.11** Calling the `sayHello()` method'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**图4.11** 调用`sayHello()`方法'
- en: The Remix IDE is easy to use. It is an excellent choice for beginners. As your
    development skill advances, there are additional tools you can use to develop
    and deploy smart contracts. [Chapter 6](ch06.xhtml#ch06) has more details.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Remix IDE易于使用。它是初学者的最佳选择。随着你的开发技能的提升，还有其他工具可供你用来开发和部署智能合约。【第6章](ch06.xhtml#ch06)有更详细的信息。
- en: Web3
  id: totrans-104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Web3
- en: While Remix is a great tool, it is too hard for regular people. To make your
    smart contracts available to the general public, you typically need to build a
    web-based UI. For that, you need the web3 JavaScript library to interact with
    the Ethereum blockchain.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Remix是一个很好的工具，但对于普通人来说太难了。为了让你的智能合约对大众可用，你通常需要构建一个基于网页的用户界面。为此，你需要web3 JavaScript库来与以太坊区块链交互。
- en: '**Note**'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: The dapp tab in BUIDL injects a preconfigured web3 instance into the JavaScript
    program in BUIDL.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: BUIDL中的dapp标签页向BUIDL中的JavaScript程序注入了一个预配置的web3实例。
- en: Once Metamask is installed, it automatically injects a custom instance of the
    web3 object into the page’s JavaScript context. Method calls that require private
    keys will automatically prompt the user to select an account, and Metamask will
    use the selected private key to sign the transaction before sending it to the
    Ethereum network.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了MetaMask，它就会自动将一个自定义的web3对象实例注入到页面的JavaScript上下文中。需要私钥的方法调用将自动提示用户选择一个账户，并且MetaMask将使用选定的私钥签署交易，然后将其发送到以太坊网络。
- en: The overall structure of a web3 dapp is a JavaScript function that starts when
    the web page loads (i.e., the following `onPageLoad()` function). The JavaScript
    function manages the application state and makes function calls to the smart contract
    on the blockchain. Because of network delay and confirmation requirements for
    blockchain operations, all web3 API calls are asynchronous. So, we use the web3
    callback API to handle the return values. Notice that if you need to make one
    smart contract call after another, you must nest those calls. The following code
    snippet shows the structure of the JavaScript function. The `myFunc()` and `anotherFunc()`
    calls can happen in parallel at the same time, while the `secondFunc()` call must
    happen after `myFunc()` returns.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: web3 dapp的整体结构是一个在网页加载时开始的JavaScript函数（即以下的`onPageLoad()`函数）。这个JavaScript函数管理应用状态，并调用区块链上的智能合约函数。由于网络延迟和区块链操作的确认要求，所有的web3
    API调用都是异步的。因此，我们使用web3回调API来处理返回值。请注意，如果你想连续调用一个智能合约，你必须嵌套这些调用。下面的代码片段显示了JavaScript函数的结构。`myFunc()`和`anotherFunc()`调用可以同时以并行方式发生，而`secondFunc()`调用必须在`myFunc()`返回之后发生。
- en: '[Click here to view code image](Images/ch04_images.xhtml#pro4_3)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 【点击此处查看代码图片](Images/ch04_images.xhtml#pro4_3)
- en: '[PRE2]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The “Hello, World!” example, however, does not require complex sequences of
    smart contract function invocations. It just needs to invoke one contract function
    and then update the web UI. The source code for the `helloworld.html` file is
    shown here:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，“Hello, World!”示例并不需要复杂的一系列智能合约函数调用。它只需要调用一个合约函数，然后更新Web UI。`helloworld.html`文件的源代码如下：
- en: '[Click here to view code image](Images/ch04_images.xhtml#pro4_4)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 请点击[此处查看代码图片](Images/ch04_images.xhtml#pro4_4)
- en: '[PRE3]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Notice the `web3.eth.contract(...).at("...")` line. The at() function takes
    the contract’s deployment address on the blockchain as a parameter. You can find
    it on the Run tab’s Deployed Contracts section, as shown in [Figures 4.9](ch04.xhtml#ch04fig9)
    and [4.10](ch04.xhtml#ch04fig10). The contract function takes a JSON structure
    known as the contract’s ABI. You can find that by clicking the Details button
    on the Compile tab. You can copy the entire ABI section to your computer’s clipboard
    by clicking the clipboard icon. Alternatively, the WEB3DEPLOY section’s first
    line of code shows the `contract` function’s ABI parameter all on one line ([Figure
    4.12](ch04.xhtml#ch04fig12)).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意`web3.eth.contract(...).at("...")`这行代码。at()函数需要区块链上的合约部署地址作为参数。您可以在“运行”标签的“已部署合约”部分找到它，如图[4.9](ch04.xhtml#ch04fig9)和[4.10](ch04.xhtml#ch04fig10)所示。合约函数采用一个称为合约ABI的JSON结构。您可以通过在“编译”标签上点击“详情”按钮找到它。您可以通过点击剪贴板图标将整个ABI部分复制到您的计算机剪贴板中。另外，WEB3DEPLOY部分的代码第一行显示了`contract`函数的ABI参数全部放在一行（[图4.12](ch04.xhtml#ch04fig12)）。
- en: '![image](Images/yuan_f04_12.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/yuan_f04_12.jpg)'
- en: '**Figure 4.12** Finding the ABI'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**图4.12** 查找ABI'
- en: The web application now allows users to interact with the “Hello, World!” smart
    contract directly from the Web ([Figure 4.13](ch04.xhtml#ch04fig13)). To submit
    a new message, the app requires Metamask to send gas fees as it calls the `updateMessage()`
    function on the contract. Notice that all web3 functions are nested and invoked
    asynchronously. You can read more about dapp development in [Chapter 7](ch07.xhtml#ch07).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Web应用程序允许用户直接从Web与“Hello, World!”智能合约互动（[图4.13](ch04.xhtml#ch04fig13)）。要提交新消息，应用程序需要MetaMask发送燃气费，因为它调用合约上的`updateMessage()`函数。注意所有的web3函数都是嵌套的，并异步调用。您可以在第7章中了解更多关于dapp开发的内容。
- en: '![image](Images/yuan_f04_13.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/yuan_f04_13.jpg)'
- en: '**Figure 4.13** Using the Metamask wallet to write to a contract'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**图4.13** 使用MetaMask钱包向合约写入'
- en: Using Metamask with web3.js is probably the best way to get started with Ethereum
    application development. But for the average web user, installing and using Metamask
    is a significant barrier of entry. As you have seen, the BUIDL IDE provides a
    light-weight wallet on the dapp web page, which is probably sufficient for users
    who just need to pay gas for their interactions with the Ethereum blockchain.
    Or, we could design the application so that a centralized server pays for gas
    on behalf of users (see [Chapter 8](ch08.xhtml#ch08)).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 使用MetaMask和web3.js可能是开始以太坊应用开发的最好方式。但对于普通Web用户来说，安装和使用MetaMask是一个重要的入门门槛。正如你所看到的，BUIDL
    IDE在dapp网页上提供了一个轻量级的钱包，这对于只需要为与以太坊区块链的互动支付燃气费的用户来说可能已经足够了。或者，我们可以设计应用程序，使中心化服务器代表用户支付燃气费（见第8章）。
- en: Conclusion
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结论
- en: In this chapter, I explained how to build, deploy, and use a smart contract
    on Ethereum-compatible blockchains. We used tools such as Metamask, Remix, and
    web3 to get started. In the next several chapters, we will explore the key concepts
    behind Ethereum, software tools involved in its operation, inner workings of smart
    contracts, alternative development tools, and the software stack for decentralized
    applications. We will tie everything together with a new dapp that showcases the
    capability of smart contracts in [Chapter 16](ch16.xhtml#ch16).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我解释了如何在以太坊兼容的区块链上构建、部署和使用智能合约。我们使用了MetaMask、Remix和web3等工具来开始操作。在接下来的几章中，我们将探讨以太坊背后的关键概念、涉及其运作的软件工具、智能合约的内部工作原理、替代开发工具以及去中心化应用的软件堆栈。我们将在第16章中通过一个新的dapp来展示智能合约的能力，并将所有内容整合在一起。
- en: 5. Concepts and Tools
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5. 概念与工具
- en: In the previous chapter, I showed you how to build, deploy, and interact with
    an Ethereum smart contract. However, by focusing on graphical user interface (GUI)
    tools, we have also left many concepts and points unexplained.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我向您展示了如何构建、部署和与以太坊智能合约互动。然而，通过专注于图形用户界面（GUI）工具，我们也留下了许多概念和观点未解释。
- en: In this chapter, I will explain how to run and interact with an Ethereum node.
    In the process, you will learn critical concepts behind the design, implementation,
    and operation of the Ethereum blockchain. Those concepts also apply to Ethereum-compatible
    blockchains.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将解释如何运行并与以太坊节点交互。在这个过程中，你将学习到以太坊区块链设计、实现和运营背后的关键概念。这些概念也适用于与以太坊兼容的区块链。
- en: Ethereum Wallet and Basic Concepts
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 以太坊钱包和基本概念
- en: To use Ethereum, you first need an Ethereum wallet to hold your ETH coins. Like
    Bitcoin, anyone can create an “account” on the Ethereum blockchain to hold and
    transact ETH coins. An account is uniquely identified by a pair of public and
    private keys. A *key* is a long string of seemingly random numbers and characters.
    The key pair can be randomly generated on your own computer.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用以太坊，你首先需要一个以太坊钱包来存放你的 ETH 币。与比特币一样，任何人都可以在以太坊区块链上创建一个“账户”来持有和交易 ETH 币。账户由一对公钥和私钥唯一标识。*密钥*是一长串看似随机的数字和字符。密钥对可以在您自己的电脑上随机生成。
- en: The Ethereum account number is directly derived from the public key. If someone
    wants to send you some ETHs, all they need is the account number.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以太坊账户号码直接从公钥派生。如果有人想给你一些 ETH，他们需要的只是账户号码。
- en: The private key is used to identify the owner of this account. When you need
    to move ETH out of the account (i.e., to spend it or transfer to another account),
    you will need the private key. Without the private key, the Ethereum miners will
    deem the transaction invalid and refuse to include it in the blockchain.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 私钥用于标识此账户的所有者。当你需要将 ETH 从账户中转出（即花费它或转帐到另一个账户）时，你需要私钥。没有私钥，以太坊矿工会认为交易无效，并拒绝将其包含在区块链中。
- en: Now you see that it is critical to safeguard your private key. If someone else
    gets hold of it, that person will have full authority over the ETHs in that account.
    And if you somehow lose the private key, you will forever lose control over the
    ETHs in your account—the ETHs will remain in the account for the world to see,
    but no one can move or spend them without the private key.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该看到保护你的私钥是多么的关键。如果别人得到了它，那么这个人将拥有该账户中ETH的全部权限。而且，如果你 somehow 丢失了私钥，你将永远失去对账户中ETH的控制权——ETH将留在账户中供全世界查看，但没有私钥，没有人能够移动或花费它们。
- en: 'All the wallet does is store and manage your public/private key pair. It often
    also provides a UI for you to manage ETHs in your account using the underlying
    public/private key pair. The wallet can be a completely stand-alone piece of software
    (or even hardware). Or, it can be a web application that stores your keys on their
    servers. Here are some notable wallets for Ethereum:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 钱包所做的就是存储和管理你的公钥/私钥对。它通常还提供用户界面，以便你可以使用底层的公钥/私钥对来管理账户中的 ETH。钱包可以是一个完全独立的软件（或甚至是硬件）。或者，它可以是一个网络应用程序，它在他们的服务器上存储你的密钥。以下是一些著名的以太坊钱包：
- en: Mist is the official wallet software from the Ethereum development team. You
    can install and run it on your own computer. It is more than just a wallet, though;
    it is a “blockchain browser” that includes a full Ethereum node. For example,
    you can upload smart contract code using Mist. That also means Mist requires more
    than 4GB of RAM and more than 100GB of hard drive space to run. It takes 24 to
    48 hours for Mist to start the first time as it needs to download the entire blockchain
    history.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mist 是以太坊开发团队官方的钱包软件。你可以在自己的电脑上安装并运行它。它不仅仅是一个钱包，更是一个“区块链浏览器”，包括一个完整的以太坊节点。例如，你可以使用
    Mist 上传智能合约代码。这也意味着 Mist 需要超过 4GB 的 RAM 和超过 100GB 的硬盘空间来运行。Mist 需要 24 到 48 小时来启动第一次，因为它需要下载整个区块链历史。
- en: Parity is another fully featured GUI Ethereum client. It competes against Mist.
    It is supposed to be faster than Mist. But still, it needs to download the entire
    blockchain to run a full Ethereum node.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Parity 是另一个功能全面的 GUI 以太坊客户端。它与 Mist 竞争。它应该比 Mist 快。但是，仍然需要下载整个区块链来运行一个完整的以太坊节点。
- en: Metamask, covered in [Chapter 4](ch04.xhtml#ch04), is a Chrome-based wallet.
    It stores the private keys on your computer with the Chrome browser. Hence, physical
    security of your computer is important for Metamask wallets.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Metamask，在[第 4 章](ch04.xhtml#ch04)中介绍，是一个基于 Chrome 的钱包。它将私钥存储在您使用 Chrome 浏览器的电脑上。因此，对
    Metamask 钱包来说，电脑的物理安全很重要。
- en: The imToken mobile app is a wallet for your smartphone. You can create key pairs
    (accounts) in the app and use the app to send and receive ETH to and from your
    accounts in the wallet. The imToken app does not download the blockchain itself.
    It starts instantly and is ready for use.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: imToken 移动应用程序是一个智能手机的钱包。你可以在应用程序中创建密钥对（账户），并使用该应用程序将 ETH 发送到或从钱包中的账户接收。imToken
    应用程序本身不下载区块链。它即刻启动，并准备好使用。
- en: Tezer and Ledger are USB key-sized hardware devices that store and manage your
    keys. They typically work in tandem with a computer program. The computer program
    provides the UI to check balances and create transactions. When it needs to sign
    a transaction, it passes to the USB device to complete it. The private key never
    leaves the USB device.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tezer 和 Ledger 是尺寸与 USB 密钥相当的硬件设备，用于存储和管理你的密钥。它们通常与计算机程序协同工作。计算机程序提供 UI 以检查余额和创建交易。当它需要签署一个交易时，它将其传递到
    USB 设备以完成交易。私钥从未离开 USB 设备。
- en: Coinbase is a web-based wallet, which also provides banking services to convert
    your ETHs to and from U.S. dollars. Almost all crypto exchanges have wallets for
    you to deposit and withdraw coins.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Coinbase 是一个基于网页的钱包，同时也提供银行服务，用于将你的 ETH 转换成或从美元中提取。几乎所有的加密货币交易所都为你提供钱包，用于存入和提取货币。
- en: '**Note**'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**注解**'
- en: If you are running a wallet application on your own PC/mobile/dedicated hardware
    device, you must be responsible for the physical safety of the device. Do not
    lose your private key!
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在自己的 PC/移动设备/专用硬件设备上运行钱包应用程序，你必须负责设备的物理安全。不要丢失你的私钥！
- en: '**Note**'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**注解**'
- en: Ethereum-compatible blockchains also have their own wallet applications. For
    example, the CyberMiles blockchain has its own Metamask-like Chrome extension
    wallet, as well as a stand-alone mobile wallet application, called CyberMiles
    App, which can run web3-based dapps. Learn more in [Appendix A](app.xhtml#app).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 与以太坊兼容的区块链也有自己的钱包应用程序。例如，CyberMiles 区块链有一个类似于 Metamask 的 Chrome 扩展钱包，以及一个独立的移动钱包应用程序，称为
    CyberMiles App，它可以运行基于 web3 的 dapp。详情请见 [附录 A](app.xhtml#app)。
- en: If the wallet manages only the public/private key pairs, what about the coins
    and tokens stored in those accounts? Are your coins in your wallet? The answer
    is no, your tokens or coins are not in your wallet. Remember that the blockchain
    is a ledger system. It records all the transactions and balances associated with
    all accounts in the system. So, the wallet needs to manage only your account credentials,
    and the tokens or coins in your account can be found on the blockchain itself.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果钱包只管理公/私钥对，那么存储在这些账户中的硬币和代币怎么办？你的货币在钱包里吗？答案是不是，你的代币或货币不在你的钱包里。记住，区块链是一个账本系统。它记录了系统中所有账户的交易和余额。所以，钱包只需要管理你的账户凭据，而你账户中的代币或货币可以在区块链本身上找到。
- en: Etherscan
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Etherscan
- en: The Etherscan web site is a useful tool to look into the internal states of
    the Ethereum blockchain. You can use it to look up and review every transaction
    recorded on the blockchain and, by extension, the balance and history of every
    account. On its front page, you can see the latest blocks and the transactions
    within them ([Figure 5.1](ch05.xhtml#ch05fig1)).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊区块链的内部状态可以通过 Etherscan 网站这个有用的工具来查看。你可以用它来查询和审查区块链上记录的每一笔交易，以及由此延伸出的每个账户的余额和历史。在该网站首页，你可以看到最新的区块及其内的交易（[图
    5.1](ch05.xhtml#ch05fig1)）。
- en: '![image](Images/yuan_f05_01.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/yuan_f05_01.jpg)'
- en: '**Figure 5.1** Latest blocks and transactions in Etherscan'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 5.1** Etherscan 中的最新区块和交易'
- en: '**Note**'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**注解**'
- en: Most blockchains also have their own blockchain explorer. For example, the CyberMiles
    public blockchain has [https://www.cmttracking.io/](https://www.cmttracking.io/),
    which shows not only transactions but also data related to its delegated proof
    of stake operations. Learn more in the Appendix.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数区块链也有自己的区块链浏览器。例如，CyberMiles 公共区块链有 [https://www.cmttracking.io/](https://www.cmttracking.io/)，它不仅显示交易，还显示与它的委托证明权益操作相关的数据。详情请见附录。
- en: Wallets or exchanges can also display transactions to or from your account.
    Etherscan shows the accounts and fund involved, as well as whether the transaction
    is validated by blockchain miners ([Figure 5.2](ch05.xhtml#ch05fig2)).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 钱包或交易所也可以显示来自或发送到你账户的交易。Etherscan 显示了涉及的账户和资金，以及交易是否得到了区块链矿工的验证（[图 5.2](ch05.xhtml#ch05fig2)）。
- en: '![image](Images/yuan_f05_02.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/yuan_f05_02.jpg)'
- en: '**Figure 5.2** Drilling into a transaction'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 5.2** 深入一个交易'
- en: Of course, as a developer, it is not enough just to have accounts and ETHs.
    We want to run the blockchain software, mine ETH coins, and execute our own smart
    contracts.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，作为一个开发者，仅仅拥有账户和ETH是不够的。我们希望运行区块链软件，挖掘ETH币，并执行我们自己的智能合约。
- en: The TestRPC
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TestRPC
- en: To study and develop applications for Ethereum, you need access to the Ethereum
    Virtual Machine (EVM). Ideally, you would run a full Ethereum node on the blockchain
    and communicate with the blockchain network through that node. However, a full
    Ethereum node is expensive. For developers, it is much easier to get started with
    the TestRPC. I will discuss how to run Ethereum full nodes later in this chapter.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 为了研究和开发以太坊应用程序，您需要访问以太坊虚拟机（EVM）。理想情况下，您会在区块链上运行一个完整的以太坊节点，并通过该节点与区块链网络通信。然而，完整的以太坊节点很昂贵。对于开发者来说，使用TestRPC开始要容易得多。我将在本章后面讨论如何运行以太坊完整节点。
- en: '**Note**'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: To run a full Ethereum node and join the Ethereum network, you will need to
    run a full Ethereum client, download the entire transaction history of the Ethereum
    blockchain (more than 100GB worth of data), and then start “mining” ETH to participate
    in the process of validating transactions and creating new blocks on the blockchain.
    This is a big commitment and requires a significant amount of computing resources.
    Even then, you are unlikely to mine any ETH successfully—with ETH traded at above
    $150, mining competition is fierce. Since most tasks on the public Ethereum blockchain
    require ETH to complete, you will need to purchase ETH just to start experimenting
    with it. Again, at $150+ per ETH, that is an expensive learning process.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行一个完整的以太坊节点并加入以太坊网络，您需要运行一个完整的以太坊客户端，下载以太坊区块链的全部交易历史（超过100GB的数据），然后开始“挖掘”ETH，以参与验证交易和区块链上创建新区块的过程。这是一个很大的承诺，需要大量的计算资源。即便如此，您成功挖掘ETH的可能性也不大——ETH的交易价格超过150美元，挖掘竞争非常激烈。由于以太坊区块链上的大多数任务都需要ETH来完成，您需要购买ETH
    just to start experimenting with it。再次，每个ETH超过150美元，这是一个昂贵的学习过程。
- en: For developer testing of Ethereum application programming interface (API) functions
    and smart contract programming, you can use a simulator that simply answers all
    Ethereum API calls but does not incur the cost of actually building a blockchain
    network. The TestRPC is just such a simulator. The TestRPC was originally developed
    as a volunteer open source project. It was later acquired by the company behind
    the open source Truffle framework for smart contract development (renamed to Ganache
    CLI; see [https://github.com/trufflesuite/ganache-cli](https://github.com/trufflesuite/ganache-cli)).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试以太坊应用程序编程接口（API）函数和智能合约编程，您可以使用一个简单地回答所有以太坊API调用但不会实际构建区块链网络的模拟器。TestRPC就是这样一款模拟器。TestRPC最初是一个志愿者开源项目开发的。后来，它被开源Truffle智能合约开发框架背后的公司收购，更名为Ganache
    CLI（参见[https://github.com/trufflesuite/ganache-cli](https://github.com/trufflesuite/ganache-cli))。
- en: 'You should first make sure that node.js and its package manager npm, are installed
    on your machine. You can install them from [https://www.npmjs.com/get-npm](https://www.npmjs.com/get-npm).
    On most Linux distributions, you can use the system package manager to install
    them as well. For example, the following command installs node.js and npm on a
    CentOS/RedHat/Fedora Linux system:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 您首先应该确保node.js及其包管理器npm已安装在您的机器上。您可以从[https://www.npmjs.com/get-npm](https://www.npmjs.com/get-npm)安装它们。在大多数Linux发行版上，您还可以使用系统包管理器来安装它们。例如，以下命令在CentOS/RedHat/Fedora
    Linux系统上安装node.js和npm：
- en: '[Click here to view code image](Images/ch05_images.xhtml#pro5_1)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击此处查看代码图片](Images/ch05_images.xhtml#pro5_1)'
- en: '[PRE4]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Next, let’s install the Ganache CLI using the npm package manager.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们使用npm包管理器安装Ganache CLI。
- en: '[Click here to view code image](Images/ch05_images.xhtml#pro5_2)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击此处查看代码图片](Images/ch05_images.xhtml#pro5_2)'
- en: '[PRE5]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You can start the TestRPC server from the command line. It will randomly create
    ten accounts (pairs of public key addresses and private keys). All the accounts
    are unlocked by default for easy testing.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从命令行启动TestRPC服务器。它会随机创建十个账户（公钥地址和私钥的对）。所有账户默认都是解锁的，以便于测试。
- en: '[Click here to view code image](Images/ch05_images.xhtml#pro5_3)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击此处查看代码图片](Images/ch05_images.xhtml#pro5_3)'
- en: '[PRE6]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You can start the TestRPC node with the same set of accounts every time, and
    you can give each account an initial balance as well.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以每次使用相同的一组账户启动TestRPC节点，并且还可以为每个账户设置一个初始余额。
- en: '[Click here to view code image](Images/ch05_images.xhtml#pro5_4)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击此处查看代码图片](Images/ch05_images.xhtml#pro5_4)'
- en: '[PRE7]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The TestRPC is a fully featured Ethereum simulator. It is much faster than any
    live Ethereum node because it does not perform the actual work of creating, mining,
    and synchronizing blocks. That makes it ideally suited for fast turnaround development
    cycles.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: TestRPC是一个功能齐全的以太坊模拟器。它比任何实时的以太坊节点都要快，因为它不执行创建、挖矿和同步块的实际工作。这使得它非常适合快速周转的开发周期。
- en: Interacting with Ethereum via GETH
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过GETH与以太坊交互
- en: Once the TestRPC node starts or the full Ethereum node is synchronized to the
    blockchain, you can use the GETH program to connect to it and send commands and
    interactions to the network. All you need to do is to attach the GETH command
    to the node by specifying the node’s IP address. If the node is running locally
    (e.g., a TestRPC node on the local machine), you can simply use `localhost` for
    the IP address.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦TestRPC节点启动或完整的以太坊节点与区块链同步，您可以使用GETH程序连接到它并发送命令和与网络的交互。您需要做的就是通过指定节点的IP地址附加GETH命令。如果节点在本地运行（例如，本地机器上的TestRPC节点），您只需将IP地址设置为`localhost`即可。
- en: '[Click here to view code image](Images/ch05_images.xhtml#pro5_5)'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击此处查看代码图片](Images/ch05_images.xhtml#pro5_5)'
- en: '[PRE8]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: GETH opens an interactive console in the new terminal, and you can use the Ethereum
    JavaScript API to access the blockchain. For instance, the following commands
    will create a new account to hold virtual currency on this network. Just repeat
    it a few times, and you will see a few accounts in the `eth.accounts` list. As
    mentioned earlier, each account consists of a pair of private and public keys.
    Only the public key is recorded on the blockchain in every transaction that involves
    this account.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: GETH在新终端中打开一个交互式控制台，您可以使用以太坊JavaScript API访问区块链。例如，以下命令将在该网络上创建一个新账户以持有虚拟货币。只需重复几次，您就会在`eth.accounts`列表中看到几个账户。如前所述，每个账户都由一对私钥和公钥组成。只在涉及此账户的每笔交易中记录公钥。
- en: '[Click here to view code image](Images/ch05_images.xhtml#pro5_6)'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击此处查看代码图片](Images/ch05_images.xhtml#pro5_6)'
- en: '[PRE9]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When you create or unlock accounts from the GETH console, the private key of
    the account is stored in the keystore file on the attached node’s file system.
    On a live Ethereum node (i.e., not the TestRPC), you can start mining and deposit
    the ethers you mine to one of your accounts. For the TestRPC, you will have ETHs
    in your initial accounts, and you can skip this step.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当您从GETH控制台创建或解锁账户时，账户的私钥存储在附加节点的文件系统上的keystore文件中。在实时以太坊节点（即不是TestRPC）上，您可以开始挖矿并将您挖出的以太币存入您的一个账户中。对于TestRPC，您将会在初始账户中有ETH，您可以跳过此步骤。
- en: '[Click here to view code image](Images/ch05_images.xhtml#pro5_7)'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击此处查看代码图片](Images/ch05_images.xhtml#pro5_7)'
- en: '[PRE10]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Next, you can send some of your ethers from one account to another. If your
    GETH console is attached to a live Ethereum node, you will need access to the
    sender account’s private key via the keystore and passphrase on the node. If you
    are attached to TestRPC either via `localhost` or remotely, you can skip the account
    unlocking calls, as all accounts are unlocked by default in the TestRPC. On a
    console attached to a live Ethereum node, if you do not call the `unlockAccount()`
    method first, the `sendTransaction()` method will ask for your passphrase to unlock
    the account for you.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您可以将一些您的以太币从一个账户发送到另一个账户。如果您的GETH控制台附着在实时的以太坊节点上，您需要通过节点上的keystore和密码访问发送者账户的私钥。如果您通过`localhost`或远程连接到TestRPC，您可以跳过账户解锁调用，因为TestRPC中所有账户默认都是解锁的。在附着在实时以太坊节点的控制台中，如果您没有首先调用`unlockAccount()`方法，`sendTransaction()`方法将要求您输入密码以为您解锁账户。
- en: '[Click here to view code image](Images/ch05_images.xhtml#pro5_8)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击此处查看代码图片](Images/ch05_images.xhtml#pro5_8)'
- en: '[PRE11]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The last line is the transaction ID for the transaction to send 0.05 ETH between
    the two accounts. Using a tool like Etherscan, you will be able to see a record
    of this transaction on the blockchain.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行是发送两个账户之间0.05 ETH交易的事务ID。使用像Etherscan这样的工具，您将能够在区块链上看到这笔交易的记录。
- en: Interacting with Ethereum via web3
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过web3与以太坊交互
- en: The GETH interactive console is convenient to test and experiment with the Ethereum
    blockchain using the JavaScript API methods. But to access the Ethereum blockchain
    from an application, you can use the JavaScript API directly from a web page.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: GETH交互式控制台方便地使用JavaScript API方法测试和实验以太坊区块链。但是，要从应用程序访问以太坊区块链，您可以直接从网页使用JavaScript
    API。
- en: The web page in [Figure 5.3](ch05.xhtml#ch05fig3) shows an application that
    queries an Ethereum account’s balance. The user enters an account address, and
    the JavaScript API retrieves and displays the account balance.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图5.3](ch05.xhtml#ch05fig3)中的网页显示了一个查询以太坊账户余额的应用程序。用户输入一个账户地址，JavaScript API检索并显示账户余额。
- en: '![image](Images/yuan_f05_03.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/yuan_f05_03.jpg)'
- en: '**Figure 5.3** A demo page for web3.js'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**图5.3** web3.js的演示页面'
- en: Via the web3.js library provided by the Ethereum project, the JavaScript on
    the page first connects to an Ethereum node. Here, you can put in your own Ethereum
    node (e.g., `http://node.ip.addr:8545`) or a public node INFURA provides (see
    the following example). For a local TestRPC node, you can simply use the `http://localhost:8545`
    URL.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以太坊项目提供的web3.js库，页面上的JavaScript首先连接到一个以太坊节点。在这里，你可以输入你自己的以太坊节点（例如`http://node.ip.addr:8545`）或INFURA提供的公共节点（请参见以下示例）。对于本地的TestRPC节点，你可以简单地使用`http://localhost:8545`这个URL。
- en: '[Click here to view code image](Images/ch05_images.xhtml#pro5_9)'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击此处查看代码图片](Images/ch05_images.xhtml#pro5_9)'
- en: '[PRE12]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Then the JavaScript uses web3.js functions to query the address. These are the
    same JavaScript method calls we can make in the GETH console.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，JavaScript使用web3.js函数来查询地址。这些函数就是我们可以在GETH控制台执行的相同的JavaScript方法调用。
- en: '[Click here to view code image](Images/ch05_images.xhtml#pro5_10)'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击此处查看代码图片](Images/ch05_images.xhtml#pro5_10)'
- en: '[PRE13]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Our demo application queries the account balance. The balance is public information
    and does not require any account private key. If your web3.js application needs
    to send ETH from one account to another, you will need access to the sending account’s
    private key. There are several ways to do this, and I will cover them in [Chapter
    8](ch08.xhtml#ch08).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的演示应用程序查询账户余额。余额是公开信息，不需要任何账户私钥。如果你的web3.js应用程序需要从一个账户发送ETH到另一个账户，你需要访问发送账户的私钥。有几种方法可以做到这一点，我将在[第8章](ch08.xhtml#ch08)中介绍它们。
- en: Running an Ethereum Node
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行以太坊节点
- en: While the TestRPC is great for beginners, to truly understand the Ethereum blockchain,
    you should run your own node. Only through your own node can you examine the blocks
    and access all the functionalities the blockchain offers. In this section, I will
    discuss how to run a node on the Ethereum public network. It requires a significant
    amount of computing resources, such as a 24/7 available server and Internet connection,
    as well as at least a few hundred gigabytes of disk space to store the blockchain
    data. If you are on a development team (e.g., in a company), it is sufficient
    to run a single node for all the team members to access. To get started, download
    the official Ethereum client software GETH to your computer.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管TestRPC对于初学者来说很不错，但要真正理解以太坊区块链，你应该运行自己的节点。只有通过自己的节点，你才能检查区块并访问区块链提供的所有功能。在本节中，我将讨论如何在以太坊公共网络上运行一个节点。这需要相当大的计算资源，比如一台全天候可用的服务器和互联网连接，以及至少几百GB的磁盘空间来存储区块链数据。如果你是在一个开发团队（例如，在公司里），为了供所有团队成员访问，运行一个节点就足够了。开始使用时，请将官方以太坊客户端软件GETH下载到你的电脑上。
- en: '[Click here to view code image](Images/ch05_images.xhtml#pro5_11)'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击此处查看代码图片](Images/ch05_images.xhtml#pro5_11)'
- en: '[PRE14]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The official GETH program is written in the GO programming language. It is simply
    a compiled binary executable program that you can run from the command line.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 官方的GETH程序是用GO编程语言编写的。它只是一个编译后的二进制可执行程序，你可以在命令行中运行。
- en: '[PRE15]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If you start GETH with all the default options, you will be connected to the
    public Ethereum blockchain. To start the node in noninteractive node and keep
    it running in the background after the current user logs out, use NOHUP.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用所有默认选项启动GETH，你将连接到公共以太坊区块链。为了以非交互方式启动节点并在当前用户退出后继续在后台运行，请使用NOHUP。
- en: '[PRE16]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: It will take hours and many gigabytes of RAM and disk space to download and
    sync the entire blockchain history. So, it is probably a good idea to start GETH
    on the official Ethereum test network. That will cut down on the initial startup
    time and resources significantly, but still you need to prepare to wait for several
    hours even to sync the testnet.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 下载并同步整个区块链历史需要数小时以及大量的RAM和磁盘空间。因此，最好是从官方以太坊测试网络开始GETH。这将显著减少初始启动时间和资源，但你仍然需要准备等待几小时来同步测试网络。
- en: '[PRE17]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '**Note**'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: The ether cryptocurrency (ETH) you mine or receive on testnet or your private
    network has no value. It can be used only for network testing purposes. You cannot
    exchange it on the open market.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试网或您的私有网络上挖掘或接收的以太币（ETH）没有价值。它只能用于网络测试目的。您不能在公开市场上交易它。
- en: As I mentioned earlier in this section, you need only one running Ethereum node
    for the entire development team. The GETH client on the running Ethereum node
    manages its own keystore on the machine’s local file system. All the accounts
    created through this node will have their private keys stored in this file, and
    each private key will be protected by a passphrase. The keystore file is located
    in the following directories. You can copy the keystore file to another node and
    access the accounts from the new node. You can also extract the private key from
    the keystore and sign your transactions to access the account from any node on
    the Ethereum blockchain network.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如本节开头我提到的，整个开发团队只需要运行一个以太坊节点。运行中的以太坊节点上的GETH客户端在其本地文件系统上管理自己的密钥库。通过此节点创建的所有账户的私钥都将存储在此文件中，每个私钥都将由一个密码短语保护。密钥库文件位于以下目录中。您可以将密钥库文件复制到另一个节点，并从新节点访问这些账户。您还可以从密钥库中提取私钥，并签署交易以从以太坊区块链网络上的任何节点访问账户。
- en: 'Linux: `~/.ethereum/keystore`'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Linux: `~/.ethereum/keystore`'
- en: 'Mac: `/Library/Ethereum/keystore`'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'macOS: `/Library/Ethereum/keystore`'
- en: 'Windows: `%APPDATA%/Ethereum`'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Windows: `%APPDATA%/Ethereum`'
- en: Companies like INFURA ([https://infura.io/](https://infura.io/)) provide public
    Ethereum nodes on the Internet. This saves you the trouble and significant resources
    required by running a node. However, the public nodes cannot store private keys
    for security reasons. Specifically, you have to use signed transactions to access
    accounts.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 像INFURA这样的公司（[https://infura.io/](https://infura.io/)）在网上提供公共以太坊节点。这省去了运行节点所需的麻烦和大量资源。然而，出于安全原因，公共节点不能存储私钥。具体来说，您必须使用签名交易来访问账户。
- en: Running a Private Ethereum Network
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行私有以太坊网络
- en: 'For developers, it is often a good idea just to start your own private Ethereum
    test network. The following command starts the first node on the private network
    from scratch (i.e., block 0, or the *genesis*):'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 对于开发者来说，启动自己的私有以太坊测试网络通常是个不错的主意。以下命令从零开始（即区块0或*创世纪*）启动私有网络上的第一个节点：
- en: '[PRE18]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '**Note**'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: 'There are many command-line options for geth that you can use to customize
    your private network. For example, you could pass a genesis.json file to the geth
    init command and specify the following: peer nodes on the network, initial coin
    balances for selected accounts, difficulty in mining new coins, and so on.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多命令行选项可以用来定制您的私有网络。例如，您可以向`geth init`命令传递一个`genesis.json`文件，并指定以下内容：网络上的对等节点、所选账户的初始币余额、挖掘新币的难度等。
- en: Running a single node network is oftentimes sufficient for development tasks.
    But sometimes you do need a real network with multiple nodes. To start a new peer
    node, find out the identity of your current (first) node in the interactive console.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 对于开发任务，运行一个单节点网络通常就足够了。但有时你确实需要一个具有多个节点的真实网络。要启动一个新的对等节点，请在交互式控制台中找到您当前（第一个）节点的安全身份。
- en: '[Click here to view code image](Images/ch05_images.xhtml#pro5_12)'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击此处查看代码图片](Images/ch05_images.xhtml#pro5_12)'
- en: '[PRE19]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: With the enode ID, you can start a second peer node from another computer. Notice
    that the [::] in the enode ID is your node’s IP address. So, you will need to
    replace it with the IP address of the first node.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 有了enode ID，您可以在另一台计算机上启动第二个对等节点。请注意enode ID中的`[::]`是您节点的IP地址。因此，您需要将其替换为第一个节点的IP地址。
- en: '[Click here to view code image](Images/ch05_images.xhtml#pro5_13)'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击此处查看代码图片](Images/ch05_images.xhtml#pro5_13)'
- en: '[PRE20]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You can now start more peer nodes. The `bootnodes` parameter can take multiple
    enode addresses separated by commas. Alternatively, you can start each node in
    the console mode, use `admin.nodeInfo` to figure out the enode ID for each, and
    then use `admin.addPeer` to connect each node to each other.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以启动更多的对等节点。`bootnodes`参数可以接受由逗号分隔的多个enode地址。或者，您可以每个节点都以控制台模式启动，使用`admin.nodeInfo`找出每个节点的enode
    ID，然后使用`admin.addPeer`将每个节点相互连接。
- en: '[Click here to view code image](Images/ch05_images.xhtml#pro5_14)'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击此处查看代码图片](Images/ch05_images.xhtml#pro5_14)'
- en: '[PRE21]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Each new node will start by downloading and syncing the complete blockchain
    from the private network. They can all mine ethers and validate transactions on
    the network.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 每个新节点都会通过从私有网络下载并同步完整区块链开始运行。他们都可以在网络上挖掘以太币并验证交易。
- en: Conclusion
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结论
- en: In this chapter, I discussed the basic concepts behind Ethereum and how to set
    up your own private Ethereum blockchain. Of course, Ethereum does much more than
    creating and transacting the ETH cryptocurrency. The core idea of Ethereum is
    the smart contract, which we will explore in the next chapter.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我讨论了以太坊的基本概念以及如何建立你自己的私有以太坊区块链。当然，以太坊所做的不仅仅是创建和交易ETH加密货币。以太坊的核心思想是智能合约，我们将在下一章探讨。
- en: 6. Smart Contracts
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6. 智能合约
- en: The most important feature of the Ethereum blockchain is its ability to execute
    software code known as *smart contracts*. Now, we already have many distributed
    computing networks. Why do we need a blockchain to act as a distributed computer?
    The answer is decentralized and trusted autonomous execution. With the Ethereum
    blockchain, you do not need to trust anyone to correctly execute your code. Instead,
    a community of network participants (Ethereum miners) will all execute your smart
    contract code and reach a consensus that the results are correct.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊区块链最重要的特性是其能够执行名为*智能合约*的软件代码。现在，我们已经有很多分布式计算网络。为什么我们还需要一个区块链作为分布式计算机呢？答案是去中心化和可信的自主执行。有了以太坊区块链，你不需要信任任何人来正确执行你的代码。相反，一个由网络参与者（以太坊矿工）组成的社区将共同执行你的智能合约代码，并达成共识，认为结果是正确的。
- en: In this chapter, I will first revisit the “Hello, World!” smart contract to
    illustrate how an Ethereum smart contract works under the hood. I will then provide
    a high-level overview of the design features of smart contract languages like
    Solidity to help you get a head start on Solidity programming. I will also cover
    how to build and deploy smart contracts using the open source framework and tools.
    While I will continue to cover graphical user interface (GUI) tools, I will focus
    on command-line power tools that are more suitable for professional developers
    in this chapter.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将首先重新访问“Hello, World!”智能合约，以说明以太坊智能合约是如何运行的。然后，我将提供一个高级概述，介绍像Solidity这样的智能合约语言的设计特点，以帮助你快速上手Solidity编程。我还将介绍如何使用开源框架和工具构建和部署智能合约。虽然我将继续涵盖图形用户界面（GUI）工具，但在这章中，我将重点介绍更适合专业开发者的命令行工具。
- en: “Hello, World!” Again
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 再次编写“Hello, World!”
- en: 'The idea behind smart contracts is software code that is, once written, guaranteed
    to get executed correctly. In this section, let’s review a simple smart contract.
    It works as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约背后的想法是软件代码，一旦编写，就能保证被正确执行。在本节中，让我们回顾一个简单的智能合约。它的工作原理如下：
- en: Anyone can submit the smart contract code to the Ethereum blockchain. Ethereum
    miners validate the code, and if most of them agree (i.e., reach consensus), the
    code will be saved on the blockchain. The smart contract now has an address on
    the blockchain, as if it is an account.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何人都可以将智能合约代码提交到以太坊区块链。以太坊矿工验证代码，如果大多数矿工同意（即达成共识），该代码将被保存在区块链上。现在，智能合约在区块链上有一个地址，就像一个账户一样。
- en: Anyone can then call any public method on the smart contract at that blockchain
    address. The blockchain nodes will all execute the code. If most of them agree
    on the results of the code execution, the changes made by the code will be saved
    on the blockchain.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何人都可以调用该区块链地址上的智能合约的公共方法。区块链节点将执行所有代码。如果大多数节点对代码执行的结果达成一致，那么由代码所做的更改将被保存在区块链上。
- en: '**Note**'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: Ethereum network nodes are responsible for executing those smart contracts and
    reaching consensus on the correctness of their results. The nodes perform this
    work in exchange for Ethereum’s native cryptocurrency, called *ether* (ETH), in
    each transaction. The transaction fee, called *gas*, is paid by the “from” account
    specified by the method caller.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊网络节点负责执行这些智能合约，并对它们的结果的正确性达成共识。节点通过执行这项工作，以以太坊的原生加密货币，称为*以太*（ETH），作为每笔交易的报酬。交易费，称为*燃料费*，由方法调用者指定的“来自”账户支付。
- en: In this chapter, I will again use the “Hello, World!” example to further illustrate
    how smart contracts work and how to interact with them using different tools.
    The contract is written in the Solidity programming language. The filename is
    `HelloWorld.sol`. The most important requirement of a smart contract is that it
    must produce the same result when executed on different node computers. That means
    it cannot contain any random functions or even floating-point math as floating-point
    numbers are represented differently on different computer architectures. The Solidity
    language is designed to be completely unambiguous in the programs it expresses.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将继续使用“Hello, World!”示例来进一步说明智能合约是如何工作的，以及如何使用不同的工具与它们进行交互。该合约是用Solidity编程语言编写的。文件名是`HelloWorld.sol`。智能合约最重要的要求是在不同的节点计算机上执行时产生相同的结果。这意味着它不能包含任何随机函数，甚至不能包含浮点数学，因为浮点数在不同的计算机架构上有不同的表示方式。Solidity语言旨在使其表达的程序完全无歧义。
- en: '[Click here to view code image](Images/ch06_images.xhtml#pro6_1)'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击此处查看代码图片](Images/ch06_images.xhtml#pro6_1)'
- en: '[PRE22]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The “Hello, World!” smart contract has two key functions.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约的“Hello, World!”有两个关键功能。
- en: The `sayHello()` function returns a greeting to its caller. The greeting is
    initially set to “Hello, World!” when the smart contract is deployed. It is a
    view method indicating that it does not change the state of the smart contract
    and hence can be executed locally on any Ethereum node without gas fees.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sayHello()`函数将其调用者返回问候。当智能合约部署时，问候最初被设置为“Hello, World!”。它是一个视图方法，表明它不会改变智能合约的状态，因此可以在任何以太坊节点上本地执行，而无需支付燃料费。'
- en: The `updateMessage()` function allows the method caller to change the greeting
    from “Hello, World!” to another message.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`updateMessage()`函数允许调用者将问候从“Hello, World!”更改为另一条信息。'
- en: The “Hello, World!” smart contract maintains an internal state (`helloMessage`)
    that can be modified by the public function `updateMessage()`. The key feature
    of blockchain technology is that each function call is executed by all nodes on
    the network, and any change to the `helloMessage` state must be agreed upon by
    at least the majority of validators or miners on the network before it can be
    recorded on the blockchain. In turn, every change of the `helloMessage` state
    is recorded in the blockchain. Any interested party can review the blocks and
    find out all recorded change histories for `helloMessage`. That level of transparency
    ensures that the smart contract cannot be tampered with.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: “Hello, World!”智能合约维护一个内部状态（`helloMessage`），可以通过公共函数`updateMessage()`进行修改。区块链技术的关键特性是每个函数调用都由网络上的所有节点执行，任何对`helloMessage`状态的更改都必须得到网络上至少大多数验证器或矿工的同意，才能记录在区块链上。反过来，`helloMessage`状态的每一次更改都会记录在区块链上。任何感兴趣的各方都可以查看区块，并找出所有记录的`helloMessage`更改历史。这种透明度确保了智能合约不能被篡改。
- en: It is important to note that the `sayHello()` function can be executed on any
    Ethereum node the caller has access to. It looks up information from the blockchain
    and does not change the blockchain state. It affects no other nodes in the network.
    Hence, the Ethereum blockchain does not require a gas fee for view function calls
    like `sayHello()`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 需要指出的是，`sayHello()`函数可以在调用者有权访问的任何以太坊节点上执行。它从区块链中查找信息，并不会改变区块链的状态。它不会影响网络中的其他节点。因此，以太坊区块链不需要为类似于`sayHello()`的视图函数调用支付燃料费。
- en: On the other hand, the `updateMessage()` function causes state changes across
    all nodes in the Ethereum network. It can take effect only when nodes on the blockchain
    all execute it and reach consensus on the results. Hence, the `updateMessage()`
    function call requires a gas fee. The results of the `updateMessage()` function
    call also takes a rather long time (up to ten minutes on Ethereum) to take effect
    since the blocks containing the results need to be confirmed and added to the
    blockchain by miner nodes.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`updateMessage()`函数会在以太坊网络的所有节点上引起状态变化。它只能在区块链上的节点执行它并对其结果达成共识时生效。因此，`updateMessage()`函数调用需要支付燃料费。`updateMessage()`函数调用的结果也需要相当长的时间（在以太坊上最多十分钟）才能生效，因为包含结果的区块需要由矿工节点确认并添加到区块链中。
- en: Learning Smart Contract Programming
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 学习智能合约编程
- en: This book does not intend to be a Solidity tutorial. Solidity is a JavaScript-like
    language. It is also unique and different from JavaScript in many important ways.
    Details of the Solidity syntax are ever-evolving and outside the scope of this
    book. I encourage you to learn the Solidity language from its official documentation
    at [https://solidity.readthedocs.io/](https://solidity.readthedocs.io/).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 本书无意成为Solidity教程。Solidity是一种类似JavaScript的语言。在许多重要方面，它也与JavaScript不同。Solidity语法的详细信息不断演变，超出了本书的范围。我鼓励你通过官方文档[https://solidity.readthedocs.io/](https://solidity.readthedocs.io/)学习Solidity语言。
- en: However, it is important to understand the high-level design features of Solidity
    as they are generally applicable to all smart contract languages. Understanding
    the design will give you a head start on learning Solidity as its quirkiness will
    now make sense.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，理解Solidity的高级设计特点是重要的，因为它们通常适用于所有智能合约语言。了解设计将使你学习Solidity时有一个良好的开端，因为它的奇特之处现在变得有意义。
- en: Consensus vs. Nonconsensus Code
  id: totrans-253
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 共识与非共识代码
- en: As you have seen from the “Hello, World!” smart contract’s `sayHello()` and
    `updateMessage()` functions, there are clearly two types of code in a smart contract.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在“Hello, World!”智能合约的`sayHello()`和`updateMessage()`函数中所看到的，智能合约中有显然的两种代码类型。
- en: One type of code, like the `updateMessage()` function, requires consensus. These
    functions must be precise and produce deterministic behaviors (i.e., no random
    numbers or floating-point numbers) since all nodes must produce the same results.
    They are also slow, require long confirmation time, and are expensive to execute
    both in terms of computing resources (all nodes must run them) and in gas fees.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种代码类型，如`updateMessage()`函数，需要共识。这些函数必须精确且产生确定性行为（即，没有随机数或浮点数），因为所有节点必须产生相同的结果。它们还慢，需要长时间确认时间，并且在计算资源（所有节点必须运行它们）和燃料费用上执行昂贵。
- en: The other type of code, like the `sayHello()` function, does not require consensus.
    These functions can be executed by a local node and hence do not require gas.
    It is not a problem even if different nodes return different results from the
    same function (i.e., precision loss for floating-point numbers).
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一种代码类型，如`sayHello()`函数，不需要共识。这些函数可以由本地节点执行，因此不需要燃料。即使不同节点从同一个函数返回不同结果（即，浮点数的精度损失）也无妨。
- en: In Solidity variables have the reference types `memory` and `storage` to indicate
    whether the values should be saved on the blockchain. Functions that do not modify
    the blockchain state (nonconsensus) should be labeled as view functions. Functions
    that do not even read the blockchain state (purely computational) should be labeled
    as pure functions.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在Solidity中，变量具有引用类型`memory`和`storage`，用以指示值是否应保存在区块链上。不修改区块链状态（非共识）的函数应被标记为视图函数。甚至不读取区块链状态（纯粹计算）的函数应被标记为纯函数。
- en: It is clear that the virtual machine can provide many more functionalities and
    performance optimizations for nonconsensus code. However, the current design of
    the Solidity language is dominated by the need of consensus code. As a result,
    it lacks many basic features that could be easily provided for the nonconsensus
    part of the system, such as a string library, JSON parser, complex data structure
    support, and so on.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 很显然，虚拟机可以为非共识代码提供许多更多功能和性能优化。然而，Solidity语言的当前设计主要是由共识代码的需求所主导。结果是，它在系统非共识部分缺少许多基础功能，例如字符串库、JSON解析器、复杂数据结构支持等。
- en: I view this as a flaw of Solidity. In the future Ethereum 2.0, the WebAssembly-based
    new virtual machines (including the Second State Virtual Machine) could solve
    this problem by supporting multiple commonly used programming languages for nonconsensus
    code. That would make the blockchain truly a computing platform rather than just
    a decentralized state machine.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为这是Solidity的一个缺陷。在未来的以太坊2.0中，基于WebAssembly的新虚拟机（包括Second State虚拟机）可以通过支持非共识代码的多种常用编程语言来解决这一问题。那将使区块链成为一个真正的计算平台，而不仅仅是去中心化的状态机。
- en: Data Structures
  id: totrans-260
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 数据结构
- en: Besides the primitive types, such as `int, uint`, and `address`, the Solidity
    language supports the `array` data type. In fact, the `string` data type is internally
    implemented as an array. However, the array type is also difficult to work with.
    For example, the computational cost for iterating over an array depends on the
    size of the array. It could be expensive and is difficult to estimate before the
    function execution. That is why Solidity supports only limited string operations
    out of the box.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 除了像`int, uint`和`address`这样的基本类型，Solidity语言还支持`array`数据类型。实际上，`string`数据类型内部是作为数组实现的。然而，数组类型也很难操作。例如，遍历数组的计算成本取决于数组的大小。它可能很昂贵，并且在函数执行之前很难估计。这就是为什么Solidity默认只支持有限的字符串操作。
- en: For structured data, I recommend using the `struct` data type to group multiple
    related data fields. For collections, I recommend using the `mapping` data type
    to build key/value stores. The mapping structure has the advantage of fixed computational
    cost for adding, removing, or looking up elements from the collection.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 对于结构化数据，我建议使用`struct`数据类型来组合多个相关数据字段。对于集合，我建议使用`mapping`数据类型来构建键/值存储。映射结构的优势在于，对于添加、删除或从集合中查找元素，计算成本是固定的。
- en: Function Parameters and Return Values
  id: totrans-263
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 函数参数和返回值
- en: While `struct` and `mapping` are widely used inside smart contracts, you can
    pass only primitive types into and out of contract functions. The contract function’s
    input and return values are both tuples of limited length. Ethereum extension
    (as well as EVM 2.0) projects are working on different ways to relax such constraints,
    especially for nonconsensus view functions.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在智能合约内部广泛使用`struct`和`mapping`，但你只能将基本类型作为合约函数的输入和输出。合约函数的输入和返回值都是有限长度的元组。以太坊扩展（以及EVM
    2.0）项目正在研究不同的方法来放宽此类限制，特别是对于非共识视图函数。
- en: For now, to pass complex data objects to a function, you could encode the data
    into a string format (e.g., a CSV) and then parse the string inside the contract.
    However, because of the lack of high-performance string libraries in Solidity,
    this is also difficult and gas expensive.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，要向一个函数传递复杂的数据对象，你可以将数据编码成字符串格式（例如，CSV格式），然后在合约内部解析这个字符串。然而，由于Solidity中缺乏高性能的字符串库，这也很困难且消耗大量GAS。
- en: Payable Functions
  id: totrans-266
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 可支付函数
- en: One of the unique features of a smart contract language is functions that can
    receive payments. In Solidity, you can label any contract function as `payable`.
    A `payable` function automatically requires consensus. It can be invoked only
    via a transaction that gets recorded in the blockchain. The caller can attach
    an ETH `value` to the transaction. The ETHs will be transferred from the caller’s
    address to the contract address upon execution of this function.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约语言的独特特性之一就是可以接收支付的函数。在Solidity中，你可以将任何合约函数标记为`payable`。一个`payable`函数会自动要求共识。它只能通过记录在区块链上的交易来调用。调用者可以在交易中附上ETH`value`。在执行这个函数时，ETH将从调用者的地址转移到合约地址。
- en: The contract can also have a default `payable` function. It is called when an
    address makes a regular ETH transfer to the contract address without making an
    explicit function call.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 合约也可以有一个默认的`payable`函数。当一个地址不通过显式的函数调用，而是向合约地址进行常规ETH转账时，会调用这个函数。
- en: The contract can access its own fund through the `this.balance()` function and
    transfer funds to other addresses through the `<address>.transfer(amount)` function.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 合约可以通过`this.balance()`函数访问自己的资金，并通过`<address>.transfer(amount)`函数将资金转给其他地址。
- en: Calling Other Contracts
  id: totrans-270
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 调用其他合约
- en: A contract function can call functions in another contract deployed at a different
    address. The caller contract needs to know the callee contract’s ABI and address.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 合约函数可以调用部署在另一个地址上的另一个合约中的函数。调用者合约需要知道被调用合约的ABI和地址。
- en: This feature allows us to build proxy contracts, where function implementations
    can be changed or upgraded because we can update the proxy to point to different
    implementing contracts. Some well-known smart contracts, such as the GUSD contract,
    are written this way.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特性允许我们构建代理合约，其中函数实现可以更改或升级，因为我们可以更新代理以指向不同的实现合约。一些著名的智能合约，如GUSD合约，就是这样编写的。
- en: In this section, I discussed some unique design features of the Solidity language,
    compared with traditional programming languages. It should get you started on
    learning Solidity. As a first-generation smart contract programming language,
    Solidity has many shortcomings, especially with regard to nonconsensus functions
    and programs. Ethereum extensions such as the Lity project are working on better
    solutions (see [Chapter 14](ch14.xhtml#ch14)).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我讨论了Solidity语言与传统编程语言相比的一些独特设计特点。这应该能帮助您开始学习Solidity。作为第一代智能合约编程语言，Solidity有很多不足之处，特别是在非共识函数和程序方面。以太坊扩展，如Lity项目，正在努力寻求更好的解决方案（参见[第14章](ch14.xhtml#ch14)）。
- en: Building and Deploying the Smart Contract
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建和部署智能合约
- en: In this section, I will use the “Hello, World!” contract as an example to show
    how to build and deploy an Ethereum smart contract. Let’s start with the standard
    Solidity tools.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将使用“Hello, World!”合约作为示例，展示如何构建和部署以太坊智能合约。让我们从标准的Solidity工具开始。
- en: Solidity Tools
  id: totrans-276
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Solidity工具
- en: 'While you can install and use a JavaScript version of the Solidity compiler,
    I recommend you install the fully featured C++ version. You can do it easily with
    Linux distributions’ package managers. Here is how to do it using the `apt-get`
    package manager on Ubuntu:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您可以安装和使用JavaScript版本的Solidity编译器，但我建议您安装功能齐全的C++版本。您可以使用Linux发行版的包管理器轻松完成。以下是使用Ubuntu上的`apt-get`包管理器进行安装的方法：
- en: '[Click here to view code image](Images/ch06_images.xhtml#pro6_2)'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '![image](Images/ch06_images.xhtml#pro6_2)'
- en: '[PRE23]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `solc` command takes a Solidity source file as input and outputs the compiled
    bytecode as well as the ABI definition as a JSON string.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`solc`命令接受一个Solidity源文件作为输入，输出编译后的字节码以及作为JSON字符串的ABI定义。'
- en: '[PRE24]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The output from the command is a large JSON structure that gives information
    about compiler errors and results. You can find the following under the HelloWorld
    contract:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的输出是一个大型JSON结构，提供了有关编译器错误和结果的信息。您可以在HelloWorld合约下找到以下内容：
- en: The compiled EVM bytecode as a hex string in the evm/bytecode/object field
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在evm/bytecode/object字段中作为十六进制字符串编译的EVM字节码
- en: The associated ABI definition in the `abi` field
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`abi`字段中关联的ABI定义'
- en: The recommended gas costs in the `gasEstimates` field
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gasEstimates`字段中推荐的燃气成本'
- en: 'Next, you can deploy this contract from GETH and obtain an address on the blockchain
    for the deployed contract instance. You can run the following command in the GETH
    console attached to an Ethereum blockchain network or the TestRPC:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您可以从GETH部署此合约，并在部署的合约实例上获得区块链地址。您可以在连接到以太坊区块链网络或TestRPC的GETH控制台中运行以下命令：
- en: '[Click here to view code image](Images/ch06_images.xhtml#pro6_3)'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击此处查看代码图片](Images/ch06_images.xhtml#pro6_3)'
- en: '[PRE25]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Once the contract is mined and recorded on the blockchain, you should be able
    to query for its address.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦合约被挖掘并记录在区块链上，您应该能够查询到其地址。
- en: '[PRE26]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You need to record and save the ABI and contract address. As you have seen,
    those two pieces of information are needed when you retrieve this contract instance
    later in another program.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要记录并保存ABI和合约地址。正如您所看到的，当您在另一个程序中稍后检索此合约实例时，这两条信息是必需的。
- en: The BUIDL Integrated Development Environment (IDE)
  id: totrans-292
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: BUIDL集成开发环境（IDE）
- en: While the command-line compiler tool is fundamental to Solidity smart contract
    development, many developers prefer to use graphical user interface (GUI) tools
    for a more visual development experience. The BUIDL IDE is by far the easiest
    GUI tool to compile and deploy Solidity smart contracts.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然命令行编译工具是Solidity智能合约开发的基础，但许多开发者更喜欢使用图形用户界面（GUI）工具以获得更直观的开发体验。到目前为止，BUIDL
    IDE是编译和部署Solidity智能合约最容易的GUI工具。
- en: First, you need to configure BUIDL to work with Ethereum blockchains via the
    **Providers** tab (see [Figure 6.1](ch06.xhtml#ch06fig1)). Then, send a small
    amount of ETH (e.g., 0.1 ETH) to the default address on the **Accounts** tab so
    that BUIDL can pay gas fees to Ethereum on your behalf. See more details in [Chapter
    4](ch04.xhtml#ch04).
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要通过**Providers**标签配置BUIDL以与以太坊区块链配合工作（参见[图6.1](ch06.xhtml#ch06fig1)）。然后，在**Accounts**标签上向默认地址发送少量ETH（例如，0.1
    ETH），以便BUIDL可以代表您支付以太坊的燃气费。更多详细信息请参见[第4章](ch04.xhtml#ch04)。
- en: '![image](Images/yuan_f06_01.jpg)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/yuan_f06_01.jpg)'
- en: '**Figure 6.1** Configuring BUIDL to work with Ethereum'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '**图6.1** 配置BUIDL以配合以太坊工作'
- en: Next, type your Solidity code into the editor in the contract section, and hit
    the **Compile** button. You will be able to see the compiled ABI and bytecode
    in the side panel (see [Figure 6.2](ch06.xhtml#ch06fig2)).
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在合约部分将您的Solidity代码输入到编辑器中，然后点击**编译**按钮。您将能够在侧边栏看到编译后的ABI和字节码（见[图 6.2](ch06.xhtml#ch06fig2)）。
- en: '![image](Images/yuan_f06_02.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/yuan_f06_02.jpg)'
- en: '**Figure 6.2** Compiled artifacts from BUIDL'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 6.2** BUIDL编译后的工件'
- en: Of course, you can also copy the ABI and bytecode and paste them into your other
    tools to use.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您还可以复制ABI和字节码并粘贴到您的其他工具中使用。
- en: The Remix IDE
  id: totrans-301
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Remix 集成开发环境
- en: 'Remix is a web-based IDE for Solidity smart contracts from the Ethereum Foundation.
    You can access it in your web browser: [http://remix.ethereum.org/](http://remix.ethereum.org/).'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: Remix 是由以太坊基金会提供的基于网页的Solidity智能合约IDE。您可以通过网页浏览器访问它：[http://remix.ethereum.org/](http://remix.ethereum.org/)。
- en: You can simply enter Solidity source code into the text box, and the IDE will
    compile it for you. The compiler output is shown by clicking the **Details** button
    next to the contract name ([Figure 6.3](ch06.xhtml#ch06fig3)).
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 您只需将Solidity源代码输入文本框，IDE就会为您编译。编译输出通过点击合约名称旁边的**详情**按钮查看（[图 6.3](ch06.xhtml#ch06fig3)）。
- en: '![image](Images/yuan_f06_03.jpg)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/yuan_f06_03.jpg)'
- en: '**Figure 6.3** The Remix IDE compiles a Solidity smart contract.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 6.3** Remix集成开发环境编译Solidity智能合约。'
- en: As you can see in [Figure 6.4](ch06.xhtml#ch06fig4), the IDE provides the ABI
    and bytecode results from the compiler, as well as a GETH script to deploy the
    contract for your convenience.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 正如[图 6.4](ch06.xhtml#ch06fig4)所示，集成开发环境（IDE）提供了编译器的ABI和字节码结果，以及一个GETH脚本，以便为您方便地部署合约。
- en: '![image](Images/yuan_f06_04.jpg)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/yuan_f06_04.jpg)'
- en: '**Figure 6.4** Clicking the Details button shows the ABI, bytecode, and a deployment
    script for the smart contract.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 6.4** 点击详情按钮显示智能合约的ABI、字节码和一个部署脚本。'
- en: Truffle Framework
  id: totrans-309
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Truffle 框架
- en: The Truffle Framework significantly streamlines and simplifies the process of
    building and deploying smart contracts. We recommend it for complex smart contracts
    as well as for automated building and testing in professional software development
    settings.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: Truffle 框架显著简化了构建和部署智能合约的过程，我们推荐它在复杂的智能合约以及专业的软件开发环境中的自动化构建和测试。
- en: 'The Truffle framework builds on the node.js framework. So, you should first
    make sure that node.js and its package manager, npm, are installed on your machine.
    You can install them at [https://www.npmjs.com/get-npm](https://www.npmjs.com/get-npm).
    On most Linux distributions, you can use the system package manager to install
    them as well. For example, the following command installs node.js and npm on a
    CentOS/RedHat/Fedora Linux system:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: Truffle 框架建立在node.js框架之上。因此，您首先需要确保node.js及其包管理器npm已安装在您的计算机上。您可以在[https://www.npmjs.com/get-npm](https://www.npmjs.com/get-npm)安装它们。在大多数Linux发行版上，您还可以使用系统包管理器安装它们。例如，以下命令在CentOS/RedHat/Fedora
    Linux系统上安装node.js和npm：
- en: '[Click here to view code image](Images/ch06_images.xhtml#pro6_4)'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 点击[此处查看代码图片](Images/ch06_images.xhtml#pro6_4)
- en: '[PRE27]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Next, let’s install the Truffle framework using the npm package manager.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们使用npm包管理器安装Truffle 框架。
- en: '[Click here to view code image](Images/ch06_images.xhtml#pro6_5)'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 点击[此处查看代码图片](Images/ch06_images.xhtml#pro6_5)
- en: '[PRE28]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Next, you can create a basic project structure using the truffle command.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您可以使用truffle命令创建一个基本的项目结构。
- en: '[Click here to view code image](Images/ch06_images.xhtml#pro6_6)'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 点击[此处查看代码图片](Images/ch06_images.xhtml#pro6_6)
- en: '[PRE29]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now you can create a `HelloWorld.sol` file in the `HelloWorld/contracts` directory.
    The file content was listed earlier in this chapter, and you can also get it from
    the sample project on GitHub. In addition, create a `migrations/2_deploy_contracts.js`
    file to indicate that the HelloWorld contract needs to be deployed by Truffle.
    The content of the `2_deploy_contracts.js` file is as follows:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以在`HelloWorld/contracts`目录中创建一个`HelloWorld.sol`文件。该文件的内容在本章前面已经列出，您也可以从GitHub上的示例项目中获取。此外，创建一个`migrations/2_deploy_contracts.js`文件，以指示需要使用Truffle部署HelloWorld合约。`2_deploy_contracts.js`文件的内容如下：
- en: '[Click here to view code image](Images/ch06_images.xhtml#pro6_7)'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 点击[此处查看代码图片](Images/ch06_images.xhtml#pro6_7)
- en: '[PRE30]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You will also need to update the `truffle.js` file, which configures the deployment
    targets. The following `truffle.js` example has two targets: one for the TestRPC
    on the localhost, and one for an Ethereum testnet node on the local network.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要更新`truffle.js`文件，该文件配置了部署目标。以下`truffle.js`示例有两个目标：一个是本地主机上的TestRPC，另一个是本地网络上的以太坊测试网节点。
- en: '[Click here to view code image](Images/ch06_images.xhtml#pro6_8)'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 点击[此处查看代码图片](Images/ch06_images.xhtml#pro6_8)
- en: '[PRE31]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'To compile and build the smart contract, you can use the following command:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译和构建智能合约，您可以使用以下命令：
- en: '[Click here to view code image](Images/ch06_images.xhtml#pro6_9)'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 点击[此处查看代码图片](Images/ch06_images.xhtml#pro6_9)
- en: '[PRE32]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The previously mentioned contract ABI, when constructing a contract object from
    the blockchain address, is a JSON object in the `build/contracts/HelloWorld.json`
    file.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在从区块链地址构造合约对象时，之前提到的合约ABI是一个JSON对象，在`build/contracts/HelloWorld.json`文件中。
- en: '[Click here to view code image](Images/ch06_images.xhtml#pro6_10)'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 点击[此处查看代码图片](Images/ch06_images.xhtml#pro6_10)
- en: '[PRE33]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Finally, you have two deployment options. The first option is to deploy to
    the TestRPC. You must have the TestRPC running on the same machine. Run the following
    command to deploy the `HelloWorld` contract to the TestRPC:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您有两个部署选项。第一个选项是部署到TestRPC。您的机器上必须运行TestRPC。运行以下命令在TestRPC上部署`HelloWorld`合约：
- en: '[Click here to view code image](Images/ch06_images.xhtml#pro6_11)'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 点击[此处查看代码图片](Images/ch06_images.xhtml#pro6_11)
- en: '[PRE34]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The second option is to deploy to a live Ethereum blockchain network. However,
    since this costs gas, you will need to unlock an account with an ETH balance first.
    You can use GETH attached to the testnet node to do this. The unlocked address
    is the one specified in the `testnet/from` field in the `truffle.js` file. Please
    see [Chapter 5](ch05.xhtml#ch05) to review GETH account unlocking commands.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个选项是将部署到以太坊主网络。然而，由于这需要gas，您需要先解锁一个带有ETH余额的账户。您可以使用附着在测试网节点上的GETH来完成这个操作。解锁的地址是在`truffle.js`文件中的`testnet/from`字段指定的。请参阅[第5章](ch05.xhtml#ch05)以复习GETH账户解锁命令。
- en: '[Click here to view code image](Images/ch06_images.xhtml#pro6_12)'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 点击[此处查看代码图片](Images/ch06_images.xhtml#pro6_12)
- en: '[PRE35]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Then deploy to the testnet using `truffle`.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用`truffle`部署到测试网。
- en: '[Click here to view code image](Images/ch06_images.xhtml#pro6_13)'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 点击[此处查看代码图片](Images/ch06_images.xhtml#pro6_13)
- en: '[PRE36]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Finally, you can verify the contract deployed on the live network at this address:
    [https://ropsten.etherscan.io/address/0x8bc27c8129eea739362d786ca0754b5062857e9c](https://ropsten.etherscan.io/address/0x8bc27c8129eea739362d786ca0754b5062857e9c)'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以验证在此地址上部署的合约：[https://ropsten.etherscan.io/address/0x8bc27c8129eea739362d786ca0754b5062857e9c](https://ropsten.etherscan.io/address/0x8bc27c8129eea739362d786ca0754b5062857e9c)
- en: Calling Smart Contract Functions
  id: totrans-342
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调用智能合约函数
- en: Now that you have deployed the “Hello, World!” smart contract on the blockchain,
    you should be able to interact with it and call its public functions.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经在区块链上部署了“Hello, World!”智能合约，您应该能够与它交互并调用其公共函数。
- en: The BUIDL IDE
  id: totrans-344
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: BUIDL IDE
- en: Once you have configured the BUIDL IDE to work with the Ethereum blockchain
    and have hit the **Compile** button to compile your Solidity smart contract, you
    are ready to deploy it.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您配置了BUIDL IDE以与以太坊区块链协同工作，并点击**编译**按钮以编译您的Solidity智能合约，您就准备好部署它了。
- en: Hit the **Deploy to the chain** button (see [Figure 6.5](ch06.xhtml#ch06fig5))
    to deploy the smart contract onto the Ethereum blockchain. The deployed contracts
    are available on the Deployed tab. You can click to open any of them and interact
    with the public functions directly from inside BUIDL.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**部署到链上**按钮（见[图6.5](ch06.xhtml#ch06fig5)），将智能合约部署到以太坊区块链。部署的合约在“已部署”标签页中可用。您可以点击打开其中的任何一个，并直接从BUIDL内部与公共函数交互。
- en: '![image](Images/yuan_f06_05.jpg)'
  id: totrans-347
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/yuan_f06_05.jpg)'
- en: '**Figure 6.5** Calling functions on a deployed Ethereum smart contract'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '**图6.5** 部署后的以太坊智能合约调用函数'
- en: The Remix IDE
  id: totrans-349
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Remix IDE
- en: As I showed in [Chapter 4](ch04.xhtml#ch04), the Remix IDE can build a UI for
    a smart contract given the ABI and contract address. All public functions of the
    contract are listed in the UI. Functions that result in blockchain state changes
    (e.g., require gas to operate) are labeled as red buttons ([Figure 6.6](ch06.xhtml#ch06fig6)).
    Functions that do not result in state changes (i.e., view methods) are labeled
    as blue buttons. You can pass call parameters to functions in the input boxes
    next to each button.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在[第4章](ch04.xhtml#ch04)中提到的，Remix IDE可以构建一个智能合约的UI，给定ABI和合约地址。合约的所有公共函数都列在UI中。那些导致区块链状态更改的函数（例如，需要gas操作的）被标记为红色按钮([图6.6](ch06.xhtml#ch06fig6))。那些不导致状态更改的函数（即视图方法）被标记为蓝色按钮。您可以在每个按钮旁边的输入框中传递调用参数到函数。
- en: '![image](Images/yuan_f06_06.jpg)'
  id: totrans-351
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/yuan_f06_06.jpg)'
- en: '**Figure 6.6** A smart contract UI built by Remix'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '**图6.6** 由Remix构建的智能合约UI'
- en: The Remix UI is convenient, but it cannot be automated and hides details of
    the transactions. To fully understand how smart contracts are executed on the
    blockchain, I recommend you interact with the functions directly on a blockchain
    node. In the case of Ethereum, it is a node running GETH connected to the mainnet
    or testnet.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: Remix UI虽然方便，但不能自动化，并且隐藏了交易的细节。为了完全理解智能合约是如何在区块链上执行的，我建议你直接在以太坊节点上与函数交互。在以太坊的情况下，这是一个运行GETH并连接到主网或测试网的节点。
- en: '**Note**'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: As shown in [Chapter 4](ch04.xhtml#ch04), you can use the web3.js JavaScript
    library to build applications that work in tandem with the Metamask wallet to
    call smart contract methods. But web3.js does not help you with interactive development
    and debugging of the smart contract itself.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第4章](ch04.xhtml#ch04)所示，你可以使用web3.js JavaScript库与MetaMask钱包协同工作，调用智能合约方法。但web3.js无法帮助你进行智能合约本身的交互式开发和调试。
- en: GETH Console
  id: totrans-356
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: GETH 控制台
- en: GETH is a GO language-based client for Ethereum. You can run GETH in a mode
    that attaches itself to an Ethereum node (or the TestRPC for local testing). See
    [Chapter 5](ch05.xhtml#ch05) for how to run an Ethereum node yourself using GETH.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: GETH是以太坊的GO语言客户端。你可以以一种模式运行GETH，使其附加到一个以太坊节点（或TestRPC，用于本地测试）。有关如何使用GETH自己运行以太坊节点的信息，请参阅[第5章](ch05.xhtml#ch05)。
- en: '[Click here to view code image](Images/ch06_images.xhtml#pro6_14)'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击此处查看代码图片](Images/ch06_images.xhtml#pro6_14)'
- en: '[PRE37]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In the console, you can now create an instance of the contract via the `eth.contract().at()`
    method. You need two pieces of information. Both of them come from the tool you
    use to build and deploy your smart contract to the blockchain, which I will cover
    in the next section.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以在控制台中通过`eth.contract().at()`方法创建合约实例。你需要两样信息。这两样信息都来自你用来将智能合约部署到区块链上的工具，这部分我将在下一节中介绍。
- en: The JSON parameter to the `contract()` method is known as the ABI. When you
    build the smart contract, the compiler outputs the ABI. In the case of the Truffle
    framework, the ABI is located in the `build/contracts/HelloWorld.json` file’s
    abi JSON field, with all line breaks removed.
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`contract()`方法中的JSON参数被称为ABI。当你构建智能合约时，编译器会输出ABI。在Truffle框架的情况下，ABI位于`build/contracts/HelloWorld.json`文件中的abi
    JSON字段，其中所有换行符都被移除了。'
- en: The `at()` method parameter is the address to this specific instance of the
    smart contract. That is, you can deploy the same smart contract class multiple
    times, and each time the Ethereum blockchain will create a unique address for
    it.
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`at()`方法参数是智能合约的特定实例地址。也就是说，你可以多次部署同一个智能合约类，每次以太坊区块链都会为它创建一个独特的地址。'
- en: '[Click here to view code image](Images/ch06_images.xhtml#pro6_15)'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击此处查看代码图片](Images/ch06_images.xhtml#pro6_15)'
- en: '[PRE38]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `sayHello()` method on the contract instance does not change the blockchain
    state. So, it is “free” and immediately executed by the node connected to our
    GETH console.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 合约实例上的`sayHello()`方法不会改变区块链状态。因此，它是“免费”的，并且立即由连接到我们GETH控制台的节点执行。
- en: '[PRE39]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `updateMessage()` method, on the other hand, changes the contract’s internal
    state on the blockchain. It must be executed by all the miners and gets recorded
    on the blockchain once most miners reach consensus. Because of that, it’s execution
    requires gas (in ETH) to pay the miners for their effort. The gas is provided
    by an account specified on the method call.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`updateMessage()`方法会改变区块链上的合约内部状态。它必须由所有矿工执行，并在大多数矿工达成共识后记录在区块链上。因此，它的执行需要消耗燃料费（以ETH计），以支付矿工的努力。燃料费由方法调用中指定的账户提供。
- en: 'If your GETH console is connected to the TestRPC, you should already have unlocked
    accounts. But if you are connected to a real Ethereum node, you can use the following
    command in the GETH console to create a new Ethereum account and then send ETH
    to this account from one of your wallets:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的GETH控制台连接到TestRPC，你可能已经解锁了账户。但如果你连接到一个真实的以太坊节点，你可以在GETH控制台中使用以下命令创建一个新的以太坊账户，然后从你的钱包中向这个账户发送ETH：
- en: '[PRE40]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Next, the account must be unlocked so that we can “spend” its ETH as gas.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，账户必须解锁，以便我们可以“花费”其ETH作为燃料费。
- en: '[Click here to view code image](Images/ch06_images.xhtml#pro6_16)'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击此处查看代码图片](Images/ch06_images.xhtml#pro6_16)'
- en: '[PRE41]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: While the gas fee is small, it is necessary. If your account specified in the
    method call has zero balance and cannot pay gas, the function call will fail.
    The changed state of the contract will be finalized across all blockchain nodes
    when the transaction is confirmed by the miners. The confirmation could take several
    minutes on the Ethereum blockchain, degrading the user experience. On Ethereum-compatible
    blockchains like CyberMiles, the confirmation time could be as fast as seconds.
    That is a compelling reason to develop and deploy Ethereum applications on alternative
    compatible blockchains (learn more in [Appendix A](app.xhtml#app)).
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然燃料费很小，但它是必要的。如果你的账户在方法调用中指定的余额为零，并且无法支付燃料费，那么函数调用将会失败。当交易被矿工确认时，智能合约的状态变化将在所有区块链节点上最终确定。在以太坊区块链上，确认可能需要几分钟，这会降低用户体验。在类似于CyberMiles这样的与以太坊兼容的区块链上，确认时间可能快至几秒钟。这是在兼容的替代区块链上开发和部署以太坊应用程序的有力理由（在[附录A](app.xhtml#app)中了解更多）。
- en: A New Language
  id: totrans-374
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一种新语言
- en: While the Solidity language is currently the most widely used programming language
    for Ethereum smart contract development, it is also hard to use and has many design
    flaws. Specifically, it lacks safeguards and logical separations commonly available
    in modern programming languages. It is easy to make human errors in Solidity.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然目前Solidity语言是用于以太坊智能合约开发的最广泛使用的编程语言，但它也难以使用且存在许多设计缺陷。特别是，它缺乏现代编程语言中常见的保护措施和逻辑分离。在Solidity中容易人为犯错。
- en: In fact, a large-scale code audit has revealed about 100 obvious bugs for every
    1,000 lines of Solidity code. That is astonishingly high as most Solidity code
    is for smart contracts that actually manage financial assets. In contrast, nonfinancial
    business software typically contains 10 bugs per 1,000 lines of code.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，一项大规模的代码审计显示，每1000行Solidity代码中约有100个明显的错误。这对于大多数实际上管理金融资产的Solidity代码来说是非常惊人的高，相比之下，非金融业务软件通常在每1000行代码中含有10个错误。
- en: To address Solidity’s problems, the Ethereum community is developing a new experimental
    language for smart contract programming called Vyper. It is designed for human
    readability and auditability. It removes some confusing features from Solidity
    and should produce safer smart contracts with fewer bugs.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决Solidity的问题，以太坊社区正在开发一种新的智能合约编程实验语言，称为Vyper。它旨在提高人类可读性和可审计性。它移除了Solidity中的一些令人困惑的功能，应该能产生更安全的智能合约，错误更少。
- en: While Vyper is in early beta and the design is still changing, it is possibly
    the future of Ethereum development. In this section, I will show how to rewrite
    the Solidity “Hello, World!” example in Vyper and how to deploy it. The following
    is the Vyper code for the smart contract. You will notice that the Vyper smart
    contract is similar to the Python language. The filename is `HelloWorld.v.py`.
    The filename suffix is `.py` to allow development tools to highlight its syntax
    using Python rules. If that is a concern, you can also use the `.vy` suffix.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Vyper目前处于早期测试阶段，设计仍在变化，但它可能是以太坊开发的未来。在本节中，我将展示如何用Vyper重写Solidity的“Hello, World!”示例以及如何部署它。以下是智能合约的Vyper代码。你会注意到Vyper智能合约与Python语言相似。文件名是`HelloWorld.v.py`。文件名后缀是`.py`，以便开发工具使用Python规则突出其语法。如果这是一个问题，你也可以使用`.vy`后缀。
- en: '[Click here to view code image](Images/ch06_images.xhtml#pro6_17)'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击此处查看代码图片](Images/ch06_images.xhtml#pro6_17)'
- en: '[PRE42]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: To install the Vyper compiler, you will need Python 3.6 or newer. Since Vyper
    is still an evolving technology, the official documentation suggests building
    from the source. You can find the latest instructions at [https://vyper.readthedocs.io/en/latest/installing-vyper.html](https://vyper.readthedocs.io/en/latest/installing-vyper.html).
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装Vyper编译器，你需要Python 3.6或更高版本。由于Vyper仍然是一个不断发展的技术，官方文档建议从源代码构建。你可以在[https://vyper.readthedocs.io/en/latest/installing-vyper.html](https://vyper.readthedocs.io/en/latest/installing-vyper.html)找到最新的安装说明。
- en: 'Once you have the Vyper application installed, you can run it as any other
    compiler. The following command will output the hex string of the compiled bytecode
    of the contract:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你安装了Vyper应用程序，你就可以像运行任何其他编译器一样运行它。以下命令将输出合同编译后的字节码的十六进制字符串：
- en: '[PRE43]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The following command will output the JSON string of the ABI for the contract:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将输出合同的ABI的JSON字符串：
- en: '[PRE44]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: With both the bytecode and ABI, you can use GETH to deploy the smart contract
    to Ethereum or the TestRPC.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 有了字节码和ABI，你可以使用GETH将智能合约部署到以太坊或TestRPC。
- en: '[Click here to view code image](Images/ch06_images.xhtml#pro6_18)'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击此处查看代码图片](Images/ch06_images.xhtml#pro6_18)'
- en: '[PRE45]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, similar to Remix, there is also an online compiler for Vyper contracts:
    [https://vyper.online/](https://vyper.online/) ([Figure 6.7](ch06.xhtml#ch06fig7)).
    You can type in your Vyper source code and let the web application compile it
    into bytecode ([Figure 6.8](ch06.xhtml#ch06fig8)) and ABI ([Figure 6.9](ch06.xhtml#ch06fig9)).'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，类似于Remix，还有一个Vyper合约的在线编译器：[https://vyper.online/](https://vyper.online/)
    ([图6.7](ch06.xhtml#ch06fig7))。您可以输入您的Vyper源代码，让网页应用程序将其编译成字节码([图6.8](ch06.xhtml#ch06fig8))和ABI([图6.9](ch06.xhtml#ch06fig9))。
- en: '![image](Images/yuan_f06_07.jpg)'
  id: totrans-390
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/yuan_f06_07.jpg)'
- en: '**Figure 6.7** A web-based Vyper compiler, vyper.online'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '**图6.7** 一个基于网页的Vyper编译器，vyper.online'
- en: '![image](Images/yuan_f06_08.jpg)'
  id: totrans-392
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/yuan_f06_08.jpg)'
- en: '**Figure 6.8** The compiled bytecode from vyper.online'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '**图6.8** vyper.online编译的字节码'
- en: '![image](Images/yuan_f06_09.jpg)'
  id: totrans-394
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/yuan_f06_09.jpg)'
- en: '**Figure 6.9** The ABI interface generated by vyper.online'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '**图6.9** vyper.online生成的ABI界面'
- en: More Smart Contract Languages
  id: totrans-396
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更多智能合约语言
- en: While the Vyper language is similar to Python, it cannot be called Python since
    it removes some important features from the Python language to make its programs
    deterministic. All blockchain node computers must produce the same result when
    executing the smart contract code in order to reach consensus. Therefore, no general-purpose
    computer programming language can be used directly for smart contract programming.
    The language must be modified to produce entirely deterministic behavior.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Vyper语言与Python相似，但由于它去除了Python语言中一些重要的功能以使其程序具有确定性，因此不能将其称为Python。所有区块链节点计算机在执行智能合约代码时必须产生相同的结果，以达到共识。因此，不能直接使用通用目的的计算机编程语言进行智能合约编程。该语言必须进行修改，以产生完全确定性的行为。
- en: The new generations of blockchain virtual machines are leveraging state-of-the-art
    virtual machine technologies such as the WebAssembly (Wasm) virtual machine. For
    example, the next Ethereum Virtual Machine will be based on WebAssembly and called
    Ethereum Flavored WebAssembly (eWASM). Another large public blockchain, EOS, already
    has a WebAssembly-based virtual machine.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 新一代区块链虚拟机正在利用如WebAssembly（Wasm）虚拟机等最先进的虚拟机技术。例如，下一个以太坊虚拟机将基于WebAssembly，称为以太坊风味WebAssembly（eWASM）。另一个大型公共区块链，EOS，已经有一个基于WebAssembly的虚拟机。
- en: Those new-generation virtual machines are commonly based on the LLVM technology
    that supports optimization across the entire application lifecycle from compile
    time to link time to runtime. LLVM uses an intermediate representation (IR) code
    format between the application source code and machine bytecode to support a “language-agnostic”
    compiler infrastructure. The IR allows the virtual machine to support multiple
    source code programming languages on the front end. Indeed, LLVM already supports
    20+ programming languages. Solidity and Vyper are also evolving to become compatible
    with the LLVM IR. For example, the open source SOLL project is developing an LLVM-based
    Solidity compiler for the next generation of blockchain virtual machines. See
    [https://github.com/second-state/soll](https://github.com/second-state/soll).
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 这些新一代虚拟机通常基于支持在整个应用程序生命周期内进行优化的LLVM技术，从编译时间到链接时间再到运行时间。LLVM使用应用程序源代码与机器字节码之间的中间表示（IR）代码格式，以支持“语言不可知”的编译器基础设施。IR允许虚拟机支持多种源代码编程语言在前端。实际上，LLVM已经支持了20多种编程语言。Solidity和Vyper也在发展以与LLVM
    IR兼容。例如，开源的SOLL项目正在开发一个基于LLVM的Solidity编译器，用于下一代的区块链虚拟机。参见[https://github.com/second-state/soll](https://github.com/second-state/soll)。
- en: However, because of the unique constraints of smart contract programming, it
    is impossible to expect mainstream programming languages to be fully supported
    on blockchain virtual machines. When EOS says that its smart contract programming
    language is C++, it means a modified version of C++ that produces deterministic
    programs. It will be a major effort to modify and reform mainstream programming
    languages to support smart contract programming. So, in the near future, I think
    Solidity will continue to be the dominant smart contract programming language.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于智能合约编程的独特限制，无法期望主流编程语言能够在区块链虚拟机上得到全面支持。当EOS说其智能合约编程语言是C++时，它指的是一个经过修改的C++版本，可以生成确定性程序。要修改和改革主流编程语言以支持智能合约编程，将是一项重大努力。所以，在不久的将来，我认为Solidity将继续是主导的智能合约编程语言。
- en: Conclusion
  id: totrans-401
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结论
- en: In this chapter, I explained what a smart contract is, how to program it, and
    how to interact with it. I covered both the Solidity language and the upcoming
    Vyper language for smart contract programming. Using open source tools, we explored
    different options to test and deploy the smart contract onto Ethereum blockchain
    networks. Of course, Solidity and Vyper still have their limitations. I will cover
    an alternative programming language called Lity, which is fully backward compatible
    with Solidity but attempts to address some of the most glaring problems, in [Chapter
    14](ch14.xhtml#ch14).
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我解释了智能合约是什么，如何编程它，以及如何与它交互。我涵盖了智能合约编程的 Solidity 语言和即将推出的 Vyper 语言。使用开源工具，我们探讨了不同的选项来测试和将智能合约部署到以太坊区块链网络。当然，Solidity
    和 Vyper 仍然存在一些局限性。我将在[第 14 章](ch14.xhtml#ch14)介绍一种名为 Lity 的替代编程语言，它与 Solidity
    完全向后兼容，但尝试解决一些最明显的问题。
- en: 7. Decentralized Applications (Dapps)
  id: totrans-403
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7. 去中心化应用程序（Dapps）
- en: In the previous chapter, we discussed the concept of smart contracts and how
    to interact with them on the Ethereum blockchain. However, tools like GETH, Truffle,
    and even Remix and Metamask are geared toward developers or expert users. For
    regular users to access blockchain applications, there is still much work around
    the user interface (UI), user experience (UX), and supporting infrastructure.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，我们讨论了智能合约的概念以及如何在以太坊区块链上与它们进行交互。然而，像 GETH、Truffle 这样的工具，甚至是 Remix 和 Metamask，都是针对开发者或高级用户的。对于普通用户来说，要访问区块链应用程序，用户界面（UI）、用户体验（UX）和支持基础设施方面还有很多工作要做。
- en: The Internet took off when the user experience of web applications started to
    match client-server applications on closed networks. Only after that point did
    the open and decentralized advantages of the Internet start to matter. The Internet
    excels at enabling open ecosystems that orchestrate multiple data and service
    providers. But such ecosystems are useful only when the users are willing to use
    web applications. Similarly, decentralized and autonomous smart contracts can
    be mass adopted only when the application user experience is on par with regular
    web applications. Enter *dapps*.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Web 应用程序的用户体验开始与封闭网络上的客户端-服务器应用程序相匹配时，互联网才开始蓬勃发展。只有到了这个时候，互联网的开放和去中心化优势才开始显现。互联网擅长于促进开放生态系统的构建，这些生态系统可以协调多个数据和服务提供商。但是，只有当用户愿意使用
    Web 应用程序时，这样的生态系统才是有用的。同样地，只有当应用程序用户体验与常规 Web 应用程序相媲美时，去中心化和自主的智能合约才能被大规模采用。于是就有了
    *dapps*。
- en: The purpose of a decentralized application is to provide UIs for smart contracts
    and other blockchain functionalities. Ideally, a dapp is a rich client application
    downloaded onto the user’s device. It ties together multiple back-end services,
    including the blockchain service. A dapp is typically a JavaScript application
    that can be downloaded from any web server (i.e., there is no central server that
    can be shut down) and relies on the decentralized blockchain for its data and
    logic functionalities.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 去中心化应用程序的目的是为智能合约和其他区块链功能提供 UI。理想情况下，一个 dapp 是一个丰富的客户端应用程序，下载到用户的设备上。它将多个后端服务（包括区块链服务）紧密结合在一起。一个
    dapp 通常是一个可以从任何 Web 服务器下载的 JavaScript 应用程序（即没有可以被关闭的中心服务器）并且依赖于去中心化的区块链来实现其数据和逻辑功能。
- en: In this chapter, I discuss architectural design and best practices for blockchain
    dapps through some notable success stories.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我通过一些值得关注的成功案例讨论了区块链 dapp 的架构设计和最佳实践。
- en: '**Note**'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: Dapp development on Ethereum is a chore. It requires you to set up Metamask,
    Remix, web3, a web server, maybe even an Ethereum node, and a flurry of infrastructure
    tools just to write the first line of code. And the standard Ethereum dapp is
    not going to work on mobile devices out of the box.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: Ethereum 上的 dapp 开发是一项繁琐的工作。它要求你设置 Metamask、Remix、web3、Web 服务器，甚至可能是 Ethereum
    节点，以及一大堆基础工具，只为了编写第一行代码。而且，标准的 Ethereum dapp 默认情况下无法在移动设备上运行。
- en: On the other hand, BUIDL is a complete dapp development environment that requires
    almost no setup. BUIDL applications can be published to the Web and accessed from
    mobile devices. Learn more about BUIDL in [Chapter 3](ch03.xhtml#ch03) and [Chapter
    4](ch04.xhtml#ch04).
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，BUIDL 是一个完整的 dapp 开发环境，几乎不需要任何设置。BUIDL 应用程序可以发布到 Web 上，并从移动设备访问。了解更多关于
    BUIDL 的内容，请参阅[第 3 章](ch03.xhtml#ch03)和[第 4 章](ch04.xhtml#ch04)。
- en: Dapp Stack
  id: totrans-411
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Dapp 栈
- en: Once we have built and tested the smart contracts, it is time to build the dapp
    UI for users to interact with the smart contracts. The idea here is that unlike
    a web application that depends on a central server for logic and data, a dapp
    can save user data locally and utilize multiple back-end services, including the
    blockchain service, to achieve decentralization ([Figure 7.1](ch07.xhtml#ch07fig1)).
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们构建并测试了智能合约，是时候为用户与智能合约交互构建dapp UI了。这里的想法是，与依赖中心服务器进行逻辑和数据处理的Web应用程序不同，dapp可以将用户数据保存在本地，并利用包括区块链服务在内的多个后端服务，以实现去中心化([图7.1](ch07.xhtml#ch07fig1))。
- en: '![image](Images/yuan_f07_01.jpg)'
  id: totrans-413
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/yuan_f07_01.jpg)'
- en: '**Figure 7.1** The dapp architecture'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '**图7.1** dapp架构'
- en: The dapp typically runs in the user’s device as a client-side JavaScript application.
    Its primary function is to provide a user interface. It interacts with the blockchain
    smart contracts for core data and application logic. It could also interact with
    other public or even local services to store and manage off-chain data. The most
    important difference between a dapp’s off-chain data and a regular web app’s central
    server is that the dapp’s server data can be replicated and replaced when needed.
    There is no single point of failure in a dapp infrastructure.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，dapp在用户的设备上作为客户端JavaScript应用运行。其主要功能是提供用户界面。它与区块链智能合约交互以获取核心数据和应用逻辑。它还可以与其他公共服务甚至本地服务交互，以存储和管理链下数据。dapp的链下数据与常规Web应用的中心服务器数据的最重要区别在于，当需要时，dapp的服务器数据可以被复制和替换。dapp基础设施中没有单点故障。
- en: For example, the dapp can utilize the device’s HTML5 local storage API to store
    data specific to users on this device.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，去中心化应用（dapp）可以利用设备的HTML5本地存储API来存储特定于该设备用户的用户数据。
- en: You can write a dapp in any client-side JavaScript framework. Popular examples
    include jQuery and ReactJS. In the Truffle project, you can find templates ([https://truffleframework.com/boxes](https://truffleframework.com/boxes))
    for creating dapps for popular JavaScript frameworks.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在任何客户端JavaScript框架中编写dapp。常见的例子包括jQuery和ReactJS。在Truffle项目中，你可以找到创建dapp的模板([https://truffleframework.com/boxes](https://truffleframework.com/boxes))，适用于流行的JavaScript框架。
- en: The web3 Library
  id: totrans-418
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: web3库
- en: 'The JavaScript application connects to the blockchain services via a library
    called web3.js ([https://github.com/ethereum/web3.js/](https://github.com/ethereum/web3.js/)).
    Currently, web3.js supports only the Ethereum blockchain, and it has not reached
    version 1.0\. Yet it is already by far the most popular library to connect dapps
    to blockchain services. The web3 library provides the following features:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript应用程序通过一个名为web3.js的库连接到区块链服务([https://github.com/ethereum/web3.js/](https://github.com/ethereum/web3.js/)）。目前，web3.js只支持以太坊区块链，并且尚未达到1.0版本。然而，它已经是连接dapp和区块链服务最受欢迎的库。web3库提供以下功能：
- en: Send or transfer fund from one address to another
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从一个地址发送或转移资金到另一个地址
- en: Deploy smart contracts
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署智能合约
- en: Call public functions on deployed smart contracts
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用已部署智能合约的公共函数
- en: Estimate the gas fee for contract function calls
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 估算合约函数调用的燃气费
- en: Query a contract or address status
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询合约或地址状态
- en: The web3.js library requires a private key to sign transactions it sends to
    the blockchain. As you have seen, blockchain account private keys are stored and
    managed by wallet applications; the web3.js library should be used in junction
    with a compatible wallet application. The wallet is also known as a *web3 provider*.
    It is up to the dapp JavaScript code to detect the availability and validity of
    a web3 provider. Metamask is a web3 provider for Ethereum. The “Hello, World!”
    web application from [Chapter 4](ch04.xhtml#ch04) is an example of a web3 dapp
    that works in tandem with Metamask.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: web3.js库需要私钥来签署发送到区块链的交易。正如你所见，区块链账户私钥由钱包应用程序存储和管理；web3.js库应与兼容的钱包应用程序一起使用。钱包也被称为*web3提供商*。检测web3提供程序的可用性和有效性是dapp
    JavaScript代码的事。MetaMask是针对以太坊的web3提供商。"第4章的"Hello, World!"网络应用程序是一个与MetaMask协同工作的web3
    dapp的例子。
- en: '**Note**'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: In addition to the more popular web3.js, the ethereumJS library ([https://ethereumjs.github.io/](https://ethereumjs.github.io/))
    can sign Ethereum transactions without a wallet application. However, to do so,
    the JavaScript code must have access to the account private key. It provides a
    JavaScript library ([https://github.com/ethereumjs/ethereumjs-wallet](https://github.com/ethereumjs/ethereumjs-wallet))
    to implement your own embedded wallet inside the dapp.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 除了更受欢迎的web3.js，以太坊JS库（[https://ethereumjs.github.io/](https://ethereumjs.github.io/)）可以在没有钱包应用程序的情况下签署以太坊交易。然而，要做到这一点，JavaScript代码必须能够访问账户私钥。它提供了一个JavaScript库（[https://github.com/ethereumjs/ethereumjs-wallet](https://github.com/ethereumjs/ethereumjs-wallet)）来实现你自己的嵌入式钱包。
- en: '**Note**'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: Cross-blockchain applications like Scatter ([https://get-scatter.com/](https://get-scatter.com/))
    act like wallets but are designed to run dapps.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 跨区块链应用程序，如Scatter [https://get-scatter.com/](https://get-scatter.com/)，像钱包一样运行dapps。
- en: External Services
  id: totrans-430
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 外部服务
- en: 'As I have described, dapps store only core logic and data on blockchain smart
    contracts. It is too slow and too expensive to store large amounts of data on
    the blockchain. Most applications also require media files, databases, and other
    off-chain data to function. The dapp could use online services to store and manage
    data. Here are some examples:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我所说，dapps只在区块链智能合约上存储核心逻辑和数据。在区块链上存储大量数据太慢，也太昂贵。大多数应用程序还需要媒体文件、数据库等其他离链数据才能运行。dapp可以使用在线服务来存储和管理数据。以下是一些示例：
- en: The IPFS ([https://ipfs.io/](https://ipfs.io/)) is a blockchain-based media
    file storage and exchange service protocol. Dapps can store large user files on
    IPFS and make them accessible everywhere.
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 星际文件系统（IPFS）[https://ipfs.io/](https://ipfs.io/) 是一个基于区块链的媒体文件存储和交换服务协议。Dapps可以在IPFS上存储大量用户文件，并使它们无处不在。
- en: Swarm ([https://ethersphere.github.io/swarm-home/](https://ethersphere.github.io/swarm-home/))
    is a file storage and sharing solution built on top of Ethereum.
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swarm（[https://ethersphere.github.io/swarm-home/](https://ethersphere.github.io/swarm-home/)）是基于以太坊的文件存储和共享解决方案。
- en: GitHub ([https://github.com/](https://github.com/)), Dropbox ([https://www.dropbox.com/](https://www.dropbox.com/)),
    or Google Drive ([https://www.google.com/drive/](https://www.google.com/drive/))
    are examples of traditional Internet file storage and sharing services that can
    be accessible by individual dapp users. You can use GitHub or Dropbox web sites
    to serve dapp JavaScript files directly from an individual user’s accounts.
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitHub [https://github.com/](https://github.com/)、Dropbox [https://www.dropbox.com/](https://www.dropbox.com/)
    或 Google Drive [https://www.google.com/drive/](https://www.google.com/drive/)
    是传统互联网文件存储和共享服务的示例，可以被个别dapp用户访问。你可以使用GitHub或Dropbox网站直接从个别用户账户中服务dapp JavaScript文件。
- en: Database as a service (DBaaS) providers such as Microsoft Azure SQL ([https://azure.microsoft.com/en-us/services/sql-database/](https://azure.microsoft.com/en-us/services/sql-database/)),
    AWS Relational Database Service ([https://aws.amazon.com/rds/](https://aws.amazon.com/rds/)),
    Google BigQuery ([https://cloud.google.com/bigquery/](https://cloud.google.com/bigquery/)),
    and MongoDB Atlas ([https://www.mongodb.com/cloud/atlas](https://www.mongodb.com/cloud/atlas))
    are examples of database services that can be utilized by dapps to store application
    data.
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库即服务（DBaaS）提供商，如微软Azure SQL [https://azure.microsoft.com/en-us/services/sql-database/](https://azure.microsoft.com/en-us/services/sql-database/)、亚马逊关系型数据库服务
    [https://aws.amazon.com/rds/](https://aws.amazon.com/rds/)、谷歌大数据查询 [https://cloud.google.com/bigquery/](https://cloud.google.com/bigquery/)
    和 MongoDB Atlas [https://www.mongodb.com/cloud/atlas](https://www.mongodb.com/cloud/atlas)
    是可以被dapps用来存储应用程序数据的数据库服务示例。
- en: An off-chain data service is a query interface to search and browse blockchain
    data, such as transactions, accounts, and smart contract function calls. It is
    potentially much more powerful, versatile, and scalable than calling the view
    functions to get smart contract data. This approach is discussed in more detail
    in [Chapter 10](ch10.xhtml#ch10).
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 离链数据服务是一个查询接口，用于搜索和浏览区块链数据，如交易、账户和智能合约函数调用。它比调用视图函数获取智能合约数据要强大、多功能和可扩展得多。这个方法在[第10章](ch10.xhtml#ch10)中有更详细的讨论。
- en: A common design practice to ensure the safety and validity of off-chain data
    is to store the data’s hash in on-chain smart contracts.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 确保离链数据的安全性和有效性的常见设计实践是将数据的哈希存储在链上智能合约中。
- en: A dapp is more complex than most web applications. From the start, you need
    to design which part of the application is based on blockchain smart contracts,
    which part utilizes off-chain server-side data, and which part is the client-side
    UI. Each of those elements requires its own software stack to function and communicate
    with the rest of the application.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 一个dapp比大多数web应用程序更复杂。从一开始，你就要设计应用的哪部分基于区块链智能合约，哪部分利用离线服务器端数据，哪部分是客户端UI。这些元素中的每一个都需要其自己的软件堆栈来运行并与其他应用部分进行通信。
- en: Dapp Showcases
  id: totrans-439
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 区块链应用展示
- en: Because of Ethereum’s slow confirmation time (up to ten seconds) and high gas
    fees for executing smart contract functions, successful Ethereum dapps so far
    are all financial applications that do not require frequent user interactions.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 由于以太坊的确认时间较慢（长达十秒）和执行智能合约功能的汽油费较高，迄今为止成功的以太坊dapp都是不需要频繁用户交互的金融应用。
- en: Uniswap
  id: totrans-441
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Uniswap
- en: One of the most polished Ethereum dapps is the Uniswap exchange. It is a decentralized
    crypto token exchange. The idea is that some people will make initial contributions
    to a liquidity pool (as market makers) and earn a share of the trading fees. All
    other traders will trade against the liquidity pool based on a simple pricing
    formula of supply and demand. If a token becomes scarce in the liquidity pool,
    its price against the ETH will increase, incentivizing holders to sell it back
    to the liquidity pool. This mechanism allows trading to happen in a completely
    automated manner without matching for counter parties. The entire Uniswap system
    is a set of smart contracts on the Ethereum blockchain. The application state
    is completely stored in and managed by the contracts.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 最精致的以太坊dapp之一就是Uniswap交易所。它是一个去中心化的加密货币交易所。该想法是，一些人将向流动性池做出初始贡献（作为市场制造商）并获得交易费的一部分。所有其他交易者都将根据简单的供需定价公式与流动性池进行交易。如果流动性池中的代币变得稀缺，其相对于ETH的价格将会上涨，从而激励持有者将其卖回给流动性池。这种机制使得交易在没有匹配对手方的情况下完全自动化。整个Uniswap系统是运行在以太坊区块链上的一组智能合约。应用状态完全存储在并由合约管理。
- en: The Uniswap project has developed a polished UI ([Figure 7.2](ch07.xhtml#ch07fig2))
    to interact with its underlying smart contracts. The UI is completely written
    in web3 JavaScript and is fully internationalized. Through the dapp UI, novice
    users can contribute to the liquidity pool and earn fees for their crypto deposits
    or can immediately start trading pairs of ERC20 tokens.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: Uniswap项目开发了一个精致的UI界面([图7.2](ch07.xhtml#ch07fig2))以便与底层智能合约进行交互。这个UI界面完全是用web3
    JavaScript编写的，并且完全实现了国际化。通过dapp UI，新手用户可以为流动性池贡献资金，并为他们存入的加密货币赚取费用，或者可以立即开始交易ERC20代币对。
- en: '![image](Images/yuan_f07_02.jpg)'
  id: totrans-444
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/yuan_f07_02.jpg)'
- en: '**Figure 7.2** The Uniswap UI'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '**图7.2** Uniswap UI'
- en: The interesting aspect of the Uniswap dapp is that it is truly decentralized.
    All the application logic and its data are stored on the Ethereum blockchain.
    Anyone can create a web site to host the JavaScript dapp, and all those copies
    of dapps will behave the same way as they all get their logic and data from the
    blockchain. In Uniswap, Ethereum has truly become a “computer” back end.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: Uniswap dapp的一个有趣之处在于它确实是去中心化的。应用逻辑和数据都存储在以太坊区块链上。任何人都可以创建一个网站来托管JavaScript
    dapp，所有这些dapp的副本都会以相同的方式运行，因为它们都从区块链获取逻辑和数据。在Uniswap中，以太坊真正成为了一个“计算机”后端。
- en: CryptoKitties
  id: totrans-447
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: CryptoKitties
- en: The CryptoKitties game took over Ethereum by storm in late 2017\. It gave rise
    to the idea of crypto collectibles and nonfungible tokens, which later become
    the ERC721 specification.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: CryptoKitties游戏在2017年底以风暴之势席卷了以太坊。它催生了对加密收藏品和非同质化代币的想法，这些后来成为了ERC721规范。
- en: CryptoKitties are unique digital entities that exist on the Ethereum blockchain.
    They are data in smart contracts. Their uniqueness is guaranteed by the contract
    code. Each CryptoKittie has an associated owner address. CryptoKitties can then
    by bought, sold, and traded on the blockchain.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 存在于以太坊区块链上的CryptoKitties是一种独特的数字实体。它们是智能合约中的数据。它们的独特性由合约代码保证。每个CryptoKittie都有一个关联的所有者地址。CryptoKitties可以在区块链上进行购买、出售和交易。
- en: The interesting thing about CryptoKitties is that they are visually appealing
    ([Figure 7.3](ch07.xhtml#ch07fig3)). The dapp UI design visualizes the unique
    features of each digital entity. That contributed significantly to CryptoKitties’
    success.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 关于CryptoKitties的一个有趣之处在于它们 visually appealing([图7.3](ch07.xhtml#ch07fig3))。dapp
    UI设计可视化了每个数字实体的独特特征。这对CryptoKitties的成功做出了重大贡献。
- en: '![image](Images/yuan_f07_03.jpg)'
  id: totrans-451
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/yuan_f07_03.jpg)'
- en: '**Figure 7.3** CryptoKitties'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: '**图7.3** 加密猫'
- en: Gambling Games
  id: totrans-453
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 赌博游戏
- en: Gambling games are popular dapps. They are great use cases for smart contracts,
    with transparent rules and betting pools. They also benefit greatly from largely
    unregulated cryptocurrencies.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 赌博游戏是流行的DApps。它们是智能合约的优秀用例，具有透明的规则和投注池。它们也从很大程度上未受监管的加密货币中受益匪浅。
- en: However, gambling games are often interactive in nature, requiring users to
    bet often in response to other people’s real-time bets. Ethereum’s slow confirmation
    time represents a great barrier for this type of game. Faster blockchains such
    as EOS and Tron, which is itself a fork from Ethereum, are now blockchains specialized
    in gambling dapps.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，赌博游戏通常是交互性的，要求用户经常对别人的实时投注进行下注。以太坊的慢确认时间对于这类游戏来说是一个巨大的障碍。像EOS和Tron这样的更快的区块链，Tron本身是从以太坊分叉出来的，现在是一些专门针对赌博DApps的区块链。
- en: Interactive Dapps
  id: totrans-456
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 交互式DApps
- en: Most Internet applications are interactive. For Ethereum blockchains to support
    interactive applications, performance is an important factor. The Lity project
    creates high-performance extensions to the Ethereum protocol and tools. It enables
    us to create interesting interactive dapps. See [Chapter 16](ch16.xhtml#ch16)
    for several complete examples.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数互联网应用都是互动式的。为了让以太坊区块链支持交互式应用，性能是一个重要因素。Lity项目为以太坊协议创建了高性能的扩展和工具。它使我们能够创建有趣的交互式DApps。请参阅[第16章](ch16.xhtml#ch16)以获取几个完整的示例。
- en: Conclusion
  id: totrans-458
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结论
- en: A dapp is typically a web3 application that runs in tandem with a wallet application.
    It interacts with smart contracts on the blockchain for essential data and core
    application logic. It can also use local storage or third-party services to store
    and manage nonessential data that is private to the user or could be regenerated
    by the public. In the next chapter, I will discuss how applications use blockchain
    data services, in addition to blockchain transactions, to provide a rich user
    experience.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 一个DApp通常是一个与钱包应用程序并行运行的web3应用程序。它与区块链上的智能合约进行交互，以获取基本数据和核心应用程序逻辑。它还可以使用本地存储或第三方服务来存储和管理对用户私有的非必要数据或可以由公众重建的数据。在下一章中，我将讨论应用程序如何使用区块链数据服务，以及区块链交易，以提供丰富的用户体验。
- en: 8. Alternatives to Dapps
  id: totrans-460
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8. DApps的替代方案
- en: The concept of dapps is compelling and native to blockchain technology’s most
    obvious use cases, such as peer-to-peer financing. However, the world is never
    binary. There are also many blockchain application use cases that could fit into
    the model of traditional web applications. Those are typically use cases where
    the public or consortium blockchain’s transparency and immutability can add value
    to an existing business. The application only needs the blockchain as a feature
    and does not need to decentralize the entire application itself. A payment processor
    for e-commerce web sites to accept cryptocurrencies is a good example. A crypto
    asset exchange (crypto to crypto or crypto to fiat) is another example.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 去中心化应用（DApps）的概念很有吸引力，并且与区块链技术的最明显用例（如点对点融资）密切相关。然而，世界从来都不是二元的。还有许多区块链应用用例可以适合传统网络应用的模型。这些通常是用例，其中公共或联盟区块链的透明性和不可变性可以为现有业务增加价值。应用程序只需要区块链作为一个特性，并不需要去中心化整个应用程序本身。电子商务网站的支付处理器以接受加密货币就是一个很好的例子。加密货币交易所（加密货币之间或加密货币与法定货币之间）是另一个例子。
- en: For those applications, we need to make blockchain transactions and/or make
    smart contract function calls from a server. To do that, the accounts’ private
    keys or keystores and passwords must be managed on the server side.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些应用，我们需要从服务器端发起区块链交易和/或调用智能合约函数。为此，账户的私钥或密钥库和密码必须在服务器端进行管理。
- en: For new transactions, it is obvious since the sender account needs to use its
    private key to authenticate the funds transferring out of it.
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于新交易，这是显而易见的，因为发送方账户需要使用其私钥来验证其资金的转出。
- en: For modifying contract states, an Ethereum-compatible blockchain requires the
    party requesting the change to pay a “gas fee” for network maintainers (miners)
    to validate the request and record the change in new blocks. That also requires
    transferring funds (a gas fee) out of the requestor’s account and hence requires
    its private key.
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于修改合约状态，以太坊兼容的区块链要求请求更改的一方支付“燃气费”给网络维护者（矿工）以验证请求并在新块中记录更改。这也需要将资金（燃气费）从请求者的账户中转出，因此需要其私钥。
- en: In this chapter, we explore how to access Ethereum-compatible blockchain functionalities
    from a web app. The basic approach is to use a web3-compatible library but without
    a client-side wallet like Metamask.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何从网络应用程序中访问以太坊兼容的区块链功能。基本方法是使用一个web3兼容的库，但不需要像Metamask这样的客户端钱包。
- en: JavaScript
  id: totrans-466
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: javascript
- en: The node.js framework enables JavaScript applications to be deployed on the
    server side. It is hence conceivable to use the web3.js library (or the compatible
    web3-cmt.js library) in a node.js server application.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 节点.js框架使得JavaScript应用程序能够部署在服务器端。因此，在node.js服务器应用程序中使用web3.js库（或兼容的web3-cmt.js库）是可行的。
- en: The Full-Node Wallet
  id: totrans-468
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 完整节点钱包
- en: The first approach is to use a fully synchronized Ethereum node as the “wallet”
    for the application. The GETH (Ethereum) or Travis (CyberMiles) software running
    the node is able to manage keystores (i.e., the web3.personal package), sign transactions,
    and broadcast transactions to other blockchain nodes. Through the blockchain node’s
    Remote Procedure Call (RPC) interface, external applications can interact with
    the blockchain.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法是使用一个完全同步的以太坊节点作为应用程序的“钱包”。运行节点的GETH（以太坊）或Travis（CyberMiles）软件能够管理密钥库（即web3.personal包），签署交易，并将交易广播到其他区块链节点。通过区块链节点的远程过程调用（RPC）接口，外部应用程序可以与区块链互动。
- en: You will need to synchronize a full Ethereum (or Ethereum-compatible blockchain,
    such as CyberMiles) node behind a firewall. The node should turn on RPC services
    (i.e., the Ethereum default port 8545) so that the server-side web application
    can access it behind the firewall. It is important that the node’s port 8545 be
    completely blocked by the firewall and available only inside the firewall, as
    illustrated in [Figure 8.1](ch08.xhtml#ch08fig1).
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在一个防火墙后同步一个完整的以太坊（或以太坊兼容的区块链，如CyberMiles）节点。节点应该开启RPC服务（即以太坊默认端口8545），这样服务器端网络应用程序就可以在防火墙后访问它。重要的是，节点的8545端口应完全被防火墙封锁，并且仅在防火墙内可用，如图[8.1](ch08.xhtml#ch08fig1)所示。
- en: '![image](Images/yuan_f08_01.jpg)'
  id: totrans-471
  prefs: []
  type: TYPE_IMG
  zh: '![图像](Images/yuan_f08_01.jpg)'
- en: '**Figure 8.1** The behind-the-firewall setup'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '**图8.1** 防火墙后的设置'
- en: The following code example shows how to call the `HelloWorld` contract’s `updateMessage()`
    function (see [Chapter 4](ch04.xhtml#ch04)) to record a new state in helloMessage
    onto the blockchain and pay its gas fees. We assume that the web3.js instance
    on the node.js server is attached to an Ethereum node that already has the keystore
    containing an account private key. The account has a sufficient balance to pay
    the gas fee for this transaction. You just need to unlock the account using its
    passphrase.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例展示了如何调用`HelloWorld`合约的`updateMessage()`函数（参见[第4章](ch04.xhtml#ch04)）在helloMessage中记录一个新的状态，并支付其燃气费。我们假设节点.js服务器上的web3.js实例附属于一个已经包含一个账户私钥的密钥库的以太坊节点。该账户有足够的余额支付此次交易的燃气费。您只需要使用密码短语解锁账户。
- en: '[Click here to view code image](Images/ch08_images.xhtml#pro8_1)'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 点击[此处查看代码图片](Images/ch08_images.xhtml#pro8_1)
- en: '[PRE46]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Of course, storing the keystores on the node is still insecure. A single misconfigured
    firewall setting might expose the node’s port 8545 to attackers. Attackers could
    easily gain access to all private keys on the server as they are unlocked by the
    web application.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，将密钥库存储在节点上仍然是不安全的。单个配置错误的防火墙设置可能会使节点的8545端口暴露给攻击者。攻击者可以轻松地访问服务器上的所有私钥，因为它们被网络应用程序解锁。
- en: Raw Transactions
  id: totrans-477
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 原始交易
- en: The second approach is to create signed raw transactions and then simply use
    web3.js to broadcast the transaction onto a blockchain node. In this setup, the
    blockchain node could be a third-party hosted node outside of the firewall, such
    as an Infura node. The blockchain node does not store any private key or keystore.
    The web application itself, however, manages the private keys it needs in a database
    table. [Figure 8.2](ch08.xhtml#ch08fig2) illustrates the architecture of this
    design.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法是创建已签名的原始交易，然后简单地使用web3.js将交易广播到一个区块链节点。在这种设置中，区块链节点可能是一个位于防火墙外的第三方托管节点，如Infura节点。区块链节点不存储任何私钥或密钥库。然而，网络应用程序本身却在数据库表中管理它需要的私钥。[图8.2](ch08.xhtml#ch08fig2)展示了这种设计的架构。
- en: '![image](Images/yuan_f08_02.jpg)'
  id: totrans-479
  prefs: []
  type: TYPE_IMG
  zh: '![图像](Images/yuan_f08_02.jpg)'
- en: '**Figure 8.2** Application-managed private keys'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '**图8.2** 应用程序管理的私钥'
- en: Signing raw transactions is beyond the scope of web3.js. We use the EthereumJS
    library here to work in conjunction with web3.js. In particular, the `ethereumjs-tx`
    project provides ways to sign transactions using private keys. The private keys
    are typically stored in database tables in this case.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 签署原始交易超出了web3.js的范围。在这里我们使用EthereumJS库与web3.js协同工作。特别是，`ethereumjs-tx`项目提供了使用私钥签署交易的方法。在这种情况下，私钥通常存储在数据库表中。
- en: The following code shows how to deploy the `HelloWorld` smart contract on Ethereum
    using a signed raw transaction. The gas fee is paid from the account, and the
    application has access to the private key.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码展示了如何使用已签名的原始交易在以太坊上部署`HelloWorld`智能合约。交易费用由账户支付，应用程序可以访问私钥。
- en: '[Click here to view code image](Images/ch08_images.xhtml#pro8_2)'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击此处查看代码图片](Images/ch08_images.xhtml#pro8_2)'
- en: '[PRE47]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The next example shows how to call the `updateMessage()` function on the contract:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例展示了如何调用合约上的`updateMessage()`函数：
- en: '[Click here to view code image](Images/ch08_images.xhtml#pro8_3)'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击此处查看代码图片](Images/ch08_images.xhtml#pro8_3)'
- en: '[PRE48]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The EthereumJS library is much more than just `ethereumjs–tx`. It provides the
    JavaScript to manage private keys, keystores, and wallets. It would be useful
    if you are doing extensive key management and low-level programming on your own.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊JS库远不止`ethereumjs-tx`。它提供了用于管理私钥、密钥库和钱包的JavaScript。如果你需要进行大量的密钥管理以及自行进行低层次编程，这将非常有用。
- en: Python and Others
  id: totrans-489
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Python及其他
- en: While JavaScript is the native language for web3.js, many developers do not
    like to use JavaScript on server applications. Because of that, there are other
    programming languages’ implementations of the web3 library. For example, web3.py
    is a Python implementation of web3\. The following code shows how to decrypt and
    construct a private key from a GETH keystore file. You can store the content of
    this keystore file in a database table, and its password in another database table.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管JavaScript是web3.js的本机语言，但许多开发人员不喜欢在服务器应用程序中使用JavaScript。正因为如此，才有了其他编程语言的web3库实现。例如，web3.py是web3的Python实现。下面的代码展示了如何从GETH密钥库文件中解密并构建私钥。你可以将这个密钥库文件的内容存储在数据库表中，其密码存储在另一个数据库表中。
- en: '[Click here to view code image](Images/ch08_images.xhtml#pro8_4)'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击此处查看代码图片](Images/ch08_images.xhtml#pro8_4)'
- en: '[PRE49]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: With the private key in place, the code segment next illustrates how to construct
    a raw transaction in web3.py to transfer ETH from one account to another.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 在私钥就位的情况下，接下来的代码段将展示如何使用web3.py构建原始交易，将ETH从一台账户转移到另一台账户。
- en: '[Click here to view code image](Images/ch08_images.xhtml#pro8_5)'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击此处查看代码图片](Images/ch08_images.xhtml#pro8_5)'
- en: '[PRE50]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The next example shows how to use web3.py to make a smart contract function
    call:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例展示了如何使用web3.py调用智能合约函数：
- en: '[Click here to view code image](Images/ch08_images.xhtml#pro8_6)'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击此处查看代码图片](Images/ch08_images.xhtml#pro8_6)'
- en: '[PRE51]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: There is obviously a lot more to the `web3.py` library, and it is substantially
    different from web3.js when it comes to the exact API usages. I encourage interested
    readers to review its documentation at [https://web3py.readthedocs.io](https://web3py.readthedocs.io).
    Furthermore, there are other programming language choices for web3.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: '`web3.py`库显然有很多内容，并且与web3.js在具体的API使用上有显著差异。我鼓励感兴趣的读者查阅其在[https://web3py.readthedocs.io](https://web3py.readthedocs.io)的文档。此外，还有其他编程语言可以选择的web3。'
- en: '*The PHP web3*: [https://github.com/formaldehid/php-web3](https://github.com/formaldehid/php-web3)'
  id: totrans-500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PHP的web3*：[https://github.com/formaldehid/php-web3](https://github.com/formaldehid/php-web3)'
- en: '*The Java web3*: [https://github.com/web3j/web3j](https://github.com/web3j/web3j)'
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Java的web3*：[https://github.com/web3j/web3j](https://github.com/web3j/web3j)'
- en: Since web applications vary a lot depending on the development framework you
    choose, I will leave it as an exercise for you to work out your own web applications.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 由于web应用程序根据你选择的开发框架而有很大差异，我将留给你自己练习构建自己的web应用程序。
- en: Conclusion
  id: totrans-503
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结论
- en: In this chapter, I discussed how to build server-side applications that interact
    with blockchains and smart contracts. Those applications require central servers
    to function and hence are less decentralized than the dapps discussed in [Chapter
    7](ch07.xhtml#ch07). However, for the short term, incorporating decentralized
    features into otherwise centralized applications could be the most plausible path
    for the mass adoption of blockchain applications.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我讨论了如何构建与区块链和智能合约交互的服务器端应用程序。这些应用程序需要中心服务器才能运行，因此与[第7章](ch07.xhtml#ch07)中讨论的去中心化应用程序（dapps）相比，其去中心化程度较低。然而，从短期来看，将去中心化特性整合到其他中心化应用程序中，可能是区块链应用程序大规模采用的最可行路径。
