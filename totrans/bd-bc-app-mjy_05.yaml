- en: 'Part II: An Introduction to Ethereum'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this part of the book, I introduce one of the most important public blockchains
    today, Ethereum. In terms of market cap, Ethereum is second only to the Bitcoin
    blockchain. Since Ethereum was the first blockchain that pioneered the concept
    of smart contracts, many public and private blockchains today are compatible with
    Ethereum to leverage the Ethereum developer community. In that regard, Ethereum
    is not just a public blockchain. It is a protocol many other blockchains conform
    to.
  prefs: []
  type: TYPE_NORMAL
- en: Hence, for developers, it is important to understand how Ethereum works and
    how to write applications (i.e., smart contracts and decentralized applications)
    on it. The chapters in this part will discuss how to build Ethereum-compatible
    smart contracts and applications from the ground up. It is important to note that
    there are several Ethereum-compatible blockchains you can use to develop and deploy
    Ethereum applications, ESPECIALLY for applications optimized for specific business
    use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Then, in [Part III](part3.xhtml#part03) of the book, I will further explore
    the inner workings and future plans of Ethereum.
  prefs: []
  type: TYPE_NORMAL
- en: 4. Getting Started
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While it is possible to write software programs for the Bitcoin blockchain,
    few people do because of the limited programming functionality supported on the
    Bitcoin network.
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum is the first large-scale blockchain network that supports sophisticated
    application development. Ethereum’s ambition is to become the “world’s computer.”
    Through autonomous software programs, known as *smart contracts*, the Ethereum
    blockchain can be programmed to automatically execute transactions when certain
    conditions are met. To support this, Ethereum natively supports a Turing complete
    programming language (Solidity) and virtual machine (Ethereum Virtual Machine
    [EVM]), making it possible to program a wide range of applications.
  prefs: []
  type: TYPE_NORMAL
- en: For programmers, writing smart contract code to run on the Ethereum blockchain
    is the first step into the world of blockchain application development. As Ethereum
    continues to gain popularity and value, programming Ethereum applications has
    become a necessary and valuable skill.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will start with a simple “Hello, World!” smart contract
    on Ethereum. We walk through the entire process to deploy and then interact with
    it on one of the Ethereum’s test networks using popular tools. This example aims
    to get you started with Ethereum as quickly as possible. The subsequent chapters
    will go deeper into those concepts and alternative tools.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: It is often beneficial to develop your applications on an Ethereum-compatible
    blockchain rather than the Ethereum blockchain itself. You have seen the Second
    State DevChain as a clear example of a fast Ethereum-compatible blockchain. Later
    in this book, we will use the CyberMiles public blockchain as another Ethereum-compatible
    alternative for developers. The CyberMiles public blockchain is optimized for
    e-commerce applications. But at the same time, it is fully compatible with Ethereum
    languages and tools with faster execution speed, faster transaction confirmation
    time (10s), and much lower cost (1,000 times cheaper). You can learn more in [Chapter
    14](ch14.xhtml#ch14).
  prefs: []
  type: TYPE_NORMAL
- en: The BUIDL Way
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In [Chapter 3](ch03.xhtml#ch03), I introduced you to the BUIDL open source integrated
    development environment (IDE). It works with all Ethereum-compatible blockchains
    including the Ethereum mainnet and testnet. Let’s set up BUIDL to work with Ethereum.
    Open the BUIDL web app at [http://buidl.secondstate.io/](http://buidl.secondstate.io/)
    and click the **Providers** tab in the lower-left corner of the browser window
    ([Figure 4.1](ch04.xhtml#ch04fig1)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 4.1** Configuring BUIDL to work with the Ethereum mainnet'
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum Mainnet
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You should configure the web3 and ES (Elasticsearch) providers to public Ethereum
    nodes, as shown below. Or you can launch the following URL to have everything
    auto-configured for Ethereum. [https://buidl.secondstate.io/eth](https://buidl.secondstate.io/eth)
  prefs: []
  type: TYPE_NORMAL
- en: '*ES provider*: Set this to [https://eth.search.secondstate.io/](https://eth.search.secondstate.io/).
    The ES provider is a smart contract search engine that provides real-time data
    from the Ethereum network. You can learn more in [Chapter 11](ch11.xhtml#ch11).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Web3 provider*: Set this to [https://mainnet.infura.io/](https://mainnet.infura.io/).
    This is a public Ethereum blockchain node provided by Infura. Infura requests
    regular users to register an API key in order to use their services. Please do
    so and set your own mainnet.infura.io URL with your API key here. Alternatively,
    you could use a community-provided web3 provider such as [https://main-rpc.linkpool.io/](https://main-rpc.linkpool.io/)
    or [https://eth.node.secondstate.io/](https://eth.node.secondstate.io/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Chain ID*: Set this to 1 for the Ethereum mainnet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Custom Tx gas*: Check this box so that BUIDL uses the specified gas price
    when creating contracts and calling contract functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Gas price*: Set this to 10000000000 (wei, or 10 Gwei) as the default gas price
    used by BUIDL. You can use the Ethereum Gas Tracker to see the current gas price
    on the network ([https://etherscan.io/gasTracker](https://etherscan.io/gasTracker)).
    The higher gas price you are willing to pay, the faster your transactions can
    be confirmed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Gas limit*: Set this to 8000000, which is the current block gas limit for
    Ethereum.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: Since the Ethereum mainnet can be extremely congested from time to time, you
    should be prepared to pay a high gas price (as much as $10 USD just to deploy
    a contract or call a function), and you could wait hours for the transaction to
    confirm. I recommend that most developers develop and even deploy on much faster
    and cheaper blockchains such as the Ethereum Classic or CyberMiles.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have configured BUIDL to pay gas when deploying and calling smart contracts
    on Ethereum. BUIDL creates five random accounts for each user and then uses the
    default selected account to interact with the blockchain ([Figure 4.2](ch04.xhtml#ch04fig2)).
    So, you need an ETH balance in the default account. Just send some ETHs from your
    wallet or exchange accounts to your BUIDL default account. Or, you can use the
    + button next to Accounts to import an ETH account from other wallets.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 4.2** Select a default account in BUIDL. You need an ETH balance in
    it to pay for gas.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: BUIDL has a built-in wallet that manages account private keys. However, BUIDL
    can only sign transactions and pay gas from its accounts. It is designed for application
    development. BUIDL is not a general-purpose wallet, and I do not recommend maintaining
    more than 0.1 ETH balance in it.
  prefs: []
  type: TYPE_NORMAL
- en: That’s all you need in the contract tab. You can now write a smart contract,
    click the **Compile** and **Deploy to the chain** buttons to deploy it to Ethereum,
    and then use the BUIDL user interface (UI) to call any function on the deployed
    contract.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, on the dapp tab of BUIDL, you need to add `gasPrice` and `gas` parameters
    to all web3 transactions. You are safe to use BUIDL’s default `web3.ss` package
    here, as it contains all `web3.eth` objects and functions. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch04_images.xhtml#pro4_1)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: That’s it. You now have the default BUIDL example smart contract and dapp deployed
    on the Ethereum public blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum Classic Mainnet
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you are not willing to pay $10 USD and wait hours for every contract call,
    you can use the Ethereum Classic blockchain to deploy your applications. The Ethereum
    Classic blockchain is one of the most reputable and stable blockchain networks
    in the world, and it is fully compatible with the Ethereum protocol. Its native
    cryptocurrency, ETC, costs a fraction of ETH. The Ethereum Classic blockchain
    is seldom congested, and hence a 10 Gwei gas price (pennies) typically results
    in transaction confirmation in less than a minute. To configure BUIDL to use the
    Ethereum Classic mainnet, use the following settings. Or you can launch the following
    URL to have everything auto-configured for Ethereum Classic. [https://buidl.secondstate.io/etc](https://buidl.secondstate.io/etc)
  prefs: []
  type: TYPE_NORMAL
- en: '*ES provider* : Set this to [https://etc.search.secondstate.io/](https://etc.search.secondstate.io/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Web3 provider* : Set this to [https://www.ethercluster.com/etc](https://www.ethercluster.com/etc).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Chain ID*: Set this to 61 for the Ethereum Classic mainnet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Custom Tx gas*: Check this box.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Gas Price*: Set this to 10000000000 (wei, or 10 Gwei) as the default gas price
    used by BUIDL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Gas Limit*: Set this to 8000000.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition, the current Ethereum Classic blockchain requires Solidity compiler
    version 0.4.2.
  prefs: []
  type: TYPE_NORMAL
- en: You must configure that for BUIDL by using URL parameter `/?s042` when launching
    BUIDL.
  prefs: []
  type: TYPE_NORMAL
- en: Send some ETC to your BUIDL account as gas. You can now compile, deploy, and
    call your smart contract on the Ethereum Classic blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: CyberMiles Mainnet
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The CyberMiles public blockchain is an Ethereum-compatible blockchain that is
    much faster (a ten-second transaction confirmation time) and cheaper than both
    ETH and ETC. You can read more about it in [Chapter 14](ch14.xhtml#ch14). To configure
    BUIDL to use the CyberMiles mainnet, configure the following settings. Or you
    can launch the following URL to have everything auto-configured for CyberMiles.
    [https://buidl.secondstate.io/cmt](https://buidl.secondstate.io/cmt)
  prefs: []
  type: TYPE_NORMAL
- en: '*ES provider* : Set this to [https://cmt.search.secondstate.io/](https://cmt.search.secondstate.io/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Web3 provider* : Set this to [https://rpc.cybermiles.io:8545/](https://rpc.cybermiles.io:8545/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Chain ID*: Set this to 18 for the CyberMiles mainnet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Custom Tx gas*: Check this box.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Gas Price*: Set this to 5000000000 (wei, or 5 Gwei) as the default gas price
    used by BUIDL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Gas Limit*: Set this to 8000000.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Send some CMT to your BUIDL account as gas. You can now compile, deploy, and
    call your smart contract on the CyberMiles blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum, Ethereum Classic, and CyberMiles all have testnets for developers
    to try their applications without spending real money. However, from my experience,
    testnet tokens are difficult to come by, and the test dapps are difficult to share,
    as few users have testnet wallets or tokens. The testnet is also often unreliable
    and runs different software than the mainnet. For CyberMiles, the cost of transactions
    is less than 1 cent. It is a good choice even for development purposes.
  prefs: []
  type: TYPE_NORMAL
- en: The Hard Way
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The key benefit of BUIDL is that it is easy to use and allows fast development
    cycles. But it also hides some important concepts from the application developer.
    In this section, we will take a step back and use more traditional Ethereum developer
    tools to explain the concepts behind Ethereum.
  prefs: []
  type: TYPE_NORMAL
- en: Metamask Wallet
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Metamask wallet is a Chrome browser extension to manage your Ethereum blockchain
    accounts. It stores and manages your private keys to those accounts on your computer
    (i.e., a wallet for private keys and, by extension, cryptocurrency stored in those
    accounts). For developers, Metamask is a great tool since it integrates with other
    development tools and allows you to interact with Ethereum accounts programmatically.
  prefs: []
  type: TYPE_NORMAL
- en: First, make sure you have the latest Google Chrome browser installed. You can
    get it at [https://www.google.com/chrome/](https://www.google.com/chrome/).
  prefs: []
  type: TYPE_NORMAL
- en: Next, follow the instructions on the Metamask web site ([https://metamask.io/](https://metamask.io/))
    to install Metamask on your Chrome browser.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you should see the Metamask icon on your Chrome toolbar. Click it to bring
    up its UI. You should create a password for your Metamask wallet ([Figure 4.3](ch04.xhtml#ch04fig3)).
    This is important since your password protects your account’s private keys stored
    on this computer. Once you create the password, Metamask will give you a 12-word
    recovery phase. That is the only way for you to recover the password, so keep
    it safe!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 4.3** Creating a password for your Metamask wallet'
  prefs: []
  type: TYPE_NORMAL
- en: For development purposes, select the top-left drop-down list in the Metamask
    UI, and select the Ropsten Test Network ([Figure 4.4](ch04.xhtml#ch04fig4)), which
    is an Ethereum public blockchain maintained for testing purposes.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 4.4** Selecting the Ropsten testnet'
  prefs: []
  type: TYPE_NORMAL
- en: You will also need to create an account on the Ropsten testnet to store your
    ETH cryptocurrency there. Select the person icon at the top right of the Metamask
    UI, and select **Create Account** ([Figure 4.5](ch04.xhtml#ch04fig5), left). Metamask
    will create an account address and its associated private key for you. You can
    click an account in the UI and get its address in the clipboard or export its
    private key ([Figure 4.5](ch04.xhtml#ch04fig5), right). You can name this account
    so that you can access it in the Metamask UI later. You can also use Metamask
    to manage mainnet ETHs, which can be traded on exchanges for U.S. dollars. But
    to do that, you should make sure that your computer is physically secure since
    real money will be at stake.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 4.5** Creating a new account on the Ropsten testnet and getting the
    account address'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, you still need to fund your account with some Ropsten testnet ETH
    to use it. Go to the public Ropsten faucet ([http://faucet.ropsten.be:3001/](http://faucet.ropsten.be:3001/))
    and request 1 testnet ETH for your address! The Ropsten testnet ETH can be used
    only on the testnet. It is not traded in any exchanges and can disappear at any
    time when the Ropsten testnet is retired. Unlike the mainnet ETH, Ropsten ETH
    has zero monetary value.
  prefs: []
  type: TYPE_NORMAL
- en: Now you have set up Metamask and are ready to interact with your first Ethereum
    smart contract on the Ropsten testnet!
  prefs: []
  type: TYPE_NORMAL
- en: Remix
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Remix the Ethereum IDE for developers to experience smart contracts on the
    Ethereum blockchain. Remix is completely web-based. Just go to its web site to
    load the web app: [http://remix.ethereum.org/](http://remix.ethereum.org/).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: The Remix IDE is similar to the contract tab in BUIDL, except that BUIDL does
    not require any external wallet like Metamask.
  prefs: []
  type: TYPE_NORMAL
- en: In the code editor to the right, let’s enter a simple smart contract. The following
    is an example of the “Hello, World!” smart contract. It is written in a special
    JavaScript-like programming language known as Solidity.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch04_images.xhtml#pro4_2)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The “Hello, World!” smart contract has two key methods.
  prefs: []
  type: TYPE_NORMAL
- en: The `sayHello()` method returns a greeting to its caller. The greeting is initially
    set to “Hello, World!” when the smart contract is deployed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `updateMessage()` method allows the method caller to change the greeting
    message from “Hello, World!” to another message.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hit the **Start to compile** button in the right panel to compile this contract
    ([Figure 4.6](ch04.xhtml#ch04fig6)). It will generate the bytecode and application
    binary interface (ABI) to be used later.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 4.6** Compiling an Ethereum smart contract in Remix'
  prefs: []
  type: TYPE_NORMAL
- en: Next, on the Run tab of Remix ([Figure 4.7](ch04.xhtml#ch04fig7)), you can connect
    Remix to your Metamask account via the Injected Web3 drop-down box. Remix will
    automatically detect your existing Metamask accounts. If your Ropsten address
    does not show up here, try logging out and then back into Remix.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 4.7** Injecting Metamask into Remix'
  prefs: []
  type: TYPE_NORMAL
- en: You should now see options to deploy the smart contract to the blockchain. Click
    the **Deploy** button to deploy the contract to the blockchain. Since you have
    selected a Ropsten address to inject into this Remix session, the contract will
    be deployed on the Ropsten testnet. At this time, Metamask will pop up and ask
    you to send a gas fee from your existing account address ([Figure 4.8](ch04.xhtml#ch04fig8)).
    The gas fee is required by the Ethereum network to pay for the network service
    required to deploy your contract.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 4.8** Paying a gas fee to deploy the contract'
  prefs: []
  type: TYPE_NORMAL
- en: After you submit the Metamask request, wait for a few minutes for the Ethereum
    network to confirm the deployment of your contract. The contract deployment address
    will be shown in the confirmation, and the deployed contract and its available
    functions will be available on the Run tab in Remix as well ([Figure 4.9](ch04.xhtml#ch04fig9)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f04_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 4.9** The contract is now deployed, and the available methods are
    shown.'
  prefs: []
  type: TYPE_NORMAL
- en: If you have already deployed the smart contract on the Ropsten testnet, you
    already know the deployed address of the contract. You can simply enter the contract
    address in the box next to the At Address button and click the button. This configures
    Remix to use an already-deployed contract. No gas fee is needed in this case.
  prefs: []
  type: TYPE_NORMAL
- en: Once Remix is connected to your deployed contract, it shows the contract functions
    on the Run tab. You can enter a new greeting next to the updateMessage button
    and click the button to update the message. Since Ethereum network storage is
    required to store the updated message, you will again be prompted to pay a gas
    fee through Metamask.
  prefs: []
  type: TYPE_NORMAL
- en: Once the network confirms the message update, you will again see a confirmation
    message ([Figure 4.10](ch04.xhtml#ch04fig10)). After the `updateMessage()` method
    is confirmed, you can call `sayHello()` from Remix ([Figure 4.11](ch04.xhtml#ch04fig11)),
    and you will see the updated message. The `sayHello()` function does not alter
    the blockchain state. It can be executed by a local node connected to Remix and
    does not affect any other node on the network. It can be executed without any
    need for gas fees.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 4.10** Calling the `updateMessage()` method'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f04_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 4.11** Calling the `sayHello()` method'
  prefs: []
  type: TYPE_NORMAL
- en: The Remix IDE is easy to use. It is an excellent choice for beginners. As your
    development skill advances, there are additional tools you can use to develop
    and deploy smart contracts. [Chapter 6](ch06.xhtml#ch06) has more details.
  prefs: []
  type: TYPE_NORMAL
- en: Web3
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: While Remix is a great tool, it is too hard for regular people. To make your
    smart contracts available to the general public, you typically need to build a
    web-based UI. For that, you need the web3 JavaScript library to interact with
    the Ethereum blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: The dapp tab in BUIDL injects a preconfigured web3 instance into the JavaScript
    program in BUIDL.
  prefs: []
  type: TYPE_NORMAL
- en: Once Metamask is installed, it automatically injects a custom instance of the
    web3 object into the page’s JavaScript context. Method calls that require private
    keys will automatically prompt the user to select an account, and Metamask will
    use the selected private key to sign the transaction before sending it to the
    Ethereum network.
  prefs: []
  type: TYPE_NORMAL
- en: The overall structure of a web3 dapp is a JavaScript function that starts when
    the web page loads (i.e., the following `onPageLoad()` function). The JavaScript
    function manages the application state and makes function calls to the smart contract
    on the blockchain. Because of network delay and confirmation requirements for
    blockchain operations, all web3 API calls are asynchronous. So, we use the web3
    callback API to handle the return values. Notice that if you need to make one
    smart contract call after another, you must nest those calls. The following code
    snippet shows the structure of the JavaScript function. The `myFunc()` and `anotherFunc()`
    calls can happen in parallel at the same time, while the `secondFunc()` call must
    happen after `myFunc()` returns.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch04_images.xhtml#pro4_3)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The “Hello, World!” example, however, does not require complex sequences of
    smart contract function invocations. It just needs to invoke one contract function
    and then update the web UI. The source code for the `helloworld.html` file is
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch04_images.xhtml#pro4_4)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Notice the `web3.eth.contract(...).at("...")` line. The at() function takes
    the contract’s deployment address on the blockchain as a parameter. You can find
    it on the Run tab’s Deployed Contracts section, as shown in [Figures 4.9](ch04.xhtml#ch04fig9)
    and [4.10](ch04.xhtml#ch04fig10). The contract function takes a JSON structure
    known as the contract’s ABI. You can find that by clicking the Details button
    on the Compile tab. You can copy the entire ABI section to your computer’s clipboard
    by clicking the clipboard icon. Alternatively, the WEB3DEPLOY section’s first
    line of code shows the `contract` function’s ABI parameter all on one line ([Figure
    4.12](ch04.xhtml#ch04fig12)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f04_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 4.12** Finding the ABI'
  prefs: []
  type: TYPE_NORMAL
- en: The web application now allows users to interact with the “Hello, World!” smart
    contract directly from the Web ([Figure 4.13](ch04.xhtml#ch04fig13)). To submit
    a new message, the app requires Metamask to send gas fees as it calls the `updateMessage()`
    function on the contract. Notice that all web3 functions are nested and invoked
    asynchronously. You can read more about dapp development in [Chapter 7](ch07.xhtml#ch07).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f04_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 4.13** Using the Metamask wallet to write to a contract'
  prefs: []
  type: TYPE_NORMAL
- en: Using Metamask with web3.js is probably the best way to get started with Ethereum
    application development. But for the average web user, installing and using Metamask
    is a significant barrier of entry. As you have seen, the BUIDL IDE provides a
    light-weight wallet on the dapp web page, which is probably sufficient for users
    who just need to pay gas for their interactions with the Ethereum blockchain.
    Or, we could design the application so that a centralized server pays for gas
    on behalf of users (see [Chapter 8](ch08.xhtml#ch08)).
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, I explained how to build, deploy, and use a smart contract
    on Ethereum-compatible blockchains. We used tools such as Metamask, Remix, and
    web3 to get started. In the next several chapters, we will explore the key concepts
    behind Ethereum, software tools involved in its operation, inner workings of smart
    contracts, alternative development tools, and the software stack for decentralized
    applications. We will tie everything together with a new dapp that showcases the
    capability of smart contracts in [Chapter 16](ch16.xhtml#ch16).
  prefs: []
  type: TYPE_NORMAL
- en: 5. Concepts and Tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous chapter, I showed you how to build, deploy, and interact with
    an Ethereum smart contract. However, by focusing on graphical user interface (GUI)
    tools, we have also left many concepts and points unexplained.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I will explain how to run and interact with an Ethereum node.
    In the process, you will learn critical concepts behind the design, implementation,
    and operation of the Ethereum blockchain. Those concepts also apply to Ethereum-compatible
    blockchains.
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum Wallet and Basic Concepts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To use Ethereum, you first need an Ethereum wallet to hold your ETH coins. Like
    Bitcoin, anyone can create an “account” on the Ethereum blockchain to hold and
    transact ETH coins. An account is uniquely identified by a pair of public and
    private keys. A *key* is a long string of seemingly random numbers and characters.
    The key pair can be randomly generated on your own computer.
  prefs: []
  type: TYPE_NORMAL
- en: The Ethereum account number is directly derived from the public key. If someone
    wants to send you some ETHs, all they need is the account number.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The private key is used to identify the owner of this account. When you need
    to move ETH out of the account (i.e., to spend it or transfer to another account),
    you will need the private key. Without the private key, the Ethereum miners will
    deem the transaction invalid and refuse to include it in the blockchain.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now you see that it is critical to safeguard your private key. If someone else
    gets hold of it, that person will have full authority over the ETHs in that account.
    And if you somehow lose the private key, you will forever lose control over the
    ETHs in your account—the ETHs will remain in the account for the world to see,
    but no one can move or spend them without the private key.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the wallet does is store and manage your public/private key pair. It often
    also provides a UI for you to manage ETHs in your account using the underlying
    public/private key pair. The wallet can be a completely stand-alone piece of software
    (or even hardware). Or, it can be a web application that stores your keys on their
    servers. Here are some notable wallets for Ethereum:'
  prefs: []
  type: TYPE_NORMAL
- en: Mist is the official wallet software from the Ethereum development team. You
    can install and run it on your own computer. It is more than just a wallet, though;
    it is a “blockchain browser” that includes a full Ethereum node. For example,
    you can upload smart contract code using Mist. That also means Mist requires more
    than 4GB of RAM and more than 100GB of hard drive space to run. It takes 24 to
    48 hours for Mist to start the first time as it needs to download the entire blockchain
    history.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parity is another fully featured GUI Ethereum client. It competes against Mist.
    It is supposed to be faster than Mist. But still, it needs to download the entire
    blockchain to run a full Ethereum node.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Metamask, covered in [Chapter 4](ch04.xhtml#ch04), is a Chrome-based wallet.
    It stores the private keys on your computer with the Chrome browser. Hence, physical
    security of your computer is important for Metamask wallets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The imToken mobile app is a wallet for your smartphone. You can create key pairs
    (accounts) in the app and use the app to send and receive ETH to and from your
    accounts in the wallet. The imToken app does not download the blockchain itself.
    It starts instantly and is ready for use.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tezer and Ledger are USB key-sized hardware devices that store and manage your
    keys. They typically work in tandem with a computer program. The computer program
    provides the UI to check balances and create transactions. When it needs to sign
    a transaction, it passes to the USB device to complete it. The private key never
    leaves the USB device.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coinbase is a web-based wallet, which also provides banking services to convert
    your ETHs to and from U.S. dollars. Almost all crypto exchanges have wallets for
    you to deposit and withdraw coins.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: If you are running a wallet application on your own PC/mobile/dedicated hardware
    device, you must be responsible for the physical safety of the device. Do not
    lose your private key!
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum-compatible blockchains also have their own wallet applications. For
    example, the CyberMiles blockchain has its own Metamask-like Chrome extension
    wallet, as well as a stand-alone mobile wallet application, called CyberMiles
    App, which can run web3-based dapps. Learn more in [Appendix A](app.xhtml#app).
  prefs: []
  type: TYPE_NORMAL
- en: If the wallet manages only the public/private key pairs, what about the coins
    and tokens stored in those accounts? Are your coins in your wallet? The answer
    is no, your tokens or coins are not in your wallet. Remember that the blockchain
    is a ledger system. It records all the transactions and balances associated with
    all accounts in the system. So, the wallet needs to manage only your account credentials,
    and the tokens or coins in your account can be found on the blockchain itself.
  prefs: []
  type: TYPE_NORMAL
- en: Etherscan
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Etherscan web site is a useful tool to look into the internal states of
    the Ethereum blockchain. You can use it to look up and review every transaction
    recorded on the blockchain and, by extension, the balance and history of every
    account. On its front page, you can see the latest blocks and the transactions
    within them ([Figure 5.1](ch05.xhtml#ch05fig1)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 5.1** Latest blocks and transactions in Etherscan'
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: Most blockchains also have their own blockchain explorer. For example, the CyberMiles
    public blockchain has [https://www.cmttracking.io/](https://www.cmttracking.io/),
    which shows not only transactions but also data related to its delegated proof
    of stake operations. Learn more in the Appendix.
  prefs: []
  type: TYPE_NORMAL
- en: Wallets or exchanges can also display transactions to or from your account.
    Etherscan shows the accounts and fund involved, as well as whether the transaction
    is validated by blockchain miners ([Figure 5.2](ch05.xhtml#ch05fig2)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 5.2** Drilling into a transaction'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, as a developer, it is not enough just to have accounts and ETHs.
    We want to run the blockchain software, mine ETH coins, and execute our own smart
    contracts.
  prefs: []
  type: TYPE_NORMAL
- en: The TestRPC
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To study and develop applications for Ethereum, you need access to the Ethereum
    Virtual Machine (EVM). Ideally, you would run a full Ethereum node on the blockchain
    and communicate with the blockchain network through that node. However, a full
    Ethereum node is expensive. For developers, it is much easier to get started with
    the TestRPC. I will discuss how to run Ethereum full nodes later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: To run a full Ethereum node and join the Ethereum network, you will need to
    run a full Ethereum client, download the entire transaction history of the Ethereum
    blockchain (more than 100GB worth of data), and then start “mining” ETH to participate
    in the process of validating transactions and creating new blocks on the blockchain.
    This is a big commitment and requires a significant amount of computing resources.
    Even then, you are unlikely to mine any ETH successfully—with ETH traded at above
    $150, mining competition is fierce. Since most tasks on the public Ethereum blockchain
    require ETH to complete, you will need to purchase ETH just to start experimenting
    with it. Again, at $150+ per ETH, that is an expensive learning process.
  prefs: []
  type: TYPE_NORMAL
- en: For developer testing of Ethereum application programming interface (API) functions
    and smart contract programming, you can use a simulator that simply answers all
    Ethereum API calls but does not incur the cost of actually building a blockchain
    network. The TestRPC is just such a simulator. The TestRPC was originally developed
    as a volunteer open source project. It was later acquired by the company behind
    the open source Truffle framework for smart contract development (renamed to Ganache
    CLI; see [https://github.com/trufflesuite/ganache-cli](https://github.com/trufflesuite/ganache-cli)).
  prefs: []
  type: TYPE_NORMAL
- en: 'You should first make sure that node.js and its package manager npm, are installed
    on your machine. You can install them from [https://www.npmjs.com/get-npm](https://www.npmjs.com/get-npm).
    On most Linux distributions, you can use the system package manager to install
    them as well. For example, the following command installs node.js and npm on a
    CentOS/RedHat/Fedora Linux system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch05_images.xhtml#pro5_1)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Next, let’s install the Ganache CLI using the npm package manager.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch05_images.xhtml#pro5_2)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You can start the TestRPC server from the command line. It will randomly create
    ten accounts (pairs of public key addresses and private keys). All the accounts
    are unlocked by default for easy testing.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch05_images.xhtml#pro5_3)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: You can start the TestRPC node with the same set of accounts every time, and
    you can give each account an initial balance as well.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch05_images.xhtml#pro5_4)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The TestRPC is a fully featured Ethereum simulator. It is much faster than any
    live Ethereum node because it does not perform the actual work of creating, mining,
    and synchronizing blocks. That makes it ideally suited for fast turnaround development
    cycles.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with Ethereum via GETH
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once the TestRPC node starts or the full Ethereum node is synchronized to the
    blockchain, you can use the GETH program to connect to it and send commands and
    interactions to the network. All you need to do is to attach the GETH command
    to the node by specifying the node’s IP address. If the node is running locally
    (e.g., a TestRPC node on the local machine), you can simply use `localhost` for
    the IP address.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch05_images.xhtml#pro5_5)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: GETH opens an interactive console in the new terminal, and you can use the Ethereum
    JavaScript API to access the blockchain. For instance, the following commands
    will create a new account to hold virtual currency on this network. Just repeat
    it a few times, and you will see a few accounts in the `eth.accounts` list. As
    mentioned earlier, each account consists of a pair of private and public keys.
    Only the public key is recorded on the blockchain in every transaction that involves
    this account.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch05_images.xhtml#pro5_6)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: When you create or unlock accounts from the GETH console, the private key of
    the account is stored in the keystore file on the attached node’s file system.
    On a live Ethereum node (i.e., not the TestRPC), you can start mining and deposit
    the ethers you mine to one of your accounts. For the TestRPC, you will have ETHs
    in your initial accounts, and you can skip this step.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch05_images.xhtml#pro5_7)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Next, you can send some of your ethers from one account to another. If your
    GETH console is attached to a live Ethereum node, you will need access to the
    sender account’s private key via the keystore and passphrase on the node. If you
    are attached to TestRPC either via `localhost` or remotely, you can skip the account
    unlocking calls, as all accounts are unlocked by default in the TestRPC. On a
    console attached to a live Ethereum node, if you do not call the `unlockAccount()`
    method first, the `sendTransaction()` method will ask for your passphrase to unlock
    the account for you.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch05_images.xhtml#pro5_8)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The last line is the transaction ID for the transaction to send 0.05 ETH between
    the two accounts. Using a tool like Etherscan, you will be able to see a record
    of this transaction on the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with Ethereum via web3
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The GETH interactive console is convenient to test and experiment with the Ethereum
    blockchain using the JavaScript API methods. But to access the Ethereum blockchain
    from an application, you can use the JavaScript API directly from a web page.
  prefs: []
  type: TYPE_NORMAL
- en: The web page in [Figure 5.3](ch05.xhtml#ch05fig3) shows an application that
    queries an Ethereum account’s balance. The user enters an account address, and
    the JavaScript API retrieves and displays the account balance.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 5.3** A demo page for web3.js'
  prefs: []
  type: TYPE_NORMAL
- en: Via the web3.js library provided by the Ethereum project, the JavaScript on
    the page first connects to an Ethereum node. Here, you can put in your own Ethereum
    node (e.g., `http://node.ip.addr:8545`) or a public node INFURA provides (see
    the following example). For a local TestRPC node, you can simply use the `http://localhost:8545`
    URL.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch05_images.xhtml#pro5_9)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Then the JavaScript uses web3.js functions to query the address. These are the
    same JavaScript method calls we can make in the GETH console.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch05_images.xhtml#pro5_10)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Our demo application queries the account balance. The balance is public information
    and does not require any account private key. If your web3.js application needs
    to send ETH from one account to another, you will need access to the sending account’s
    private key. There are several ways to do this, and I will cover them in [Chapter
    8](ch08.xhtml#ch08).
  prefs: []
  type: TYPE_NORMAL
- en: Running an Ethereum Node
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While the TestRPC is great for beginners, to truly understand the Ethereum blockchain,
    you should run your own node. Only through your own node can you examine the blocks
    and access all the functionalities the blockchain offers. In this section, I will
    discuss how to run a node on the Ethereum public network. It requires a significant
    amount of computing resources, such as a 24/7 available server and Internet connection,
    as well as at least a few hundred gigabytes of disk space to store the blockchain
    data. If you are on a development team (e.g., in a company), it is sufficient
    to run a single node for all the team members to access. To get started, download
    the official Ethereum client software GETH to your computer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch05_images.xhtml#pro5_11)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The official GETH program is written in the GO programming language. It is simply
    a compiled binary executable program that you can run from the command line.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: If you start GETH with all the default options, you will be connected to the
    public Ethereum blockchain. To start the node in noninteractive node and keep
    it running in the background after the current user logs out, use NOHUP.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: It will take hours and many gigabytes of RAM and disk space to download and
    sync the entire blockchain history. So, it is probably a good idea to start GETH
    on the official Ethereum test network. That will cut down on the initial startup
    time and resources significantly, but still you need to prepare to wait for several
    hours even to sync the testnet.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: The ether cryptocurrency (ETH) you mine or receive on testnet or your private
    network has no value. It can be used only for network testing purposes. You cannot
    exchange it on the open market.
  prefs: []
  type: TYPE_NORMAL
- en: As I mentioned earlier in this section, you need only one running Ethereum node
    for the entire development team. The GETH client on the running Ethereum node
    manages its own keystore on the machine’s local file system. All the accounts
    created through this node will have their private keys stored in this file, and
    each private key will be protected by a passphrase. The keystore file is located
    in the following directories. You can copy the keystore file to another node and
    access the accounts from the new node. You can also extract the private key from
    the keystore and sign your transactions to access the account from any node on
    the Ethereum blockchain network.
  prefs: []
  type: TYPE_NORMAL
- en: 'Linux: `~/.ethereum/keystore`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Mac: `/Library/Ethereum/keystore`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Windows: `%APPDATA%/Ethereum`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Companies like INFURA ([https://infura.io/](https://infura.io/)) provide public
    Ethereum nodes on the Internet. This saves you the trouble and significant resources
    required by running a node. However, the public nodes cannot store private keys
    for security reasons. Specifically, you have to use signed transactions to access
    accounts.
  prefs: []
  type: TYPE_NORMAL
- en: Running a Private Ethereum Network
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For developers, it is often a good idea just to start your own private Ethereum
    test network. The following command starts the first node on the private network
    from scratch (i.e., block 0, or the *genesis*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many command-line options for geth that you can use to customize
    your private network. For example, you could pass a genesis.json file to the geth
    init command and specify the following: peer nodes on the network, initial coin
    balances for selected accounts, difficulty in mining new coins, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: Running a single node network is oftentimes sufficient for development tasks.
    But sometimes you do need a real network with multiple nodes. To start a new peer
    node, find out the identity of your current (first) node in the interactive console.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch05_images.xhtml#pro5_12)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: With the enode ID, you can start a second peer node from another computer. Notice
    that the [::] in the enode ID is your node’s IP address. So, you will need to
    replace it with the IP address of the first node.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch05_images.xhtml#pro5_13)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: You can now start more peer nodes. The `bootnodes` parameter can take multiple
    enode addresses separated by commas. Alternatively, you can start each node in
    the console mode, use `admin.nodeInfo` to figure out the enode ID for each, and
    then use `admin.addPeer` to connect each node to each other.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch05_images.xhtml#pro5_14)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Each new node will start by downloading and syncing the complete blockchain
    from the private network. They can all mine ethers and validate transactions on
    the network.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, I discussed the basic concepts behind Ethereum and how to set
    up your own private Ethereum blockchain. Of course, Ethereum does much more than
    creating and transacting the ETH cryptocurrency. The core idea of Ethereum is
    the smart contract, which we will explore in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 6. Smart Contracts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most important feature of the Ethereum blockchain is its ability to execute
    software code known as *smart contracts*. Now, we already have many distributed
    computing networks. Why do we need a blockchain to act as a distributed computer?
    The answer is decentralized and trusted autonomous execution. With the Ethereum
    blockchain, you do not need to trust anyone to correctly execute your code. Instead,
    a community of network participants (Ethereum miners) will all execute your smart
    contract code and reach a consensus that the results are correct.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I will first revisit the “Hello, World!” smart contract to
    illustrate how an Ethereum smart contract works under the hood. I will then provide
    a high-level overview of the design features of smart contract languages like
    Solidity to help you get a head start on Solidity programming. I will also cover
    how to build and deploy smart contracts using the open source framework and tools.
    While I will continue to cover graphical user interface (GUI) tools, I will focus
    on command-line power tools that are more suitable for professional developers
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: “Hello, World!” Again
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The idea behind smart contracts is software code that is, once written, guaranteed
    to get executed correctly. In this section, let’s review a simple smart contract.
    It works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Anyone can submit the smart contract code to the Ethereum blockchain. Ethereum
    miners validate the code, and if most of them agree (i.e., reach consensus), the
    code will be saved on the blockchain. The smart contract now has an address on
    the blockchain, as if it is an account.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anyone can then call any public method on the smart contract at that blockchain
    address. The blockchain nodes will all execute the code. If most of them agree
    on the results of the code execution, the changes made by the code will be saved
    on the blockchain.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum network nodes are responsible for executing those smart contracts and
    reaching consensus on the correctness of their results. The nodes perform this
    work in exchange for Ethereum’s native cryptocurrency, called *ether* (ETH), in
    each transaction. The transaction fee, called *gas*, is paid by the “from” account
    specified by the method caller.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I will again use the “Hello, World!” example to further illustrate
    how smart contracts work and how to interact with them using different tools.
    The contract is written in the Solidity programming language. The filename is
    `HelloWorld.sol`. The most important requirement of a smart contract is that it
    must produce the same result when executed on different node computers. That means
    it cannot contain any random functions or even floating-point math as floating-point
    numbers are represented differently on different computer architectures. The Solidity
    language is designed to be completely unambiguous in the programs it expresses.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch06_images.xhtml#pro6_1)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The “Hello, World!” smart contract has two key functions.
  prefs: []
  type: TYPE_NORMAL
- en: The `sayHello()` function returns a greeting to its caller. The greeting is
    initially set to “Hello, World!” when the smart contract is deployed. It is a
    view method indicating that it does not change the state of the smart contract
    and hence can be executed locally on any Ethereum node without gas fees.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `updateMessage()` function allows the method caller to change the greeting
    from “Hello, World!” to another message.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The “Hello, World!” smart contract maintains an internal state (`helloMessage`)
    that can be modified by the public function `updateMessage()`. The key feature
    of blockchain technology is that each function call is executed by all nodes on
    the network, and any change to the `helloMessage` state must be agreed upon by
    at least the majority of validators or miners on the network before it can be
    recorded on the blockchain. In turn, every change of the `helloMessage` state
    is recorded in the blockchain. Any interested party can review the blocks and
    find out all recorded change histories for `helloMessage`. That level of transparency
    ensures that the smart contract cannot be tampered with.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that the `sayHello()` function can be executed on any
    Ethereum node the caller has access to. It looks up information from the blockchain
    and does not change the blockchain state. It affects no other nodes in the network.
    Hence, the Ethereum blockchain does not require a gas fee for view function calls
    like `sayHello()`.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, the `updateMessage()` function causes state changes across
    all nodes in the Ethereum network. It can take effect only when nodes on the blockchain
    all execute it and reach consensus on the results. Hence, the `updateMessage()`
    function call requires a gas fee. The results of the `updateMessage()` function
    call also takes a rather long time (up to ten minutes on Ethereum) to take effect
    since the blocks containing the results need to be confirmed and added to the
    blockchain by miner nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Learning Smart Contract Programming
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This book does not intend to be a Solidity tutorial. Solidity is a JavaScript-like
    language. It is also unique and different from JavaScript in many important ways.
    Details of the Solidity syntax are ever-evolving and outside the scope of this
    book. I encourage you to learn the Solidity language from its official documentation
    at [https://solidity.readthedocs.io/](https://solidity.readthedocs.io/).
  prefs: []
  type: TYPE_NORMAL
- en: However, it is important to understand the high-level design features of Solidity
    as they are generally applicable to all smart contract languages. Understanding
    the design will give you a head start on learning Solidity as its quirkiness will
    now make sense.
  prefs: []
  type: TYPE_NORMAL
- en: Consensus vs. Nonconsensus Code
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you have seen from the “Hello, World!” smart contract’s `sayHello()` and
    `updateMessage()` functions, there are clearly two types of code in a smart contract.
  prefs: []
  type: TYPE_NORMAL
- en: One type of code, like the `updateMessage()` function, requires consensus. These
    functions must be precise and produce deterministic behaviors (i.e., no random
    numbers or floating-point numbers) since all nodes must produce the same results.
    They are also slow, require long confirmation time, and are expensive to execute
    both in terms of computing resources (all nodes must run them) and in gas fees.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The other type of code, like the `sayHello()` function, does not require consensus.
    These functions can be executed by a local node and hence do not require gas.
    It is not a problem even if different nodes return different results from the
    same function (i.e., precision loss for floating-point numbers).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Solidity variables have the reference types `memory` and `storage` to indicate
    whether the values should be saved on the blockchain. Functions that do not modify
    the blockchain state (nonconsensus) should be labeled as view functions. Functions
    that do not even read the blockchain state (purely computational) should be labeled
    as pure functions.
  prefs: []
  type: TYPE_NORMAL
- en: It is clear that the virtual machine can provide many more functionalities and
    performance optimizations for nonconsensus code. However, the current design of
    the Solidity language is dominated by the need of consensus code. As a result,
    it lacks many basic features that could be easily provided for the nonconsensus
    part of the system, such as a string library, JSON parser, complex data structure
    support, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: I view this as a flaw of Solidity. In the future Ethereum 2.0, the WebAssembly-based
    new virtual machines (including the Second State Virtual Machine) could solve
    this problem by supporting multiple commonly used programming languages for nonconsensus
    code. That would make the blockchain truly a computing platform rather than just
    a decentralized state machine.
  prefs: []
  type: TYPE_NORMAL
- en: Data Structures
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Besides the primitive types, such as `int, uint`, and `address`, the Solidity
    language supports the `array` data type. In fact, the `string` data type is internally
    implemented as an array. However, the array type is also difficult to work with.
    For example, the computational cost for iterating over an array depends on the
    size of the array. It could be expensive and is difficult to estimate before the
    function execution. That is why Solidity supports only limited string operations
    out of the box.
  prefs: []
  type: TYPE_NORMAL
- en: For structured data, I recommend using the `struct` data type to group multiple
    related data fields. For collections, I recommend using the `mapping` data type
    to build key/value stores. The mapping structure has the advantage of fixed computational
    cost for adding, removing, or looking up elements from the collection.
  prefs: []
  type: TYPE_NORMAL
- en: Function Parameters and Return Values
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: While `struct` and `mapping` are widely used inside smart contracts, you can
    pass only primitive types into and out of contract functions. The contract function’s
    input and return values are both tuples of limited length. Ethereum extension
    (as well as EVM 2.0) projects are working on different ways to relax such constraints,
    especially for nonconsensus view functions.
  prefs: []
  type: TYPE_NORMAL
- en: For now, to pass complex data objects to a function, you could encode the data
    into a string format (e.g., a CSV) and then parse the string inside the contract.
    However, because of the lack of high-performance string libraries in Solidity,
    this is also difficult and gas expensive.
  prefs: []
  type: TYPE_NORMAL
- en: Payable Functions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One of the unique features of a smart contract language is functions that can
    receive payments. In Solidity, you can label any contract function as `payable`.
    A `payable` function automatically requires consensus. It can be invoked only
    via a transaction that gets recorded in the blockchain. The caller can attach
    an ETH `value` to the transaction. The ETHs will be transferred from the caller’s
    address to the contract address upon execution of this function.
  prefs: []
  type: TYPE_NORMAL
- en: The contract can also have a default `payable` function. It is called when an
    address makes a regular ETH transfer to the contract address without making an
    explicit function call.
  prefs: []
  type: TYPE_NORMAL
- en: The contract can access its own fund through the `this.balance()` function and
    transfer funds to other addresses through the `<address>.transfer(amount)` function.
  prefs: []
  type: TYPE_NORMAL
- en: Calling Other Contracts
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A contract function can call functions in another contract deployed at a different
    address. The caller contract needs to know the callee contract’s ABI and address.
  prefs: []
  type: TYPE_NORMAL
- en: This feature allows us to build proxy contracts, where function implementations
    can be changed or upgraded because we can update the proxy to point to different
    implementing contracts. Some well-known smart contracts, such as the GUSD contract,
    are written this way.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, I discussed some unique design features of the Solidity language,
    compared with traditional programming languages. It should get you started on
    learning Solidity. As a first-generation smart contract programming language,
    Solidity has many shortcomings, especially with regard to nonconsensus functions
    and programs. Ethereum extensions such as the Lity project are working on better
    solutions (see [Chapter 14](ch14.xhtml#ch14)).
  prefs: []
  type: TYPE_NORMAL
- en: Building and Deploying the Smart Contract
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, I will use the “Hello, World!” contract as an example to show
    how to build and deploy an Ethereum smart contract. Let’s start with the standard
    Solidity tools.
  prefs: []
  type: TYPE_NORMAL
- en: Solidity Tools
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While you can install and use a JavaScript version of the Solidity compiler,
    I recommend you install the fully featured C++ version. You can do it easily with
    Linux distributions’ package managers. Here is how to do it using the `apt-get`
    package manager on Ubuntu:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch06_images.xhtml#pro6_2)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `solc` command takes a Solidity source file as input and outputs the compiled
    bytecode as well as the ABI definition as a JSON string.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The output from the command is a large JSON structure that gives information
    about compiler errors and results. You can find the following under the HelloWorld
    contract:'
  prefs: []
  type: TYPE_NORMAL
- en: The compiled EVM bytecode as a hex string in the evm/bytecode/object field
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The associated ABI definition in the `abi` field
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The recommended gas costs in the `gasEstimates` field
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, you can deploy this contract from GETH and obtain an address on the blockchain
    for the deployed contract instance. You can run the following command in the GETH
    console attached to an Ethereum blockchain network or the TestRPC:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch06_images.xhtml#pro6_3)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Once the contract is mined and recorded on the blockchain, you should be able
    to query for its address.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: You need to record and save the ABI and contract address. As you have seen,
    those two pieces of information are needed when you retrieve this contract instance
    later in another program.
  prefs: []
  type: TYPE_NORMAL
- en: The BUIDL Integrated Development Environment (IDE)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: While the command-line compiler tool is fundamental to Solidity smart contract
    development, many developers prefer to use graphical user interface (GUI) tools
    for a more visual development experience. The BUIDL IDE is by far the easiest
    GUI tool to compile and deploy Solidity smart contracts.
  prefs: []
  type: TYPE_NORMAL
- en: First, you need to configure BUIDL to work with Ethereum blockchains via the
    **Providers** tab (see [Figure 6.1](ch06.xhtml#ch06fig1)). Then, send a small
    amount of ETH (e.g., 0.1 ETH) to the default address on the **Accounts** tab so
    that BUIDL can pay gas fees to Ethereum on your behalf. See more details in [Chapter
    4](ch04.xhtml#ch04).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 6.1** Configuring BUIDL to work with Ethereum'
  prefs: []
  type: TYPE_NORMAL
- en: Next, type your Solidity code into the editor in the contract section, and hit
    the **Compile** button. You will be able to see the compiled ABI and bytecode
    in the side panel (see [Figure 6.2](ch06.xhtml#ch06fig2)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 6.2** Compiled artifacts from BUIDL'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, you can also copy the ABI and bytecode and paste them into your other
    tools to use.
  prefs: []
  type: TYPE_NORMAL
- en: The Remix IDE
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Remix is a web-based IDE for Solidity smart contracts from the Ethereum Foundation.
    You can access it in your web browser: [http://remix.ethereum.org/](http://remix.ethereum.org/).'
  prefs: []
  type: TYPE_NORMAL
- en: You can simply enter Solidity source code into the text box, and the IDE will
    compile it for you. The compiler output is shown by clicking the **Details** button
    next to the contract name ([Figure 6.3](ch06.xhtml#ch06fig3)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 6.3** The Remix IDE compiles a Solidity smart contract.'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in [Figure 6.4](ch06.xhtml#ch06fig4), the IDE provides the ABI
    and bytecode results from the compiler, as well as a GETH script to deploy the
    contract for your convenience.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 6.4** Clicking the Details button shows the ABI, bytecode, and a deployment
    script for the smart contract.'
  prefs: []
  type: TYPE_NORMAL
- en: Truffle Framework
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Truffle Framework significantly streamlines and simplifies the process of
    building and deploying smart contracts. We recommend it for complex smart contracts
    as well as for automated building and testing in professional software development
    settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Truffle framework builds on the node.js framework. So, you should first
    make sure that node.js and its package manager, npm, are installed on your machine.
    You can install them at [https://www.npmjs.com/get-npm](https://www.npmjs.com/get-npm).
    On most Linux distributions, you can use the system package manager to install
    them as well. For example, the following command installs node.js and npm on a
    CentOS/RedHat/Fedora Linux system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch06_images.xhtml#pro6_4)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Next, let’s install the Truffle framework using the npm package manager.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch06_images.xhtml#pro6_5)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Next, you can create a basic project structure using the truffle command.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch06_images.xhtml#pro6_6)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can create a `HelloWorld.sol` file in the `HelloWorld/contracts` directory.
    The file content was listed earlier in this chapter, and you can also get it from
    the sample project on GitHub. In addition, create a `migrations/2_deploy_contracts.js`
    file to indicate that the HelloWorld contract needs to be deployed by Truffle.
    The content of the `2_deploy_contracts.js` file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch06_images.xhtml#pro6_7)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'You will also need to update the `truffle.js` file, which configures the deployment
    targets. The following `truffle.js` example has two targets: one for the TestRPC
    on the localhost, and one for an Ethereum testnet node on the local network.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch06_images.xhtml#pro6_8)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'To compile and build the smart contract, you can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch06_images.xhtml#pro6_9)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The previously mentioned contract ABI, when constructing a contract object from
    the blockchain address, is a JSON object in the `build/contracts/HelloWorld.json`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch06_images.xhtml#pro6_10)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you have two deployment options. The first option is to deploy to
    the TestRPC. You must have the TestRPC running on the same machine. Run the following
    command to deploy the `HelloWorld` contract to the TestRPC:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch06_images.xhtml#pro6_11)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The second option is to deploy to a live Ethereum blockchain network. However,
    since this costs gas, you will need to unlock an account with an ETH balance first.
    You can use GETH attached to the testnet node to do this. The unlocked address
    is the one specified in the `testnet/from` field in the `truffle.js` file. Please
    see [Chapter 5](ch05.xhtml#ch05) to review GETH account unlocking commands.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch06_images.xhtml#pro6_12)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Then deploy to the testnet using `truffle`.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch06_images.xhtml#pro6_13)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you can verify the contract deployed on the live network at this address:
    [https://ropsten.etherscan.io/address/0x8bc27c8129eea739362d786ca0754b5062857e9c](https://ropsten.etherscan.io/address/0x8bc27c8129eea739362d786ca0754b5062857e9c)'
  prefs: []
  type: TYPE_NORMAL
- en: Calling Smart Contract Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you have deployed the “Hello, World!” smart contract on the blockchain,
    you should be able to interact with it and call its public functions.
  prefs: []
  type: TYPE_NORMAL
- en: The BUIDL IDE
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Once you have configured the BUIDL IDE to work with the Ethereum blockchain
    and have hit the **Compile** button to compile your Solidity smart contract, you
    are ready to deploy it.
  prefs: []
  type: TYPE_NORMAL
- en: Hit the **Deploy to the chain** button (see [Figure 6.5](ch06.xhtml#ch06fig5))
    to deploy the smart contract onto the Ethereum blockchain. The deployed contracts
    are available on the Deployed tab. You can click to open any of them and interact
    with the public functions directly from inside BUIDL.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 6.5** Calling functions on a deployed Ethereum smart contract'
  prefs: []
  type: TYPE_NORMAL
- en: The Remix IDE
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As I showed in [Chapter 4](ch04.xhtml#ch04), the Remix IDE can build a UI for
    a smart contract given the ABI and contract address. All public functions of the
    contract are listed in the UI. Functions that result in blockchain state changes
    (e.g., require gas to operate) are labeled as red buttons ([Figure 6.6](ch06.xhtml#ch06fig6)).
    Functions that do not result in state changes (i.e., view methods) are labeled
    as blue buttons. You can pass call parameters to functions in the input boxes
    next to each button.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 6.6** A smart contract UI built by Remix'
  prefs: []
  type: TYPE_NORMAL
- en: The Remix UI is convenient, but it cannot be automated and hides details of
    the transactions. To fully understand how smart contracts are executed on the
    blockchain, I recommend you interact with the functions directly on a blockchain
    node. In the case of Ethereum, it is a node running GETH connected to the mainnet
    or testnet.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: As shown in [Chapter 4](ch04.xhtml#ch04), you can use the web3.js JavaScript
    library to build applications that work in tandem with the Metamask wallet to
    call smart contract methods. But web3.js does not help you with interactive development
    and debugging of the smart contract itself.
  prefs: []
  type: TYPE_NORMAL
- en: GETH Console
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: GETH is a GO language-based client for Ethereum. You can run GETH in a mode
    that attaches itself to an Ethereum node (or the TestRPC for local testing). See
    [Chapter 5](ch05.xhtml#ch05) for how to run an Ethereum node yourself using GETH.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch06_images.xhtml#pro6_14)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In the console, you can now create an instance of the contract via the `eth.contract().at()`
    method. You need two pieces of information. Both of them come from the tool you
    use to build and deploy your smart contract to the blockchain, which I will cover
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The JSON parameter to the `contract()` method is known as the ABI. When you
    build the smart contract, the compiler outputs the ABI. In the case of the Truffle
    framework, the ABI is located in the `build/contracts/HelloWorld.json` file’s
    abi JSON field, with all line breaks removed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `at()` method parameter is the address to this specific instance of the
    smart contract. That is, you can deploy the same smart contract class multiple
    times, and each time the Ethereum blockchain will create a unique address for
    it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch06_images.xhtml#pro6_15)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The `sayHello()` method on the contract instance does not change the blockchain
    state. So, it is “free” and immediately executed by the node connected to our
    GETH console.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The `updateMessage()` method, on the other hand, changes the contract’s internal
    state on the blockchain. It must be executed by all the miners and gets recorded
    on the blockchain once most miners reach consensus. Because of that, it’s execution
    requires gas (in ETH) to pay the miners for their effort. The gas is provided
    by an account specified on the method call.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your GETH console is connected to the TestRPC, you should already have unlocked
    accounts. But if you are connected to a real Ethereum node, you can use the following
    command in the GETH console to create a new Ethereum account and then send ETH
    to this account from one of your wallets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Next, the account must be unlocked so that we can “spend” its ETH as gas.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch06_images.xhtml#pro6_16)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: While the gas fee is small, it is necessary. If your account specified in the
    method call has zero balance and cannot pay gas, the function call will fail.
    The changed state of the contract will be finalized across all blockchain nodes
    when the transaction is confirmed by the miners. The confirmation could take several
    minutes on the Ethereum blockchain, degrading the user experience. On Ethereum-compatible
    blockchains like CyberMiles, the confirmation time could be as fast as seconds.
    That is a compelling reason to develop and deploy Ethereum applications on alternative
    compatible blockchains (learn more in [Appendix A](app.xhtml#app)).
  prefs: []
  type: TYPE_NORMAL
- en: A New Language
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While the Solidity language is currently the most widely used programming language
    for Ethereum smart contract development, it is also hard to use and has many design
    flaws. Specifically, it lacks safeguards and logical separations commonly available
    in modern programming languages. It is easy to make human errors in Solidity.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, a large-scale code audit has revealed about 100 obvious bugs for every
    1,000 lines of Solidity code. That is astonishingly high as most Solidity code
    is for smart contracts that actually manage financial assets. In contrast, nonfinancial
    business software typically contains 10 bugs per 1,000 lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: To address Solidity’s problems, the Ethereum community is developing a new experimental
    language for smart contract programming called Vyper. It is designed for human
    readability and auditability. It removes some confusing features from Solidity
    and should produce safer smart contracts with fewer bugs.
  prefs: []
  type: TYPE_NORMAL
- en: While Vyper is in early beta and the design is still changing, it is possibly
    the future of Ethereum development. In this section, I will show how to rewrite
    the Solidity “Hello, World!” example in Vyper and how to deploy it. The following
    is the Vyper code for the smart contract. You will notice that the Vyper smart
    contract is similar to the Python language. The filename is `HelloWorld.v.py`.
    The filename suffix is `.py` to allow development tools to highlight its syntax
    using Python rules. If that is a concern, you can also use the `.vy` suffix.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch06_images.xhtml#pro6_17)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: To install the Vyper compiler, you will need Python 3.6 or newer. Since Vyper
    is still an evolving technology, the official documentation suggests building
    from the source. You can find the latest instructions at [https://vyper.readthedocs.io/en/latest/installing-vyper.html](https://vyper.readthedocs.io/en/latest/installing-vyper.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have the Vyper application installed, you can run it as any other
    compiler. The following command will output the hex string of the compiled bytecode
    of the contract:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command will output the JSON string of the ABI for the contract:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: With both the bytecode and ABI, you can use GETH to deploy the smart contract
    to Ethereum or the TestRPC.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch06_images.xhtml#pro6_18)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, similar to Remix, there is also an online compiler for Vyper contracts:
    [https://vyper.online/](https://vyper.online/) ([Figure 6.7](ch06.xhtml#ch06fig7)).
    You can type in your Vyper source code and let the web application compile it
    into bytecode ([Figure 6.8](ch06.xhtml#ch06fig8)) and ABI ([Figure 6.9](ch06.xhtml#ch06fig9)).'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f06_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 6.7** A web-based Vyper compiler, vyper.online'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f06_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 6.8** The compiled bytecode from vyper.online'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f06_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 6.9** The ABI interface generated by vyper.online'
  prefs: []
  type: TYPE_NORMAL
- en: More Smart Contract Languages
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: While the Vyper language is similar to Python, it cannot be called Python since
    it removes some important features from the Python language to make its programs
    deterministic. All blockchain node computers must produce the same result when
    executing the smart contract code in order to reach consensus. Therefore, no general-purpose
    computer programming language can be used directly for smart contract programming.
    The language must be modified to produce entirely deterministic behavior.
  prefs: []
  type: TYPE_NORMAL
- en: The new generations of blockchain virtual machines are leveraging state-of-the-art
    virtual machine technologies such as the WebAssembly (Wasm) virtual machine. For
    example, the next Ethereum Virtual Machine will be based on WebAssembly and called
    Ethereum Flavored WebAssembly (eWASM). Another large public blockchain, EOS, already
    has a WebAssembly-based virtual machine.
  prefs: []
  type: TYPE_NORMAL
- en: Those new-generation virtual machines are commonly based on the LLVM technology
    that supports optimization across the entire application lifecycle from compile
    time to link time to runtime. LLVM uses an intermediate representation (IR) code
    format between the application source code and machine bytecode to support a “language-agnostic”
    compiler infrastructure. The IR allows the virtual machine to support multiple
    source code programming languages on the front end. Indeed, LLVM already supports
    20+ programming languages. Solidity and Vyper are also evolving to become compatible
    with the LLVM IR. For example, the open source SOLL project is developing an LLVM-based
    Solidity compiler for the next generation of blockchain virtual machines. See
    [https://github.com/second-state/soll](https://github.com/second-state/soll).
  prefs: []
  type: TYPE_NORMAL
- en: However, because of the unique constraints of smart contract programming, it
    is impossible to expect mainstream programming languages to be fully supported
    on blockchain virtual machines. When EOS says that its smart contract programming
    language is C++, it means a modified version of C++ that produces deterministic
    programs. It will be a major effort to modify and reform mainstream programming
    languages to support smart contract programming. So, in the near future, I think
    Solidity will continue to be the dominant smart contract programming language.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, I explained what a smart contract is, how to program it, and
    how to interact with it. I covered both the Solidity language and the upcoming
    Vyper language for smart contract programming. Using open source tools, we explored
    different options to test and deploy the smart contract onto Ethereum blockchain
    networks. Of course, Solidity and Vyper still have their limitations. I will cover
    an alternative programming language called Lity, which is fully backward compatible
    with Solidity but attempts to address some of the most glaring problems, in [Chapter
    14](ch14.xhtml#ch14).
  prefs: []
  type: TYPE_NORMAL
- en: 7. Decentralized Applications (Dapps)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous chapter, we discussed the concept of smart contracts and how
    to interact with them on the Ethereum blockchain. However, tools like GETH, Truffle,
    and even Remix and Metamask are geared toward developers or expert users. For
    regular users to access blockchain applications, there is still much work around
    the user interface (UI), user experience (UX), and supporting infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: The Internet took off when the user experience of web applications started to
    match client-server applications on closed networks. Only after that point did
    the open and decentralized advantages of the Internet start to matter. The Internet
    excels at enabling open ecosystems that orchestrate multiple data and service
    providers. But such ecosystems are useful only when the users are willing to use
    web applications. Similarly, decentralized and autonomous smart contracts can
    be mass adopted only when the application user experience is on par with regular
    web applications. Enter *dapps*.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of a decentralized application is to provide UIs for smart contracts
    and other blockchain functionalities. Ideally, a dapp is a rich client application
    downloaded onto the user’s device. It ties together multiple back-end services,
    including the blockchain service. A dapp is typically a JavaScript application
    that can be downloaded from any web server (i.e., there is no central server that
    can be shut down) and relies on the decentralized blockchain for its data and
    logic functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I discuss architectural design and best practices for blockchain
    dapps through some notable success stories.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: Dapp development on Ethereum is a chore. It requires you to set up Metamask,
    Remix, web3, a web server, maybe even an Ethereum node, and a flurry of infrastructure
    tools just to write the first line of code. And the standard Ethereum dapp is
    not going to work on mobile devices out of the box.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, BUIDL is a complete dapp development environment that requires
    almost no setup. BUIDL applications can be published to the Web and accessed from
    mobile devices. Learn more about BUIDL in [Chapter 3](ch03.xhtml#ch03) and [Chapter
    4](ch04.xhtml#ch04).
  prefs: []
  type: TYPE_NORMAL
- en: Dapp Stack
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once we have built and tested the smart contracts, it is time to build the dapp
    UI for users to interact with the smart contracts. The idea here is that unlike
    a web application that depends on a central server for logic and data, a dapp
    can save user data locally and utilize multiple back-end services, including the
    blockchain service, to achieve decentralization ([Figure 7.1](ch07.xhtml#ch07fig1)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 7.1** The dapp architecture'
  prefs: []
  type: TYPE_NORMAL
- en: The dapp typically runs in the user’s device as a client-side JavaScript application.
    Its primary function is to provide a user interface. It interacts with the blockchain
    smart contracts for core data and application logic. It could also interact with
    other public or even local services to store and manage off-chain data. The most
    important difference between a dapp’s off-chain data and a regular web app’s central
    server is that the dapp’s server data can be replicated and replaced when needed.
    There is no single point of failure in a dapp infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the dapp can utilize the device’s HTML5 local storage API to store
    data specific to users on this device.
  prefs: []
  type: TYPE_NORMAL
- en: You can write a dapp in any client-side JavaScript framework. Popular examples
    include jQuery and ReactJS. In the Truffle project, you can find templates ([https://truffleframework.com/boxes](https://truffleframework.com/boxes))
    for creating dapps for popular JavaScript frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: The web3 Library
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The JavaScript application connects to the blockchain services via a library
    called web3.js ([https://github.com/ethereum/web3.js/](https://github.com/ethereum/web3.js/)).
    Currently, web3.js supports only the Ethereum blockchain, and it has not reached
    version 1.0\. Yet it is already by far the most popular library to connect dapps
    to blockchain services. The web3 library provides the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: Send or transfer fund from one address to another
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploy smart contracts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Call public functions on deployed smart contracts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Estimate the gas fee for contract function calls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Query a contract or address status
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The web3.js library requires a private key to sign transactions it sends to
    the blockchain. As you have seen, blockchain account private keys are stored and
    managed by wallet applications; the web3.js library should be used in junction
    with a compatible wallet application. The wallet is also known as a *web3 provider*.
    It is up to the dapp JavaScript code to detect the availability and validity of
    a web3 provider. Metamask is a web3 provider for Ethereum. The “Hello, World!”
    web application from [Chapter 4](ch04.xhtml#ch04) is an example of a web3 dapp
    that works in tandem with Metamask.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the more popular web3.js, the ethereumJS library ([https://ethereumjs.github.io/](https://ethereumjs.github.io/))
    can sign Ethereum transactions without a wallet application. However, to do so,
    the JavaScript code must have access to the account private key. It provides a
    JavaScript library ([https://github.com/ethereumjs/ethereumjs-wallet](https://github.com/ethereumjs/ethereumjs-wallet))
    to implement your own embedded wallet inside the dapp.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: Cross-blockchain applications like Scatter ([https://get-scatter.com/](https://get-scatter.com/))
    act like wallets but are designed to run dapps.
  prefs: []
  type: TYPE_NORMAL
- en: External Services
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As I have described, dapps store only core logic and data on blockchain smart
    contracts. It is too slow and too expensive to store large amounts of data on
    the blockchain. Most applications also require media files, databases, and other
    off-chain data to function. The dapp could use online services to store and manage
    data. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: The IPFS ([https://ipfs.io/](https://ipfs.io/)) is a blockchain-based media
    file storage and exchange service protocol. Dapps can store large user files on
    IPFS and make them accessible everywhere.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Swarm ([https://ethersphere.github.io/swarm-home/](https://ethersphere.github.io/swarm-home/))
    is a file storage and sharing solution built on top of Ethereum.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GitHub ([https://github.com/](https://github.com/)), Dropbox ([https://www.dropbox.com/](https://www.dropbox.com/)),
    or Google Drive ([https://www.google.com/drive/](https://www.google.com/drive/))
    are examples of traditional Internet file storage and sharing services that can
    be accessible by individual dapp users. You can use GitHub or Dropbox web sites
    to serve dapp JavaScript files directly from an individual user’s accounts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database as a service (DBaaS) providers such as Microsoft Azure SQL ([https://azure.microsoft.com/en-us/services/sql-database/](https://azure.microsoft.com/en-us/services/sql-database/)),
    AWS Relational Database Service ([https://aws.amazon.com/rds/](https://aws.amazon.com/rds/)),
    Google BigQuery ([https://cloud.google.com/bigquery/](https://cloud.google.com/bigquery/)),
    and MongoDB Atlas ([https://www.mongodb.com/cloud/atlas](https://www.mongodb.com/cloud/atlas))
    are examples of database services that can be utilized by dapps to store application
    data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An off-chain data service is a query interface to search and browse blockchain
    data, such as transactions, accounts, and smart contract function calls. It is
    potentially much more powerful, versatile, and scalable than calling the view
    functions to get smart contract data. This approach is discussed in more detail
    in [Chapter 10](ch10.xhtml#ch10).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A common design practice to ensure the safety and validity of off-chain data
    is to store the data’s hash in on-chain smart contracts.
  prefs: []
  type: TYPE_NORMAL
- en: A dapp is more complex than most web applications. From the start, you need
    to design which part of the application is based on blockchain smart contracts,
    which part utilizes off-chain server-side data, and which part is the client-side
    UI. Each of those elements requires its own software stack to function and communicate
    with the rest of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Dapp Showcases
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because of Ethereum’s slow confirmation time (up to ten seconds) and high gas
    fees for executing smart contract functions, successful Ethereum dapps so far
    are all financial applications that do not require frequent user interactions.
  prefs: []
  type: TYPE_NORMAL
- en: Uniswap
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One of the most polished Ethereum dapps is the Uniswap exchange. It is a decentralized
    crypto token exchange. The idea is that some people will make initial contributions
    to a liquidity pool (as market makers) and earn a share of the trading fees. All
    other traders will trade against the liquidity pool based on a simple pricing
    formula of supply and demand. If a token becomes scarce in the liquidity pool,
    its price against the ETH will increase, incentivizing holders to sell it back
    to the liquidity pool. This mechanism allows trading to happen in a completely
    automated manner without matching for counter parties. The entire Uniswap system
    is a set of smart contracts on the Ethereum blockchain. The application state
    is completely stored in and managed by the contracts.
  prefs: []
  type: TYPE_NORMAL
- en: The Uniswap project has developed a polished UI ([Figure 7.2](ch07.xhtml#ch07fig2))
    to interact with its underlying smart contracts. The UI is completely written
    in web3 JavaScript and is fully internationalized. Through the dapp UI, novice
    users can contribute to the liquidity pool and earn fees for their crypto deposits
    or can immediately start trading pairs of ERC20 tokens.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 7.2** The Uniswap UI'
  prefs: []
  type: TYPE_NORMAL
- en: The interesting aspect of the Uniswap dapp is that it is truly decentralized.
    All the application logic and its data are stored on the Ethereum blockchain.
    Anyone can create a web site to host the JavaScript dapp, and all those copies
    of dapps will behave the same way as they all get their logic and data from the
    blockchain. In Uniswap, Ethereum has truly become a “computer” back end.
  prefs: []
  type: TYPE_NORMAL
- en: CryptoKitties
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The CryptoKitties game took over Ethereum by storm in late 2017\. It gave rise
    to the idea of crypto collectibles and nonfungible tokens, which later become
    the ERC721 specification.
  prefs: []
  type: TYPE_NORMAL
- en: CryptoKitties are unique digital entities that exist on the Ethereum blockchain.
    They are data in smart contracts. Their uniqueness is guaranteed by the contract
    code. Each CryptoKittie has an associated owner address. CryptoKitties can then
    by bought, sold, and traded on the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: The interesting thing about CryptoKitties is that they are visually appealing
    ([Figure 7.3](ch07.xhtml#ch07fig3)). The dapp UI design visualizes the unique
    features of each digital entity. That contributed significantly to CryptoKitties’
    success.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 7.3** CryptoKitties'
  prefs: []
  type: TYPE_NORMAL
- en: Gambling Games
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Gambling games are popular dapps. They are great use cases for smart contracts,
    with transparent rules and betting pools. They also benefit greatly from largely
    unregulated cryptocurrencies.
  prefs: []
  type: TYPE_NORMAL
- en: However, gambling games are often interactive in nature, requiring users to
    bet often in response to other people’s real-time bets. Ethereum’s slow confirmation
    time represents a great barrier for this type of game. Faster blockchains such
    as EOS and Tron, which is itself a fork from Ethereum, are now blockchains specialized
    in gambling dapps.
  prefs: []
  type: TYPE_NORMAL
- en: Interactive Dapps
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Most Internet applications are interactive. For Ethereum blockchains to support
    interactive applications, performance is an important factor. The Lity project
    creates high-performance extensions to the Ethereum protocol and tools. It enables
    us to create interesting interactive dapps. See [Chapter 16](ch16.xhtml#ch16)
    for several complete examples.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A dapp is typically a web3 application that runs in tandem with a wallet application.
    It interacts with smart contracts on the blockchain for essential data and core
    application logic. It can also use local storage or third-party services to store
    and manage nonessential data that is private to the user or could be regenerated
    by the public. In the next chapter, I will discuss how applications use blockchain
    data services, in addition to blockchain transactions, to provide a rich user
    experience.
  prefs: []
  type: TYPE_NORMAL
- en: 8. Alternatives to Dapps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The concept of dapps is compelling and native to blockchain technology’s most
    obvious use cases, such as peer-to-peer financing. However, the world is never
    binary. There are also many blockchain application use cases that could fit into
    the model of traditional web applications. Those are typically use cases where
    the public or consortium blockchain’s transparency and immutability can add value
    to an existing business. The application only needs the blockchain as a feature
    and does not need to decentralize the entire application itself. A payment processor
    for e-commerce web sites to accept cryptocurrencies is a good example. A crypto
    asset exchange (crypto to crypto or crypto to fiat) is another example.
  prefs: []
  type: TYPE_NORMAL
- en: For those applications, we need to make blockchain transactions and/or make
    smart contract function calls from a server. To do that, the accounts’ private
    keys or keystores and passwords must be managed on the server side.
  prefs: []
  type: TYPE_NORMAL
- en: For new transactions, it is obvious since the sender account needs to use its
    private key to authenticate the funds transferring out of it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For modifying contract states, an Ethereum-compatible blockchain requires the
    party requesting the change to pay a “gas fee” for network maintainers (miners)
    to validate the request and record the change in new blocks. That also requires
    transferring funds (a gas fee) out of the requestor’s account and hence requires
    its private key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we explore how to access Ethereum-compatible blockchain functionalities
    from a web app. The basic approach is to use a web3-compatible library but without
    a client-side wallet like Metamask.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The node.js framework enables JavaScript applications to be deployed on the
    server side. It is hence conceivable to use the web3.js library (or the compatible
    web3-cmt.js library) in a node.js server application.
  prefs: []
  type: TYPE_NORMAL
- en: The Full-Node Wallet
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The first approach is to use a fully synchronized Ethereum node as the “wallet”
    for the application. The GETH (Ethereum) or Travis (CyberMiles) software running
    the node is able to manage keystores (i.e., the web3.personal package), sign transactions,
    and broadcast transactions to other blockchain nodes. Through the blockchain node’s
    Remote Procedure Call (RPC) interface, external applications can interact with
    the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: You will need to synchronize a full Ethereum (or Ethereum-compatible blockchain,
    such as CyberMiles) node behind a firewall. The node should turn on RPC services
    (i.e., the Ethereum default port 8545) so that the server-side web application
    can access it behind the firewall. It is important that the node’s port 8545 be
    completely blocked by the firewall and available only inside the firewall, as
    illustrated in [Figure 8.1](ch08.xhtml#ch08fig1).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 8.1** The behind-the-firewall setup'
  prefs: []
  type: TYPE_NORMAL
- en: The following code example shows how to call the `HelloWorld` contract’s `updateMessage()`
    function (see [Chapter 4](ch04.xhtml#ch04)) to record a new state in helloMessage
    onto the blockchain and pay its gas fees. We assume that the web3.js instance
    on the node.js server is attached to an Ethereum node that already has the keystore
    containing an account private key. The account has a sufficient balance to pay
    the gas fee for this transaction. You just need to unlock the account using its
    passphrase.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch08_images.xhtml#pro8_1)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Of course, storing the keystores on the node is still insecure. A single misconfigured
    firewall setting might expose the node’s port 8545 to attackers. Attackers could
    easily gain access to all private keys on the server as they are unlocked by the
    web application.
  prefs: []
  type: TYPE_NORMAL
- en: Raw Transactions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The second approach is to create signed raw transactions and then simply use
    web3.js to broadcast the transaction onto a blockchain node. In this setup, the
    blockchain node could be a third-party hosted node outside of the firewall, such
    as an Infura node. The blockchain node does not store any private key or keystore.
    The web application itself, however, manages the private keys it needs in a database
    table. [Figure 8.2](ch08.xhtml#ch08fig2) illustrates the architecture of this
    design.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 8.2** Application-managed private keys'
  prefs: []
  type: TYPE_NORMAL
- en: Signing raw transactions is beyond the scope of web3.js. We use the EthereumJS
    library here to work in conjunction with web3.js. In particular, the `ethereumjs-tx`
    project provides ways to sign transactions using private keys. The private keys
    are typically stored in database tables in this case.
  prefs: []
  type: TYPE_NORMAL
- en: The following code shows how to deploy the `HelloWorld` smart contract on Ethereum
    using a signed raw transaction. The gas fee is paid from the account, and the
    application has access to the private key.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch08_images.xhtml#pro8_2)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The next example shows how to call the `updateMessage()` function on the contract:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch08_images.xhtml#pro8_3)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The EthereumJS library is much more than just `ethereumjs–tx`. It provides the
    JavaScript to manage private keys, keystores, and wallets. It would be useful
    if you are doing extensive key management and low-level programming on your own.
  prefs: []
  type: TYPE_NORMAL
- en: Python and Others
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While JavaScript is the native language for web3.js, many developers do not
    like to use JavaScript on server applications. Because of that, there are other
    programming languages’ implementations of the web3 library. For example, web3.py
    is a Python implementation of web3\. The following code shows how to decrypt and
    construct a private key from a GETH keystore file. You can store the content of
    this keystore file in a database table, and its password in another database table.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch08_images.xhtml#pro8_4)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: With the private key in place, the code segment next illustrates how to construct
    a raw transaction in web3.py to transfer ETH from one account to another.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch08_images.xhtml#pro8_5)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The next example shows how to use web3.py to make a smart contract function
    call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch08_images.xhtml#pro8_6)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: There is obviously a lot more to the `web3.py` library, and it is substantially
    different from web3.js when it comes to the exact API usages. I encourage interested
    readers to review its documentation at [https://web3py.readthedocs.io](https://web3py.readthedocs.io).
    Furthermore, there are other programming language choices for web3.
  prefs: []
  type: TYPE_NORMAL
- en: '*The PHP web3*: [https://github.com/formaldehid/php-web3](https://github.com/formaldehid/php-web3)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The Java web3*: [https://github.com/web3j/web3j](https://github.com/web3j/web3j)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since web applications vary a lot depending on the development framework you
    choose, I will leave it as an exercise for you to work out your own web applications.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, I discussed how to build server-side applications that interact
    with blockchains and smart contracts. Those applications require central servers
    to function and hence are less decentralized than the dapps discussed in [Chapter
    7](ch07.xhtml#ch07). However, for the short term, incorporating decentralized
    features into otherwise centralized applications could be the most plausible path
    for the mass adoption of blockchain applications.
  prefs: []
  type: TYPE_NORMAL
