- en: © The Editor(s) (if applicable) and The Author(s), under exclusive license to
    Springer Nature Switzerland AG 2020K. S. MohamedNew Frontiers in Cryptography[https://doi.org/10.1007/978-3-030-58996-7_2](https://doi.org/10.1007/978-3-030-58996-7_2)
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: © 编辑（如适用）和作者，独家授权给施普林格自然瑞士公司 2020K. S. 莫哈默德[https://doi.org/10.1007/978-3-030-58996-7_2](https://doi.org/10.1007/978-3-030-58996-7_2)
- en: '2. Cryptography Concepts: Confidentiality'
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2. 密码学概念：保密
- en: Khaled Salah Mohamed^([1](#Aff2) )(1)A Siemens Business, Fremont, CA, USAKeywordsEncryptionSymmetricAsymmetricRSAAESDESCipherECCKey-exchangeCryptanalysis
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 卡莱德·萨拉赫·莫哈默德^([1](#Aff2) )(1)A Siemens Business, Fremont, CA, USA关键词加密对称非对称RSA高级加密标准DES密码椭圆曲线密钥交换密码分析
- en: 2.1 Cryptography History
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1 密码学历史
- en: 'The term cryptography is derived from the Greek word Kryptos. Kryptos is used
    to describe anything that is hidden, veiled, secret, or mysterious. Cryptography
    is the study of mathematical techniques for the secure transmission of a private
    message over an insecure channel. Cryptography is the basic technique to secure
    our data from different kind of attackers like: interruption, modification, fabrication,
    etc. It has been around for 2000+ years. They were shaving the slave’s head, tattooed
    the message on it, and let the hair grow [[1](#CR1)]. The first documented use
    of cryptography in writing dates back to circa 1900 B.C. when an Egyptian scribe
    used nonstandard hieroglyphs in an inscription. Some experts argue that cryptography
    appeared spontaneously sometime after writing was invented, with applications
    ranging from diplomatic missives to war-time battle plans. Caesar’s cipher: shifting
    each letter of the alphabet by a fixed amount. It is easy to break. Vigenere’s
    polyalphabetic cipher generalizes Caesar’s shift cipher. It uses keyword to select
    encrypting rows. *Substitution cipher*: permutations of 26 letters, using the
    dictionary. It is easy to break. Then in modern era, we have many cryptography
    algorithms as we will explain in the rest of this chapter. Modern cryptography
    algorithms are based over the fundamental process of factoring large integers
    into their primes, which is said to be intractable [[2](#CR2), [3](#CR3)]. In
    both *symmetric* and *asymmetric* cryptosystems, encryption is the process of
    changing the original form of text to unreadable form and decryption process gets
    the original form of data from the meaningless text. For block cipher, use of
    plaintext and ciphertext of equal size avoids data expansion. In this chapter,
    confidentiality will be addressed. Encryption is the major tool to achieve confidentiality
    [[4](#CR4)–[6](#CR6)].'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 密码学一词源自希腊词汇 Kryptos。Kryptos 用于描述任何隐藏、遮蔽、秘密或神秘的事物。密码学是研究数学技术，用于通过不安全的信道安全传输私密消息。密码学是保护我们的数据免受不同类型攻击者的基本技术，如中断、修改、伪造等。它已存在
    2000 多年。他们给奴隶剃头，将消息刺青在头上，然后让头发生长[1]。密码学在书写中的第一次记录使用可以追溯到公元前约 1900 年，当时一名埃及抄写员在铭文中使用了非标准的象形文字。一些专家认为，密码学是在书写发明后的某个时候自发出现的，其应用范围从外交信函到战时作战计划。凯撒密码：将字母表中的每个字母按固定数量移位。很容易破解。维吉尼亚多表密码将凯撒的移位密码推广为多表密码。它使用关键字来选择加密行。*替换密码*：使用字典的
    26 个字母的排列。很容易破解。然后在现代，我们有许多密码学算法，我们将在本章的其余部分中解释。现代密码学算法基于将大整数分解为其质数的基本过程，这被认为是棘手的[2][3]。在*对称*和*非对称*加密系统中，加密是将原始文本更改为不可读形式的过程，解密过程从无意义的文本中获取原始数据。对于分组密码，使用相等大小的明文和密文避免了数据扩展。在本章中，将讨论机密性。加密是实现机密性的主要工具[4]–[6]。
- en: 2.2 Symmetric Encryption
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2 对称加密
- en: 'Figure [2.1](#Fig1) shows a summary for different symmetric encryption algorithms.
    Symmetric means sender and receiver have a shared secret key. There are two primitive
    operations with which strong encryption algorithms can be built: *confusion* and
    *diffusion.* In confusion, an encryption operation where the relationship between
    key and ciphertext is obscured, and a common element for achieving confusion is
    substitution. In diffusion, an encryption operation where the influence of one
    plaintext symbol is spread over many ciphertext symbols with the goal of hiding
    statistical properties of the plaintext and a common element for achieving diffusion
    is through permutations (i.e., transposition). Avalanche effect is considered
    as one of the desirable property of any encryption algorithm. A slight change
    in either the key or the plaintext should result in a significant change in the
    ciphertext.![../images/501530_1_En_2_Chapter/501530_1_En_2_Fig1_HTML.png](../images/501530_1_En_2_Chapter/501530_1_En_2_Fig1_HTML.png)'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 图 [2.1](#Fig1) 显示了不同对称加密算法的摘要。对称意味着发送者和接收者有一个共享的秘密密钥。有两个基本操作可以构建强加密算法：*混淆* 和
    *扩散*。在混淆中，加密操作会使密钥与密文之间的关系变得模糊，而实现混淆的常见元素是替换。在扩散中，加密操作会使一个明文符号的影响分散到许多密文符号中，其目标是隐藏明文的统计属性，实现扩散的常见元素是通过置换（即，转位）。雪崩效应被认为是任何加密算法的理想属性之一。无论是密钥还是明文的轻微变化都应导致密文的显著变化。![../images/501530_1_En_2_Chapter/501530_1_En_2_Fig1_HTML.png](../images/501530_1_En_2_Chapter/501530_1_En_2_Fig1_HTML.png)
- en: Fig. 2.1
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1
- en: Symmetric cryptographic algorithm. Symmetric means sender and receiver have
    a shared secret key
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 对称加密算法。对称意味着发送者和接收者有一个共享的秘密密钥
- en: '2.2.1 Historical Algorithms: Letter-Based Algorithms'
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.1 历史算法：基于字母的算法
- en: 2.2.1.1 Caesar Cipher
  id: totrans-10
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.2.1.1 凯撒密码
- en: This is one of the oldest and earliest examples of cryptography, invented by
    Julius Caesar, the emperor of Rome, during the Gallic Wars. In this type of algorithm,
    the letters A through W are encrypted by being represented with the letters that
    come three places ahead of each letter in the alphabet, while the remaining letters
    A, B, and C are represented by X, Y, and Z. This means that a “shift” of 3 is
    used, although by using any of the numbers between 1 and 25, we could obtain a
    similar effect on the encrypted text. Therefore, nowadays, a shift is often regarded
    as a Caesar Cipher (Fig. [2.2](#Fig2)) [[7](#CR7)]. A Python code for Caesar cipher
    is shown in Fig. [2.3](#Fig3).![../images/501530_1_En_2_Chapter/501530_1_En_2_Fig2_HTML.png](../images/501530_1_En_2_Chapter/501530_1_En_2_Fig2_HTML.png)
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这是密码学最古老和最早的例子之一，由罗马帝国皇帝**凯撒大帝**在高卢战争期间发明。在这种算法中，字母A到W通过用字母代表字母的方法进行加密，该字母在字母表中的位置比原字母向前三个位置，而剩余的字母A、B和C则用X、Y和Z代表。这意味着使用了“偏移”为3，虽然通过使用1到25之间的任何数字，我们也可以对加密文本产生类似的效果。因此，如今，偏移通常被视为凯撒密码（图[2.2](#Fig2)）[[7](#CR7)]。凯撒密码的Python代码显示在图[2.3](#Fig3)中。![../images/501530_1_En_2_Chapter/501530_1_En_2_Fig2_HTML.png](../images/501530_1_En_2_Chapter/501530_1_En_2_Fig2_HTML.png)
- en: Fig. 2.2
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2
- en: Caesar cipher
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 凯撒密码
- en: '*Encryption: C = P + K mod 26 (1)*'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*加密：C = P + K mod 26 (1)*'
- en: '*Decryption: P = C − K mod 26 (2)*'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*解密：P = C − K mod 26 (2)*'
- en: '![../images/501530_1_En_2_Chapter/501530_1_En_2_Fig3_HTML.png](../images/501530_1_En_2_Chapter/501530_1_En_2_Fig3_HTML.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![../images/501530_1_En_2_Chapter/501530_1_En_2_Fig3_HTML.png](../images/501530_1_En_2_Chapter/501530_1_En_2_Fig3_HTML.png)'
- en: Fig. 2.3
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3
- en: 'Python code for Caesar cipher example: shift by 1 letter'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 凯撒密码示例的Python代码：字母偏移1位
- en: 2.2.1.2 Substitution Ciphers
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.2.1.2 代换密码
- en: In a substitution cipher, we take the alphabet letters and place them in random
    order under the alphabet written correctly. In the encryption and decryption,
    the same key is used. The rule of encryption here is that “each letter gets replaced
    by the letter beneath it,” and the rule of decryption would be the opposite [[8](#CR8)].
    The substitution cipher did not shift the data by a fixed number. Instead, it
    shifts it by a random one. A Python example for substitution cipher is shown in
    Fig. [2.4](#Fig4).![../images/501530_1_En_2_Chapter/501530_1_En_2_Fig4_HTML.png](../images/501530_1_En_2_Chapter/501530_1_En_2_Fig4_HTML.png)
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在代换密码中，我们取字母表字母并将它们按照正确的字母表顺序放置在随机顺序下。在加密和解密中，使用相同的密钥。这里的加密规则是“每个字母被其下面的字母替换”，而解密规则则相反[[8](#CR8)]。代换密码不会通过固定数字进行偏移。而是通过随机数字进行偏移。代换密码的Python示例显示在图[2.4](#Fig4)中。![../images/501530_1_En_2_Chapter/501530_1_En_2_Fig4_HTML.png](../images/501530_1_En_2_Chapter/501530_1_En_2_Fig4_HTML.png)
- en: Fig. 2.4
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4
- en: Python code for substitution cipher example
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 代换密码示例的Python代码
- en: 2.2.1.3 Transposition/Polyalphabetic Ciphers
  id: totrans-23
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.2.1.3 位移/多表密码
- en: 'Instead of substituting letters, rearrange them. Transposition can be defined
    as the alteration of the letters in the plaintext through rules and a specific
    key. A columnar transposition cipher can be considered as one of the simplest
    types of transposition cipher and has two forms: the first is called “complete
    columnar transposition,” while the second is “incomplete columnar.” Regardless
    of which form is used, a rectangle shape is utilized to represent the written
    plaintext horizontally, and its width should correspond to the length of the key
    being used. There can be as many rows as necessary to write the message. When
    complete columnar transposition is used, the plaintext is written, and all empty
    columns are filled with null so that each column has the same length [[9](#CR9)].
    The key cannot have a repetitive letters. Python code for transposition cipher
    example is shown in Fig. [2.5](#Fig5). The algorithm can be summarized as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是替换字母，重新排列它们。移位可以被定义为通过规则和特定密钥在明文中对字母的更改。列移位密码可以被认为是移位密码中最简单的类型之一，有两种形式：第一种称为“完整的列移位”，而第二种称为“不完整的列移位”。无论使用哪种形式，都要使用矩形形状来水平表示书写的明文，其宽度应与正在使用的密钥的长度相对应。可以有任意多行以写入消息。当使用完整的列移位时，明文被写入，所有空列都填充了空值，以便每列的长度相同[[9](#CR9)]。密钥不能有重复的字母。列移位密码示例的Python代码如图[2.5](#Fig5)所示。算法可以总结如下：
- en: '1.'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '1.'
- en: The message is written out in rows of a fixed length and then read out again
    column by column, and the columns are chosen in some scrambled order according
    to the key.
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 消息按照固定长度的行写出，然后再按列读出，列根据密钥按某种乱序选择。
- en: '2.'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '2.'
- en: Width of the rows and the permutation of the columns are usually defined by
    a keyword.
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 行的宽度和列的排列通常由一个关键字定义。
- en: '3.'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '3.'
- en: For example, the key “KHALED” is of length 6, and the permutation is defined
    by the alphabetical order of the letters in the keyword. In this case, the order
    would be “3 6 5 2 1 4.”
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，密钥“KHALED”的长度为6，排列是由关键字中字母的字母顺序定义的。在这种情况下，顺序将是“3 6 5 2 1 4”。
- en: '4.'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '4.'
- en: Any spare spaces are filled with nulls or left blank.
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 任何多余的空格都填充了空值或留空。
- en: '5.'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '5.'
- en: Finally, the message is read off in columns, in the order specified by the keyword.
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，消息按照关键字指定的顺序按列读取。
- en: '6.'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '6.'
- en: To decipher it, the recipient has to work out the column lengths by dividing
    the message length by the key length.
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要解密它，接收者必须通过将消息长度除以密钥长度来计算列长度。
- en: '7.'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '7.'
- en: Then, write the message out in columns again, then re-order the columns by reforming
    the key word.
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，再次按列将消息写出，然后通过重新组合关键字重新排序列。
- en: '![../images/501530_1_En_2_Chapter/501530_1_En_2_Fig5_HTML.png](../images/501530_1_En_2_Chapter/501530_1_En_2_Fig5_HTML.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![../images/501530_1_En_2_Chapter/501530_1_En_2_Fig5_HTML.png](../images/501530_1_En_2_Chapter/501530_1_En_2_Fig5_HTML.png)'
- en: Fig. 2.5
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5
- en: Python code for transposition cipher example
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 用于列移位密码示例的Python代码
- en: 2.2.1.4 One-Time Pad Cipher
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.2.1.4 一次性密码本加密
- en: 'The cryptographic algorithms that already exist have the common strategy to
    have a large key space and a complicated algorithm. For symmetric cryptography,
    the use of one time pad is the simplest solution to the key distribution problem.
    However, with increasing advancement in technology, it is getting easier to break
    the algorithms that are widely in use. The increasing length of OTPs is also a
    cause of concern. Polyalphabetic cipher continued for almost 400 years. In 1882,
    Frank Miller invented cipher called as one-time pad. In one-time pad, a key was
    selected whose length was same as that of the plaintext message. The shifts in
    the plaintext never followed a repetitive pattern, and the encrypted message had
    uniform frequency distribution, thereby providing no leakage of the information.
    One-time pad (OTP) cipher is unbreakable due to the following [[10](#CR10)]:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现有的加密算法通常采用拥有较大密钥空间和复杂算法的常见策略。对于对称加密，使用一次性密码本是解决密钥分发问题的最简单方案。然而，随着技术的不断进步，越来越容易破解广泛使用的算法。一次性密码本的长度增加也是一个令人担忧的问题。多表密码持续了将近400年。1882年，Frank
    Miller发明了被称为一次性密码本的密码。在一次性密码本中，选择了一个与明文消息长度相同的密钥。明文中的偏移从不遵循重复模式，加密消息具有均匀的频率分布，从而不会泄漏信息。一次性密码本（OTP）密码由于以下原因是不可破解的[[10](#CR10)]：
- en: The key is as long as the given message.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密钥与给定消息一样长。
- en: The key is truly random and especially auto-generated.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密钥是真正随机的，特别是自动生成的。
- en: Key and plain text calculated as modulo 10/26/2.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密钥和明文计算为模10/26/2。
- en: Each key should *be used once* and destroyed by both sender and receiver.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个密钥应该*仅使用一次*，并由发送方和接收方销毁。
- en: 'There should be two copies of key: one with the sender and other with the receiver.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该有两份密钥副本：一份给发送方，另一份给接收方。
- en: The problem with the one-time pad is that, in order to create such a cipher,
    its key should be as long as or even longer than the plaintext. In other words,
    if you have 500 megabyte video file that you would like to encrypt, you would
    need a key that’s at least 4 gigabits long.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一次性密码本的问题在于，为了创建这样的密码，其密钥应该与明文一样长甚至更长。换句话说，如果您有一个500兆字节的视频文件需要加密，您将需要一个至少4吉比特长的密钥。
- en: '2.2.2 Modern Algorithms: Bits-Based Algorithms'
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.2 现代算法：基于比特的算法
- en: 2.2.2.1 Stream Ciphers
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.2.2.1 流密码
- en: 'Stream ciphers operate on pseudorandom bits generated from the key, and the
    plaintext is encrypted by XORing both the plaintext and the pseudorandom bits.
    Stream ciphers use conceptual tools similar to block ciphers. Substitution is
    the primary tool: each bit or byte of plaintext is combined with the key material
    by an Exclusive-OR (XOR) operation to substitute the plaintext bit into the ciphertext
    bit. Binary XOR is quite simple. There are only two possible values, 1 and 0,
    and if the two inputs are the same, the result is 0; otherwise it is 1 [[11](#CR11)].
    Stream cipher’s security depends entirely on the “suitable” key stream, while
    randomness plays a main role, so the random number generator (RNG) is significant
    for that purpose. *Neural* cryptography is a new source for public key cryptography
    schemes which are not based on number theory and have less computation time and
    memory complexities. Neural cryptography can be used to generate a common secret
    key between two parties [[12](#CR12)].'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 流密码使用从密钥生成的伪随机比特，并通过对明文和伪随机比特进行异或运算来加密明文。流密码使用类似于块密码的概念工具。替换是主要工具：每个明文的比特或字节通过异或运算与密钥材料相结合，将明文比特替换为密文比特。二进制异或运算非常简单。只有两种可能的值，1
    和 0，如果两个输入相同，则结果为 0；否则为 1 [[11](#CR11)]。流密码的安全性完全取决于“合适”的密钥流，而随机性起主要作用，因此随机数生成器
    (RNG) 对此非常重要。*神经*密码学是公钥密码方案的新来源，它不基于数论，并且具有较少的计算时间和内存复杂性。神经密码学可用于在两个方之间生成一个公共秘密密钥
    [[12](#CR12)]。
- en: E0 Cipher
  id: totrans-53
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: E0 密码
- en: E0 is a stream cipher used in the Bluetooth protocol. It generates a sequence
    of pseudorandom numbers and combines it with the data using the XOR operator.
    The key length may vary but is generally 128 bits. At each iteration, E0 generates
    a bit using four shift registers of differing lengths (25, 31, 33, 39 bits) and
    two internal states, each 2 bits long. At each clock tick, the registers are shifted,
    and the two states are updated with the current state, the previous state and
    the values in the shift registers. Four bits are then extracted from the shift
    registers and added together. The algorithm XORs that sum with the value in the
    2 bit register. The first bit of the result is output for the encoding [[13](#CR13)].
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: E0 是蓝牙协议中使用的流密码。它生成一系列伪随机数，并使用异或运算符与数据结合。密钥长度可能有所不同，但通常为 128 位。在每次迭代中，E0 使用四个不同长度的移位寄存器（25、31、33、39
    位）和两个内部状态（每个 2 位长）生成一个比特。在每个时钟周期中，寄存器被移位，并且两个状态使用当前状态、前一个状态和移位寄存器中的值进行更新。然后从移位寄存器中提取四位并将它们相加。该算法使用异或运算符将该和与
    2 位寄存器中的值异或。结果的第一个比特用于编码 [[13](#CR13)]。
- en: 2.2.2.2 Block Ciphers
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.2.2.2 块密码
- en: 'In a block cipher, two values are generally referred to: the size of the block
    and the size of the key. The security relies on the value of both. Many block
    ciphers use a 64 bit block or a 128 bit block. As it is crucial that the blocks
    are not too large, the memory footprint and the ciphertext length are small in
    size. Regarding the ciphertext length, blocks instead of bits are processed in
    a block cipher. Block ciphers can be symmetric or nonsymmetric as will be discussed
    later in this chapter.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在块密码中，通常提到两个值：块大小和密钥大小。安全性取决于两者的值。许多块密码使用64位块或128位块。由于块的大小不宜过大，因此内存占用和密文长度较小。关于密文长度，在块密码中处理的是块而不是位。块密码可以是对称的或非对称的，稍后将在本章中讨论。
- en: We start with *plaintext*. Something you can read. We apply a mathematical algorithm
    to the plaintext.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从*明文*开始。那是你可以阅读的东西。我们对明文应用数学算法。
- en: The algorithm is the *cipher*. The plaintext is turned in to *ciphertext*. In
    symmetric encryption, same key is used to encrypt and decrypt the data. The shared
    key K between sender and receiver should be kept secret. The encryption/decryption
    process can be modeled by eq. ([2.1](#Equ1)) and can be seen in Fig. [2.6](#Fig6):![$$
    P={D}_K\left({E}_k(P)\right) $$](../images/501530_1_En_2_Chapter/501530_1_En_2_Chapter_TeX_Equ1.png)(2.1)![../images/501530_1_En_2_Chapter/501530_1_En_2_Fig6_HTML.png](../images/501530_1_En_2_Chapter/501530_1_En_2_Fig6_HTML.png)
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法是*密码*。明文被转化为*密文*。在对称加密中，同一密钥用于加密和解密数据。发送方和接收方之间共享的密钥K应保密。加密/解密过程可以由等式([2.1](#Equ1))建模，并可见于图[2.6](#Fig6)：![$$
    P={D}_K\left({E}_k(P)\right) $$](../images/501530_1_En_2_Chapter/501530_1_En_2_Chapter_TeX_Equ1.png)(2.1)![../images/501530_1_En_2_Chapter/501530_1_En_2_Fig6_HTML.png](../images/501530_1_En_2_Chapter/501530_1_En_2_Fig6_HTML.png)
- en: Fig. 2.6
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.6
- en: Symmetric key encryption
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 对称密钥加密
- en: Symmetric encryption is fast to encrypt and decrypt, suitable for large volumes
    of data. Comparative analysis of symmetric encryption algorithm is shown in Table
    [2.1](#Tab1).Table 2.1
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 对称加密速度快，适用于大数据量的加密和解密。对称加密算法的比较分析如表[2.1](#Tab1)所示。表 2.1
- en: Comparative analysis of symmetric encryption algorithm [[14](#CR14), [15](#CR15)]
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 对称加密算法的比较分析[[14](#CR14), [15](#CR15)]
- en: '| Algorithms/parameters | DES | 3DES | AES | Blowfish |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| 算法/参数 | DES | 3DES | AES | 布洛菲斯 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| Published | 1977 | 1998 | 2001 | 1993 |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| 发表 | 1977 | 1998 | 2001 | 1993 |'
- en: '| Developed by | IBM | IBM | Vincent Rijmen, Joan Daeman | Bruce Schneier |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| 由 | IBM | IBM | 文森特·里曼，琼·达曼 | 布鲁斯·施耐尔 |'
- en: '| Algorithm structure | Feistel | Feistel | Substitution-Permutation | Feistel
    |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| 算法结构 | 菲斯特尔 | 菲斯特尔 | 替代-置换 | 菲斯特尔 |'
- en: '| Block cipher | Binary | Binary | Binary | Binary |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| 块密码 | 二进制 | 二进制 | 二进制 | 二进制 |'
- en: '| Key length | 56 bits | 112 bits, 168 bits | 128 bits, 192 bits and 256 |
    32–448 bits |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 密钥长度 | 56位 | 112位，168位 | 128位，192位和256 | 32-448位 |'
- en: '| Flexibility or modification | No | Yes, extended from 56 to 168 bits | Yes,
    256 key size is multiple of 64 | Yes, 64–448 key size in multiple of 32 |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| 灵活性或修改 | 否 | 是，从 56 位扩展到 168 位 | 是，256 位密钥大小是 64 的倍数 | 是，64-448 位密钥大小是 32
    的倍数 |'
- en: '| Number of rounds | 16 | 48 | 10, 12, 14 | 16 |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 轮数 | 16 | 48 | 10、12、14 | 16 |'
- en: '| Block size | 64 bits | 64 bits | 128 bits | 64 bits |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| 块大小 | 64 位 | 64 位 | 128 位 | 64 位 |'
- en: '| Throughput | Lower than AES | Lower than DES | Lower than Blowfish | High
    |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| 吞吐量 | 低于 AES | 低于 DES | 低于 Blowfish | 高 |'
- en: '| Level of security | Adequate security | Adequate security | Excellent security
    | Excellent security |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| 安全级别 | 充分的安全性 | 充分的安全性 | 出色的安全性 | 出色的安全性 |'
- en: '| Encryption speed | slow | Very slow | Fast | Fast |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| 加密速度 | 慢 | 非常慢 | 快 | 快 |'
- en: '| Effectiveness | Slow in both software and hardware | Slow in software | Effective
    in both software and hardware | Efficient in software |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| 效率 | 在软件和硬件中都较慢 | 在软件中较慢 | 在软件和硬件中都有效 | 在软件中高效 |'
- en: '| Attacks | Brute force attack | Brute force attack, known plaintext, chosen
    plaintext | Side channel attack | Dictionary attack |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| 攻击 | 暴力破解 | 暴力破解、已知明文、已选明文 | 侧信道攻击 | 字典攻击 |'
- en: Rijndael Algorithm
  id: totrans-78
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Rijndael 算法
- en: Rijndael is a symmetric key encryption algorithm that’s constructed as a block
    cipher. It supports key sizes of 128, 192, and 256 bits, with data handling taking
    place in 128 bit blocks. In addition, the block sizes can mirror those of their
    respective keys. This last specification puts Rijndael over the limits required
    for AES design conditions, and the Advanced Encryption Standard itself is looked
    upon as a subset of the Rijndael algorithm [[16](#CR16)].
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Rijndael 是一种对称密钥加密算法，构建为块密码。它支持 128、192 和 256 位的密钥大小，数据处理以 128 位块为单位进行。此外，块大小可以与相应的密钥大小相同。这个最后的规范使
    Rijndael 超过了 AES 设计条件所要求的限制，而高级加密标准本身被视为 Rijndael 算法的子集[[16](#CR16)]。
- en: SAFER Algorithm
  id: totrans-80
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: SAFER 算法
- en: 'In cryptography, SAFER (Secure And Fast Encryption Routine) is the name of
    a family of block ciphers designed primarily by James Massey (one of the designers
    of IDEA) on behalf of Cylink Corporation. The first SAFER cipher was SAFER K-64,
    published by Massey in 1993, with a 64 bit block size. The “K-64” denotes a key
    size of 64 bits. There was some demand for a version with a larger 128 bit key.
    This algorithm is of interest for several reasons. It is designed for use in software.
    Unlike DES, or even IDEA, it does not divide the block into parts of which some
    parts affect others; instead, the plaintext is directly changed by going through
    S-boxes, which are replaced by their inverses for decryption. SAFER uses eight
    rounds. The first step for a round is to apply the first subkey for the round
    to the 8 bytes of the block. The operation by which each byte of the subkey is
    applied to each byte of the block depends on which byte is used: the sequence
    is XOR, add, add, XOR, XOR, add, add, XOR. Then, the S-box is used. Those bytes
    to which the subkey was applied by an XOR go through the regular S-box; those
    bytes to which it was applied by addition go through the inverse S-box [[17](#CR17)].'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在密码学中，SAFER（Secure And Fast Encryption Routine）是由James Massey（IDEA的设计者之一）代表Cylink
    Corporation设计的一类分组密码算法。第一个SAFER密码是SAFER K-64，由Massey于1993年发布，块大小为64位。“K-64”表示64位密钥大小。人们对带有更大128位密钥版本的SAFER有一定的需求。该算法因几个原因而引起了兴趣。它是为软件设计的。与DES甚至IDEA不同，它不将块分成一些部分，其中的一些部分影响其他部分；相反，明文通过S-boxes直接改变，解密时通过它们的逆旋转替换。SAFER使用了八轮。一轮的第一步是将该轮的第一个子密钥应用于该块的8个字节。每个子密钥字节应用于块的每个字节的操作取决于使用了哪个字节：序列是XOR，add，add，XOR，XOR，add，add，XOR。然后使用S-box。XOR应用的字节通过常规的S-box；通过加法应用的字节通过逆S-box
    [[17](#CR17)]。
- en: AES Algorithm
  id: totrans-82
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: AES算法
- en: 'Data Encryption Standard (DES) was the encryption standard till 2001 when it
    was replaced by AES. The Advanced Encryption Standard (AES) was established by
    National Institute of Standards and Technology (NIST) in 2001 as the current standard
    for encrypting electronic data [[18](#CR18)]. AES is based on *Rijndael* cipher
    which is an iterated block cipher with a fixed block length and supports variable
    key lengths. A block length of 128 bits and three different key sizes of 128,
    192, and 256, which require 10, 12, and 14 rounds, respectively, are used. Figures
    [2.7](#Fig7) and [2.8](#Fig8), respectively, show AES ciphering and deciphering.
    AES is working as follows (Fig. [2.9](#Fig9)):'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 数据加密标准（DES）是2001年之前的加密标准，后来被AES取代。高级加密标准（AES）是由美国国家标准与技术研究所（NIST）于2001年确定的电子数据加密的当前标准
    [[18](#CR18)]。AES基于* Rijndael*密码，它是一个迭代块密码，具有固定的块长度并支持可变的密钥长度。使用128位块长度和三种不同的密钥大小，分别为128、192和256位，需要进行10、12和14轮加密。图[2.7](#Fig7)和图[2.8](#Fig8)分别显示了AES加密和解密。AES的工作如下（图[2.9](#Fig9)）：
- en: '1.'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '1.'
- en: 'Add round key: round key is XORed with the plaintext, and then the result will
    be converted into 4× 4 *matrix* (state).'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The sub-byte transformation is a nonlinear *substitution* operation that works
    on bytes. It’s based on the Galois field GF (2⁸) with irreducible polynomial *m*(*x*) = *x*⁸ + *x*⁴ + *x*³ + *x* + 1
    and can be done using look up table.
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '3.'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The shift row transformation *rotates* each row of the input state to the left;
    the first row will remain unshifted; the second row will be rotated by 1 step
    to the left, whereas the second row will be rotated by two steps; and the third
    row will be rotated 3 steps to the left.
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '4.'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Mix columns: each input column is considered as a polynomial over GF (2⁸) and
    *multiplied* with the constant polynomial *a*(*x*) = {03}*x*3 + {01}*x*² + {01}*x* + {02}modulo *x*⁴ + 1\.
    The coefficients of *a*(*x*) are also elements of GF (2⁸) and are represented
    by hexadecimal values in this equation. The inverse mix column transformation
    is the multiplication of each column with *a*(*x*) = {0*B*}*x*3 + {0*D*}*x*² + {09}*x* + {0*E*}modulo *x*⁴ − 1.'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '5.'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Key expansion.
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![../images/501530_1_En_2_Chapter/501530_1_En_2_Fig7_HTML.png](../images/501530_1_En_2_Chapter/501530_1_En_2_Fig7_HTML.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
- en: Fig. 2.7
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: AES ciphering
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '![../images/501530_1_En_2_Chapter/501530_1_En_2_Fig8_HTML.png](../images/501530_1_En_2_Chapter/501530_1_En_2_Fig8_HTML.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
- en: Fig. 2.8
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: AES deciphering
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '![../images/501530_1_En_2_Chapter/501530_1_En_2_Fig9_HTML.png](../images/501530_1_En_2_Chapter/501530_1_En_2_Fig9_HTML.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
- en: Fig. 2.9
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: AES encryption
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Blowfish
  id: totrans-103
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Blowfish  is a 64 bit symmetric key block cipher used to efficiently encrypt
    data. The Blowfish algorithm has a Feistel structure which means that it iterates
    a simple encryption function 16 times. It uses variable key lengths ranging from
    32 bits up to a maximum of 448 bits. It was first introduced by the security guru
    Bruce Schneier in 1993, and it has never been cracked [[19](#CR19)]. Twofish,
    also designed by Schneier, is the successor of Blowfish, and it contains a 128
    bit block along with key up to 256 bits long [[20](#CR20)].
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Blowfish是一种64位对称密钥分组密码，用于高效加密数据。Blowfish算法具有费斯特结构，这意味着它会对简单的加密函数进行16次迭代。它使用可变长度的密钥，范围从32位到最大448位。它是由安全专家布鲁斯·施奈尔于1993年首次引入的，并且从未被破解[[19](#CR19)]。Twofish，也是由施奈尔设计，是Blowfish的继任者，它包含一个128位块以及长达256位的密钥[[20](#CR20)]。
- en: Des
  id: totrans-105
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 描述
- en: The Data Encryption Standard (DES)  is a symmetric key block cipher published
    by the National Institute of Standards and Technology (NIST). DES is an implementation
    of a Feistel cipher. It uses 16 round Feistel structure. The block size is 64
    bit. Though, key length is 64 bit, DES has an effective key length of 56 bits,
    since 8 of the 64 bits of the key are not used by the encryption algorithm (function
    as check bits only). DES structure is shown in Fig. [2.10](#Fig10) [[21](#CR21)].
    *Feistel cipher* is not a specific scheme of block cipher. It is a design model
    from which many different block ciphers are derived. DES is just one example of
    a Feistel cipher. A cryptographic system based on Feistel cipher structure uses
    the same algorithm for both encryption and decryption. The encryption process
    uses the Feistel structure consisting multiple rounds of processing of the plaintext,
    each round consisting of a “substitution” step followed by a permutation step.![../images/501530_1_En_2_Chapter/501530_1_En_2_Fig10_HTML.png](../images/501530_1_En_2_Chapter/501530_1_En_2_Fig10_HTML.png)
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 数据加密标准（DES）是由美国国家标准与技术研究院（NIST）发布的对称密钥分组密码。DES是费斯特密码的一种实现。它使用16轮费斯特结构。分组大小为64位。尽管密钥长度为64位，但DES的有效密钥长度为56位，因为64位密钥中的8位仅用作加密算法的校验位（仅起校验位作用）。DES结构如图[2.10](#Fig10)所示[[21](#CR21)]。*费斯特密码*不是特定的分组密码方案。它是一个设计模型，从中衍生出许多不同的分组密码。DES只是费斯特密码的一个示例。基于费斯特密码结构的加密系统使用相同的算法进行加密和解密。加密过程使用费斯特结构对明文进行多轮处理，每轮由“替代”步骤和置换步骤组成。![../images/501530_1_En_2_Chapter/501530_1_En_2_Fig10_HTML.png](../images/501530_1_En_2_Chapter/501530_1_En_2_Fig10_HTML.png)
- en: Fig. 2.10
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.10
- en: DES structure
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: DES结构
- en: Triple DES/3DES
  id: totrans-109
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 三重DES/3DES
- en: The basic methodology of Triple DES is based on DES. It encrypts the plain text
    three times. The overall key length of Triple DES is 192 bits, i.e., three 64
    bit keys are used in this block cipher. Like DES, the effective length of each
    key is 56 bits. In Triple DES, the first encrypted cipher text is again encrypted
    by the second key, and again the third key encrypts the resulting encrypted cipher
    text. Though this algorithm is much more secure than DES, it is too slow for many
    real life applications [[22](#CR22)].
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 三重 DES 的基本方法是基于 DES。它将明文加密三次。三重 DES 的总密钥长度为192位，即在此分组密码中使用了三个64位密钥。与 DES 一样，每个密钥的有效长度为56位。在三重
    DES 中，第一个加密的密文再次被第二个密钥加密，然后第三个密钥加密生成的加密密文。虽然此算法比 DES 安全得多，但对于许多实际应用来说速度太慢[[22](#CR22)]。
- en: RC4 (Rivest Cipher 4)
  id: totrans-111
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: RC4（Rivest Cipher 4）
- en: This is a stream cipher published in 1987\. The disadvantage of these techniques
    is the generation of the key stream, which is a potentially long sequence of values
    consisting of 40 bit to 128 bit key and a 24 bit initialization vector. But the
    encryption is straightforward; the actual plaintext is xor’d with the key stream.
    The key input is a pseudorandom bit generator that creates a byte number, which
    is the output of the generator and it is called the key stream. The key stream
    is then XORed with the plaintext byte by byte to produce the ciphertext. It is
    impossible to predict the key stream without having knowledge of the key.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这是1987年发布的一种流密码。这些技术的缺点是密钥流的生成，这是一个潜在的长序列，由40位至128位的密钥和24位的初始化向量组成。但加密很简单；实际的明文与密钥流进行异或操作。密钥输入是一个伪随机比特生成器，它创建一个字节号，即生成器的输出，并称之为密钥流。然后，密钥流与明文逐字节进行异或操作以生成密文。在没有密钥知识的情况下，无法预测密钥流。
- en: RC5 (Rivest Cipher 4)
  id: totrans-113
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: RC5（Rivest Cipher 4）
- en: This is a block cipher algorithm, published in 1994, which uses variable block
    size, key size, and encryption steps. The block size can be 32, 64, or 128 bits,
    and the key size can be from 0 up to 2040 bits. Additionally, the number of rounds
    can be from 0 up to 255\. It consists of some modular additions and exclusive
    OR (XOR) operations. It is vulnerable to a differential attack using numerous
    chosen plaintexts, where the inputs differences can also affect the outputs [[23](#CR23)].
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这是1994年发布的一个分组密码算法，它使用可变的块大小、密钥大小和加密步骤。块大小可以是32位、64位或128位，密钥大小可以从0到2040位。此外，轮数可以从0到255。它由一些模加和异或（XOR）操作组成。它容易受到差分攻击的影响，使用大量的已选择的明文，其中输入差异也会影响输出[[23](#CR23)]。
- en: SEAL Algorithm
  id: totrans-115
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: SEAL 算法
- en: 'SEAL is a length-raising “illusive random” that depicts 32 bit string N- to
    L-bit string SEAL under a hidden 160 bit key. The output length *L* is intended
    to be diverse, however, in general bound to 64 kilobytes. The key usage is to
    figure out three secret charts: R, S, and T; these charts have 256, 256, and 512
    32 bit values, respectively, that are induced from the Secure Hash Algorithm (SHA).
    SEAL is the fruit of the dual shower source clarified. The first generator implements
    a systematic relies on the deducted charts R and T. It maps the 32-bit string
    n and the 6-bit counter [[24](#CR24)].'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: SEAL 是一种长度扩展的“虚假随机”，用一个隐藏的 160 位密钥将 32 位字符串 N 转换为 L 位字符串 SEAL。输出长度 *L* 旨在多样化，但通常限制在
    64 千字节。密钥的用途是确定三个秘密图表：R、S 和 T；这些图表分别具有 256、256 和 512 个 32 位值，这些值是从安全哈希算法（SHA）中产生的。SEAL
    是双淋浴源的成果。第一个生成器实现了一个系统，依赖于推断的图表 R 和 T。它映射了 32 位字符串 n 和 6 位计数器[[24](#CR24)]。
- en: 2.3 Asymmetric Encryption
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3 非对称加密
- en: Many applications use asymmetric cryptography to secure communications between
    two parties. One of the main issues with asymmetric cryptography is the need for
    vast amounts of computation and storage.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 许多应用程序使用非对称加密来保护两方之间的通信。非对称加密的主要问题之一是需要大量的计算和存储。
- en: The concept of public key cryptography evolved from an ‑attempt to attack two
    of the most difficult problems associated with symmetric encryption. The first
    problem is that of key distribution, where under symmetric encryption requires
    either that two communicants already share a key, which somehow has been distributed
    to them or the use of a *key distribution center.* Asymmetric algorithms rely
    on one key for encryption and a different but related key for decryption [[25](#CR25)].
    There are many methods for key establishment, including certificates and public
    key infrastructure (*PKI*).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 公钥密码学的概念起源于试图攻击与对称加密相关的两个最困难的问题。第一个问题是密钥分配，其中对称加密要求两个通信方已经共享一个密钥，该密钥已以某种方式分发给它们，或者使用
    *密钥分配中心*。非对称算法依赖于一个密钥进行加密，而使用另一个但相关的密钥进行解密[[25](#CR25)]。有许多方法用于密钥建立，包括证书和公钥基础设施（*PKI*）。
- en: The *public key* is freely distributable. It is related mathematically to the
    private key, but you cannot (easily) reverse engineer the *private key* from the
    *public key.* Use the *public key* to encrypt data.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*公钥* 是可以自由分发的。它在数学上与私钥相关，但你不能（轻易地）从 *公钥* 反推 *私钥*。使用 *公钥* 加密数据。'
- en: Only someone with the *private key* can decrypt.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 只有拥有 *私钥* 的人才能解密。
- en: The key for encryption (K[E]) and decryption (K[D]) are different. But, K[E]
    and K[D] form a unique pair. One of keys is made public and another made private.
    The encryption/decryption process can be modeled by eq. ([2.2](#Equ2)) and can
    be seen in Fig. [2.11](#Fig11).![$$ P={D}_{K_D}\left({E}_{K_E}(P)\right) $$](../images/501530_1_En_2_Chapter/501530_1_En_2_Chapter_TeX_Equ2.png)(2.2)![../images/501530_1_En_2_Chapter/501530_1_En_2_Fig11_HTML.png](../images/501530_1_En_2_Chapter/501530_1_En_2_Fig11_HTML.png)
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 用于加密（K[E]）和解密（K[D]）的密钥是不同的。但是，K[E] 和 K[D] 构成了一个唯一的密钥对。其中一个密钥是公开的，另一个是私有的。加密/解密过程可以通过方程([2.2](#Equ2))建模，并可在图[2.11](#Fig11)中看到。![$$
    P={D}_{K_D}\left({E}_{K_E}(P)\right) $$](../images/501530_1_En_2_Chapter/501530_1_En_2_Chapter_TeX_Equ2.png)(2.2)![../images/501530_1_En_2_Chapter/501530_1_En_2_Fig11_HTML.png](../images/501530_1_En_2_Chapter/501530_1_En_2_Fig11_HTML.png)
- en: Fig. 2.11
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.11
- en: Asymmetric key encryption
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 非对称密钥加密
- en: Public key systems can be used for encryption and authentication. One key is
    used to encrypt the document; a different key is used to decrypt it. Comparison
    between symmetric and nonsymmetric encryption is shown in Table [2.2](#Tab2).Table
    2.2
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 公钥系统可用于加密和认证。一个密钥用于加密文档；另一个密钥用于解密。对称和非对称加密的比较如表[2.2](#Tab2)所示。表2.2
- en: Comparison between symmetric and nonsymmetric encryption
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 对称和非对称加密的比较
- en: '| Symmetric encryption | Nonsymmetric encryption |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| 对称加密 | 非对称加密 |'
- en: '| --- | --- |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 1\. The same algorithm with the same key is used for encryption and decryption2\.
    The sender and receiver must share the algorithm and the key3\. The key must be
    kept secret4\. It must be impossible or at least impractical to decipher a message
    if no other information is available5\. Knowledge of the algorithm plus samples
    of ciphertext must be insufficient to determine the key | 1\. One algorithm is
    used for encryption and decryption with a pair of keys, one for encryption and
    one for decryption2\. The sender and receiver must each have one of the matched
    pair of keys (not the same one)3\. One of the two keys must be kept secret4\.
    It must be impossible or at least impractical to decipher a message if no other
    information is available5\. Knowledge of the algorithm plus one of the keys plus
    samples of ciphertext must be insufficient to determine the other key |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| 1\. 使用相同的算法和相同的密钥进行加密和解密2\. 发件人和收件人必须共享算法和密钥3\. 密钥必须保密4\. 如果没有其他信息可用，解密消息必须是不可能的或至少是不切实际的5\.
    算法的知识加上密文样本必须不足以确定密钥 | 1\. 一种算法用于加密和解密，使用一对密钥，一个用于加密，一个用于解密2\. 发件人和收件人必须分别拥有匹配的密钥对中的一个（不是相同的密钥）3\.
    两个密钥中的一个必须保密4\. 如果没有其他信息可用，解密消息必须是不可能的或至少是不切实际的5\. 算法的知识加上一个密钥加上密文样本必须不足以确定另一个密钥
    |'
- en: The security of asymmetric encryption rests on computational problems such as
    the difficulty of factorizing large prime numbers and the discrete logarithm problem.
    Such kind of algorithms is called one-way functions because they are easy to compute
    in one direction, but the inversion is difficult. Public key encryption works
    very well and is extremely secure, but it’s based on complicated mathematics.
    Because of this, your computer has to work very hard to both encrypt and decrypt
    data using the system. In applications where you need to work with large quantities
    of encrypted data on a regular basis, the computational overhead means that public
    key systems can be very slow.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '2.3.1 RSA: Factorization Computational Problem'
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Rivest–Shamir–Adleman (RSA) scheme has been published in 1978, and since
    that time it is the most widely accepted and implemented general-purpose approach
    to public key encryption [[26](#CR26)]. Encryption and decryption are of the following
    form, for some plaintext block *M* and ciphertext block *C*:![$$ C={M}^e\operatorname{mod}n
    $$](../images/501530_1_En_2_Chapter/501530_1_En_2_Chapter_TeX_Equ3.png)(2.3)![$$
    M={C}^d\operatorname{mod}n={\left({M}^e\right)}^d\operatorname{mod}n={M}^{ed}\operatorname{mod}n
    $$](../images/501530_1_En_2_Chapter/501530_1_En_2_Chapter_TeX_Equ4.png)(2.4)
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Both sender and receiver must know the value of *n*. Plaintext is encrypted
    in blocks, with each block having a binary value less than some number *n*. That
    is, the block size must be less than or equal to log[2](*n*). The RSA scheme is
    a block cipher in which the plaintext and ciphertext are integers between 0 and
    *n*-1 for some *n*. The sender knows the value of e, and only the receiver knows
    the value of d. Thus, this is a public key encryption algorithm with a public
    key of = {*e*, *n*} and a private key of = {*d*, *n*}.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'For this algorithm to be satisfactory for public key encryption, the following
    requirements must be met:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '1.'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is possible to find values of *e*, *d*, and *n* such that *M*^(*ed*) mod
    *n* = *M* for all *M < n.*
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可以找到*e*、*d*和*n*的值，使得*M*^(*ed*) mod *n* = *M*对所有*M < n*成立。
- en: This is done by choosing *n = pq, where p and q are primes numbers.* Select
    e, where *1 < e < (p-1) (q-1)* and *gcd ((p-1) (q-1), e) = 1, which means e is
    a prime to (p-1) (q-1). Select d, where d = e*^(*−1*)*mod ((p-1) (q-1)) or de = 1
    mod((p-1) (q-1)).*
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过选择*n = pq*，其中*p*和*q*是质数，完成这一过程。选择*e*，其中*1 < e < (p-1)(q-1)*且*gcd((p-1)(q-1),
    e) = 1*，这意味着*e*是*(p-1)(q-1)*的质数。选择*d*，其中*d = e*^(*−1*)*mod((p-1)(q-1))*或*de =
    1 mod((p-1)(q-1))*。
- en: '2.'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '2.'
- en: It is relatively easy to calculate mod *M*^(*e*) mod *n* and *C*^(*d*) for all
    values of *M < n.*
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 计算模*M*^(*e*) mod *n*和所有*M < n*值的*C*^(*d*)相对容易。
- en: '3.'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '3.'
- en: It is infeasible to determine d given *e* and *n.*
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在给定*e*和*n*的情况下确定*d*是不可行的。
- en: 'An example is shown below:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '以下是一个示例:'
- en: Assume plaintext = 88.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设明文= 88。
- en: '*Key generation*: *n* = 17 × 11 = 187\. *e* = 7, where gcd (160, 7) =1\. *D* = 23,
    where *d**7 = 1 mod 160.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*密钥生成*: *n* = 17 × 11 = 187。*e* = 7，其中*gcd(160, 7) = 1*。*D* = 23，其中*d*^(*7*)*
    = 1 mod 160*。'
- en: '*Encryption process*: *C* = 88⁷ mod 187 = 11.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*加密过程*: *C* = 88⁷ mod 187 = 11。'
- en: '*Decryption process*: *M* = 11^(23) mod 187 = 88.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*解密过程*: *M* = 11^(23) mod 187 = 88。'
- en: '2.3.2 ECC: Discrete Logarithm Problem (DLP)'
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.2 ECC：离散对数问题（DLP）
- en: Elliptic curve cryptography (ECC) is a public key cryptographic technique based
    on the algebraic structure of elliptic curves over finite fields. ECC is an approach
    to asymmetric cryptography used widely in low computation devices such as wireless
    sensor networks (WSNs) and Internet of Things (IoT) devices as it decreases power
    consumption and increases device performance [[27](#CR27)]. This is due to its
    ability to generate small keys with a strong encryption mechanism. For example,
    encryption using the RSA algorithm with a 1024 bit key is equal to ECC encryption
    with a 160 bit key [[28](#CR28)]. ECC ensures security depending on the ability
    to compute a point multiplication with a random point, as well as the inability
    to figure out a multiplicand given the original curve and product points. ECC
    uses a pair (*x*; *y*) that fits into the equation *y*² = *x*³ + *ax* + *b* mod
    *p* together with an imaginary point (theta) at infinity, where *a*; *b* ϵ *Zp*
    and 4*a*³ + 27*b*² ≠ 0 mod *p*. ECC needs a cyclic Group G and the primitive elements
    we use, or pair elements, to be of order G.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 椭圆曲线密码学（ECC）是一种基于有限域上椭圆曲线的代数结构的公钥密码技术。ECC是一种用于低计算设备（如无线传感器网络（WSN）和物联网（IoT）设备）的非对称加密技术，因其降低了功耗并提高了设备性能而被广泛使用，这归功于其生成具有强加密机制的小密钥的能力。例如，使用1024位密钥的RSA算法加密等同于使用160位密钥的ECC加密。ECC确保安全性取决于计算具有随机点的点乘的能力，以及在给定原始曲线和乘积点的情况下无法找出乘数。ECC使用一个(*x*;
    *y*)对，它适合于方程*y*² = *x*³ + *ax* + *b* mod *p*，以及一个无穷远点（theta），其中*a*; *b* ϵ *Zp*且*4a³
    + 27b² ≠ 0 mod p*。ECC需要一个循环群*G*和我们使用的原始元素，或成对元素，是*G*的顺序。
- en: 2.3.3 ElGamal Cryptosystem
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.3 ElGamal加密系统
- en: ElGamal cryptosystem is an asymmetric key encryption which was proposed by Taher
    Elgamal in 1984\. The security of this algorithm is based on the discrete logarithm
    problem. For a given number, there is no existing algorithm which can find its
    discrete logarithm in polynomial time, but the inverse operation of the power
    can be derived efficiently. Another key aspect of ElGamal cryptosystem is randomized
    encryption. This algorithm can establish a secure channel for key sharing and
    generally used as key authentication protocol. For security the key size of this
    algorithm should be greater than 1024 bits. The major drawback of ElGamal algorithm
    is that it is relatively time-consuming.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '2.3.4 Diffie–Hellman Algorithm: Key Exchange'
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Diffie–Hellman (DH) key exchange algorithm is a method for securely exchanging
    cryptographic keys over a public communications channel. Keys are not actually
    exchanged, but they are jointly derived. Traditionally, secure encrypted communication
    between two parties required that they first exchange keys by some secure physical
    means, such as paper key lists transported by a trusted courier. The Diffie–Hellman
    key exchange method allows two parties that have no prior knowledge of each other
    to jointly establish a shared secret key over an insecure channel. This key can
    then be used to encrypt subsequent communications using a symmetric key cipher.
    The steps are as follows [[29](#CR29)]:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '1.'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Alice and Bob publicly agree to use a modulus *p* and base *g* (which is a primitive
    root modulo p).
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Alice chooses a secret integer ***a*** and then sends Bob *A* = *g*^(***a***)
    mod *p.*
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '3.'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bob chooses a secret integer ***b*** and then sends Alice *B* = *g*^(***b***)
    mod *p.*
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '4.'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Alice computes ***s*** = *B*^(***a***) mod *p*.
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '5.'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bob computes ***s*** = *A*^(***b***) mod *p*.
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '6.'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Alice and Bob now share a secret (s).
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The difficulty of breaking these cryptosystems is based on the difficulty in
    determining the integer r such that *g*^(*r*) = *x* mod *p*. The integer r is
    called the discrete logarithm problem of *x* to the base *g*, and we can write
    it as ![$$ r={\log}_g^x $$](../images/501530_1_En_2_Chapter/501530_1_En_2_Chapter_TeX_IEq1.png)
    mod p. The discrete logarithm problem is a very hard problem to compute if the
    parameters are large enough.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 破解这些加密系统的难度基于确定整数r，使得*g*^(*r*) = *x* mod *p*的难度。整数r称为*x*对于基数*g*的离散对数问题，我们可以将其写为
    ![$$ r={\log}_g^x $$](../images/501530_1_En_2_Chapter/501530_1_En_2_Chapter_TeX_IEq1.png)
    mod p。离散对数问题是一个非常难以计算的问题，如果参数足够大的话。
- en: 2.3.5 EGC
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.5 EGC
- en: Elliptic curve cryptography (ECC) is an approach to public key cryptography
    based on the algebraic structure of elliptic curves over finite fields. ECC allows
    smaller keys compared to non-EC cryptography (based on plain Galois fields) to
    provide equivalent security. Elliptic curves are applicable for key agreement,
    digital signatures, pseudorandom generators and other tasks. Indirectly, they
    can be used for encryption by combining the key agreement with a symmetric encryption
    scheme. The EGC protocol generated high levels of data security to serve the purpose
    of protecting data during transmission in the IoT [[30](#CR30)–[32](#CR32)].
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 椭圆曲线密码学(ECC)是一种基于有限域上椭圆曲线的代数结构的公钥密码学方法。ECC允许使用比非EC密码学(基于普通的Galois域)更小的密钥来提供相同的安全性。椭圆曲线适用于密钥协商、数字签名、伪随机生成器和其他任务。间接地，它们可以通过将密钥协商与对称加密方案结合来用于加密。EGC协议为在物联网中传输数据期间保护数据的目的提供了高水平的数据安全性[[30](#CR30)–[32](#CR32)]。
- en: 2.4 Hybrid Encryption
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.4 混合加密
- en: One of the known methods to strengthen the secureness of a cryptography is by
    combining two existing cryptographies. A combination of two cryptographies is
    also called the hybrid algorithm such as combination of symmetric and public key-based
    system. Symmetric key cryptography is faster and more efficient than public key
    cryptography but lacks security when exchanging keys over unsecured channels.
    Hybrid cryptosystems combine the speed of symmetric key cryptography with the
    security of public key cryptography. A hybrid cryptosystem consists of a public
    key cryptosystem for key encapsulation and a symmetric key cryptosystem for data
    encapsulation. Hybrid cryptosystems are used by most computer users in the form
    of HTTP Secure (*HTTPS*) [[33](#CR33)].
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 加强密码学安全性的已知方法之一是将两种现有的密码学结合起来。两种密码学的组合也称为混合算法，例如对称密钥和基于公钥的系统的组合。对称密钥密码学比公钥密码学更快更高效，但在通过不安全的通道交换密钥时缺乏安全性。混合加密系统将对称密钥密码学的速度与公钥密码学的安全性结合起来。混合加密系统由用于密钥封装的公钥密码系统和用于数据封装的对称密钥密码系统组成。大多数计算机用户使用混合加密系统以HTTP安全(*HTTPS*)的形式[[33](#CR33)]。
- en: 2.5 Crypto-Analysis/Attacks
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.5 加密分析/攻击
- en: The analysis of the cryptography algorithms in general is known as cryptanalysis
    and is an essential aspect of testing the reliability of the cryptography system
    for practical. Cryptographic algorithms are provably secure against mathematical
    cryptanalysis under the black box assumption. Cryptanalysis methods are summarized
    below, and different types of attacks on different security levels are shown in
    Table [2.3](#Tab3). Attacks can be passive or active. *Passive attacks* do not
    alter or affect at any other way the information, and they do not cause any issue
    to the communication channel. The main goal here is to acquire unauthorized access
    to sensitive and confidential information and data. Passive attacks are often
    called as stealing information. What really makes this attack harmful is the fact
    that most of the times the owner is not aware that an unauthorized person has
    knowledge of the owner’s data. For instance, an attacker could intercept and eavesdrop
    a communication channel and gain knowledge to confidential information, and neither
    the sender nor the receiver could figure that out. *Active attacks* is able to
    process the information and alter it in many different ways. More specifically,
    the attacker could change specific fields of the data like the originator name
    and the timestamp and generally modifying the information in an unauthorized way.
    Moreover, unauthorized deletion of data, initiation of unintended transmission
    of information or data, and, lastly, denial of access to data by legitimate users
    the so-called denial of service (DoS) attack are also examples of active attacks
    [[34](#CR34), [35](#CR35)].Table 2.3
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 对加密算法的分析通常被称为密码分析，是测试密码系统可靠性的重要方面。根据黑盒假设，密码算法在数学密码分析方面是可证明安全的。密码分析方法总结如下，并且不同安全级别上的不同类型攻击显示在表[2.3](#Tab3)中。攻击可以是被动的或主动的。*被动攻击*不会改变或以任何其他方式影响信息，并且不会对通信通道造成任何问题。这里的主要目标是未经授权地获取敏感和机密信息和数据的访问权限。被动攻击通常被称为信息窃取。这种攻击真正危险的地方在于，大多数情况下，所有者并不知道未经授权的人已经了解了所有者的数据。例如，攻击者可能会截获和窃听通信通道，并获取机密信息的知识，而发送者和接收者都无法发现这一点。*主动攻击*能够处理信息并以多种不同的方式更改它。更具体地说，攻击者可以更改数据的特定字段，如发起者名称和时间戳，并通常以未经授权的方式修改信息。此外，未经授权删除数据、意外传输信息或数据的启动以及最后，拒绝合法用户访问数据，即所谓的拒绝服务（DoS）攻击也是主动攻击的示例[[34](#CR34)，[35](#CR35)]。表2.3
- en: Different types of attacks on different security levels
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 不同安全级别上的不同类型攻击
- en: '| Security abstraction level | Security objective | Side channel attack |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| 安全抽象级别 | 安全目标 | 侧信道攻击 |'
- en: '| --- | --- | --- |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Protocol | Authenticated communications | Man-in-the-middle,Traffic analysis
    |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| 协议 | 鉴别通信 | 中间人，流量分析 |'
- en: '| Algorithm | Encryption/hashing | Known plaintext,Known cryptext |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| 算法 | 加密/散列 | 已知明文，已知密文 |'
- en: '| Architecture | Functional integration (SW) | Stack smashing |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| 架构 | 功能集成（软件） | 堆栈破坏'
- en: '| Micro-architecture | Architecture integration (HW) | Bus probing |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| 微体系结构 | 架构集成（硬件） | 总线探测 |'
- en: '| Circuit | Implementation | Differential power analysis |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| 电路 | 实施 | 差分功率分析 |'
- en: 2.5.1 Exhaustive/Brute Force Attack
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.1 穷举/暴力攻击
- en: The secret *key’s space* should be long. Crypto-analysis time versus key size
    is shown in Table [2.4](#Tab4). The security of an encryption algorithm ought
    to have vast key space more sensitive to the secret key to tackling a different
    kind of attacks such as statistical attacks, differential attack, known plain
    text attacks, and exhaustive attacks. The large size of the key space also makes
    brute force attacks infeasible. Moreover, the **sensitivity of algorithms**  toward
    the secret key during encryption and decryption is the key point of the robustness
    of an encryption algorithm. The higher the sensitivity, the more secure is the
    information because only a slight change in the key will lead toward an entirely
    different cipher image. That means no one can recover the original image except
    having the correct secret key [[36](#CR36)–[38](#CR38)].Table 2.4
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 密钥空间应足够长。表 [2.4](#Tab4) 显示了密码分析时间与密钥大小之间的关系。加密算法的安全性应具有更大的密钥空间，以更有效地抵御各种攻击，如统计攻击、差分攻击、已知明文攻击和穷举攻击。密钥空间的大尺寸也使得暴力攻击变得不可行。此外，加密算法对于密钥的敏感性在加密和解密过程中是其健壮性的关键点。密钥的敏感性越高，信息就越安全，因为密钥的轻微变化将导致完全不同的密文图像。这意味着除非拥有正确的密钥，否则无法恢复原始图像
    [[36](#CR36)–[38](#CR38)]。表 2.4
- en: Crypto-analysis time versus key size
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 密码分析时间与密钥大小
- en: '| Key size | Possible no. of keys | Time to crack |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| 密钥大小 | 可能的密钥数量 | 破解时间 |'
- en: '| --- | --- | --- |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| (1 encryption/μs) | (10⁶ encryptions/ μs) |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| (每微秒1次加密) | (每微秒10⁶次加密) |'
- en: '| --- | --- |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 32 | 10⁹ | 36 min | 2\. msec |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| 32 | 10⁹ | 36 分钟 | 2\. 毫秒 |'
- en: '| 56 | 10^(16) | 1100 years | 10 hrs |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| 56 | 10^(16) | 1100 年 | 10 小时 |'
- en: '| 128 | 10^(38) | 5 × 10^(24) years | 5 × 10^(18) years |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| 128 | 10^(38) | 5 × 10^(24) 年 | 5 × 10^(18) 年 |'
- en: '| 26 characters | 10^(26) | 6 × 10^(12) years | 6 × 10⁶ years |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| 26个字符 | 10^(26) | 6 × 10^(12) 年 | 6 × 10⁶ 年 |'
- en: 2.5.2 Statistical/Histogram Attack
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.2 统计/直方图攻击
- en: The histogram is a common approach to get the distribution of an image pixel
    values. Histogram of data should be uniform after encryption. This leads to statistical
    attacks invalid. In information theory, entropy is the most significant feature
    of the disorder. We can say numerical property reflecting the randomness associated
    unpredictability of an information source called entropy. The ideal *entropy*
    value for a random image with a gray level of 2⁸ is 8\. Which means the closer
    the entropy value is, the more is the haphazardness of an image, conclusively
    less information disclosed by the encryption scheme.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 直方图是获取图像像素值分布的常用方法。加密后，数据的直方图应该是均匀的。这导致统计攻击失效。在信息理论中，熵是混乱的最重要特征。我们可以说反映信息源不可预测的随机性的数值特性称为熵。灰度为2⁸的随机图像的理想*熵*值为8。这意味着熵值越接近，图像的无序性就越大，最终加密方案披露的信息就越少。
- en: 2.5.3 Differential Attack
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.3 差分攻击
- en: Attackers often make a slight change to the original data and use the proposed
    algorithm to encrypt for the original data before and after changing, through
    comparing two encrypted image to find out the relationship between the original
    data and the encrypted data.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者经常对原始数据进行轻微更改，并使用提出的算法加密原始数据之前和之后的数据，通过比较两个加密图像找出原始数据和加密数据之间的关系。
- en: 2.5.4 Known/Chosen Plaintext/Ciphertext Attack
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.4 已知/选择明文/密文攻击
- en: 2.5.4.1 Known Ciphertext Attacks (KCA)
  id: totrans-196
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.5.4.1 已知密文攻击（KCA）
- en: Here the attacker possesses multiple ciphertexts, but without the corresponding
    plaintexts. This attack becomes effective when the corresponding plaintext can
    be extracted from one or more ciphertexts. Additionally, sometimes the encryption
    key can be discovered by this attack. In practice, however, the adversary performing
    this attack has also some knowledge about the plaintext. This information could
    be the language that the plaintext is written or the foreseeable statistical distribution
    of the characters in it.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种攻击中，攻击者拥有多个密文，但没有相应的明文。当可以从一个或多个密文中提取相应的明文时，这种攻击变得有效。此外，有时也可以通过此攻击发现加密密钥。然而，在实践中，执行此攻击的对手也对明文有一定的了解。这些信息可能是明文所写的语言或其中字符的可预见的统计分布。
- en: 2.5.4.2 Chosen Plaintext Attack (CPA)
  id: totrans-198
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.5.4.2 选择明文攻击（CPA）
- en: The adversary here has free access to the encryption process and can create
    any ciphertext from any plaintext of his choice. So basically, the attacker can
    have any desirable pair of plaintext–ciphertext. This makes the process of finding
    the encryption key easier, as the attacker can gain more knowledge of the encryption
    operation, the more pairs of messages, and ciphertexts created.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，对手可以自由访问加密过程，并且可以从他选择的任何明文创建任何密文。因此，基本上，攻击者可以拥有任何理想的明文-密文对。这使得查找加密密钥的过程更容易，因为攻击者可以通过创建更多的消息和密文对来获得有关加密操作的更多知识。
- en: 2.5.4.3 Known Plaintext Attack (KPA)
  id: totrans-200
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.5.4.3 已知明文攻击（KPA）
- en: This attack is quite similar to the previous one. Here the attacker knows the
    plaintext that the sender has sent and the corresponding ciphertext. The goal
    of the adversary is to gain information by taking advantage of the ciphertext–plaintext
    pairs they have. This could result to the discovery of the encryption key or other
    information for the algorithm as well. The difference with the chosen plaintext
    attack is that the plaintext is not chosen by the attacker but the sender of the
    message.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: 2.5.4.4 Chosen Ciphertext Attack (CCA)
  id: totrans-202
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this type of attack, the adversary or the cryptanalyst has the ability to
    analyze any chosen ciphertexts along with the corresponding plaintexts. The goal
    is to gain the secret key or as much information as possible for the attacked
    cryptographic system. This attack holds with the assumption that the attacker
    can make the victim decrypt any encrypted message and send it to him. The more
    decrypted ciphertexts the attack owns, the more information is gained for the
    system, and thus it is more likely to break it.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 2.5.4.5 Side Channel Attack
  id: totrans-204
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The system is attacked via the channel leaked information such as *time consumption,
    power consumption, or electromagnetic radiation*. Timing attack is one type of
    side channel attack. The attacker can access the equipment or physically damage
    them by performing, for instance, Differential Power Analysis (DPA) attack. In
    Differential Power Analysis, the attacker send lots of plaintext (bits) to the
    FPGA, which will decrypt them accordingly, and meanwhile the attacker will be
    measuring the power traces, trying to get the cryptography algorithm key (using
    statistical techniques and knowledge of the CMOS power model). There are many
    countermeasures against this attack, including changing the time of the key transmission
    or encryption to confuse the adversary and filtering the power line conditioning
    to prevent power-monitoring acts.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '*Deep learning* technique can be used in side channel analysis context. Like
    other machine learning techniques, a deep learning technique builds a profiling
    model for each possible value of the targeted sensitive variable during the training
    phase, and, during the attack phase, these models are involved to output the most
    likely key used during the acquisition of the attack traces. In side channel attack
    context, an adversary is rather interested in the computation of the probability
    of each possible value deduced from a key hypothesis. Therefore, to recover the
    good key, the adversary computes the maximum or the log maximum likelihood approach
    like for template attack [[39](#CR39)–[41](#CR41)].'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '*深度学习*技术可以在侧信道分析的情境中使用。与其他机器学习技术类似，深度学习技术在训练阶段为目标敏感变量的每个可能值构建一个概要模型，在攻击阶段，这些模型被用来输出在攻击轨迹获取期间最有可能使用的密钥。在侧信道攻击情境中，对手更感兴趣的是从密钥假设中推导出的每个可能值的概率计算。因此，为了恢复正确的密钥，对手计算最大或对数最大似然方法，就像模板攻击[[39](#CR39)–[41](#CR41)]一样。'
- en: 2.5.4.6 Man-in-the-Middle Attack
  id: totrans-207
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.5.4.6 中间人攻击
- en: This attack depends on standing between the two communicating parties to get
    the message from the sender, change, and add to it and then send it forward to
    the receiver. This needs that the attacker knows the encryption keys to be able
    to encrypt the added parts to the message. One-time pad keys and changing the
    block lengths make the attacker not able to succeed to play the man-in-the middle
    role.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 此攻击依赖于站在两个通信方之间，以获取发送方的消息，对其进行更改和添加，然后将其转发给接收方。这需要攻击者知道加密密钥，才能加密消息的附加部分。一次性密码键和改变块长度使攻击者无法成功扮演中间人角色。
- en: 2.6 Comparison Between Different Encryption Algorithms
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.6 不同加密算法的比较
- en: Stream ciphers are generally faster than block ciphers, due to the fact that
    in the second category, each block needs to be processed, one by one in order
    to be encrypted, which is not the case in stream ciphers where only one bit or
    byte is processed at a time. As a result, block ciphers require more memory allocation,
    since they have to work on bigger chunks of data, and, sometimes, they have to
    continue the operation from previous blocks as well. On the contrary, stream ciphers
    process at most a byte at a time, so they have relatively low memory requirements,
    and as a result they are cheaper to implement in constrained devices like embedded
    systems and IoT devices and more general in lightweight cryptographic algorithms.
    Nevertheless, stream ciphers are more difficult to develop and design effectively,
    and they are vulnerable depending on the usage. Stream ciphers do not offer integrity
    protection and authentication, whereas some block ciphers depending on the mode
    they use are able to provide integrity together with confidentiality. Additionally,
    because of the fact that block ciphers encrypt a whole block at a time and most
    of them have feedback modes, they are prone to adding noise in the transmission
    that could alter the data, so the rest of the transmission will not be the appropriate
    for the algorithm. Stream ciphers do not face such problem as the bits or bytes
    are encrypted separately from the other data, and most of the times there are
    solutions in case of connection issues. A comparative evaluation of different
    encryption algorithms is shown in Tables [2.5](#Tab5) and [2.6](#Tab6). DES algorithm
    has the lower encryption and decryption speed. AES algorithm has the least memory
    utilization. RSA has a very high memory utilization [[42](#CR42), [43](#CR43)].
    Due to its low power consumption, DES is designed to work better in hardware than
    in software program. 3DES requires higher time than DES and consumes more power
    consumption and has less throughputs. The 3DES algorithm is the best for data
    protection because it uses three keys to encrypt and decrypt data [[44](#CR44)].Table
    2.5
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Comparison between different encryption algorithms
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '| Algorithm | Encryption and decryption speed | Scalability | Vulnerabilities
    | Security |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
- en: '| RSA | High | Not scalable | Brute force attack | High |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
- en: '| DES | Low | Scalable | Brute force attack | Medium |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
- en: '| AES | Low | Not scalable | Cryptanalysis attack | High |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
- en: '| 3DES | Low | Not scalable | Man-in-the-middle-attack | High |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
- en: '| BLOWFISH | Low | Scalable | Brute force attack | Low |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
- en: '| ECC | Low | Scalable | Brute force attack | Medium |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
- en: Table 2.6
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Comparison between AES, DES, and RSA
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '| Factors | AES | DES | RSA |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
- en: '| Development year | 2000 | 1977 | 1978 |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
- en: '| Key length (bits) | 128,192,256 | 56 | 1024 |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
- en: '| Key type | Symmetric | Symmetric | Asymmetric |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
- en: '| Block size (bits) | 128 | 64 | 512 |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
- en: '| Execution time | Fast | Moderate | Slow |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
- en: '| Rounds | 10,12,14 | 16 | 1 |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
- en: 2.7 Cryptography Applications
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The need for strong cryptographic algorithms is very high, and the design of
    them is challenging, especially by taking into consideration that the processing
    power of computers increases day by day and malicious parties tend to find new
    vulnerabilities and breaches in security systems all the time. Nowadays, cryptography
    is excessively used in many types of applications.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 2.7.1 Secured Email
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Alice wants to send confidential email “m” to Bob (Fig. [2.12](#Fig12)).![../images/501530_1_En_2_Chapter/501530_1_En_2_Fig12_HTML.png](../images/501530_1_En_2_Chapter/501530_1_En_2_Fig12_HTML.png)
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 2.12
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Sending a secured email
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: 'Alice:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Generates random symmetric private key, *K*[*S*]
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encrypts message with *K*[*S*]
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encrypts *K*[*S*] with Bob’s public key
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sends both *K*[*S*](*m*) and *K*[*B*](*K*[*S*]) to Bob
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Bob:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Uses his private key to decrypt and recover *K*[*S*]
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uses *K*[*S*] to decrypt *K*[*S*](*m*) to recover *m*
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2.7.2 Secured Chat
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The chat client will use an encryption algorithm to provide end-to-end encrypted
    communications with other clients. There are many popular session setup protocol
    that powers real-world chat systems such as Signal and WhatsApp.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: 2.7.3 Secured Wireless Communication System
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A high-level wireless communication system is shown in Fig. [2.13](#Fig13),
    where encryption plays a vital role. The *Bluetooth* encryption system uses the
    stream cipher E0 to encrypt the payloads of the packets which is re-synchronized
    for every payload. The E0 stream cipher consists of the payload key generator,
    the key stream generator, and the encryption/decryption part. The input bits are
    combined by the payload key generator and are shifted to the four linear feedback
    shift registers (LSFR) of the key stream generator. The key stream bits are then
    generated which are used for encryption. The Exclusive-OR operation is then performed
    on the key stream bits and data stream bits to generate the ciphertext. Similarly
    the Exclusive-OR operation is performed on the ciphertext to get back the plaintext
    during the decryption process.![../images/501530_1_En_2_Chapter/501530_1_En_2_Fig13_HTML.png](../images/501530_1_En_2_Chapter/501530_1_En_2_Fig13_HTML.png)
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 2.13
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: High-Level wireless communication system
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '*WLAN* encryption methods includes:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 'Wired Equivalent Privacy (*WEP*): Wired Equivalent Privacy (WEP) is a security
    algorithm for IEEE 802.11 wireless networks. Standard 64 bit WEP uses a 40 bit
    key (also known as WEP-40), which is concatenated with a 24 bit initialization
    vector (IV) to form the RC4 key. At the time that the original WEP standard was
    drafted, the US Government’s export restrictions on cryptographic technology limited
    the key size. Once the restrictions were lifted, manufacturers of access points
    implemented an extended 128 bit WEP protocol using a 104 bit key size (WEP-104).'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Wi-Fi Protected Access (*WPA*): Wi-Fi Protected Access (WPA) was the Wi-Fi
    Alliance’s direct response and replacement to the increasingly apparent vulnerabilities
    of the WEP standard. WPA was formally adopted in 2003, a year before WEP was officially
    retired. The most common WPA configuration is WPA-PSK (pre-shared key). The keys
    used by WPA are 256 bit, a significant increase over the 64 bit, and 128 bit keys
    used in the WEP system [[45](#CR45)].'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Wi-Fi Protected Access（*WPA*）：Wi-Fi Protected Access（WPA）是Wi-Fi联盟对WEP标准日益明显的漏洞做出的直接回应和替代。WPA于2003年正式采纳，比WEP正式退役提前一年。最常见的WPA配置是WPA-PSK（预共享密钥）。WPA使用的密钥为256位，比WEP系统中使用的64位和128位密钥显著增加。
- en: 'Wi-Fi Protected Access 2 (*WPA2*): WPA has, as of 2006, been officially superseded
    by WPA2. One of the most significant changes between WPA and WPA2 is the mandatory
    use of AES algorithms and the introduction of CCMP (Counter Mode Cipher Block
    Chaining Message Authentication Code Protocol) as a replacement for TKIP. However,
    TKIP is still preserved in WPA2 as a fallback system and for interoperability
    with WPA.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Wi-Fi Protected Access 2（*WPA2*）：截至2006年，WPA已被WPA2正式取代。WPA和WPA2之间最重要的变化之一是强制使用AES算法，以及引入CCMP（计数器模式密码块链接消息认证码协议）作为TKIP的替代。然而，TKIP仍然在WPA2中保留为后备系统，并用于与WPA的互操作性。
- en: '*5G* uses 256 bit encryption, a substantial improvement on the 128 bit standard
    used by 4G. With 5G, the user’s identity and location are encrypted, making them
    impossible to identify or locate from the moment they get on the network [[46](#CR46)].
    In older 2G cellular systems, the cryptographic algorithms used to secure the
    air interface and perform subscriber authentication functions were not publicly
    disclosed. The GSM algorithm families pertinent to our discussion are A3, A5,
    and A8\. A3 provides subscriber authentication, A5 provides air interface confidentiality,
    and A8 is related to A3, in that it provides subscriber authentication functions
    but within the SIM card. UMTS introduced the first publicly disclosed cryptographic
    algorithms used in commercial cellular systems. The terms UEA (UMTS Encryption
    Algorithm) and UIA (UMTS Integrity Algorithm) are used within UMTS as broad categories.
    UEA1 is a 128 bit block cipher called KASUMI, which is related to the Japanese
    cipher MISTY. UIA1 is a message authentication code (MAC), also based on KASUMI.
    UEA2 is a stream cipher related to SNOW 3G, and UIA2 computes a MAC based on the
    same algorithm. LTE builds upon the lessons learned from deploying the 2G and
    3G cryptographic algorithms. LTE introduced a new set of cryptographic algorithms
    and a significantly different key structure than that of GSM and UMTS. There are
    three sets of cryptographic algorithms for both confidentiality and integrity
    termed EPS Encryption Algorithms (EEA) and EPS Integrity Algorithms (EIA). EEA1
    and EIA1 are based on SNOW 3G, very similar to algorithms used in UMTS. EEA2 and
    EIA2 are based on the Advanced Encryption Standard (AES) with EEA2 defined by
    AES in CTR mode (e.g., stream cipher) and EIA2 defined by AES-CMAC (cipher-based
    MAC). EEA3 and EIA3 are both based on a Chinese cipher ZUC. While these new algorithms
    have been introduced in LTE, network implementations commonly include older algorithms
    for backward compatibility for legacy devices and cellular deployments [[47](#CR47)].'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: 2.7.4 Secured Mobile/Smartphone
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Smartphone users are exposed to different threats. These threats may disturb
    operation and transfer user data from smartphones. There are a number of ways
    in which the type of attacks in mobiles can be segregated. Some of them are explained
    as follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '*Wi-Fi-based attacks*'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An attacker can intercept a Wi-Fi communication by doing eavesdropping. The
    security in WLAN is more vulnerable. It is possible for an attacker to break the
    password easily get in the local network of the victim. In an event where an attacker
    prospers in breaking identification cipher, it becomes possible to attack both
    the phone and the entire network.
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Web browser-based attack*'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In web browser-based attacks, an attacker uses leverages like stack-based overflow
    and other vulnerabilities in libraries. This is possible in all kinds of operating
    system either Android or iOS. Smartphones are also vulnerable to phishing and
    other malicious web site-based attacks, and the biggest problem with smartphones
    is that they don’t have strong antivirus protection yet.
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Operating system-based attacks*'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One may apply any number of secure mechanisms, but if there is vulnerability
    in operating system, it might be going to affect one day surely. There are several
    loopholes in operating systems of smartphones as these are in earlier stages and
    developers are not much aware about the kind of attacks possible. It was likely
    to dodge the security of operating system and circumvent the bytecode verifier
    and gain access of core operating system. Similarly in windows mobile OS, one
    can easily edit the general configuration file to a modifiable file. It is also
    possible for a malicious attacker to do modifications in the directory whenever
    an application is installed as at that time it has root privileges.
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 2.8 Conclusions
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter discusses the fundamentals of private and public key cryptography.
    Moreover, it explains the details of the main building blocks of these cryptographic
    systems. Besides, this chapter explores the different crypto-analysis techniques.
    It addresses stream ciphers, the Data Encryption Standard (DES) and 3DES, the
    Advanced Encryption Standard (AES), block ciphers, the RSA cryptosystem, and public
    key cryptosystems based on the discrete logarithm problem, elliptic curve cryptography
    (ECC), key exchange algorithms, and so many other algorithms. Moreover, this chapter
    provides a comparison between different encryption algorithms in terms of speed
    encryption, decoding, complexity, the length of the key, structure, and flexibility.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
