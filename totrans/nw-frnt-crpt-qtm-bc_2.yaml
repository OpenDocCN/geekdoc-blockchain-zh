- en: © The Editor(s) (if applicable) and The Author(s), under exclusive license to
    Springer Nature Switzerland AG 2020K. S. MohamedNew Frontiers in Cryptography[https://doi.org/10.1007/978-3-030-58996-7_2](https://doi.org/10.1007/978-3-030-58996-7_2)
  prefs: []
  type: TYPE_NORMAL
- en: '2. Cryptography Concepts: Confidentiality'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Khaled Salah Mohamed^([1](#Aff2) )(1)A Siemens Business, Fremont, CA, USAKeywordsEncryptionSymmetricAsymmetricRSAAESDESCipherECCKey-exchangeCryptanalysis
  prefs: []
  type: TYPE_NORMAL
- en: 2.1 Cryptography History
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The term cryptography is derived from the Greek word Kryptos. Kryptos is used
    to describe anything that is hidden, veiled, secret, or mysterious. Cryptography
    is the study of mathematical techniques for the secure transmission of a private
    message over an insecure channel. Cryptography is the basic technique to secure
    our data from different kind of attackers like: interruption, modification, fabrication,
    etc. It has been around for 2000+ years. They were shaving the slave’s head, tattooed
    the message on it, and let the hair grow [[1](#CR1)]. The first documented use
    of cryptography in writing dates back to circa 1900 B.C. when an Egyptian scribe
    used nonstandard hieroglyphs in an inscription. Some experts argue that cryptography
    appeared spontaneously sometime after writing was invented, with applications
    ranging from diplomatic missives to war-time battle plans. Caesar’s cipher: shifting
    each letter of the alphabet by a fixed amount. It is easy to break. Vigenere’s
    polyalphabetic cipher generalizes Caesar’s shift cipher. It uses keyword to select
    encrypting rows. *Substitution cipher*: permutations of 26 letters, using the
    dictionary. It is easy to break. Then in modern era, we have many cryptography
    algorithms as we will explain in the rest of this chapter. Modern cryptography
    algorithms are based over the fundamental process of factoring large integers
    into their primes, which is said to be intractable [[2](#CR2), [3](#CR3)]. In
    both *symmetric* and *asymmetric* cryptosystems, encryption is the process of
    changing the original form of text to unreadable form and decryption process gets
    the original form of data from the meaningless text. For block cipher, use of
    plaintext and ciphertext of equal size avoids data expansion. In this chapter,
    confidentiality will be addressed. Encryption is the major tool to achieve confidentiality
    [[4](#CR4)–[6](#CR6)].'
  prefs: []
  type: TYPE_NORMAL
- en: 2.2 Symmetric Encryption
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Figure [2.1](#Fig1) shows a summary for different symmetric encryption algorithms.
    Symmetric means sender and receiver have a shared secret key. There are two primitive
    operations with which strong encryption algorithms can be built: *confusion* and
    *diffusion.* In confusion, an encryption operation where the relationship between
    key and ciphertext is obscured, and a common element for achieving confusion is
    substitution. In diffusion, an encryption operation where the influence of one
    plaintext symbol is spread over many ciphertext symbols with the goal of hiding
    statistical properties of the plaintext and a common element for achieving diffusion
    is through permutations (i.e., transposition). Avalanche effect is considered
    as one of the desirable property of any encryption algorithm. A slight change
    in either the key or the plaintext should result in a significant change in the
    ciphertext.![../images/501530_1_En_2_Chapter/501530_1_En_2_Fig1_HTML.png](../images/501530_1_En_2_Chapter/501530_1_En_2_Fig1_HTML.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 2.1
  prefs: []
  type: TYPE_NORMAL
- en: Symmetric cryptographic algorithm. Symmetric means sender and receiver have
    a shared secret key
  prefs: []
  type: TYPE_NORMAL
- en: '2.2.1 Historical Algorithms: Letter-Based Algorithms'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 2.2.1.1 Caesar Cipher
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This is one of the oldest and earliest examples of cryptography, invented by
    Julius Caesar, the emperor of Rome, during the Gallic Wars. In this type of algorithm,
    the letters A through W are encrypted by being represented with the letters that
    come three places ahead of each letter in the alphabet, while the remaining letters
    A, B, and C are represented by X, Y, and Z. This means that a “shift” of 3 is
    used, although by using any of the numbers between 1 and 25, we could obtain a
    similar effect on the encrypted text. Therefore, nowadays, a shift is often regarded
    as a Caesar Cipher (Fig. [2.2](#Fig2)) [[7](#CR7)]. A Python code for Caesar cipher
    is shown in Fig. [2.3](#Fig3).![../images/501530_1_En_2_Chapter/501530_1_En_2_Fig2_HTML.png](../images/501530_1_En_2_Chapter/501530_1_En_2_Fig2_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 2.2
  prefs: []
  type: TYPE_NORMAL
- en: Caesar cipher
  prefs: []
  type: TYPE_NORMAL
- en: '*Encryption: C = P + K mod 26 (1)*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Decryption: P = C − K mod 26 (2)*'
  prefs: []
  type: TYPE_NORMAL
- en: '![../images/501530_1_En_2_Chapter/501530_1_En_2_Fig3_HTML.png](../images/501530_1_En_2_Chapter/501530_1_En_2_Fig3_HTML.png)'
  prefs: []
  type: TYPE_IMG
- en: Fig. 2.3
  prefs: []
  type: TYPE_NORMAL
- en: 'Python code for Caesar cipher example: shift by 1 letter'
  prefs: []
  type: TYPE_NORMAL
- en: 2.2.1.2 Substitution Ciphers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In a substitution cipher, we take the alphabet letters and place them in random
    order under the alphabet written correctly. In the encryption and decryption,
    the same key is used. The rule of encryption here is that “each letter gets replaced
    by the letter beneath it,” and the rule of decryption would be the opposite [[8](#CR8)].
    The substitution cipher did not shift the data by a fixed number. Instead, it
    shifts it by a random one. A Python example for substitution cipher is shown in
    Fig. [2.4](#Fig4).![../images/501530_1_En_2_Chapter/501530_1_En_2_Fig4_HTML.png](../images/501530_1_En_2_Chapter/501530_1_En_2_Fig4_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 2.4
  prefs: []
  type: TYPE_NORMAL
- en: Python code for substitution cipher example
  prefs: []
  type: TYPE_NORMAL
- en: 2.2.1.3 Transposition/Polyalphabetic Ciphers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Instead of substituting letters, rearrange them. Transposition can be defined
    as the alteration of the letters in the plaintext through rules and a specific
    key. A columnar transposition cipher can be considered as one of the simplest
    types of transposition cipher and has two forms: the first is called “complete
    columnar transposition,” while the second is “incomplete columnar.” Regardless
    of which form is used, a rectangle shape is utilized to represent the written
    plaintext horizontally, and its width should correspond to the length of the key
    being used. There can be as many rows as necessary to write the message. When
    complete columnar transposition is used, the plaintext is written, and all empty
    columns are filled with null so that each column has the same length [[9](#CR9)].
    The key cannot have a repetitive letters. Python code for transposition cipher
    example is shown in Fig. [2.5](#Fig5). The algorithm can be summarized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The message is written out in rows of a fixed length and then read out again
    column by column, and the columns are chosen in some scrambled order according
    to the key.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Width of the rows and the permutation of the columns are usually defined by
    a keyword.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '3.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For example, the key “KHALED” is of length 6, and the permutation is defined
    by the alphabetical order of the letters in the keyword. In this case, the order
    would be “3 6 5 2 1 4.”
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '4.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Any spare spaces are filled with nulls or left blank.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '5.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, the message is read off in columns, in the order specified by the keyword.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '6.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To decipher it, the recipient has to work out the column lengths by dividing
    the message length by the key length.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '7.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, write the message out in columns again, then re-order the columns by reforming
    the key word.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![../images/501530_1_En_2_Chapter/501530_1_En_2_Fig5_HTML.png](../images/501530_1_En_2_Chapter/501530_1_En_2_Fig5_HTML.png)'
  prefs: []
  type: TYPE_IMG
- en: Fig. 2.5
  prefs: []
  type: TYPE_NORMAL
- en: Python code for transposition cipher example
  prefs: []
  type: TYPE_NORMAL
- en: 2.2.1.4 One-Time Pad Cipher
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The cryptographic algorithms that already exist have the common strategy to
    have a large key space and a complicated algorithm. For symmetric cryptography,
    the use of one time pad is the simplest solution to the key distribution problem.
    However, with increasing advancement in technology, it is getting easier to break
    the algorithms that are widely in use. The increasing length of OTPs is also a
    cause of concern. Polyalphabetic cipher continued for almost 400 years. In 1882,
    Frank Miller invented cipher called as one-time pad. In one-time pad, a key was
    selected whose length was same as that of the plaintext message. The shifts in
    the plaintext never followed a repetitive pattern, and the encrypted message had
    uniform frequency distribution, thereby providing no leakage of the information.
    One-time pad (OTP) cipher is unbreakable due to the following [[10](#CR10)]:'
  prefs: []
  type: TYPE_NORMAL
- en: The key is as long as the given message.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The key is truly random and especially auto-generated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Key and plain text calculated as modulo 10/26/2.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each key should *be used once* and destroyed by both sender and receiver.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There should be two copies of key: one with the sender and other with the receiver.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The problem with the one-time pad is that, in order to create such a cipher,
    its key should be as long as or even longer than the plaintext. In other words,
    if you have 500 megabyte video file that you would like to encrypt, you would
    need a key that’s at least 4 gigabits long.
  prefs: []
  type: TYPE_NORMAL
- en: '2.2.2 Modern Algorithms: Bits-Based Algorithms'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 2.2.2.1 Stream Ciphers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Stream ciphers operate on pseudorandom bits generated from the key, and the
    plaintext is encrypted by XORing both the plaintext and the pseudorandom bits.
    Stream ciphers use conceptual tools similar to block ciphers. Substitution is
    the primary tool: each bit or byte of plaintext is combined with the key material
    by an Exclusive-OR (XOR) operation to substitute the plaintext bit into the ciphertext
    bit. Binary XOR is quite simple. There are only two possible values, 1 and 0,
    and if the two inputs are the same, the result is 0; otherwise it is 1 [[11](#CR11)].
    Stream cipher’s security depends entirely on the “suitable” key stream, while
    randomness plays a main role, so the random number generator (RNG) is significant
    for that purpose. *Neural* cryptography is a new source for public key cryptography
    schemes which are not based on number theory and have less computation time and
    memory complexities. Neural cryptography can be used to generate a common secret
    key between two parties [[12](#CR12)].'
  prefs: []
  type: TYPE_NORMAL
- en: E0 Cipher
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: E0 is a stream cipher used in the Bluetooth protocol. It generates a sequence
    of pseudorandom numbers and combines it with the data using the XOR operator.
    The key length may vary but is generally 128 bits. At each iteration, E0 generates
    a bit using four shift registers of differing lengths (25, 31, 33, 39 bits) and
    two internal states, each 2 bits long. At each clock tick, the registers are shifted,
    and the two states are updated with the current state, the previous state and
    the values in the shift registers. Four bits are then extracted from the shift
    registers and added together. The algorithm XORs that sum with the value in the
    2 bit register. The first bit of the result is output for the encoding [[13](#CR13)].
  prefs: []
  type: TYPE_NORMAL
- en: 2.2.2.2 Block Ciphers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In a block cipher, two values are generally referred to: the size of the block
    and the size of the key. The security relies on the value of both. Many block
    ciphers use a 64 bit block or a 128 bit block. As it is crucial that the blocks
    are not too large, the memory footprint and the ciphertext length are small in
    size. Regarding the ciphertext length, blocks instead of bits are processed in
    a block cipher. Block ciphers can be symmetric or nonsymmetric as will be discussed
    later in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: We start with *plaintext*. Something you can read. We apply a mathematical algorithm
    to the plaintext.
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm is the *cipher*. The plaintext is turned in to *ciphertext*. In
    symmetric encryption, same key is used to encrypt and decrypt the data. The shared
    key K between sender and receiver should be kept secret. The encryption/decryption
    process can be modeled by eq. ([2.1](#Equ1)) and can be seen in Fig. [2.6](#Fig6):![$$
    P={D}_K\left({E}_k(P)\right) $$](../images/501530_1_En_2_Chapter/501530_1_En_2_Chapter_TeX_Equ1.png)(2.1)![../images/501530_1_En_2_Chapter/501530_1_En_2_Fig6_HTML.png](../images/501530_1_En_2_Chapter/501530_1_En_2_Fig6_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 2.6
  prefs: []
  type: TYPE_NORMAL
- en: Symmetric key encryption
  prefs: []
  type: TYPE_NORMAL
- en: Symmetric encryption is fast to encrypt and decrypt, suitable for large volumes
    of data. Comparative analysis of symmetric encryption algorithm is shown in Table
    [2.1](#Tab1).Table 2.1
  prefs: []
  type: TYPE_NORMAL
- en: Comparative analysis of symmetric encryption algorithm [[14](#CR14), [15](#CR15)]
  prefs: []
  type: TYPE_NORMAL
- en: '| Algorithms/parameters | DES | 3DES | AES | Blowfish |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Published | 1977 | 1998 | 2001 | 1993 |'
  prefs: []
  type: TYPE_TB
- en: '| Developed by | IBM | IBM | Vincent Rijmen, Joan Daeman | Bruce Schneier |'
  prefs: []
  type: TYPE_TB
- en: '| Algorithm structure | Feistel | Feistel | Substitution-Permutation | Feistel
    |'
  prefs: []
  type: TYPE_TB
- en: '| Block cipher | Binary | Binary | Binary | Binary |'
  prefs: []
  type: TYPE_TB
- en: '| Key length | 56 bits | 112 bits, 168 bits | 128 bits, 192 bits and 256 |
    32–448 bits |'
  prefs: []
  type: TYPE_TB
- en: '| Flexibility or modification | No | Yes, extended from 56 to 168 bits | Yes,
    256 key size is multiple of 64 | Yes, 64–448 key size in multiple of 32 |'
  prefs: []
  type: TYPE_TB
- en: '| Number of rounds | 16 | 48 | 10, 12, 14 | 16 |'
  prefs: []
  type: TYPE_TB
- en: '| Block size | 64 bits | 64 bits | 128 bits | 64 bits |'
  prefs: []
  type: TYPE_TB
- en: '| Throughput | Lower than AES | Lower than DES | Lower than Blowfish | High
    |'
  prefs: []
  type: TYPE_TB
- en: '| Level of security | Adequate security | Adequate security | Excellent security
    | Excellent security |'
  prefs: []
  type: TYPE_TB
- en: '| Encryption speed | slow | Very slow | Fast | Fast |'
  prefs: []
  type: TYPE_TB
- en: '| Effectiveness | Slow in both software and hardware | Slow in software | Effective
    in both software and hardware | Efficient in software |'
  prefs: []
  type: TYPE_TB
- en: '| Attacks | Brute force attack | Brute force attack, known plaintext, chosen
    plaintext | Side channel attack | Dictionary attack |'
  prefs: []
  type: TYPE_TB
- en: Rijndael Algorithm
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Rijndael is a symmetric key encryption algorithm that’s constructed as a block
    cipher. It supports key sizes of 128, 192, and 256 bits, with data handling taking
    place in 128 bit blocks. In addition, the block sizes can mirror those of their
    respective keys. This last specification puts Rijndael over the limits required
    for AES design conditions, and the Advanced Encryption Standard itself is looked
    upon as a subset of the Rijndael algorithm [[16](#CR16)].
  prefs: []
  type: TYPE_NORMAL
- en: SAFER Algorithm
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In cryptography, SAFER (Secure And Fast Encryption Routine) is the name of
    a family of block ciphers designed primarily by James Massey (one of the designers
    of IDEA) on behalf of Cylink Corporation. The first SAFER cipher was SAFER K-64,
    published by Massey in 1993, with a 64 bit block size. The “K-64” denotes a key
    size of 64 bits. There was some demand for a version with a larger 128 bit key.
    This algorithm is of interest for several reasons. It is designed for use in software.
    Unlike DES, or even IDEA, it does not divide the block into parts of which some
    parts affect others; instead, the plaintext is directly changed by going through
    S-boxes, which are replaced by their inverses for decryption. SAFER uses eight
    rounds. The first step for a round is to apply the first subkey for the round
    to the 8 bytes of the block. The operation by which each byte of the subkey is
    applied to each byte of the block depends on which byte is used: the sequence
    is XOR, add, add, XOR, XOR, add, add, XOR. Then, the S-box is used. Those bytes
    to which the subkey was applied by an XOR go through the regular S-box; those
    bytes to which it was applied by addition go through the inverse S-box [[17](#CR17)].'
  prefs: []
  type: TYPE_NORMAL
- en: AES Algorithm
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Data Encryption Standard (DES) was the encryption standard till 2001 when it
    was replaced by AES. The Advanced Encryption Standard (AES) was established by
    National Institute of Standards and Technology (NIST) in 2001 as the current standard
    for encrypting electronic data [[18](#CR18)]. AES is based on *Rijndael* cipher
    which is an iterated block cipher with a fixed block length and supports variable
    key lengths. A block length of 128 bits and three different key sizes of 128,
    192, and 256, which require 10, 12, and 14 rounds, respectively, are used. Figures
    [2.7](#Fig7) and [2.8](#Fig8), respectively, show AES ciphering and deciphering.
    AES is working as follows (Fig. [2.9](#Fig9)):'
  prefs: []
  type: TYPE_NORMAL
- en: '1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add round key: round key is XORed with the plaintext, and then the result will
    be converted into 4× 4 *matrix* (state).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The sub-byte transformation is a nonlinear *substitution* operation that works
    on bytes. It’s based on the Galois field GF (2⁸) with irreducible polynomial *m*(*x*) = *x*⁸ + *x*⁴ + *x*³ + *x* + 1
    and can be done using look up table.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '3.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The shift row transformation *rotates* each row of the input state to the left;
    the first row will remain unshifted; the second row will be rotated by 1 step
    to the left, whereas the second row will be rotated by two steps; and the third
    row will be rotated 3 steps to the left.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '4.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Mix columns: each input column is considered as a polynomial over GF (2⁸) and
    *multiplied* with the constant polynomial *a*(*x*) = {03}*x*3 + {01}*x*² + {01}*x* + {02}modulo *x*⁴ + 1\.
    The coefficients of *a*(*x*) are also elements of GF (2⁸) and are represented
    by hexadecimal values in this equation. The inverse mix column transformation
    is the multiplication of each column with *a*(*x*) = {0*B*}*x*3 + {0*D*}*x*² + {09}*x* + {0*E*}modulo *x*⁴ − 1.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '5.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Key expansion.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![../images/501530_1_En_2_Chapter/501530_1_En_2_Fig7_HTML.png](../images/501530_1_En_2_Chapter/501530_1_En_2_Fig7_HTML.png)'
  prefs: []
  type: TYPE_IMG
- en: Fig. 2.7
  prefs: []
  type: TYPE_NORMAL
- en: AES ciphering
  prefs: []
  type: TYPE_NORMAL
- en: '![../images/501530_1_En_2_Chapter/501530_1_En_2_Fig8_HTML.png](../images/501530_1_En_2_Chapter/501530_1_En_2_Fig8_HTML.png)'
  prefs: []
  type: TYPE_IMG
- en: Fig. 2.8
  prefs: []
  type: TYPE_NORMAL
- en: AES deciphering
  prefs: []
  type: TYPE_NORMAL
- en: '![../images/501530_1_En_2_Chapter/501530_1_En_2_Fig9_HTML.png](../images/501530_1_En_2_Chapter/501530_1_En_2_Fig9_HTML.png)'
  prefs: []
  type: TYPE_IMG
- en: Fig. 2.9
  prefs: []
  type: TYPE_NORMAL
- en: AES encryption
  prefs: []
  type: TYPE_NORMAL
- en: Blowfish
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Blowfish  is a 64 bit symmetric key block cipher used to efficiently encrypt
    data. The Blowfish algorithm has a Feistel structure which means that it iterates
    a simple encryption function 16 times. It uses variable key lengths ranging from
    32 bits up to a maximum of 448 bits. It was first introduced by the security guru
    Bruce Schneier in 1993, and it has never been cracked [[19](#CR19)]. Twofish,
    also designed by Schneier, is the successor of Blowfish, and it contains a 128
    bit block along with key up to 256 bits long [[20](#CR20)].
  prefs: []
  type: TYPE_NORMAL
- en: Des
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Data Encryption Standard (DES)  is a symmetric key block cipher published
    by the National Institute of Standards and Technology (NIST). DES is an implementation
    of a Feistel cipher. It uses 16 round Feistel structure. The block size is 64
    bit. Though, key length is 64 bit, DES has an effective key length of 56 bits,
    since 8 of the 64 bits of the key are not used by the encryption algorithm (function
    as check bits only). DES structure is shown in Fig. [2.10](#Fig10) [[21](#CR21)].
    *Feistel cipher* is not a specific scheme of block cipher. It is a design model
    from which many different block ciphers are derived. DES is just one example of
    a Feistel cipher. A cryptographic system based on Feistel cipher structure uses
    the same algorithm for both encryption and decryption. The encryption process
    uses the Feistel structure consisting multiple rounds of processing of the plaintext,
    each round consisting of a “substitution” step followed by a permutation step.![../images/501530_1_En_2_Chapter/501530_1_En_2_Fig10_HTML.png](../images/501530_1_En_2_Chapter/501530_1_En_2_Fig10_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 2.10
  prefs: []
  type: TYPE_NORMAL
- en: DES structure
  prefs: []
  type: TYPE_NORMAL
- en: Triple DES/3DES
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The basic methodology of Triple DES is based on DES. It encrypts the plain text
    three times. The overall key length of Triple DES is 192 bits, i.e., three 64
    bit keys are used in this block cipher. Like DES, the effective length of each
    key is 56 bits. In Triple DES, the first encrypted cipher text is again encrypted
    by the second key, and again the third key encrypts the resulting encrypted cipher
    text. Though this algorithm is much more secure than DES, it is too slow for many
    real life applications [[22](#CR22)].
  prefs: []
  type: TYPE_NORMAL
- en: RC4 (Rivest Cipher 4)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This is a stream cipher published in 1987\. The disadvantage of these techniques
    is the generation of the key stream, which is a potentially long sequence of values
    consisting of 40 bit to 128 bit key and a 24 bit initialization vector. But the
    encryption is straightforward; the actual plaintext is xor’d with the key stream.
    The key input is a pseudorandom bit generator that creates a byte number, which
    is the output of the generator and it is called the key stream. The key stream
    is then XORed with the plaintext byte by byte to produce the ciphertext. It is
    impossible to predict the key stream without having knowledge of the key.
  prefs: []
  type: TYPE_NORMAL
- en: RC5 (Rivest Cipher 4)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This is a block cipher algorithm, published in 1994, which uses variable block
    size, key size, and encryption steps. The block size can be 32, 64, or 128 bits,
    and the key size can be from 0 up to 2040 bits. Additionally, the number of rounds
    can be from 0 up to 255\. It consists of some modular additions and exclusive
    OR (XOR) operations. It is vulnerable to a differential attack using numerous
    chosen plaintexts, where the inputs differences can also affect the outputs [[23](#CR23)].
  prefs: []
  type: TYPE_NORMAL
- en: SEAL Algorithm
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'SEAL is a length-raising “illusive random” that depicts 32 bit string N- to
    L-bit string SEAL under a hidden 160 bit key. The output length *L* is intended
    to be diverse, however, in general bound to 64 kilobytes. The key usage is to
    figure out three secret charts: R, S, and T; these charts have 256, 256, and 512
    32 bit values, respectively, that are induced from the Secure Hash Algorithm (SHA).
    SEAL is the fruit of the dual shower source clarified. The first generator implements
    a systematic relies on the deducted charts R and T. It maps the 32-bit string
    n and the 6-bit counter [[24](#CR24)].'
  prefs: []
  type: TYPE_NORMAL
- en: 2.3 Asymmetric Encryption
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many applications use asymmetric cryptography to secure communications between
    two parties. One of the main issues with asymmetric cryptography is the need for
    vast amounts of computation and storage.
  prefs: []
  type: TYPE_NORMAL
- en: The concept of public key cryptography evolved from an ‑attempt to attack two
    of the most difficult problems associated with symmetric encryption. The first
    problem is that of key distribution, where under symmetric encryption requires
    either that two communicants already share a key, which somehow has been distributed
    to them or the use of a *key distribution center.* Asymmetric algorithms rely
    on one key for encryption and a different but related key for decryption [[25](#CR25)].
    There are many methods for key establishment, including certificates and public
    key infrastructure (*PKI*).
  prefs: []
  type: TYPE_NORMAL
- en: The *public key* is freely distributable. It is related mathematically to the
    private key, but you cannot (easily) reverse engineer the *private key* from the
    *public key.* Use the *public key* to encrypt data.
  prefs: []
  type: TYPE_NORMAL
- en: Only someone with the *private key* can decrypt.
  prefs: []
  type: TYPE_NORMAL
- en: The key for encryption (K[E]) and decryption (K[D]) are different. But, K[E]
    and K[D] form a unique pair. One of keys is made public and another made private.
    The encryption/decryption process can be modeled by eq. ([2.2](#Equ2)) and can
    be seen in Fig. [2.11](#Fig11).![$$ P={D}_{K_D}\left({E}_{K_E}(P)\right) $$](../images/501530_1_En_2_Chapter/501530_1_En_2_Chapter_TeX_Equ2.png)(2.2)![../images/501530_1_En_2_Chapter/501530_1_En_2_Fig11_HTML.png](../images/501530_1_En_2_Chapter/501530_1_En_2_Fig11_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 2.11
  prefs: []
  type: TYPE_NORMAL
- en: Asymmetric key encryption
  prefs: []
  type: TYPE_NORMAL
- en: Public key systems can be used for encryption and authentication. One key is
    used to encrypt the document; a different key is used to decrypt it. Comparison
    between symmetric and nonsymmetric encryption is shown in Table [2.2](#Tab2).Table
    2.2
  prefs: []
  type: TYPE_NORMAL
- en: Comparison between symmetric and nonsymmetric encryption
  prefs: []
  type: TYPE_NORMAL
- en: '| Symmetric encryption | Nonsymmetric encryption |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1\. The same algorithm with the same key is used for encryption and decryption2\.
    The sender and receiver must share the algorithm and the key3\. The key must be
    kept secret4\. It must be impossible or at least impractical to decipher a message
    if no other information is available5\. Knowledge of the algorithm plus samples
    of ciphertext must be insufficient to determine the key | 1\. One algorithm is
    used for encryption and decryption with a pair of keys, one for encryption and
    one for decryption2\. The sender and receiver must each have one of the matched
    pair of keys (not the same one)3\. One of the two keys must be kept secret4\.
    It must be impossible or at least impractical to decipher a message if no other
    information is available5\. Knowledge of the algorithm plus one of the keys plus
    samples of ciphertext must be insufficient to determine the other key |'
  prefs: []
  type: TYPE_TB
- en: The security of asymmetric encryption rests on computational problems such as
    the difficulty of factorizing large prime numbers and the discrete logarithm problem.
    Such kind of algorithms is called one-way functions because they are easy to compute
    in one direction, but the inversion is difficult. Public key encryption works
    very well and is extremely secure, but it’s based on complicated mathematics.
    Because of this, your computer has to work very hard to both encrypt and decrypt
    data using the system. In applications where you need to work with large quantities
    of encrypted data on a regular basis, the computational overhead means that public
    key systems can be very slow.
  prefs: []
  type: TYPE_NORMAL
- en: '2.3.1 RSA: Factorization Computational Problem'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Rivest–Shamir–Adleman (RSA) scheme has been published in 1978, and since
    that time it is the most widely accepted and implemented general-purpose approach
    to public key encryption [[26](#CR26)]. Encryption and decryption are of the following
    form, for some plaintext block *M* and ciphertext block *C*:![$$ C={M}^e\operatorname{mod}n
    $$](../images/501530_1_En_2_Chapter/501530_1_En_2_Chapter_TeX_Equ3.png)(2.3)![$$
    M={C}^d\operatorname{mod}n={\left({M}^e\right)}^d\operatorname{mod}n={M}^{ed}\operatorname{mod}n
    $$](../images/501530_1_En_2_Chapter/501530_1_En_2_Chapter_TeX_Equ4.png)(2.4)
  prefs: []
  type: TYPE_NORMAL
- en: Both sender and receiver must know the value of *n*. Plaintext is encrypted
    in blocks, with each block having a binary value less than some number *n*. That
    is, the block size must be less than or equal to log[2](*n*). The RSA scheme is
    a block cipher in which the plaintext and ciphertext are integers between 0 and
    *n*-1 for some *n*. The sender knows the value of e, and only the receiver knows
    the value of d. Thus, this is a public key encryption algorithm with a public
    key of = {*e*, *n*} and a private key of = {*d*, *n*}.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this algorithm to be satisfactory for public key encryption, the following
    requirements must be met:'
  prefs: []
  type: TYPE_NORMAL
- en: '1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is possible to find values of *e*, *d*, and *n* such that *M*^(*ed*) mod
    *n* = *M* for all *M < n.*
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This is done by choosing *n = pq, where p and q are primes numbers.* Select
    e, where *1 < e < (p-1) (q-1)* and *gcd ((p-1) (q-1), e) = 1, which means e is
    a prime to (p-1) (q-1). Select d, where d = e*^(*−1*)*mod ((p-1) (q-1)) or de = 1
    mod((p-1) (q-1)).*
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is relatively easy to calculate mod *M*^(*e*) mod *n* and *C*^(*d*) for all
    values of *M < n.*
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '3.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is infeasible to determine d given *e* and *n.*
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'An example is shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: Assume plaintext = 88.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Key generation*: *n* = 17 × 11 = 187\. *e* = 7, where gcd (160, 7) =1\. *D* = 23,
    where *d**7 = 1 mod 160.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Encryption process*: *C* = 88⁷ mod 187 = 11.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Decryption process*: *M* = 11^(23) mod 187 = 88.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '2.3.2 ECC: Discrete Logarithm Problem (DLP)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Elliptic curve cryptography (ECC) is a public key cryptographic technique based
    on the algebraic structure of elliptic curves over finite fields. ECC is an approach
    to asymmetric cryptography used widely in low computation devices such as wireless
    sensor networks (WSNs) and Internet of Things (IoT) devices as it decreases power
    consumption and increases device performance [[27](#CR27)]. This is due to its
    ability to generate small keys with a strong encryption mechanism. For example,
    encryption using the RSA algorithm with a 1024 bit key is equal to ECC encryption
    with a 160 bit key [[28](#CR28)]. ECC ensures security depending on the ability
    to compute a point multiplication with a random point, as well as the inability
    to figure out a multiplicand given the original curve and product points. ECC
    uses a pair (*x*; *y*) that fits into the equation *y*² = *x*³ + *ax* + *b* mod
    *p* together with an imaginary point (theta) at infinity, where *a*; *b* ϵ *Zp*
    and 4*a*³ + 27*b*² ≠ 0 mod *p*. ECC needs a cyclic Group G and the primitive elements
    we use, or pair elements, to be of order G.
  prefs: []
  type: TYPE_NORMAL
- en: 2.3.3 ElGamal Cryptosystem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: ElGamal cryptosystem is an asymmetric key encryption which was proposed by Taher
    Elgamal in 1984\. The security of this algorithm is based on the discrete logarithm
    problem. For a given number, there is no existing algorithm which can find its
    discrete logarithm in polynomial time, but the inverse operation of the power
    can be derived efficiently. Another key aspect of ElGamal cryptosystem is randomized
    encryption. This algorithm can establish a secure channel for key sharing and
    generally used as key authentication protocol. For security the key size of this
    algorithm should be greater than 1024 bits. The major drawback of ElGamal algorithm
    is that it is relatively time-consuming.
  prefs: []
  type: TYPE_NORMAL
- en: '2.3.4 Diffie–Hellman Algorithm: Key Exchange'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Diffie–Hellman (DH) key exchange algorithm is a method for securely exchanging
    cryptographic keys over a public communications channel. Keys are not actually
    exchanged, but they are jointly derived. Traditionally, secure encrypted communication
    between two parties required that they first exchange keys by some secure physical
    means, such as paper key lists transported by a trusted courier. The Diffie–Hellman
    key exchange method allows two parties that have no prior knowledge of each other
    to jointly establish a shared secret key over an insecure channel. This key can
    then be used to encrypt subsequent communications using a symmetric key cipher.
    The steps are as follows [[29](#CR29)]:'
  prefs: []
  type: TYPE_NORMAL
- en: '1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Alice and Bob publicly agree to use a modulus *p* and base *g* (which is a primitive
    root modulo p).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Alice chooses a secret integer ***a*** and then sends Bob *A* = *g*^(***a***)
    mod *p.*
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '3.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bob chooses a secret integer ***b*** and then sends Alice *B* = *g*^(***b***)
    mod *p.*
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '4.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Alice computes ***s*** = *B*^(***a***) mod *p*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '5.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bob computes ***s*** = *A*^(***b***) mod *p*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '6.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Alice and Bob now share a secret (s).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The difficulty of breaking these cryptosystems is based on the difficulty in
    determining the integer r such that *g*^(*r*) = *x* mod *p*. The integer r is
    called the discrete logarithm problem of *x* to the base *g*, and we can write
    it as ![$$ r={\log}_g^x $$](../images/501530_1_En_2_Chapter/501530_1_En_2_Chapter_TeX_IEq1.png)
    mod p. The discrete logarithm problem is a very hard problem to compute if the
    parameters are large enough.
  prefs: []
  type: TYPE_NORMAL
- en: 2.3.5 EGC
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Elliptic curve cryptography (ECC) is an approach to public key cryptography
    based on the algebraic structure of elliptic curves over finite fields. ECC allows
    smaller keys compared to non-EC cryptography (based on plain Galois fields) to
    provide equivalent security. Elliptic curves are applicable for key agreement,
    digital signatures, pseudorandom generators and other tasks. Indirectly, they
    can be used for encryption by combining the key agreement with a symmetric encryption
    scheme. The EGC protocol generated high levels of data security to serve the purpose
    of protecting data during transmission in the IoT [[30](#CR30)–[32](#CR32)].
  prefs: []
  type: TYPE_NORMAL
- en: 2.4 Hybrid Encryption
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the known methods to strengthen the secureness of a cryptography is by
    combining two existing cryptographies. A combination of two cryptographies is
    also called the hybrid algorithm such as combination of symmetric and public key-based
    system. Symmetric key cryptography is faster and more efficient than public key
    cryptography but lacks security when exchanging keys over unsecured channels.
    Hybrid cryptosystems combine the speed of symmetric key cryptography with the
    security of public key cryptography. A hybrid cryptosystem consists of a public
    key cryptosystem for key encapsulation and a symmetric key cryptosystem for data
    encapsulation. Hybrid cryptosystems are used by most computer users in the form
    of HTTP Secure (*HTTPS*) [[33](#CR33)].
  prefs: []
  type: TYPE_NORMAL
- en: 2.5 Crypto-Analysis/Attacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The analysis of the cryptography algorithms in general is known as cryptanalysis
    and is an essential aspect of testing the reliability of the cryptography system
    for practical. Cryptographic algorithms are provably secure against mathematical
    cryptanalysis under the black box assumption. Cryptanalysis methods are summarized
    below, and different types of attacks on different security levels are shown in
    Table [2.3](#Tab3). Attacks can be passive or active. *Passive attacks* do not
    alter or affect at any other way the information, and they do not cause any issue
    to the communication channel. The main goal here is to acquire unauthorized access
    to sensitive and confidential information and data. Passive attacks are often
    called as stealing information. What really makes this attack harmful is the fact
    that most of the times the owner is not aware that an unauthorized person has
    knowledge of the owner’s data. For instance, an attacker could intercept and eavesdrop
    a communication channel and gain knowledge to confidential information, and neither
    the sender nor the receiver could figure that out. *Active attacks* is able to
    process the information and alter it in many different ways. More specifically,
    the attacker could change specific fields of the data like the originator name
    and the timestamp and generally modifying the information in an unauthorized way.
    Moreover, unauthorized deletion of data, initiation of unintended transmission
    of information or data, and, lastly, denial of access to data by legitimate users
    the so-called denial of service (DoS) attack are also examples of active attacks
    [[34](#CR34), [35](#CR35)].Table 2.3
  prefs: []
  type: TYPE_NORMAL
- en: Different types of attacks on different security levels
  prefs: []
  type: TYPE_NORMAL
- en: '| Security abstraction level | Security objective | Side channel attack |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Protocol | Authenticated communications | Man-in-the-middle,Traffic analysis
    |'
  prefs: []
  type: TYPE_TB
- en: '| Algorithm | Encryption/hashing | Known plaintext,Known cryptext |'
  prefs: []
  type: TYPE_TB
- en: '| Architecture | Functional integration (SW) | Stack smashing |'
  prefs: []
  type: TYPE_TB
- en: '| Micro-architecture | Architecture integration (HW) | Bus probing |'
  prefs: []
  type: TYPE_TB
- en: '| Circuit | Implementation | Differential power analysis |'
  prefs: []
  type: TYPE_TB
- en: 2.5.1 Exhaustive/Brute Force Attack
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The secret *key’s space* should be long. Crypto-analysis time versus key size
    is shown in Table [2.4](#Tab4). The security of an encryption algorithm ought
    to have vast key space more sensitive to the secret key to tackling a different
    kind of attacks such as statistical attacks, differential attack, known plain
    text attacks, and exhaustive attacks. The large size of the key space also makes
    brute force attacks infeasible. Moreover, the **sensitivity of algorithms**  toward
    the secret key during encryption and decryption is the key point of the robustness
    of an encryption algorithm. The higher the sensitivity, the more secure is the
    information because only a slight change in the key will lead toward an entirely
    different cipher image. That means no one can recover the original image except
    having the correct secret key [[36](#CR36)–[38](#CR38)].Table 2.4
  prefs: []
  type: TYPE_NORMAL
- en: Crypto-analysis time versus key size
  prefs: []
  type: TYPE_NORMAL
- en: '| Key size | Possible no. of keys | Time to crack |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| (1 encryption/μs) | (10⁶ encryptions/ μs) |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 32 | 10⁹ | 36 min | 2\. msec |'
  prefs: []
  type: TYPE_TB
- en: '| 56 | 10^(16) | 1100 years | 10 hrs |'
  prefs: []
  type: TYPE_TB
- en: '| 128 | 10^(38) | 5 × 10^(24) years | 5 × 10^(18) years |'
  prefs: []
  type: TYPE_TB
- en: '| 26 characters | 10^(26) | 6 × 10^(12) years | 6 × 10⁶ years |'
  prefs: []
  type: TYPE_TB
- en: 2.5.2 Statistical/Histogram Attack
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The histogram is a common approach to get the distribution of an image pixel
    values. Histogram of data should be uniform after encryption. This leads to statistical
    attacks invalid. In information theory, entropy is the most significant feature
    of the disorder. We can say numerical property reflecting the randomness associated
    unpredictability of an information source called entropy. The ideal *entropy*
    value for a random image with a gray level of 2⁸ is 8\. Which means the closer
    the entropy value is, the more is the haphazardness of an image, conclusively
    less information disclosed by the encryption scheme.
  prefs: []
  type: TYPE_NORMAL
- en: 2.5.3 Differential Attack
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Attackers often make a slight change to the original data and use the proposed
    algorithm to encrypt for the original data before and after changing, through
    comparing two encrypted image to find out the relationship between the original
    data and the encrypted data.
  prefs: []
  type: TYPE_NORMAL
- en: 2.5.4 Known/Chosen Plaintext/Ciphertext Attack
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 2.5.4.1 Known Ciphertext Attacks (KCA)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Here the attacker possesses multiple ciphertexts, but without the corresponding
    plaintexts. This attack becomes effective when the corresponding plaintext can
    be extracted from one or more ciphertexts. Additionally, sometimes the encryption
    key can be discovered by this attack. In practice, however, the adversary performing
    this attack has also some knowledge about the plaintext. This information could
    be the language that the plaintext is written or the foreseeable statistical distribution
    of the characters in it.
  prefs: []
  type: TYPE_NORMAL
- en: 2.5.4.2 Chosen Plaintext Attack (CPA)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The adversary here has free access to the encryption process and can create
    any ciphertext from any plaintext of his choice. So basically, the attacker can
    have any desirable pair of plaintext–ciphertext. This makes the process of finding
    the encryption key easier, as the attacker can gain more knowledge of the encryption
    operation, the more pairs of messages, and ciphertexts created.
  prefs: []
  type: TYPE_NORMAL
- en: 2.5.4.3 Known Plaintext Attack (KPA)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This attack is quite similar to the previous one. Here the attacker knows the
    plaintext that the sender has sent and the corresponding ciphertext. The goal
    of the adversary is to gain information by taking advantage of the ciphertext–plaintext
    pairs they have. This could result to the discovery of the encryption key or other
    information for the algorithm as well. The difference with the chosen plaintext
    attack is that the plaintext is not chosen by the attacker but the sender of the
    message.
  prefs: []
  type: TYPE_NORMAL
- en: 2.5.4.4 Chosen Ciphertext Attack (CCA)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this type of attack, the adversary or the cryptanalyst has the ability to
    analyze any chosen ciphertexts along with the corresponding plaintexts. The goal
    is to gain the secret key or as much information as possible for the attacked
    cryptographic system. This attack holds with the assumption that the attacker
    can make the victim decrypt any encrypted message and send it to him. The more
    decrypted ciphertexts the attack owns, the more information is gained for the
    system, and thus it is more likely to break it.
  prefs: []
  type: TYPE_NORMAL
- en: 2.5.4.5 Side Channel Attack
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The system is attacked via the channel leaked information such as *time consumption,
    power consumption, or electromagnetic radiation*. Timing attack is one type of
    side channel attack. The attacker can access the equipment or physically damage
    them by performing, for instance, Differential Power Analysis (DPA) attack. In
    Differential Power Analysis, the attacker send lots of plaintext (bits) to the
    FPGA, which will decrypt them accordingly, and meanwhile the attacker will be
    measuring the power traces, trying to get the cryptography algorithm key (using
    statistical techniques and knowledge of the CMOS power model). There are many
    countermeasures against this attack, including changing the time of the key transmission
    or encryption to confuse the adversary and filtering the power line conditioning
    to prevent power-monitoring acts.
  prefs: []
  type: TYPE_NORMAL
- en: '*Deep learning* technique can be used in side channel analysis context. Like
    other machine learning techniques, a deep learning technique builds a profiling
    model for each possible value of the targeted sensitive variable during the training
    phase, and, during the attack phase, these models are involved to output the most
    likely key used during the acquisition of the attack traces. In side channel attack
    context, an adversary is rather interested in the computation of the probability
    of each possible value deduced from a key hypothesis. Therefore, to recover the
    good key, the adversary computes the maximum or the log maximum likelihood approach
    like for template attack [[39](#CR39)–[41](#CR41)].'
  prefs: []
  type: TYPE_NORMAL
- en: 2.5.4.6 Man-in-the-Middle Attack
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This attack depends on standing between the two communicating parties to get
    the message from the sender, change, and add to it and then send it forward to
    the receiver. This needs that the attacker knows the encryption keys to be able
    to encrypt the added parts to the message. One-time pad keys and changing the
    block lengths make the attacker not able to succeed to play the man-in-the middle
    role.
  prefs: []
  type: TYPE_NORMAL
- en: 2.6 Comparison Between Different Encryption Algorithms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Stream ciphers are generally faster than block ciphers, due to the fact that
    in the second category, each block needs to be processed, one by one in order
    to be encrypted, which is not the case in stream ciphers where only one bit or
    byte is processed at a time. As a result, block ciphers require more memory allocation,
    since they have to work on bigger chunks of data, and, sometimes, they have to
    continue the operation from previous blocks as well. On the contrary, stream ciphers
    process at most a byte at a time, so they have relatively low memory requirements,
    and as a result they are cheaper to implement in constrained devices like embedded
    systems and IoT devices and more general in lightweight cryptographic algorithms.
    Nevertheless, stream ciphers are more difficult to develop and design effectively,
    and they are vulnerable depending on the usage. Stream ciphers do not offer integrity
    protection and authentication, whereas some block ciphers depending on the mode
    they use are able to provide integrity together with confidentiality. Additionally,
    because of the fact that block ciphers encrypt a whole block at a time and most
    of them have feedback modes, they are prone to adding noise in the transmission
    that could alter the data, so the rest of the transmission will not be the appropriate
    for the algorithm. Stream ciphers do not face such problem as the bits or bytes
    are encrypted separately from the other data, and most of the times there are
    solutions in case of connection issues. A comparative evaluation of different
    encryption algorithms is shown in Tables [2.5](#Tab5) and [2.6](#Tab6). DES algorithm
    has the lower encryption and decryption speed. AES algorithm has the least memory
    utilization. RSA has a very high memory utilization [[42](#CR42), [43](#CR43)].
    Due to its low power consumption, DES is designed to work better in hardware than
    in software program. 3DES requires higher time than DES and consumes more power
    consumption and has less throughputs. The 3DES algorithm is the best for data
    protection because it uses three keys to encrypt and decrypt data [[44](#CR44)].Table
    2.5
  prefs: []
  type: TYPE_NORMAL
- en: Comparison between different encryption algorithms
  prefs: []
  type: TYPE_NORMAL
- en: '| Algorithm | Encryption and decryption speed | Scalability | Vulnerabilities
    | Security |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| RSA | High | Not scalable | Brute force attack | High |'
  prefs: []
  type: TYPE_TB
- en: '| DES | Low | Scalable | Brute force attack | Medium |'
  prefs: []
  type: TYPE_TB
- en: '| AES | Low | Not scalable | Cryptanalysis attack | High |'
  prefs: []
  type: TYPE_TB
- en: '| 3DES | Low | Not scalable | Man-in-the-middle-attack | High |'
  prefs: []
  type: TYPE_TB
- en: '| BLOWFISH | Low | Scalable | Brute force attack | Low |'
  prefs: []
  type: TYPE_TB
- en: '| ECC | Low | Scalable | Brute force attack | Medium |'
  prefs: []
  type: TYPE_TB
- en: Table 2.6
  prefs: []
  type: TYPE_NORMAL
- en: Comparison between AES, DES, and RSA
  prefs: []
  type: TYPE_NORMAL
- en: '| Factors | AES | DES | RSA |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Development year | 2000 | 1977 | 1978 |'
  prefs: []
  type: TYPE_TB
- en: '| Key length (bits) | 128,192,256 | 56 | 1024 |'
  prefs: []
  type: TYPE_TB
- en: '| Key type | Symmetric | Symmetric | Asymmetric |'
  prefs: []
  type: TYPE_TB
- en: '| Block size (bits) | 128 | 64 | 512 |'
  prefs: []
  type: TYPE_TB
- en: '| Execution time | Fast | Moderate | Slow |'
  prefs: []
  type: TYPE_TB
- en: '| Rounds | 10,12,14 | 16 | 1 |'
  prefs: []
  type: TYPE_TB
- en: 2.7 Cryptography Applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The need for strong cryptographic algorithms is very high, and the design of
    them is challenging, especially by taking into consideration that the processing
    power of computers increases day by day and malicious parties tend to find new
    vulnerabilities and breaches in security systems all the time. Nowadays, cryptography
    is excessively used in many types of applications.
  prefs: []
  type: TYPE_NORMAL
- en: 2.7.1 Secured Email
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Alice wants to send confidential email “m” to Bob (Fig. [2.12](#Fig12)).![../images/501530_1_En_2_Chapter/501530_1_En_2_Fig12_HTML.png](../images/501530_1_En_2_Chapter/501530_1_En_2_Fig12_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 2.12
  prefs: []
  type: TYPE_NORMAL
- en: Sending a secured email
  prefs: []
  type: TYPE_NORMAL
- en: 'Alice:'
  prefs: []
  type: TYPE_NORMAL
- en: Generates random symmetric private key, *K*[*S*]
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encrypts message with *K*[*S*]
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encrypts *K*[*S*] with Bob’s public key
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sends both *K*[*S*](*m*) and *K*[*B*](*K*[*S*]) to Bob
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Bob:'
  prefs: []
  type: TYPE_NORMAL
- en: Uses his private key to decrypt and recover *K*[*S*]
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uses *K*[*S*] to decrypt *K*[*S*](*m*) to recover *m*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2.7.2 Secured Chat
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The chat client will use an encryption algorithm to provide end-to-end encrypted
    communications with other clients. There are many popular session setup protocol
    that powers real-world chat systems such as Signal and WhatsApp.
  prefs: []
  type: TYPE_NORMAL
- en: 2.7.3 Secured Wireless Communication System
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A high-level wireless communication system is shown in Fig. [2.13](#Fig13),
    where encryption plays a vital role. The *Bluetooth* encryption system uses the
    stream cipher E0 to encrypt the payloads of the packets which is re-synchronized
    for every payload. The E0 stream cipher consists of the payload key generator,
    the key stream generator, and the encryption/decryption part. The input bits are
    combined by the payload key generator and are shifted to the four linear feedback
    shift registers (LSFR) of the key stream generator. The key stream bits are then
    generated which are used for encryption. The Exclusive-OR operation is then performed
    on the key stream bits and data stream bits to generate the ciphertext. Similarly
    the Exclusive-OR operation is performed on the ciphertext to get back the plaintext
    during the decryption process.![../images/501530_1_En_2_Chapter/501530_1_En_2_Fig13_HTML.png](../images/501530_1_En_2_Chapter/501530_1_En_2_Fig13_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 2.13
  prefs: []
  type: TYPE_NORMAL
- en: High-Level wireless communication system
  prefs: []
  type: TYPE_NORMAL
- en: '*WLAN* encryption methods includes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Wired Equivalent Privacy (*WEP*): Wired Equivalent Privacy (WEP) is a security
    algorithm for IEEE 802.11 wireless networks. Standard 64 bit WEP uses a 40 bit
    key (also known as WEP-40), which is concatenated with a 24 bit initialization
    vector (IV) to form the RC4 key. At the time that the original WEP standard was
    drafted, the US Government’s export restrictions on cryptographic technology limited
    the key size. Once the restrictions were lifted, manufacturers of access points
    implemented an extended 128 bit WEP protocol using a 104 bit key size (WEP-104).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Wi-Fi Protected Access (*WPA*): Wi-Fi Protected Access (WPA) was the Wi-Fi
    Alliance’s direct response and replacement to the increasingly apparent vulnerabilities
    of the WEP standard. WPA was formally adopted in 2003, a year before WEP was officially
    retired. The most common WPA configuration is WPA-PSK (pre-shared key). The keys
    used by WPA are 256 bit, a significant increase over the 64 bit, and 128 bit keys
    used in the WEP system [[45](#CR45)].'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Wi-Fi Protected Access 2 (*WPA2*): WPA has, as of 2006, been officially superseded
    by WPA2. One of the most significant changes between WPA and WPA2 is the mandatory
    use of AES algorithms and the introduction of CCMP (Counter Mode Cipher Block
    Chaining Message Authentication Code Protocol) as a replacement for TKIP. However,
    TKIP is still preserved in WPA2 as a fallback system and for interoperability
    with WPA.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*5G* uses 256 bit encryption, a substantial improvement on the 128 bit standard
    used by 4G. With 5G, the user’s identity and location are encrypted, making them
    impossible to identify or locate from the moment they get on the network [[46](#CR46)].
    In older 2G cellular systems, the cryptographic algorithms used to secure the
    air interface and perform subscriber authentication functions were not publicly
    disclosed. The GSM algorithm families pertinent to our discussion are A3, A5,
    and A8\. A3 provides subscriber authentication, A5 provides air interface confidentiality,
    and A8 is related to A3, in that it provides subscriber authentication functions
    but within the SIM card. UMTS introduced the first publicly disclosed cryptographic
    algorithms used in commercial cellular systems. The terms UEA (UMTS Encryption
    Algorithm) and UIA (UMTS Integrity Algorithm) are used within UMTS as broad categories.
    UEA1 is a 128 bit block cipher called KASUMI, which is related to the Japanese
    cipher MISTY. UIA1 is a message authentication code (MAC), also based on KASUMI.
    UEA2 is a stream cipher related to SNOW 3G, and UIA2 computes a MAC based on the
    same algorithm. LTE builds upon the lessons learned from deploying the 2G and
    3G cryptographic algorithms. LTE introduced a new set of cryptographic algorithms
    and a significantly different key structure than that of GSM and UMTS. There are
    three sets of cryptographic algorithms for both confidentiality and integrity
    termed EPS Encryption Algorithms (EEA) and EPS Integrity Algorithms (EIA). EEA1
    and EIA1 are based on SNOW 3G, very similar to algorithms used in UMTS. EEA2 and
    EIA2 are based on the Advanced Encryption Standard (AES) with EEA2 defined by
    AES in CTR mode (e.g., stream cipher) and EIA2 defined by AES-CMAC (cipher-based
    MAC). EEA3 and EIA3 are both based on a Chinese cipher ZUC. While these new algorithms
    have been introduced in LTE, network implementations commonly include older algorithms
    for backward compatibility for legacy devices and cellular deployments [[47](#CR47)].'
  prefs: []
  type: TYPE_NORMAL
- en: 2.7.4 Secured Mobile/Smartphone
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Smartphone users are exposed to different threats. These threats may disturb
    operation and transfer user data from smartphones. There are a number of ways
    in which the type of attacks in mobiles can be segregated. Some of them are explained
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Wi-Fi-based attacks*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An attacker can intercept a Wi-Fi communication by doing eavesdropping. The
    security in WLAN is more vulnerable. It is possible for an attacker to break the
    password easily get in the local network of the victim. In an event where an attacker
    prospers in breaking identification cipher, it becomes possible to attack both
    the phone and the entire network.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Web browser-based attack*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In web browser-based attacks, an attacker uses leverages like stack-based overflow
    and other vulnerabilities in libraries. This is possible in all kinds of operating
    system either Android or iOS. Smartphones are also vulnerable to phishing and
    other malicious web site-based attacks, and the biggest problem with smartphones
    is that they don’t have strong antivirus protection yet.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Operating system-based attacks*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One may apply any number of secure mechanisms, but if there is vulnerability
    in operating system, it might be going to affect one day surely. There are several
    loopholes in operating systems of smartphones as these are in earlier stages and
    developers are not much aware about the kind of attacks possible. It was likely
    to dodge the security of operating system and circumvent the bytecode verifier
    and gain access of core operating system. Similarly in windows mobile OS, one
    can easily edit the general configuration file to a modifiable file. It is also
    possible for a malicious attacker to do modifications in the directory whenever
    an application is installed as at that time it has root privileges.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 2.8 Conclusions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter discusses the fundamentals of private and public key cryptography.
    Moreover, it explains the details of the main building blocks of these cryptographic
    systems. Besides, this chapter explores the different crypto-analysis techniques.
    It addresses stream ciphers, the Data Encryption Standard (DES) and 3DES, the
    Advanced Encryption Standard (AES), block ciphers, the RSA cryptosystem, and public
    key cryptosystems based on the discrete logarithm problem, elliptic curve cryptography
    (ECC), key exchange algorithms, and so many other algorithms. Moreover, this chapter
    provides a comparison between different encryption algorithms in terms of speed
    encryption, decoding, complexity, the length of the key, structure, and flexibility.
  prefs: []
  type: TYPE_NORMAL
