- en: '© The Author(s), under exclusive license to Springer Nature Switzerland AG 2022A.
    Kumar et al. (eds.)Quantum and Blockchain for Modern Computing Systems: Vision
    and AdvancementsLecture Notes on Data Engineering and Communications Technologies133[https://doi.org/10.1007/978-3-031-04613-1_5](https://doi.org/10.1007/978-3-031-04613-1_5)'
  prefs: []
  type: TYPE_NORMAL
- en: A Conceptual Framework for Scaling and Security in Serverless Environments Using
    Blockchain and Quantum Key Distribution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'P. R. Mahalingam^([1](#Aff5) [ ](#ContactOfAuthor1))(1)Muthoot Institute of
    Technology and Science, Kochi, Kerala, IndiaP. R. MahalingamEmail: [prmahalingam@gmail.com](mailto:prmahalingam@gmail.com)'
  prefs: []
  type: TYPE_NORMAL
- en: Abstract
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Serverless computing is one of the most preferred deployment strategies in today’s
    world. It refers to a concept where execution environment is not predefined during
    deployment, but scaled based on demand. The concept has gained importance with
    improvements in cloud computing, which banks on this concept. Nowadays, cloud
    service providers are able to expose this concept as a cloud service itself, with
    application like GCP Cloud Functions and AWS Lambda. But as services go online,
    securing them becomes a challenge. Serverless computing was originally envisaged
    as a stateless environment, but now it has evolved to semi-stateful entities,
    making them prone to state analysis and hijacking. With current cryptosystems
    being outmatched at a fast pace, and quantum computing expected to break almost
    all cryptographic algorithms in the coming decade, it is imperative that serverless
    communications be encrypted in a much more secure fashion. A concept based on
    quantum key distribution and blockchain is proposed to improve application scaling
    and security. Blockchain platforms like Ethereum work based on smart contracts,
    which can execute pieces of code on the nodes and place results on the blockchain
    after consensus. The same can be adapted to serverless computing because smart
    contract codebase is deployed on the node itself, and is triggered by user requests.
    The user-defined function can then be deployed as a smart contract. When demand
    is huge, more nodes can be spun up, which contain the codebase for the smart contract,
    and they can initiate execution. In order to enhance security, the communication
    between endpoints can be protected by using Quantum Key Distribution, and even
    among the nodes, selections can be done using principles behind QKD. After execution
    is complete, the result is placed on the blockchain itself, which acts as a log
    of execution, as well as carry the result.
  prefs: []
  type: TYPE_NORMAL
- en: 1 Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Serverless computing is a concept that has gained importance over the last decade,
    with the rise in popularity of cloud computing. As per popular cloud service providers
    like AWS and Azure, *serverless computing* allows the user to build applications
    that can be run over the internet, without worrying about underlying infrastructure.
    The term *serverless* doesn’t refer to the absence of servers entirely. It simply
    refers to the transparent nature of the whole ecosystem so that the user doesn’t
    feel there is a server in between them and the execution environment.
  prefs: []
  type: TYPE_NORMAL
- en: The transparency offered by cloud providers is achieved by a complex framework
    of *autoscaling* programs that constantly monitor the demand on servers and automatically
    start/stop new instances of the server. The transparency also removes many aspects
    of security from the user’s control. While these are advantageous from a deployment
    point of view, it does pose a risk when the user is not aware of what is happening
    in the background. It provides developers with a simplified programming model
    for rapid application development and deployment, abstracting away underlying
    complexities, cheaper deployment (since cloud providers support as pay-as-you-go
    model), better code templates, and coordination. But at the same time, there is
    little control over platform design decisions that control QoS, scaling, and fault
    tolerance  [[1](#CR1)–[3](#CR3)].
  prefs: []
  type: TYPE_NORMAL
- en: This chapter provides an insight towards how technologies like blockchain and
    quantum computing can help in ensuring scalability and security of serverless
    computing platforms. Section [2](#Sec2) discusses the architecture of serverless
    computing and how it evolved from basic client-server models. Section [3](#Sec5)
    gives an insight into the concept behind blockchain, how it is popularly deployed,
    and aspects like smart contracts that can come in handy when integrating with
    serverless computing. Section [4](#Sec8) gives an overview of quantum physics
    and their role in developing a new programming and execution paradigm. Section
    [5](#Sec10) discusses about different opportunities to include blockchain in serverless
    platforms, while Sect. [6](#Sec11) talks about security loopholes and management.
    The discussion is consolidated in Sect. [7](#Sec14), where a model is proposed
    to combine all advantages discussed till then, and how it can be architected.
  prefs: []
  type: TYPE_NORMAL
- en: 2 Serverless Computing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cloud computing has gained a lot of importance and popularity over the last
    few years, especially since applications began to get migrated to microservice
    architectures  [[1](#CR1)]. Conventional software packages were highly cohesive,
    with all capabilities embedded into their own modules inside the same package.
    But with microservice architecture, developers were able to migrate each module
    individually into their own packages, and deploy them independently. This was
    supported by advances in client-server computing, which enabled services to offload
    their computing to the server, and client limited to providing basic processing,
    and rendering inputs and results.
  prefs: []
  type: TYPE_NORMAL
- en: When we consider the philosophy of cloud computing, there are three levels of
    deployment which are popularly considered.
  prefs: []
  type: TYPE_NORMAL
- en: IaaS
  prefs: []
  type: TYPE_NORMAL
- en: Infrastructure-as-a-Service (IaaS) is the deployment strategy where *bare-bones*
    infrastructure is provided, which contains only the storage, compute, and networking
    infrastructure. All installations, software configurations, and management is
    required to be done by the user. Only physical security and infrastructure maintenance
    falls under the responsibility of the service provider.
  prefs: []
  type: TYPE_NORMAL
- en: PaaS
  prefs: []
  type: TYPE_NORMAL
- en: Platform-as-a-Service adds the software layer on top of IaaS. Basic software
    is provided either off the shelf, or as a readily installable package. Developers
    may use the provided resources to build their applications. In this case, physical
    security and infrastructure management is still managed by the service provider,
    but updating and securing the software from the user side is still under the responsibility
    of developers.
  prefs: []
  type: TYPE_NORMAL
- en: SaaS
  prefs: []
  type: TYPE_NORMAL
- en: Software-as-a-Service refers to the cloud application services, which are fully
    hosted and managed by service providers. An example of the same is Gmail, which
    is fully managed by Google. Here, everything except the end user security is managed
    by the service provider.
  prefs: []
  type: TYPE_NORMAL
- en: Serverless computing can be thought of as a platform that is a mix of these.
  prefs: []
  type: TYPE_NORMAL
- en: 2.1 Going Serverless
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before serverless and cloud computing became popular, the domain was controlled
    by *distributed computing*. In this paradigm, the required processing and storage
    capability is distributed among a set of participating nodes, each housing a fully
    autonomous unit. When data is to be stored, it is migrated to two or more nodes
    (which is called *replication*) to ensure availability in case of failures. Processes
    are also replicated appropriately and done close to the location of their data.
  prefs: []
  type: TYPE_NORMAL
- en: Serverless computing is an execution model based on cloud computing in which
    the cloud service provider automatically allocates, manages, scales, and deallocates
    compute services based on demand. In short, server management is transferred from
    the developer to cloud service provider. This is extremely useful in scenarios
    where execution is in the form of short bursts, rather than consistent loads.
    Data input and output is managed from persistent storage.
  prefs: []
  type: TYPE_NORMAL
- en: From a cloud provider point of view, serverless computing provides an opportunity
    to control the development stack, efficient optimization and management of cloud
    resources (making the entire process cheaper), encourage usage of native applications,
    and attract audience by lowering the effort needed to create applications.
  prefs: []
  type: TYPE_NORMAL
- en: The concept shows strong similarity to that of SaaS, since both share the philosophy
    of automatic management and provisioning. But the major difference between both
    of them lies in the workload that gets executed. While SaaS is tuned for persistent
    and consistent workloads that need to be available round the clock, serverless
    is useful for intense workloads that last for a short duration. This is popularly
    implemented using a concept called **Function-as-a-Service (FaaS)**, which is
    in fact, a subset of the serverless paradigm. All major cloud service providers
    (CSPs) have their own offering for serverless platforms. The list of popular services
    are given in Table [1](#Tab1), and an extensive evaluation of production grade
    platforms is available in [[4](#CR4), [5](#CR5)]. Open source implementations
    like Kubeless, OpenWhisk, Fission, and OpenFaaS are also available for serverless
    platforms [[6](#CR6)].Table 1
  prefs: []
  type: TYPE_NORMAL
- en: Serverless provisions of popular CSPs
  prefs: []
  type: TYPE_NORMAL
- en: '| Service | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| AWS Lambda | The service was named after lambda calculus, which popularized
    functional execution. Lambda uses micro-VMs using Kernel-based Virtual Machines
    for rapid provisioning and low overhead. Code can be directly deployed using the
    raw source code, or as a built-up version using containers. The platform supports
    Node.js, Python, Go, Java, etc. The concept of serverless was made popular with
    the announcement of Lambda [[1](#CR1)] |'
  prefs: []
  type: TYPE_TB
- en: '| Azure Functions | A managed service provided by Azure, that can be used to
    build web APIs (with inbuilt support for HTTP web hooks), respond to database
    changes, process IoT streams, manage message queues, etc. with deployment support
    for external pipelines also. Stateful behavior is also supported using *Azure
    Durable Functions* with the help of orchestrator functions and entity functions
    |'
  prefs: []
  type: TYPE_TB
- en: '| Google Cloud Run | Enables development and deployment of containerized apps.
    It supports languages like Java, Go, Python, Ruby, and Node.js |'
  prefs: []
  type: TYPE_TB
- en: '| Google App Engine | Fully managed platform and developer environment with
    completely elastic compute and storage management |'
  prefs: []
  type: TYPE_TB
- en: '| Google Cloud Functions | The pay-as-you-go FaaS implementation provided by
    GCP, with support for hybrid cloud and multi-cloud scenarios |'
  prefs: []
  type: TYPE_TB
- en: '| IBM Cloud Code Engine | Description |'
  prefs: []
  type: TYPE_TB
- en: '| Red Hat OpenShift Serverless | It is based on the open source KNative project.
    The project extensively uses Kubernetes controllers and definitions to execute
    serverless tasks. The focus is placed on (i) building containers, (ii) handling
    events to trigger containers, and (iii) rapid deployment and automatic scaling
    |'
  prefs: []
  type: TYPE_TB
- en: A general architecture of serverless platforms is given in Fig. [1](#Fig1).![](../images/516210_1_En_5_Chapter/516210_1_En_5_Fig1_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 1
  prefs: []
  type: TYPE_NORMAL
- en: General architecture of serverless computing [[1](#CR1)]
  prefs: []
  type: TYPE_NORMAL
- en: The advantages of serverless computing are as follows [[7](#CR7), [8](#CR8)].
  prefs: []
  type: TYPE_NORMAL
- en: '**Lower costs**—Most CSPs run serverless under a pay-as-you-go model [[9](#CR9)].
    It has to be noted that serverless can scale to even zero instances, thereby costing
    nothing at all [[1](#CR1)]. Splitting the task into microservices running in parallel
    is highly cost effective for tasks that can be parallelized.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simplified scalability**—Since autoscaling is given as part of the platform,
    scaling policies can be avoided.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simplified backend code**—Modularity can be maximized since each function
    is supposed to do a fixed, minimum task. Serverless functions typically execute
    a single main function that takes data (mostly in JSON format) as input, and produces
    a similar format as output [[1](#CR1)]. It also enables developers to focus on
    code (in a language of their choice), not infrastructure. CSPs prefer serverless
    code to be triggered as API calls. If any complex operation is needed, it is preferred
    to use cascaded calls [[10](#CR10)].'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Quicker turnaround**—Deployment is nearly instantaneous. If the code can
    be packaged to a container [[11](#CR11)], it can be repeatably deployed with minimal
    delay.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But serverless comes with some tradeoffs.
  prefs: []
  type: TYPE_NORMAL
- en: Serverless doesn’t offer savings for workloads characterized by predictable,
    steady or long-running processes. Conventionally, serverless code executes for
    a maximum of 15 min, before they are swapped out for another allocation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serverless applications sometimes need to start up from scratch to serve a new
    request. It may be a concern for low latency applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing and monitoring the environment may be challenging if there are a lot
    of functions. On evaluation by [[12](#CR12)], it was found that serverless architectures
    tend to overprovision resources to manage initialization overhead when the process
    has to be started from scratch.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vendor lock-in may be required if the code uses vendor-specific libraries.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serverless deployments are stateless by definition. Hence subsequent invocations
    may get routed to different VMs, making any persistent storage difficult. Any
    such storage will result in I/O bottlenecks, eliminating the performance advantage
    given by FaaS [[13](#CR13)].
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No specialized hardware is available to support serverless computing [[13](#CR13)].
    As cloud processes are ephemeral, each invocation may run on hardware at different
    location, making cost unpredictable [[14](#CR14)].
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hardware heterogeneity will have to be taken into consideration when designing
    functions. If the program is tightly tuned with a particular architecture in mind,
    it may fail or perform below par when provisioned on any other architecture [[14](#CR14)].
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The technology stack for implementing serverless architectures will need to
    take into consideration a number of components. Serverless refers to FaaS and
    other associated cloud services and resources for which configuration, management
    and billing of services are invisible to the user. The major components that will
    be need designing are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Functions as a Service (FaaS):** It represents the core compute (processing)
    engine in serverless. It is conventionally developed using languages like Java,
    Python, Go, etc. and deployed either as program itself, or as a container. Another
    option is to use WebAssembly [[15](#CR15)], which has its limitations in capability
    since the native code should be in C or C++, but is extremely efficient during
    execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Serverless databases and storage:** It involves transitioning away from provisioning
    SQL and NoSQL instances that scale linearly with demand in both infrastructure
    and pricing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event streaming and messaging:** Event-driven and stream-processing workloads
    (like Apache Kafka) need to be supported.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**API gateways:** Invocation is best done via gateways, which can be configured
    for security and load balancing as needed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2.2 Shared Responsibility Model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the operational principles in cloud security is that of shared responsibility
    model.
  prefs: []
  type: TYPE_NORMAL
- en: Shared Responsibility model states that cloud service providers ensure security
    of the cloud, whereas security in the cloud is the responsibility of the developer
    and user.
  prefs: []
  type: TYPE_NORMAL
- en: This means that CSPs ensure physical security of cloud infrastructure from any
    tampering, and provide enough replication to keep the availability of stored data.
    But the provider won’t be responsible for any data loss or data leak due to improper
    security practices in applications developed on that (except SaaS, where CSPs
    are responsible for the service also). Shared responsibility also states that
    users are solely responsible for the security of their login credentials. Even
    though many providers now give additional facilities like Multi Factor Authentication,
    it is up to the user to safeguard their credentials.
  prefs: []
  type: TYPE_NORMAL
- en: This brings us to the requirement of secure communication between client and
    server in serverless applications also. If the communication is not properly secured,
    it will be open to any eavesdropper or malicious entity, thereby leading to unexpected
    data loss and disclosure. More discussion on security in serverless domain is
    done in Sect. [6](#Sec11).
  prefs: []
  type: TYPE_NORMAL
- en: 3 Blockchain
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Blockchain is a distributed ledger framework that is popularly known as the
    foundation of Bitcoin. It is made up of a series of transactions stored on *blocks*,
    with blocks connected to each other using a *chain* of links. Any transaction
    that is committed and gets logged into the chain must be agreed upon by majority
    of participants in the distributed system through a method called *consensus*
    [[16](#CR16), [17](#CR17)].
  prefs: []
  type: TYPE_NORMAL
- en: Links are created using hash values, with each block storing the hash value
    of the previous block also. This makes the chain tamper-evident, since a change
    in any previous block will automatically invalidate all subsequent hashes. This
    property of blockchain makes it suitable for maintaining data logs. There are
    four main characteristics which make blockchain useful [[18](#CR18), [19](#CR19)].
  prefs: []
  type: TYPE_NORMAL
- en: '**Decentralization**—The need of any third party moderator or validator is
    eliminated with the help of distributed consensus. A transaction is said to be
    committed only after a majority of nodes in the blockchain agree that it is valid.
    This also makes it hard to forge a new entry.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Persistent**—Once added, it is difficult to remove any entry from the chain
    because it is inherently tamper-evident.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Anonymous**—Users interact with chains using a generated address, which is
    difficult to trace back to the original user. This is taken advantage of in cryptocurrencies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Auditability**—Any transaction can be traced back to the original entry,
    since data cannot be erased from the chain. In Bitcoin, this is done using the
    *Unspent Transaction Output* entry.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another application domain of blockchain is in transaction code execution, which
    is made possible using the concept of **smart contracts**. They are small pieces
    of code that are executed when a transaction is deemed successful.
  prefs: []
  type: TYPE_NORMAL
- en: 3.1 Blockchain Architecture
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A general architecture of blockchain is given in Figs. [2](#Fig2) and [3](#Fig3).![](../images/516210_1_En_5_Chapter/516210_1_En_5_Fig2_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 2
  prefs: []
  type: TYPE_NORMAL
- en: General architecture of blockchain [[18](#CR18)]
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/516210_1_En_5_Chapter/516210_1_En_5_Fig3_HTML.png)'
  prefs: []
  type: TYPE_IMG
- en: Fig. 3
  prefs: []
  type: TYPE_NORMAL
- en: Structure of a block [[18](#CR18)]
  prefs: []
  type: TYPE_NORMAL
- en: A block consists of a *block header* followed by *block body* [[18](#CR18),
    [19](#CR19)]. Transactions are managed with the help of a merkel tree, which creates
    hash values based on a tree-like arrangement of elements. The root of a merkel
    tree will represent the hash of all elements under it. This is added to the block
    header. The header also contains recordkeeping information like version, timestamp,
    etc., followed by the hash of previous block. All transaction information is maintained
    in the block body.
  prefs: []
  type: TYPE_NORMAL
- en: Consensus is the core of any blockchain ecosystem. This is since transactions
    cannot be added to the chain unless there is approval from majority of participating
    nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Two popular consensus algorithms are considered here.
  prefs: []
  type: TYPE_NORMAL
- en: '1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Proof of Work (PoW)**—In PoW, each node of the network (called a *miner*)
    calculates a hash value of the block header for authority to initiate a transaction
    (called *mining*). A value called *nonce* is present in the header, which is tweaked
    to change the hash value. In order to start a transaction, the computed hash should
    be less than a predetermined threshold. If a node reaches that threshold, the
    status is broadcast to all nodes, and everyone needs to validate that block. On
    validation, nodes add the block to their chain. If multiple miners generate valid
    blocks simultaneously, the chain is forked at that point, and eventually shorter
    forks are discarded. Even though the process is quite effective, it is computationally
    expensive.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Proof of Stake (PoS)**—It is an energy-saving alternative to PoW where miners
    prove authority based on the amount of currency held by them. Here, mining cost
    is nearly zero. The nodes need to broadcast their account balance and the network
    reaches a consensus on who can add the next block.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If we want to draw parallels between blockchain and conventional databases,
    we need to consider database read and write operations. In blockchain, *writing*
    is analogous to creating consensus in the blockchain and adding a new block. *Reading*
    simply involves reading and auditing the entries in blockchain [[20](#CR20)].
    Considering that there are analogous operations, decision needs to be made on
    when blockchain becomes important. This is explained in details using a simple
    illustration in [[20](#CR20)], which is given in Fig. [4](#Fig4).![](../images/516210_1_En_5_Chapter/516210_1_En_5_Fig4_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 4
  prefs: []
  type: TYPE_NORMAL
- en: When to use blockchain [[20](#CR20)]
  prefs: []
  type: TYPE_NORMAL
- en: Hyperledger and Ethereum are two popular implementations of blockchain [[21](#CR21)].
    Hyperledger follows the traditionalist model, wherein the user has control over
    the data, and the entire processing is based on how information moves across the
    chain. Ethereum considers the problem in a different perspective. It is a permissionless
    platform, which implements the concept of smart contracts through a scripting
    platform. For that, it makes use of the *Ethereum Virtual Machine (EVM)*, which
    enables us to strike parallels with the micro-VMs of serverless computing. Such
    diverse implementations have enabled blockchain to find applications in a number
    of domains like Internet of Things, healthcare, supply chain, governance, etc.
    A functional description is given in [[19](#CR19)], which is depicted in Fig. [5](#Fig5).![](../images/516210_1_En_5_Chapter/516210_1_En_5_Fig5_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 5
  prefs: []
  type: TYPE_NORMAL
- en: Functional architecture of blockchain [[19](#CR19)]
  prefs: []
  type: TYPE_NORMAL
- en: 3.2 Smart Contracts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Smart contracts open up an avenue to incorporate executable codes into blockchain.
    They enable higher order functions and a level of complexity to be added to the
    conventional blockchain framework. This is quite useful in applications like real
    estate management and supply chain management, where every transaction needs to
    be validated not only from the blockchain point of view, but in terms of the data
    contained within. The concept of smart contract can be used like a database trigger
    to inspect the contents being logged into the chain once ready. They also allow
    specific computations to be performed so that the transaction is completed (analogous
    to signing the physical sale letter, smart contracts may be considered as digitally
    signing a sale letter).
  prefs: []
  type: TYPE_NORMAL
- en: A smart contract is an encapsulation of functions (code) and state (data) that
    is deployed using signed transactions on the blockchain network [[22](#CR22)].
    This contract is executed by nodes within the blockchain network and the results
    of execution are recorded on the blockchain. In many cases, the publishing nodes
    execute the contract when publishing new blocks. In some implementations, nodes
    only validate the results of the nodes that are publishing.
  prefs: []
  type: TYPE_NORMAL
- en: Based on the complexity of the code, there is a time limit on how long a contract
    can execute. Any violation of this time limit will result in forced termination
    of the contract execution, and the transaction is discarded. This prevents malicious
    users from deploying and executing smart contracts that can potentially lead to
    denial of service attacks. For conventional blockchain implementations, executing
    a smart contract will incur a small fee, which is deducted from their stake. But
    for permissioned blockchain networks, this may not be required since users are
    known in advance, and other methods of preventing malicious execution can be used
    (like removing access rights).
  prefs: []
  type: TYPE_NORMAL
- en: 4 Quantum Computing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: According to Li et al [[23](#CR23)], quantum computing combines the capabilities
    of quantum mechanics and computer science. While the elementary unit of computation
    in a conventional computational unit is the *bit*, quantum computers perform computations
    in terms of *qubit* (quantum bit). A qubit can be considered as a two-level atom.
    The advantage of quantum entities is that they can be in super-position of basic
    states. This means that all of these numbers represented by the basic states can
    be manipulated simultaneously, leading to opportunities for enormous parallelism.
    This is a huge paradigm shift from the conventional computing model which was
    based on boolean algebra, turing machine, and lambda calculus.
  prefs: []
  type: TYPE_NORMAL
- en: Quantum computation requires the following to be in place before processing
    can begin.
  prefs: []
  type: TYPE_NORMAL
- en: A two-level system to ensure compatibility with conventional binary logic (represented
    as |0> and |1>)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initial state for the qubit (one of the levels mentioned above)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A method to measure the state of qubit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Construction of basic gate operations (analogous to boolean logic)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decoherence time, which ensures the system attains stability after any interaction
    with the surroundings and within itself.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One of the important features of quantum models is that of entanglement.
  prefs: []
  type: TYPE_NORMAL
- en: Entanglement states that, measurements of one particle affect measurements of
    another. It creates a virtual synchronization mechanism between qubits [[24](#CR24)].
  prefs: []
  type: TYPE_NORMAL
- en: Considering entanglement, any state of superposition in quantum computing can
    be represented as follows.![$$\begin{aligned} |\psi&gt; = \alpha |0&gt; + \beta
    |1&gt; \end{aligned}$$](../images/516210_1_En_5_Chapter/516210_1_En_5_Chapter_TeX_Equ1.png)(1)This
    representation can be directly converted to the Hilbert space by giving corresponding
    base vectors. This gives rise to the following mathematical model.![$$\begin{aligned}
    |0&gt; = \begin{bmatrix}1 \\ 0 \end{bmatrix} \end{aligned}$$](../images/516210_1_En_5_Chapter/516210_1_En_5_Chapter_TeX_Equ2.png)(2)![$$\begin{aligned}
    |1&gt; = \begin{bmatrix}0 \\ 1 \end{bmatrix} \end{aligned}$$](../images/516210_1_En_5_Chapter/516210_1_En_5_Chapter_TeX_Equ3.png)(3)![$$\begin{aligned}
    |\psi&gt; = \alpha |0&gt; + \beta |1&gt; = \begin{bmatrix}\alpha \\ \beta \end{bmatrix}
    \end{aligned}$$](../images/516210_1_En_5_Chapter/516210_1_En_5_Chapter_TeX_Equ4.png)(4)For
    two qubits, we can generate a 4-dimensional basis, with four coefficients of superposition.
    The same can be converted to the Hilbert space also as seen earlier.![$$\begin{aligned}
    |\psi&gt; = \alpha |00&gt; + \beta |01&gt; + \gamma |10&gt; + \delta |11&gt; \end{aligned}$$](../images/516210_1_En_5_Chapter/516210_1_En_5_Chapter_TeX_Equ5.png)(5)![$$\begin{aligned}
    \Longrightarrow |\psi &gt; = \alpha \begin{bmatrix}1\\ 0\\ 0\\ 0 \end{bmatrix}
    + \beta \begin{bmatrix}0\\ 1\\ 0\\ 0 \end{bmatrix} + \gamma \begin{bmatrix}0\\
    0\\ 1\\ 0 \end{bmatrix} + \delta \begin{bmatrix}0\\ 0\\ 0\\ 1 \end{bmatrix} =
    \begin{bmatrix}\alpha \\ \beta \\ \gamma \\ \delta \end{bmatrix} \end{aligned}$$](../images/516210_1_En_5_Chapter/516210_1_En_5_Chapter_TeX_Equ6.png)(6)This
    concept enables us to extend a N-state system to a 2^N-state system with different
    levels of superposition. This has led to the generation of a number of quantum-based
    computational models like Quantum Turing Machine, Quantum circuits, etc. The concept
    is explained well in the 2014 thesis by Markus Kiili. The ideal state of the system
    is termed as the *normalized* state, which is characterized by the sum of squares
    of superposition coefficients becoming 1.![$$\begin{aligned} \alpha ^{2} + \beta
    ^{2} = 1 \end{aligned}$$](../images/516210_1_En_5_Chapter/516210_1_En_5_Chapter_TeX_Equ7.png)(7)![$$\begin{aligned}
    \alpha ^{2} + \beta ^{2} + \gamma ^{2} + \delta ^{2} = 1 \end{aligned}$$](../images/516210_1_En_5_Chapter/516210_1_En_5_Chapter_TeX_Equ8.png)(8)If
    the condition cannot be met, manual normalization may be needed [[25](#CR25)].
  prefs: []
  type: TYPE_NORMAL
- en: 4.1 Quantum Key Distribution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It has been estimated that quantum computers will be able to break current cryptographic
    algorithms using brute force itself [[26](#CR26)]. Security systems like in blockchain
    rely on one-way codes (like hashes) that are easily computable in the forward
    direction, but computationally difficult to reverse engineer. Two such common
    methods are *Integer Factorization Problem* and *Discrete Logarithm Problem*.
    Shor’s factorization algorithm [[27](#CR27)] gave an insight towards how quantum
    computing and entanglement can create shortcuts in executing massively parallel
    tasks. While the complexity of the algorithm remains the same, qubits allow multiple
    combinations to be tried out in parallel, thereby reducing the required time to
    a great extent.
  prefs: []
  type: TYPE_NORMAL
- en: Quantum computing itself gives a solution to this. It works by harnessing the
    property of entanglement which states that measurement of one particle affects
    the measurement of its pair.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, communications using quantum computing are inherently authenticated,
    and fundamental principles of physics states that quantum states cannot be copied
    or measured without alteration. Hence, any eavesdropper will immediately leave
    a mark, and is detected. This is the fundamental principle behind **Quantum Key
    Distribution (QKD)**.
  prefs: []
  type: TYPE_NORMAL
- en: A comprehensive description of the concept is available in [[28](#CR28)]. QKD
    uses quantum states to establish a random key for cryptography. Here, data is
    sent across an optical channel, which is best suited for encoding quantum information.
    The sequence of actions are as follows, considering a communication between Alice
    and Bob.
  prefs: []
  type: TYPE_NORMAL
- en: '1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Alice sends to Bob 2n qubits, each prepared in one of the states |0>, |1>, |+>,
    |-> randomly chosen. Since communication is optical, this may be done using polarizers.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bob measures the received bits, choosing the measurement basis randomly between
    |0>,|1> and |+>,|->. This can be achieved using polarity filters.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '3.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Alice and Bob inform each other publicly of the basis they used to prepare or
    measure each qubit.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '4.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Both find out on which occasions they used the same basis. This happens on average
    half the time. Those occasions in which same basis is used are retained.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '5.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ideally, they now share the same random string of n qubits, which are then mapped
    to classical bits (for example, |0> and |+> map to 0, |1> and |-> map to 1). This
    bit string is called RQT (*Raw Quantum Transmission*).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '6.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Alice and Bob announce a randomly chosen (and predefined) set of n/2 bits from
    the RQT. If all those bits match, the undisclosed n/2 bits are accepted as the
    key. Otherwise it is discarded and a fresh transmission is initiated.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: While the algorithm seems straightforward, the fundamental principle of quantum
    entanglement is used here. Alice and Bob don’t disclose the data being sent across.
    Only the basis used for each instance is disclosed publicly, and it is ineffective
    to an eavesdropper as long as the original qubit stream is absent. If an eavesdropper
    manages to intercept the bit stream, the qubit will change in orientation, and
    that bit won’t match in the RQT. Taking a probabilistic estimate, if an eavesdropper
    was listening to the entire transmission, it would have changed the orientation
    of all bits, and it should be detectable using just 50% of the RQT (since it is
    a binary system). This is achieved in Step 6 of the process given above. The advantage
    of this method is that a majority of the algorithm can be directly implemented.
    But challenge remains in the realm of long distance transmission, since optical
    communication needs to be reliable not only in terms of intensity, but in terms
    of polarity also. The QKD procedure is illustrated in *Quantum Flagship*, which
    is given in Fig. [6](#Fig6).![](../images/516210_1_En_5_Chapter/516210_1_En_5_Fig6_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 6
  prefs: []
  type: TYPE_NORMAL
- en: 'Working of QKD *(Courtesy: Quantum Flagship)*'
  prefs: []
  type: TYPE_NORMAL
- en: 5 Blockchain in Serverless Computing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Tien et al. [[29](#CR29)] has introduced a data-centric view of blockchain.
    It breaks the ecosystem down into four layers, each dealing with a different type
    of data item. The layers are as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Consensus:** It deals with data that prove authority of adding new data into
    the chain. As part of that, values like nonce, stake, etc. may be transferred
    and validated.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Data model:** It refers to the actual data being processed in the chain.
    It may comprise of transaction data, indices, blocks, etc. Those who qualify after
    consensus get the authority to generate an instance of the data model and write
    it to block after approval.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '3.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Execution engine:** It denotes processing done on the data model. It may
    be pieces of code run on VMs, containers, etc.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '4.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Application:** It refers to the application layer code, embedded in the form
    of smart contracts, that get executed within the execution engine.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The layered architecture diagram from [[29](#CR29)] has been adapted in Fig. [7](#Fig7).![](../images/516210_1_En_5_Chapter/516210_1_En_5_Fig7_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 7
  prefs: []
  type: TYPE_NORMAL
- en: Layered architecture—A data centric view of blockchain [[29](#CR29)]
  prefs: []
  type: TYPE_NORMAL
- en: Considering the layered stack discussed in [[29](#CR29)], an abstract model
    can be created wherein parallels can be established between blockchain implementations
    and serverless platforms. This will enable easier integration of blockchain into
    serverless frameworks. The possibility is explored in Table [2](#Tab2).Table 2
  prefs: []
  type: TYPE_NORMAL
- en: Possibility of integrating blockchain into serverless platforms
  prefs: []
  type: TYPE_NORMAL
- en: '| Blockchain layer | Use in serverless platforms |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Consensus | When there are excessive number of requests to be handled, serverless
    platforms can automatically scale the processing capability by adding more virtual
    machines. Consequently, there will be a number of nodes concurrently waiting for
    new requests. Consensus methods can be used by the load balancer to select which
    node should accept the request |'
  prefs: []
  type: TYPE_TB
- en: '| Data model | Serverless platforms use request-response model of execution.
    This involves request header, request body, response code, response header, and
    response payload. Requests are directly forwarded to the selected node, which
    can execute it, and return the result. Prior to sending the result, the request
    and response data should be logged to the blockchain after validation |'
  prefs: []
  type: TYPE_TB
- en: '| Execution engine | This may be a micro-VM or container on which the server
    code should run. While one node is selected for execution, others may have to
    validate the output by running their own code and verifying if the output is as
    advertised. Depending on the language of choice, the container or VM can be installed.
    The Ethereum platform already supports EVM for running its smart contracts |'
  prefs: []
  type: TYPE_TB
- en: '| Application | Whenever a new request comes, it is logged as a transaction
    and the smart contract is initiated. The smart contract will contain the actual
    code to be executed, and the output is written to the chain after validation |'
  prefs: []
  type: TYPE_TB
- en: FBaaS [[30](#CR30)] is an implementation which provides blockchain as a cloud-like
    service. It comprised of the following layers.
  prefs: []
  type: TYPE_NORMAL
- en: '1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Infrastructure layer* set up on regular compute nodes (not serverless).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Components layer* to handle authentication and authorization operations, that
    are commonly used in execution. *Role Based Access Control* is used for this purpose.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '3.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Services layer* that houses the blockchain code to be executed. It takes care
    of object storage, transaction initiation, mining, chain management, and conflict
    resolutions (in case of inconsistency). It also performs autoscaling by deploying
    containers as needed. This process is referred to as *Function Server*.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '4.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Business logic layer* that exposes the services to be used by participants.
    Abstractions can be added on top of existing layers to extend the functionality.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ChainFaaS [[31](#CR31)] is an implementation that uses blockchain to implement
    a serverless platform. The role of blockchain in the architecture is to maintain
    a log of execution, and keep track of financial transactions (which are given
    as an execution fee to the service provider). It implements the architecture discussed
    above in a different way.
  prefs: []
  type: TYPE_NORMAL
- en: '1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Blockchain network* takes care of logging and keeps track of execution fee.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Serverless controller* is the interface to the outside, and maintains the
    scheduling part.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '3.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Execution network* is responsible for maintaining and deploying containers
    and VMs to perform execution.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Yet another implementation of microservices using blockchain was discussed in
    [[32](#CR32)]. It created a comparison between conventional serverless API-based
    implementations, and blockchain-based implementations. In the architecture proposed
    in [[32](#CR32)], microservices are directly written as smart contracts, similar
    to that done by APIs. These smart contracts may use remote procedure calls to
    access external entities. The architecture from [[32](#CR32)] is given in Fig. [8](#Fig8).![](../images/516210_1_En_5_Chapter/516210_1_En_5_Fig8_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 8
  prefs: []
  type: TYPE_NORMAL
- en: API versus Blockchain—Implementing microservices [[32](#CR32)]
  prefs: []
  type: TYPE_NORMAL
- en: The three implementations seen above can be compared in terms of the generic
    architecture discussed in Table [2](#Tab2). The comparison is given in Table [3](#Tab3).Table
    3
  prefs: []
  type: TYPE_NORMAL
- en: Comparison of FBaaS, ChainFaaS and Microservices architectures
  prefs: []
  type: TYPE_NORMAL
- en: '| Blockchain layer | FBaaS [[30](#CR30)] | ChainFaaS [[31](#CR31)] | Microservices
    [[32](#CR32)] |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Consensus | Services layer | Blockchain network | Blockchain layer |'
  prefs: []
  type: TYPE_TB
- en: '| Data model | Services layer | Blockchain network | Blockchain layer |'
  prefs: []
  type: TYPE_TB
- en: '| Execution engine | Services layer | Execution network | API gateway and blockchain
    layer |'
  prefs: []
  type: TYPE_TB
- en: '| Application | Business logic layer | Serverless controller | API frontend
    |'
  prefs: []
  type: TYPE_TB
- en: 6 Quantum Key Distribution in Serverless Computing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 6.1 Security in Serverless Domain
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Eric et al. [[14](#CR14)] have listed the most important security issues caused
    exclusively due to serverless computing. While this paradigm suffers from all
    security loopholes in terms of authentication and protocol-level breaches, the
    fact that there is limited control over resource provisioning raises some additional
    dangers. The dangers are due to application disintegration for modularity, and
    relocation for load balancing. The important security challenges to be considered
    are as follows.
  prefs: []
  type: TYPE_NORMAL
- en: Physical isolation may have to ensured so that no attacker can gain colocated
    access to any other process. Since cloud processes are ephemeral, there is a chance
    that an attacker can gain access to an unprotected process in the middle of their
    execution.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fine-grained security management may be required since security policies have
    to be enforced at each node where the code is executed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As large applications get disintegrated to small functions, they will have to
    maintain communication between themselves so that continuity is maintained. As
    part of that, intermediate outputs will have to be transferred between API calls.
    This transfer may leak patterns and sensitive information even if it is protected
    end to end.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If any external service is accessed from within the function (like external
    databases), access privilege needs to be exposed to all possible hosting locations
    for the function. Otherwise certain accesses will be blocked since they are not
    in the allowed list [[2](#CR2)].
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 6.2 Using QKD as a Security Mechanism
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The concept of Quantum Key Distribution was introduced in Sect. [4.1](#Sec9).
    Scarani et al. [[33](#CR33)] have verified the proof of a practical QKD algorithm
    called BB84, and evaluated the effectiveness of different transmitters and channels
    in their working. Shor and Preskill [[34](#CR34)] evaluated the same considering
    overlapping quantum states, and found that the algorithm is resistant enough to
    thwart most attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Kiktenko et al. [[35](#CR35)] demonstrated a model in which blockchain itself
    can be secured using QKD. It is designed on top of a two-layer arrangement. QKD
    can securely generate symmetric keys. Hence layer 1 will be a mesh network that
    runs QKD between all pairs of nodes, thereby generating unconditionally secure
    keys between all of them. Layer 2 will be a conventional network that uses the
    securely generated private keys to perform further transmission. It also changes
    the framework by which new blocks are mined. Since quantum computers are empowered
    with massive inherent parallelism (because of superposition, they are in multiple
    states at once), a sufficiently powerful quantum computer can create enough blocks
    simultaneously to overwhelm the security and execute a 51% attack. Instead, the
    proposal in [[35](#CR35)] enforces a broadcast for each block, and individual
    approvals have to be obtained. The protocol performs periodic checks on the integrity
    of all chains. They were able to demonstrate it successfully on a small scale
    using optically modulated qubits.
  prefs: []
  type: TYPE_NORMAL
- en: A number of cryptographic models that can survive a post-quantum ecosystem [[36](#CR36)]
    is described in [[37](#CR37)]. Rajan et al. [[38](#CR38)] takes it one step further
    and changes the notion of entanglement itself. They propose encoding the photons
    into a *Greenberger-Horne-Zeilinger (GHZ) state*, which ensures that simultaneous
    coexistence of superpositions don’t happen in space, but happens in time. This
    means that if there is a qubit state ![$$\psi $$](../images/516210_1_En_5_Chapter/516210_1_En_5_Chapter_TeX_IEq1.png)
    at time t ![$$=$$](../images/516210_1_En_5_Chapter/516210_1_En_5_Chapter_TeX_IEq2.png)
    0, there is a possibility to generate the same state ![$$\psi $$](../images/516210_1_En_5_Chapter/516210_1_En_5_Chapter_TeX_IEq3.png)
    at some t ![$$=$$](../images/516210_1_En_5_Chapter/516210_1_En_5_Chapter_TeX_IEq4.png)
    k. Hence the key need not be passed on immediately, and it could be regenerated
    at a later point of time. But it results in an increased risk of tampering, since
    changing the state at t=0 could potentially affect the working at its entangled
    time t ![$$=$$](../images/516210_1_En_5_Chapter/516210_1_En_5_Chapter_TeX_IEq5.png)
    k.
  prefs: []
  type: TYPE_NORMAL
- en: 7 Integrating QKD and Blockchain into Serverless Domain
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As seen in previous sections, the crux of serverless platform is rapid resource
    provisioning and code execution. Both seem to be well taken care of using smart
    contracts on Ethereum. In addition, shared responsibility model of CSPs place
    the responsibility of security in the cloud on the developers and users themselves.
    This can be taken care of using cryptographic methods. Here, a method is proposed
    that uses blockchain and Quantum Key Distribution to create a scalable and secure
    platform to support conventional serverless platforms.
  prefs: []
  type: TYPE_NORMAL
- en: 7.1 Deployment of Server Code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A well-defined programming model has been given for serverless platforms in
    [[1](#CR1)]. The aspects under discussion are given below.
  prefs: []
  type: TYPE_NORMAL
- en: Since serverless programs are ephemeral, maintaining state will be difficult
    between executions. Subsequent executions may even be routed to different VMs.
    Hence they are stateless by design. In order to maintain continuity, state information
    (including security) is sent across as a parameter with each invocation. Another
    option would be to maintain the state in persistent storage or databases (like
    Amazon S3 buckets or Google Cloud SQL), which would be slower than stateless implementations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A programming framework is essential to maintain proper sequencing. When using
    languages like Python or Node.js, routing frameworks will be helpful in connecting
    to web hooks and avoiding additional bridging code that may upset the load balancing
    capabilities.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The functions defined as serverless may require automatic triggering in response
    to various events (like adding a new file in storage), which is inherently stateless.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serverless functions may have to call other public APIs from within, because
    it may function as *glue code* to prevent end clients from invoking a chain of
    APIs. In that case, security should also be taken into consideration. This eventually
    leads to aggregated APIs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hence each node that is spun up as part of demand-based autoscaling will have
    the following properties.
  prefs: []
  type: TYPE_NORMAL
- en: The node will be loaded with a micro-VM or container that houses the blockchain
    layer, including the smart contract.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The chain won’t reside within the ephemeral node. Instead, it is offloaded to
    stable storage like Amazon S3 buckets or Google Cloud SQL.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The working of nodes are completely stateless. There should not be any delay
    in execution because the node is waiting for input from stable storage.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An abstract illustration of the layer is given in Fig. [9](#Fig9).![](../images/516210_1_En_5_Chapter/516210_1_En_5_Fig9_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 9
  prefs: []
  type: TYPE_NORMAL
- en: Smart contract deployment for serverless
  prefs: []
  type: TYPE_NORMAL
- en: 7.2 Blockchain and Consensus Algorithm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As per NIST [[22](#CR22)], a *permissioned blockchain* is one in which users
    must be authorized by some authority. This makes restricting access much more
    easier. Read and write access can be managed at multiple levels by an entity that
    is centrally managing the access control. Even though blockchain as a concept
    thrives on decentralization, this centralized mode of control may be beneficial
    in the case of server execution, especially since the executing node is ephemeral,
    and can get initiated from any location. Use of permissioned blockchain will allow
    a service-based access control. As per the decision flowchart given in Fig. [4](#Fig4),
    permissioned blockchain is most preferred for serverless application since (i)
    stateful storage may be needed to persist across ephemeral executions, (ii) there
    are multiple writers, (iii) trusted third party may not always be available, (iv)
    all writer nodes are already known (they are spun up by the cloud provider), (v)
    all writers cannot be directly trusted (an attacker can still manipulate them
    since they are exposed to the internet, and security is not guaranteed under shared
    responsibility model), and (vi) public verifiability is not needed.
  prefs: []
  type: TYPE_NORMAL
- en: In order to avoid expensive computation, a Proof of Stake (PoS) consensus model
    is used. In this model, the participant with highest stake (currency) will get
    authority to insert the next block. The stake amount is verified by all nodes
    to reach the consensus. But in the long run it may become unfair because the richest
    node always gets the authority. Hence our model will use a semi-randomized selection
    process based on the key. In this model, each node will generate a random number,
    which is then hashed to generate a 256-bit number. This hash is XORed with the
    key to get the *stake*. This stake is then broadcast among the nodes and consensus
    is reached on who has the authority to add the next block.
  prefs: []
  type: TYPE_NORMAL
- en: Once the modified PoS is in place, the focus turns to key transfer. Key transfer
    is based on QKD, which uses polarized or modulated photons to carry their quantum
    state. As per the description in Sect. [4.1](#Sec9), it is inherently tamper-proof.
    Hence, we implement a multi-phase process as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The client initiates a communication with the server. For that, Quantum Key
    Transfer is used to create a symmetric encryption channel between the client and
    load balancer at the service end. A payload of 1024 bits are transmitted from
    the client, which is received by the load balancer (recipient), and mapped from
    qubits to binary to generate the RQT. This RQT will be half the size of original
    payload, giving 512 bits. This RQT is then randomly verified with 256 bits announced,
    and if successful, the other 256 bits form the final **key**. The key may occasionally
    be renewed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When a request arrives at the load balancer, all available nodes will get activated,
    and they will generate a random number (**nonce**), which is then hashed to 256
    bits. This number is XORed with the key generated from QKD (which is also 256
    bits), and the result is broadcast as the **stake**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '3.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once all nodes broadcast their stake, the one with maximum stake becomes eligible
    for adding a block to the chain. This node is the **selected** node.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As an example, lets consider a case where we scale the system down to 16 bits
    of key. Hence the original communication needs to be 64 bits long. The process
    is tabulated in Table [4](#Tab4). Hexadecimal notation is considered in the beginning.Table
    4
  prefs: []
  type: TYPE_NORMAL
- en: 'Sequence of execution of QKD and consensus: Example of 16-bit key'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | Bits | Content |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Transmitted | 64 | ![$$608918c0659e33dc_H$$](../images/516210_1_En_5_Chapter/516210_1_En_5_Chapter_TeX_IEq6.png)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Received | 64 | ![$$608918c0659e33dc_H$$](../images/516210_1_En_5_Chapter/516210_1_En_5_Chapter_TeX_IEq7.png)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Assume alternate bits are valid as per base | 32 | ![$$4a284b5a_H$$](../images/516210_1_En_5_Chapter/516210_1_En_5_Chapter_TeX_IEq8.png)
    = ![$$1001010001010000100101101011010_2$$](../images/516210_1_En_5_Chapter/516210_1_En_5_Chapter_TeX_IEq9.png)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Pick alternate bits for verification | 16 | ![$$3633_H$$](../images/516210_1_En_5_Chapter/516210_1_En_5_Chapter_TeX_IEq10.png)
    = ![$$011011000110011_2$$](../images/516210_1_En_5_Chapter/516210_1_En_5_Chapter_TeX_IEq11.png)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Key after successful verification | 16 | ![$$809c_H$$](../images/516210_1_En_5_Chapter/516210_1_En_5_Chapter_TeX_IEq12.png)
    = ![$$1000000010011100_2$$](../images/516210_1_En_5_Chapter/516210_1_En_5_Chapter_TeX_IEq13.png)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Address: Node 1 | 64 | ![$$3de1016e288ba240_H$$](../images/516210_1_En_5_Chapter/516210_1_En_5_Chapter_TeX_IEq14.png)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Address: Node 2 | 64 | ![$$e1681f706a664a1a_H$$](../images/516210_1_En_5_Chapter/516210_1_En_5_Chapter_TeX_IEq15.png)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Hash(nonce): Node 1 | 16 | ![$$f9f5_H$$](../images/516210_1_En_5_Chapter/516210_1_En_5_Chapter_TeX_IEq16.png)
    = ![$$1111100111110101_2$$](../images/516210_1_En_5_Chapter/516210_1_En_5_Chapter_TeX_IEq17.png)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Hash(nonce): Node 2 | 16 | ![$$e686_H$$](../images/516210_1_En_5_Chapter/516210_1_En_5_Chapter_TeX_IEq18.png)
    = ![$$1110011010000110_2$$](../images/516210_1_En_5_Chapter/516210_1_En_5_Chapter_TeX_IEq19.png)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Key XOR Nonce: Node 1 | 16 | ![$$7969_H$$](../images/516210_1_En_5_Chapter/516210_1_En_5_Chapter_TeX_IEq20.png)
    = ![$$0111100101101001_2$$](../images/516210_1_En_5_Chapter/516210_1_En_5_Chapter_TeX_IEq21.png)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Key XOR Nonce: Node 2 | 16 | ![$$661a_H$$](../images/516210_1_En_5_Chapter/516210_1_En_5_Chapter_TeX_IEq22.png)
    = ![$$0110011000011010_2$$](../images/516210_1_En_5_Chapter/516210_1_En_5_Chapter_TeX_IEq23.png)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Winner | 16 | Node 1 (since ![$$7969_H$$](../images/516210_1_En_5_Chapter/516210_1_En_5_Chapter_TeX_IEq24.png)
    > ![$$661a_H$$](../images/516210_1_En_5_Chapter/516210_1_En_5_Chapter_TeX_IEq25.png))
    |'
  prefs: []
  type: TYPE_TB
- en: 7.3 Execution of Smart Contract
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once a node is selected to execute the contract, the request is read by the
    contract and it runs the codebase loaded along with it. This codebase is loaded
    once per node, and is analogous to an API call. The sequence of steps are as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The codebase for that node accepts the request parameters and performs validations
    if needed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The function is executed, and result is generated as a transaction payload.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '3.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The payload is broadcast among all nodes, and one node is randomly selected
    to verify the result by executing its own local copy. If both match, the result
    is ready to be propagated. If not, a third node will have to execute and the majority
    answer is taken.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '4.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If there are insufficient nodes to verify and validate the transaction, the
    original output is accepted by default.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '5.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The transaction is written to stable storage in the format *{request header,
    request payload, key, nonce, execution timestamp, selected node details, validator
    node details, conflict details, response payload}* via its own blockchain API
    calls.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This is explained with the below example. A part of smart contract codebase
    to increment the input value is given below.![](../images/516210_1_En_5_Chapter/516210_1_En_5_Figa_HTML.png)The
    request is received from IP 119.208.23.5, and it is requesting to increment the
    value “100”. As seen previously, Node 1 is ready to execute the contract. It is
    executed, and the following payload is generated.![](../images/516210_1_En_5_Chapter/516210_1_En_5_Figb_HTML.png)This
    is sent to all nodes, and Node 2 will verify that it is correct. Since it is the
    correct output, it can be sent to stable storage. The following transaction is
    logged.![](../images/516210_1_En_5_Chapter/516210_1_En_5_Figc_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: 8 Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A reference model was proposed by Gill [[39](#CR39)], which incorporated blockchain,
    quantum computing, and serverless technology for IoT domain. A quantum integration
    for serverless domain was also proposed in [[40](#CR40)]. The architecture discussed
    in Sect. [7](#Sec14) has been created keeping in mind a generic use case, and
    has an inherent layered structure to it, like that in [[39](#CR39)]. In principle,
    it should be stable under dynamic loads. Kaplunovich et al. [[41](#CR41)] conducted
    a study using Hyperledger Fabric implemented on top of AWS SQS and Lambda, and
    found that even though the concept of serverless computing is supported, clouds
    had difficulty scaling up when it came to blockchain layers. This is since there
    is limited concurrency possible when updating chains. In order to manage it to
    the best extent, platforms like Amazon QLDB (Quantum Ledger Database), which is
    a fully managed and traceable solution outside blockchain, may be used. The proposed
    architecture is also designed to minimize the load on blockchain layer because
    of the following aspects.
  prefs: []
  type: TYPE_NORMAL
- en: Blockchain is being used only as the logging utility. Data reads are non-existent
    during routine operation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All encryption and decryption are being managed at the load balancer level.
    No data access is required.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consensus is exclusively based on Proof of Stake, which is dependent solely
    on the incoming key and nonce.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Xiaoqi et al. [[42](#CR42)] have conducted a detailed analysis on different
    security weaknesses in blockchains. The proposed architecture mitigates some of
    the identified weaknesses either inherently, or by design. Table [5](#Tab5) describes
    the measures taken and further opportunities available.Table 5
  prefs: []
  type: TYPE_NORMAL
- en: Security issues and their management in proposed solution
  prefs: []
  type: TYPE_NORMAL
- en: '| Issue identified | Solution/Opportunity |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 51% vulnerability | Handled because PoW is not used, and PoS uses stake values
    that are generated instantaneously using key and nonce |'
  prefs: []
  type: TYPE_TB
- en: '| Private key security | Cloud-native key management systems can be used. Master
    key can be based on the key negotiated by QKD |'
  prefs: []
  type: TYPE_TB
- en: '| Criminal activity | Out of scope, since the domain of application is solely
    compute-based. As per shared responsibility principle, security in the cloud is
    the responsibility of the user |'
  prefs: []
  type: TYPE_TB
- en: '| Double spending | Can be safely ignored since double spending problem in
    serverless platform simply creates multiple copies of the same response payload
    |'
  prefs: []
  type: TYPE_TB
- en: '| Transaction privacy leakage | No private information is saved. The log simply
    contains IP-level information |'
  prefs: []
  type: TYPE_TB
- en: '| Criminal smart contracts | Since transaction is computational in nature,
    criminal smart contracts can generate unwanted accesses to confidential data stored
    in remote locations. The user has to manually verify the contract occasionally.
    Since containers are used, it is difficult to spin up malicious code directly.
    But contract should be immune to injection attacks |'
  prefs: []
  type: TYPE_TB
- en: '| Vulnerabilities in smart contract | Exceptions should be properly dealt with.
    Principle of shared responsibility applies here |'
  prefs: []
  type: TYPE_TB
- en: '| Under-optimized smart contract | Developer should be responsible for creating
    optimized code. Proper budget alerts on the cloud platform will flag possible
    over-utilization of resources. Since serverless executions are ephemeral in nature,
    and last for a maximum of 15 min, poorly written code will lead to premature termination
    |'
  prefs: []
  type: TYPE_TB
- en: '| Under-priced operations | Since no stake is transferred as part of operations,
    pricing is not a concern |'
  prefs: []
  type: TYPE_TB
- en: From both analysis, we can infer that the proposed architecture should be able
    to maintain scalability and security to a good extent when rolled out on serverless
    platforms.
  prefs: []
  type: TYPE_NORMAL
- en: 9 Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the advent of cloud computing, serverless execution has become a popular
    choice for application developers. It removes the overhead of infrastructure establishment,
    provisioning, and management from the hands of the developers by automating the
    provisioning and scaling process. But they suffer from security issues because
    of excessive automation, which is being mitigated with the help of blockchain.
    On adding blockchain to the mix, they have a potential reduction in scalability,
    which has been managed to a good extent by controlling which nodes are activated
    at each request. In addition, the layered architecture makes it easy to adapt
    to different types of workloads, keeping the concept of shared responsibility
    intact.
  prefs: []
  type: TYPE_NORMAL
