- en: 7   Ethereum Application Best Practices
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7   以太坊应用最佳实践
- en: Ethereum Blockchain Development
  id: totrans-1
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 以太坊区块链开发
- en: As we write this book in late 2017, integrated blockchain development environments
    (IDEs) are still emerging. Truffle ([http://truffleframework.com/](http://truffleframework.com/))
    is a development environment, testing framework, and asset pipeline for Ethereum.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 截至2017年底我们撰写这本书时，集成的区块链开发环境（IDEs）仍然在涌现。Truffle（\[http://truffleframework.com/\](http://truffleframework.com/)）是一个用于以太坊的开发环境、测试框架和资产管道。
- en: 'Truffle provides:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Truffle 提供：
- en: •   Built-in smart contract compilation, linking, deployment, and binary management
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: •   内置的智能合约编译、链接、部署和二进制管理
- en: •   Automated contract testing
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: •   自动化的合约测试
- en: •   Scriptable, extensible deployment and migration
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: •   可脚本化、可扩展的部署和迁移
- en: •   Network management for deploying to any number of public and private networks
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: •   部署到任何数量的公私网络的网络管理
- en: •   Package management with EthPM and NPM, using the ERC190 standard
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: •   使用ERC190标准的EthPM和NPM的包管理
- en: •   Interactive console for direct contract communication
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: •   用于直接合约通信的交互式控制台
- en: •   The ability to build pipeline with configuration and tight integration
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: •   具有配置和紧密集成的构建管道的能力
- en: •   Script runner that executes within a Truffle environment
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: •   在Truffle环境中执行的脚本运行器
- en: Setting Up the Development Environment for Truffle
  id: totrans-12
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置Truffle的开发环境
- en: 'There are technical requirements to work with Truffle. You should install the
    following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Truffle需要满足技术要求。你应该安装以下内容：
- en: •   Node.js ([https://nodejs.org/en/](https://nodejs.org/en/))
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: •   Node.js（\[https://nodejs.org/en/\](https://nodejs.org/en/)）
- en: •   Git ([https://git-scm.com/](https://git-scm.com/))
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: •   Git（\[https://git-scm.com/\](https://git-scm.com/)）
- en: When developing your Truffle-based application, it is recommended that you use
    the EthereumJS TestRPC ([https://github.com/ethereumjs/testrpc](https://github.com/ethereumjs/testrpc)).
    It’s a complete blockchain-in-memory that runs only on your development machine.
    It processes transactions instantly instead of waiting for the default blocktime—so
    you can test that your code works quickly—and it tells you immediately when your
    smart contracts run into errors.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发基于Truffle的应用时，建议使用EthereumJS TestRPC（\[https://github.com/ethereumjs/testrpc\](https://github.com/ethereumjs/testrpc)）。这是一个完整的内存中区块链，只在你的开发机上运行。它立即处理交易，而不是等待默认的区块时间——所以你可以快速测试你的代码是否工作——并且当你的智能合约出现错误时，它会立即告诉你。
- en: 'You need the following two commands to install the TestRPC for Ethereum and
    Truffle:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要以下两个命令来安装用于以太坊和Truffle的TestRPC：
- en: '![Images](p0146-01.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0146-01.jpg)'
- en: Set Up a Truffle Project
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置Truffle项目
- en: To verify it installed, type
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证它是否安装成功，请输入
- en: '`truffle list`'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: \`truffle list\`
- en: in a console window to list all Truffle commands.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制台窗口中输入以下内容以列出所有Truffle命令。
- en: 'Then create a new project directory, cd to it and type:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 然后创建一个新的项目目录，cd到它并输入：
- en: '`truffle init`'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: \`truffle init\`
- en: By default, `truffle init` gives you a set of example contracts (`MetaCoin`
    and `ConvertLib`) which act like a simple alt-coin built on top of Ethereum. You
    can use these contracts to learn quickly while navigating through the Getting
    Started guide, or delete these files and build a project of your own.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，\`truffle init\`为你提供了一组示例合约（\`MetaCoin\`和\`ConvertLib\`），这些合约像是在以太坊之上的简单山寨币。你可以在浏览入门指南的同时使用这些合约快速学习，或者删除这些文件并构建自己的项目。
- en: By default, `truffle init` creates a simple project for you so you can get familiar
    with writing, compiling, and deploying Solidity-based smart contracts.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，\`truffle init\`为你创建了一个简单的项目，这样你可以熟悉编写、编译和部署基于Solidity的智能合约。
- en: 'Now start a client node in a new console window by running:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在新的控制台窗口中运行以下命令来启动客户端节点：
- en: '`testrpc`'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`testrpc`'
- en: 'Then in another command prompt window run the following commands to compile
    and deploy the code:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在另一个命令提示符窗口运行以下命令来编译和部署代码：
- en: '![Images](p0146-02.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0146-02.jpg)'
- en: Truffle Directory Structure
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Truffle 目录结构
- en: 'The default Truffle directory structure contains the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的Truffle目录结构包含以下内容：
- en: '•   `/contracts`: Contains the Solidity source files for our smart contracts.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: •   \`/contracts\`：包含了我们智能合约的Solidity源文件。
- en: '•   `/migrations`: Truffle uses a migration system to handle smart contract
    deployments. A migration is an additional special smart contract that keeps track
    of changes.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: •   `/migrations`：Truffle使用迁移系统来处理智能合约的部署。迁移是一种额外的特殊智能合约，用于跟踪更改。
- en: '•   `/test`: Contains both JavaScript and Solidity tests for our smart contracts.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: •   \`/test\`：包含了我们智能合约的JavaScript和Solidity测试。
- en: '•   `truffle.js`: Truffle configuration file.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: •  `truffle.js`：Truffle 的配置文件。
- en: Beyond this brief overview, go to [http://truffleframework.com/tutorials/](http://truffleframework.com/tutorials/)
    to try the latest Truffle tutorials and documentation to continue with your Ethereum
    blockchain development.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这个简要概述之外，前往[http://truffleframework.com/tutorials/](http://truffleframework.com/tutorials/)尝试最新的Truffle教程和文档，继续你的以太坊区块链开发。
- en: 'Ethereum Blockchain Development: Best Practices'
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 以太坊区块链开发：最佳实践
- en: Before plunging into code design and implementation, let’s recap the properties
    that define the possibilities and constraints we need to consider when making
    contracts and applications and systems that utilize them.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入代码设计和实现之前，让我们回顾一下定义了我们制作合约、应用程序和系统时需要考虑的可能性和限制属性。
- en: The Ethereum blockchain is a second-generation blockchain. It contains all the
    properties of the first-generation blockchain, like an immutable block of transactions,
    proof of work, and cryptographic verification. In addition, the Ethereum blockchain
    contains a Turing complete virtual machine or EVM (Ethereum Virtual Machine).
    This allows for much richer applications than what Bitcoin has with transactions.
    The EVM is a simple 256-bit stack machine with a stack size of 1024\. EVM code
    is deployed as smart contracts. All code is committed to the blockchain and accessed
    from the EVM as virtual ROM. Storage is word-addressable word arrays persisted
    as part of the blockchain system state.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊区块链是一种第二代区块链。它包含了一代区块链的所有特性，如不可变的交易区块、工作量证明和加密验证。此外，以太坊区块链包含了一个图灵完备的虚拟机或EVM（以太坊虚拟机）。这使得可以实现比比特币交易更丰富的应用。EVM是一个简单的256位栈机器，拥有1024个栈的大小。EVM代码作为智能合约部署。所有代码都提交到区块链上，并从EVM作为虚拟ROM访问。存储是按单词地址的字符串数组，作为区块链系统状态的一部分持久化。
- en: The EVM can be considered a single instance of a worldwide virtual machine,
    synchronized across all nodes in the network. All code execution (transactions
    and smart contract function calls) is started by an external user—smart contracts
    do not execute by themselves. A code execution is considered a single transaction.
    Either all code is executed and the new state is persisted on the blockchain,
    or an error occurs and everything is reverted (except the mining reward), just
    like an ACID transaction in a relational database management system (RDBMS).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 可以认为EVM是全世界虚拟机的一个实例，在网络中的所有节点上同步。所有代码执行（交易和智能合约函数调用）都是由外部用户发起的——智能合约不会自己执行。代码执行被视为一个单一的交易。要么执行所有代码，并在区块链上持久化新状态，要么出现错误，一切都会回滚（除了挖矿奖励），就像关系数据库管理系统（RDBMS）中的ACID交易一样。
- en: The EVM can be perceived as a cloud computer service, where the payment and
    execution are integrated. To execute EVM code and change blockchain state and
    storage, cash is provided as “gas” to the execution call. However, there is only
    a limited amount of execution gas available in each block. This implies that there
    is a finite and restricted amount of code that can be executed and storage to
    be changed in a single transaction. This is in sharp contrast to modern development
    where you have access to an almost infinite amount of resources at hand in the
    cloud.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 可以认为EVM是一个云计算服务，其中支付和执行是集成的。为了执行EVM代码并改变区块链状态和存储，向执行调用提供现金作为“燃料”。然而，每个块中可用的执行燃料是有限的。这意味着在单个交易中可以执行的代码量以及可以更改的存储量是有限和受限制的。这与现代开发形成鲜明对比，在现代开发中，您可以访问几乎无限的云计算资源。
- en: The best mindset to have when programming smart contracts is to consider it
    as programming a microcontroller that is launched into space. There are very limited
    resources to execute, limited gas, and limited memory and stack size. If there
    is an error (bug) in the code, it’s hard to fix, and one needs to think of the
    entire life cycle, with all of the future security and operational needs of the
    contract taken into consideration.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写智能合约时，最好的心态是把它当作一个被送入太空的微控制器来编程。执行资源非常有限，燃料（gas）和内存及栈大小都有限。如果代码中有错误（bug），修复起来会很困难，需要考虑整个生命周期，包括考虑合约未来的安全性和运营需求。
- en: Blockchain Technologies
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 区块链技术
- en: 'The EVM itself is only part of the whole decentralized ecosystem. In order
    to interact with and execute smart contracts, other components are needed. As
    mentioned in [Chapter 3](ch3.xhtml#ch3) on blockchain technology use cases, Web
    3.0 components include:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊虚拟机（EVM）本身只是整个去中心化生态系统的部分。为了与智能合约交互和执行，还需要其他组件。如在第3章[区块链技术应用](ch3.xhtml#ch3)中提到的，Web
    3.0组件包括：
- en: '•   Dapps: decentralized applications'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: •   Dapps：去中心化应用程序
- en: '•   Contracts: decentralized logic'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: •  合约：去中心化逻辑
- en: '•   Swarm: decentralized storage'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: •   Swarm：去中心化存储
- en: '•   Whisper: decentralized messaging'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: •   Whisper：去中心化消息传递
- en: The simplest solution is a decentralized application (dapp). This form does
    not need a central server, only code running in a browser that interacts with
    the user and an underlying smart contract (or set of smart contracts). The browser
    code (web application) can be distributed either from a normal web server or from
    decentralized storage like Swarm or InterPlanetary File System (IPFS). For the
    remainder of this chapter we will mostly deal with applications that interact
    with traditional systems.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的解决方案是去中心化应用（dapp）。这种形式不需要中心服务器，只需要在浏览器中运行与用户交互的代码和一个底层智能合约（或智能合约集合）。浏览器代码（网络应用）可以从正常的网络服务器或Swarm或星际文件系统（IPFS）等去中心化存储中分发。在本章剩余的部分，我们将主要处理与传统系统交互的应用程序。
- en: Solidity Basics Continued
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Solidity基础继续
- en: We covered Solidity and the language constructs in [Chapter 6](ch6.xhtml#ch6).
    Now let’s continue with a review of the basic language elements. Here is a contract
    showing constructor, modifier, and events for the Ownable pattern.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第6章](ch6.xhtml#ch6)中介绍了Solidity和语言结构。现在让我们继续回顾基本语言元素。以下是一个展示所有权模式构造函数、修改器和事件的合约。
- en: '![Images](p0148-01.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0148-01.jpg)'
- en: This is a good, simple base contract defining an `onlyOwner` modifier and function
    that allows the ownership to be transferred and issues an event when the ownership
    is changed. However, the `transferOwnership` function contains a danger. If it
    is called with a wrong address, the control of the contract is lost forever. One
    way of dealing with this is to transfer the ownership in a two-phase push/pull
    pattern. First, the old owner “pushes” a newOwner by calling the `transferOwnership`
    function. This does not transfer the ownership right away but rather stores the
    address in a contract variable in a pending state. Second, the new owner has to
    accept the ownership by calling `acceptOwnership`. This will “pull” the ownership
    to the new owner. Note that *only* the newOwner specified in the `transferOwnership`
    function can actually claim the new ownership, and the ownership is actually transferred
    *only* when the newOwner has called the `acceptOwnership` function. If the newOwner
    address is wrong or newOwner has lost access to the account, then the ownership
    is never transferred, thus avoiding the potential predicament from the first version
    of the contract.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单好用的基础合约，定义了一个`onlyOwner`修改器和一个函数，允许转让所有权，并在所有权更改时发出事件。然而，`transferOwnership`函数存在风险。如果用错误的地址调用它，合约的控制权将永远丢失。处理这种情况的一种方法是采用两阶段推/拉模式来转让所有权。首先，原所有者通过调用`transferOwnership`函数“推”出新所有者。这不会立即转让所有权，而是将地址存储在合约变量中，处于待定状态。其次，新所有者必须通过调用`acceptOwnership`函数来接受所有权。这将“拉”所有权给新所有者。请注意，*只有*在`transferOwnership`函数中指定的新所有者才能实际声称新的所有权，所有权*只有在*新所有者调用`acceptOwnership`函数后*才会*实际转让。如果新所有者的地址错误或新所有者失去了对账户的访问权限，那么所有权永远不会转让，从而避免了合约第一版可能出现的潜在困境。
- en: In general, it is good practice to use a two-phase push/pull when dealing with
    irreversible functions with high implications like transfer of ownership, refunding,
    etc.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在处理诸如所有权的转移、退款等高影响不可逆函数时，采用两阶段推/拉的做法是一个好习惯。
- en: '![Images](p0148-02.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0148-02.jpg)'
- en: '![Images](p0149-01.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0149-01.jpg)'
- en: Calling Contracts from Contracts
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 合约中调用合约
- en: A unique aspect of the EVM environment is the concepts of *gas* and *value*.
    As mentioned, the EVM can be conceived as a cloud computing service, where you
    need to pass payment to each call to pay for cloud execution. The payment for
    execution is added as gas, and the payment passed to accounts is added as value.
    As discussed, gas has a wei price (gasPrice) and can be calculated as a wei amount
    = gas*gasPrice. Both gas*gasPrice and value are taken from the caller’s balance.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊虚拟机环境的一个独特方面是*气*和*值*的概念。如前所述，EVM可以被认为是一个云计算服务，你需要为每个调用支付云计算执行费用。执行费用以气的形式增加，传递给账户的支付以值的形式增加。如前所述，气有一个wei价格（gasPrice），可以计算为气量*气价格（wei）。气和值都从调用者的余额中扣除。
- en: 'Consider the following contract:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下合约：
- en: '![Images](p0149-02.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0149-02.jpg)'
- en: Then to instantiate it from within another contract as
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然后从另一个合同中实例化它
- en: '`A a = new A(…);`'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`A a = new A(…);`'
- en: if you simply now call
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在简单地调用
- en: '`a.trade();`'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`a.trade();`'
- en: it will by default not pass any value to the function. You need to add a `.value(...)`
    argument to the calls like
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，它不会向函数传递任何值。你需要给调用添加一个`.value(...)`参数，如
- en: '`a.trade**.value**`(**`somevalue`)**();'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`a.trade**.value**`(**`somevalue`)**();'
- en: When you call a function on a smart contract with a value, that contract will
    then own the value sent. It can in turn call functions on other contracts, transferring
    value to these and so on.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当你向智能合约调用一个带有值的函数时，该合约将拥有发送的值。它可以反过来调用其他合约上的函数，将这些值转移给这些合约等等。
- en: 'Let’s see that in action. Consider a contract B:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个操作。考虑一个合同B：
- en: '![Images](p0150-01.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0150-01.jpg)'
- en: and instantiate B as
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 并实例化B为
- en: '`B b = new B(a,wallet,10);`'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`B b = new B(a,wallet,10);`'
- en: and then call
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然后调用
- en: '`a.trade.value(sometradevalue)();`'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`a.trade.value(sometradevalue)();`'
- en: Within the trade function of B that now has `sometradevalue`, you can see an
    example of splitting this value passed to b.trade into a call to `a.trade()` with
    90 percent of the value and passing 10 percent of the value to a commission wallet.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在B的贸易函数中，现在有了`sometradevalue`，你可以看到一个将传递给b.trade的值拆分为对`a.trade()`的调用，传递90%的值，并将10%的值传递给佣金钱包的示例。
- en: If you want to create a cloud service for the blockchain contracts that binds
    outside the EVM, this is a way to get paid by the caller directly, thus avoiding
    separate invoicing and so on.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要为区块链合约创建一个云服务，将合约绑定在EVM之外，这是一种直接从调用者那里获得报酬的方式，从而避免了单独开票等等。
- en: However, please note that the `.value` call by default passes on all available
    (remaining) gas and should be considered unsafe against reentrancy. So be careful
    if you don’t control the contract being called.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，默认情况下`.value`调用传递所有可用的（剩余的）气，因此应考虑对重入不安全。所以，如果你不控制被调用的合约，要小心。
- en: 'You can specify the amount of gas passed to a function by adding `.gas(someGasAmount)`
    to the function call:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过向函数调用添加`.gas(someGasAmount)`来指定传递给函数的气量：
- en: '`a.trade.value(msg.value - commission).gas(40000)();`'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`a.trade.value(msg.value - commission).gas(40000)();`'
- en: Calling `address.transfer` only passes 23000 gas. That is insufficient to do
    any reentrancy but might be insufficient for complex `function () payable` routines
    to complete.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`address.transfer`只传递23000个气。这不足以进行任何重入，但可能不足以完成复杂的`function () payable`例程。
- en: 'Pitfall: Remember to forward gas and ether between contracts when calling payable
    functions.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 陷阱：调用可支付函数时，请记得在合约之间传递气和以太币。
- en: Handling Events
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 处理事件
- en: EVM events are a central part of the smart contract ecosystem. We saw an example
    of an event in the Owner contract where the contract issues a `TransferOwnership`
    event each time the owner changes
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: EVM事件是智能合约生态系统的核心部分。我们在Owner合约中看到了一个事件示例，每次所有者更改时，该合约都会发出一个`TransferOwnership`事件。
- en: Events allow users and especially applications to monitor smart contract changes
    on the blockchain. This is done by specifying filters and applying them on a blockchain
    node. Events can be filtered on topics, values, and block intervals, thus listing
    to new events or scanning through old events.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 事件允许用户特别是应用程序监视区块链上的智能合约变化。这是通过指定过滤器并将它们应用于区块链节点来实现的。事件可以根据主题、值和区块间隔进行过滤，从而监听新事件或扫描旧事件。
- en: Users can be notified about changes to contracts they have interest in, such
    as changes to ownership, ERC20 tokens, changes to balances, notification of multisig
    wallets pending confirmations, etc. Likewise, enterprise applications that integrate
    to business logic and process flows in smart contracts can be notified when enterprise
    application actions are needed.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以被通知到他们感兴趣的合约的变化，例如所有权的变更、ERC20代币的变化、余额的变更、多签名钱包待确认的通知等。同样，集成到智能合约中的业务逻辑和流程的企业应用程序可以在需要企业应用程序操作时收到通知。
- en: User actions on smart contracts can trigger enterprise services, and enterprise
    status updates on smart contracts can notify users, just like events in regular
    applications. In enterprise applications, a process needs to be put in place for
    events to be captured. Consider the event
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 用户对智能合约的操作可以触发企业服务，而企业智能合约的状态更新可以通知用户，就像常规应用程序中的事件一样。在企业应用程序中，需要建立一个事件捕获流程。考虑以下事件：
- en: '`event MyEvent(address indexed myidx, uint myval);`'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`event MyEvent(address indexed myidx, uint myval);`'
- en: Adding `indexed` to the event argument `myidx` makes the event searchable through
    filters using `myidx` values.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 将`indexed`添加到事件参数`myidx`中，使得可以通过`myidx`值使用过滤器对事件进行搜索。
- en: 'In C#, using the Nethereum package monitoring for live events might look like
    this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，使用Nethereum包监控实时事件可能看起来像这样：
- en: '![Images](p0151-01.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0151-01.jpg)'
- en: '![Images](p0152-01.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0152-01.jpg)'
- en: The example below will set up an event listener that calls two functions whenever
    a new `MyEvent` event is seen on the blockchain.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例将设置一个事件监听器，每当在区块链上看到新的`MyEvent`事件时，就会调用两个函数。
- en: '![Images](p0152-02.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0152-02.jpg)'
- en: 'In NodeJS the syntax is a little simpler:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在NodeJS中，语法要简单一些：
- en: '![Images](p0152-03.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0152-03.jpg)'
- en: If the service needs to process events from the past, they can be filtered by
    block interval as well as by filters on indexed parameters.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务需要处理过去的事件，它们可以通过块间隔以及索引参数的过滤器进行过滤。
- en: '![Images](p0152-04.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0152-04.jpg)'
- en: If an enterprise system needs to handle all events issued from a contract, it’s
    a good idea to add a sequence number on each event.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果企业系统需要处理从合约发出的所有事件，给每个事件添加一个序列号是个好主意。
- en: '`event MyEvent(uint indexed eventId, address indexed myidx, uint myval);`'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`event MyEvent(uint indexed eventId, address indexed myidx, uint myval);`'
- en: This allows the enterprise system to easily track whether all events are handled
    and in case of breakdown efficiently recover/reprocess the missing events.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得企业系统可以轻松跟踪是否处理了所有事件，在出现故障时可以有效地恢复/重新处理缺失的事件。
- en: Remember that enterprise system event handlers can also call functions on contracts.
    This makes EVM events behave just like other kinds of events, thus allowing mixed
    cascade triggers through different systems. Imagine the following system flow
    (see [Figure 7-1](ch7.xhtml#ch7fig1)).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，企业系统事件处理程序也可以调用合约上的函数。这使得EVM事件的行为与其他事件类似，从而允许通过不同系统混合级联触发。想象一下以下系统流程（参见[图7-1](ch7.xhtml#ch7fig1)）。
- en: '![Images](fig7-1.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![Images](fig7-1.jpg)'
- en: '**FIGURE 7-1   Example of enterprise system flow involving smart contracts**'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**FIGURE 7-1   涉及智能合约的企业系统流程示例**'
- en: 1.   A user (web) app calls a function on a smart contract.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '-   1. 用户（网页）应用程序调用智能合约上的一个函数。'
- en: 2.   The smart contract function generates an EVM event.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '-   2. 智能合约函数生成一个EVM事件。'
- en: 3.   This event is captured by a server monitor.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '-   3. 服务器监控捕获了此事件。'
- en: 4.   The monitor starts a job on a third-party system.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '-   4. 监控器在第三方系统上启动一个作业。'
- en: 5.   Retrieve the result from the third party when the job completes or some
    condition is met.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '-   5. 当作业完成或满足某些条件时，从第三方获取结果。'
- en: 6.   The monitor calls a function on a smart contract with the outcome and changes
    the status.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '-   6. 监控器调用智能合约上的一个函数，并带有结果更改状态。'
- en: 7.   The smart contract function generates an event containing the outcome and
    the new status.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '-   7. 智能合约函数生成一个包含结果和新状态的事件。'
- en: 8.   The user app captures this event and updates the UI with the outcome and
    new status.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '-   8. 用户应用程序捕获此事件，并使用结果和新状态更新UI。'
- en: As seen, this allows building of complex integrated systems without building
    complex infrastructures between trusted parties or agreements of cost share. It
    solely uses the blockchain of the infrastructure and payment platform. The user
    app and the server systems are independent of each other and do not need to establish
    complex agreements.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如所见，这使得可以在信任的各方之间不建立复杂的架构或成本分担协议的情况下构建复杂的集成系统。它仅使用基础架构的区块链和支付平台。用户应用和服务系统彼此独立，无需建立复杂的协议。
- en: In a generalized form the server monitor acts like an intermediary between the
    blockchain and the real world; this is often referred to as an oracle.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在一般形式下，服务器监控充当区块链和现实世界之间的中介；这通常被称为预言机。
- en: As discussed, a smart contract can’t trigger itself, since the blockchain needs
    to be deterministic. So it cannot depend upon or access the real world directly
    from the EVM. It needs to be activated by an external agent, as illustrated in
    [Figure 7-2](ch7.xhtml#ch7fig2). An agent can be either a user or an oracle. Oracles
    comes in two forms. They can be “callable” from the smart contract by generating
    an event with a request/reply interaction as shown in [Figure 7-1](ch7.xhtml#ch7fig1).
    Or they can be trigger based where the oracle calls the smart contract when certain
    conditions are met. This could be when a currency hits a certain price or when
    an IoT sensor detects a certain value.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如所讨论，智能合约不能触发自己，因为区块链需要是确定性的。所以它不能依赖或直接从 EVM 访问现实世界。它需要由外部代理激活，如图 7-2 所示。代理可以是用户或预言机。预言机有两种形式。他们可以通过生成一个带有请求/回复交互的事件从智能合约中“调用”，如图
    7-1 所示。或者他们可以是基于触发的事件，当满足某些条件时预言机会调用智能合约。这可能是当一种货币达到一定的价格，或者当物联网传感器检测到某个值的时候。
- en: '![Images](fig7-2.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![Images](fig7-2.jpg)'
- en: '**FIGURE 7-2   Application with a user, a smart contract, and an oracle**'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 7-2   用户、智能合约和预言机的应用**'
- en: To include a third-party oracle in the smart contract flow, it needs to be trustworthy
    and reliable since its interaction with the blockchain is immutable and hence
    irreversible.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将第三方预言机包含在智能合约流程中，它需要是可信和可靠的，因为其与区块链的交互是 immutable 的，因此是不可逆的。
- en: Smart Contract Design
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 智能合约设计
- en: 'All the virtues of modern design certainly apply to making smart contracts.
    In fact, even more so, because of the immutable nature of the blockchain: clear
    design, well-thought-out security, thorough tests, and life cycle management are
    musts. In this section, we will elaborate on some of the important virtues.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 所有现代设计的优点当然也适用于编写智能合约。实际上，由于区块链的不变性，更是如此：清晰的设计、深思熟虑的安全性、彻底的测试和生命周期管理都是必不可少的。在本节中，我们将详细阐述一些重要的优点。
- en: Modules and Interfaces
  id: totrans-120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 模块和接口
- en: 'For traditional coding, it is a widespread best practice to divide the code
    into sections representing separation of concerns. This is especially relevant
    in writing smart contracts. There already exist a number of libraries containing
    typical modules that are needed when writing a contract. And it is preferable
    to reuse well-established modules. A good example of this is OpenZeppelin ([https://github.com/OpenZeppelin/zeppelin-solidity](https://github.com/OpenZeppelin/zeppelin-solidity)).
    Their tagline formulates it very well: “Reduce the risk of vulnerabilities in
    your applications by using standard, tested, and community-reviewed code.”'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 对于传统编程，广泛的最佳实践是将代码划分为代表关注点分离的章节。这在编写智能合约时尤其相关。已经存在许多包含编写合约时需要的一些典型模块的库。并且最好重用已经确立的模块。一个很好的例子是
    OpenZeppelin([https://github.com/OpenZeppelin/zeppelin-solidity](https://github.com/OpenZeppelin/zeppelin-solidity)).
    他们的口号很好地概括了这一点：“通过使用标准、经过测试和社区审查的代码，降低您应用程序中漏洞的风险。”
- en: Using such modules whenever possible reduces the risk of error and frees valuable
    time to focus on the unique features of the contracts at hand. Even when a module
    needs to be modified to fit some particular needs, reuse of the corresponding
    tests to ensure nothing gets broken is highly recommended.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能使用此类模块可以减少错误风险，并节省宝贵的时间来专注于手头合同的独特特性。即使某个模块需要修改以适应某些特定需求，也强烈建议 reuse 相应的测试以确保不会破坏任何内容。
- en: Don’t over-engineer the contract or dazzle with fanciful coding techniques.
    Keep it simple, stupid—especially because most contracts used by the public are
    going to have the corresponding source attached on the blockchain for anybody
    to inspect and validate. Having a clear, simple contract that is easy to understand
    gains more trust and is actually less likely to contain flaws than a large over-engineered
    contract doing way more than actually needed, as its attach vector is much smaller.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 不要过度设计合约，也不要用花哨的编程技术来炫耀。保持简单，傻瓜——特别是因为大多数公众使用的合约都将对应源代码附加在区块链上，供任何人检查和验证。拥有清晰、简单的合约，易于理解，会赢得更多信任，实际上比一个做很多实际上不需要的事情的大型过度设计的合约含有更少的缺陷，因为它的攻击向量要小得多。
- en: Security and Roles
  id: totrans-124
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 安全与角色
- en: When designing smart contracts, it is important to think about security from
    the very start. Since contracts are public and visible on the blockchain, everybody
    can potentially call every function. Even if you do not submit the source code,
    there is still the bytecode so everyone with the right understanding of the EVM
    and proper endurance can figure out what the contract does and call it, so don’t
    count on security by obscurity.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计智能合约时，从一开始就要考虑安全性非常重要。由于合约是公开的，并且区块链上的每个人都可见，所以每个人都可能调用每个函数。即使你不提交源代码，还存在字节码，所以任何理解EVM并且有适当耐心的每个人都可以弄清楚合约做什么并且调用它，因此不能依靠隐秘性来保证安全。
- en: Most contracts implement the owner pattern that can be used to restrict the
    highest state “administrator” change functions, like `setup`, `start`, `stop`,
    and `kill`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数合约实现所有者模式，以限制最高状态“管理员”变更函数，如`setup`、`start`、`stop`和`kill`。
- en: 'Consider the `kill` function:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑`kill`函数：
- en: '![Images](p0155-01.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0155-01.jpg)'
- en: Using the modifier signature, it becomes clear that the function is only allowed
    to be called by the owner and the function body contains only the business code.
    However, the private key of the owner should be stored somewhere safe and only
    used in major life cycle events for the contract.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 使用修改器签名，可以清楚地看出该函数只能由所有者调用，并且函数体中只包含业务代码。然而，所有者的私钥应该保存在安全的地方，仅在合约的重大生命周期事件中使用。
- en: More operational functions should be modularized and restricted to special roles
    different from the owner. The owner should then delegate these role rights to
    other addresses. The specialized roles often run on web services or staff computers,
    and need to contain the private key for their role address in order to execute.
    If a system is hacked and the private key of a role gets compromised, the implications
    are confined to that role’s operations, and the system can more easily be recovered
    by the owner by changing the compromised role address.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 应该将更多的操作功能模块化并限制在不同的特殊角色中，与所有者角色不同。然后所有者应将这些角色权利委派给其他地址。这些专用角色通常在网络服务或员工计算机上运行，并且需要包含其角色地址的私钥才能执行。如果系统被黑客攻击并且某个角色的私钥被泄露，影响仅限于该角色的操作，并且所有者可以通过更改受影响的角色地址更容易地恢复系统。
- en: 'Examples of roles could be:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 角色示例可能包括：
- en: '•   Minter: A role capable of minting new tokens in a token contract'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: •   铸币师：能够在代币合约中铸新代币的角色
- en: '•   MigrationMaster: A role responsible for the migration process from an old
    contract to a new contract'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: •   迁移大师：负责从旧合约迁移到新合约的流程的角色
- en: '•   InvitedInvestor: A role given to invited addresses to make investments
    in a restricted ICO'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: •   受邀投资者：给予受邀地址投资受限ICO的角色
- en: '•   Trader/Executer: A role that executes trades or orders on behalf of customers'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: •   交易员/执行者：代表客户执行交易或订单的角色
- en: Each role can either be a single address role or multiple addresses, often referred
    to as whitelisted addresses.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 每个角色可以是单个地址角色或多个地址，通常被称为白名单地址。
- en: As we saw in the Ownable contract, a modifier for a single address role can
    be as simple as
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在Ownable合约中看到的那样，单个地址角色的修改器可以简单到
- en: '`modifier only***Role*** { require(msg.sender == ***roleAddress***); _; }`'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`modifier only***Role*** { require(msg.sender == ***roleAddress***); _; }`'
- en: A multiple address role can be implemented as a mapping like
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 多地址角色可以实现为像这样的映射
- en: '![Images](p0155-02.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0155-02.jpg)'
- en: 'And then the modifier would change to this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 然后修改器将更改为这个样子：
- en: '`modifier only***Role*** { require(***role***Whitelist[msg.sender]); _; }`'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`modifier only***Role*** { require(***role***Whitelist[msg.sender]); _; }`'
- en: The use of access control should not be implemented as part of the function
    itself, but the use of clearly defined modifiers on the function header is highly
    recommended. This is because it separates the access control logic from the function
    and also because it makes the functions easier to read since they only contain
    the business logic.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 访问控制的使用不应作为函数本身的一部分实现，而是建议在函数头使用明确定义的修饰符。这是因为它将访问控制逻辑与函数分离，并且使函数更容易阅读，因为它们只包含业务逻辑。
- en: Single Contract Design
  id: totrans-144
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 单合同设计
- en: As a contract evolves and has more and more features added to it, it’s easy
    to end up with a fat contract that does way too much and becomes difficult to
    manage. If nothing else is done, the development will end abruptly one day, simply
    because the combined cost of code deposit and create execution exceeds the total
    available gas within a single block execution. This is called block gas limit
    (BGL). The BGL on the public net is currently 4,712,388.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 随着合同的发展并且添加了越来越多的功能，很容易最终得到一个过于庞大的合同，做很多事情，并且变得难以管理。如果其他不做任何事情，发展将有一天突然停止，仅仅是因为代码存款和创建执行的总成本超过了单个块执行中的总可用gas。这称为块gas限制（BGL）。公共网络上的BGL目前为4,712,388。
- en: A way to keep an eye on this is to look at the gas estimates in the `json` output
    of the compilation. As seen here, the sum of the two numbers (code deposit and
    execution) exceeds BGL, so this contract will not be able to deploy.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 一种保持关注的方法是查看编译输出中的`json`的gas估算。如前所见，两个数字（代码存款和执行）之和超过了BGL，因此这个合同将无法部署。
- en: '![Images](p0156-01.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0156-01.jpg)'
- en: In general, if the contract creation estimate comes anywhere near to BGL, the
    contract design should be revised.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，如果合同创建的估算值接近BGL，合同设计应该进行修订。
- en: Linked Contracts
  id: totrans-149
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Linked Contracts
- en: Instead of putting all functionality into a single contract, it’s often advisable
    to divide it into several contracts that act together. Ideally you can reuse already
    existing base contracts that have been well designed, well tested, and have stood
    the test of time. Such contracts could be standard tokens, multisig wallets, etc.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 与其将所有功能放入一个单一的合同中，通常建议将其划分为几个一起行动的合同。理想情况下，您可以重用已经设计良好、测试良好并且经过时间考验的现有基础合同。这样的合同可能是标准代币、多签名钱包等。
- en: Let’s say that you want to build an ICO contract, where investors are invited
    to buy tokens at a fixed price for a limited period of time. You want to collect
    all the ether into a secure wallet, and you want all the tokens to reside in a
    standard ERC20 token that eventually will be freely tradable on exchanges after
    the ICO. When the ICO is over and validated, the ICO contract is in fact not needed
    anymore as it has completed its life cycle.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您想要建立一个ICO合同，邀请投资者在有限的时间内以固定价格购买代币。您希望将所有的以太币收集到一个安全的钱包中，并且您希望所有的代币都存放在一个最终可以在交易所自由交易的
    standard ERC20 代币中，在ICO之后。当ICO完成并验证后，实际上ICO合同不再需要，因为它已经完成了它的生命周期。
- en: How would you construct such an ICO contract system?
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 您将如何构建这样一个ICO合同系统？
- en: Well, there are a number of implementations of both multisig wallets and standard
    contracts, so no need to write those. Instead, we concentrate on writing our particular
    ICO process and then just bind it to a standard multisig wallet and a standard
    token contract.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，有多重签名钱包和标准合同的许多实现，所以不需要写那些。相反，我们专注于编写我们特定的ICO流程，然后只需将其绑定到标准多签名钱包和标准代币合同。
- en: Each contract is deployed as a separate transaction so the size of the total
    contract system can be much larger that a single BGL. Only the individual contracts
    need to be below BGL. Here is the pseudocode to create the contracts and bind
    them together.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 每个合同作为单独的交易部署，因此整个合同系统的总大小可以远大于一个单一的BGL。只有个别合同需要低于BGL。以下是创建合同并将它们绑定在一起的伪代码。
- en: '![Images](p0156-02.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0156-02.jpg)'
- en: '![Images](p0157-01.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0157-01.jpg)'
- en: Once the contracts are deployed and connected, the ICO sales can start (here
    shown as explicit functions, often the ICO runs within a specified blockNumber
    range).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦合同部署并连接起来，ICO销售就可以开始（这里显示为显式函数，通常ICO在一个指定的blockNumber范围内运行）。
- en: '![Images](p0157-02.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0157-02.jpg)'
- en: When the ICO is complete, the ICO owner can request the funds.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当ICO完成时，ICO所有者可以请求资金。
- en: '![Images](p0157-03.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0157-03.jpg)'
- en: The auditor can validate the ICO process and state and release the funds to
    the ICO owner.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 审计员可以验证ICO过程和状态，并将资金释放给ICO所有者。
- en: '![Images](p0157-04.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0157-04.jpg)'
- en: Now that the ICO is complete and the shares are stored in the standard contract,
    the ICO crowd contract can be destroyed.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 既然 ICO 已经完成，股份已经存储在标准合同中，ICO 人群合同可以被销毁。
- en: '![Images](p0157-05.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0157-05.jpg)'
- en: User-Specific Contracts
  id: totrans-165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 用户特定合同
- en: Previously we saw an example where several (standard) contracts worked in conjunction,
    forming the whole system. If we want each user to have its own individual settings
    and peculiarities, then instead of polluting the core contracts with this complexity,
    it might be better to keep them as user-specific contracts. As we discussed earlier,
    polymorphism works well in Solidity with the interface specification.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 以前我们看到了一个例子，其中几个（标准）合同协同工作，构成整个系统。如果我们希望每个用户都有其自己的个性化设置和特点，那么与其让这种复杂性污染核心合同，不如将其作为用户特定的合同来维护可能更好。正如我们之前讨论的，多态性在
    Solidity 中通过接口规范工作得很好。
- en: 'Imagine we have a contract system that handles assets that is accessed within
    the main contract master only using an asset interface like this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 想象我们有一个通过主合同 master 只使用资产接口处理的资产的合同系统：
- en: '![Images](p0158-01.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0158-01.jpg)'
- en: Then different asset implementations can be developed even after the master
    contract is deployed.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在主合同部署后，可以开发不同的资产实现。
- en: '![Images](p0158-02.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0158-02.jpg)'
- en: '![Images](p0159-01.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0159-01.jpg)'
- en: 'Some later implementation of an asset contract:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 一些后来对资产合同的实现：
- en: '![Images](p0159-02.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0159-02.jpg)'
- en: This allows for the following deploy sequence.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许以下部署序列。
- en: 'Deploy master:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 部署主合同：
- en: '`Master m = new Master();`'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`Master m = new Master();`'
- en: 'Develop MyAsset, deploy it, and bind it to master:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 开发 MyAsset，部署它，并将其绑定到主合同：
- en: '![Images](p0160-01.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0160-01.jpg)'
- en: 'Later, develop MyAsset2, deploy it, and bind it to master:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 后来，开发 MyAsset2，部署它，并将其绑定到主合同：
- en: '![Images](p0160-02.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0160-02.jpg)'
- en: 'Call some actions on the assets:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在资产上执行一些操作：
- en: '![Images](p0160-03.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0160-03.jpg)'
- en: This also demonstrates that a system of linked contracts can be designed to
    upgrade and extend over time without a total redeployment—in this example, especially
    without redeployment of master, which address might be embedded in a lot of systems
    and users’ wallets.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这也说明了一个可以通过不重新部署而随时间升级和扩展的合同系统——在这个例子中，尤其是不需要重新部署主合同，其地址可能被嵌入到许多系统和用户的钱包中。
- en: Handling Persistent Contract Addresses
  id: totrans-184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 处理持久合同地址
- en: In some situations, it may be desirable to keep a persistent contract address
    while maintaining the possibility of changing the implementation. For instance,
    if the contract address is imbedded in many other systems or registered with many
    users, changing the instance address may be an insurmountable endeavor and involve
    unmanageable synchronization issues.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，保持一个持久的合同地址的同时保持更改实现的可能性可能是有益的。例如，如果合同地址被嵌入到许多其他系统中，或者被许多用户注册，更改实例地址可能是一项无法克服的艰巨任务，并涉及无法管理的同步问题。
- en: This problem can be resolved by introducing a proxy contract that wraps the
    implementation contract. This is a well-known traditional technique that is especially
    relevant for this smart contract issue.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题可以通过引入一个包装实现合同的代理合同来解决。这是一个众所周知的技术，尤其适用于这个智能合约问题。
- en: 'An implementation of a proxy goes like this:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 代理的一个实现如下：
- en: You start with the interface of the desired functionality.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 你从所需功能的接口开始。
- en: '![Images](p0160-04.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0160-04.jpg)'
- en: Implement the proxy contract as callthroughs to the implementation contract
    functions.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 将代理合同实现为对实现合同功能的调用通过。
- en: The `log` function is a helper function to issue events on the proxy contract
    level.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`log` 函数是在代理合同层面发出事件的辅助函数。'
- en: '![Images](p0160-05.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0160-05.jpg)'
- en: '![Images](p0161-01.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0161-01.jpg)'
- en: The implementation class that implements the actual `doSomething` function is
    only allowed to be called from the proxy call.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 实现实际 `doSomething` 功能的类只能从代理调用中调用。
- en: '![Images](p0161-02.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0161-02.jpg)'
- en: Set up the proxy.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 设置代理。
- en: '![Images](p0162-01.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0162-01.jpg)'
- en: Correct call to implementation as a call to the proxy contract.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 正确地将实现作为对代理合同的调用。
- en: '`proxy.doSomething(this,0xFFF0);`'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`proxy.doSomething(this,0xFFF0);`'
- en: 'This is not allowed:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这是不允许的：
- en: '![Images](p0162-02.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0162-02.jpg)'
- en: If a change is needed, then change the implementation to a new class.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要更改，则将实现更改为新类。
- en: '`proxy.setImplementation(new ContractImplementation2(proxy))`'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`proxy.setImplementation(new ContractImplementation2(proxy))`'
- en: Now the same proxy call will call the new implementation.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在相同的代理调用将会调用新实现。
- en: '`proxy.doSomething(this,0xFFF0);`'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`proxy.doSomething(this,0xFFF0);`'
- en: Halting a Contract
  id: totrans-206
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Halting a Contract
- en: If an unforeseen event happens, like a severe bug in the EVM or the discovery
    of a vulnerability within the code, the assets within the contract might be in
    danger. In this case it will be a good idea to have a halt functionally that stops
    most (but not all) of the activity within the contract while the situation is
    evaluated.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生无法预见的事件，比如EVM中的严重漏洞或代码中的漏洞，合约内的资产可能会面临风险。在这种情况下，拥有一个暂停功能是一个好主意，它可以在评估情况时停止合约内的大部分（但不是全部）活动。
- en: This can easily be accomplished by adding a `notHalted` modifier to the functions.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过向函数添加一个`notHalted`修饰符来轻松实现。
- en: '![Images](p0162-03.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0162-03.jpg)'
- en: From a security perspective, the decision to halt the contract should be available
    for central system operators and security agencies, while the unhalt should be
    restricted to the owner—much like a normal emergency button where many people
    can stop the machinery, but only a few can start it again. Better safe than sorry.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 从安全角度讲，暂停合约的决定应该对中心系统运营商和安全机构可用，而恢复运行应该限制给所有者——就像一个普通的紧急按钮，许多人可以停止机器，但只有少数人可以再次启动它。安全总比后悔好。
- en: '![Images](p0162-04.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0162-04.jpg)'
- en: 'Smart Contract Life Cycle: Migration'
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'Smart Contract Life Cycle: Migration'
- en: If case of bugs, vulnerabilities, or the need to add some new features, a new
    contract is needed and should replace the old contract.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出现bug、漏洞或需要添加新功能，需要一个新的合约来替代旧合约。
- en: The basic idea with a smart contract migration is similar to a normal application
    migration. The state of the old smart contract is transferred securely to a new
    smart contract, and the old contract becomes inert or is destroyed.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约迁移的基本思想与正常应用迁移类似。旧智能合约的状态安全地转移到新智能合约，旧合约变得无效或被销毁。
- en: Here we have a trust issue. In the best-case scenario, the benign contract owner
    discovers a security issue, fixes the error and deploys a new contract, and as
    migration master puts the original smart contract into migration mode pointing
    to the new contract. Then each stakeholder transfers their state from the old
    contract to the new contract—that is, for a token contract the user transfers
    their tokens from the old contract to the new contract, and so on. Once all states
    (tokens, etc.) are transferred, the old contract can be destroyed or simply become
    an inactive void instance. Note that the *user* transfers the state, not the contract
    owner.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们存在一个信任问题。在最佳情况下，善意的合约所有者发现了一个安全问题，修复了错误并部署了一个新合约，作为迁移主控将原始智能合约置于迁移模式并指向新合约。然后每个利益相关者将自己的状态从旧合约转移到新合约——也就是说，对于一个代币合约，用户将他们的代币从旧合约转移到新合约，依此类推。一旦所有状态（代币等）都转移完毕，旧合约可以被销毁或简单地变成一个不活跃的空实例。注意是*用户*转移状态，而不是合约所有者。
- en: 'A migration interface could look like this:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移接口可能看起来像这样：
- en: '![Images](p0163-01.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0163-01.jpg)'
- en: When implementing the transfer function, we must ensure that it can only be
    called from the original smart contract.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现转账函数时，我们必须确保它只能从原始智能合约调用。
- en: '![Images](p0163-02.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0163-02.jpg)'
- en: '![Images](p0164-01.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0164-01.jpg)'
- en: Smart Contract Interaction with Users and Enterprise Applications
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Smart Contract Interaction with Users and Enterprise Applications
- en: As we discussed earlier, smart contracts and blockchain are only a part of a
    whole solution. If the bulk of the business logic is within the contract(s) and
    only a simple user application is needed, it can easily be implemented as a dapp.
    In an enterprise solution, smart contracts can be thought of as an asynchronous
    web service or a batch job component of the system.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前讨论的，智能合约和区块链只是整体解决方案的一部分。如果大部分业务逻辑在合约内，并且只需要一个简单的用户应用，这可以很容易地实现为一个dapp。在企业解决方案中，智能合约可以被看作是系统的一个异步网络服务或批处理作业组件。
- en: When integrating blockchains into an existing enterprise application, in many
    cases it is a good idea to expose the blockchain interaction through a standard
    web service. In this way, the “old” enterprise application developers don’t need
    to deal with or understand the particulars of blockchain interaction. From their
    perspective, it’s just an additional third-party component with normal async WEB-API
    behavior.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 当将区块链整合到现有的企业应用程序中时，在许多情况下通过标准Web服务暴露区块链交互是一个好主意。这样，"老"企业应用程序开发者不需要处理或理解区块链交互的细节。对他们来说，这只是一个具有正常异步WEB-API行为的额外第三方组件。
- en: Debugging Your Smart Contract
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调试你的智能合约
- en: Debugging is an essential part of application development. This is true for
    smart contract development as well. Unfortunately, in Solidity the `throw` keyword
    or calling `revert()` does not take any argument and cannot return any error number
    or error text. In non-trivial functions there can be several reasons for failure,
    and as a newbie or with complex contracts it can be difficult to quickly identify
    the reason for failure. This is a limitation of the current environment both during
    development debugging and debugging production problems. We hope this will be
    addressed in future versions of EVM and Solidity.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 调试是应用程序开发的重要组成部分。这对智能合约开发也是如此。不幸的是，在Solidity中，`throw`关键字或调用`revert()`不接受任何参数，也无法返回任何错误号或错误文本。在非琐碎函数中可能有几个失败的原因，对于新手或复杂合约，快速识别失败原因可能很困难。这是当前开发调试和生产问题调试环境的一个局限。我们希望未来版本的EVM和Solidity能够解决这一问题。
- en: 'Pitfall: The low-level functions `send`, `call`, `delegatecall`,and `callcode`
    return *false* in case of an error; they do *not* throw an error. Take extra care
    when using these functions and test thoroughly.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 陷阱：低级函数`send`、`call`、`delegatecall`和`callcode`在出错时返回*false*；它们不会抛出异常。使用这些函数时要格外小心，并彻底测试。
- en: Debugging Using Remix
  id: totrans-227
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用Remix进行调试
- en: As covered in [Chapter 6](ch6.xhtml#ch6), Remix Solidity IDE is one of the best
    debugging tools presently available. This tool allows you to code Solidity contracts,
    compile them, analyze them, and even run them. It is a great tool to try things
    out and to get acquainted with the mechanics and quirks of the Solidity and EVM
    environment. It also has a JavaScript VM that allows you to step through the function
    calls and identify problems and states, and is an indispensable tool to find those
    bugs that just elude your comprehension. Unfortunately, it currently only works
    well for small code bases. For large code bases containing many contracts, Remix
    becomes slow and even unworkable.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第6章](ch6.xhtml#ch6)所述，Remix Solidity IDE是目前可用的最佳调试工具之一。这个工具允许你编写Solidity合约，编译它们，分析它们，甚至运行它们。它是尝试事物和熟悉Solidity和EVM环境的机制和怪癖的好工具。它还有一个JavaScript
    VM，允许你逐步执行函数调用并识别问题和状态，是找出那些让你困惑的bug的不可或缺的工具。不幸的是，它目前只适用于小型的代码库。对于包含许多合约的大型代码库，Remix变得缓慢甚至无法使用。
- en: Debugging Using Events
  id: totrans-229
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用事件进行调试
- en: Another way to debug your code is to (mis)use an event. If you add an event
    like this one,
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种调试代码的方法是误用一个事件。如果你添加这样一个事件，
- en: '`event Debug(string text, uint value);`'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`event Debug(string text, uint value);`'
- en: 'then you can add calls like this to your code:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你可以在你的代码中添加这样的调用：
- en: '![Images](p0165-01.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0165-01.jpg)'
- en: You can then examine the values from the event log within your test environment.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你可以在测试环境中检查事件日志的值。
- en: Notice the premature `return` to prevent having the function throw, because
    otherwise all is reverted and no events are logged. It is the nearest thing to
    a `log.writeline` you can have in EVM. We often use this approach if we inadvertently
    introduce a throw bug that reveals itself within a complex Truffle test set, where
    the reason for the error is not obvious and is too cumbersome to reproduce in
    Remix.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 注意提前`return`以防止函数抛出异常，因为否则所有操作都会撤销，且不会记录任何事件。这是在EVM中能拥有的最接近`log.writeline`的东西。如果我们不经意间引入了一个在复杂Truffle测试集中显现出来的抛出异常的bug，而这个错误的原因不明显，在Remix中复现起来又过于繁琐，我们经常采用这种方法。
- en: Smart Contract Validation
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 智能合约验证
- en: Testing smart contracts is especially important since they cannot be changed
    once deployed. Therefore you definitely want to test and review every possible
    scenario that can unfold in the production network, including what happens when
    hackers are trying to steal the assets they contain.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 测试智能合约尤其重要，因为一旦部署，它们就无法更改。因此，你肯定希望测试和审查在生产网络上可能展开的每一个可能的场景，包括黑客试图窃取它们所包含的资产时会发生什么。
- en: Types of Tests
  id: totrans-238
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 测试类型
- en: The relevant tests can be divided into separate types and domains and are described
    individually.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 相关的测试可以分为不同的类型和领域，并分别描述。
- en: Functional Tests
  id: totrans-240
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 功能测试
- en: Firstly, you have the traditional CRUD-like function tests that ensure you can
    create, read, update, and delete entries, roles, users, etc., within your contract.
    This is just business as usual.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你有传统的CRUD-like函数测试，确保你可以在你的合约内创建、读取、更新和删除条目、角色、用户等。这只是日常工作。
- en: Normal Life Cycle Flow Tests
  id: totrans-242
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 正常生命周期流量测试
- en: These tests run through the different stages of a contract such as creating,
    preparing, running, halting, and terminating. They test that the contract can
    change stages correctly all the way from create to destroy. For each stage, it
    is tested that the functions for that stage can be called but also that functions
    for other stages *cannot* be called—for example, testing that `init` functions
    cannot be called in the running stage.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试通过合约的不同阶段，例如创建、准备、运行、停止和终止。它们测试合约能否正确地从创建到销毁的每个阶段都进行更改。对于每个阶段，都测试那个阶段的函数可以被调用，但其他阶段的函数*不能*被调用——例如，测试在运行阶段`init`函数不能被调用。
- en: Vulnerability Tests
  id: totrans-244
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 漏洞测试
- en: There are known vulnerabilities that need to be mitigated and tested.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些已知的漏洞需要缓解和测试。
- en: Overflow and Underflow Attacks
  id: totrans-246
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 溢出和下溢攻击
- en: Numbers like `uint` don’t fail on overflow or underflow like most other high-level
    languages, but just wrap around, maxsize assembler style. Why this design decision
    was made is beyond us.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 像`uint`这样的数字不会像大多数其他高级语言那样在溢出或下溢时失败，而是简单地绕过，最大尺寸汇编风格。为什么做出这种设计决策是我们无法理解的。
- en: 'Consider the code:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个代码：
- en: '![Images](p0166-01.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0166-01.jpg)'
- en: Here `a – 2` performed an underflow and becomes 115792089237316195423570985008687907853269984665640564039457584007913129639935.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里`a – 2`执行了下溢，变成了115792089237316195423570985008687907853269984665640564039457584007913129639935。
- en: And `b + 2` performs an overflow and becomes 1\. The same condition can be found
    for most other operations.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 而`b + 2`执行了溢出，变成了1。这个条件可以在大多数其他操作中找到。
- en: 'This constitutes an attack vector that may allow a user to call a function
    with a carefully designed value that triggers an arithmetic error, i.e., assigns
    a very large account value for an address. Normally these kinds of errors are
    mitigated by safe numeric operations like this:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这构成了一种攻击向量，可能允许用户用精心设计的值调用一个函数，触发算术错误，即给一个地址分配一个非常大的账户值。通常，这种类型的错误是通过安全数字操作来缓解的，就像这样：
- en: '![Images](p0166-02.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0166-02.jpg)'
- en: 'and used in contracts like this:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 并用在像这样的合约中：
- en: '![Images](p0166-03.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0166-03.jpg)'
- en: We don’t understand why this is not the default behavior since everyone has
    to add it to their contract code.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不明白为什么这不是默认行为，因为每个人都必须将其添加到他们的合约代码中。
- en: Recursive Call Attacks, Reentrancy Exploit
  id: totrans-257
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 递归调用攻击，重入漏洞
- en: 'Consider this code:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这段代码：
- en: '![Images](p0166-04.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0166-04.jpg)'
- en: This function withdraws all assets from an account (3), sends them to its owner
    (4), and updates the account balance to zero (5). However, since the `call.value`
    potentially hits a function at a sender’s contract, this function can call the
    `withdraw` function again before it is set to 0, thus withdrawing the balance
    value again and again until the original contract is depleted.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数从账户中提取所有资产（3），将它们发送给其所有者（4），并将账户余额更新为零（5）。然而，由于`call.value`可能会击中发送者合约中的一个函数，这个函数可以在设置为0之前再次调用`withdraw`函数，从而反复提取余额值，直到原始合约耗尽。
- en: 'Note that this attack might also be executed by calling a sequence of other
    functions on the original contract that exploit an incomplete state change. Normally
    this issue is mitigated by applying the Checks-Effects-Interaction pattern—that
    is:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这种攻击也可能通过调用原始合约上的其他一系列函数来执行，这些函数利用一个不完整的状态更改。通常，这个问题是通过应用Checks-Effects-Interaction模式来缓解的——也就是说：
- en: 1.   First Check all preconditions,
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 首先检查所有先决条件，
- en: 2.   Then perform all the Effects on the global state,
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 然后对全局状态执行所有Effects，
- en: 3.   And finally do Interactions with other contracts
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 最后与其他合约进行交互
- en: '![Images](p0167-01.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0167-01.jpg)'
- en: Test Contract at Maximum Capacity
  id: totrans-266
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 测试合约达到最大容量
- en: One consequence of the limited amount of gas in a block (BGL) is that you need
    to think about gas usage of the different functions when you keep adding items
    to the contract system. What happens at maximum capacity of the contract? Will
    the contract functions experience gas overflows at maximum capacity?
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 区块中有限数量的gas（BGL）的一个后果是你需要在不断向合约系统添加项目时考虑不同函数的gas使用情况。合约在最大容量时会发生什么？在最大容量时合约函数会经历gas溢出吗？
- en: Loops and recursive calls are especially critical. Will the operations have
    enough gas to execute in worst-case conditions? Try to identify the longest run
    for loops and the deepest recursive call. In fact, it’s best to avoid them altogether
    if possible. If that is not possible, ensure that they will have a defined upper
    limit within BGL.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 循环和递归调用尤其关键。在最坏的情况下，操作是否有足够的gas执行？尝试识别循环中的最长运行时间和最深递归调用。事实上，最好是完全避免它们。如果不可避免，确保它们在BGL内有定义的上限。
- en: Dry Run Using Private Nets
  id: totrans-269
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用私有网络进行干跑
- en: At the end of the day, testing with TestRPC and JavaScript VM isn’t the real
    McCoy. To be blunt, each test daemon implements its own particular quirks and
    errors that are different from the quirks and errors in the production environment.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 说到底，使用TestRPC和JavaScript VM进行测试并不是真正的东西。坦白说，每个测试守护进程都实现了自己独特的怪癖和错误，这些错误与生产环境中的怪癖和错误不同。
- en: Therefore, it is prudent to do a dry run of the intended usage (and misusage)
    using the real daemon, such as Geth or Parity. The actual code is the same in
    all environments. The only difference between executing in dev, testnet, or production
    is the chainId. In many cases, especially during development, it is desirable
    to run in a private blockchain. You don’t want to plaster testnet or production
    with half-baked contracts in your name. Fortunately, it’s rather easy to launch
    a private blockchain. Here it’s shown for Geth.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，谨慎地进行一次干跑，以测试预期的使用（和误用）情况，使用真实的守护进程，如Geth或Parity。在所有环境中实际代码都是相同的。在dev、testnet或生产环境中执行的唯一区别是chainId。在许多情况下，尤其是在开发过程中，运行在私有区块链中是可取的。你不希望用半成品的合约在你的名字测试网或生产网上涂抹。幸运的是，启动私有区块链相当容易。这里以Geth为例进行展示。
- en: In a test cycle, it’s preferable to start at the same state every time, so first
    delete all old chain information.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试周期中，每次最好从相同的状态开始，所以首先删除所有旧链信息。
- en: '![Images](p0168-01.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0168-01.jpg)'
- en: Then initialize a new blockchain using a configuration file.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用配置文件初始化一个新的区块链。
- en: '`geth --datadir=privChain init genesis_dev.json`'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '`geth --datadir=privChain init genesis_dev.json`'
- en: Finally, launch a node running your private blockchain.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，启动一个运行您私有区块链的节点。
- en: '![Images](p0168-02.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0168-02.jpg)'
- en: 'If you want your private node to run simultaneously with other nodes, add specification
    of the modified port like this:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要您的私有节点与其他节点同时运行，请像这样添加修改后的端口的规格：
- en: '`--port 30304 --rpcport=8551 --ipcpath “devgeth.ipc”`'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`--port 30304 --rpcport=8551 --ipcpath “devgeth.ipc”`'
- en: Then connect to the private node using the URL, e.g., [http://localhost:8551](http://localhost:8551).
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用URL连接到私有节点，例如[http://localhost:8551](http://localhost:8551)。
- en: 'The configuration file that reflects production details might look like this:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 反映生产细节的配置文件可能看起来像这样：
- en: '![Images](p0168-03.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0168-03.jpg)'
- en: Most are default values that should match production. The main values to set
    are the chainId and the alloc section where addresses can be prefilled with ether.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数都是默认值，应该与生产环境相匹配。需要设置的主要值是chainId和alloc部分，在该部分中可以预填充以太币地址。
- en: Autopsy of a Wallet Bug
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 钱包Bug的解剖
- en: On July 19, 2017, it was discovered that somebody had heisted three Parity multisig
    wallets. This resulted in a race where the community, with the White Hat Group
    (WHG) in front, tried to identify and mitigate the issue.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 2017年7月19日，有人发现有三个Parity多签名钱包被盗窃。这导致了一场社区与白帽小组（WHG）竞争的局面，他们试图识别并减轻问题。
- en: 'The constructor function looks like this:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数看起来像这样：
- en: '![Images](p0169-01.jpg)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0169-01.jpg)'
- en: As you can see, it delegates the initialization to a `_walletLibrary` function
    `initWallet` by constructing the call directly in memory using assembly opcodes.
    This code is not for the fainthearted. This is pure brain surgery—you don’t want
    to sneeze while writing this code.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，它通过使用汇编操作码直接在内存中构建调用，将初始化委托给`_walletLibrary`函数`initWallet`。这段代码不是给胆小的人看的。这是纯粹的大脑手术——编写这段代码时你不想打喷嚏。
- en: Also, the wallet default function uses the fact that if you call a function
    not defined in the wallet contract itself, it will be caught by the default function.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，钱包默认函数利用了这样一个事实：如果你调用的是未在钱包合约中定义的函数，它将被默认函数捕获。
- en: The `delegatecall` to `_walletLibrary` is called with the original function
    call data. This means that you will have implicit access to *all* the functions
    in `_walletLibrary` as they were implemented directly in the wallet contract.
    This is a very powerful mechanism but potentially also very dangerous.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 对`_walletLibrary`的`delegatecall`调用使用原始函数调用数据。这意味着你将隐式访问`_walletLibrary`中*所有*的函数，因为它们就像直接在钱包合约中实现一样。这是一个非常强大的机制，但也可能非常危险。
- en: '![Images](p0170-01.jpg)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0170-01.jpg)'
- en: One of the functions in the WalletLibrary is the `init` helper function `initWallet`
    we saw called in the constructor of the wallet, and that is what it was meant
    for. However, since there are no checks or modifiers on it, and with the `delegatecall`
    call in the default function, this unfortunately means that *everybody* can call
    the `initWallet` at *every* moment of the wallet life cycle. Thus, they gain owner
    control over the multisig wallet, making transferring money out of it like stealing
    candy from a baby.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 钱包库中的一个函数是我们在钱包构造函数中看到的`init`帮助函数`initWallet`，这就是它的用途。然而，由于它没有任何检查或修饰符，并且有默认函数中的`delegatecall`调用，这不幸意味着任何人在钱包生命周期的任何时刻都可以调用`initWallet`。因此，他们获得了多签钱包的所有者控制权，使得将资金转出钱包变得易如反掌。
- en: '![Images](p0170-02.jpg)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0170-02.jpg)'
- en: The fix was very simple, by just adding the missing modifier to control that
    the `init` helper functions can only be called in the initialization phase.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 修复方法非常简单，只需向控制`init`帮助函数只能在其初始化阶段被调用的修改器中添加缺失的修饰符。
- en: '![Images](p0170-03.jpg)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0170-03.jpg)'
- en: 'This clearly illustrates how important it is to think very thoroughly about
    each and every function:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子清楚地说明了深入思考每一个函数的重要性：
- en: •   What are the preconditions?
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: •   前提条件是什么？
- en: •   Who is allowed to call it?
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: •   谁被允许调用它？
- en: •   When in the life cycle is it allowed to be called?
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: •   它在生命周期中的哪个阶段被允许调用？
- en: Moreover, test that when you call it at the right moment as the rightful operator,
    it indeed does what it is supposed to do (normal unit testing). Even more important,
    test that if you are not the rightful operator or call it in the wrong state,
    it will do no harm and will in fact be rejected (security testing).
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 而且，测试在正确的时间以合法操作者的身份调用它时，它确实能完成它应该完成的工作（正常单元测试）。更重要的是，测试如果你不是合法操作者或者在错误的状态下调用它，它不会造成伤害并且实际上会被拒绝（安全测试）。
- en: Writing thorough test cases is a job magnitude larger and more comprehensive
    than writing the contract itself.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 编写详尽的测试用例比编写合约本身的工作量要大得多，也更加全面。
- en: The Future
  id: totrans-302
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 未来
- en: One part of the smart contract development system that lags behind is automated
    testing. Using and extending the NatSpec comments could easily facilitate the
    generation of skeleton testing code that would significantly reduce the time spent
    on setting up unit and security testing.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约开发系统中落后的一部分是自动化测试。利用和扩展NatSpec注释可以很容易地生成骨架测试代码，这将显著减少设置单元和安全测试所需的时间。
- en: However, the elephant in the room is the lack of scalability, which limits wide
    adaptation. It also makes blockchain vulnerable to denial-of-service attacks by
    flooding it with spam transactions. Also, to support microtransactions the transaction
    price needs to be lower. To become a universal and scalable platform, this problem
    has to be solved. One solution that tries to address the problem is the Lightning
    Network–like implementation for Ethereum called the Raiden Network. This work-in-progress
    project supplements the Ethereum blockchain with an offline chain to settle microtransactions.
    However, it requires preallocation of tokens/ether that are taken offline by transferring
    them to the Raiden Network before they can be utilized. This introduces a locking
    of assets offchain equal to the total liquidity needed. Also, it doesn’t solve
    the scalability of general smart contracts. Other types of blockchain projects
    try to address this problem too. One example is the EOS Project, a generalized
    platform based on features from Steemit and Ethereum. This platform has no transaction
    fee and offers three-second block transactions without congestion by allowing
    parallelism in block execution and thereby introducing horizontal scalability
    beyond the 100,000 transaction per second mark.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，房间里的大象是可扩展性的缺乏，这限制了广泛的应用。这也使得区块链容易受到通过垃圾交易淹没它的服务拒绝攻击。此外，为了支持微交易，交易价格需要更低。为了成为一个通用和可扩展的平台，这个问题必须解决。一个尝试解决这个问题的解决方案是针对以太坊的闪电网络式的实现，名为Raiden网络。这个进行中的项目通过一个离线链补充以太坊区块链，以解决微交易。然而，它需要预分配代币/以太币，通过将其转移到Raiden网络来离线。这引入了等于所需总流动性的资产离线锁定。此外，它并没有解决一般智能合约的可扩展性问题。其他类型的区块链项目也试图解决这个问题。一个例子是以太坊操作系统（EOS）项目，它基于Steemit和以太坊的功能特性。这个平台没有交易费，并通过允许块执行中的并行性，提供每3秒一个块的交易，从而引入水平可扩展性，超过每秒100,000个交易。
- en: Another example is the IOTA project, which is designed directly for massive
    microtransactions between IoT devices. In IOTA when you need to add a transaction,
    you need to validate two other transactions and check for conflicts before submitting
    into a tangle (connected graph), so you become your own miner, thus eliminating
    the need to pay somebody else for the validation. Strictly speaking, IOTA is not
    a chain of blocks containing transactions but rather a mesh of linked transactions.
    On the roadmap, IOTA will include smart contracts and oracles.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是IOTA项目，它专门为IoT设备之间的大量微交易而设计。在IOTA中，当你需要添加一个交易时，你需要验证两个其他交易并检查冲突，然后才能提交到纠缠（连接图），所以你成为自己的矿工，从而消除了支付给别人验证的必要性。严格来说，IOTA不是包含交易的区块链，而是一系列链接交易的网络。在路线图上，IOTA将包括智能合约和预言机。
- en: Absolute privacy is also an issue. Even though addresses are anonymous in the
    sense that the identities behind them are not normally registered, all transactions
    and balances are publicly available by design. If you use ether to pay to an address
    that uses some kind of KYC, either directly or indirectly, it is possible to back-trace
    your spending habits and wealth. Monero is an example of a blockchain that focuses
    on complete anonymity that is secure, private, and untraceable. It uses ring signatures
    where decoy addresses are added to the transaction, making it possible to hide
    the origin of a transaction. With stealth addresses (one-time addresses), the
    destination address is obscured. By using ring confidential transactions, the
    value of the transactions is hidden by cryptographical algorithms, but still verifiable.
    All in all, it ensures complete anonymity end to end. As yet they don’t have Lightning
    Network or smart contracts, but those are on the roadmap.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 绝对隐私也是一个问题。尽管地址在某种意义上匿名，因为背后的身份通常没有注册，但所有交易和余额都是公开的。如果你用以太币支付到一个进行某种KYC验证的地址，无论是直接还是间接，可能会追溯到你的消费习惯和财富。门罗币是一个专注于完全匿名、安全、私密的区块链的例子。它使用环签名，在交易中添加诱饵地址，从而可能隐藏交易来源。通过一次性地址（stealth
    addresses），目的地地址被隐藏。通过使用环密文交易，交易的价值通过加密算法隐藏，但仍然可以验证。总的来说，它确保了端到端的完全匿名。他们还没有闪电网络或智能合约，但这些已经在路线图上。
- en: Ripple XRP is a private centralized permission-based blockchain that acts like
    a worldwide transfer between bank accounts à la SWIFT. It’s designed to scale
    to the same performance as VISA by implementing a peer-to-peer ledger network
    with a distributed agreement protocol. Instead of including the smart contract
    into the core blockchain, Ripple decided to implement a separate platform, Codius,
    for the smart contract and oracle part, which also allows cross-blockchain applications.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: Ripple XRP 是一个私有的、集中式的、基于权限的区块链，其作用类似于 SWIFT 银行账户之间的全球转账。它通过实现一个点对点的账本网络和分布式共识协议，旨在扩展到与
    VISA 相同的性能。Ripple 决定不将智能合约包含在核心区块链中，而是实现一个单独的平台 Codius，用于智能合约和预言机部分，这也允许跨区块链应用程序。
- en: When looking at roadmaps for the different blockchains, it’s clear that they
    have many of the same properties in mind. These include scaling the number of
    transactions to allow both volume and micropayments, as well as the inclusion
    of smart contracts and integration of oracles. All of these are where the best
    practices in this chapter will come in handy.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看不同区块链的路标时，很明显它们有很多相似的属性。这些包括扩展交易数量以允许交易量和微支付，以及智能合约的包含和预言机的集成。所有这些都是本章中最佳实践用武之地的地方。
- en: Summary
  id: totrans-309
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: As we have seen in this chapter, the EVM provides a rich environment that enables
    development of solutions ranging from simple dapps, over simple interactions with
    oracles to fetch external information, all the way to full stack enterprise solutions.
    The smart contract platform includes all the features for creating modern code
    with multiple contracts calling and interaction with each other, including producing
    events to external systems. Also, we have recognized the importance of clear design
    in terms of modularity, roles and security, and life cycle management. Finally,
    because of blockchain’s immutable nature, testing and validating of smart contracts
    need special attention prior to deployment on the blockchain.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本章所看到的，EVM 提供了一个丰富的环境，使得从简单的 dapps 开发，通过与预言机简单交互以获取外部信息，一直到完整的栈式企业解决方案的开发成为可能。智能合约平台包括所有创建现代代码所需的特性，多个合约之间的调用和相互交互，包括向外部系统产生事件。此外，我们认识到了在模块性、角色和安全性以及生命周期管理方面清晰设计的重要性。最后，由于区块链的不变性，
    smart contracts 在部署到区块链之前需要特别关注测试和验证。
