["```\ncd go-ipfs\n/install.sh\n/ipfs init\nipfs cat <readme file>\ncat <filename>\nipfs add <filename>\n\n```", "```\nimport Table from 'react-bootstrap/Table';\nimport Grid from 'react-bootstrap/Container';\nimport Form from ‘react-bootstrap/Form’;\nimport Button from ‘react-bootstrap/Button’;\nimport React, { Component } from 'react';\nimport logo from './logo.svg';\nimport './App.css';\nimport web3 from './web3';\nimport ipfs from './ipfs';\nimport storehash from './storehash';\n\nclass App extends Component\n{\n  state =\n  {\n   ipfsHash:null,\n   buffer:'',\n   ethAddress:'',\n   blockNumber:'',\n   transactionHash:'',\n   gasUsed:'',\n   txReceipt: ''\n  };\n  captureFile =(event) =>\n  {\n   event.stopPropagation()\n   event.preventDefault()\n   const file = event.target.files[0]\n   let reader = new window.FileReader()\n   reader.readAsArrayBuffer(file)\n   reader.onloadend = () => this.convertToBuffer(reader)\n  };\n\nconvertToBuffer = async(reader) =>\n{\n //file is converted to a buffer to prepare for uploading to IPFS\n  const buffer = await Buffer.from(reader.result);\n //set this buffer -using es6 syntax\n this.setState({buffer});\n};\n\nonClick = async () =>\n{\n try\n {\n  this.setState({blockNumber:\"waiting..\"});\n  this.setState({gasUsed:\"waiting…\"});\n\n  // get Transaction Receipt in console on click\n  await web3.eth.getTransactionReceipt(this.state.transactionHash, (err, txReceipt)=>\n{\n  console.log(err,txReceipt);\n  this.setState({txReceipt});\n });//await for getTransactionReceipt\n await this.setState({blockNumber: this.state.txReceipt.blockNumber});\n await this.setState({gasUsed: this.state.txReceipt.gasUsed});\n} //try\n catch(error)\n {\n console.log(error);\n } //catch\n} //onClick\n\nonSubmit = async (event) =>\n{\n  event.preventDefault();\n\n  //bring in user's Metamask account address\n     const accounts = await web3.eth.getAccounts();\n\n  console.log('Sending from Metamask account: ' + accounts[0]);\n\n  //obtain contract address from storehash.js\n  const ethAddress= await storehash.options.address;\n  this.setState({ethAddress});\n\n  //save document to IPFS,return its hash#, and set hash# to state\n  await ipfs.add(this.state.buffer, (err, ipfsHash) =>\n  {\n   console.log(err,ipfsHash);\n   //setState by setting ipfsHash to ipfsHash[0].hash\n   this.setState({ ipfsHash:ipfsHash[0].hash });\n\n   // call Ethereum contract method \"sendHash\" and .send IPFS hash to contract\n   //return the transaction hash from the ethereum contract\n   storehash.methods.sendHash(this.state.ipfsHash).send({\n   from: accounts[0]\n  }, (error, transactionHash) => {\n   console.log(transactionHash);\n    this.setState({transactionHash});\n  }); //storehash\n }) //await ipfs.add\n};\n\nrender()\n{\n return(\n  <div className=\"App\">\n   <header className=\"App-header\">\n     <h1>Blockchain Storage</h1>\n     <img src=\"https:ipfs.io/ipfs/QmVqKYfEjdHmbWD4qML5RezYakhRQC3aJL5vj2qb4cBu8m\" width=\"90\" height=\"90\"/>\n   </header>\n   <hr/>\n\n  <Grid>\n    <h3>Select a file to upload on the Blockchain Storage</h3>\n   <Form onSubmit={this.onSubmit}>\n    <input\n     type = \"file\"\n     onChange = {this.captureFile}\n   />\n     <Button\n     bsStyle=\"primary\"\n     type=\"submit\">\n     Submit\n     </Button>\n  </Form>\n\n   <img src={‘https:ipfs.io/ipfs/${this.state.ipfsHash}‘} alt=\"\"/>\n   <hr/>\n    <Button onClick = {this.onClick}> Get Transaction Receipt </Button>\n    <Table bordered responsive>\n  <thead>\n   <tr>\n    <th>Tx Receipt Category</th>\n    <th>Values</th>\n   </tr>\n</thead>\n\n<tbody>\n  <tr>\n   <td>IPFS Hash # stored on Eth Contract</td>\n   <td>{this.state.ipfsHash}</td>\n  </tr>\n  <tr>\n   <td>Ethereum Contract Address</td>\n   <td>{this.state.ethAddress}</td>\n  </tr>\n\n  <tr>\n   <td>Tx Hash # </td>\n   <td>{this.state.transactionHash}</td>\n  </tr>\n  <tr>\n   <td>Block Number # </td>\n   <td>{this.state.blockNumber}</td>\n  </tr>\n\n  <tr>\n   <td>Gas Used</td>\n   <td>{this.state.gasUsed}</td>\n  </tr>\n  </tbody>\n </Table>\n </Grid>\n </div>\n);\n}\n}\nexport default App; \n```", "```\n//using infura.io node, otherwise ipfs requires to run a\ndaemon on computer/server.\nconst IPFS = require('ipfs-api');\nconst ipfs = new IPFS({ host: 'ipfs.infura.io', port:\n5001, protocol: 'https' });\n\n//run with local daemon\n// const ipfsApi = require('ipfs-api');\n// const ipfs = new ipfsApi('localhost', '5001',\n{protocol: 'http'});\n\nexport default ipfs;\n\n```", "```\nimport web3 from './web3';\n//access our local copy to contract deployed on rinkeby\ntestnet\n//use your own contract address \nconst address =\n'0xb84b11953f5bcf01b08f926728e855f2d4a62a9';\n//use the ABI from contract\nconst abi = [\n  {\n    \"constant\": true,\n    quot;inputs\": [],\n    \"name\": \"getHash\",\n    \"outputs\":[\n  {\n        \"name\":\"x\",\n        \"type\": \"string\"\n  }\n    ],\n    \"payable\": false,\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n    },\n    {\n    \"constant\": false,\n    \"inputs\": [\n    {\n        \"name\": \"x\",\n        \"type\": \"string\"\n    }\n    ],\n    \"name\": \"sendHash\",\n    \"outputs\": [],\n    \"payable\": false,\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n    }\n  ]\n\nexport default new web3.eth.Contract(abi, address);\n\n```", "```\nuser sends government id to creator;\ncreator checks;\ncd 1: the validity of government id;\ncd 2 : consistency of government and user;\nif cd 1= cd 2 = true, then;\nuser provides smartphone to creator;\nif user can unlock smartphone using biometric\ninformation, then;\ncreator and smartphone together run (public key, private key)\n← KeyGen;\nprivate key is securely stored in smartphone;\ncreator collects information about user from government\nid;\ncreator generates a certificate with both public key and\ninformation, and authenticate certificate with its\nprivate key;\nreturn certificate;\nend if;\nend if;\nreturn fail;\n\n```", "```\nuser receives a transaction tx from blockchain;\nif user recognizes tx and wants to authorize it, then;\nuser unlocks smartphone using their biometric\ninformation;\nif smartphone accepts user’s biometric, then;\nsmartphone uses private key to generate a digital signature\nof tx and returns it to user;\nuser submits signature to blockchain;\nreturn 1;\nend if\nend if return 0;\n\n```", "```\ncontext . verify ( . . .\nreply : {\n[unowned self] (s,err)\n−> Void in\nif ( s ) {\n// fingerprint supplied by user matches\n// Process the transaction from blockchain\n} else {\n// Display err\n}\n} )\n\n```"]