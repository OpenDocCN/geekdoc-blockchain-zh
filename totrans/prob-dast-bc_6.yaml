- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: '[Part IV](contents.xhtml#rpart4)'
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[第四部分](contents.xhtml#rpart4)'
- en: '[Integration of Probabilistic Data Structures with Blockchain](contents.xhtml#rpart4)'
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[将概率数据结构与区块链集成](contents.xhtml#rpart4)'
- en: </hgroup>
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: <hgroup>
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: '[14](contents.xhtml#rchapter14)'
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[14](contents.xhtml#rchapter14)'
- en: '[Applicability of Membership Query PDS with Blockchain](contents.xhtml#rchapter14)'
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[将成员查询 PDS 应用于区块链](contents.xhtml#rchapter14)'
- en: </hgroup>
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '[14.1 Full Blockchain Client vs Lightweight Blockchain Client](contents.xhtml#rsec14_1)'
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[14.1 完整的区块链客户端与轻量级区块链客户端](contents.xhtml#rsec14_1)'
- en: As discussed in [subsection 6.1.3](08chap_06.xhtml#sec6_1_3), blockchain supports
    two types of clients. A full blockchain node stores a full copy of the digital
    ledger. The entire history of blocks has to be downloaded and stored. As it is
    time-consuming and requires high space to download the entire blockchain. This
    poses a heavy requirement on resources, memory, bandwidth, and computing of blockchain
    nodes. Along with disk space consumption, another concern is overhead of verifying
    the correctness of broadcasted block due to growth of Bitcoin volume. So, blockchain
    supports another type of client to solve the problem of resource and memory-constrained
    devices. In contrast to a full client, a lightweight client can transact without
    downloading full copy of the blockchain. Nevertheless, the lightweight client
    only stores block header in order to achieve the PoW blockchain concept. However,
    a lightweight client has to reference a trusted full client's copy of the blockchain.
    The full client only forwards the copy of the transactions requested by lightweight
    client.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如[子节 6.1.3](08chap_06.xhtml#sec6_1_3)所述，区块链支持两种类型的客户端。完整的区块链节点存储数字账本的完整副本。必须下载并存储整个区块链的全部历史记录。由于下载整个区块链需要耗费时间，并且需要大量的存储空间。这对区块链节点的资源、内存、带宽和计算都提出了严格的要求。除了磁盘空间消耗之外，另一个问题是由于比特币量的增长而增加的验证广播块正确性的开销。因此，区块链支持另一种类型的客户端来解决资源和内存受限设备的问题。与完整客户端相反，轻量级客户端可以在不下载完整区块链副本的情况下进行交易。然而，轻量级客户端仅存储区块头以实现
    PoW 区块链概念。但是，轻量级客户端必须引用可信完整客户端的区块链副本。完整客户端仅转发轻量级客户端请求的交易副本。
- en: In this context, SPV is a method used by lightweight client to verify whether
    a transaction is included in a block or not without downloading the entire blockchain.
    The process of verification has been described in [subsection 6.1.3](08chap_06.xhtml#sec6_1_3).
    Readers may refer to that subsection. Along with checking the existence of a transaction
    in a block, Lightweight clients can also verify the block's difficulty. To verify,
    the lightweight client checks whether a block has successful cryptographic ink
    to the previous block. Also, the lightweight client checks whether PoW solution
    meets the block difficulty or not. The difference between full blockchain client
    and lightweight blocchain client is shown in [Table 14.1](#tab14_1).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '**TABLE 14.1**'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Full blockchain client vs lightweight blockchain client.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '| **Full blockchain client** | **Lightweight blockchain client** |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
- en: '| Stores entire history (full copy) of blockchain distributed ledger | No need
    to download full copy of blockchain ledger |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
- en: '| No reference to any other node required | References one or more full client
    for performing operations |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
- en: '| Provides greater privacy | Lightweight client has to specify transaction
    to full nodes. Hence, privacy risks exists |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
- en: '| Mostly consists of computer system | Mobile consists of mobile wallets |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
- en: '| Nodes have mining rights | No mining rights are given to lightweight clients
    |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
- en: '| Contributes to full functionality of a network | No contribution in functionality
    og the network |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
- en: '| No dependency on third-party or any other node | Dependency on light wallet
    provider |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
- en: '| Full control over your own money | No guarantee that referenced full node
    is online when required |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
- en: '| Full clients maintenance is highly complex | Provides ease of use |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
- en: '| These nodes have to verify the correctness of each transaction of the network
    | These nodes doesn''t have rights to verify blocks to be added in blockchain
    network |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
- en: Key point
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: A full client can fool a lightweight client by simply not providing interested
    transaction. This is a case of DoS attack. However, by connecting to more than
    one full nodes, this problem can be solved.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 完整客户端可以通过简单地不提供感兴趣的交易来欺骗轻量级客户端。这是一种 DoS 攻击。但是，通过连接到多个完整节点，可以解决这个问题。
- en: '[14.2 BF with probabilistic data structures](contents.xhtml#rsec14_2)'
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[14.2 使用概率数据结构的 BF](contents.xhtml#rsec14_2)'
- en: '[14.2.1 Bitcoin using BF](contents.xhtml#rsec14_2_1)'
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[14.2.1 使用 BF 的比特币](contents.xhtml#rsec14_2_1)'
- en: 'Notably, SPV client does not need to list every transaction in which they are
    interested in (this could be thousand in number). In this context, a BF can be
    used with SPV clients. Rather than directly sending an interested transaction''s
    address list, BF can be used with SPV clients to achieve a space-efficient means
    to acquire the transaction of interest. All the addresses required by SPV client
    are embedded in BF and is forwarded to associated full client. The step by step
    sequence of this process is described as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，SPV 客户端无需列出他们感兴趣的每一笔交易（可能有数千笔）。在这种情况下，BF 可以与 SPV 客户端一起使用。BF 不直接发送感兴趣交易的地址列表，而是将
    BF 嵌入到 SPV 客户端中，并转发给相关的完整客户端。这个过程的步骤顺序如下所述：
- en: Here, client forms a BF by inserting addresses of all interested transaction.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这里，客户端通过插入所有感兴趣交易的地址形成 BF。
- en: When referenced full client comes online, the lightweight client establishes
    a connection with the full client and upon a successful connection, formulated
    BF is transferred over a secure channel.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当完整客户端上线时，轻量级客户端与完整客户端建立连接，连接成功后，经过安全通道传输构建的 BF。
- en: For every received block of transaction, the full client will first check it
    against BF received from SPV/lightweight clients.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于收到的每个交易块，完整客户端将首先根据从 SPV/轻量级客户端接收到的 BF 进行检查。
- en: In case of positive results matched transactions along with some Merkle branch
    required to achieve Merkle hash is sent to SPV client. The sequence steps between
    SPV client and full client is represented in [Fig. 14.1](#fig14_1).
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在匹配的正结果的情况下，与一些 Merkle 分支一起实现 Merkle 哈希所需的交易发送到 SPV 客户端。 SPV 客户端和完整客户端之间的序列步骤在
    [图 14.1](#fig14_1) 中表示。
- en: '![Figure 14.1](../images/fig14_1.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.1](../images/fig14_1.jpg)'
- en: '**FIGURE 14.1.**'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 14.1.**'
- en: Sequence of steps between SPV client and Full Client.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: SPV 客户端和完整客户端之间的步骤顺序。
- en: '**Issues with SPV client**'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**SPV 客户端存在的问题**'
- en: A full node now knows all public addresses of the transaction received by the
    requesting light client, this fact obviously violates the client's privacy. Information
    such as- purchase habits may get released with this privacy threat. Also, it can
    lead to DoS attack.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在完整节点知道了请求的轻客户端接收的交易的所有公共地址，这个事实显然违反了客户端的隐私。购买习惯等信息可能会随着这种隐私威胁而被泄露。此外，它可能导致
    DoS 攻击。
- en: A full node may get compromised by attacker and steals BF pertaining to SPV
    client. Moreover, in case of Sybil attack (where attacker intentionally generates
    lots of malicious nodes) launched by attacker, the chances of picking any malicious
    node as full client increases.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unfortunately, the false positive probability exists in this case as well which
    implies may be an unwanted transaction can be transferred to the lightweight client.
    However, this property creates difficulty to recognize Bitcoin address owned by
    users as it is hard to identify what positive addresses are actually inside BF.
    Nevertheless, authors of [[86](bib.xhtml#ch00-bib-86)] suggested that false positive
    of BF is not enough to preserve privacy of SPV client. Also, high false positive
    rate waste more network bandwidth. However, a SPV client with enough bandwidth
    may choose high positive rate. This implies full client can't accurately judge
    the interested transaction of SPV client. Infact, a BF with much high false positive
    rate would result in downloading almost entire blockchain. In contrast, by setting
    a low FP rate, full node would know exactly the transaction of interest for a
    SPV client as specific transactions would be downloaded only. Moreover, low FP
    rates would result in faster synchronization for SPV clients whereas high FPR
    rate leads to high synchronization time as large number of transactions are downloaded
    tcolorbox
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Key point:** BF represents a tradeoff between privacy and network bandwidth.'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The size of memory request gets increased with the increase in number of addresses
    possessed by SPV client.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Research on preserving privacy of SPV client using BF**'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Authors of [[86](bib.xhtml#ch00-bib-86)] discussed the issue of addresses information
    leakage with BF used by SPV client. The authors have concluded and observed the
    following points:'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is shown by experiment that address information leakage depends on number
    of addresses used by SPV client to form BF. It has been concluded that if an SPV
    client constructs BF with ¡20 addresses, the risk of information leakage is high
    as compared to case if 20 plus addresses are embedded in BF.
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实验证明地址信息泄漏取决于 SPV 客户端用于形成 BF 的地址数量。研究结论表明，如果一个 SPV 客户端构建 BF 时使用 ¡20 个地址，则与嵌入
    BF 中使用 20 个以上地址的情况相比，信息泄漏的风险较高。
- en: If an adversary is able to collect more than one BF from same SPV client, this
    situation leaks considerable more number of addresses. Hence, construction of
    more than one BF by same SPV client should be avoided. Moreover, BF should be
    formed with different elements and different seeds in order to avoid much information
    leakage by adversary.
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果对手能够从同一个 SPV 客户端收集到多个 BF，这种情况会泄露出更多的地址。因此，应该避免同一个 SPV 客户端构建多个 BF。此外，为了避免对手通过，BF
    应该由不同的元素和不同的种子组成，从而避免泄露过多的信息。
- en: Information leakage is worsen if SPV client is restarted and a adversary can
    link two different BF with same elements but different parameters. Hence, SPV
    client should remember state for their outsourced BF in order to avoid recomputing
    a new filter with same elements but different parameters.
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 SPV 客户端重新启动，对手可以将两个具有相同元素但不同参数的不同 BF 进行关联，这会加剧信息泄露。因此，SPV 客户端应该记住其外包的 BF
    的状态，以避免重新计算具有相同元素但不同参数的新过滤器。
- en: Notably, for a fixed false positive rate of BF, privacy level preserved depends
    on total number of unique addresses in the block. As these total number of unique
    addresses in a block may increase steadily, so it is important to decide a strategy
    for privacy preservation while designing BF. In this context, authors of [[114](bib.xhtml#ch00-bib-114)]
    proposed a privacy metric, i.e., *γ*-deniability to determine how truly involved
    addresses are hidden by false positive rate of BF. Basically, *γ* is a parameter
    to control privacy level while designing SPV client's BF. *γ*-deniability depicts
    measure of how much addresses inserted in BF are kept balanced by false positive
    Bitcoin addresses. However to create a BF that specify a particular *γ*, it is
    required to have information about the number of unique addresses from the last
    checkpoint to latest block (Nu). To calculate Nu, without accessing the entire
    blockchain, linear regression model s suggested by authors. To check the mathematics
    behind estimation scheme of Nu, readers may refer to [[114](bib.xhtml#ch00-bib-114)].
    After computing Nu using linear regression model and target *γ*, the array size
    of BF can be constructed. It has been shown in results that as compared to conventional
    scheme, achieved privacy level is high in the proposed scheme.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authors of [[163](bib.xhtml#ch00-bib-163)] explained that there is another implementation
    of SPV client where this client downloads whole Bitcoin blockchain from full node
    to verify a single transaction of interest. However, client will only keep the
    interested transactions from block and discard rest other transactions. This approach
    is privacy preserving as no other node on the network can determine the transaction
    of interest for SPV client. Unfortunately, this way there is lots of bandwidth
    wastage. Here, authors used the concept of private information retrieval (PIR)
    to create fully private queries with low bandwidth and low latency cost. PIR enable
    users to query a database in a way that database doesnot learn anything about
    user's query. The system model of this proposal involves different PIR servers
    that responds to PIR queries of SPV client and provides required data to perform
    operations. PIR server don't learn anything about user-centric transaction data.
    PIR server actually first downloads whole blockchain and stores it in PIR database.
    For every database, a description file named manifest file is created by PIR server.
    SPV client still downloads BF from associated full client and fetches manifest
    file to query PIR database afterwards.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To integrate BF with BC, a similar approach in [[23](bib.xhtml#ch00-bib-23)],
    presents a method that leverages fast chain synchronization by not sending any
    irrelevant transaction to SPV Client. Three messages perform operations between
    lightweight client and full client: *filterload* message initializes and set current
    BF on connection, *filteradd* message updates current BF by adding data elements
    to current BF, *filterclear* message deletes current BF in use. Also, authors
    concluded that compact size of BF enables fast membership which consequently open
    up risk for DoS attack. Moreover, SPV approach can lead to privacy issue as full
    client has information regarding bitcoin address used by SPV client. However,
    false positive generated by BF makes it difficult for a full client to identify
    actual addresses but it cannot completely hide the anonymity of addresses of SPV
    Client. Besides, high FPR can lead to wastage of network bandwidth [[153](bib.xhtml#ch00-bib-153)].'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要将 BF 与 BC 集成，[23](bib.xhtml#ch00-bib-23) 中提出了一种类似的方法，该方法通过不向 SPV 客户端发送任何不相关的事务来利用快速链同步。三条消息在轻量级客户端和完整客户端之间执行操作：*filterload*
    消息在连接上初始化并设置当前 BF，*filteradd* 消息通过向当前 BF 添加数据元素来更新当前 BF，*filterclear* 消息删除正在使用的当前
    BF。此外，作者得出结论，BF 的紧凑大小使得快速成员资格成为可能，从而增加了 DoS 攻击的风险。此外，SPV 方法可能导致隐私问题，因为完整客户端拥有关于
    SPV 客户端使用的比特币地址的信息。然而，BF 生成的误报使得完整客户端难以识别实际地址，但它无法完全隐藏 SPV 客户端地址的匿名性。此外，高 FPR
    可能导致网络带宽的浪费 [153](bib.xhtml#ch00-bib-153)。
- en: '[14.2.1.1 PoW using BF](contents.xhtml#rsec14_2_1_1)'
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[14.2.1.1 使用 BF 的 PoW](contents.xhtml#rsec14_2_1_1)'
- en: 'In addition to SPV implementation, PoW mechanism of Bitcoin uses BF to avoid
    nonce reuse attack. To realize In addition to SPV implementation, PoW mechanism
    of Bitcoin uses BF to avoid nonce reuse attack [[24](bib.xhtml#ch00-bib-24)].
    To realize this each verifier employs two BF''s: current and previous. Before
    computing PoW, each nonce is checked against both BF''s and for positive membership
    results, reject the nonce value and compute <math alttext="" display="inline"><mrow><mi>S</mi><mi>H</mi><mi>A</mi><mo>−</mo><mn>256</mn><mo
    stretchy="false">(</mo><mi>S</mi><mi>H</mi><mi>A</mi><mo>−</mo><mn>256</mn><mo
    stretchy="false">(</mo><mo>+</mo><mo>+</mo><mi>n</mi><mo>|</mo><mo>|</mo><mi>h</mi><mo
    stretchy="false">)</mo><mo stretchy="false">)</mo></mrow></math>(where, *n* is
    nonce and *h* is previous header) to check whether MSB bits of results match with
    the given target. Finally, add nonce value *n* to update current BF. Also, the
    verifier can reset current BF by copying current BF to previous BF.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 除了SPV实现外，比特币的PoW机制使用BF来避免nonce重复使用攻击。为了实现这一点，每个验证器都使用两个BF：当前的和先前的。在计算PoW之前，会对每个nonce分别对这两个BF进行检查，对于正面的成员资格结果，拒绝nonce值并计算<math
    alttext="" display="inline"><mrow><mi>S</mi><mi>H</mi><mi>A</mi><mo>−</mo><mn>256</mn><mo
    stretchy="false">(</mo><mi>S</mi><mi>H</mi><mi>A</mi><mo>−</mo><mn>256</mn><mo
    stretchy="false">(</mo><mo>+</mo><mo>+</mo><mi>n</mi><mo>|</mo><mo>|</mo><mi>h</mi><mo
    stretchy="false">)</mo><mo stretchy="false">)</mo></mrow></math>（其中，*n*是nonce，*h*是先前的头）来检查结果的MSB位是否与给定的目标匹配。最后，将nonce值*n*添加到更新当前的BF。此外，验证器可以通过将当前的BF复制到先前的BF来重置当前的BF。
- en: '[14.2.2 Ethereum using BF](contents.xhtml#rsec14_2_2)'
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[14.2.2 以太坊使用BF](contents.xhtml#rsec14_2_2)'
- en: Other than *Bitcoin, Ethereum* also integrates BF to achieve better space efficiency.
    Parameters in Ethereum storage are indexed, to filter the event logs for specific
    value/address [[215](bib.xhtml#ch00-bib-215)]. Receipt of each transaction is
    encoded in Ethereum. Each transaction receipt is denoted as *BR[i]* where *i*
    represents ith transaction. This receipt consists of 4 items, i.e., (R, Ru, Rl,
    Rb) where R signifies post transaction state, Ru signifies the amount of cumulative
    gas consumed in block holding the transaction receipt just immediately after the
    transaction has been executed, Rl signifies set of logs created while execution
    of transactions and Rb signifies BF constructed from information in each log entries.
    The BF is of 2048 bits. With BF entire Ethereum blockchain can be scanned in seconds
    to find logs matching specific topic.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 除了比特币，以太坊也集成了BF以实现更好的空间效率。以太坊存储中的参数是索引的，以便为特定值/地址过滤事件日志。每个交易的收据都被编码在以太坊中。每个交易收据被表示为*BR[i]*，其中*i*表示第*i*个交易。这个收据包括4个项目，即(R,
    Ru, Rl, Rb)，其中R表示交易后的状态，Ru表示在执行交易后立即持有交易收据的区块中累积消耗的气体量，Rl表示在执行交易时创建的日志集，Rb表示从每个日志条目中的信息构造的BF。BF是2048位。使用BF可以在几秒钟内扫描整个以太坊区块链，以查找与特定主题匹配的日志。
- en: Whenever a new block is created, the address of any logging contract and indexed
    fields of logs generated when transaction has happened are inserted in BF and
    this BF is added to the block header. Indexed fields mostly consists of address
    fields of transaction including “to, from and smart contract address” and other
    log topics (e.g., transfer). Nevertheless, actual logs are not added to the block
    header in order to save space. If an application requires to find log entries
    of a given contract or having specific indexed fields, it just need to scan each
    block header to retrieve BF to check for relevant logs it contains or not. In
    case of positive results, the node again executes the transaction from that block,
    regenerates logs, and return the relevant ones. However, direct indexing of the
    transaction by addresses can put a high burden on target machine. In this context,
    the authors in [[166](bib.xhtml#ch00-bib-166)] proposed a method using BF that
    extracts account wise information of individual account in an improvised way.
    Also, authors in [[90](bib.xhtml#ch00-bib-90)] proposed a cuckoo filter to check
    address membership. It has been concluded that cuckoo filter performs fast membership
    search over SBF.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 每当创建新的区块时，任何日志合约的地址以及发生交易时生成的日志的索引字段都会被插入 BF 中，并将此 BF 添加到区块头中。索引字段主要包括交易的地址字段，包括“收件人、发件人和智能合约地址”，以及其他日志主题（例如，转账）。然而，实际的日志并没有添加到区块头中，以节省空间。如果应用程序需要查找给定合约的日志条目或具有特定索引字段，它只需要扫描每个区块头以检索
    BF，以查看其中是否包含相关日志。在出现积极结果的情况下，节点会再次执行该区块的交易，重新生成日志，并返回相关日志。然而，通过地址直接索引交易可能会给目标机器带来很大负担。在这种情况下，作者在[[166](bib.xhtml#ch00-bib-166)]提出了一种使用
    BF 的方法，以一种改进的方式提取各个账户的账户信息。此外，[[90](bib.xhtml#ch00-bib-90)]的作者提出了一种布谷鸟过滤器来检查地址成员资格。已经得出结论，布谷鸟过滤器在
    SBF 上执行快速成员搜索。
- en: '[14.2.3 Integration of blockchain and BF for certificate revocation](contents.xhtml#rsec14_2_3)'
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[14.2.3 区块链与 BF 在证书吊销中的集成](contents.xhtml#rsec14_2_3)'
- en: Authors of [[64](bib.xhtml#ch00-bib-64)] proposed to use blockchain for a certificate
    management system which is the core component of public key infrastructure. Here.
    All the associated operations to certificates are stored on the blockchain for
    public audit. However, the authors described some of the concerns with blockchain
    for certificate management.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '[[64](bib.xhtml#ch00-bib-64)]的作者提出使用区块链进行证书管理系统，这是公钥基础设施的核心组件。在这里，所有与证书相关的操作都存储在区块链上供公开审计。然而，作者描述了一些与区块链用于证书管理的关切。'
- en: 'Centralization in practice: Due to privileged nodes which possess high stakes
    or better computational capability in consensus algorithm including PoW, PoS,
    etc., there is a risk of centralization in the network.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实践中的中心化：由于在包括 PoW、PoS 等共识算法中拥有高利益或更好的计算能力的特权节点，网络存在中心化风险。
- en: 'Block size management: As discussed earlier, the current block size of the
    blockchain is specific and limited. However, in some case certification revocation
    list size can reach up to 76 MB which clearly does not get fit to one block. Hence
    more than one block is required to store CRL information. Therefore, to check
    information regarding certificate revocation becomes insufficient.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 区块大小管理：正如前面讨论的，区块链的当前区块大小是特定的且有限的。然而，在某些情况下，证书吊销列表的大小可达 76 MB，显然无法适应一个区块。因此，需要多个块来存储
    CRL 信息。因此，检查有关证书吊销的信息变得不足。
- en: To maintain the brevity of this book, we will not discuss the solution to the
    first problem. We are just discussing the integration of blockchain and Bitcoin.
    Readers may refer to the original paper for detailing.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持本书的简洁，我们不讨论第一个问题的解决方案。我们只讨论区块链和比特币的集成。读者可以参考原始论文以获取详细信息。
- en: In order to solve the later issue, i.e., block size limitation, authors have
    presented a revocation checking method using Dual Counting Bloom Filter (DCBF).
    DCBF provides efficient query processing and economic storage. The whole certificates
    of the system are divided into two sets, i.e., valid certificate set and revoked
    certificate set. To store two different varieties of sets two counting BF's are
    employed, i.e., CBF1 and CBF2\. The updated or newly created certificates are
    stored in CBF1 and a revoked certificate is first deleted from CBF1, then stored
    in CBF2\. When a block is created, both CBF1 and CBF2 are stored in one block.
    To check for a revoked certificate, first, the certificate in question is passed
    through CBF2\. If this BF returns negative, the certificate is marked as a valid
    certificate. Otherwise, in case of positive results, the certificate is matched
    in CBF1\. If the result is negative in this case, the certificate is revoked definitely
    whereas, for positive results, related operations of certificates are then checked
    in the block. Comparing results in two BF's ensures the accurate status of certificate
    without any false positive.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决后一个问题，即区块大小限制，作者提出了使用双计数布隆过滤器（DCBF）进行吊销检查的方法。DCBF 提供了高效的查询处理和经济的存储。系统的整个证书被分为两组，即有效证书集和已吊销证书集。为了存储两种不同的集合，使用了两个计数
    BF，即 CBF1 和 CBF2。更新或新创建的证书存储在 CBF1 中，而吊销的证书首先从 CBF1 中删除，然后存储在 CBF2 中。当创建一个块时，CBF1
    和 CBF2 都存储在一个块中。要检查吊销的证书，首先将待检查的证书通过 CBF2。如果此 BF 返回负值，则将证书标记为有效证书。否则，在结果为正数的情况下，在
    CBF1 中匹配证书。如果在这种情况下结果为负数，则证书被明确吊销，否则，则检查块中的证书相关操作。比较两个 BF 的结果可确保证书的准确状态而无误报。
- en: '[14.2.4 Integration of blockchain and BF in smart grid sector](contents.xhtml#rsec14_2_4)'
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[14.2.4 区块链与 BF 在智能电网领域的集成](contents.xhtml#rsec14_2_4)'
- en: In research work [[91](bib.xhtml#ch00-bib-91)], the authors have presented solutions
    to achieve privacy in the smart grid. Here, authors employ blockchain for data
    aggregation rather than relying on trusted third-party. The system architecture
    divides all users of smart grid in different groups as per their electricity consumption
    type. The keys of all users are initialized by a key management center (KMC).
    KMC basically allocates multiple public and private keys to each user and the
    public key is used as a user's pseudonym. In each time slot, a new miner node
    is chosen according to electricity consumption data. The selected miner node aggregates
    nodes data and records this data in private blockchain to ensure message integrity.
    To select a miner node, a random procedure is followed. The node whose electricity
    consumption data is nearest to average electricity consumption data for a time
    slot, that node is selected as the miner node. A user of the network can create
    multiple pseudonyms to submit their electricity generation/consumption information.
    This way users true identity can't be revealed.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在研究工作[[91](bib.xhtml#ch00-bib-91)]中，作者提出了在智能电网中实现隐私的解决方案。在这里，作者采用区块链进行数据聚合，而不是依赖可信的第三方。系统架构将智能电网的所有用户根据其用电类型分成不同的组。所有用户的密钥由密钥管理中心（KMC）初始化。KMC基本上为每个用户分配多个公钥和私钥，并且公钥被用作用户的化名。在每个时间段，根据电力消耗数据选择一个新的矿工节点。所选的矿工节点聚合节点数据，并将这些数据记录在私有区块链中，以确保消息完整性。为了选择一个矿工节点，遵循一个随机的过程。那个电力消耗数据最接近时间段平均电力消耗数据的节点，就被选为矿工节点。网络用户可以创建多个化名来提交他们的电力发电/消耗信息。这样一来，用户的真实身份就无法被揭示。
- en: Moreover, to ensure fast authentication in the blockchain-based system, BF is
    used. BF probes the existence of fake pseudonyms using zero-knowledge proof. The
    bloom filter is constructed for each different group by using pseudonyms for that
    group and the constructed BF is sent to all nodes in the corresponding group.
    To authenticate the validity of a user, the registered pseudonym of the user is
    passed through BF. If there is a positive match, the user is authenticated otherwise
    not. Notably, identity authentication is done using zero-knowledge proof. In case
    an unregistered user uses a pseudonym and sends wrong information to the system,
    BF can validate a user's pseudonym with efficient space consumption. Therefore
    is a user without registration at KMC tries to send false information to the network,
    this attempt will get fail as mapping value in BF will contain at least one zero.
    To avoid false positive, authors have suggested that the array size of BF should
    be sufficiently large so that the probability of hash collisions ca be decreased.
    [Fig. 14.2](#fig14_2) shows the identity management system using bloom filter.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了确保在基于区块链的系统中进行快速认证，使用了BF。BF使用零知识证明来探测假冒的伪名的存在。为每个不同的组构建布隆过滤器，使用该组的伪名，并将构建的BF发送到相应组中的所有节点。为了验证用户的有效性，将用户的注册伪名通过BF。如果有积极匹配，则对用户进行验证，否则不进行验证。值得注意的是，使用零知识证明进行身份认证。如果未注册用户使用伪名并向系统发送错误信息，则BF可以使用有效的空间消耗验证用户的伪名。因此，如果在KMC没有注册的用户尝试向网络发送错误信息，则此尝试将失败，因为BF中的映射值将至少包含一个零。为了避免误报，作者建议BF的数组大小应足够大，以减少哈希碰撞的概率。[图
    14.2](#fig14_2)显示了使用布隆过滤器的身份管理系统。
- en: '![Figure 14.2](../images/fig14_2.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.2](../images/fig14_2.jpg)'
- en: '**FIGURE 14.2.**'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 14.2.**'
- en: Identity Authentication Management System using BF.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 使用BF的身份认证管理系统。
- en: '[14.2.5 Integration of blockchain and Bitcoin for bodyworn sensing devices](contents.xhtml#rsec14_2_5)'
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[14.2.5 集成区块链和比特币用于身体佩戴传感设备](contents.xhtml#rsec14_2_5)'
- en: Health issuers are developing strategies to collaborate with bodyworn devices
    with their policies. Although bodyworn IoT devices generate quite private information
    about patient's routine and this information should not be tampered with in any
    sense [[209](bib.xhtml#ch00-bib-209)]. In order to address the concern of secure
    data logging, authors of [[172](bib.xhtml#ch00-bib-172)] presented a lightweight
    solution. Here, all smart devices that lie in same broadcast domain serve as witnesses
    for neighboring devices by logging all data conversation in a chain like structure.
    However, a gateway is employed for detailed logging of all information that it
    conducts with sensor devices. Basically, sensor devices record all conversations
    they overhear in the network and maintain a record and forward it to the gateway.
    Notably, there is heavy traffic in the network with this approach which uses large
    memory and imposes high communication overhead for witnesses. As a solution, rather
    than recording the whole conversation, these devices use BF to store fingerprints
    of conversation in chronological order instead. Hence, using BF reduces space
    complexity. After a certain time, witnesses upload their signed BF to the gateway.
    The digital signing ensures integrity and non-repudiation in the system. Moreover,
    to reduce false positive probability authors have suggested using different hash
    functions.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[14.2.6 Graphene: Block propagation protocol](contents.xhtml#rsec14_2_6)'
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In distributed systems, it is always required to minimize the network bandwidth
    for efficient synchronization among replicas. Clearly, the efficiently designed
    network protocol for synchronization of newly mined block and newly created transactions
    provides may benefits. For example, if blocks are passed on consuming less network
    data, consequently maximum block size can be increased. Additionally, there will
    be an increase in processing of overall number of transactions per second. Many
    researchers are trying to invent techniques that transmits block with less bandwidth.
    The lesser the bandwidth is used, faster the blocks or messages will be propagated
    in the network. Blocks transferred with less bandwidth not only increases synchronization
    among peers but also reduces forks in the chain. Graphene protocol in blockchain
    is believed to be a protocol which transmits block with minimum amount of bandwidth
    possible.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, Bitcoin miners aim to broadcast the newly founded block fast as delay
    of even milliseconds increases the probability of other blocks to be added into
    the BC. This motivates a miner to cut the number of transactions to be added in
    a block. Miners in Bitcoin network keep a memory pool for all unconfirmed transactions.
    Miners choose some transaction from memory pool and construct a new candidate
    block. If mining pool of all the miners are ideally synchronized and they use
    same protocol for selecting the transactions to be added to their candidate block.
    This eliminates the need to include transactions in blocks and enables each miner
    to reconstruct a block from memory pool. In real scenarios, memory pool of miners
    are not perfectly synchronized, thus it leads to inefficiency in block propagation.
    To address this issue, authors in [[159](bib.xhtml#ch00-bib-159)] presented a
    protocol named Graphene to design new blocks for a BC based network. It integrates
    BF with a Inverse Bloom Lookup Table (IBLT) to solve the issue of set reconciliation
    in P2P network. IBLT [[25](bib.xhtml#ch00-bib-25)] solves the problem of calculating
    difference in two data sets which helps in determining what data sets share in
    common. To synchronize the blocks, sender first constructs a IBLT from transaction
    ID's in block. Also, it constructs a BF using same transaction ID's. The receiver
    utilizes BF to strain transactions ID's from memory pool and construct its own
    IBLT. Finally, receiver decodes the difference between two blocks. This way network
    bandwidth can be decreased significantly. Simulation results proved that with
    Graphene, network traffic decreases dramatically.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，比特币矿工的目标是尽快广播新发现的区块，因为哪怕延迟只有毫秒级别，也会增加其他区块被添加到区块链的概率。这促使矿工减少要添加到一个区块中的交易数量。比特币网络中的矿工保留了一个未确认交易的内存池。矿工从内存池中选择一些交易并构建一个新的候选区块。如果所有矿工的挖矿池都是理想同步的，并且它们使用相同的协议来选择要添加到其候选区块中的交易。这消除了将交易包含在区块中的需要，并使每个矿工能够从内存池重建一个区块。在真实场景中，矿工的内存池并不完全同步，因此导致区块传播的低效。为了解决这个问题，作者在[[159](bib.xhtml#ch00-bib-159)]中提出了一个名为
    Graphene 的协议，用于设计基于区块链的网络的新区块。它将 BF 与反布隆过滤器查找表（IBLT）集成在一起，以解决P2P网络中的集合协调问题。IBLT
    [[25](bib.xhtml#ch00-bib-25)] 解决了计算两个数据集之间差异的问题，这有助于确定这两个数据集共享的内容。为了同步区块，发送方首先从区块中的交易ID构造一个
    IBLT。此外，它使用相同的交易ID构造了一个 BF。接收方利用 BF 从内存池中提取交易ID并构建自己的 IBLT。最后，接收方解码两个区块之间的差异。这样可以显著减少网络带宽。模拟结果证明，使用
    Graphene，网络流量显著减少。
- en: '[14.2.7 Anti-malware software using BF and blockchain](contents.xhtml#rsec14_2_7)'
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[14.2.7 使用 BF 和区块链的反恶意软件](contents.xhtml#rsec14_2_7)'
- en: With the increase in Internet usage, the threats of viruses and malwares also
    gets increased. Mostly, anti-malware programs work by matching signatures of attack
    to arbitrary input stream. Nevertheless, its important to update these pattern
    matching mechanism in order to protect users from all types of new malwares. The
    idea of deploying a centralized update server is obviously a target for malicious
    attacker.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 随着互联网使用量的增加，病毒和恶意软件的威胁也在增加。大多数反恶意软件程序通过将攻击签名与任意输入流进行匹配来工作。然而，重要的是更新这些模式匹配机制，以保护用户免受所有类型的新恶意软件的侵害。部署集中式更新服务器的想法显然是恶意攻击者的目标。
- en: 'Authors of [[156](bib.xhtml#ch00-bib-156)] provides a architecture named “BitAV”
    that scans the input with less memory usage and fast speed. Along with this, BitAV
    provides decentralized updates and maintenance by relying on blockchain based
    system. Systems can distribute the novel virus pattern on blockchain which increases
    the fault tolerance. Moreover, the blockchain enabled P2P maintenance mechanism
    that improves end-to-end performance and it is comparatively less susceptible
    to DoS attack. The blockchain structure of BitAV blockchain is similar to Bitcoin
    implementation. The only difference comes in the way transaction fields works.
    BitAV stores two information in place of transaction field, i.e, identifier and
    invalidation fields. The identifier field enables addition of new malware identifiers.
    The rest metadeta section is same as the Bitcoin header section to ensure verifiability.
    Every new identifier on blockchain holds format: *[Identifier][Publickey][Signature]*.
    Over and above, the scanning mechanism of BitAV uses a BF to enable constant time
    key value queries. Instead of storing signatures of malwares or their updates,
    BF stores them in hash format to save space and to reduce query time.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '[[156](bib.xhtml#ch00-bib-156)] 的作者提供了一种名为“BitAV”的架构，它以更少的内存使用和更快的速度扫描输入。除此之外，BitAV
    通过依赖基于区块链的系统提供了分散式更新和维护。系统可以在区块链上分发新型病毒模式，从而提高了容错性。此外，区块链启用的对等维护机制提高了端到端性能，并且相对不太容易受到
    DoS 攻击。BitAV 区块链的结构类似于比特币实现。唯一的区别在于交易字段的工作方式。BitAV 在交易字段的位置存储两个信息，即标识符和使字段。标识符字段使得可以添加新的恶意软件标识符。其余的元数据部分与比特币头部部分相同，以确保可验证性。区块链上的每个新标识符都保持以下格式：*[标识符][公钥][签名]*。此外，BitAV
    的扫描机制使用 BF 实现了恒定时间的键值查询。BF 不是存储恶意软件或其更新的签名，而是以哈希格式存储它们，以节省空间并减少查询时间。'
- en: '[14.2.8 Transaction execution in disaster prone area using BF and blockchain](contents.xhtml#rsec14_2_8)'
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[14.2.8 在灾难多发地区使用 BF 和区块链进行交易执行](contents.xhtml#rsec14_2_8)'
- en: Authors of [[157](bib.xhtml#ch00-bib-157)] utilizes a BF and blockchain to enable
    mobile based transaction mechanism in a disaster prone area. Here, it is assumed
    that there is no or limited access to bank in a disaster prone area as there is
    no Internet connectivity to this area. Endorsers supports absolute payment security
    for transactions between customer and merchant. Similar to Bitcoin, here also
    transactions are stored in blockchain like structure. Nevertheless, in this approach
    computing PoW by Miners is not required. Users computes hash of transactions log
    and other neighboring nodes add this signature to the log after verification to
    form an event chain. An event chain is a use case of cryptographic hash function
    on block. Rather than signing entire log, endorser computes hash value of previous
    block and sends it to monitor. Furthermore, monitor signs on the integration of
    hash value, GPS co-ordinate, spending of coin and sends back to endorser. Each
    user on the network stores event chain as their transaction log. Whenever a new
    event happens, a new block is cryptographically linked to last event chain. In
    case a mobile phone is switched off, the event chain is considered broken as the
    device is not able to ping messages with neighboring monitor nodes. Therefore,
    restricting a new event from being added to the event chain.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '[[157](bib.xhtml#ch00-bib-157)] 的作者利用 BF 和区块链在灾难易发区域实现基于手机的交易机制。在这里，假设灾难易发区域没有或只有有限的银行接入，因为该地区没有互联网连接。背书者支持客户和商家之间的交易绝对安全性。与比特币类似，在这里，交易也以类似区块链的结构存储。然而，在这种方法中，矿工不需要计算
    PoW。用户计算交易日志的哈希值，其他邻近节点在验证后将此签名添加到日志中以形成事件链。事件链是对块上的加密哈希函数的用例。背书者不是签署整个日志，而是计算前一个块的哈希值并将其发送给监控器。此外，监控器对哈希值、GPS
    坐标、硬币花费进行整合并发送回给背书者进行签名。网络上的每个用户都将事件链存储为其交易日志。每当发生新事件时，都会将一个新块与上一个事件链进行加密链接。如果手机关闭，事件链被视为中断，因为设备无法与相邻监控节点发送消息。因此，限制了将新事件添加到事件链的可能性。'
- en: Additionally, in order to depict all spent e-coin from the beginning, a BF is
    used. All spent e-coins are mapped using hash function to BF. Rather than storing
    all ID's of spent e-coins, only the hashes of ID's are recorded in event chain.
    To check double spending of a certain e-coin, BF is probed. Clearly, communication
    overhead is reduced by using a BF.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了描绘从一开始花费的所有电子硬币，使用了布隆过滤器（BF）。所有花费的电子硬币都使用哈希函数映射到 BF 上。与存储所有已花费电子硬币的 ID
    不同，只记录 ID 的哈希值在事件链中。要检查特定电子硬币的双重支付，需要探测 BF。显然，通过使用 BF 可以减少通信开销。
- en: '[14.2.9 Non-equivocation with BF and blockchain](contents.xhtml#rsec14_2_9)'
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[14.2.9 利用 BF 和区块链实现的非否认性](contents.xhtml#rsec14_2_9)'
- en: Authors of [[197](bib.xhtml#ch00-bib-197)] discussed their concerns on non -equivocation
    by a Certificate authority. If a CA equivocates different contradicting certificates
    for the same identity, it can compromise user's privacy. Hence, non-revocation
    is indeed an important necessity in security system today including blockchain
    based transparency and public key distribution. However with online trusted parties
    non-equivocation is difficult again because of privacy concerns and single point
    of failure.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '[197](bib.xhtml#ch00-bib-197)的作者讨论了他们对证书颁发机构不明确的担忧。如果CA对同一身份发布不一致的证书，可能会危及用户的隐私。因此，无撤销确实是当今安全系统中的重要必需品，包括基于区块链的透明度和公钥分发。然而，由于隐私问题和单点故障，使用在线可信方面的无不明确又变得困难。'
- en: 'To address this issue, authors have used Bitcoin witness approach, mainly due
    to three reasons:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，作者采用了比特币见证方法，主要有三个原因：
- en: Bitcoin witnesses scheme is resistant to forking attacks.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比特币见证方案对分叉攻击具有抵抗能力。
- en: It involves a single global witnesses, i.e., Bitcoin blockchain and other multiple
    trusted entities for example, log providers and auditors are not allowed.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它涉及单一全球见证，即比特币区块链，其他多个可信实体，例如日志提供商和审计员不被允许。
- en: Bitcoin blockchain provides open, decentralized and transparent environment
    to provide a efficient witnesses system.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比特币区块链提供了开放、去中心化和透明的环境，以提供高效的见证系统。
- en: Authors present their scheme with name Catena that reduces auditors bandwidth
    and provides tamper-evident log on the top of Bitcoin blockchain. Also, with Catena,
    forking is not allowed. Each Catena transaction consists of exactly one statement
    and previous catena transaction is suspended, thus creating a chain of transactions.
    Along with prevention of equivocation attack, Man-in-the-Middle (MITM) attacks
    are also prevented with Catena. Here, Bitcoin blockchain employs a trustworthy
    witnesses that can confirm for directory digest. For instance, in certificate
    transparency a log server can be employed to directly witness signed heads via
    a Catena log. Additionally, auditors who are running client interface can check
    for non-equivocation via SPV method. Similar to SPV verification, clients only
    have to download Bitcoin block headers and some pieces of Merkle hash to check
    for non-equivocation. Here also, thin clients relies on BF in order to avoid downloading
    whole data. Thin nodes insert only transactions of interest or its relevant connections
    in BF to filter out irrelevant transactions. Therefore, with using BF, Catena
    clients only receive relevant Catena transactions. Notably, authors of this scheme
    also pointed out that thin nodes have less security than full nodes.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 作者提出了他们的方案，名为 Catena，可以减少审计员的带宽，并在比特币区块链顶部提供防篡改的日志。此外，使用 Catena，不允许分叉。每个 Catena
    交易都包含正好一个语句，并暂停上一个 catena 交易，从而创建一系列交易。除了防止模棱两可攻击外，Catena 还可以防止中间人（MITM）攻击。在这里，比特币区块链采用了可信的见证人，可以确认目录摘要。例如，在证书透明度中，可以使用日志服务器直接见证通过
    Catena 日志签名的头部。此外，运行客户端界面的审计员可以通过 SPV 方法检查非模棱两可性。类似于 SPV 验证，客户端只需下载比特币区块头和一些 Merkle
    散列片段即可检查非模棱两可性。在这里，轻量级客户端依靠 BF，以避免下载完整的数据。轻节点只插入感兴趣的交易或其相关连接以在 BF 中过滤掉不相关的交易。因此，使用
    BF，Catena 客户端只接收相关的 Catena 交易。值得注意的是，该方案的作者还指出，轻节点的安全性比完整节点低。
- en: '[14.2.10 Outdoor health monitoring using blockchain and BF](contents.xhtml#rsec14_2_10)'
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[14.2.10 使用区块链和 BF 进行户外健康监测](contents.xhtml#rsec14_2_10)'
- en: A popular application of IoT is in health care system [[149](bib.xhtml#ch00-bib-149)][[214](bib.xhtml#ch00-bib-214)].
    In this context, Unmanned aerial vehicle (UAV) can provide help to body wearable
    sensors in outdoor by alarming unpredictable problems for example, natural disaster
    and traffic hotspot. (UAV also known as drones is a type of aircrraft without
    a pilot on board and it has capability to provide efficient solutions in military,
    civil, and commercial sectors for audio and video surveillance [[138](bib.xhtml#ch00-bib-138)].)
    Notably, UAV collaborated with mobile edge computing (MEC) can enable real-time
    support to users to store their health related information to MEC server. MEC
    brings cloud storage services near to user proximity [[45](bib.xhtml#ch00-bib-45)].
    Nevertheless, communication link between UAV and MEC suffers lots of cyber threats
    such as- MITM etc. Also, MEC server is prone to data integrity attack.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: IoT 的一个热门应用是在医疗保健系统中[[149](bib.xhtml#ch00-bib-149)][[214](bib.xhtml#ch00-bib-214)]。在这种情况下，无人机（UAV）可以在户外为身体可穿戴传感器提供帮助，例如，在自然灾害和交通热点等不可预测的问题上发出警报。（无人机也被称为无人驾驶飞行器，它是一种没有机上飞行员的飞行器，具有在军事、民用和商业领域提供高效解决方案的能力，用于音频和视频监视[[138](bib.xhtml#ch00-bib-138)]。）值得注意的是，无人机与移动边缘计算（MEC）合作，可以实现实时支持用户将其健康相关信息存储到MEC服务器上。MEC将云存储服务带到用户附近[[45](bib.xhtml#ch00-bib-45)]。然而，无人机和MEC之间的通信链路面临着诸多网络威胁，例如中间人攻击等。此外，MEC服务器容易受到数据完整性攻击的威胁。
- en: Authors of [[110](bib.xhtml#ch00-bib-110)] suggested to blockchain as a solution
    for resolving security issues existing among UAV and MEC server. This is the first
    attempt when outdoor health monitoring system is proposed using blockchain. Here,
    health information that is collected from via UAV from users and stored on MEC
    server is protected with blockchain based architecture. To validate users, authors
    have used BF and health data is only stored in blockchain if blockchain validators
    them. Every user first registers on the network and for that user first generate
    a public and private key pair by using ECC. Next, user requests MEC server for
    registration. The health data collected from wearable devices and this data is
    transferred to MEC server via UAV. Before sending health care data, user encrypt
    this data using public key of UAV. Next, after decrypting health data UAV users
    using BF. Finally after successful validation, MEC encrypts health data and forwards
    to nearest MEC server. However before forwarding data, UAV validates identity
    of user with BF. Hence, using a BF in this case reduces data transmission. MEC
    server decrypts this data and checks this data for finding abnormalities. In case
    of any issue it is reported to the hospital. To validate the results parameters,
    i.e., processing time of MEC server, UAV validation time, UAV energy consumption,
    transmission of data for MEC server are used. It has been proved in experiments
    expected size of transmission data increases at much lower rate with BF over non-BF.
    With increase in number of users, data increases exponentially for non-BF.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[14.2.11 Multi-domain collaboration for MEC in 5G and beyond based on blockchain
    and BF](contents.xhtml#rsec14_2_11)'
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The rapid growth of IoT and 5G systems accelerates the concept of Internet of
    everything [[145](bib.xhtml#ch00-bib-145)], [[55](bib.xhtml#ch00-bib-55)]. Clearly,
    this increase in number of devices lead to high growth of data. However, this
    high data growth possess challenge for the computing power of 5G systems and cloud
    computing models [[58](bib.xhtml#ch00-bib-58)]. To solve this problem, heterogeneous
    MEC system were designed [[132](bib.xhtml#ch00-bib-132)], [[220](bib.xhtml#ch00-bib-220)].
    Heterogeneous MEC is designed as a distributed computing platform integrating
    more than one MEC server, cloud server, and computing storage that provides intelligent
    edge services near the data source. As these systems have short transmission link,
    edge computing responds quickly to the service request. Nevertheless, in order
    to accomplish a heterogeneous MEC system, multiple MEC servers needs to integrate
    their resources so as to complete large scale computing tasks. Unfortunately,
    this multi-server collaboration involves trust and security issues as these server
    belongs to different domains and they are managed by different organization. MEC
    server contacts other MEC servers via cross-domain routing enabled by SDN controller.
    However, to ensure cross-domain routing among multiple server, SDN controller
    demands topology information of other domain. Notably, this information of different
    domain should be confidential to each other and this privacy leakage can harm
    MEC system.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 物联网和5G系统的快速增长加速了万物互联的概念[[145](bib.xhtml#ch00-bib-145)]，[[55](bib.xhtml#ch00-bib-55)]。显然，设备数量的增加导致了数据的高增长。然而，这种高数据增长对5G系统和云计算模型的计算能力构成了挑战[[58](bib.xhtml#ch00-bib-58)]。为了解决这个问题，设计了异构MEC系统[[132](bib.xhtml#ch00-bib-132)]，[[220](bib.xhtml#ch00-bib-220)]。异构MEC被设计为一个分布式计算平台，集成了一个以上的MEC服务器、云服务器和计算存储，提供靠近数据源的智能边缘服务。由于这些系统具有短传输链路，边缘计算能够快速响应服务请求。然而，为了实现异构MEC系统，多个MEC服务器需要整合它们的资源，以完成大规模的计算任务。不幸的是，这种多服务器协作涉及信任和安全问题，因为这些服务器属于不同的域，由不同的组织管理。MEC服务器通过SDN控制器启用的跨域路由与其他MEC服务器联系。然而，为了确保多个服务器之间的跨域路由，SDN控制器需要其他域的拓扑信息。值得注意的是，不同域的这些信息应该对彼此保密，否则隐私泄露可能会损害MEC系统。
- en: Authors in [[218](bib.xhtml#ch00-bib-218)] resolves privacy leakage issue using
    blockchain. Here, blockchain enables trusted data sharing between MEC servers
    to achieve trusted collaboration of multi-domain MEC network. Also, this system
    adopts accommodative BF as a carrier to help multi-domain collaborative routing
    consensus without revealing topology privacy.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '[[218](bib.xhtml#ch00-bib-218)]中的作者使用区块链解决了隐私泄露问题。在这里，区块链实现了MEC服务器之间的可信数据共享，实现了多域MEC网络的信任合作。此外，该系统采用了适应性BF作为载体，帮助实现多域协作路由一致性，而不会泄露拓扑隐私。'
- en: First, a cross-domain MEC request arrives at controller A through domain 1\.
    As per this request, controller A computes intra domain path for domain 1 and
    choses the optimal one with minimized sum of weights. While a new request is also
    send to controller of subsequent domain having virtual topology of domain 1\.
    Also, controller A constructs BF containing the routing results from the controller.
    Here, BF maintains distributed ledger and efficient routing mechanism. In specific,
    BF are also used as a carrier of routing verification. [Tables 14.2](#tab14_2),
    and [14.3](#tab14_3) represents tabular comparison of above discussed scheme.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，跨领域的MEC请求通过域1到达控制器A。根据此请求，控制器A为域1计算域内路径，并选择总权重最小的最优路径。同时，还向后续域的控制器发送新请求，其中包含域1的虚拟拓扑。此外，控制器A构建包含控制器路由结果的BF。在这里，BF维护分布式账本和高效的路由机制。具体而言，BF还用作路由验证的载体。[表14.2](#tab14_2)和[14.3](#tab14_3)代表上述方案的表格比较。
- en: '**TABLE 14.2**'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**表14.2**'
- en: Comparison between different schemes integrating blockchain with BF.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 比较不同方案将区块链与BF集成的情况。
- en: '![Table 14.2](../images/tab14_2.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![表14.2](../images/tab14_2.jpg)'
- en: '**TABLE 14.3**'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**表14.3**'
- en: Comparison between different schemes integrating blockchain with BF.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 比较不同方案将区块链与BF集成的情况。
- en: '![Table 14.3](../images/tab14_3.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![表14.3](../images/tab14_3.jpg)'
- en: '[14.3 Integration of QF with Blockchain](contents.xhtml#rsec14_3)'
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[14.3 QF与区块链的集成](contents.xhtml#rsec14_3)'
- en: QF serves the same purpose as BF. However, BF fails if data does not fit inside
    main memory. Literature does not support any work integrating QF and blockchain.
    Nevertheless, the above mentioned work using BF can be replaced with QF specially
    if the filter size is too large to get fit inside main memory.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: QF与BF具有相同的目的。然而，如果数据不适合主存储器，BF将失败。文献不支持任何将QF与区块链集成的工作。然而，如果过滤器大小太大无法适应主存储器，则上述使用BF的工作可以用QF替代，特别是如果过滤器大小太大无法适应主存储器的情况。
- en: '[14.4 Integration of Skiplist with Blockchain](contents.xhtml#rsec14_4)'
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[14.4 Skiplist与区块链的集成](contents.xhtml#rsec14_4)'
- en: One of the worth mentioning use case for blockchain is in notarizing document
    for example, academic degrees. The tamper proof and transparent property of blockchain
    makes the document on blockchain harder to forge and modify. However, being a
    promising application the notarization use case suffers from some limitations.
    One of such challenge is to verify the presence of a document on blockchain even
    if that document is very old with respect to a reference point. There may be a
    case when a user has not updated his/her blockchain, then verifiers reference
    point on the blockchain may be behind in time with the block in question. Notably,
    this problem becomes even more worse for a low powered device.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链的一个值得一提的应用案例是在公证文件，例如学位证书方面。区块链的防篡改和透明属性使得区块链上的文件更难伪造和修改。然而，作为一个有前途的应用，公证案例受到一些限制。其中一个挑战是即使文件相对于参考点非常古老，也要验证其在区块链上的存在。可能会出现这样一种情况，即用户未更新他/她的区块链，那么验证人在区块链上的参考点可能落后于问题区块的时间。值得注意的是，这个问题对于低功率设备来说变得更加严重。
- en: One solution to this problem is to use SPV client that is discussed in previous
    chapters. Additionally, SPV introduces security weakness; if SPV client acquires
    transaction from a single full node, which may become prone to single point of
    failure. Moreover, SPV and full client are prone to isolation attack (for example,
    a fork from public blockchain with vey less work) and routing based hijacking
    attacks [[37](bib.xhtml#ch00-bib-37)]. Also, if a SPV client connects with more
    than one full node, it may lead to consumption of more bandwidth and power. Hence
    it is not scalable for large number of thin clients. Importantly, it is necessary
    that an SPV client should remain online in order to check whether the transaction
    is committed to blockchain or not. Infact for any verifier to verify, device needs
    to be online with a good Internet connection. Verification of a transaction without
    a well connected network is either impossible or insecure.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的一个方法是使用在前几章讨论过的SPV客户端。此外，SPV引入了安全弱点；如果SPV客户端从单个完整节点获取交易，这可能会导致单点故障。此外，SPV和完整客户端容易受到孤立攻击（例如，来自具有非常少工作量的公共区块链的分叉）和基于路由的劫持攻击
    [[37](bib.xhtml#ch00-bib-37)]。另外，如果SPV客户端连接了多个完整节点，可能会导致更多的带宽和功耗消耗。因此，对于大量薄客户端来说，它不具有可扩展性。重要的是，SPV客户端需要保持在线，以便检查交易是否提交到区块链上。事实上，对于任何验证者来说，设备需要与良好的互联网连接保持在线。在没有良好连接网络的情况下，验证交易要么是不可能的，要么是不安全的。
- en: Other solution to this problem is to use collective signing (CoSi) [[183](bib.xhtml#ch00-bib-183)],
    an efficient digital signatures technique offered by ByzCoin. ByzCoin constructs
    a consensus group from recently successful proof of work miners from past few
    days or weaks. In order to commit transactions securely, this consensus group
    formed runs PBFT algorithm. However, rather than using all-to-all communication,
    CoSi is used during each of these phases CoSi produces a single efficiently verifiable
    compact and collective signature cryptographically signed revealing that a fraction
    of consensus group has verified. To check CoSi on a transaction, verifier should
    know the public keys of miners in the consensus group in time when the transaction
    was committed. Clearly, this consensus group continuously gets changed. To address
    this problem, on change of a consensus group, some nodes of previous consensus
    group collectively forms and signs a forward link have two important information.
    The architecture of CoSi protocol is represented in [Fig. 14.3](#fig14_3).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 此问题的另一解决方案是使用集体签名（CoSi）[[183](bib.xhtml#ch00-bib-183)]，这是一种由ByzCoin提供的高效数字签名技术。ByzCoin根据过去几天或几周内最近成功的工作证明矿工构建一个共识组。为了安全地提交交易，形成的这个共识组运行PBFT算法。然而，与全对全通信不同，CoSi在每个阶段都使用，CoSi生成一个单一的高效可验证的紧凑集体签名，用密码学签名来揭示共识组的一部分已验证。要检查交易上的CoSi，验证者应该知道交易提交时共识组中矿工的公钥。显然，这个共识组不断变化。为了解决这个问题，在共识组更改时，前一个共识组的一些节点集体形成并签署了一个前向链接，其中包含两个重要信息。CoSi
    协议的架构如 [图 14.3](#fig14_3) 所示。
- en: '![Figure 14.3](../images/fig14_3.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.3](../images/fig14_3.jpg)'
- en: '**FIGURE 14.3.**'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 14.3。**'
- en: CoSi protocol architecture [[121](bib.xhtml#ch00-bib-121)].
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: CoSi 协议架构 [[121](bib.xhtml#ch00-bib-121)]。
- en: A hash pointer to the very first block committed by next consensus group.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过下一个共识组提交的第一个区块的哈希指针。
- en: A description telling how consensus group is changed which specifying which
    miners public keys are inserted or removed.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述共识组如何更改，同时指定插入或移除的矿工公钥。
- en: Also, all committed block has backward links using hashes. Hence, a verifier
    with no Internet connection can verify using forward and backward link of the
    chain. However, with his method it is required that prover should send all intervening
    block headers and forward link. Clearly, this puts bandwidth, power and storage
    bandwidth on low powered devices.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，所有已提交的区块都使用哈希值具有向后链接。因此，即使验证者没有互联网连接，也可以使用链的前向和后向链接进行验证。然而，使用该方法需要证明者发送所有介入的区块头和前向链接。显然，这会占用低功率设备的带宽、功率和存储带宽。
- en: To solve this problem, Chainiac used Skipchains, a cryptographic blockchain
    variant of skiplist integrated with blockchain to provide secure P2P verification.
    *Skipchains* were originally introduced in context of updating softwares by a
    framework called *CHAINIAC [[154](bib.xhtml#ch00-bib-154)]*. It uses *skipchains*
    to validate integrity and authenticity of software update provided by the vendors.
    Also, this proposal eliminates a single point of failure. Skipchain contains both
    long distance forward and backward links to the blockchain. With *skipchains*,
    the verifier can traverse both in forward and backward directions to track the
    timeline from any reference point. Whenever a new block is created in Chainiac,
    that block contains the hash link to point farther backward in time along with
    having link to immediate prior block. This backward link can prove integrity of
    old transaction anywhere in the blockchain. Also, Chainiac provides long distance
    forward links along with CoSi. The long distance forward links contains information
    of public key changes in consensus group. With this technique, instead of a single
    authority to validate the documents, document is validated by a leader as well
    as by a group of decentralized witnesses. It is implemented in 4 rounds of communication
    and after each round, signature is generated and verified by witnesses. It gives
    assurance that if central authority key gets compromised, client can not validate
    the document unless it is signed by multiple witnesses. Additionally, it reduces
    communication overhead in PBFT. As each node no longer requires individual node
    signature. So, *CoSi* reduces the data size of message that is to be broadcasted
    in network during prepare and commit phase [[72](bib.xhtml#ch00-bib-72)]. With
    having both long distance forward and long distance backward links, the cryptographic
    chain is traversable in both direction so that verifier can verify the correctness
    of a block anywhere in time having others participants reference to a point on
    blockchain. This verification can be performed in logarithmic number of steps.
    Hence this offline and P2P verification with skipchain can be extended in future
    blockchain technology
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，Chainiac 使用了 Skipchains，这是一种将跳表与区块链集成的加密区块链变体，用于提供安全的 P2P 验证。*Skipchains*
    最初是在一个名为 *CHAINIAC* 的框架中引入的，用于更新软件。它使用 *skipchains* 来验证供应商提供的软件更新的完整性和真实性。此外，这个提案消除了单点故障。Skipchain
    同时包含了与区块链的长距离前向和后向链接。通过 *skipchains*，验证者可以在前向和后向方向上遍历时间线，从任何参考点跟踪时间。每当在 Chainiac
    中创建一个新的区块时，该区块都包含一个向时间更久远的地方指向的哈希链接，同时还具有指向前一个区块的链接。这个后向链接可以证明区块链中任何地方的旧交易的完整性。此外，Chainiac
    还提供了与 CoSi 一起的长距离前向链接。长距离前向链接包含共识组中公钥更改的信息。通过这种技术，文档不再由单一的权威验证，而是由领导者以及一组分散的见证人验证。它通过
    4 轮通信实现，并在每一轮之后，由见证人生成并验证签名。这确保了如果中央权威密钥被破坏，客户端将无法验证文档，除非它被多个见证人签署。此外，它减少了 PBFT
    中的通信开销。因为每个节点不再需要个别节点签名。所以，*CoSi* 减少了在准备和提交阶段在网络中广播的消息的数据大小。拥有长距离前向和长距离后向链接，加密链可以在两个方向上遍历，以便验证者可以验证任何时间点上的区块的正确性，其他参与者可以参考区块链上的某一点。这种验证可以在对数步骤中完成。因此，这种使用
    skipchain 的离线和 P2P 验证可以在未来的区块链技术中得到扩展。
- en: '*Skipchains* is denoted as <math alttext="" display="inline"><mrow><msubsup><mi>S</mi><mi>b</mi><mi>h</mi></msubsup></mrow></math>where
    *h* and *b*, define height and basis of *skipchain* respectively; if <math alttext=""
    display="inline"><mrow><mn>0</mn><mtext><</mtext><mi>b</mi><mtext><</mtext><mn>1</mn></mrow></math>skipchain
    is randomized and if <math alttext="" display="inline"><mrow><mi>b</mi><mtext>></mtext><mn>1</mn></mrow></math>(integer)
    it is defined to be deterministic. The tuples of *skipchains* contain ( <math
    alttext="" display="inline"><mrow><mi>i</mi><msub><mi>d</mi><mi>t</mi></msub><mo>,</mo><msub><mi>D</mi><mi>t</mi></msub><mo>,</mo><msub><mi>h</mi><mi>t</mi></msub><mo>,</mo><msub><mi>F</mi><mi>t</mi></msub><mo>,</mo><msub><mi>B</mi><mi>t</mi></msub></mrow></math>)
    which denotes block identifier, payload data, block height, list of forward and
    backward link respectively.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: In BC, *Skipchains* is used by resource-constrained devices to verify the correctness
    of a transaction. In order to verify, instead of downloading all BC data, *skipchains*
    only downloads some logarithmic number of blocks. [Fig. 14.4](#fig14_4) shows
    forward and backward links in skipchain. Verification process in *skipchain* is
    also similar to verification process using Merle tree. All committed blocks contain
    backward hash link to not only immediate prior block, but also it points farther
    backward. Forward links are formed using *CoSi* which ensures that a certain number
    of miners have verified and committed a block.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.4](../images/fig14_4.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 14.4.**'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Structure of <math alttext="" display="inline"><mrow><msubsup><mi>S</mi><mn>2</mn><mn>3</mn></msubsup></mrow></math>
    deterministic Skipchains.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Activity
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Multiple Choice Questions
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What are the characteristics of a lightweight blockchain client?
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lightweight client is also known as SPV client
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Lightweight client only downloads block header of a blockchain network.
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Lightweight client downloads full copy of a blockchain distributed ledger
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Lightweight client has to refer to a trusted full client for performing operations
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The method used by lightweight client to verify inclusion of a transaction in
    a block is called?
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Complex payment verification
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Simplified payment verification
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Blockchain payment verification
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: None of these
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the characteristics of a full blockchain client?
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Stores entire history of blockchain distributed ledger
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Provides better security over lightweight client
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Refers to lightweight client for performing operations
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: None of these
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Integrating BF with SPV client provides?
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Protection from DoS attack
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Space efficient way to acquire transaction of interest
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Protection from sybil attack
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: BF can't be used with SPV client
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following is the main issue with SPV client?
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: SPV client can't download block header easily
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: SPV client can't be run on a mobile device
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: SPV client privacy is threatened
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: None of these
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Explain how Ethereum uses BF for better space efficiency?
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Explain how Bitcoin is using BF for implementing SPV client?
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Explain how BF can be used for blockchain based certificate revocation system?
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Explain working of Graphene protocol.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How anti-malware softwares are using BF and blockchain in integration?
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Explain the concept of Skipchains.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 1\. a, b, d  2\. b  3\. a, b  4\. b  5\. c
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: <hgroup>
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[15](contents.xhtml#rchapter15)'
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Applicability of Cardinality Estimation PDS with Blockchain](contents.xhtml#rchapter15)'
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: </hgroup>
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[15.1 DDoS Attack in Blockchain](contents.xhtml#rsec15_1)'
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: DDoS stands for distributed denial of service attack. This attack is used to
    create a complete shutdown for a machine. Here, the target machine is overloaded
    with bogus traffic so that legitimate requests cannot be processed. The term distributed
    is used as this attack is delivered by a network of computers called botnets.
    Particularly, attackers launch this attack for fun and profit purpose. One reason
    that DDoS is hard to tackle is that it is difficult to differentiate between legitimate
    and malicious requests.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: DDoS 是分布式拒绝服务攻击的缩写。这种攻击用于使机器完全关闭。在这种攻击中，目标机器被虚假流量超载，使得合法请求无法被处理。分布式一词用于表示此攻击是由称为僵尸网络的计算机网络传递的。特别地，攻击者发起此攻击是为了娱乐和利润目的。DDoS
    难以应对的一个原因是很难区分合法请求和恶意请求。
- en: However, the decentralized nature of blockchain prevents this attack to be launched
    [[164](bib.xhtml#ch00-bib-164)], [[173](bib.xhtml#ch00-bib-173)], [[174](bib.xhtml#ch00-bib-174)].
    In particular, attacks on single blockchain machine are known in a blockchain
    network (such as sybil attack, routing attack). Nevertheless, if some nodes fail
    to be active, the blockchain network still operates. Later when attacked system
    manged to recover, they re-sync and updates with recent data collected from the
    nodes. The degree of protection in blockchain network depends on number of nodes
    and hash rate of the network. In order to compromise the whole system, attacker
    needs to attack 51% of the total number of nodes of the network or in other words
    attacker needs to have more computational power over combination of other participants.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，区块链的去中心化特性阻止了此类攻击的发生。特别地，在区块链网络中已知存在对单个区块链机器的攻击（如 sybil 攻击、路由攻击）。然而，即使一些节点未能处于活动状态，区块链网络仍然可以运作。当受攻击的系统设法恢复时，它们会重新同步并更新来自节点的最新数据。区块链网络的保护程度取决于节点数量和网络的哈希率。为了破坏整个系统，攻击者需要攻击网络总节点数的
    51% 或者换句话说，攻击者需要比其他参与者组合拥有更多的计算能力。
- en: For a blockchain based cryptocurrency system this attack include targeting transaction
    processes, i.e., disabling a machine so as to refrain the generation of new transactions.
    One way to launch this attack is by creating various transaction to transfer asset
    between malicious attacker's pre created wallet's. By creating multiple transactions
    miners involve themselves solving proof for these transactions. The denial of
    service is caused by requirement to process legitimate transactions. Notably,
    in Bitcoin blockchain network, a transaction fee is charged but this fees is not
    much high to be payed by an attacker.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基于区块链的加密货币系统，此攻击包括针对交易过程，即禁用机器以阻止新交易的生成。发起此攻击的一种方式是创建多个交易以在恶意攻击者预先创建的钱包之间转移资产。通过创建多个交易，矿工们参与解决这些交易的证明。由于需要处理合法交易，导致了服务的拒绝。值得注意的是，在比特币区块链网络中，会收取交易费，但攻击者支付的费用并不高。
- en: For example, when cryptocurrency named Bitcoin gold [[26](bib.xhtml#ch00-bib-26)]
    was launched, it immediately got effected by DDoS leading to website down for
    four hours. Bitcoin gold hard fork noticed 10 million hits per minute. Later the
    twitter statement reveals that most of the hits involve IP addresses routed via
    china.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 举例来说，当加密货币比特币黄金[[26](bib.xhtml#ch00-bib-26)]上线时，立刻遭受到了DDoS的影响，导致网站下线长达四小时。比特币黄金硬分叉注意到每分钟有1000万次点击。后来，推特声明揭示了大多数点击涉及通过中国路由的IP地址。
- en: An another effort to launch DDoS attack on blockchain is discussed by the authors
    of [[143](bib.xhtml#ch00-bib-143)] and the attack is named as **blockchain denial
    of service (BDoS)**. This is based on the fundamental that blockchain protocol
    distributes incentives for security as miners get reward for mining a block successfully.
    BDoS exploits rationality of miners by giving them higher profit for playing against
    system. Compared to traditional DoS attack, BDoS can disrupt the blockchain with
    significantly less resources. Unlike selfish mining, here aim of attacker is not
    to provide revenue to adversary but to disrupt the blockchain network. Lets understand
    BDoS attack.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种对区块链发起DDoS攻击的尝试由[[143](bib.xhtml#ch00-bib-143)]的作者讨论，并将该攻击命名为**区块链拒绝服务（BDoS）**。这基于区块链协议为安全分发激励的基本原理，因为挖矿者成功挖出一个区块后会获得奖励。BDoS利用挖矿者的理性，为他们提供更高的利润来对抗系统。与传统的DoS攻击相比，BDoS可以用更少的资源破坏区块链。与自私挖矿不同，攻击者的目标不是为对手提供收入，而是破坏区块链网络。让我们了解一下BDoS攻击。
- en: If more than one miner mines block concurrently, it results in fork (if block
    have same parent) and in that case chain got different branches. As per Bitcoin
    rules, to prevent ambiguity, only a single chain is extended, i.e., the miner
    should extend the longest chain in the main chain. Then the rewards of blocks
    diverged from that chain are ignored. However, to avoid reward loss, miners usually
    start mining even before the current block is validated. Notably, they start mining
    on the latest block once its metadata of the header is received. Therefore by
    avoiding wasting resources on block, miners try to increase their mining chance
    of next block. This approach of mining using only header is called SPV mining
    described earlier in [chapter 7](09chap_07.xhtml). To launch an attack, attacker
    creates a block and publishes its header only. With a given header, miner tries
    to extend that block. However, attacker never publishes full block and that block
    tried by rational miner never gets included in the blockchain's main chain and
    it comes with zero expected reward from that block. Hence, the attacker created
    a situation where honest miner ends up in loosing reward. Also, miners can't process
    legitimate requests that leads to a situation where honest miner gives up with
    mining and leads to wastage of resources.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果多个矿工同时挖掘区块，则会导致分叉（如果区块具有相同的父区块），在这种情况下，链会出现不同的分支。根据比特币规则，为了防止歧义，只会延伸单一的链，即矿工应该延伸主链上最长的链。然后忽略那些与该链分叉的区块的奖励。然而，为了避免奖励损失，矿工通常在当前区块验证之前就开始挖掘。值得注意的是，他们在收到区块头的元数据后立即开始挖掘最新的区块。因此，通过避免浪费区块资源，矿工尝试增加下一个区块的挖掘机会。这种仅使用头部的挖矿方法被称为前面在
    [第 7 章](09chap_07.xhtml) 中描述的 SPV 挖矿。为了发起攻击，攻击者创建一个区块，并仅发布其头部。给定一个头部，矿工尝试扩展该区块。然而，攻击者从不发布完整的区块，而理性矿工尝试的那个区块永远不会包含在区块链的主链中，并且它不会带来来自该区块的预期奖励。因此，攻击者制造了一个使诚实矿工损失奖励的局面。此外，矿工无法处理合法请求，导致诚实矿工放弃挖掘，并导致资源的浪费。
- en: Countermeasure of DDoS attack include identifying source of flooding and then
    to design filter in order to block that source. Allow the outgoing and incoming
    traffic from a source only if the source address is in the range of expected IP
    addresses.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 防御 DDoS 攻击的措施包括识别洪泛源，然后设计过滤器以阻止该源。只有源地址位于预期 IP 地址范围内时，才允许来自该源的出站和入站流量。
- en: 'Note:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：
- en: DDoS attack is not directly effecting the security of data stored in blockchain
    network but the ode being attacked can't take part in consensus mechanism and
    its computation power and resources are therefore wasted.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: DDoS 攻击并不直接影响存储在区块链网络中的数据的安全性，但被攻击的节点无法参与共识机制，其计算能力和资源因此被浪费。
- en: '[15.2 Mempool Transaction Count](contents.xhtml#rsec15_2)'
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[15.2 内存池交易计数](contents.xhtml#rsec15_2)'
- en: All transactions waiting to be confirmed is stored in memory pool(mempool) of
    Bitcoin network. To get confirmed, transaction first needs to be in block from
    mempool. Notably, there is no global memory pool in blockchain network. Every
    node on Bitcoin network constructs its own version of mempool by connecting to
    Bitcoin network. Each transaction in mempool pays a fees and has a size. Clearly,
    transaction having high fees are picked with priority by miners. Mempool is cleared
    whenever the node is rebooted. Nodes pay fees to miners for mining transactions.
    The maximum number of transaction in a block varies as all transaction doesn't
    have same size. The more the number of transactions in mempool, the more is the
    congestion in traffic that leads to longer confirmation time. Also, transaction
    fees of network is determined by network congestion and size of transaction. The
    size of Bitcoin block size is 1 MB which implies a miner can take and process
    1 MB of transactions per block roughly around every 10 minutes. For a Bitcoin
    network, if number of transactions exceeds 1 MB, it leads to network congestion
    and miners then prioritize transaction having higher fees. In this context, the
    mempool transaction count metric [[27](bib.xhtml#ch00-bib-27)] of Bitcoin reveals
    number of transactions causing the congestion. (In contrast, mempool size will
    specify for how long congestion will last long.)
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[15.3 Interation of Linear Counting, LogLog and HyperLogLog with Blockchain](contents.xhtml#rsec15_3)'
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although there is no existing work in literature that integrates HLL, LogLog
    or linear counting in blockchain. But these PDS can be used for counting purpose
    in blockchain network as discussed below. Notably, we have presented our view
    in context of HLL as this the most popular and efficient algorithm among all three.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[15.3.1 Counting transaction in mempool](contents.xhtml#rsec15_3_1)'
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This cardinality estimation PDS can be used to count transactions in mempool.
    Mempool transaction count tells how many transactions causes the congestion. As
    each system on blockchain network has different storage capacity for these unconfirmed
    transactions. In this context, HLL can be used to count number of transactions
    in each nodes mempool. To implement this logic, whenever a new transaction is
    added to mempool, it is first hashed and this resultant hash is stored in the
    bucket as per the value of longest zero sequence. Finally, the values in buckets
    are combined using harmonic mean of the values in bucket. Moreover, using programming
    an upper limit can be set on mempool specifying maximum transactions to be added
    in mempool to avoid congestion. To set a limit, concept of smart contract can
    also be used where a contract with logic specifying maximum transaction in mempool
    is developed. The usage of HLL to check congested traffic in blockchain network
    is show in [Fig. 15.1](#fig15_1).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这种基数估计 PDS 可用于计算内存池中的交易数。内存池中的交易计数告诉我们有多少交易导致了拥堵。由于区块链网络上的每个系统对于这些未确认交易具有不同的存储能力。在这种情况下，可以使用
    HLL 来计算每个节点内存池中的交易数。要实现这个逻辑，每当新的交易被添加到内存池中，首先对其进行哈希处理，然后将所得的哈希存储在零序列最长值所对应的桶中。最后，将桶中的值使用调和平均数进行组合。此外，可以使用编程在内存池上设置一个上限，指定最大交易数以避免拥堵。要设置限制，还可以使用智能合约的概念，其中开发了一个包含逻辑的合约，指定了内存池中的最大交易数。使用
    HLL 检查区块链网络中的拥堵交通的用法如 [图 15.1](#fig15_1) 所示。
- en: '![Figure 15.1](../images/fig15_1.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图 15.1](../images/fig15_1.jpg)'
- en: '**FIGURE 15.1.**'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 15.1.**'
- en: HLL to check congested traffic in Bitcoin network.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 HLL 检查比特币网络中的拥堵交通。
- en: '[15.3.2 HLL to prevent DoS attack](contents.xhtml#rsec15_3_2)'
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[15.3.2 使用 HLL 预防 DoS 攻击](contents.xhtml#rsec15_3_2)'
- en: An interesting area where HLL can be implemented is to prevent DDoS in blockchain.
    Here, the intention of an attacker is to overwhelm victim machine with bulk of
    non-sense traffic to consume resources and bandwidth. As discussed earlier, DDoS
    attack can be launched in blockchain by sending lots of transaction simultaneously.
    Another way, adversary can also send an extra large size opcode so as to process
    the block, time taken by miners also gets high. Consequently, miners cannot process
    legitimate request. Another way of performing DoS on blockchain is by filling
    up orphan blocks with unlimited bogus transactions as orphan transactions blocks
    are provided with unlimited storage. So, when new transaction arrives, all transactions
    in orphan blocks are verified and validated if not validated earlier which consequently
    makes miner node so busy that it is unable to process normal transactions [[28](bib.xhtml#ch00-bib-28)].
    In this context, HLL can be employed in the network to notify if the source IP
    of the incoming packet extends a predefined threshold. For example, authors in
    [[60](bib.xhtml#ch00-bib-60)] proposed an algorithm that uses sliding HLL and
    BF to detect port scan attack. Port Scan attack is a form of DoS attack where
    an attacker targets to find some services on victims machine. Sliding HLL is almost
    similar to original HLL which was proposed by [[61](bib.xhtml#ch00-bib-61)] to
    approximate cardinality over a changeable bounded interval using sliding window
    model. Also, smart contracts can be employed for the same purpose. For example,
    Rodrigues et al. [[164](bib.xhtml#ch00-bib-164)] used smart contract to mitigate
    DoS. Here, smart contract reports blacklisted IP address across multiple domains.
    Notably, techniques of blocking IP address only works for static IP addresses
    and this fails for dynamic IP address. Smart contracts are programmed with logic
    to block IP address in the blockchain. However, authors used traditional data
    structures to count number of transactions from same IP address. Instead of using
    traditional data structures, probabilistic data structure can be used in order
    to save space and to perform the operation of counting in constant time. The process
    of handling DoS in blockchain based IoT network is shown in [Fig. 15.2](#fig15_2)
    To obtain unique count of addresses within a block, extract IP address and port
    number from data/transaction generated by IoT node. Pass the extracted fields
    from SHA-256 hash function to estimate cardinality.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.2](../images/fig15_2.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 15.2.**'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Approximate cardinality estimation in blockchain based IoT environment.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '**Note** The above discussion can be applicable to IoT based environment as
    this environment involves financial services like exchanging payments, paying
    bills etc. for smart grid environment or V2G environment. Also, blockchain network
    is applicable to many other IoT fields such as agriculture, medical line etc.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[15.3.3 IoT chain](contents.xhtml#rsec15_3_3)'
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A project named, IoT chain [[29](bib.xhtml#ch00-bib-29)] is designed using blockchain
    and PDS to make IoT network better. IoT chain (ITC) was introduced to solve challenges
    such as data privacy, DDoS attack, overhead cost of centralized environment, data
    acquisition, data processing etc. in IoT. This technology is a combination of
    asymmetric encryption, semi-homomorphic encryption and distributed ledgers powered
    by blockchain technology. With a private-public key pair of asymmetric algorithm,
    private data of users cannot be seen by the adversary. Blockchain technology reduces
    the cost incurred by the centralized architecture, besides it ensures that data
    is not shared with any third party. Homomorphic encryption enables operations
    to be performed on an encrypted data. In addition to this, ITC uses BF and HLL
    in the decentralized environment to perform real-time analysis of data where it
    becomes necessary to process the data before a certain time period.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Activity
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Multiple Choice Questions
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What does mempool transaction count reveals?
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Number of transactions that are causing congestion.
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: For how long congestion will last?
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Block size
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: None of these
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What does mempool size metric tells?
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Number of transactions that are causing congestion.
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: For how long congestion will last?
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Block size
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: None of these
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What is IoT chain?
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Integration of blockchain and IoT
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Integration of IoT and PDS
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Integration of IoT and homonorphic encryption
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: None of these
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What is Bitcoin gold?
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Gold version of Bitcoin
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A variant of Ethereum
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Consensus algorithm
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Hard fork of Bitcoin
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: There is a global memory pool for a blockchain network.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True'
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'False'
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: To compromise the whole blockchain network, attacker needs to attack ……..% of
    total nodes?
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 51%
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 30%
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 33%
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 1%
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the main characteristics of homomorphic encryption?
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Operations can be performed on encrypted data.
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: It resolves encryption issues
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Its process involves a third party service provider
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: All of the above
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: BDoS stands for?
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Blockchain Denial of Service
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Base Denial of Service
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Bloated Denial of Service
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: None of these
  id: totrans-221
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 1\. a  2\. b  3\. a  4\. d  5\. b  6\. c  7\. d  8\. a
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: <hgroup>
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[16](contents.xhtml#rchapter16)'
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Applicability of Frequency Estimation PDS with Blockchain](contents.xhtml#rchapter16)'
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: </hgroup>
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[16.1 RFID Tag Cloning](contents.xhtml#rsec16_1)'
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Radio frequency identification (RFID) is latest auto-identification technology
    based on radio waves for identification and tracking of object without line of
    sight [[31](bib.xhtml#ch00-bib-31)]. Unlike conventional barcode, RFID tag is
    a reusable, readable or writable and less likely to be error prone. RFID use case
    includes shipping, port operation, supply chain management, banknotes etc. to
    name a few. Enhanced operational efficiency, better accuracy, lower operational
    cost, improved service are some of the benefits of RFID. RFID tag reading are
    in form of data stream. For example, say S=S1, S2,…….,Sm is a data stream of tag
    readings divided into batches of t seconds. Despite having various technology,
    security issues of RFID are a matter of concern among which RFID cloning attack
    is one of the malicious attack. RFID cloning attack implies fabricating more than
    one replicas of genuine tag. A cloned tag is generally the duplicate copy of Electronic
    Product Code (EPC) against a genuine tag. Whenever a reader reads the tag, it
    is hard to differentiate among two tags. Additionally, using same hash function
    against same EPC results in hash collision. Cloning of RFID can lead to financial
    loses. However, cryptography based authentication method assures security and
    privacy but also impose requirements of high memory and computational power [[80](bib.xhtml#ch00-bib-80)].
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[16.2 Understanding Heavy Hitters](contents.xhtml#rsec16_2)'
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Network traffic monitoring is very important for secure network operation. In
    this context, detecting heavy hitters is one of the process for traffic measurement
    applications. Detecting heavy hitters can be used for network operations such
    as traffic accounting and anomaly detection. Heavy hitter is defined as a flow
    that has a particular fraction of total link capacity. In other words it is detecting
    flow whose size is more than given threshold. According to Zhou et al., detecting
    heavy hitter is the process of determining the frequency of same element belonging
    to network data stream [[221](bib.xhtml#ch00-bib-221)]. Notably, network flow
    is determined by 5 tuples, i.e., source IP address, destination IP address, source
    port, destination port and protocol. Generally, the data stream is defined as
    S=p1, p2,….,pn where, pi that is made up of IP address, port number etc. Detecting
    heavy hitters has been studied in many domains such as- network traffic and IP
    calling.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: To detect heavy hitters with PDS, first step is packet processing stage which
    extracts network data stream from network packet. Second, each element of data
    stream is updated to probabilistic sketch. In third step, flow size is calculated
    by probabilistic counting. Finally, heavy hitters are detected as the estimation
    of flow size in measurement interval. If the value of a element is greater than
    or equal to a threshold then the corresponding IP address is identified as heavy
    hitter.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[16.3 Integration of CMS with Blockchain](contents.xhtml#rsec16_3)'
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Literature lacks work supporting integration of CMS and blockchain. However,
    we could use CMS for various ways in blockchain.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[16.3.1 Detecting DoS attack](contents.xhtml#rsec16_3_1)'
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As discussed above detecting DoS attack, anomaly detection, QoS management are
    important use-cases of detecting heavy hitters in real-time. Apart from HLL, DoS
    attack can also be handled by CMS by setting a threshold *ϕ* for any time slot
    *t* and if the frequency of counter in CMS is greater than predefined threshold
    <math alttext="" display="inline" id="chapter16_eq1"><mrow><mi>ϕ</mi> <mo>*</mo>
    <mi>N</mi></mrow></math> (N is overall count) then that node can be identified
    as malicious node. Also, by using frequency count PDS, a verifier can check frequency
    of address in a block or to count frequency of same source and destination address
    pair to generate real-time response. This way by using CMS, each streaming update
    can be processed in logarithmic number of steps. Another advantage of CMS is that
    legitimate connection can be deleted from the pool of observation [[118](bib.xhtml#ch00-bib-118)].
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Inspired from the work of [[179](bib.xhtml#ch00-bib-179)], an idea to detect
    heavy hitter in real-time for private blockchain based IoT network is presented
    in [Fig. 16.1](#fig16_1). Although authors in [[179](bib.xhtml#ch00-bib-179)]
    have not used PDS to detect heavy hitters. As the number of participants in private
    blockchain are usually less, therefore it is necessary to ensure the availability
    of nodes in order to operate correctly. Clearly, the nodes of the private blockchain
    network should be available all time while being protected from DoS attack. The
    proposal used an Software Defined Network (SDN)-enabled switch to protect nodes
    within private blockchain against DDoS attack. Within a network, this attack refrains
    nodes participation in consensus mechanism which can lead to wastage of computational
    power. However, DDoS is detected based on flow statistics by usage of Count-Sketches
    [[135](bib.xhtml#ch00-bib-135), [134](bib.xhtml#ch00-bib-134), [84](bib.xhtml#ch00-bib-84)].
    SDN-enabled switch filters out remote nodes that generate heavy hitters and tries
    to send data within network. It listens to all incoming packets (*p1, p2,……..,
    pn*) and extracts source-destination pair from each packet to compute statistics
    for flow entries. The SDN switch is configured with information (IP address and
    port number) of registered blockchain nodes of private network. SDN network controller
    checks probabilistic count sketch periodically to detect heavy hitters. It places
    heavy hitter flow and normal flow in blacklist and whitelist respectively. Finally,
    packets from whitelist are forwarded to be verified by miner nodes within the
    network.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.1](../images/fig16_1.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 16.1.**'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Heavy hitter detection in blockchain based IoT environment.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[16.3.2 Detecting RFID tag cloning](contents.xhtml#rsec16_3_2)'
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In IoT environment, Count-sketches can be used to detect RFID clone tagging
    in applications, such as supply chain management, shipping and port operations,
    water level monitoring etc. In this context, Hazalila *et al.[[113](bib.xhtml#ch00-bib-113)]*
    proposed a lightweight anti-cloning approach based on CMS vector and consistency
    of dual hash collisions. CMS uses two independent hash functions to probe identical
    EPC. While hashing the identical EPC, the same hash function results in hash collisions
    which implies high chance of tag cloning. Implementation results show that the
    proposed method performs better than baseline approaches and achieves a better
    accuracy in detecting clone ratio. Although, this proposal does not implement
    blockchain technology but the CMS could be extended to a blockchain based IoT
    network. The sketch is a accumulation of tag reading spread out for multiple RFID
    readers. Each sketch has tag readings received during batch interval.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Activity
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Multiple Choice Questions
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What does EPC stand for in context to RFID?
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Explain how integration of CMS and blockchain helps in preventing RFID tag cloning?
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Explain what is meant by heavy hitter?
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How RFID tag cloning can be performed?
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Explain how count-sketch can prevent DoS attack.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <hgroup>
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[17](contents.xhtml#rchapter17)'
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Applicability of Approximate Similarity Search PDS with Blockchain](contents.xhtml#rchapter17)'
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: </hgroup>
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[17.1 Approximate Nearest Neighbor Binary Search Algorithm for Wireless Multimedia
    Sensor Network](contents.xhtml#rsec17_1)'
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Storing massive IoT data on blockchain requires a large space of memory. Also,
    existing similarity search methods take space even more than that for an actual
    dataset for creating indexed structure. In view of this problem, similarity search
    PDS in blockchain allows a verifier or user to retrieve similar data for a given
    query in real time. ASS based PDS performs computations with minimum number of
    distance evaluations. In literature [[136](bib.xhtml#ch00-bib-136)] authors have
    combined LSH and blockchain with IPFS to manage data generated by Wireless multimedia
    sensor network (WMSN). Blockchain based system protects highly sensitive data
    from tampering.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[17.2 A Blockchain of Image Copyrights Using Locality Sensitive Hashing](contents.xhtml#rsec17_2)'
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For proving copyrights on digital asset, A. Zhuvikin [[222](bib.xhtml#ch00-bib-222)]
    proposed a blockchain based image copyright registry based on robust image features.
    As discussed above, LSH searches easily on high dimensional data sets by ensuring
    that similar objects has high probability for collision over dissimilar objects.
    Rather than using LSH, cross-polytop LSH is used that also maps similar data to
    same index value [[35](bib.xhtml#ch00-bib-35)]. However, compared to original
    LSH, cross-polytope significantly reduces space and time complexity. It uses LSH
    to retrieve images with similar content even if they are changed by content-preserving
    operations, such as- JPEG compression, shrinking, zooming etc. To share original
    image with copyright, first robust image features vector is calculated by performing
    LSH and signing using private key of the owner. In the next step, obtained signature
    is multiplied with a random integer called blinding factor to generate blind signatures
    which is broadcasted to all miner nodes on network for verification. Finally,
    image index item is constructed using LSH and blind signatures to ease locating
    copyright owner. Moreover, a hybrid data query method named One Permutation with
    rotation and cross-polytope locality sensitive hashing (OPRCP) is proposed which
    approximates nearest neighbour search in WMSN hybrid data (audio, image, text)
    along with constructing a query data structure. OPRCP first extracts feature vector
    of multimedia data using TF-IDF method followed by constructing a hash table data
    structure from obtained feature vector. When a verifier or a user has to map query
    object to data structure, then after feature vectorization query undergoes same
    hash calculation process. Authors have also analyzed relationship between query
    time and accuracy of query from LSH nearest neighbor search. Compared to original
    LSH, OPRCP improves similarity search in terms of space and time.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Activity
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Answer the following questions
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Explain how integration of blockchain and locality sensitive hashing can help
    to preserve image copyrights.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: According to you, what are the possible fields where minhashing can be integrated
    with blockchain?
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
