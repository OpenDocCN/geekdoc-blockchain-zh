["```\ntendermint\ndummy\ncounter\nabci-cli\n```", "```\n$ tendermint version\n0.10.3-'8d76408\n```", "```\n$ dummy\nStarting ABCIServer\nWaiting for new connection...\n```", "```\ntendermint init\n```", "```\ntendermint unsafe_reset_all\n```", "```\n$ tendermint node\nExecuted block module=state height=1 validTxs=0 invalidTxs=0\nCommitted state module=state height=1 txs=0 hash=\nExecuted block module=state height=2 validTxs=0 invalidTxs=0\nCommitted state module=state height=2 txs=0 hash=\n```", "```\n$ dummy\nStarting ABCIServer\nWaiting for new connection...\nAccepted a new connection\n```", "```\ncurl -s 'localhost:46657/broadcast_tx_commit?tx=\"hello\"'\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"\",\n  \"result\": {\n    \"check_tx\": {\n      \"code\": 0,\n      \"data\": \"\",\n      \"log\": \"\"\n    },\n\n    \"deliver_tx\": {\n      \"code\": 0,\n      \"data\": \"\",\n      \"log\": \"\"\n    },\n    \"hash\": \"995DE4D6FA43728945C235642E5DCCB64C08B4A2\",\n    \"height\": 30\n  },\n  \"error\": \"\"\n}\n```", "```\n$ tendermint node\n... ...\nExecuted block module=state height=30 validTxs=1 invalidTxs=0\nCommitted state module=state height=30 txs=1 hash=EA4...934\n... ...\n```", "```\ncurl -s 'localhost:46657/abci_query?data=\"hello\"'\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"\",\n  \"result\": {\n    \"response\": {\n      \"code\": 0,\n      \"index\": 0,\n      \"key\": \"\",\n      \"value\": \"68656C6C6F\",\n      \"proof\": \"\",\n      \"height\": 0,\n      \"log\": \"exists\"\n    }\n  },\n  \"error\": \"\"\n}\n```", "```\n{\n  \"genesis_time\":\"0001-01-01T00:00:00Z\",\n  \"chain_id\":\"test-chain-dmpZNA\",\n  \"validators\":[\n    {\n      \"pub_key\":\n      {\n        \"type\":\"ed25519\",\n        \"data\":\"F8...DC47D\"\n      },\n      \"amount\":10,\"name\":\"\"\n    }\n  ],\n  \"app_hash\":\"\"\n}\n```", "```\ncurl -s 'localhost:46657/broadcast_tx_commit?tx=\"Michael:True%20fact\"'\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"\",\n  \"result\": {\n    \"check_tx\": {\n      \"code\": 0,\n      \"data\": \"\",\n      \"log\": \"\"\n    },\n    \"deliver_tx\": {\n      \"code\": 0,\n      \"data\": \"\",\n      \"log\": \"\"\n    },\n    \"hash\": \"2A02B575181CEB71F03AF9715B236472D75025C2\",\n    \"height\": 18\n  },\n  \"error\": \"\"\n}\n```", "```\nCommit 0 items\nCheck tx : Michael:True fact\nThe source is : Michael\nThe statement is : True fact\nThe fact is in the right format!\nDeliver tx : Michael:True fact\nThe source is : Michael\nThe statement is : True fact\nThe count in this block is : 1\nThe fact is validated by this node!\nCommit 1 items\n```", "```\ncurl -s 'localhost:46657/abci_query?data=\"all\"'\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"\",\n  \"result\": {\n    \"response\": {\n      \"code\": 0,\n      \"index\": 0,\n      \"key\": \"\",\n      \"value\": \"4A696D3A312C4D69636861656C3A32\",\n      \"proof\": \"\",\n      \"height\": 0,\n      \"log\": \"Jim:1,Michael:2\"\n    }\n  },\n  \"error\": \"\"\n}\n```", "```\npublic final class FactsApp\n        implements IDeliverTx, ICheckTx, ICommit, IQuery {\n\n    public static Hashtable<String, Integer> db;\n    public static Hashtable<String, Integer> cache;\n\n    private TSocket socket;\n\n    public static void main(String[] args) throws Exception {\n        new FactsApp ();\n    }\n\n    public FactsApp () throws InterruptedException {\n        socket = new TSocket();\n        socket.registerListener(this);\n\n        // Init the database\n        db = new Hashtable <String, Integer> ();\n        cache = new Hashtable <String, Integer> ();\n\n        Thread t = new Thread(socket::start);\n        t.setName(\"Facts App Thread\");\n        t.start();\n        while (true) {\n            Thread.sleep(1000L);\n        }\n   }\n   ... ...\n}\n```", "```\npublic ResponseCheckTx requestCheckTx (RequestCheckTx req) {\n    ByteString tx = req.getTx();\n    String payload = tx.toStringUtf8();\n    if (payload == null || payload.isEmpty()) {\n        return ResponseCheckTx.newBuilder()\n            .setCode(CodeType.BAD)\n            .setLog(\"payload is empty\").build();\n    }\n    String [] parts = payload.split(\":\", 2);\n    String source = \"\";\n    String statement = \"\";\n    try {\n        source = parts[0].trim();\n        statement = parts[1].trim();\n        if (source.isEmpty() || statement.isEmpty()) {\n            throw new Exception(\"Payload parsing error\");\n        }\n    } catch (Exception e) {\n        return ResponseCheckTx.newBuilder()\n            .setCode(CodeType.BAD)\n            .setLog(e.getMessage()).build();\n    }\n\n    return ResponseCheckTx.newBuilder().setCode(CodeType.OK).build();\n}\n```", "```\npublic ResponseDeliverTx receivedDeliverTx (RequestDeliverTx req) {\n    ByteString tx = req.getTx();\n    String payload = tx.toStringUtf8();\n    if (payload == null || payload.isEmpty()) {\n        return ResponseDeliverTx.newBuilder()\n            .setCode(CodeType.BAD)\n            .setLog(\"payload is empty\").build();\n    }\n    String [] parts = payload.split(\":\", 2);\n    String source = \"\";\n    String statement = \"\";\n    try {\n        source = parts[0].trim();\n        statement = parts[1].trim();\n        if (source.isEmpty() || statement.isEmpty()) {\n            throw new Exception(\"Payload parsing error\");\n        }\n    } catch (Exception e) {\n        return ResponseDeliverTx.newBuilder()\n            .setCode(CodeType.BAD)\n            .setLog(e.getMessage()).build();\n    }\n\n    // In the DeliverTx message handler,\n    // we will only count facts in this block.\n    if (cache.containsKey(source)) {\n        int count = cache.get(source);\n        cache.put(source, count++);\n    } else {\n        cache.put(source, 1);\n    }\n\n    return Response`DeliverTx`.newBuilder().setCode(CodeType.OK).build();\n}\n```", "```\npublic ResponseCommit requestCommit (RequestCommit requestCommit) {\n    Set<String> keys = cache.keySet();\n    for (String source: keys) {\n        if (db.containsKey(source)) {\n            db.put(source, cache.get(source) + db.get(source));\n        } else {\n            db.put(source, cache.get(source));\n        }\n    }\n    cache.clear();\n\n    return ResponseCommit.newBuilder()\n      .setData(ByteString.copyFromUtf8(\n      String.valueOf(db.hashCode()))).build();\n}\n```", "```\npublic ResponseQuery requestQuery (RequestQuery req) {\n  String query = req.getData().toStringUtf8();\n\n  if (query.equalsIgnoreCase(\"all\")) {\n    StringBuffer buf = new StringBuffer ();\n    String prefix = \"\";\n    Set<String> keys = db.keySet();\n    for (String source: keys) {\n      buf.append(prefix);\n      prefix = \",\";\n      buf.append(source).append(\":\").append(db.get(source));\n    }\n    return ResponseQuery.newBuilder().setCode(CodeType.OK).setValue(\n            ByteString.copyFromUtf8((buf.toString()))\n    ).setLog(buf.toString()).build();\n  }\n\n  if (query.startsWith(\"Source\")) {\n    String keyword = query.substring(6).trim();\n    if (db.containsKey(keyword)) {\n      return ResponseQuery.newBuilder().setCode(CodeType.OK).setValue(\n          ByteString.copyFromUtf8(db.get(keyword).toString())\n      ).setLog(db.get(keyword).toString()).build();\n    }\n  }\n\n  return ResponseQuery.newBuilder()\n      .setCode(CodeType.BadNonce).setLog(\"Invalid query\").build();\n}\n```", "```\n$ mvn clean package\n```", "```\n$ java â€“jar facts-1.0.jar\n```", "```\npackage main\n\nimport (\n  \"flag\"\n  \"os\"\n  \"strings\"\n  \"bytes\"\n  \"strconv\"\n  \"github.com/tendermint/abci/example/code\"\n  \"github.com/tendermint/abci/server\"\n  \"github.com/tendermint/abci/types\"\n  cmn \"github.com/tendermint/tmlibs/common\"\n  \"github.com/tendermint/tmlibs/log\"\n)\n\nfunc main() {\n  addrPtr := flag.String(\"addr\", \"tcp://0.0.0.0:46658\", \"Listen address\")\n  abciPtr := flag.String(\"abci\", \"socket\", \"socket | grpc\")\n  flag.Parse()\n\n  logger := log.NewTMLogger(log.NewSyncWriter(os.Stdout))\n\n  var app types.Application\n  app = NewFactsApplication()\n  // Start the listener\n  srv, err := server.NewServer(*addrPtr, *abciPtr, app)\n  if err != nil {\n    logger.Error(err.Error())\n    os.Exit(1)\n  }\n  srv.SetLogger(logger.With(\"module\", \"abci-server\"))\n  if err := srv.Start(); err != nil {\n    logger.Error(err.Error())\n    os.Exit(1)\n  }\n\n  // Wait forever\n  cmn.TrapSignal(func() {\n    // Cleanup\n    srv.Stop()\n  })\n}\n```", "```\ntype FactsApplication struct {\n  types.BaseApplication\n\n  db map[string]int\n  cache map[string]int\n}\n\nfunc NewFactsApplication() *FactsApplication {\n  db := make(map[string]int)\n  cache := make(map[string]int)\n  return &FactsApplication{db: db, cache: cache}\n}\n```", "```\nfunc (app *FactsApplication) CheckTx (tx []byte) types.ResponseCheckTx {\n  parts := strings.Split(string(tx), \":\")\n  source := strings.TrimSpace(parts[0])\n  statement := strings.TrimSpace(parts[1])\n  if (len(source) == 0) || (len(statement) == 0) {\n    return types.ResponseCheckTx{\n        Code:code.CodeTypeEncodingError,\n        Log:\"Empty Input\"\n    }\n  }\n  return types.ResponseCheckTx{Code: code.CodeTypeOK}\n}\n```", "```\nfunc (app *FactsApplication) DeliverTx (tx []byte) types.ResponseDeliverTx {\n  parts := strings.Split(string(tx), \":\")\n  source := strings.TrimSpace(parts[0])\n  statement := strings.TrimSpace(parts[1])\n  if (len(source) == 0) || (len(statement) == 0) {\n    return types.ResponseDeliverTx{\n      Code:code.CodeTypeEncodingError,\n      Log:\"Empty Input\"\n    }\n  }\n\n  if val, ok := app.cache[source]; ok {\n    app.cache[source] = val + 1\n  } else {\n    app.cache[source] = 1\n  }\n  return types.ResponseDeliverTx{Code: code.CodeTypeOK}\n}\n```", "```\nfunc (app *FactsApplication) Commit() types.ResponseCommit {\n  for source, v := range app.cache {\n    if val, ok := app.db[source]; ok {\n      app.db[source] = val + v\n    } else {\n      app.db[source] = v\n    }\n  }\n  app.cache = make(map[string]int)\n\n  hash := make([]byte, 8)\n  binary.BigEndian.PutUint64(hash, uint64(totalCount))\n  return types.ResponseCommit{Data: hash}\n}\n```", "```\nfunc (app *FactsApplication) Query (reqQuery types.RequestQuery)\n                                   (resQuery types.ResponseQuery) {\n  query := string(reqQuery.Data)\n\n  if (strings.EqualFold(query, \"all\")) {\n    var buffer bytes.Buffer\n    var prefix = \"\"\n    for source, v := range app.db {\n      buffer.WriteString(prefix)\n      prefix = \",\"\n      buffer.WriteString(source)\n      buffer.WriteString(\":\")\n      buffer.WriteString(strconv.Itoa(v))\n    }\n    resQuery.Value = buffer.Bytes()\n    resQuery.Log = buffer.String()\n  }\n\n  if (strings.HasPrefix(query, \"Source\")) {\n    source := query[6:len(query)]\n    if val, ok := app.db[source]; ok {\n      resQuery.Value = []byte(strconv.Itoa(val))\n      resQuery.Log = string(val)\n    }\n  }\n\n  return\n}\n```", "```\n$ go build\n```", "```\n$ ./facts\n```", "```\napp.Router().\n    AddRoute(bank.RouterKey, bank.NewHandler(app.bankKeeper)).\n    AddRoute(staking.RouterKey, staking.NewHandler(app.stakingKeeper)).\n    ... ...\n```", "```\n$source = $_REQUEST['source'];\n$stmt = $_REQUEST['stmt'];\nif (empty($source) or empty($stmt)) {\n  // Not valid entry\n} else {\n  $transaction_req = 'localhost:46657/broadcast_tx_commit?tx=\"'\n        . urlencode($source) . ':'\n        . urlencode($stmt) . '\"';\n  $ch = curl_init($transaction_req);\n  curl_setopt($ch, CURLOPT_RETURNTRANSFER, TRUE);\n  curl_exec($ch);\n  curl_close($ch);\n}\n```", "```\n<?php\n  ... ...\n  $query_req = 'localhost:46657/abci_query?data=\"all\"';\n  $ch = curl_init($query_req);\n  curl_setopt($ch, CURLOPT_RETURNTRANSFER, TRUE);\n  $json_str = curl_exec($ch);\n  $json = json_decode($json_str, true);\n  $result = hex2str($json['result']['response']['value']);\n  curl_close($ch);\n  $entries = explode(\",\", $result);\n?>\n... ...\n<table class=\"table table-bordered table-striped\">\n  <thead>\n    <tr>\n      <th>Source</th>\n      <th># of statements</th>\n    </tr>\n  </thead>\n  <tbody>\n<?php\n  foreach ($entries as $entry) {\n    list($s, $c) = explode(\":\", $entry);\n?>\n    <tr>\n      <td><b><?= $s ?></b></td>\n      <td><?= $c ?></td>\n    </tr>\n<?php\n  }\n?>\n  </tbody>\n</table>\n```", "```\n<servlet>\n  <servlet-name>StartupServlet</servlet-name>\n  <servlet-class>\n    com.ringful.blockchain.facts.servlets.StartupServlet\n  </servlet-class>\n  <load-on-startup>1</load-on-startup>\n</servlet>\n```", "```\npublic class StartupServlet extends GenericServlet {\n  public void init(ServletConfig servletConfig) throws ServletException {\n    super.init(servletConfig);\n    try {\n      // This starts the ABCI listener sockets\n      FactsApp app = new FactsApp ();\n      getServletContext().setAttribute(\"app\", app);\n    } catch (Exception e) {\n      e.printStackTrace();\n    }\n  }\n}\n```", "```\npublic class IndexFilter implements Filter {\n  private FactsApp app;\n  FilterConfig config;\n  public void destroy() { }\n  public void doFilter (ServletRequest request,\n            ServletResponse response, FilterChain chain)\n                      throws IOException, ServletException {\n    if (app == null) {\n      app = (FactsApp) config.getServletContext().getAttribute(\"app\");\n    }\n    String source = request.getParameter(\"source\");\n    String stmt = request.getParameter(\"stmt\");\n    if (source == null || source.trim().isEmpty() ||\n        stmt == null || stmt.trim().isEmpty()) {\n      // Do nothing\n    } else {\n      CloseableHttpClient httpclient = HttpClients.createDefault();\n      HttpGet httpGet = new HttpGet(\n          \"http://localhost:46657/broadcast_tx_commit?tx=%22\" +\n          URLEncoder.encode(source) + \":\" +\n          URLEncoder.encode(stmt) + \"%22\");\n      CloseableHttpResponse resp = httpclient.execute(httpGet);\n\n      try {\n        HttpEntity entity = resp.getEntity();\n        System.out.println(EntityUtils.toString(entity));\n      } finally {\n        resp.close();\n      }\n    }\n    // Sends the application data store to the web page for JSTL\n    // to display in a table.\n    request.setAttribute(\"facts\", app.db);\n    chain.doFilter(request, response);\n  }\n  public void init(FilterConfig filterConfig) throws ServletException {\n    this.config = filterConfig;\n  }\n}\n```", "```\n<table class=\"table table-bordered table-striped\">\n  <thead>\n    <tr>\n      <th>Source</th>\n      <th># of statements</th>\n    </tr>\n  </thead>\n  <tbody>\n    <c:forEach items=\"${facts}\" var=\"fact\">\n      <tr>\n        <td><b>${fact.key}</b></td>\n        <td>${fact.value}</td>\n      </tr>\n    </c:forEach>\n  </tbody>\n</table>\n```", "```\n$ mvn clean package\n```"]