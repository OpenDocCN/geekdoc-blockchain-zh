- en: 'Part IV: Building Application Protocols'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the original vision of Ethereum was a single public blockchain to serve
    as a “world computer,” the reality is much more nuanced. It is now clear that
    a single public blockchain cannot scale to the capacity needed for mass consumer
    applications. Ethereum itself is moving toward the direction of multiple interconnected
    blockchains for sharding and state channels (for more about side chains, see [Chapter
    13](ch13.xhtml#ch13)). In fact, a compelling idea for sharding is to divide computing
    load onto various blockchains according to business application. For example,
    there could be a blockchain specializing in e-commerce, another specializing in
    gambling games, and yet another one specializing in payments and stable coins.
    These specialized blockchains are called *application protocol* blockchains.
  prefs: []
  type: TYPE_NORMAL
- en: I envision a world with many interconnected application protocol blockchains,
    each with a specially optimized virtual machine to efficiently handle one type
    of application. The Ethereum protocol will thrive by providing an interoperability
    layer for all those specialized and optimized blockchains.
  prefs: []
  type: TYPE_NORMAL
- en: Indeed, in the history of enterprise software engineering, successful products
    are always optimized for their specific application use cases. One size fits all
    does not work. In this part of the book, I will discuss how to develop optimized
    blockchains for specific application protocols. In this book, we will use open
    source software developed by Second State to customize and optimize the Ethereum
    platform, including the Lity language extension to Solidity ([www.LityLang.org](http://www.LityLang.org)).
    We will also use the CyberMiles public blockchain ([www.CyberMiles.io](http://www.CyberMiles.io))
    as a case study. The CyberMiles public blockchain is fully compatible with Ethereum
    but optimized for e-commerce applications.
  prefs: []
  type: TYPE_NORMAL
- en: 14. Extending the Ethereum Protocol
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous chapters of this book, you learned about the power and also
    the limitations of Ethereum. Ethereum is one of the first and certainly the most
    popular blockchain smart contract platform. It is a protocol with multiple open
    source implementations from the community and has a robust software upgrade process
    known as Ethereum Improvement Proposals (EIPs). However, as a big organization
    with many stakeholders, Ethereum improvement is a slow process. As a “world computer,”
    Ethereum is also unlikely to optimize for specific applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'I believe there are opportunities for many different public blockchains. Each
    of them will optimize Ethereum for specific application protocols. However, all
    of them will need to fix at least a few of Ethereum’s most glaring problems, as
    described here:'
  prefs: []
  type: TYPE_NORMAL
- en: The Ethereum Virtual Machine (EVM) has many limitations. While the EVM is Turing
    complete, it is inefficient to implement many algorithms. For example, it is currently
    impossible to implement public-private key applications on Ethereum because a
    single public key infrastructure (PKI) encryption operation will consume Ethereum
    gas fees worth hundreds of dollars. Even basic string operations are slow and
    expensive with the standard EVM.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ethereum is too slow. At about 20 transactions per second (fewer for smart contract
    transactions), Ethereum is not suitable for most application use cases.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It does not yet scale. With the Ethereum public blockchain in 2019, the more
    people who use it, the worse the user experience gets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It could be unsafe, especially for beginners. It is easy to send Ethereum assets
    to the wrong address or lose assets because of poorly written smart contracts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Smart contract programming is hard. Code audits have shown that Ethereum smart
    contracts average about 100 obvious bugs per 1,000 lines of code. That is an astonishing
    number for applications managing financial assets. In contrast, Microsoft business
    applications, which are a lot less mission critical, average about 15 bugs per
    1,000 lines of code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, I provide an overview of the technical approaches that could
    potentially alleviate these Ethereum shortcomings.
  prefs: []
  type: TYPE_NORMAL
- en: Fully Compatible, Yet Faster
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Second State creates Ethereum-compatible virtual machines that can run on a
    variety of underlying consensus mechanisms. This allows developers to choose the
    most suitable blockchain to deploy their applications. For example, the virtual
    machine can run as a Tendermint application (see [Chapter 20](ch20.xhtml#ch20))
    to take advantage of the Byzantine fault tolerant (BFT) Tendermint consensus engine,
    as well as the various delegated proof-of-stake (DPoS) mechanisms that can be
    implemented on top of Tendermint (e.g., the CyberMiles public blockchain).
  prefs: []
  type: TYPE_NORMAL
- en: The performance impediment of Ethereum is primarily a result of its proof-of-work
    (PoW) consensus mechanism. A huge amount of meaningless computation must be performed
    for each block of data that can be added to the blockchain. An Ethereum-compatible
    blockchain can easily achieve 100× performance gain by simply replacing the PoW
    module with a DPoS or delegated Byzantine fault tolerance (DBFT) module. For example,
    on the CyberMiles blockchain, consensus is reached by 19 validator nodes (i.e.,
    super nodes) before a new block is created. The validators are elected by CyberMiles
    token holders and are required to run high-performance hardware in tier 1 data
    centers.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: Being Ethereum-compatible, all Ethereum scalability solutions are also available
    on EVM-based blockchains. This allows users to take advantage of extensive research
    conducted by the Ethereum community and contribute improvements back to the Ethereum
    community. A great example here is the Plasma protocol, which aims to build layer
    2 networks to scale Ethereum to millions of transactions per second.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, as we will discuss in the next section, the virtual machine can
    offload complex computational tasks to native library functions. That allows for
    vastly improved smart contract execution speed and much lower gas costs for such
    tasks. For many operations, the native functions could represent four to six orders
    of magnitudes in terms of performance gains (see [Chapter 18](ch18.xhtml#ch18)
    for more).
  prefs: []
  type: TYPE_NORMAL
- en: Smart Enhancements to the EVM
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Lity is a new programming language extension to Solidity, with support for
    its features in an extended EVM version. Here are some of Lity’s features:'
  prefs: []
  type: TYPE_NORMAL
- en: Lity provides a new language keyword to call native library functions written
    in C or C++. This is known as the libENI framework. Through libENI, each Lity-based
    blockchain can be customized and optimized for address-specific application scenarios.
    I will discuss libENI in [Chapter 18](ch18.xhtml#ch18).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lity supports fixed-point math and sophisticated math operations. It provides
    deterministic results for fractional number operations, which was a key limitation
    in Ethereum.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lity supports timer-based operations scheduled for a future time. The scheduled
    execution is crucial for many classes of use cases, such as interest and dividends
    payment, trust and will, delivery confirmations, and so on. This is also called
    *long-running contracts*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lity supports “trusted” operations that can be invoked only by current validators
    or super nodes of the underlying blockchain. This allows for trusted smart contracts
    on the blockchain that can provide a first-class substitute for community-based
    oracles, which connect the blockchain to the outside world.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lity supports secure random numbers generated by validators or super nodes of
    the underlying blockchain.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lity supports alternative mechanisms for paying for gas fees in blockchains
    that require gas for executing smart contracts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lity supports a new type of “upgradeable” smart contract. Those contracts only
    expose the function interfaces to the world at the contract address. The actual
    implementation of those functions are proxy contracts deployed at other addresses
    on the blockchain. Lity supports virtual machine operations to change the smart
    contract’s proxy implementation. That allows developers to upgrade or fix critical
    bugs on smart contracts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lity supports new language constructs such as rule expressions so that application
    developers can build business rules directly into the smart contract (see [Chapter
    17](ch17.xhtml#ch17)). Those are commonly known as *domain-specific language*
    (DSL) features.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, let’s look into some concrete examples from this list.
  prefs: []
  type: TYPE_NORMAL
- en: Trusted Oracles
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One of the most important services on blockchains is the oracle service. An
    *oracle* is typically a smart contract that makes external data (i.e., off-chain,
    real-world, or cross-chain data) deterministically available on the blockchain.
    It provides a single source of truth for off-chain states and hence allows blockchain
    nodes to reach consensus.
  prefs: []
  type: TYPE_NORMAL
- en: The traditional oracle is highly centralized and goes against the spirit of
    the decentralized blockchain. For example, Fedex might establish a delivery service
    oracle that provides delivery status of packages. A weather station might establish
    a weather oracle. To use those oracles, blockchain users and dapps must trust
    the entities behind those oracles.
  prefs: []
  type: TYPE_NORMAL
- en: A second approach for oracles is to create a community-based cryptoeconomic
    game for members of the community to compete and provide the truth in a smart
    contract. Examples of such oracles include the BTC Relay to provide information
    about the Bitcoin blockchain, and the Ethereum Alarm Clock to provide time.
  prefs: []
  type: TYPE_NORMAL
- en: Lity, however, takes a different approach to create trusted smart contracts
    and make oracles first-class citizens. This approach works on DPoS blockchains.
    In a DPoS blockchain, the validators (super nodes) are trusted entities. They
    must stake a large number of tokens from their own account and from their supporters/community.
    Those tokens are subject to slashing and confiscation if the validator misbehaves.
    So, if a smart contract can be updated only by current validators, data from this
    contract should have a high level of trust on the DPoS blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: In the Lity language, a built-in function called `isValidator` checks whether
    the current transaction sender/function caller is a validator. It works on any
    Lity-based DPoS blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch14_images.xhtml#pro14_1)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Then with the `ValidatorOnly` modifier, we can construct smart contracts that
    act as trusted oracles on the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch14_images.xhtml#pro14_2)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Secure Random Numbers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Getting secure random numbers is a significant challenge for blockchain smart
    contracts. Lity pioneered an approach to access a random number series from a
    seed in the current block header. The random seed is based on the hashes of all
    transactions in the current block, and it is extremely difficult to manipulate
    even for the validator node that builds and proposes the block.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the smart contract, you can access the random number series by simply
    calling the built-in function `rand()`. The following is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch14_images.xhtml#pro14_3)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You should not call `rand()` in a `view` or `pure` function. If the random number
    does not need to be recorded on the blockchain (i.e., outside of a transaction
    in a `view` function executed on a single node), it does not need to be generated
    by the blockchain. The calling application should simply generate a random number
    locally, which is much cheaper in terms of resource consumption.
  prefs: []
  type: TYPE_NORMAL
- en: Alternative Gas Fees
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One of the major hurdles of blockchain application adoption is that end users
    are asked to pay a gas fee to perform certain functions on the blockchain. The
    gas mechanism is crucial for the blockchain’s security, as it prevents DoS attackers
    from overwhelming the blockchain nodes with computationally intensive requests.
    However, the gas requirement also means that new end users must be taught to purchase
    cryptocurrencies and manage private keys before they can even start to use decentralized
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Lity provides an alternative approach to onboard new users to blockchain applications.
    Through the `freegas` keyword, the smart contract owner can designate a contract
    function that should have gas fees paid by the owner herself. When the user calls
    those functions, she would indicate that she is not paying gas by setting `gasPrice`
    to 0.
  prefs: []
  type: TYPE_NORMAL
- en: If the `gasPrice=0` transaction calls a function that is *not* `freegas`, the
    transaction will fail.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the `gasPrice=0` transaction calls a `freegas` function in a contract that
    does not have a balance, the transaction will fail.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, the caller can specify a regular `gasPrice` (e.g., 2Gwei), and in
    that case, the caller pays for gas even if the contract function is `freegas`.
  prefs: []
  type: TYPE_NORMAL
- en: If the `gasPrice=0` transaction calls a `freegas` function in a contract that
    has a sufficient balance, then the function executes, and the gas fee is deducted
    from the contract address. The caller pays nothing, and the contract pays gas
    at the system’s standard gas price.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: There is a configurable rate limit for making `gasPrice=0` transactions. The
    blockchain node software can prevent users from exploiting the system by sending
    a lot of free transactions.
  prefs: []
  type: TYPE_NORMAL
- en: The following is an example. On the CyberMiles blockchain, if an end user calls
    the test function with `gasPrice=0` and the contract address has a CMT balance,
    the transaction’s gas fee will come out of the contract address.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch14_images.xhtml#pro14_4)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `payable` function is important as it allows the contract to receive funds
    that will later be used as gas. [Figure 14.1](ch14.xhtml#ch14fig1) shows the `freegas`
    transaction in action on the CyberMiles public blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f14_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 14.1** The caller makes a `freegas` transaction by setting `gasPrice`
    to zero.'
  prefs: []
  type: TYPE_NORMAL
- en: Safety First
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Through language and virtual machine enhancements in Lity, we can proactively
    prevent many classes of security problems. The following are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: The Lity compiler automatically checks the structural signature of the smart
    contracts it compiles. If it detects the smart contract is likely to be one of
    the popular types (e.g., an ERC20 or ERC721 token contract), it will check that
    all required methods are implemented and the contract is free of common errors.
    The Lity compiler throws errors if it sees a noncompliant ERC20 contract (learn
    more in [Chapter 15](ch15.xhtml#ch15)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Lity compiler checks for known code issues and bug patterns, such as the
    ERC20 contract’s compliance to the ERC223 safety standard. It throws warnings
    and can attempt to automatically fix some most serious issues.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Lity language provides access to secure random numbers generated by blockchain
    validators, when the consensus mechanism allows.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Lity virtual machine automatically checks for unsafe operations at runtime,
    such as integer overflow, which is a common ERC20 issue that had resulted in billions
    of dollars of value destruction. When a contract encounters an integer overflow
    in Lity runtime, it will stop execution with an error instead of proceeding with
    the overflowed buffer, as Ethereum does today. This eliminates a whole class of
    errors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As an open source collaborative effort, the Lity project aims to continuously
    bring updates to those security features, such as support for new ERCs and new
    code vulnerability patterns, to the community.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, I discussed how the Lity project extends the Ethereum protocol
    both at the consensus layer and at the virtual machine layer to create Ethereum-compatible
    blockchains that support much needed performance/security/usability enhancements
    as well as experimental features. In the next several chapters, we will look into
    application design and development on the Lity language and virtual machine.
  prefs: []
  type: TYPE_NORMAL
- en: 15. Extending Ethereum Tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous chapter, you saw how the Lity language and virtual machine extends
    and improves on the Ethereum protocol. The open source Ethereum ecosystem also
    encourages such platforms to extend and fork existing tools to incorporate new
    features.
  prefs: []
  type: TYPE_NORMAL
- en: Lity tools include wallets, block explorers, and coding/deployment tools. These
    tools are customized and configured for each blockchain and are supported by commercial
    providers, such as Second State ([www.SecondState.io](http://www.SecondState.io)).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, I will cover Lity-customized tools for the CyberMiles public
    blockchain. They include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The Venus chrome extension is CyberMiles’ extension of the Metamask wallet for
    Ethereum.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Europa integrated development environment (IDE) is Lity and CyberMiles’
    fork of the Remix IDE for Ethereum.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The web3-cmt.js library is the customized web3 library that supports the CMT
    cryptocurrency on the CyberMiles blockchain. It can be customized to any Lity-based
    blockchain.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The CyberMiles App (aka the CMT wallet) is a mobile wallet application that
    runs CyberMiles dapps inside the wallet.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `lityc` project provides tools to analyze and secure Lity smart contract
    source code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A blockchain explorer web service provides a query and search interface for
    blockchain data on a Lity-based blockchain. On CyberMiles, this data service is
    available at [www.CMTTracking.io](http://www.CMTTracking.io).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: With Second State’s BUIDL online IDE ([http://buidl.secondstate.io](http://buidl.secondstate.io)),
    you can experiment with the latest Lity features on a live blockchain. There is
    no need to deal with cryptocurrencies or gas fees or event wallets, just Lity
    contracts and web3 JavaScript applications. Learn more in [Chapter 3](ch03.xhtml#ch03).
  prefs: []
  type: TYPE_NORMAL
- en: Smart Contract Tools
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, I will review how to develop and deploy smart contracts on
    the CyberMiles blockchain using the Europa online IDE together with the Venus
    wallet.
  prefs: []
  type: TYPE_NORMAL
- en: Venus Wallet
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Venus wallet ([Figure 15.1](ch15.xhtml#ch15fig1)) is a Chrome browser extension
    to manage your CyberMiles blockchain accounts. It is based on the open source
    Metamask software. It stores and manages your private keys to those accounts on
    your computer (i.e., a wallet for private keys and, by extension, cryptocurrency
    stored in those accounts). For developers, Venus is a great tool since it integrates
    with other development tools and allows you to interact with CyberMiles accounts.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f15_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 15.1** The Venus wallet is based on the open source Metamask project.'
  prefs: []
  type: TYPE_NORMAL
- en: First, make sure you have the latest Google Chrome browser installed. You can
    get it at [https://www.google.com/chrome/](https://www.google.com/chrome/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, follow the instructions on the CyberMiles web site to install Venus on
    your Chrome browser: [https://cybermiles.io/venus](https://cybermiles.io/venus).'
  prefs: []
  type: TYPE_NORMAL
- en: Now, you should see the Venus icon on your Chrome toolbar. Click it to bring
    up its user interface (UI). You should create a password for your Venus wallet.
    This is important since your password protects your account private keys stored
    on this computer. Once you create the password, Venus will give you a 12-word
    recovery phrase. That is the only way for you to recover the password, so keep
    it safe!
  prefs: []
  type: TYPE_NORMAL
- en: For development purposes, select the top-left drop-down list from the Venus
    UI, and select CyberMiles Testnet, which is a CyberMiles public blockchain maintained
    for testing purposes.
  prefs: []
  type: TYPE_NORMAL
- en: You will also need to create an account on the testnet to store your testnet
    CMTs there. Select the icon at the top right of the Venus UI, and click **Create
    Account**. Venus will create an account address and its associated private key
    for you. You can name this account so that you can access it in the Venus UI later.
    You can also use Venus to manage mainnet CMTs, which can be traded on exchanges
    for U.S. dollars. But to do that, you should make sure that your computer is physically
    secure since real money will be at stake.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, you still need to fund your account with some testnet CMTs to use
    it. Go to the public CyberMiles testnet faucet at [https://travis-faucet.cybermiles.io/](https://travis-faucet.cybermiles.io/)
    and request 1,000 testnet CMTs for your address! The testnet CMTs can be used
    only on the testnet. They are not traded on any exchanges and can disappear at
    any time when the testnet is retired. Unlike the mainnet CMTs, testnet CMTs have
    zero monetary value.
  prefs: []
  type: TYPE_NORMAL
- en: Now you have set up Venus and are ready to interact with your first smart contract
    on the CyberMiles testnet!
  prefs: []
  type: TYPE_NORMAL
- en: Europa IDE
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The Europa IDE is based on Remix on the Ethereum blockchain but customized
    for CyberMiles. Europa is completely web-based. Just go to its web site to load
    the web app: [http://europa.cybermiles.io/](http://europa.cybermiles.io/).'
  prefs: []
  type: TYPE_NORMAL
- en: In the code editor to the right, let’s enter a simple smart contract. What follows
    is an example of the `HelloWorld` smart contract. It is written in Solidity/Lity.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch15_images.xhtml#pro15_1)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `HelloWorld` smart contract has two key methods.
  prefs: []
  type: TYPE_NORMAL
- en: The `sayHello()` method returns a greeting to its caller. The greeting is initially
    set to “Hello, World!” when the smart contract is deployed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `updateMessage()` method allows the method caller to change the greeting
    from “Hello, World!” to another message.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hit the **Start to compile** button in the right panel ([Figure 15.2](ch15.xhtml#ch15fig2))
    to compile this contract. This will generate the bytecode and application binary
    interface (ABI) to be used later. When you click the ABI or Bytecode button, the
    ABI or bytecode will be copied to the computer’s clipboard, and you can paste
    them into other files or applications later.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f15_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 15.2** Compiling a CyberMiles smart contract on Europa'
  prefs: []
  type: TYPE_NORMAL
- en: Next, on the Run tab of Europa, you can connect Europa to your Venus account
    via the Injected Web3 drop-down box. Europa will automatically detect your currently
    selected Venus account.
  prefs: []
  type: TYPE_NORMAL
- en: You should now see options to deploy the smart contract to the blockchain. Click
    the **Deploy** button to deploy the contract to the blockchain. The contract will
    be deployed on the CyberMiles testnet. At this time, Europa will pop up and ask
    you to send the “gas fee” from your account address ([Figure 15.3](ch15.xhtml#ch15fig3)).
    The gas fee is required by the CyberMiles blockchain to pay for the network service
    required to deploy your contract.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f15_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 15.3** Paying a gas fee to deploy the contract'
  prefs: []
  type: TYPE_NORMAL
- en: After you submit the request, wait for a few minutes for the CyberMiles network
    to confirm the deployment of your contract. The contract deployment address will
    be shown in the confirmation ([Figure 15.4](ch15.xhtml#ch15fig4)), and the deployed
    contract and its available methods will be available on the Europa Run tab as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f15_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 15.4** The contract is now deployed, and the available methods are
    shown.'
  prefs: []
  type: TYPE_NORMAL
- en: If you have already deployed the smart contract on the testnet, you already
    know the deployed address of the contract. You can simply enter the contract address
    on the box next to the At Address button and then click the button. This will
    configure Europa to use an already-deployed contract. No gas fee is needed in
    this case.
  prefs: []
  type: TYPE_NORMAL
- en: Once Europa is connected to your deployed contract, it shows the contract methods
    on the Run tab. You can enter a new greeting next to the updateMessage button
    and click the button to update the message ([Figure 15.5](ch15.xhtml#ch15fig5)).
    Since blockchain storage is required to store the updated message, you will again
    be prompted to pay a gas fee through Venus.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f15_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 15.5** Calling the `updateMessage()` method'
  prefs: []
  type: TYPE_NORMAL
- en: Once the network confirms the message update, you will again see a confirmation
    message. After the `updateMessage()` is confirmed, you can call `sayHello()` from
    Europa ([Figure 15.6](ch15.xhtml#ch15fig6)), and you will see the updated message.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f15_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 15.6** Calling the `sayHello()` method'
  prefs: []
  type: TYPE_NORMAL
- en: The Europa IDE is easy to use. It is an excellent choice for beginners. You
    can also interact with the blockchain through command-line tools on each node.
    The node software provides more capabilities, and we will discuss it later in
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The `lityc` Compiler and Analysis Tool
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `lityc` software extends the Ethereum `solc` to provide a compiler for the
    Lity language. It compiles the Lity smart contract into ABI and bytecode. You
    can then use the Travis node console or web3-cmt.js to deploy the ABI and bytecode
    to the CyberMiles public blockchain as smart contracts. Please see [Appendix A](app.xhtml#app)
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: While compiling and deploying can also be done in tools like Europa, a more
    interesting feature of the command-line `lityc` is its source code static analyzer.
    For example, the `lityc` compiler can check the contract’s compliance to specified
    ERC specification. Let’s consider the following contract. The `totalSupply()`
    function does not conform to the ERC20 specification.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch15_images.xhtml#pro15_2)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Running `lityc` to compile it will yield the following error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch15_images.xhtml#pro15_3)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'At the time of this writing, `lityc` supports the following ERC specifications,
    and more are being added on a regular basis:'
  prefs: []
  type: TYPE_NORMAL
- en: ERC20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ERC223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ERC721
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ERC827
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ERC884
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Furthermore, if you have the Oyente static analysis tool installed on your
    computer, `lityc` can automatically run Oyente when compiling. See the following
    code for an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch15_images.xhtml#pro15_4)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Oyente is an open source project that is actively developed and updated to detect
    even more problem patterns with smart contract source code. Oyente integration
    with `lityc` will likely drive adoption of static analyzer tools in blockchain
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Dapp Tools
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While Europa is a great tool, it is too hard for regular people. To make your
    smart contracts available to the general public, you typically need to build a
    web-based UI. For that, you need the web3-cmt.js JavaScript library to interact
    with the CyberMiles blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: From this point on, I presume you have successfully deployed the previous `HelloWorld`
    contract to the CyberMiles mainnet and recorded its deployed contract address.
    The reason is that production version of the CyberMiles App (CMT wallet) works
    only with CyberMiles mainnet contracts (see the “CyberMiles App” section).
  prefs: []
  type: TYPE_NORMAL
- en: web3-cmt
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Once Europa is installed, it automatically injects a custom instance of the
    `web3` object (or `web3.cmt` object) into the page’s JavaScript context. Method
    calls that require private keys will automatically prompt the user to select an
    account, and Metamask will use the selected private key to sign the transaction
    before sending it to the Ethereum network. In addition, all web3 API calls must
    be asynchronous. So, we use the web3 callback API to handle the return values.
    The source code for the `helloworld_europa.html` file follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch15_images.xhtml#pro15_5)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `web3.cmt.contract(...).at("...")` function takes the contract’s deployment
    address on the blockchain as a parameter. You can find it on the Run tab in Europa.
    The `contract` function takes a JSON structure known as the contract’s ABI, which
    you can copy from Europa, as shown in [Figure 15.2](ch15.xhtml#ch15fig2).
  prefs: []
  type: TYPE_NORMAL
- en: The web application now allows users to interact with the `HelloWorld` smart
    contract directly from the Web ([Figure 15.7](ch15.xhtml#ch15fig7)). The “submit
    new message” action requires Europa to send gas fees since it invokes the `updateMessage()`
    method on the contract. Notice that all web3 functions are nested and invoked
    asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f15_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 15.7** Using the Europa wallet to write to a contract'
  prefs: []
  type: TYPE_NORMAL
- en: Using Europa together with `web3-cmt` is one of the best ways to get started
    with CyberMiles application development. But for the average user, the process
    of installing and using Europa is a significant barrier of entry. Next, let’s
    explore how to run dapps inside the CyberMiles App (CMT wallet) mobile application.
  prefs: []
  type: TYPE_NORMAL
- en: CyberMiles App
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The CyberMiles App is a consumer-grade mobile wallet application that requires
    no complicated installs. You can get the CyberMiles App at [http://app.cybermiles.io/](http://app.cybermiles.io/).
  prefs: []
  type: TYPE_NORMAL
- en: To run a dapp from the CyberMiles App, the easiest approach is to create a QR
    code from the dapp’s URL and then use the wallet application to scan the URL.
    You can create a QR code for any URL at [www.qr-code-generator.com/](http://www.qr-code-generator.com/).
    [Figure 15.8](ch15.xhtml#ch15fig8) shows the entire process.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f15_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 15.8** Scanning a bar code to load a dapp in the CyberMiles App'
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, the dapp could be on a regular web site and redirect to the CyberMiles
    App when it needs to send transactions to the blockchain. The FairPlay dapp discussed
    in [Chapter 11](ch11.xhtml#ch11) is a good example of this. [Figure 15.9](ch15.xhtml#ch15fig9)
    shows another, simpler example.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f15_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 15.9** Using the CyberMiles App to run the dapp and pay for gas fees'
  prefs: []
  type: TYPE_NORMAL
- en: Dapp user experience in the CyberMiles App is one of the advantages CyberMiles
    has over Ethereum.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, I reviewed tools for the Ethereum-compatible CyberMiles blockchain.
    I reviewed the available wallets, web3 library, and development/deployment tools
    for CyberMiles. In the next chapter, we will put these together and see a few
    complete example dapps that were developed using Lity and have been deployed on
    the CyberMiles public blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: 16. Example Dapps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous two chapters, I discussed how to extend the Ethereum protocol
    and related development tools. But how do those extensions and improvements translate
    into real-world applications? In this chapter, I will discuss a few complete dapps
    deployed on CyberMiles to illustrate how Ethereum extensions make it possible
    for developers to create interactive dapps for the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: Everything discussed in this chapter is compatible with Ethereum. But as discussed,
    CyberMiles offers some important advantages as an Ethereum-compatible development
    and deployment platform.
  prefs: []
  type: TYPE_NORMAL
- en: CyberMiles has a much faster transaction confirmation time than Ethereum. That
    is important for interactive dapp user experience (UX) since it reduces the time
    needed for operations to be confirmed and recorded on the blockchain.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CyberMiles has a mobile wallet application that can run web3-based JavaScript
    applications in an embedded mode. The CMT wallet is available in all iOS and Android
    app stores, and you can load the dapp by scanning a bar code pointing to the JavaScript
    code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The CyberMiles blockchain uses the CMT token to pay for gas fees. As the CMT
    price is much lower ETH, it can accomplish much more with the same amount of money.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, let’s get started.
  prefs: []
  type: TYPE_NORMAL
- en: 'Case Study 1: Valentines'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Valentines dapp is for people to declare and record their love permanently
    on the blockchain. Through the CyberMiles App (CMT wallet), anyone can create
    a love declaration and share the QR code (see [Figure 16.1](ch16.xhtml#ch16fig1)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f16_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 16-1** Declaring your love'
  prefs: []
  type: TYPE_NORMAL
- en: The recipient of the declaration uses her CyberMiles App to scan the QR code
    and open the dapp. From there, she can reply to the declaration. Once she replies,
    she can share the QR code to the world so that anyone can open the dapp and witness
    the declaration and reply recorded on the blockchain ([Figure 16.2](ch16.xhtml#ch16fig2)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f16_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 16-2** Replying and witnessing the declaration'
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s review the smart contract code behind the Valentines contract and
    then the JavaScript dapp to interact with the Valentines contract.
  prefs: []
  type: TYPE_NORMAL
- en: The Valentines Smart Contract
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The Valentines smart contract contains all the declarations and replies (each
    of them is a valentine) submitted from the dapp. It has two main functions: `declare()`
    to create a new declaration and `reply()` to reply to an existing declaration.
    It also has two informational functions (`view` functions), `getDeclaration()`
    and `getReplies()`, to help dapps retrieve information from the blockchain.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch16_images.xhtml#pro16_1)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The contract’s four functions are self-explanatory. The `Declaration` struct
    contains a declaration and its reply. The declaration is mapped to its creator
    in the `declarations` mapping array. The `replies` array maps each address to
    the declarations it replied to. Note that each address can make one declaration
    but can reply to multiple declarations.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can deploy the contract to the CyberMiles blockchain and record the
    deployed contract address. The easiest approach is probably to use the CyberMiles
    Europa tool or the Second State BUIDL tool configured for CyberMiles. The JavaScript
    dapp accesses this deployed contract.
  prefs: []
  type: TYPE_NORMAL
- en: The JavaScript Dapp
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The dapp is written in JavaScript and runs in the client browser in conjunction
    with a wallet application. The `getDeclaration()` function in the `declare.js`
    file calls the smart contract’s `getDeclaration()` function and then uses the
    results to update the HTML user interface (UI) in the `declare.html` file. The
    following code snippet shows the `getDeclaration()` function in the JavaScript
    dapp. Notice that all web3-related operations are done asynchronously since many
    are remote calls, and we have to guarantee the correct order to execution. The
    `contract_address` value is the previously mentioned contract address after successful
    deployment. It is hard-coded into the dapp. The `targetAddress` value is the address
    from which this declaration was made. The `userAddress` value is the current user’s
    CMT address.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch16_images.xhtml#pro16_2)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: When the user makes a declaration, the contract’s `declare()` function is called.
    Notice that we have to pay a small gas fee to invoke this function since it saves
    data on the blockchain. Upon successful return of the contract function call,
    the JavaScript waits for the transaction to be confirmed on the blockchain (when
    the block is produced and accepted by the validators) and then reloads the `getDeclaration()`
    function to update the UI.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch16_images.xhtml#pro16_3)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: When a second user replies to the declaration, the dapp calls the `reply()`
    function on the contract and updates the UI after the transaction is confirmed
    on the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch16_images.xhtml#pro16_4)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: So far, we have reviewed the core logic of the Valentines dapp and how it interacts
    with data and functions on the blockchain via web3\. The dapp uses open source
    libraries to perform other important tasks. For example, it uses the `qrcode.js`
    script to generate QR codes on the fly. It uses the `IUToast` script to create
    messages and alerts for users.
  prefs: []
  type: TYPE_NORMAL
- en: The Valentines dapp has only a single web page and a single JavaScript control
    file. It interacts with an already deployed smart contract. In the next section,
    we will study a more complex dapp called WeBet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Case Study 2: WeBet'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The WeBet dapp is a peer-to-peer betting application. It allows anyone to create
    a bet contract inside the CyberMiles App ([Figure 16.3](ch16.xhtml#ch16fig3))
    and share the bet ([Figure 16.4](ch16.xhtml#ch16fig4)). The bet is a multiple-choice
    question.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f16_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 16-3** Creating a new WeBet contract'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f16_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 16-4** Sharing a WeBet contract'
  prefs: []
  type: TYPE_NORMAL
- en: Other people can then use their own CyberMiles Apps to place bets ([Figure 16.5](ch16.xhtml#ch16fig5)).
    They get to the bet by simply scanning the QR code shared by the bet contract’s
    creator. They each select a choice and send CMTs to the contract as the bet on
    that choice.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f16_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 16-5** Placing a bet on a WeBet contract'
  prefs: []
  type: TYPE_NORMAL
- en: The creator can declare a winning choice after the bets are placed ([Figure
    16.6](ch16.xhtml#ch16fig6)). There could be multiple winners since several people
    could select the same choice.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f16_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 16-6** Declaring a winner choice'
  prefs: []
  type: TYPE_NORMAL
- en: The winners use their CMT wallets to claim winnings from the bet ([Figure 16.7](ch16.xhtml#ch16fig7)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f16_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 16-7** Claiming WeBet winnings'
  prefs: []
  type: TYPE_NORMAL
- en: Another use case of the WeBet dapp is to create “commitment contracts.” That
    is, someone can create a personal goal (e.g., to lose 10 pounds in a month) and
    bet on the goal outcome with a large amount of CMTs (e.g., 10,000 CMTs) as a commitment.
    Then, friends and family will each bet a small amount (e.g., 1 CMT) on the opposite
    outcome. If the creator achieves his goal, he will get the commitment CMTs back.
    If not, friends and family will share the commitment CMTs.
  prefs: []
  type: TYPE_NORMAL
- en: This type of personal betting application is well suited for the public blockchain.
    The blockchain dapp could potentially provide a much better user experience than
    a traditional web application.
  prefs: []
  type: TYPE_NORMAL
- en: The smart contracts on the public blockchain guarantee that the application
    developer or host cannot cheat by changing the betting records, or even running
    away with the funds. Similarly, it is difficult for governments or other entities
    to shut down these contracts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is much easier to transfer “value” on the blockchain. To bet with small amounts
    of fiat money, you still need the whole banking infrastructure and its high fees.
    On an established public chain like CyberMiles or Ethereum, the tokens have an
    established exchange rate with U.S. dollars and are much easier and cheaper to
    use as payments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, let’s review the smart contract code behind the WeBet contract and then
    the JavaScript dapp to interact with WeBet contracts.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: You have probably noticed that the WeBet contract owner must declare the winning
    choice for the bet. Can the contract owner cheat here? Yes, mapping real-world
    off-chain information (i.e., whether he lost 10 pounds) onto the blockchain is
    always a challenge. However, it is also important to note that everything related
    to the WeBet contract, including the declaration and all the bets, are recorded
    on the blockchain for everyone to see. If a contract owner does cheat, he forever
    damages his reputation.
  prefs: []
  type: TYPE_NORMAL
- en: We could also modify the product to require multiple known “arbiters” to verify
    the contract owner declaration before it takes effect. However, that makes the
    product more complex to use.
  prefs: []
  type: TYPE_NORMAL
- en: WeBet Smart Contract
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The overall structure of the WeBet smart contract written in Solidity is as
    follows. As discussed, the dapp creates a new instance of the WeBet contract for
    every new betting contract.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch16_images.xhtml#pro16_5)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The constructor method creates the contract with all the information needed
    to set up the betting.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `game_desc` string contains the bet’s title, description, and all the choices.
    They are constructed in a single string with the `;` symbol to delimit various
    components. For example, the `game_desc` string could be as follows: `bet title;choice
    1;choice 2;choice 3`. We are not passing and storing choices in string arrays
    because of Solidity’s limitations on string arrays. The parsing work is left for
    JavaScript in the dapp as it is not core to the transaction logic of the contract.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `number_of_choices` value specifies the number choices contained in the
    `game_desc` string. In our example, it would be `3`. This helps the dapp JavaScript
    parse the information components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `min_bet_amount` value is the minimum amount each user must bet to participate
    in the game. It is in the unit of CMTs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `allow_user_bet_amount` value is a `boolean` variable that specifies whether
    a user can bet in an amount greater than `min_bet_amount`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the contract is created, the `game_status` variable defaults to `1`, which
    means the betting has started. Through methods such as `stopGame()`, `resumeGame()`,
    `endGame()`, and `cancelGame()`, you can change the game status. That allows the
    contractor owner to stop voting before declaring a winner. For example, a sports
    bet should stop once the game starts in the real world, and the winner will be
    declared when the real-world game ends. The `getBetInfo()` function returns the
    basic information and status of the bet.
  prefs: []
  type: TYPE_NORMAL
- en: The `bets` array in the contract maps an address to `Bet`. Each `Bet` struct
    in the array is created by a bet. It contains the better’s choice, the amount
    she bets, and whether this user has claimed her winnings if she wins. The better’s
    address is the key in the `bets` array.
  prefs: []
  type: TYPE_NORMAL
- en: The `choice_bet_amounts` array in the contract maps each choice to its aggregated
    bet amounts (in the unit of CMTs). It allows easy computation of the winning for
    each betting address. The `checkStatus()` function is called by the dapp to check
    the bet status and winning of the current user address.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch16_images.xhtml#pro16_9)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now the key function in the entire contract is the `placeBet()` function. It
    is called by any users who want to place a bet on a choice in this contract. The
    function is `payable`, meaning that the user can attach a payment to its call.
    The payment is the bet placed on the choice. It should at least meet the `min_bet_amount`.
    Once a bet is made, the contract’s `bets` and `choice_bet_amounts` arrays are
    both updated.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch16_images.xhtml#pro16_10)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: A user checks her winnings by calling the `checkStatus()` function from her
    betting address. If the user wins, she can get paid from the contract by calling
    the `payMe()` function. Notice that if the `game_status` indicates that the owner
    has canceled the bet, every better is refunded.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch16_images.xhtml#pro16_11)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The Solidity smart contract is deliberately simple. It mostly deals with important
    application states and automatic transfer of “money” (i.e., CMTs in this case).
    It is a back-end service for the JavaScript dapp.
  prefs: []
  type: TYPE_NORMAL
- en: WeBet JavaScript Application
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The WeBet dapp is a JavaScript application that can be executed inside the CyberMiles
    App or in a Chrome browser with the CyberMiles Venus (Metamask for CMT) extension
    enabled. In the `browser.js` file, we test if the `web3.cmt` object is `nil`.
    If it is, the user will be directed to install the CMT wallet on mobile devices
    or Venus Chrome extension on PCs and then restart the dapp.
  prefs: []
  type: TYPE_NORMAL
- en: Since the dapp is just a collection of static JavaScript and HTML files, the
    files can be served from any anonymous web server or even be bundled inside the
    device client. There is no need for a central server to manage the application
    state. In our example, the dapp files are served from [http://webet.codeislaw.co/](http://webet.codeislaw.co/).
  prefs: []
  type: TYPE_NORMAL
- en: Create a New WeBet Contract
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The `start.html` and `start.js` files in the dapp work in tandem to support
    the creation and deployment of a new WeBet contract. The HTML file captures the
    user input about the contract details (e.g., title, choices, minimum bet amount),
    and the JS file creates the contract on the blockchain. The following is the initialization
    code for the `start.js` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch16_images.xhtml#pro16_12)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Notice that every blockchain-related operation is done asynchronously. The app
    shows a spinner and asks the user to wait while it discovers the user’s current
    account address from the wallet. The `startGame()` JavaScript function is mapped
    to the click event when the user hits the Submit button to create a WeBet contract.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch16_images.xhtml#pro16_13)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Aside from the regular input validation and processing code, the main part of
    the function is nested in two asynchronous blocks. The `estimateGas()` function
    asks a connected blockchain node to estimate the amount of gas fee needed to create
    this contract. We multiply the gas by 2 since the estimate is sometimes conservative.
    Notice that this is the *gas limit*, or the maximum amount gas the user authorizes
    to use. The user will be charged only for the actual gas used when creating the
    contract. Then, the `contract.new()` function passes information to the contract’s
    `constructor()` function and asynchronously returns the newly created contract’s
    address.
  prefs: []
  type: TYPE_NORMAL
- en: The dapp UI displays a spinner until the contract address is successfully created
    and returned. It then calls the `setTheContractAddressAndTurn()` function to navigate
    to the betting screen.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch16_images.xhtml#pro16_15)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The dapp now navigates to the `join.html` screen. The URL with the contract
    address is how other people access this bet from their CyberMiles App (CMT wallets).
    The `join.html` screen can create a QR bar code to be shared with friends and
    potential betters.
  prefs: []
  type: TYPE_NORMAL
- en: Bet on a Choice
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `join.html` and `bet.js` files work in tandem to present the betting UI.
    The `getGameStatus()` function retrieves information from the contract’s `checkStatus()`
    function. It is a `pure view` function and hence requires no gas to operate. Once
    the JavaScript `getGameStatus()` function receives the result, it parses the title,
    choices, the current choice, the current bet, and the user’s award status, and
    then displays those information items on the `join.html` screen. I will not repeat
    that code in this book as it is lengthy, but you can see it in the source code
    listing.
  prefs: []
  type: TYPE_NORMAL
- en: The `confirmOptionSubmit()` function is called when the user submits her bet.
    It calls the contract’s `placeBet()` function asynchronously after estimating
    gas. The bet is sent to the contract as a value for the payable `placeBet()` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch16_images.xhtml#pro16_16)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Once the `placeBet()` function call returns, the dapp does not wait for the
    transaction to be confirmed. It just goes ahead and updates the UI to show the
    current selected choice and a message showing that the bet is submitted. The `getGameStatus()`
    function refreshes the page every ten seconds to get the latest from the blockchain.
    Once the transaction is confirmed on the blockchain, the message changes to say
    that the bet is recorded.
  prefs: []
  type: TYPE_NORMAL
- en: Declare the Winning Choice
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: When the `bet.js` script displays information retrieved from the WeBet smart
    contract, it determines whether to display the owner’s control options, such as
    the options to stop the bet or to declare a winning option.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch16_images.xhtml#pro16_18)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: When the user touches the owner button, she sees a dialog box to declare a winning
    option. The action is mapped to the `declareBetGame()` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch16_images.xhtml#pro16_19)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The contract’s `endGame()` function is called. This allows the contract to compute
    winnings for each bet participant. After the remote function call returns, the
    WeBet UI refreshes.
  prefs: []
  type: TYPE_NORMAL
- en: Claim Your Winnings
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: When the user loads the dapp again after the winning choice is declared, she
    sees whether her bet choice is the winning one. And if she wins, she sees an option
    to get the reward into her current account address.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch16_images.xhtml#pro16_21)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: When the user clicks the button to claim her winnings, the contract’s `payMe()`
    function is called.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch16_images.xhtml#pro16_22)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This design requires the user to come back to her bet and pay the gas fee to
    claim her winnings. Another option is to automate the contract so that the owner
    pays the gas fee at `endGame()` and the contract automatically distributes the
    winnings.
  prefs: []
  type: TYPE_NORMAL
- en: With the current WeBet design, the dapp user needs to access her past bets.
    In our setup, we use data stored locally or on replaceable servers to achieve
    decentralization. That is the topic of the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Dapp Off-Chain Operations
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The WeBet dapp illustrates how to store nonessential application data in off-chain
    services. The off-chain data is not stored in a central server like with typical
    web apps. The data belongs to each WeBet dapp user.
  prefs: []
  type: TYPE_NORMAL
- en: The JavaScript Local Storage
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The WeBet dapp uses JavaScript’s `localStorage` API for storing data related
    to the current user. For example, in the `start.js` file, we use the local storage
    to save the user’s current address and the newly created contract address. They
    are needed for the next web page, `join.html`, which can be shared with other
    betting participants.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch16_images.xhtml#pro16_23)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The local storage can be used to store data that is private to the current user.
    It is stored on the device that runs the wallet. Only people who have access to
    the device can get this data.
  prefs: []
  type: TYPE_NORMAL
- en: Replaceable Third-Party Services
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `my.html` and `my.js` files work together to display a list of WeBet contracts
    the current user has participated in. The Ethereum protocol does not provide a
    way to query the blockchain nodes for this type of information. For the WeBet
    dapp, we build an online service that ingests the blocks from a CyberMiles node,
    builds a relational database for the data in the blocks (e.g., contracts, owners,
    and bets), and then provides an API to query the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'This database is decentralized because it can be deployed by anyone using open
    source software. So, the dapp has many potential choices for this data source.
    There is no single power of failure or control. The following is the relevant
    code in `my.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch16_images.xhtml#pro16_24)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the service is deployed at `api.cmttracking.io` and allows searching
    for smart contract addresses via their bytecode signatures.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, using the Valentines and WeBet dapps as examples, I showed
    how to create complete dapps on the CyberMiles public blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: 17. Business Rules and Contracts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The blockchain virtual machine is essentially a state machine that reacts to
    state changes in the accounts (i.e., the transactions). Of course, as part of
    the reaction, the virtual machine can also cause additional state changes. In
    many cases, such state changes can be defined and described by sets of formal
    rules (“If this, then that,” or ITTT). In fact, in modern computer systems, most
    machine-to-machine interactions are defined by such rules.
  prefs: []
  type: TYPE_NORMAL
- en: However, when we have multiple interacting systems, explicitly coding and executing
    rules using a general programming language becomes impossible even for seasoned
    computer programmers. For example, in a typical airline mileage program, the points
    a person earns depend on complex rules for her account status, account history,
    the ticket purchased, and the flight taken. Each of those systems has its own
    rules, and the final execution outcome (the points awarded after this flight)
    is a “join” operation for all of those rules. Furthermore, those rules should
    not be programmed or maintained by computer programmers, as they are often changing
    depending on business requirements. A business analyst must be able to create,
    validate, and maintain those rules. That had given rise to the business rules
    engine (BRE).
  prefs: []
  type: TYPE_NORMAL
- en: A typical BRE consists of a specialized computer programming language (formal
    rules language), runtime to execute rules, and optional visual tools to create
    and manage rules. BREs are available in almost any programming language and are
    widely available from commercial and open source providers. Examples of well-known
    BREs include Drools, Jess, Pega, ILOG, and InRule. Lity, the programming language
    and virtual machine, is the first blockchain-based BRE.
  prefs: []
  type: TYPE_NORMAL
- en: Supporting the rules language and tools in blockchain smart contracts could
    help bring a large number of business analysts/programmers and their existing
    rules applications into the blockchain ecosystem. A BRE allows people to build
    decentralized financial, e-commerce, and other applications using familiar tools.
    On the other hand, the blockchain provides a secure and verifiable platform to
    execute business rules and could bring a new level of trust to a BRE.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will explore how the Lity smart contract language and the
    CyberMiles public blockchain support formal business rules in the smart contract
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: An Example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Lity rules definition is simple. The overall approach is to first define
    when the rule should be triggered and then define the triggered actions.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s examine a rule that will give retirees their stipend when there is available
    budget. The BRE has a “working memory” space to store personal profiles, as well
    as the budget. When the rule is fired, the execution engine in the Lity virtual
    machine goes through all the objects in the working memory and identifies the
    combinations that meet the `when` clause. It executes the `then` clause and updates
    the state of the objects in the working memory. The virtual machine executes this
    rule over all objects in the working memory until the `when` clause can match
    no object in the working memory anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch17_images.xhtml#pro17_1)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code snippet, the Lity virtual machine matches a person who
    is older than 60 and is eligible for the stipend. It then checks whether the budget
    is still available. If both conditions are met, the `when` clause finds a match,
    and the `then` clause is triggered. The `then` clause sends the fund to the person
    and reduces the budget. One of the `then` actions is to change the person’s `eligible`
    attribute to `false` so that this person will not be matched by the `when` clause
    again because, as described, the rules engine runs the rule over and over again
    until no more match can be found.
  prefs: []
  type: TYPE_NORMAL
- en: Now, how do we get the `Person` objects and the Budget object into the working
    memory of the Lity rules engine? This is done via the `factInsert` and `factDelete`
    statements in Lity. The following code listing shows the contract in its entirety.
    The `Budget` object is inserted into the working memory when the contract is created.
    The `addPerson()` function adds a `Person` object to the working memory. It keeps
    a reference to the person in the `ps` array so that the person can be removed
    from the working memory later if needed. The `pay()` function fires the rule against
    all objects in the working memory.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch17_images.xhtml#pro17_2)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: You can type this contract into CyberMiles’ Europa online integrated development
    environment (IDE) and deploy it to the live CyberMiles public blockchain network
    ([Figure 17.1](ch17.xhtml#ch17fig1)). You can use the Europa UI to directly interact
    with contract methods such as `addPerson()` and `pay()` to see the rules execution
    in action.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f17_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 17-1** Deploying the rules contract via Europa on the CyberMiles public
    blockchain'
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: The BUIDL IDE can also compile and deploy Lity smart contracts with embedded
    rules. Try it!
  prefs: []
  type: TYPE_NORMAL
- en: Now you have seen a simple example of the Lity rules smart contract. In this
    example, the functionality can be easily implemented using regular `if-then` statements.
    In the next sections, let’s look into the rules language and more common rules
    use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Rules Language
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Modern BREs including Lity use the Rete algorithm to construct, evaluate, and
    then execute a network of interfering rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'All rules can be sequenced into a series of nesting `if-then` statements. However,
    when the rules are complex, the `if-then` structure could become complicated.
    Consider the following simple rules for airline rewards:'
  prefs: []
  type: TYPE_NORMAL
- en: The customer is given silver status when the number of award miles reaches 25,000
    miles.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The customer is given gold status when the number of award miles reaches 50,000
    miles.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Silver customers get a 10 percent bonus of award miles from any flight.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gold customers get a 20 percent bonus of award miles from any flight.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This example involves only two sets of simple inferencing rules, the customer
    status and the flight awards. Now, consider the rules to compute awards for all
    customers on a flight. Some customers might reach the silver or gold status on
    the flight. So, the `if-then` sequence will need to first compute award miles,
    then update the status, and then recompute the award miles for some customers
    again.
  prefs: []
  type: TYPE_NORMAL
- en: If the rules are more complex and include a few more inferencing rule sets,
    the `if-then` sequence could be exponentially more complex. Each rule set will
    need to be evaluated and executed again and again inside every combination of
    other rule sets. The deeply nested sequence cannot be built by hand and is impossible
    to test and validate. Furthermore, if the rules are changed by business requirements,
    the entire sequence of evaluation, revaluation, and execution would need to be
    rebuilt.
  prefs: []
  type: TYPE_NORMAL
- en: Rete Algorithm
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Rete algorithm, invented by Dr. Charles Forgy, solves this problem elegantly.
    Without going into details of the algorithm, it allows us to declare individual
    rules as nodes in a network (known as the Rete network) and connect the nodes
    via inference relationships between rules. Once a Rete network is defined, the
    algorithm automatically applies to a collection of objects in working memory (i.e.,
    the customer and flight objects in the airline example). The Rete algorithm efficiently
    evaluates and re-evaluates the objects by traversing the network nodes and then
    executes the rules.
  prefs: []
  type: TYPE_NORMAL
- en: For developers and business analysts, we can simply declare the rules and place
    objects into the working memory. We no longer need to build the highly nested
    `if-then` sequence and can now rely on computers to execute the Rete algorithm
    on the rules and objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Lity rules engine implements the Rete algorithm. The overall syntax of
    the Lity rules is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch17_images.xhtml#pro17_4)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Next, let’s look into the structure of the rules.
  prefs: []
  type: TYPE_NORMAL
- en: Rule Attribute
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A rule can have the following attributes.
  prefs: []
  type: TYPE_NORMAL
- en: The `salience` attribute indicates the activation priority of a rule. A contract
    can have multiple rules, and they are ordered by `salience`. The higher `salience`
    rules are evaluated and executed first. It defaults to integer value 0\. In the
    following example, the second rule is evaluated first.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch17_images.xhtml#pro17_5)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: When true, the `no_loop` attribute forbids a rule to activate itself with the
    same set of facts. This is for the purpose of preventing an infinite loop. It
    defaults to `false`. In the following example, the rule is fired only once for
    every `Person` in working memory.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch17_images.xhtml#pro17_6)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: When true, the `lock_on_active` attribute forbids a rule to be activated more
    than once with the same set of facts. This is stronger than `no_loop` because
    it also prevents the reactivation of the rule even if it is caused by another
    rule’s actions.
  prefs: []
  type: TYPE_NORMAL
- en: Rule Filters
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The filter statements specify how to match the facts (struts and objects) against
    the rule. It is a series of statements joined by `AND`, meaning that all of them
    must be satisfied for a combination of objects to be matched and filtered.
  prefs: []
  type: TYPE_NORMAL
- en: Each statement specifies an object type and filter criteria for its attributes.
    It starts with pattern binding, which specifies the fact identifier referred to
    in this rule scope. After binding, the pattern type specifies the type of the
    fact object. Then, a set of constraints describes conditions of this fact. The
    constraints must be `boolean` expressions.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch17_images.xhtml#pro17_7)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The previous pattern describes a fact `p` with the `Person` type; its constraints
    are that the `age` must be greater or equal to `65` and that `eligible` must be
    `true`.
  prefs: []
  type: TYPE_NORMAL
- en: Rule Actions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The action statements specify the functions to be called on the filtered facts.
    For example, the following code in the action block calls `transfer()` and then
    updates the person’s eligibility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch17_images.xhtml#pro17_8)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `update` keyword in the actions block is a special keyword for the rules
    language. The update object statement informs the rule engine that this object
    may be modified and the rules may need to be reevaluated.
  prefs: []
  type: TYPE_NORMAL
- en: Rule Inheritance
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Rules can be inherited. Sometimes constraints of a rule are based on constraints
    of another rule. In this case, this rule can extend another rule.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, a department store wants to give elder customers a 10 percent
    discount and their cars free parking. The discount rule is described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch17_images.xhtml#pro17_9)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The free parking rule can extend the constraint of elder customers (older than
    60). Then this rule can be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch17_images.xhtml#pro17_10)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The inheritance allows developers and analysts to build on complex libraries
    of rules based on past work.
  prefs: []
  type: TYPE_NORMAL
- en: Working Memory
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As we have seen in the example, the `factInsert` and `factDelete` statements
    are used to manage facts in the working memory for rules to filter and act on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `factInsert` operator takes an object with a storage data location and
    evaluates to a fact handle, which has type `uint256`. Insert the reference to
    the storage object into working memory. An example is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch17_images.xhtml#pro17_11)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Note that `factInsert fact(0)`; cannot be compiled. The reason is that `fact(0)`
    is a reference with memory data location, which is not persistent and thus cannot
    be inserted into working memory.
  prefs: []
  type: TYPE_NORMAL
- en: The `factDelete` operator takes a fact handle (a `uint256`) and evaluates to
    `void`. It removes the reference of the fact from working memory.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, `fireAllRules` is a special statement that launches the Lity rule engine
    execution.
  prefs: []
  type: TYPE_NORMAL
- en: More Business Examples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are many applications for rules in smart contracts. You have already seen
    a simple example of an airline points program. In general, public blockchains
    are great platforms for such points programs since they provide transparency in
    the supply, issuance, and use of such points, and they could allow the points
    from different merchants to be exchanged and traded. In this section, I will go
    over a few more simplified examples to give you some ideas of real-world application
    use cases for rules.
  prefs: []
  type: TYPE_NORMAL
- en: Insurance Claim
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Consider a travel insurance company that provides a claim for flight delays
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If the flight is delayed for more than four hours, everyone receives at least
    $100.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the flight is delayed for more than six hours, everyone receives up to $300
    in accountable expenses.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first rule (four hours or more) is represented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch17_images.xhtml#pro17_12)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: For the second rule (six hours or more), $100 in compensation is implied in
    the first rule, so we need to consider only the limited expense here.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch17_images.xhtml#pro17_13)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The rules engine can be useful in evaluation insurance claims as the payouts
    are all the rules written into the insurance contracts.
  prefs: []
  type: TYPE_NORMAL
- en: Taxes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This example illustrates how to calculate taxes using a rule engine. In most
    countries, tax rates are divided into brackets. That is, certain income ranges
    are taxed at corresponding rates. Often, more income indicates higher tax rates.
    For example, in the 2018 U.S. federal tax system, single filers pay the following
    rates based on their income:'
  prefs: []
  type: TYPE_NORMAL
- en: '*$0 to $9,525*: 10 percent'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*$9,526 to $38,700*: 12 percent'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*$38,701 to $82,500*: 22 percent'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*$82,501 to $157,500*: 24 percent'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*$157,501 to $200,000*: 32 percent'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*$200,001 to $500,000*: 35 percent'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*$500,001 or more*: 37 percent'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The rates are marginal rates, meaning that the tax payer pays that rate only
    on the amount of her income that falls into the specified range. For example,
    if you have $10,000 in taxable income, the first $9,525 is subject to the 10 percent
    rate, and the remaining $475 is subject to the tax rate of the next bracket, which
    is 12 percent. Now, let’s look at the rules. For the first tax bracket, the net
    income from $0 to $9,525 is taxed at 10 percent.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch17_images.xhtml#pro17_14)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, the net income from $9,526 to $38,700 is taxed at 12 percent in the
    second tax bracket. Note that $9,525 of income has already been taxed in the first
    tax bracket, so $9,525 should be subtracted from the amount taxed here.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch17_images.xhtml#pro17_15)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'In the same way, the rest of the brackets are represented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch17_images.xhtml#pro17_16)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Of course, the tax code has many other rules to adjust a person’s taxable income,
    categorize income into additional rate brackets (e.g., all capital gains are taxed
    at 10 percent), and refund some taxes when certain rules are met. The tax code
    is a compelling use case for rules engine!
  prefs: []
  type: TYPE_NORMAL
- en: Product Combos
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Finally, let’s look at an example of commerce applications. It’s common practice
    for online and offline stores to offer discounts when a customer orders multiple
    products at the same time. Consider restaurants, for example; a hamburger costs
    $11 and a drink costs $3, and these sum up to $14\. This summation rule could
    be simply represented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch17_images.xhtml#pro17_17)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'However, many restaurants offer a meal combo discount. For example, a drink
    with a hamburger is discounted by $2\. With a rules engine, this discount rule
    can be automatically applied as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch17_images.xhtml#pro17_18)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '`nCombo` is the number of combos in a bill, and the `combo` value of a burger/drink
    denotes the combo number (`-1` denotes no combo) that the burger/drink belongs
    to. Each burger or drink belongs to at most one combo to prevent duplicate discounts.'
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Blockchain smart contracts are a natural fit for formal rules. Smart contracts
    are just sets of rules executed by computers without human intervention when certain
    conditions are met. Conversely, the blockchain guarantees the correct execution
    of the rules.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I discussed the Lity rules language and engine. It enables
    formal business rules to be constructed and executed in blockchain smart contracts.
    Note that many examples in this chapter originally appeared in the Lity documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 18. Building an Application-Specific EVM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the key features of Lity is the libENI facility. It allows developers
    to add native C/C++ functions to the Lity virtual machine. While Solidity and
    Lity are both Turing complete languages, they are inefficient. And that translates
    to slow performance and high gas costs for many common computer operations on
    the blockchain, such as string manipulation and encryption/decryption. The libENI
    native functions allow developers to support those operations in blockchain smart
    contracts in a highly efficient manner. The importance of libENI is twofold.
  prefs: []
  type: TYPE_NORMAL
- en: If you are building your own blockchain, you can customize it for specific application
    use cases by bundling a selected library of libENI functions. For example, if
    you are building a blockchain specifically for the exchange of privacy data, you
    could bundle libENI functions commonly used for data encryption. Commercial providers,
    such as the Second State, provide tools for you to create custom libENI bundles
    for your own blockchains.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are developing smart contracts on a Lity-enabled public blockchain, such
    as the CyberMiles public blockchain, you could add new system-wide functions via
    libENI. On the CyberMiles blockchain, the libENI modules and functions can be
    developed by anyone and added to the blockchain virtual machine via the consensus
    of the validators. It is the most democratic way to extend the blockchain virtual
    machine.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: The Ethereum road map also calls for native and precompiled contracts. These
    contracts are developed by Ethereum core developers and deployed with Ethereum
    software updates. The libENI extensions for public blockchains, on the other hand,
    can be developed by anyone and need to be approved only by the underlying blockchain’s
    consensus.
  prefs: []
  type: TYPE_NORMAL
- en: For example, on the CyberMiles blockchain, anyone can propose to add a libENI
    function to the blockchain through a governance TX. The CyberMiles validators
    or super nodes vote on the governance TX to approve or reject it. That enables
    dynamic and democratic extension to the virtual machine outside of the software
    development cycle and outside of the “core” developer community. The community-developed
    libENI functions can be added to virtual machines without stopping, forking, or
    restarting the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I will explain how to use, develop, and deploy libENI functions.
    We will use CyberMiles as an example to demonstrate how libENI on-chain governance
    works. The Lity team is adding to libENI implementations on a regular basis. It
    is developing complete sets of string libraries, encryption libraries, JSON libraries,
    and other common utilities as highly efficient and optional libENI functions to
    the Lity virtual machine.
  prefs: []
  type: TYPE_NORMAL
- en: Using libENI Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The CyberMiles blockchain software comes with a few simple libENI functions
    already pre-installed. They allow us to experiment with libENI functions in our
    smart contracts immediately. But first, you will need to install the `lityc` compiler
    to build smart contracts written in the Lity programming language.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can choose to build the `lityc` compiler from source or directly download
    a binary build for one of its supported OS platforms. The binary distribution
    page is on GitHub at [https://github.com/CyberMiles/lity/releases](https://github.com/CyberMiles/lity/releases).
    But if you are inclined to build your own, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch18_images.xhtml#pro18_1)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Now that you have `lityc` installed, we will go through a couple of examples
    to see how libENI functions are used in smart contracts.
  prefs: []
  type: TYPE_NORMAL
- en: The String Reversing Example
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This example shows a rather trivial libENI function that reverses any string
    it receives. The following is an example contract. As you can see, it is similar
    to a regular Solidity contract. However, the keyword `eni` is not available in
    Solidity, and it will not compile using a regular Solidity compiler.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch18_images.xhtml#pro18_2)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The keyword `eni` is followed by two parameters. `reverse` is the name of the
    libENI function. Each libENI function added to the virtual machine must have a
    unique name. The string parameter `input` is the parameter passed into the `reverse`
    libENI function. You can pass any number of parameters into your libENI functions.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s save the code in a file named `Reverse.lity`. You must use the `lityc`
    compiler to compile the source to generate the bytecode and application binary
    interface (ABI) definition.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch18_images.xhtml#pro18_3)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: On the travis client’s web3-cmt console (similar to the GETH console on Ethereum),
    you can now deploy the contract bytecode and ABI to the CyberMiles node you run.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch18_images.xhtml#pro18_4)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Once the contract is deployed with a confirmation from the blockchain, you will
    see its contract address printed on the console. You can call its `reverse` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch18_images.xhtml#pro18_5)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Since most libENI functions require the blockchain nodes to perform work, they
    typically require gas fees. That is why we have a `from` account to pay gas fees
    for this libENI function call.
  prefs: []
  type: TYPE_NORMAL
- en: The RSA Example
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The RSA example shows how to use a pair of RSA public and private keys to encrypt
    and decrypt data inside a smart contract. Such functions enable blockchain accounts
    to exchange private information via smart contracts. They are crucial building
    blocks for a wide range of applications including data marketplaces and content
    distribution.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: An interesting RSA application is a data marketplace. Let’s use a marketplace
    for medical records to illustrate how an RSA re-encryption scheme works in this
    context. Patients own their own medical records, and they authorize Bob (the data
    broker or the hospital) to aggregate and sell the medical records on their behalf.
    Alice (the data user or researcher) buys the patients’ data from Bob. And Bob
    distributes the profit back to the patients. How do we automate and record the
    whole process on-chain?
  prefs: []
  type: TYPE_NORMAL
- en: Bob sets up three RSA keys (a public encryption key 1, a public re-encryption
    key 2, and a private decryption key 3) and sets up a smart contract for the transaction.
    The smart contract contains both public keys 1 and 2.
  prefs: []
  type: TYPE_NORMAL
- en: An individual patient authorizes Bob to sell her records by encrypting the records
    using key 1 and uploading the encrypted data to the contract. Alice agrees to
    buy the data from Bob and makes a payment to the smart contract. The smart contract
    re-encrypts all the records using key 2 and makes them publically available. Bob
    then sends private key 3 directly to Alice off-chain, which allows Alice to decrypt
    all the records held in the contract. Alice acknowledges receiving the private
    key 3 to the contract, and the contract automatically distributes the payments
    to patients and Bob.
  prefs: []
  type: TYPE_NORMAL
- en: In this process, Alice and Bob are the only ones who can decrypt the whole data
    set. All patients know their own data. The public can verify the transaction,
    including all the monetary payments, but cannot see any data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code illustrates a simple contract that encrypts a plaintext
    string using an RSA public key and then decrypts it using an RSA private key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch18_images.xhtml#pro18_6)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: In this example, you can see that the libENI functions `rsa_encrypt` and `rsa_decrypt`
    take multiple input parameters. In this section, I will show you how to use `lityc`
    to generate the bytecode and ABI interface in one go.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch18_images.xhtml#pro18_7)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Next, deploy the bytecode and ABI to a local or testnet CyberMiles blockchain
    and receive a contract address upon successful deployment.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch18_images.xhtml#pro18_8)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: To use the RSA functions, you call the smart contract methods and pass in the
    key and data.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch18_images.xhtml#pro18_9)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Of course, in the real world, we cannot call smart contract methods using the
    private key since all such transactions are public records. This example is for
    illustration only.
  prefs: []
  type: TYPE_NORMAL
- en: The Scrypt Example
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This scrypt example is to verify Dogecoin blockchain headers in a Lity smart
    contract. Why would anyone do this? The reason is that Dogecoin is a clone of
    the Bitcoin blockchain. Verifying a Dogecoin block header allows the smart contract
    to further verify the transactions inside that block. By extending this computation
    to the Bitcoin, we can develop Ethereum smart contracts that can automatically
    verify and respond to Bitcoin transactions, making cross-chain asset exchanges
    a possibility.
  prefs: []
  type: TYPE_NORMAL
- en: Yet, the verification of a Dogecoin header requires the smart contract to perform
    a scrypt operation, which is computationally expensive for Solidity and the EVM.
    Vitalik Buterin estimates that it requires 390 million units of Ethereum gas to
    perform and far exceeds the block gas limit of Ethereum. To address this problem,
    there is a bounty of $250,000 set up by the Ethereum and Dogecoin communities
    to award the first viable solution to perform a scrypt operation on Ethereum to
    verify a Dogecoin block. In this section, we will show that libENI provides such
    a solution at a low cost on a fully Ethereum-compatible blockchain virtual machine.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: BTCRely is a community service to verify Bitcoin transactions on Ethereum. It
    is set up as an Ethereum smart contract, which allows other contracts to request
    verification and pay a fee. The fee is used to incentivize a community of off-chain
    workers to perform the verification on their own computers and submit the results.
    The Truebit project has a similar approach for off-chain verification. However,
    in the end, those off-chain schemes are cryptoeconomic games that rely on incentives
    for “good behavior.” They are expensive, slow, tedious, and not reliable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The full source code of the scrypt example is available on the Lity documentation
    site at [http://lity.readthedocs.io/en/latest/verify-dogecoin-block-on-travis.html](http://lity.readthedocs.io/en/latest/verify-dogecoin-block-on-travis.html).
    Here, you can see the key part of the smart contract that calls the libENI function
    `scrypt` to perform the work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch18_images.xhtml#pro18_10)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Again, we use `lityc` to generate the bytecode and ABI interface in one go.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch18_images.xhtml#pro18_11)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: We can now deploy the bytecode and ABI to the blockchain and receive a contract
    address upon successful deployment.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch18_images.xhtml#pro18_12)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: To call the contract and verify a Dogecoin block header, we need the following
    pieces of information. They are algorithmically linked together to form a valid
    blockchain header. All of them are public information readily available from the
    Dogecoin blockchain explorer. In the following example, we use block 2 from the
    Dogecoin blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Version: `1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Previous block hash: `82bc68038f6034c0596b6e313729793a887fded6e92a31fbdf70863f89d9bea2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Transaction Merkle root hash: `3b14b76d22a3f2859d73316002bc1b9bfc7f37e2c3393be9b722b62bbd786983`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Timestamp: `1386474933` (converted from `2013-12-07 19:55:33 -0800`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Difficulty (bits): `1e0ffff0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Nonce: `3404207872`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can now call the `verifyBlock` method on the contract using the previous
    data.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch18_images.xhtml#pro18_13)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: While it is beyond the scope of this book, the native `scrypt` function lays
    the foundation for decentralized cross-chain operations with the Bitcoin blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a libENI Function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now we have seen how to use the libENI functions. In this section, I will discuss
    how to program your own libENI functions that can be dynamically deployed to the
    CyberMiles blockchain as virtual machine extensions. Let’s use the simple `reverse`
    libENI function as an example. The entire example is available in CyberMiles’
    libENI public GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'The libENI functions are written in C++ as OS native library functions. You
    need to use `#include <eni.h>`, create a subclass of `eni::EniBase`, and implement
    the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: A constructor that takes a string as its parameter. Remember to pass the string
    to the constructor of the superclass, `eni::EniBase`, which will convert the raw
    string into a `json::Array` containing the arguments for your ENI operation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A destructor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `parse` virtual function to parse the arguments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `gas` virtual function to calculate gas consumption from the arguments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `run` virtual function to execute your ENI operation with the arguments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The skeleton code for the `reverse` function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch18_images.xhtml#pro18_14)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Next, let’s look into the implementation of these three virtual functions.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing Arguments
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The parse function takes a `json::Array` containing the arguments given to your
    libENI operation. To ensure the other two functions, `gas` and `run`, process
    the arguments in the same way, please validate, preprocess, and store the arguments
    into member variables in the `parse` function.
  prefs: []
  type: TYPE_NORMAL
- en: The `parse` function should return `true` when all arguments are good and return
    `false` otherwise (e.g., lacking arguments, or the wrong type).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, the `json::Array` constructed by `eni::EniBase` contains only
    the argument string for the libENI operation `reverse`. The following is the implementation
    of `parse`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch18_images.xhtml#pro18_15)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Estimating Gas
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before your libENI function can run, you need to estimate how much gas it will
    cost. Override the virtual function `gas` and return your estimated gas cost.
    In this example, we use the string length as its gas consumption.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch18_images.xhtml#pro18_16)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: You can return `0` for gas calculation errors. The virtual machine will not
    execute the libENI function if `gas` returns `0`.
  prefs: []
  type: TYPE_NORMAL
- en: Executing the Function
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Override the virtual function `run` and push the result of your libENI function
    back into the `json::Array` as the return value.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch18_images.xhtml#pro18_17)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Mapping to libENI Function Name
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Finally, we need to map the reverse C++ class to the reverse libENI function
    name. To do that, we export a C interface with `ENI_C_INTERFACE(OP, CLASS)`, where
    `OP` is your libENI function name (i.e., `reverse` in this example), and `CLASS`
    is the name of implemented class (i.e., `Reverse` in this example).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: That’s it. You have written a C++ program for the libENI function. In the next
    section, we will review how to build the function into a shared library file and
    deploy the file to a running blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying the libENI Function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We use the GCC to build libENI classes into binary library files. You can look
    into the `Makefile` in the `examples/eni/reverse` directory in libENI public GitHub
    repository. Here are the key compiler settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch18_images.xhtml#pro18_18)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '`${LIBENI_PATH}` is the path to locate libENI support libraries on your development
    machine. See the details in the GitHub documentation. Once you run `make all`,
    you should have the `reverse.so` library file built for your OS.'
  prefs: []
  type: TYPE_NORMAL
- en: CyberMiles Governance
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To deploy the `reverse` libENI function to a running CyberMiles blockchain,
    we will use the CyberMiles governance transactions. First, you need to set up
    a CyberMiles blockchain node and then connect to it using the travis client (see
    [Appendix A](app.xhtml#app) for details).
  prefs: []
  type: TYPE_NORMAL
- en: 'From the travis client console, you have access to the web3-cmt JavaScript
    module. You can now create a new transaction to propose a new libENI function.
    The transaction includes a brief description of the library function and the location
    to download the library binary files for people to try. It also includes the MD5
    hash of those files. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch18_images.xhtml#pro18_19)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Once the `proposeDeployLibEni` transaction is processed, all nodes on the CyberMiles
    blockchain will download and cache the library files and start a seven-day voting
    period. The voting period can be customized by the `expireBlockHeight` or `expireTimestamp`
    parameter in the `proposeDeployLibEni` transaction. During the voting period,
    all validator nodes can vote on the proposal. `proposalId` is the result value
    from the `proposeDeployLibEni` transaction.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch18_images.xhtml#pro18_20)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: If at least two-thirds voting power voted yes for `proposalId`, all nodes will
    deploy the new libENI function and make it available at the seven-day mark or
    at the specified `expireBlockHeight` or `expireTimestamp`.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we discussed how to create and deploy new libENI functions
    to extend the Etheruem Virtual Machine (EVM). It allows developers or even the
    public chain community to dynamically extend the virtual machines with new functionalities
    without stopping or forking the blockchain.
  prefs: []
  type: TYPE_NORMAL
