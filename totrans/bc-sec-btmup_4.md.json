["```\nfunction batchTransfer(address[] _receivers, uint256 _value) \n public whenNotPaused returns (bool){\n uint cnt = _receivers.length;\n uint256 amount = uint256(cnt) * _value;\n require(cnt > 0 && cnt <= 20);\n require(_value > 0 && balances[msg.sender] >= amount);\n\n balances[msg.sender] = balances[msg.sender].sub(amount);\n for (uint i =0; i < cnt; i++) {\n balances[_receivers[i]] = balances[_receivers[i]].add(_value);\n Transfer(msg.sender,_receivers[i],_value);\n }\n return true\n}\n\n```", "```\nfunction withdraw(uint _amount) {\n require(balances[msg.sender] - _amount >= 0);\n msg.sender.transfer(_amount);\n balances[msg.sender] -= _amount;\n}\n\n```", "```\nfunction calcLiquidityShare(uint units, address token, \n address pool, address member) {\n uint amount = iBEP20(token).balanceOf(pool);\n uint totalSupply = iBEP20(pool).totalSupply();\n return(amount.div(totalSupply)).mul(units);\n}\n\n```", "```\ncontract GuessTheNumber {\n uint _secretNumber;\n address payable _owner;\n event success(string);\n event wrongNumber(string);\n\n constructor(uint secretNumber) payable public {\n require(secretNumber <= 10);\n _secretNumber = secretNumber;\n _owner = msg.sender; \n }\n\n function getValue() view public returns (uint) {\n return address(this).balance;\n }\n\n function guess(uint n) payable public {\n require(msg.value == 1 ether);\n\n uint p = address(this).balance;\n checkAndTransferPrize(/*The prize*/p , n/*guessed number*/\n /*The user who should benefit */,msg.sender);\n }\n\n function checkAndTransferPrize(uint p, uint n, address payable guesser) \n internal returns(bool) {\n if(n == _secretNumber) {\n guesser.transfer(p);\n emit success(\"You guessed the correct number!\");\n }\n else {\n emit wrongNumber(\"You've made an incorrect guess!\");\n }\n }\n\n function kill() public {\n require(msg.sender == _owner);\n selfdestruct(_owner);\n }\n}\n\n```", "```\ncheckAndTransferPrize(/*The prize*/p , n/*guessed number*/\n /*The user who should benefit */,msg.sender);\n\n```", "```\nevent Transfer(address _from, address indexed _to, uint256 _value);\nfunction sendCoin(address to, uint amount) returns (bool sufficient) {\n if(balances[msg.sender] < amount) return false;\n balances[msg.sender] -= amount;\n balances[to] += amount;\n Transfer(msg.sender, to, amount);\n return true;\n}\n\n```", "```\nfunction initContract() public {\n owner = msg.sender;\n}\n\n```", "```\nfunction initContract() public {\n require(firstCall);\n owner = msg.sender;\n firstCall = false;\n}\n\n```", "```\nfunction privateFunction(_data) private {\n // Perform privileged actions\n}\nfunction forwarder(address callee, bytes _data) public {\n callee.delegatecall(_data);\n}\n\n```", "```\nfunction play() public payable {\n require(msg.value >= 1 ether);\n if (block.blockhash(blockNumber) % 2 == 0) {\n msg.sender.transfer(this.balance);\n }\n}\n\n```", "```\nfunction play() public {\n require(now > 1521763200 && neverPlayed == true);\n neverPlayed = false;\n msg.sender.transfer(1500 ether);\n}\n\n```", "```\nfunction selectNextWinners(uint256 _largestWinner) {\n for(uint256 i = 0; i < largestWinner, i++) {\n // heavy code\n }\n largestWinner = _largestWinner;\n}\n\n```", "```\ncontract Auction {\n address currentLeader;\n uint highestBid;\n\n function bid() payable {\n require(msg.value > highestBid);\n\n // Refund the old leader, if it fails then revert \n require(currentLeader.send(highestBid)); \n\n currentLeader = msg.sender;\n highestBid = msg.value;\n }\n}\n\n```", "```\ncontract Vulnerable {\n function () payable {\n revert();\n }\n\n function somethingBad() {\n require(this.balance > 0);\n // Do something bad\n }\n}\n\n```", "```\ncontract Fixed {\n function () payable {\n if (isAcceptableTransaction()) {\n balance = balance + msg.value;\n } else {\n revert();\n }\n }\n\n function somethingBad() {\n require(balance > 0);\n // Do something bad\n }\n}\n\n```", "```\nfunction safeTransferFrom(address token, address from, \n address to, uint value) internal {\n (bool success, bytes memory data) = \n token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n require(success && (data.length == 0 || abi.decode(data, (bool)), \n \"!safeTransferFrom\");\n}\n\n```", "```\nfunction withdraw(uint _amount) {\n require(balances[msg.sender] >= _amount);\n msg.sender.call.value(_amount)();\n balances[msg.sender] -= _amount;\n}\n\n```", "```\nrequire(IERC20(inputToken).transfer(msg.sender,_amountIn),errorMessage);\n\n```", "```\nfunction withdraw(uint256 _amount) public {\n require(balances[msg.sender] >= _amount);\n balances[msg.sender] -= _amount;\n etherLeft -= _amount;\n msg.sender.send(_amount);\n}\n\n```", "```\ncontract Proxy {\n\n address owner;\n\n constructor() public {\n owner = msg.sender; \n }\n\n function forward(address callee, bytes _data) public {\n require(callee.delegatecall(_data));\n }\n}\n\n```", "```\nvoid test::transfer(name from, name to, asset quantity, string memo)\n{\n if (from == _self)\n {\n // we're sending money, do nothing additional\n return;\n }\n\n eosio_assert(to == _self,\"contract is not involved in this transfer\");\n eosio_assert(quantity.symbol.is_valid(),\"invalid quantity\");\n eosio_assert(quantity.amount > 0,\"only positive quantity allowed\");\n eosio_assert(quantity.symbol == EOS_SYMBOL,\"only EOS tokens allowed\");\n}\n\n```", "```\nvoid transfer(uint64_t sender, uint64_t receiver) {\n\n auto transfer_data = unpack_action_data<st_transfer>();\n\n if (transfer_data.from == _self || \n transfer_data.from == N(eosbetcasino)){\n return;\n }\n\n eosio_assert( transfer_data.quantity.is_valid(), \"Invalid asset\");\n}\n\n```", "```\n[[eosio::on_notify(\"*::transfer\")]]\nvoid tester::on_transfer(const name from, const name to, \n const asset quantity, const string memo )\n{\n log_action log( get_self(), { get_self(), \"active\"_n });\n log.send( \"hello from \" + get_self().to_string() );\n}\n\n```", "```\nfunction mint(address to, uint256 amount) public virtual {\n mint(to, amount);\n}\n\n```", "```\nfunction mint(uint256 amount) public onlyOwner returns (bool) {\n _mint(_msgSender(), amount);\n return true;\n}\n\n```", "```\nfunction calcLiquidityShare(uint units, address token, \n address pool, address member) {\n `uint amount = iBEP20(token).balanceOf(pool);`\n `uint totalSupply = iBEP20(pool).totalSupply();`\n `return(amount.mul(units)).div(totalSupply);`\n`}` \n```", "```\nfunction reserveApes() public onlyOwner { \n uint supply = totalSupply();\n uint i;\n for (i = 0; i < 30; i++) {\n _safeMint(msg.sender, supply + i);\n }\n}\n\n```"]