- en: © The Author(s), under exclusive license to Springer Nature Switzerland AG 2022Y.
    Maleh et al. (eds.)Advances in Blockchain Technology for Cyber Physical SystemsInternet
    of ThingsTechnology, Communications and Computing[https://doi.org/10.1007/978-3-030-93646-4_5](https://doi.org/10.1007/978-3-030-93646-4_5)
  prefs: []
  type: TYPE_NORMAL
- en: Privacy-Preserving *k*-Means Clustering over Blockchain-Based Encrypted IoMT
    Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Rakib Ul Haque^([1](#Aff7), [2](#Aff8) [ ](#ContactOfAuthor1)), A. S. M. Touhidul Hasan^([3](#Aff9),
    [4](#Aff10) [ ](#ContactOfAuthor2)), Tasnia Nishat^([5](#Aff11) [ ](#ContactOfAuthor3))
    and Md Akhtaruzzaman Adnan^([6](#Aff12) [ ](#ContactOfAuthor4))(1)School of Computer
    Science & Technology, University of Chinese Academy of Sciences, Beijing, China(2)Institute
    of Automation Research and Engineering, Dhaka, Bangladesh(3)Department of Computer
    Science and Engineering, University of Asia Pacific, Dhaka, Bangladesh(4)Institute
    of Automation Research and Engineering, Dhaka, Bangladesh(5)Daraz Bangladesh Ltd,
    Dhaka, Bangladesh(6)Department of Computer Science and Engineering, University
    of Asia Pacific, Dhaka, BangladeshRakib Ul HaqueEmail: [rakibulhaqueraj@mails.ucas.ac.cn](mailto:rakibulhaqueraj@mails.ucas.ac.cn)A. S. M. Touhidul Hasan (Corresponding
    author)Email: [touhid@uap-bd.edu](mailto:touhid@uap-bd.edu)Tasnia NishatEmail:
    [nishat.tasnia@daraz.com.bd](mailto:nishat.tasnia@daraz.com.bd)Md Akhtaruzzaman AdnanEmail:
    [adnan.cse@uap-bd.edu](mailto:adnan.cse@uap-bd.edu)KeywordsPrivacyAuthenticityBlockchainIoMTHomomorphic
    cryptosystem'
  prefs: []
  type: TYPE_NORMAL
- en: 1 Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the modern healthcare sector, a rapidly emerging technology is the Internet
    of Medical Things (IoMT) [[1](#CR1)], which is based on enormous volumes of data
    being continuously collected from health monitoring devices. Software applications
    and medical devices are combined for providing health services and building health
    care systems [[2](#CR2)]. For which it is possible to create a wave of stand-alone
    devices for remote patient monitoring [[3](#CR3)]. The union of the Internet-connected
    health devices with patient information and sensor-based tools such as wearables
    have eventually established the ecosystem of IoMT [[4](#CR4)]. IoMT can generate,
    store, investigate, or transfer medical data or images to healthcare service provider’s
    networks and retain data to either an internal database or cloud repository [[5](#CR5)].
    This connection within healthcare devices and sensors is the streamline of medical
    workflow administration and directing to the overall improvement in medical care.
    IoMT devices are demonstrating higher accuracy in diagnosis, ensuring fewer errors
    but are cheaper in terms of costs. Nowadays, diversified Machine Learning (ML)
    [[6](#CR6), [7](#CR7)] algorithms are used to train these vast amounts of data
    to build the prediction model.
  prefs: []
  type: TYPE_NORMAL
- en: The dataset required for training various ML models generally comes from entities
    like health care service providers or hospitals. For ML model classifiers to produce
    predictive results with higher accuracy, it is essential to have data sample distinctiveness
    along with data amounts [[8](#CR8)]. This is effectively achieved by using a process
    of unifying different sample sets gathered from various entities. But many entities
    often disapprove to provide their datasets for training as there are many privacy
    concerns. The most common issues are regarding ownership, data integrity, and
    data privacy [[9](#CR9)]. During training phases, medical data from IoMT devices
    are handled by other associates or can be manipulated causing loss of privacy
    of sensitive and private data. Unauthorized data modification by altering or tampering
    done by dormant invaders during data sharing can lower the data integrity, resulting
    in a faulty classification of the ML model. The ownership authority of data providers
    may be lost during replicating or reusing the shared datasets by many associates.
  prefs: []
  type: TYPE_NORMAL
- en: Data privacy issues are handled in the past by using cryptographic and differential
    privacy (DP) [[10](#CR10)]. While cryptographic methodologies are heavy and time-consuming,
    DP does not ensure data utility. In order to make sure data utility this work
    focuses on cryptographic methods [[11](#CR11)]. Recent works on cryptography ML
    methods are expensive in terms of space and time-consuming. Among ML methods *k*-mean
    is one of the most simple and lightweight unsupervised algorithms, but past work
    on *k*-mean does make sure all privacy concerns. Those methods lack data authenticity.
  prefs: []
  type: TYPE_NORMAL
- en: In order to solve these issues, this study proposes secure *k*-means. A partially
    Homomorphic known as Paillier is applied with Blockchain technology. IoMT data
    of each data owner is encrypted using Paillier and then recorded on a distributed
    ledger. The secure building blocks are developed in order to handle the classification
    tasks with encrypted data, i.e., Secure Polynomial Operation (SPO) (addition/subtraction),
    and Secure Comparison (SC). No trusted third party is needed. The secure *k*-means
    can employ *k*-means classifiers with the loss of insignificant accuracy and faster
    than other cryptographic methods.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the paper is articulated as follows. Sections [2](#Sec2) and [3](#Sec3)
    describe related work and preliminaries, respectively. System overview and Model
    constructions are outlined in Sects. [4](#Sec7) and [5](#Sec12). Section [6](#Sec16)
    represents experiment and result evaluation. Finally, this paper is concluded
    in Sect. [7](#Sec21).
  prefs: []
  type: TYPE_NORMAL
- en: 2 Related Work
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Numerous research focused on privacy issues with various methods, i.e., cryptographic
    [[12](#CR12)], differential privacy [[13](#CR13)], and data publishing in privacy-preserving
    manner [[14](#CR14)–[17](#CR17)], where cryptographic and differential privacy
    is time-consuming and provides less data utility. On the contrary, ML training
    is not considered in privacy-preserving data publishing. In addition, these methods
    cannot keep data owner and data analyst information at the time of data sharing.
    Recent solutions to protect the data owner’s privacy when training ML techniques
    are secure support vector machine (SVM) [[18](#CR18)], secure *k*-nearest neighbor
    (*k*-nn) [[19](#CR19), [20](#CR20)], and secure linear regression (LR) [[21](#CR21)].
    All these methods consolidate Blockchain to keep the information related to any
    transaction of the data owner and the data analyst into ML training with encrypted
    IoMT data. These methods achieve the most proximal correctness to standard SVM,
    *k*-nn, and LR. However, secure SVM, secure *k*-nn, and secure LR need several
    comparisons and calculations that result in higher space and time complexity for
    analyzing the health data.
  prefs: []
  type: TYPE_NORMAL
- en: Previous research on secure *k*-means mainly focused on any specific domain
    [[22](#CR22)], some do not consider Blockchain [[23](#CR23)] and only a few sets
    of research utilizing Blockchain [[24](#CR24)–[28](#CR28)]. None of them are versatile
    as they are based on a specific setup and address all the privacy concerns related
    to data integrity, authenticity, and privacy. In this study, a Cryptosystem, which
    is partially Homomorphic (Paillier) is applied along with Blockchain technology
    to address the above concerns when employing *k*-means classifiers with IoMT data
    of the owners. Paillier is employed in order to encrypt IoMT data of various data
    owners. An immutable distributed ledger is used to record all transactions. Secure
    *k*-means can be employed by the data analysts after associating with the individual
    data owner in order to obtain encrypted data. No participant can infer the original
    data of other participants from the Blockchain as only the hash of the transaction
    is saved in the ledger. SPO and SC are employed as the secure protocol for polynomial
    calculation of encrypted data in *k*-means. These are also noted as a secure building
    block, where a trusted third party is not necessary. The proposed method achieves
    higher efficiency with minimal loss of accuracy.
  prefs: []
  type: TYPE_NORMAL
- en: 3 Preliminaries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, all background technologies and mathematical equations are
    presented. Dataset *D* has *m* records, where *x* [*i*] and *y* [*i*] are the
    *i*th attributes and after classification they get label *l* [*i*]. The distance
    *d* represents the interval between two points and the *k*-means’ model parameters
    are ![
  prefs: []
  type: TYPE_NORMAL
- en: $$\sum _{i=1}^{k}$$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/513458_1_En_5_Chapter/513458_1_En_5_Chapter_TeX_IEq1.png) !['
  prefs: []
  type: TYPE_NORMAL
- en: $$(c_{x_{i}}, c_{y_{i}})$$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/513458_1_En_5_Chapter/513458_1_En_5_Chapter_TeX_IEq2.png). The
    symbols *P* stands for data owner, and *A* stands for data analyst, respectively.
    The encrypted messages under Paillier are represented as [[*m*]].'
  prefs: []
  type: TYPE_NORMAL
- en: Homomorphic Cryptosystem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Three methods combinedly develop Cryptosystems: key generation (*KeyGen*),
    encryption of data (*Enc*), decryption of data (*Dec*). (*PK*;*SK*) are pair of
    keys known as (public key; private key) used in public-key cryptosystems. These
    key pairs are used for encryption and decryption. A cryptosystem can be Homomorphic
    if and only if its feature can map the calculation over ciphertext to the respective
    plaintext without knowing the decryption key. In the proposed model, polynomial
    operations (secure mathematical addition and subtraction) are operated based on
    Paillier. *p*, *q*, and *N* are *n*-bit prime numbers, where, *N*  =  *p* *q*.
    The public and private keys are denoted by *N* and (*N*, *ϕ*(*N*)).^([1](#Fn1))
    The encryption function of Paillier is *c* := [[(1 + *N*)^(*m*) *r* ^(*N*) *mod*
    *N* ²]], and decryption function is *m* ∈ *Z* [*N*] and !['
  prefs: []
  type: TYPE_NORMAL
- en: $$m:=[[\frac {[c^{\phi (N)}\;mod\; N^{2}-1]}{N}\; \times \; \phi (N)^{-1} \;
    mod \; N]]$$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/513458_1_En_5_Chapter/513458_1_En_5_Chapter_TeX_IEq6.png). Paillier
    is elaborately discussed in [[11](#CR11)].'
  prefs: []
  type: TYPE_NORMAL
- en: Blockchain
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Blockchain is a continuously expanding list of transactions, known as blocks
    connected and protected utilizing cryptography [[29](#CR29)]. In order to avoid
    the single point of failure, a Peer-to-Peer (P2P) architecture is adopted in Blockchain.
    The consensus mechanism ensures robust unambiguous control of blocks and transactions.
    It also assures the consistency and integrity across distributed nodes of the
    Blockchain, i.e., Auditability, Integrity, and Decentralization.
  prefs: []
  type: TYPE_NORMAL
- en: Public Blockchain (Bitcoin and Ethereum).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consortium Blockchain (Hyperledger, Ripple).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Private Blockchain. Blockchain labors as the stage to be hosted and executed
    on for smart contracts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*k*-Means Algorithm'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*k*-Means [[30](#CR30)] is an unsupervised ML algorithm mainly utilized for
    the classification task. In order to identify centroids !['
  prefs: []
  type: TYPE_NORMAL
- en: $$(c_{x_{j}},c_{y{{ }_j}})$$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/513458_1_En_5_Chapter/513458_1_En_5_Chapter_TeX_IEq7.png) calculation
    of distance *d* is necessary. Popular methods to identify distances are *Euclidean*
    *d* [*e*] (Eq. ([1](#Equ1))), *Manhattan* *d* [*m*] (Eq. ([2](#Equ2))), etc. In
    this study, we will use *Manhattan* *d* [*m*]. Let, (*x* [1], *y* [1]), (*x* [2],
    *y* [2]), …, (*x* [*n*], *y* [*n*])  ∈ *D*.!['
  prefs: []
  type: TYPE_NORMAL
- en: $$\displaystyle \begin{aligned} d_{e} = \sqrt{(c_{x_{j}}-x_{i})^{2}+(c_{y_{j}}-y_{i})^{2}}
    \end{aligned} $$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/513458_1_En_5_Chapter/513458_1_En_5_Chapter_TeX_Equ1.png)(1)!['
  prefs: []
  type: TYPE_NORMAL
- en: $$\displaystyle \begin{aligned} d_{m} = |(c_{x_{j}}-x_{i})|+|(c_{y_{j}}-y_{i})|
    \end{aligned} $$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/513458_1_En_5_Chapter/513458_1_En_5_Chapter_TeX_Equ2.png)(2)'
  prefs: []
  type: TYPE_NORMAL
- en: 4 System Overview
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section discusses models related to the system, threat, and security definitions.
  prefs: []
  type: TYPE_NORMAL
- en: System Model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The objective of the proposed model is to make sure privacy and guarantee protected
    data sharing between *A* and *P*. *A* gets encrypted IoMT data from each *P*.
    All the shared data are recorded in a distributed ledger of Blockchain by forming
    transactions in order to keep authenticity. *A* assembles its Ml model (*k*-means)
    by acquiring recorded data from the public ledger of Blockchain. *A* erects a
    protected method utilizing protected building blocks (SC and SPO). At the time
    of employing the secure ML model, it is important to have moderate interaction
    between *A* and *P* in order to share intermediate results. When sharing the intermediate
    data for comparison, a tiny amount of bias *δ* is added by *P*. It reduces the
    possibility of model inversion attacks. It also diminishes the algorithm’s space
    and time complexity, and the performance of the model is not affected. Its goal
    is to make sure the privacy of the data owner at the time of SC. The entire process
    is illustrated in Fig. [1](#Fig1).![](../images/513458_1_En_5_Chapter/513458_1_En_5_Fig1_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 1
  prefs: []
  type: TYPE_NORMAL
- en: Data driven IoMT ecosystem
  prefs: []
  type: TYPE_NORMAL
- en: '**IoMT Devices:** These are accountable for collecting and transferring important
    IoMT data by the wireless medium.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data Owners P:** It gathers every part of data from the IoMT devices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data Analyst A:** It wants its ML model to be trained on the dataset of various
    P.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The considered scenario has *n* number of *P* :=  *P* [*i*] (*i* ∈ (1, …, *n*))
    with dataset *D* [*i*] consisting of sensitive information and an untrusted data
    analyst *A*. Horizontal data sharing [[31](#CR31)] method is utilized for *n*
    datasets ![
  prefs: []
  type: TYPE_NORMAL
- en: $$[D_{i}]_{i=1}^{n}$$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/513458_1_En_5_Chapter/513458_1_En_5_Chapter_TeX_IEq8.png) with
    alike feature space but distinct in sample sets. *A* collects *n* encrypted data
    sequentially and *k*-means model is applied on the dataset *D*  :=  (*D* [1] *U*….*U*
    *D* [*n*]), where, !['
  prefs: []
  type: TYPE_NORMAL
- en: $$|D| = \sum _{i=1}^{n} |D_{i}|$$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/513458_1_En_5_Chapter/513458_1_En_5_Chapter_TeX_IEq9.png). *A*
    can obtain its model after the execution of the secure protocol *π*.'
  prefs: []
  type: TYPE_NORMAL
- en: Security GoalsThe protocols *π* meets the points discussed subsequently.
  prefs: []
  type: TYPE_NORMAL
- en: '*A* will not be able to infer any sensitive information of *P* from *D*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*P* failed to learn *A*’s private information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*P* failed in acquiring the private information of another *P*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Threat Model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'All the participants are acknowledged as adversaries, who are honest but curious
    (semi-honest) and they do not trust each other. *A* is fair in obeying protocol
    *π* and also interested in the raw data of other participants. *A* also tries
    to infer further information of *P* from the shared intermediate data. On the
    other hand, *P* might infer in *A*’s private information. Following threats are
    considered:'
  prefs: []
  type: TYPE_NORMAL
- en: Encrypted information registered in the blockchain is hardly accessible to *A*
    but can record the intermediate results (iteration steps) at the time of data
    sharing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*A* is considered to be aware of the details, which can be extracted from the
    public encryption model. *A* is expected to plot with diverse *P* to acquire another
    *P*’s private information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encrypted Data Sharing via Blockchain
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'All alike instances of data are allocated to the corresponding feature vectors,
    and all of them are pre-processed locally. Input and output are the two domains,
    which are developed for transaction formation. The input field consists of:'
  prefs: []
  type: TYPE_NORMAL
- en: Sender’s address
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encrypted data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Name of IoMT device (Source)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The output field (corresponding) consists of:'
  prefs: []
  type: TYPE_NORMAL
- en: Receiver’s address
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encrypted data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Name of IoMT device (Source)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This study employs the proposed model in the Hyperledger Fabric platform. It
    is known as a permissioned blockchain platform. Sender and receiver’s addresses
    are hash values. Paillier determines the encrypted data. Only the hash of the
    transactions is recorded in the Blockchain. The length of them and private key
    are 128 bytes. The segment length is 4 bytes for the type of IoMT device. The
    sender node assembles the transaction and broadcasts it in the Peer to Peer (P2P)
    [[32](#CR32)] system of the Blockchain network. The operation’s correctness is
    validated by miner nodes. The transaction is packaged into a block by a specific
    miner node. Each block may record various transactions. Common protocols for consensus
    mechanisms are used such as Proof of Work (PoW) or Byzantine Fault Tolerance [[33](#CR33),
    [34](#CR34)].
  prefs: []
  type: TYPE_NORMAL
- en: Security Definitions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Secure Two-party Computation [[12](#CR12), [35](#CR35), [36](#CR36)] and Modular
    Sequential Composition [[37](#CR37)] are employed in order to assemble the secure
    building blocks for deploying the protocols of privacy-preserving ML in a modular
    design.
  prefs: []
  type: TYPE_NORMAL
- en: Secure Two-Party Computation
  prefs: []
  type: TYPE_NORMAL
- en: To guarantee the security for two-party protocols, it is important to confirm
    that *X* (*Y* ) can be calculated from its interactions with *Y*  (*X*), which
    is also calculated from the input and output. Ultimately, it points toward secure
    two-party computation [[12](#CR12), [35](#CR35), [36](#CR36)]. Let a probabilistic
    polynomial function be *G* =  (*f* [*X*], *f* [*Y*]) and *G* be computed by protocol
    *π*. *X*’s and *Y* ’s inputs are *x* and *y* and *X* and *Y*  compute *G*(*x*,
    *y*). *X*’s view at the time of executing *π* is the tuple ![
  prefs: []
  type: TYPE_NORMAL
- en: $$view^{\pi }_{X}$$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/513458_1_En_5_Chapter/513458_1_En_5_Chapter_TeX_IEq10.png) (*x*,
    *y*) =  (*x*, *c*, *a* [1], *b* [2], …, *a* [*b*]) where *a* [1], *a* [2], …,
    *a* [*b*] are the messages received from *Y* . *X*’s random tape is *c*. The view
    of *Y*  is defined similarly.'
  prefs: []
  type: TYPE_NORMAL
- en: Modular Sequential Composition
  prefs: []
  type: TYPE_NORMAL
- en: Modular Sequential Composition [[37](#CR37)] is employed for confirming the
    protection proofs of protocols.
  prefs: []
  type: TYPE_NORMAL
- en: Definition 1 (Modular Sequential Composition [[37](#CR37)])
  prefs: []
  type: TYPE_NORMAL
- en: Let *g* [1], …, *g* [*b*] be two-party probabilistic polynomial-time functionalities
    , which is securely calculated by *ρ* [1], …, *ρ* [*b*] in semi-honest adversaries’
    presence. Let *G* be a probabilistic polynomial-time functionality and *π* a protocol
    that securely computes *G* with *g* [1], …, *g* [*b*] in the presence of semi-honest
    adversaries. Then *G* is securely computed by ![
  prefs: []
  type: TYPE_NORMAL
- en: $$\pi ^{\rho _{1}, \ldots , \rho _{b}}$$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/513458_1_En_5_Chapter/513458_1_En_5_Chapter_TeX_IEq11.png) in semi-honest
    adversaries’ presence.'
  prefs: []
  type: TYPE_NORMAL
- en: 5 Model Construction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The construction details of the proposed system are presented in this section.
    The aim is to secure the privacy of distinct *P* and *A* at the time of *k*-means
    classification.
  prefs: []
  type: TYPE_NORMAL
- en: Secure Polynomial Operations (SPO)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Secure addition and subtraction are developed to develop the secure *k*-means
    based on Paillier. It can ensure reliability at the time of addition and subtraction
    on encrypted data. Additional homomorphic property of Paillier is: [[*ma* [1] + *ma*
    [2]]]  =  [[*ma* [1]]]  × [[*ma* [2]]] *mod* *n* ² and subtraction is : [[*ma*
    [1] − *ma* [2]]]  =  [[*ma* [1]]] × [[*ma* [2]]]^(−1) *mod* *n* ².^([2](#Fn2))
    Secure addition and subtraction are statistically indistinguishable as Paillier
    is alike [[11](#CR11)].'
  prefs: []
  type: TYPE_NORMAL
- en: Secure Comparison (SC)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It aims at a privacy-preserving comparison of encrypted numbers. Protocol *π*
    based upon which *A* and *B* participant in SC to compare [[*m* [1]]] and [[*m*
    [2]]]. None of the participants can know original *m* [1] and *m* [2]. SC is illustrated
    in Algorithm 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'Algorithm 1: Secure comparison![](../images/513458_1_En_5_Chapter/513458_1_En_5_Figaaa_HTML.png)Proposition
    1 (Sanctuary of SC)'
  prefs: []
  type: TYPE_NORMAL
- en: '*Algorithm* 1 *is protected in a semi-honest scenario.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Proof of Proposition** [**1**](#FPar3)'
  prefs: []
  type: TYPE_NORMAL
- en: Two entities (*P* and *A*) are involved in Algorithm 1.
  prefs: []
  type: TYPE_NORMAL
- en: The view of *P* is:![
  prefs: []
  type: TYPE_NORMAL
- en: $$\displaystyle \begin{aligned} view_{P}^{\pi} = ([[m_{1}^{\prime}]]_{A},\;[[m_{2}^{\prime}]]_{A},\;PK_{A})
    \end{aligned}$$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/513458_1_En_5_Chapter/513458_1_En_5_Chapter_TeX_Equa.png)Consequently,
    the simulator *S*:!['
  prefs: []
  type: TYPE_NORMAL
- en: $$\displaystyle \begin{aligned} S_{P}^{\pi} ((m_{1},m_{2});\;F(m_{1},m_{2}))=
    view_{P}^{\pi} ([[m_{1}^{\prime}]]_{A},\;[[m_{2}^{\prime}]]_{A},\; [[\delta]]_{A}
    ,\;PK_{A}) \end{aligned}$$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/513458_1_En_5_Chapter/513458_1_En_5_Chapter_TeX_Equb.png)Security
    of [[*m* [1]]][*A*] and [[*m* [2]]][*A*] is same as Paillier as !['
  prefs: []
  type: TYPE_NORMAL
- en: $$[[m_{1}^{\prime }]]_{A}$$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/513458_1_En_5_Chapter/513458_1_En_5_Chapter_TeX_IEq12.png) and
    !['
  prefs: []
  type: TYPE_NORMAL
- en: $$[[m_{2}^{\prime }]]_{A}$$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/513458_1_En_5_Chapter/513458_1_En_5_Chapter_TeX_IEq13.png) are
    encrypted by *PK* [*A*] based on Paillier. Therefore, *P* will never be able to
    deduce the original (*m* [1], *m* [2])[*A*]. *A*’s view:!['
  prefs: []
  type: TYPE_NORMAL
- en: $$\displaystyle \begin{aligned} view_{A}^{\pi} = ([[m_{1}^{\prime}]]_{A},\;[[m_{2}^{\prime}]]_{A},\;PK_{A},SK_{A})
    \end{aligned}$$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/513458_1_En_5_Chapter/513458_1_En_5_Chapter_TeX_Equc.png)Then,
    !['
  prefs: []
  type: TYPE_NORMAL
- en: $$S_{A}^{\pi }$$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/513458_1_En_5_Chapter/513458_1_En_5_Chapter_TeX_IEq14.png) runs
    as follows:!['
  prefs: []
  type: TYPE_NORMAL
- en: $$\displaystyle \begin{aligned} F(m_{1}^{\prime}, m_{2}^{\prime})\;=\; view_{A}^{\pi}\;
    (m_{1}^{\prime},\;m_{2}^{\prime},\;PK_{A},\;SK_{A}) \end{aligned}$$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/513458_1_En_5_Chapter/513458_1_En_5_Chapter_TeX_Equd.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Any attempt of *A* to infer original *m* [1] and *m* [2] from ![
  prefs: []
  type: TYPE_NORMAL
- en: $$m_{1}^{\prime }$$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/513458_1_En_5_Chapter/513458_1_En_5_Chapter_TeX_IEq15.png) and
    !['
  prefs: []
  type: TYPE_NORMAL
- en: $$m_{2}^{\prime }$$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/513458_1_En_5_Chapter/513458_1_En_5_Chapter_TeX_IEq16.png) will
    fail as *A* is not knowledgeable of *δ*. *A* returns 0 or 1 depending on the case
    !['
  prefs: []
  type: TYPE_NORMAL
- en: $$m_{1}^{\prime }$$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/513458_1_En_5_Chapter/513458_1_En_5_Chapter_TeX_IEq17.png) ≥ !['
  prefs: []
  type: TYPE_NORMAL
- en: $$m_{2}^{\prime }$$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/513458_1_En_5_Chapter/513458_1_En_5_Chapter_TeX_IEq18.png) or !['
  prefs: []
  type: TYPE_NORMAL
- en: $$m_{1}^{\prime }$$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/513458_1_En_5_Chapter/513458_1_En_5_Chapter_TeX_IEq19.png) <  !['
  prefs: []
  type: TYPE_NORMAL
- en: $$m_{2}^{\prime }$$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/513458_1_En_5_Chapter/513458_1_En_5_Chapter_TeX_IEq20.png) as *A*
    is trustworthy in following protocols. □'
  prefs: []
  type: TYPE_NORMAL
- en: Training Algorithm of Secure *k*-Means
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Protocols are employed for secure *k*-means classification, where all participants’
    parameters are protected. This study assumes one *A* and *n* amount of *P*. Secure
    *k*-means’ protocol *protocol* [*π*] is specified in Algorithm 2\. In Algorithm
    2, all participants (*A* and *P*) parameters are secret. At the time of facing
    any semi-honest collusions, no participant will lose data privacy from intermediate
    results of the algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'Algorithm 2: Proposed *protocol* [*π*]![](../images/513458_1_En_5_Chapter/513458_1_En_5_Figaab_HTML.png)Proposition
    2 (*Protocol* [*π*]’s Security)'
  prefs: []
  type: TYPE_NORMAL
- en: '*protocol* [*π*] *in Algorithm* 2 *is secured in the semi-honest scenario.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Proof of Proposition** [**2**](#FPar5)In *protocol* [*π*] two entities *P*
    and *A* are involved. Each *P* follows the same protocol, so security satisfaction
    for one *P* is enough to cover all *P*. Individual *P*’s view is:!['
  prefs: []
  type: TYPE_NORMAL
- en: $$\displaystyle \begin{aligned} view_{P}^{protocol_{\pi}} = ([[D_{cen}]]_{PK_{A}},\;PK_{A},\;D_{P})
    \end{aligned}$$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/513458_1_En_5_Chapter/513458_1_En_5_Chapter_TeX_Eque.png)where,
    !['
  prefs: []
  type: TYPE_NORMAL
- en: $$[[D_{cen}]]_{PK_{A}}$$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/513458_1_En_5_Chapter/513458_1_En_5_Chapter_TeX_IEq21.png) are
    encrypted by *PK* [*A*], the confidentiality of !['
  prefs: []
  type: TYPE_NORMAL
- en: $$[[D_{cen}]]_{PK_{A}}$$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/513458_1_En_5_Chapter/513458_1_En_5_Chapter_TeX_IEq22.png) is alike
    to Paillier. Therefore *P* cannot learn !['
  prefs: []
  type: TYPE_NORMAL
- en: $$(D_{cen})_{PK_{A}}$$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/513458_1_En_5_Chapter/513458_1_En_5_Chapter_TeX_IEq23.png).*A*’s
    view:!['
  prefs: []
  type: TYPE_NORMAL
- en: $$\displaystyle \begin{aligned} view_{A}^{protocol_{\pi}}\;= \;([[data_{i=1}^{n}]]_{PK_{A}},\;[[length_{i=1}^{n}]]_{PK_{A}},\;d_{m}^{\prime},\;D_{cen},\;PK_{A},\;SK_{A})
    \end{aligned}$$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/513458_1_En_5_Chapter/513458_1_En_5_Chapter_TeX_Equf.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Now, the confidentiality of ![
  prefs: []
  type: TYPE_NORMAL
- en: $$[[data_{i=1}^{n}]]_{PK_{A}}$$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/513458_1_En_5_Chapter/513458_1_En_5_Chapter_TeX_IEq24.png) and
    !['
  prefs: []
  type: TYPE_NORMAL
- en: $$[[length_{i=1}^{n}]]_{PK_{A}}$$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/513458_1_En_5_Chapter/513458_1_En_5_Chapter_TeX_IEq25.png) needs
    to be analyzed. Whether *P*’s private *D* [*P*] can be inferred from shared data
    by *A*. Clearly, !['
  prefs: []
  type: TYPE_NORMAL
- en: $$[[data_{i=1}^{n}]]_{PK_{A}}$$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/513458_1_En_5_Chapter/513458_1_En_5_Chapter_TeX_IEq26.png) and
    !['
  prefs: []
  type: TYPE_NORMAL
- en: $$[[length_{i=1}^{n}]]_{PK_{A}}$$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/513458_1_En_5_Chapter/513458_1_En_5_Chapter_TeX_IEq27.png) are
    not the resulted values from secret *D* [*P*]. *A* might aim to compute *D* [*P*]
    utilizing the distance !['
  prefs: []
  type: TYPE_NORMAL
- en: $$d_{m}^{\prime }$$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/513458_1_En_5_Chapter/513458_1_En_5_Chapter_TeX_IEq28.png) and
    centroids *D* [*cen*] at the time SC. *D* [*P*] is added with bias *δ* by *P*
    and *δ*’s exact value is unknown to *A*. Therefore, *A* will not be able to infer
    *D* [*P*]. At the time of division, *A* has the summation of each centroid from
    !['
  prefs: []
  type: TYPE_NORMAL
- en: $$[[data_{i=1}^{n}]]_{PK_{A}}$$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/513458_1_En_5_Chapter/513458_1_En_5_Chapter_TeX_IEq29.png). *A*
    also gets the exact number of points !['
  prefs: []
  type: TYPE_NORMAL
- en: $$[[length_{i=1}^{n}]]_{PK_{A}}$$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/513458_1_En_5_Chapter/513458_1_En_5_Chapter_TeX_IEq30.png), which
    are added together. Still, A will fail to guess the exact *D* [*P*] of *P*. Without
    brute force cracking, a genuine value of *D* [*P*] cannot be perceived by anyone,
    which is not the realistic possibility to achieve[[11](#CR11)]. So, in a scenario
    of semi-honest adversaries *protocol* [*π*] is secured. □'
  prefs: []
  type: TYPE_NORMAL
- en: 6 Experiment and Result Evaluation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Dataset and performance analysis are showed in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Dataset
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Three medical datasets are used namely Diabetes dataset (DD), Breast cancer
    Wisconsin data (BCWD), and Heart disease data (HDD) [[18](#CR18), [19](#CR19)].
    BCWD and DD have 9 numeric attributes. On the other hand, HDD has 13 Discrete
    attributes. 80% of the dataset is used for training and 20% of the dataset is
    used for testing. Table [1](#Tab1) summarizes the utilized datasets.Table 1
  prefs: []
  type: TYPE_NORMAL
- en: Statistics of datasets
  prefs: []
  type: TYPE_NORMAL
- en: '|   | Datasets |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Measures | BCWD | HDD | DD |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Instances | 699 | 303 | 768 |'
  prefs: []
  type: TYPE_TB
- en: '| Attributes | 9 | 13 | 9 |'
  prefs: []
  type: TYPE_TB
- en: Float Format Conversion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Cryptosystems can only operate on whole numbers. Therefore, the conversion of
    format is a must, and all numbers are converted into an integer. Based on the
    IEEE 754 global standard format (floating-point binary number) *D* is *D* = (−1)^(*s*) × *M* × 2^(*E*),
    where *s*, *M*, and *E* are sign bit, significant number, and exponential bit,
    respectively. This study considers a key size of 1024-bit for the Paillier cryptosystem.
  prefs: []
  type: TYPE_NORMAL
- en: Evaluation Parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are three most popular metrics, i.e., accuracy ([3](#Equ3)), precision
    ([4](#Equ4)), and recall ([5](#Equ5)).![
  prefs: []
  type: TYPE_NORMAL
- en: $$\displaystyle \begin{aligned} accuracy=\frac{t_{p}+t_{n}}{t_{p}+t_{n}+f_{p}+f_{n}}
    \end{aligned} $$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/513458_1_En_5_Chapter/513458_1_En_5_Chapter_TeX_Equ3.png)(3)!['
  prefs: []
  type: TYPE_NORMAL
- en: $$\displaystyle \begin{aligned} precision=\frac{t_{p}}{t_{p}+f_{p}} \end{aligned}
    $$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/513458_1_En_5_Chapter/513458_1_En_5_Chapter_TeX_Equ4.png)(4)!['
  prefs: []
  type: TYPE_NORMAL
- en: $$\displaystyle \begin{aligned} recall=\frac{t_{p}}{t_{p}+f_{n}} \end{aligned}
    $$
  prefs: []
  type: TYPE_NORMAL
- en: '](../images/513458_1_En_5_Chapter/513458_1_En_5_Chapter_TeX_Equ5.png)(5)Here,
    the positive or relevant classes are represented as *t* [*p*]. These classes are
    precisely labeled. The negative or irrelevant classes that are labeled correctly
    are represented as *f* [*p*]. *f* [*n*] and *t* [*n*] represent the number of
    relevant but mislabeled and the number mislabeled but irrelevant, respectively,
    in the test result. Table [2](#Tab2) shows the outcomes.Table 2'
  prefs: []
  type: TYPE_NORMAL
- en: Summary of performance
  prefs: []
  type: TYPE_NORMAL
- en: '|   |   | Datasets |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Measure | Model | BCWD | HDD | DD |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Accuracy | SVM | 96.60% | 81.00% | 77.00% |'
  prefs: []
  type: TYPE_TB
- en: '|   | Secure SVM | 95.25% | 80.89% | 76.67% |'
  prefs: []
  type: TYPE_TB
- en: '|   | *k*-nn (*t* = 8) | 96.96% | 83.50% | 79.00% |'
  prefs: []
  type: TYPE_TB
- en: '|   | Secure *k*-nn (*t* = 8) | 97.80% | 82.33% | 78.00% |'
  prefs: []
  type: TYPE_TB
- en: '|   | *k*-Means (*k* = 2) | 95.23% | 82.54% | 78.55% |'
  prefs: []
  type: TYPE_TB
- en: '|   | Secure *k*-Means (*k* = 2) | 94.95% | 81.88% | 78.10% |'
  prefs: []
  type: TYPE_TB
- en: '| Precision | SVM | 96.16% | 81.79% | 75.00% |'
  prefs: []
  type: TYPE_TB
- en: '|   | Secure SVM | 96.02% | 81.25% | 74.80% |'
  prefs: []
  type: TYPE_TB
- en: '|   | *k*-nn (*t* = 8) | 96.54% | 83.85% | 77.00% |'
  prefs: []
  type: TYPE_TB
- en: '|   | Secure *k*-nn (*t* = 8) | 96.26% | 82.30% | 76.00% |'
  prefs: []
  type: TYPE_TB
- en: '|   | *k*-Means (*k* = 2) | 95.95% | 82.75% | 76.23% |'
  prefs: []
  type: TYPE_TB
- en: '|   | Secure *k*-Means (*k* = 2) | 95.01% | 81.58% | 75.85% |'
  prefs: []
  type: TYPE_TB
- en: '| Recall | SVM | 96.48% | 80.38% | 71.00% |'
  prefs: []
  type: TYPE_TB
- en: '|   | Secure SVM | 95.65% | 79.65% | 70.91% |'
  prefs: []
  type: TYPE_TB
- en: '|   | *k*-nn (*t* = 8) | 96.85% | 83.85% | 75.90% |'
  prefs: []
  type: TYPE_TB
- en: '|   | Secure *k*-nn (*t* = 8) | 96.67% | 82.66% | 75.10% |'
  prefs: []
  type: TYPE_TB
- en: '|   | *k*-Means (*k* = 2) | 96.01% | 82.91% | 74.69% |'
  prefs: []
  type: TYPE_TB
- en: '|   | Secure *k*-means (*k* = 2) | 95.87% | 81.76% | 74.25% |'
  prefs: []
  type: TYPE_TB
- en: Table [2](#Tab2) shows that secure *k*-nn achieve highest performance and followed
    by secure SVM and secure *k*-means, where *k*-nn with a threshold value *t* = 8
    and *k* = 2 cluster for *k*-means. Most importantly the difference of correctness
    among these ML models is in the range between 1% to 4%. The proposed secure *k*-means
    achieved 78.10%, 81.88%, and 94.95% of accuracy on DD, HDD, and BCWD datasets,
    where the state-of-the-art technique provides 77.00%, 81.00%, and 96.60%, respectively.
    Therefore, secure *k*-means performers are approximately alike compared to conventional
    *k*-means and slightly differ from state-of-the-art secure *k*-nn [[18](#CR18)].
  prefs: []
  type: TYPE_NORMAL
- en: Efficiency
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The scalability analysis of SPO is showed in Table [3](#Tab3). The proposed
    method consumes minimal time compared to other methods based on Table [3](#Tab3).
    Several *P*s’ are linearly simulated. SPO in *k*-means takes the 2500 s, 1000
    s, 1790 s on BCWD, HDD, DD datasets, respectively, which is better than other
    methods. Facing diverse datasets with numerical attributes, and discrete attributes,
    the proposed method shows enough efficiency scalability. The scalability performance
    comparison is summarized in Fig. [2](#Fig2) and the *x*-axis holds the datasets
    (BCWD, HDD, and DD), and the *y*-axis holds time (seconds). It is also clear that
    secure *k*-means is more realistic.![](../images/513458_1_En_5_Chapter/513458_1_En_5_Fig2_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 2
  prefs: []
  type: TYPE_NORMAL
- en: Comparison of time consumption
  prefs: []
  type: TYPE_NORMAL
- en: Table 3
  prefs: []
  type: TYPE_NORMAL
- en: Summary of time consumption
  prefs: []
  type: TYPE_NORMAL
- en: '|   |   | Methods |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|   |   | Secure | Secure | Secure |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Dataset | Time | SVM | *k*-nn | *k*-means |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| BCWD | Total | 3674 s | 3357 s | 2200 s |'
  prefs: []
  type: TYPE_TB
- en: '|   | P | 2789 s | 2534 s | 1500 s |'
  prefs: []
  type: TYPE_TB
- en: '|   | A | 1066 s | 860 s | 500 s |'
  prefs: []
  type: TYPE_TB
- en: '|   | SPO | 3462 s | 3113 s | 2500 s |'
  prefs: []
  type: TYPE_TB
- en: '| HDD | Total | 2735 s | 2534 s | 1500 s |'
  prefs: []
  type: TYPE_TB
- en: '|   | P | 1761 s | 1520 s | 700 s |'
  prefs: []
  type: TYPE_TB
- en: '|   | A | 924 s | 765 s | 300 s |'
  prefs: []
  type: TYPE_TB
- en: '|   | SPO | 2333 s | 1922 s | 1000 s |'
  prefs: []
  type: TYPE_TB
- en: '| DD | Total | 3959 s | 3709 s | 2605 s |'
  prefs: []
  type: TYPE_TB
- en: '|   | P | 3199 s | 2920 s | 1580 s |'
  prefs: []
  type: TYPE_TB
- en: '|   | A | 1045 s | 995 s | 507 s |'
  prefs: []
  type: TYPE_TB
- en: '|   | SPO | 3773 s | 3527 s | 1790 s |'
  prefs: []
  type: TYPE_TB
- en: The proposed secure *k*-means is efficient and practical than the state-of-the-art
    techniques. In our designed protocol, secure *k*-means need a single iteration
    consisting of two interactions to calculate the new clustering points, and no
    trusted third party is required since it employs Blockchain for secure data sharing.
    Therefore, the proposed method is more atomic in scalability than other methods
    and covers all the security and privacy features. Table [3](#Tab3) and Fig. [2](#Fig2)
    illustrate that secure *k*-means achieve the best possible computation time for
    all datasets. Some insignificant fluctuations exist between the proposed methods
    and other techniques in the case of correctness. However, Table [2](#Tab2) proves
    that secure *k*-means achieve almost similar performance like secure SVM and secure
    *k*-nn.
  prefs: []
  type: TYPE_NORMAL
- en: 7 Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This study introduces a secure protocol for training the *k*-means algorithm.
    It mainly focuses on data authenticity, data integrity, and data privacy issues
    of *P*. It employs Blockchain technology to record all intermediate data. A multi-party
    scheme is considered for training the algorithm, where involved entities are *n*
    number of *P* and a *A*. A reliable method is achieved by employing Paillier for
    cryptographic polynomial operations. The introduced approach encompasses approximately
    comparable correctness compared to the state of the arts but outperforms them
    in terms of time consumption. Generally, cryptographic methods are secured but
    take exponentially higher time than straightforward ML techniques. These methods
    only allow operations on integers, and there also exist some limitations in the
    case of division operations. Future work includes developing lightweight Cryptographic
    privacy-preserving ML algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Acknowledgements
  prefs: []
  type: TYPE_NORMAL
- en: The authors thank the school of computer science and technology of the University
    of Chinese Academy of Science, Beijing, China; Institute of Automation Research
    and Engineering, Dhaka 1205, Bangladesh; and the Department of Computer Science
    and Engineering of University of Asia Pacific, Dhaka, Bangladesh for their support
    toward this study.
  prefs: []
  type: TYPE_NORMAL
