- en: © The Author(s), under exclusive license to APress Media, LLC, part of Springer
    Nature 2022J. T. GeorgeIntroducing Blockchain Applications[https://doi.org/10.1007/978-1-4842-7480-4_5](https://doi.org/10.1007/978-1-4842-7480-4_5)
  prefs: []
  type: TYPE_NORMAL
- en: '5. Proof of Stake: Consensus of the Future'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Joseph Thachil George^([1](#Aff2)  )(1)Rome, Italy
  prefs: []
  type: TYPE_NORMAL
- en: The *Proof of Stake* algorithm replaces miners with validators and makes the
    mining process virtual. Ethereum developers have always wanted to switch to Proof
    of Stake, but it presents some problems that developers are still working to resolve.
  prefs: []
  type: TYPE_NORMAL
- en: The Proof of Stake algorithm is based on a different mining philosophy of blocks.
  prefs: []
  type: TYPE_NORMAL
- en: 'In general terms, the algorithm is based on these facts:'
  prefs: []
  type: TYPE_NORMAL
- en: Any user who wants to be a validator must register on the network as validators
    through a stake of coins. The stake value is then blocked and frozen.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This coin bet can never be less than a certain quantity. In fact the stake must
    be greater than the gain that they can derive from validating new blocks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to work correctly, the algorithm must punish dishonest validators by
    cutting their stake. This way, validators benefit more from behaving honestly
    than from attacking the blockchain.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At each time interval, a validator is chosen from the pool of validators for
    validating and providing another block to the blockchain. The choice of the validator
    is made at each time interval according to various criteria.
  prefs: []
  type: TYPE_NORMAL
- en: The odds bet by each validator affect the probability of being chosen. The greater
    the odds, the greater the likelihood of being chosen.
  prefs: []
  type: TYPE_NORMAL
- en: Each implementation of the Proof of Stake defines, as it sees fit, this choice.
    So it can vary from PoW to PoS.
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, there are two ways to make this type of selection:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Randomly chosen block** **:** The validator is picked through the pairs between
    the smallest hash value and the biggest stake value. However, since the stakes
    of each validator are public, this choice can be foreseen.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Coin age selection** **:** The validator is chosen based on how long their
    tokens have been held. Age is calculated based on the number of days the coins
    are held in the stake for the stake share. However, each time a validator adds
    a block, the age of the coin is reset to 0\. So it has to wait for a certain time
    interval to validate a new block.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This allows decentralization.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This prevents large stake nodes from dominating validation and therefore the
    blockchain.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This obviously does not prevent new selection methods. On the contrary, everyone,
    through the choices of the project, can implement their selection.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, each blockchain that uses PoS implements its own methods and its own
    techniques as it deems most appropriate. The chosen node will therefore validate
    the new block, sign it, and add it to the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: As a reward, the node receives transaction fees.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a node wants to stop validating blocks, and therefore withdraw its stake,
    it can do so. However, it will have to wait a certain amount of time to allow
    the network to verify that it has behaved honestly. This algorithm allows you
    to reach:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Safety** **:** The stake acts as a financial incentive to validate only blocks
    and therefore valid transactions. It then rejects invalid ones. It also incentivizes
    validators to work on the canonical chain. In case of dishonest behavior, the
    penalty is that the episode is cut.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Energy efficiency** **:** No need for expensive and specialized hardware
    to carry out the complex calculations required, for example, by the PoW.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Incentive** **:** More and more users will be incentivized into managing
    validations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Decentralization** **:** Thanks to the pseudo-randomness with which the validators
    are chosen, it avoids centralizing the validation to a restricted circle of organizations,
    as happens with the PoW.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stability of the price of the coin****:** Due to the fact that it no longer
    needs to release new coins as a reward to miners.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For this reason, as long as the stake is higher than the prize, the validator,
    in the case of dishonest behavior, will lose more coins than they can earn.
  prefs: []
  type: TYPE_NORMAL
- en: 'To effectively control the network and validate fraudulent transactions, a
    validator should hold 51% of the total stake amount in the network. However, if
    this is not mathematically impossible, it is practically unlikely. In fact, for
    this to happen, a validator must have control of the network, holding at least
    51% of the current offer. There are two types of shareholder proof algorithms:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Proof of stake on a chain**  **:** The algorithm pseudo-randomly picks a
    validator during every time band (each ten-second period could represent a time
    slot) and assigns to that validator the ability to generate a single block. This
    block must refer to some prior block (usually the block at the conclusion of the
    preceding longest chain, in most cases). As a result, as time goes, the majority
    of the blocks converge into a single chain that continues to grow.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Proof of stake in the** **style of BFT** **(Byzantine Fault Tolerance**  **):**
    Validators are given the right to propose blocks at random, but a multi-round
    method determines which block is canonical. On that basis each validator submits
    a vote for some particular block at every round, and at end of the process all
    validators (honest and online) agree if the given block is linked with the chain.
    Note that the blocks can still be connected to the chain; the difference is that
    an approval on a block can occur within a block, and it is not dependent on the
    length or size of the chain afterward.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.1 Chain-Based Proof of Stake
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section discusses a Proof of Stake algorithm combined with Proof of Work.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first PoS technique proposed by developers of Bitcoin as an alternate block
    generation method to PoW was chain-based PoS. It is, in fact, a combined mechanism
    between PoS and PoW. It is within the context of the Nakamoto agreement within
    which the following principles are maintained:'
  prefs: []
  type: TYPE_NORMAL
- en: A communication in the style of gossip
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The rule of block validation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The most extensive chain rule
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The logical goal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first complete chain blockchain POS systems have been implemented and adopted
    by Nxt and Peercoin. The procedure of a chain-based POS can be stated by the algorithm
    that follows. PoS, unlike PoW, does not rely on useless hashes to create blocks.
    A miner can only find the solution once for a tick of the clock.
  prefs: []
  type: TYPE_NORMAL
- en: Since the complexity of the hashing puzzle reduces with the amount of the miner’s
    bet, the estimated number of hashing attempts for a miner to solve the puzzle
    can be greatly reduced, even if their stake level is greater.
  prefs: []
  type: TYPE_NORMAL
- en: So, the PoS component avoids the use of force hashing concurrency, which would
    have occurred if PoW was used, resulting in a large energy savings.
  prefs: []
  type: TYPE_NORMAL
- en: We first propose the BlockGen() method  and then the consensus algorithm. (See
    Figure [5-1](#Fig1).)![../images/520777_1_En_5_Chapter/520777_1_En_5_Fig1_HTML.jpg](../images/520777_1_En_5_Chapter/520777_1_En_5_Fig1_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5-1
  prefs: []
  type: TYPE_NORMAL
- en: BlockGen() and the chained-based proof of stake general procedure
  prefs: []
  type: TYPE_NORMAL
- en: 5.1.1 Committee-Based PoS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Chain-based PoS still depends on the hashing puzzle to create the blocks. As
    an alternative technique, committee-based PoS  follows a more orderly procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: Establishes a stakeholder committee based on the mail at stake.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allows the committee to create blocks in turn.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A safe multi-party computation (MPC) technique is frequently used to derive
    such a board in the global network. MPC is a kind of distributed computing where
    different parts starting with diverse inputs produce the same outcome.
  prefs: []
  type: TYPE_NORMAL
- en: The MPC process in committee-based PoS effectively achieves the functionality
    that takes the values from the present state of the blockchain targeted by all
    shareholders and produces a pseudo-random series of shareholders (sequence of
    leaders) that will then occupy the proposing committee. (See Figure [5-2](#Fig2).)
  prefs: []
  type: TYPE_NORMAL
- en: This leader sequence is the same for all parties involved and those with greater
    levels of authority can occupy multiple stitches in the sequence.![../images/520777_1_En_5_Chapter/520777_1_En_5_Fig2_HTML.jpg](../images/520777_1_En_5_Chapter/520777_1_En_5_Fig2_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5-2
  prefs: []
  type: TYPE_NORMAL
- en: CommitteeElect() and the committee-based proof of stake general procedure
  prefs: []
  type: TYPE_NORMAL
- en: 5.1.2 The Nothing at Stake Theory
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are no penalties or incentives in many early chain-based proof of stake
    systems. (See Figure [5-3](#Fig3).)
  prefs: []
  type: TYPE_NORMAL
- en: 'This has the undesirable consequence that, if multiple chains compete, the
    validator’s incentive is to strive to make blocks on each chain. There are two
    basic reasons for this:'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike PoW, validators can validate transactions across multiple branches for
    free. Because PoW is not required to build a block, it is computationally cheap
    to be produced on each fork.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validators work on all forks because it is profitable for them to do so. If
    validators validate blocks mainly on two (or more) chains, they will collect trading
    fees on any branch that wins. This increases the probability of collection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The problem therefore is that if the validators point to every fork, the blockchain
    will become more susceptible to double spending attacks.![../images/520777_1_En_5_Chapter/520777_1_En_5_Fig3_HTML.jpg](../images/520777_1_En_5_Chapter/520777_1_En_5_Fig3_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5-3
  prefs: []
  type: TYPE_NORMAL
- en: Chain-based proof of stake systems
  prefs: []
  type: TYPE_NORMAL
- en: In PoW, there is no incentive to mine on numerous chains at the same time. It
    will not boost a miner’s chances of extracting a block if they split their hash
    power (computational power) between two chains.
  prefs: []
  type: TYPE_NORMAL
- en: This problem can be solved by two strategies—Slasher and Dunkle.
  prefs: []
  type: TYPE_NORMAL
- en: 5.1.2.1 Slasher
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This includes a punishment for validators that create blocks on numerous chains
    at the same time, as well as evidence of wrongdoing. The deposit of the wicked
    validator is cut in this situation. The incentive structure is altered as a result
    of this. (See Figure [5-4](#Fig4).)![../images/520777_1_En_5_Chapter/520777_1_En_5_Fig4_HTML.jpg](../images/520777_1_En_5_Chapter/520777_1_En_5_Fig4_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5-4
  prefs: []
  type: TYPE_NORMAL
- en: Slasher
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the validator selection for each block on both branches is identical
    for this technique to solve the problem, necessitating validator selection before
    the fork. There are certain disadvantages to this solution:'
  prefs: []
  type: TYPE_NORMAL
- en: Nodes must be online often to have a secure view of the blockchain.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Openness to the risks of collusion for medium-range validators (e.g., situations
    in which, for example, 25 of the 30 validators get together and agree ahead of
    time to launch a 51% attack on the preceding 19 blocks).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.1.2.2 Dunkle
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The second approach is to simply penalize validators who create blocks on the
    incorrect chain. Assume two opposing chains, A and B. A validator who constructs
    a block on A receives a reward of + R on A, but the block’s header can be included
    in B, and the validator receives a penalty of -F on B. In other words, even validators
    trying to forge a chain (minor) “incorrectly” may be penalized. (See Figure [5-5](#Fig5).)![../images/520777_1_En_5_Chapter/520777_1_En_5_Fig5_HTML.jpg](../images/520777_1_En_5_Chapter/520777_1_En_5_Fig5_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5-5
  prefs: []
  type: TYPE_NORMAL
- en: Dunkle
  prefs: []
  type: TYPE_NORMAL
- en: The insight here is that you can replicate the PoW economy within the PoS.
  prefs: []
  type: TYPE_NORMAL
- en: In PoW, there is a charge for making a mistake while creating a block on the
    chain, but this cost is hidden in the environment. Miners must spend more electricity
    and buy or rent additional hardware. Or alternatively, they must divide their
    computational resources, which is not convenient.
  prefs: []
  type: TYPE_NORMAL
- en: Here, the sanctions are simply stated. This technique has the downside of putting
    validators at greater risk.
  prefs: []
  type: TYPE_NORMAL
- en: For these reasons, Ethereum 2.0 is planning its own Proof of Stake, which takes
    the name of Casper, in the style of BFT (Byzantine Fault Tolerance).
  prefs: []
  type: TYPE_NORMAL
- en: 5.1.3 BFT-Based Proof of Stake
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because the rule of the longest chain is still employed to ensure the probabilistic
    finality of the blocks, chain-based PoS  and commission-based PoS substantially
    follow the Nakamoto consensus structure. In contrast, BFT-based PoS incorporates
    an additional layer of consent that gives a quick finalization that is deterministic
    of the blocks.
  prefs: []
  type: TYPE_NORMAL
- en: The blocking proposal can be made by any mechanism PoS (round-robin, committee-based,
    etc.) provided it injects a steady stream of fresh blocks into the BFT consensus
    layer.
  prefs: []
  type: TYPE_NORMAL
- en: Aside from the standard approach, a checkpoint mechanism can be employed to
    ensure that the blockchain’s goal is fulfilled. (See Figure [5-6](#Fig6).)
  prefs: []
  type: TYPE_NORMAL
- en: Consequently, the longest chain rule can be substituted in a safe way by the
    current and secure checkpoint rule to determine the canonical main chain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Where BlockGen():'
  prefs: []
  type: TYPE_NORMAL
- en: Elects a proposed block with a success rate proportionate to the stake value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Proposes, therefore, the block BlockFi BTC().
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Participates in the consensus BFT that finalizes a winning block.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The winning block returns.![../images/520777_1_En_5_Chapter/520777_1_En_5_Fig6_HTML.jpg](../images/520777_1_En_5_Chapter/520777_1_En_5_Fig6_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5-6
  prefs: []
  type: TYPE_NORMAL
- en: Byzantine fault tolerance-based PoS general procedure
  prefs: []
  type: TYPE_NORMAL
- en: 5.2 Ethereum Casper
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The FT approach (partially synchronous) allows validators  to vote on blocks
    using proof of stake techniques, which deliver one or more forms of signed messages.
    The goal is to reach consensus and to identify and punish any dishonest validators.
  prefs: []
  type: TYPE_NORMAL
- en: Like the BFT consensus algorithms, the assumption is that if 2/3 of the validators
    follow the protocol properly, then, regardless of network latency, the algorithm
    will not be able to resolve conflicting blocks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Vitalik Buterin states that one of Casper’s targets is to reach the economic
    purpose. We can define this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: B1 block is economically finalized, with margin $X crypto security, if a customer
    has proof that (i) B1 will be part of the canonical chain forever, or (ii) those
    actors who caused the restoration of B1 are guaranteed to be economically penalized
    by an amount of at least $X.
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, the economic crypto safety margin must be high enough. In fact, if
    we think of X = $70 million, we understand that that block it is part of the chain
    and it is very expensive to change it. The PoW does not have these guarantees.
    It is a specific feature of the PoS.
  prefs: []
  type: TYPE_NORMAL
- en: The intention is to make 51% attacks extremely expensive, so most validators
    working together fail to restore the locks finalized without suffering an extremely
    great economic loss. The economic purpose is achieved by asking those who want
    to participate in the validation process to file a bet.
  prefs: []
  type: TYPE_NORMAL
- en: If the protocol determines that a validator acted dishonestly, violating the
    rules of the protocol, then they are punished, and their bet is cut.
  prefs: []
  type: TYPE_NORMAL
- en: The set of rules of the protocol are called *slashing conditions* . The slashing
    conditions make it possible to determine, beyond any reasonable doubt, when a
    validator has acted inappropriately (for example, voting for numerous different
    blocks at the same time).
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, there is a guarantee for validators who follow the rules
    of the protocol not to violate any rule and not to incur any sanction.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are also the *finality conditions*, which describe when it is possible
    to consider a certain finalized hash. A hash is considered finalized when at least
    2/3 of the total balances, deposited by the current set of active validators,
    are committed the hash. Slashing conditions must satisfy two properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Accountable safety:** If two conflicting hashes are finalized, then it must
    be demonstrable that at least 1/3 of the validators violated certain cutting conditions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Plausible liveness:** A set of messages must exist so that 2/3 of the validators
    can transmit to complete some new hashes without breaching the slashing conditions
    unless at least 1/3 of the validators violated certain slashing conditions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Accountable safety is what brings this idea of economic purpose: if two conflicting
    hashes are finalized (i.e., a fork), then you have mathematical proof that a large
    set of validators must have violated some cut conditions and you can present evidence
    of this to the blockchain and penalize them.'
  prefs: []
  type: TYPE_NORMAL
- en: Plausible liveness basically means it “shouldn’t be.” It is possible that the
    algorithm remains blocked and is unable to finalize anything.
  prefs: []
  type: TYPE_NORMAL
- en: 5.3 Casper Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Blocktree, which is a tree data structure, is related to the blocks that have
    just been generated and received in Casper. The actual object of the consent is
    the *checkpoint tree* *,* which is a subtree of blocktree.
  prefs: []
  type: TYPE_NORMAL
- en: In particular, for each epoch of consent (every 100 in height of the blocktree
    or every 1 in height of the checkpoint tree), each validator transmits to its
    peers one vote for a block as a checkpoint.
  prefs: []
  type: TYPE_NORMAL
- en: A checkpoint is the genesis block and each block whose height in the blocktree
    is 100 or a multiple of 100\. However, the “checkpoint height” of a block whose
    height is 100 k is simply k. In blocktree, the block’s height has to be divisible
    by 100.
  prefs: []
  type: TYPE_NORMAL
- en: For a better understanding, see the checkpoint tree in Figure [5-7](#Fig7).![../images/520777_1_En_5_Chapter/520777_1_En_5_Fig7_HTML.jpg](../images/520777_1_En_5_Chapter/520777_1_En_5_Fig7_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5-7
  prefs: []
  type: TYPE_NORMAL
- en: 'Checkpoint tree: Dashed lines represent 100 blocks between checkpoints'
  prefs: []
  type: TYPE_NORMAL
- en: The height function is shown in Figure [5-8](#Fig8).![../images/520777_1_En_5_Chapter/520777_1_En_5_Fig8_HTML.jpg](../images/520777_1_En_5_Chapter/520777_1_En_5_Fig8_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5-8
  prefs: []
  type: TYPE_NORMAL
- en: Checkpoint tree with the height function
  prefs: []
  type: TYPE_NORMAL
- en: The grade consists of justified source checkpoint (CPs) and their height h (s).
    A destination gates CPT and their height h (t) and the signature of the validator
    S. It must be h (t)> h (s).
  prefs: []
  type: TYPE_NORMAL
- en: Therefore <s; CPs; CPt; h (s); h (t)> is the vote of the validator.
  prefs: []
  type: TYPE_NORMAL
- en: Every vote is sent to the network and is weighted based on the value of participation
    of the signatory (from their stake).
  prefs: []
  type: TYPE_NORMAL
- en: If the pair of source-target control points <CP[s]; CP[t]> is voted from validators
    who have more than 2/3 of the total bets deposited, then CP[t] is justified and
    CP[s] are completed. All blocks between CP[s] and CP[t] are also completed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Casper FFG depends on two so-called Casper commandments to ensure the security
    of consent:'
  prefs: []
  type: TYPE_NORMAL
- en: '1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There can’t be two votes for the same checkpoint height from the validator.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The validator does not need to cast a new vote because the scope of its existing
    vote includes the source-target.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Violators face harsh penalties, including forfeiture of stakes and a temporary
    betting prohibition. Casper FFG can easily detect and apply the cutting rules
    since each vote is signed with the validator’s private key, which is received
    by validators.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, the following conditions apply:'
  prefs: []
  type: TYPE_NORMAL
- en: A supermajority link is defined as an ordered pair of checkpoints (a; b), also
    written a -> b, such that at least 2/3 of the validators (that is, the set of
    validators whose deposit sum is 2/3 of total) posted a vote with a sorgete and
    b target. The supermajority links can skip check-points. So it’s okay if h (b)>
    h (a) + 1.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two checkpoints (a and b) are defined as conflicting if and only if they are
    nodes in distinct branches, that is to say, one is not an ancestor or descendant
    of the other.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A checkpoint is said to be justified if:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is the source
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Link c0 - <c has a supermajority
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A checkpoint c is said to be finalized if a supermajority link c-> c0 exists,
    and c0 is a significant child of c. In the same way, c is finalized if and only
    if c is justified. There must also be a supermajority link c - > c0, in which
    the checkpoints c and c0 are not conflicting, and h (c0) = h (c) + 1\. (See Figure
    [5-9](#Fig9).)![../images/520777_1_En_5_Chapter/520777_1_En_5_Fig9_HTML.jpg](../images/520777_1_En_5_Chapter/520777_1_En_5_Fig9_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5-9
  prefs: []
  type: TYPE_NORMAL
- en: The justified r -> b1 -> b2 -> b3 chain
  prefs: []
  type: TYPE_NORMAL
- en: EIP 1011 contains information about Casper FFG’s current smart contract. A stakeholder
    becomes eligible to participate by registering for the committed smart contract,
    which encodes Casper FFG e and can be accessed via Ethereum transactions.
  prefs: []
  type: TYPE_NORMAL
- en: Here we report the CheckpointTimes() function  (see Figure [5-10](#Fig10)),
    and then the Casper FFG (Casper the Friendly Finality Gadget) algorithm.![../images/520777_1_En_5_Chapter/520777_1_En_5_Fig10_HTML.jpg](../images/520777_1_En_5_Chapter/520777_1_En_5_Fig10_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5-10
  prefs: []
  type: TYPE_NORMAL
- en: CheckPointVote()
  prefs: []
  type: TYPE_NORMAL
- en: Then we report Casper FFG, as shown in Figure [5-11](#Fig11).![../images/520777_1_En_5_Chapter/520777_1_En_5_Fig11_HTML.jpg](../images/520777_1_En_5_Chapter/520777_1_En_5_Fig11_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5-11
  prefs: []
  type: TYPE_NORMAL
- en: CheckPointVote()
  prefs: []
  type: TYPE_NORMAL
- en: 5.4 Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter introduced the future scope of proof of stake, which replaces miners
    with validators and makes the mining process virtual. The chapter also discussed
    chain-based proof of stake, which uses a block system.
  prefs: []
  type: TYPE_NORMAL
- en: The popularity of public blockchains like Bitcoin and Ethereum has sparked interest
    in blockchain technology and its usage as a distributed system in the most cutting-edge
    commercial applications. To use blockchain in the distributed system, you need
    to understand the concept of *hyperledger fabric* *,* which serves as a foundation
    for application development or modular architecture solutions. The next chapter
    contains more details about hyperledger fabric.
  prefs: []
  type: TYPE_NORMAL
