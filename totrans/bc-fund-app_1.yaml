- en: © The Author(s), under exclusive license to Springer Nature Switzerland AG 2022X.
    Yi et al.Blockchain Foundations and ApplicationsSpringerBriefs in Applied Sciences
    and Technology[https://doi.org/10.1007/978-3-031-09670-9_1](https://doi.org/10.1007/978-3-031-09670-9_1)
  prefs: []
  type: TYPE_NORMAL
- en: 1. Cryptographic Primitives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Xun Yi^([1](#Aff6) [ ](#ContactOfAuthor6)), Xuechao Yang^([1](#Aff6) [ ](#ContactOfAuthor7)),
    Andrei Kelarev^([1](#Aff6) [ ](#ContactOfAuthor8)), Kwok Yan Lam^([2](#Aff7) [ ](#ContactOfAuthor9))
    and Zahir Tari^([1](#Aff6) [ ](#ContactOfAuthor10))(1)School of Computing Technologies,
    RMIT University, Melbourne, VIC, Australia(2)School of Computer Science and Engineering,
    Nanyang Technological University, Singapore, SingaporeXun Yi (Corresponding author)Email:
    [xun.yi@rmit.edu.au](mailto:xun.yi@rmit.edu.au)Xuechao YangEmail: [xuechao.yang@rmit.edu.au](mailto:xuechao.yang@rmit.edu.au)Andrei KelarevEmail:
    [andrei.kelarev@gmail.com](mailto:andrei.kelarev@gmail.com)Kwok Yan LamEmail:
    [kwokyan.lam@ntu.edu.sg](mailto:kwokyan.lam@ntu.edu.sg)Zahir TariEmail: [zahir.tari@rmit.edu.au](mailto:zahir.tari@rmit.edu.au)'
  prefs: []
  type: TYPE_NORMAL
- en: 1.1 Secret Key Cryptosystems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 1.1.1 Secret Key Cryptosystem Model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A secret key cryptosystem is an encryption system that uses secret keys for
    the encryption of plaintext and decryption of ciphertext. The keys may be identical
    or there may be two different keys and a simple transformation to go between them.
    The keys, in practice, represent a shared secret between two or more parties that
    can be used to maintain a private information link.
  prefs: []
  type: TYPE_NORMAL
- en: The first systematic information-theoretic study of secret key cryptosystems
    can be found in Shannon’s classical paper “Communication Theory of Secrecy Systems” [[7](#CR7)].
    It gave a secret key encryption model as shown in Fig. [1.1](#Fig1).
  prefs: []
  type: TYPE_NORMAL
- en: Prior to transmission of a plaintext *P*, the sender and the recipient need
    to exchange a shared secret key *K* or to receive it from a trusted key source.
    This key is used by the sending side to encrypt a plaintext *P*, obtaining a ciphertext
    *C*, which is delivered to the receiving side and may be intercepted by an enemy
    eavesdropper. The receiver then uses the key *K* in order to reconstruct the clear
    plaintext *P*.
  prefs: []
  type: TYPE_NORMAL
- en: 1.1.2 Advanced Encryption Standard
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Data Encryption Standard (DES) is a secret key cryptosystem for the encryption
    of electronic data developed in the early 1970s at IBM and based on an earlier
    design by Horst Feistel [[6](#CR6)]. The algorithm was submitted to the National
    Bureau of Standards (NBS) following the agency’s invitation to propose a candidate
    for the protection of sensitive, unclassified electronic government data. In 1976,
    after consultation with the National Security Agency (NSA), the NBS eventually
    selected a slightly modified version, which was published as an official Federal
    Information Processing Standard (FIPS) for the United States in 1977.
  prefs: []
  type: TYPE_NORMAL
- en: DES and its variations have been widely used for more than 40 years. The main
    problem of the DES algorithm was its relatively short secret key, with ![$$2^{56}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq1.png)
    possible keys. Although this a fairly large number, sufficient computational resources
    make a brute force attacks on DES feasible. The so-called DES challenges, where
    a large number of computers connected to the Internet exhaustively searched the
    key space, demonstrated this is a dramatical weakness. The first DES challenge
    in 1997 was completed in 4.5 months, the second in 1998 in 39 days and the third
    and final DES challenge in 1999 was completed in less than a day (22.5 h).![](../images/516136_1_En_1_Chapter/516136_1_En_1_Fig1_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Image reflects the secret key encryption model, it consists of sender, encrypt,
    decrypt, recipient, plaintext, and ciphertext.
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 1.1
  prefs: []
  type: TYPE_NORMAL
- en: Secret key encryption model
  prefs: []
  type: TYPE_NORMAL
- en: In 1997, the US National Institute of Standards and Technology (NIST) started
    a public competition to select an algorithm for replacing DES. The algorithm was
    required to support key sizes of 128, 192, and 256 bits and to be free of any
    patents. The selection process consisted of several rounds where candidate algorithms
    were evaluated. At the end of the first round in August 1998, 15 algorithms were
    accepted as candidates. In the next round in August 1999, the candidates were
    reduced to five finalist algorithms (MARS, Blowfish, RC6, Rijndael, Serpent).
    Finally, in April 2000 the Rijndael algorithm was selected as the winner. On 2
    October 2000, NIST officially announced that Rijndael had been chosen as Advanced
    Encryption Standard (AES) [[2](#CR2)].
  prefs: []
  type: TYPE_NORMAL
- en: The AES algorithm operates on 128-bit data blocks supporting three different
    key sizes of 128, 192 and 256\. These three flavours of the AES algorithm are
    also referred to as AES-128, AES-192 and AES-256, for 128, 192, and 256-bit keys,
    respectively. An AES encryption process consists of a number of encryption rounds
    (Nr) that depends on the size of the key. The standard calls for 10 rounds for
    AES-128, 12 rounds for a AES-192, and 14 rounds for a AES-256.
  prefs: []
  type: TYPE_NORMAL
- en: During encryption, each round is composed of a set of four basic operations.
    The decryption process applies the inverse of these operations in reverse order.
    Figure [1.2](#Fig2) shows the basic structure of the AES-128 encryption and decryption.![](../images/516136_1_En_1_Chapter/516136_1_En_1_Fig2_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Image represents the encryption and decryption of the basic structure of the
    advanced encryption standard.
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 1.2
  prefs: []
  type: TYPE_NORMAL
- en: Encryption and decryption of AES-128
  prefs: []
  type: TYPE_NORMAL
- en: AES operates on a ![$$4\times 4$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq2.png)
    column-major order matrix of bytes, termed the state, as shown in Fig. [1.3](#Fig3),
    where the element ![$$S_{r,c}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq3.png)
    is an 8-bit value that corresponds to row *r* and column *c* of the state. Most
    AES calculations are done in a special finite field.![](../images/516136_1_En_1_Chapter/516136_1_En_1_Fig3_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: a table consists of 4 columns and 4 rows. The first column starts with S subscript
    0,0 and ends with S subscript 3,0\. Similar pattern is followed in other three
    columns.
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 1.3
  prefs: []
  type: TYPE_NORMAL
- en: State of AES
  prefs: []
  type: TYPE_NORMAL
- en: Next, we present a high-level description of the main operations of the AES
    algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: '**KeyExpansion**. Round keys are derived from the key using AES key schedule.
    AES requires a separate 128-bit round key block for each round plus one more.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**InitialRound**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AddRoundKey**. Each byte of the state is combined with a block of the round
    key using bitwise ![$$\,\text{ XOR }\,$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq4.png)
    operation.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Rounds**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SubBytes** is a non-linear substitution step where each byte is replaced
    with another according to a lookup table.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**ShiftRows** is a transposition step where the last three rows of the state
    are shifted cyclically a certain number of steps.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**MixColumns** is a mixing operation which operates on the columns of the state,
    combining four bytes in each column. The MixColumns operations of the AES encryption
    and AES decryption are illustrated in Fig. [1.4](#Fig4).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**AddRoundKey**.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Final Round** (without MixColumns).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SubBytes**.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**ShiftRows**.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**AddRoundKey**.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](../images/516136_1_En_1_Chapter/516136_1_En_1_Fig4_HTML.png)'
  prefs: []
  type: TYPE_IMG
- en: Image reflects the mix columns of advanced encryption standard encryption and
    decryption. Mix Columns is a mixing operation that operates on the columns of
    the state, combining four bytes in each column.
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 1.4
  prefs: []
  type: TYPE_NORMAL
- en: The MixColumns of AES encryption and decryption
  prefs: []
  type: TYPE_NORMAL
- en: 'The National Security Agency (NSA) reviewed all the AES finalists, including
    Rijndael, and stated that all of them were secure enough for U.S. Government non-classified
    data. In June 2003, the U.S. Government announced that AES could be used to protect
    classified information: “The design and strength of all key lengths of the AES
    algorithm (i.e., 128, 192 and 256) are sufficient to protect classified information
    up to the SECRET level. TOP SECRET information will require use of either the
    192 or 256 key lengths. The implementation of AES in products intended to protect
    national security systems and/or information must be reviewed and certified by
    NSA prior to their acquisition and use.” Until 2009, the only successful published
    attacks against the full AES were side-channel attacks on some specific implementations.'
  prefs: []
  type: TYPE_NORMAL
- en: 1.2 Public Key Cryptosystem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Public key cryptosystems include public key encryption algorithms and digital
    signature algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: 1.2.1 Public Key Encryption Model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In a secret key cryptosystem, two parties would rely upon a key that they would
    exchange between themselves by means of a secure method. For example, a face-to-face
    meeting or an exchange via a trusted courier could be used. This key, which both
    parties keep absolutely secret, can then be used to exchange encrypted messages.
    A number of significant practical difficulties arise with this approach to distributing
    keys. Public key encryption addresses these drawbacks so that users can communicate
    securely over a public channel without having to agree upon a shared key beforehand.
  prefs: []
  type: TYPE_NORMAL
- en: The public key encryption model, as shown in Fig. [1.5](#Fig5), was published
    in 1976 by Whitfield Diffie and Martin Hellman [[3](#CR3)] who, influenced by
    Ralph Merkle’s work on public-key distribution, proposed a method of public-key
    agreement.![](../images/516136_1_En_1_Chapter/516136_1_En_1_Fig5_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Image represents the public key encryption model. The public key is used to
    encrypt plaintext, whereas the private key is used to decrypt the ciphertext.
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 1.5
  prefs: []
  type: TYPE_NORMAL
- en: Public key encryption model
  prefs: []
  type: TYPE_NORMAL
- en: Public key encryption, also called asymmetric key encryption, is a class of
    algorithms which require two separate keys, one of which is secret (or private)
    and another one is public. Although these two keys are different, they form a
    key pair and are mathematically linked. The public key is used to encrypt plaintext,
    whereas the private key is used to decrypt ciphertext. The term “asymmetric” stems
    from the use of different keys to perform these opposite functions, each the inverse
    of the other—as contrasted with the conventional (“symmetric key”) encryption
    relying on the same key to perform both.
  prefs: []
  type: TYPE_NORMAL
- en: In general, a public key encryption algorithm, associated with a key space ![$$\mathbf{K}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq5.png),
    a plaintext space ![$$\mathbf{M}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq6.png)
    and a ciphertext space ![$$\mathbf{C}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq7.png),
    consists of the following three algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Key generation algorithm (KG): Given a security parameter *k*, a public and
    private key pair ![$$(\mathsf {pk},\mathsf {sk})$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq8.png)
    is generated, where ![$$\mathsf {sk}\in \mathbf{K}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq9.png).
    The public key ![$$\mathsf {pk}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq10.png)
    is published to the public, while the private key ![$$\mathsf {sk}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq11.png)
    is known to its owner only.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Encryption algorithm (*E*): Given a plaintext ![$$m\in \mathbf{M}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq12.png)
    and a public key ![$$\mathsf {pk}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq13.png),
    a ciphertext *c* is produced, denoted as ![$$c=E(m,\mathsf {pk})$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq14.png),
    where ![$$c\in \mathbf{C}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq15.png).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Decryption algorithm (*D*): Given a ciphertext ![$$c=E(m,\mathsf {pk})$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq16.png)
    and the private key ![$$\mathsf {sk}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq17.png),
    the plaintext *m* is recovered, denoted as ![$$m=D(c,\mathsf {sk})$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq18.png).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The encryption algorithm *E* is a mapping from the plaintext space ![$$\mathbf{M}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq19.png)
    to the ciphertext space ![$$\mathbf{C}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq20.png).
    It must be a trap-door one-way function. For virtually all ciphertexts ![$$c =
    E(m,\mathsf {pk})$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq21.png),
    it must be computationally infeasible to recover the plaintext *m* from a given
    ![$$\mathsf {pk}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq22.png)
    and *c*. However, since the legitimate recipient of the message must be able to
    recover *m* from *c*, more is required of the one-way function. Namely, each *E*
    must have an inverse *D*, and this inverse must be easily obtainable given some
    additional secret information ![$$\mathsf {sk}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq23.png).
    The extra information ![$$\mathsf {sk}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq24.png)
    is called a *trap-door* of *E* and the function *E* itself is called a *trap-door
    one-way function*. It is also required that, with the knowledge of ![$$\mathsf
    {sk}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq25.png),
    it should be easy to compute ![$$m = D(c,\mathsf {sk})$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq26.png),
    for all *c* in the ciphertext space.
  prefs: []
  type: TYPE_NORMAL
- en: Trap-door functions are based on mathematical problems which currently admit
    no efficient solution. They can involve certain integer factorization, discrete
    logarithms, and elliptic curve relationships. It is computationally easy for a
    user to generate their own public and private key-pair and to use them for encryption
    and decryption. The strength lies in the fact that it is “impossible” (computationally
    infeasible) for a properly generated private key to be determined from its corresponding
    public key. Thus the public key may be published without compromising security,
    whereas the private key must not be revealed to anyone unauthorized to read messages.
    Public key algorithms, unlike secret key algorithms, do not require a secure initial
    exchange of one or more secret keys between the parties.
  prefs: []
  type: TYPE_NORMAL
- en: 1.2.2 RSA Encryption Algorithm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Diffie and Hellman introduced the great idea of a public key cryptosystem in
    1976, but they did not provide any examples of practical public key cryptosystems.
    In 1977, Ron Rivest, Adi Shamir and Leonard Adleman proposed the first practical
    public key cryptosystem, RSA [[5](#CR5)]. In the RSA encryption algorithm, the
    encryption key is public and is different from the decryption key, which is kept
    secret. The security is based on the practical difficulty of factoring the product
    of two large prime numbers, the factoring problem. An English mathematician Clifford
    Cocks developed an equivalent system in 1973, but it remained classified until
    1997.
  prefs: []
  type: TYPE_NORMAL
- en: 'The RSA encryption algorithm includes three algorithms: key generation, encryption
    and decryption. These algorithms are described as follows.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Key generation**. The RSA requires a public key and a private key. The public
    key can be known to everyone and is used for encrypting messages. Messages encrypted
    with the public key can only be decrypted in a reasonable amount of time using
    the private key. The keys for the RSA algorithm are generated in the following
    way.'
  prefs: []
  type: TYPE_NORMAL
- en: '1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose two distinct prime numbers *p* and *q*. For security purposes, the integers
    *p* and *q* should be chosen at random, and should be of similar bit-length. Prime
    integers can be efficiently found using a primality test.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compute ![$$n = pq$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq27.png).
    The number *n* is used as a modulus for both the public and private keys. Its
    length, usually expressed in bits, is the key length.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '3.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compute ![$$\phi (n) = \phi (p)\phi (q) = (p - 1)(q - 1) = n - (p + q -1)$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq28.png),
    where ![$$\phi $$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq29.png)
    is the Euler’s totient function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '4.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose an integer *e* such that ![$$1&lt; e &lt; \phi (n)$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq30.png)
    and ![$$\,\text{ gcd }(e, \phi (n)) = 1$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq31.png);
    i.e., *e* and ![$$\phi (n)$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq32.png)
    are coprime. The integer *e* is released as the public key exponent. If *e* has
    a short bit-length and small Hamming weight (as, for example, ![$$2^{16} + 1 =
    65,537$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq33.png)),
    then it results in a more efficient encryption. However, much smaller values of
    *e* (such as 3) have been shown to be less secure in some settings [[1](#CR1)].
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '5.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Determine *d* as ![$$d = e^{-1} \pmod {\phi (n)}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq34.png);
    i.e., *d* is the multiplicative inverse of ![$$e \pmod {\phi (n)}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq35.png).
    The multiplicative inverse can be computed using the extended Euclidean algorithm.
    The number *d* is used as the private key.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The public key consists of the modulus *n* and the public (or encryption) exponent *e*.
    The private key consists of the modulus *n* and the private (or decryption) exponent
    *d*, which must be kept secret. The numbers *p*, *q*, and ![$$\phi (n)$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq36.png)
    must also be kept secret, because they can be used to calculate *d*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Encryption**. Alice transmits her public key (*n*, *e*) to Bob and keeps
    the private key secret. Bob then wishes to send a message *M* to Alice.'
  prefs: []
  type: TYPE_NORMAL
- en: First, Bob turns *M* into an integer *m* such that ![$$0 \le m &lt; n$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq37.png)
    by using an agreed-upon reversible protocol known as a padding scheme. Then Bob
    computes the ciphertext *c* given by![$$\begin{aligned} c= &amp; {} m^e (\bmod
    ~n). \end{aligned}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ1.png)(1.1)This
    can be done quickly using the method of exponentiation by squaring. Bob then transmits
    *c* to Alice.**Decryption**. Alice can recover *m* from *c* by using her private
    key exponent *d* via computing![$$\begin{aligned} m= &amp; {} c^d \pmod {n}. \end{aligned}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ2.png)(1.2)Given
    *m*, Alice can recover the original message *M* by reversing the padding scheme.
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate the RSA encryption and decryption procedures, next we give a numerical
    example. The parameters used here are artificially small, but it can also help
    the readers who may wish to use OpenSSL for generating and examining a real keypair.
  prefs: []
  type: TYPE_NORMAL
- en: '1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose two distinct prime numbers, such as ![$$p=61$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq38.png)
    and ![$$q=53$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq39.png).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compute ![$$n = pq = 61 \times 53=3233$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq40.png).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '3.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compute the totient function of the product ![$$\phi (n) = (p - 1)(q - 1)$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq41.png).
    In our example, we get ![$$\phi (3233)=(61-1)\times (53-1)=3120$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq42.png).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '4.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose any number ![$$1&lt; e &lt; 3120$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq43.png)
    that is coprime with 3120\. If a prime number is chosen for *e*, then it suffices
    to check that *e* is not a divisor of 3120\. In the example, let us take ![$$e=17$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq44.png).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '5.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compute ![$$d = e^{-1} \pmod {\phi (n)} = 2753$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq45.png).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The public key is the pair ![$$(n, e) = (3233, 17)$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq46.png).
    For a padded plaintext message *m*, the encryption function is![$$c = m^{17} \pmod
    {3233}.$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ34.png)The
    private key is the pair ![$$(n, d) = (3233, 2753)$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq47.png).For
    an encrypted ciphertext *c*, the decryption function is![$$m = c^{2753} \pmod
    {3233}.$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ35.png)For
    instance, in order to encrypt ![$$m = 65$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq48.png),
    we compute![$$c=65^{17}=2790 \pmod {3233}.$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ36.png)To
    decrypt ![$$c = 2790$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq49.png),
    we calculate![$$m=2790^{2753} \pmod {3233} = 65.$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ37.png)
  prefs: []
  type: TYPE_NORMAL
- en: 1.2.3 Digital Signature Model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A digital signature is a mathematical scheme for verifying the authenticity
    of digital messages or documents. A valid digital signature, where the prerequisites
    are satisfied, gives a recipient very strong reason to believe that the message
    was created by a known sender (authenticity), and that the message was not altered
    in transit (integrity). In many instances, it provides a layer of validation and
    security to messages sent through a non-secure channel. Digital signatures are
    equivalent to traditional handwritten signatures in many respects, but properly
    implemented digital signatures are more difficult to forge than the handwritten
    ones. They can also provide non-repudiation, which means that the signer cannot
    successfully claim that they did not sign a message. Digital signatures can be
    used to sign any messages representable as a bitstring: examples include electronic
    mail, contracts, or messages sent in other cryptographic protocols.'
  prefs: []
  type: TYPE_NORMAL
- en: A model of digital signatures was invented by Whitfield Diffie and Martin Hellman [[3](#CR3)]
    in 1976\. It is shown in Fig. [1.6](#Fig6).![](../images/516136_1_En_1_Chapter/516136_1_En_1_Fig6_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Image depicts the digital signature model. The process consists of signing and
    verification.
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 1.6
  prefs: []
  type: TYPE_NORMAL
- en: Digital signature model
  prefs: []
  type: TYPE_NORMAL
- en: Typically, a digital signature scheme consists of the following three algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: A key generation algorithm selecting a private key uniformly at random from
    a set of possible private keys. The algorithm outputs a private key and the corresponding
    public key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A signing algorithm, which produces a signature for a given message with the
    private key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A signature verifying algorithm, which accepts or rejects the authenticity claim
    for a given message, public key and signature.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The digital signature scheme must satisfy the following two main properties.
    First, it should be possible to use the corresponding public key to verify the
    authenticity of a signature generated from a fixed message and a fixed private
    key. Second, it must be computationally infeasible to generate a valid signature
    for a party without knowing the party’s private key. A digital signature is an
    authentication mechanism that enables the creator of the message to attach a bit
    string that acts as a signature.
  prefs: []
  type: TYPE_NORMAL
- en: Formally, a digital signature algorithm can be defined as a triple of algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Key generation algorithm (***KG***)**. Given a security parameter *k*, a
    public and private key pair ![$$(\mathsf {pk},\mathsf {sk})$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq50.png)
    is generated. The public key ![$$\mathsf {pk}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq51.png)
    is published to the public, while the private key ![$$\mathsf {sk}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq52.png)
    is known to its owner only.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Signing algorithm (***S***)**. Given a message *m* and a private key ![$$\mathsf
    {sk}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq53.png),
    a signature ![$$s=S(m,\mathsf {sk})$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq54.png)
    is produced.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Verification algorithm (***V***)**. Given a message *m*, the signature *s*
    and the public key ![$$\mathsf {pk}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq55.png),
    the algorithm outputs a value ![$$V(m,s,\mathsf {pk}) \in \{0, 1\}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq56.png),
    where ![$$V(m,s,\mathsf {pk})$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq57.png)
    is equal to 1 if the authenticity is accepted and is equal to 0 if it is rejected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1.2.4 RSA Digital Signature Algorithm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The RSA digital signature algorithm was the first practical digital signature
    algorithm. It was proposed by Ron Rivest, Adi Shamir and Leonard Adleman and was
    named using an acronym of the first letters of their surnames [[5](#CR5)].
  prefs: []
  type: TYPE_NORMAL
- en: 'The RSA digital signature algorithm is made up from three algorithms: key generation,
    signing and verification algorithms described below.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Key generation**. A public key and a private key are required for RSA. The
    public key can be known by everyone and is used for verifying digital signatures.
    The private key is known only to the signer. Messages are signed with the private
    key by the signer. The public key can be used for verifying digital signatures
    in a reasonable amount of time. The keys for the RSA digital signature algorithm
    are generated in the same way as for the RSA encryption algorithm.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Signing algorithm**. Alice transmits her public key (*n*, *e*) to Bob and
    keeps the private key *d* secret. Alice then wishes to send a message *m* with
    her digital signature to Bob.'
  prefs: []
  type: TYPE_NORMAL
- en: First, Alice computes her signature for the message *m* with her private key
    *d*,![$$\begin{aligned} s= &amp; {} m^d \pmod {n} \end{aligned}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ3.png)(1.3)This
    can be done quickly using the method of exponentiation by squaring. Alice then
    transmits (*m*, *s*) to Bob.**Verification algorithm**. Bob verifies Alice’s signature
    *s* on the message *m* by using her public key (*n*, *e*) to check whether the
    following modular equality holds![$$\begin{aligned} m= &amp; {} s^e \pmod {n}
    \end{aligned}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ4.png)(1.4)If
    the above equality is valid, then the signature is genuine and the message has
    been signed by Alice. Otherwise, the signature must be rejected.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we give an example of RSA signature generation and verification. For convenience,
    the example uses small parameters, but one can also use OpenSSL to generate and
    examine a real keypair.
  prefs: []
  type: TYPE_NORMAL
- en: '1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose two distinct prime numbers, for example, ![$$p=61$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq58.png)
    and ![$$q=53$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq59.png).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compute ![$$n = pq = 61\times 53 = 3233$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq60.png).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '3.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compute the totient of the product as ![$$\phi (n) = (p - 1)(q - 1)$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq61.png).
    In the example, we get ![$$\phi (3233) = (61-1) \times (53-1) = 3120$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq62.png).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '4.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose any number ![$$1&lt; e &lt; 3120$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq63.png)
    that is coprime to 3120\. If we choose a prime number for *e*, then it remains
    only to check that *e* is not a divisor of 3120\. In our example, let us take
    ![$$e=17$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq64.png).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '5.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compute ![$$d = e^{-1} \pmod {\phi (n)} = 2753$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq65.png).
    The public key is the pair ![$$(n, e) = (3233, 17)$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq66.png)
    and the private key is ![$$(n, d) = (3233, 2753)$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq67.png).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For a message *m*, the signature is![$$s = m^{2753} \pmod {3233}.$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ38.png)For
    signature verification, one needs to check whether the following equality holds![$$m=s^{17}
    \pmod {3233}.$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ39.png)For
    example, in order to sign ![$$m = 2790$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq68.png),
    we calculate![$$s=2790^{2753}=65 \pmod {3233}.$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ40.png)To
    verify the signature, we compute![$$65^{17}\pmod {3233} = 2790.$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ41.png)Since
    ![$$m = s^e\pmod {n}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq69.png),
    the signature can be accepted.
  prefs: []
  type: TYPE_NORMAL
- en: 1.3 Hash Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The original RSA digital signature algorithm can sign only a short message with
    less than *n* bits. In order to sign longer messages with more than *n* bits,
    a hash function has to be used at first. A hash function maps each longer message
    to a shorter string of bits called the *hash* of the message. Then the RSA digital
    signature algorithm can be used to generate a signature for the short hash of
    the original message.
  prefs: []
  type: TYPE_NORMAL
- en: 1.3.1 The Concept of a Hash Function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *hash function* is a mathematical algorithm that maps data of an arbitrary
    size (often called the “message”) to a bit array of a fixed size (the “hash value”,
    “hash”, or “message digest”). It is a one-way function, which means that it is
    practically infeasible to invert or reverse the computation and recover the input
    of the function given only its output. Ideally, the only way to find a message
    that produces a given hash is to attempt a brute-force search through all possible
    inputs to see which of the inputs produces a match, or use a rainbow table of
    matched hashes. Hash functions are a basic tool of modern cryptography.
  prefs: []
  type: TYPE_NORMAL
- en: A hash function must be deterministic, which means that the same message always
    results in the same hash. Ideally, it should also have the following properties.
  prefs: []
  type: TYPE_NORMAL
- en: It must be quick to compute the hash value for any given message.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should be infeasible to generate a message that yields a given hash value
    (i.e., to reverse the process that generated the given hash value).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should be infeasible to find two different messages with the same hash value.
    A small change to a message should alter the hash value so extensively that a
    new hash value would appear uncorrelated with the old hash value (avalanche effect).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hash functions have many security applications, notably in digital signatures,
    message authentication codes (MACs), and other forms of authentication. They can
    also be used for indexing data in hash tables, for fingerprinting, for detecting
    duplicate data, for unique identification of files, and as checksums to detect
    accidental data corruption. In information-security contexts, hash values are
    sometimes called (digital) fingerprints, checksums, or just hash values, even
    though all these terms stand for more general functions with rather different
    properties and purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Most hash functions are designed to take a string of any length as input and
    produce a fixed-length hash value.
  prefs: []
  type: TYPE_NORMAL
- en: A hash function must be able to withstand all known types of cryptanalytic attacks.
    In theoretical cryptography, the security level of a hash function has been defined
    using the following properties.
  prefs: []
  type: TYPE_NORMAL
- en: '**Pre-image resistance**. Given a hash value *h*, it should be difficult to
    find any message *m* such that ![$$h = \mathsf {hash}(m)$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq70.png).
    This concept is related to that of a one-way function. Functions that lack this
    property are vulnerable to preimage attacks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Second pre-image resistance**. Given an input ![$$m_1$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq71.png),
    it should be difficult to find a different input ![$$m_2$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq72.png)
    such that ![$$\mathsf {hash}(m_1) = \mathsf {hash}(m_2)$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq73.png).
    This property is sometimes referred to as a *weak collision resistance*. Functions
    that lack this property are vulnerable to second pre-image attacks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Collision resistance**. It should be difficult to find two different messages
    ![$$m_1$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq74.png)
    and ![$$m_2$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq75.png)
    such that ![$$\mathsf {hash}(m_1) = \mathsf {hash}(m_2)$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq76.png).
    Such a pair is called a *cryptographic hash collision*. This property is sometimes
    referred to as a *strong collision resistance*. It requires a hash value at least
    twice as long as that required for pre-image resistance; otherwise collisions
    may be found by a birthday attack.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collision resistance implies second pre-image resistance but does not imply
    pre-image resistance. The weaker assumption is always preferred in theoretical
    cryptography, but in practice, a hash function which is only second pre-image
    resistant is considered insecure and is therefore not recommended for real applications.
  prefs: []
  type: TYPE_NORMAL
- en: Informally, these properties mean that a malicious adversary cannot replace
    or modify the input data without changing its digest. Thus, if two strings have
    the same digest, one can be very confident that they are identical. Second pre-image
    resistance prevents an attacker from crafting a document with the same hash as
    a document the attacker cannot control. Collision resistance prevents an attacker
    from creating two distinct documents with the same hash.
  prefs: []
  type: TYPE_NORMAL
- en: 'A function satisfying these criteria may still have undesirable properties.
    Currently, popular hash functions are vulnerable to length-extension attacks:
    given ![$$\mathsf {hash}(m)$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq77.png)
    and ![$$\mathsf {len}(m)$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq78.png)
    but not *m*, by choosing a suitable ![$$m''$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq79.png)
    an attacker can calculate ![$$\mathsf {hash}(m \Vert m'')$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq80.png),
    where ![$$\Vert $$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq81.png)
    denotes concatenation. This property can be used to break naive authentication
    schemes based on hash functions. The Hash-based Message Authentication Code (HMAC)
    construction works around these problems.'
  prefs: []
  type: TYPE_NORMAL
- en: In practice, collision resistance is insufficient for many practical uses. In
    addition to collision resistance, it should be impossible for an adversary to
    find two messages with substantially similar digests, or to infer any useful information
    about the data given only its digest. In particular, a hash function should behave
    as much as possible like a random function (often called a random oracle in proofs
    of security) while still being deterministic and efficiently computable. This
    rules out functions like the SWIFFT function [[4](#CR4)], which can be rigorously
    proven to be collision resistant assuming that certain problems on ideal lattices
    are computationally difficult, but, as a linear function, does not satisfy these
    additional properties.
  prefs: []
  type: TYPE_NORMAL
- en: Checksum algorithms, such as CRC (Cyclic Redundancy Check) and other cyclic
    redundancy checks, are designed to satisfy much weaker requirements and are generally
    unsuitable as hash functions. For example, a CRC was used for message integrity
    in the Wired Equivalent Privacy (WEP) encryption standard, but an attack was readily
    discovered, which exploited the linearity of the checksum.
  prefs: []
  type: TYPE_NORMAL
- en: 1.3.2 SHA-1
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SHA-1 (Secure Hash Algorithm 1) is a hash function which takes an input and
    produces a 160-bit (20-byte) hash value known as a message digest— typically rendered
    as a hexadecimal number, 40 digits long. It was designed by the United States
    National Security Agency, and is a U.S. Federal Information Processing Standard.
  prefs: []
  type: TYPE_NORMAL
- en: When a message of any length less than ![$$2^{64}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq82.png)
    is an input, SHA-1 produces a 160-bit output called a *message digest*. The message
    digest can then be used, for example, in a signature algorithm which generates
    or verifies the signature for a message. Signing the message digest rather than
    the message often improves the efficiency of the process because the message digest
    is usually much shorter than the message. The same hash algorithm must be used
    by the verifier of a digital signature as the one used by the creator of the digital
    signature. Any change to the message in transit will, with very high probability,
    result in a different message digest, and the signature will fail to verify.
  prefs: []
  type: TYPE_NORMAL
- en: SHA-1 produces a message digest based on principles similar to those used by
    Ronald L. Rivest of MIT in the design of the MD2, MD4 and MD5 message digest algorithms,
    but generates a larger hash value (160 bits vs. 128 bits). SHA-1 was designed
    on the basis of Merkle-Damgård construction as shown in Fig. [1.7](#Fig7).![](../images/516136_1_En_1_Chapter/516136_1_En_1_Fig7_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Image reflects Merkle Damgård hash function construction. The original message
    flows to message block 1 and message block 2, while the padding flows to message
    block n.
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 1.7
  prefs: []
  type: TYPE_NORMAL
- en: Merkle-Damgård hash function construction
  prefs: []
  type: TYPE_NORMAL
- en: To describe SHA-1, let us first define the terminology and functions used as
    building blocks for it.
  prefs: []
  type: TYPE_NORMAL
- en: 'A hexadecimal digit (or hex digit) is an element of the set ![$$\{0, 1, \ldots
    , 9, A, \ldots , F\}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq83.png).
    Each hex digit is a representation of a 4-bit string. For examples: ![$$7 = 0111$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq84.png)
    and ![$$A = 1010$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq85.png).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *word* is a 32-bit string which may be represented as a sequence of 8 hex
    digits. To convert a word to 8 hex digits each 4-bit string is converted to its
    hex equivalent as described above. For example,![$$1010 0001 0000 0011 1111 1110
    0010 0011 = A103FE23.$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ42.png)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every integer between 0 and ![$$2^{32} - 1$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq86.png)
    inclusive can be represented as a word. The least significant four bits of the
    integer are represented by the rightmost hex digits of the word representation.
    For example, the integer ![$$291 = 2^8+2^5+2^1+2^0 = 256+32+2+1$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq87.png)
    is represented by the hex word 00000123.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *block* is a 512-bit string. Every block can be represented as a sequence
    of 16 words.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following logical operators will be applied to words.
  prefs: []
  type: TYPE_NORMAL
- en: Bitwise logical word operations![$$\begin{aligned} \,\text{ AND }\,&amp;\text
    { is a bitwise logical ``and'' operator}, \nonumber \\ \,\text{ OR }\,&amp;\text
    { is a bitwise logical ``inclusive-or'' operator}, \nonumber \\ \,\text{ XOR }\,&amp;\text
    { is a bitwise logical ``exclusive-or'' operator}, \nonumber \\ \text{ NOT }\,&amp;\text
    { is a bitwise logical ``complement'' operator}. \nonumber \end{aligned}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ43.png)For
    example,![](../images/516136_1_En_1_Chapter/516136_1_En_1_Equ46_HTML.png)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Image duplicates for positive integers n and m, the remainder upon dividing
    n by m is denoted by n.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The operation ![$$X + Y$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq88.png)
    is defined as follows. Let *X* and *Y* be the words representing integers *x*
    and *y*, where ![$$0 \le x, y &lt; 2^{32}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq89.png).
    For positive integers *n* and *m*, the remainder upon dividing *n* by *m* is denoted
    by ![$$n \pmod {m}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq90.png).
    Compute![$$\begin{aligned} z= &amp; {} (x + y) \pmod {2^{32}}. \end{aligned}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ5.png)(1.5)Then
    ![$$0 \le z &lt; 2^{32}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq91.png).
    Convert *z* to a word *Z*, and define the value of operation ![$$X + Y$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq92.png)
    to be equal to *Z*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If *X* is a word and *i* is an integer such that ![$$0 \le i &lt; 32$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq93.png),
    then the *circular left shift operation* ![$$S^{i}(X)$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq94.png)
    is defined by![$$\begin{aligned} S^i(X)= &amp; {} (X \ll i) \,\text{ OR }\,(X
    \gg 32-i). \end{aligned}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ6.png)(1.6)In
    the above, ![$$X \ll i$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq95.png)
    is obtained by discarding the leftmost *i* bits of *X* and then padding the result
    with *i* zeroes on the right (the result still has 32 bits). Likewise, ![$$X \gg
    i$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq96.png) is obtained
    by discarding the rightmost *i* bits of *X* and then padding the result with i
    zeroes on the left. Thus ![$$S^i(X)$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq97.png)
    is equivalent to a circular shift of *X* by *i* positions to the left.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Padding**. The purpose of message padding is to make the total length of
    a padded message a multiple of 512\. SHA-1 is used to compute a message digest
    for a message or data file that is provided as input. SHA-1 sequentially processes
    blocks of 512 bits when computing the message digest.'
  prefs: []
  type: TYPE_NORMAL
- en: The message or data file should be considered as a bit string. The length of
    the message is the number of bits in the message. (The empty message has length
    0). If the number of bits in a message is a multiple of 8, for compactness we
    can represent the message in hex.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we describe how the message padding is performed. In a summary, a “1”
    followed by *m* “0”s followed by a 64-bit integer are appended to the end of the
    message to produce a padded message of length 512*n*. The 64-bit integer is the
    length of the original message. The padded message is then processed by SHA-1
    as *n* 512-bit blocks.
  prefs: []
  type: TYPE_NORMAL
- en: The first 512-bit block, denoted as *M*(1), is processed in the following steps.
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 1: Initialisation**. The hash function *H* is initialised as follows
    (in hexadecimal notation):'
  prefs: []
  type: TYPE_NORMAL
- en: '![$$H_0 = 67452301$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq98.png),
    ![$$H_1 = EFCDAB89$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq99.png),
    ![$$H_2 = 98BADCFE$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq100.png),'
  prefs: []
  type: TYPE_NORMAL
- en: '![$$H_3 = 10325476$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq101.png),
    ![$$H_4 = C3D2E1F0.$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq102.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Step 2: Expanding**. Divide *M*(1) into 16 words ![$$W(0), W(1), \ldots ,
    W(15)$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq103.png),
    where *W*(0) is the leftmost word. For ![$$t = 16$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq104.png)
    to 79, let![$$\begin{aligned} W(t)= &amp; {} S^1(W(t-3) \,\text{ XOR }\,W(t-8)
    \,\text{ XOR }\,W(t-14) \,\text{ XOR }\,W(t-16)). \end{aligned}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ7.png)(1.7)**Step
    3: Mixing up by looping**. Let ![$$A = H_0$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq105.png),
    ![$$B = H_1$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq106.png),
    ![$$C = H_2$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq107.png),
    ![$$D = H_3$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq108.png),
    ![$$E = H_4$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq109.png).
    For ![$$t = 0$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq110.png)
    to 79 do![$$\begin{aligned}&amp;\text{ TEMP } = S^5(A) + f(t;B,C,D) + E + W(t)
    + K(t),\nonumber \\&amp;E = D; D = C; C = S^{30}(B); B = A; A = \text{ TEMP },
    \end{aligned}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ8.png)(1.8)where![$$f(t;B,C,D)
    = \left\{ \begin{array}{ll} (B \,\text{ AND }\,C) \,\text{ OR }\,((\text{ NOT
    }\,~ B)~ \,\text{ AND }\,~ D) &amp;{} \text{ for } 0 \le t \le 19), \\ B~ \,\text{
    XOR }\,C~ \,\text{ XOR }\,D &amp;{} \text{ for } 20 \le t \le 39),\\ (B \,\text{
    AND }\,C) \,\text{ OR }\,(B \,\text{ AND }\,D) \,\text{ OR }\,(C \,\text{ AND
    }\,D) &amp;{} \text{ for } 40 \le t \le 59),\\ B~ \,\text{ XOR }\,C \,\text{ XOR
    }\,D &amp;{} \text{ for } 60 \le t \le 79, \end{array}\right. $$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ44.png)![$$K(t)
    = \left\{ \begin{array}{ll} 5A827999 &amp;{} \text{ for } 0 \le t \le 19,\\ 6ED9EBA1
    &amp;{} \text{ for } 20 \le t \le 39,\\ 8F1BBCDC &amp;{} \text{ for } 40 \le t
    \le 59,\\ CA62C1D6 &amp;{} \text{ for } 60 \le t \le 79\. \end{array}\right. $$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ45.png)Each
    of these loops can be illustrated with Fig. [1.8](#Fig8).![](../images/516136_1_En_1_Chapter/516136_1_En_1_Fig8_HTML.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Image represents secure hash algorithm computation,
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 1.8
  prefs: []
  type: TYPE_NORMAL
- en: SHA-1 computation
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 4: Output**. Let ![$$H_0 = H_0 + A, H_1 = H_1 + B, H_2 = H_2 + C, H_3
    = H_3 + D, H_4 = H_4 + E$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq111.png).
    Repeatedly execute Steps 1 to 4 for the other 512-bit blocks ![$$M(2), \ldots
    , M(n)$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq112.png).
    The final output ![$$H_0, H_1,H_2,H_3, H_4$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq113.png)
    is the hash digest of the message.'
  prefs: []
  type: TYPE_NORMAL
- en: In early 2005, Vincent Rijmen and Elisabeth Oswald published an attack on a
    reduced version of SHA-1, 53 out of 80 rounds, which finds collisions with a computational
    effort of fewer than 280 operations.
  prefs: []
  type: TYPE_NORMAL
- en: In February 2005, an attack by Wang et al. [[8](#CR8)] was announced. The attack
    can find collisions in the full version of SHA-1, requiring fewer than 269 operations.
    (A brute-force search would require 280 operations.)
  prefs: []
  type: TYPE_NORMAL
- en: 'The authors write: “In particular, our analysis is built upon the original
    differential attack on SHA-0, the near collision attack on SHA-0, the multiblock
    collision techniques, as well as the message modification techniques used in the
    collision search attack on MD5\. Breaking SHA-1 would not be possible without
    these powerful analytical techniques.” The authors presented a collision for 58-round
    SHA-1, found with 233 hash operations. The paper with a description of the full
    attack was published in August 2005 at the CRYPTO conference.'
  prefs: []
  type: TYPE_NORMAL
- en: Since 2005, SHA-1 has not been considered secure against well-funded opponents
    [[4](#CR4)]. Since 2010 many organisations have recommended its replacement. NIST
    formally deprecated the use of SHA-1 in 2011 and disallowed its use for digital
    signatures in 2013\. In 2020, chosen-prefix attacks against SHA-1 have become
    practical. It is recommended to remove SHA-1 from products as soon as possible
    and instead use SHA-2 or SHA-3\. Replacing SHA-1 is urgent where it is used for
    digital signatures.
  prefs: []
  type: TYPE_NORMAL
- en: 1.3.3 SHA-2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SHA-2 includes significant changes in comparison to its predecessor SHA-1\.
    The SHA-2 family consists of six hash functions with digests (hash values) that
    are 224, 256, 384 or 512 bits. These functions are denoted by SHA-224, SHA-256,
    SHA-384, SHA-512, SHA-512/224, SHA-512/256\. The functions SHA-256 and SHA-512
    are novel hash functions computed with eight 32-bit and 64-bit words, respectively.
    They use different shift amounts and additive constants, but in other respects
    their structures are virtually identical; the only difference is in the number
    of rounds. SHA-224 and SHA-384 are truncated versions of SHA-256 and SHA-512,
    respectively, computed with different initial values. SHA-512/224 and SHA-512/256
    are also truncated versions of SHA-512, but the initial values are generated using
    the method described in Federal Information Processing Standards (FIPS) PUB 180-4.
  prefs: []
  type: TYPE_NORMAL
- en: '**Padding**. Begin with the original message of length *L* bits, append a single
    ‘1’ bit, append *K* ‘0’ bits, where *K* is the minimum number ![$$\ge 0$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq114.png)
    such that ![$$L + 1 + K + 64$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq115.png)
    is a multiple of 512, append *L* as a 64-bit big-endian integer, making the total
    post-processed length a multiple of 512 bits such that the bits in the message
    are ![$$L 1 00 \cdots \langle K~0''s \rangle \cdots 00 \langle L \text{ as } 64
    \text{ bit } \text{ integer }\rangle = 512n$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq116.png)
    total bits.'
  prefs: []
  type: TYPE_NORMAL
- en: The first 512-bit block, denoted by *M*(1), is processed in the following steps.
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 1: Initialisation**. In hexadecimal notation, the hash function *H*
    is initialised as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![$$H_0= 6A09E667$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq117.png),
    ![$$H_1= BB67AE85$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq118.png),
    ![$$H_2= 3C6EF372$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq119.png),
    ![$$H_3= A54FF53A$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq120.png),'
  prefs: []
  type: TYPE_NORMAL
- en: '![$$H_4= 510E527F$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq121.png),
    ![$$H_5= 9B05688C$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq122.png),
    ![$$H_6= 1F83D9AB$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq123.png),
    ![$$H_7= 5BE0CD19$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq124.png).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 2: Expanding**. Divide *M*(1) into 16 words ![$$W(0), W(1), \dots ,
    W(15),$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq125.png)
    where *W*(0) is the leftmost word. For ![$$i = 16$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq126.png)
    to 63, let![$$\begin{aligned} S_0= &amp; {} S^7((W(i-15) )\,\text{ XOR }\,S^{18}((W(i-15))\,\text{
    XOR }\,(W(i-15)\gg 3) \end{aligned}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ9.png)(1.9)![$$\begin{aligned}
    S_1= &amp; {} S^{17} (W(i-2)) \,\text{ XOR }\,S^{19}(W(i-2)) \,\text{ XOR }\,(W(i-2)\gg
    10) \end{aligned}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ10.png)(1.10)![$$\begin{aligned}
    W(i)= &amp; {} W(i-16) + S_0 + W(i-7)+ S_1\ \end{aligned}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ11.png)(1.11)where
    ![$$S^i(X)=(X \gg i) \,\text{ OR }\,(X \ll 32-i)$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq127.png).**Step
    3: Mixing up by looping**. Let ![$$A=H_0$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq128.png),
    ![$$B=H_1$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq129.png),
    ![$$C=H_2$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq130.png),
    ![$$D=H_3$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq131.png),
    ![$$E=H_4$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq132.png),
    ![$$F=H_5$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq133.png),
    ![$$G=H_6$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq134.png),
    ![$$H=H_7$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq135.png).
    For ![$$t = 0$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq136.png)
    to 63, iteratively compute![$$\begin{aligned} S1= &amp; {} S^6 (E) \,\text{ XOR
    }\,S^{11 }(E) \,\text{ XOR }\,S^{25}(E) \end{aligned}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ12.png)(1.12)![$$\begin{aligned}
    \text{ CH }= &amp; {} (E \,\text{ AND }\,F)\,\text{ XOR }\,((\text{ NOT }\,E)
    \,\text{ AND }\,G) \end{aligned}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ13.png)(1.13)![$$\begin{aligned}
    \text{ TEMP}_1= &amp; {} H + S1 + \text{ CH } + K(i) + W(i) \end{aligned}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ14.png)(1.14)![$$\begin{aligned}
    S0= &amp; {} S^2(A)~ \,\text{ XOR }\,S^{13} (A)\,\text{ XOR }\,S^{22}(A) \end{aligned}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ15.png)(1.15)![$$\begin{aligned}
    \text{ MAJ }= &amp; {} (A \,\text{ AND }\,B)\,\text{ XOR }\,(A \,\text{ AND }\,C)
    \,\text{ XOR }\,(B \,\text{ AND }\,C)) \end{aligned}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ16.png)(1.16)![$$\begin{aligned}
    \text{ TEMP}_2= &amp; {} S0 + \text{ MAJ }\ \end{aligned}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ17.png)(1.17)where
    ![$$K(0\dots 63) =$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq137.png)'
  prefs: []
  type: TYPE_NORMAL
- en: 428*A*2*F*98, 71374491, *B*5*C*0*FBCF*, *E*9*B*5*DBA*5, 3956*C*25*B*, 59*F*111*F*1,
  prefs: []
  type: TYPE_NORMAL
- en: 923*F*82*A*4, *AB*1*C*5*ED*5, *D*807*AA*98, 12835*B*01, 243185*BE*, 550*C*7*DC*3,
  prefs: []
  type: TYPE_NORMAL
- en: 72*BE*5*D*74, 80*DEB*1*FE*, 9*BDC*06*A*7, *C*19*BF*174, *E*49*B*69*C*1, *EFBE*4786,
  prefs: []
  type: TYPE_NORMAL
- en: 0*FC*19*DC*6, 240*CA*1*CC*, 2*DE*92*C*6*F*, 4*A*7484*AA*, 5*CB*0*A*9*DC*, 76*F*988*DA*,
  prefs: []
  type: TYPE_NORMAL
- en: 983*E*5152, *A*831*C*66*D*, *B*00327*C*8, *BF*597*FC*7, *C*6*E*00*BF*3, *D*5*A*79147,
  prefs: []
  type: TYPE_NORMAL
- en: 06*CA*6351, 14292967, 27*B*70*A*85, 2*E*1*B*2138, 4*D*2*C*6*DFC*, 53380*D*13,
  prefs: []
  type: TYPE_NORMAL
- en: 650*A*7354, 766*A*0*ABB*, 81*C*2*C*92*E*, 92722*C*85, *A*2*BFE*8*A*1, *A*81*A*664*B*,
  prefs: []
  type: TYPE_NORMAL
- en: '*C*24*B*8*B*70, *C*76*C*51*A*3, *D*192*E*819, *D*6990624, *F*40*E*3585, 106*AA*070,'
  prefs: []
  type: TYPE_NORMAL
- en: 19*A*4*C*116, 1*E*376*C*08, 2748774*C*, 34*B*0*BCB*5, 391*C*0*CB*3, 4*ED*8*AA*4*A*,
  prefs: []
  type: TYPE_NORMAL
- en: 5*B*9*CCA*4*F*, 682*E*6*FF*3, 748*F*82*EE*, 78*A*5636*F*, 84*C*87814, 8*CC*70208,
  prefs: []
  type: TYPE_NORMAL
- en: 90*BEFFFA*, *A*4506*CEB*, *BEF*9*A*3*F*7, *C*67178*F*2.
  prefs: []
  type: TYPE_NORMAL
- en: Then let ![$$H=G$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq138.png),
    ![$$G=F$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq139.png),
    ![$$F=E$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq140.png),
    ![$$E=D+\text{ TEMP}_1$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq141.png),
    ![$$D=C$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq142.png),
    ![$$C=B$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq143.png),
    ![$$B=A$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq144.png),
    ![$$A=\text{ TEMP}_1+\text{ TEMP}_2$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq145.png).
  prefs: []
  type: TYPE_NORMAL
- en: Each loop can be illustrated with Fig. [1.9](#Fig9).![](../images/516136_1_En_1_Chapter/516136_1_En_1_Fig9_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Image shows S H A - 2 computation. It consists of C h, uppercase sigma 1, M
    a and uppercase sigma 0\.
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 1.9
  prefs: []
  type: TYPE_NORMAL
- en: SHA-2 computation
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 4: Output**. Let ![$$H_0 = H_0 + A, H_1 = H_1 + B, H_2 = H_2 + C, H_3
    = H_3 + D, H_4 = H_4 \,{+}\, E, H_5=H_5\,{+}\,F, H_6=H_6+G, H_7=H_7+H$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq146.png).
    Repeatedly execute the above Steps 1–4 for other 512-bit blocks ![$$M(2), M(3),
    \dots , M(n)$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq147.png).
    The final output ![$$H_0, H_1,H_2,H_3, H_4$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq148.png)
    is the hash digest of the message.'
  prefs: []
  type: TYPE_NORMAL
- en: The SHA-2 hash function is implemented in some widely used security applications
    and protocols, including TLS and SSL, PGP, SSH, S/MIME, and IPsec.
  prefs: []
  type: TYPE_NORMAL
- en: Several cryptocurrencies, including Bitcoin, use SHA-256 for verifying transactions
    and calculating proof of work or proof of stake.
  prefs: []
  type: TYPE_NORMAL
- en: 1.4 Elliptic Curve Cryptography
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Elliptic-curve cryptography (ECC) is an approach to public-key cryptography
    based on the algebraic structure of elliptic curves over finite fields. ECC allows
    smaller keys compared to non-EC cryptography (based on plain Galois fields) to
    provide equivalent security. Bitcoin, for example, uses ECC as its public key
    cryptosystem because it is lightweight.
  prefs: []
  type: TYPE_NORMAL
- en: 1.4.1 Elliptic Curves over the Real Numbers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In mathematics, an elliptic curve is a smooth, projective, algebraic curve of
    genus one, on which there is a specified point *O*. An elliptic curve is defined
    over a field *K* and describes points in ![$$K^2$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq149.png),
    the Cartesian product of *K* with itself. If the field’s characteristic is different
    from 2 and 3, then the curve can be described as a plane algebraic curve which,
    after a linear change of variables, consists of solutions (*x*, *y*) to the equation
    ![$$y^{2} = x^{3}+ax+b$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq150.png)
    for some coefficients *a* and *b* in *K*. The curve is required to be non-singular,
    which means that the curve has no cusps or self-intersections. (This is equivalent
    to the inequality ![$$4a^{3}+27b^{2}\ne 0$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq151.png).)
    It is always understood that the curve is really sitting in the projective plane,
    with the point *O* to be the unique point at infinity. Many sources define an
    elliptic curve as a curve given by an equation of this form.
  prefs: []
  type: TYPE_NORMAL
- en: An elliptic curve is an abelian variety. This means that it has a group law
    defined algebraically, with respect to which it is an abelian group, where *O*
    serves as the identity element.
  prefs: []
  type: TYPE_NORMAL
- en: Although the formal definition of an elliptic curve requires some background
    in algebraic geometry, it is possible to describe some features of elliptic curves
    over the real numbers using only introductory algebra and geometry. In this context,
    an elliptic curve is a plane curve defined by an equation of the form![$$\begin{aligned}
    y^2&amp;=x^3 + ax + b \end{aligned}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ18.png)(1.18)after
    a linear change of variables (*a* and *b* are real numbers). This type of equation
    is called a *Weierstrass equation*.The definition of an elliptic curve also requires
    that the curve be non-singular. Geometrically, this means that the graph has no
    cusps, self-intersections, or isolated points. Algebraically, this holds if and
    only if the discriminant![$$\begin{aligned} \Delta&amp;= -16(4a^3 + 27b^2) \end{aligned}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ19.png)(1.19)is
    not equal to zero.The (real) graph of a non-singular curve has two components
    if its discriminant is positive, and one component if it is negative. For example,
    in the graphs shown in Fig. [1.10](#Fig10), the discriminant in the first case
    is 64, and in the second case it is −368.![](../images/516136_1_En_1_Chapter/516136_1_En_1_Fig10_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Two graphs, both consists of elliptic curves, representing y superscript 2,
    equals x superscript 3 minus x and y superscript 2, equals x superscript 3 minus
    x plus 1 respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 1.10
  prefs: []
  type: TYPE_NORMAL
- en: Elliptic curves over the real numbers
  prefs: []
  type: TYPE_NORMAL
- en: 1.4.2 The Group Law
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When working in the projective plane, we can define a group structure on any
    smooth cubic curve.
  prefs: []
  type: TYPE_NORMAL
- en: Since the curve is symmetrical about the *x*-axis, given any point *P*, we can
    take ![$$-P$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq152.png)
    to be the point opposite to it. We take ![$$-O$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq153.png)
    to be just *O*. If *P* and *Q* are two points on the curve, then we can uniquely
    describe a third point ![$$P + Q$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq154.png)
    in the following way. First, draw the line that intersects *P* and *Q*. This line
    will generally intersect the cubic at a third point *R*. We then take ![$$P +
    Q$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq155.png) to
    be ![$$-R$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq156.png),
    the point opposite *R*. This definition for addition works except in a few special
    cases related to the point at infinity and the intersection multiplicity. The
    first exception occurs when one of the points is *O*. Then, we define ![$$P +
    O = P = O + P$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq157.png),
    making *O* the identity of the group. Next, if *P* and *Q* are the opposites of
    each other, we define ![$$P + Q = O$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq158.png).
    Finally, if ![$$P = Q$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq159.png),
    then we only have one point and we cannot define a unique line through these points.
    In this case, we use the tangent line to the curve at this point as our line.
    In most cases, the tangent will intersect a second point *R* and we can take its
    opposite. However, if *P* happens to be an inflection point (a point where the
    concavity of the curve changes), then we take *R* to be *P* itself and ![$$P +
    P$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq160.png) is
    simply the point opposite to itself. The group law is illustrated in Fig. [1.11](#Fig11).![](../images/516136_1_En_1_Chapter/516136_1_En_1_Fig11_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Four graph depict elliptic curve group law, representing P plus Q plus R equal
    0, P plus Q plus Q equal 0, P plus Q plus 0 equal 0, P plus P plus 0 equal 0.
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 1.11
  prefs: []
  type: TYPE_NORMAL
- en: Elliptic curve group law
  prefs: []
  type: TYPE_NORMAL
- en: 'The above group can be described algebraically as well as geometrically. Given
    the curve ![$$y^2 = x^3 + ax + b$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq161.png)
    over the field *K* and points ![$$P = (x_P, y_P)$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq162.png)
    and ![$$Q = (x_Q, y_Q)$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq163.png)
    on the curve, assume first that ![$$x_P \not = x_Q$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq164.png)
    (the first pane above). Let us define ![$$R=(x_R,y_R)=P+Q$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq165.png).
    Compute![$$\begin{aligned} \lambda&amp;= \frac{y_P-y_Q}{x_P-x_Q}, \end{aligned}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ20.png)(1.20)![$$\begin{aligned}
    x_R&amp;= \lambda ^2-x_P-x_Q, \end{aligned}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ21.png)(1.21)![$$\begin{aligned}
    y_R&amp;=y_P+\lambda (x_R-x_P). \end{aligned}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ22.png)(1.22)If
    ![$$x_P = x_Q$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq166.png),
    then there are two options: if ![$$y_P = -y_Q$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq167.png)
    (the third and fourth panes above), including the case where ![$$y_P = y_Q = 0$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq168.png)
    (the fourth pane), then the sum is defined as 0\. Thus, the inverse of each point
    on the curve is found by reflecting it across the x-axis. If ![$$y_P = y_Q \not
    = 0$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq169.png),
    then ![$$Q = P$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq170.png)
    and ![$$R = (x_R, y_R)=2P$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq171.png)
    (the second pane above with *P* shown for *R*) is given by![$$\begin{aligned}
    \lambda&amp;= \frac{3x_P^2+a}{2y_P}, \end{aligned}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ23.png)(1.23)![$$\begin{aligned}
    x_R&amp;= \lambda ^2-2x_P, \end{aligned}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ24.png)(1.24)![$$\begin{aligned}
    y_R&amp;= y_P+\lambda (x_R-x_P). \end{aligned}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ25.png)(1.25)'
  prefs: []
  type: TYPE_NORMAL
- en: 1.4.3 Elliptic Curves over Finite Fields
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let ![$$K = F_q$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq172.png)
    be the finite field with *q* elements, and let *E* be an elliptic curve over *K*.
    While the precise number of rational points of an elliptic curve *E* over *K*
    is in general rather difficult to compute, Hasse’s theorem on elliptic curves
    gives us the following estimate (including the point at infinity):![$$\begin{aligned}
    |\#E(K)-(q+1)| \le 2 \sqrt{q}. \end{aligned}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ26.png)(1.26)It
    follows that the number of points of the curve grows approximately as the number
    of elements in the field.The set of points *E*(*Fq*) is a finite abelian group.
    It is always cyclic or the product of two cyclic groups. For example, the curve
    defined by![$$\begin{aligned} y^{2}=x^{3}-x \end{aligned}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ27.png)(1.27)over
    ![$$F_{71}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq173.png)
    has 72 points (71 affine points including (0, 0) and one point at infinity) over
    this field, as shown in Fig. [1.12](#Fig12).![](../images/516136_1_En_1_Chapter/516136_1_En_1_Fig12_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: A scatterplot of a set of affine points of an elliptic curve, Y superscript
    2 equals x superscript 3 minus x, over the finite F superscript 71\. The x and
    y axis range from 0 to 72.
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 1.12
  prefs: []
  type: TYPE_NORMAL
- en: Set of affine points of elliptic curve ![$$y^2 = x^3 - x$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq174.png)
    over the finite field ![$$F_{71}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq175.png)
  prefs: []
  type: TYPE_NORMAL
- en: 1.4.4 Elliptic Curve Digital Signature Algorithm (ECDSA)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In cryptography, the Elliptic Curve Digital Signature Algorithm (ECDSA) offers
    a variant of the Digital Signature Algorithm (DSA) which uses elliptic curve cryptography.
    ECDSA comprises three algorithms described as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '**Key Generation**. First, the curve parameters (![$$\text{ CURVE }, G, n$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq176.png))
    are chosen. In addition to the field and equation of the curve, the algorithm
    requires to fix a base point *G* of prime order on the curve. The number *n* is
    the multiplicative order of the point *G*. The order *n* of the base point *G*
    must be prime.'
  prefs: []
  type: TYPE_NORMAL
- en: Alice creates a key pair consisting of a private key integer ![$$d_A$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq177.png)
    randomly selected in the interval ![$$[1,n-1]$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq178.png),
    and a public key curve point ![$$Q_A = d_A \times G$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq179.png).
    Here ![$$\times $$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq180.png)
    denotes a multiplication of the elliptic curve point by a scalar. The point ![$$Q_A$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq181.png)
    is published while ![$$d_A$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq182.png)
    is kept secret by Alice.
  prefs: []
  type: TYPE_NORMAL
- en: '**Signature Generation**. To sign a message *m*, Alice proceeds as follows.'
  prefs: []
  type: TYPE_NORMAL
- en: '1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compute ![$$e = \mathsf {hash}(m)$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq183.png).
    (Here ![$$\mathsf {hash}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq184.png)
    is a cryptographic hash function, such as SHA-2, with the output converted to
    an integer.)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Denote by ![$$L_n$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq185.png)
    is the bit length of the group order *n*, and let *z* be the ![$$L_{n}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq186.png)
    leftmost bits of *e*. (Note that *z* can be greater than *n* but should not be
    longer in binary notation.)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '3.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select a cryptographically secure random integer *k* from ![$$[1,n-1]$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq187.png).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 4.Compute the curve point![$$\begin{aligned} (x_{1},y_{1})=k\times G. \end{aligned}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ28.png)(1.28)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 5.Calculate![$$\begin{aligned} r=x_{1} (\text {mod}~ n). \end{aligned}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ29.png)(1.29)If
    ![$$r=0$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq188.png),
    go back to step 3.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 6.Calculate![$$\begin{aligned} s=k^{-1}(z+rd_{A}) (\text {mod}~ n). \end{aligned}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ30.png)(1.30)If
    ![$$s=0$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq189.png),
    go back to step 3.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '7.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The signature is the pair (*r*, *s*).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Signature Verification**. For Bob to authenticate Alice’s signature, he must
    have a copy of her public-key curve point ![$$Q_A$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq190.png).
    Bob can verify that ![$$Q_A$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq191.png)
    is a valid curve point as follows.'
  prefs: []
  type: TYPE_NORMAL
- en: '1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check that ![$$Q_A$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq192.png)
    is not equal to the identity element *O* and its coordinates are otherwise valid.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check that ![$$Q_A$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq193.png)
    lies on the curve.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '3.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check that ![$$n\times Q_A = O$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq194.png).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If ![$$Q_A$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq195.png)
    is a valid curve point, Bob continues to verify the signature as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify that *r* and *s* are integers in ![$$[1, n-1]$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq196.png).
    If not, the signature is invalid.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compute ![$$e=\mathsf {hash}(m)$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq197.png),
    where ![$$\mathsf {hash}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq198.png)
    is the same function used in the signature generation. Denote by *z* the ![$$L_{n}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq199.png)
    leftmost bits of *e*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 3.Calculate![$$\begin{aligned} u_{1}=zs^{-1} (\text {mod}~ n), \end{aligned}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ31.png)(1.31)![$$\begin{aligned}
    u_{2}=rs^{-1}(\text {mod} ~n). \end{aligned}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ32.png)(1.32)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 4.Compute the curve point![$$\begin{aligned} (x_1,y_1) = u_1 \times G+u_2 \times
    Q_A. \end{aligned}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ33.png)(1.33)If
    ![$$(x_1,y_1) = O$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq200.png)
    then the signature is invalid.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '5.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The signature is valid if ![$$r = x_1 (\text {mod} ~n)$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq201.png),
    and is invalid otherwise.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 1.4.5 ECDSA Versus RSA
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To provide the same level of security, ECC requires much shorter key lengths
    than RSA does. The following table shows a comparison of ECDSA and RSA.
  prefs: []
  type: TYPE_NORMAL
- en: '| Security (bits) | RSA key length required (bits) | ECC key length required
    (bits) |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 80 | 1024 | 160–223 |'
  prefs: []
  type: TYPE_TB
- en: '| 112 | 2048 | 224–255 |'
  prefs: []
  type: TYPE_TB
- en: '| 128 | 3072 | 256–383 |'
  prefs: []
  type: TYPE_TB
- en: '| 192 | 7680 | 384–511 |'
  prefs: []
  type: TYPE_TB
- en: '| 256 | 15,360 | 512+ |'
  prefs: []
  type: TYPE_TB
