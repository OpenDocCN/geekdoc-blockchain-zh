- en: © The Author(s), under exclusive license to Springer Nature Switzerland AG 2022X.
    Yi et al.Blockchain Foundations and ApplicationsSpringerBriefs in Applied Sciences
    and Technology[https://doi.org/10.1007/978-3-031-09670-9_1](https://doi.org/10.1007/978-3-031-09670-9_1)
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: © 作者（们），在Springer Nature Switzerland AG独家授权2022年X. Yi 等。区块链基础与应用Springer应用科学与技术简报[https://doi.org/10.1007/978-3-031-09670-9_1](https://doi.org/10.1007/978-3-031-09670-9_1)
- en: 1. Cryptographic Primitives
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1. 密码学基本元素
- en: 'Xun Yi^([1](#Aff6) [ ](#ContactOfAuthor6)), Xuechao Yang^([1](#Aff6) [ ](#ContactOfAuthor7)),
    Andrei Kelarev^([1](#Aff6) [ ](#ContactOfAuthor8)), Kwok Yan Lam^([2](#Aff7) [ ](#ContactOfAuthor9))
    and Zahir Tari^([1](#Aff6) [ ](#ContactOfAuthor10))(1)School of Computing Technologies,
    RMIT University, Melbourne, VIC, Australia(2)School of Computer Science and Engineering,
    Nanyang Technological University, Singapore, SingaporeXun Yi (Corresponding author)Email:
    [xun.yi@rmit.edu.au](mailto:xun.yi@rmit.edu.au)Xuechao YangEmail: [xuechao.yang@rmit.edu.au](mailto:xuechao.yang@rmit.edu.au)Andrei KelarevEmail:
    [andrei.kelarev@gmail.com](mailto:andrei.kelarev@gmail.com)Kwok Yan LamEmail:
    [kwokyan.lam@ntu.edu.sg](mailto:kwokyan.lam@ntu.edu.sg)Zahir TariEmail: [zahir.tari@rmit.edu.au](mailto:zahir.tari@rmit.edu.au)'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 许**毅**^([1](#Aff6) [ ](#ContactOfAuthor6))，杨**学超**^([1](#Aff6) [ ](#ContactOfAuthor7))，安德烈**基拉耶夫**^([1](#Aff6)
    [ ](#ContactOfAuthor8))，林**耀坚**^([2](#Aff7) [ ](#ContactOfAuthor9)) 和 **塔里**^([1](#Aff6)
    [ ](#ContactOfAuthor10))（1）澳大利亚墨尔本RMIT大学计算机技术学院（2）新加坡南洋理工大学计算机科学与工程学院**许**毅**（通讯作者）电子邮件：**[xun.yi@rmit.edu.au](mailto:xun.yi@rmit.edu.au)**杨**学超**电子邮件：**[xuechao.yang@rmit.edu.au](mailto:xuechao.yang@rmit.edu.au)**基拉耶夫**安德烈**电子邮件：**[andrei.kelarev@gmail.com](mailto:andrei.kelarev@gmail.com)**林**耀坚**电子邮件：**[kwokyan.lam@ntu.edu.sg](mailto:kwokyan.lam@ntu.edu.sg)**塔里**扎希**电子邮件：**[zahir.tari@rmit.edu.au](mailto:zahir.tari@rmit.edu.au)
- en: 1.1 Secret Key Cryptosystems
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.1 秘密密钥加密系统
- en: 1.1.1 Secret Key Cryptosystem Model
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1.1 秘密密钥加密系统模型
- en: A secret key cryptosystem is an encryption system that uses secret keys for
    the encryption of plaintext and decryption of ciphertext. The keys may be identical
    or there may be two different keys and a simple transformation to go between them.
    The keys, in practice, represent a shared secret between two or more parties that
    can be used to maintain a private information link.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 秘密密钥加密系统是一种加密系统，使用秘密密钥对明文进行加密和对密文进行解密。密钥可能相同，也可能有两个不同的密钥和一个简单的转换方法。在实践中，密钥代表两个或更多方之间的共享秘密，可用于维护私人信息链接。
- en: The first systematic information-theoretic study of secret key cryptosystems
    can be found in Shannon’s classical paper “Communication Theory of Secrecy Systems” [[7](#CR7)].
    It gave a secret key encryption model as shown in Fig. [1.1](#Fig1).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 秘密密钥加密系统的第一个系统信息理论研究可以在香农的经典论文“通信理论的保密系统”[[7](#CR7)]中找到。它给出了一个秘密密钥加密模型，如图 [1.1](#Fig1)
    所示。
- en: Prior to transmission of a plaintext *P*, the sender and the recipient need
    to exchange a shared secret key *K* or to receive it from a trusted key source.
    This key is used by the sending side to encrypt a plaintext *P*, obtaining a ciphertext
    *C*, which is delivered to the receiving side and may be intercepted by an enemy
    eavesdropper. The receiver then uses the key *K* in order to reconstruct the clear
    plaintext *P*.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在明文 *P* 传输之前，发送方和接收方需要交换一个共享密钥 *K*，或者从可信密钥源接收它。发送方使用该密钥加密明文 *P*，产生密文 *C*，交付给接收方，可能会被敌方窃听者拦截。接收方然后使用密钥
    *K* 以便重建明文 *P*。
- en: 1.1.2 Advanced Encryption Standard
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1.2 高级加密标准
- en: The Data Encryption Standard (DES) is a secret key cryptosystem for the encryption
    of electronic data developed in the early 1970s at IBM and based on an earlier
    design by Horst Feistel [[6](#CR6)]. The algorithm was submitted to the National
    Bureau of Standards (NBS) following the agency’s invitation to propose a candidate
    for the protection of sensitive, unclassified electronic government data. In 1976,
    after consultation with the National Security Agency (NSA), the NBS eventually
    selected a slightly modified version, which was published as an official Federal
    Information Processing Standard (FIPS) for the United States in 1977.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 数据加密标准（DES）是一种在20世纪70年代初由IBM开发的秘密密钥加密系统，用于加密电子数据，其基础是Horst Feistel的早期设计[[6](#CR6)]。该算法在机构邀请提出用于保护敏感、非机密电子政府数据的候选算法后，提交给了国家标准局（NBS）。在1976年与国家安全局（NSA）咨询后，NBS最终选择了一个略有修改的版本，该版本于1977年作为美国的官方联邦信息处理标准（FIPS）发布。
- en: DES and its variations have been widely used for more than 40 years. The main
    problem of the DES algorithm was its relatively short secret key, with ![$$2^{56}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq1.png)
    possible keys. Although this a fairly large number, sufficient computational resources
    make a brute force attacks on DES feasible. The so-called DES challenges, where
    a large number of computers connected to the Internet exhaustively searched the
    key space, demonstrated this is a dramatical weakness. The first DES challenge
    in 1997 was completed in 4.5 months, the second in 1998 in 39 days and the third
    and final DES challenge in 1999 was completed in less than a day (22.5 h).![](../images/516136_1_En_1_Chapter/516136_1_En_1_Fig1_HTML.png)
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: DES及其变种已经被广泛使用超过40年。DES算法的主要问题是它的密钥相对较短，只有![$$2^{56}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq1.png)种可能的密钥。尽管这个数字相当大，但足够的计算资源使得对DES的暴力攻击变得可行。所谓的DES挑战，就是大量连接到互联网的计算机
    exhaustively搜索密钥空间，这证明了这是一个剧烈的弱点。1997年的第一次DES挑战用了4.5个月完成，1998年的第二次用了39天，1999年的第三次也是最后一次DES挑战在不到一天内（22.5小时）完成。![](../images/516136_1_En_1_Chapter/516136_1_En_1_Fig1_HTML.png)
- en: Image reflects the secret key encryption model, it consists of sender, encrypt,
    decrypt, recipient, plaintext, and ciphertext.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 图反映了密钥加密模型，它包括发送方、加密、解密、接收方、明文和密文。
- en: Fig. 1.1
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Fig. 1.1
- en: Secret key encryption model
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 密钥加密模型
- en: In 1997, the US National Institute of Standards and Technology (NIST) started
    a public competition to select an algorithm for replacing DES. The algorithm was
    required to support key sizes of 128, 192, and 256 bits and to be free of any
    patents. The selection process consisted of several rounds where candidate algorithms
    were evaluated. At the end of the first round in August 1998, 15 algorithms were
    accepted as candidates. In the next round in August 1999, the candidates were
    reduced to five finalist algorithms (MARS, Blowfish, RC6, Rijndael, Serpent).
    Finally, in April 2000 the Rijndael algorithm was selected as the winner. On 2
    October 2000, NIST officially announced that Rijndael had been chosen as Advanced
    Encryption Standard (AES) [[2](#CR2)].
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 1997年，美国国家标准与技术研究院（NIST）启动了一场公开竞赛，以选择一个替代DES的算法。该算法需要支持128、192和256位的密钥大小，并且不得受任何专利的限制。选拔过程包括几个回合，在这些回合中，候选算法得到了评估。到了1998年8月第一轮结束时，有15个算法被接受为候选人。在接下来1999年8月的第二轮中，候选算法被减少到了五个最终候选算法（MARS，Blowfish，RC6，Rijndael，Serpent）。最终，在2000年4月，Rijndael算法被选为胜者。2000年10月2日，NIST正式宣布Rijndael已被选为高级加密标准（AES）
    [[2](#CR2)]。
- en: The AES algorithm operates on 128-bit data blocks supporting three different
    key sizes of 128, 192 and 256\. These three flavours of the AES algorithm are
    also referred to as AES-128, AES-192 and AES-256, for 128, 192, and 256-bit keys,
    respectively. An AES encryption process consists of a number of encryption rounds
    (Nr) that depends on the size of the key. The standard calls for 10 rounds for
    AES-128, 12 rounds for a AES-192, and 14 rounds for a AES-256.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: AES算法对128位数据块进行操作，支持三种不同密钥大小：128、192和256。这三个AES算法的版本也分别称为AES-128、AES-192和AES-256，对应于128、192和256位的密钥，
    respectively. AES加密过程包括多个加密轮次（Nr），这取决于密钥的大小。标准要求AES-128需要10轮加密，AES-192需要12轮，AES-256需要14轮。
- en: During encryption, each round is composed of a set of four basic operations.
    The decryption process applies the inverse of these operations in reverse order.
    Figure [1.2](#Fig2) shows the basic structure of the AES-128 encryption and decryption.![](../images/516136_1_En_1_Chapter/516136_1_En_1_Fig2_HTML.png)
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在加密过程中，每一轮都由一组四个基本操作组成。解密过程应用这些操作的逆序。图[1.2](#Fig2) 展示了AES-128加密和解密的基本结构。![](../images/516136_1_En_1_Chapter/516136_1_En_1_Fig2_HTML.png)
- en: Image represents the encryption and decryption of the basic structure of the
    advanced encryption standard.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图表示高级加密标准的基本结构的加密和解密。
- en: Fig. 1.2
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Fig. 1.2
- en: Encryption and decryption of AES-128
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: AES-128的加密和解密
- en: AES operates on a ![$$4\times 4$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq2.png)
    column-major order matrix of bytes, termed the state, as shown in Fig. [1.3](#Fig3),
    where the element ![$$S_{r,c}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq3.png)
    is an 8-bit value that corresponds to row *r* and column *c* of the state. Most
    AES calculations are done in a special finite field.![](../images/516136_1_En_1_Chapter/516136_1_En_1_Fig3_HTML.png)
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: AES 操作的是一个 ![$$4\times 4$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq2.png)
    列优先的矩阵字节，称为状态，如图 [1.3](#Fig3) 所示，其中元素 ![$$S_{r,c}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq3.png)
    是一个 8 位的值，对应于状态的行 *r* 和列 *c*。AES 的大多数计算都是在特殊的有限域中进行的。![](../images/516136_1_En_1_Chapter/516136_1_En_1_Fig3_HTML.png)
- en: a table consists of 4 columns and 4 rows. The first column starts with S subscript
    0,0 and ends with S subscript 3,0\. Similar pattern is followed in other three
    columns.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一个表由 4 列和 4 行组成。第一列从 S 脚标 0,0 开始，以 S 脚标 3,0 结束。其他三列遵循类似的模式。
- en: Fig. 1.3
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.3
- en: State of AES
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: AES 的状态
- en: Next, we present a high-level description of the main operations of the AES
    algorithm.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们提供一个高级描述，描述 AES 算法的主要操作。
- en: '**KeyExpansion**. Round keys are derived from the key using AES key schedule.
    AES requires a separate 128-bit round key block for each round plus one more.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**KeyExpansion**。轮密钥是通过 AES 密钥计划从密钥派生的。AES 需要为每个轮次加一额外的一个 128 位的轮密钥块。'
- en: '**InitialRound**.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**InitialRound**。'
- en: '**AddRoundKey**. Each byte of the state is combined with a block of the round
    key using bitwise ![$$\,\text{ XOR }\,$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq4.png)
    operation.'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**AddRoundKey**。状态的每个字节与轮密钥的一个块使用位异或操作结合。'
- en: '**Rounds**.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Rounds**。'
- en: '**SubBytes** is a non-linear substitution step where each byte is replaced
    with another according to a lookup table.'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**SubBytes** 是一个非线性替换步骤，其中每个字节根据查找表用另一个字节替换。'
- en: '**ShiftRows** is a transposition step where the last three rows of the state
    are shifted cyclically a certain number of steps.'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**ShiftRows** 是一个置换步骤，其中状态的最后三行按一定步数循环移动。'
- en: '**MixColumns** is a mixing operation which operates on the columns of the state,
    combining four bytes in each column. The MixColumns operations of the AES encryption
    and AES decryption are illustrated in Fig. [1.4](#Fig4).'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**MixColumns** 是对状态的列进行的混合操作，每个列中结合四个字节。AES 加密和 AES 解密的混合列操作分别如图 [1.4](#Fig4)
    所示。'
- en: '**AddRoundKey**.'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**AddRoundKey**。'
- en: '**Final Round** (without MixColumns).'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Final Round**（不包含混合列）。'
- en: '**SubBytes**.'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**SubBytes**。'
- en: '**ShiftRows**.'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**ShiftRows**。'
- en: '**AddRoundKey**.'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**AddRoundKey**。'
- en: '![](../images/516136_1_En_1_Chapter/516136_1_En_1_Fig4_HTML.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/516136_1_En_1_Chapter/516136_1_En_1_Fig4_HTML.png)'
- en: Image reflects the mix columns of advanced encryption standard encryption and
    decryption. Mix Columns is a mixing operation that operates on the columns of
    the state, combining four bytes in each column.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图反映了高级加密标准加密和解密的混合列。混合列是对状态的列进行的混合操作，每个列中结合四个字节。
- en: Fig. 1.4
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.4
- en: The MixColumns of AES encryption and decryption
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: AES 加密和解密的混合列
- en: 'The National Security Agency (NSA) reviewed all the AES finalists, including
    Rijndael, and stated that all of them were secure enough for U.S. Government non-classified
    data. In June 2003, the U.S. Government announced that AES could be used to protect
    classified information: “The design and strength of all key lengths of the AES
    algorithm (i.e., 128, 192 and 256) are sufficient to protect classified information
    up to the SECRET level. TOP SECRET information will require use of either the
    192 or 256 key lengths. The implementation of AES in products intended to protect
    national security systems and/or information must be reviewed and certified by
    NSA prior to their acquisition and use.” Until 2009, the only successful published
    attacks against the full AES were side-channel attacks on some specific implementations.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 美国国家安全局（NSA）审查了所有 AES 决赛选手，包括 Rijndael，并表示它们都足够安全，可用于美国政府的非机密数据。2003 年 6 月，美国政府宣布
    AES 可以用来保护机密信息：“AES 算法（即 128 位、192 位和 256 位）的所有密钥长度的设计和强度都足以保护机密信息至秘密级别。绝密信息将需要使用
    192 位或 256 位密钥长度。旨在保护国家安全系统及/或信息的产品中 AES 的实现必须在其获取和使用之前由 NSA 审查并认证。”直到 2009 年，针对完整
    AES 的唯一成功的公开攻击是对某些特定实现的双通道攻击。
- en: 1.2 Public Key Cryptosystem
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.2 公钥密码系统
- en: Public key cryptosystems include public key encryption algorithms and digital
    signature algorithms.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 公钥密码系统包括公钥加密算法和数字签名算法。
- en: 1.2.1 Public Key Encryption Model
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.1 公钥加密模型
- en: In a secret key cryptosystem, two parties would rely upon a key that they would
    exchange between themselves by means of a secure method. For example, a face-to-face
    meeting or an exchange via a trusted courier could be used. This key, which both
    parties keep absolutely secret, can then be used to exchange encrypted messages.
    A number of significant practical difficulties arise with this approach to distributing
    keys. Public key encryption addresses these drawbacks so that users can communicate
    securely over a public channel without having to agree upon a shared key beforehand.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在秘密密钥加密系统中，两个方会依赖于一个他们通过安全方式相互交换的密钥。例如，面对面会议或通过可信信使交换都可以使用。这个双方绝对保密保持的密钥，然后可以用来交换加密信息。这种密钥分发方法有几个显著的实践难题。公钥加密解决了这些缺点，使得用户可以在不需要事先商定共享密钥的情况下，通过公共通道安全地通信。
- en: The public key encryption model, as shown in Fig. [1.5](#Fig5), was published
    in 1976 by Whitfield Diffie and Martin Hellman [[3](#CR3)] who, influenced by
    Ralph Merkle’s work on public-key distribution, proposed a method of public-key
    agreement.![](../images/516136_1_En_1_Chapter/516136_1_En_1_Fig5_HTML.png)
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 公钥加密模型，如图[1.5](#Fig5)所示，是由Whitfield Diffie和Martin Hellman于1976年提出的[[3](#CR3)]，他们受到了Ralph
    Merkle关于公钥分发的作品的启发，提出了一种公钥协商方法。![](../images/516136_1_En_1_Chapter/516136_1_En_1_Fig5_HTML.png)
- en: Image represents the public key encryption model. The public key is used to
    encrypt plaintext, whereas the private key is used to decrypt the ciphertext.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图示代表了公钥加密模型。公钥用于加密明文，私钥用于解密密文。
- en: Fig. 1.5
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.5
- en: Public key encryption model
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 公钥加密模型
- en: Public key encryption, also called asymmetric key encryption, is a class of
    algorithms which require two separate keys, one of which is secret (or private)
    and another one is public. Although these two keys are different, they form a
    key pair and are mathematically linked. The public key is used to encrypt plaintext,
    whereas the private key is used to decrypt ciphertext. The term “asymmetric” stems
    from the use of different keys to perform these opposite functions, each the inverse
    of the other—as contrasted with the conventional (“symmetric key”) encryption
    relying on the same key to perform both.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 公钥加密，也称为非对称密钥加密，是一类需要两个不同密钥的算法，其中一个保密（或私有的），另一个是公开的。尽管这两个密钥不同，但它们形成一个密钥对，并且在数学上是相关的。公钥用于加密明文，私钥用于解密密文。术语“非对称”源于使用不同的密钥来执行这些相反的功能，每个都是另一个的逆——与传统的（“对称密钥”）加密形成对比，后者依赖于相同的密钥来执行两个操作。
- en: In general, a public key encryption algorithm, associated with a key space ![$$\mathbf{K}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq5.png),
    a plaintext space ![$$\mathbf{M}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq6.png)
    and a ciphertext space ![$$\mathbf{C}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq7.png),
    consists of the following three algorithms.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，与一个密钥空间![$$\mathbf{K}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq5.png)、明文空间![$$\mathbf{M}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq6.png)和密文空间![$$\mathbf{C}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq7.png)相关的公钥加密算法包括以下三个算法。
- en: 'Key generation algorithm (KG): Given a security parameter *k*, a public and
    private key pair ![$$(\mathsf {pk},\mathsf {sk})$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq8.png)
    is generated, where ![$$\mathsf {sk}\in \mathbf{K}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq9.png).
    The public key ![$$\mathsf {pk}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq10.png)
    is published to the public, while the private key ![$$\mathsf {sk}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq11.png)
    is known to its owner only.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密钥生成算法（KG）：给定一个安全参数*k*，生成一个公钥和私钥对![$$(\mathsf {pk},\mathsf {sk})$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq8.png)，其中![$$\mathsf
    {sk}\in \mathbf{K}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq9.png)。公钥![$$\mathsf
    {pk}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq10.png)公布于众，而私钥![$$\mathsf
    {sk}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq11.png)只有其所有者知道。
- en: 'Encryption algorithm (*E*): Given a plaintext ![$$m\in \mathbf{M}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq12.png)
    and a public key ![$$\mathsf {pk}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq13.png),
    a ciphertext *c* is produced, denoted as ![$$c=E(m,\mathsf {pk})$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq14.png),
    where ![$$c\in \mathbf{C}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq15.png).'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '加密算法(*E*): 给定明文 ![$$m\in \mathbf{M}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq12.png)
    和公钥 ![$$\mathsf {pk}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq13.png)，产生密文
    *c*，表示为 ![$$c=E(m,\mathsf {pk})$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq14.png)，其中
    ![$$c\in \mathbf{C}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq15.png)。'
- en: 'Decryption algorithm (*D*): Given a ciphertext ![$$c=E(m,\mathsf {pk})$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq16.png)
    and the private key ![$$\mathsf {sk}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq17.png),
    the plaintext *m* is recovered, denoted as ![$$m=D(c,\mathsf {sk})$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq18.png).'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '解密算法(*D*): 给定密文 ![$$c=E(m,\mathsf {pk})$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq16.png)
    和私钥 ![$$\mathsf {sk}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq17.png)，恢复明文
    *m*，表示为 ![$$m=D(c,\mathsf {sk})$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq18.png)。'
- en: The encryption algorithm *E* is a mapping from the plaintext space ![$$\mathbf{M}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq19.png)
    to the ciphertext space ![$$\mathbf{C}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq20.png).
    It must be a trap-door one-way function. For virtually all ciphertexts ![$$c =
    E(m,\mathsf {pk})$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq21.png),
    it must be computationally infeasible to recover the plaintext *m* from a given
    ![$$\mathsf {pk}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq22.png)
    and *c*. However, since the legitimate recipient of the message must be able to
    recover *m* from *c*, more is required of the one-way function. Namely, each *E*
    must have an inverse *D*, and this inverse must be easily obtainable given some
    additional secret information ![$$\mathsf {sk}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq23.png).
    The extra information ![$$\mathsf {sk}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq24.png)
    is called a *trap-door* of *E* and the function *E* itself is called a *trap-door
    one-way function*. It is also required that, with the knowledge of ![$$\mathsf
    {sk}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq25.png),
    it should be easy to compute ![$$m = D(c,\mathsf {sk})$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq26.png),
    for all *c* in the ciphertext space.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 加密算法 *E* 是明文空间 ![$$\mathbf{M}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq19.png)
    到密文空间 ![$$\mathbf{C}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq20.png)
    的映射。它必须是一个陷门单向函数。对于几乎所有的密文 ![$$c = E(m,\mathsf {pk})$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq21.png)，从给定的
    ![$$\mathsf {pk}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq22.png)
    和 *c* 恢复明文 *m* 必须在计算上不可行。然而，由于消息的合法接收者必须能够从 *c* 恢复 *m*，单向函数还需要更多的要求。具体来说，每个 *E*
    都必须有一个逆函数 *D*，并且这个逆函数必须容易获得一些额外的秘密信息 ![$$\mathsf {sk}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq23.png)。额外的信息
    ![$$\mathsf {sk}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq24.png)
    称为 *E* 的陷门，而函数 *E* 本身称为陷门单向函数。另外，还要求在知道 ![$$\mathsf {sk}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq25.png)
    的情况下，对于密文空间中的所有 *c*，都应该容易计算 ![$$m = D(c,\mathsf {sk})$$](../images/516136_1_
- en: Trap-door functions are based on mathematical problems which currently admit
    no efficient solution. They can involve certain integer factorization, discrete
    logarithms, and elliptic curve relationships. It is computationally easy for a
    user to generate their own public and private key-pair and to use them for encryption
    and decryption. The strength lies in the fact that it is “impossible” (computationally
    infeasible) for a properly generated private key to be determined from its corresponding
    public key. Thus the public key may be published without compromising security,
    whereas the private key must not be revealed to anyone unauthorized to read messages.
    Public key algorithms, unlike secret key algorithms, do not require a secure initial
    exchange of one or more secret keys between the parties.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 陷门函数是基于目前没有有效解决方案的数学问题。它们可能涉及某些整数因式分解、离散对数和椭圆曲线关系。对于用户来说，生成自己的公钥和私钥对并在加密和解密中使用是计算上容易的。其优势在于，对于一个适当生成的私钥，从其对应的公钥确定是“不可能”的（计算上不可行）。因此，公钥可以公布而不损害安全性，而私钥不能透露给任何未经授权阅读消息的人。与秘密密钥算法不同，公钥算法不需要在各方之间安全地交换一个或多个秘密密钥。
- en: 1.2.2 RSA Encryption Algorithm
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.2 RSA加密算法
- en: Diffie and Hellman introduced the great idea of a public key cryptosystem in
    1976, but they did not provide any examples of practical public key cryptosystems.
    In 1977, Ron Rivest, Adi Shamir and Leonard Adleman proposed the first practical
    public key cryptosystem, RSA [[5](#CR5)]. In the RSA encryption algorithm, the
    encryption key is public and is different from the decryption key, which is kept
    secret. The security is based on the practical difficulty of factoring the product
    of two large prime numbers, the factoring problem. An English mathematician Clifford
    Cocks developed an equivalent system in 1973, but it remained classified until
    1997.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 迪菲和赫尔曼在1976年引入了公钥密码系统的大胆想法，但他们没有提供任何实际公钥密码系统的例子。1977年，罗纳德·李维斯特、阿迪·沙米尔和伦纳德·阿德曼提出了第一个实际的公钥密码系统，RSA
    [[5](#CR5)]。在RSA加密算法中，加密密钥是公开的，与保持秘密的解密密钥不同。安全性基于两个大素数乘积的因式分解问题的实际困难。一位英国数学家克利福德·科克斯在1973年开发了一个等效系统，但直到1997年才解密。
- en: 'The RSA encryption algorithm includes three algorithms: key generation, encryption
    and decryption. These algorithms are described as follows.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: RSA加密算法包括三个算法：密钥生成、加密和解密。这些算法如下所述。
- en: '**Key generation**. The RSA requires a public key and a private key. The public
    key can be known to everyone and is used for encrypting messages. Messages encrypted
    with the public key can only be decrypted in a reasonable amount of time using
    the private key. The keys for the RSA algorithm are generated in the following
    way.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**密钥生成**。RSA需要一个公钥和一个私钥。公钥可以被任何人知道，用于加密消息。使用公钥加密的消息只能使用私钥在合理的时间内解密。RSA算法的密钥以以下方式生成。'
- en: '1.'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '1.'
- en: Choose two distinct prime numbers *p* and *q*. For security purposes, the integers
    *p* and *q* should be chosen at random, and should be of similar bit-length. Prime
    integers can be efficiently found using a primality test.
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 选择两个不同的素数*p*和*q*。为了安全起见，整数*p*和*q*应该随机选择，并且应该具有相似的位长度。可以使用素性测试有效地找到素数。
- en: '2.'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '2.'
- en: Compute ![$$n = pq$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq27.png).
    The number *n* is used as a modulus for both the public and private keys. Its
    length, usually expressed in bits, is the key length.
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 计算![$$n = pq$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq27.png)。数*n*作为公钥和私钥的模数。其长度，通常以位表示，是密钥长度。
- en: '3.'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '3.'
- en: Compute ![$$\phi (n) = \phi (p)\phi (q) = (p - 1)(q - 1) = n - (p + q -1)$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq28.png),
    where ![$$\phi $$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq29.png)
    is the Euler’s totient function.
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 计算![$$\phi (n) = \phi (p)\phi (q) = (p - 1)(q - 1) = n - (p + q -1)$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq28.png)，其中![$$\phi
    $$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq29.png)是欧拉函数。
- en: '4.'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '4.'
- en: Choose an integer *e* such that ![$$1&lt; e &lt; \phi (n)$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq30.png)
    and ![$$\,\text{ gcd }(e, \phi (n)) = 1$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq31.png);
    i.e., *e* and ![$$\phi (n)$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq32.png)
    are coprime. The integer *e* is released as the public key exponent. If *e* has
    a short bit-length and small Hamming weight (as, for example, ![$$2^{16} + 1 =
    65,537$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq33.png)),
    then it results in a more efficient encryption. However, much smaller values of
    *e* (such as 3) have been shown to be less secure in some settings [[1](#CR1)].
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 选择一个整数 *e*，使得 ![$$1< e < \phi (n)$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq30.png)
    并且 ![$$\text{ gcd }(e, \phi (n)) = 1$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq31.png);
    也就是说，*e* 和 ![$$\phi (n)$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq32.png)
    是互质的。选定的整数 *e* 被公布为公钥指数。如果 *e* 的位数较短且汉明重量较小（例如，![$$2^{16} + 1 = 65,537$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq33.png)），则加密效率更高。然而，在某些设置中，已经证明
    *e* 取值过小（如 3）会变得不那么安全 [[1](#CR1)].
- en: '5.'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '5.'
- en: Determine *d* as ![$$d = e^{-1} \pmod {\phi (n)}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq34.png);
    i.e., *d* is the multiplicative inverse of ![$$e \pmod {\phi (n)}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq35.png).
    The multiplicative inverse can be computed using the extended Euclidean algorithm.
    The number *d* is used as the private key.
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将 *d* 定义为 ![$$d = e^{-1} \pmod {\phi (n)}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq34.png);
    也就是说，*d* 是 ![$$e \pmod {\phi (n)}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq35.png)
    的乘法逆元。乘法逆元可以使用扩展欧几里得算法计算得出。生成的数 *d* 被用作私钥。
- en: The public key consists of the modulus *n* and the public (or encryption) exponent *e*.
    The private key consists of the modulus *n* and the private (or decryption) exponent
    *d*, which must be kept secret. The numbers *p*, *q*, and ![$$\phi (n)$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq36.png)
    must also be kept secret, because they can be used to calculate *d*.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 公钥由模数 *n* 和公钥（或加密）指数 *e* 组成。私钥由模数 *n* 和私钥（或解密）指数 *d* 组成，必须保密。数字 *p*, *q*, 和
    ![$$\phi (n)$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq36.png)
    也必须保密，因为它们可以用来计算 *d*。
- en: '**Encryption**. Alice transmits her public key (*n*, *e*) to Bob and keeps
    the private key secret. Bob then wishes to send a message *M* to Alice.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**加密**。爱丽丝将她的公钥 (*n*, *e*) 传送给鲍勃，并保持私钥的秘密。鲍勃然后希望向爱丽丝发送一条消息 *M*。'
- en: First, Bob turns *M* into an integer *m* such that ![$$0 \le m &lt; n$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq37.png)
    by using an agreed-upon reversible protocol known as a padding scheme. Then Bob
    computes the ciphertext *c* given by![$$\begin{aligned} c= &amp; {} m^e (\bmod
    ~n). \end{aligned}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ1.png)(1.1)This
    can be done quickly using the method of exponentiation by squaring. Bob then transmits
    *c* to Alice.**Decryption**. Alice can recover *m* from *c* by using her private
    key exponent *d* via computing![$$\begin{aligned} m= &amp; {} c^d \pmod {n}. \end{aligned}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ2.png)(1.2)Given
    *m*, Alice can recover the original message *M* by reversing the padding scheme.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，鲍勃将 *M* 转换为一个整数 *m*，使得 ![$$0 \le m < n$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq37.png)，通过使用一个已知的可逆协议，即填充方案。然后鲍勃计算出密文
    *c*，由![$$\begin{aligned} c= &amp; {} m^e (\bmod ~n). \end{aligned}$$](../images/516136_1_En_1_Chapter/5161
- en: To illustrate the RSA encryption and decryption procedures, next we give a numerical
    example. The parameters used here are artificially small, but it can also help
    the readers who may wish to use OpenSSL for generating and examining a real keypair.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明 RSA 加密和解密过程，接下来我们给出一个数值示例。这里使用的参数是故意设置得较小的，但它也可以帮助那些可能希望使用 OpenSSL 生成和检查实际密钥对的读者。
- en: '1.'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '1.'
- en: Choose two distinct prime numbers, such as ![$$p=61$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq38.png)
    and ![$$q=53$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq39.png).
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 选择两个不同的素数，例如 ![$$p=61$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq38.png)
    和 ![$$q=53$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq39.png)。
- en: '2.'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '2.'
- en: Compute ![$$n = pq = 61 \times 53=3233$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq40.png).
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '3.'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compute the totient function of the product ![$$\phi (n) = (p - 1)(q - 1)$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq41.png).
    In our example, we get ![$$\phi (3233)=(61-1)\times (53-1)=3120$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq42.png).
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '4.'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose any number ![$$1&lt; e &lt; 3120$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq43.png)
    that is coprime with 3120\. If a prime number is chosen for *e*, then it suffices
    to check that *e* is not a divisor of 3120\. In the example, let us take ![$$e=17$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq44.png).
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '5.'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compute ![$$d = e^{-1} \pmod {\phi (n)} = 2753$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq45.png).
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The public key is the pair ![$$(n, e) = (3233, 17)$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq46.png).
    For a padded plaintext message *m*, the encryption function is![$$c = m^{17} \pmod
    {3233}.$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ34.png)The
    private key is the pair ![$$(n, d) = (3233, 2753)$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq47.png).For
    an encrypted ciphertext *c*, the decryption function is![$$m = c^{2753} \pmod
    {3233}.$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ35.png)For
    instance, in order to encrypt ![$$m = 65$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq48.png),
    we compute![$$c=65^{17}=2790 \pmod {3233}.$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ36.png)To
    decrypt ![$$c = 2790$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq49.png),
    we calculate![$$m=2790^{2753} \pmod {3233} = 65.$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ37.png)
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 1.2.3 Digital Signature Model
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A digital signature is a mathematical scheme for verifying the authenticity
    of digital messages or documents. A valid digital signature, where the prerequisites
    are satisfied, gives a recipient very strong reason to believe that the message
    was created by a known sender (authenticity), and that the message was not altered
    in transit (integrity). In many instances, it provides a layer of validation and
    security to messages sent through a non-secure channel. Digital signatures are
    equivalent to traditional handwritten signatures in many respects, but properly
    implemented digital signatures are more difficult to forge than the handwritten
    ones. They can also provide non-repudiation, which means that the signer cannot
    successfully claim that they did not sign a message. Digital signatures can be
    used to sign any messages representable as a bitstring: examples include electronic
    mail, contracts, or messages sent in other cryptographic protocols.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: A model of digital signatures was invented by Whitfield Diffie and Martin Hellman [[3](#CR3)]
    in 1976\. It is shown in Fig. [1.6](#Fig6).![](../images/516136_1_En_1_Chapter/516136_1_En_1_Fig6_HTML.png)
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 数字签名模型是由惠特菲尔德·迪菲（Whitfield Diffie）和马丁·赫尔曼（Martin Hellman）发明的。
- en: Image depicts the digital signature model. The process consists of signing and
    verification.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图象显示了数字签名模型。该过程包括签名和验证。
- en: Fig. 1.6
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.6
- en: Digital signature model
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 数字签名模型
- en: Typically, a digital signature scheme consists of the following three algorithms.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，数字签名方案包括以下三种算法。
- en: A key generation algorithm selecting a private key uniformly at random from
    a set of possible private keys. The algorithm outputs a private key and the corresponding
    public key.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个关键的生成算法，它从可能的私钥集中均匀随机选择一个私钥。该算法输出一个私钥和相应的公钥。
- en: A signing algorithm, which produces a signature for a given message with the
    private key.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个签名算法，它使用私钥为给定消息生成签名。
- en: A signature verifying algorithm, which accepts or rejects the authenticity claim
    for a given message, public key and signature.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个签名验证算法，它接受或拒绝给定消息、公钥和签名的真实性声明。
- en: The digital signature scheme must satisfy the following two main properties.
    First, it should be possible to use the corresponding public key to verify the
    authenticity of a signature generated from a fixed message and a fixed private
    key. Second, it must be computationally infeasible to generate a valid signature
    for a party without knowing the party’s private key. A digital signature is an
    authentication mechanism that enables the creator of the message to attach a bit
    string that acts as a signature.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 数字签名方案必须满足以下两个主要性质。首先，应该能够使用相应的公钥来验证从固定消息和固定私钥生成的签名。其次，对于不知道方私钥的第三方生成有效签名，必须计算上不可行。数字签名是创建者能够附加一个位串作为签名的认证机制。
- en: Formally, a digital signature algorithm can be defined as a triple of algorithms.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 正式地，一个数字签名算法可以被定义为算法的三元组。
- en: '**Key generation algorithm (***KG***)**. Given a security parameter *k*, a
    public and private key pair ![$$(\mathsf {pk},\mathsf {sk})$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq50.png)
    is generated. The public key ![$$\mathsf {pk}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq51.png)
    is published to the public, while the private key ![$$\mathsf {sk}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq52.png)
    is known to its owner only.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**密钥生成算法（\*KG\*）**。给定一个安全参数 *k*，生成一个公私钥对 ![$$(\mathsf {pk},\mathsf {sk})$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq50.png)。公钥
    ![$$\mathsf {pk}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq51.png)
    公布给公众，而私钥 ![$$\mathsf {sk}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq52.png)
    只有其所有者知道。'
- en: '**Signing algorithm (***S***)**. Given a message *m* and a private key ![$$\mathsf
    {sk}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq53.png),
    a signature ![$$s=S(m,\mathsf {sk})$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq54.png)
    is produced.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**签名算法（\*S\*）**。给定一个消息 \*m* 和一个私钥 ![$$\mathsf {sk}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq53.png)，生成的签名
    ![$$s=S(m,\mathsf {sk})$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq54.png)。'
- en: '**Verification algorithm (***V***)**. Given a message *m*, the signature *s*
    and the public key ![$$\mathsf {pk}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq55.png),
    the algorithm outputs a value ![$$V(m,s,\mathsf {pk}) \in \{0, 1\}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq56.png),
    where ![$$V(m,s,\mathsf {pk})$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq57.png)
    is equal to 1 if the authenticity is accepted and is equal to 0 if it is rejected.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**验证算法（\*V\*）**。给定一个消息 \*m\*，签名 \*s\* 和公钥 ![$$\mathsf {pk}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq55.png)，算法输出一个值
    ![$$V(m,s,\mathsf {pk}) \in \{0, 1\}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq56.png)，其中
    ![$$V(m,s,\mathsf {pk})$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq57.png)
    如果真实性被接受则等于1，如果被拒绝则等于0。'
- en: 1.2.4 RSA Digital Signature Algorithm
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.4 RSA数字签名算法
- en: The RSA digital signature algorithm was the first practical digital signature
    algorithm. It was proposed by Ron Rivest, Adi Shamir and Leonard Adleman and was
    named using an acronym of the first letters of their surnames [[5](#CR5)].
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 罗纳德·里维斯特（Ron Rivest）、阿迪·夏米尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）提出了RSA数字签名算法，它是第一个实用的数字签名算法，以其姓氏的首字母缩写命名。
- en: 'The RSA digital signature algorithm is made up from three algorithms: key generation,
    signing and verification algorithms described below.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: RSA数字签名算法由以下三个算法组成：密钥生成、签名和验证算法，如下所述。
- en: '**Key generation**. A public key and a private key are required for RSA. The
    public key can be known by everyone and is used for verifying digital signatures.
    The private key is known only to the signer. Messages are signed with the private
    key by the signer. The public key can be used for verifying digital signatures
    in a reasonable amount of time. The keys for the RSA digital signature algorithm
    are generated in the same way as for the RSA encryption algorithm.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**密钥生成**。RSA算法需要一个公钥和一个私钥。公钥可以被任何人知道，用于验证数字签名。私钥仅被签名者知道。签名者使用私钥签署消息。公钥可以用于在合理的时间内验证数字签名。RSA数字签名算法的密钥生成方式与RSA加密算法的密钥生成方式相同。'
- en: '**Signing algorithm**. Alice transmits her public key (*n*, *e*) to Bob and
    keeps the private key *d* secret. Alice then wishes to send a message *m* with
    her digital signature to Bob.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**签名算法**。爱丽丝将她的公钥(*n*, *e*)发送给鲍勃，并保持私钥*d*的秘密。然后爱丽丝希望用她的数字签名发送一条消息*m*给鲍勃。'
- en: First, Alice computes her signature for the message *m* with her private key
    *d*,![$$\begin{aligned} s= &amp; {} m^d \pmod {n} \end{aligned}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ3.png)(1.3)This
    can be done quickly using the method of exponentiation by squaring. Alice then
    transmits (*m*, *s*) to Bob.**Verification algorithm**. Bob verifies Alice’s signature
    *s* on the message *m* by using her public key (*n*, *e*) to check whether the
    following modular equality holds![$$\begin{aligned} m= &amp; {} s^e \pmod {n}
    \end{aligned}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ4.png)(1.4)If
    the above equality is valid, then the signature is genuine and the message has
    been signed by Alice. Otherwise, the signature must be rejected.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，爱丽丝使用她的私钥*d*为消息*m*计算签名，![$$\begin{aligned} s= &amp; {} m^d \pmod {n} \end{aligned}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ3.png)(1.3)这可以通过指数平方的方法快速完成。然后爱丽丝将(*m*,
    *s*)发送给鲍勃。**验证算法**。鲍勃通过使用爱丽丝的公钥(*n*, *e*)来验证她对消息*m*的签名*s*，检查以下模等式是否成立![$$\begin{aligned}
    m= &amp; {} s^e \pmod {n} \end{aligned}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ4.png)(1.4)如果上述等式有效，则签名是真实的，消息是由爱丽丝签名的。否则，必须拒绝签名。
- en: Next, we give an example of RSA signature generation and verification. For convenience,
    the example uses small parameters, but one can also use OpenSSL to generate and
    examine a real keypair.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们给出一个RSA签名生成和验证的示例。为了方便，示例使用了小参数，但也可以使用OpenSSL生成并检查一个真实的密钥对。
- en: '1.'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '1.'
- en: Choose two distinct prime numbers, for example, ![$$p=61$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq58.png)
    and ![$$q=53$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq59.png).
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 选择两个不同的素数，例如，![$$p=61$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq58.png)和![$$q=53$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq59.png)。
- en: '2.'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '2.'
- en: Compute ![$$n = pq = 61\times 53 = 3233$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq60.png).
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 计算![$$n = pq = 61\times 53 = 3233$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq60.png)。
- en: '3.'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '3.'
- en: Compute the totient of the product as ![$$\phi (n) = (p - 1)(q - 1)$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq61.png).
    In the example, we get ![$$\phi (3233) = (61-1) \times (53-1) = 3120$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq62.png).
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 计算乘积的欧拉函数值为![$$\phi (n) = (p - 1)(q - 1)$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq61.png)。在示例中，我们得到![$$\phi
    (3233) = (61-1) \times (53-1) = 3120$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq62.png)。
- en: '4.'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '4.'
- en: Choose any number ![$$1&lt; e &lt; 3120$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq63.png)
    that is coprime to 3120\. If we choose a prime number for *e*, then it remains
    only to check that *e* is not a divisor of 3120\. In our example, let us take
    ![$$e=17$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq64.png).
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 选择任何介于1和3120之间的数![$$1&lt; e &lt; 3120$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq63.png)，使其与3120互质。如果我们选择一个素数作为*e*，那么只需要检查*e*是否不是3120的除数。在我们的示例中，让我们取![$$e=17$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq64.png)。
- en: '5.'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '5.'
- en: Compute ![$$d = e^{-1} \pmod {\phi (n)} = 2753$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq65.png).
    The public key is the pair ![$$(n, e) = (3233, 17)$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq66.png)
    and the private key is ![$$(n, d) = (3233, 2753)$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq67.png).
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 计算 ![$$d = e^{-1} \pmod {\phi (n)} = 2753$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq65.png)。公钥是
    ![$$(n, e) = (3233, 17)$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq66.png)
    对，私钥是 ![$$(n, d) = (3233, 2753)$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq67.png)。
- en: For a message *m*, the signature is![$$s = m^{2753} \pmod {3233}.$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ38.png)For
    signature verification, one needs to check whether the following equality holds![$$m=s^{17}
    \pmod {3233}.$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ39.png)For
    example, in order to sign ![$$m = 2790$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq68.png),
    we calculate![$$s=2790^{2753}=65 \pmod {3233}.$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ40.png)To
    verify the signature, we compute![$$65^{17}\pmod {3233} = 2790.$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ41.png)Since
    ![$$m = s^e\pmod {n}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq69.png),
    the signature can be accepted.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 对于消息 *m*，签名是 ![$$s = m^{2753} \pmod {3233}.$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ38.png)进行签名验证时，需要检查以下等式是否成立
    ![$$m=s^{17} \pmod {3233}.$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ39.png)例如，为了签名
    ![$$m = 2790$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq68.png)，我们计算
    ![$$s=2790^{2753}=65 \pmod {3233}.$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ40.png)验证签名时，我们计算
    ![$$65^{17}\pmod {3233} = 2790.$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ41.png)由于
    ![$$m = s^e\pmod {n}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq69.png)，因此可以接受签名。
- en: 1.3 Hash Functions
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.3 哈希函数
- en: The original RSA digital signature algorithm can sign only a short message with
    less than *n* bits. In order to sign longer messages with more than *n* bits,
    a hash function has to be used at first. A hash function maps each longer message
    to a shorter string of bits called the *hash* of the message. Then the RSA digital
    signature algorithm can be used to generate a signature for the short hash of
    the original message.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的RSA数字签名算法只能签名小于*n*位的短消息。为了签名超过*n*位的长消息，首先必须使用一个哈希函数。哈希函数将每个较长的消息映射到一个较短的位字符串，称为消息的*哈希*。然后，RSA数字签名算法可以用来生成原始消息的短哈希的签名。
- en: 1.3.1 The Concept of a Hash Function
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3.1 哈希函数的概念
- en: A *hash function* is a mathematical algorithm that maps data of an arbitrary
    size (often called the “message”) to a bit array of a fixed size (the “hash value”,
    “hash”, or “message digest”). It is a one-way function, which means that it is
    practically infeasible to invert or reverse the computation and recover the input
    of the function given only its output. Ideally, the only way to find a message
    that produces a given hash is to attempt a brute-force search through all possible
    inputs to see which of the inputs produces a match, or use a rainbow table of
    matched hashes. Hash functions are a basic tool of modern cryptography.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希函数是一种数学算法，它将任意大小的数据（通常称为“消息”）映射到一个固定大小的位数组（“哈希值”、“哈希”或“消息摘要”）。它是一个单向函数，这意味着实际上不可能逆向或反转计算，仅凭输出无法恢复函数的输入。理想情况下，找到一个产生给定哈希的消息的唯一方法是尝试通过所有可能的输入进行暴力搜索，看哪个输入产生匹配，或者使用匹配哈希的彩虹表。哈希函数是现代密码学的基本工具。
- en: A hash function must be deterministic, which means that the same message always
    results in the same hash. Ideally, it should also have the following properties.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希函数必须是确定性的，这意味着相同的消息总是产生相同的哈希值。理想情况下，它还应具有以下特性。
- en: It must be quick to compute the hash value for any given message.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于任何给定消息，计算哈希值必须快速。
- en: It should be infeasible to generate a message that yields a given hash value
    (i.e., to reverse the process that generated the given hash value).
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成一个消息，使其产生给定的哈希值（即，逆转产生给定哈希值的过程）应该是不可行的。
- en: It should be infeasible to find two different messages with the same hash value.
    A small change to a message should alter the hash value so extensively that a
    new hash value would appear uncorrelated with the old hash value (avalanche effect).
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找到两个具有相同哈希值的不同消息应该是不可行的。消息的小幅更改应使哈希值发生巨大变化，以至于新的哈希值与旧的哈希值（雪崩效应）看起来不相关。
- en: Hash functions have many security applications, notably in digital signatures,
    message authentication codes (MACs), and other forms of authentication. They can
    also be used for indexing data in hash tables, for fingerprinting, for detecting
    duplicate data, for unique identification of files, and as checksums to detect
    accidental data corruption. In information-security contexts, hash values are
    sometimes called (digital) fingerprints, checksums, or just hash values, even
    though all these terms stand for more general functions with rather different
    properties and purposes.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希函数在数字签名、消息认证码（MACs）和其他形式的认证中具有许多安全应用。它们还可以用于哈希表中的数据索引、指纹识别、检测重复数据、文件的唯一标识以及检测意外数据损坏的校验和。在信息安全上下文中，哈希值有时被称为（数字）指纹、校验和，或者只是哈希值，尽管所有这些术语都代表具有相当不同属性和目的的一般函数。
- en: Most hash functions are designed to take a string of any length as input and
    produce a fixed-length hash value.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数哈希函数被设计为接受任意长度的字符串作为输入，并产生固定长度的哈希值。
- en: A hash function must be able to withstand all known types of cryptanalytic attacks.
    In theoretical cryptography, the security level of a hash function has been defined
    using the following properties.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希函数必须能够抵御所有已知的密码分析攻击。在理论密码学中，哈希函数的安全级别是使用以下属性定义的。
- en: '**Pre-image resistance**. Given a hash value *h*, it should be difficult to
    find any message *m* such that ![$$h = \mathsf {hash}(m)$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq70.png).
    This concept is related to that of a one-way function. Functions that lack this
    property are vulnerable to preimage attacks.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**预图像阻力**。给定一个哈希值*h*，找到任何消息*m*使得![$$h = \mathsf {hash}(m)$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq70.png)应该困难。这个概念与单向函数的概念有关。缺乏这一属性的函数容易受到预图像攻击。'
- en: '**Second pre-image resistance**. Given an input ![$$m_1$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq71.png),
    it should be difficult to find a different input ![$$m_2$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq72.png)
    such that ![$$\mathsf {hash}(m_1) = \mathsf {hash}(m_2)$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq73.png).
    This property is sometimes referred to as a *weak collision resistance*. Functions
    that lack this property are vulnerable to second pre-image attacks.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第二次预图像阻力**。给定一个输入![$$m_1$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq71.png)，找到一个不同的输入![$$m_2$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq72.png)使得![$$\mathsf
    {hash}(m_1) = \mathsf {hash}(m_2)$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq73.png)应该困难。这一属性有时被称为*弱碰撞阻力*。缺乏这一属性的函数容易受到第二次预图像攻击。'
- en: '**Collision resistance**. It should be difficult to find two different messages
    ![$$m_1$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq74.png)
    and ![$$m_2$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq75.png)
    such that ![$$\mathsf {hash}(m_1) = \mathsf {hash}(m_2)$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq76.png).
    Such a pair is called a *cryptographic hash collision*. This property is sometimes
    referred to as a *strong collision resistance*. It requires a hash value at least
    twice as long as that required for pre-image resistance; otherwise collisions
    may be found by a birthday attack.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**碰撞阻力**。找到两个不同的消息![$$m_1$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq74.png)和![$$m_2$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq75.png)使得![$$\mathsf
    {hash}(m_1) = \mathsf {hash}(m_2)$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq76.png)应该困难。这样的一对被称为*密码学哈希碰撞*。这一属性有时被称为*强碰撞阻力*。它要求哈希值至少是预图像阻力所需的两倍长；否则，可以通过生日攻击找到碰撞。'
- en: Collision resistance implies second pre-image resistance but does not imply
    pre-image resistance. The weaker assumption is always preferred in theoretical
    cryptography, but in practice, a hash function which is only second pre-image
    resistant is considered insecure and is therefore not recommended for real applications.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 碰撞阻力意味着第二次预图像阻力，但并不意味着预图像阻力。在理论密码学中，总是优先考虑较弱的假设，但在实践中，一个只是第二次预图像阻力的哈希函数被认为是安全的，因此不建议用于实际应用。
- en: Informally, these properties mean that a malicious adversary cannot replace
    or modify the input data without changing its digest. Thus, if two strings have
    the same digest, one can be very confident that they are identical. Second pre-image
    resistance prevents an attacker from crafting a document with the same hash as
    a document the attacker cannot control. Collision resistance prevents an attacker
    from creating two distinct documents with the same hash.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 非正式地，这些属性意味着恶意敌方不能不改变其摘要的情况下替换或修改输入数据。因此，如果两个字符串有相同的摘要，我们可以非常有信心它们是相同的。第二图像阻力防止攻击者制作与攻击者无法控制的文档具有相同哈希值的文档。碰撞阻力防止攻击者创建具有相同哈希值的两个不同文档。
- en: 'A function satisfying these criteria may still have undesirable properties.
    Currently, popular hash functions are vulnerable to length-extension attacks:
    given ![$$\mathsf {hash}(m)$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq77.png)
    and ![$$\mathsf {len}(m)$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq78.png)
    but not *m*, by choosing a suitable ![$$m''$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq79.png)
    an attacker can calculate ![$$\mathsf {hash}(m \Vert m'')$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq80.png),
    where ![$$\Vert $$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq81.png)
    denotes concatenation. This property can be used to break naive authentication
    schemes based on hash functions. The Hash-based Message Authentication Code (HMAC)
    construction works around these problems.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 满足这些标准的函数可能仍然具有不希望的属性。目前，流行的哈希函数容易受到长度扩展攻击：给定![$$\mathsf {hash}(m)$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq77.png)和![$$\mathsf
    {len}(m)$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq78.png)，但不是*m*，通过选择一个合适的![$$m'$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq79.png)，攻击者可以计算![$$\mathsf
    {hash}(m \Vert m')$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq80.png)，其中![$$\Vert
    $$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq81.png)表示连接。这一特性可以用来破坏基于哈希函数的朴素认证方案。基于哈希的消息认证码（HMAC）构造可以解决这些问题。
- en: In practice, collision resistance is insufficient for many practical uses. In
    addition to collision resistance, it should be impossible for an adversary to
    find two messages with substantially similar digests, or to infer any useful information
    about the data given only its digest. In particular, a hash function should behave
    as much as possible like a random function (often called a random oracle in proofs
    of security) while still being deterministic and efficiently computable. This
    rules out functions like the SWIFFT function [[4](#CR4)], which can be rigorously
    proven to be collision resistant assuming that certain problems on ideal lattices
    are computationally difficult, but, as a linear function, does not satisfy these
    additional properties.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际中，碰撞阻力对许多实际应用来说是不够的。除了碰撞阻力之外，还应该使敌方无法找到两个具有实质上相似摘要的消息，或者仅凭消息摘要推断出有关数据的有用信息。特别是，哈希函数应该尽可能地表现得像一个随机函数（在安全性的证明中通常称为随机预言机），同时仍然具有确定性和高效的可计算性。这排除了像SWIFFT函数[[4](#CR4)]这样的函数，它可以严格证明是碰撞抵抗的，前提是某些理想格上的问题是计算上困难的，但作为一个线性函数，不满足这些额外的属性。
- en: Checksum algorithms, such as CRC (Cyclic Redundancy Check) and other cyclic
    redundancy checks, are designed to satisfy much weaker requirements and are generally
    unsuitable as hash functions. For example, a CRC was used for message integrity
    in the Wired Equivalent Privacy (WEP) encryption standard, but an attack was readily
    discovered, which exploited the linearity of the checksum.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 校验和算法，如CRC（循环冗余校验）和其他循环冗余校验，设计来满足更弱的要求，通常不适用于哈希函数。例如，CRC被用于Wired Equivalent
    Privacy (WEP)加密标准的消息完整性，但很快就发现了一个攻击，该攻击利用了校验和的线性性质。
- en: 1.3.2 SHA-1
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3.2 SHA-1
- en: SHA-1 (Secure Hash Algorithm 1) is a hash function which takes an input and
    produces a 160-bit (20-byte) hash value known as a message digest— typically rendered
    as a hexadecimal number, 40 digits long. It was designed by the United States
    National Security Agency, and is a U.S. Federal Information Processing Standard.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: SHA-1（安全哈希算法1）是一个哈希函数，它接受一个输入并产生一个160位（20字节）的哈希值，称为消息摘要——通常表示为一个十六进制数，40位数字。它是由美国国家安全局设计的，是美国联邦信息处理标准。
- en: When a message of any length less than ![$$2^{64}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq82.png)
    is an input, SHA-1 produces a 160-bit output called a *message digest*. The message
    digest can then be used, for example, in a signature algorithm which generates
    or verifies the signature for a message. Signing the message digest rather than
    the message often improves the efficiency of the process because the message digest
    is usually much shorter than the message. The same hash algorithm must be used
    by the verifier of a digital signature as the one used by the creator of the digital
    signature. Any change to the message in transit will, with very high probability,
    result in a different message digest, and the signature will fail to verify.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当输入的消息长度小于![$$2^{64}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq82.png)时，SHA-1产生一个160位的输出，称为*消息摘要*。消息摘要可以用于例如签名算法，该算法生成或验证消息的签名。对消息摘要进行签名而不是消息本身通常会提高过程的效率，因为消息摘要通常比消息短得多。验证数字签名的人必须使用与创建数字签名的人相同的哈希算法。消息在传输过程中的任何更改都将以非常高的概率导致不同的消息摘要，并且签名将无法验证。
- en: SHA-1 produces a message digest based on principles similar to those used by
    Ronald L. Rivest of MIT in the design of the MD2, MD4 and MD5 message digest algorithms,
    but generates a larger hash value (160 bits vs. 128 bits). SHA-1 was designed
    on the basis of Merkle-Damgård construction as shown in Fig. [1.7](#Fig7).![](../images/516136_1_En_1_Chapter/516136_1_En_1_Fig7_HTML.png)
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: SHA-1根据与麻省理工学院Ronald L. Rivest设计的MD2、MD4和MD5消息摘要算法相似的原则生成消息摘要，但生成更大的哈希值（160位对128位）。SHA-1是基于Merkle-Damgård构造设计的，如图[1.7](#Fig7)所示。![](../images/516136_1_En_1_Chapter/516136_1_En_1_Fig7_HTML.png)
- en: Image reflects Merkle Damgård hash function construction. The original message
    flows to message block 1 and message block 2, while the padding flows to message
    block n.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图反映了Merkle Damgård哈希函数构造。原始消息流向消息块1和消息块2，而填充流向消息块n。
- en: Fig. 1.7
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.7
- en: Merkle-Damgård hash function construction
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Merkle-Damgård哈希函数构造
- en: To describe SHA-1, let us first define the terminology and functions used as
    building blocks for it.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要描述SHA-1，让我们首先定义用于构建它的术语和函数。
- en: 'A hexadecimal digit (or hex digit) is an element of the set ![$$\{0, 1, \ldots
    , 9, A, \ldots , F\}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq83.png).
    Each hex digit is a representation of a 4-bit string. For examples: ![$$7 = 0111$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq84.png)
    and ![$$A = 1010$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq85.png).'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 十六进制数字（或十六进制数字）是集合![$$\{0, 1, \ldots , 9, A, \ldots , F\}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq83.png)的一个元素。每个十六进制数字是一个4位字符串的表示。例如：![$$7
    = 0111$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq84.png)和![$$A
    = 1010$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq85.png)。
- en: A *word* is a 32-bit string which may be represented as a sequence of 8 hex
    digits. To convert a word to 8 hex digits each 4-bit string is converted to its
    hex equivalent as described above. For example,![$$1010 0001 0000 0011 1111 1110
    0010 0011 = A103FE23.$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ42.png)
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个*单词*是一个32位字符串，可以表示为8个十六进制数字的序列。要将一个单词转换为8个十六进制数字，每个4位字符串都转换为其上述描述的十六进制等效物。例如，![$$1010
    0001 0000 0011 1111 1110 0010 0011 = A103FE23.$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ42.png)
- en: Every integer between 0 and ![$$2^{32} - 1$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq86.png)
    inclusive can be represented as a word. The least significant four bits of the
    integer are represented by the rightmost hex digits of the word representation.
    For example, the integer ![$$291 = 2^8+2^5+2^1+2^0 = 256+32+2+1$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq87.png)
    is represented by the hex word 00000123.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0到![$$2^{32} - 1$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq86.png]之间的每个整数都可以表示为一个单词。整数的最小有效四位字符串由单词表示的右边的十六进制数字表示。例如，整数![$$291
    = 2^8+2^5+2^1+2^0 = 256+32+2+1$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq87.png)由十六进制单词00000123表示。
- en: A *block* is a 512-bit string. Every block can be represented as a sequence
    of 16 words.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个*块*是一个512位字符串。每个块可以表示为16个单词的序列。
- en: The following logical operators will be applied to words.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 以下逻辑运算符将应用于单词。
- en: Bitwise logical word operations![$$\begin{aligned} \,\text{ AND }\,&amp;\text
    { is a bitwise logical ``and'' operator}, \nonumber \\ \,\text{ OR }\,&amp;\text
    { is a bitwise logical ``inclusive-or'' operator}, \nonumber \\ \,\text{ XOR }\,&amp;\text
    { is a bitwise logical ``exclusive-or'' operator}, \nonumber \\ \text{ NOT }\,&amp;\text
    { is a bitwise logical ``complement'' operator}. \nonumber \end{aligned}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ43.png)For
    example,![](../images/516136_1_En_1_Chapter/516136_1_En_1_Equ46_HTML.png)
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位逻辑词运算![
- en: Image duplicates for positive integers n and m, the remainder upon dividing
    n by m is denoted by n.
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于正整数 n 和 m，n除以m的余数表示为 n。
- en: The operation ![$$X + Y$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq88.png)
    is defined as follows. Let *X* and *Y* be the words representing integers *x*
    and *y*, where ![$$0 \le x, y &lt; 2^{32}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq89.png).
    For positive integers *n* and *m*, the remainder upon dividing *n* by *m* is denoted
    by ![$$n \pmod {m}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq90.png).
    Compute![$$\begin{aligned} z= &amp; {} (x + y) \pmod {2^{32}}. \end{aligned}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ5.png)(1.5)Then
    ![$$0 \le z &lt; 2^{32}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq91.png).
    Convert *z* to a word *Z*, and define the value of operation ![$$X + Y$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq92.png)
    to be equal to *Z*.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运算 ![$$X + Y$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq88.png)
    定义如下。令 *X* 和 *Y* 分别为表示整数 *x* 和 *y* 的词，其中 ![$$0 \le x, y < 2^{32}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq89.png)。对于正整数
    *n* 和 *m*，*n*除以*m*的余数表示为 ![$$n \pmod {m}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq90.png)。计算![$$\begin{aligned}
    z= &amp; {} (x + y) \pmod {2^{32}}. \end{aligned}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ5.png)(1.5)然后
    ![$$0 \le z < 2^{32}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq91.png)。将
    *z* 转换为词 *Z*，并将运算 ![$$X + Y$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq92.png)
    的值定义为 *Z*。
- en: If *X* is a word and *i* is an integer such that ![$$0 \le i &lt; 32$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq93.png),
    then the *circular left shift operation* ![$$S^{i}(X)$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq94.png)
    is defined by![$$\begin{aligned} S^i(X)= &amp; {} (X \ll i) \,\text{ OR }\,(X
    \gg 32-i). \end{aligned}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ6.png)(1.6)In
    the above, ![$$X \ll i$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq95.png)
    is obtained by discarding the leftmost *i* bits of *X* and then padding the result
    with *i* zeroes on the right (the result still has 32 bits). Likewise, ![$$X \gg
    i$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq96.png) is obtained
    by discarding the rightmost *i* bits of *X* and then padding the result with i
    zeroes on the left. Thus ![$$S^i(X)$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq97.png)
    is equivalent to a circular shift of *X* by *i* positions to the left.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 *X* 是一个词而 *i* 是一个整数，使得 ![$$0 \le i < 32$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq93.png)，那么
    *循环左移操作* ![$$S^{i}(X)$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq94.png)
    定义如下![$$\begin{aligned} S^i(X)= &amp; {} (X \ll i) \,\text{ OR }\,(X \gg 32-i).
    \end{aligned}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ6.png)(1.6)在上式中，![$$X
    \ll i$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq95.png)
    是通过丢弃 *X* 的最左边的 *i* 位，然后在右侧用 *i* 个零填充结果得到的（结果仍然有32位）。同样地，![$$X \gg i$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq96.png)
    是通过丢弃 *X* 的最右边的 *i* 位，然后在左侧用 *i* 个零填充结果得到的。因此 ![$$S^i(X)$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq97.png)
    等价于将 *X* 循环左移 *i* 位。
- en: '**Padding**. The purpose of message padding is to make the total length of
    a padded message a multiple of 512\. SHA-1 is used to compute a message digest
    for a message or data file that is provided as input. SHA-1 sequentially processes
    blocks of 512 bits when computing the message digest.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**填充**。消息填充的目的是使填充后的消息总长度为512的倍数。当SHA-1用于计算作为输入提供的一条消息或数据文件的消息摘要时，它按顺序处理512位的数据块来计算消息摘要。'
- en: The message or data file should be considered as a bit string. The length of
    the message is the number of bits in the message. (The empty message has length
    0). If the number of bits in a message is a multiple of 8, for compactness we
    can represent the message in hex.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 消息或数据文件应被视为一个位串。消息的长度就是消息中的位数。（空消息长度为0）。如果消息中的位数是8的倍数，为了紧凑起见，我们可以将消息表示为十六进制。
- en: Next, we describe how the message padding is performed. In a summary, a “1”
    followed by *m* “0”s followed by a 64-bit integer are appended to the end of the
    message to produce a padded message of length 512*n*. The 64-bit integer is the
    length of the original message. The padded message is then processed by SHA-1
    as *n* 512-bit blocks.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们描述如何进行消息填充。简要来说，在消息的末尾添加一个“1”和一个*m*个“0”，再加上一个64位的整数，以产生长度为512*n*的填充消息。64位的整数是原始消息的长度。然后将填充后的消息作为*n*个512位块处理，使用SHA-1算法。
- en: The first 512-bit block, denoted as *M*(1), is processed in the following steps.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个512位的块，表示为*M*(1)，按以下步骤处理。
- en: '**Step 1: Initialisation**. The hash function *H* is initialised as follows
    (in hexadecimal notation):'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤1：初始化**。散列函数*H*按照以下方式初始化（用十六进制表示）：'
- en: '![$$H_0 = 67452301$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq98.png),
    ![$$H_1 = EFCDAB89$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq99.png),
    ![$$H_2 = 98BADCFE$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq100.png),'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '![$$H_0 = 67452301$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq98.png),
    ![$$H_1 = EFCDAB89$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq99.png),
    ![$$H_2 = 98BADCFE$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq100.png),'
- en: '![$$H_3 = 10325476$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq101.png),
    ![$$H_4 = C3D2E1F0.$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq102.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![$$H_3 = 10325476$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq101.png),
    ![$$H_4 = C3D2E1F0.$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq102.png)'
- en: '**Step 2: Expanding**. Divide *M*(1) into 16 words ![$$W(0), W(1), \ldots ,
    W(15)$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq103.png),
    where *W*(0) is the leftmost word. For ![$$t = 16$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq104.png)
    to 79, let![$$\begin{aligned} W(t)= &amp; {} S^1(W(t-3) \,\text{ XOR }\,W(t-8)
    \,\text{ XOR }\,W(t-14) \,\text{ XOR }\,W(t-16)). \end{aligned}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ7.png)(1.7)**Step
    3: Mixing up by looping**. Let ![$$A = H_0$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq105.png),
    ![$$B = H_1$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq106.png),
    ![$$C = H_2$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq107.png),
    ![$$D = H_3$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq108.png),
    ![$$E = H_4$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq109.png).
    For ![$$t = 0$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq110.png)
    to 79 do![$$\begin{aligned}&amp;\text{ TEMP } = S^5(A) + f(t;B,C,D) + E + W(t)
    + K(t),\nonumber \\&amp;E = D; D = C; C = S^{30}(B); B = A; A = \text{ TEMP },
    \end{aligned}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ8.png)(1.8)where![$$f(t;B,C,D)
    = \left\{ \begin{array}{ll} (B \,\text{ AND }\,C) \,\text{ OR }\,((\text{ NOT
    }\,~ B)~ \,\text{ AND }\,~ D) &amp;{} \text{ for } 0 \le t \le 19), \\ B~ \,\text{
    XOR }\,C~ \,\text{ XOR }\,D &amp;{} \text{ for } 20 \le t \le 39),\\ (B \,\text{
    AND }\,C) \,\text{ OR }\,(B \,\text{ AND }\,D) \,\text{ OR }\,(C \,\text{ AND
    }\,D) &amp;{} \text{ for } 40 \le t \le 59),\\ B~ \,\text{ XOR }\,C \,\text{ XOR
    }\,D &amp;{} \text{ for } 60 \le t \le 79, \end{array}\right. $$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ44.png)![$$K(t)
    = \left\{ \begin{array}{ll} 5A827999 &amp;{} \text{ for } 0 \le t \le 19,\\ 6ED9EBA1
    &amp;{} \text{ for } 20 \le t \le 39,\\ 8F1BBCDC &amp;{} \text{ for } 40 \le t
    \le 59,\\ CA62C1D6 &amp;{} \text{ for } 60 \le t \le 79\. \end{array}\right. $$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ45.png)Each
    of these loops can be illustrated with Fig. [1.8](#Fig8).![](../images/516136_1_En_1_Chapter/516136_1_En_1_Fig8_HTML.png)'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤2：扩展**。将*M*(1)分为16个词![$$W(0), W(1), \ldots , W(15)$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq103.png)，其中*W*(0)是最左边的单词。对于![$$t
    = 16$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq104.png)到79，令![$$\begin{aligned}
    W(t)= &amp; {} S^1(W(t-3) \,\text{ XOR }\,W(t-8) \,\text{ XOR }\,W(t-14) \,\text{
    XOR }\,W(t-16)). \end{aligned}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ7.png)(1.7)**步骤3：通过循环进行混合**。令![$$A
    = H_0$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq105.png)，![$$B
    = H_1$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq106.png)，![$$C
    = H_2$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq107.png)，![$$D
    = H_3$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq108.png)，![$$E
    = H_4$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq109.png)。对于![$$t
    = 0$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq110.png)到79，执行![$$\begin{aligned}&amp;\text{
    TEMP } = S^5(A) + f(t;B,C,D) + E + W(t) + K(t),\nonumber \\&amp;E = D; D = C;
    C = S^{30}(B); B = A; A = \text{ TEMP }, \end{aligned}$$](../images/516'
- en: Image represents secure hash algorithm computation,
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图像表示安全散列算法计算，
- en: Fig. 1.8
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Fig. 1.8
- en: SHA-1 computation
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: SHA-1计算
- en: '**Step 4: Output**. Let ![$$H_0 = H_0 + A, H_1 = H_1 + B, H_2 = H_2 + C, H_3
    = H_3 + D, H_4 = H_4 + E$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq111.png).
    Repeatedly execute Steps 1 to 4 for the other 512-bit blocks ![$$M(2), \ldots
    , M(n)$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq112.png).
    The final output ![$$H_0, H_1,H_2,H_3, H_4$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq113.png)
    is the hash digest of the message.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤4：输出**。令![$$H_0 = H_0 + A, H_1 = H_1 + B, H_2 = H_2 + C, H_3 = H_3 + D,
    H_4 = H_4 + E$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq111.png)。重复执行步骤1至4，处理其他512位块![$$M(2),
    \ldots , M(n)$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq112.png)。最终输出![$$H_0,
    H_1,H_2,H_3, H_4$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq113.png)为消息的散列摘要。'
- en: In early 2005, Vincent Rijmen and Elisabeth Oswald published an attack on a
    reduced version of SHA-1, 53 out of 80 rounds, which finds collisions with a computational
    effort of fewer than 280 operations.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 2005年初，Vincent Rijmen和Elisabeth Oswald发布了对SHA-1简化版本的攻击，即80轮中的53轮，其计算工作量少于280次操作。
- en: In February 2005, an attack by Wang et al. [[8](#CR8)] was announced. The attack
    can find collisions in the full version of SHA-1, requiring fewer than 269 operations.
    (A brute-force search would require 280 operations.)
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 2005年2月， Wang 等人[[8](#CR8)]宣布了一种攻击方法。这种攻击可以在SHA-1完整版本的散列函数中找到碰撞，所需的操作数少于269次。（如果采用暴力破解方法，则需要280次操作。）
- en: 'The authors write: “In particular, our analysis is built upon the original
    differential attack on SHA-0, the near collision attack on SHA-0, the multiblock
    collision techniques, as well as the message modification techniques used in the
    collision search attack on MD5\. Breaking SHA-1 would not be possible without
    these powerful analytical techniques.” The authors presented a collision for 58-round
    SHA-1, found with 233 hash operations. The paper with a description of the full
    attack was published in August 2005 at the CRYPTO conference.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 作者写道：“特别是，我们的分析基于对SHA-0的原始差分攻击、对SHA-0的近碰撞攻击、多块碰撞技术，以及用于对MD5进行碰撞搜索攻击的消息修改技术。没有这些强大的分析技术，不可能破解SHA-1。”作者展示了58轮SHA-1的一个碰撞，使用了233次哈希操作。描述完整攻击的论文于2005年8月在CRYPTO会议上发表。
- en: Since 2005, SHA-1 has not been considered secure against well-funded opponents
    [[4](#CR4)]. Since 2010 many organisations have recommended its replacement. NIST
    formally deprecated the use of SHA-1 in 2011 and disallowed its use for digital
    signatures in 2013\. In 2020, chosen-prefix attacks against SHA-1 have become
    practical. It is recommended to remove SHA-1 from products as soon as possible
    and instead use SHA-2 or SHA-3\. Replacing SHA-1 is urgent where it is used for
    digital signatures.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 自2005年以来，SHA-1已经被认为在面对资金充足的对手时不再安全[[4](#CR4)]。自2010年以来，许多组织建议更换SHA-1。NIST在2011年正式宣布不推荐使用SHA-1，在2013年禁止其用于数字签名。到2020年，针对SHA-1的选择前缀攻击变得可行。建议尽可能快地从产品中移除SHA-1，转而使用SHA-2或SHA-3。在数字签名中使用SHA-1的情况下，更换SHA-1是迫切的。
- en: 1.3.3 SHA-2
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3.3 SHA-2
- en: SHA-2 includes significant changes in comparison to its predecessor SHA-1\.
    The SHA-2 family consists of six hash functions with digests (hash values) that
    are 224, 256, 384 or 512 bits. These functions are denoted by SHA-224, SHA-256,
    SHA-384, SHA-512, SHA-512/224, SHA-512/256\. The functions SHA-256 and SHA-512
    are novel hash functions computed with eight 32-bit and 64-bit words, respectively.
    They use different shift amounts and additive constants, but in other respects
    their structures are virtually identical; the only difference is in the number
    of rounds. SHA-224 and SHA-384 are truncated versions of SHA-256 and SHA-512,
    respectively, computed with different initial values. SHA-512/224 and SHA-512/256
    are also truncated versions of SHA-512, but the initial values are generated using
    the method described in Federal Information Processing Standards (FIPS) PUB 180-4.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: SHA-2与它的前身SHA-1相比有了显著的改变。SHA-2家族包括六个散列函数，其摘要（散列值）为224、256、384或512位。这些函数分别表示为SHA-224、SHA-256、SHA-384、SHA-512、SHA-512/224、SHA-512/256。SHA-256和SHA-512是使用八个32位和64位单词计算的新散列函数，它们使用不同的位移量和加法常数，但在其他方面结构几乎相同；唯一的区别是轮数。SHA-224和SHA-384分别是SHA-256和SHA-512的截断版本，使用不同的初始值计算。SHA-512/224和SHA-512/256也是SHA-512的截断版本，但初始值是使用联邦信息处理标准（FIPS）PUB
    180-4中描述的方法生成的。
- en: '**Padding**. Begin with the original message of length *L* bits, append a single
    ‘1’ bit, append *K* ‘0’ bits, where *K* is the minimum number ![$$\ge 0$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq114.png)
    such that ![$$L + 1 + K + 64$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq115.png)
    is a multiple of 512, append *L* as a 64-bit big-endian integer, making the total
    post-processed length a multiple of 512 bits such that the bits in the message
    are ![$$L 1 00 \cdots \langle K~0''s \rangle \cdots 00 \langle L \text{ as } 64
    \text{ bit } \text{ integer }\rangle = 512n$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq116.png)
    total bits.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**填充**。从长度为*L*位的原始消息开始，附上一个‘1’位，附上*K*个‘0’位，其中*K*是最小的满足![$$\ge 0$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq114.png)的数，使得![$$L
    + 1 + K + 64$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq115.png)是512的倍数，附上*L*作为一个64位的大端整数，使得处理后的总长度是512位的倍数，消息中的位为![$$L
    1 00 \cdots \langle K~0''s \rangle \cdots 00 \langle L \text{ as } 64 \text{ bit
    } \text{ integer }\rangle = 512n$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq116.png)总位。'
- en: The first 512-bit block, denoted by *M*(1), is processed in the following steps.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个512位块，用*M*(1)表示，按以下步骤处理。
- en: '**Step 1: Initialisation**. In hexadecimal notation, the hash function *H*
    is initialised as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤1：初始化**。以十六进制表示，哈希函数*H*初始化为以下形式：'
- en: '![$$H_0= 6A09E667$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq117.png),
    ![$$H_1= BB67AE85$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq118.png),
    ![$$H_2= 3C6EF372$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq119.png),
    ![$$H_3= A54FF53A$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq120.png),'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '![$$H_0= 6A09E667$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq117.png),
    ![$$H_1= BB67AE85$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq118.png),
    ![$$H_2= 3C6EF372$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq119.png),
    ![$$H_3= A54FF53A$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq120.png),'
- en: '![$$H_4= 510E527F$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq121.png),
    ![$$H_5= 9B05688C$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq122.png),
    ![$$H_6= 1F83D9AB$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq123.png),
    ![$$H_7= 5BE0CD19$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq124.png).'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '![$$H_4= 510E527F$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq121.png),
    ![$$H_5= 9B05688C$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq122.png),
    ![$$H_6= 1F83D9AB$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq123.png),
    ![$$H_7= 5BE0CD19$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq124.png).'
- en: '**Step 2: Expanding**. Divide *M*(1) into 16 words ![$$W(0), W(1), \dots ,
    W(15),$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq125.png)
    where *W*(0) is the leftmost word. For ![$$i = 16$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq126.png)
    to 63, let![$$\begin{aligned} S_0= &amp; {} S^7((W(i-15) )\,\text{ XOR }\,S^{18}((W(i-15))\,\text{
    XOR }\,(W(i-15)\gg 3) \end{aligned}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ9.png)(1.9)![$$\begin{aligned}
    S_1= &amp; {} S^{17} (W(i-2)) \,\text{ XOR }\,S^{19}(W(i-2)) \,\text{ XOR }\,(W(i-2)\gg
    10) \end{aligned}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ10.png)(1.10)![$$\begin{aligned}
    W(i)= &amp; {} W(i-16) + S_0 + W(i-7)+ S_1\ \end{aligned}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ11.png)(1.11)where
    ![$$S^i(X)=(X \gg i) \,\text{ OR }\,(X \ll 32-i)$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq127.png).**Step
    3: Mixing up by looping**. Let ![$$A=H_0$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq128.png),
    ![$$B=H_1$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq129.png),
    ![$$C=H_2$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq130.png),
    ![$$D=H_3$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq131.png),
    ![$$E=H_4$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq132.png),
    ![$$F=H_5$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq133.png),
    ![$$G=H_6$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq134.png),
    ![$$H=H_7$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq135.png).
    For ![$$t = 0$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq136.png)
    to 63, iteratively compute![$$\begin{aligned} S1= &amp; {} S^6 (E) \,\text{ XOR
    }\,S^{11 }(E) \,\text{ XOR }\,S^{25}(E) \end{aligned}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ12.png)(1.12)![$$\begin{aligned}
    \text{ CH }= &amp; {} (E \,\text{ AND }\,F)\,\text{ XOR }\,((\text{ NOT }\,E)
    \,\text{ AND }\,G) \end{aligned}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ13.png)(1.13)![$$\begin{aligned}
    \text{ TEMP}_1= &amp; {} H + S1 + \text{ CH } + K(i) + W(i) \end{aligned}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ14.png)(1.14)![$$\begin{aligned}
    S0= &amp; {} S^2(A)~ \,\text{ XOR }\,S^{13} (A)\,\text{ XOR }\,S^{22}(A) \end{aligned}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ15.png)(1.15)![$$\begin{aligned}
    \text{ MAJ }= &amp; {} (A \,\text{ AND }\,B)\,\text{ XOR }\,(A \,\text{ AND }\,C)
    \,\text{ XOR }\,(B \,\text{ AND }\,C)) \end{aligned}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ16.png)(1.16)![$$\begin{aligned}
    \text{ TEMP}_2= &amp; {} S0 + \text{ MAJ }\ \end{aligned}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ17.png)(1.17)where
    ![$$K(0\dots 63) =$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq137.png)'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤2：扩展**。将*M*(1)分为16个词 ![$$W(0), W(1), \dots , W(15),$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq125.png)
    其中*W*(0)是最左边的词。对于 ![$$i = 16$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq126.png)
    到63，设![$$\begin{aligned} S_0= &amp; {} S^7((W(i-15) )\,\text{ XOR }\,S^{18}((W(i-15))\,\text{
    XOR }\,(W(i-15)\gg 3) \end{aligned}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ9.png)(1.9)![$$\begin{aligned}
    S_1= &amp; {} S^{17} (W(i-2)) \,\text{ XOR }\,S^{19}(W(i-2)) \,\text{ XOR }\,(W(i-2)\gg
    10) \end{aligned}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ10.png)(1.10)![$$\begin{aligned}
    W(i)= &amp; {} W(i-16) + S_0 + W(i-7)+ S_1\ \end{aligned}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ11.png)(1.11)其中
    ![$$S^i(X)=(X \gg i) \,\text{ OR }\,(X \ll 32-i)$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq127.png)。**步骤3：通过循环打乱**。令
    ![$$A=H_0$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq128.png)，![$$B=H_1$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq129.png)，![$$C=H_2$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq130.png)，![$$D=H_3$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq131.png)，![$$E=H_4$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq132.png)，![$$F=H_5$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq133.png)，![$$G=H_6$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq134.png)，![$$H=H_7$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter'
- en: 428*A*2*F*98, 71374491, *B*5*C*0*FBCF*, *E*9*B*5*DBA*5, 3956*C*25*B*, 59*F*111*F*1,
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 923*F*82*A*4, *AB*1*C*5*ED*5, *D*807*AA*98, 12835*B*01, 243185*BE*, 550*C*7*DC*3,
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 72*BE*5*D*74, 80*DEB*1*FE*, 9*BDC*06*A*7, *C*19*BF*174, *E*49*B*69*C*1, *EFBE*4786,
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 0*FC*19*DC*6, 240*CA*1*CC*, 2*DE*92*C*6*F*, 4*A*7484*AA*, 5*CB*0*A*9*DC*, 76*F*988*DA*,
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 983*E*5152, *A*831*C*66*D*, *B*00327*C*8, *BF*597*FC*7, *C*6*E*00*BF*3, *D*5*A*79147,
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 06*CA*6351, 14292967, 27*B*70*A*85, 2*E*1*B*2138, 4*D*2*C*6*DFC*, 53380*D*13,
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 650*A*7354, 766*A*0*ABB*, 81*C*2*C*92*E*, 92722*C*85, *A*2*BFE*8*A*1, *A*81*A*664*B*,
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '*C*24*B*8*B*70, *C*76*C*51*A*3, *D*192*E*819, *D*6990624, *F*40*E*3585, 106*AA*070,'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: 19*A*4*C*116, 1*E*376*C*08, 2748774*C*, 34*B*0*BCB*5, 391*C*0*CB*3, 4*ED*8*AA*4*A*,
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 5*B*9*CCA*4*F*, 682*E*6*FF*3, 748*F*82*EE*, 78*A*5636*F*, 84*C*87814, 8*CC*70208,
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 90*BEFFFA*, *A*4506*CEB*, *BEF*9*A*3*F*7, *C*67178*F*2.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Then let ![$$H=G$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq138.png),
    ![$$G=F$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq139.png),
    ![$$F=E$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq140.png),
    ![$$E=D+\text{ TEMP}_1$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq141.png),
    ![$$D=C$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq142.png),
    ![$$C=B$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq143.png),
    ![$$B=A$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq144.png),
    ![$$A=\text{ TEMP}_1+\text{ TEMP}_2$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq145.png).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Each loop can be illustrated with Fig. [1.9](#Fig9).![](../images/516136_1_En_1_Chapter/516136_1_En_1_Fig9_HTML.png)
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Image shows S H A - 2 computation. It consists of C h, uppercase sigma 1, M
    a and uppercase sigma 0\.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 1.9
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: SHA-2 computation
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 4: Output**. Let ![$$H_0 = H_0 + A, H_1 = H_1 + B, H_2 = H_2 + C, H_3
    = H_3 + D, H_4 = H_4 \,{+}\, E, H_5=H_5\,{+}\,F, H_6=H_6+G, H_7=H_7+H$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq146.png).
    Repeatedly execute the above Steps 1–4 for other 512-bit blocks ![$$M(2), M(3),
    \dots , M(n)$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq147.png).
    The final output ![$$H_0, H_1,H_2,H_3, H_4$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq148.png)
    is the hash digest of the message.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: The SHA-2 hash function is implemented in some widely used security applications
    and protocols, including TLS and SSL, PGP, SSH, S/MIME, and IPsec.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Several cryptocurrencies, including Bitcoin, use SHA-256 for verifying transactions
    and calculating proof of work or proof of stake.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: 1.4 Elliptic Curve Cryptography
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Elliptic-curve cryptography (ECC) is an approach to public-key cryptography
    based on the algebraic structure of elliptic curves over finite fields. ECC allows
    smaller keys compared to non-EC cryptography (based on plain Galois fields) to
    provide equivalent security. Bitcoin, for example, uses ECC as its public key
    cryptosystem because it is lightweight.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 椭圆曲线密码学（ECC）是一种基于有限域中椭圆曲线的代数结构的公钥密码学方法。与非EC密码学（基于简单的伽罗瓦域）相比，ECC允许使用更小的密钥提供等效的安全性。例如，比特币就使用ECC作为其公钥加密系统，因为它更轻便。
- en: 1.4.1 Elliptic Curves over the Real Numbers
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.4.1 实数域上的椭圆曲线
- en: In mathematics, an elliptic curve is a smooth, projective, algebraic curve of
    genus one, on which there is a specified point *O*. An elliptic curve is defined
    over a field *K* and describes points in ![$$K^2$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq149.png),
    the Cartesian product of *K* with itself. If the field’s characteristic is different
    from 2 and 3, then the curve can be described as a plane algebraic curve which,
    after a linear change of variables, consists of solutions (*x*, *y*) to the equation
    ![$$y^{2} = x^{3}+ax+b$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq150.png)
    for some coefficients *a* and *b* in *K*. The curve is required to be non-singular,
    which means that the curve has no cusps or self-intersections. (This is equivalent
    to the inequality ![$$4a^{3}+27b^{2}\ne 0$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq151.png).)
    It is always understood that the curve is really sitting in the projective plane,
    with the point *O* to be the unique point at infinity. Many sources define an
    elliptic curve as a curve given by an equation of this form.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学中，椭圆曲线是一个光滑的、射影的、 genus 为一的代数曲线，上面有一个指定的点 *O*。椭圆曲线定义在一个域 *K* 上，并描述 *K* 的笛卡尔积中的点。如果域的特征数不同于2和3，那么该曲线可以被描述为一个平面代数曲线，通过变量的一次线性变换后，由某些系数
    *a* 和 *b* 在 *K* 中的方程 ![$$y^{2} = x^{3}+ax+b$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq150.png)
    的解 (*x*, *y*) 组成。曲线必须是非 singular 的，这意味着曲线没有尖点或自交。 （这等同于不等式 ![$$4a^{3}+27b^{2}\ne
    0$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq151.png)。) 始终理解曲线实际上位于射影平面上，点
    *O* 是唯一的无穷远点。许多来源将椭圆曲线定义为具有这种形式的方程的曲线。
- en: An elliptic curve is an abelian variety. This means that it has a group law
    defined algebraically, with respect to which it is an abelian group, where *O*
    serves as the identity element.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 椭圆曲线是一种阿贝尔品种。这意味着它有一个通过代数方式定义的群法，相对于它是一个阿贝尔群，其中*O*作为单位元素。
- en: Although the formal definition of an elliptic curve requires some background
    in algebraic geometry, it is possible to describe some features of elliptic curves
    over the real numbers using only introductory algebra and geometry. In this context,
    an elliptic curve is a plane curve defined by an equation of the form![$$\begin{aligned}
    y^2&amp;=x^3 + ax + b \end{aligned}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ18.png)(1.18)after
    a linear change of variables (*a* and *b* are real numbers). This type of equation
    is called a *Weierstrass equation*.The definition of an elliptic curve also requires
    that the curve be non-singular. Geometrically, this means that the graph has no
    cusps, self-intersections, or isolated points. Algebraically, this holds if and
    only if the discriminant![$$\begin{aligned} \Delta&amp;= -16(4a^3 + 27b^2) \end{aligned}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ19.png)(1.19)is
    not equal to zero.The (real) graph of a non-singular curve has two components
    if its discriminant is positive, and one component if it is negative. For example,
    in the graphs shown in Fig. [1.10](#Fig10), the discriminant in the first case
    is 64, and in the second case it is −368.![](../images/516136_1_En_1_Chapter/516136_1_En_1_Fig10_HTML.png)
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然椭圆曲线的正式定义需要一些代数几何的背景知识，但是仅使用初等代数和几何就可以描述实数域上椭圆曲线的一些特性。 在这个背景下，椭圆曲线是一个由形式![$$\begin{aligned}
    y^2&amp;=x^3 + ax + b \end{aligned}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ18.png)（其中*a*和*b*是实数）定义的平面曲线，经过一次线性变量变换。这种方程称为*魏尔斯特拉斯方程*。椭圆曲线的定义还要求曲线是非
    singular 的。从几何上看，这意味着图形没有尖点、自交点或孤立点。从代数上看，这只有在判别式![$$\begin{aligned} \Delta&amp;=
    -16(4a^3 + 27b^2) \end{aligned}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ19.png)不等于零时才成立。如果非
    singular 曲线的判别式为正，则其图形有两个部分；如果为负，则有一个部分。例如，在图[1.10](#Fig10)中，第一个案例的判别式为64，第二个案例为-368。
- en: Two graphs, both consists of elliptic curves, representing y superscript 2,
    equals x superscript 3 minus x and y superscript 2, equals x superscript 3 minus
    x plus 1 respectively.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 两个图形，都由椭圆曲线组成，分别表示y的平方等于x的立方减x和y的平方等于x的立方减x加1。
- en: Fig. 1.10
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.10
- en: Elliptic curves over the real numbers
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 实数域上的椭圆曲线
- en: 1.4.2 The Group Law
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.4.2 群规
- en: When working in the projective plane, we can define a group structure on any
    smooth cubic curve.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在投影平面上工作时，我们可以在任何光滑的三次曲线 上定义一个群结构。
- en: Since the curve is symmetrical about the *x*-axis, given any point *P*, we can
    take ![$$-P$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq152.png)
    to be the point opposite to it. We take ![$$-O$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq153.png)
    to be just *O*. If *P* and *Q* are two points on the curve, then we can uniquely
    describe a third point ![$$P + Q$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq154.png)
    in the following way. First, draw the line that intersects *P* and *Q*. This line
    will generally intersect the cubic at a third point *R*. We then take ![$$P +
    Q$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq155.png) to
    be ![$$-R$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq156.png),
    the point opposite *R*. This definition for addition works except in a few special
    cases related to the point at infinity and the intersection multiplicity. The
    first exception occurs when one of the points is *O*. Then, we define ![$$P +
    O = P = O + P$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq157.png),
    making *O* the identity of the group. Next, if *P* and *Q* are the opposites of
    each other, we define ![$$P + Q = O$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq158.png).
    Finally, if ![$$P = Q$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq159.png),
    then we only have one point and we cannot define a unique line through these points.
    In this case, we use the tangent line to the curve at this point as our line.
    In most cases, the tangent will intersect a second point *R* and we can take its
    opposite. However, if *P* happens to be an inflection point (a point where the
    concavity of the curve changes), then we take *R* to be *P* itself and ![$$P +
    P$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq160.png) is
    simply the point opposite to itself. The group law is illustrated in Fig. [1.11](#Fig11).![](../images/516136_1_En_1_Chapter/516136_1_En_1_Fig11_HTML.png)
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 由于曲线关于*x*轴对称，给定任意点*P*，我们可以取![$$-P$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq152.png)为其对面的点。我们取![$$-O$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq153.png)为仅仅是*O*。如果*P*和*Q*是曲线上的两个点，那么我们可以唯一地描述一个第三个点![$$P
    + Q$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq154.png)如下。首先，画出穿过*P*和*Q*的直线。这条直线通常会与三次曲线相交于第三个点*R*。然后我们取![$$P
    + Q$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq155.png)为![$$-R$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq156.png)，即*R*的对面点。这种加法定义在涉及到无穷远点和平行线
    multiplicity 的少数特殊情况除外。第一个异常情况发生在其中一个点是*O*时。这时，我们定义![$$P + O = P = O + P$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq157.png)，使得*O*成为该群的单位元。接下来，如果*P*和*Q*是彼此的相反点，我们定义![$$P
    + Q = O$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq158.png)。最后，如果![$$P
    = Q$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq159.png)，那么我们只有一个点，我们无法定义通过这些点的唯一直线。在这种情况下，我们使用该点处的切线作为我们的直线。在大多数情况下，切线会相交于第二个点*R*，我们可以取其相反点。然而，如果*P*碰巧是一个拐点（一个曲线凸度发生变化的点），那么我们取*R*为*P*本身，![$$P
    + P$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq160.png)就是自己相反的点。群法则在图[1.11](#Fig11)中说明。![](../images/516136_1_En_1_Chapter/516136_1_En_1_Fig11_HTML.png)
- en: Four graph depict elliptic curve group law, representing P plus Q plus R equal
    0, P plus Q plus Q equal 0, P plus Q plus 0 equal 0, P plus P plus 0 equal 0.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 四幅图描绘了椭圆曲线的群法则，表示P加Q加R等于0，P加Q加Q等于0，P加Q加0等于0，P加P加0等于0。
- en: Fig. 1.11
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.11
- en: Elliptic curve group law
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 椭圆曲线群法则
- en: 'The above group can be described algebraically as well as geometrically. Given
    the curve ![$$y^2 = x^3 + ax + b$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq161.png)
    over the field *K* and points ![$$P = (x_P, y_P)$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq162.png)
    and ![$$Q = (x_Q, y_Q)$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq163.png)
    on the curve, assume first that ![$$x_P \not = x_Q$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq164.png)
    (the first pane above). Let us define ![$$R=(x_R,y_R)=P+Q$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq165.png).
    Compute![$$\begin{aligned} \lambda&amp;= \frac{y_P-y_Q}{x_P-x_Q}, \end{aligned}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ20.png)(1.20)![$$\begin{aligned}
    x_R&amp;= \lambda ^2-x_P-x_Q, \end{aligned}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ21.png)(1.21)![$$\begin{aligned}
    y_R&amp;=y_P+\lambda (x_R-x_P). \end{aligned}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ22.png)(1.22)If
    ![$$x_P = x_Q$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq166.png),
    then there are two options: if ![$$y_P = -y_Q$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq167.png)
    (the third and fourth panes above), including the case where ![$$y_P = y_Q = 0$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq168.png)
    (the fourth pane), then the sum is defined as 0\. Thus, the inverse of each point
    on the curve is found by reflecting it across the x-axis. If ![$$y_P = y_Q \not
    = 0$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq169.png),
    then ![$$Q = P$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq170.png)
    and ![$$R = (x_R, y_R)=2P$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq171.png)
    (the second pane above with *P* shown for *R*) is given by![$$\begin{aligned}
    \lambda&amp;= \frac{3x_P^2+a}{2y_P}, \end{aligned}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ23.png)(1.23)![$$\begin{aligned}
    x_R&amp;= \lambda ^2-2x_P, \end{aligned}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ24.png)(1.24)![$$\begin{aligned}
    y_R&amp;= y_P+\lambda (x_R-x_P). \end{aligned}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ25.png)(1.25)'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 上述群既可以用代数方法也可以用几何方法描述。给定曲线 ![$$y^2 = x^3 + ax + b$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq161.png)
    在域 *K* 上，以及曲线上的点 ![$$P = (x_P, y_P)$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq162.png)
    和 ![$$Q = (x_Q, y_Q)$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq163.png)，首先假设
    ![$$x_P \not = x_Q$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq164.png)（上面的第一块面板）。让我们定义
    ![$$R=(x_R,y_R)=P+Q$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq165.png)。计算![$$\begin{aligned}
    \lambda&amp;= \frac{y_P-y_Q}{x_P-x_Q}, \end{aligned}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ20.png)(1.20)![$$\begin{aligned}
    x_R&amp;= \lambda ^2-x_P-x_Q, \end{aligned}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ21.png)(1.21)![$$\begin{aligned}
    y_R&amp;=y_P+\lambda (x_R-x_P). \end{aligned}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ22.png)(1.22)如果
    ![$$x_P = x_Q$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq166.png)，那么有两种选项：如果
    ![$$y_P = -y_Q$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq167.png)（上面的第三和第四块面板），包括
    ![$$y_P = y_Q = 0$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq168.png)（第四块面板）的情况，和为0。因此，曲线上的每个点的倒数是通过将其反射到x轴上找到的。如果
    ![$$y_P = y_Q \not = 0$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq169.png)，那么
    ![$$Q = P$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq170.png)
    并且 ![$$R = (x_R, y_R)=2P$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq171.png
- en: 1.4.3 Elliptic Curves over Finite Fields
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.4.3 有限域上的椭圆曲线
- en: Let ![$$K = F_q$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq172.png)
    be the finite field with *q* elements, and let *E* be an elliptic curve over *K*.
    While the precise number of rational points of an elliptic curve *E* over *K*
    is in general rather difficult to compute, Hasse’s theorem on elliptic curves
    gives us the following estimate (including the point at infinity):![$$\begin{aligned}
    |\#E(K)-(q+1)| \le 2 \sqrt{q}. \end{aligned}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ26.png)(1.26)It
    follows that the number of points of the curve grows approximately as the number
    of elements in the field.The set of points *E*(*Fq*) is a finite abelian group.
    It is always cyclic or the product of two cyclic groups. For example, the curve
    defined by![$$\begin{aligned} y^{2}=x^{3}-x \end{aligned}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ27.png)(1.27)over
    ![$$F_{71}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq173.png)
    has 72 points (71 affine points including (0, 0) and one point at infinity) over
    this field, as shown in Fig. [1.12](#Fig12).![](../images/516136_1_En_1_Chapter/516136_1_En_1_Fig12_HTML.png)
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 令![$$K = F_q$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq172.png)为具有*q*个元素的有限域，令*E*为*K*上的椭圆曲线。尽管通常很难计算出椭圆曲线*E*上*K*的准确有理点数，但椭圆曲线上的Hasse定理给出了以下估计（包括无穷远点）![$$\begin{aligned}
    |\#E(K)-(q+1)| \le 2 \sqrt{q}. \end{aligned}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ26.png)(1.26)因此，曲线的点数大约与字段中的元素数相同。椭圆曲线*E*(*Fq*)的点集是一个有限阿贝尔群。它总是循环的，或者是两个循环群的乘积。例如，由![$$\begin{aligned}
    y^{2}=x^{3}-x \end{aligned}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ27.png)(1.27)定义的曲线在![$$F_{71}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq173.png)上有72个点（包括71个affine点和一个无穷远点），如图[1.12](#Fig12)所示。![](../images/516136_1_En_1_Chapter/516136_1_En_1_Fig12_HTML.png)
- en: A scatterplot of a set of affine points of an elliptic curve, Y superscript
    2 equals x superscript 3 minus x, over the finite F superscript 71\. The x and
    y axis range from 0 to 72.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 椭圆曲线一组affine点的散点图，Y的平方等于x的立方减x，在有限域F的71次方。x和y轴的范围从0到72。
- en: Fig. 1.12
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.12
- en: Set of affine points of elliptic curve ![$$y^2 = x^3 - x$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq174.png)
    over the finite field ![$$F_{71}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq175.png)
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 椭圆曲线![$$y^2 = x^3 - x$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq174.png)在有限域![$$F_{71}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq175.png)上的affine点集
- en: 1.4.4 Elliptic Curve Digital Signature Algorithm (ECDSA)
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.4.4 椭圆曲线数字签名算法（ECDSA）
- en: In cryptography, the Elliptic Curve Digital Signature Algorithm (ECDSA) offers
    a variant of the Digital Signature Algorithm (DSA) which uses elliptic curve cryptography.
    ECDSA comprises three algorithms described as follows.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在密码学中，椭圆曲线数字签名算法（ECDSA）提供了数字签名算法（DSA）的一个变体，该算法使用椭圆曲线密码学。ECDSA包括以下三个算法。
- en: '**Key Generation**. First, the curve parameters (![$$\text{ CURVE }, G, n$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq176.png))
    are chosen. In addition to the field and equation of the curve, the algorithm
    requires to fix a base point *G* of prime order on the curve. The number *n* is
    the multiplicative order of the point *G*. The order *n* of the base point *G*
    must be prime.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '**密钥生成**。首先，选择曲线参数(![$$\text{ CURVE }, G, n$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq176.png))。除了曲线的域和方程外，算法还需要确定曲线上的一个基点*G*，其阶为素数。数字*n*是点*G*的乘法阶。基点*G*的阶*n*必须是素数。'
- en: Alice creates a key pair consisting of a private key integer ![$$d_A$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq177.png)
    randomly selected in the interval ![$$[1,n-1]$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq178.png),
    and a public key curve point ![$$Q_A = d_A \times G$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq179.png).
    Here ![$$\times $$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq180.png)
    denotes a multiplication of the elliptic curve point by a scalar. The point ![$$Q_A$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq181.png)
    is published while ![$$d_A$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq182.png)
    is kept secret by Alice.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '**Signature Generation**. To sign a message *m*, Alice proceeds as follows.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '1.'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compute ![$$e = \mathsf {hash}(m)$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq183.png).
    (Here ![$$\mathsf {hash}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq184.png)
    is a cryptographic hash function, such as SHA-2, with the output converted to
    an integer.)
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Denote by ![$$L_n$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq185.png)
    is the bit length of the group order *n*, and let *z* be the ![$$L_{n}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq186.png)
    leftmost bits of *e*. (Note that *z* can be greater than *n* but should not be
    longer in binary notation.)
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '3.'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select a cryptographically secure random integer *k* from ![$$[1,n-1]$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq187.png).
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 4.Compute the curve point![$$\begin{aligned} (x_{1},y_{1})=k\times G. \end{aligned}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ28.png)(1.28)
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 5.Calculate![$$\begin{aligned} r=x_{1} (\text {mod}~ n). \end{aligned}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ29.png)(1.29)If
    ![$$r=0$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq188.png),
    go back to step 3.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 6.Calculate![$$\begin{aligned} s=k^{-1}(z+rd_{A}) (\text {mod}~ n). \end{aligned}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ30.png)(1.30)If
    ![$$s=0$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq189.png),
    go back to step 3.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '7.'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The signature is the pair (*r*, *s*).
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Signature Verification**. For Bob to authenticate Alice’s signature, he must
    have a copy of her public-key curve point ![$$Q_A$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq190.png).
    Bob can verify that ![$$Q_A$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq191.png)
    is a valid curve point as follows.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '1.'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check that ![$$Q_A$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq192.png)
    is not equal to the identity element *O* and its coordinates are otherwise valid.
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check that ![$$Q_A$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq193.png)
    lies on the curve.
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '3.'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check that ![$$n\times Q_A = O$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq194.png).
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 检查![$$n\times Q_A = O$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq194.png)。
- en: If ![$$Q_A$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq195.png)
    is a valid curve point, Bob continues to verify the signature as follows.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果![$$Q_A$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq195.png)是一个有效的曲线点，Bob继续按照以下步骤验证签名。
- en: '1.'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '1.'
- en: Verify that *r* and *s* are integers in ![$$[1, n-1]$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq196.png).
    If not, the signature is invalid.
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 验证*r*和*s*是否是![$$[1, n-1]$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq196.png)中的整数。如果不是，则签名无效。
- en: '2.'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '2.'
- en: Compute ![$$e=\mathsf {hash}(m)$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq197.png),
    where ![$$\mathsf {hash}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq198.png)
    is the same function used in the signature generation. Denote by *z* the ![$$L_{n}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq199.png)
    leftmost bits of *e*.
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 计算![$$e=\mathsf {hash}(m)$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq197.png)，其中![$$\mathsf
    {hash}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq198.png)是签名生成中使用的同一函数。用*z*表示*e*的![$$L_{n}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq199.png)最左边的位。
- en: 3.Calculate![$$\begin{aligned} u_{1}=zs^{-1} (\text {mod}~ n), \end{aligned}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ31.png)(1.31)![$$\begin{aligned}
    u_{2}=rs^{-1}(\text {mod} ~n). \end{aligned}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ32.png)(1.32)
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3.计算![$$\begin{aligned} u_{1}=zs^{-1} (\text {mod}~ n), \end{aligned}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ31.png)(1.31)![$$\begin{aligned}
    u_{2}=rs^{-1}(\text {mod} ~n). \end{aligned}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ32.png)(1.32)
- en: 4.Compute the curve point![$$\begin{aligned} (x_1,y_1) = u_1 \times G+u_2 \times
    Q_A. \end{aligned}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ33.png)(1.33)If
    ![$$(x_1,y_1) = O$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq200.png)
    then the signature is invalid.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 4.计算曲线点![$$\begin{aligned} (x_1,y_1) = u_1 \times G+u_2 \times Q_A. \end{aligned}$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_Equ33.png)(1.33)如果![$$(x_1,y_1)
    = O$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq200.png)则签名无效。
- en: '5.'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '5.'
- en: The signature is valid if ![$$r = x_1 (\text {mod} ~n)$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq201.png),
    and is invalid otherwise.
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果![$$r = x_1 (\text {mod} ~n)$$](../images/516136_1_En_1_Chapter/516136_1_En_1_Chapter_TeX_IEq201.png)，则签名有效，否则无效。
- en: 1.4.5 ECDSA Versus RSA
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.4.5 ECDSA与RSA对比
- en: To provide the same level of security, ECC requires much shorter key lengths
    than RSA does. The following table shows a comparison of ECDSA and RSA.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 以相同的级别提供安全性，ECC所需的密钥长度比RSA短得多。以下表格展示了ECDSA与RSA的比较。
- en: '| Security (bits) | RSA key length required (bits) | ECC key length required
    (bits) |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| 安全级别（位） | 所需RSA密钥长度（位） | 所需ECC密钥长度（位） |'
- en: '| --- | --- | --- |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 80 | 1024 | 160–223 |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| 80 | 1024 | 160–223 |'
- en: '| 112 | 2048 | 224–255 |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| 112 | 2048 | 224–255 |'
- en: '| 128 | 3072 | 256–383 |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| 128 | 3072 | 256–383 |'
- en: '| 192 | 7680 | 384–511 |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| 192 | 7680 | 384–511 |'
- en: '| 256 | 15,360 | 512+ |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| 256 | 15,360 | 512+ |'
