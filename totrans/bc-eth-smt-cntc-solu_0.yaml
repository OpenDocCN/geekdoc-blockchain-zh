- en: '**Application Layer**'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '**应用层**'
- en: The application layer contains software applications, tokens, and smart
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 应用层包括软件应用，代币和智能
- en: contract languages.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 合约语言。
- en: 'First, the software application has three elements as shown below:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，软件应用程序有三个元素，如下所示：
- en: '*A web interface*'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*一个网页界面*'
- en: a web Gui is needed for a decentralized application
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 去中心化应用程序需要一个网页界面
- en: '*A dApp connector*'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*一个dApp连接器*'
- en: a connector uses web3 to connect web pages with
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 连接器使用web3将网页与
- en: blockchain smart contracts
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链智能合约
- en: '*Smart contracts on*'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在*智能合约上
- en: Smart contracts provide business and transaction logic for
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约为企业提供业务和交易逻辑
- en: '*blockchain*'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链*
- en: your applications
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您的应用程序
- en: The second important component in the application layer is the
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 应用层中的第二个重要组件是
- en: token. This is unique with blockchain, and the token economy is essential
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 代币。这是区块链独特的特点，代币经济至关重要
- en: to sustain a blockchain and decentralized applications. Token designs
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 维持区块链和去中心化应用程序。代币设计
- en: '217'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '217'
- en: Chapter 6 ethereum arChiteCture and Overview
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 第6章 ethereum arChiteCture 和 Overview
- en: include the kinds of tokens to issue, the amount of tokens supplied, who
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 包括要发行的代币类型，供应的代币数量，以及谁
- en: governs the administration of token supply, and whether a new token
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 管理代币供应，以及是否发行新的代币
- en: should be generated or an existing token can be reused.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 应该生成新的代币或重用现有的代币。
- en: Smart contract languages are also a major factor to consider. Besides
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约语言也是需要考虑的一个重要因素。除了
- en: Solidity, there are other languages such as Vyper, Yul, FE, and Serpent that
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Solidity，还有其他语言，如Vyper，Yul，FE和Serpent
- en: can be leveraged to write smart contracts.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 可以用来编写智能合约。
- en: In summary, the Ethereum blockchain architecture contains the
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，以太坊区块链架构包括
- en: 'following layers: Network Layer, Core Blockchain Layer, Enterprise'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 以下层次：网络层，核心区块链层，企业
- en: Blockchain Layer, Tooling Layer, and Applications Layer. Each layer
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链层，工具层和应用层。每一层
- en: serves essential functions for the Ethereum blockchain. We will describe
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 对以太坊区块链至关重要。我们将描述
- en: in more detail the Tooling and Applications Layers for developers in the
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 更详细地介绍开发人员关于工具层和应用层
- en: subsequent chapters.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 后续章节。
- en: '**Ethereum Blockchain Ecosystem**'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**以太坊区块链生态系统**'
- en: '**and DeFi Projects**'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**和DeFi项目**'
- en: Before building a project using the smart contract development
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在智能合约开发之前
- en: technology, it is essential to learn about the current Ethereum ecosystems.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 了解当前以太坊生态系统至关重要
- en: There are thousands of smart contracts and dApps deployed to the
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 已经有数千个智能合约和dApp部署在
- en: Ethereum blockchain already. We will walk through some of these projects
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊区块链已经存在。我们将介绍一些这些项目
- en: so that you are aware of what kinds of projects are available already. It is
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让你知道有哪些项目已经可用。这是
- en: better to brainstorm new ideas rather than reinvent the wheel.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 与其重新发明轮子，不如更好地头脑风暴新想法。
- en: '**Wallet to Manage Assets**'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**资产管理钱包**'
- en: The first class of blockchain applications are wallets that are used to
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链应用的第一类是用于
- en: manage assets.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 管理资产。
- en: In traditional finance, if you want to manage your asset, you most likely
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统金融中，如果你想管理你的资产，你最有可能是
- en: will go to a bank to open an account and let the bank manage the asset for
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 将去银行开设账户，并让银行为您管理资产
- en: you. But in the Ethereum blockchain, the assets are stored in a distributed
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你。但是，在以太坊区块链上，资产是存储在分布式
- en: ledger, and therefore, there are multiple ways to manage it.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 账本，因此，有多种方法可以管理它。
- en: '218'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '218'
- en: '![](index-230_1.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](index-230_1.png)'
- en: Chapter 6 ethereum arChiteCture and Overview
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 第6章 ethereum arChiteCture 和 Overview
- en: '**Hosted Service**'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**托管服务**'
- en: You can open an account with Coinbase and let Coinbase host the
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用Coinbase开设账户，并让Coinbase托管
- en: management of your crypto asset. When Coinbase is hosting your asset, you
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 管理您的加密资产。当Coinbase托管您的资产时，您
- en: do not manage the private key for the asset; rather, you create a login account
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 不管理资产的私钥；相反，您创建一个登录账户
- en: with the Coinbase service and let Coinbase do the transactions on your
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Coinbase服务，让Coinbase在您的
- en: behalf. These kinds of services are centralized. There are asset management
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 代表您进行交易。这类服务是集中的。有资产管理
- en: services around the world that offer services similar to Coinbase.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 世界各地提供与Coinbase类似服务的资产管理系统
- en: For users who prefer managing assets without a central portal, they
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些更喜欢在没有中央门户的管理下管理资产的用户，这是他们的选择。但在以太坊区块链上，资产是存储在分布式
- en: can have full control of their assets by using Coinbase wallets that store
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用存储在Coinbase钱包中的资产，可以完全控制他们的资产
- en: their private keys locally. Coinbase wallets allow users to create accounts
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 他们的私钥本地。 Coinbase 钱包允许用户创建账户
- en: by themselves and do the asset management directly with the blockchain
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 自己操作并直接与区块链进行资产管理。
- en: without going through a custodian.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 无需通过托管商即可进行。
- en: '**MetaMask**'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**MetaMask**'
- en: MetaMask is one of the most popular web browser extension wallets and
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: MetaMask 是最受欢迎的 Web 浏览器扩展钱包之一，
- en: most versatile to use. Figur[e 6-3 sho](#p230)ws how MetaMask interacts with
    blockchain to manage assets.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图 [6-3](#p230) 展示了 MetaMask 如何与区块链交互以管理资产。
- en: '***Figure 6-3\.** MetaMask workflow*'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '***图 6-3。 MetaMask 工作流程*'
- en: '219'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '219'
- en: '![](index-231_1.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](index-231_1.png)'
- en: Chapter 6 ethereum arChiteCture and Overview
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 第 6 章 以太坊架构和概述
- en: MetaMask can be installed on the Chrome or Firefox browser. For
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: MetaMask 可以在 Chrome 或 Firefox 浏览器上安装。对于
- en: Chrome installation, you simply download it from Chrome web store
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Chrome 安装后，你只需从 Chrome 网上应用店下载它。
- en: and install it to your browser. When MetaMask is first launched, it will
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 启动时，它会
- en: create crypto accounts for you. Instead of generating private keys directly,
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为用户创建加密账户。而不是直接生成私钥，
- en: MetaMask uses BIP39 specifications to generate mnemonic words, i.e.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: MetaMask 使用 BIP39 规范生成助记词，即
- en: seed phrases, that are 12 common and easy-to-remember English words.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 种子短语，这是 12 个常见且容易记住的英文单词。
- en: The seed phrase can be used to generate multiple private keys and
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 种子短语可用于生成多个私钥和
- en: addresses. You need to write down the seed phrases in order to recover
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 地址。你需要写下种子短语才能恢复
- en: MetaMask accounts if the extension is uninstalled.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果移除扩展程序，MetaMask 账户将消失。
- en: '**MyEtherWallet**'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**MyEtherWallet**'
- en: MyEtherWallet (MEW) is an open source, client-side interface that allows
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: MyEtherWallet (MEW) 是一个开源的客户端界面，允许
- en: users to interact directly with the Ethereum blockchain without having to
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 用户直接与以太坊区块链交互，而无需
- en: join a centralized exchange. Figur[e 6-4 sho](#p231)ws the workflow of transactions
    from user action to the blockchain.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 加入中心化交易所。图 [6-4](#p231) 展示了从用户操作到区块链的交易流程。
- en: '***Figure 6-4\.** MyEtherWallet workflow*'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '***图 6-4。 MyEtherWallet 工作流程*'
- en: '220'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '220'
- en: Chapter 6 ethereum arChiteCture and Overview
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 第 6 章 以太坊架构和概述
- en: Although MyEtherWallet only works on the client side with no blockchain
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 MyEtherWallet 只在不具有区块链的客户端侧工作，
- en: information sent back to the web server for processing and storage, there
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 信息发送回 Web 服务器进行处理和存储，因此
- en: are still possibilities for phishing attacks. Using a hardware or mobile wallet
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 使用硬件或移动钱包仍有可能发生钓鱼攻击。
- en: of MyEtherWallet is recommended. The web-based MyEtherWallet is not
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 建议使用 MyEtherWallet。基于 Web 的 MyEtherWallet 不是
- en: recommended and should be used in offline settings only.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 建议使用，并且仅应在离线环境中使用。
- en: '**Fortmatic**'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**Fortmatic**'
- en: Fortmatic is another kind of wallet that allows users to create accounts
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Fortmatic 是另一种允许用户创建账户的钱包。
- en: with their social identities. This is similar to a PayPal service where you
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 使用他们的社交身份。这类似于 PayPal 服务，你
- en: can create an account with an email address. Fortmatic provides APIs to
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用电子邮件地址创建账户。 Fortmatic 提供 API 以
- en: connect with various web-based decentralized applications and is very
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 与各种基于 Web 的去中心化应用程序连接，并且非常
- en: convenient for users who do not mind using a custodian wallet for crypto
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不介意使用托管钱包进行加密货币的用户来说，非常方便。
- en: transactions and applications.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 交易和应用程序。
- en: In this section, we mention asset management tools such as the web
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们提到了如 Web-based MyEtherWallet 等资产管理系统。
- en: wallet, web extension wallet, mobile wallet, and custodian wallet. When
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 钱包，Web 扩展钱包，移动钱包和托管钱包。当
- en: 'choosing or developing a wallet, there are many factors to be considered:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择或开发钱包时，需要考虑许多因素：
- en: • **Private keys** – Who generates, stores, and manages
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: • **私钥** – 谁生成、存储和管理
- en: private keys?
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 私钥？
- en: • **Decentralization** – Is the wallet managed by a central
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: • **去中心化** – 钱包是否由中心
- en: service or custodia?
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 服务或托管服务？
- en: • **Security** – Have there been any security breaches or
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: • **安全性** – 是否发生过任何安全漏洞或
- en: vulnerabilities reported in this wallet?
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个钱包中报告的漏洞有哪些？
- en: • **Ease of use** – Are the GUI and UX of the wallet user-
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: • **易用性** – 钱包的 GUI 和 UX 是否用户
- en: friendly?
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 友好？
- en: • **Open source** – Is wallet open source or proprietary?
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: • **开源** – 钱包是开源还是专有？
- en: • **Central control** – Is the wallet a client-side or server-
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: • **集中控制** – 钱包是客户端或服务器端
- en: side application?
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 侧应用程序？
- en: • **Recovery** – Is there a trusted way to recover the
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: • **恢复** – 是否有可靠的恢复
- en: account if the wallet gets lost or damaged?
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果钱包丢失或损坏，账户是否会丢失？
- en: '221'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '221'
- en: Chapter 6 ethereum arChiteCture and Overview
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 第6章 以太坊架构和概览
- en: Since the crypto wallet is needed to manage assets in blockchain, it is
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 由于加密钱包需要管理区块链中的资产，所以
- en: worth some time to research and choose the most trusted one.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 花些时间研究和选择最值得信赖的一个。
- en: '**Smart Contract–Enabled Banking dApp**'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**智能合约启用银行dApp**'
- en: In a conventional bank, customers can open accounts, deposit, and
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统银行中，客户可以开立账户、存款和
- en: borrow money. The bank has to maintain huge databases and IT systems
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 借款。银行必须维护庞大的数据库和IT系统
- en: to keep track of all transactions and compute the interest on the savings
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪所有交易并计算储蓄的利息。
- en: accounts and loans. The Ethereum blockchain is a public distributed
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 账户和贷款。以太坊区块链是一个公共分布式
- en: ledger, and crypto banking functions such as lending can be easily
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 账本，加密银行功能如借贷可以轻松
- en: implemented with smart contracts.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 用智能合约实现。
- en: One popular DeFi project in this category is Compound. Compound is
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类别中一个流行的DeFi项目是Compound。Compound是
- en: a decentralized DeFi protocol (open API) to enable lending and borrowing
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 去中心化DeFi协议（开放API）以实现借贷和借款。
- en: of cryptocurrency through smart contracts. A lender is an actor who
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 通过智能合约发行加密货币。放贷者是一个参与者，
- en: deposits supported cryptocurrencies such as ETH, USDT, USDC, and
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 支持存款的加密货币，如ETH、USDT、USDC以及
- en: DAI to the Compound platform to earn interest. When a lender deposits
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 将DAI存入Compound平台以获得利息。当放贷者存入
- en: cryptocurrency X to Compound, the smart contract will lock the asset and
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 将加密货币X存入Compound，智能合约将锁定该资产并
- en: issue the same amount of cX token to the depositor. The lender can use
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 向存款人发行相同数量的cX代币。放贷者可以使用
- en: the cX token to trade or redeem the X token back later. The smart contract
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 将cX代币用于交易或稍后赎回X代币。智能合约
- en: will also calculate the interest earned by the lender for each deposit
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 也将计算出放贷者每笔存款所获得的利息。
- en: period. A borrower can borrow the cryptocurrency deposited by the
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 期间。借款人可以借用存款人存入的
- en: lender to the Compound repository. Borrowers need to deposit a collateral
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 放贷者存入Compound仓库作为抵押。借款人需要存入一笔
- en: asset in order to borrow the cryptocurrency they want. Borrowers pay
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了借用他们想要的加密货币，借款人支付
- en: interest for the cryptocurrency they borrow and can repay the borrowed
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 借款方为他们借入的加密货币支付利息，并且可以偿还所借的
- en: cryptocurrency to get the collateral back.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 加密货币以取回抵押品。
- en: If a borrower’s collateral value factor falls below the balance of
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果借款人的抵押品价值因子低于
- en: the loan, the borrowing account becomes insolvent and triggers a
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 贷款时，借款账户变得资不抵债并触发一个
- en: liquidation event. A third party can pay a portion of the loan and get
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 清算事件。第三方可以支付部分贷款，并获得
- en: the corresponding collateral originally deposited to this account. To
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 将相应的一笔抵押品原封不动地存入这个账户。为了
- en: incentivize third parties to participate in liquidation, an incentive
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 激励第三方参与清算，一种激励
- en: determined by Compound’s governing system is provided.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 由Compound的治理系统提供。
- en: '222'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '222'
- en: Chapter 6 ethereum arChiteCture and Overview
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 第6章 以太坊架构和概览
- en: In a smart contract–enabled banking function, there is no central
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在智能合约启用的银行功能中，没有中央
- en: agency to manage the asset; the community needs to look at the smart
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 代理机构管理资产；社区需要关注智能
- en: contract and check for security risk. There is always a risk that the smart
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 合约并进行安全风险检查。总是存在智能
- en: contracts are breached and customers’ funds are lost. To minimize the
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 合约被突破，客户的资金就会丢失。为了最小化
- en: risks, smart contracts are always open source, and the project team
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 风险，智能合约总是开源的，项目团队
- en: normally has a third-party security audit before releasing them to the
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 通常在发布之前会进行第三方安全审计。
- en: mainnet of the public blockchain.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 公有区块链的主网。
- en: '**Decentralized Exchange in Ethereum**'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**以太坊中的去中心化交易所**'
- en: Crypto exchanges are used to transfer asset ownership between two
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 加密交易所用于在两个
- en: different users. There have been some centralized exchanges such as
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 不同用户。已经有一些中心化交易所，如
- en: Coinbase and Binance. Decentralized exchanges are fully built on smart
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Coinbase和Binance。去中心化交易所完全基于智能
- en: contracts, and there is no need to build a centrally managed database for
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 合约，无需建立集中管理的数据库。
- en: the exchanges. Popular decentralized exchanges include DDEX, Loopring,
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 交易所。流行的去中心化交易所包括DDEX、Loopring，
- en: Uniswap, etc.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Uniswap等。
- en: The Decentralized Exchange (DEX) using the Automated Market
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 自动市场
- en: Maker (AMM) has some innovations over centralized or conventional
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Maker (AMM)在中心化或传统
- en: exchanges. The AMM uses smart contracts and algorithms to adjust prices
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 交易所。AMM使用智能合约和算法来调整价格
- en: of assets in the liquidity pool and enables transactions without the need of
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 流动性池中的资产数量，并使交易无需
- en: maintaining an order book. For example, Uniswap is a popular AMM DEX
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 维护订单簿。例如，Uniswap是一个流行的AMM DEX
- en: 'that uses the following mechanism through smart contracts:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 通过智能合约使用以下机制：
- en: '**Automatic Liquidity Protocol** – Uniswap allows'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**自动流动性协议** - Uniswap允许'
- en: users to set up liquid pools by depositing an equal
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 用户通过存入相等的
- en: value of trading pairs to a smart contract. Traders
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 交易对的交易价值到一个智能合约。交易员
- en: can then trade their tokens with assets in the
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 然后可以用资产与代币进行交易。当代币对（X，Y）中的
- en: liquidity pool.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 流动性池。
- en: '223'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '223'
- en: Chapter 6 ethereum arChiteCture and Overview
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 第6章 以太坊架构和概览
- en: '**Automatic Price Adjustment** – With the Uniswap'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**自动价格调整** - 使用Uniswap'
- en: liquidity pool, the amount of both tokens in a token
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 流动性池，代币对中的代币数量
- en: pair (X,Y) needs to be balanced. If the amount of
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 对（X，Y）需要平衡。如果代币
- en: token X increases, then the amount for token Y
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 代币X增加，然后代币Y的数量
- en: decreases, and the price of token Y increases. This
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 减少，代币Y的价格会增加。这种情况
- en: triggers negative feedback to balance the pool.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 触发负反馈以平衡池。
- en: '**Arbitration**: Arbitration is a process for traders to'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**仲裁**：仲裁是交易者之间的一个过程，'
- en: balance the price fluctuation in a liquidity pool.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 平衡流动性池中的价格波动。
- en: When the amount of token X in token pair
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 代币X的数量增加时，代币Y的数量会减少，
- en: (X, Y) increases, the amount of token Y decreases,
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: （X，Y）增加，代币Y的数量减少，
- en: and the price of token Y increases. The arbitrator
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 和代币Y的价格会增加。仲裁员
- en: then sees that token Y’s price is higher than in
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 然后发现代币Y的价格在其他交易所中更高，
- en: other exchanges and will sell token Y from other
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 其他交易所出售代币Y。
- en: exchanges to Uniswap to increase the supply of
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 交易所将代币X增加到Uniswap，以增加
- en: token Y to balance the liquidity pool. When the
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 为了平衡流动性池，代币Y会增加。当
- en: liquidity pool is balanced, the token prices should
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 流动性池平衡时，代币价格应
- en: be similar to the token prices in other exchanges.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他交易所的代币价格相似。
- en: Using the Automated Market Maker mechanism, Uniswap was able to
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 使用自动市场制造商机制，Uniswap能够
- en: grow the TLV (total locked value) to 5 billion dollars within three years of
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在三年的时间里将TLV（总锁定价值）增长到50亿美元，
- en: development with an impressive 5% day-over-day growth.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 每天以5%的速度增长。
- en: '**NFT Applications**'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**NFT应用**'
- en: The NFT is a kind of token that has a unique identification and cannot
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: NFT是一种具有唯一标识的代币，不能
- en: be replaced or swapped with another. The specification of the NFT is in
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 可以替换或与其他代币交换。NFT的规格在
- en: ERC721 and in a later version of ERC1440\. One key feature of ERC721 is a
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: ERC721和稍后的ERC1440版本。ERC721的一个关键特性是
- en: field called id that contains a unique value for each token. ERC721 is most
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 称为id的字段，其中包含每个代币的唯一值。ERC721是最
- en: frequently used to represent creative artwork. Projects in NFT include
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 经常用于表示创意艺术品。NFT项目包括
- en: 0xcert, OpenSea, Decentraland, CryptoPunk, etc.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 0xcert，OpenSea，Decentraland，CryptoPunk等。
- en: '224'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '224'
- en: Chapter 6 ethereum arChiteCture and Overview
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 第6章 以太坊架构和概览
- en: 0xcert is an SDK tool set that allows you to develop NFTs. Most of the
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 0xcert是一个允许您开发NFT的SDK工具集。大多数
- en: tokens issued in Ethereum for ERC20 are fungible, meaning that there is no
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在以太坊上发行的ERC20代币是可替代的，这意味着没有
- en: difference between token items. Fungible tokens are value based and like
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 代币项目之间的差异。可替代代币是基于价值的，就像
- en: dollar bills are swappable. For NFTs, each token is different, and they are
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 美元钞票可以互换。对于NFT，每个代币都是不同的，它们是不可
- en: not replaceable. For example, a certificate or diploma can be represented
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 不可替代的。例如，证书或文凭可以作为
- en: as a nonfungible token because it is uniquely issued by an institute to
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 因为它是唯一由机构发行的。
- en: a particular person. In the future, there will be more and more dApps
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 特定的人。将来，将会有越来越多的dApps
- en: developed to work with nonfungible tokens. For example, original art works,
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 为非可替代代币而开发。例如，原始艺术品，
- en: court documents, and college certificates all belonged to this category.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 法院文件，大学证书都属于这一类。
- en: OpenSea allows users to submit NFT works for sale or buy NFT
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: OpenSea允许用户提交NFT作品进行销售或购买NFT
- en: collections with cryptocurrencies. They also support auctions so that the
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 支持加密货币的拍卖。他们还支持拍卖，以便用户
- en: highest bidders are granted the right to purchase an NFT artwork by smart
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 最高出价者有权通过智能合约购买NFT艺术品。
- en: contract. All transactions are controlled by smart contracts automatically,
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 合约。所有交易都由智能合约自动控制，
- en: and no manual intervention or third-party hosts are needed.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 无需手动干预或第三方托管。
- en: '**Oracle Service**'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '**Oracle服务**'
- en: An Oracle service is used to provide connection between blockchain and
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle服务用于提供区块链与
- en: conventional IT systems. Blockchain is self-confined, and there is no direct
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的IT系统。区块链是自成一体的，没有直接
- en: way for a blockchain client to talk to web servers directly. This is most
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链客户端与Web服务器直接对话的方式。这是最
- en: likely designed for security considerations. Neither Bitcoin or Ethereum
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 可能出于安全考虑而设计。比特币或以太坊
- en: blockchains have a web API integrated on chain to call web services hosted
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链上都集成了一个链上Web API，用于调用托管在
- en: by conventional IT systems. In order for blockchains to interact with
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的IT系统。为了让区块链与
- en: conventional IT systems, Oracle services need to be used.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的IT系统，需要使用Oracle服务。
- en: Chainlink is one of the most popular Oracle services that allow linkage
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Chainlink是最受欢迎的Oracle服务之一，允许与
- en: of traditional web services with Ethereum blockchain. If you have a
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 与以太坊区块链的传统Web服务相比。如果你有一个
- en: decentralized application that needs to get outside data, you need to use
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 需要获取外部数据的去中心化应用程序，你需要使用
- en: an Oracle service. For example, if your smart contract needs to get weather
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle服务。例如，如果你的智能合约需要获取天气
- en: information, you have to use an Oracle service, as the blockchain itself does
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 信息，你必须使用Oracle服务，因为区块链本身不
- en: not have any weather information. To get information about FIAT/CBDC
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 没有任何天气信息。为了获取关于FIAT/CBDC
- en: values, currency exchange rate, or cryptocurrency values, you need to
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 价值，货币汇率或加密货币价值，你需要
- en: connect to Oracle services provided by banks or third parties services as well.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以连接银行或第三方服务提供的Oracle服务。
- en: '225'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '225'
- en: Chapter 6 ethereum arChiteCture and Overview
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 第6章 以太坊架构概述
- en: There are other Oracle services provided by Provable and Band
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 还有由Proveble和Band提供的其他Oracle服务
- en: projects. Provable project also provides some SDK and example code to
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 项目。Proveble项目还提供一些SDK和示例代码来
- en: work with Oracle services with dApps and is very convenient.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 与dApps合作使用Oracle服务，非常方便。
- en: '**DAO Platforms**'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '**DAO平台**'
- en: DAO (Decentralized Autonomous Organization) is a platform to use smart
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: DAO（去中心化自治组织）是使用智能
- en: contracts to manage an organization or community. The DAO platforms
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 合约来管理组织或社区。DAO平台
- en: provide registration services and assign identities to constituents. Each
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 提供注册服务并为选民分配身份。每个
- en: member of the community can propose proposals and can also vote on
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 社区成员可以提出提案，也可以对
- en: proposals. There are many DAO platforms in the blockchain space already.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 提案。区块链领域已经有许多DAO平台。
- en: In fact, many projects such as Compound and Uniswap have their own
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，像Compound和Uniswap这样的许多项目都有自己的
- en: DAO communities and governing tokens to vote for proposals in the
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: DAO社区和治理代币用于投票提案在链上。
- en: community.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 社区。
- en: '**Decentralized Insurance Platform**'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '**去中心化保险平台**'
- en: The Decentralized Insurance Platform allows smart contracts to manage
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 去中心化保险平台允许智能合约管理
- en: the signing up of insurance services, provide insurance service from
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 保险服务的注册，从
- en: various sources, and then manage claims for the insured accounts. For
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 来自各种来源的信息，并管理保险账户的索赔。对于
- en: example, if you want to prevent a heavy loss from a Bitcoin price crash, you
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你想要防止比特币价格暴跌造成重大损失，你
- en: can actually send a transaction to a smart contract to pay a premium as
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上可以发送交易到智能合约支付保费，
- en: insurance, and there are people on the provider side who will accept the
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 保险，保险提供商方面也有人会接受
- en: insurance request. All the terms of insurance are recorded and enforced
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 保险请求。所有保险条款都被记录并强制执行
- en: through smart contracts. If unexpected events happen and trigger the
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 通过智能合约。如果发生意外事件并触发
- en: insurance actions, the smart contract will execute the corresponding
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 保险行为，智能合约将执行相应的
- en: function and compensate the insured person.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 功能并赔偿投保人。
- en: '226'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '226'
- en: Chapter 6 ethereum arChiteCture and Overview
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 第6章 以太坊架构概述
- en: '**Decentralized KYC and Identity**'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '**去中心化KYC和身份验证**'
- en: KYC (Know Your Customers) and Identity are services and tools to identify
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: KYC（了解你的客户）和身份验证是识别
- en: a real person and gather needed personal information to be in compliance
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 真实人物，收集必要的个人信息以符合规定
- en: with regulations. There are projects such as Civic, Hydro, Sovrin, and uPort
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 工具生成一个本地单节点 Ethereum 区块链，并允许
- en: that provide decentralized identity service for decentralized applications.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 一些出版物。
- en: To build KYC features within a decentralized application is quite
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在去中心化应用程序中构建 KYC 功能是相当
- en: challenging. It is much easier just to use a third-party KYC service.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '**设置智能合约的工具**'
- en: '**Stablecoin**'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '**稳定币**'
- en: One of the challenges of cryptocurrencies is its volatility. Bitcoin and
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 加密货币的一个挑战是其波动性。比特币和
- en: Ether’s values fluctuate a lot, and using them to represent values for
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 以太币的价值波动很大，用它们来表示
- en: products and services will cause fluctuations in prices. Stablecoin is an
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 产品和服务将导致价格波动。稳定币是一种
- en: asset that has relatively stable values when pegged with fiat currencies.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 当与法定货币挂钩时，价值相对稳定。
- en: These stablecoins are normally ERC20 tokens in the Ethereum blockchain.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这些稳定币通常是 Ethereum 区块链中的 ERC20 代币。
- en: Their values are maintained to be stable in several ways. For example,
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '![](index-239_1.png)'
- en: a stablecoin can be backed by US dollars with a one-to-one ratio. These
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 已经在 Ethereum 上的几乎所有主要类别中。有一些
- en: stablecoins include Gemini Dollar, TrueUSD, USD Coin, etc, as reported in
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 稳定币包括 Gemini Dollar、TrueUSD、USD Coin 等，如报道所述
- en: some publications.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 它们的价值观通过几种方式保持稳定。例如，
- en: There are other kinds such as MakerDAO’s Dai that are an aggregation
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 稳定币可以与美元以一对一的比例背书。这些
- en: of various assets and controlled by automatic burning and minting of
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 各种资产，并通过自动燃烧和铸币进行控制。有像 Civic、Hydro、Sovrin 和 uPort 等项目
- en: stablecoins to make the value stable.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序仍然在涌现。一些小型的智能合约项目
- en: In summary, there are many big decentralized applications built
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 具有挑战性。使用第三方 KYC 服务要容易得多。
- en: on Ethereum already in almost all major categories. There are some
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 发展革命性的去中心化应用程序的无限可能性
- en: applications that are still emerging. Small smart contract projects such
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 代币可以通过一些公共水龙头获得。没有可交易的
- en: as rental sharing, on-demand music service, and decentralized voting
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，几乎所有主要类别中都有许多大型去中心化应用程序
- en: platforms are all possible projects that can be built with smart contracts.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 稳定币来保持价值稳定。
- en: Smart contract development is a fascinating area. Developers can find
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约开发是一个迷人的领域。开发者可以找到
- en: unlimited possibilities to develop revolutionary decentralized applications
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 钱包、浏览器、节点客户端、智能合约 IDE，以及与
- en: once they learn how to program smart contracts.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦他们学会了如何编程智能合约。
- en: '227'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '227'
- en: '![](index-239_1.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: 作为租赁共享、按需音乐服务和去中心化投票
- en: Chapter 6 ethereum arChiteCture and Overview
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 第 6 章 Ethereum 架构和概览
- en: '**Tools to Set Up a Smart Contract**'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 还有像 MakerDAO 的 Dai 这样的，是一个聚合
- en: '**Development Environment**'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '**开发环境**'
- en: There are multiple ways to set up environments to interact with the
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方式设置环境与
- en: Ethereum blockchain. Figure [6-5](#p239) shows an overview of various tools
    and components.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: Ethereum 区块链。图 [6-5](#p239) 展示了各种工具和组件的概览。
- en: '***Figure 6-5\.** Some basic tools for Ethereum blockchain*'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '***图 6-5。** Ethereum 区块链的基本工具*'
- en: The top layer shows various kinds of Ethereum blockchains. Ganache
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 顶层显示了各种 Ethereum 区块链。Ganache
- en: tool produces a local and single-node Ethereum blockchain and allows
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 平台都是可以用智能合约构建的可能项目。
- en: for development and quick testing of smart contracts and clients.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 开发和快速测试智能合约和客户端。
- en: Development blockchain allows developers to change the genesis file
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 开发区块链允许开发人员更改创世文件
- en: and start a fully controlled blockchain. Developers can issue Ether tokens
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 并启动一个完全受控的区块链。开发者可以发行以太币代币
- en: in the development blockchain and can decide on a permissioned list
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发区块链中，可以决定一个权限列表
- en: for blockchain nodes. Testnets are public Ethereum blockchains that are
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 用于区块链节点的最小可行工具集。测试网是公开的 Ethereum 区块链，
- en: built by the Ethereum community for testing purposes. Testnet Ether
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 由 Ethereum 社区为测试目的而建立。测试网以太币
- en: tokens can be obtained through some public faucets. There is no tradable
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 为去中心化应用程序提供去中心化身份服务。
- en: crypto value for the testnet token. The public mainnet is the production
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 加密价值用于测试网代币。公开主网是生产
- en: '228'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '228'
- en: Chapter 6 ethereum arChiteCture and Overview
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 第 6 章 Ethereum 架构和概览
- en: blockchain of Ethereum, and the Ethers have value and can be traded in
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: Ethereum 的区块链，以太币有价值，可以在
- en: exchanges. In this section, we mention minimal viable tool sets including
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 交易所。在本节中，我们提到了包括
- en: wallet, browser, node client, smart contract IDE, and Web3 to interact with
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: Ethereum 区块链交互的 Web3。
- en: Ethereum blockchains.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: Ethereum 区块链。
- en: '**MetaMask: The Simplest Way to Interact**'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '**MetaMask:与以太坊区块链互动的最简单方式**'
- en: '**with the Ethereum Blockchain**'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '**Ethereum区块链**'
- en: To get hands-on experience with the Ethereum blockchain, one of the
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实际体验以太坊区块链，其中之一的
- en: easiest steps is to use a wallet to create an account and do some simple
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的步骤是使用钱包创建一个账户并进行一些简单的
- en: transactions of sending and receiving crypto tokens. This can be done in
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 发送和接收加密代币的交易。这可以在
- en: Ethereum by using MetaMask. MetaMask is a web extension that can be
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 使用MetaMask连接以太坊。MetaMask是一个网络扩展，可以被
- en: installed onto a web browser to create accounts to interact with Ethereum
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 安装在网络浏览器上以与以太坊互动创建账户
- en: 'with the following steps:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '以下步骤:'
- en: '*Step 1: Install the MetaMask extension and create*'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '步骤 1: 安装MetaMask扩展并创建'
- en: '*crypto accounts*'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '**加密账户**'
- en: Go to [https://metamask.io and ins](https://metamask.io)tall MetaMask
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 [https://metamask.io 和 ins](https://metamask.io)tall MetaMask
- en: to your web browser such as Chrome or Firefox.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 到您的网络浏览器，如Chrome或Firefox。
- en: After the installation, open MetaMask and write
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 安装后，打开MetaMask并写下
- en: down the mnemonic passphrase of the wallet. The
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 写下钱包的助记词。这个
- en: passphrase is 12 English words that are used to
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 密码短语是 12 个英文单词，用于
- en: represent the private key of a wallet. This passphrase
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 代表钱包的私钥。这个密码短语
- en: needs to be stored securely because it is needed to
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 需要安全地存储，因为它需要用来
- en: recover the wallet if the MetaMask is mistakenly
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 如果MetaMask被错误地
- en: uninstalled or the computer system stops working
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 未安装或计算机系统停止工作
- en: and the MetaMask needs to be reinstalled. Once you
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 如果MetaMask被错误地
- en: create a crypto account with MetaMask, there will
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 使用MetaMask创建一个加密账户，会有
- en: be a public address for the account. This address is
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 对于账户有一个公共地址。这个地址是
- en: also called the account address and can be used to
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 也称为账户地址，可以用来
- en: receive cryptocurrency for the account.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 为账户接收加密货币。
- en: '229'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '229'
- en: Chapter 6 ethereum arChiteCture and Overview
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 第 6 章以太坊架构概述
- en: '*Step 2: Fund MetaMask account*'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '步骤 2: 充MetaMask账户'
- en: Depending on the type of Ethereum blockchain you
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您要连接的以太坊区块链类型
- en: are connecting with, there might be different ways to
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 连接的，可能会有不同的方法来
- en: get the wallet account funded.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 为钱包账户注资。
- en: For development blockchains that are created
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 为创建的开发区块链
- en: by developers or through ganache_cli, there will
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 通过开发者或通过ganache_cli，会有
- en: be some default accounts created and funded.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 可能有一些默认账户创建和注资。
- en: Whoever starts the development blockchain will
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 谁开始开发区块链，就会
- en: have some Ethers minted automatically in the
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在
- en: accounts owned by the developer. Developers
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者拥有的账户。开发者
- en: can import these funded accounts to their
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将这些注资账户导入到他们的
- en: MetaMask wallet.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: MetaMask钱包。
- en: For testnets such as Rinkeby, Kovan, Ropsten, and
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 对于如Rinkeby、Kovan、Ropsten和
- en: Goerli, the test token can be obtained through a
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Goerli这样的测试网，可以通过一个
- en: faucet. Developers can go to the faucet URL, paste
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 水龙头。开发者可以访问水龙头URL，粘贴
- en: a social media message with the wallet account’s
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在社交媒体消息中附上钱包账户的
- en: public address, and send it to the faucet web server.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 公共地址，并将其发送到水龙头网站服务器。
- en: The faucet will then send a small amount of testnet
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 水龙头随后会发送一小笔测试网
- en: Ether to the address specified in the message.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 将以太币发送到消息中指定的地址。
- en: For mainnet Ethereum, the Ether needs to be
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 对于主网以太坊，需要支付以太币
- en: purchased. This can be done by opening an
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 购买。这可以通过打开一个
- en: exchange account from services such as Coinbase
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 从Coinbase等服务平台创建一个
- en: and paying with FIAT to get Ether.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 用法定货币支付以获取以太币。
- en: '*Step 3: Send and receive tokens*'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '步骤 3: 发送和接收代币'
- en: Once the crypto account is created and funded,
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建并注资加密账户，
- en: users can start sending and receiving tokens.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以开始发送和接收代币。
- en: To send tokens, simply click Send and fill in Nonce,
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 发送代币，只需点击发送并填写Nonce，
- en: receiving amount, and receiver address and then
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 接收金额，然后接收地址，然后
- en: click “Send” after verifying information.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 验证信息后点击“发送”。
- en: '230'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '230'
- en: Chapter 6 ethereum arChiteCture and Overview
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 第 6 章以太坊架构概述
- en: To receive tokens, just give the account address to
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 要接收代币，只需将账户地址给
- en: the sender, and let the sender send cryptocurrency
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 发送者，让发送者发送加密货币
- en: to that address.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 发送到该地址。
- en: '**Etherscan: The Most Comprehensive**'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '**Etherscan:最全面**'
- en: '**Blockchain Browser**'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '**区块链浏览器**'
- en: When transactions are transported to and executed in Ethereum, they
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 当交易被传输到并在以太坊中执行时，它们
- en: induce Ethereum state changes in account balances, blocks, transactions,
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 导致以太坊状态变化，如账户余额、区块、交易，
- en: smart contracts, and event logs. The Ethereum blockchain only records
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约和事件日志。以太坊区块链只记录
- en: raw data in its storage. To browse the blockchain and make sense of it,
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在其存储中以原始数据形式存储。为了浏览区块链并弄懂它，
- en: some of the data will need to be processed and stored in databases for
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 一些数据将需要在数据库中进行处理和存储
- en: easy query and visualization. Etherscan is a web service that provides an
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 轻松查询和可视化。Etherscan是一个提供
- en: excellent Ethereum blockchain browsing experience. To use Etherscan,
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 出色的以太坊区块链浏览体验。要使用Etherscan，
- en: simply open any web browser and point the URL to http://etherscan.io.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 只需打开任何网络浏览器，并将URL指向http://etherscan.io。
- en: You can use the Etherscan browser to browse every account, smart
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用Etherscan浏览器浏览每个账户、智能
- en: contract, block, and transaction in Ethereum blockchain. For developers
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 合约、区块和以太坊区块链中的交易。对于开发者
- en: who need to use the blockchain data programmatically, Etherscan also
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 需要使用区块链数据编程的人员，Etherscan还
- en: provide API functions and an API key to integrate dynamic Ethereum
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 提供API功能和API密钥以集成动态以太坊
- en: blockchain data into your decentralized applications. Etherscan, as well
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 将区块链数据集成到您的去中心化应用程序中。Etherscan还
- en: as other Ethereum blockchain browsers, only works with Ethereum public
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他以太坊区块链浏览器一样，只支持以太坊公共
- en: blockchains, such as mainnet, Rinkeby, Kovan, Ropsten, and Goerli; it
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链，如主网、Rinkeby、Kovan、Ropsten和Goerli；它
- en: does not work with development blockchains.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 不适用于开发区块链。
- en: '**Geth: The Swiss Army Knife for the**'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '**Geth：瑞士军刀式的**'
- en: '**Ethereum Blockchain**'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '**以太坊区块链**'
- en: Geth stands for Go Ethereum and is a stand-alone Ethereum client that
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: Geth代表Go Ethereum，是一个独立的以太坊客户端，
- en: can run on an operating system as a miner node to earn Ether, or as an
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在操作系统上作为挖矿节点赚取以太币，或者作为
- en: RPC node to provide RPC services to client applications. We recommend
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: RPC节点为客户端应用程序提供RPC服务。我们建议
- en: developers download a version of geth and use it as a sandbox with
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者下载geth的一个版本并将其作为沙盒使用
- en: following steps to interact with Ethereum blockchain.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤与以太坊区块链交互。
- en: '231'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '231'
- en: Chapter 6 ethereum arChiteCture and Overview
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 第6章 以太坊架构和概览
- en: '*Task 1: Prepare a geth standalone client*'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '*任务1：准备一个geth独立客户端*'
- en: Geth client repository is located at [https://geth.ethereum.org/](https://geth.ethereum.org/downloads/)
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: Geth客户端仓库位于 [https://geth.ethereum.org/](https://geth.ethereum.org/downloads/)
- en: '[downloads/.](https://geth.ethereum.org/downloads/)'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '[downloads/.](https://geth.ethereum.org/downloads/)'
- en: 'You can also download it from GitHub at the following location:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以从GitHub以下位置下载：
- en: '[https://github.com/ethereum/go- ethereum.](https://github.com/ethereum/go-ethereum)'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/ethereum/go-ethereum](https://github.com/ethereum/go-ethereum)'
- en: Geth client is supported by major operating systems such as Linux,
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: Geth客户端支持如Linux、
- en: Windows, and MacOS. Since it is open source, it is recommended that
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: Windows，和MacOS。由于它是开源的，建议
- en: developers run it in Linux systems such as Ubuntu.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者可以在如Ubuntu的Linux系统中运行它。
- en: To compile geth from its source code, the Go programming language
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 要从其源代码编译geth，需要使用Go编程语言
- en: compiler will need to be installed. Developers can use the Golang
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器需要安装。开发者可以使用Golang
- en: compiler for geth compilation.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器用于geth编译。
- en: '*Task 2: Run geth application*'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '*任务2：运行geth应用程序*'
- en: The geth application can run with various options. The full instruction
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: geth应用程序可以与各种选项运行。完整的指令
- en: is locate[d in https://geth.ethereum.org/docs/](https://geth.ethereum.org/docs/).
    You can run it with the --miner option to do mining, but this is not recommended
    because
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 位于 https://geth.ethereum.org/docs/。您可以使用--miner选项运行它进行挖矿，但这不建议，因为
- en: Ethereum mining difficulty level is high, and it is almost impossible to
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊挖矿难度高，几乎不可能
- en: compete with big mining pools in proof-of-work (POW) blockchains.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 与大型挖矿池在工作量证明（POW）区块链中竞争。
- en: 'Geth can run as a sandbox for the following functions:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: Geth可以作为以下功能的沙盒：
- en: • Use geth to build a development blockchain.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: • 使用geth构建开发区块链。
- en: • Use geth as a full blockchain client to download the
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: • 使用geth作为完整的区块链客户端下载
- en: whole Ethereum testnet or mainnet blockchain.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 整个以太坊测试网或主网区块链。
- en: • Use geth as an RPC service to query blockchain
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: • 使用geth作为RPC服务查询区块链
- en: information and broadcast transactions to all
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 信息和将交易广播到所有
- en: blockchain nodes.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链节点。
- en: • Use geth as a JavaScript console to interact with
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: • 使用geth作为JavaScript控制台与
- en: blockchains.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链。
- en: '*Task 3: Interact with geth RPC service*'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '*任务3：与geth RPC服务交互*'
- en: Once a geth node is set up with RPC service running, users can use
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦geth节点设置了运行RPC服务的，用户可以使用
- en: wallets, applications, or the JavaScript console to connect to the RPC
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 钱包、应用程序或JavaScript控制台连接到RPC
- en: endpoint.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 端点。
- en: '232'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '232'
- en: Chapter 6 ethereum arChiteCture and Overview
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 第6章以太坊架构和概述
- en: A. Through MetaMask custom RPC connection
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: A. 通过MetaMask自定义RPC连接
- en: To connect to an RPC service from MetaMask, simply
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 从MetaMask连接到RPC服务，只需
- en: open MetaMask, click to open the Network list, and
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 打开MetaMask，点击打开网络列表，然后
- en: choose Custom RPC to open up a new network widget.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 选择自定义RPC以打开新的网络小部件。
- en: Specify a network name, and enter the RPC endpoint
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 指定网络名称，输入RPC端点
- en: and the chainId of the network. The chainId is an
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 网络的chainId。chainId是一个
- en: identifier that is unique for all blockchains as specified
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一标识符，该标识符对所有区块链都是指定的
- en: by Ethereum standard EIP-155\. If you are working on
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 由以太坊标准EIP-155定义。如果你正在从事
- en: building a development network, you can specify a
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 建立开发网络，你可以指定一个
- en: chainId in the genesis file. You can optionally specify
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 在创世文件中设置chainId。你可以选择性地指定
- en: the currency symbol for the blockchain and a URL
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链的货币符号和一个URL
- en: for the block browser. Click Save to attach the new
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 为区块浏览器。点击保存以附加新的
- en: RPC node.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: RPC节点。
- en: Once MetaMask is attached to the RPC node specified
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦MetaMask附加到指定的RPC节点
- en: earlier, it will interact with the blockchain to which
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面提到的，它将与附加的
- en: the node is connected. You can use MetaMask to send
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 节点连接。你可以使用MetaMask发送
- en: and receive transactions through the RPC node for a
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 通过RPC节点为智能合约发送和接收交易
- en: development blockchain.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 开发区块链。
- en: B. Through JavaScript console
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: B. 通过JavaScript控制台
- en: Geth can run not only as a blockchain node but also
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: Geth不仅可以作为一个区块链节点运行，还可以
- en: as a client to attach to an RPC endpoint and involve a
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 作为客户端连接到RPC端点并参与
- en: command-line console to provide interactive scripting
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行控制台提供交互式脚本
- en: to the blockchain.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链。
- en: To attach to an RPC node and open up a JavaScript
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到RPC节点并打开JavaScript
- en: console, simply type
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制台，只需输入
- en: geth attach [rpc_url]
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: geth attach [rpc_url]
- en: '233'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '233'
- en: Chapter 6 ethereum arChiteCture and Overview
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 第6章以太坊架构和概述
- en: Here, rpc_url is the RPC endpoint for an Ethereum
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，rpc_url是以太坊的RPC端点
- en: client node with RPC service enabled.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 带有RPC服务的客户端节点。
- en: The JavaScript console will allow users to query block
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript控制台将允许用户查询区块
- en: information, balances, transactions, blockchain
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 信息、余额、交易、区块链
- en: syncing status, event logs, etc. For JavaScript console
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 同步状态、事件日志等。对于JavaScript控制台
- en: syntax, refer to the following document.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 语法，请参考以下文档。
- en: '[https://geth.ethereum.org/docs/interface/](https://geth.ethereum.org/docs/interface/javascript-console)'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://geth.ethereum.org/docs/interface/](https://geth.ethereum.org/docs/interface/)'
- en: '[javascript- console](https://geth.ethereum.org/docs/interface/javascript-console),
    Console syntax'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '[javascript-console](https://geth.ethereum.org/docs/interface/javascript-console)，控制台语法'
- en: '[https://web3js.readthedocs.io/en/v1.2.9/,](https://web3js.readthedocs.io/en/v1.2.9/)'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://web3js.readthedocs.io/en/v1.2.9/,](https://web3js.readthedocs.io/en/v1.2.9/)'
- en: Ethereum JavaScript API
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: Ethereum JavaScript API
- en: C. Through a third-party application such as Truffle
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: C. 通过像Truffle这样的第三方应用程序
- en: or Remix
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 或Remix
- en: Third-party applications will attach to an RPC endpoint
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 第三方应用程序将附加到一个RPC端点
- en: to interact with Ethereum blockchains. Smart contract
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 与以太坊区块链互动。智能合约
- en: compiling tools such as Truffle and Remix all have
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 例如Truffle和Remix的编译工具都有
- en: features to connect to an RPC server. Once an RPC
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到RPC服务器的功能。一旦RPC
- en: endpoint is connected, the smart contract bytecode
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 端点连接后，智能合约字节码
- en: files that are compiled will be sent to the attached
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 编译的文件将发送到附加的
- en: RPC server and then broadcasted to the rest of the
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: RPC服务器，然后广播到其余的
- en: blockchain network.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链网络。
- en: Geth is the most popular Ethereum client adopted by the developer
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: Geth是最受欢迎的以太坊客户端，被开发者
- en: community. Besides geth, there are other clients such as Java-based Besu
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 社区。除了geth，还有其他客户端，如基于Java的Besu
- en: and quorum clients that can be used. Geth nodes can download the full
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 和可以使用的quorum客户端。Geth节点可以下载完整的
- en: blockchain to local storage, so having a system with hundreds of gigabyte
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链到本地存储，所以需要一个拥有数百吉字节的系统
- en: storage is a requirement for running geth in full node mode.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 在全节点模式下运行geth需要数百吉字节的存储。
- en: '234'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '234'
- en: Chapter 6 ethereum arChiteCture and Overview
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 第6章以太坊架构和概述
- en: '**Truffle: The Most Comprehensive Smart Contract**'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '**Truffle:最全面的智能合约**'
- en: '**Development Tool**'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: '**开发工具**'
- en: Truffle is a smart contract development tool that allows users to compile,
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: Truffle是一个允许用户编译、
- en: test, debug, and deploy Solidity code. It is easy to try out Truffle in a
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 测试、调试和部署Solidity代码。尝试Truffle非常容易
- en: sandbox to get a good understanding about how to compile and deploy
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 沙盒以了解如何编译和部署
- en: smart contracts.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约。
- en: '*Task 1: Install Truffle package*'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: '*任务1：安装Truffle包*'
- en: The Truffle package can be downloaded and installed through node
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: Truffle包可以通过node
- en: 'package manager (npm):'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 包管理器（npm）：
- en: npm install -g truffle
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: npm install -g truffle
- en: Here, the flag g means to install it globally so that the Truffle
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，g标志意味着全局安装，以便Truffle
- en: application can be launched from any directory.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序可以从任何目录启动。
- en: '*Task 2: Prepare a project*'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: '*任务2：准备一个项目*'
- en: Truffle has an init command that allows a developer to create a
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: Truffle有一个init命令，允许开发者创建一个
- en: sandbox project for smart contracts. Simply go to a target directory and run
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约的沙盒项目。只需转到目标目录并运行
- en: 'the following command:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令：
- en: truffle init
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: truffle init
- en: A sample project will be created with sample smart contract and
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 一个示例项目将被创建，带有示例智能合约和
- en: configuration files.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件。
- en: You can also replace the sample smart contract with your own smart
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以用你自己的智能合约替换示例智能合约
- en: contract and use a new configuration file.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 合约，并使用一个新的配置文件。
- en: '*Task 3: Compile and deploy a smart contract*'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: '*任务3：编译并部署智能合约*'
- en: Before compiling or deploying a smart contract, the Truffle
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译或部署智能合约之前，Truffle
- en: configuration file will need to be configured. The Truffle tool uses the
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件需要进行配置。Truffle工具使用
- en: default file name of truffle-config.js file to look for the configuration. This
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的文件名truffle-config.js文件来查找配置。这个
- en: configuration file has two major components to configure. The first is the
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件有两个主要配置组件。第一个是
- en: network component, where you need to specify which blockchain network
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 网络组件，您需要指定哪个区块链网络
- en: the compiled smart contract will be deployed onto. The configuration
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 编译后的智能合约将被部署到。配置
- en: '235'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: '235'
- en: Chapter 6 ethereum arChiteCture and Overview
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 第6章以太坊架构和概述
- en: for the network will include network name, host address for the RPC
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 网络将包括网络名称、RPC的主机地址
- en: endpoint, port number for the RPC endpoint, and network_id. The second
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 端点、RPC端点的端口号和network_id。第二个
- en: configuration component is the compiler. For compiler configuration, the
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 配置组件是编译器。对于编译器配置，
- en: Solidity compiler version will need to be specified.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: Solidity编译器版本需要指定。
- en: module.exports = {
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 模块导出={
- en: 'networks: {'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 网络：{
- en: 'development: {'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 开发：{
- en: 'host: "127.0.0.1",'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 主机："127.0.0.1"，
- en: 'port: 8545,'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 端口：8545，
- en: 'network_id: "*" // Match any network id'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 网络_id："*" // 匹配任何网络id
- en: '}'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '},'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: 'compilers: {'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器：{
- en: 'solc: {'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: solc：{
- en: 'version: "^0.8.0"'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 版本："^0.8.0"
- en: '}'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '};'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: Once the project is ready for compilation, simply run
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦项目准备好编译，只需运行
- en: truffle compile
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: truffle编译
- en: The compiled result will be stored in the directory of build. This
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 编译结果将存储在build目录中。这个
- en: directory will contain the bytecode and ABI (Application Bytecode
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 目录将包含字节码和ABI（应用程序字节码
- en: Interface) files. Smart contract bytecodes are the executable codes that will
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 接口）文件。智能合约的字节码是将要
- en: be deployed to the blockchain. The ABI code is used as a function lookup
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 部署到区块链。ABI代码用作函数查找
- en: map for external applications to call the smart contract.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 映射，以便外部应用程序调用智能合约。
- en: To deploy a compiled smart contract from Truffle, simply type
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 要从Truffle部署编译后的智能合约，只需输入
- en: truffle deploy
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: truffle deploy
- en: '236'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: '236'
- en: Chapter 6 ethereum arChiteCture and Overview
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 第6章以太坊架构和概述
- en: This command will invoke deployment operation using the truffle-
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将调用使用truffle-
- en: config.js file. It will deploy the smart contract to the network by using the
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: config.js文件。它将使用
- en: RPC client service specified in the network section of the configuration file.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件中指定的RPC客户端服务。
- en: There is one more thing that needs to be emphasized. When deploying
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件事需要强调。在部署
- en: a smart contract, the developer needs to have a wallet to send the
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 部署智能合约，开发者需要有一个钱包来发送
- en: deployment transaction to the blockchain. For development blockchains,
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 部署交易到区块链。对于开发区块链，
- en: because this is internal and there are no security concerns, a user can
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这是内部的，而且没有安全问题，用户可以
- en: simply add a wallet address in the configuration file. For production
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 只需在配置文件中添加一个钱包地址。对于生产
- en: deployment, strict production security procedures will need to be
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 部署，严格的生产安全程序将需要
- en: followed, including using a hardware wallet or signing offline transactions.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 按照步骤进行，包括使用硬件钱包或签名离线交易。
- en: '*Task 4: Use the Truffle console* *to interact with blockchains*'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: '*任务4：使用Truffle控制台* *与区块链交互*'
- en: Truffle provides a console command to interact with the attached
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: Truffle提供了一个控制台命令来与附加的
- en: blockchain node. There are two types of consoles available. One is a
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链节点。有两种类型的控制台可供使用。一个是
- en: console that is connected to a testnet or mainnet blockchain. This console
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到测试网或主网区块链的控制台。这个控制台
- en: 'is launched through the following command:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下命令启动：
- en: truffle console
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: truffle console
- en: Another console is connected to a development blockchain. This
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个控制台连接到一个开发区块链。这个
- en: 'console is launched through the following command:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台通过以下命令启动：
- en: truffle develop
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: truffle develop
- en: The major difference between a regular console and a development
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 普通控制台和开发控制台之间的主要区别是
- en: console is that a regular console connects to an existing blockchain,
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 普通控制台连接到一个现有的区块链，
- en: while a development console creates an embedded blockchain, default
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 而开发控制台创建一个嵌入式区块链，默认
- en: accounts, and issued tokens for use by the developers.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 账户，并为开发者使用发行代币。
- en: '237'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: '237'
- en: Chapter 6 ethereum arChiteCture and Overview
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 第6章 以太坊架构和概览
- en: Once a Truffle console is launched, developers can use it to query
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Truffle控制台启动，开发者可以使用它来查询
- en: blockchain information, send and receive tokens, and call smart contract
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链信息，发送和接收代币，以及调用智能合约
- en: functions. To call a smart contract function, the following steps are
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 函数。要调用智能合约函数，按以下步骤进行：
- en: 'followed:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 按以下步骤进行：
- en: • From the console, instantiate a smart contract object
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: • 从控制台，实例化一个智能合约对象
- en: from its address and corresponding ABI.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 从其地址和相应的ABI。
- en: • Get an account from the blockchain.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: • 从区块链获取一个账户。
- en: • Call the instance smart contract function with a sender
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: • 使用发送者调用实例智能合约函数
- en: account and other parameters.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 账户和其他参数。
- en: 'The full example can be referenced at the following location:'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的示例可以在以下位置参考：
- en: '[www.trufflesuite.com/docs/truffle/getting- started/interacting-](https://www.trufflesuite.com/docs/truffle/getting-started/interacting-with-your-contracts)'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.trufflesuite.com/docs/truffle/getting- started/interacting-](https://www.trufflesuite.com/docs/truffle/getting-started/interacting-with-your-contracts)'
- en: '[with- your- contracts](https://www.trufflesuite.com/docs/truffle/getting-started/interacting-with-your-contracts)'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: '[带有-您的-合同](https://www.trufflesuite.com/docs/truffle/getting-started/interacting-with-your-contracts)'
- en: Truffle is a very comprehensive and complex system. This section only
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: Truffle是一个非常全面和复杂的系统。这一部分只
- en: mentions the features needed for compiling, deploying, and testing smart
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 提到了编译，部署和测试智能合约所需的功能
- en: 'contracts. For details, refer to the Truffle office website:'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 合同。详细信息请参考Truffle官方网站：
- en: '[www.trufflesuite.com/docs/truffle/quickstart](http://www.trufflesuite.com/docs/truffle/quickstart)'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.trufflesuite.com/docs/truffle/quickstart](http://www.trufflesuite.com/docs/truffle/quickstart)'
- en: '**Remix: The Most Convenient Web-Based Smart**'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: '**Remix：最便捷的基于网页的智能**'
- en: '**Contract Development Tool**'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: '**合同开发工具**'
- en: Remix is a web-based smart contract programming suite that is very easy
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: Remix是一个基于网页的智能合约编程套件，非常容易
- en: to use. Remix can run as a browser web page or as a desktop application.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 使用。Remix可以在浏览器网页上运行，也可以作为桌面应用程序运行。
- en: To use Remix on a browser, simply open the Chrome or Firefox browser
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 要在浏览器上使用Remix，只需打开Chrome或Firefox浏览器
- en: 'and point to the following location:'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 并指向以下位置：
- en: '[https://remix.ethereum.org](https://remix.ethereum.org)'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://remix.ethereum.org](https://remix.ethereum.org)'
- en: '238'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: '238'
- en: '![](index-250_1.jpg)'
  id: totrans-590
  prefs: []
  type: TYPE_IMG
  zh: '![](index-250_1.jpg)'
- en: Chapter 6 ethereum arChiteCture and Overview
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 第6章 以太坊架构和概览
- en: '***Figure 6-6\.** Remix compiler*'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: '***图6-6.* Remix编译器*'
- en: 'There are four sections in the IDE: the icon panel on the left, the side'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: IDE中有四个部分：左边的图标面板，侧边
- en: panel in the middle, the main panel on the top right, and the terminal on
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 中间的面板，右上角的主要面板，以及
- en: the bottom left as shown in Figur[e 6-6\.](#p250)
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 如图6-6所示](#p250)
- en: '**Icon panel** – Shows the file explorer, remix plug-ins,'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: '**图标面板** – 显示文件浏览器，Remix插件，'
- en: plug-in manager, and general setup icon.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 插件管理器和一般设置图标。
- en: '**Side panel** – Shows source code files and GUI for'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: '**侧边栏** – 显示源代码文件和GUI for'
- en: each plug-in when selected.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 当选择每个插件时。
- en: '**Main panel** – Shows the source file content for'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: '**主面板** – 显示源文件内容为'
- en: each smart contract. Source files can be edited in
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 每个智能合约的源文件可以在
- en: this panel.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 此面板。
- en: '**Terminal** – Shows the result of compilation,'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: '**终端** – 显示编译结果，'
- en: deployment, and interaction with the blockchain.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 部署和与区块链的交互
- en: Can also run scripts on this panel.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以在这个面板上运行脚本。
- en: '239'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: '239'
- en: Chapter 6 ethereum arChiteCture and Overview
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 第6章 以太坊架构和概览
- en: For the remix web console, you can easily experiment with the
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Remix Web控制台，您可以轻松地实验
- en: 'following tasks:'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 以下任务：
- en: '*Task 1: Set up and install plug-ins*'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 任务1：设置和安装插件
- en: The Remix IDE (integrated development environment) uses
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 混音集成开发环境（IDE）使用
- en: component models to add basic features and third-party plug-ins to
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 添加基本功能和第三方插件的组件模型
- en: the system. The icon panel by default activates and shows three basic
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 系统。默认情况下，图标面板激活并显示三个基本
- en: 'components: the file explorer, Solidity compilation, and deploy and run'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 组件：文件浏览器，Solidity编译，部署和运行
- en: transactions. These three components should be sufficient for quick smart
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 事务。这三个组件应足以进行快速智能合约
- en: contract development. For other operations such as debugging, security
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 合约开发。对于其他操作，如调试、安全
- en: scan, and visualization, developers can click the Plugin Manager icon and
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 扫描和可视化，开发者可以点击插件管理图标
- en: select the intended plug-in to activate.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 选择打算激活的插件。
- en: Plug-ins can be activated or deactivated as needed by the developers.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者可以根据需要激活或禁用插件。
- en: The icon panel also contains a settings button that can launch a settings
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 图标面板还包含一个设置按钮，可以启动设置
- en: page to configure the theme of the GUI, the source code editor, access to
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 页面以配置GUI的主题，源代码编辑器，访问
- en: GitHub, etc. Once plug-ins are activated, developers can click each plug-
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 例如GitHub等。一旦插件被激活，开发者可以点击每个插件
- en: in icon, and the side panel will show the interface and GUI details of the
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 图标，侧边栏将显示界面和GUI详细信息
- en: corresponding plug-in.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的插件。
- en: '*Task 2: Browse, edit, and compile a smart contract*'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 任务2：浏览，编辑和编译智能合约
- en: The Remix packages some sample smart contracts in the web server.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 混音在Web服务器中包含一些示例智能合约。
- en: Click the File Explorer icon to open up the smart contract browsing
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 点击文件浏览器图标以打开智能合约浏览
- en: panel. The source file of the smart contracts can be created as a new file
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 面板。智能合约的源文件可以创建为一个新文件
- en: or imported from repositories such as Gist, GitHub, Swarm, IPFS, or an
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 或从Gist，GitHub，Swarm，IPFS等仓库导入
- en: HTTPS URL. One thing to note is that if a source file is imported from
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 的HTTPS URL。需要指出的是，如果智能合约的源文件从
- en: an external repository, the modified file will not be written back to the
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 外部仓库，修改后的文件不会被写回
- en: repository, and some manual operations are needed. For example, a
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库，需要一些手动操作。例如，一个
- en: workspace can be published as a gist in a GitHub repository. For other
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 工作区可以作为Gist发布到GitHub仓库。对于其他
- en: repositories such as IPFS, HTTPS, and Swarm, manual uploads outside
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 从Gist，GitHub，Swarm，IPFS等仓库导入，或者从外部
- en: Remix are needed.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 需要进行混音。
- en: '240'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: '240'
- en: Chapter 6 ethereum arChiteCture and Overview
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 第6章 以太坊架构和概览
- en: To compile a smart contract, first, browse the source files and click
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译智能合约，首先，浏览源文件并点击
- en: the file you want to edit. The file content will be shown on the main panel.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要编辑的文件。文件内容将在主面板中显示。
- en: Developers can then simply modify the source code using the embedded
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者可以使用内嵌的源代码编辑器修改源代码
- en: editor. Once files are edited, click the Solidity Compiler button. This
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑器。一旦文件被编辑，点击Solidity编译器按钮。这时
- en: will launch a compiler GUI in the side panel. After selecting the Solidity
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 将启动侧边栏的编译器GUI。在选择Solidity
- en: compiler version and EVM to use, developers can click the Compile button
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器版本和EVM使用，开发者可以点击编译按钮
- en: to start compilation. Any compilation errors will be shown on the compiler
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 开始编译。任何编译错误都会在编译器
- en: panel, and developers will be prompted to modify the source code to fix
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 面板，并提示修改源代码以修复错误
- en: the error. Once a smart contract compiles successfully, bytecodes and ABI
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦智能合约成功编译，字节码和ABI
- en: files will be generated.
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 将生成文件。
- en: One thing to note is that the modified source code is stored in the
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，修改后的源代码存储在
- en: browser only, and additional steps need to be taken to save it to permanent
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器仅限，需要采取其他步骤将其保存到永久
- en: storage. This can be done by downloading the file to local storage, or
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 存储。这可以通过将文件下载到本地存储或
- en: publishing the file to a new gist in GitHub storage. Since the Remix browser
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 将文件发布到GitHub存储的新gist中。由于Remix浏览器
- en: does not have persistent storage, files that are edited but not downloaded
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 不具有持久存储，未下载的文件将被编辑
- en: or published will be erased if the browser data is cleared. To synchronize
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 如果浏览器数据被清除，存储在浏览器中的智能合约代码
- en: the Remix browser with persistent storage, the Remix web page will need
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 与持久存储一起使用的Remix浏览器，Remix网页需要
- en: to be connected to local storage. This is done by running a remixd in the
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 需要连接到本地存储。这可以通过在
- en: background that provides shared persistent storage for Remix.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 在后台为Remix提供共享持久存储。
- en: '*Task 3: Deploy a smart contract and execute functions*'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: '*任务3：部署智能合约并执行函数*'
- en: Once a smart contract is compiled successfully, developers can use
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦智能合约成功编译，开发者可以使用
- en: the “*deploy and run transactions*” plug-in to deploy smart contracts and
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 部署智能合约和使用
- en: run transactions. After clicking the Deploy and Run transactions icon, a
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 运行交易。点击“部署和运行交易”图标后，将出现一个
- en: deployment GUI will prompt developers to choose a network connection
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 部署GUI将提示开发者选择网络连接
- en: environment, deployment account, smart contract to deploy, gas fee, etc.,
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 环境、部署账户、要部署的智能合约、燃料费等，
- en: as shown in Figur[e 6-7\.](#p253)
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 如图所示[图6-7.](#p253)
- en: '241'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: '241'
- en: '![](index-253_1.jpg)'
  id: totrans-665
  prefs: []
  type: TYPE_IMG
  zh: '![](index-253_1.jpg)'
- en: Chapter 6 ethereum arChiteCture and Overview
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 第6章以太坊架构和概览
- en: '***Figure 6-7\.** Remix compiler widget*'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: '***图6-7.** Remix编译器小部件*'
- en: 'There are three kinds of deployment environments: JavaScript VM,'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 部署环境有三种：JavaScript VM、
- en: injected Web3, and Web3 provider. The JavaScript VM is an environment
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 注入的Web3，和Web3提供者。JavaScript VM是一个环境
- en: where the EVM is embedded within the Remix web page and is a
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 在Remix网页中嵌入EVM，是
- en: simulated use case where no blockchain is actually connected. This is
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟用例，其中没有实际连接区块链。这是
- en: the easiest case for deploying and testing a smart contract. The injected
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 部署和测试智能合约的最简单案例。注入的
- en: Web3 environment uses the MetaMask extension to connect Remix with
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: Web3环境使用MetaMask扩展将Remix与
- en: an external blockchain through MetaMask configurations. Instead of using
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 通过MetaMask配置连接外部区块链。 instead of using
- en: '242'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: '242'
- en: Chapter 6 ethereum arChiteCture and Overview
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 第6章以太坊架构和概览
- en: Remix, the MetaMask is used to connect to the blockchain and serves as a
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: Remix，MetaMask用于连接区块链并作为
- en: proxy to deploy the smart contract to the intended blockchain. The “Web3
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 代理将智能合约部署到目标区块链。 “Web3
- en: provider” environment connects Remix with an RPC endpoint and deploys
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 提供者”环境将Remix与RPC端点连接并部署
- en: the smart contract to that RPC server and then broadcasts to the rest of the
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约到那个RPC服务器，然后广播给其余的
- en: network.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 网络。
- en: Besides choosing a blockchain network environment, developers also
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 除了选择区块链网络环境外，开发者还
- en: need to specify an account for sending the deployment transactions. This
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 需要指定一个发送部署交易的账户。这个
- en: account should have some Ether to pay for the gas fee for the deployment.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 账户应该有一些以太币来支付部署的燃料费。
- en: This account will also become the owner of the smart contract. There are
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 这个账户也将成为智能合约的所有者。有一些
- en: other miscellaneous parameters to configure. “Gas limit” specifies the
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 其他杂项参数进行配置。“气体限制”指定
- en: maximum amount of gas that the transaction can consume. “Value” is
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 交易可以消耗的最大气体量。“值”是
- en: the token to be sent to a target address. For smart contract deployment,
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 将代币发送到目标地址。对于智能合约部署，
- en: the “Value” is irrelevant and should be set to zero. Once all parameters
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: “值”无关，应设置为零。一旦所有参数
- en: are set correctly, click the “Deploy” button to send out the deployment
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 正确设置，点击“部署”按钮发出部署
- en: transaction. Some smart contracts might have constructors that take input
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 交易。一些智能合约可能具有构造函数，它接受输入
- en: parameters. In that case, the input parameters need to be specified in the
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 参数。在这种情况下，输入参数需要在
- en: input field beside the Deploy button.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 部署按钮旁边的输入字段。
- en: Once a smart contract is deployed successfully, it will return an
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦智能合约成功部署，它将返回一个
- en: address that is called the smart contract address. Developers can browse
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 被调用为智能合约地址。开发者可以浏览
- en: the blockchain by clicking the address shown at the bottom of the
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击地址底部的
- en: deployment GUI. The deployment smart contract will then show variable
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 部署GUI。部署智能合约后，将显示变量
- en: names and values, functions, and other internal storage information.
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 名称和值、函数以及其他内部存储信息。
- en: Developers can then input parameters into a function and execute the
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者可以在函数中输入参数并执行
- en: function. When calling a smart contract function, the developer is actually
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 函数。当调用智能合约函数时，开发者实际上是
- en: sending a transaction; therefore, there should be an account to pay for the
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 发送交易；因此，应该有一个账户来支付交易费用
- en: transaction, and the transaction parameters should be specified as well.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 交易，交易参数也应该指定。
- en: The execution results will be shown in the same panel, and some output
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 执行结果将在相同的面板中显示，一些输出
- en: will be shown in the terminal panel.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 终端面板将显示相关信息。
- en: '243'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: '243'
- en: Chapter 6 ethereum arChiteCture and Overview
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: '[第6章 以太坊架构和概览](https://wiki.example.org/feynmans_learning_method)'
- en: '**Summary**'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: '**总结**'
- en: 'Three topics are mentioned in this chapter: overview of the Ethereum'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提到了三个主题：以太坊的概览
- en: blockchain, ecosystem and dApps, and essential tools for smart
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链、生态系统和dApps，以及智能
- en: contract developments. In the next chapter, the Solidity programming
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 合约开发。在下一章中，将介绍Solidity编程
- en: and deployment technology will be covered to teach how to build
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 以及部署技术将得到详细介绍，以教授如何构建
- en: decentralized applications with smart contracts.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 使用智能合约的开发去中心化应用。
- en: '244'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: '244'
- en: '**CHAPTER 7**'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: '**第7章**'
- en: '**Programming Smart**'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: '**智能合约编程**'
- en: '**Contract with Solidity**'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: '**用Solidity编写的合约**'
- en: '**Introduction: What We Learned**'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: '**引言：我们学到了什么**'
- en: '**in the Last Chapter**'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: '**在上次章节中**'
- en: In the previous chapter, we discussed Ethereum architecture, ecosystem,
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，我们讨论了以太坊架构、生态系统，
- en: and decentralized applications. We also described development tools
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 以及去中心化应用开发所必需的工具。我们还描述了
- en: such as MetaMask, Remix, Truffle, and Geth. In this chapter, we are going
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 如MetaMask、Remix、Truffle和Geth。在本章中，我们将
- en: to learn detailed Solidity programming skills for smart contract and
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 要学习智能合约的精确Solidity编程技能，
- en: decentralized application development.
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 去中心化应用开发。
- en: '**What Is Smart Contract**'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: '**智能合约是什么**'
- en: Smart contract is an overloaded phrase. Although there are different
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约是一个过度使用的术语。尽管有不同的
- en: 'interpretations for smart contract, we define it as follows:'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 对智能合约的不同解释，我们将其定义如下：
- en: “A smart contract is an executable computer program that runs on
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: “智能合约是一个在
- en: Ethereum Virtual Machine (EVM) on the blockchain to access and alter
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: Ethereum Virtual Machine (EVM) 上区块链的编程，以访问和修改
- en: the states of blockchain blocks.” Different from conventional computer
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链块的状态。”与传统的计算机
- en: programs that normally run on one single system, smart contracts run on
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 通常在单个系统上运行的程序，智能合约在
- en: every node of the blockchain.
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链的每个节点。
- en: © Weijia Zhang and Tej Anand 2022
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: © 张伟佳 安德 2022
- en: '245'
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: '245'
- en: W. Zhang and T. Anand, *Blockchain and Ethereum Smart Contract Solution Development*,
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 张伟佳，安德，*区块链与以太坊智能合约解决方案开发*，
- en: '[https://doi.org/10.1007/978-1-4842-8164-2_7](https://doi.org/10.1007/978-1-4842-8164-2_7#DOI)'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://doi.org/10.1007/978-1-4842-8164-2_7](https://doi.org/10.1007/978-1-4842-8164-2_7#DOI)'
- en: Chapter 7 programming Smart ContraCt with Solidity
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: '[第7章 用Solidity编程智能合约](https://wiki.example.org/feynmans_learning_method)'
- en: For Ethereum, smart contracts are compiled as executable bytecode
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 对于以太坊，智能合约被编译为可执行的字节码
- en: and deployed to Ethereum blockchain. The bytecodes of a smart contract
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 并部署到以太坊区块链。智能合约的字节码
- en: are sent through the data field of a transaction. Once the transaction is
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 通过交易的数据字段发送。一旦交易被
- en: included in a block, a smart contract address is generated, and the bytecode
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 包含在一个块中，生成智能合约地址，并执行字节码
- en: is stored in that address. To call a function in a smart contract, a transaction
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在该地址中。要调用智能合约中的一个函数，需要发送一个
- en: is sent to the smart contract address, and the function name and input data
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 发送到智能合约地址，以及函数名和输入数据
- en: are supplied through the data field of the transaction. When a transaction to
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 数据字段提供了交易所需的信息。当向
- en: call a smart contract is sent to a node, the Ethereum Virtual Machine loads
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 向节点发送智能合约调用时，Ethereum Virtual Machine 加载
- en: the bytecode from the smart contract address and executes the function.
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 从智能合约地址获取字节码并执行函数。
- en: For a business person, a smart contract defines business attributes
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 对商人来说，智能合约定义了商业属性
- en: and processing logic to let multiple parties to execute and witness the
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 和处理逻辑，让多方执行和见证
- en: processing of the business logic to ensure transparency, reliability, fault
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 处理业务逻辑，确保透明度、可靠性和故障
- en: tolerance, immutability, and integrity for all parties (when the smart
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 宽容度、不可变性和完整性（当智能
- en: contract is well written).
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 合约发送交易时，如果交易编写得当)。
- en: Smart contracts differ from stand-alone computer programs because
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约与独立的计算机程序不同，因为
- en: they are on all the machines and all parties have access to the smart
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 它们在所有机器上，所有各方都可以访问智能
- en: contract to take advantage of transparency, reliability, and other benefits
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 利用透明度、可靠性等优势。
- en: of blockchain.
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链。
- en: But this is only the case where the smart contract is well written. If a
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 但这种情况只适用于智能合约写得好的情况。如果一个
- en: smart contract is poorly written, then all these benefits go away.
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 如果智能合约写得不好，那么所有这些好处都会消失。
- en: For a technical person, a smart contract is a computer program that
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 对于技术人员来说，智能合约是一种运行在
- en: can be coded, compiled, tested, deployed, and executed on a blockchain.
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 可以编写、编译、测试、部署和在一个区块链上执行。
- en: From technical point of view, the phrase “smart contract” can mean
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术角度来看，“智能合约”可以意味着
- en: several things.
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 几件事。
- en: Firstly, it can mean smart contract source code. Secondly, it can mean
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它可以指智能合约源代码。其次，它可以指
- en: a compiled bytecode of a smart contract. Thirdly, it can mean a deployed
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约编译后的字节码。第三，它可以指已部署
- en: smart contract residing on a blockchain.
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 位于区块链上的智能合约。
- en: 'When a smart contract is compiled, two files are generated: a bytecode'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个智能合约被编译时，会生成两个文件：一个字节码
- en: file and an ABI (Application Bytecode Interface). The bytecode of a smart
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 文件和ABI（应用程序字节码接口）。智能合约的字节码是
- en: contract can be deployed to Ethereum blockchain and can be executed
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 合约可以部署到以太坊区块链上，并且可以被执行
- en: by the Ethereum Virtual Machine. The ABI code is a definition and
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 由Ethereum虚拟机执行。ABI代码是定义和
- en: description of smart contract rather than executable code. The ABI file is
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约的描述，而不是可执行代码。ABI文件是
- en: '246'
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: '246'
- en: Chapter 7 programming Smart ContraCt with Solidity
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 第7章用Solidity编程智能合约
- en: used by third-party applications to parse what functions are defined in a
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 被第三方应用程序用来解析在智能合约中定义了哪些函数
- en: deployed smart contract and how to interact with them.
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 部署的智能合约以及如何与它们互动。
- en: When a smart contract is “deployed” to a blockchain, a smart contract
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个智能合约“部署”到一个区块链上时，一个智能合约
- en: address is generated by calculating the Keccak-256 hash of the sender
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 地址是由发送者计算Keccak-256散列生成的
- en: address and transaction nonce encoded with recursive-length prefix (RLP)
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 地址和交易nonce，使用递归长度前缀（RLP）编码
- en: serialization. A smart contract can also be deployed to different
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 序列化。智能合约也可以部署到不同的
- en: blockchains such as testnet or mainnet. The same smart contract address
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 例如testnet或mainnet。相同的智能合约地址
- en: may refer to different blockchains.
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 可能指的是不同的区块链。
- en: It is important to know that “smart contracts” are used in different
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要知道“智能合约”在不同的
- en: scenarios and contexts. In the following sections, we go into detail of smart
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 场景和上下文。在下面的章节中，我们将详细介绍智能
- en: contract programming.
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 合约编程。
- en: '**What Is Solidity Programming Language**'
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: '**什么是Solidity编程语言**'
- en: Solidity is the most popular programming language for Ethereum smart
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: Solidity是用于以太坊智能合约的最流行的编程语言
- en: contracts. Solidity source code can be edited with a simple text editor or
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 合约。Solidity源代码可以用简单的文本编辑器或
- en: through IDE such as Remix or Microsoft Visual Studio. In order for Solidity
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 例如Remix或微软Visual Studio的IDE。为了让Solidity
- en: code to run on Ethereum node, several things need to be done.
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 代码以在以太坊节点上运行，需要做几件事。
- en: Firstly, the source code needs to be compiled into bytecode that can
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，源代码需要编译成可以在
- en: be interpreted and executed by the Ethereum Virtual Machine (EVM).
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 被以太坊虚拟机（EVM）解释和执行。
- en: Secondly, you need to deploy the smart contract bytecode to a blockchain
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，你需要将智能合约字节码部署到一个区块链上
- en: or an EVM emulator for executions.
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: 或者在执行上的EVM模拟器。
- en: A bytecode is a program that can be executed by the Ethereum Virtual
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 字节码是可以在以太坊虚拟机上执行的程序
- en: Machine. A bytecode program contains operands, data, and storage for
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 机器。字节码程序包含操作数、数据和存储
- en: each step. The EVM engine interprets instructions for each step and
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 每一步。EVM引擎为每一步解释指令
- en: executes the instructions.
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 执行指令。
- en: As mentioned in Chapter [6, R](https://doi.org/10.1007/978-1-4842-8164-2_6)emix
    is a web-based integrated development environment (IDE), so developers can write
    code on the web
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 如第[6章R](https://doi.org/10.1007/978-1-4842-8164-2_6)emix是一个基于web的集成开发环境（IDE），因此开发人员可以在web上编写代码
- en: page specified by the URL of remix.ethereum.org. This is very convenient
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 页面由remix.ethereum.org的URL指定。这非常方便
- en: for practicing smart contracting writing, compilation, and testing. The
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 用于练习智能合约编写、编译和测试。该
- en: introduction of Remix has been mentioned in Chapter [6\. T](https://doi.org/10.1007/978-1-4842-8164-2_6)his
    section will be focused on writing the Solidity programs.
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: 介绍Remix已在第[6章](https://doi.org/10.1007/978-1-4842-8164-2_6)中提到This section will
    be focused on writing the Solidity programs.
- en: '247'
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: '247'
- en: Chapter 7 programming Smart ContraCt with Solidity
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: 第7章 使用Solidity编程智能合约
- en: '**Module 1: Hello World Solidity Example**'
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: '**第1模块：Hello World Solidity示例**'
- en: 'Let’s take the first example, HelloWorld.sol, as shown in the following:'
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以第一个例子，HelloWorld.sol为例，如下所示：
- en: /**
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: '`/**`'
- en: '* *SPDX-License-Identifier: MIT*'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: '`* *SPDX-License-Identifier: MIT*`'
- en: '* *@title HelloWorld*'
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: '`* *@title HelloWorld*`'
- en: '* *@dev Implements the hello world program*'
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: '`* *@dev 实现hello world程序*`'
- en: '*/'
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: '`*/`'
- en: '*pragma solidity >=0.7.0 <0.9.0;*'
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: '`pragma solidity >=0.7.0 <0.9.0;`'
- en: '*contract HelloWorld {*'
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: '`contract HelloWorld {`'
- en: '*string helloworld = "Hello World";*'
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: '`string helloworld = "Hello World";`'
- en: '*function justHelloWorld() public view returns(string*'
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: '`function justHelloWorld() public view returns(string`'
- en: '*memory) {*'
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: '`memory) {`'
- en: '*return helloworld;*'
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: '`return helloworld;`'
- en: '*}*'
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: '`}`'
- en: '*function showHelloWorld(string memory me) public view*'
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: '`function showHelloWorld(string memory me) public view`'
- en: '*returns(string memory) {*'
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: '`returns(string memory) {`'
- en: '*string memory result = string(abi.*'
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: '`string memory result = string(abi.*'
- en: '*encodePacked(helloworld, " from ", me));*'
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: '`encodePacked(helloworld, " from ", me));`'
- en: '*return result;*'
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: '`return result;`'
- en: '*}*'
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: '`}`'
- en: '*}*'
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: '`}`'
- en: In this example of helloworld.sol, it starts with comments that
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个helloworld.sol示例中，它从注释开始
- en: describe what the smart contract is about and then a HelloWorld smart
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: 描述智能合约是关于什么，然后是一个HelloWorld智能
- en: contract where two functions are implemented. The first function,
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: 合约中有两个函数实现。第一个函数，
- en: justHelloWorld(), simply outputs a string “HelloWorld”, and the
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: justHelloWorld()，简单地输出一个字符串“HelloWorld”，以及
- en: second function takes an input variable named “me” and then outputs
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个函数接收一个名为“me”的输入变量，然后输出
- en: “HelloWorld from [me]”. This simple smart contract can be compiled,
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: “HelloWorld from [me]”。这个简单的智能合约可以被编译，
- en: deployed, and executed on the blockchain. In the following, we describe
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: 部署在，并在区块链上执行。在下面，我们描述
- en: the syntax of a smart contract Solidity code.
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约Solidity代码的语法。
- en: '248'
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: '248'
- en: Chapter 7 programming Smart ContraCt with Solidity
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: 第7章 使用Solidity编程智能合约
- en: '**Solidity Comments**'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: '**Solidity注释**'
- en: Comments are used extensively in Solidity to ensure that the smart
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: 注释在Solidity中广泛使用，以确保智能
- en: contracts can be clearly understood by both programmers and third party
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: 合约可以被程序员和第三方清楚地理解。
- en: users who need to use and trust the smart contracts. There are two kinds of
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: 需要使用和信任智能合约的用户。有两种
- en: comments that are supported with Solidity.
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 支持Solidity的注释。
- en: First is the double-forward slash “//” that is used to comment a whole
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: 首先是双斜杠“//”，用于注释一整行
- en: line or a rear portion of a line as shown below.
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示。
- en: //This is to comment a whole line
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: '`//This is to comment a whole line`'
- en: return “Hello World”; //This is to comment a portion of a line
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: 返回“Hello World”; // 这是注释一行的一部分
- en: Second syntax is to enclose the text with “/*” and “*/” to comment out
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种语法是用“/*”和“*/”括起来以注释
- en: the whole paragraph. To improve readability, each line in the commented
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: 注释整个段落。为了提高可读性，被注释的
- en: paragraph might start with “**”.
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: 段落可能以“**”开始。
- en: /**
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: '`/**`'
- en: '** The HelloWorld program demonstrates a simple smart contract'
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: '**HelloWorld程序演示了一个简单的智能合约`'
- en: to return a "Hello World" string when a HelloWorld function
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用HelloWorld函数时，返回一个“Hello World”字符串
- en: is called.
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 被调用。
- en: '** This program is an open source program that can be copied or'
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: '`* 这个程序是一个开源程序，可以复制或`'
- en: modified without permission.
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 未经许可修改。
- en: '**/'
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: '`*/`'
- en: '**Solidity Program and Version Declaration**'
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: '`* Solidity程序和版本声明`'
- en: Solidity source code starts with the “pragma” compiler directive followed
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: Solidity源代码以“pragma”编译指令开始
- en: by “solidity” and then a version specification. A compiler directive is an
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: 通过“solidity”和一个版本规格。编译指令是一个
- en: instruction for the compiler to parse and perform certain operations. The
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器的指令以解析并执行某些操作。The
- en: keyword “pragma solidity” instructs the compiler to treat the source code
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字“pragma solidity”指示编译器对待源代码
- en: as a “Solidity” programming language.
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: 将“Solidity”作为编程语言。
- en: '249'
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: '249'
- en: Chapter 7 programming Smart ContraCt with Solidity
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: 第7章 使用Solidity编程智能合约
- en: '// pragma: Tells compiler about the programming language and'
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: '`// pragma: 告诉编译器关于编程语言和`'
- en: compiler version
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器版本
- en: pragma solidity ^0.5.2;
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: pragma solidity ^0.5.2;
- en: // specify an exact major version
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: '`// 指定一个确切的major版本`'
- en: pragma solidity >0.5.2;
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: pragma solidity >0.5.2;
- en: // specify a newer version
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: '`// 指定一个较新的版本`'
- en: pragma solidity >0.5.2, <0.6.2; // specify a range
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: '`pragma solidity >0.5.2, <0.6.2; // 指定一个范围`'
- en: Solidity programming language version has the syntax of x.y.z format
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: Solidity编程语言版本具有x.y.z格式的语法
- en: such as 0.8.10\. Here, x,y,z are numbers that can include 0\. x is the major
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 例如0.8.10。在这里，x，y，z是包括0的数字。x是主要
- en: version number, y is the minor version number, and z is the patch number.
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: 版本号，y是次要版本号，z是修补程序号。
- en: For convenience, since x in Solidity has been “0” for a long time, “y” is
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Solidity中的x已经很长时间为“0”，因此“y”是
- en: referred to as “major version”, and “z” is referred to as minor version.
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: 被称为“主要版本”，而“z”被称为次要版本。
- en: Solidity language version section can have several forms such as the
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: Solidity语言版本部分可以有几种形式，如
- en: 'following:'
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: 如下：
- en: ~0.5.0 // This means an exact match of the Solidity.
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: ~0.5.0 //这意味着Solidity的精确匹配。
- en: ^0.5.0 // This means a major version match. This
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: ^0.5.0 //这意味着主要版本匹配。这个
- en: version works with any 0.5.z but not 0.4.z or 0.6.z.
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: 版本与任何0.5.z兼容，但不与0.4.z或0.6.z兼容。
- en: '>0.5.2; // specify a newer version. This version'
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: '>0.5.2; //指定新版本。这个版本'
- en: works with any version that is newer than 0.5.2\.
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何大于0.5.2的版本兼容。
- en: '>=0.5.2, =<0.6.2; // specify a range of versions. Any'
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: '>=0.5.2, =<0.6.2; //指定版本范围。任何'
- en: version that is newer or equal to 0.5.2 but older or
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: 等于或大于0.5.2但小于或
- en: equal to 0.6.2 can be selected.
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: 等于0.6.2可以选择。
- en: Versioning in Solidity is very important because Solidity programs run
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: 在Solidity中版本非常重要，因为Solidity程序运行
- en: on blockchain and cannot be updated or patched to newer versions once
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: 在区块链上运行，一旦
- en: they are deployed.
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: 它们被部署。
- en: For developers, there are several things that can go wrong with the
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: 对于开发者来说，有几个可能导致
- en: Solidity version. Because smart contracts cannot be upgraded or replaced,
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: Solidity版本。因为智能合约不能升级或更换，
- en: it is very important to make sure the source code is written in its "best"
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: 确保源代码以其“最佳”
- en: version as shown below
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: 版本如下所示
- en: 'Exact latest version: This is recommended option. However, although'
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: 确切的最新版本：这是推荐选项。然而，尽管
- en: specifying the exact version number is recommended, there are cases
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: 建议指定确切的版本号，但在某些情况下
- en: where flexibility is needed to address compatibility with other libraries.
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: 需要灵活性以解决与其他库的兼容性问题。
- en: '250'
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: '250'
- en: Chapter 7 programming Smart ContraCt with Solidity
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: 第7章用Solidity编程智能合约
- en: 'Exact older version: This is used when the code is not compatible with'
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: 确切的旧版本：当代码与
- en: the latest compiler and it takes too much effort to port it to the latest compiler.
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: 最新的编译器，并且移植到最新的编译器需要太多的努力。
- en: 'Support of major versions: This provides more flexibility, particularly'
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: 主要版本支持：这提供了更多的灵活性，特别是
- en: when the code is limited in scope and can be used as a library for various
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: 当代码范围有限且可作为各种
- en: versions of smart contracts.
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约的版本。
- en: 'A range of versions: This is used when the code itself contains libraries'
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: 版本范围：当代码本身包含库时使用
- en: of various versions and the smart contract is not mission critical.
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: 各种版本和智能合约不是关键任务。
- en: It is very important to keep in mind that Solidity programming
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: 非常重要，要牢记Solidity编程
- en: is progressing and the syntaxes are changing with different versions.
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: 正在发展，并且随着不同版本的变化而变化。
- en: Sometimes, a developer may have a source code working with version 0.5
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，开发者可能使源代码与版本0.5一起工作
- en: but fail to compile with version 0.8\. Therefore, it is a good practice to pay
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: 但是与版本0.8编译失败。因此，支付
- en: attention to version compatibility with Solidity source code or library.
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: 注意Solidity源代码或库的版本兼容性。
- en: '**Import a Solidity File**'
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: '**导入Solidity文件**'
- en: Right after Solidity and version declaration, there is normally an import
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: 在Solidity和版本声明之后，通常有一个导入
- en: statement where an external Solidity file is pulled into the source code.
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: 语句中，将外部Solidity文件拉入源代码。
- en: Solidity is an object orientation programming language and is very
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: Solidity是一种面向对象的编程语言，并且非常
- en: modularized. Developers separate source codes into different files and
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: 模块化。开发者将源代码分离到不同文件中
- en: libraries and import the needed files to the main source code.
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: 库并将所需文件导入主源代码。
- en: Many Solidity smart contracts are open source, and developers can
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: 许多Solidity智能合约是开源的，开发者可以
- en: import the library directly from open source repositories. One of the
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: 从开源仓库直接导入库。其中一个是
- en: most popular open source smart contract libraries is from OpenZeppelin
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: 最流行的开源智能合约库来自OpenZeppelin
- en: ([https://github.com/OpenZeppelin/openzeppelin- contracts](https://github.com/OpenZeppelin/openzeppelin-contracts)).
    Code such as SafeMath, ERC20, ERC721, ownership, and oracles can be reused
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: （[https://github.com/OpenZeppelin/openzeppelin-contracts](https://github.com/OpenZeppelin/openzeppelin-contracts)）。SafeMath、ERC20、ERC721、所有权和预言机等代码可以被重复使用
- en: from OpenZeppelin.
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: 自OpenZeppelin。
- en: '251'
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: '251'
- en: Chapter 7 programming Smart ContraCt with Solidity
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: 第7章用Solidity编程智能合约
- en: 'To import another source file, simply use the following formats:'
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: 要导入另一个源文件，只需使用以下格式：
- en: '**import filename** – This will import a file from the'
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: '**导入文件名** – 这将导入从'
- en: local directory.
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: 本地目录。
- en: '**import full_filename_with_path** – This will import'
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: '**导入全文件名与路径** –这将导入'
- en: a file specified with an absolute path.
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: 使用绝对路径指定文件。
- en: '**import github_location** – This syntax will import a'
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: '**导入github_location** – 这个语法将导入一个'
- en: file from a GitHub location.
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: 从GitHub位置导入文件。
- en: You can also import the file and give it a simple name to refer to such
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以导入一个文件，并给它一个简单的名字来引用这样的
- en: 'as following:'
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示：
- en: 'import filename as XYZ: Here, XYZ can be used to refer to the specific'
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: 导入文件名作为XYZ：在这里，XYZ可以用来引用具体的
- en: smart contract imported.
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约导入。
- en: '**Constructor Function**'
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: '**构造函数**'
- en: A constructor is a special function that is executed during the deployment
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数是一个特殊的函数，在部署
- en: of a smart contract. This is to define parameters that are assigned during
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约的。这是为了定义在
- en: the deployment phase or to run an algorithm to dynamically set some
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: 部署阶段，或者运行一个算法来自动设置一些
- en: parameters based on the deployment environment.
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: 参数基于部署环境。
- en: '**Function Modifier**'
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数修改器**'
- en: A function modifier is similar to a macro that is defined once and can be
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: 函数修改器类似于定义一次的宏，可以
- en: used in multiple functions. For example, the following is a modifier that
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: 在多个函数中。例如，以下是一个修改器，
- en: checks if the sender of the transaction is the owner. If yes, the validation
    is
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: 检查交易发送者是否是所有者。如果是，则进行验证
- en: good, and if not, an exception is thrown. The “_” sign is the place where the
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，如果不是，将抛出异常。"_"符号是引发
- en: function code will be inserted and executed.
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: 函数代码。
- en: modifier onlyOwner {
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: 修改器onlyOwner {
- en: require(msg.sender == owner);
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: 要求(msg.sender == owner);
- en: _;
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: _;
- en: '}'
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '252'
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: '252'
- en: Chapter 7 programming Smart ContraCt with Solidity
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: 第7章用Solidity编程智能合约
- en: function setMessage(string memory str) onlyOwner {
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: 函数setMessage(字符串内存str) onlyOwner {
- en: //Do_Something
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
  zh: //Do_Something
- en: '}'
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: In the preceding code, the setMessage function has a modifier to check
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，setMessage函数有一个检查
- en: if the sender is the owner of the smart contract. If yes, the “Do_Something”
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发送者是智能合约的所有者。如果是，将插入并执行“Do_Something”
- en: code will be executed in the “_” location right after the require statement.
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: 代码将在“_”位置require语句之后执行。
- en: The best use of modifiers is for simplifying redundant codes of
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: 修改器最好的用途是简化
- en: multiple functions in a smart contract. Once a modifier is defined, it can be
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约中的多个函数。一旦定义了一个修改器，它就可以被
- en: used anywhere.
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何地方使用。
- en: '**Blockchain Access Scope: Pure/View/Payable**'
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: '**区块链访问范围：纯/视图/可支付**'
- en: '**Functions**'
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数**'
- en: There are multiple scopes and permissions to define a function. The scope
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: 有多个范围和权限来定义一个函数。范围
- en: of a function describes the boundary of the function regarding whether the
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: 函数描述了函数关于是否访问
- en: data can be altered and what part of the data can be accessed.
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: 数据可以被修改，以及数据可以访问的部分。
- en: If a function is defined as pure, it is a self-confined function.
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数定义为纯，它是一个自封闭的函数。
- en: The function variables are local, and the function will not access the
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的变量是局部的，函数不会访问
- en: blockchain. It simply takes an input, processes it, and returns an output.
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链。它简单地接收一个输入，处理它，并返回一个输出。
- en: The "pure" functions do not have dependences on the blockchain states.
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: “纯”函数没有对区块链状态的依赖。
- en: For the view function, the function may access the blockchain and get
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: 对于视图函数，函数可能访问区块链并获取
- en: some read-only data from the blockchain to carry out the computation.
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: 从区块链获取一些只读数据以进行计算。
- en: The view function will not alter the state of the blockchain.
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: 视图函数不会改变区块链的状态。
- en: For payable functions, the blockchain state can be changed. For any
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: 对于可支付函数，可以改变区块链状态。对于任何
- en: function that will induce a transfer of assets, there should be a payable type
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: 函数将引发资产转移，应该有一个可支付类型
- en: assigned to the function and address.
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: 分配给函数和地址的参数。
- en: One frequently asked question about pure, view, and payable functions
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: 关于纯函数、视图函数和可支付函数的常见问题
- en: is whether they all consume gas fees. It is obvious that a payable function
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，可支付函数消耗燃料费用。
- en: always consumes gas fees as it changes the state of blockchain. For the
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: 总是消耗燃料费用，因为它改变了区块链的状态。对于
- en: view function, it only retrieves blockchain data, and the pure function does
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: 视图函数，它只是检索区块链数据，纯函数则
- en: not even access blockchain state. The question regarding whether pure
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至无法访问区块链状态。关于纯
- en: and view functions consume gas depends on how the function is called.
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: 燃料消耗取决于函数是如何被调用的。
- en: '253'
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: '253'
- en: Chapter 7 programming Smart ContraCt with Solidity
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
  zh: 第7章 使用Solidity编程智能合约
- en: If a pure and view function is called through a transaction, there is a gas
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: 如果通过交易调用纯视图函数，会消耗一定的燃料
- en: fee incurred to the transaction because running the function consumes
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
  zh: 产生的交易因为运行函数会消耗
- en: CPU time. If the pure and view function is not called through a transaction,
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器时间。如果纯视图函数没有通过交易调用，
- en: then there is no gas fee. A pure and view function can be called by directly
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: 那么就没有燃料费。纯视图函数可以直接调用
- en: attaching a client to an Ethereum node and instantiating a smart contract
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: 将客户端连接到以太坊节点并实例化智能合约
- en: object in that local node and calling the function directly. Calling a smart
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地节点上作为对象调用函数。调用智能
- en: contract function directly does not generate a transaction. The operation
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: 直接调用合约函数不会生成交易。操作
- en: can be done by the local node without incurring gas fee. Therefore, the
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在不产生燃料费的情况下由本地节点完成。因此，该
- en: answer to the question about whether there is gas consumption for pure
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: 关于纯函数是否有燃料消耗的问题，答案是
- en: or view function depends whether there is transaction to the function call
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: 或视图函数决定了是否有交易到函数调用
- en: or not. Any function call that is triggered by a transaction will incur gas
    fee.
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: 或否。任何由交易触发的函数调用都会产生燃料费。
- en: The gas fee can be calculated by a gas fee consumption table in EIP-1559\.
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: 燃料费用可以通过EIP-1559中的燃料消耗表计算。
- en: '**Function Access Scope: Public, External,**'
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数访问范围：公共、外部，**'
- en: '**Internal, and Private**'
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: '**内部和私有**'
- en: The scope of functions defines who can access the functions. This is
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的访问范围定义了谁可以访问函数。这是
- en: different from the function type of view/pure/payable, which defines
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: 不同于视图/纯/可支付函数类型，它定义了
- en: whether the function will access the blockchain, and if yes, whether it
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: 函数将访问区块链，如果确实需要，是否
- en: reads or writes to the blockchain.
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: 对区块链的读取或写入。
- en: 'There are four access scopes in Solidity functions: public, external,'
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: 在Solidity函数中有四个访问范围：公共、外部、
- en: internal, and private scopes. Public function means that you can call this
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: 内部和私有范围。公共函数意味着你可以调用这个
- en: function from an external blockchain client. If a function needs to be
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: 从外部区块链客户端调用函数。如果一个函数需要被
- en: called through a Web3 client, it is defined as public. External functions
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: 通过Web3客户端调用，定义为公共。外部函数
- en: can be called by another smart contract. Solidity supports importing an
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
  zh: 可以被另一个智能合约调用。Solidity支持导入一个
- en: external smart contract and calling the functions defined in the other smart
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: 外部智能合约并调用其他智能合约中定义的功能
- en: contract. The syntax to call an external smart contract is contractName.
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: 合约。调用外部智能合约的语法是contractName.
- en: functionName(). If an external function is called by the same smart contract,
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: functionName()。如果同一个智能合约中通过合约调用外部函数，
- en: use “this.functionName()” to refer to calling within the same contract.
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: 使用“this.functionName()”来指代在同一个合约中的调用。
- en: Internal functions can be called by other functions in the same or
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: 内部函数可以被同一合约中的其他函数或
- en: derived smart contract. And finally, private functions can only be called by
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: 派生智能合约。最后，私有函数只能被
- en: the functions in the same smart contract, which is the most restrictive.
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一个智能合约中调用函数，这是最严格的。
- en: '254'
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: '254'
- en: Chapter 7 programming Smart ContraCt with Solidity
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: 第7章 使用Solidity编程智能合约
- en: '**Module 2: Solidity Data Types**'
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: '**模块2：Solidity数据类型**'
- en: A data type is a supported format and classification of data that tells the
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类型是一种支持的数据格式和分类，它告诉了
- en: compiler and execution engine to interpret a programming language.
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器和执行引擎来解释一种编程语言。
- en: Similar to any modern programming languages, Solidity has a good set
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何现代编程语言类似，Solidity有一套良好的
- en: of supported data types. In general, understanding data types can help
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: 支持的数据类型。通常，了解数据类型可以帮助
- en: programmers to improve code security and execution efficiency. For
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员提高代码的安全性和执行效率。对于
- en: Solidity, there are additional reasons for knowing and paying attention
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
  zh: 在Solidity中，了解并关注
- en: to data types. Firstly, users who call smart contract functions need to
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: 需要
- en: pay gas fees for the storage and processing of computing steps. The gas
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
  zh: 为存储和处理计算步骤支付燃气费。燃气
- en: consumption could be quite expensive, sometimes reaching $200 per
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: 消耗可能相当昂贵，有时达到每笔200美元。
- en: transaction for Ethereum mainnet transactions. Secondly, smart contract
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: Ethereum主网交易的交易。其次，智能合约
- en: functions are open to the world. Anyone can call the smart contract's
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
  zh: 函数对全世界开放。任何人都可以调用智能合约的
- en: public functions. If the data type for a variable is improperly defined such
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
  zh: 公共函数。如果变量的数据类型不正确地定义，例如
- en: as allocating too much space, a malicious user may inject garbage to the
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: 分配过多空间，恶意用户可能会注入垃圾数据
- en: data and cause some performance issue or even stall the process of smart
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: 数据并导致一些性能问题甚至智能合约进程的停滞
- en: contract function calls. Thirdly, Solidity only supports a limited set of data
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: 合约函数调用。第三，Solidity只支持有限的数据
- en: types when compared with Java programming language. Data types such
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
  zh: 类型与Java编程语言中的类型相比。如
- en: as double and float are not supported in Solidity programming language.
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
  zh: 作为Solidity编程语言中不支持的双重和浮点类型。
- en: '**Boolean**'
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
  zh: '**布尔**'
- en: Boolean is the simplest data type for a programming language. It only uses
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔是编程语言中最简单的数据类型。它只使用
- en: one bit of storage to represent a true or false state of a variable. In Solidity,
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: 用来表示变量的真或假状态的一个位。在Solidity中，
- en: a variable can be declared as a boolean with bool keyword as shown in the
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
  zh: 变量可以用bool关键字声明为布尔类型，如下所示：
- en: 'following:'
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
  zh: 以下：
- en: bool new_member;
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
  zh: bool new_member;
- en: There are several logical operators that can be applied to a boolean
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个逻辑运算符可以应用于布尔
- en: 'data type as shown in the following:'
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类型，如下所示：
- en: '! (logical negation)'
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
  zh: '!（逻辑否定）'
- en: '&& (logical conjunction, “and”)'
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
  zh: '&&（逻辑与）'
- en: '255'
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
  zh: '255'
- en: Chapter 7 programming Smart ContraCt with Solidity
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
  zh: 第7章 使用Solidity编程智能合约
- en: '|| (logical disjunction, “or”)'
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: '||（逻辑或）'
- en: == (equality)
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
  zh: ==（等于）
- en: '!= (inequality)'
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
  zh: '!=（不等式）'
- en: With the boolean data type, an exclamation sign ! can be used as a
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
  zh: 使用布尔数据类型，感叹号!可以用作一个
- en: negation of the boolean type. A negation operation turns a true state to false
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔类型的否定。否定操作将真状态转为假状态。
- en: and a false state to true. Other operations on a boolean type can be && or
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
  zh: 并且布尔类型之间的其他操作可以是&&或
- en: '||. An && operation of two boolean types will be true if both are true. A “||”'
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
  zh: '||。两个布尔类型的&&操作将为真，如果两者都为真。一个“||”'
- en: operation of two boolean type variables will be true if either variable is true.
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
  zh: 两个布尔类型变量的操作将为真，如果任意一个变量为真。
- en: Two boolean variables can also be compared. Two boolean variables are
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
  zh: 两个布尔变量也可以进行比较。两个布尔变量是
- en: equal if they are both true or both false. Sometimes, a boolean variable can
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它们都是真或都是假，则相等。有时，布尔变量可以
- en: be conditionally checked in an "if" statement. If(variable) returns true if
    the variable is true, and false if the variable is false.
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在“if”语句中条件性地检查。如果(变量)如果变量为真，则返回true，如果变量为假，则返回false。
- en: Since a boolean variable consumes only one bit storage and there are
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
  zh: 由于布尔变量只占用一个位的存储空间，所以
- en: multiple operations that can be used to operate on boolean variables, it
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: 可以用于操作布尔变量的多个操作，它
- en: is recommended that developers use boolean type rather than other data
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
  zh: 建议开发者使用布尔类型而不是其他数据
- en: types if possible for storage efficiency.
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
  zh: 类型尽可能存储效率。
- en: '**Integer Type**'
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
  zh: '**整数类型**'
- en: Integer data type is used to represent a positive integer (unsigned) or
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
  zh: 整数数据类型用于表示正整数（无符号）或
- en: any integer (signed). In Solidity, the signed or unsigned integer can be in
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
  zh: 任何整数（有符号）。在Solidity中，有符号或无符号整数可以是
- en: different sizes represented by the amount of bits allocated for an integer
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
  zh: 由分配给整数的位的数量表示的不同大小
- en: variable. For example, uint8 means an 8-bit unsigned integer. uint8 can
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
  zh: 变量。例如，uint8意味着一个8位无符号整数。uint8可以
- en: hold values from 0 upto 2^8-1 (0–255). uint256 can hold values from 0 to
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
  zh: 持有从0到2^8-1（0–255）的值。uint256可以持有从0到
- en: 2^256-1\. Between uint8 and uint256, there are also various integer data
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
  zh: 2^256-1。在uint8和uint256之间，还有各种整数数据
- en: types in incremental size increase of 8 bit (1 byte). Signed data types differ
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: 类型以8位（1字节）的递增大小增加。有符号数据类型与
- en: from unsigned ones as it can represent both positive and negative integers.
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
  zh: 与无符号类型相比，因为它可以表示正整数和负整数。
- en: For example, int8 can hold values from -128 to 127 (range of -2^7 to 2^7-1).
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，int8可以保存从-128到127的值（范围从-2^7到2^7-1）。
- en: int256 can hold values from -2^255 to 2^255-1\. "int" can also have various
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
  zh: int256可以保存从-2^255到2^255-1的值。"int"也可以有各种
- en: sizes at an incremental step of 8 bit, such as int8, int16, int24, int32 up
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
  zh: 以8位为单位递增步长，如int8、int16、int24、int32等。
- en: to int256\.
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
  zh: 转换为int256。
- en: '256'
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
  zh: '256'
- en: Chapter 7 programming Smart ContraCt with Solidity
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
  zh: 第7章用Solidity编程智能合约。
- en: If the bit number is not specified in the integer type, it is default to 256\.
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有指定整数类型中的位数，则默认为256。
- en: uint and int are aliases for uint256 and int256, respectively.
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
  zh: uint和int分别是uint256和int256的别名。
- en: Solidity also has built-in operators for integer type variables. This is
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
  zh: Solidity还内置了整数类型变量的操作符。这是
- en: shown in the following table (Figur[e 7-1):](#p268)
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: 如下表所示（图7-1）：（#p268）
- en: '***Figure 7-1\.** Operators for Integer Datatype*'
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
  zh: '***图7-1。整数数据类型运算符*'
- en: '257'
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
  zh: '257'
- en: Chapter 7 programming Smart ContraCt with Solidity
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: 第7章用Solidity编程智能合约。
- en: Since smart contracts can be written to handle large sums of assets,
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
  zh: 由于智能合约可以被编写来处理大量资产，
- en: it is important to ensure that the math is fully accurate. The boundary
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
  zh: 确保数学完全准确很重要。边界
- en: conditions and validity of inputs should be checked thoroughly. Many
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
  zh: 输入的条件和有效性应该被彻底检查。许多
- en: libraries have been written to let developers reuse the math components
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: 库已编写，让开发者重用数学组件
- en: and to prevent hackers attacking smart contracts through security holes in
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
  zh: 以防止黑客通过智能合约中的安全漏洞进行攻击。
- en: math functions. For example, SafeMath is a good library to use to handle
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
  zh: 数学函数。例如，SafeMath是一个很好的库，用于处理
- en: mathematics operations. Developers can download SafeMath libraries
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
  zh: 数学运算。开发者可以下载SafeMath库
- en: by OpenZeppelin and import the smart contract to use the class and
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
  zh: 由OpenZeppelin提供，并导入智能合约以使用类和
- en: functions in the library.
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
  zh: 库中的函数。
- en: '**Address Type**'
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: '**地址类型**'
- en: Address is an unique identifier of a crypto account in blockchains. Address
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: 地址是区块链中加密货币账户的唯一标识符。地址
- en: type is a data structure that is not defined in conventional programming
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
  zh: 类型是一种在传统编程中没有定义的数据结构
- en: languages such as C or Java but is essential in smart contract programming
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
  zh: 例如C或Java等语言，但在智能合约编程中是必不可少的。
- en: languages. Ethereum blockchain uses a 20-byte hex value to represent a
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
  zh: 语言。以太坊区块链使用20字节的十六进制值来表示一个
- en: crypto address.
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
  zh: 加密货币地址。
- en: When you create an account in Ethereum, three items are generated.
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在以太坊上创建一个账户时，会生成三个项目。
- en: The first item is a private key. This is the unique key to access the account
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个项目是一个私钥。这是访问账户的独特密钥。
- en: and should be kept by the account owner and never revealed to other
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
  zh: 应由账户所有者保管，绝不能透露给其他人
- en: people. The second item is a public key that is used to represent the account
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
  zh: 人们。第二个项目是公钥，用来表示账户
- en: and can be published. A public key can be used to encrypt a message, and
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
  zh: 并可以公布。公钥可以用来加密信息，并且
- en: only the private key can decrypt the message. The third item is an address
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
  zh: 只有私钥才能解密信息。第三个项目是一个地址。
- en: derived from a public key. An address is actually a simplification of the
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
  zh: 从公钥派生。实际上，地址是公钥的简化形式
- en: public key. Simply apply Keccak-256 hashing to the public key and then take
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
  zh: 公钥。只需对公钥应用Keccak-256散列，然后取
- en: the last 20 bytes; the output is the address for the account. Since each byte
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
  zh: 最后20个字节；输出是账户的地址。由于每个字节
- en: can represent two hex numbers, it is actually a hex string with 40 digits such
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
  zh: 可以表示两个十六进制数字，实际上是一个40位十六进制字符串，如
- en: as *0x1F2D3A67b8E96039BbAC84EB4BC0913c0c16778c*.
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
  zh: 作为*0x1F2D3A67b8E96039BbAC84EB4BC0913c0c16778c*。
- en: In Solidity code, address data type is a representation of an asset
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
  zh: 在Solidity代码中，地址数据类型是资产
- en: account. When declaring an address variable, the developer needs to
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
  zh: 账户。当声明一个地址变量时，开发者需要
- en: specify whether this address can receive external funds or not. This can be
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
  zh: 指定这个地址是否可以接收外部资金。这可以被
- en: done by using the keyword **payable**.
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用关键字**payable**完成。
- en: '258'
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
  zh: '258'
- en: Chapter 7 programming Smart ContraCt with Solidity
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
  zh: 第7章用Solidity编程智能合约。
- en: If an address is declared payable, it can receive funds sent to this
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个地址被声明为可支付，它可以接收发送到这个
- en: address. If not, the smart contract will reject any funds that are sent to this
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
  zh: 地址。如果没有，智能合约将拒绝向这个
- en: account. Payable keyword is an additional safeguard to ensure only valid
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
  zh: 账户。Payable关键字是确保只有有效
- en: accounts can receive assets transferred to it.
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
  zh: 账户可以接收资产转移。
- en: The following shows how to define a nonpayable and payable address
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
  zh: 以下展示了如何定义一个非可支付和可支付地址
- en: example.
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
  zh: 示例。
- en: '*// address type is a twenty byte hex variable*'
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
  zh: '*// 地址类型是一个二十字节的十六进制变量*'
- en: '*address account_spending;*'
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
  zh: '*address account_spending;*'
- en: '*account_spending = 0x1F2D3A67b8E96039BbAC84EB4BC0913c0c16778c;*'
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
  zh: '*account_spending = 0x1F2D3A67b8E96039BbAC84EB4BC0913c0c16778c;*'
- en: '*address payable account_receiving;*'
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
  zh: '*address payable account_receiving;*'
- en: '*account_receiving = 0xDda897285Ce46CG78D786a9e993286AaC68c45bC;*'
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
  zh: '*account_receiving = 0xDda897285Ce46CG78D786a9e993286AaC68c45bC;*'
- en: In the preceding examples, there are two address variables defined.
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，定义了两个地址变量。
- en: The first one, account_spending, is a nonpayable account. It cannot
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个，account_spending，是一个非可支付账户。它不能
- en: be used to receive any funds. It can, however, send out funds from its
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
  zh: 可用于接收任何资金。然而，它可以从其
- en: own account. The second one called account_receiving has the payable
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
  zh: 自己的账户。第二个称为 account_receiving，具有可支付性
- en: attribute and hence can send out or receive funds with the account.
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
  zh: 属性和因此可以使账户发送或接收资金。
- en: One more thing to point out is that address can not only be an
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
  zh: 需要指出的一点是，地址不仅可以是
- en: identification to an account, it can also point to a smart contract instance.
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
  zh: 指向智能合约实例。
- en: A smart contract address is the entry point to a deployed smart contract.
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约地址是部署智能合约的入口点。
- en: This address can be used to represent a deployed smart contract and call
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
  zh: 这个地址可以用来表示一个部署的智能合约并调用
- en: the functions inside the smart contract.
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约内的函数。
- en: '**Byte Array**'
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
  zh: '**字节数组**'
- en: Byte array (Figure [7-2](#p271)) uses array to represent a fixed amount of bytes
    from 1 to 32\. The following defines various types of byte arrays and the bit
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
  zh: 字节数组（图 [7-2](#p271)）使用数组表示从1到32的固定字节量。以下定义了各种类型的字节数组和位
- en: operations that can be applied to the array.
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
  zh: 可以应用于数组的操作。
- en: '259'
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
  zh: '259'
- en: Chapter 7 programming Smart ContraCt with Solidity
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
  zh: 第7章 使用Solidity编程智能合约
- en: '***Figure 7-2\.** Byte arrays data type*'
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
  zh: '***图7-2。**字节数组数据类型*'
- en: 'Note:'
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：
- en: Byte is the same as byte1\.
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
  zh: Byte 与 byte1 相同。
- en: 'To define a byte array, use the following syntax:'
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
  zh: 要以以下语法定义字节数组：
- en: byte1 b1;
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
  zh: 字节1 b1;
- en: byte2 b2;
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
  zh: byte2 b2;
- en: Byte32 b32;
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
  zh: Byte32 b32;
- en: In the preceding example, b1, b2, and b32 represent a 1-byte, a 2-byte,
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，b1、b2 和 b32 分别表示一个1字节、一个2字节
- en: and a 32-byte variable, respectively.
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
  zh: 分别表示一个1字节、一个2字节和一個32字节的变量。
- en: To retrieve an element of a byte array variable x, use x[i], where i ranges
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字节数组变量 x 中检索元素，请使用 x[i]，其中 i 范围
- en: from 0 to byte size to get the byte at index i.
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
  zh: 从0到字节大小以获取索引 i 的字节。
- en: The following diagram shows the operations for byte arrays
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了字节数组的操作
- en: (Figure [7-3).](#p272)
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
  zh: （图 [7-3)](#p272)
- en: '260'
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
  zh: '260'
- en: Chapter 7 programming Smart ContraCt with Solidity
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
  zh: 第7章 使用Solidity编程智能合约
- en: '***Figure 7-3\.** Byte array operations*'
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
  zh: '***图7-3。**字节数组操作*'
- en: '**Fixed Size Array**'
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
  zh: '**固定大小数组**'
- en: 'Fixed size array is an indexed array of any data type such as the following:'
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
  zh: 固定大小数组是任何数据类型的索引数组，如下所示：
- en: '*data_type array_name[array_size]*'
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
  zh: '*数据类型 数组名[数组大小]*'
- en: Here, data_type is any data type such as integer, address, and byte,
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，data_type 是任何数据类型，如整数、地址和字节。
- en: 'such as following:'
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
  zh: 例如以下：
- en: uint balances[30]; // an unsigned integer array of fixed size
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
  zh: uint balances[30]; // 一个固定大小的无符号整数数组
- en: address students[25];
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
  zh: 地址 students[25];
- en: // an address array that holds 25 students' account address
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
  zh: // 包含25名学生账户地址的学生地址数组
- en: '261'
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
  zh: '261'
- en: Chapter 7 programming Smart ContraCt with Solidity
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
  zh: 第7章 使用Solidity编程智能合约
- en: A fixed size array can be initialized by assigning the data value during
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
  zh: 固定大小数组可以通过在
- en: the declaration phase or later by assigning a value to the variable element.
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过分配值来在声明阶段或之后定义数组元素。
- en: '*uint balances[5] = [10, 20, 30, 40, 50]; // This declares a*'
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
  zh: '*uint balances[5] = [10, 20, 30, 40, 50]; // 这声明了一个*'
- en: '*balanced array of type unsigned integer and assigns values to*'
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
  zh: '*平衡的整数类型数组并赋值给*'
- en: '*each element.*'
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
  zh: '*每个元素.*'
- en: '*uint balances[] = [10, 20, 30, 40, 50]; // This declares a*'
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
  zh: '*uint balances[] = [10, 20, 30, 40, 50]; // 这声明了一个*'
- en: '*balanced array of type unsigned integer and assigns values to*'
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
  zh: '*平衡的整数类型数组并赋值给*'
- en: '*each element. The array size is omitted and it is equal to the*'
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
  zh: '*每个元素。数组大小被省略，它等于*'
- en: '*number of values assigned to the array.*'
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
  zh: '*分配给数组的值的数量.*'
- en: 'To assign a value to an array element, simply use the following syntax:'
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
  zh: 要以数组元素赋值，请简单使用以下语法：
- en: array_name[index] = data_value;
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
  zh: 数组名[索引] = 数据值;
- en: Here, array_name is the array variable name, index is the index for the
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，array_name 是数组变量名，index 是为
- en: array element, and data_value is the value to be assigned to the element.
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
  zh: 数组元素，并且 data_value 是要分配给该元素的值。
- en: 'An example is shown here:'
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例：
- en: balances[3] =300; // assigned value 300 to index 3 of
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
  zh: '`balances[3] =300; // 将值 300 分配给索引 3 的数组`'
- en: balances array.
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
  zh: 余额数组。
- en: '**Dynamically Sized Array**'
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
  zh: '**动态大小数组**'
- en: In Solidity, arrays have continuous addresses. The first element points to
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Solidity 中，数组具有连续的地址。第一个元素指向
- en: the lowest address, and the last elements points to the highest address. For
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
  zh: 最低地址，最后一个元素指向最高地址。对于
- en: a fixed size array, the size of the array is set during the compilation time.
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
  zh: 固定大小的数组，数组的大小在编译时设置。
- en: For a dynamically sized array, the array size is set during the runtime. To
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
  zh: 对于动态大小数组，数组大小在运行时设置。为了
- en: 'declare a dynamically sized array, use the following syntax:'
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
  zh: 声明一个动态大小的数组，使用以下语法：
- en: data_type[] array_name;
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
  zh: '`data_type[] array_name;`'
- en: Here, data_type is the name of the data type such as uint and address.
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
  zh: 在此，data_type 是数据类型的名称，如 uint 和 address。
- en: array_name is the array variable name such as balances and students_
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
  zh: '`array_name` 是数组变量名称，如 balances 和 students_'
- en: addresses.
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
  zh: 地址。
- en: '262'
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
  zh: '262'
- en: Chapter 7 programming Smart ContraCt with Solidity
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
  zh: 第 7 章用 Solidity 编程智能合约
- en: '*uint[] balances;*'
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
  zh: '`uint[] balances;`'
- en: '*address[] students_addresses;*'
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
  zh: '`address[] students_addresses;`'
- en: When a dynamic array is declared, its size will need to be set with a
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
  zh: 当声明动态数组时，其大小需要在编译时设置一个
- en: length in the code execution.
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
  zh: 代码执行中的长度。
- en: 'To set the array length, use the following syntax:'
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置数组长度，请使用以下语法：
- en: array_name = new data_type[](size);
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
  zh: '`array_name = new data_type[](size);`'
- en: Here, array_name is the array variable name. data_type is the data
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
  zh: 在此，array_name 是数组变量的名称。data_type 是数据的
- en: type name, and size is an uint that represents the intended size of the
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
  zh: 类型名称，大小是一个 uint，代表预期的大小 of the
- en: array. For example, the array variables mentioned earlier can be set to the
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
  zh: 数组。例如，前面提到的数组变量可以设置为
- en: 'following length:'
  id: totrans-1198
  prefs: []
  type: TYPE_NORMAL
  zh: 以下长度：
- en: '*balances = new uint[](9); // set balances array size to 9*'
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
  zh: '`balances = new uint[](9); // 将 balances 数组大小设置为 9`'
- en: '*students_addresses = new address[](10);*'
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
  zh: '`students_addresses = new address[](10);`'
- en: '*// set students_addresses array size to 10*'
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
  zh: '`// 将 students_addresses 数组大小设置为 10`'
- en: '**Mapping Data Type**'
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
  zh: '**映射数据类型**'
- en: Besides address data type, another important one is mapping type.
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
  zh: 除了地址数据类型，另一种重要的类型是映射类型。
- en: Mapping data type associates two variables like an associative array.
  id: totrans-1204
  prefs: []
  type: TYPE_NORMAL
  zh: 映射数据类型将两个变量关联起来，就像关联数组一样。
- en: Mapping type is an important data type because it correlates two or more
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
  zh: 映射类型是一种重要的数据类型，因为它关联了两个或更多
- en: variables.
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
  zh: 变量。
- en: 'To declare mapping types, use the following syntax:'
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
  zh: 声明映射类型时，使用以下语法：
- en: mapping(key_type => value_type)
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
  zh: 映射(key_type => value_type)
- en: The key_type can be any elementary type such as built-in types like
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
  zh: 键类型可以是任何基本类型，如内置类型如
- en: uint, address, bytes, and string.
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
  zh: uint、address、bytes 和 string。
- en: The key_type can also be user-defined or complex types like contract
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
  zh: 键类型也可以是用户定义或复杂类型，如合约
- en: types, enums, mappings, structs, and any array type.
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
  zh: 类型、枚举、映射、结构体以及任何数组类型。
- en: value_type can be any type, including mappings.
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
  zh: 值类型可以是任何类型，包括映射。
- en: '263'
  id: totrans-1214
  prefs: []
  type: TYPE_NORMAL
  zh: '263'
- en: Chapter 7 programming Smart ContraCt with Solidity
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
  zh: 第 7 章用 Solidity 编程智能合约
- en: The following defines a mapping of address array with balance for each
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
  zh: 以下定义了一个映射，每个地址的余额映射
- en: 'array element:'
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
  zh: 数组元素：
- en: '*address student_address;*'
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
  zh: '`address student_address;`'
- en: '*uint score;*'
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
  zh: '`uint score;`'
- en: '*mapping(student_address => score) public scores;*'
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
  zh: '`mapping(student_address => score) public scores;`'
- en: The preceding example defines student_address as an address data
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例将 student_address 定义为一个地址数据
- en: type and a score as uint type. Then student_address is mapped to score. To
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
  zh: 类型和分数 uint 类型。然后 student_address 被映射到分数。为了
- en: 'assign a score to a student, use the following syntax as example:'
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
  zh: 为学生分配分数，使用以下语法作为示例：
- en: student_1_address = *0x1B2E2A67b8E96039BbAC84EB4BC0913c0c16668D;*
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
  zh: student_1_address = `0x1B2E2A67b8E96039BbAC84EB4BC0913c0c16668D;`
- en: '*score_1 = 90;*'
  id: totrans-1225
  prefs: []
  type: TYPE_NORMAL
  zh: '`score_1 = 90;`'
- en: '*scores[student_1_address] = score_1;*'
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
  zh: '`scores[student_1_address] = score_1;`'
- en: // This example sets the score for student 1 to be 90\.
  id: totrans-1227
  prefs: []
  type: TYPE_NORMAL
  zh: // 这个示例将学生 1 的分数设置为 90。
- en: To retrieve the score of student 1, simply enter the student's address to
  id: totrans-1228
  prefs: []
  type: TYPE_NORMAL
  zh: 要检索学生 1 的分数，只需输入学生的地址即可
- en: 'the scores variable:'
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
  zh: 分数变量：
- en: scores[student_1_address] // This will return 90\.
  id: totrans-1230
  prefs: []
  type: TYPE_NORMAL
  zh: '`scores[student_1_address] // 这将返回 90。`'
- en: A mapping is a versatile data type that associates two variables without
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
  zh: 映射是一种灵活的数据类型，它关联了两个变量而没有
- en: a predefined size. This is used frequently in smart contracts.
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
  zh: 预定义的大小。这在智能合约中经常使用。
- en: '**Enum Data Type**'
  id: totrans-1233
  prefs: []
  type: TYPE_NORMAL
  zh: '**枚举数据类型**'
- en: Enum is a data type that enumerates a variable to have only some
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举是一种数据类型，它枚举一个变量只能有一些
- en: predefined values. By restricting the values in an enum variable, the
  id: totrans-1235
  prefs: []
  type: TYPE_NORMAL
  zh: 预定义的值。通过限制枚举变量中的值， the
- en: chance to make mistakes is decreased.
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
  zh: 减少犯错的机会。
- en: The syntax for defining an enum is
  id: totrans-1237
  prefs: []
  type: TYPE_NORMAL
  zh: 定义枚举的语法是
- en: enum enum_type_name{VALUE_LIST};
  id: totrans-1238
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举枚举类型名{VALUE_LIST};
- en: Here, enum is the data type keyword, and enum_type_name is
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
  zh: 在此，枚举是数据类型关键词，枚举类型名是
- en: the name of the enum type. VALUE_LIST is a list of values separated
  id: totrans-1240
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举类型的名称。VALUE_LIST是一个由值分隔的
- en: by comma.
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
  zh: 用逗号。
- en: '264'
  id: totrans-1242
  prefs: []
  type: TYPE_NORMAL
  zh: '264'
- en: Chapter 7 programming Smart ContraCt with Solidity
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
  zh: 第7章用Solidity编程智能合约
- en: Once an enum type is defined, it can be used to declare an enum
  id: totrans-1244
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义了一个枚举类型，它就可以用来声明一个枚举
- en: variable.
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
  zh: 变量。
- en: enum_type_name variable_name;
  id: totrans-1246
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举类型名变量名;
- en: For example, in order to limit the role of a decentralized organization,
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，为了限制去中心化组织的角色，
- en: the role variable can be an enum data type such as
  id: totrans-1248
  prefs: []
  type: TYPE_NORMAL
  zh: 角色变量可以是枚举数据类型，如
- en: '*enum DAO_ROLES{SECRETARY, ACCOUNTANT, LEGAL, MEMBER};*'
  id: totrans-1249
  prefs: []
  type: TYPE_NORMAL
  zh: '**枚举DAO_ROLES{SECRETARY, ACCOUNTANT, LEGAL, MEMBER};*'
- en: '*DAO_ROLES newMember;*'
  id: totrans-1250
  prefs: []
  type: TYPE_NORMAL
  zh: '**DAO_ROLES newMember;*'
- en: '*newMember = DAO_ROLES.MEMBER;*'
  id: totrans-1251
  prefs: []
  type: TYPE_NORMAL
  zh: '**新成员 = DAO_ROLES.MEMBER;*'
- en: In the preceding example, DAO_ROLES is declared as an enum
  id: totrans-1252
  prefs: []
  type: TYPE_NORMAL
  zh: 在前例中，DAO_ROLES被声明为一个枚举
- en: that can have the values of SECRETARY, ACCOUNTANT, LEGAL,
  id: totrans-1253
  prefs: []
  type: TYPE_NORMAL
  zh: 可以具有SECRETARY, ACCOUNTANT, LEGAL,
- en: and MEMBER.
  id: totrans-1254
  prefs: []
  type: TYPE_NORMAL
  zh: 和MEMBER。
- en: The DAO_ROLES is used to declare a variable newMember. This new
  id: totrans-1255
  prefs: []
  type: TYPE_NORMAL
  zh: DAO_ROLES用于声明新成员变量。这个新
- en: member is assigned a value of DAO_ROLES.MEMBER.
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
  zh: 成员被分配DAO_ROLES.MEMBER的值。
- en: By using enum, it reduces the values for a variable to a limited list and
  id: totrans-1257
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用枚举，它将变量的值减少到一个有限的列表，
- en: hence is less error prone.
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
  zh: 因此错误较少。
- en: In the following, a code snippet is shown to illustrate how to use an
  id: totrans-1259
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个代码片段，说明如何使用
- en: 'enum to define variables:'
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举定义变量：
- en: '*pragma solidity ^0.6.0;*'
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
  zh: '**pragma solidity ^0.6.0;*'
- en: '*contract enum_example {*'
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
  zh: '**合约枚举示例{*'
- en: '*enum DAO_ROLES{ SECRETARY, ACCOUNTANT, LEGAL, MEMBER};*'
  id: totrans-1263
  prefs: []
  type: TYPE_NORMAL
  zh: '**枚举DAO_ROLES{ SECRETARY, ACCOUNTANT, LEGAL, MEMBER};*'
- en: '*// define an enum type*'
  id: totrans-1264
  prefs: []
  type: TYPE_NORMAL
  zh: '**// 定义一个枚举类型*'
- en: '*DAO_ROLES latestMember; // define an enum variable*'
  id: totrans-1265
  prefs: []
  type: TYPE_NORMAL
  zh: '**DAO_ROLES latestMember; // 定义一个枚举变量*'
- en: '*function setRoleSECRETARY() public { // declare a function*'
  id: totrans-1266
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数setRoleSECRETARY()公共{ // 声明一个函数*'
- en: '*to set latestMember to be a SECRETARY role*'
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
  zh: '**将latestMember设置为SECRETARY角色*'
- en: '*latestMember = DAO_ROLES.SECRETARY;*'
  id: totrans-1268
  prefs: []
  type: TYPE_NORMAL
  zh: '**最新成员 = DAO_ROLES.SECRETARY;*'
- en: '*}*'
  id: totrans-1269
  prefs: []
  type: TYPE_NORMAL
  zh: '**}*'
- en: '265'
  id: totrans-1270
  prefs: []
  type: TYPE_NORMAL
  zh: '265'
- en: Chapter 7 programming Smart ContraCt with Solidity
  id: totrans-1271
  prefs: []
  type: TYPE_NORMAL
  zh: 第7章用Solidity编程智能合约
- en: '*function getRole() public view returns (DAO_ROLES)*'
  id: totrans-1272
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数getRole()公共视图返回(DAO_ROLES)*'
- en: '*{ // Query the role of the latest member*'
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
  zh: '**{ // 查询最新成员的角色*'
- en: '*return latestMember;*'
  id: totrans-1274
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回latestMember;*'
- en: '*}*'
  id: totrans-1275
  prefs: []
  type: TYPE_NORMAL
  zh: '**}*'
- en: '*}*'
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
  zh: '**}*'
- en: '**Struct Data Type**'
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
  zh: '**结构数据类型**'
- en: Struct is the abbreviation of structure. Similar to struct in other
  id: totrans-1278
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体的缩写是结构。与其他
- en: programming languages, Solidity supports struct data type to group a
  id: totrans-1279
  prefs: []
  type: TYPE_NORMAL
  zh: 编程语言中，Solidity支持结构数据类型来分组
- en: number of variables together. The group of variables can have different
  id: totrans-1280
  prefs: []
  type: TYPE_NORMAL
  zh: 一起定义的变量数量。变量组可以有不同的
- en: 'data types. A struct variable type is defined with the following syntax:'
  id: totrans-1281
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类型。一个结构体变量类型是用以下语法定义的：
- en: struct struct_type{
  id: totrans-1282
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体结构类型{
- en: datatype_1 variable_1;
  id: totrans-1283
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类型1变量1;
- en: datatype_2 variable_2;
  id: totrans-1284
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类型2变量2;
- en: '...'
  id: totrans-1285
  prefs: []
  type: TYPE_NORMAL
  zh: ……
- en: '}'
  id: totrans-1286
  prefs: []
  type: TYPE_NORMAL
  zh: '**}*'
- en: Here, struct_type is the struct to be defined. datatype_1, datatype_2,
  id: totrans-1287
  prefs: []
  type: TYPE_NORMAL
  zh: 在此，struct_type是要定义的结构体。datatype_1，datatype_2，
- en: etc., are data types that are native with Solidity or defined by the user.
  id: totrans-1288
  prefs: []
  type: TYPE_NORMAL
  zh: 等等，都是Solidity原生数据类型或由用户定义的。
- en: 'An example of defining a struct is shown here:'
  id: totrans-1289
  prefs: []
  type: TYPE_NORMAL
  zh: 定义结构体的示例如下：
- en: '*enum Experience{ENTRY, JUNIOR, SENIOR, EXPERT};*'
  id: totrans-1290
  prefs: []
  type: TYPE_NORMAL
  zh: '**枚举经验{入门, 初级, 高级, 专家};*'
- en: '*enum Skillset{SOLIDITY, PROTOCOL, BOTH};*'
  id: totrans-1291
  prefs: []
  type: TYPE_NORMAL
  zh: '**枚举Skillset{SOLIDITY, PROTOCOL, BOTH};*'
- en: '*struct Developer {*'
  id: totrans-1292
  prefs: []
  type: TYPE_NORMAL
  zh: '**结构体开发者{**'
- en: '*address addr;*'
  id: totrans-1293
  prefs: []
  type: TYPE_NORMAL
  zh: '**地址 addr;*'
- en: '*Experience level;*'
  id: totrans-1294
  prefs: []
  type: TYPE_NORMAL
  zh: '**经验水平;*'
- en: '*uint hourly_rate;*'
  id: totrans-1295
  prefs: []
  type: TYPE_NORMAL
  zh: '**uint hourly_rate;*'
- en: '*Skillset skill;*'
  id: totrans-1296
  prefs: []
  type: TYPE_NORMAL
  zh: '**Skillset skill;*'
- en: '*}*'
  id: totrans-1297
  prefs: []
  type: TYPE_NORMAL
  zh: '**}*'
- en: '*Developer guru1;*'
  id: totrans-1298
  prefs: []
  type: TYPE_NORMAL
  zh: '**开发者guru1;*'
- en: '266'
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
  zh: '266'
- en: Chapter 7 programming Smart ContraCt with Solidity
  id: totrans-1300
  prefs: []
  type: TYPE_NORMAL
  zh: 第7章用Solidity编程智能合约
- en: In the preceding example, a Developer struct is defined that contains
  id: totrans-1301
  prefs: []
  type: TYPE_NORMAL
  zh: 在前例中，定义了一个包含
- en: 'four components: an account address of the developer, an enum of'
  id: totrans-1302
  prefs: []
  type: TYPE_NORMAL
  zh: 四个组件：开发者账户地址，枚举的
- en: experience level, an hourly rate of uint type, and skill of enum type. The
  id: totrans-1303
  prefs: []
  type: TYPE_NORMAL
  zh: 经验水平，uint类型的每小时费率，以及枚举类型的技能。该
- en: variable guru1 is declared as a Developer struct type variable.
  id: totrans-1304
  prefs: []
  type: TYPE_NORMAL
  zh: 变量guru1声明为开发者结构体类型变量。
- en: To refer to components inside a struct, use “.” symbol. For example, to
  id: totrans-1305
  prefs: []
  type: TYPE_NORMAL
  zh: 要引用结构体内部的组件，请使用“.”符号。例如，要
- en: 'set values to guru1 in the preceding example, do the following:'
  id: totrans-1306
  prefs: []
  type: TYPE_NORMAL
  zh: 在前例中，将guru1的值设置为：
- en: guru1.address = *0x1B2E2A67b8E96039BbAC84EB4BC0913c0c16668D;*
  id: totrans-1307
  prefs: []
  type: TYPE_NORMAL
  zh: guru1.address = *0x1B2E2A67b8E96039BbAC84EB4BC0913c0c16668D;*
- en: '*guru1.level = Experience.EXPERT;*'
  id: totrans-1308
  prefs: []
  type: TYPE_NORMAL
  zh: '*guru1.level = Experience.EXPERT;*'
- en: '*guru1.hourly_rate = 80;*'
  id: totrans-1309
  prefs: []
  type: TYPE_NORMAL
  zh: '*guru1.hourly_rate = 80;*'
- en: '*guru1.skil = Skillset.SOLIDITY;*'
  id: totrans-1310
  prefs: []
  type: TYPE_NORMAL
  zh: '*guru1.skil = Skillset.SOLIDITY;*'
- en: '*Besides setting values individually as shown earlier, a struct variable*'
  id: totrans-1311
  prefs: []
  type: TYPE_NORMAL
  zh: '*除了像以前那样单独设置值之外，结构体变量*'
- en: '*can be assigned values through struct constructor as shown in the following:*'
  id: totrans-1312
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过结构体构造函数像以下这样赋值：
- en: '*guru1 = Developer(0x1B2E2A67b8E96039BbAC84EB4BC0913c0c16668D,*'
  id: totrans-1313
  prefs: []
  type: TYPE_NORMAL
  zh: '*guru1 = Developer(0x1B2E2A67b8E96039BbAC84EB4BC0913c0c16668D,*'
- en: '*Experience.EXPERT,*'
  id: totrans-1314
  prefs: []
  type: TYPE_NORMAL
  zh: '*Experience.EXPERT,*'
- en: '*80,*'
  id: totrans-1315
  prefs: []
  type: TYPE_NORMAL
  zh: '*80,*'
- en: '*Skillset.SOLIDITY*'
  id: totrans-1316
  prefs: []
  type: TYPE_NORMAL
  zh: Skillset.SOLIDITY
- en: '*)*'
  id: totrans-1317
  prefs: []
  type: TYPE_NORMAL
  zh: '*)*'
- en: If there are multiple developers such as guru1, guru2, and guru3, a
  id: totrans-1318
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有多个开发者，如guru1，guru2和guru3，一个
- en: mapping combined with struct can be used. For example, an uint can be
  id: totrans-1319
  prefs: []
  type: TYPE_NORMAL
  zh: 映射与结构体结合可以使用。例如，uint可以被
- en: 'mapped to a Developer struct to refer to a list of developers:'
  id: totrans-1320
  prefs: []
  type: TYPE_NORMAL
  zh: 映射到一个Developer struct以引用开发人员列表：
- en: mapping(uint=>Developer) developers;
  id: totrans-1321
  prefs: []
  type: TYPE_NORMAL
  zh: mapping(uint=>Developer) developers;
- en: Here, developers is a mapping variable. Each developer can be referred
  id: totrans-1322
  prefs: []
  type: TYPE_NORMAL
  zh: 在此，developers是一个映射变量。每个开发者都可以被引用
- en: to as developer[0], developer[1], etc.
  id: totrans-1323
  prefs: []
  type: TYPE_NORMAL
  zh: 可以作为developer[0]，developer[1]，等等。
- en: Mapping combined with struct can provide very sophisticated data
  id: totrans-1324
  prefs: []
  type: TYPE_NORMAL
  zh: 映射与结构体结合可以提供非常复杂的数据
- en: types that can address most of the data type tasks in Solidity programming.
  id: totrans-1325
  prefs: []
  type: TYPE_NORMAL
  zh: 可以解决Solidity编程中大多数数据类型任务的数据类型。
- en: '267'
  id: totrans-1326
  prefs: []
  type: TYPE_NORMAL
  zh: '267'
- en: Chapter 7 programming Smart ContraCt with Solidity
  id: totrans-1327
  prefs: []
  type: TYPE_NORMAL
  zh: Chapter 7 使用Solidity编程 Smart ContraCt
- en: In summary, Solidity provides a way to define new types in the form of
  id: totrans-1328
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，Solidity提供了一种以
- en: structs. The following code snippet shows an example of Donor struct that
  id: totrans-1329
  prefs: []
  type: TYPE_NORMAL
  zh: structs。以下代码片段展示了一个Donor struct的示例
- en: 'contains an address and the donation amount:'
  id: totrans-1330
  prefs: []
  type: TYPE_NORMAL
  zh: 包含一个地址和捐赠金额：
- en: '*contract Charity {*'
  id: totrans-1331
  prefs: []
  type: TYPE_NORMAL
  zh: '*contract Charity {*'
- en: '*// Defines a struct with two fields.*'
  id: totrans-1332
  prefs: []
  type: TYPE_NORMAL
  zh: '*// 定义一个具有两个字段的结构体.*'
- en: '*struct Donor {*'
  id: totrans-1333
  prefs: []
  type: TYPE_NORMAL
  zh: '*struct Donor {*'
- en: '*address addr;*'
  id: totrans-1334
  prefs: []
  type: TYPE_NORMAL
  zh: '*address addr;*'
- en: '*uint donation_amount;*'
  id: totrans-1335
  prefs: []
  type: TYPE_NORMAL
  zh: uint donation_amount;
- en: '*}*'
  id: totrans-1336
  prefs: []
  type: TYPE_NORMAL
  zh: '*}*'
- en: '*// define a mapping*'
  id: totrans-1337
  prefs: []
  type: TYPE_NORMAL
  zh: '*// 定义一个映射*'
- en: '*mapping (uint =>Donors) donors;*'
  id: totrans-1338
  prefs: []
  type: TYPE_NORMAL
  zh: '*mapping (uint =>Donors) donors;*'
- en: '*//...*'
  id: totrans-1339
  prefs: []
  type: TYPE_NORMAL
  zh: '*//...*'
- en: '*}*'
  id: totrans-1340
  prefs: []
  type: TYPE_NORMAL
  zh: '*}*'
- en: '**Blockchain Specific Variables**'
  id: totrans-1341
  prefs: []
  type: TYPE_NORMAL
  zh: '**区块链特定变量**'
- en: Frequently, smart contracts need to get information from blockchain itself
  id: totrans-1342
  prefs: []
  type: TYPE_NORMAL
  zh: 经常，智能合约需要从区块链本身获取信息
- en: and use blockchain data in the functions. Solidity actually defines some
  id: totrans-1343
  prefs: []
  type: TYPE_NORMAL
  zh: 并在函数中使用区块链数据。Solidity实际上定义了一些
- en: global variables to refer to the blockchain state and transaction data. The
  id: totrans-1344
  prefs: []
  type: TYPE_NORMAL
  zh: 全局变量来引用区块链状态和交易数据。该
- en: common ones are global variables and functions defined in the following
  id: totrans-1345
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的有全局变量和以下定义的函数
- en: 'table (Figur[e 7-4). T](#p280)here are two major variables: msg (message global
    variable) and block (the blockchain variable).'
  id: totrans-1346
  prefs: []
  type: TYPE_NORMAL
  zh: table (Figur[e 7-4). T](#p280)这里有两个主要变量：msg（消息全局变量）和block（区块链变量）。
- en: '268'
  id: totrans-1347
  prefs: []
  type: TYPE_NORMAL
  zh: '268'
- en: Chapter 7 programming Smart ContraCt with Solidity
  id: totrans-1348
  prefs: []
  type: TYPE_NORMAL
  zh: Chapter 7 使用Solidity编程 Smart ContraCt
- en: '***Figure 7-4\.** Special blockchain variables and functions*'
  id: totrans-1349
  prefs: []
  type: TYPE_NORMAL
  zh: '***Figure 7-4\.** 特殊的区块链变量和函数*'
- en: Most of the global variables listed in the preceding table are self-
  id: totrans-1350
  prefs: []
  type: TYPE_NORMAL
  zh: 前表中列出的大多数全局变量都是自
- en: explanatory. There are a few variables that need further clarification.
  id: totrans-1351
  prefs: []
  type: TYPE_NORMAL
  zh: 解释性。有一些变量需要进一步澄清。
- en: The msg variable mainly defines the parameters and data inside a
  id: totrans-1352
  prefs: []
  type: TYPE_NORMAL
  zh: msg变量主要定义了交易内部
- en: transaction. Every time when a transaction is sent to Ethereum blockchain,
  id: totrans-1353
  prefs: []
  type: TYPE_NORMAL
  zh: 交易。每次将交易发送到以太坊区块链时，
- en: '269'
  id: totrans-1354
  prefs: []
  type: TYPE_NORMAL
  zh: '269'
- en: Chapter 7 programming Smart ContraCt with Solidity
  id: totrans-1355
  prefs: []
  type: TYPE_NORMAL
  zh: Chapter 7 使用Solidity编程 Smart ContraCt
- en: the msg object can be referred by a smart contract to extract the following
  id: totrans-1356
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约可以通过msg对象提取以下
- en: 'information:'
  id: totrans-1357
  prefs: []
  type: TYPE_NORMAL
  zh: 信息：
- en: '**msg.value** – This is the amount of Ether that is sent'
  id: totrans-1358
  prefs: []
  type: TYPE_NORMAL
  zh: '**msg.value** – 这是发送的以太币数量'
- en: to the receiver. It is in the unit of wei.
  id: totrans-1359
  prefs: []
  type: TYPE_NORMAL
  zh: 发送给接收者。它的单位是wei。
- en: '**msg.data** – This is the data field in a transaction. It is'
  id: totrans-1360
  prefs: []
  type: TYPE_NORMAL
  zh: '**msg.data** – 这是交易中的数据字段。它是'
- en: the user input data that is sent to a smart contract to
  id: totrans-1361
  prefs: []
  type: TYPE_NORMAL
  zh: 用户输入的数据发送到智能合约以
- en: process.
  id: totrans-1362
  prefs: []
  type: TYPE_NORMAL
  zh: 过程。
- en: '**msg.sig** – This is the signature of the sender who'
  id: totrans-1363
  prefs: []
  type: TYPE_NORMAL
  zh: '**msg.sig** – 这是发送者的签名，'
- en: sent the transaction.
  id: totrans-1364
  prefs: []
  type: TYPE_NORMAL
  zh: 发送交易。
- en: '**msg.sender** – This is the address of the sender. It'
  id: totrans-1365
  prefs: []
  type: TYPE_NORMAL
  zh: '**msg.sender** – 这是发送者的地址。它'
- en: is important to check the address of the sender to
  id: totrans-1366
  prefs: []
  type: TYPE_NORMAL
  zh: 检查发送者的地址是重要的以
- en: ensure that the sender is authorized to perform
  id: totrans-1367
  prefs: []
  type: TYPE_NORMAL
  zh: 确保发送者被授权执行
- en: actions on the smart contract functions.
  id: totrans-1368
  prefs: []
  type: TYPE_NORMAL
  zh: 在智能合约功能上执行操作。
- en: '**block.blockhash** – The block.blockhash is a special'
  id: totrans-1369
  prefs: []
  type: TYPE_NORMAL
  zh: '**block.blockhash** – 区块的`blockhash`是一个特殊'
- en: function that takes in a block number and outputs
  id: totrans-1370
  prefs: []
  type: TYPE_NORMAL
  zh: 函数，它接收一个区块号码并输出
- en: its block hash.
  id: totrans-1371
  prefs: []
  type: TYPE_NORMAL
  zh: 其区块哈希。
- en: '**block.difficulty** – Outputs the difficulty of'
  id: totrans-1372
  prefs: []
  type: TYPE_NORMAL
  zh: '**block.difficulty** – 输出的难度'
- en: blockchain mining.
  id: totrans-1373
  prefs: []
  type: TYPE_NORMAL
  zh: blockchain mining.
- en: '**block.gaslimit** – Defines the gas limit for the'
  id: totrans-1374
  prefs: []
  type: TYPE_NORMAL
  zh: '**block.gaslimit** —— 为'
- en: latest block.
  id: totrans-1375
  prefs: []
  type: TYPE_NORMAL
  zh: 最新的区块。
- en: '**block.number** – The latest block number.'
  id: totrans-1376
  prefs: []
  type: TYPE_NORMAL
  zh: '**block.number** —— 最新的区块号码。'
- en: '**gasleft()** – Returns the gas left for a transaction.'
  id: totrans-1377
  prefs: []
  type: TYPE_NORMAL
  zh: '**gasleft()** —— 返回交易剩余的燃料。'
- en: '**now** – The current timestamp.'
  id: totrans-1378
  prefs: []
  type: TYPE_NORMAL
  zh: '**now** —— 当前时间戳。'
- en: Another global variable is tx reserved for the transactions.
  id: totrans-1379
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个全局变量是tx，专用于交易。
- en: '**tx.gasprice** – Shows the gas price of the transaction.'
  id: totrans-1380
  prefs: []
  type: TYPE_NORMAL
  zh: '**tx.gasprice** —— 显示交易的燃料价格。'
- en: '**tx.origin** – Original sender of the transaction. This is'
  id: totrans-1381
  prefs: []
  type: TYPE_NORMAL
  zh: '**tx.origin** —— 交易的原发送者。这是'
- en: the same in single function calls as msg.sender.
  id: totrans-1382
  prefs: []
  type: TYPE_NORMAL
  zh: 在单个函数调用中与msg.sender相同。
- en: '270'
  id: totrans-1383
  prefs: []
  type: TYPE_NORMAL
  zh: '270'
- en: Chapter 7 programming Smart ContraCt with Solidity
  id: totrans-1384
  prefs: []
  type: TYPE_NORMAL
  zh: 第7章用Solidity编程智能合约
- en: '**Module 3: Events**'
  id: totrans-1385
  prefs: []
  type: TYPE_NORMAL
  zh: '**模块3：事件**'
- en: '**What Is Ethereum Event**'
  id: totrans-1386
  prefs: []
  type: TYPE_NORMAL
  zh: '**什么是以太坊事件**'
- en: Ethereum events are important concepts that are related to how to
  id: totrans-1387
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊事件是与如何
- en: message smart contract states and communicate with external programs.
  id: totrans-1388
  prefs: []
  type: TYPE_NORMAL
  zh: 消息智能合约状态并与外部程序通信。
- en: Event type is an inheritable member of smart contract that is built into
  id: totrans-1389
  prefs: []
  type: TYPE_NORMAL
  zh: 事件类型是内置到智能合约中的可继承成员
- en: Solidity programming language. Solidity provides syntaxes for defining an
  id: totrans-1390
  prefs: []
  type: TYPE_NORMAL
  zh: Solidity编程语言。Solidity提供了定义一个
- en: event format and emitting an event.
  id: totrans-1391
  prefs: []
  type: TYPE_NORMAL
  zh: 事件格式和发出事件。
- en: '**Where Are Events Stored**'
  id: totrans-1392
  prefs: []
  type: TYPE_NORMAL
  zh: '**事件存储在哪里**'
- en: Once an event is emitted, the corresponding event data is stored in the
  id: totrans-1393
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦发出事件，相应的事件数据将被存储在
- en: transaction logs. The event data is the list of arguments passed to the emit
  id: totrans-1394
  prefs: []
  type: TYPE_NORMAL
  zh: 交易日志。事件数据是传递给emit
- en: event function. The transaction logs are accessible through smart contract
  id: totrans-1395
  prefs: []
  type: TYPE_NORMAL
  zh: 事件函数。交易日志可以通过智能合约
- en: addresses by external programs. Although events are stored in transaction
  id: totrans-1396
  prefs: []
  type: TYPE_NORMAL
  zh: 地址被外部程序访问。尽管事件存储在交易
- en: logs, its content is not accessible by smart contracts. Smart contracts can
  id: totrans-1397
  prefs: []
  type: TYPE_NORMAL
  zh: 日志，其内容无法被智能合约访问。智能合约可以
- en: emit events but cannot access events that are emitted.
  id: totrans-1398
  prefs: []
  type: TYPE_NORMAL
  zh: 发出事件但不能访问发出的事件。
- en: '**How to Define an Event**'
  id: totrans-1399
  prefs: []
  type: TYPE_NORMAL
  zh: '**如何定义事件**'
- en: Defining an event is very simple; just use the “event” keyword to define an
  id: totrans-1400
  prefs: []
  type: TYPE_NORMAL
  zh: 定义事件非常简单；只需使用“event”关键词来定义一个
- en: 'event name with a list of attributes as the following:'
  id: totrans-1401
  prefs: []
  type: TYPE_NORMAL
  zh: 以事件名称和以下属性的列表：
- en: '*event eventName(dataType_1 [indexed] attribute_1, dataType_2*'
  id: totrans-1402
  prefs: []
  type: TYPE_NORMAL
  zh: '*事件 eventName(数据类型_1 [索引] 属性_1, 数据类型_2*'
- en: '*[indexed] attribute_2, ..., dataType_n [indexed] attribute_n);*'
  id: totrans-1403
  prefs: []
  type: TYPE_NORMAL
  zh: '*[索引] 属性_2, ..., 数据类型_n [索引] 属性_n);*'
- en: Here, event is the keyword to define an event.
  id: totrans-1404
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，event 是定义事件的关键词。
- en: eventName is a name of the event.
  id: totrans-1405
  prefs: []
  type: TYPE_NORMAL
  zh: eventName 是一个事件的名称。
- en: dataType_1, dataType_2, dataType_n are lists of data types defined in
  id: totrans-1406
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类型_1, 数据类型_2, 数据类型_n 是定义在
- en: Solidity.
  id: totrans-1407
  prefs: []
  type: TYPE_NORMAL
  zh: Solidity。
- en: attribute_1, attribute_2, attribute_n are lists of attribute names
  id: totrans-1408
  prefs: []
  type: TYPE_NORMAL
  zh: 属性_1, 属性_2, 属性_n 是属性名称列表
- en: specified by the developers.
  id: totrans-1409
  prefs: []
  type: TYPE_NORMAL
  zh: 由开发者指定。
- en: '271'
  id: totrans-1410
  prefs: []
  type: TYPE_NORMAL
  zh: '271'
- en: Chapter 7 programming Smart ContraCt with Solidity
  id: totrans-1411
  prefs: []
  type: TYPE_NORMAL
  zh: 第7章用Solidity编程智能合约
- en: indexed is a reserved keyword to allow a search for these events using
  id: totrans-1412
  prefs: []
  type: TYPE_NORMAL
  zh: 索引是保留关键字，允许使用这些事件进行搜索
- en: the indexed parameters as filters.
  id: totrans-1413
  prefs: []
  type: TYPE_NORMAL
  zh: 作为过滤器使用索引参数。
- en: For example, to define an event when a token is minted, use the
  id: totrans-1414
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要定义一个代币被铸成的事件，使用
- en: 'following event definition as example:'
  id: totrans-1415
  prefs: []
  type: TYPE_NORMAL
  zh: 以下事件定义为例：
- en: '*event Mint(address indexed receiver, uint amount);*'
  id: totrans-1416
  prefs: []
  type: TYPE_NORMAL
  zh: '*事件 Mint(地址索引接收者, uint 金额);*'
- en: In the example above, a Mint event is defined with two attributes. The
  id: totrans-1417
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，定义了一个带有两个属性的Mint事件。
- en: first attribute is the address of the receiver to which the minted token is
  id: totrans-1418
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的第一个属性是接收铸成代币的地址
- en: sent. The address is indexed, meaning that this is a searchable attribute.
  id: totrans-1419
  prefs: []
  type: TYPE_NORMAL
  zh: 发送。地址被索引，这意味着这是一个可搜索的属性。
- en: The second attribute is the amount of token that is minted. The event does
  id: totrans-1420
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个属性是铸成的代币数量。事件并没有
- en: not need to specify the token name or mint time as these can be inferred
  id: totrans-1421
  prefs: []
  type: TYPE_NORMAL
  zh: 无需指定代币名称或铸币时间，因为这些可以被推导出
- en: from the smart contract address and the block time for the transaction.
  id: totrans-1422
  prefs: []
  type: TYPE_NORMAL
  zh: 从智能合约地址和交易时间。
- en: In summary, an event definition basically defines an event name and a
  id: totrans-1423
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，事件定义基本是定义一个事件名称和一个
- en: list of attributes. Once an event is defined, it can be called with parameters
  id: totrans-1424
  prefs: []
  type: TYPE_NORMAL
  zh: 参数列表。一旦定义了一个事件，它可以通过参数
- en: to emit an event.
  id: totrans-1425
  prefs: []
  type: TYPE_NORMAL
  zh: 来发出事件。
- en: '**How to Emit an Event**'
  id: totrans-1426
  prefs: []
  type: TYPE_NORMAL
  zh: '**如何发出事件**'
- en: Once an event type is defined, it can be emitted and recorded in the
  id: totrans-1427
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义了事件类型，它就可以被发出并在
- en: transaction log as controlled by smart contract function. The syntax to emit
  id: totrans-1428
  prefs: []
  type: TYPE_NORMAL
  zh: 交易日志，由智能合约函数控制。发出事件的语法是
- en: 'an event is shown here:'
  id: totrans-1429
  prefs: []
  type: TYPE_NORMAL
  zh: 事件在这里显示：
- en: '*emit eventName(parameter_1, parameter_2, ..., parameter_n);*'
  id: totrans-1430
  prefs: []
  type: TYPE_NORMAL
  zh: '*emit eventName(parameter_1, parameter_2, ..., parameter_n);*'
- en: Here, emit is the keyword to trigger an emission of an event.
  id: totrans-1431
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，emit是触发事件发出的关键字。
- en: eventName is the event type defined by the developer using the
  id: totrans-1432
  prefs: []
  type: TYPE_NORMAL
  zh: 事件名称是开发者使用
- en: “event” keyword.
  id: totrans-1433
  prefs: []
  type: TYPE_NORMAL
  zh: “event”关键字定义的事件类型。
- en: Parameter_1, parameter_2, parameter_n are the parameters for the
  id: totrans-1434
  prefs: []
  type: TYPE_NORMAL
  zh: 参数1、参数2、参数n是事件类型的参数：
- en: attributes defined in the event type. The parameter data type should match
  id: totrans-1435
  prefs: []
  type: TYPE_NORMAL
  zh: 定义在事件类型中的属性。参数数据类型应与：
- en: the data type of the event attributes.
  id: totrans-1436
  prefs: []
  type: TYPE_NORMAL
  zh: 事件属性的数据类型。
- en: '272'
  id: totrans-1437
  prefs: []
  type: TYPE_NORMAL
  zh: '272'
- en: Chapter 7 programming Smart ContraCt with Solidity
  id: totrans-1438
  prefs: []
  type: TYPE_NORMAL
  zh: 第7章用Solidity编程智能合约
- en: An event type can be called to emit as many events as needed. For
  id: totrans-1439
  prefs: []
  type: TYPE_NORMAL
  zh: 事件类型可以被调用发出所需的事件数量。对于：
- en: example, the Mint event as defined in the last section can emit an event
  id: totrans-1440
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，上一节定义的Mint事件可以发出一个事件：
- en: each time a mint operation is performed.
  id: totrans-1441
  prefs: []
  type: TYPE_NORMAL
  zh: 每次执行铸币操作时。
- en: '*emit Mint(0x1F2D3A67b8E96039BbAC84EB4BC0913c0c16778c, 200);*'
  id: totrans-1442
  prefs: []
  type: TYPE_NORMAL
  zh: '*emit Mint(0x1F2D3A67b8E96039BbAC84EB4BC0913c0c16778c, 200);*'
- en: In the example above, an event is emitted to show that
  id: totrans-1443
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，发出一个事件来显示：
- en: 200 tokens have been minted to the specified address of
  id: totrans-1444
  prefs: []
  type: TYPE_NORMAL
  zh: 200个代币已经被铸送到指定地址的
- en: 0x1F2D3A67b8E96039BbAC84EB4BC0913c0c16778c.
  id: totrans-1445
  prefs: []
  type: TYPE_NORMAL
  zh: 0x1F2D3A67b8E96039BbAC84EB4BC0913c0c16778c.
- en: When an event is emitted, its data is actually saved onto the
  id: totrans-1446
  prefs: []
  type: TYPE_NORMAL
  zh: 当事件被发出时，其数据实际上被保存在：
- en: transaction log. The event can be viewed by using a block explorer to look
  id: totrans-1447
  prefs: []
  type: TYPE_NORMAL
  zh: 交易日志。事件可以通过使用区块浏览器来查看：
- en: into the transaction log section of a transaction. The log can be accessed
  id: totrans-1448
  prefs: []
  type: TYPE_NORMAL
  zh: 写入交易日志部分的交易。日志可以通过：
- en: through the address of the smart contract. The log cannot be accessed
  id: totrans-1449
  prefs: []
  type: TYPE_NORMAL
  zh: 通过智能合约的地址。日志无法被访问
- en: within the smart contract itself. A smart contract cannot emit an event in
  id: totrans-1450
  prefs: []
  type: TYPE_NORMAL
  zh: 在智能合约本身内部。智能合约不能在：
- en: one function and then call another function to process the emitted event.
  id: totrans-1451
  prefs: []
  type: TYPE_NORMAL
  zh: 一个函数，然后调用另一个函数来处理发出的事件。
- en: Events can only be accessed through external programs such as client
  id: totrans-1452
  prefs: []
  type: TYPE_NORMAL
  zh: 事件只能通过如客户端等外部程序访问：
- en: programs. The Web3 library has some event access function calls that can
  id: totrans-1453
  prefs: []
  type: TYPE_NORMAL
  zh: 程序。Web3库有一些事件访问函数调用，可以：
- en: be used to retrieve or search for the events.
  id: totrans-1454
  prefs: []
  type: TYPE_NORMAL
  zh: 可以用来检索或搜索事件。
- en: '**Event Examples**'
  id: totrans-1455
  prefs: []
  type: TYPE_NORMAL
  zh: '**事件示例**'
- en: Once we know the event definition and emission, coding events is very
  id: totrans-1456
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们知道了事件的定义和发出，编码事件就变得非常：
- en: straightforward. The following shows a contract for DepositEvent that
  id: totrans-1457
  prefs: []
  type: TYPE_NORMAL
  zh: 很直接。下面展示了一个名为DepositEvent的合约：
- en: 'emits deposit records:'
  id: totrans-1458
  prefs: []
  type: TYPE_NORMAL
  zh: 发出存款记录：
- en: '*pragma solidity ^0.8.0;*'
  id: totrans-1459
  prefs: []
  type: TYPE_NORMAL
  zh: '*pragma solidity ^0.8.0;*'
- en: '*contract DepositEvent {*'
  id: totrans-1460
  prefs: []
  type: TYPE_NORMAL
  zh: '*合约 DepositEvent {*'
- en: '*event Deposit(address indexed depositor_address, uint*'
  id: totrans-1461
  prefs: []
  type: TYPE_NORMAL
  zh: '*事件 Deposit(地址索引的存款人_地址，uint*'
- en: '*indexed deposit_id, uint deposit_amount); // defines a*'
  id: totrans-1462
  prefs: []
  type: TYPE_NORMAL
  zh: '*索引的存款_id，uint存款_金额); //定义了一个*'
- en: '*Deposit event with depositor address, depositor_id (or*'
  id: totrans-1463
  prefs: []
  type: TYPE_NORMAL
  zh: '*带有存款人地址、存款人_id（或*'
- en: '*deposit number), and deposit_amount as attributes*'
  id: totrans-1464
  prefs: []
  type: TYPE_NORMAL
  zh: '*存款_编号)，和存款_金额作为属性*'
- en: '273'
  id: totrans-1465
  prefs: []
  type: TYPE_NORMAL
  zh: '273'
- en: Chapter 7 programming Smart ContraCt with Solidity
  id: totrans-1466
  prefs: []
  type: TYPE_NORMAL
  zh: 第7章用Solidity编程智能合约
- en: '*function deposit(uint deposit_id) public payable {*'
  id: totrans-1467
  prefs: []
  type: TYPE_NORMAL
  zh: '*function deposit(uint deposit_id) public payable {*'
- en: '*emit Deposit(msg.sender, deposit_id, msg.value); //emit*'
  id: totrans-1468
  prefs: []
  type: TYPE_NORMAL
  zh: '*emit Deposit(msg.sender, deposit_id, msg.value); //发出*'
- en: '*a Depositor event with sender address, positor_id, and*'
  id: totrans-1469
  prefs: []
  type: TYPE_NORMAL
  zh: '*存款人事件带有发送者地址、存款人_id、和*'
- en: '*depositor_amount equal to the ether transferred in the*'
  id: totrans-1470
  prefs: []
  type: TYPE_NORMAL
  zh: '*存款人_金额等于在*'
- en: '*transaction.*'
  id: totrans-1471
  prefs: []
  type: TYPE_NORMAL
  zh: '*交易.*'
- en: '*}*'
  id: totrans-1472
  prefs: []
  type: TYPE_NORMAL
  zh: '*}*'
- en: '*}*'
  id: totrans-1473
  prefs: []
  type: TYPE_NORMAL
  zh: '*}*'
- en: In this example, a snippet of the DepositEvent class is defined. In the
  id: totrans-1474
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，定义了一个DepositEvent类的片段。在：
- en: class, a Deposit event is defined globally. There is a function deposit that
  id: totrans-1475
  prefs: []
  type: TYPE_NORMAL
  zh: 类中，定义了一个全局的存款事件。有一个名为deposit的函数：
- en: takes in a deposit_id as input and emits an event with depositor_address,
  id: totrans-1476
  prefs: []
  type: TYPE_NORMAL
  zh: 输入存款_id，并发出带有存款人_地址，
- en: deposit_id, and deposit_amount. The depositor_address and deposit_
  id: totrans-1477
  prefs: []
  type: TYPE_NORMAL
  zh: 存款_id，和存款_金额。存款人_地址和存款_
- en: amount are obtained from a special variable msg directly.
  id: totrans-1478
  prefs: []
  type: TYPE_NORMAL
  zh: 金额直接从特殊变量msg获取。
- en: Event is a messaging method that allows smart contracts to communicate
  id: totrans-1479
  prefs: []
  type: TYPE_NORMAL
  zh: 事件是一种消息传递方法，允许智能合约之间进行通信：
- en: with external programs. Blockchain is very self-confined, and smart contracts
  id: totrans-1480
  prefs: []
  type: TYPE_NORMAL
  zh: 与外部程序通信。区块链非常自我封闭，智能合约
- en: cannot access external programs directly. In this case, events become a
  id: totrans-1481
  prefs: []
  type: TYPE_NORMAL
  zh: 不能直接访问外部程序。在这种情况下，事件成为了一种：
- en: messaging mechanism between external programs and smart contracts.
  id: totrans-1482
  prefs: []
  type: TYPE_NORMAL
  zh: 外部程序和智能合约之间的消息传递机制。
- en: Since events are in transaction logs that are part of the state of Ethereum,
  id: totrans-1483
  prefs: []
  type: TYPE_NORMAL
  zh: 由于事件是Ethereum状态部分的事务日志，
- en: emitting events will cause gas consumption and should be carefully designed.
  id: totrans-1484
  prefs: []
  type: TYPE_NORMAL
  zh: 发出事件将导致燃料消耗，应该仔细设计。
- en: '**Module 4: Security**'
  id: totrans-1485
  prefs: []
  type: TYPE_NORMAL
  zh: '**模块4：安全**'
- en: Security is the most important aspect of Solidity programming.
  id: totrans-1486
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性是Solidity编程最重要的方面。
- en: In Chapter [8](https://doi.org/10.1007/978-1-4842-8164-2_8), we have one whole
    chapter describing blockchain security.
  id: totrans-1487
  prefs: []
  type: TYPE_NORMAL
  zh: 在第[8章](https://doi.org/10.1007/978-1-4842-8164-2_8)中，我们有一整章描述了区块链安全。
- en: In this module, we will discuss security with Solidity programming.
  id: totrans-1488
  prefs: []
  type: TYPE_NORMAL
  zh: 在本模块中，我们将讨论与Solidity编程相关的安全性。
- en: '**Function Vulnerabilities**'
  id: totrans-1489
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数漏洞**'
- en: '**Function Visibility Error**'
  id: totrans-1490
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数可见性错误**'
- en: This is a vulnerability where function visibility is not specified, or specified
  id: totrans-1491
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个函数可见性未指定或指定的漏洞
- en: as public when it is supposed to be private.
  id: totrans-1492
  prefs: []
  type: TYPE_NORMAL
  zh: 当它应该被声明为私有时，却声明为公共。
- en: '274'
  id: totrans-1493
  prefs: []
  type: TYPE_NORMAL
  zh: '274'
- en: Chapter 7 programming Smart ContraCt with Solidity
  id: totrans-1494
  prefs: []
  type: TYPE_NORMAL
  zh: 第7章 使用Solidity编程智能合约
- en: In earlier versions of the Solidity compiler, the visibility of a function is
  id: totrans-1495
  prefs: []
  type: TYPE_NORMAL
  zh: 在Solidity编译器的早期版本中，函数的可见性是
- en: default to public.
  id: totrans-1496
  prefs: []
  type: TYPE_NORMAL
  zh: 默认为公共。
- en: Functions should be properly specified as external, public, internal, or
  id: totrans-1497
  prefs: []
  type: TYPE_NORMAL
  zh: 函数应该被适当地指定为外部、公共、内部或
- en: private.
  id: totrans-1498
  prefs: []
  type: TYPE_NORMAL
  zh: 私有。
- en: One example of this vulnerability is shown in the following. The
  id: totrans-1499
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个此类漏洞的示例。在
- en: first function has an input check and calls the second function. The first
  id: totrans-1500
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数有输入检查并调用第二个函数。第一个
- en: function is declared as public, and it needs to be called by the client
  id: totrans-1501
  prefs: []
  type: TYPE_NORMAL
  zh: 函数被声明为公共，需要由客户端
- en: application with input from users. The second function has a vulnerability
  id: totrans-1502
  prefs: []
  type: TYPE_NORMAL
  zh: 带有用户输入的应用程序。第二个函数存在漏洞
- en: as it is declared as public but sends out funds without checking the validity
  id: totrans-1503
  prefs: []
  type: TYPE_NORMAL
  zh: 因为它被声明为公共，但发送资金时未检查其有效性
- en: of the senders.
  id: totrans-1504
  prefs: []
  type: TYPE_NORMAL
  zh: 发送者。
- en: pragma solidity ^0.4.24;
  id: totrans-1505
  prefs: []
  type: TYPE_NORMAL
  zh: pragma solidity ^0.4.24;
- en: contract HashForEther {
  id: totrans-1506
  prefs: []
  type: TYPE_NORMAL
  zh: contract HashForEther {
- en: function withdrawWinnings() public {
  id: totrans-1507
  prefs: []
  type: TYPE_NORMAL
  zh: function withdrawWinnings() public {
- en: // Winner if the last 8 hex characters of the
  id: totrans-1508
  prefs: []
  type: TYPE_NORMAL
  zh: // 如果最后一个8个十六进制字符的
- en: address are 0\.
  id: totrans-1509
  prefs: []
  type: TYPE_NORMAL
  zh: 地址是0\。
- en: require(uint32(msg.sender) == 0);
  id: totrans-1510
  prefs: []
  type: TYPE_NORMAL
  zh: require(uint32(msg.sender) == 0);
- en: _sendWinnings();
  id: totrans-1511
  prefs: []
  type: TYPE_NORMAL
  zh: _sendWinnings();
- en: '}'
  id: totrans-1512
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: function _sendWinnings() public { // security error. This
  id: totrans-1513
  prefs: []
  type: TYPE_NORMAL
  zh: function _sendWinnings() public { // 安全错误。这个
- en: function should be declared as private
  id: totrans-1514
  prefs: []
  type: TYPE_NORMAL
  zh: 函数应该被声明为私有
- en: msg.sender.transfer(this.balance);
  id: totrans-1515
  prefs: []
  type: TYPE_NORMAL
  zh: msg.sender.transfer(this.balance);
- en: '}'
  id: totrans-1516
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-1517
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: To fix this vulnerability, simply declare the second function to be
  id: totrans-1518
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个漏洞，只需将第二个函数声明为
- en: private.
  id: totrans-1519
  prefs: []
  type: TYPE_NORMAL
  zh: 私有。
- en: '275'
  id: totrans-1520
  prefs: []
  type: TYPE_NORMAL
  zh: '275'
- en: Chapter 7 programming Smart ContraCt with Solidity
  id: totrans-1521
  prefs: []
  type: TYPE_NORMAL
  zh: 第7章 使用Solidity编程智能合约
- en: '**Vulnerability: Function Call Return Value Not Checked**'
  id: totrans-1522
  prefs: []
  type: TYPE_NORMAL
  zh: '**漏洞：函数调用返回值未检查**'
- en: This is a vulnerability where the function call value is not checked. When
  id: totrans-1523
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个返回值未检查的漏洞。当
- en: a function is called and returns an error, the subsequent program still
  id: totrans-1524
  prefs: []
  type: TYPE_NORMAL
  zh: 一个函数被调用并返回一个错误，后续程序仍然
- en: executes. It is important to check return values and exceptions and process
  id: totrans-1525
  prefs: []
  type: TYPE_NORMAL
  zh: 执行。检查返回值和异常并处理
- en: the return value accordingly.
  id: totrans-1526
  prefs: []
  type: TYPE_NORMAL
  zh: 相应地处理返回值。
- en: '**Vulnerability: Ether Withdraw Operation Not Protected**'
  id: totrans-1527
  prefs: []
  type: TYPE_NORMAL
  zh: '**漏洞：以太坊提取操作未保护**'
- en: This is a serious vulnerability. It can happen in many cases. A
  id: totrans-1528
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个严重的漏洞。它可以在许多情况下发生。一个
- en: withdraw function should be protected with many factors. Firstly, the
  id: totrans-1529
  prefs: []
  type: TYPE_NORMAL
  zh: 提款功能应该有多个因素保护。首先，
- en: visibility of the function should be right. Secondly, the input addresses
  id: totrans-1530
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的可见性应该是正确的。其次，输入地址
- en: need to be checked to make sure the sender has the authority to withdraw
  id: totrans-1531
  prefs: []
  type: TYPE_NORMAL
  zh: 需要检查发送者是否有权提款
- en: the funds. Furthermore, the constructor code will need to be protected.
  id: totrans-1532
  prefs: []
  type: TYPE_NORMAL
  zh: 资金。此外，构造函数代码需要受到保护。
- en: The constructor function runs in the runtime bytecode and can be called
  id: totrans-1533
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数在运行时字节码中运行，可以被调用
- en: by a hacker to execute the code.
  id: totrans-1534
  prefs: []
  type: TYPE_NORMAL
  zh: 被黑客执行代码。
- en: '**Vulnerability: Self-Destruction Functions**'
  id: totrans-1535
  prefs: []
  type: TYPE_NORMAL
  zh: '**漏洞：自毁功能**'
- en: This is a vulnerability in which a user or hacker can call a function to
  id: totrans-1536
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个漏洞，用户或黑客可以调用一个函数来
- en: destroy the functionality of a smart contract and make it unrecoverable.
  id: totrans-1537
  prefs: []
  type: TYPE_NORMAL
  zh: 销毁智能合约的功能并使其不可恢复。
- en: This happened with the famous parity “I accidentally killed it” bug where
  id: totrans-1538
  prefs: []
  type: TYPE_NORMAL
  zh: 这发生在著名的Parity“我意外地杀死了它”错误中，
- en: an anonymous user called a "kill" function in a parity multisign wallet
  id: totrans-1539
  prefs: []
  type: TYPE_NORMAL
  zh: 一个匿名用户在Parity多重签名钱包中调用“kill”函数
- en: component and destroyed the component. The vulnerability caused a total
  id: totrans-1540
  prefs: []
  type: TYPE_NORMAL
  zh: 组件并被销毁。这个漏洞导致总共
- en: of 513,774.16 Ether inaccessible to the asset owners. In order to prevent this
  id: totrans-1541
  prefs: []
  type: TYPE_NORMAL
  zh: 513,774.16以太坊无法到达资产所有者。为了防止这种情况
- en: from happening, the use of kill function, denouncing ownership function,
  id: totrans-1542
  prefs: []
  type: TYPE_NORMAL
  zh: 从发生，使用kill函数，否认所有权函数，
- en: and destruct function should be kept minimum unless it is absolutely
  id: totrans-1543
  prefs: []
  type: TYPE_NORMAL
  zh: 除非绝对必要，否则应将销毁函数保持在最小
- en: needed. The self-destruction functions include suicide or selfdestruct
  id: totrans-1544
  prefs: []
  type: TYPE_NORMAL
  zh: 所需。自毁函数包括自杀或selfdestruct
- en: function.
  id: totrans-1545
  prefs: []
  type: TYPE_NORMAL
  zh: 函数。
- en: // This is a selfdestruct function that will remove the
  id: totrans-1546
  prefs: []
  type: TYPE_NORMAL
  zh: //这是一个自我销毁函数，将移除
- en: contract and send the remaining asset to the sender address
  id: totrans-1547
  prefs: []
  type: TYPE_NORMAL
  zh: 合同并把剩余的资产发送到发送者地址
- en: pragma solidity ^0.4.22;
  id: totrans-1548
  prefs: []
  type: TYPE_NORMAL
  zh: pragma solidity ^0.4.22;
- en: '276'
  id: totrans-1549
  prefs: []
  type: TYPE_NORMAL
  zh: '276'
- en: Chapter 7 programming Smart ContraCt with Solidity
  id: totrans-1550
  prefs: []
  type: TYPE_NORMAL
  zh: 第7章用Solidity编程智能合约
- en: contract SimpleSuicide {
  id: totrans-1551
  prefs: []
  type: TYPE_NORMAL
  zh: 合同SimpleSuicide {
- en: function sudicideAnyone() {
  id: totrans-1552
  prefs: []
  type: TYPE_NORMAL
  zh: 函数sudicideAnyone() {
- en: selfdestruct(msg.sender);
  id: totrans-1553
  prefs: []
  type: TYPE_NORMAL
  zh: selfdestruct(msg.sender);
- en: '}'
  id: totrans-1554
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-1555
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '**Vulnerability: Use of Solidity Deprecated Functions**'
  id: totrans-1556
  prefs: []
  type: TYPE_NORMAL
  zh: '**漏洞：使用Solidity弃用函数**'
- en: Some of the functions in the older Solidity versions are deprecated and
  id: totrans-1557
  prefs: []
  type: TYPE_NORMAL
  zh: Solidity早期版本中的一些函数已被弃用。
- en: replaced with new ones as shown in Figur[e 7-5](#p288). When doing the compilation,
    watch the warnings and replace the deprecated ones with the new ones.
  id: totrans-1558
  prefs: []
  type: TYPE_NORMAL
  zh: 用如图7-5所示的新函数替换旧函数（图7-5](#p288)）。在编译时，注意警告并替换旧的函数。
- en: '***Figure 7-5\.** Deprecated functions in Solidity*'
  id: totrans-1559
  prefs: []
  type: TYPE_NORMAL
  zh: '**图7-5.** Solidity中的弃用函数*'
- en: '**Vulnerability: Delegatecall to Untrusted Callee**'
  id: totrans-1560
  prefs: []
  type: TYPE_NORMAL
  zh: '**漏洞：向不可信的目标调用delegatecall**'
- en: Solidity supports delegatecall function that will call another smart contract
  id: totrans-1561
  prefs: []
  type: TYPE_NORMAL
  zh: Solidity支持delegatecall函数，将调用另一个智能合约。
- en: with the same execution context of the calling contract. This means that
  id: totrans-1562
  prefs: []
  type: TYPE_NORMAL
  zh: 与调用合同相同的执行上下文。这意味着
- en: msg.sender and msg.value are the same for the caller and callee. If the callee
  id: totrans-1563
  prefs: []
  type: TYPE_NORMAL
  zh: msg.sender和msg.value对调用者和被调用者是相同的。如果被调用者
- en: address is not trusted, it will cause security issues with the calling contract.
  id: totrans-1564
  prefs: []
  type: TYPE_NORMAL
  zh: 如果地址不可信，它将导致调用合同的安全问题。
- en: '277'
  id: totrans-1565
  prefs: []
  type: TYPE_NORMAL
  zh: '277'
- en: Chapter 7 programming Smart ContraCt with Solidity
  id: totrans-1566
  prefs: []
  type: TYPE_NORMAL
  zh: 第7章用Solidity编程智能合约
- en: '**Vulnerability: DOS with Failed Function Calls**'
  id: totrans-1567
  prefs: []
  type: TYPE_NORMAL
  zh: '**漏洞：失败的函数调用的DOS**'
- en: External calls may fail, and it should not halt the rest of the execution steps.
  id: totrans-1568
  prefs: []
  type: TYPE_NORMAL
  zh: 外部调用可能会失败，它不应该停止执行其余步骤。
- en: Developers should avoid combining multiple calls in a single transaction.
  id: totrans-1569
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者应避免在单个交易中组合多个调用。
- en: Contract functions should have logic to process failed calls. When
  id: totrans-1570
  prefs: []
  type: TYPE_NORMAL
  zh: 合同功能应具有处理失败调用的逻辑。当
- en: sending funds to users, it is best to let users “pull” the funds by initiating
    a
  id: totrans-1571
  prefs: []
  type: TYPE_NORMAL
  zh: 向用户发送资金，最好是让用户通过发起一个
- en: transaction rather than using smart contracts to push the asset to a group
  id: totrans-1572
  prefs: []
  type: TYPE_NORMAL
  zh: 交易，而不是使用智能合约将资产推送到一组。
- en: of users.
  id: totrans-1573
  prefs: []
  type: TYPE_NORMAL
  zh: 用户之间。
- en: '**Vulnerability: Race Conditions and Transaction**'
  id: totrans-1574
  prefs: []
  type: TYPE_NORMAL
  zh: '**漏洞：竞态条件与交易**'
- en: '**Order Dependence**'
  id: totrans-1575
  prefs: []
  type: TYPE_NORMAL
  zh: '**顺序依赖**'
- en: Blockchain does not execute transactions in the order in which they are
  id: totrans-1576
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链不会按照提交顺序执行交易。
- en: submitted. Transactions are packed by miners, and miners would like to
  id: totrans-1577
  prefs: []
  type: TYPE_NORMAL
  zh: 交易由矿工打包，矿工希望这样做。
- en: package transactions with higher gas fees. It will cause issues for some
  id: totrans-1578
  prefs: []
  type: TYPE_NORMAL
  zh: 高额交易费打包交易。它将给一些
- en: smart contract functions when there are dependencies for function calls
  id: totrans-1579
  prefs: []
  type: TYPE_NORMAL
  zh: 当有函数调用依赖时，应避免使用智能合约函数。
- en: in different smart contracts. For example, ERC20 fungible tokens have
  id: totrans-1580
  prefs: []
  type: TYPE_NORMAL
  zh: 在不同的智能合约之间。例如，ERC20代币具有
- en: an “approve” function to specify another user to use a certain amount
  id: totrans-1581
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个“批准”函数来指定另一个用户使用一定金额的代币。
- en: of token. Then there is a transfer function that can transfer funds not
  id: totrans-1582
  prefs: []
  type: TYPE_NORMAL
  zh: 代币的转账功能，可以转账不超过
- en: exceeding the approved amount. Suppose Alice approves funds to Bob at
  id: totrans-1583
  prefs: []
  type: TYPE_NORMAL
  zh: 超过了批准金额。假设Alice批准了对Bob的资金，
- en: the amount of m and then changes the approval amount to n, and during
  id: totrans-1584
  prefs: []
  type: TYPE_NORMAL
  zh: 将金额m更改为n，并在
- en: this time, Bob sends two transactions to transfer funds at amounts of n
  id: totrans-1585
  prefs: []
  type: TYPE_NORMAL
  zh: 这时，Bob发送了两个交易，转移资金的金额分别为n
- en: and m, respectively. Since the transactions are not in the exact order, it is
  id: totrans-1586
  prefs: []
  type: TYPE_NORMAL
  zh: 和 m， respectively. Since the transactions are not in the exact order, it is
- en: possible that Bob first transfer falls between Alice approval 1 and approval
  id: totrans-1587
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的Bob首先转移落在了Alice批准1和批准
- en: 2, while Bob transfer 2 falls after approval 2\. This will allow Bob to retrieve
  id: totrans-1588
  prefs: []
  type: TYPE_NORMAL
  zh: 2，而Bob转移2落在批准2之后。这将允许Bob取回
- en: the m+n token rather than the expected amount of either n or m.
  id: totrans-1589
  prefs: []
  type: TYPE_NORMAL
  zh: 代币，而不是预期金额的n或m。
- en: Fixing race conditions in function calls is not easy. One way to ensure
  id: totrans-1590
  prefs: []
  type: TYPE_NORMAL
  zh: 修复函数调用中的竞态条件并不容易。确保区块链按照提交顺序执行交易的一种方法是使用**理查德·费曼**，诺贝尔物理学奖获得者的学习方法。
- en: function dependency is to use secret salt and hash methods. The sender
  id: totrans-1591
  prefs: []
  type: TYPE_NORMAL
  zh: 函数依赖关系是使用秘密盐和哈希方法。发送者
- en: will have a secret salt and produce a hash of the salt. Then the sender
  id: totrans-1592
  prefs: []
  type: TYPE_NORMAL
  zh: 将有一个秘密盐并产生盐的哈希。然后发送者
- en: of the function will call the approved function with a hash and address.
  id: totrans-1593
  prefs: []
  type: TYPE_NORMAL
  zh: 函数将用哈希和地址调用批准的功能。
- en: The smart contract will save the hash to the blockchain. The sender
  id: totrans-1594
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约会将哈希保存到区块链上。发送
- en: '278'
  id: totrans-1595
  prefs: []
  type: TYPE_NORMAL
  zh: '278'
- en: Chapter 7 programming Smart ContraCt with Solidity
  id: totrans-1596
  prefs: []
  type: TYPE_NORMAL
  zh: 第7章 使用Solidity编写智能合约
- en: then sends the salt to the receiver. The receiver then calls the request
  id: totrans-1597
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将盐发送给接收方。接收方然后调用请求
- en: function with a secret salt. The smart contract computes the hash from
  id: totrans-1598
  prefs: []
  type: TYPE_NORMAL
  zh: 带有秘密盐的函数。智能合约从
- en: the salt and compares it with the one saved by the smart contract. If it
  id: totrans-1599
  prefs: []
  type: TYPE_NORMAL
  zh: 该盐与智能合约保存的盐进行比较。如果它
- en: matches, the request function will process the receiver’s request. If not,
  id: totrans-1600
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配，请求函数将处理接收方的请求。如果不匹配，
- en: it will be rejected. This ensures one-on-one mapping of two subsequent
  id: totrans-1601
  prefs: []
  type: TYPE_NORMAL
  zh: 它将被拒绝。这确保了两个连续
- en: function calls.
  id: totrans-1602
  prefs: []
  type: TYPE_NORMAL
  zh: 函数调用的一对一映射。
- en: '**Vulnerability: Assert Violation**'
  id: totrans-1603
  prefs: []
  type: TYPE_NORMAL
  zh: '**漏洞：断言违规**'
- en: Assert() is a function call to ensure the statement to be evaluated is always
  id: totrans-1604
  prefs: []
  type: TYPE_NORMAL
  zh: Assert()是一个函数调用，用于确保要评估的语句始终
- en: true. This is different from the require() function that is used to check the
  id: totrans-1605
  prefs: []
  type: TYPE_NORMAL
  zh: 真。这与用于检查的require()函数不同
- en: condition of the statement. Assert() result should never be false. If assert()
  id: totrans-1606
  prefs: []
  type: TYPE_NORMAL
  zh: 语句的条件。Assert()的结果永远不应该是假的。如果assert()
- en: function returns a false result, it means that there is a serious bug in
  id: totrans-1607
  prefs: []
  type: TYPE_NORMAL
  zh: 函数返回一个假结果，这意味着其中存在一个严重错误
- en: the code.
  id: totrans-1608
  prefs: []
  type: TYPE_NORMAL
  zh: 代码。
- en: '**Vulnerability: Cross Contract Call Enters into a Loop**'
  id: totrans-1609
  prefs: []
  type: TYPE_NORMAL
  zh: '**漏洞：跨合约调用进入循环**'
