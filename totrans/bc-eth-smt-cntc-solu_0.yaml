- en: '**Application Layer**'
  prefs: []
  type: TYPE_NORMAL
- en: The application layer contains software applications, tokens, and smart
  prefs: []
  type: TYPE_NORMAL
- en: contract languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the software application has three elements as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '*A web interface*'
  prefs: []
  type: TYPE_NORMAL
- en: a web Gui is needed for a decentralized application
  prefs: []
  type: TYPE_NORMAL
- en: '*A dApp connector*'
  prefs: []
  type: TYPE_NORMAL
- en: a connector uses web3 to connect web pages with
  prefs: []
  type: TYPE_NORMAL
- en: blockchain smart contracts
  prefs: []
  type: TYPE_NORMAL
- en: '*Smart contracts on*'
  prefs: []
  type: TYPE_NORMAL
- en: Smart contracts provide business and transaction logic for
  prefs: []
  type: TYPE_NORMAL
- en: '*blockchain*'
  prefs: []
  type: TYPE_NORMAL
- en: your applications
  prefs: []
  type: TYPE_NORMAL
- en: The second important component in the application layer is the
  prefs: []
  type: TYPE_NORMAL
- en: token. This is unique with blockchain, and the token economy is essential
  prefs: []
  type: TYPE_NORMAL
- en: to sustain a blockchain and decentralized applications. Token designs
  prefs: []
  type: TYPE_NORMAL
- en: '217'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 6 ethereum arChiteCture and Overview
  prefs: []
  type: TYPE_NORMAL
- en: include the kinds of tokens to issue, the amount of tokens supplied, who
  prefs: []
  type: TYPE_NORMAL
- en: governs the administration of token supply, and whether a new token
  prefs: []
  type: TYPE_NORMAL
- en: should be generated or an existing token can be reused.
  prefs: []
  type: TYPE_NORMAL
- en: Smart contract languages are also a major factor to consider. Besides
  prefs: []
  type: TYPE_NORMAL
- en: Solidity, there are other languages such as Vyper, Yul, FE, and Serpent that
  prefs: []
  type: TYPE_NORMAL
- en: can be leveraged to write smart contracts.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, the Ethereum blockchain architecture contains the
  prefs: []
  type: TYPE_NORMAL
- en: 'following layers: Network Layer, Core Blockchain Layer, Enterprise'
  prefs: []
  type: TYPE_NORMAL
- en: Blockchain Layer, Tooling Layer, and Applications Layer. Each layer
  prefs: []
  type: TYPE_NORMAL
- en: serves essential functions for the Ethereum blockchain. We will describe
  prefs: []
  type: TYPE_NORMAL
- en: in more detail the Tooling and Applications Layers for developers in the
  prefs: []
  type: TYPE_NORMAL
- en: subsequent chapters.
  prefs: []
  type: TYPE_NORMAL
- en: '**Ethereum Blockchain Ecosystem**'
  prefs: []
  type: TYPE_NORMAL
- en: '**and DeFi Projects**'
  prefs: []
  type: TYPE_NORMAL
- en: Before building a project using the smart contract development
  prefs: []
  type: TYPE_NORMAL
- en: technology, it is essential to learn about the current Ethereum ecosystems.
  prefs: []
  type: TYPE_NORMAL
- en: There are thousands of smart contracts and dApps deployed to the
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum blockchain already. We will walk through some of these projects
  prefs: []
  type: TYPE_NORMAL
- en: so that you are aware of what kinds of projects are available already. It is
  prefs: []
  type: TYPE_NORMAL
- en: better to brainstorm new ideas rather than reinvent the wheel.
  prefs: []
  type: TYPE_NORMAL
- en: '**Wallet to Manage Assets**'
  prefs: []
  type: TYPE_NORMAL
- en: The first class of blockchain applications are wallets that are used to
  prefs: []
  type: TYPE_NORMAL
- en: manage assets.
  prefs: []
  type: TYPE_NORMAL
- en: In traditional finance, if you want to manage your asset, you most likely
  prefs: []
  type: TYPE_NORMAL
- en: will go to a bank to open an account and let the bank manage the asset for
  prefs: []
  type: TYPE_NORMAL
- en: you. But in the Ethereum blockchain, the assets are stored in a distributed
  prefs: []
  type: TYPE_NORMAL
- en: ledger, and therefore, there are multiple ways to manage it.
  prefs: []
  type: TYPE_NORMAL
- en: '218'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-230_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 6 ethereum arChiteCture and Overview
  prefs: []
  type: TYPE_NORMAL
- en: '**Hosted Service**'
  prefs: []
  type: TYPE_NORMAL
- en: You can open an account with Coinbase and let Coinbase host the
  prefs: []
  type: TYPE_NORMAL
- en: management of your crypto asset. When Coinbase is hosting your asset, you
  prefs: []
  type: TYPE_NORMAL
- en: do not manage the private key for the asset; rather, you create a login account
  prefs: []
  type: TYPE_NORMAL
- en: with the Coinbase service and let Coinbase do the transactions on your
  prefs: []
  type: TYPE_NORMAL
- en: behalf. These kinds of services are centralized. There are asset management
  prefs: []
  type: TYPE_NORMAL
- en: services around the world that offer services similar to Coinbase.
  prefs: []
  type: TYPE_NORMAL
- en: For users who prefer managing assets without a central portal, they
  prefs: []
  type: TYPE_NORMAL
- en: can have full control of their assets by using Coinbase wallets that store
  prefs: []
  type: TYPE_NORMAL
- en: their private keys locally. Coinbase wallets allow users to create accounts
  prefs: []
  type: TYPE_NORMAL
- en: by themselves and do the asset management directly with the blockchain
  prefs: []
  type: TYPE_NORMAL
- en: without going through a custodian.
  prefs: []
  type: TYPE_NORMAL
- en: '**MetaMask**'
  prefs: []
  type: TYPE_NORMAL
- en: MetaMask is one of the most popular web browser extension wallets and
  prefs: []
  type: TYPE_NORMAL
- en: most versatile to use. Figur[e 6-3 sho](#p230)ws how MetaMask interacts with
    blockchain to manage assets.
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 6-3\.** MetaMask workflow*'
  prefs: []
  type: TYPE_NORMAL
- en: '219'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-231_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 6 ethereum arChiteCture and Overview
  prefs: []
  type: TYPE_NORMAL
- en: MetaMask can be installed on the Chrome or Firefox browser. For
  prefs: []
  type: TYPE_NORMAL
- en: Chrome installation, you simply download it from Chrome web store
  prefs: []
  type: TYPE_NORMAL
- en: and install it to your browser. When MetaMask is first launched, it will
  prefs: []
  type: TYPE_NORMAL
- en: create crypto accounts for you. Instead of generating private keys directly,
  prefs: []
  type: TYPE_NORMAL
- en: MetaMask uses BIP39 specifications to generate mnemonic words, i.e.
  prefs: []
  type: TYPE_NORMAL
- en: seed phrases, that are 12 common and easy-to-remember English words.
  prefs: []
  type: TYPE_NORMAL
- en: The seed phrase can be used to generate multiple private keys and
  prefs: []
  type: TYPE_NORMAL
- en: addresses. You need to write down the seed phrases in order to recover
  prefs: []
  type: TYPE_NORMAL
- en: MetaMask accounts if the extension is uninstalled.
  prefs: []
  type: TYPE_NORMAL
- en: '**MyEtherWallet**'
  prefs: []
  type: TYPE_NORMAL
- en: MyEtherWallet (MEW) is an open source, client-side interface that allows
  prefs: []
  type: TYPE_NORMAL
- en: users to interact directly with the Ethereum blockchain without having to
  prefs: []
  type: TYPE_NORMAL
- en: join a centralized exchange. Figur[e 6-4 sho](#p231)ws the workflow of transactions
    from user action to the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 6-4\.** MyEtherWallet workflow*'
  prefs: []
  type: TYPE_NORMAL
- en: '220'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 6 ethereum arChiteCture and Overview
  prefs: []
  type: TYPE_NORMAL
- en: Although MyEtherWallet only works on the client side with no blockchain
  prefs: []
  type: TYPE_NORMAL
- en: information sent back to the web server for processing and storage, there
  prefs: []
  type: TYPE_NORMAL
- en: are still possibilities for phishing attacks. Using a hardware or mobile wallet
  prefs: []
  type: TYPE_NORMAL
- en: of MyEtherWallet is recommended. The web-based MyEtherWallet is not
  prefs: []
  type: TYPE_NORMAL
- en: recommended and should be used in offline settings only.
  prefs: []
  type: TYPE_NORMAL
- en: '**Fortmatic**'
  prefs: []
  type: TYPE_NORMAL
- en: Fortmatic is another kind of wallet that allows users to create accounts
  prefs: []
  type: TYPE_NORMAL
- en: with their social identities. This is similar to a PayPal service where you
  prefs: []
  type: TYPE_NORMAL
- en: can create an account with an email address. Fortmatic provides APIs to
  prefs: []
  type: TYPE_NORMAL
- en: connect with various web-based decentralized applications and is very
  prefs: []
  type: TYPE_NORMAL
- en: convenient for users who do not mind using a custodian wallet for crypto
  prefs: []
  type: TYPE_NORMAL
- en: transactions and applications.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we mention asset management tools such as the web
  prefs: []
  type: TYPE_NORMAL
- en: wallet, web extension wallet, mobile wallet, and custodian wallet. When
  prefs: []
  type: TYPE_NORMAL
- en: 'choosing or developing a wallet, there are many factors to be considered:'
  prefs: []
  type: TYPE_NORMAL
- en: • **Private keys** – Who generates, stores, and manages
  prefs: []
  type: TYPE_NORMAL
- en: private keys?
  prefs: []
  type: TYPE_NORMAL
- en: • **Decentralization** – Is the wallet managed by a central
  prefs: []
  type: TYPE_NORMAL
- en: service or custodia?
  prefs: []
  type: TYPE_NORMAL
- en: • **Security** – Have there been any security breaches or
  prefs: []
  type: TYPE_NORMAL
- en: vulnerabilities reported in this wallet?
  prefs: []
  type: TYPE_NORMAL
- en: • **Ease of use** – Are the GUI and UX of the wallet user-
  prefs: []
  type: TYPE_NORMAL
- en: friendly?
  prefs: []
  type: TYPE_NORMAL
- en: • **Open source** – Is wallet open source or proprietary?
  prefs: []
  type: TYPE_NORMAL
- en: • **Central control** – Is the wallet a client-side or server-
  prefs: []
  type: TYPE_NORMAL
- en: side application?
  prefs: []
  type: TYPE_NORMAL
- en: • **Recovery** – Is there a trusted way to recover the
  prefs: []
  type: TYPE_NORMAL
- en: account if the wallet gets lost or damaged?
  prefs: []
  type: TYPE_NORMAL
- en: '221'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 6 ethereum arChiteCture and Overview
  prefs: []
  type: TYPE_NORMAL
- en: Since the crypto wallet is needed to manage assets in blockchain, it is
  prefs: []
  type: TYPE_NORMAL
- en: worth some time to research and choose the most trusted one.
  prefs: []
  type: TYPE_NORMAL
- en: '**Smart Contract–Enabled Banking dApp**'
  prefs: []
  type: TYPE_NORMAL
- en: In a conventional bank, customers can open accounts, deposit, and
  prefs: []
  type: TYPE_NORMAL
- en: borrow money. The bank has to maintain huge databases and IT systems
  prefs: []
  type: TYPE_NORMAL
- en: to keep track of all transactions and compute the interest on the savings
  prefs: []
  type: TYPE_NORMAL
- en: accounts and loans. The Ethereum blockchain is a public distributed
  prefs: []
  type: TYPE_NORMAL
- en: ledger, and crypto banking functions such as lending can be easily
  prefs: []
  type: TYPE_NORMAL
- en: implemented with smart contracts.
  prefs: []
  type: TYPE_NORMAL
- en: One popular DeFi project in this category is Compound. Compound is
  prefs: []
  type: TYPE_NORMAL
- en: a decentralized DeFi protocol (open API) to enable lending and borrowing
  prefs: []
  type: TYPE_NORMAL
- en: of cryptocurrency through smart contracts. A lender is an actor who
  prefs: []
  type: TYPE_NORMAL
- en: deposits supported cryptocurrencies such as ETH, USDT, USDC, and
  prefs: []
  type: TYPE_NORMAL
- en: DAI to the Compound platform to earn interest. When a lender deposits
  prefs: []
  type: TYPE_NORMAL
- en: cryptocurrency X to Compound, the smart contract will lock the asset and
  prefs: []
  type: TYPE_NORMAL
- en: issue the same amount of cX token to the depositor. The lender can use
  prefs: []
  type: TYPE_NORMAL
- en: the cX token to trade or redeem the X token back later. The smart contract
  prefs: []
  type: TYPE_NORMAL
- en: will also calculate the interest earned by the lender for each deposit
  prefs: []
  type: TYPE_NORMAL
- en: period. A borrower can borrow the cryptocurrency deposited by the
  prefs: []
  type: TYPE_NORMAL
- en: lender to the Compound repository. Borrowers need to deposit a collateral
  prefs: []
  type: TYPE_NORMAL
- en: asset in order to borrow the cryptocurrency they want. Borrowers pay
  prefs: []
  type: TYPE_NORMAL
- en: interest for the cryptocurrency they borrow and can repay the borrowed
  prefs: []
  type: TYPE_NORMAL
- en: cryptocurrency to get the collateral back.
  prefs: []
  type: TYPE_NORMAL
- en: If a borrower’s collateral value factor falls below the balance of
  prefs: []
  type: TYPE_NORMAL
- en: the loan, the borrowing account becomes insolvent and triggers a
  prefs: []
  type: TYPE_NORMAL
- en: liquidation event. A third party can pay a portion of the loan and get
  prefs: []
  type: TYPE_NORMAL
- en: the corresponding collateral originally deposited to this account. To
  prefs: []
  type: TYPE_NORMAL
- en: incentivize third parties to participate in liquidation, an incentive
  prefs: []
  type: TYPE_NORMAL
- en: determined by Compound’s governing system is provided.
  prefs: []
  type: TYPE_NORMAL
- en: '222'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 6 ethereum arChiteCture and Overview
  prefs: []
  type: TYPE_NORMAL
- en: In a smart contract–enabled banking function, there is no central
  prefs: []
  type: TYPE_NORMAL
- en: agency to manage the asset; the community needs to look at the smart
  prefs: []
  type: TYPE_NORMAL
- en: contract and check for security risk. There is always a risk that the smart
  prefs: []
  type: TYPE_NORMAL
- en: contracts are breached and customers’ funds are lost. To minimize the
  prefs: []
  type: TYPE_NORMAL
- en: risks, smart contracts are always open source, and the project team
  prefs: []
  type: TYPE_NORMAL
- en: normally has a third-party security audit before releasing them to the
  prefs: []
  type: TYPE_NORMAL
- en: mainnet of the public blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: '**Decentralized Exchange in Ethereum**'
  prefs: []
  type: TYPE_NORMAL
- en: Crypto exchanges are used to transfer asset ownership between two
  prefs: []
  type: TYPE_NORMAL
- en: different users. There have been some centralized exchanges such as
  prefs: []
  type: TYPE_NORMAL
- en: Coinbase and Binance. Decentralized exchanges are fully built on smart
  prefs: []
  type: TYPE_NORMAL
- en: contracts, and there is no need to build a centrally managed database for
  prefs: []
  type: TYPE_NORMAL
- en: the exchanges. Popular decentralized exchanges include DDEX, Loopring,
  prefs: []
  type: TYPE_NORMAL
- en: Uniswap, etc.
  prefs: []
  type: TYPE_NORMAL
- en: The Decentralized Exchange (DEX) using the Automated Market
  prefs: []
  type: TYPE_NORMAL
- en: Maker (AMM) has some innovations over centralized or conventional
  prefs: []
  type: TYPE_NORMAL
- en: exchanges. The AMM uses smart contracts and algorithms to adjust prices
  prefs: []
  type: TYPE_NORMAL
- en: of assets in the liquidity pool and enables transactions without the need of
  prefs: []
  type: TYPE_NORMAL
- en: maintaining an order book. For example, Uniswap is a popular AMM DEX
  prefs: []
  type: TYPE_NORMAL
- en: 'that uses the following mechanism through smart contracts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Automatic Liquidity Protocol** – Uniswap allows'
  prefs: []
  type: TYPE_NORMAL
- en: users to set up liquid pools by depositing an equal
  prefs: []
  type: TYPE_NORMAL
- en: value of trading pairs to a smart contract. Traders
  prefs: []
  type: TYPE_NORMAL
- en: can then trade their tokens with assets in the
  prefs: []
  type: TYPE_NORMAL
- en: liquidity pool.
  prefs: []
  type: TYPE_NORMAL
- en: '223'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 6 ethereum arChiteCture and Overview
  prefs: []
  type: TYPE_NORMAL
- en: '**Automatic Price Adjustment** – With the Uniswap'
  prefs: []
  type: TYPE_NORMAL
- en: liquidity pool, the amount of both tokens in a token
  prefs: []
  type: TYPE_NORMAL
- en: pair (X,Y) needs to be balanced. If the amount of
  prefs: []
  type: TYPE_NORMAL
- en: token X increases, then the amount for token Y
  prefs: []
  type: TYPE_NORMAL
- en: decreases, and the price of token Y increases. This
  prefs: []
  type: TYPE_NORMAL
- en: triggers negative feedback to balance the pool.
  prefs: []
  type: TYPE_NORMAL
- en: '**Arbitration**: Arbitration is a process for traders to'
  prefs: []
  type: TYPE_NORMAL
- en: balance the price fluctuation in a liquidity pool.
  prefs: []
  type: TYPE_NORMAL
- en: When the amount of token X in token pair
  prefs: []
  type: TYPE_NORMAL
- en: (X, Y) increases, the amount of token Y decreases,
  prefs: []
  type: TYPE_NORMAL
- en: and the price of token Y increases. The arbitrator
  prefs: []
  type: TYPE_NORMAL
- en: then sees that token Y’s price is higher than in
  prefs: []
  type: TYPE_NORMAL
- en: other exchanges and will sell token Y from other
  prefs: []
  type: TYPE_NORMAL
- en: exchanges to Uniswap to increase the supply of
  prefs: []
  type: TYPE_NORMAL
- en: token Y to balance the liquidity pool. When the
  prefs: []
  type: TYPE_NORMAL
- en: liquidity pool is balanced, the token prices should
  prefs: []
  type: TYPE_NORMAL
- en: be similar to the token prices in other exchanges.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Automated Market Maker mechanism, Uniswap was able to
  prefs: []
  type: TYPE_NORMAL
- en: grow the TLV (total locked value) to 5 billion dollars within three years of
  prefs: []
  type: TYPE_NORMAL
- en: development with an impressive 5% day-over-day growth.
  prefs: []
  type: TYPE_NORMAL
- en: '**NFT Applications**'
  prefs: []
  type: TYPE_NORMAL
- en: The NFT is a kind of token that has a unique identification and cannot
  prefs: []
  type: TYPE_NORMAL
- en: be replaced or swapped with another. The specification of the NFT is in
  prefs: []
  type: TYPE_NORMAL
- en: ERC721 and in a later version of ERC1440\. One key feature of ERC721 is a
  prefs: []
  type: TYPE_NORMAL
- en: field called id that contains a unique value for each token. ERC721 is most
  prefs: []
  type: TYPE_NORMAL
- en: frequently used to represent creative artwork. Projects in NFT include
  prefs: []
  type: TYPE_NORMAL
- en: 0xcert, OpenSea, Decentraland, CryptoPunk, etc.
  prefs: []
  type: TYPE_NORMAL
- en: '224'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 6 ethereum arChiteCture and Overview
  prefs: []
  type: TYPE_NORMAL
- en: 0xcert is an SDK tool set that allows you to develop NFTs. Most of the
  prefs: []
  type: TYPE_NORMAL
- en: tokens issued in Ethereum for ERC20 are fungible, meaning that there is no
  prefs: []
  type: TYPE_NORMAL
- en: difference between token items. Fungible tokens are value based and like
  prefs: []
  type: TYPE_NORMAL
- en: dollar bills are swappable. For NFTs, each token is different, and they are
  prefs: []
  type: TYPE_NORMAL
- en: not replaceable. For example, a certificate or diploma can be represented
  prefs: []
  type: TYPE_NORMAL
- en: as a nonfungible token because it is uniquely issued by an institute to
  prefs: []
  type: TYPE_NORMAL
- en: a particular person. In the future, there will be more and more dApps
  prefs: []
  type: TYPE_NORMAL
- en: developed to work with nonfungible tokens. For example, original art works,
  prefs: []
  type: TYPE_NORMAL
- en: court documents, and college certificates all belonged to this category.
  prefs: []
  type: TYPE_NORMAL
- en: OpenSea allows users to submit NFT works for sale or buy NFT
  prefs: []
  type: TYPE_NORMAL
- en: collections with cryptocurrencies. They also support auctions so that the
  prefs: []
  type: TYPE_NORMAL
- en: highest bidders are granted the right to purchase an NFT artwork by smart
  prefs: []
  type: TYPE_NORMAL
- en: contract. All transactions are controlled by smart contracts automatically,
  prefs: []
  type: TYPE_NORMAL
- en: and no manual intervention or third-party hosts are needed.
  prefs: []
  type: TYPE_NORMAL
- en: '**Oracle Service**'
  prefs: []
  type: TYPE_NORMAL
- en: An Oracle service is used to provide connection between blockchain and
  prefs: []
  type: TYPE_NORMAL
- en: conventional IT systems. Blockchain is self-confined, and there is no direct
  prefs: []
  type: TYPE_NORMAL
- en: way for a blockchain client to talk to web servers directly. This is most
  prefs: []
  type: TYPE_NORMAL
- en: likely designed for security considerations. Neither Bitcoin or Ethereum
  prefs: []
  type: TYPE_NORMAL
- en: blockchains have a web API integrated on chain to call web services hosted
  prefs: []
  type: TYPE_NORMAL
- en: by conventional IT systems. In order for blockchains to interact with
  prefs: []
  type: TYPE_NORMAL
- en: conventional IT systems, Oracle services need to be used.
  prefs: []
  type: TYPE_NORMAL
- en: Chainlink is one of the most popular Oracle services that allow linkage
  prefs: []
  type: TYPE_NORMAL
- en: of traditional web services with Ethereum blockchain. If you have a
  prefs: []
  type: TYPE_NORMAL
- en: decentralized application that needs to get outside data, you need to use
  prefs: []
  type: TYPE_NORMAL
- en: an Oracle service. For example, if your smart contract needs to get weather
  prefs: []
  type: TYPE_NORMAL
- en: information, you have to use an Oracle service, as the blockchain itself does
  prefs: []
  type: TYPE_NORMAL
- en: not have any weather information. To get information about FIAT/CBDC
  prefs: []
  type: TYPE_NORMAL
- en: values, currency exchange rate, or cryptocurrency values, you need to
  prefs: []
  type: TYPE_NORMAL
- en: connect to Oracle services provided by banks or third parties services as well.
  prefs: []
  type: TYPE_NORMAL
- en: '225'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 6 ethereum arChiteCture and Overview
  prefs: []
  type: TYPE_NORMAL
- en: There are other Oracle services provided by Provable and Band
  prefs: []
  type: TYPE_NORMAL
- en: projects. Provable project also provides some SDK and example code to
  prefs: []
  type: TYPE_NORMAL
- en: work with Oracle services with dApps and is very convenient.
  prefs: []
  type: TYPE_NORMAL
- en: '**DAO Platforms**'
  prefs: []
  type: TYPE_NORMAL
- en: DAO (Decentralized Autonomous Organization) is a platform to use smart
  prefs: []
  type: TYPE_NORMAL
- en: contracts to manage an organization or community. The DAO platforms
  prefs: []
  type: TYPE_NORMAL
- en: provide registration services and assign identities to constituents. Each
  prefs: []
  type: TYPE_NORMAL
- en: member of the community can propose proposals and can also vote on
  prefs: []
  type: TYPE_NORMAL
- en: proposals. There are many DAO platforms in the blockchain space already.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, many projects such as Compound and Uniswap have their own
  prefs: []
  type: TYPE_NORMAL
- en: DAO communities and governing tokens to vote for proposals in the
  prefs: []
  type: TYPE_NORMAL
- en: community.
  prefs: []
  type: TYPE_NORMAL
- en: '**Decentralized Insurance Platform**'
  prefs: []
  type: TYPE_NORMAL
- en: The Decentralized Insurance Platform allows smart contracts to manage
  prefs: []
  type: TYPE_NORMAL
- en: the signing up of insurance services, provide insurance service from
  prefs: []
  type: TYPE_NORMAL
- en: various sources, and then manage claims for the insured accounts. For
  prefs: []
  type: TYPE_NORMAL
- en: example, if you want to prevent a heavy loss from a Bitcoin price crash, you
  prefs: []
  type: TYPE_NORMAL
- en: can actually send a transaction to a smart contract to pay a premium as
  prefs: []
  type: TYPE_NORMAL
- en: insurance, and there are people on the provider side who will accept the
  prefs: []
  type: TYPE_NORMAL
- en: insurance request. All the terms of insurance are recorded and enforced
  prefs: []
  type: TYPE_NORMAL
- en: through smart contracts. If unexpected events happen and trigger the
  prefs: []
  type: TYPE_NORMAL
- en: insurance actions, the smart contract will execute the corresponding
  prefs: []
  type: TYPE_NORMAL
- en: function and compensate the insured person.
  prefs: []
  type: TYPE_NORMAL
- en: '226'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 6 ethereum arChiteCture and Overview
  prefs: []
  type: TYPE_NORMAL
- en: '**Decentralized KYC and Identity**'
  prefs: []
  type: TYPE_NORMAL
- en: KYC (Know Your Customers) and Identity are services and tools to identify
  prefs: []
  type: TYPE_NORMAL
- en: a real person and gather needed personal information to be in compliance
  prefs: []
  type: TYPE_NORMAL
- en: with regulations. There are projects such as Civic, Hydro, Sovrin, and uPort
  prefs: []
  type: TYPE_NORMAL
- en: that provide decentralized identity service for decentralized applications.
  prefs: []
  type: TYPE_NORMAL
- en: To build KYC features within a decentralized application is quite
  prefs: []
  type: TYPE_NORMAL
- en: challenging. It is much easier just to use a third-party KYC service.
  prefs: []
  type: TYPE_NORMAL
- en: '**Stablecoin**'
  prefs: []
  type: TYPE_NORMAL
- en: One of the challenges of cryptocurrencies is its volatility. Bitcoin and
  prefs: []
  type: TYPE_NORMAL
- en: Ether’s values fluctuate a lot, and using them to represent values for
  prefs: []
  type: TYPE_NORMAL
- en: products and services will cause fluctuations in prices. Stablecoin is an
  prefs: []
  type: TYPE_NORMAL
- en: asset that has relatively stable values when pegged with fiat currencies.
  prefs: []
  type: TYPE_NORMAL
- en: These stablecoins are normally ERC20 tokens in the Ethereum blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: Their values are maintained to be stable in several ways. For example,
  prefs: []
  type: TYPE_NORMAL
- en: a stablecoin can be backed by US dollars with a one-to-one ratio. These
  prefs: []
  type: TYPE_NORMAL
- en: stablecoins include Gemini Dollar, TrueUSD, USD Coin, etc, as reported in
  prefs: []
  type: TYPE_NORMAL
- en: some publications.
  prefs: []
  type: TYPE_NORMAL
- en: There are other kinds such as MakerDAO’s Dai that are an aggregation
  prefs: []
  type: TYPE_NORMAL
- en: of various assets and controlled by automatic burning and minting of
  prefs: []
  type: TYPE_NORMAL
- en: stablecoins to make the value stable.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, there are many big decentralized applications built
  prefs: []
  type: TYPE_NORMAL
- en: on Ethereum already in almost all major categories. There are some
  prefs: []
  type: TYPE_NORMAL
- en: applications that are still emerging. Small smart contract projects such
  prefs: []
  type: TYPE_NORMAL
- en: as rental sharing, on-demand music service, and decentralized voting
  prefs: []
  type: TYPE_NORMAL
- en: platforms are all possible projects that can be built with smart contracts.
  prefs: []
  type: TYPE_NORMAL
- en: Smart contract development is a fascinating area. Developers can find
  prefs: []
  type: TYPE_NORMAL
- en: unlimited possibilities to develop revolutionary decentralized applications
  prefs: []
  type: TYPE_NORMAL
- en: once they learn how to program smart contracts.
  prefs: []
  type: TYPE_NORMAL
- en: '227'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-239_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 6 ethereum arChiteCture and Overview
  prefs: []
  type: TYPE_NORMAL
- en: '**Tools to Set Up a Smart Contract**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Development Environment**'
  prefs: []
  type: TYPE_NORMAL
- en: There are multiple ways to set up environments to interact with the
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum blockchain. Figure [6-5](#p239) shows an overview of various tools
    and components.
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 6-5\.** Some basic tools for Ethereum blockchain*'
  prefs: []
  type: TYPE_NORMAL
- en: The top layer shows various kinds of Ethereum blockchains. Ganache
  prefs: []
  type: TYPE_NORMAL
- en: tool produces a local and single-node Ethereum blockchain and allows
  prefs: []
  type: TYPE_NORMAL
- en: for development and quick testing of smart contracts and clients.
  prefs: []
  type: TYPE_NORMAL
- en: Development blockchain allows developers to change the genesis file
  prefs: []
  type: TYPE_NORMAL
- en: and start a fully controlled blockchain. Developers can issue Ether tokens
  prefs: []
  type: TYPE_NORMAL
- en: in the development blockchain and can decide on a permissioned list
  prefs: []
  type: TYPE_NORMAL
- en: for blockchain nodes. Testnets are public Ethereum blockchains that are
  prefs: []
  type: TYPE_NORMAL
- en: built by the Ethereum community for testing purposes. Testnet Ether
  prefs: []
  type: TYPE_NORMAL
- en: tokens can be obtained through some public faucets. There is no tradable
  prefs: []
  type: TYPE_NORMAL
- en: crypto value for the testnet token. The public mainnet is the production
  prefs: []
  type: TYPE_NORMAL
- en: '228'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 6 ethereum arChiteCture and Overview
  prefs: []
  type: TYPE_NORMAL
- en: blockchain of Ethereum, and the Ethers have value and can be traded in
  prefs: []
  type: TYPE_NORMAL
- en: exchanges. In this section, we mention minimal viable tool sets including
  prefs: []
  type: TYPE_NORMAL
- en: wallet, browser, node client, smart contract IDE, and Web3 to interact with
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum blockchains.
  prefs: []
  type: TYPE_NORMAL
- en: '**MetaMask: The Simplest Way to Interact**'
  prefs: []
  type: TYPE_NORMAL
- en: '**with the Ethereum Blockchain**'
  prefs: []
  type: TYPE_NORMAL
- en: To get hands-on experience with the Ethereum blockchain, one of the
  prefs: []
  type: TYPE_NORMAL
- en: easiest steps is to use a wallet to create an account and do some simple
  prefs: []
  type: TYPE_NORMAL
- en: transactions of sending and receiving crypto tokens. This can be done in
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum by using MetaMask. MetaMask is a web extension that can be
  prefs: []
  type: TYPE_NORMAL
- en: installed onto a web browser to create accounts to interact with Ethereum
  prefs: []
  type: TYPE_NORMAL
- en: 'with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 1: Install the MetaMask extension and create*'
  prefs: []
  type: TYPE_NORMAL
- en: '*crypto accounts*'
  prefs: []
  type: TYPE_NORMAL
- en: Go to [https://metamask.io and ins](https://metamask.io)tall MetaMask
  prefs: []
  type: TYPE_NORMAL
- en: to your web browser such as Chrome or Firefox.
  prefs: []
  type: TYPE_NORMAL
- en: After the installation, open MetaMask and write
  prefs: []
  type: TYPE_NORMAL
- en: down the mnemonic passphrase of the wallet. The
  prefs: []
  type: TYPE_NORMAL
- en: passphrase is 12 English words that are used to
  prefs: []
  type: TYPE_NORMAL
- en: represent the private key of a wallet. This passphrase
  prefs: []
  type: TYPE_NORMAL
- en: needs to be stored securely because it is needed to
  prefs: []
  type: TYPE_NORMAL
- en: recover the wallet if the MetaMask is mistakenly
  prefs: []
  type: TYPE_NORMAL
- en: uninstalled or the computer system stops working
  prefs: []
  type: TYPE_NORMAL
- en: and the MetaMask needs to be reinstalled. Once you
  prefs: []
  type: TYPE_NORMAL
- en: create a crypto account with MetaMask, there will
  prefs: []
  type: TYPE_NORMAL
- en: be a public address for the account. This address is
  prefs: []
  type: TYPE_NORMAL
- en: also called the account address and can be used to
  prefs: []
  type: TYPE_NORMAL
- en: receive cryptocurrency for the account.
  prefs: []
  type: TYPE_NORMAL
- en: '229'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 6 ethereum arChiteCture and Overview
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 2: Fund MetaMask account*'
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the type of Ethereum blockchain you
  prefs: []
  type: TYPE_NORMAL
- en: are connecting with, there might be different ways to
  prefs: []
  type: TYPE_NORMAL
- en: get the wallet account funded.
  prefs: []
  type: TYPE_NORMAL
- en: For development blockchains that are created
  prefs: []
  type: TYPE_NORMAL
- en: by developers or through ganache_cli, there will
  prefs: []
  type: TYPE_NORMAL
- en: be some default accounts created and funded.
  prefs: []
  type: TYPE_NORMAL
- en: Whoever starts the development blockchain will
  prefs: []
  type: TYPE_NORMAL
- en: have some Ethers minted automatically in the
  prefs: []
  type: TYPE_NORMAL
- en: accounts owned by the developer. Developers
  prefs: []
  type: TYPE_NORMAL
- en: can import these funded accounts to their
  prefs: []
  type: TYPE_NORMAL
- en: MetaMask wallet.
  prefs: []
  type: TYPE_NORMAL
- en: For testnets such as Rinkeby, Kovan, Ropsten, and
  prefs: []
  type: TYPE_NORMAL
- en: Goerli, the test token can be obtained through a
  prefs: []
  type: TYPE_NORMAL
- en: faucet. Developers can go to the faucet URL, paste
  prefs: []
  type: TYPE_NORMAL
- en: a social media message with the wallet account’s
  prefs: []
  type: TYPE_NORMAL
- en: public address, and send it to the faucet web server.
  prefs: []
  type: TYPE_NORMAL
- en: The faucet will then send a small amount of testnet
  prefs: []
  type: TYPE_NORMAL
- en: Ether to the address specified in the message.
  prefs: []
  type: TYPE_NORMAL
- en: For mainnet Ethereum, the Ether needs to be
  prefs: []
  type: TYPE_NORMAL
- en: purchased. This can be done by opening an
  prefs: []
  type: TYPE_NORMAL
- en: exchange account from services such as Coinbase
  prefs: []
  type: TYPE_NORMAL
- en: and paying with FIAT to get Ether.
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 3: Send and receive tokens*'
  prefs: []
  type: TYPE_NORMAL
- en: Once the crypto account is created and funded,
  prefs: []
  type: TYPE_NORMAL
- en: users can start sending and receiving tokens.
  prefs: []
  type: TYPE_NORMAL
- en: To send tokens, simply click Send and fill in Nonce,
  prefs: []
  type: TYPE_NORMAL
- en: receiving amount, and receiver address and then
  prefs: []
  type: TYPE_NORMAL
- en: click “Send” after verifying information.
  prefs: []
  type: TYPE_NORMAL
- en: '230'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 6 ethereum arChiteCture and Overview
  prefs: []
  type: TYPE_NORMAL
- en: To receive tokens, just give the account address to
  prefs: []
  type: TYPE_NORMAL
- en: the sender, and let the sender send cryptocurrency
  prefs: []
  type: TYPE_NORMAL
- en: to that address.
  prefs: []
  type: TYPE_NORMAL
- en: '**Etherscan: The Most Comprehensive**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Blockchain Browser**'
  prefs: []
  type: TYPE_NORMAL
- en: When transactions are transported to and executed in Ethereum, they
  prefs: []
  type: TYPE_NORMAL
- en: induce Ethereum state changes in account balances, blocks, transactions,
  prefs: []
  type: TYPE_NORMAL
- en: smart contracts, and event logs. The Ethereum blockchain only records
  prefs: []
  type: TYPE_NORMAL
- en: raw data in its storage. To browse the blockchain and make sense of it,
  prefs: []
  type: TYPE_NORMAL
- en: some of the data will need to be processed and stored in databases for
  prefs: []
  type: TYPE_NORMAL
- en: easy query and visualization. Etherscan is a web service that provides an
  prefs: []
  type: TYPE_NORMAL
- en: excellent Ethereum blockchain browsing experience. To use Etherscan,
  prefs: []
  type: TYPE_NORMAL
- en: simply open any web browser and point the URL to http://etherscan.io.
  prefs: []
  type: TYPE_NORMAL
- en: You can use the Etherscan browser to browse every account, smart
  prefs: []
  type: TYPE_NORMAL
- en: contract, block, and transaction in Ethereum blockchain. For developers
  prefs: []
  type: TYPE_NORMAL
- en: who need to use the blockchain data programmatically, Etherscan also
  prefs: []
  type: TYPE_NORMAL
- en: provide API functions and an API key to integrate dynamic Ethereum
  prefs: []
  type: TYPE_NORMAL
- en: blockchain data into your decentralized applications. Etherscan, as well
  prefs: []
  type: TYPE_NORMAL
- en: as other Ethereum blockchain browsers, only works with Ethereum public
  prefs: []
  type: TYPE_NORMAL
- en: blockchains, such as mainnet, Rinkeby, Kovan, Ropsten, and Goerli; it
  prefs: []
  type: TYPE_NORMAL
- en: does not work with development blockchains.
  prefs: []
  type: TYPE_NORMAL
- en: '**Geth: The Swiss Army Knife for the**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ethereum Blockchain**'
  prefs: []
  type: TYPE_NORMAL
- en: Geth stands for Go Ethereum and is a stand-alone Ethereum client that
  prefs: []
  type: TYPE_NORMAL
- en: can run on an operating system as a miner node to earn Ether, or as an
  prefs: []
  type: TYPE_NORMAL
- en: RPC node to provide RPC services to client applications. We recommend
  prefs: []
  type: TYPE_NORMAL
- en: developers download a version of geth and use it as a sandbox with
  prefs: []
  type: TYPE_NORMAL
- en: following steps to interact with Ethereum blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: '231'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 6 ethereum arChiteCture and Overview
  prefs: []
  type: TYPE_NORMAL
- en: '*Task 1: Prepare a geth standalone client*'
  prefs: []
  type: TYPE_NORMAL
- en: Geth client repository is located at [https://geth.ethereum.org/](https://geth.ethereum.org/downloads/)
  prefs: []
  type: TYPE_NORMAL
- en: '[downloads/.](https://geth.ethereum.org/downloads/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also download it from GitHub at the following location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/ethereum/go- ethereum.](https://github.com/ethereum/go-ethereum)'
  prefs: []
  type: TYPE_NORMAL
- en: Geth client is supported by major operating systems such as Linux,
  prefs: []
  type: TYPE_NORMAL
- en: Windows, and MacOS. Since it is open source, it is recommended that
  prefs: []
  type: TYPE_NORMAL
- en: developers run it in Linux systems such as Ubuntu.
  prefs: []
  type: TYPE_NORMAL
- en: To compile geth from its source code, the Go programming language
  prefs: []
  type: TYPE_NORMAL
- en: compiler will need to be installed. Developers can use the Golang
  prefs: []
  type: TYPE_NORMAL
- en: compiler for geth compilation.
  prefs: []
  type: TYPE_NORMAL
- en: '*Task 2: Run geth application*'
  prefs: []
  type: TYPE_NORMAL
- en: The geth application can run with various options. The full instruction
  prefs: []
  type: TYPE_NORMAL
- en: is locate[d in https://geth.ethereum.org/docs/](https://geth.ethereum.org/docs/).
    You can run it with the --miner option to do mining, but this is not recommended
    because
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum mining difficulty level is high, and it is almost impossible to
  prefs: []
  type: TYPE_NORMAL
- en: compete with big mining pools in proof-of-work (POW) blockchains.
  prefs: []
  type: TYPE_NORMAL
- en: 'Geth can run as a sandbox for the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: • Use geth to build a development blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: • Use geth as a full blockchain client to download the
  prefs: []
  type: TYPE_NORMAL
- en: whole Ethereum testnet or mainnet blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: • Use geth as an RPC service to query blockchain
  prefs: []
  type: TYPE_NORMAL
- en: information and broadcast transactions to all
  prefs: []
  type: TYPE_NORMAL
- en: blockchain nodes.
  prefs: []
  type: TYPE_NORMAL
- en: • Use geth as a JavaScript console to interact with
  prefs: []
  type: TYPE_NORMAL
- en: blockchains.
  prefs: []
  type: TYPE_NORMAL
- en: '*Task 3: Interact with geth RPC service*'
  prefs: []
  type: TYPE_NORMAL
- en: Once a geth node is set up with RPC service running, users can use
  prefs: []
  type: TYPE_NORMAL
- en: wallets, applications, or the JavaScript console to connect to the RPC
  prefs: []
  type: TYPE_NORMAL
- en: endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: '232'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 6 ethereum arChiteCture and Overview
  prefs: []
  type: TYPE_NORMAL
- en: A. Through MetaMask custom RPC connection
  prefs: []
  type: TYPE_NORMAL
- en: To connect to an RPC service from MetaMask, simply
  prefs: []
  type: TYPE_NORMAL
- en: open MetaMask, click to open the Network list, and
  prefs: []
  type: TYPE_NORMAL
- en: choose Custom RPC to open up a new network widget.
  prefs: []
  type: TYPE_NORMAL
- en: Specify a network name, and enter the RPC endpoint
  prefs: []
  type: TYPE_NORMAL
- en: and the chainId of the network. The chainId is an
  prefs: []
  type: TYPE_NORMAL
- en: identifier that is unique for all blockchains as specified
  prefs: []
  type: TYPE_NORMAL
- en: by Ethereum standard EIP-155\. If you are working on
  prefs: []
  type: TYPE_NORMAL
- en: building a development network, you can specify a
  prefs: []
  type: TYPE_NORMAL
- en: chainId in the genesis file. You can optionally specify
  prefs: []
  type: TYPE_NORMAL
- en: the currency symbol for the blockchain and a URL
  prefs: []
  type: TYPE_NORMAL
- en: for the block browser. Click Save to attach the new
  prefs: []
  type: TYPE_NORMAL
- en: RPC node.
  prefs: []
  type: TYPE_NORMAL
- en: Once MetaMask is attached to the RPC node specified
  prefs: []
  type: TYPE_NORMAL
- en: earlier, it will interact with the blockchain to which
  prefs: []
  type: TYPE_NORMAL
- en: the node is connected. You can use MetaMask to send
  prefs: []
  type: TYPE_NORMAL
- en: and receive transactions through the RPC node for a
  prefs: []
  type: TYPE_NORMAL
- en: development blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: B. Through JavaScript console
  prefs: []
  type: TYPE_NORMAL
- en: Geth can run not only as a blockchain node but also
  prefs: []
  type: TYPE_NORMAL
- en: as a client to attach to an RPC endpoint and involve a
  prefs: []
  type: TYPE_NORMAL
- en: command-line console to provide interactive scripting
  prefs: []
  type: TYPE_NORMAL
- en: to the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: To attach to an RPC node and open up a JavaScript
  prefs: []
  type: TYPE_NORMAL
- en: console, simply type
  prefs: []
  type: TYPE_NORMAL
- en: geth attach [rpc_url]
  prefs: []
  type: TYPE_NORMAL
- en: '233'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 6 ethereum arChiteCture and Overview
  prefs: []
  type: TYPE_NORMAL
- en: Here, rpc_url is the RPC endpoint for an Ethereum
  prefs: []
  type: TYPE_NORMAL
- en: client node with RPC service enabled.
  prefs: []
  type: TYPE_NORMAL
- en: The JavaScript console will allow users to query block
  prefs: []
  type: TYPE_NORMAL
- en: information, balances, transactions, blockchain
  prefs: []
  type: TYPE_NORMAL
- en: syncing status, event logs, etc. For JavaScript console
  prefs: []
  type: TYPE_NORMAL
- en: syntax, refer to the following document.
  prefs: []
  type: TYPE_NORMAL
- en: '[https://geth.ethereum.org/docs/interface/](https://geth.ethereum.org/docs/interface/javascript-console)'
  prefs: []
  type: TYPE_NORMAL
- en: '[javascript- console](https://geth.ethereum.org/docs/interface/javascript-console),
    Console syntax'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://web3js.readthedocs.io/en/v1.2.9/,](https://web3js.readthedocs.io/en/v1.2.9/)'
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum JavaScript API
  prefs: []
  type: TYPE_NORMAL
- en: C. Through a third-party application such as Truffle
  prefs: []
  type: TYPE_NORMAL
- en: or Remix
  prefs: []
  type: TYPE_NORMAL
- en: Third-party applications will attach to an RPC endpoint
  prefs: []
  type: TYPE_NORMAL
- en: to interact with Ethereum blockchains. Smart contract
  prefs: []
  type: TYPE_NORMAL
- en: compiling tools such as Truffle and Remix all have
  prefs: []
  type: TYPE_NORMAL
- en: features to connect to an RPC server. Once an RPC
  prefs: []
  type: TYPE_NORMAL
- en: endpoint is connected, the smart contract bytecode
  prefs: []
  type: TYPE_NORMAL
- en: files that are compiled will be sent to the attached
  prefs: []
  type: TYPE_NORMAL
- en: RPC server and then broadcasted to the rest of the
  prefs: []
  type: TYPE_NORMAL
- en: blockchain network.
  prefs: []
  type: TYPE_NORMAL
- en: Geth is the most popular Ethereum client adopted by the developer
  prefs: []
  type: TYPE_NORMAL
- en: community. Besides geth, there are other clients such as Java-based Besu
  prefs: []
  type: TYPE_NORMAL
- en: and quorum clients that can be used. Geth nodes can download the full
  prefs: []
  type: TYPE_NORMAL
- en: blockchain to local storage, so having a system with hundreds of gigabyte
  prefs: []
  type: TYPE_NORMAL
- en: storage is a requirement for running geth in full node mode.
  prefs: []
  type: TYPE_NORMAL
- en: '234'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 6 ethereum arChiteCture and Overview
  prefs: []
  type: TYPE_NORMAL
- en: '**Truffle: The Most Comprehensive Smart Contract**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Development Tool**'
  prefs: []
  type: TYPE_NORMAL
- en: Truffle is a smart contract development tool that allows users to compile,
  prefs: []
  type: TYPE_NORMAL
- en: test, debug, and deploy Solidity code. It is easy to try out Truffle in a
  prefs: []
  type: TYPE_NORMAL
- en: sandbox to get a good understanding about how to compile and deploy
  prefs: []
  type: TYPE_NORMAL
- en: smart contracts.
  prefs: []
  type: TYPE_NORMAL
- en: '*Task 1: Install Truffle package*'
  prefs: []
  type: TYPE_NORMAL
- en: The Truffle package can be downloaded and installed through node
  prefs: []
  type: TYPE_NORMAL
- en: 'package manager (npm):'
  prefs: []
  type: TYPE_NORMAL
- en: npm install -g truffle
  prefs: []
  type: TYPE_NORMAL
- en: Here, the flag g means to install it globally so that the Truffle
  prefs: []
  type: TYPE_NORMAL
- en: application can be launched from any directory.
  prefs: []
  type: TYPE_NORMAL
- en: '*Task 2: Prepare a project*'
  prefs: []
  type: TYPE_NORMAL
- en: Truffle has an init command that allows a developer to create a
  prefs: []
  type: TYPE_NORMAL
- en: sandbox project for smart contracts. Simply go to a target directory and run
  prefs: []
  type: TYPE_NORMAL
- en: 'the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: truffle init
  prefs: []
  type: TYPE_NORMAL
- en: A sample project will be created with sample smart contract and
  prefs: []
  type: TYPE_NORMAL
- en: configuration files.
  prefs: []
  type: TYPE_NORMAL
- en: You can also replace the sample smart contract with your own smart
  prefs: []
  type: TYPE_NORMAL
- en: contract and use a new configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: '*Task 3: Compile and deploy a smart contract*'
  prefs: []
  type: TYPE_NORMAL
- en: Before compiling or deploying a smart contract, the Truffle
  prefs: []
  type: TYPE_NORMAL
- en: configuration file will need to be configured. The Truffle tool uses the
  prefs: []
  type: TYPE_NORMAL
- en: default file name of truffle-config.js file to look for the configuration. This
  prefs: []
  type: TYPE_NORMAL
- en: configuration file has two major components to configure. The first is the
  prefs: []
  type: TYPE_NORMAL
- en: network component, where you need to specify which blockchain network
  prefs: []
  type: TYPE_NORMAL
- en: the compiled smart contract will be deployed onto. The configuration
  prefs: []
  type: TYPE_NORMAL
- en: '235'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 6 ethereum arChiteCture and Overview
  prefs: []
  type: TYPE_NORMAL
- en: for the network will include network name, host address for the RPC
  prefs: []
  type: TYPE_NORMAL
- en: endpoint, port number for the RPC endpoint, and network_id. The second
  prefs: []
  type: TYPE_NORMAL
- en: configuration component is the compiler. For compiler configuration, the
  prefs: []
  type: TYPE_NORMAL
- en: Solidity compiler version will need to be specified.
  prefs: []
  type: TYPE_NORMAL
- en: module.exports = {
  prefs: []
  type: TYPE_NORMAL
- en: 'networks: {'
  prefs: []
  type: TYPE_NORMAL
- en: 'development: {'
  prefs: []
  type: TYPE_NORMAL
- en: 'host: "127.0.0.1",'
  prefs: []
  type: TYPE_NORMAL
- en: 'port: 8545,'
  prefs: []
  type: TYPE_NORMAL
- en: 'network_id: "*" // Match any network id'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '},'
  prefs: []
  type: TYPE_NORMAL
- en: 'compilers: {'
  prefs: []
  type: TYPE_NORMAL
- en: 'solc: {'
  prefs: []
  type: TYPE_NORMAL
- en: 'version: "^0.8.0"'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: Once the project is ready for compilation, simply run
  prefs: []
  type: TYPE_NORMAL
- en: truffle compile
  prefs: []
  type: TYPE_NORMAL
- en: The compiled result will be stored in the directory of build. This
  prefs: []
  type: TYPE_NORMAL
- en: directory will contain the bytecode and ABI (Application Bytecode
  prefs: []
  type: TYPE_NORMAL
- en: Interface) files. Smart contract bytecodes are the executable codes that will
  prefs: []
  type: TYPE_NORMAL
- en: be deployed to the blockchain. The ABI code is used as a function lookup
  prefs: []
  type: TYPE_NORMAL
- en: map for external applications to call the smart contract.
  prefs: []
  type: TYPE_NORMAL
- en: To deploy a compiled smart contract from Truffle, simply type
  prefs: []
  type: TYPE_NORMAL
- en: truffle deploy
  prefs: []
  type: TYPE_NORMAL
- en: '236'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 6 ethereum arChiteCture and Overview
  prefs: []
  type: TYPE_NORMAL
- en: This command will invoke deployment operation using the truffle-
  prefs: []
  type: TYPE_NORMAL
- en: config.js file. It will deploy the smart contract to the network by using the
  prefs: []
  type: TYPE_NORMAL
- en: RPC client service specified in the network section of the configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: There is one more thing that needs to be emphasized. When deploying
  prefs: []
  type: TYPE_NORMAL
- en: a smart contract, the developer needs to have a wallet to send the
  prefs: []
  type: TYPE_NORMAL
- en: deployment transaction to the blockchain. For development blockchains,
  prefs: []
  type: TYPE_NORMAL
- en: because this is internal and there are no security concerns, a user can
  prefs: []
  type: TYPE_NORMAL
- en: simply add a wallet address in the configuration file. For production
  prefs: []
  type: TYPE_NORMAL
- en: deployment, strict production security procedures will need to be
  prefs: []
  type: TYPE_NORMAL
- en: followed, including using a hardware wallet or signing offline transactions.
  prefs: []
  type: TYPE_NORMAL
- en: '*Task 4: Use the Truffle console* *to interact with blockchains*'
  prefs: []
  type: TYPE_NORMAL
- en: Truffle provides a console command to interact with the attached
  prefs: []
  type: TYPE_NORMAL
- en: blockchain node. There are two types of consoles available. One is a
  prefs: []
  type: TYPE_NORMAL
- en: console that is connected to a testnet or mainnet blockchain. This console
  prefs: []
  type: TYPE_NORMAL
- en: 'is launched through the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: truffle console
  prefs: []
  type: TYPE_NORMAL
- en: Another console is connected to a development blockchain. This
  prefs: []
  type: TYPE_NORMAL
- en: 'console is launched through the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: truffle develop
  prefs: []
  type: TYPE_NORMAL
- en: The major difference between a regular console and a development
  prefs: []
  type: TYPE_NORMAL
- en: console is that a regular console connects to an existing blockchain,
  prefs: []
  type: TYPE_NORMAL
- en: while a development console creates an embedded blockchain, default
  prefs: []
  type: TYPE_NORMAL
- en: accounts, and issued tokens for use by the developers.
  prefs: []
  type: TYPE_NORMAL
- en: '237'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 6 ethereum arChiteCture and Overview
  prefs: []
  type: TYPE_NORMAL
- en: Once a Truffle console is launched, developers can use it to query
  prefs: []
  type: TYPE_NORMAL
- en: blockchain information, send and receive tokens, and call smart contract
  prefs: []
  type: TYPE_NORMAL
- en: functions. To call a smart contract function, the following steps are
  prefs: []
  type: TYPE_NORMAL
- en: 'followed:'
  prefs: []
  type: TYPE_NORMAL
- en: • From the console, instantiate a smart contract object
  prefs: []
  type: TYPE_NORMAL
- en: from its address and corresponding ABI.
  prefs: []
  type: TYPE_NORMAL
- en: • Get an account from the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: • Call the instance smart contract function with a sender
  prefs: []
  type: TYPE_NORMAL
- en: account and other parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The full example can be referenced at the following location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.trufflesuite.com/docs/truffle/getting- started/interacting-](https://www.trufflesuite.com/docs/truffle/getting-started/interacting-with-your-contracts)'
  prefs: []
  type: TYPE_NORMAL
- en: '[with- your- contracts](https://www.trufflesuite.com/docs/truffle/getting-started/interacting-with-your-contracts)'
  prefs: []
  type: TYPE_NORMAL
- en: Truffle is a very comprehensive and complex system. This section only
  prefs: []
  type: TYPE_NORMAL
- en: mentions the features needed for compiling, deploying, and testing smart
  prefs: []
  type: TYPE_NORMAL
- en: 'contracts. For details, refer to the Truffle office website:'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.trufflesuite.com/docs/truffle/quickstart](http://www.trufflesuite.com/docs/truffle/quickstart)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Remix: The Most Convenient Web-Based Smart**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Contract Development Tool**'
  prefs: []
  type: TYPE_NORMAL
- en: Remix is a web-based smart contract programming suite that is very easy
  prefs: []
  type: TYPE_NORMAL
- en: to use. Remix can run as a browser web page or as a desktop application.
  prefs: []
  type: TYPE_NORMAL
- en: To use Remix on a browser, simply open the Chrome or Firefox browser
  prefs: []
  type: TYPE_NORMAL
- en: 'and point to the following location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://remix.ethereum.org](https://remix.ethereum.org)'
  prefs: []
  type: TYPE_NORMAL
- en: '238'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-250_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 6 ethereum arChiteCture and Overview
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 6-6\.** Remix compiler*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four sections in the IDE: the icon panel on the left, the side'
  prefs: []
  type: TYPE_NORMAL
- en: panel in the middle, the main panel on the top right, and the terminal on
  prefs: []
  type: TYPE_NORMAL
- en: the bottom left as shown in Figur[e 6-6\.](#p250)
  prefs: []
  type: TYPE_NORMAL
- en: '**Icon panel** – Shows the file explorer, remix plug-ins,'
  prefs: []
  type: TYPE_NORMAL
- en: plug-in manager, and general setup icon.
  prefs: []
  type: TYPE_NORMAL
- en: '**Side panel** – Shows source code files and GUI for'
  prefs: []
  type: TYPE_NORMAL
- en: each plug-in when selected.
  prefs: []
  type: TYPE_NORMAL
- en: '**Main panel** – Shows the source file content for'
  prefs: []
  type: TYPE_NORMAL
- en: each smart contract. Source files can be edited in
  prefs: []
  type: TYPE_NORMAL
- en: this panel.
  prefs: []
  type: TYPE_NORMAL
- en: '**Terminal** – Shows the result of compilation,'
  prefs: []
  type: TYPE_NORMAL
- en: deployment, and interaction with the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: Can also run scripts on this panel.
  prefs: []
  type: TYPE_NORMAL
- en: '239'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 6 ethereum arChiteCture and Overview
  prefs: []
  type: TYPE_NORMAL
- en: For the remix web console, you can easily experiment with the
  prefs: []
  type: TYPE_NORMAL
- en: 'following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Task 1: Set up and install plug-ins*'
  prefs: []
  type: TYPE_NORMAL
- en: The Remix IDE (integrated development environment) uses
  prefs: []
  type: TYPE_NORMAL
- en: component models to add basic features and third-party plug-ins to
  prefs: []
  type: TYPE_NORMAL
- en: the system. The icon panel by default activates and shows three basic
  prefs: []
  type: TYPE_NORMAL
- en: 'components: the file explorer, Solidity compilation, and deploy and run'
  prefs: []
  type: TYPE_NORMAL
- en: transactions. These three components should be sufficient for quick smart
  prefs: []
  type: TYPE_NORMAL
- en: contract development. For other operations such as debugging, security
  prefs: []
  type: TYPE_NORMAL
- en: scan, and visualization, developers can click the Plugin Manager icon and
  prefs: []
  type: TYPE_NORMAL
- en: select the intended plug-in to activate.
  prefs: []
  type: TYPE_NORMAL
- en: Plug-ins can be activated or deactivated as needed by the developers.
  prefs: []
  type: TYPE_NORMAL
- en: The icon panel also contains a settings button that can launch a settings
  prefs: []
  type: TYPE_NORMAL
- en: page to configure the theme of the GUI, the source code editor, access to
  prefs: []
  type: TYPE_NORMAL
- en: GitHub, etc. Once plug-ins are activated, developers can click each plug-
  prefs: []
  type: TYPE_NORMAL
- en: in icon, and the side panel will show the interface and GUI details of the
  prefs: []
  type: TYPE_NORMAL
- en: corresponding plug-in.
  prefs: []
  type: TYPE_NORMAL
- en: '*Task 2: Browse, edit, and compile a smart contract*'
  prefs: []
  type: TYPE_NORMAL
- en: The Remix packages some sample smart contracts in the web server.
  prefs: []
  type: TYPE_NORMAL
- en: Click the File Explorer icon to open up the smart contract browsing
  prefs: []
  type: TYPE_NORMAL
- en: panel. The source file of the smart contracts can be created as a new file
  prefs: []
  type: TYPE_NORMAL
- en: or imported from repositories such as Gist, GitHub, Swarm, IPFS, or an
  prefs: []
  type: TYPE_NORMAL
- en: HTTPS URL. One thing to note is that if a source file is imported from
  prefs: []
  type: TYPE_NORMAL
- en: an external repository, the modified file will not be written back to the
  prefs: []
  type: TYPE_NORMAL
- en: repository, and some manual operations are needed. For example, a
  prefs: []
  type: TYPE_NORMAL
- en: workspace can be published as a gist in a GitHub repository. For other
  prefs: []
  type: TYPE_NORMAL
- en: repositories such as IPFS, HTTPS, and Swarm, manual uploads outside
  prefs: []
  type: TYPE_NORMAL
- en: Remix are needed.
  prefs: []
  type: TYPE_NORMAL
- en: '240'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 6 ethereum arChiteCture and Overview
  prefs: []
  type: TYPE_NORMAL
- en: To compile a smart contract, first, browse the source files and click
  prefs: []
  type: TYPE_NORMAL
- en: the file you want to edit. The file content will be shown on the main panel.
  prefs: []
  type: TYPE_NORMAL
- en: Developers can then simply modify the source code using the embedded
  prefs: []
  type: TYPE_NORMAL
- en: editor. Once files are edited, click the Solidity Compiler button. This
  prefs: []
  type: TYPE_NORMAL
- en: will launch a compiler GUI in the side panel. After selecting the Solidity
  prefs: []
  type: TYPE_NORMAL
- en: compiler version and EVM to use, developers can click the Compile button
  prefs: []
  type: TYPE_NORMAL
- en: to start compilation. Any compilation errors will be shown on the compiler
  prefs: []
  type: TYPE_NORMAL
- en: panel, and developers will be prompted to modify the source code to fix
  prefs: []
  type: TYPE_NORMAL
- en: the error. Once a smart contract compiles successfully, bytecodes and ABI
  prefs: []
  type: TYPE_NORMAL
- en: files will be generated.
  prefs: []
  type: TYPE_NORMAL
- en: One thing to note is that the modified source code is stored in the
  prefs: []
  type: TYPE_NORMAL
- en: browser only, and additional steps need to be taken to save it to permanent
  prefs: []
  type: TYPE_NORMAL
- en: storage. This can be done by downloading the file to local storage, or
  prefs: []
  type: TYPE_NORMAL
- en: publishing the file to a new gist in GitHub storage. Since the Remix browser
  prefs: []
  type: TYPE_NORMAL
- en: does not have persistent storage, files that are edited but not downloaded
  prefs: []
  type: TYPE_NORMAL
- en: or published will be erased if the browser data is cleared. To synchronize
  prefs: []
  type: TYPE_NORMAL
- en: the Remix browser with persistent storage, the Remix web page will need
  prefs: []
  type: TYPE_NORMAL
- en: to be connected to local storage. This is done by running a remixd in the
  prefs: []
  type: TYPE_NORMAL
- en: background that provides shared persistent storage for Remix.
  prefs: []
  type: TYPE_NORMAL
- en: '*Task 3: Deploy a smart contract and execute functions*'
  prefs: []
  type: TYPE_NORMAL
- en: Once a smart contract is compiled successfully, developers can use
  prefs: []
  type: TYPE_NORMAL
- en: the “*deploy and run transactions*” plug-in to deploy smart contracts and
  prefs: []
  type: TYPE_NORMAL
- en: run transactions. After clicking the Deploy and Run transactions icon, a
  prefs: []
  type: TYPE_NORMAL
- en: deployment GUI will prompt developers to choose a network connection
  prefs: []
  type: TYPE_NORMAL
- en: environment, deployment account, smart contract to deploy, gas fee, etc.,
  prefs: []
  type: TYPE_NORMAL
- en: as shown in Figur[e 6-7\.](#p253)
  prefs: []
  type: TYPE_NORMAL
- en: '241'
  prefs: []
  type: TYPE_NORMAL
- en: '![](index-253_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 6 ethereum arChiteCture and Overview
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 6-7\.** Remix compiler widget*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three kinds of deployment environments: JavaScript VM,'
  prefs: []
  type: TYPE_NORMAL
- en: injected Web3, and Web3 provider. The JavaScript VM is an environment
  prefs: []
  type: TYPE_NORMAL
- en: where the EVM is embedded within the Remix web page and is a
  prefs: []
  type: TYPE_NORMAL
- en: simulated use case where no blockchain is actually connected. This is
  prefs: []
  type: TYPE_NORMAL
- en: the easiest case for deploying and testing a smart contract. The injected
  prefs: []
  type: TYPE_NORMAL
- en: Web3 environment uses the MetaMask extension to connect Remix with
  prefs: []
  type: TYPE_NORMAL
- en: an external blockchain through MetaMask configurations. Instead of using
  prefs: []
  type: TYPE_NORMAL
- en: '242'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 6 ethereum arChiteCture and Overview
  prefs: []
  type: TYPE_NORMAL
- en: Remix, the MetaMask is used to connect to the blockchain and serves as a
  prefs: []
  type: TYPE_NORMAL
- en: proxy to deploy the smart contract to the intended blockchain. The “Web3
  prefs: []
  type: TYPE_NORMAL
- en: provider” environment connects Remix with an RPC endpoint and deploys
  prefs: []
  type: TYPE_NORMAL
- en: the smart contract to that RPC server and then broadcasts to the rest of the
  prefs: []
  type: TYPE_NORMAL
- en: network.
  prefs: []
  type: TYPE_NORMAL
- en: Besides choosing a blockchain network environment, developers also
  prefs: []
  type: TYPE_NORMAL
- en: need to specify an account for sending the deployment transactions. This
  prefs: []
  type: TYPE_NORMAL
- en: account should have some Ether to pay for the gas fee for the deployment.
  prefs: []
  type: TYPE_NORMAL
- en: This account will also become the owner of the smart contract. There are
  prefs: []
  type: TYPE_NORMAL
- en: other miscellaneous parameters to configure. “Gas limit” specifies the
  prefs: []
  type: TYPE_NORMAL
- en: maximum amount of gas that the transaction can consume. “Value” is
  prefs: []
  type: TYPE_NORMAL
- en: the token to be sent to a target address. For smart contract deployment,
  prefs: []
  type: TYPE_NORMAL
- en: the “Value” is irrelevant and should be set to zero. Once all parameters
  prefs: []
  type: TYPE_NORMAL
- en: are set correctly, click the “Deploy” button to send out the deployment
  prefs: []
  type: TYPE_NORMAL
- en: transaction. Some smart contracts might have constructors that take input
  prefs: []
  type: TYPE_NORMAL
- en: parameters. In that case, the input parameters need to be specified in the
  prefs: []
  type: TYPE_NORMAL
- en: input field beside the Deploy button.
  prefs: []
  type: TYPE_NORMAL
- en: Once a smart contract is deployed successfully, it will return an
  prefs: []
  type: TYPE_NORMAL
- en: address that is called the smart contract address. Developers can browse
  prefs: []
  type: TYPE_NORMAL
- en: the blockchain by clicking the address shown at the bottom of the
  prefs: []
  type: TYPE_NORMAL
- en: deployment GUI. The deployment smart contract will then show variable
  prefs: []
  type: TYPE_NORMAL
- en: names and values, functions, and other internal storage information.
  prefs: []
  type: TYPE_NORMAL
- en: Developers can then input parameters into a function and execute the
  prefs: []
  type: TYPE_NORMAL
- en: function. When calling a smart contract function, the developer is actually
  prefs: []
  type: TYPE_NORMAL
- en: sending a transaction; therefore, there should be an account to pay for the
  prefs: []
  type: TYPE_NORMAL
- en: transaction, and the transaction parameters should be specified as well.
  prefs: []
  type: TYPE_NORMAL
- en: The execution results will be shown in the same panel, and some output
  prefs: []
  type: TYPE_NORMAL
- en: will be shown in the terminal panel.
  prefs: []
  type: TYPE_NORMAL
- en: '243'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 6 ethereum arChiteCture and Overview
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Three topics are mentioned in this chapter: overview of the Ethereum'
  prefs: []
  type: TYPE_NORMAL
- en: blockchain, ecosystem and dApps, and essential tools for smart
  prefs: []
  type: TYPE_NORMAL
- en: contract developments. In the next chapter, the Solidity programming
  prefs: []
  type: TYPE_NORMAL
- en: and deployment technology will be covered to teach how to build
  prefs: []
  type: TYPE_NORMAL
- en: decentralized applications with smart contracts.
  prefs: []
  type: TYPE_NORMAL
- en: '244'
  prefs: []
  type: TYPE_NORMAL
- en: '**CHAPTER 7**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Programming Smart**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Contract with Solidity**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Introduction: What We Learned**'
  prefs: []
  type: TYPE_NORMAL
- en: '**in the Last Chapter**'
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, we discussed Ethereum architecture, ecosystem,
  prefs: []
  type: TYPE_NORMAL
- en: and decentralized applications. We also described development tools
  prefs: []
  type: TYPE_NORMAL
- en: such as MetaMask, Remix, Truffle, and Geth. In this chapter, we are going
  prefs: []
  type: TYPE_NORMAL
- en: to learn detailed Solidity programming skills for smart contract and
  prefs: []
  type: TYPE_NORMAL
- en: decentralized application development.
  prefs: []
  type: TYPE_NORMAL
- en: '**What Is Smart Contract**'
  prefs: []
  type: TYPE_NORMAL
- en: Smart contract is an overloaded phrase. Although there are different
  prefs: []
  type: TYPE_NORMAL
- en: 'interpretations for smart contract, we define it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: “A smart contract is an executable computer program that runs on
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum Virtual Machine (EVM) on the blockchain to access and alter
  prefs: []
  type: TYPE_NORMAL
- en: the states of blockchain blocks.” Different from conventional computer
  prefs: []
  type: TYPE_NORMAL
- en: programs that normally run on one single system, smart contracts run on
  prefs: []
  type: TYPE_NORMAL
- en: every node of the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: © Weijia Zhang and Tej Anand 2022
  prefs: []
  type: TYPE_NORMAL
- en: '245'
  prefs: []
  type: TYPE_NORMAL
- en: W. Zhang and T. Anand, *Blockchain and Ethereum Smart Contract Solution Development*,
  prefs: []
  type: TYPE_NORMAL
- en: '[https://doi.org/10.1007/978-1-4842-8164-2_7](https://doi.org/10.1007/978-1-4842-8164-2_7#DOI)'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 7 programming Smart ContraCt with Solidity
  prefs: []
  type: TYPE_NORMAL
- en: For Ethereum, smart contracts are compiled as executable bytecode
  prefs: []
  type: TYPE_NORMAL
- en: and deployed to Ethereum blockchain. The bytecodes of a smart contract
  prefs: []
  type: TYPE_NORMAL
- en: are sent through the data field of a transaction. Once the transaction is
  prefs: []
  type: TYPE_NORMAL
- en: included in a block, a smart contract address is generated, and the bytecode
  prefs: []
  type: TYPE_NORMAL
- en: is stored in that address. To call a function in a smart contract, a transaction
  prefs: []
  type: TYPE_NORMAL
- en: is sent to the smart contract address, and the function name and input data
  prefs: []
  type: TYPE_NORMAL
- en: are supplied through the data field of the transaction. When a transaction to
  prefs: []
  type: TYPE_NORMAL
- en: call a smart contract is sent to a node, the Ethereum Virtual Machine loads
  prefs: []
  type: TYPE_NORMAL
- en: the bytecode from the smart contract address and executes the function.
  prefs: []
  type: TYPE_NORMAL
- en: For a business person, a smart contract defines business attributes
  prefs: []
  type: TYPE_NORMAL
- en: and processing logic to let multiple parties to execute and witness the
  prefs: []
  type: TYPE_NORMAL
- en: processing of the business logic to ensure transparency, reliability, fault
  prefs: []
  type: TYPE_NORMAL
- en: tolerance, immutability, and integrity for all parties (when the smart
  prefs: []
  type: TYPE_NORMAL
- en: contract is well written).
  prefs: []
  type: TYPE_NORMAL
- en: Smart contracts differ from stand-alone computer programs because
  prefs: []
  type: TYPE_NORMAL
- en: they are on all the machines and all parties have access to the smart
  prefs: []
  type: TYPE_NORMAL
- en: contract to take advantage of transparency, reliability, and other benefits
  prefs: []
  type: TYPE_NORMAL
- en: of blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: But this is only the case where the smart contract is well written. If a
  prefs: []
  type: TYPE_NORMAL
- en: smart contract is poorly written, then all these benefits go away.
  prefs: []
  type: TYPE_NORMAL
- en: For a technical person, a smart contract is a computer program that
  prefs: []
  type: TYPE_NORMAL
- en: can be coded, compiled, tested, deployed, and executed on a blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: From technical point of view, the phrase “smart contract” can mean
  prefs: []
  type: TYPE_NORMAL
- en: several things.
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, it can mean smart contract source code. Secondly, it can mean
  prefs: []
  type: TYPE_NORMAL
- en: a compiled bytecode of a smart contract. Thirdly, it can mean a deployed
  prefs: []
  type: TYPE_NORMAL
- en: smart contract residing on a blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a smart contract is compiled, two files are generated: a bytecode'
  prefs: []
  type: TYPE_NORMAL
- en: file and an ABI (Application Bytecode Interface). The bytecode of a smart
  prefs: []
  type: TYPE_NORMAL
- en: contract can be deployed to Ethereum blockchain and can be executed
  prefs: []
  type: TYPE_NORMAL
- en: by the Ethereum Virtual Machine. The ABI code is a definition and
  prefs: []
  type: TYPE_NORMAL
- en: description of smart contract rather than executable code. The ABI file is
  prefs: []
  type: TYPE_NORMAL
- en: '246'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 7 programming Smart ContraCt with Solidity
  prefs: []
  type: TYPE_NORMAL
- en: used by third-party applications to parse what functions are defined in a
  prefs: []
  type: TYPE_NORMAL
- en: deployed smart contract and how to interact with them.
  prefs: []
  type: TYPE_NORMAL
- en: When a smart contract is “deployed” to a blockchain, a smart contract
  prefs: []
  type: TYPE_NORMAL
- en: address is generated by calculating the Keccak-256 hash of the sender
  prefs: []
  type: TYPE_NORMAL
- en: address and transaction nonce encoded with recursive-length prefix (RLP)
  prefs: []
  type: TYPE_NORMAL
- en: serialization. A smart contract can also be deployed to different
  prefs: []
  type: TYPE_NORMAL
- en: blockchains such as testnet or mainnet. The same smart contract address
  prefs: []
  type: TYPE_NORMAL
- en: may refer to different blockchains.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to know that “smart contracts” are used in different
  prefs: []
  type: TYPE_NORMAL
- en: scenarios and contexts. In the following sections, we go into detail of smart
  prefs: []
  type: TYPE_NORMAL
- en: contract programming.
  prefs: []
  type: TYPE_NORMAL
- en: '**What Is Solidity Programming Language**'
  prefs: []
  type: TYPE_NORMAL
- en: Solidity is the most popular programming language for Ethereum smart
  prefs: []
  type: TYPE_NORMAL
- en: contracts. Solidity source code can be edited with a simple text editor or
  prefs: []
  type: TYPE_NORMAL
- en: through IDE such as Remix or Microsoft Visual Studio. In order for Solidity
  prefs: []
  type: TYPE_NORMAL
- en: code to run on Ethereum node, several things need to be done.
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, the source code needs to be compiled into bytecode that can
  prefs: []
  type: TYPE_NORMAL
- en: be interpreted and executed by the Ethereum Virtual Machine (EVM).
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, you need to deploy the smart contract bytecode to a blockchain
  prefs: []
  type: TYPE_NORMAL
- en: or an EVM emulator for executions.
  prefs: []
  type: TYPE_NORMAL
- en: A bytecode is a program that can be executed by the Ethereum Virtual
  prefs: []
  type: TYPE_NORMAL
- en: Machine. A bytecode program contains operands, data, and storage for
  prefs: []
  type: TYPE_NORMAL
- en: each step. The EVM engine interprets instructions for each step and
  prefs: []
  type: TYPE_NORMAL
- en: executes the instructions.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned in Chapter [6, R](https://doi.org/10.1007/978-1-4842-8164-2_6)emix
    is a web-based integrated development environment (IDE), so developers can write
    code on the web
  prefs: []
  type: TYPE_NORMAL
- en: page specified by the URL of remix.ethereum.org. This is very convenient
  prefs: []
  type: TYPE_NORMAL
- en: for practicing smart contracting writing, compilation, and testing. The
  prefs: []
  type: TYPE_NORMAL
- en: introduction of Remix has been mentioned in Chapter [6\. T](https://doi.org/10.1007/978-1-4842-8164-2_6)his
    section will be focused on writing the Solidity programs.
  prefs: []
  type: TYPE_NORMAL
- en: '247'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 7 programming Smart ContraCt with Solidity
  prefs: []
  type: TYPE_NORMAL
- en: '**Module 1: Hello World Solidity Example**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take the first example, HelloWorld.sol, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: /**
  prefs: []
  type: TYPE_NORMAL
- en: '* *SPDX-License-Identifier: MIT*'
  prefs: []
  type: TYPE_NORMAL
- en: '* *@title HelloWorld*'
  prefs: []
  type: TYPE_NORMAL
- en: '* *@dev Implements the hello world program*'
  prefs: []
  type: TYPE_NORMAL
- en: '*/'
  prefs: []
  type: TYPE_NORMAL
- en: '*pragma solidity >=0.7.0 <0.9.0;*'
  prefs: []
  type: TYPE_NORMAL
- en: '*contract HelloWorld {*'
  prefs: []
  type: TYPE_NORMAL
- en: '*string helloworld = "Hello World";*'
  prefs: []
  type: TYPE_NORMAL
- en: '*function justHelloWorld() public view returns(string*'
  prefs: []
  type: TYPE_NORMAL
- en: '*memory) {*'
  prefs: []
  type: TYPE_NORMAL
- en: '*return helloworld;*'
  prefs: []
  type: TYPE_NORMAL
- en: '*}*'
  prefs: []
  type: TYPE_NORMAL
- en: '*function showHelloWorld(string memory me) public view*'
  prefs: []
  type: TYPE_NORMAL
- en: '*returns(string memory) {*'
  prefs: []
  type: TYPE_NORMAL
- en: '*string memory result = string(abi.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*encodePacked(helloworld, " from ", me));*'
  prefs: []
  type: TYPE_NORMAL
- en: '*return result;*'
  prefs: []
  type: TYPE_NORMAL
- en: '*}*'
  prefs: []
  type: TYPE_NORMAL
- en: '*}*'
  prefs: []
  type: TYPE_NORMAL
- en: In this example of helloworld.sol, it starts with comments that
  prefs: []
  type: TYPE_NORMAL
- en: describe what the smart contract is about and then a HelloWorld smart
  prefs: []
  type: TYPE_NORMAL
- en: contract where two functions are implemented. The first function,
  prefs: []
  type: TYPE_NORMAL
- en: justHelloWorld(), simply outputs a string “HelloWorld”, and the
  prefs: []
  type: TYPE_NORMAL
- en: second function takes an input variable named “me” and then outputs
  prefs: []
  type: TYPE_NORMAL
- en: “HelloWorld from [me]”. This simple smart contract can be compiled,
  prefs: []
  type: TYPE_NORMAL
- en: deployed, and executed on the blockchain. In the following, we describe
  prefs: []
  type: TYPE_NORMAL
- en: the syntax of a smart contract Solidity code.
  prefs: []
  type: TYPE_NORMAL
- en: '248'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 7 programming Smart ContraCt with Solidity
  prefs: []
  type: TYPE_NORMAL
- en: '**Solidity Comments**'
  prefs: []
  type: TYPE_NORMAL
- en: Comments are used extensively in Solidity to ensure that the smart
  prefs: []
  type: TYPE_NORMAL
- en: contracts can be clearly understood by both programmers and third party
  prefs: []
  type: TYPE_NORMAL
- en: users who need to use and trust the smart contracts. There are two kinds of
  prefs: []
  type: TYPE_NORMAL
- en: comments that are supported with Solidity.
  prefs: []
  type: TYPE_NORMAL
- en: First is the double-forward slash “//” that is used to comment a whole
  prefs: []
  type: TYPE_NORMAL
- en: line or a rear portion of a line as shown below.
  prefs: []
  type: TYPE_NORMAL
- en: //This is to comment a whole line
  prefs: []
  type: TYPE_NORMAL
- en: return “Hello World”; //This is to comment a portion of a line
  prefs: []
  type: TYPE_NORMAL
- en: Second syntax is to enclose the text with “/*” and “*/” to comment out
  prefs: []
  type: TYPE_NORMAL
- en: the whole paragraph. To improve readability, each line in the commented
  prefs: []
  type: TYPE_NORMAL
- en: paragraph might start with “**”.
  prefs: []
  type: TYPE_NORMAL
- en: /**
  prefs: []
  type: TYPE_NORMAL
- en: '** The HelloWorld program demonstrates a simple smart contract'
  prefs: []
  type: TYPE_NORMAL
- en: to return a "Hello World" string when a HelloWorld function
  prefs: []
  type: TYPE_NORMAL
- en: is called.
  prefs: []
  type: TYPE_NORMAL
- en: '** This program is an open source program that can be copied or'
  prefs: []
  type: TYPE_NORMAL
- en: modified without permission.
  prefs: []
  type: TYPE_NORMAL
- en: '**/'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solidity Program and Version Declaration**'
  prefs: []
  type: TYPE_NORMAL
- en: Solidity source code starts with the “pragma” compiler directive followed
  prefs: []
  type: TYPE_NORMAL
- en: by “solidity” and then a version specification. A compiler directive is an
  prefs: []
  type: TYPE_NORMAL
- en: instruction for the compiler to parse and perform certain operations. The
  prefs: []
  type: TYPE_NORMAL
- en: keyword “pragma solidity” instructs the compiler to treat the source code
  prefs: []
  type: TYPE_NORMAL
- en: as a “Solidity” programming language.
  prefs: []
  type: TYPE_NORMAL
- en: '249'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 7 programming Smart ContraCt with Solidity
  prefs: []
  type: TYPE_NORMAL
- en: '// pragma: Tells compiler about the programming language and'
  prefs: []
  type: TYPE_NORMAL
- en: compiler version
  prefs: []
  type: TYPE_NORMAL
- en: pragma solidity ^0.5.2;
  prefs: []
  type: TYPE_NORMAL
- en: // specify an exact major version
  prefs: []
  type: TYPE_NORMAL
- en: pragma solidity >0.5.2;
  prefs: []
  type: TYPE_NORMAL
- en: // specify a newer version
  prefs: []
  type: TYPE_NORMAL
- en: pragma solidity >0.5.2, <0.6.2; // specify a range
  prefs: []
  type: TYPE_NORMAL
- en: Solidity programming language version has the syntax of x.y.z format
  prefs: []
  type: TYPE_NORMAL
- en: such as 0.8.10\. Here, x,y,z are numbers that can include 0\. x is the major
  prefs: []
  type: TYPE_NORMAL
- en: version number, y is the minor version number, and z is the patch number.
  prefs: []
  type: TYPE_NORMAL
- en: For convenience, since x in Solidity has been “0” for a long time, “y” is
  prefs: []
  type: TYPE_NORMAL
- en: referred to as “major version”, and “z” is referred to as minor version.
  prefs: []
  type: TYPE_NORMAL
- en: Solidity language version section can have several forms such as the
  prefs: []
  type: TYPE_NORMAL
- en: 'following:'
  prefs: []
  type: TYPE_NORMAL
- en: ~0.5.0 // This means an exact match of the Solidity.
  prefs: []
  type: TYPE_NORMAL
- en: ^0.5.0 // This means a major version match. This
  prefs: []
  type: TYPE_NORMAL
- en: version works with any 0.5.z but not 0.4.z or 0.6.z.
  prefs: []
  type: TYPE_NORMAL
- en: '>0.5.2; // specify a newer version. This version'
  prefs: []
  type: TYPE_NORMAL
- en: works with any version that is newer than 0.5.2\.
  prefs: []
  type: TYPE_NORMAL
- en: '>=0.5.2, =<0.6.2; // specify a range of versions. Any'
  prefs: []
  type: TYPE_NORMAL
- en: version that is newer or equal to 0.5.2 but older or
  prefs: []
  type: TYPE_NORMAL
- en: equal to 0.6.2 can be selected.
  prefs: []
  type: TYPE_NORMAL
- en: Versioning in Solidity is very important because Solidity programs run
  prefs: []
  type: TYPE_NORMAL
- en: on blockchain and cannot be updated or patched to newer versions once
  prefs: []
  type: TYPE_NORMAL
- en: they are deployed.
  prefs: []
  type: TYPE_NORMAL
- en: For developers, there are several things that can go wrong with the
  prefs: []
  type: TYPE_NORMAL
- en: Solidity version. Because smart contracts cannot be upgraded or replaced,
  prefs: []
  type: TYPE_NORMAL
- en: it is very important to make sure the source code is written in its "best"
  prefs: []
  type: TYPE_NORMAL
- en: version as shown below
  prefs: []
  type: TYPE_NORMAL
- en: 'Exact latest version: This is recommended option. However, although'
  prefs: []
  type: TYPE_NORMAL
- en: specifying the exact version number is recommended, there are cases
  prefs: []
  type: TYPE_NORMAL
- en: where flexibility is needed to address compatibility with other libraries.
  prefs: []
  type: TYPE_NORMAL
- en: '250'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 7 programming Smart ContraCt with Solidity
  prefs: []
  type: TYPE_NORMAL
- en: 'Exact older version: This is used when the code is not compatible with'
  prefs: []
  type: TYPE_NORMAL
- en: the latest compiler and it takes too much effort to port it to the latest compiler.
  prefs: []
  type: TYPE_NORMAL
- en: 'Support of major versions: This provides more flexibility, particularly'
  prefs: []
  type: TYPE_NORMAL
- en: when the code is limited in scope and can be used as a library for various
  prefs: []
  type: TYPE_NORMAL
- en: versions of smart contracts.
  prefs: []
  type: TYPE_NORMAL
- en: 'A range of versions: This is used when the code itself contains libraries'
  prefs: []
  type: TYPE_NORMAL
- en: of various versions and the smart contract is not mission critical.
  prefs: []
  type: TYPE_NORMAL
- en: It is very important to keep in mind that Solidity programming
  prefs: []
  type: TYPE_NORMAL
- en: is progressing and the syntaxes are changing with different versions.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, a developer may have a source code working with version 0.5
  prefs: []
  type: TYPE_NORMAL
- en: but fail to compile with version 0.8\. Therefore, it is a good practice to pay
  prefs: []
  type: TYPE_NORMAL
- en: attention to version compatibility with Solidity source code or library.
  prefs: []
  type: TYPE_NORMAL
- en: '**Import a Solidity File**'
  prefs: []
  type: TYPE_NORMAL
- en: Right after Solidity and version declaration, there is normally an import
  prefs: []
  type: TYPE_NORMAL
- en: statement where an external Solidity file is pulled into the source code.
  prefs: []
  type: TYPE_NORMAL
- en: Solidity is an object orientation programming language and is very
  prefs: []
  type: TYPE_NORMAL
- en: modularized. Developers separate source codes into different files and
  prefs: []
  type: TYPE_NORMAL
- en: libraries and import the needed files to the main source code.
  prefs: []
  type: TYPE_NORMAL
- en: Many Solidity smart contracts are open source, and developers can
  prefs: []
  type: TYPE_NORMAL
- en: import the library directly from open source repositories. One of the
  prefs: []
  type: TYPE_NORMAL
- en: most popular open source smart contract libraries is from OpenZeppelin
  prefs: []
  type: TYPE_NORMAL
- en: ([https://github.com/OpenZeppelin/openzeppelin- contracts](https://github.com/OpenZeppelin/openzeppelin-contracts)).
    Code such as SafeMath, ERC20, ERC721, ownership, and oracles can be reused
  prefs: []
  type: TYPE_NORMAL
- en: from OpenZeppelin.
  prefs: []
  type: TYPE_NORMAL
- en: '251'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 7 programming Smart ContraCt with Solidity
  prefs: []
  type: TYPE_NORMAL
- en: 'To import another source file, simply use the following formats:'
  prefs: []
  type: TYPE_NORMAL
- en: '**import filename** – This will import a file from the'
  prefs: []
  type: TYPE_NORMAL
- en: local directory.
  prefs: []
  type: TYPE_NORMAL
- en: '**import full_filename_with_path** – This will import'
  prefs: []
  type: TYPE_NORMAL
- en: a file specified with an absolute path.
  prefs: []
  type: TYPE_NORMAL
- en: '**import github_location** – This syntax will import a'
  prefs: []
  type: TYPE_NORMAL
- en: file from a GitHub location.
  prefs: []
  type: TYPE_NORMAL
- en: You can also import the file and give it a simple name to refer to such
  prefs: []
  type: TYPE_NORMAL
- en: 'as following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'import filename as XYZ: Here, XYZ can be used to refer to the specific'
  prefs: []
  type: TYPE_NORMAL
- en: smart contract imported.
  prefs: []
  type: TYPE_NORMAL
- en: '**Constructor Function**'
  prefs: []
  type: TYPE_NORMAL
- en: A constructor is a special function that is executed during the deployment
  prefs: []
  type: TYPE_NORMAL
- en: of a smart contract. This is to define parameters that are assigned during
  prefs: []
  type: TYPE_NORMAL
- en: the deployment phase or to run an algorithm to dynamically set some
  prefs: []
  type: TYPE_NORMAL
- en: parameters based on the deployment environment.
  prefs: []
  type: TYPE_NORMAL
- en: '**Function Modifier**'
  prefs: []
  type: TYPE_NORMAL
- en: A function modifier is similar to a macro that is defined once and can be
  prefs: []
  type: TYPE_NORMAL
- en: used in multiple functions. For example, the following is a modifier that
  prefs: []
  type: TYPE_NORMAL
- en: checks if the sender of the transaction is the owner. If yes, the validation
    is
  prefs: []
  type: TYPE_NORMAL
- en: good, and if not, an exception is thrown. The “_” sign is the place where the
  prefs: []
  type: TYPE_NORMAL
- en: function code will be inserted and executed.
  prefs: []
  type: TYPE_NORMAL
- en: modifier onlyOwner {
  prefs: []
  type: TYPE_NORMAL
- en: require(msg.sender == owner);
  prefs: []
  type: TYPE_NORMAL
- en: _;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '252'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 7 programming Smart ContraCt with Solidity
  prefs: []
  type: TYPE_NORMAL
- en: function setMessage(string memory str) onlyOwner {
  prefs: []
  type: TYPE_NORMAL
- en: //Do_Something
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code, the setMessage function has a modifier to check
  prefs: []
  type: TYPE_NORMAL
- en: if the sender is the owner of the smart contract. If yes, the “Do_Something”
  prefs: []
  type: TYPE_NORMAL
- en: code will be executed in the “_” location right after the require statement.
  prefs: []
  type: TYPE_NORMAL
- en: The best use of modifiers is for simplifying redundant codes of
  prefs: []
  type: TYPE_NORMAL
- en: multiple functions in a smart contract. Once a modifier is defined, it can be
  prefs: []
  type: TYPE_NORMAL
- en: used anywhere.
  prefs: []
  type: TYPE_NORMAL
- en: '**Blockchain Access Scope: Pure/View/Payable**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Functions**'
  prefs: []
  type: TYPE_NORMAL
- en: There are multiple scopes and permissions to define a function. The scope
  prefs: []
  type: TYPE_NORMAL
- en: of a function describes the boundary of the function regarding whether the
  prefs: []
  type: TYPE_NORMAL
- en: data can be altered and what part of the data can be accessed.
  prefs: []
  type: TYPE_NORMAL
- en: If a function is defined as pure, it is a self-confined function.
  prefs: []
  type: TYPE_NORMAL
- en: The function variables are local, and the function will not access the
  prefs: []
  type: TYPE_NORMAL
- en: blockchain. It simply takes an input, processes it, and returns an output.
  prefs: []
  type: TYPE_NORMAL
- en: The "pure" functions do not have dependences on the blockchain states.
  prefs: []
  type: TYPE_NORMAL
- en: For the view function, the function may access the blockchain and get
  prefs: []
  type: TYPE_NORMAL
- en: some read-only data from the blockchain to carry out the computation.
  prefs: []
  type: TYPE_NORMAL
- en: The view function will not alter the state of the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: For payable functions, the blockchain state can be changed. For any
  prefs: []
  type: TYPE_NORMAL
- en: function that will induce a transfer of assets, there should be a payable type
  prefs: []
  type: TYPE_NORMAL
- en: assigned to the function and address.
  prefs: []
  type: TYPE_NORMAL
- en: One frequently asked question about pure, view, and payable functions
  prefs: []
  type: TYPE_NORMAL
- en: is whether they all consume gas fees. It is obvious that a payable function
  prefs: []
  type: TYPE_NORMAL
- en: always consumes gas fees as it changes the state of blockchain. For the
  prefs: []
  type: TYPE_NORMAL
- en: view function, it only retrieves blockchain data, and the pure function does
  prefs: []
  type: TYPE_NORMAL
- en: not even access blockchain state. The question regarding whether pure
  prefs: []
  type: TYPE_NORMAL
- en: and view functions consume gas depends on how the function is called.
  prefs: []
  type: TYPE_NORMAL
- en: '253'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 7 programming Smart ContraCt with Solidity
  prefs: []
  type: TYPE_NORMAL
- en: If a pure and view function is called through a transaction, there is a gas
  prefs: []
  type: TYPE_NORMAL
- en: fee incurred to the transaction because running the function consumes
  prefs: []
  type: TYPE_NORMAL
- en: CPU time. If the pure and view function is not called through a transaction,
  prefs: []
  type: TYPE_NORMAL
- en: then there is no gas fee. A pure and view function can be called by directly
  prefs: []
  type: TYPE_NORMAL
- en: attaching a client to an Ethereum node and instantiating a smart contract
  prefs: []
  type: TYPE_NORMAL
- en: object in that local node and calling the function directly. Calling a smart
  prefs: []
  type: TYPE_NORMAL
- en: contract function directly does not generate a transaction. The operation
  prefs: []
  type: TYPE_NORMAL
- en: can be done by the local node without incurring gas fee. Therefore, the
  prefs: []
  type: TYPE_NORMAL
- en: answer to the question about whether there is gas consumption for pure
  prefs: []
  type: TYPE_NORMAL
- en: or view function depends whether there is transaction to the function call
  prefs: []
  type: TYPE_NORMAL
- en: or not. Any function call that is triggered by a transaction will incur gas
    fee.
  prefs: []
  type: TYPE_NORMAL
- en: The gas fee can be calculated by a gas fee consumption table in EIP-1559\.
  prefs: []
  type: TYPE_NORMAL
- en: '**Function Access Scope: Public, External,**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Internal, and Private**'
  prefs: []
  type: TYPE_NORMAL
- en: The scope of functions defines who can access the functions. This is
  prefs: []
  type: TYPE_NORMAL
- en: different from the function type of view/pure/payable, which defines
  prefs: []
  type: TYPE_NORMAL
- en: whether the function will access the blockchain, and if yes, whether it
  prefs: []
  type: TYPE_NORMAL
- en: reads or writes to the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four access scopes in Solidity functions: public, external,'
  prefs: []
  type: TYPE_NORMAL
- en: internal, and private scopes. Public function means that you can call this
  prefs: []
  type: TYPE_NORMAL
- en: function from an external blockchain client. If a function needs to be
  prefs: []
  type: TYPE_NORMAL
- en: called through a Web3 client, it is defined as public. External functions
  prefs: []
  type: TYPE_NORMAL
- en: can be called by another smart contract. Solidity supports importing an
  prefs: []
  type: TYPE_NORMAL
- en: external smart contract and calling the functions defined in the other smart
  prefs: []
  type: TYPE_NORMAL
- en: contract. The syntax to call an external smart contract is contractName.
  prefs: []
  type: TYPE_NORMAL
- en: functionName(). If an external function is called by the same smart contract,
  prefs: []
  type: TYPE_NORMAL
- en: use “this.functionName()” to refer to calling within the same contract.
  prefs: []
  type: TYPE_NORMAL
- en: Internal functions can be called by other functions in the same or
  prefs: []
  type: TYPE_NORMAL
- en: derived smart contract. And finally, private functions can only be called by
  prefs: []
  type: TYPE_NORMAL
- en: the functions in the same smart contract, which is the most restrictive.
  prefs: []
  type: TYPE_NORMAL
- en: '254'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 7 programming Smart ContraCt with Solidity
  prefs: []
  type: TYPE_NORMAL
- en: '**Module 2: Solidity Data Types**'
  prefs: []
  type: TYPE_NORMAL
- en: A data type is a supported format and classification of data that tells the
  prefs: []
  type: TYPE_NORMAL
- en: compiler and execution engine to interpret a programming language.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to any modern programming languages, Solidity has a good set
  prefs: []
  type: TYPE_NORMAL
- en: of supported data types. In general, understanding data types can help
  prefs: []
  type: TYPE_NORMAL
- en: programmers to improve code security and execution efficiency. For
  prefs: []
  type: TYPE_NORMAL
- en: Solidity, there are additional reasons for knowing and paying attention
  prefs: []
  type: TYPE_NORMAL
- en: to data types. Firstly, users who call smart contract functions need to
  prefs: []
  type: TYPE_NORMAL
- en: pay gas fees for the storage and processing of computing steps. The gas
  prefs: []
  type: TYPE_NORMAL
- en: consumption could be quite expensive, sometimes reaching $200 per
  prefs: []
  type: TYPE_NORMAL
- en: transaction for Ethereum mainnet transactions. Secondly, smart contract
  prefs: []
  type: TYPE_NORMAL
- en: functions are open to the world. Anyone can call the smart contract's
  prefs: []
  type: TYPE_NORMAL
- en: public functions. If the data type for a variable is improperly defined such
  prefs: []
  type: TYPE_NORMAL
- en: as allocating too much space, a malicious user may inject garbage to the
  prefs: []
  type: TYPE_NORMAL
- en: data and cause some performance issue or even stall the process of smart
  prefs: []
  type: TYPE_NORMAL
- en: contract function calls. Thirdly, Solidity only supports a limited set of data
  prefs: []
  type: TYPE_NORMAL
- en: types when compared with Java programming language. Data types such
  prefs: []
  type: TYPE_NORMAL
- en: as double and float are not supported in Solidity programming language.
  prefs: []
  type: TYPE_NORMAL
- en: '**Boolean**'
  prefs: []
  type: TYPE_NORMAL
- en: Boolean is the simplest data type for a programming language. It only uses
  prefs: []
  type: TYPE_NORMAL
- en: one bit of storage to represent a true or false state of a variable. In Solidity,
  prefs: []
  type: TYPE_NORMAL
- en: a variable can be declared as a boolean with bool keyword as shown in the
  prefs: []
  type: TYPE_NORMAL
- en: 'following:'
  prefs: []
  type: TYPE_NORMAL
- en: bool new_member;
  prefs: []
  type: TYPE_NORMAL
- en: There are several logical operators that can be applied to a boolean
  prefs: []
  type: TYPE_NORMAL
- en: 'data type as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '! (logical negation)'
  prefs: []
  type: TYPE_NORMAL
- en: '&& (logical conjunction, “and”)'
  prefs: []
  type: TYPE_NORMAL
- en: '255'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 7 programming Smart ContraCt with Solidity
  prefs: []
  type: TYPE_NORMAL
- en: '|| (logical disjunction, “or”)'
  prefs: []
  type: TYPE_NORMAL
- en: == (equality)
  prefs: []
  type: TYPE_NORMAL
- en: '!= (inequality)'
  prefs: []
  type: TYPE_NORMAL
- en: With the boolean data type, an exclamation sign ! can be used as a
  prefs: []
  type: TYPE_NORMAL
- en: negation of the boolean type. A negation operation turns a true state to false
  prefs: []
  type: TYPE_NORMAL
- en: and a false state to true. Other operations on a boolean type can be && or
  prefs: []
  type: TYPE_NORMAL
- en: '||. An && operation of two boolean types will be true if both are true. A “||”'
  prefs: []
  type: TYPE_NORMAL
- en: operation of two boolean type variables will be true if either variable is true.
  prefs: []
  type: TYPE_NORMAL
- en: Two boolean variables can also be compared. Two boolean variables are
  prefs: []
  type: TYPE_NORMAL
- en: equal if they are both true or both false. Sometimes, a boolean variable can
  prefs: []
  type: TYPE_NORMAL
- en: be conditionally checked in an "if" statement. If(variable) returns true if
    the variable is true, and false if the variable is false.
  prefs: []
  type: TYPE_NORMAL
- en: Since a boolean variable consumes only one bit storage and there are
  prefs: []
  type: TYPE_NORMAL
- en: multiple operations that can be used to operate on boolean variables, it
  prefs: []
  type: TYPE_NORMAL
- en: is recommended that developers use boolean type rather than other data
  prefs: []
  type: TYPE_NORMAL
- en: types if possible for storage efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: '**Integer Type**'
  prefs: []
  type: TYPE_NORMAL
- en: Integer data type is used to represent a positive integer (unsigned) or
  prefs: []
  type: TYPE_NORMAL
- en: any integer (signed). In Solidity, the signed or unsigned integer can be in
  prefs: []
  type: TYPE_NORMAL
- en: different sizes represented by the amount of bits allocated for an integer
  prefs: []
  type: TYPE_NORMAL
- en: variable. For example, uint8 means an 8-bit unsigned integer. uint8 can
  prefs: []
  type: TYPE_NORMAL
- en: hold values from 0 upto 2^8-1 (0–255). uint256 can hold values from 0 to
  prefs: []
  type: TYPE_NORMAL
- en: 2^256-1\. Between uint8 and uint256, there are also various integer data
  prefs: []
  type: TYPE_NORMAL
- en: types in incremental size increase of 8 bit (1 byte). Signed data types differ
  prefs: []
  type: TYPE_NORMAL
- en: from unsigned ones as it can represent both positive and negative integers.
  prefs: []
  type: TYPE_NORMAL
- en: For example, int8 can hold values from -128 to 127 (range of -2^7 to 2^7-1).
  prefs: []
  type: TYPE_NORMAL
- en: int256 can hold values from -2^255 to 2^255-1\. "int" can also have various
  prefs: []
  type: TYPE_NORMAL
- en: sizes at an incremental step of 8 bit, such as int8, int16, int24, int32 up
  prefs: []
  type: TYPE_NORMAL
- en: to int256\.
  prefs: []
  type: TYPE_NORMAL
- en: '256'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 7 programming Smart ContraCt with Solidity
  prefs: []
  type: TYPE_NORMAL
- en: If the bit number is not specified in the integer type, it is default to 256\.
  prefs: []
  type: TYPE_NORMAL
- en: uint and int are aliases for uint256 and int256, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Solidity also has built-in operators for integer type variables. This is
  prefs: []
  type: TYPE_NORMAL
- en: shown in the following table (Figur[e 7-1):](#p268)
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 7-1\.** Operators for Integer Datatype*'
  prefs: []
  type: TYPE_NORMAL
- en: '257'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 7 programming Smart ContraCt with Solidity
  prefs: []
  type: TYPE_NORMAL
- en: Since smart contracts can be written to handle large sums of assets,
  prefs: []
  type: TYPE_NORMAL
- en: it is important to ensure that the math is fully accurate. The boundary
  prefs: []
  type: TYPE_NORMAL
- en: conditions and validity of inputs should be checked thoroughly. Many
  prefs: []
  type: TYPE_NORMAL
- en: libraries have been written to let developers reuse the math components
  prefs: []
  type: TYPE_NORMAL
- en: and to prevent hackers attacking smart contracts through security holes in
  prefs: []
  type: TYPE_NORMAL
- en: math functions. For example, SafeMath is a good library to use to handle
  prefs: []
  type: TYPE_NORMAL
- en: mathematics operations. Developers can download SafeMath libraries
  prefs: []
  type: TYPE_NORMAL
- en: by OpenZeppelin and import the smart contract to use the class and
  prefs: []
  type: TYPE_NORMAL
- en: functions in the library.
  prefs: []
  type: TYPE_NORMAL
- en: '**Address Type**'
  prefs: []
  type: TYPE_NORMAL
- en: Address is an unique identifier of a crypto account in blockchains. Address
  prefs: []
  type: TYPE_NORMAL
- en: type is a data structure that is not defined in conventional programming
  prefs: []
  type: TYPE_NORMAL
- en: languages such as C or Java but is essential in smart contract programming
  prefs: []
  type: TYPE_NORMAL
- en: languages. Ethereum blockchain uses a 20-byte hex value to represent a
  prefs: []
  type: TYPE_NORMAL
- en: crypto address.
  prefs: []
  type: TYPE_NORMAL
- en: When you create an account in Ethereum, three items are generated.
  prefs: []
  type: TYPE_NORMAL
- en: The first item is a private key. This is the unique key to access the account
  prefs: []
  type: TYPE_NORMAL
- en: and should be kept by the account owner and never revealed to other
  prefs: []
  type: TYPE_NORMAL
- en: people. The second item is a public key that is used to represent the account
  prefs: []
  type: TYPE_NORMAL
- en: and can be published. A public key can be used to encrypt a message, and
  prefs: []
  type: TYPE_NORMAL
- en: only the private key can decrypt the message. The third item is an address
  prefs: []
  type: TYPE_NORMAL
- en: derived from a public key. An address is actually a simplification of the
  prefs: []
  type: TYPE_NORMAL
- en: public key. Simply apply Keccak-256 hashing to the public key and then take
  prefs: []
  type: TYPE_NORMAL
- en: the last 20 bytes; the output is the address for the account. Since each byte
  prefs: []
  type: TYPE_NORMAL
- en: can represent two hex numbers, it is actually a hex string with 40 digits such
  prefs: []
  type: TYPE_NORMAL
- en: as *0x1F2D3A67b8E96039BbAC84EB4BC0913c0c16778c*.
  prefs: []
  type: TYPE_NORMAL
- en: In Solidity code, address data type is a representation of an asset
  prefs: []
  type: TYPE_NORMAL
- en: account. When declaring an address variable, the developer needs to
  prefs: []
  type: TYPE_NORMAL
- en: specify whether this address can receive external funds or not. This can be
  prefs: []
  type: TYPE_NORMAL
- en: done by using the keyword **payable**.
  prefs: []
  type: TYPE_NORMAL
- en: '258'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 7 programming Smart ContraCt with Solidity
  prefs: []
  type: TYPE_NORMAL
- en: If an address is declared payable, it can receive funds sent to this
  prefs: []
  type: TYPE_NORMAL
- en: address. If not, the smart contract will reject any funds that are sent to this
  prefs: []
  type: TYPE_NORMAL
- en: account. Payable keyword is an additional safeguard to ensure only valid
  prefs: []
  type: TYPE_NORMAL
- en: accounts can receive assets transferred to it.
  prefs: []
  type: TYPE_NORMAL
- en: The following shows how to define a nonpayable and payable address
  prefs: []
  type: TYPE_NORMAL
- en: example.
  prefs: []
  type: TYPE_NORMAL
- en: '*// address type is a twenty byte hex variable*'
  prefs: []
  type: TYPE_NORMAL
- en: '*address account_spending;*'
  prefs: []
  type: TYPE_NORMAL
- en: '*account_spending = 0x1F2D3A67b8E96039BbAC84EB4BC0913c0c16778c;*'
  prefs: []
  type: TYPE_NORMAL
- en: '*address payable account_receiving;*'
  prefs: []
  type: TYPE_NORMAL
- en: '*account_receiving = 0xDda897285Ce46CG78D786a9e993286AaC68c45bC;*'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding examples, there are two address variables defined.
  prefs: []
  type: TYPE_NORMAL
- en: The first one, account_spending, is a nonpayable account. It cannot
  prefs: []
  type: TYPE_NORMAL
- en: be used to receive any funds. It can, however, send out funds from its
  prefs: []
  type: TYPE_NORMAL
- en: own account. The second one called account_receiving has the payable
  prefs: []
  type: TYPE_NORMAL
- en: attribute and hence can send out or receive funds with the account.
  prefs: []
  type: TYPE_NORMAL
- en: One more thing to point out is that address can not only be an
  prefs: []
  type: TYPE_NORMAL
- en: identification to an account, it can also point to a smart contract instance.
  prefs: []
  type: TYPE_NORMAL
- en: A smart contract address is the entry point to a deployed smart contract.
  prefs: []
  type: TYPE_NORMAL
- en: This address can be used to represent a deployed smart contract and call
  prefs: []
  type: TYPE_NORMAL
- en: the functions inside the smart contract.
  prefs: []
  type: TYPE_NORMAL
- en: '**Byte Array**'
  prefs: []
  type: TYPE_NORMAL
- en: Byte array (Figure [7-2](#p271)) uses array to represent a fixed amount of bytes
    from 1 to 32\. The following defines various types of byte arrays and the bit
  prefs: []
  type: TYPE_NORMAL
- en: operations that can be applied to the array.
  prefs: []
  type: TYPE_NORMAL
- en: '259'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 7 programming Smart ContraCt with Solidity
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 7-2\.** Byte arrays data type*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note:'
  prefs: []
  type: TYPE_NORMAL
- en: Byte is the same as byte1\.
  prefs: []
  type: TYPE_NORMAL
- en: 'To define a byte array, use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: byte1 b1;
  prefs: []
  type: TYPE_NORMAL
- en: byte2 b2;
  prefs: []
  type: TYPE_NORMAL
- en: Byte32 b32;
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, b1, b2, and b32 represent a 1-byte, a 2-byte,
  prefs: []
  type: TYPE_NORMAL
- en: and a 32-byte variable, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: To retrieve an element of a byte array variable x, use x[i], where i ranges
  prefs: []
  type: TYPE_NORMAL
- en: from 0 to byte size to get the byte at index i.
  prefs: []
  type: TYPE_NORMAL
- en: The following diagram shows the operations for byte arrays
  prefs: []
  type: TYPE_NORMAL
- en: (Figure [7-3).](#p272)
  prefs: []
  type: TYPE_NORMAL
- en: '260'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 7 programming Smart ContraCt with Solidity
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 7-3\.** Byte array operations*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Fixed Size Array**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Fixed size array is an indexed array of any data type such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*data_type array_name[array_size]*'
  prefs: []
  type: TYPE_NORMAL
- en: Here, data_type is any data type such as integer, address, and byte,
  prefs: []
  type: TYPE_NORMAL
- en: 'such as following:'
  prefs: []
  type: TYPE_NORMAL
- en: uint balances[30]; // an unsigned integer array of fixed size
  prefs: []
  type: TYPE_NORMAL
- en: address students[25];
  prefs: []
  type: TYPE_NORMAL
- en: // an address array that holds 25 students' account address
  prefs: []
  type: TYPE_NORMAL
- en: '261'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 7 programming Smart ContraCt with Solidity
  prefs: []
  type: TYPE_NORMAL
- en: A fixed size array can be initialized by assigning the data value during
  prefs: []
  type: TYPE_NORMAL
- en: the declaration phase or later by assigning a value to the variable element.
  prefs: []
  type: TYPE_NORMAL
- en: '*uint balances[5] = [10, 20, 30, 40, 50]; // This declares a*'
  prefs: []
  type: TYPE_NORMAL
- en: '*balanced array of type unsigned integer and assigns values to*'
  prefs: []
  type: TYPE_NORMAL
- en: '*each element.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*uint balances[] = [10, 20, 30, 40, 50]; // This declares a*'
  prefs: []
  type: TYPE_NORMAL
- en: '*balanced array of type unsigned integer and assigns values to*'
  prefs: []
  type: TYPE_NORMAL
- en: '*each element. The array size is omitted and it is equal to the*'
  prefs: []
  type: TYPE_NORMAL
- en: '*number of values assigned to the array.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To assign a value to an array element, simply use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: array_name[index] = data_value;
  prefs: []
  type: TYPE_NORMAL
- en: Here, array_name is the array variable name, index is the index for the
  prefs: []
  type: TYPE_NORMAL
- en: array element, and data_value is the value to be assigned to the element.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: balances[3] =300; // assigned value 300 to index 3 of
  prefs: []
  type: TYPE_NORMAL
- en: balances array.
  prefs: []
  type: TYPE_NORMAL
- en: '**Dynamically Sized Array**'
  prefs: []
  type: TYPE_NORMAL
- en: In Solidity, arrays have continuous addresses. The first element points to
  prefs: []
  type: TYPE_NORMAL
- en: the lowest address, and the last elements points to the highest address. For
  prefs: []
  type: TYPE_NORMAL
- en: a fixed size array, the size of the array is set during the compilation time.
  prefs: []
  type: TYPE_NORMAL
- en: For a dynamically sized array, the array size is set during the runtime. To
  prefs: []
  type: TYPE_NORMAL
- en: 'declare a dynamically sized array, use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: data_type[] array_name;
  prefs: []
  type: TYPE_NORMAL
- en: Here, data_type is the name of the data type such as uint and address.
  prefs: []
  type: TYPE_NORMAL
- en: array_name is the array variable name such as balances and students_
  prefs: []
  type: TYPE_NORMAL
- en: addresses.
  prefs: []
  type: TYPE_NORMAL
- en: '262'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 7 programming Smart ContraCt with Solidity
  prefs: []
  type: TYPE_NORMAL
- en: '*uint[] balances;*'
  prefs: []
  type: TYPE_NORMAL
- en: '*address[] students_addresses;*'
  prefs: []
  type: TYPE_NORMAL
- en: When a dynamic array is declared, its size will need to be set with a
  prefs: []
  type: TYPE_NORMAL
- en: length in the code execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set the array length, use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: array_name = new data_type[](size);
  prefs: []
  type: TYPE_NORMAL
- en: Here, array_name is the array variable name. data_type is the data
  prefs: []
  type: TYPE_NORMAL
- en: type name, and size is an uint that represents the intended size of the
  prefs: []
  type: TYPE_NORMAL
- en: array. For example, the array variables mentioned earlier can be set to the
  prefs: []
  type: TYPE_NORMAL
- en: 'following length:'
  prefs: []
  type: TYPE_NORMAL
- en: '*balances = new uint[](9); // set balances array size to 9*'
  prefs: []
  type: TYPE_NORMAL
- en: '*students_addresses = new address[](10);*'
  prefs: []
  type: TYPE_NORMAL
- en: '*// set students_addresses array size to 10*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Mapping Data Type**'
  prefs: []
  type: TYPE_NORMAL
- en: Besides address data type, another important one is mapping type.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping data type associates two variables like an associative array.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping type is an important data type because it correlates two or more
  prefs: []
  type: TYPE_NORMAL
- en: variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'To declare mapping types, use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: mapping(key_type => value_type)
  prefs: []
  type: TYPE_NORMAL
- en: The key_type can be any elementary type such as built-in types like
  prefs: []
  type: TYPE_NORMAL
- en: uint, address, bytes, and string.
  prefs: []
  type: TYPE_NORMAL
- en: The key_type can also be user-defined or complex types like contract
  prefs: []
  type: TYPE_NORMAL
- en: types, enums, mappings, structs, and any array type.
  prefs: []
  type: TYPE_NORMAL
- en: value_type can be any type, including mappings.
  prefs: []
  type: TYPE_NORMAL
- en: '263'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 7 programming Smart ContraCt with Solidity
  prefs: []
  type: TYPE_NORMAL
- en: The following defines a mapping of address array with balance for each
  prefs: []
  type: TYPE_NORMAL
- en: 'array element:'
  prefs: []
  type: TYPE_NORMAL
- en: '*address student_address;*'
  prefs: []
  type: TYPE_NORMAL
- en: '*uint score;*'
  prefs: []
  type: TYPE_NORMAL
- en: '*mapping(student_address => score) public scores;*'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding example defines student_address as an address data
  prefs: []
  type: TYPE_NORMAL
- en: type and a score as uint type. Then student_address is mapped to score. To
  prefs: []
  type: TYPE_NORMAL
- en: 'assign a score to a student, use the following syntax as example:'
  prefs: []
  type: TYPE_NORMAL
- en: student_1_address = *0x1B2E2A67b8E96039BbAC84EB4BC0913c0c16668D;*
  prefs: []
  type: TYPE_NORMAL
- en: '*score_1 = 90;*'
  prefs: []
  type: TYPE_NORMAL
- en: '*scores[student_1_address] = score_1;*'
  prefs: []
  type: TYPE_NORMAL
- en: // This example sets the score for student 1 to be 90\.
  prefs: []
  type: TYPE_NORMAL
- en: To retrieve the score of student 1, simply enter the student's address to
  prefs: []
  type: TYPE_NORMAL
- en: 'the scores variable:'
  prefs: []
  type: TYPE_NORMAL
- en: scores[student_1_address] // This will return 90\.
  prefs: []
  type: TYPE_NORMAL
- en: A mapping is a versatile data type that associates two variables without
  prefs: []
  type: TYPE_NORMAL
- en: a predefined size. This is used frequently in smart contracts.
  prefs: []
  type: TYPE_NORMAL
- en: '**Enum Data Type**'
  prefs: []
  type: TYPE_NORMAL
- en: Enum is a data type that enumerates a variable to have only some
  prefs: []
  type: TYPE_NORMAL
- en: predefined values. By restricting the values in an enum variable, the
  prefs: []
  type: TYPE_NORMAL
- en: chance to make mistakes is decreased.
  prefs: []
  type: TYPE_NORMAL
- en: The syntax for defining an enum is
  prefs: []
  type: TYPE_NORMAL
- en: enum enum_type_name{VALUE_LIST};
  prefs: []
  type: TYPE_NORMAL
- en: Here, enum is the data type keyword, and enum_type_name is
  prefs: []
  type: TYPE_NORMAL
- en: the name of the enum type. VALUE_LIST is a list of values separated
  prefs: []
  type: TYPE_NORMAL
- en: by comma.
  prefs: []
  type: TYPE_NORMAL
- en: '264'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 7 programming Smart ContraCt with Solidity
  prefs: []
  type: TYPE_NORMAL
- en: Once an enum type is defined, it can be used to declare an enum
  prefs: []
  type: TYPE_NORMAL
- en: variable.
  prefs: []
  type: TYPE_NORMAL
- en: enum_type_name variable_name;
  prefs: []
  type: TYPE_NORMAL
- en: For example, in order to limit the role of a decentralized organization,
  prefs: []
  type: TYPE_NORMAL
- en: the role variable can be an enum data type such as
  prefs: []
  type: TYPE_NORMAL
- en: '*enum DAO_ROLES{SECRETARY, ACCOUNTANT, LEGAL, MEMBER};*'
  prefs: []
  type: TYPE_NORMAL
- en: '*DAO_ROLES newMember;*'
  prefs: []
  type: TYPE_NORMAL
- en: '*newMember = DAO_ROLES.MEMBER;*'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, DAO_ROLES is declared as an enum
  prefs: []
  type: TYPE_NORMAL
- en: that can have the values of SECRETARY, ACCOUNTANT, LEGAL,
  prefs: []
  type: TYPE_NORMAL
- en: and MEMBER.
  prefs: []
  type: TYPE_NORMAL
- en: The DAO_ROLES is used to declare a variable newMember. This new
  prefs: []
  type: TYPE_NORMAL
- en: member is assigned a value of DAO_ROLES.MEMBER.
  prefs: []
  type: TYPE_NORMAL
- en: By using enum, it reduces the values for a variable to a limited list and
  prefs: []
  type: TYPE_NORMAL
- en: hence is less error prone.
  prefs: []
  type: TYPE_NORMAL
- en: In the following, a code snippet is shown to illustrate how to use an
  prefs: []
  type: TYPE_NORMAL
- en: 'enum to define variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '*pragma solidity ^0.6.0;*'
  prefs: []
  type: TYPE_NORMAL
- en: '*contract enum_example {*'
  prefs: []
  type: TYPE_NORMAL
- en: '*enum DAO_ROLES{ SECRETARY, ACCOUNTANT, LEGAL, MEMBER};*'
  prefs: []
  type: TYPE_NORMAL
- en: '*// define an enum type*'
  prefs: []
  type: TYPE_NORMAL
- en: '*DAO_ROLES latestMember; // define an enum variable*'
  prefs: []
  type: TYPE_NORMAL
- en: '*function setRoleSECRETARY() public { // declare a function*'
  prefs: []
  type: TYPE_NORMAL
- en: '*to set latestMember to be a SECRETARY role*'
  prefs: []
  type: TYPE_NORMAL
- en: '*latestMember = DAO_ROLES.SECRETARY;*'
  prefs: []
  type: TYPE_NORMAL
- en: '*}*'
  prefs: []
  type: TYPE_NORMAL
- en: '265'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 7 programming Smart ContraCt with Solidity
  prefs: []
  type: TYPE_NORMAL
- en: '*function getRole() public view returns (DAO_ROLES)*'
  prefs: []
  type: TYPE_NORMAL
- en: '*{ // Query the role of the latest member*'
  prefs: []
  type: TYPE_NORMAL
- en: '*return latestMember;*'
  prefs: []
  type: TYPE_NORMAL
- en: '*}*'
  prefs: []
  type: TYPE_NORMAL
- en: '*}*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Struct Data Type**'
  prefs: []
  type: TYPE_NORMAL
- en: Struct is the abbreviation of structure. Similar to struct in other
  prefs: []
  type: TYPE_NORMAL
- en: programming languages, Solidity supports struct data type to group a
  prefs: []
  type: TYPE_NORMAL
- en: number of variables together. The group of variables can have different
  prefs: []
  type: TYPE_NORMAL
- en: 'data types. A struct variable type is defined with the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: struct struct_type{
  prefs: []
  type: TYPE_NORMAL
- en: datatype_1 variable_1;
  prefs: []
  type: TYPE_NORMAL
- en: datatype_2 variable_2;
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: Here, struct_type is the struct to be defined. datatype_1, datatype_2,
  prefs: []
  type: TYPE_NORMAL
- en: etc., are data types that are native with Solidity or defined by the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of defining a struct is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '*enum Experience{ENTRY, JUNIOR, SENIOR, EXPERT};*'
  prefs: []
  type: TYPE_NORMAL
- en: '*enum Skillset{SOLIDITY, PROTOCOL, BOTH};*'
  prefs: []
  type: TYPE_NORMAL
- en: '*struct Developer {*'
  prefs: []
  type: TYPE_NORMAL
- en: '*address addr;*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Experience level;*'
  prefs: []
  type: TYPE_NORMAL
- en: '*uint hourly_rate;*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skillset skill;*'
  prefs: []
  type: TYPE_NORMAL
- en: '*}*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Developer guru1;*'
  prefs: []
  type: TYPE_NORMAL
- en: '266'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 7 programming Smart ContraCt with Solidity
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, a Developer struct is defined that contains
  prefs: []
  type: TYPE_NORMAL
- en: 'four components: an account address of the developer, an enum of'
  prefs: []
  type: TYPE_NORMAL
- en: experience level, an hourly rate of uint type, and skill of enum type. The
  prefs: []
  type: TYPE_NORMAL
- en: variable guru1 is declared as a Developer struct type variable.
  prefs: []
  type: TYPE_NORMAL
- en: To refer to components inside a struct, use “.” symbol. For example, to
  prefs: []
  type: TYPE_NORMAL
- en: 'set values to guru1 in the preceding example, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: guru1.address = *0x1B2E2A67b8E96039BbAC84EB4BC0913c0c16668D;*
  prefs: []
  type: TYPE_NORMAL
- en: '*guru1.level = Experience.EXPERT;*'
  prefs: []
  type: TYPE_NORMAL
- en: '*guru1.hourly_rate = 80;*'
  prefs: []
  type: TYPE_NORMAL
- en: '*guru1.skil = Skillset.SOLIDITY;*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Besides setting values individually as shown earlier, a struct variable*'
  prefs: []
  type: TYPE_NORMAL
- en: '*can be assigned values through struct constructor as shown in the following:*'
  prefs: []
  type: TYPE_NORMAL
- en: '*guru1 = Developer(0x1B2E2A67b8E96039BbAC84EB4BC0913c0c16668D,*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Experience.EXPERT,*'
  prefs: []
  type: TYPE_NORMAL
- en: '*80,*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skillset.SOLIDITY*'
  prefs: []
  type: TYPE_NORMAL
- en: '*)*'
  prefs: []
  type: TYPE_NORMAL
- en: If there are multiple developers such as guru1, guru2, and guru3, a
  prefs: []
  type: TYPE_NORMAL
- en: mapping combined with struct can be used. For example, an uint can be
  prefs: []
  type: TYPE_NORMAL
- en: 'mapped to a Developer struct to refer to a list of developers:'
  prefs: []
  type: TYPE_NORMAL
- en: mapping(uint=>Developer) developers;
  prefs: []
  type: TYPE_NORMAL
- en: Here, developers is a mapping variable. Each developer can be referred
  prefs: []
  type: TYPE_NORMAL
- en: to as developer[0], developer[1], etc.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping combined with struct can provide very sophisticated data
  prefs: []
  type: TYPE_NORMAL
- en: types that can address most of the data type tasks in Solidity programming.
  prefs: []
  type: TYPE_NORMAL
- en: '267'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 7 programming Smart ContraCt with Solidity
  prefs: []
  type: TYPE_NORMAL
- en: In summary, Solidity provides a way to define new types in the form of
  prefs: []
  type: TYPE_NORMAL
- en: structs. The following code snippet shows an example of Donor struct that
  prefs: []
  type: TYPE_NORMAL
- en: 'contains an address and the donation amount:'
  prefs: []
  type: TYPE_NORMAL
- en: '*contract Charity {*'
  prefs: []
  type: TYPE_NORMAL
- en: '*// Defines a struct with two fields.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*struct Donor {*'
  prefs: []
  type: TYPE_NORMAL
- en: '*address addr;*'
  prefs: []
  type: TYPE_NORMAL
- en: '*uint donation_amount;*'
  prefs: []
  type: TYPE_NORMAL
- en: '*}*'
  prefs: []
  type: TYPE_NORMAL
- en: '*// define a mapping*'
  prefs: []
  type: TYPE_NORMAL
- en: '*mapping (uint =>Donors) donors;*'
  prefs: []
  type: TYPE_NORMAL
- en: '*//...*'
  prefs: []
  type: TYPE_NORMAL
- en: '*}*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Blockchain Specific Variables**'
  prefs: []
  type: TYPE_NORMAL
- en: Frequently, smart contracts need to get information from blockchain itself
  prefs: []
  type: TYPE_NORMAL
- en: and use blockchain data in the functions. Solidity actually defines some
  prefs: []
  type: TYPE_NORMAL
- en: global variables to refer to the blockchain state and transaction data. The
  prefs: []
  type: TYPE_NORMAL
- en: common ones are global variables and functions defined in the following
  prefs: []
  type: TYPE_NORMAL
- en: 'table (Figur[e 7-4). T](#p280)here are two major variables: msg (message global
    variable) and block (the blockchain variable).'
  prefs: []
  type: TYPE_NORMAL
- en: '268'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 7 programming Smart ContraCt with Solidity
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 7-4\.** Special blockchain variables and functions*'
  prefs: []
  type: TYPE_NORMAL
- en: Most of the global variables listed in the preceding table are self-
  prefs: []
  type: TYPE_NORMAL
- en: explanatory. There are a few variables that need further clarification.
  prefs: []
  type: TYPE_NORMAL
- en: The msg variable mainly defines the parameters and data inside a
  prefs: []
  type: TYPE_NORMAL
- en: transaction. Every time when a transaction is sent to Ethereum blockchain,
  prefs: []
  type: TYPE_NORMAL
- en: '269'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 7 programming Smart ContraCt with Solidity
  prefs: []
  type: TYPE_NORMAL
- en: the msg object can be referred by a smart contract to extract the following
  prefs: []
  type: TYPE_NORMAL
- en: 'information:'
  prefs: []
  type: TYPE_NORMAL
- en: '**msg.value** – This is the amount of Ether that is sent'
  prefs: []
  type: TYPE_NORMAL
- en: to the receiver. It is in the unit of wei.
  prefs: []
  type: TYPE_NORMAL
- en: '**msg.data** – This is the data field in a transaction. It is'
  prefs: []
  type: TYPE_NORMAL
- en: the user input data that is sent to a smart contract to
  prefs: []
  type: TYPE_NORMAL
- en: process.
  prefs: []
  type: TYPE_NORMAL
- en: '**msg.sig** – This is the signature of the sender who'
  prefs: []
  type: TYPE_NORMAL
- en: sent the transaction.
  prefs: []
  type: TYPE_NORMAL
- en: '**msg.sender** – This is the address of the sender. It'
  prefs: []
  type: TYPE_NORMAL
- en: is important to check the address of the sender to
  prefs: []
  type: TYPE_NORMAL
- en: ensure that the sender is authorized to perform
  prefs: []
  type: TYPE_NORMAL
- en: actions on the smart contract functions.
  prefs: []
  type: TYPE_NORMAL
- en: '**block.blockhash** – The block.blockhash is a special'
  prefs: []
  type: TYPE_NORMAL
- en: function that takes in a block number and outputs
  prefs: []
  type: TYPE_NORMAL
- en: its block hash.
  prefs: []
  type: TYPE_NORMAL
- en: '**block.difficulty** – Outputs the difficulty of'
  prefs: []
  type: TYPE_NORMAL
- en: blockchain mining.
  prefs: []
  type: TYPE_NORMAL
- en: '**block.gaslimit** – Defines the gas limit for the'
  prefs: []
  type: TYPE_NORMAL
- en: latest block.
  prefs: []
  type: TYPE_NORMAL
- en: '**block.number** – The latest block number.'
  prefs: []
  type: TYPE_NORMAL
- en: '**gasleft()** – Returns the gas left for a transaction.'
  prefs: []
  type: TYPE_NORMAL
- en: '**now** – The current timestamp.'
  prefs: []
  type: TYPE_NORMAL
- en: Another global variable is tx reserved for the transactions.
  prefs: []
  type: TYPE_NORMAL
- en: '**tx.gasprice** – Shows the gas price of the transaction.'
  prefs: []
  type: TYPE_NORMAL
- en: '**tx.origin** – Original sender of the transaction. This is'
  prefs: []
  type: TYPE_NORMAL
- en: the same in single function calls as msg.sender.
  prefs: []
  type: TYPE_NORMAL
- en: '270'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 7 programming Smart ContraCt with Solidity
  prefs: []
  type: TYPE_NORMAL
- en: '**Module 3: Events**'
  prefs: []
  type: TYPE_NORMAL
- en: '**What Is Ethereum Event**'
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum events are important concepts that are related to how to
  prefs: []
  type: TYPE_NORMAL
- en: message smart contract states and communicate with external programs.
  prefs: []
  type: TYPE_NORMAL
- en: Event type is an inheritable member of smart contract that is built into
  prefs: []
  type: TYPE_NORMAL
- en: Solidity programming language. Solidity provides syntaxes for defining an
  prefs: []
  type: TYPE_NORMAL
- en: event format and emitting an event.
  prefs: []
  type: TYPE_NORMAL
- en: '**Where Are Events Stored**'
  prefs: []
  type: TYPE_NORMAL
- en: Once an event is emitted, the corresponding event data is stored in the
  prefs: []
  type: TYPE_NORMAL
- en: transaction logs. The event data is the list of arguments passed to the emit
  prefs: []
  type: TYPE_NORMAL
- en: event function. The transaction logs are accessible through smart contract
  prefs: []
  type: TYPE_NORMAL
- en: addresses by external programs. Although events are stored in transaction
  prefs: []
  type: TYPE_NORMAL
- en: logs, its content is not accessible by smart contracts. Smart contracts can
  prefs: []
  type: TYPE_NORMAL
- en: emit events but cannot access events that are emitted.
  prefs: []
  type: TYPE_NORMAL
- en: '**How to Define an Event**'
  prefs: []
  type: TYPE_NORMAL
- en: Defining an event is very simple; just use the “event” keyword to define an
  prefs: []
  type: TYPE_NORMAL
- en: 'event name with a list of attributes as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*event eventName(dataType_1 [indexed] attribute_1, dataType_2*'
  prefs: []
  type: TYPE_NORMAL
- en: '*[indexed] attribute_2, ..., dataType_n [indexed] attribute_n);*'
  prefs: []
  type: TYPE_NORMAL
- en: Here, event is the keyword to define an event.
  prefs: []
  type: TYPE_NORMAL
- en: eventName is a name of the event.
  prefs: []
  type: TYPE_NORMAL
- en: dataType_1, dataType_2, dataType_n are lists of data types defined in
  prefs: []
  type: TYPE_NORMAL
- en: Solidity.
  prefs: []
  type: TYPE_NORMAL
- en: attribute_1, attribute_2, attribute_n are lists of attribute names
  prefs: []
  type: TYPE_NORMAL
- en: specified by the developers.
  prefs: []
  type: TYPE_NORMAL
- en: '271'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 7 programming Smart ContraCt with Solidity
  prefs: []
  type: TYPE_NORMAL
- en: indexed is a reserved keyword to allow a search for these events using
  prefs: []
  type: TYPE_NORMAL
- en: the indexed parameters as filters.
  prefs: []
  type: TYPE_NORMAL
- en: For example, to define an event when a token is minted, use the
  prefs: []
  type: TYPE_NORMAL
- en: 'following event definition as example:'
  prefs: []
  type: TYPE_NORMAL
- en: '*event Mint(address indexed receiver, uint amount);*'
  prefs: []
  type: TYPE_NORMAL
- en: In the example above, a Mint event is defined with two attributes. The
  prefs: []
  type: TYPE_NORMAL
- en: first attribute is the address of the receiver to which the minted token is
  prefs: []
  type: TYPE_NORMAL
- en: sent. The address is indexed, meaning that this is a searchable attribute.
  prefs: []
  type: TYPE_NORMAL
- en: The second attribute is the amount of token that is minted. The event does
  prefs: []
  type: TYPE_NORMAL
- en: not need to specify the token name or mint time as these can be inferred
  prefs: []
  type: TYPE_NORMAL
- en: from the smart contract address and the block time for the transaction.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, an event definition basically defines an event name and a
  prefs: []
  type: TYPE_NORMAL
- en: list of attributes. Once an event is defined, it can be called with parameters
  prefs: []
  type: TYPE_NORMAL
- en: to emit an event.
  prefs: []
  type: TYPE_NORMAL
- en: '**How to Emit an Event**'
  prefs: []
  type: TYPE_NORMAL
- en: Once an event type is defined, it can be emitted and recorded in the
  prefs: []
  type: TYPE_NORMAL
- en: transaction log as controlled by smart contract function. The syntax to emit
  prefs: []
  type: TYPE_NORMAL
- en: 'an event is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '*emit eventName(parameter_1, parameter_2, ..., parameter_n);*'
  prefs: []
  type: TYPE_NORMAL
- en: Here, emit is the keyword to trigger an emission of an event.
  prefs: []
  type: TYPE_NORMAL
- en: eventName is the event type defined by the developer using the
  prefs: []
  type: TYPE_NORMAL
- en: “event” keyword.
  prefs: []
  type: TYPE_NORMAL
- en: Parameter_1, parameter_2, parameter_n are the parameters for the
  prefs: []
  type: TYPE_NORMAL
- en: attributes defined in the event type. The parameter data type should match
  prefs: []
  type: TYPE_NORMAL
- en: the data type of the event attributes.
  prefs: []
  type: TYPE_NORMAL
- en: '272'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 7 programming Smart ContraCt with Solidity
  prefs: []
  type: TYPE_NORMAL
- en: An event type can be called to emit as many events as needed. For
  prefs: []
  type: TYPE_NORMAL
- en: example, the Mint event as defined in the last section can emit an event
  prefs: []
  type: TYPE_NORMAL
- en: each time a mint operation is performed.
  prefs: []
  type: TYPE_NORMAL
- en: '*emit Mint(0x1F2D3A67b8E96039BbAC84EB4BC0913c0c16778c, 200);*'
  prefs: []
  type: TYPE_NORMAL
- en: In the example above, an event is emitted to show that
  prefs: []
  type: TYPE_NORMAL
- en: 200 tokens have been minted to the specified address of
  prefs: []
  type: TYPE_NORMAL
- en: 0x1F2D3A67b8E96039BbAC84EB4BC0913c0c16778c.
  prefs: []
  type: TYPE_NORMAL
- en: When an event is emitted, its data is actually saved onto the
  prefs: []
  type: TYPE_NORMAL
- en: transaction log. The event can be viewed by using a block explorer to look
  prefs: []
  type: TYPE_NORMAL
- en: into the transaction log section of a transaction. The log can be accessed
  prefs: []
  type: TYPE_NORMAL
- en: through the address of the smart contract. The log cannot be accessed
  prefs: []
  type: TYPE_NORMAL
- en: within the smart contract itself. A smart contract cannot emit an event in
  prefs: []
  type: TYPE_NORMAL
- en: one function and then call another function to process the emitted event.
  prefs: []
  type: TYPE_NORMAL
- en: Events can only be accessed through external programs such as client
  prefs: []
  type: TYPE_NORMAL
- en: programs. The Web3 library has some event access function calls that can
  prefs: []
  type: TYPE_NORMAL
- en: be used to retrieve or search for the events.
  prefs: []
  type: TYPE_NORMAL
- en: '**Event Examples**'
  prefs: []
  type: TYPE_NORMAL
- en: Once we know the event definition and emission, coding events is very
  prefs: []
  type: TYPE_NORMAL
- en: straightforward. The following shows a contract for DepositEvent that
  prefs: []
  type: TYPE_NORMAL
- en: 'emits deposit records:'
  prefs: []
  type: TYPE_NORMAL
- en: '*pragma solidity ^0.8.0;*'
  prefs: []
  type: TYPE_NORMAL
- en: '*contract DepositEvent {*'
  prefs: []
  type: TYPE_NORMAL
- en: '*event Deposit(address indexed depositor_address, uint*'
  prefs: []
  type: TYPE_NORMAL
- en: '*indexed deposit_id, uint deposit_amount); // defines a*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Deposit event with depositor address, depositor_id (or*'
  prefs: []
  type: TYPE_NORMAL
- en: '*deposit number), and deposit_amount as attributes*'
  prefs: []
  type: TYPE_NORMAL
- en: '273'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 7 programming Smart ContraCt with Solidity
  prefs: []
  type: TYPE_NORMAL
- en: '*function deposit(uint deposit_id) public payable {*'
  prefs: []
  type: TYPE_NORMAL
- en: '*emit Deposit(msg.sender, deposit_id, msg.value); //emit*'
  prefs: []
  type: TYPE_NORMAL
- en: '*a Depositor event with sender address, positor_id, and*'
  prefs: []
  type: TYPE_NORMAL
- en: '*depositor_amount equal to the ether transferred in the*'
  prefs: []
  type: TYPE_NORMAL
- en: '*transaction.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*}*'
  prefs: []
  type: TYPE_NORMAL
- en: '*}*'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, a snippet of the DepositEvent class is defined. In the
  prefs: []
  type: TYPE_NORMAL
- en: class, a Deposit event is defined globally. There is a function deposit that
  prefs: []
  type: TYPE_NORMAL
- en: takes in a deposit_id as input and emits an event with depositor_address,
  prefs: []
  type: TYPE_NORMAL
- en: deposit_id, and deposit_amount. The depositor_address and deposit_
  prefs: []
  type: TYPE_NORMAL
- en: amount are obtained from a special variable msg directly.
  prefs: []
  type: TYPE_NORMAL
- en: Event is a messaging method that allows smart contracts to communicate
  prefs: []
  type: TYPE_NORMAL
- en: with external programs. Blockchain is very self-confined, and smart contracts
  prefs: []
  type: TYPE_NORMAL
- en: cannot access external programs directly. In this case, events become a
  prefs: []
  type: TYPE_NORMAL
- en: messaging mechanism between external programs and smart contracts.
  prefs: []
  type: TYPE_NORMAL
- en: Since events are in transaction logs that are part of the state of Ethereum,
  prefs: []
  type: TYPE_NORMAL
- en: emitting events will cause gas consumption and should be carefully designed.
  prefs: []
  type: TYPE_NORMAL
- en: '**Module 4: Security**'
  prefs: []
  type: TYPE_NORMAL
- en: Security is the most important aspect of Solidity programming.
  prefs: []
  type: TYPE_NORMAL
- en: In Chapter [8](https://doi.org/10.1007/978-1-4842-8164-2_8), we have one whole
    chapter describing blockchain security.
  prefs: []
  type: TYPE_NORMAL
- en: In this module, we will discuss security with Solidity programming.
  prefs: []
  type: TYPE_NORMAL
- en: '**Function Vulnerabilities**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Function Visibility Error**'
  prefs: []
  type: TYPE_NORMAL
- en: This is a vulnerability where function visibility is not specified, or specified
  prefs: []
  type: TYPE_NORMAL
- en: as public when it is supposed to be private.
  prefs: []
  type: TYPE_NORMAL
- en: '274'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 7 programming Smart ContraCt with Solidity
  prefs: []
  type: TYPE_NORMAL
- en: In earlier versions of the Solidity compiler, the visibility of a function is
  prefs: []
  type: TYPE_NORMAL
- en: default to public.
  prefs: []
  type: TYPE_NORMAL
- en: Functions should be properly specified as external, public, internal, or
  prefs: []
  type: TYPE_NORMAL
- en: private.
  prefs: []
  type: TYPE_NORMAL
- en: One example of this vulnerability is shown in the following. The
  prefs: []
  type: TYPE_NORMAL
- en: first function has an input check and calls the second function. The first
  prefs: []
  type: TYPE_NORMAL
- en: function is declared as public, and it needs to be called by the client
  prefs: []
  type: TYPE_NORMAL
- en: application with input from users. The second function has a vulnerability
  prefs: []
  type: TYPE_NORMAL
- en: as it is declared as public but sends out funds without checking the validity
  prefs: []
  type: TYPE_NORMAL
- en: of the senders.
  prefs: []
  type: TYPE_NORMAL
- en: pragma solidity ^0.4.24;
  prefs: []
  type: TYPE_NORMAL
- en: contract HashForEther {
  prefs: []
  type: TYPE_NORMAL
- en: function withdrawWinnings() public {
  prefs: []
  type: TYPE_NORMAL
- en: // Winner if the last 8 hex characters of the
  prefs: []
  type: TYPE_NORMAL
- en: address are 0\.
  prefs: []
  type: TYPE_NORMAL
- en: require(uint32(msg.sender) == 0);
  prefs: []
  type: TYPE_NORMAL
- en: _sendWinnings();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: function _sendWinnings() public { // security error. This
  prefs: []
  type: TYPE_NORMAL
- en: function should be declared as private
  prefs: []
  type: TYPE_NORMAL
- en: msg.sender.transfer(this.balance);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: To fix this vulnerability, simply declare the second function to be
  prefs: []
  type: TYPE_NORMAL
- en: private.
  prefs: []
  type: TYPE_NORMAL
- en: '275'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 7 programming Smart ContraCt with Solidity
  prefs: []
  type: TYPE_NORMAL
- en: '**Vulnerability: Function Call Return Value Not Checked**'
  prefs: []
  type: TYPE_NORMAL
- en: This is a vulnerability where the function call value is not checked. When
  prefs: []
  type: TYPE_NORMAL
- en: a function is called and returns an error, the subsequent program still
  prefs: []
  type: TYPE_NORMAL
- en: executes. It is important to check return values and exceptions and process
  prefs: []
  type: TYPE_NORMAL
- en: the return value accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: '**Vulnerability: Ether Withdraw Operation Not Protected**'
  prefs: []
  type: TYPE_NORMAL
- en: This is a serious vulnerability. It can happen in many cases. A
  prefs: []
  type: TYPE_NORMAL
- en: withdraw function should be protected with many factors. Firstly, the
  prefs: []
  type: TYPE_NORMAL
- en: visibility of the function should be right. Secondly, the input addresses
  prefs: []
  type: TYPE_NORMAL
- en: need to be checked to make sure the sender has the authority to withdraw
  prefs: []
  type: TYPE_NORMAL
- en: the funds. Furthermore, the constructor code will need to be protected.
  prefs: []
  type: TYPE_NORMAL
- en: The constructor function runs in the runtime bytecode and can be called
  prefs: []
  type: TYPE_NORMAL
- en: by a hacker to execute the code.
  prefs: []
  type: TYPE_NORMAL
- en: '**Vulnerability: Self-Destruction Functions**'
  prefs: []
  type: TYPE_NORMAL
- en: This is a vulnerability in which a user or hacker can call a function to
  prefs: []
  type: TYPE_NORMAL
- en: destroy the functionality of a smart contract and make it unrecoverable.
  prefs: []
  type: TYPE_NORMAL
- en: This happened with the famous parity “I accidentally killed it” bug where
  prefs: []
  type: TYPE_NORMAL
- en: an anonymous user called a "kill" function in a parity multisign wallet
  prefs: []
  type: TYPE_NORMAL
- en: component and destroyed the component. The vulnerability caused a total
  prefs: []
  type: TYPE_NORMAL
- en: of 513,774.16 Ether inaccessible to the asset owners. In order to prevent this
  prefs: []
  type: TYPE_NORMAL
- en: from happening, the use of kill function, denouncing ownership function,
  prefs: []
  type: TYPE_NORMAL
- en: and destruct function should be kept minimum unless it is absolutely
  prefs: []
  type: TYPE_NORMAL
- en: needed. The self-destruction functions include suicide or selfdestruct
  prefs: []
  type: TYPE_NORMAL
- en: function.
  prefs: []
  type: TYPE_NORMAL
- en: // This is a selfdestruct function that will remove the
  prefs: []
  type: TYPE_NORMAL
- en: contract and send the remaining asset to the sender address
  prefs: []
  type: TYPE_NORMAL
- en: pragma solidity ^0.4.22;
  prefs: []
  type: TYPE_NORMAL
- en: '276'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 7 programming Smart ContraCt with Solidity
  prefs: []
  type: TYPE_NORMAL
- en: contract SimpleSuicide {
  prefs: []
  type: TYPE_NORMAL
- en: function sudicideAnyone() {
  prefs: []
  type: TYPE_NORMAL
- en: selfdestruct(msg.sender);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '**Vulnerability: Use of Solidity Deprecated Functions**'
  prefs: []
  type: TYPE_NORMAL
- en: Some of the functions in the older Solidity versions are deprecated and
  prefs: []
  type: TYPE_NORMAL
- en: replaced with new ones as shown in Figur[e 7-5](#p288). When doing the compilation,
    watch the warnings and replace the deprecated ones with the new ones.
  prefs: []
  type: TYPE_NORMAL
- en: '***Figure 7-5\.** Deprecated functions in Solidity*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Vulnerability: Delegatecall to Untrusted Callee**'
  prefs: []
  type: TYPE_NORMAL
- en: Solidity supports delegatecall function that will call another smart contract
  prefs: []
  type: TYPE_NORMAL
- en: with the same execution context of the calling contract. This means that
  prefs: []
  type: TYPE_NORMAL
- en: msg.sender and msg.value are the same for the caller and callee. If the callee
  prefs: []
  type: TYPE_NORMAL
- en: address is not trusted, it will cause security issues with the calling contract.
  prefs: []
  type: TYPE_NORMAL
- en: '277'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 7 programming Smart ContraCt with Solidity
  prefs: []
  type: TYPE_NORMAL
- en: '**Vulnerability: DOS with Failed Function Calls**'
  prefs: []
  type: TYPE_NORMAL
- en: External calls may fail, and it should not halt the rest of the execution steps.
  prefs: []
  type: TYPE_NORMAL
- en: Developers should avoid combining multiple calls in a single transaction.
  prefs: []
  type: TYPE_NORMAL
- en: Contract functions should have logic to process failed calls. When
  prefs: []
  type: TYPE_NORMAL
- en: sending funds to users, it is best to let users “pull” the funds by initiating
    a
  prefs: []
  type: TYPE_NORMAL
- en: transaction rather than using smart contracts to push the asset to a group
  prefs: []
  type: TYPE_NORMAL
- en: of users.
  prefs: []
  type: TYPE_NORMAL
- en: '**Vulnerability: Race Conditions and Transaction**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Order Dependence**'
  prefs: []
  type: TYPE_NORMAL
- en: Blockchain does not execute transactions in the order in which they are
  prefs: []
  type: TYPE_NORMAL
- en: submitted. Transactions are packed by miners, and miners would like to
  prefs: []
  type: TYPE_NORMAL
- en: package transactions with higher gas fees. It will cause issues for some
  prefs: []
  type: TYPE_NORMAL
- en: smart contract functions when there are dependencies for function calls
  prefs: []
  type: TYPE_NORMAL
- en: in different smart contracts. For example, ERC20 fungible tokens have
  prefs: []
  type: TYPE_NORMAL
- en: an “approve” function to specify another user to use a certain amount
  prefs: []
  type: TYPE_NORMAL
- en: of token. Then there is a transfer function that can transfer funds not
  prefs: []
  type: TYPE_NORMAL
- en: exceeding the approved amount. Suppose Alice approves funds to Bob at
  prefs: []
  type: TYPE_NORMAL
- en: the amount of m and then changes the approval amount to n, and during
  prefs: []
  type: TYPE_NORMAL
- en: this time, Bob sends two transactions to transfer funds at amounts of n
  prefs: []
  type: TYPE_NORMAL
- en: and m, respectively. Since the transactions are not in the exact order, it is
  prefs: []
  type: TYPE_NORMAL
- en: possible that Bob first transfer falls between Alice approval 1 and approval
  prefs: []
  type: TYPE_NORMAL
- en: 2, while Bob transfer 2 falls after approval 2\. This will allow Bob to retrieve
  prefs: []
  type: TYPE_NORMAL
- en: the m+n token rather than the expected amount of either n or m.
  prefs: []
  type: TYPE_NORMAL
- en: Fixing race conditions in function calls is not easy. One way to ensure
  prefs: []
  type: TYPE_NORMAL
- en: function dependency is to use secret salt and hash methods. The sender
  prefs: []
  type: TYPE_NORMAL
- en: will have a secret salt and produce a hash of the salt. Then the sender
  prefs: []
  type: TYPE_NORMAL
- en: of the function will call the approved function with a hash and address.
  prefs: []
  type: TYPE_NORMAL
- en: The smart contract will save the hash to the blockchain. The sender
  prefs: []
  type: TYPE_NORMAL
- en: '278'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 7 programming Smart ContraCt with Solidity
  prefs: []
  type: TYPE_NORMAL
- en: then sends the salt to the receiver. The receiver then calls the request
  prefs: []
  type: TYPE_NORMAL
- en: function with a secret salt. The smart contract computes the hash from
  prefs: []
  type: TYPE_NORMAL
- en: the salt and compares it with the one saved by the smart contract. If it
  prefs: []
  type: TYPE_NORMAL
- en: matches, the request function will process the receiver’s request. If not,
  prefs: []
  type: TYPE_NORMAL
- en: it will be rejected. This ensures one-on-one mapping of two subsequent
  prefs: []
  type: TYPE_NORMAL
- en: function calls.
  prefs: []
  type: TYPE_NORMAL
- en: '**Vulnerability: Assert Violation**'
  prefs: []
  type: TYPE_NORMAL
- en: Assert() is a function call to ensure the statement to be evaluated is always
  prefs: []
  type: TYPE_NORMAL
- en: true. This is different from the require() function that is used to check the
  prefs: []
  type: TYPE_NORMAL
- en: condition of the statement. Assert() result should never be false. If assert()
  prefs: []
  type: TYPE_NORMAL
- en: function returns a false result, it means that there is a serious bug in
  prefs: []
  type: TYPE_NORMAL
- en: the code.
  prefs: []
  type: TYPE_NORMAL
- en: '**Vulnerability: Cross Contract Call Enters into a Loop**'
  prefs: []
  type: TYPE_NORMAL
