- en: 'Part III: Ethereum in Depth'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous part, I introduced you to the concepts and tools for Ethereum
    smart contract and dapp development. In the next several chapters, we will dive
    deeper into Ethereum. We will look into how smart contract data and states are
    stored in the Ethereum blockchain and how smart contract developers could make
    use of such data. We will also look into best practices to secure smart contracts,
    which is a major issue the community faces today. Finally, we will review the
    Ethereum road map on what’s coming for developers.
  prefs: []
  type: TYPE_NORMAL
- en: 9. Inside Ethereum
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By Tim McCallum
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapters, you learned how to interact with the Ethereum blockchain
    from the outside as a client. The chapters covered topics such as executing transactions,
    developing and deploying smart contracts, and developing dapps using tools like
    the web3 library. However, to truly understand how Ethereum works and perhaps
    modify its behavior for your own purposes, we will need to look deeper beneath
    the external interface of the blockchain platform.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I deconstruct Ethereum to provide you with an understanding
    of its data storage layer, and I introduce the concept of blockchain state. Also,
    I cover the theory behind the Patricia trie data structure and demonstrate Ethereum’s
    concrete implementation of tries using Google’s LevelDB database. From this point,
    you will be able to execute transactions and explore how Ethereum’s state responds
    to activities such as transactions.
  prefs: []
  type: TYPE_NORMAL
- en: What Is Blockchain State?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Bitcoin’s *state* is represented by its global collection of unspent transaction
    outputs (UTXOs). The transfer of value in Bitcoin is actioned through transactions.
    More specifically, a Bitcoin user can spend one or more UTXOs by creating a transaction
    and adding one or more UTXOs as the transaction’s input.
  prefs: []
  type: TYPE_NORMAL
- en: A full explanation of UTXOs is beyond the scope of this chapter. However, I
    mention UTXOs in the following paragraphs to point out a fundamental difference
    between Bitcoin and Ethereum. Specifically, the following two Bitcoin examples
    will provide contrast between Bitcoin’s UTXO model and Ethereum’s world state.
  prefs: []
  type: TYPE_NORMAL
- en: First, Bitcoin UTXOs cannot be partially spent. If a Bitcoin user spends 0.5
    Bitcoin (using her only UTXO, which is worth 1 Bitcoin), the user has to deliberately
    self-address (send herself ) 0.5 Bitcoins (BTC) in return change ([Figure 9.1](ch09.xhtml#ch09fig1)).
    If the user doesn’t send change, she will lose the 0.5 Bitcoin change to the Bitcoin
    miner who mines her transaction.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 9.1** Sending a partial Bitcoin'
  prefs: []
  type: TYPE_NORMAL
- en: Second, at the most fundamental level, Bitcoin does not maintain user account
    balances. With Bitcoin, a user simply holds the private keys to one or more UTXOs
    at any given point in time ([Figure 9.2](ch09.xhtml#ch09fig2)). Digital wallets
    make it seem like the Bitcoin blockchain automatically stores and organizes user
    account balances and so forth. This is not the case.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 9.2** Computing account balance for Bitcoin'
  prefs: []
  type: TYPE_NORMAL
- en: A user account balance in Bitcoin is an abstract notion. Realistically, a user’s
    account balance is the sum total of each individual UTXO (for which that user
    holds the corresponding private key), as shown in [Figure 9.3](ch09.xhtml#ch09fig3).
    The key that a user holds can be used to individually sign/spend each of the UTXOs.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f09_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 9.3** A Bitcoin wallet aggregates UTXOs to show account balances.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The UTXO system in Bitcoin works well, in part, because digital wallets are
    able to facilitate most of the tasks associated with transactions. This includes
    but is not limited to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Handling UTXOs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing keys
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting transaction fees
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing return change addresses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aggregating UTXOs (to show available, pending, and total balances)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interestingly, a backup of a nondeterministic wallet (like the Bitcoin core
    wallet pictured in [Figure 9.3](ch09.xhtml#ch09fig3)) provides only a snapshot
    of the UTXOs (at that point in time). If a user performs any transactions (sending
    or receiving), the original backup that the user made will be out-of-date.
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarize, you now know the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The Bitcoin blockchain does not hold account balances.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bitcoin wallets hold keys to UTXOs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If included in a transaction, an entire UTXO is spent (in some cases partially
    received as change in the form of a new UTXO).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, let’s look into the Ethereum blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum State
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In contrast to the previous information, the Ethereum world state is able to
    manage account balances and more. The state of Ethereum is not an abstract concept.
    It is part of Ethereum’s base protocol layer. Ethereum is a transaction-based
    state machine; in other words, it’s a technology on which all transaction-based
    state machine concepts can be built.
  prefs: []
  type: TYPE_NORMAL
- en: Storing state data on each Ethereum node allows for light clients that do not
    necessarily need to download the entire blockchain to function. Light clients
    just need access to the state database on a node to get the current state of the
    entire system and send in transactions to alter the state. That enables a whole
    range of applications to be developed on the Ethereum blockchain efficiently.
    Without stored data on nodes and light clients, most smart contracts or dapp use
    cases would be impossible.
  prefs: []
  type: TYPE_NORMAL
- en: For example, an interesting idea mentioned in the Ethereum white paper is the
    notion of a savings account. In this scenario, two users (perhaps a husband and
    wife, or business partners) can each withdraw 1 percent of the account’s total
    balance per day. This idea is mentioned in the “Further Applications” section
    of the white paper, but it’s interesting because it, in theory, could be implemented
    as part of Ethereum’s base protocol layer (as opposed to having to be written
    as part of a second-layer solution or third-party wallet). You may recall the
    discussion about Bitcoin UTXOs earlier in this chapter. UTXOs are blind to blockchain
    data, and as discussed, the Bitcoin blockchain does not actually store a user’s
    account balance. For this reason, the base protocol layer of Bitcoin is far less
    likely (or perhaps unable) to implement any sort of daily spend limits.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s look into the actual structure of the Ethereum state data store.
  prefs: []
  type: TYPE_NORMAL
- en: Data Structure
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s start at the beginning. As with all other blockchains, the Ethereum blockchain
    begins life at its own genesis block. From this point (genesis state at block
    0) onward, activities such as transactions, contracts, and mining will continually
    change the state of the Ethereum blockchain. In Ethereum, an example of this is
    an account balance (stored in the state trie, as shown in [Figure 9.4](ch09.xhtml#ch09fig4)),
    which changes every time a transaction, in relation to that account, takes place.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f09_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 9.4** The internal structure of data storage in an Ethereum node'
  prefs: []
  type: TYPE_NORMAL
- en: Importantly, data such as account balances is not stored directly in the blocks
    of the Ethereum blockchain. Only the root node hashes of the transaction trie,
    state trie, and receipts trie are stored directly in the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: You will also notice, from [Figure 9.4](ch09.xhtml#ch09fig4), that the root
    node hash of the storage trie (where all of the smart contract data is kept) actually
    points to the state trie, which in turn points to the blockchain. I will zoom
    in and cover all of this in more detail soon.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two vastly different types of data in Ethereum: permanent data and
    ephemeral data. An example of permanent data is a transaction. Once a transaction
    has been fully confirmed, it is recorded in the transaction trie and never altered.
    An example of ephemeral data is the balance of a particular Ethereum account address.
    The balance of an account address is stored in the state trie and is altered whenever
    transactions against that particular account occur. It makes sense that permanent
    data, such as mined transactions, and ephemeral data, such as account balances,
    should be stored separately. Ethereum uses trie data structures (as broadly outlined
    earlier) to manage data. The next section will take a detour and provide a quick
    overview on tries.'
  prefs: []
  type: TYPE_NORMAL
- en: Trie (or Tree)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *trie* (or tree) is a well-known data structure that is used for storing sequences
    of characters. Ethereum exclusively uses what is known as the “practical algorithm
    to retrieve information coded in alphanumeric” (Patricia) trie. The main advantage
    of the Patricia trie is its compact storage. We will now analyze the inner workings
    of the standard (more traditional) trie versus the Patricia trie.
  prefs: []
  type: TYPE_NORMAL
- en: Standard Trie
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Figure 9.5](ch09.xhtml#ch09fig5) shows the structure of a standard trie that
    stores words. Each character in the word is a node in the tree, and each word
    is terminated by a special null pointer.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f09_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 9.5** A standard trie storing two words. The special character \0
    represents the null pointer.'
  prefs: []
  type: TYPE_NORMAL
- en: Rules for Adding a Word to the Trie
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We follow the search path for the word we are adding. If we encounter a null
    pointer, we create a new node. When we have finished adding our word, we create
    a null pointer (terminator). When adding a (shorter) word that is contained in
    another (longer) word, we just exhaust all of the characters and then add a null
    pointer (terminator).
  prefs: []
  type: TYPE_NORMAL
- en: Rules for Deleting a Word from the Trie
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We search for a leaf (the end of a branch) on the trie that represents the string
    (which we want to delete). We then start deleting all nodes from the leaf back
    to the root of the trie—unless we hit a node with more than one child; in this
    case, we stop.
  prefs: []
  type: TYPE_NORMAL
- en: Rules for Searching for a Word in the Trie
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We examine each of the characters in the string for which we are searching and
    follow the trie for as long as it provides our path (in the right sequence). If
    we encounter a null pointer before exhausting all the characters in the string
    (which we are searching for), then we can conclude that the string is not stored
    in the trie. On the contrary, if we reach a leaf (the end of a branch) and that
    path (from the leaf back to the root of the trie) represents our string, we conclude
    that the string is stored in the trie.
  prefs: []
  type: TYPE_NORMAL
- en: Patricia Trie
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Figure 9.6](ch09.xhtml#ch09fig6) shows the structure of a Patricia trie that
    stores words. The storage is more compact than the standard trie. Each word is
    terminated by a special null pointer.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f09_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 9.6** A Patricia trie storing two words'
  prefs: []
  type: TYPE_NORMAL
- en: Rules for Adding a Word to the Patricia Trie
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Patricia tries group all common characters into a single branch. Any unusual
    characters will constitute a new branch in the path. When adding a word to a Patricia
    trie, we exhaust all the characters and then add the null pointer (terminator),
    as shown in [Figure 9.7](ch09.xhtml#ch09fig7).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f09_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 9.7** Adding a word (`*wooden*`) to the Patricia trie'
  prefs: []
  type: TYPE_NORMAL
- en: Rules for Deleting a Word from the Patricia Trie
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This is the same as with a traditional trie, except for when deleting nodes
    (from the leaf back to the root), we must ensure that all parent nodes must be
    in possession of at least two child nodes. It is okay for a single child node
    to just have characters and a null pointer (this occurs in [Figure 9.7](ch09.xhtml#ch09fig7),
    at the end of every word). It is also okay for a single node to just have a null
    pointer (this occurs if a shorter word is contained in a longer word). See [Figure
    9.7](ch09.xhtml#ch09fig7), which illustrates how *wood* and *wooden* coexist in
    the same trie.
  prefs: []
  type: TYPE_NORMAL
- en: Importantly, when deleting from a trie, a path cannot be left with a parent
    node that connects to just a single child node. If this occurs (when deleting,
    we need to concatenate the appropriate characters to resolve this). This is illustrated
    in [Figure 9.8](ch09.xhtml#ch09fig8) (where we delete the word from the trie).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f09_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 9.8** Deleting a word (*word*) from the Patricia trie and reorganizing
    it'
  prefs: []
  type: TYPE_NORMAL
- en: Rules for Searching for a Word in the Patricia Trie
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The rules for searching the Patricia trie are the same as for searching the
    standard trie.
  prefs: []
  type: TYPE_NORMAL
- en: Similarities between the Trie and Patricia Trie
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The runtime “O” for adding is O(mN), where “m” is the length of the string we
    are adding and “N” is the size of the available alphabet.
  prefs: []
  type: TYPE_NORMAL
- en: The runtime for deleting is O(mN), where “m” is the length of the string we
    want to delete and “N” is again the size of the available alphabet.
  prefs: []
  type: TYPE_NORMAL
- en: The runtime for searching is O(m), where “m” is the length of the string we
    are searching for.
  prefs: []
  type: TYPE_NORMAL
- en: Main Difference between the Trie and Patricia Trie
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The main advantage of using the Patricia trie is in relation to storage.
  prefs: []
  type: TYPE_NORMAL
- en: The storage requirement “O” for the standard trie is O(MN), where “M” is the
    total length of all strings in the trie and “N” is the size of the available alphabet.
  prefs: []
  type: TYPE_NORMAL
- en: The storage requirement “O” for the Patricia trie is O(nN+M), where “n” is the
    number of strings stored in the Patricia trie, “N” is the size of the available
    alphabet, and “M” is the total length of all strings in the trie.
  prefs: []
  type: TYPE_NORMAL
- en: In short, you will have noticed a marked difference in the depth of the tries.
    The Patricia trie is less deep (shallower). This is because of the Patricia trie’s
    ability to group common characters (and concatenate null pointers to leaves).
  prefs: []
  type: TYPE_NORMAL
- en: Modified Merkle Patricia Trie
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the Ethereum state database, the data is stored in a modified Merkle Patricia
    trie, which means the root node of the trie is a hash of the data in its leaves.
    This design makes the state database on each node resistant to tampering, just
    like the blockchain itself.
  prefs: []
  type: TYPE_NORMAL
- en: Every function (put, update, and delete) performed on a trie in Ethereum utilizes
    a deterministic cryptographic hash. Further, the unique cryptographic hash of
    a trie’s root node can be used as evidence that the trie has not been tampered
    with.
  prefs: []
  type: TYPE_NORMAL
- en: For example, any changes to a trie’s data, at any level (such as increasing
    an account’s balance), will completely change the root hash. This cryptographic
    feature provides an opportunity for light clients (devices that do not store the
    entire blockchain) to quickly and reliably query the blockchain; in other words,
    does account 0x…4857 have enough funds to complete this purchase at block height
    5044866?
  prefs: []
  type: TYPE_NORMAL
- en: Trie Structure in Ethereum
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s look at the state, storage, and transaction tries in a bit more depth.
  prefs: []
  type: TYPE_NORMAL
- en: 'State Trie : The One and Only'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There is one, and one only, global state trie in Ethereum. This global state
    trie is constantly updated. The state trie contains a key-value pair for every
    account that exists on the Ethereum network.
  prefs: []
  type: TYPE_NORMAL
- en: The *key* is a single 160-bit identifier (the address of an Ethereum account).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The *value* in the global state trie is created by encoding the following account
    details of an Ethereum account (using the recursive-length prefix [RLP] encoding
    method): nonce, balance, storageRoot, codeHash.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The state trie’s root node (a hash of the entire state trie at a given point
    in time) is used as a secure and unique identifier for the state trie; the state
    trie’s root node is cryptographically dependent on all internal state trie data.
    The state trie’s root node is stored in the Ethereum block header corresponding
    to the time when the state trie was updated (see [Figure 9.9](ch09.xhtml#ch09fig9))
    and can be queried from the block ([Figure 9.10](ch09.xhtml#ch09fig10)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f09_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 9.9** Relationship between the state trie (LevelDB implementation
    of a Merkle Patricia trie) and an Ethereum block'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f09_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 9.10** Showing the trie roots'
  prefs: []
  type: TYPE_NORMAL
- en: 'Storage Trie : Where the Contract Data Lives'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A storage trie is where all the contract data lives. Each Ethereum account has
    its own storage trie. A Keccak 256-bit hash of the storage trie’s root node is
    stored as the storageRoot value in the global state trie ([Figure 9.11](ch09.xhtml#ch09fig11)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f09_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 9.11** State trie — Keccak 256-bit hash of the state trie’s root node
    stored as the stateRoot value in a given block'
  prefs: []
  type: TYPE_NORMAL
- en: 'Transaction Trie : One per Block'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each Ethereum block has its own separate transaction trie. A block contains
    many transactions. The order of the transactions in a block is of course decided
    by the miner who assembles the block. The path to a specific transaction in the
    transaction trie is via the RLP encoding of the index of where the transaction
    sits in the block. Mined blocks are never updated; the position of the transaction
    in a block never changes. This means that once you locate a transaction in a block’s
    transaction trie, you can return to the same path over and over to retrieve the
    same result. [Figure 9.12](ch09.xhtml#ch09fig12) shows how the transaction trie’s
    root hash is stored in an Ethereum block header.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f09_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 9.12** The transaction trie stores data about each transaction in
    a block.'
  prefs: []
  type: TYPE_NORMAL
- en: Concrete Examples of Tries in Ethereum
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The main Ethereum clients use two different database software solutions to store
    their tries. Ethereum’s Rust client, Parity, uses RocksDB. Ethereum’s Go, C++,
    and Python clients all use LevelDB.
  prefs: []
  type: TYPE_NORMAL
- en: RocksDB is out of scope for this book. Let’s explore how three out of the four
    major Ethereum clients utilize LevelDB.
  prefs: []
  type: TYPE_NORMAL
- en: LevelDB is an open source Google key-value storage library that provides, among
    other things, forward and backward iterations over data, ordered mapping from
    string keys to string values, custom comparison functions, and automatic compression.
    The data is automatically compressed using Snappy, an open source Google compression/decompression
    library. While Snappy does not aim for maximum compression, it aims for very high
    speeds. LevelDB is an important storage and retrieval mechanism that manages the
    state of the Ethereum network. As such, LevelDB is a dependency for the most popular
    Ethereum clients (nodes) such as go-ethereum, cpp-ethereum, and pyethereum.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: While the implementation of the trie data structure can be done on disk (using
    database software such as LevelDB), it is important to note that there is a difference
    between traversing a trie and simply looking at the flat key-value database.
  prefs: []
  type: TYPE_NORMAL
- en: To learn more, we have to access the data in LevelDB using the appropriate Patricia
    trie libraries. To do this, we will need an Ethereum installation (see [Chapter
    5](ch05.xhtml#ch05)). Once you have set up your Ethereum private network, you
    will be able to execute transactions and explore how Ethereum’s state responds
    to network activities such as transactions, contracts, and mining. In the next
    section, I will provide code examples and screen captures from an Ethereum private
    network.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing the Ethereum Database
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As mentioned previously, there are many Merkle Patricia tries (referenced in
    each block) within the Ethereum blockchain: state trie, storage trie, transaction
    trie, and receipts trie.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To reference a particular Merkle Patricia trie in a particular block, we need
    to obtain its root hash as a reference. The following commands allow us to obtain
    the root hashes of the state, transaction, and receipt tries in the genesis block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch09_images.xhtml#pro9_1)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want the root hashes of the latest block (instead of the genesis block),
    please use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch09_images.xhtml#pro9_2)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We will be using a combination of the `nodejs`, `level`, and `ethereumjs` commands
    (which implements Ethereum’s VM in JavaScript) to inspect the LevelDB database.
    The following commands will further prepare our environment (in Ubuntu Linux):'
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch09_images.xhtml#pro9_3)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Get the Data
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: From this point, running the following code will print a list of the Ethereum
    account keys (which are stored in the state root of your Ethereum private network).
    The code connects to Ethereum’s LevelDB database, enters Ethereum’s world state
    (using a stateRoot value from a block in the blockchain), and then accesses the
    keys to all accounts on the Ethereum private network ([Figure 9.13](ch09.xhtml#ch09fig13)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f09_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 9.13** Raw data read from the trie in LevelDB'
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch09_images.xhtml#pro9_4)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: Interestingly, accounts in Ethereum are added to the state trie only once a
    transaction has taken place (in relation to that specific account). For example,
    just creating a new account using `geth account new` will not include that account
    in the state trie, even after many blocks have been mined. However, if a successful
    transaction (one that costs gas and is included in a mined block) is recorded
    against that account, then and only then will that account appear in the state
    trie. This is clever logic that protects against malicious attackers continuously
    creating new accounts and bloating the state trie.
  prefs: []
  type: TYPE_NORMAL
- en: Decoding the Data
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You will have noticed that querying LevelDB returns encoded results. This is
    because Ethereum uses its own specially modified Merkle Patricia trie implementation
    when interacting with LevelDB. The Ethereum wiki provides information about the
    design and implementation of both Ethereum’s modified Merkle Patricia trie and
    RLP encoding. In short, Ethereum has extended the trie data structures described
    earlier. For example, the modified Merkle Patricia trie contains a method that
    can shortcut the descent (down the trie) through the use of an extension node.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Ethereum, a single modified Merkle Patricia trie node is one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An empty string (referred to as NULL)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An array that contains 17 items (referred to as a *branch*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An array that contains two items (referred to as a *leaf* )
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An array that contains two items (referred to as an *extension*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As Ethereum’s tries are designed and constructed with rigid rules, the best
    way to inspect them is through the use of computer code. The following example
    uses ethereum.js. The following code (when provided with a particular block’s
    stateRoot as well as an Ethereum account address) will return that account’s correct
    balance in a human-readable form ([Figure 9.14](ch09.xhtml#ch09fig14)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f09_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 9.14** The decoded results'
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch09_images.xhtml#pro9_5)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Read and Write the State LevelDB
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'So far, I have shown how to access the Ethereum state’s LevelDB database using
    JavaScript on a local node. If you are familiar with GO and can work with Ethereum
    source code, there is an easier way. You could just import the go-ethereum source
    code in GO and call its functions to read and even modify the LevelDB database.
    The write function will not only change the values in the nodes but also update
    the root hash to reflect the changes. Specifically, the functions are in the following
    source code file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch09_images.xhtml#pro9_6)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: It contains methods such as `GetBalance`, `AddBalance`, `SubBalance`, and `SetBalance`
    to operate on the account balances. However, changing the state LevelDB in this
    way will change the data on only one node and will likely cause this node to go
    out of sync with the rest of the nodes on the network. The right way to change
    the state is to follow how go-ethereum processes a transaction and records it
    on the blockchain. That is out of scope for this book.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, I demonstrated that Ethereum has the ability to manage its
    state. This clever up-front design has many advantages, allowing for light clients
    and many different kinds of dapps that do not need to run the entire blockchain.
    It is important to understand the inner workings of Ethereum to write great smart
    contracts and applications on the Ethereum platform.
  prefs: []
  type: TYPE_NORMAL
- en: 10. Blockchain Data Services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The previous chapter explained how the blockchain stores state data in block-based
    databases. The data is organized into a tree structure, and each block has a timestamp.
    This structure makes it easy to add new data (new blocks) and almost impossible
    to delete or change anything in old blocks, hence securing the blockchain data.
    However, while you can easily list each block’s content (i.e., transactions),
    it is hard to get longitudinal or aggregated views of the blockchain state. As
    a result, it is hard to search the blockchain data based on an address or specific
    actions performed by an address. Yet, many blockchain applications require the
    capability to search and analyze blockchain data.
  prefs: []
  type: TYPE_NORMAL
- en: A common design pattern for dapps is to call `view` functions in smart contracts
    to query data stored in the contract. However, such an approach is hard to scale
    since you need a full blockchain node to execute every `view` request, and the
    data query is limited by the data structure supported by the smart contract (i.e.,
    no SQL or JSON queries). By harvesting smart contract data into a data warehouse
    and enabling rich queries on the data warehouse, we could potentially build much
    more complex and scalable dapps.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I discuss how to build normalized databases for blockchain
    data so that they can be easily searched, analyzed, and browsed.
  prefs: []
  type: TYPE_NORMAL
- en: Blockchain Explorers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Almost every blockchain requires a data explorer so that users can search and
    browse transactions and account addresses on the blockchain. The blockchain explorers
    and the data services they provide are now part of standard infrastructure for
    every blockchain project.
  prefs: []
  type: TYPE_NORMAL
- en: For Bitcoin and compatible Bitcoin Cash (BCH) blockchains, there are many, including
    [https://explorer.bitcoin.com/btc](https://explorer.bitcoin.com/btc) and [https://btc.com/](https://btc.com/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the Ethereum blockchain, the most well-known one is [https://etherscan.io/](https://etherscan.io/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the EOS blockchain, there are [https://bloks.io/](https://bloks.io/) and
    [https://eospark.com/](https://eospark.com/), among others.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the CyberMiles blockchain, there is [https://www.cmttracking.io/](https://www.cmttracking.io/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each blockchain explorer provides information that is specific to its blockchain.
    For example, explorers for proof-of-work (PoW) blockchains like Bitcoin and Ethereum
    provide information such as hash rate and mining awards. Explorers for delegated
    proof-of-stake (PoS) blockchains like EOS and CyberMiles provide information such
    as block producer/validator nodes, voting power, and inflation awards. Explorers
    for smart contract platforms such as Ethereum, EOS, and CyberMiles provide information
    about smart contracts as well as assets held or issued by those smart contracts.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 10.1](ch10.xhtml#ch10fig1), [Figure 10.2](ch10.xhtml#ch10fig2), and
    [Figure 10.3](ch10.xhtml#ch10fig3) show screenshots from Etherscan. They provide
    insights into the global state, transactions, and smart contracts on the Ethereum
    blockchain. [Figures 10.4](ch10.xhtml#ch10fig4) and [10.5](ch10.xhtml#ch10fig5)
    illustrate how the CMTTracking web site provides delegated PoS information for
    the CyberMiles blockchain in real time. Such information is not applicable for
    the Ethereum blockchain, as Ethereum uses PoW mining for consensus.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 10.1** Etherscan front page with pricing information, mining information,
    and recent blocks'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 10.2** Etherscan page for an account and its transactions'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 10.3** Etherscan page for a smart contract that issues an ERC20 asset'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f10_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 10.4** CMTTracking page for CyberMiles validator nodes, their status,
    voting power, and compensation rate for people who stake in them'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f10_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 10.5** CMTTracking page showing validator information, stakes, and
    awards'
  prefs: []
  type: TYPE_NORMAL
- en: The explorer can also provide off-chain information related to the crypto assets
    on the blockchain. For example, it could provide the current pricing, trading
    volume, and market cap for the crypto assets. It could associate blockchain accounts
    and smart contracts with identities in the real world. It could monitor accounts
    belonging to key ecosystem players, such as exchanges and super nodes to detect
    and report trading signals. Those data services are of broad interest from users,
    traders, investors, and government regulators.
  prefs: []
  type: TYPE_NORMAL
- en: Those explorers, especially open source explorers, are also decentralized applications.
    Everyone with the source code can deploy their own explorer service. All the data
    is from the blockchain and other distributed sources, such as pricing aggregators.
    There is no single point of failure to shut down the explorer software.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 10.6](ch10.xhtml#ch10fig6) illustrates the overall architecture of
    a typical blockchain explorer. It consists of a harvester and a query interface.
    The harvester retrieves data from the blockchain, normalizes it, associates individual
    records with off-chain sources, and then saves the data in a database. The query
    interface provides a search engine and visualization tools to chart the data.
    It could also support API services for automated queries.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f10_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 10.6** The blockchain data explorer architecture view'
  prefs: []
  type: TYPE_NORMAL
- en: In the next sections, I will go into the technology stacks of the blockchain
    explorer software and discuss how you might improve existing explorers and develop
    specialized data services for your own applications.
  prefs: []
  type: TYPE_NORMAL
- en: Harvesting Data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The harvester application must have access to a full blockchain node. This is
    a node that contains the entire blockchain history data from the genesis block
    to the current head, not just the current account states. The node runs continuously
    and stays in sync with the blockchain’s current head block. I recommend you run
    and sync a full node yourself just for the harvester to use since the harvester’s
    data quality depends on the availability of the node. With your own node, the
    harvester could also potentially access the databases inside the blockchain software
    to directly extract data as opposed to going through the blockchain’s Remote Procedure
    Call (RPC) service interface. [Figure 10.7](ch10.xhtml#ch10fig7) illustrates the
    architecture of the harvester.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f10_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 10.7** The blockchain data harvester'
  prefs: []
  type: TYPE_NORMAL
- en: The key component in the harvester is a scheduler. It runs every few seconds
    to retrieve information from the blockchain node. The scheduler’s running time
    interval should be shorter than the block time to make sure that it always gets
    the latest block information. There are a variety of technology choices for the
    scheduler.
  prefs: []
  type: TYPE_NORMAL
- en: For Linux-based systems, you can use cron jobs to run the harvester application
    in fixed intervals.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the harvester is a Java application, you can use the Quartz Scheduler to
    run worker jobs at fixed intervals ([www.quartz-scheduler.org/](http://www.quartz-scheduler.org/)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the harvester is a node.js JavaScript application, you can use the egg.js
    framework for scheduled workloads ([https://eggjs.org/](https://eggjs.org/)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The scheduler runs a workload to retrieve data through the following means.
    You could build each of them into a connector that plugs into the harvester.
  prefs: []
  type: TYPE_NORMAL
- en: '*RPC connector to the node*: For Ethereum-compatible blockchains (e.g., CyberMiles),
    this is the RPC service available via port 8545\. This connector is typically
    done through a web3-compatible library.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Database connector to LevelDB*: This is used to directly access the databases
    on the node to read data that is potentially not available (or too cumbersome)
    from the RPC connector.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Web services connectors*: This is used to access external services such as
    pricing and market intelligence data from the CoinMarketCap API ([https://coinmarketcap.com/api/](https://coinmarketcap.com/api/)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Local database connectors*: This is used to access potentially proprietary
    data stored on the harvester’s local servers. Examples include proprietary databases
    that associate blockchain accounts with names, entities, and exchanges, including
    known criminals.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the data for each block is retrieved from the connectors, the harvester
    runs a data warehouse operation to combine, clean, and normalize the data. The
    data is organized into a set of logical schema and saved.
  prefs: []
  type: TYPE_NORMAL
- en: Structured results such as blocks, accounts, and transactions can be saved into
    a relational database with well-defined schema to ensure data integrity and query
    efficiency.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unstructured data such as events generated from smart contracts or bytecodes
    and hashes can be saved on NoSQL document stores such as MongoDB and Cassandra.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: The Google Blockchain ETL is a fully integrated blockchain data warehousing
    solution. It uses the Google Cloud Composer to orchestrate the harvesting process.
    It starts by making RPC requests to export blockchain data into comma-separated
    value (CSV) files and then loads the CSV files into the Google BigQuery table.
    The data can then be queried from BigQuery. The drawback, however, is that it
    is not a real-time solution. The data is harvested and ingested every 24 hours.
    And it relies on the Google Cloud infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: In the rest of this section, we look into various data types the harvester can
    collect and normalize for later queries.
  prefs: []
  type: TYPE_NORMAL
- en: Transactions and Accounts
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Most blockchain platforms provide standard RPC interfaces to get a list of transactions
    by block height. From there, the harvester can get details from each transaction,
    including the from/to accounts, transfer amount, gas amount, success status, and
    data associated with the transaction, such as smart contract function calls.
  prefs: []
  type: TYPE_NORMAL
- en: All those data elements are highly structured. They can be normalized into a
    relational database with account addresses acting as keys. For example, we could
    query all transactions from and to a specific account. The harvester application
    could perform internal data integrity checks by adding up all the transactions
    for each account and compare them with the account balances reported by the blockchain
    RPC.
  prefs: []
  type: TYPE_NORMAL
- en: Awards
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Most blockchains also “create” crypto tokens over time to award entities that
    run computer servers to secure the blockchain network. That is called *block awards*.
    For (PoW) blockchains, miners compete for the right to create the next block.
    The winner is awarded certain amounts of tokens. For various PoS blockchains,
    including delegated proof-of-stake (DPoS) blockchains, the validators or block
    producers were assigned duties to produce the next block while all other nodes
    validate and agree on the block’s content. The block award goes to the block producer
    or is divided according to stake or voting power.
  prefs: []
  type: TYPE_NORMAL
- en: The harvester needs to understand the algorithm to distribute block awards and
    creates database entries for such events indexed by account addresses. This data
    is also highly structural and relational. The harvester can verify its computed
    block awards distribution against account balances from the blockchain itself.
  prefs: []
  type: TYPE_NORMAL
- en: Off-Chain Identities
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A key use case of the blockchain data service is to understand the flow and
    exchange of digital assets. It is often important to associate a blockchain address
    with real-world entities that hold its private key. Since blockchain transactions
    are transparent, once you know the real identity of an address, it is often possible
    to figure out the identity of any addresses that ever transferred in and out of
    the known address.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: The only “anonymous” addresses on blockchain are miner accounts from PoW blockchains.
    However, once a miner starts to spend or exchange tokens with known addresses,
    the miner’s identity could be revealed.
  prefs: []
  type: TYPE_NORMAL
- en: The association between off-chain entities and blockchain addresses can come
    from multiple sources.
  prefs: []
  type: TYPE_NORMAL
- en: '*Data sharing agreement with crypto exchanges*: Most crypto exchanges require
    know your customer (KYC) checks for all their users. They have broad reach and
    knowledge of blockchain account address ownership as users deposit and withdraw
    tokens from or into their own addresses.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Data sharing agreement with initial coin offering (ICO) projects*: Many ICO
    projects conduct KYC checks for all their initial contributors. They have knowledge
    of each contributor’s source and deposit addresses.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Data sharing agreement with crypto payment processors and e-commerce merchants*:
    When users use crypto tokens to pay for goods and services in the real world,
    they leave a trail that we can follow (e.g., shipping address) to determine the
    identity of the accounts related to the real-world transaction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Data mining from social media*: When crypto projects run marketing campaigns,
    it often provides airdrops to followers on social media. Such airdrops require
    users’ addresses.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While the association between blockchain addresses and their off-chain owners’
    identities is structured and relational, the transactions linking one blockchain
    address to the next are not relational. The harvester could put the known address
    associations into a relational database and put connected transactions into a
    graph database, such as Neo4j, for further analysis and queries.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring known exchange addresses and large token holders’ addresses can help
    you predict market movements. For example, if a large account holder withdraws
    his stake at a DPoS block producer/validator and moves the tokens to an exchange
    account, you can anticipate increased selling pressure in the near future.
  prefs: []
  type: TYPE_NORMAL
- en: Inside Smart Contracts
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Ethereum-compatible blockchains are foremost smart contract platforms. The smart
    contract bytecode and their data structure can be arbitrary. Hence, smart contract
    data is unstructured, and it has been difficult to track the function execution
    and state changes in the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: Etherscan and other Ethereum-compatible blockchain explorers have long provided
    the ability to verify user/community-submitted smart contract source code against
    its bytecode on the blockchain. That helps the community verify that the source
    code and behavior of such contracts are indeed as advertised. But, this method
    provides no insights into the execution of functions and data inside the smart
    contracts.
  prefs: []
  type: TYPE_NORMAL
- en: A smart contract can write permanent data to the blockchain by declaring and
    then emitting an event. Emitted event log data will remain intact indefinitely,
    even if that particular smart contract and its global state have been completely
    removed using the previously mentioned opcode `0xff`, known as *self-destruct*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: The cost of writing to event logs is comparatively cheaper than writing to the
    blockchain’s global state. For example, it costs around 40,000 gas to write a
    single address and a single uint to the blockchain’s state. Alternatively, it
    costs only about 1,000 gas to write that same single address and uint to the blockchain’s
    event logs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example in Solidity (and Lity) shows how to define an event in
    your smart contract:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch10_images.xhtml#pro10_1)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, to declare the event, we simply type the word `event` followed
    by the name of the event. Then we pass in some data types and data names (in this
    case, the data types of `address` and `uint256`, which relate to the data names
    `endUser` and `amount`, respectively).
  prefs: []
  type: TYPE_NORMAL
- en: You will notice that we have deliberately specified, in this declaration, that
    the `endUser` data be indexed. Essentially, indexing a parameter allows for efficient
    searching later. Up to three parameters per event declaration can be indexed.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is wise to index data, such as account addresses, because it’s likely that
    you will be searching for information based on a particular account address. It
    is not a great idea to index other types of data, such as arbitrary amounts (i.e.,
    integers such as 1 or 10). It is completely unnecessary to include (in your event
    logs) any information that can be easily retrieved using predefined global variables
    or functions (e.g., `block.number`). Variables like `block.number` are included
    in standard transaction receipts by default. Let’s now emit the event declared
    earlier, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch10_images.xhtml#pro10_2)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the previous code, to emit an event, you simply type `emit`
    followed by the name of the event (which was declared in the previous code snippet).
    The data to be included in the event log is passed in during a function’s execution.
    The order in which data is passed into the `emit` command must match the order
    of the data, as shown in the event declaration.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows the entire smart contract, thereby providing context
    for the previous snippets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch10_images.xhtml#pro10_3)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, every time a user calls the `addPoints()` function on this contract, the
    `pointBalanceUpdated` event is emitted. The event is recorded in transaction receipts
    when you query a transaction via RPC. In fact, the web3 library provides an even
    easier way to query past events, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch10_images.xhtml#pro10_4)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The harvester receives JSON objects in the `events` array in the previous code.
    Each event JSON object looks like the following. Please note that I’m showing
    a more complex event from the Uniswap exchange deployed on the CyberMiles blockchain
    here, as opposed to the simple event described earlier.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch10_images.xhtml#pro10_5)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The JavaScript Object Notation (JSON) object can be deconstructed and saved
    into a relational database. Or, it can be saved directly into a JSON-aware document
    store for future queries. In this way, we can now harvest data directly from inside
    smart contract function calls.
  prefs: []
  type: TYPE_NORMAL
- en: In this next chapter, I will discuss how to directly harvest and track public
    data from smart contracts using a search engine approach.
  prefs: []
  type: TYPE_NORMAL
- en: Query Interface
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With the harvester in place, it is now possible to query the databases and provide
    data services to end users. A web-based UI can be built with any modern JavaScript
    user interface (UI) framework in front of those back-end data query services.
    The UI simply makes asynchronous data requests to the query interface.
  prefs: []
  type: TYPE_NORMAL
- en: But more interestingly, the query interface can be used as web services for
    all applications, not just for the blockchain explorer. For example, a dapp could
    query blockchain and generate charts or maps.
  prefs: []
  type: TYPE_NORMAL
- en: SQL Query
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can use SQL to query data from the relational databases the harvester builds.
    For example, it is now easy to find transactions that originate from a specific
    address, transactions that call a specific smart contract function, or transactions
    that block awards from a certain period of time.
  prefs: []
  type: TYPE_NORMAL
- en: JSON Query
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Perhaps more interestingly, you can query JSON objects directly from tools
    like Elasticsearch. Here is an example query for Uniswap exchange events in the
    smart contract event log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch10_images.xhtml#pro10_6)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The result would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch10_images.xhtml#pro10_7)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The Elasticsearch framework is a powerful search engine framework. We have found
    that it works well with blockchain data.
  prefs: []
  type: TYPE_NORMAL
- en: GraphQL
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another promising query interface for blockchain data is GraphQL, an open source
    query language and execution engine that originally was developed by Facebook.
    Leading implementations of GraphQL for blockchain data include TheGraph ([https://thegraph.com/](https://thegraph.com/))
    and Arcblock’s OCAP. In this section, let’s look into how TheGraph handles GraphQL
    queries. You could simply use its hosted service to query data from the public
    Ethereum blockchain or build your own using its open source software ([https://github.com/graphprotocol](https://github.com/graphprotocol)).
  prefs: []
  type: TYPE_NORMAL
- en: 'TheGraph provides, among many other things, a mechanism for a dapp to directly
    fetch and consume only the exact amount of data that the dapp actually requires,
    at any given time. Here is an example of a GraphQL query for TheGraph:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch10_images.xhtml#pro10_8)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Right off the bat, we can see that TheGraph is different from a traditional
    RESTful web service, in that this GraphQL query is not written in valid JSON.
    In fact, this GraphQL syntax is more lightweight than JSON because it does not
    have to specify whole `key:value` pairs, such as `{"event": true},` and so forth.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As examples, let’s use TheGraph to query Uniswap exchange smart contracts deployed
    on the Ethereum blockchain. To echo the earlier discussion in this chapter, TheGraph
    has already harvested event logs from Ethereum smart contracts and is making this
    data available for GraphQL queries. The previous GraphQL query translates to “Considering
    all of the Uniswap transactions to date, please give me only the name of the first
    event log that was ever emitted.” The response is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch10_images.xhtml#pro10_9)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The response is, in fact, valid JSON. You also will notice that this data is
    minimalistic. We can build on this first query by expanding the query to ask for
    not only the event but also the block number.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch10_images.xhtml#pro10_10)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The following result shows that the event was mined into block 6629139:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch10_images.xhtml#pro10_11)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Another way that we can achieve/confirm this is to return all the event logs,
    ordered by block number in ascending order.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch10_images.xhtml#pro10_12)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The query returns the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch10_images.xhtml#pro10_13)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As TheGraph demonstrates, GraphQL could be an important tool for providing blockchain
    data to end-user applications.
  prefs: []
  type: TYPE_NORMAL
- en: Google BigQuery
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As discussed earlier in this chapter, the Google Blockchain ETL project is a
    fully integrated data warehouse solution to ingest data from multiple blockchains
    into Google BigQuery tables. The data schema is designed to be unified across
    multiple blockchains. On all its blockchain data sets, the Google Blockchain ETL
    project supports the “double entry book” view that lists cryptocurrency transactions
    in traditional accounting formats.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can then make queries against the data set using any query language that
    BigQuery supports, including SQL-like queries. For example, the following query
    verifies an account balance is indeed the sum of its transactions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch10_images.xhtml#pro10_14)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The following query shows the frequency of different transaction fees on the
    Bitcoin blockchain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch10_images.xhtml#pro10_15)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The Google Blockchain ETL project provides a SQL-like cloud-based data warehousing
    solution for blockchain data. You can customize it to fit your own needs.
  prefs: []
  type: TYPE_NORMAL
- en: What’s Next?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: From a design perspective, let’s briefly think back to the days of the Simple
    Object Access Protocol (SOAP). While SOAP facilitated communication between disparate
    machines, it also relied on a set of predefined application data types that were
    essentially a permanent structure. Any changes (for example, updates to the software
    application or changes to the static configuration) would disrupt or render the
    previously working interoperability inoperable. Simply put, SOAP is a rigid protocol.
  prefs: []
  type: TYPE_NORMAL
- en: Representational State Transfer (REST), on the other hand, introduced essentially
    an architectural style. Systems that conformed to all six architectural constraints
    were considered RESTful. Further, web services that adhered to the architectural
    constraints were considered RESTful APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Still, in design mode, while it is tempting to explore ways in which we can,
    say, improve JSON compression (between the data provider and the dapp) and so
    forth, thinking like this takes us down the path of a protocol — a protocol that
    enforces that both sides have to agree on a predefined set of rules and that forces
    the client side (in this case the dapp) to perform additional work (unzipping,
    decoding, etc.).
  prefs: []
  type: TYPE_NORMAL
- en: Taking more of an architectural design viewpoint, would it be more effective,
    in terms of flexibility and interoperability, to focus on conventions as opposed
    to static configuration? We must remember that smart contract developers can create
    their own custom event logs that can emit one to many variables of various data
    types. Do we want to be setting up static configuration for each contract that
    is deployed in the blockchain network? Is human-driven static configuration sustainable?
    Can it be avoided altogether through the use of strong conventions and machine
    automation?
  prefs: []
  type: TYPE_NORMAL
- en: 'The next wave of blockchain architecture is rising, and right now there are
    big opportunities. I believe that upcoming blockchain data providers and explorer
    projects should do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Provide a mechanism to autonomously harvest a smart contract’s event log data
    based purely on an application binary interface (ABI) file and a smart contract’s
    address
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatically assign correct data field types (based solely on the smart contract’s
    ABI)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Require only a minimal amount of configuration and automated schema generation
    as per the previous point
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide sufficient internal querying, filtering, and logic to produce the most
    succinct responses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatically/dynamically offer autocomplete syntax to the calling software
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide a variety of default visual front-end display portals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide a library of built-in analytics (not only to explore trends, correlations,
    and so forth, but also to generate data sets for machine learning)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide a mechanism to interoperate with ubiquitous business software, file
    formats, and content management and software development applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is an exciting time. We have an unprecedented amount of information, documentation,
    and software available, as well as the appropriate decentralized infrastructure
    to test and deploy your projects on.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, I discussed how to build a blockchain data service. The blockchain
    explorers are pioneers in this space, but there is much more that can be done
    both on the harvesting side and on the query side. I believe that advanced off-chain
    storage and querying of blockchain data, especially smart contract execution data,
    is going to be a key component in the dapp ecosystem as well. In the next chapter,
    I will cover a new data service that provides real-time updates to public states
    of smart contracts. The data service is provided over a JavaScript library that
    complements web3.
  prefs: []
  type: TYPE_NORMAL
- en: 11. Smart Contract Search Engine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first-generation blockchain data browsers were focused primarily on providing
    snapshots of transaction details. For example, in the case of Bitcoin, they displayed
    verbatim records of structured data, as well as the results of valid transactions
    executed at the rigid base protocol layer.
  prefs: []
  type: TYPE_NORMAL
- en: The unprecedented rise of smart contracts, with customized data fields and unique
    internal programmable logic, has brought about the need for a new mechanism, one
    that can provide an easy way to search and visualize this new rich, unstructured
    blockchain data.
  prefs: []
  type: TYPE_NORMAL
- en: This mechanism is analogous to the rise of search engines while the Web grew
    in the 1990s. However, blockchain networks are unique in that they record all
    data in a time series of transactions. Smart contract data needs to be indexed
    and made available to both end users and machines in real time. Traditional web
    search engine technology is seldom used in the blockchain world because the World
    Wide Web and blockchain networks are fundamentally different. In this chapter,
    I will introduce an open source smart contract search engine. I will then discuss
    how to leverage it to power new types of dapps.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to the Smart Contract Search Engine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are many ways to build a search engine for blockchain data. In this chapter,
    we focus on the open source search engine built by Second State. It works with
    all Ethereum-compatible blockchains and is production ready. Most important, it
    serves as an example for the coding and implementation patterns associated with
    smart contract search engines.
  prefs: []
  type: TYPE_NORMAL
- en: The Second State smart contract search engine has the components illustrated
    in [Figure 11.1](ch11.xhtml#ch11fig1). You can get its complete source code and
    instructions from [https://github.com/second-state/smart-contract-search-engine](https://github.com/second-state/smart-contract-search-engine).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f11_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 11.1** The software components of a smart contract search engine'
  prefs: []
  type: TYPE_NORMAL
- en: An Elasticsearch instance that indexes application binary interfaces (ABIs)
    and public data fields from contracts against contract addresses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A full blockchain node that provides contract-related data as a standard JavaScript
    Object Notation–Remote Procedure Call (JSON-RPC) service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Python-based harvester script that extracts data from a blockchain node and
    then indexes and stores the data in Elasticsearch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Python-based web service that supports submitting contracts to index and Elasticsearch-like
    queries for real-time smart contract data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A JavaScript library, es-ss.js, that enables client applications to interact
    with the web services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is easy to start a new smart contract search engine using Docker, but it
    requires a few hours to fully index a production blockchain and then keep all
    the indexed contracts updated with each new block. To make it easier for developers
    to get started, Second State and the community run a few search engine instances
    for public use.
  prefs: []
  type: TYPE_NORMAL
- en: '*Ethereum mainnet*: [https://eth.search.secondstate.io/](https://eth.search.secondstate.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Ethereum Classic (ETC) mainnet*: [https://etc.search.secondstate.io/](https://etc.search.secondstate.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*CyberMiles mainnet*: [https://cmt.search.secondstate.io/](https://cmt.search.secondstate.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Second State DevChain*: [https://devchain.ss.search.secondstate.io/](https://devchain.ss.search.secondstate.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can load these URLs in a browser to see the current status of each of the
    public search engines. From there, you can search contract addresses that conform
    to specified contract interfaces (i.e., the ABI code) and then get up-to-date
    values in public fields for a contract address. For example, you could search
    all ERC20-compliant token contracts and see the symbol, supply, and values for
    each. You could also upload new ABIs to be indexed.
  prefs: []
  type: TYPE_NORMAL
- en: However, the most interesting use of a smart contract search engine is to serve
    as a data aggregator for new types of dapps. You can access the search engine
    functions programmatically from the es-ss.js library from your JavaScript application
    or web page. In the next section, we will look into a dapp that utilizes the search
    engine to interact with multiple smart contracts at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Started with a Smart Contract Search Engine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The best way to get hands-on experience with a smart contract search engine
    and the es-ss.js library is through the BUIDL integrated development environment
    (IDE). See [Chapter 3](ch03.xhtml#ch03) for more on the BUIDL IDE tool. The simple
    dapp I will showcase here displays a number of AccountBalanceDemo contracts deployed
    on the blockchain. Each of these contracts stores a number that can be changed
    by the user. The search engine tracks and displays the tally of those numbers
    inside the contracts in real time. [Figure 11.2](ch11.xhtml#ch11fig2) shows the
    dapp in action in a web browser.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f11_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 11.2** The AccountBalanceDemo dapp'
  prefs: []
  type: TYPE_NORMAL
- en: The following code listing shows the smart contract. The contract simply stores
    a number that can be updated by the `setAccountBalance()` function call. You can
    copy and paste it into BUIDL’s contract editor.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch11_images.xhtml#pro11_1)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Compile and deploy the smart contract by clicking the **Compile** and **Deploy
    to the chain** buttons. Make sure you give the account a name in the `_accountName`
    field before you click the **Deploy to the chain** button (see [Figure 11.3](ch11.xhtml#ch11fig3)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f11_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 11.3** Deploying a new contract to be managed by the search-based
    dapp'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the following code listing shows the HTML code for the dapp. You can copy
    and paste it into BUIDL’s dapp/HTML editor. It shows multiple AccountBalanceDemo
    contracts in a table and then the tally of their account balances in another table.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch11_images.xhtml#pro11_2)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The HTML tables are rendered by JavaScript. As discussed earlier, the JavaScript
    application can use the web3.js library to communicate with a blockchain node.
    It could also use the es-ss.js library to communicate with the search engine.
    Both web3.js and es-ss.js are initialized and made available in the JavaScript
    by BUIDL. The following code listing shows the JavaScript application. You should
    copy and paste it into BUIDL’s dapp/JavaScript editor. You should put the code
    outside of the `/* Don't modify */` section.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch11_images.xhtml#pro11_3)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: When the page loads, the `reload()` JavaScript function calls the Elasticsearch
    es-ss.js API to get all contracts with the AccountBalanceDemo type from the blockchain.
    It then computes the tally in the total variable. Notice that the current state,
    in other words, the account name and balance, of each contract is contained in
    the search result. We can simply display this information without having to interact
    with the slower blockchain nodes. The `reload()` function constructs HTML Document
    Object Model (DOM) elements to display those contract public data fields.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch11_images.xhtml#pro11_4)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The Update balance buttons in the table trigger the `setNumber()` JavaScript
    function, which in turn calls the contract’s `setAccountBalance()` function via
    web3\. The JavaScript then calls the `esss.updateStateOfContractAddress()` function
    to explicitly inform the search engine that this contract has changed and calls
    the `reload()` function to refresh data from the search engine.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch11_images.xhtml#pro11_5)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: Strictly speaking, the `updateStateOfContractAddress()` function call is not
    necessary, as the search engine works in near real time, and it automatically
    picks up the changes you just made in the `setAccountBalance()` function call
    via web3\. But, as a best practice for improved stability, we recommend you explicitly
    inform the search engine of changes you make whenever you can.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you can hit the **Run** button to run the dapp in BUIDL and use the
    Publish button to publish it on a public web site (see [Figure 11.2](ch11.xhtml#ch11fig2)).
  prefs: []
  type: TYPE_NORMAL
- en: The FairPlay Dapp Example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: FairPlay uses smart contracts to conduct automated prize draws that are fair
    and transparent. It allows anyone to create and participate in product giveaways
    and e-commerce marketing campaigns. It is a dapp running on the CyberMiles public
    blockchain, an Ethereum-compatible blockchain that features low-cost and fast
    consensus (learn more in [Chapter 14](ch14.xhtml#ch14)).
  prefs: []
  type: TYPE_NORMAL
- en: The FairPlay dapp can be accessed from any web browser. The dapp runs web3.js
    and es-ss.js to fetch data from public blockchain nodes and search engine Elasticsearch
    nodes. The user does not need any special software (i.e., a crypto wallet) to
    view active and past giveaways. The FairPlay web app is simply a collection of
    HTML and JavaScript files (see [Figure 11.4](ch11.xhtml#ch11fig4)). Any user can
    start a web server on a computer and serve those files locally or publically.
    Hence, FairPlay is decentralized and resistant to censorship.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f11_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 11.4** FairPlay is a web app that can be hosted by anyone and accessed
    on any web browser.'
  prefs: []
  type: TYPE_NORMAL
- en: When the user needs to make a smart contract transaction, such as creating a
    new giveaway or participating in an existing giveaway, the web page directs the
    user to open the CyberMiles app to digitally sign and complete the operation (see
    [Figure 11.5](ch11.xhtml#ch11fig5)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f11_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 11.5** The FairPlay web app opens the CyberMiles app to send smart
    contract transactions.'
  prefs: []
  type: TYPE_NORMAL
- en: FairPlay is a dapp in front of blockchain smart contracts. Under the hood, FairPlay
    has a modular architecture that is easy to develop and maintain. Key to this architecture
    is the smart contract search engine.
  prefs: []
  type: TYPE_NORMAL
- en: A Modular Architecture
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Most of today’s dapps rely on a single monolithic smart contract to serve as
    the “back end.” The smart contract manages all application users and states. Even
    for systems that consist of multiple contracts, there is typically a registry
    or manager contract that provides aggregated information about the system.
  prefs: []
  type: TYPE_NORMAL
- en: However, a large smart contract is difficult to write and maintain. It tends
    to be error-prone and nearly impossible to fix when an error or issue is discovered,
    exacerbating the security problems that have plagued dapps today. The registry
    contract is also constrained by the limitations of today’s smart contract programming
    languages and virtual machines. It cannot support complex data query operations.
  prefs: []
  type: TYPE_NORMAL
- en: The FairPlay dapp took a different approach. The dapp consists of many giveaway
    events, but each event is its own smart contract. When we create a new giveaway,
    we deploy a new instance of the FairPlay smart contract. When an event ends, its
    smart contract instance is discarded. That allows us to continuously improve the
    FairPlay contract to add features and fix bugs, as each future giveaway event
    uses a new smart contract. However, a key challenge in this approach is how the
    dapp organizes all those smart contracts created by different addresses at different
    times and makes the information inside all those contracts available in a unified
    UI. Enter the search engine.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Smart Contract Search Engine
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The FairPlay dapp home screen displays results from the search engine (see [Figure
    11.6](ch11.xhtml#ch11fig6)). It allows users to find giveaways containing specific
    keywords or tags, as well as giveaways the user previously participated in. The
    search engine indexes information from all FairPlay contracts deployed on the
    blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f11_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 11.6** The FairPlay dapp home page is based on search engine results.'
  prefs: []
  type: TYPE_NORMAL
- en: The smart contract search engine is also decentralized—anyone can create a search
    engine-based dapp in front of all FairPlay smart contracts. Each search engine-based
    dapp could use different algorithms and queries to surface and promote FairPlay
    giveaways tailored to its users and audience. This architecture is illustrated
    in [Figure 11.7](ch11.xhtml#ch11fig7).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f11_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 11.7** The decentralized FairPlay dapp'
  prefs: []
  type: TYPE_NORMAL
- en: Each smart contract in the FairPlay dapp completes a limited set of specific
    business transactions. Smart contracts are small pieces of autonomous code that
    are designed to enforce simple business rules on the blockchain. All related smart
    contracts are aggregated in the search engine to provide a useful UI to users.
  prefs: []
  type: TYPE_NORMAL
- en: Use Cases
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The FairPlay dapp is an example of how the smart contract engine supports data-intensive
    e-commerce dapps. The following sections present some more use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Crypto Assets
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Crypto assets are represented by a large number of standard contracts such as
    ERC20, ERC721, and even ERC1400\. A search engine could provide an aggregated
    view of all account balances and transactions across those contracts.
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, every ERC smart contract standard could benefit from a search engine
    that aggregates and displays information across all contracts of the same type.
  prefs: []
  type: TYPE_NORMAL
- en: DeFi
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Decentralized crypto exchanges often have multiple asset pools each represented
    by a smart contract. A search engine can provide deep insights into the history
    and current state of those pools.
  prefs: []
  type: TYPE_NORMAL
- en: In general, decentralized finance (DeFi) solutions, such as algorithmic stable
    coins, crypto loans, and staking pools, all have asset pools held by smart contracts.
    A search engine could provide deep insights into those pools.
  prefs: []
  type: TYPE_NORMAL
- en: Gaming
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Blockchains allow participants from anywhere in the world to play games against
    each other without the need for a central operator or a trusted setup. A decentralized
    game is run entirely in accordance with a smart contract’s logic. The smart contract
    will not allow a player to perform an invalid move or participate out of turn.
    The smart contract ensures correctness and fairness, right from the initial rules
    of engagement through to the final payout or reward.
  prefs: []
  type: TYPE_NORMAL
- en: Dapps, which constitute the front end (a visually stimulating component of the
    game), obtain the real-time state of the game, programmatically, via the smart
    contract search engine API.
  prefs: []
  type: TYPE_NORMAL
- en: 'The entire ecosystem is safe and reliable. The following steps are repeated
    until a satisfactory outcome is achieved:'
  prefs: []
  type: TYPE_NORMAL
- en: The dapp visually displays the current state of the game to the end users.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If it is their turn, each end user makes a choice by touching or swiping the
    screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The dapp submits that choice to the smart contract.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The smart contract validates the instruction set that the dapp sent.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The smart contract executes the instruction set if valid.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The smart contract’s state is/isn’t updated accordingly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The dapp redisplays the current state of the game (via the API) to the end users.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, I discussed how the smart contract search engine can provide
    rich and up-to-date blockchain data to enable complex dapps. For application developers,
    the search engine services (i.e., the es-ss.js library) can supplement web3 and
    support a modular architecture for dapps.
  prefs: []
  type: TYPE_NORMAL
- en: 12. Smart Contract Security and Best Practices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By Victor Fang, PhD[*](ch12.xhtml#ch12fn1)
  prefs: []
  type: TYPE_NORMAL
- en: '[*](ch12.xhtml#rch12fn1) Victor Fang, PhD, is founder and CEO of AnChain.ai.'
  prefs: []
  type: TYPE_NORMAL
- en: A smart contract, coined by American computer scientist Nick Szabo, is the revolutionary
    feature that defines blockchain 2.0, compared to the peer-to-peer decentralized
    transactions in the blockchain 1.0 era such as Bitcoin, Ripple, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: As of 2019, Ethereum is the most widely adopted smart contract-enabled blockchain.
    An Ethereum smart contract is decentralized software that can be executed and
    verified on the Ethereum public blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ethereum smart contracts are programmed in Solidity, a JavaScript-like programming
    language (ECMAScript syntax), and they run in the Ethereum Virtual Machine (EVM).
    You can learn more about Ethereum smart contracts in [Chapter 6](ch06.xhtml#ch06).
    Since Ethereum’s launch in 2015, developers have witnessed a plethora of successful
    applications, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Tokens, such as initial coin offerings (ICOs), security token offerings (STOs),
    and stable coins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dapps, such as FOMO3D and CryptoKitties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decentralized exchanges, such as the Decentralized Ethereum Asset Exchange (IDEX)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, developers have also experienced major security vulnerabilities that
    caused billions of dollars in losses and concerns among the blockchain communities.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, I will focus on the Ethereum smart contract and discuss the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Major Ethereum smart contract hacks and vulnerabilities in history
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Best practices to secure smart contracts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Major Ethereum Smart Contract Hacks and Vulnerabilities
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since the launch of Ethereum, the community witnessed major hacks that took
    over the headlines. In this chapter, I will review a few major hacks and illustrate
    the vulnerabilities behind those exploitations.
  prefs: []
  type: TYPE_NORMAL
- en: Decentralized Autonomous Organization Hack
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The decentralized autonomous organization (DAO) hack is probably the most notorious
    hack in Ethereum history. A DAO is a decentralized autonomous organization. Its
    goal is to codify the rules and decision-making apparatus of an organization,
    eliminating the need for documents and people in governing and creating a structure
    with decentralized control.
  prefs: []
  type: TYPE_NORMAL
- en: In June 2016, an attacker drained 3.5 million ETH (about $50 million) from the
    DAO smart contract, after the ICO token sale had ended. It led to a hard fork
    of Ethereum. The technique the attackers used was reentrancy.
  prefs: []
  type: TYPE_NORMAL
- en: '*Reentrancy* is also known as *recursive call vulnerability*. It occurs when
    external contract calls are allowed to make new calls to the calling contract
    before the initial execution is complete. For a function, this means that the
    contract state may change in the middle of its execution as a result of a call
    to an untrusted contract or the use of a low-level function with an external address.
    The minimal example for reentrancy is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch12_images.xhtml#pro12_1)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In this code example, `msg.sender.call.value` can be exploited by hackers. An
    attack contract could recursively call it until all gas is consumed.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, reentrancy is quite common. In October 2018, SpankChain, a cryptocurrency
    project focused on the adult industry, suffered a breach that saw almost $40,000
    in ETH stolen.
  prefs: []
  type: TYPE_NORMAL
- en: The AnChain.ai threat research team illustrated the recursive nature of reentrancy
    when SpankChain was attacked, as shown in [Figure 12.1](ch12.xhtml#ch12fig1).
    Note that the hacker launched the attack contract that would cause SpankChain
    to recursively send ETH to the hacker’s address, until all gas was consumed. Each
    `call_0`, `call_1_0`, and `call_1_1_0_0` is an EVM internal transaction indicating
    an external smart contract call. In this case, each internal call stole 0.5 ETH
    from the SpankChain smart contract!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f12_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 12.1** The recursive nature of the reentrancy when the SpankChain
    smart contract was attacked'
  prefs: []
  type: TYPE_NORMAL
- en: BEC Token Hack
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Beauty Chain (BEC) token is particularly interesting because it shows how
    smart contract-based crypto assets can have a massive impact on a centralized
    crypto exchange (OK Exchange) in a subtle way, causing billions of dollars in
    losses.
  prefs: []
  type: TYPE_NORMAL
- en: BEC was a high-profile cryptocurrency in China, and its stated goal was to be
    “a truly decentralized and beauty-themed ecosystem.”
  prefs: []
  type: TYPE_NORMAL
- en: It started trading on OKEX on February 23, 2018\. From its peak market cap of
    around $70 billion, it gradually came down to around $2 billion USD as of April
    22, when its trading value suddenly dropped to zero. OKEX subsequently suspended
    trading of BECs.
  prefs: []
  type: TYPE_NORMAL
- en: The BEC token hack was because of an *integer overflow* vulnerability in its
    ERC20 smart contract. The annotated code line in the following listing multiplies
    two uint256 numbers and assigns the result to another uint256 variable, `amount`.
    Unfortunately, there is no overflow checking on that line. When a hacker passes
    a legitimate but large uint256 variable, it can cause the product to overflow.
    [Figure 12.2](ch12.xhtml#ch12fig2) shows the transaction that exploits the integer
    overflow vulnerability.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f12_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 12.2** The exploited overflow vulnerability transaction of the BEC
    smart contract'
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch12_images.xhtml#pro12_2)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The way to prevent this hack is to use SafeMath for all arithmetic. In fact,
    this smart contract used SafeMath in all except this particular function, and
    it caused catastrophic damage not only to BEC but also to all exchanges that traded
    it.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: There are ways to prevent integer overflows in smart contracts. The Lity language
    and virtual machine extensions to Ethereum check for integer overflow at compile
    time and then detect and abort the smart contract when there are integer overflows
    at runtime. See [Chapter 14](ch14.xhtml#ch14) for more.
  prefs: []
  type: TYPE_NORMAL
- en: The Parity Wallet Hack
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The *Parity multisig bug* vulnerability showcases another way that a cryptographic
    smart contract design bug can damage part of the ecosystem: the wallet. The impacted
    Parity wallet is one popular wallet for Ethereum and tokens.'
  prefs: []
  type: TYPE_NORMAL
- en: In fact, this bug is one of the common bugs in the top-ten list from Open Web
    Application Security Project (OWASP), categorized under access control. These
    issues are common in all programs, not just smart contracts.
  prefs: []
  type: TYPE_NORMAL
- en: The Parity multisig bug impacted all users with assets in a multisig wallet
    created in Parity wallet that was deployed after July 20, 2017, worth $155 million
    USD. This bug was patched immediately after the hack.
  prefs: []
  type: TYPE_NORMAL
- en: The attacker sent two transactions to each of the affected contracts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 1: Obtain Exclusive Ownership of the Multisig'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In the wallet contract, the `payable()` function contains a bug that causes
    all public functions from the library to be callable by anyone, including `initWallet`,
    which can change the contract’s owners.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, `initWallet` has no checks to prevent an attacker from calling
    it after the contract was initialized. The attacker exploited this and simply
    changed the contract’s owner state variable to the hacker’s addresses. This modified
    the access control and persisted in the immutable Ethereum blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 2: Move All of Its Funds'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: After the hacker took over the ownership, it was just a matter of invoking the
    execute function to send all the funds to the hacker’s account! This execution
    was automatically authorized since the attacker was then the only owner of the
    multisig, effectively draining the contract of all its funds.
  prefs: []
  type: TYPE_NORMAL
- en: FOMO3D and LastWinner Dapp Hack
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Dapps are a dominant trend enabled by smart contracts. As of March 2019, there
    were 2,667 dapps running on public blockchains, and the number will likely grow
    tremendously. Please see [Chapter 7](ch07.xhtml#ch07) for more on Ethereum dapp
    development.
  prefs: []
  type: TYPE_NORMAL
- en: 'FOMO3D is a gambling dapp ([Figure 12.3](ch12.xhtml#ch12fig3)) that was so
    popular in July/August 2018 that it even congested the Ethereum blockchain. The
    FOMO3D game rules are simple and as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f12_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 12.3** FOMO3D dapp, played by Victor Fang in July 2018'
  prefs: []
  type: TYPE_NORMAL
- en: A user buys a key, in other words, a lottery ticket, to participate.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When anyone buys a key, the countdown clock adds a few seconds, with 24 hours
    being the maximum.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The final buyer when the clock hits 0 wins the jackpot!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each key buyer receives random airdrop bonuses.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In fact, FOMO3D is a typical Ponzi scheme that theoretically should never stop,
    because it is driven by human nature: greed.'
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, FOMO3D, and its copycat LastWinner, were both hacked in August
    2018\. Those hacks led to the discovery of *blockchain advanced persistent threats*
    (BAPTs). *Advanced persistent threat* (APT) is defined as stealthy and continuous
    computer hacking processes, often orchestrated by people targeting a specific
    entity. So, BAPTs are APTs applied to blockchains.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: According to *MIT Technology Review*, “In August 2018, AnChain.ai identified
    five Ethereum addresses behind an extremely sophisticated attack that exploited
    a contract flaw in a popular gambling game to steal $4 million.” In response,
    the creators of FOMO3D, commented that everything worked as intended. “No rules
    we set in place were broken. Our experiments strive to find exploits where human
    nature and blockchain interact. We design our projects around fighting such threats,
    We were not a bank that was robbed. The very goal of our project was for someone
    to win it and run away with everything!”
  prefs: []
  type: TYPE_NORMAL
- en: Random number generation (RNG) is commonly used in dapps, just like all online
    Internet games. Think about an online poker game. The house will generate the
    hand based on a random number generator for every play.
  prefs: []
  type: TYPE_NORMAL
- en: 'A perfect random number should mathematically have high entropy and cannot
    be predicted. However, on-blockchain RNG turns out to be quite challenging because
    of the nature of the blockchain: immutable, decentralized, transparent.'
  prefs: []
  type: TYPE_NORMAL
- en: Once the dapp has “bad randomness,” it will be exploited by hackers who can
    predict the game play.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: The Lity language and virtual machine extend the Ethereum protocol to provide
    highly secure random number seeds for smart contracts when the underlying blockchain
    consensus is delegated proof of stake (DPoS). Please see [Chapter 14](ch14.xhtml#ch14)
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: The following is the code snippet of the FOMO3D `airdrop()` function that will
    generate a random number based on various sources such as `timestamp`, `block
    coinbase`, `sender`, and so on, yielding the result if the participant is the
    winner or not.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch12_images.xhtml#pro12_3)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Technically, this `airdrop()` function is bug-free. However, in the context
    of a blockchain-based smart contract, this code is vulnerable, as explained here:'
  prefs: []
  type: TYPE_NORMAL
- en: The Ethereum blockchain takes seconds to reach the consensus.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This code can be executed in milliseconds in a typical computer, which is 1,000
    times faster than on the blockchain.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This smart contract source code is transparent to everyone on the blockchain.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the random number seeds used are transparent to everyone on the blockchain;
    in other words, there’s a lack of entropy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Based on these facts, it is feasible for a hacker to design a malicious smart
    contract to exploit this bad randomness, by precomputing the `airdrop()` result,
    and participating in FOMO3D only when the result is known to be winning! Brilliant
    idea!
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 12.4](ch12.xhtml#ch12fig4) visualizes the entire hacking campaign.
    There were 2 million transactions involved over the course of 2 weeks, and there
    were 22,000+ Ethereum addresses involved. Most of them were malicious attack smart
    contracts, launched by the five wallet addresses!'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f12_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 12.4** Visualization of the BAPT-LW hacker group (more than five ETH
    wallet addresses) attacking LastWinner, a FOMO3D copycat dapp, in August 2018'
  prefs: []
  type: TYPE_NORMAL
- en: Unknowns and Beyond
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Note that these reported vulnerabilities may be only the tip of the iceberg.
    There were more than 1 million smart contracts deployed on Ethereum at the end
    of 2018, while only 50,000 of them contained publicly accessible source code.
  prefs: []
  type: TYPE_NORMAL
- en: Based on research powered by the AnChain.ai smart contract auditing sandbox,
    more than 0.6 percent of the 50,000 mainnet-deployed smart contract source code
    is vulnerable to a reentrancy attack. There are 57,911 known vulnerabilities among
    all of them.
  prefs: []
  type: TYPE_NORMAL
- en: Even a known vulnerability can repeat history. On January 16, 2019, the Constantinople
    protocol upgrade was delayed, at the last minute, because of a security vulnerability
    enabled by EIP 1283\. This vulnerability led to the possibility of a new reentrancy
    vector making previously known secure withdrawal patterns (`.send()` and `.transfer()`)
    unsafe in specific situations, where the attacker could hijack the control flow
    and use the remaining gas enabled by EIP 1283\. The upgrade was hence delayed.
    Otherwise, another Ethereum catastrophe would happen.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, there may be unknown vulnerabilities that already exist but
    have not yet been discovered, like zero-day bugs in the cybersecurity industry.
  prefs: []
  type: TYPE_NORMAL
- en: 'I will conclude this section with the Decentralized Application Security Project
    (DASP) top-ten vulnerabilities of 2018:'
  prefs: []
  type: TYPE_NORMAL
- en: Reentrancy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arithmetic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unchecked low-level calls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Denial of service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bad randomness
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Front running
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Time manipulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Short addresses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unknown unknowns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Best Practices for Securing Smart Contracts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see from the previously mentioned major smart contract hacks, developing
    secure smart contracts can be quite challenging.
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, Steve McConnell’s “Code Complete” shows the following statistics for
    the number of bugs per line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Industry average*: About 15 to 50 errors per 1,000 lines of delivered code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Microsoft applications*: About 10 to 20 defects per 1,000 lines of code during
    in-house testing and 0.5 defect per 1,000 lines of code in released products'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another challenge for the Ethereum blockchain is that it’s hard to change the
    smart contract code once it’s deployed. Think about Microsoft Windows patches
    that arrive weekly to fix known vulnerabilities. There is no such mechanism on
    the blockchain. It’s “code is law.”
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: The Lity project provides a mechanism to upgrade Ethereum-compatible smart contracts
    on Lity-based blockchains. The idea is to declare the contract interface at the
    contract address and then provide proxy implementations of all the functions.
  prefs: []
  type: TYPE_NORMAL
- en: Hence, it is critical to write secure code in the upcoming smart contract era.
    Fortunately, there are various projects and startups that aim to help developers
    secure their smart contracts by performing auditing to identify vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: The following are a few best practices.
  prefs: []
  type: TYPE_NORMAL
- en: Expert Manual Auditing
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The widely adopted way to audit smart contracts, especially the ICO tokens,
    is called *expert manual auditing*. Solidity is new programing language and lacks
    security tools compared to the commercial tools in the well-established cybersecurity
    industry such as Coverity for enterprise C++/Java source code auditing. The experts
    are mostly computer language experts with experience to identify vulnerabilities
    manually.
  prefs: []
  type: TYPE_NORMAL
- en: Formal Verification
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Formal verification* (FV) is one of the promising fields for smart contract
    auditing that aims to mathematically prove the source code correctness. According
    to an EE Times article by Alok Sanghavi, “Formal verification is the act of proving
    or disproving the correctness of intended algorithms underlying a system with
    respect to a certain formal specification or property, using formal methods of
    mathematics.” In fact, the formal method dates back 40 years ago, and there are
    various applications such as Windows leveraging formal verification to prove some
    of the critical kernel modules’ source code correctness.'
  prefs: []
  type: TYPE_NORMAL
- en: Sandbox
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A *sandbox*, simply put, is a specially designed virtual machine that can automatically
    execute the opcode instructions in a restricted environment. It’s a proven technology
    in cybersecurity; companies like FireEye and Palo Alto Network develop malware
    sandbox products that can detect the most sophisticated malware like APT32, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: For example, modern advanced malware is polymorphic, which means it will modify
    its own bytes, while most antivirus (AV) software still relies on signature-based
    detection, which is a hash of the payload bytes. Hence, this polymorphic malware
    can bypass the AV detection since they have different hashes, even though they
    function similarly. Alternatively, the sandbox will analyze the code execution
    behaviors and look for suspicious patterns in a fully automated fashion.
  prefs: []
  type: TYPE_NORMAL
- en: Inspired by the proven success of the malware sandbox, AnChain.ai developed
    the world’s first smart contract auditing sandbox and launched in February 2019\.
    A good sandbox product should have built-in features such as static analysis,
    dynamic execution, statistical analysis, code similarity, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Tools
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Based on these best practices, the following are popular open source tools
    that can get you started with secure smart contracts:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Mythril Classic*: This is an open source EVM bytecode security analysis tool.
    See [https://github.com/ConsenSys/mythril-classic](https://github.com/ConsenSys/mythril-classic).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Oyente*: This is an alternative for static smart contract security analysis.
    See [https://github.com/melonproject/oyente](https://github.com/melonproject/oyente).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Slither*: This is a Solidity static analysis framework. See [https://github.com/crytic/slither](https://github.com/crytic/slither).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Adelaide*: This is the SECBIT static analysis extension to the Solidity compiler.
    See [https://github.com/sec-bit/Adelaide](https://github.com/sec-bit/Adelaide).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: The Lity project (see [https://www.litylang.org](https://www.litylang.org))
    provides Ethereum-compatible tools to perform static analysis at compile time,
    using tools like Oyente and ERC Checker. See [Chapter 15](ch15.xhtml#ch15) for
    more details.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, I covered the major Ethereum smart contract hacks and vulnerabilities
    in its short history and discussed best practices for securing smart contracts.
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum is still in its infancy. I consider it to be like 1990’s Internet,
    slow and vulnerable. But it will soon become as mature as 2019’s Internet. However,
    with data breaches and APT hacks occasionally making headlines, even Internet
    security still has a long way to go. Security is a collaborative effort that involves
    many specialized experts, teams, and tools. Are you ready to secure your smart
    contracts?
  prefs: []
  type: TYPE_NORMAL
- en: 13. The Future of Ethereum
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By Tim McCallum
  prefs: []
  type: TYPE_NORMAL
- en: The creator of Ethereum, Vitalik Buterin, defines *blockchain* as a decentralized
    system that contains shared memory, and as such, a good blockchain application
    is one that needs both a decentralized architecture and shared memory capabilities
    across the network’s architecture. Ethereum’s focus, to date, has been on decentralization
    (philosophically, decentralizing the Internet). The Internet, while possessing
    the design characteristics to be decentralized, has since its inception become
    increasingly centralized. The Ethereum network provides guaranteed decentralized
    computation on a global scale. In addition to this, the Ethereum network holds
    shared memory within the entire network, known as the *state*.
  prefs: []
  type: TYPE_NORMAL
- en: These attributes, in a technical sense, make Ethereum a “world computer.” It
    has already proven that it can support next-generation decentralized applications
    (dapps) that facilitate customized online payments, authentication mechanisms,
    decentralized storage solutions (swarm), digital currencies, and much more.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I begin by covering the 2018 development of Ethereum. I will
    discuss how the Ethereum foundation’s researchers and Ethereum developers are
    solving present-day challenges. I then step into the future by uncovering developments
    that are at the fringe; these are developments that could materialize as proof
    of concepts for early adoption around 2020\. Before concluding the future of Ethereum,
    I look well into the future at the “hard-to-implement” paradigm shifts that, if
    realized, could propel Ethereum forward, beyond what is even imaginable today
    in terms of privacy, scalability, and security.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: Potential improvements to the Ethereum network go through the Ethereum Improvement
    Proposal (EIP) process before being implemented. The stages for EIPs are draft,
    accepted, final, and differed. Finalized EIPs are proposals that have been adopted.
    For a proposal to succeed, the issuer is required to provide detailed information
    including the motivation, specifications, rationale, and backward compatibility.
    The proposal may also provide code examples.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most famous EIPs is EIP20, which defines the smart contracts for
    issuing ERC20 tokens on the Ethereum blockchain. You can read the EIP20 standard
    at `https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md`. You can review
    all EIPs at `https://github.com/ethereum/EIPs`.
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum 1.0
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There were three main categories of challenges on the table for Ethereum in
    2018\. These are privacy, consensus, and scalability. The Ethereum Foundation’s
    researchers and Ethereum developers have already made inroads into solving these
    problematic areas. As you will read shortly, Ethereum has already released its
    hybrid proof-of-work (PoW)/proof-of-stake (PoS) consensus mechanism known as Casper
    the Friendly Finality Gadget (FFG). The future Ethereum road map is very exciting
    and full of activity. To kick things off, let’s take a look at the problems and
    solutions around privacy, consensus, and scalability in a bit more depth.
  prefs: []
  type: TYPE_NORMAL
- en: Privacy
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The privacy paradox is such that while lots of nodes are verifying your data
    on the public ledger (providing security through collaborative consensus), having
    your data on the public ledger, in fact, compromises your privacy. Here is an
    example. If somebody knew the date, time, and amount particulars of a transaction
    that you sent or received, that person could inspect the public ledger and identify
    your account’s address (public key). This issue is common to most public distributed
    ledgers (blockchains), not just Ethereum. What is important is, from that moment,
    that person could track your account balance, income, and spending via the public
    ledger. This is an invasion of your privacy. Inroads have been made into resolving
    the privacy problem at the base protocol level. The Byzantium fork released by
    Ethereum in October 2017 introduced new cryptographic algorithms (zero-knowledge
    proofs and ring signatures). These cryptographic tools and other enhancements
    to the Ethereum network such as the introduction of state channels are all going
    to help developers resolve these and other privacy problems.
  prefs: []
  type: TYPE_NORMAL
- en: Consensus
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Chapter 2](ch02.xhtml#ch02) discussed the PoW and PoS consensus mechanisms
    of blockchains. Ethereum, since its inception, has always been a PoW blockchain.
    However, with the next-generation Ethereum, it is moving toward PoS. The switch
    from PoW to PoS is perhaps the greatest challenge and opportunity facing the Ethereum
    community today.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The advent of the PoW protocol introduced one of the most revered blockchain
    attributes: immutability. More specifically, it is computationally impractical
    to reverse past transactions while computers (nodes on the peer-to-peer blockchain
    network) are competing to expend their computational energy, creating new blocks
    (mining the blockchain). Ethereum currently also uses the PoW consensus protocol,
    and just like with Bitcoin, the PoW consensus process on the Ethereum network
    thrives as computers all compete on the network, expending their computational
    energy, to create new blocks on top of the blockchain.'
  prefs: []
  type: TYPE_NORMAL
- en: While PoW has many strengths, it is also criticized in relation to energy efficiency
    and potential centralization of the PoW mining process.
  prefs: []
  type: TYPE_NORMAL
- en: Proof of Stake
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In October 2017, Ethereum’s Vitalik Buterin and colleague Virgil Griffith released
    a publication called Casper the Friendly Finality Gadget. Casper FFG is a partial
    consensus mechanism that combines PoS algorithm research and Byzantine fault-tolerant
    consensus theory. Importantly, for implementation, Casper FFG was designed to
    overlay an existing operational PoW blockchain. Hence, Casper FFG is a hybrid
    PoW/PoS consensus solution. While a formal move to PoS will only happen on Ethereum
    2.0, the PoS experimentation has already started on Ethereum 1.0.
  prefs: []
  type: TYPE_NORMAL
- en: There are more than three Ethereum testnets. These Ethereum testnets are sandboxes,
    used to simulate the Ethereum network and the Ethereum Virtual Machine (EVM).
    Ethereum’s hybrid PoW/PoS implementation, Casper FFG, was launched in its own
    testnet (not in production) in January 2018\. The following discussion is an early
    overview of the Casper FFG PoW/PoS hybrid consensus solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'In PoW mining, a miner is given a challenge: finding a nonce. Finding the nonce
    is done by brute force and involves randomly guessing repeatedly until the nonce
    is discovered. This process is miners’ proof that they have worked. That’s why
    it’s called *proof of work*. In PoS, the blocks are created by validators. Validators
    are allowed to participate in creating blocks only if they put skin in the game.
    This involves staking a large deposit (at this early stage believed to be around
    1,500 ETH). That’s why it’s called *proof of stake*.'
  prefs: []
  type: TYPE_NORMAL
- en: PoS validation is unlike PoW mining from a hardware perspective as there is
    no specialized competing hardware required. The validators are all virtual (software).
    The process of joining and leaving the role of being a validator in PoS is known
    as *bonding* and *unbonding*, respectively. So, how is the bonding and unbonding
    recorded? Casper FFG saves the bonding and unbonding activity in the blockchain
    state (along with account balances and so forth). Anyone can join the set of validators
    by sending an Ethereum transaction to the Casper contract (along with some parameters
    such as a withdrawal address and of course ETH for gas).
  prefs: []
  type: TYPE_NORMAL
- en: The basic premise behind PoS validation involves economic incentives. For example,
    a bonded validator who exerts clearly bad behavior (like creating two blocks at
    the same height) will be penalized economically. On the other hand, a bonded validator
    that does not deliberately attack the network will receive returns, or interest,
    on the deposit that they have staked. In the Casper FFG PoS implementation, the
    number of opportunities where manipulation is more profitable than the costs associated
    with performing the manipulation is small. Ideally, there would be close to zero
    (no) opportunities to manipulate (attack) the network without encountering a severe
    economic penalty. In a given PoW blockchain implementation (where all nodes are
    running the same PoW consensus mechanism), the chain with the most blocks (the
    longest chain) wins (see [Figure 13.1](ch13.xhtml#ch13fig1)). This is because
    it exhibits the most proof of work.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f13_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 13.1** The PoW algorithm identifies the longest chain as the authoritative
    one.'
  prefs: []
  type: TYPE_NORMAL
- en: In Casper FFG PoS, the chain with the most value at risk (VaR) supporting it
    wins. The general principle is that if you support a block that does not make
    it into the main chain, instead of being rewarded you get penalized. You lose
    an amount of ETH that is equal to the block reward. In practice, let’s propose
    that there are two blocks available to support. The block on chain A has a 90
    percent chance of succeeding. The block on chain B has a 10 percent chance of
    succeeding. If you support chain A, you will be rewarded. If you support chain
    B, you will be penalized. A potential economic conundrum comes into play if you
    start thinking that you could support both A and B for profit. Ethereum has a
    clever way of making this unappealing. In this case, where you have split your
    bet two ways, you will only be allowed to receive 50 percent of the reward from
    chain A (if it succeeds) and 50 percent of the reward from chain B (if it succeeds).
    This betting on both sides will always net a lesser result than just supporting
    chain A. This economic incentive results in convergence, and this is the desired
    path to ensure a single honest chain via PoS consensus. The following is a simple,
    albeit concrete, example for demonstration purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose the block reward is 10 ETH. Suppose you, as a validator, support a block
    on chain A and a block on chain B. In a scenario where chain A succeeds, you would
    receive 5 ETH (only 50 percent of the block reward) from your efforts on chain
    A, and you would lose 10 ETH (the entire block reward) for supporting a block
    on chain B. The net result for this scenario would be negative 5 ETH for your
    efforts.
  prefs: []
  type: TYPE_NORMAL
- en: In PoS, the validator needs to authenticate. It has been proposed that, instead
    of simply using a private key, a validator code function be created. This modular
    design would mean that the validator could choose alternative signatures when
    authenticating. For example, the validator could choose to use a Lamport signature
    as these are believed to be secure against quantum computer threats.
  prefs: []
  type: TYPE_NORMAL
- en: Scalability
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Blockchain systems trade off against decentralization, scalability, and security.
    It is reasonably easy to solve any two out of these three issues at any one time.
    Vitalik Buterin quips that this is a blockchain “trillema,” whereby you can easily
    solve two issues at the cost of the third, but you can’t easily solve all three.
  prefs: []
  type: TYPE_NORMAL
- en: Plasma
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Plasma is just one of the strategies that could address blockchain scalability.
    Plasma is different from sharding (covered later in the chapter). A successful
    plasma implementation would send transactions off-chain to improve scalability.
    In this regard, plasma is what is known as a second-layer solution. Second-layer
    solutions are implemented through code that is written outside of the base protocol
    layer (or, commonly known as the layer 1 protocol). More specifically, second-layer
    solutions have no effect on the base protocol layer’s consensus mechanism. Just
    to clarify, plasma differs from sharding in that a successful sharding solution
    would be coded into the base protocol layer. Plasma is designed to be compatible
    with on-chain scaling solutions such as sharding and therefore not only can coexist
    but can even be complementary. In fact, on-chain scalability improvements will
    just further increase the scalability of the second-layer solution.
  prefs: []
  type: TYPE_NORMAL
- en: Plasma is a set of nested blockchains. These plasma blockchains are created
    using smart contracts on the main Ethereum network. Uploading your smart contract
    onto the public Ethereum blockchain allows you to launch your own specific applications.
    Applications can include decentralized exchanges, social networks, payment networks,
    and even your own private Ethereum blockchain implementation. These plasma blockchains
    (your applications) are all accountable to the public Ethereum blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: The scalability is brought about by the fact that while processing an extremely
    high volume of transactions, the plasma blockchains do not submit their entire
    transaction volume to the public Ethereum blockchain. Instead, the plasma blockchains
    send only a small amount of data (block header hashes) about the plasma blockchains
    state. Plasma works on the premise that data being submitted to the main chain
    is free from fraudulent activity, while the public Ethereum blockchain is not
    required to perform computation in general. If anyone can publish a proof that
    fraudulent activity took place (a dispute), the public Ethereum blockchain performs
    computation, resolving the dispute and punishing the offending participant.
  prefs: []
  type: TYPE_NORMAL
- en: State Channels
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: State channels are a mechanism that allow two participants to sign promises,
    at given points in time. These time-based off-chain signed promises provide proof
    of activity. State channels provide an opportunity for decentralized applications
    to interact with other parties (customers) off-chain. This provides a cheap and
    fast user experience, which would not be possible on-chain. State channels are
    smart contracts. State channels are also a second-layer solution to the Ethereum
    scalability problem. From a usability perspective (dapp development), having a
    high volume of off-chain activity means low to negligible gas fees. As such, dapps
    that employ state channels as part of their solution not only offer near real-time
    activity but also the ability for customers to send and receive micro-payments.
    A use case for this could be a gambling application that allows a high volume
    of micro-betting, in real time, for entertainment purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Raiden
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Raiden network leverages off-chain state channels. The Raiden network offers
    micro payments of ERC20-compliant tokens while taking negligible fees and providing
    responses to transactions in near real time. The difference between state channels
    and the Raiden network is that rather than creating a new state channel for every
    new interaction between two parties, Raiden creates a network of channels whereby
    all participants are transitively connected via a web of ERC20 token–complaint
    payment channels, making use of natural network topology architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Token Improvements
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The ERC20 tokens have proven to be a great success. ERC20 has found one of the
    first killer applications for Ethereum, as an initial coin offering (ICO) token
    sale platform. The Ethereum community is working on further improving tokens issued
    from the Ethereum smart contracts.
  prefs: []
  type: TYPE_NORMAL
- en: One of the more interesting ideas is nonfungible tokens (NFTs). A key characteristic
    of money is fungible, meaning that a dollar bill is completely interchangeable
    with another dollar bill. That is the case for blockchain tokens as well. While
    you can trace the use of each token in the ledger, no two tokens are different.
    But with NFTs, a token is truly unique. The famous Ethereum game CryptoKitties
    is a good example of how NFTs can be applied, as each “cat” is completely unique.
    The ERC721 proposes an NFT standard that is compatible with ERC20\. Such NFTs
    could enable many token applications ranging from collectibles trading to real
    estate transactions. To participate in this EIP, please refer to [https://github.com/ethereum/eips/issues/721](https://github.com/ethereum/eips/issues/721).
  prefs: []
  type: TYPE_NORMAL
- en: Beyond Ethereum 1.0
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ethereum has had plans for some time to create a blockchain to surpass the current
    second-layer solutions on offer. The overall vision has primarily been to create
    a blockchain solution that is capable of scaling to thousands of on-chain transactions
    per second, with the most promising of the proposed solutions being sharding.
  prefs: []
  type: TYPE_NORMAL
- en: Sharding
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The original idea for sharding was that the main Ethereum blockchain would publish
    what is known as a *validator manager contract*. In this scenario, the validator
    manager contract would simply be a single smart contract on the Ethereum 1.0 blockchain.
    It was decided (in July 2017) shortly after disparate development processes in
    the areas of both Casper (PoS) and sharding that this architecture would change.
    The most significant change to the original idea was to make the core component
    of the sharding system not just a smart contract but instead a complete PoS chain.
    This shift from a PoW smart contract to a self-sufficient PoS chain would remove
    the need for gas, reduce transaction times, and reduce dependency on the underlying
    EVM.
  prefs: []
  type: TYPE_NORMAL
- en: The “Ethereum 2.0” section explains this new sharding architecture, namely,
    the introduction of the beacon chain.
  prefs: []
  type: TYPE_NORMAL
- en: Zero-Knowledge Proofs
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This section explains the basic premise of the zero-knowledge proofs. In a given
    binary situation (where there are only two outcomes available, either yes or no),
    a “prover” with the secret weapon to discern a binary statement from the situation
    must convince a skeptical “verifier” that the binary statement is correct, while
    not revealing the secret. In 2003 a Weizmann Institute of Science faculty member,
    Oded Goldreich, introduced a novel zero-knowledge proof involving a color-blind
    validator. In this scenario, the validator possessed two cards, one red and the
    other green. To the color-blind validator, the cards looked the same, other than
    the fact that the word *red* was written on the back of the red card, and the
    word *green* was written on the back of the other. Let’s play out this scenario
    and assume that the validator is skeptical about the prover’s claim to be able
    to discern the cards without seeing the words on the back. To move this experiment
    forward, the validator would repeatedly show the prover the front side of each
    card, in a random fashion. Each time, the validator would ask the prover what
    color he sees. After some time, the verifier would eventually be convinced that
    the prover is capable of discerning the colors of the two individual cards. This
    is mostly because the verifier performed this over many rounds and the validator
    randomly switched the cards behind his back during each round.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the three properties that a zero-knowledge proof must satisfy:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Completeness*: This is when the honest verifier is convinced that the honest
    prover returned the correct answer in the binary statement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Zero knowledge*: This is where the verifier has no knowledge of how the prover
    came up with the binary statement and learns nothing from the process other than
    that the binary statement provided by the prover is correct.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Soundness*: This is where a prover (even a dishonest one who is just guessing
    the answer of the binary statement) is able to convince an honest verifier that
    the answer is correct.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While the first two properties can be quite easily satisfied during one round
    of an interactive zero-knowledge proof exercise, there is statistically only a
    50 percent chance of achieving soundness. Put simply, a dishonest prover could
    just take a 50/50 guess to the binary situation and get it right 50 percent of
    the time.
  prefs: []
  type: TYPE_NORMAL
- en: With this in mind, it is important to remember that zero-knowledge proofs are
    probabilistic. They are not deterministic. They rely on randomness to succeed.
  prefs: []
  type: TYPE_NORMAL
- en: This information describes a specific type of zero-knowledge protocol known
    as *interactive*. In an interactive zero-knowledge protocol, the verifier and
    the prover must repeat each round until the verifier is convinced, without any
    reasonable doubt, that the prover knows the secret.
  prefs: []
  type: TYPE_NORMAL
- en: A noninteractive zero-knowledge protocol is different because it requires only
    a single round. A noninteractive zero-knowledge proof, however, requires a “trusted
    setup.” One advantage of the noninteractive zero-knowledge protocol is that it
    allows many verifiers to all independently query the ability of the prover. Think
    of this as a one-to-many relationship between the prover and verifier entities,
    as opposed to the interactive zero-knowledge protocol’s one-to-one relationship.
  prefs: []
  type: TYPE_NORMAL
- en: ZK-SNARKs
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Zero-Knowledge Succinct Non-interactive ARguments of Knowledge (ZK-SNARKs) are
    able to be satisfied through computer code, and as such zero-knowledge proof implementations
    have tremendous potential in the online space. Just one example of ZK-SNARKs’
    potential is the creation of a decentralized, anonymous, sealed-bid auction. In
    this case, while the logic of determining the winner would execute successfully,
    the winner’s identity and the winning bid amount could both remain confidential.
  prefs: []
  type: TYPE_NORMAL
- en: You can think of ZK-SNARKs in the following way. ZK-SNARKs are for arbitrary
    computations, just as hashing algorithms are for arbitrary data. Put simply, you
    can turn an arbitrary computation into a ZK-SNARK, and since verifying arbitrary
    computations is at the core of the Ethereum blockchain, ZK-SNARKs are of course
    relevant to Ethereum. If implemented in Ethereum, ZK-SNARKs would not be limited
    to a single computational problem. Enabling ZK-SNARKs for Ethereum would, among
    other things, reduce the gas costs for certain pairing functions and elliptic
    curve operations. Overall, the biggest payoff for enabling ZK-SNARKs would be
    improved (guaranteed) performance of the EVM. Unfortunately, an implementation
    of this magnitude would be extremely difficult to complete and as such might take
    many years to move from proof of concept to early adoption. This may be something
    that will be implemented in the future of Ethereum. Let’s now compare ZK-STARKs.
  prefs: []
  type: TYPE_NORMAL
- en: ZK-STARKs
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The confidentiality of a zero-knowledge proof is already being used to enhance
    privacy in cryptocurrencies. For example, Zcash already uses the ZK-SNARKs protocol.
    I just mentioned the possibility of an Ethereum implementation of ZK-SNARKs and
    the associated advantages. However, a shinier new cousin, Zero Knowledge Succinct
    Transparent ARguments of Knowledge (ZK-STARKs), looks to resolve one of the primary
    weaknesses of ZK-SNARKs: the reliance on a trusted setup. Interestingly, ZK-STARKs
    have also arrived with much simpler cryptographic assumptions. You may recall
    that ZK-SNARKs were promising advantages in relation to pairing functions and
    elliptical curve operations. Well, ZK-STARKs avoid the need for elliptic curves,
    pairings, and the knowledge-of-exponent assumption; instead, ZK-STARKs rely purely
    on hashes and information theory.'
  prefs: []
  type: TYPE_NORMAL
- en: This means that while ZK-STARKs bring about efficiency gains and more, they
    are also secure against attackers with quantum computers. Looking toward the future,
    ZK-STARKs could replace ZK-SNARKs, providing superior scalability and privacy,
    specifically to decentralized public ledgers like Ethereum. It is also important
    to note that these advantages all come at a cost. In other words, the size of
    a proof goes up from 288 bytes to a few hundred kilobytes. Further research is
    required in relation to shortening proof length or the aggregation and compression
    of several ZK-STARK proofs.
  prefs: []
  type: TYPE_NORMAL
- en: In the context of public blockchain applications, there is a high need for trust
    minimization, possibilities that elliptic curves could break, and a seemingly
    real possibility of quantum computers coming around. Given all of these points,
    implementing ZK-STARKs in decentralized public ledgers seems worth it, even if
    there are costs involved.
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum 2.0
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ethereum 2.0 comprises many separate components. Casper PoS, sharding, and Ethereum-flavored
    WebAssembly (eWASM) have been on the minds of Ethereum developers for quite some
    time. For example, Vitalik Buterin has been writing about PoS implementation ideas
    since as far back as 2014\. This blend of technologies somehow resulted in Ethereum
    2.0 adopting the unfortunate name of Shasper, a combination of sharding and Casper
    PoW. Thankfully, most of the time nowadays you will see it referred to as either
    Serenity or simply Ethereum 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: After years of research and development, these Ethereum 2.0 ideas are making
    their way into the code repositories of many Ethereum developers throughout the
    community. For example, there are many individual implementations of the Ethereum
    2.0 specification, such as a Rust implementation of the Ethereum 2.0 beacon chain
    and a Java implementation of the Ethereum 2.0 beacon chain. The official Ethereum
    reference implementation, which these other repositories are modeling, is a Python
    implementation of the Ethereum 2.0 beacon chain.
  prefs: []
  type: TYPE_NORMAL
- en: The Ethereum 2.0 specification documents indicate that Ethereum 2.0 can initially
    be implemented without any consensus changes to Ethereum 1.0\. This means that
    at this early stage, the Ethereum 1.0 base layer will not undergo a fork or chain
    split while moving these exciting ideas forward into production. As I will discuss
    shortly, a contract (the gateway to the Ethereum 2.0) will be added to Ethereum
    1.0, and deposits into this contract will allow users to become validators on
    the Ethereum 2.0 beacon chain.
  prefs: []
  type: TYPE_NORMAL
- en: The Beacon Chain
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One of the core components, mentioned in the Ethereum 2.0 specifications, is
    the beacon chain. The *beacon chain* is the central PoS chain that underpins the
    sharding system. The beacon chain stores and maintains a registry of validators.
  prefs: []
  type: TYPE_NORMAL
- en: Validators
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The beacon chain invites new validators to join Ethereum 2.0\. As previously
    mentioned, validators join the beacon chain by simply depositing ether into the
    appropriate Ethereum 1.0 contract. An actively participating validator is able
    to propose blocks on the beacon chain. A validator who creates an Ethereum 2.0
    beacon chain block is also known as a *proposer*. In addition to proposing blocks,
    validators are also able to sign off on beacon chain blocks. However, to do so,
    the validator has to be part of a committee. Validators cannot self-select to
    be part of a committee. Instead, committees of independent validators are assembled
    in a random fashion. Randomness is generated by the beacon chain itself. A validator
    can exit the beacon chain voluntarily or be forced to exit in the event that the
    validator attacks the chain.
  prefs: []
  type: TYPE_NORMAL
- en: Shard Chain
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: There are many shard chains. Shard chains are where end-user transactions take
    place and where transaction information is stored. When signing off (attesting
    to) a block, the committee of validators create what is known as a *crosslink*.
    A crosslink is essentially a set of validator signatures, attesting to a block
    in a shard chain that is then confirmed into the beacon chain. A crosslink allows
    updates in a shard chain to be communicated with the beacon chain; in other words,
    crosslinks are used to determine the finality of shards.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: A very interesting implication of sharding is that today’s Ethereum-compatible
    blockchains such as Ethereum Classic and CyberMiles can now interoperate within
    the new Ethereum 2.0 ecosystem. For example, Ethereum Classic and its established
    miner community will stay as a PoW chain within the ecosystem. Its native cryptocurrency,
    the ETC, will become the PoW store-of-value coin in the ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: One of the design goals of Ethereum 2.0 is to allow for a typical consumer laptop
    to process (validate) shards, including any system-level validation such as the
    beacon chain. This is made possible because the sharding architecture now uses
    its own PoS chain as opposed to the original idea, mentioned earlier, where the
    old sharding architecture used to consist of a single smart contract on the PoW
    chain.
  prefs: []
  type: TYPE_NORMAL
- en: You may have already realized by now that Ethereum 2.0/Serenity is a new blockchain,
    albeit it’s one that links to the existing Ethereum 1.0 PoW chain (i.e., the new
    PoS chain is aware of the block hashes of the PoW chain, and so forth). The goal
    for this architecture will allow ether to be moved between the original PoW chain
    and the PoS chain. In addition, the long-term vision would be to allow applications
    from the current blockchain to be redeployed on a shard of the Ethereum 2.0 system.
    This would be implemented via a new EVM interpreter written in eWASM.
  prefs: []
  type: TYPE_NORMAL
- en: eWASM
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Currently there are separate compilers for each of the smart contract programming
    languages. You can build and install either the Solidity or Vyper compiler software
    and run it on local disk. Alternatively, you can use the free online code editors
    for both Solidity and Vyper.
  prefs: []
  type: TYPE_NORMAL
- en: The job of a compiler is to convert your high-level smart contract code into
    bytecode and application binary interface (ABI). Once your code is compiled, it
    can be executed by the EVM.
  prefs: []
  type: TYPE_NORMAL
- en: eWASM is Ethereum’s own implementation of WebAssembly. WebAssembly is currently
    being designed as an open standard by a W3C Community Group.
  prefs: []
  type: TYPE_NORMAL
- en: eWASM is being developed to replace the EVM. Once eWASM is implemented, developers
    will be able to write smart contracts in other languages such as Rust and C/C++
    as opposed to just Solidity and Vyper. It is important to note that eWASM will
    be completely backward compatible with the current EVM. This means smart contracts
    that are currently written in Solidity or Vyper will still be able to execute
    in the new environment.
  prefs: []
  type: TYPE_NORMAL
- en: Delivery Phases of Ethereum 2.0
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The delivery phases of Ethereum 2.0 should run something like the following.
  prefs: []
  type: TYPE_NORMAL
- en: Phase 0
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Ethereum 2.0 is expected to be implemented as follows. Phase 0, which I have
    briefly covered, involves the introduction of the beacon chain, so essentially
    Phase 0 is the beginning of the new PoS chain. More specifically, it’s a PoS beacon
    chain without shards.
  prefs: []
  type: TYPE_NORMAL
- en: Phase 1
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The next phase, Phase 1, will implement shards as data chains. Phase 1 will
    provide the foundations to create decentralized data applications; however, to
    fully implement any of these types of applications, the benefits of Phase 2 will
    be required. Put simply, Phase 1 is implementing basic sharding without an EVM.
  prefs: []
  type: TYPE_NORMAL
- en: Phase 2
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: EVM state transition functionality will be introduced in Phase 2\. Phase 2 will
    introduce functionality to create and manage accounts and contracts as well as
    transfer funds between shards and so forth.
  prefs: []
  type: TYPE_NORMAL
- en: 'The subsequent phases 3, 4, 5, and 6 have plans to introduce the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A light-client state protocol
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cross-shard transactions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tight coupling with main chain security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Super-quadratic or exponential sharding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is hoped that state transition changes and transaction executions will improve
    significantly because of the implementation of eWASM. There is a comprehensive
    Ethereum 2.0 road map that details each proposed phase. Please keep in mind that
    these specifications do change frequently and that the proof-of-concept algorithms
    and code repositories are under heavy construction.
  prefs: []
  type: TYPE_NORMAL
- en: Post–Ethereum 2.0 Innovation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I mentioned ZK-STARKs previously in this chapter. The main difference between
    SNARKs and STARKs is transparency. More specifically, there is no “trusted setup”
    in ZK-STARKs (no secrets in the setup of the system). This is an interesting area
    of research, and there is a chance that Ethereum will eventually upgrade to the
    use of STARKs to perform tasks such as data availability checks, state execution
    correctness checks, and improved base-layer cross-shard transactions, to name
    a few.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, I discussed the future direction of the Ethereum blockchain.
    Ethereum is not only a decentralized blockchain but also a decentralized developer
    community. It has a robust and democratic upgrade process known as the EIP. We
    are optimistic that Ethereum will remain one of the most widely used and technically
    advanced blockchains in the future.
  prefs: []
  type: TYPE_NORMAL
