- en: 'Part III: Ethereum in Depth'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三部分：深入以太坊
- en: In the previous part, I introduced you to the concepts and tools for Ethereum
    smart contract and dapp development. In the next several chapters, we will dive
    deeper into Ethereum. We will look into how smart contract data and states are
    stored in the Ethereum blockchain and how smart contract developers could make
    use of such data. We will also look into best practices to secure smart contracts,
    which is a major issue the community faces today. Finally, we will review the
    Ethereum road map on what’s coming for developers.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一部分中，我向你介绍了以太坊智能合约和DApp开发的的概念和工具。在接下来的几章中，我们将更深入地了解以太坊。我们将探讨智能合约数据和状态是如何存储在以太坊区块链中的，以及智能合约开发者如何利用这些数据。我们还将探讨保障智能合约安全的最佳实践，这是社区今天面临的一个主要问题。最后，我们将回顾以太坊路线图，了解开发人员即将面临的内容。
- en: 9. Inside Ethereum
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9. 以太坊内部
- en: By Tim McCallum
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 作者：Tim McCallum
- en: In the previous chapters, you learned how to interact with the Ethereum blockchain
    from the outside as a client. The chapters covered topics such as executing transactions,
    developing and deploying smart contracts, and developing dapps using tools like
    the web3 library. However, to truly understand how Ethereum works and perhaps
    modify its behavior for your own purposes, we will need to look deeper beneath
    the external interface of the blockchain platform.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，你已经学习了如何作为客户端从外部与以太坊区块链进行交互。这些章节涵盖了执行交易、开发和部署智能合约以及使用web3库等工具开发去中心化应用（DApps）等内容。然而，为了真正理解以太坊的工作原理，或许为了你自己的目的而修改其行为，我们需要更深入地研究区块链平台的对外接口之下。
- en: In this chapter, I deconstruct Ethereum to provide you with an understanding
    of its data storage layer, and I introduce the concept of blockchain state. Also,
    I cover the theory behind the Patricia trie data structure and demonstrate Ethereum’s
    concrete implementation of tries using Google’s LevelDB database. From this point,
    you will be able to execute transactions and explore how Ethereum’s state responds
    to activities such as transactions.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我解构了以太坊，为您提供了对其数据存储层的理解，并介绍了区块链状态的概念。此外，我涵盖了帕特里夏（Patricia）字典树数据结构的理论，并展示了以太坊使用谷歌的LevelDB数据库实现字典树的具体方式。从这一点开始，您将能够执行交易并探索以太坊状态如何响应交易等活动。
- en: What Is Blockchain State?
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 区块链状态是什么？
- en: Bitcoin’s *state* is represented by its global collection of unspent transaction
    outputs (UTXOs). The transfer of value in Bitcoin is actioned through transactions.
    More specifically, a Bitcoin user can spend one or more UTXOs by creating a transaction
    and adding one or more UTXOs as the transaction’s input.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币的状态由其全球未花费交易输出（UTXO）集合表示。比特币中的价值转移是通过交易进行的。更具体地说，比特币用户可以通过创建交易并添加一个或多个UTXO作为交易的输入，来花费一个或多个UTXO。
- en: A full explanation of UTXOs is beyond the scope of this chapter. However, I
    mention UTXOs in the following paragraphs to point out a fundamental difference
    between Bitcoin and Ethereum. Specifically, the following two Bitcoin examples
    will provide contrast between Bitcoin’s UTXO model and Ethereum’s world state.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章对未花费交易输出（UTXO）的完整解释超出了范围。然而，我在下面的段落中提到UTXO，以指出比特币和以太坊之间的根本区别。具体来说，下面的两个比特币示例将提供比特币的UTXO模型与以太坊的世界状态之间的对比。
- en: First, Bitcoin UTXOs cannot be partially spent. If a Bitcoin user spends 0.5
    Bitcoin (using her only UTXO, which is worth 1 Bitcoin), the user has to deliberately
    self-address (send herself ) 0.5 Bitcoins (BTC) in return change ([Figure 9.1](ch09.xhtml#ch09fig1)).
    If the user doesn’t send change, she will lose the 0.5 Bitcoin change to the Bitcoin
    miner who mines her transaction.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，比特币的UTXO不能部分花费。如果一个比特币用户花费了0.5比特币（使用她唯一的UTXO，价值1比特币），用户必须故意自我地址（发送给自己）0.5比特币（BTC）作为回报([图9.1](ch09.xhtml#ch09fig1))。如果用户不发送回报，她将把0.5比特币的回报损失给挖出她交易的比特币矿工。
- en: '![image](Images/yuan_f09_01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/yuan_f09_01.jpg)'
- en: '**Figure 9.1** Sending a partial Bitcoin'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**图9.1** 发送部分比特币'
- en: Second, at the most fundamental level, Bitcoin does not maintain user account
    balances. With Bitcoin, a user simply holds the private keys to one or more UTXOs
    at any given point in time ([Figure 9.2](ch09.xhtml#ch09fig2)). Digital wallets
    make it seem like the Bitcoin blockchain automatically stores and organizes user
    account balances and so forth. This is not the case.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，在最深层次上，比特币不维护用户账户余额。在比特币中，用户只需在任意给定时间持有一个或多个UTXO的私钥([图9.2](ch09.xhtml#ch09fig2))。数字钱包使得看起来比特币区块链会自动存储和组织用户账户余额等等。并非如此。
- en: '![image](Images/yuan_f09_02.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
- en: '**Figure 9.2** Computing account balance for Bitcoin'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: A user account balance in Bitcoin is an abstract notion. Realistically, a user’s
    account balance is the sum total of each individual UTXO (for which that user
    holds the corresponding private key), as shown in [Figure 9.3](ch09.xhtml#ch09fig3).
    The key that a user holds can be used to individually sign/spend each of the UTXOs.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f09_03.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
- en: '**Figure 9.3** A Bitcoin wallet aggregates UTXOs to show account balances.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'The UTXO system in Bitcoin works well, in part, because digital wallets are
    able to facilitate most of the tasks associated with transactions. This includes
    but is not limited to the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Handling UTXOs
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing keys
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting transaction fees
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing return change addresses
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aggregating UTXOs (to show available, pending, and total balances)
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interestingly, a backup of a nondeterministic wallet (like the Bitcoin core
    wallet pictured in [Figure 9.3](ch09.xhtml#ch09fig3)) provides only a snapshot
    of the UTXOs (at that point in time). If a user performs any transactions (sending
    or receiving), the original backup that the user made will be out-of-date.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarize, you now know the following:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: The Bitcoin blockchain does not hold account balances.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bitcoin wallets hold keys to UTXOs.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If included in a transaction, an entire UTXO is spent (in some cases partially
    received as change in the form of a new UTXO).
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, let’s look into the Ethereum blockchain.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum State
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In contrast to the previous information, the Ethereum world state is able to
    manage account balances and more. The state of Ethereum is not an abstract concept.
    It is part of Ethereum’s base protocol layer. Ethereum is a transaction-based
    state machine; in other words, it’s a technology on which all transaction-based
    state machine concepts can be built.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Storing state data on each Ethereum node allows for light clients that do not
    necessarily need to download the entire blockchain to function. Light clients
    just need access to the state database on a node to get the current state of the
    entire system and send in transactions to alter the state. That enables a whole
    range of applications to be developed on the Ethereum blockchain efficiently.
    Without stored data on nodes and light clients, most smart contracts or dapp use
    cases would be impossible.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: For example, an interesting idea mentioned in the Ethereum white paper is the
    notion of a savings account. In this scenario, two users (perhaps a husband and
    wife, or business partners) can each withdraw 1 percent of the account’s total
    balance per day. This idea is mentioned in the “Further Applications” section
    of the white paper, but it’s interesting because it, in theory, could be implemented
    as part of Ethereum’s base protocol layer (as opposed to having to be written
    as part of a second-layer solution or third-party wallet). You may recall the
    discussion about Bitcoin UTXOs earlier in this chapter. UTXOs are blind to blockchain
    data, and as discussed, the Bitcoin blockchain does not actually store a user’s
    account balance. For this reason, the base protocol layer of Bitcoin is far less
    likely (or perhaps unable) to implement any sort of daily spend limits.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以太坊白皮书中有个有趣的想法，就是储蓄账户的概念。在这种情况下，两个用户（可能是丈夫和妻子，或商业伙伴）可以每天各自提取账户总余额的1%。这个想法在白皮书的“进一步应用”部分提到，但它有趣之处在于，理论上，这可以作为以太坊基础协议层的一部分来实现（而不是必须作为第二层解决方案或第三方钱包的一部分来编写）。你可能还记得本章早些时候关于比特币UTXO的讨论。UTXO对区块链数据是盲目的，正如讨论的那样，比特币区块链实际上并不存储用户的账户余额。正因为如此，比特币的基础协议层不太可能（或者可能无法）实现任何类型的每日支出限制。
- en: Next, let’s look into the actual structure of the Ethereum state data store.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们深入了解以太坊状态数据存储的实际结构。
- en: Data Structure
  id: totrans-35
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 数据结构
- en: Let’s start at the beginning. As with all other blockchains, the Ethereum blockchain
    begins life at its own genesis block. From this point (genesis state at block
    0) onward, activities such as transactions, contracts, and mining will continually
    change the state of the Ethereum blockchain. In Ethereum, an example of this is
    an account balance (stored in the state trie, as shown in [Figure 9.4](ch09.xhtml#ch09fig4)),
    which changes every time a transaction, in relation to that account, takes place.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从开始的地方说起。与所有其他区块链一样，以太坊区块链从它的创世区块开始。从这一点（区块0的状态）开始，诸如交易、合约和挖矿等活动将不断改变以太坊区块链的状态。在以太坊中，一个例子就是账户余额（存储在状态梅克尔树中，如图
    9.4 所示），每当与该账户相关的交易发生时，该余额就会发生变化。
- en: '![image](Images/yuan_f09_04.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/yuan_f09_04.jpg)'
- en: '**Figure 9.4** The internal structure of data storage in an Ethereum node'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 9.4** 以太坊节点数据存储的内部结构'
- en: Importantly, data such as account balances is not stored directly in the blocks
    of the Ethereum blockchain. Only the root node hashes of the transaction trie,
    state trie, and receipts trie are stored directly in the blockchain.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，诸如账户余额之类的数据并不是直接存储在以太坊区块链的区块中。只有交易梅克尔树、状态梅克尔树和收据梅克尔树的根节点哈希值是直接存储在区块链中的。
- en: You will also notice, from [Figure 9.4](ch09.xhtml#ch09fig4), that the root
    node hash of the storage trie (where all of the smart contract data is kept) actually
    points to the state trie, which in turn points to the blockchain. I will zoom
    in and cover all of this in more detail soon.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你也会注意到，从[图 9.4](ch09.xhtml#ch09fig4)中，存储梅克尔树的根节点哈希（保存所有智能合约数据的地方）实际上指向状态梅克尔树，而状态梅克尔树又指向区块链。我将会放大并详细讲解所有这些内容。
- en: 'There are two vastly different types of data in Ethereum: permanent data and
    ephemeral data. An example of permanent data is a transaction. Once a transaction
    has been fully confirmed, it is recorded in the transaction trie and never altered.
    An example of ephemeral data is the balance of a particular Ethereum account address.
    The balance of an account address is stored in the state trie and is altered whenever
    transactions against that particular account occur. It makes sense that permanent
    data, such as mined transactions, and ephemeral data, such as account balances,
    should be stored separately. Ethereum uses trie data structures (as broadly outlined
    earlier) to manage data. The next section will take a detour and provide a quick
    overview on tries.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊中有两种截然不同的数据类型：永久数据和短暂数据。永久数据的一个例子是交易。一旦交易被完全确认，它就会记录在交易梅克尔树中，并且永远不会被更改。一个短暂数据的例子是特定以太坊账户地址的余额。账户地址的余额存储在状态梅克尔树中，每当针对该特定账户的交易发生时，该余额就会被更改。永久数据（如挖出的交易）和短暂数据（如账户余额）应该分别存储是合理的。以太坊使用梅克尔树数据结构（如前面广泛概述的）来管理数据。下一节将暂时偏离主题，并提供关于梅克尔树的快速概述。
- en: Trie (or Tree)
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 梅克尔树（或树）
- en: A *trie* (or tree) is a well-known data structure that is used for storing sequences
    of characters. Ethereum exclusively uses what is known as the “practical algorithm
    to retrieve information coded in alphanumeric” (Patricia) trie. The main advantage
    of the Patricia trie is its compact storage. We will now analyze the inner workings
    of the standard (more traditional) trie versus the Patricia trie.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Standard Trie
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Figure 9.5](ch09.xhtml#ch09fig5) shows the structure of a standard trie that
    stores words. Each character in the word is a node in the tree, and each word
    is terminated by a special null pointer.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f09_05.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
- en: '**Figure 9.5** A standard trie storing two words. The special character \0
    represents the null pointer.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Rules for Adding a Word to the Trie
  id: totrans-48
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We follow the search path for the word we are adding. If we encounter a null
    pointer, we create a new node. When we have finished adding our word, we create
    a null pointer (terminator). When adding a (shorter) word that is contained in
    another (longer) word, we just exhaust all of the characters and then add a null
    pointer (terminator).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Rules for Deleting a Word from the Trie
  id: totrans-50
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We search for a leaf (the end of a branch) on the trie that represents the string
    (which we want to delete). We then start deleting all nodes from the leaf back
    to the root of the trie—unless we hit a node with more than one child; in this
    case, we stop.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Rules for Searching for a Word in the Trie
  id: totrans-52
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We examine each of the characters in the string for which we are searching and
    follow the trie for as long as it provides our path (in the right sequence). If
    we encounter a null pointer before exhausting all the characters in the string
    (which we are searching for), then we can conclude that the string is not stored
    in the trie. On the contrary, if we reach a leaf (the end of a branch) and that
    path (from the leaf back to the root of the trie) represents our string, we conclude
    that the string is stored in the trie.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Patricia Trie
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Figure 9.6](ch09.xhtml#ch09fig6) shows the structure of a Patricia trie that
    stores words. The storage is more compact than the standard trie. Each word is
    terminated by a special null pointer.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f09_06.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
- en: '**Figure 9.6** A Patricia trie storing two words'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Rules for Adding a Word to the Patricia Trie
  id: totrans-58
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Patricia tries group all common characters into a single branch. Any unusual
    characters will constitute a new branch in the path. When adding a word to a Patricia
    trie, we exhaust all the characters and then add the null pointer (terminator),
    as shown in [Figure 9.7](ch09.xhtml#ch09fig7).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f09_07.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
- en: '**Figure 9.7** Adding a word (`*wooden*`) to the Patricia trie'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Rules for Deleting a Word from the Patricia Trie
  id: totrans-62
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This is the same as with a traditional trie, except for when deleting nodes
    (from the leaf back to the root), we must ensure that all parent nodes must be
    in possession of at least two child nodes. It is okay for a single child node
    to just have characters and a null pointer (this occurs in [Figure 9.7](ch09.xhtml#ch09fig7),
    at the end of every word). It is also okay for a single node to just have a null
    pointer (this occurs if a shorter word is contained in a longer word). See [Figure
    9.7](ch09.xhtml#ch09fig7), which illustrates how *wood* and *wooden* coexist in
    the same trie.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这与传统字典树相同，除非是在删除节点（从叶子节点回溯到根节点）时，我们必须确保所有父节点至少拥有两个子节点。一个单独的子节点可以只包含字符和一个空指针（这种情况出现在[图9.7](ch09.xhtml#ch09fig7)的每个单词末尾），一个单独的节点也可以只有一个空指针（如果一个较短的单词包含在一个较长的单词中）。参见[图9.7](ch09.xhtml#ch09fig7)，它展示了*wood*和*wooden*如何在同一个字典树中共存。
- en: Importantly, when deleting from a trie, a path cannot be left with a parent
    node that connects to just a single child node. If this occurs (when deleting,
    we need to concatenate the appropriate characters to resolve this). This is illustrated
    in [Figure 9.8](ch09.xhtml#ch09fig8) (where we delete the word from the trie).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，当从字典树中删除时，不能留下一个路径，其父节点只连接到一个子节点。如果发生这种情况（在删除时，我们需要连接适当的字符来解决此问题）。这在[图9.8](ch09.xhtml#ch09fig8)中说明（我们在字典树中删除单词）。
- en: '![image](Images/yuan_f09_08.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/yuan_f09_08.jpg)'
- en: '**Figure 9.8** Deleting a word (*word*) from the Patricia trie and reorganizing
    it'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**图9.8** 从帕特里夏字典树中删除单词(*word*)并重新组织它'
- en: Rules for Searching for a Word in the Patricia Trie
  id: totrans-67
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在帕特里夏字典树中搜索单词的规则
- en: The rules for searching the Patricia trie are the same as for searching the
    standard trie.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索帕特里夏字典树的规则与搜索标准字典树的规则相同。
- en: Similarities between the Trie and Patricia Trie
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 字典树与帕特里夏字典树的相似之处
- en: The runtime “O” for adding is O(mN), where “m” is the length of the string we
    are adding and “N” is the size of the available alphabet.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 添加的运行时间“O”是O(mN)，其中“m”是我们正在添加的字符串的长度，“N”是可用的字母表的大小。
- en: The runtime for deleting is O(mN), where “m” is the length of the string we
    want to delete and “N” is again the size of the available alphabet.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 删除的运行时间是O(mN)，其中“m”是我们想要删除的字符串的长度，“N”是可用的字母表的大小。
- en: The runtime for searching is O(m), where “m” is the length of the string we
    are searching for.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索的运行时间是O(m)，其中“m”是我们正在搜索的字符串的长度。
- en: Main Difference between the Trie and Patricia Trie
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 字典树与帕特里夏字典树的主要区别
- en: The main advantage of using the Patricia trie is in relation to storage.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 使用帕特里夏字典树的主要优点是与存储有关。
- en: The storage requirement “O” for the standard trie is O(MN), where “M” is the
    total length of all strings in the trie and “N” is the size of the available alphabet.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 标准字典树的存储需求“O”是O(MN)，其中“M”是字典树中所有字符串的总长度，“N”是可用的字母表的大小。
- en: The storage requirement “O” for the Patricia trie is O(nN+M), where “n” is the
    number of strings stored in the Patricia trie, “N” is the size of the available
    alphabet, and “M” is the total length of all strings in the trie.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 帕特里夏字典树的存储需求“O”是O(nN+M)，其中“n”是存储在帕特里夏字典树中的字符串数，“N”是可用的字母表的大小，“M”是字典树中所有字符串的总长度。
- en: In short, you will have noticed a marked difference in the depth of the tries.
    The Patricia trie is less deep (shallower). This is because of the Patricia trie’s
    ability to group common characters (and concatenate null pointers to leaves).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，你将会注意到字典树的深度有明显的不同。帕特里夏字典树（Patricia trie）较浅。这是因为帕特里夏字典树能够将常见字符分组（并将空指针连接到叶子节点）。
- en: Modified Merkle Patricia Trie
  id: totrans-78
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 修改后的Merkle Patricia字典树
- en: In the Ethereum state database, the data is stored in a modified Merkle Patricia
    trie, which means the root node of the trie is a hash of the data in its leaves.
    This design makes the state database on each node resistant to tampering, just
    like the blockchain itself.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在以太坊状态数据库中，数据存储在一个修改后的Merkle Patricia字典树中，这意味着字典树的根节点是叶子中数据的哈希。这种设计使得每个节点上的状态数据库抵抗篡改，就像区块链本身一样。
- en: Every function (put, update, and delete) performed on a trie in Ethereum utilizes
    a deterministic cryptographic hash. Further, the unique cryptographic hash of
    a trie’s root node can be used as evidence that the trie has not been tampered
    with.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在以太坊中，对字典树（trie）进行的每项功能（插入、更新和删除）都使用一个确定性的加密哈希。此外，字典树根节点的唯一加密哈希可以用作证据，证明字典树没有被篡改过。
- en: For example, any changes to a trie’s data, at any level (such as increasing
    an account’s balance), will completely change the root hash. This cryptographic
    feature provides an opportunity for light clients (devices that do not store the
    entire blockchain) to quickly and reliably query the blockchain; in other words,
    does account 0x…4857 have enough funds to complete this purchase at block height
    5044866?
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对树中任何层次的数据（如增加账户余额）的任何更改都会完全改变根哈希。这一加密特性为轻客户端（不存储整个区块链的设备）提供了快速可靠地查询区块链的机会；换句话说，账户0x…4857是否有足够的资金在区块高度5044866完成这笔购买？
- en: Trie Structure in Ethereum
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 以太坊中的树结构
- en: Let’s look at the state, storage, and transaction tries in a bit more depth.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地了解一下状态树、存储树和交易树。
- en: 'State Trie : The One and Only'
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 状态树：独一无二的一个
- en: There is one, and one only, global state trie in Ethereum. This global state
    trie is constantly updated. The state trie contains a key-value pair for every
    account that exists on the Ethereum network.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊中只有一个全局状态树。这个全局状态树是在不断地更新。状态树包含以太坊网络上存在的每个账户的一个键值对。
- en: The *key* is a single 160-bit identifier (the address of an Ethereum account).
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关键**是一个160位的唯一标识符（以太坊账户的地址）。'
- en: 'The *value* in the global state trie is created by encoding the following account
    details of an Ethereum account (using the recursive-length prefix [RLP] encoding
    method): nonce, balance, storageRoot, codeHash.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局状态树中的**值**是通过使用递归长度前缀（RLP）编码方法编码以下以太坊账户详情生成的：nonce、余额、存储根、代码哈希。
- en: The state trie’s root node (a hash of the entire state trie at a given point
    in time) is used as a secure and unique identifier for the state trie; the state
    trie’s root node is cryptographically dependent on all internal state trie data.
    The state trie’s root node is stored in the Ethereum block header corresponding
    to the time when the state trie was updated (see [Figure 9.9](ch09.xhtml#ch09fig9))
    and can be queried from the block ([Figure 9.10](ch09.xhtml#ch09fig10)).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 状态树的根节点（给定时间点整个状态树的哈希）是状态树的安全且唯一的标识符；状态树的根节点与所有内部状态树数据在密码学上有关。状态树的根节点存储在状态树更新的以太坊区块头部（见[图9.9](ch09.xhtml#ch09fig9)）并且可以从区块中查询（[图9.10](ch09.xhtml#ch09fig10)）。
- en: '![image](Images/yuan_f09_09.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/yuan_f09_09.jpg)'
- en: '**Figure 9.9** Relationship between the state trie (LevelDB implementation
    of a Merkle Patricia trie) and an Ethereum block'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**图9.9** 状态树（LevelDB实现的Merkle Patricia树）与以太坊区块之间的关系'
- en: '![image](Images/yuan_f09_10.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/yuan_f09_10.jpg)'
- en: '**Figure 9.10** Showing the trie roots'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**图9.10** 展示树根'
- en: 'Storage Trie : Where the Contract Data Lives'
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 存储树：智能合约数据存放之处
- en: A storage trie is where all the contract data lives. Each Ethereum account has
    its own storage trie. A Keccak 256-bit hash of the storage trie’s root node is
    stored as the storageRoot value in the global state trie ([Figure 9.11](ch09.xhtml#ch09fig11)).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 存储树是所有合约数据存放的地方。每个以太坊账户都有自己的存储树。存储树的根节点的Keccak 256位哈希作为全局状态树的存储根值存储（[图9.11](ch09.xhtml#ch09fig11)）。
- en: '![image](Images/yuan_f09_11.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/yuan_f09_11.jpg)'
- en: '**Figure 9.11** State trie — Keccak 256-bit hash of the state trie’s root node
    stored as the stateRoot value in a given block'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**图9.11** 状态树——状态树的根节点的Keccak 256位哈希作为给定区块的状态根值存储'
- en: 'Transaction Trie : One per Block'
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 交易树：每个区块一个
- en: Each Ethereum block has its own separate transaction trie. A block contains
    many transactions. The order of the transactions in a block is of course decided
    by the miner who assembles the block. The path to a specific transaction in the
    transaction trie is via the RLP encoding of the index of where the transaction
    sits in the block. Mined blocks are never updated; the position of the transaction
    in a block never changes. This means that once you locate a transaction in a block’s
    transaction trie, you can return to the same path over and over to retrieve the
    same result. [Figure 9.12](ch09.xhtml#ch09fig12) shows how the transaction trie’s
    root hash is stored in an Ethereum block header.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 每个以太坊区块都有自己的独立交易树。一个区块包含许多交易。当然，区块中交易的顺序是由组装区块的矿工决定的。在交易树中找到特定交易的路径是通过该交易在区块中的位置的RLP编码。挖出的区块永远不会被更新；交易在区块中的位置永远不会改变。这意味着一旦你在区块的交易树中找到一个交易，你可以反复回到相同的路径来获取相同的结果。**图9.12**显示了交易树的根哈希如何存储在以太坊区块头部。[图9.11](ch09.xhtml#ch09fig11)
    展示了状态树的Keccak 256位哈希作为给定区块的状态根值存储。
- en: '![image](Images/yuan_f09_12.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/yuan_f09_12.jpg)'
- en: '**Figure 9.12** The transaction trie stores data about each transaction in
    a block.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**图9.12** 交易字典树存储了关于每个区块中交易的 data。'
- en: Concrete Examples of Tries in Ethereum
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 以太坊中字典树的具体示例
- en: The main Ethereum clients use two different database software solutions to store
    their tries. Ethereum’s Rust client, Parity, uses RocksDB. Ethereum’s Go, C++,
    and Python clients all use LevelDB.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的以太坊客户端使用两种不同的数据库软件解决方案来存储它们的字典树。以太坊的Rust客户端Parity使用RocksDB。以太坊的Go、C++和Python客户端都使用LevelDB。
- en: RocksDB is out of scope for this book. Let’s explore how three out of the four
    major Ethereum clients utilize LevelDB.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: RocksDB超出了本书的范围。让我们探索三个四大以太坊客户端如何使用LevelDB。
- en: LevelDB is an open source Google key-value storage library that provides, among
    other things, forward and backward iterations over data, ordered mapping from
    string keys to string values, custom comparison functions, and automatic compression.
    The data is automatically compressed using Snappy, an open source Google compression/decompression
    library. While Snappy does not aim for maximum compression, it aims for very high
    speeds. LevelDB is an important storage and retrieval mechanism that manages the
    state of the Ethereum network. As such, LevelDB is a dependency for the most popular
    Ethereum clients (nodes) such as go-ethereum, cpp-ethereum, and pyethereum.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: LevelDB是一个开源的Google键值存储库，提供诸如正向和反向迭代数据、按字符串键到字符串值的有序映射、自定义比较函数和自动压缩等功能。数据使用Snappy，一个开源的Google压缩/解压缩库自动压缩。虽然Snappy不追求最大压缩率，但它追求非常高的速度。LevelDB是管理以太坊网络状态的重要存储和检索机制。因此，LevelDB是最受欢迎的以太坊客户端（节点）如go-ethereum、cpp-ethereum和pyethereum的依赖。
- en: '**Note**'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: While the implementation of the trie data structure can be done on disk (using
    database software such as LevelDB), it is important to note that there is a difference
    between traversing a trie and simply looking at the flat key-value database.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以在磁盘上实现字典树数据结构（使用如LevelDB的数据库软件），但重要的是要注意遍历字典树和简单查看扁平键值数据库之间是有区别的。
- en: To learn more, we have to access the data in LevelDB using the appropriate Patricia
    trie libraries. To do this, we will need an Ethereum installation (see [Chapter
    5](ch05.xhtml#ch05)). Once you have set up your Ethereum private network, you
    will be able to execute transactions and explore how Ethereum’s state responds
    to network activities such as transactions, contracts, and mining. In the next
    section, I will provide code examples and screen captures from an Ethereum private
    network.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解更多内容，我们需要使用适当的Patricia字典树库来访问LevelDB中的数据。为此，我们需要一个以太坊安装（参见[第5章](ch05.xhtml#ch05)）。一旦你设置好了你的以太坊私有网络，你将能够执行交易并探索以太坊状态如何响应网络活动，如交易、合约和挖矿。在下一节中，我将提供来自以太坊私有网络的代码示例和屏幕截图。
- en: Analyzing the Ethereum Database
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分析以太坊数据库
- en: 'As mentioned previously, there are many Merkle Patricia tries (referenced in
    each block) within the Ethereum blockchain: state trie, storage trie, transaction
    trie, and receipts trie.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，以太坊区块链中有许多Merkle Patricia字典树（在每个块中都有引用）：状态字典树、存储字典树、交易字典树和收据字典树。
- en: 'To reference a particular Merkle Patricia trie in a particular block, we need
    to obtain its root hash as a reference. The following commands allow us to obtain
    the root hashes of the state, transaction, and receipt tries in the genesis block:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要引用特定块中的特定Merkle Patricia字典树，我们需要获取其根哈希作为引用。以下命令允许我们获取创世区块中状态、交易和收据字典树的根哈希：
- en: '[Click here to view code image](Images/ch09_images.xhtml#pro9_1)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击此处查看代码图片](Images/ch09_images.xhtml#pro9_1)'
- en: '[PRE0]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you want the root hashes of the latest block (instead of the genesis block),
    please use the following command:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要最新块的根哈希（而不是创世块），请使用以下命令：
- en: '[Click here to view code image](Images/ch09_images.xhtml#pro9_2)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击此处查看代码图片](Images/ch09_images.xhtml#pro9_2)'
- en: '[PRE1]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We will be using a combination of the `nodejs`, `level`, and `ethereumjs` commands
    (which implements Ethereum’s VM in JavaScript) to inspect the LevelDB database.
    The following commands will further prepare our environment (in Ubuntu Linux):'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`nodejs`、`level`和`ethereumjs`命令（其中实现了以太坊的虚拟机JS）来检查LevelDB数据库。以下命令将进一步准备我们的环境（在Ubuntu
    Linux中）：
- en: '[Click here to view code image](Images/ch09_images.xhtml#pro9_3)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击此处查看代码图片](Images/ch09_images.xhtml#pro9_3)'
- en: '[PRE2]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Get the Data
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 获取数据
- en: From this point, running the following code will print a list of the Ethereum
    account keys (which are stored in the state root of your Ethereum private network).
    The code connects to Ethereum’s LevelDB database, enters Ethereum’s world state
    (using a stateRoot value from a block in the blockchain), and then accesses the
    keys to all accounts on the Ethereum private network ([Figure 9.13](ch09.xhtml#ch09fig13)).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 从这一点开始，运行以下代码将会打印出以太坊账户密钥的列表（这些密钥存储在以太坊私有网络的状态根中）。该代码连接到以太坊的LevelDB数据库，进入以太坊的世界状态（使用区块链中区块的状态根值），然后访问以太坊私有网络中所有账户的密钥（[图9.13](ch09.xhtml#ch09fig13)）。
- en: '![image](Images/yuan_f09_13.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/yuan_f09_13.jpg)'
- en: '**Figure 9.13** Raw data read from the trie in LevelDB'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**图9.13** 从LevelDB中读取的三叉状态数据'
- en: '[Click here to view code image](Images/ch09_images.xhtml#pro9_4)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击此处查看代码图片](Images/ch09_images.xhtml#pro9_4)'
- en: '[PRE3]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**Note**'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: Interestingly, accounts in Ethereum are added to the state trie only once a
    transaction has taken place (in relation to that specific account). For example,
    just creating a new account using `geth account new` will not include that account
    in the state trie, even after many blocks have been mined. However, if a successful
    transaction (one that costs gas and is included in a mined block) is recorded
    against that account, then and only then will that account appear in the state
    trie. This is clever logic that protects against malicious attackers continuously
    creating new accounts and bloating the state trie.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，以太坊账户仅在发生交易时（与特定账户有关）才会添加到状态树中。例如，仅仅使用`geth account new`创建新账户并不会将该账户包含在状态树中，即使已经挖出了很多区块。然而，只有在针对该账户记录了成功的交易（消耗了燃料并且被包含在挖出的区块中）时，该账户才会出现在状态树中。这是一种巧妙的逻辑，可以防止恶意攻击者持续创建新账户并膨胀状态树。
- en: Decoding the Data
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解码数据
- en: You will have noticed that querying LevelDB returns encoded results. This is
    because Ethereum uses its own specially modified Merkle Patricia trie implementation
    when interacting with LevelDB. The Ethereum wiki provides information about the
    design and implementation of both Ethereum’s modified Merkle Patricia trie and
    RLP encoding. In short, Ethereum has extended the trie data structures described
    earlier. For example, the modified Merkle Patricia trie contains a method that
    can shortcut the descent (down the trie) through the use of an extension node.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，查询LevelDB返回的是编码结果。这是因为以太坊在与LevelDB交互时使用了其自己的特殊修改Merkle Patricia尝试实现。以太坊维基提供了关于以太坊修改Merkle
    Patricia尝试和RLP编码的设计和实现的信息。简而言之，以太坊扩展了之前描述的尝试数据结构。例如，修改后的Merkle Patricia尝试包含一个可以通过扩展节点缩短（在尝试中下降）的方法。
- en: 'In Ethereum, a single modified Merkle Patricia trie node is one of the following:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在以太坊中，单个修改后的Merkle Patricia尝试节点是以下之一：
- en: An empty string (referred to as NULL)
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空字符串（称为NULL）
- en: An array that contains 17 items (referred to as a *branch*)
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含17个项目的数组（称为*分支*）
- en: An array that contains two items (referred to as a *leaf* )
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含两个项目的数组（称为*叶节点*）
- en: An array that contains two items (referred to as an *extension*)
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含两个项目的数组（称为*扩展节点*）
- en: 'As Ethereum’s tries are designed and constructed with rigid rules, the best
    way to inspect them is through the use of computer code. The following example
    uses ethereum.js. The following code (when provided with a particular block’s
    stateRoot as well as an Ethereum account address) will return that account’s correct
    balance in a human-readable form ([Figure 9.14](ch09.xhtml#ch09fig14)):'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 由于以太坊的尝试树是按照严格的规则设计和构建的，检查它们的最佳方式是使用计算机代码。以下示例使用ethereum.js。以下代码（在提供特定块的状态根以及以太坊账户地址时）将以人类可读的形式返回该账户的正确余额：[图9.14](ch09.xhtml#ch09fig14)：
- en: '![image](Images/yuan_f09_14.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/yuan_f09_14.jpg)'
- en: '**Figure 9.14** The decoded results'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**图9.14** 解码结果'
- en: '[Click here to view code image](Images/ch09_images.xhtml#pro9_5)'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击此处查看代码图片](Images/ch09_images.xhtml#pro9_5)'
- en: '[PRE4]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Read and Write the State LevelDB
  id: totrans-139
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**读写状态层级的LevelDB**'
- en: 'So far, I have shown how to access the Ethereum state’s LevelDB database using
    JavaScript on a local node. If you are familiar with GO and can work with Ethereum
    source code, there is an easier way. You could just import the go-ethereum source
    code in GO and call its functions to read and even modify the LevelDB database.
    The write function will not only change the values in the nodes but also update
    the root hash to reflect the changes. Specifically, the functions are in the following
    source code file:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我已经展示了如何使用本地节点上的JavaScript访问以太坊状态的LevelDB数据库。如果你熟悉GO并且能够处理以太坊源代码，还有更简单的方法。你可以直接导入GO中的go-ethereum源代码，并调用其函数来读取甚至修改LevelDB数据库。写入函数不仅会更改节点中的值，还会更新根哈希以反映变化。具体来说，这些函数在以下源代码文件中：
- en: '[Click here to view code image](Images/ch09_images.xhtml#pro9_6)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击此处查看代码图片](Images/ch09_images.xhtml#pro9_6)'
- en: '[PRE5]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: It contains methods such as `GetBalance`, `AddBalance`, `SubBalance`, and `SetBalance`
    to operate on the account balances. However, changing the state LevelDB in this
    way will change the data on only one node and will likely cause this node to go
    out of sync with the rest of the nodes on the network. The right way to change
    the state is to follow how go-ethereum processes a transaction and records it
    on the blockchain. That is out of scope for this book.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 它包含诸如`GetBalance`、`AddBalance`、`SubBalance`和`SetBalance`的方法来操作账户余额。然而，以这种方式更改状态LevelDB只会改变一个节点的数据，并且很可能导致这个节点与网络上其他节点脱节。更改状态的正确方法是遵循go-ethereum处理交易并将其记录在区块链上的方式。这超出了本书的范围。
- en: Conclusion
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结论
- en: In this chapter, I demonstrated that Ethereum has the ability to manage its
    state. This clever up-front design has many advantages, allowing for light clients
    and many different kinds of dapps that do not need to run the entire blockchain.
    It is important to understand the inner workings of Ethereum to write great smart
    contracts and applications on the Ethereum platform.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我展示了以太坊能够管理其状态。这种巧妙的预先设计有许多优点，允许轻量级客户端和许多不同类型的不需要运行整个区块链的DApps。理解以太坊的内部工作对于在以太坊平台上编写优秀的智能合约和应用非常重要。
- en: 10. Blockchain Data Services
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10. 区块链数据服务
- en: The previous chapter explained how the blockchain stores state data in block-based
    databases. The data is organized into a tree structure, and each block has a timestamp.
    This structure makes it easy to add new data (new blocks) and almost impossible
    to delete or change anything in old blocks, hence securing the blockchain data.
    However, while you can easily list each block’s content (i.e., transactions),
    it is hard to get longitudinal or aggregated views of the blockchain state. As
    a result, it is hard to search the blockchain data based on an address or specific
    actions performed by an address. Yet, many blockchain applications require the
    capability to search and analyze blockchain data.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章解释了区块链如何将状态数据存储在基于块的数据库中。数据被组织成树状结构，每个块都有一个时间戳。这种结构使得添加新数据（新块）变得容易，几乎不可能删除或更改旧块中的任何内容，从而保障了区块链数据的安全。然而，虽然你可以轻松列出每个块的内容（即，交易），但要获取区块链状态的纵向或聚合视图却很困难。因此，根据地址或地址执行的特定动作来搜索区块链数据变得困难。然而，许多区块链应用需要能够搜索和分析区块链数据的能力。
- en: A common design pattern for dapps is to call `view` functions in smart contracts
    to query data stored in the contract. However, such an approach is hard to scale
    since you need a full blockchain node to execute every `view` request, and the
    data query is limited by the data structure supported by the smart contract (i.e.,
    no SQL or JSON queries). By harvesting smart contract data into a data warehouse
    and enabling rich queries on the data warehouse, we could potentially build much
    more complex and scalable dapps.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的去中心化应用（DApps）设计模式是调用智能合约中的`view`函数来查询存储在合约中的数据。然而，这种方法难以扩展，因为你需要一个完整的区块链节点来执行每一个`view`请求，而且数据查询受限于智能合约支持的数据结构（即，不支持SQL或JSON查询）。通过将智能合约数据收割至数据仓库，并使数据仓库支持丰富的查询，我们可能构建出更加复杂和可扩展的DApps。
- en: In this chapter, I discuss how to build normalized databases for blockchain
    data so that they can be easily searched, analyzed, and browsed.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我讨论了如何为区块链数据构建规范化数据库，以便它们可以被轻松搜索、分析和浏览。
- en: Blockchain Explorers
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 区块链浏览器
- en: Almost every blockchain requires a data explorer so that users can search and
    browse transactions and account addresses on the blockchain. The blockchain explorers
    and the data services they provide are now part of standard infrastructure for
    every blockchain project.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每个区块链都需要一个数据浏览器，这样用户就可以在区块链上搜索和浏览交易和账户地址。区块链浏览器及其提供的数据服务现在已经成为了每个区块链项目标准的基础设施。
- en: For Bitcoin and compatible Bitcoin Cash (BCH) blockchains, there are many, including
    [https://explorer.bitcoin.com/btc](https://explorer.bitcoin.com/btc) and [https://btc.com/](https://btc.com/).
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于比特币和兼容的比特币现金 (BCH) 区块链，还有很多，包括 [https://explorer.bitcoin.com/btc](https://explorer.bitcoin.com/btc)
    和 [https://btc.com/](https://btc.com/)。
- en: For the Ethereum blockchain, the most well-known one is [https://etherscan.io/](https://etherscan.io/).
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于以太坊区块链，最知名的是 [https://etherscan.io/](https://etherscan.io/)。
- en: For the EOS blockchain, there are [https://bloks.io/](https://bloks.io/) and
    [https://eospark.com/](https://eospark.com/), among others.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 EOS 区块链，还有 [https://bloks.io/](https://bloks.io/) 和 [https://eospark.com/](https://eospark.com/)
    等。
- en: For the CyberMiles blockchain, there is [https://www.cmttracking.io/](https://www.cmttracking.io/).
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于千米iles 区块链，有一个 [https://www.cmttracking.io/](https://www.cmttracking.io/)。
- en: Each blockchain explorer provides information that is specific to its blockchain.
    For example, explorers for proof-of-work (PoW) blockchains like Bitcoin and Ethereum
    provide information such as hash rate and mining awards. Explorers for delegated
    proof-of-stake (PoS) blockchains like EOS and CyberMiles provide information such
    as block producer/validator nodes, voting power, and inflation awards. Explorers
    for smart contract platforms such as Ethereum, EOS, and CyberMiles provide information
    about smart contracts as well as assets held or issued by those smart contracts.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 每个区块链浏览器都提供与其区块链相关的特定信息。例如，比特币和以太坊等 PoW 区块链的浏览器提供诸如哈希率和挖矿奖励等信息。EOS 和千米iles 等委派
    PoS 区块链的浏览器提供诸如区块生产者/验证节点、投票权和通胀奖励等信息。以太坊、EOS 和千米iles 等智能合约平台的浏览器也提供智能合约以及那些智能合约持有或发行的资产的信息。
- en: '[Figure 10.1](ch10.xhtml#ch10fig1), [Figure 10.2](ch10.xhtml#ch10fig2), and
    [Figure 10.3](ch10.xhtml#ch10fig3) show screenshots from Etherscan. They provide
    insights into the global state, transactions, and smart contracts on the Ethereum
    blockchain. [Figures 10.4](ch10.xhtml#ch10fig4) and [10.5](ch10.xhtml#ch10fig5)
    illustrate how the CMTTracking web site provides delegated PoS information for
    the CyberMiles blockchain in real time. Such information is not applicable for
    the Ethereum blockchain, as Ethereum uses PoW mining for consensus.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1([Figure 10.1](ch10.xhtml#ch10fig1)), 图 10.2([Figure 10.2](ch10.xhtml#ch10fig2)),
    和 图 10.3([Figure 10.3](ch10.xhtml#ch10fig3)) 展示了以太坊浏览器的截图。它们提供了关于以太坊区块链上的全局状态、交易和智能合约的洞察。图
    10.4([Figures 10.4](ch10.xhtml#ch10fig4)) 和 10.5([10.5](ch10.xhtml#ch10fig5))
    说明了 CMTTracking 网站如何实时为千米iles 区块链提供委派 PoS 信息。这些信息对于以太坊区块链不适用，因为以太坊使用 PoW 挖矿进行共识。
- en: '![image](Images/yuan_f10_01.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/yuan_f10_01.jpg)'
- en: '**Figure 10.1** Etherscan front page with pricing information, mining information,
    and recent blocks'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 10.1** 以太坊浏览器首页，带有定价信息、挖矿信息以及最近区块'
- en: '![image](Images/yuan_f10_02.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/yuan_f10_02.jpg)'
- en: '**Figure 10.2** Etherscan page for an account and its transactions'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 10.2** 以太坊浏览器中一个账户及其交易页面'
- en: '![image](Images/yuan_f10_03.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/yuan_f10_03.jpg)'
- en: '**Figure 10.3** Etherscan page for a smart contract that issues an ERC20 asset'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 10.3** 以太坊浏览器中一个发行 ERC20 资产的智能合约页面'
- en: '![image](Images/yuan_f10_04.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/yuan_f10_04.jpg)'
- en: '**Figure 10.4** CMTTracking page for CyberMiles validator nodes, their status,
    voting power, and compensation rate for people who stake in them'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 10.4** CMTTracking 页面，用于千米iles 验证节点，其状态、投票权以及人们投注它们的补偿率'
- en: '![image](Images/yuan_f10_05.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/yuan_f10_05.jpg)'
- en: '**Figure 10.5** CMTTracking page showing validator information, stakes, and
    awards'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 10.5** CMTTracking 页面，展示验证者信息、投注以及奖励'
- en: The explorer can also provide off-chain information related to the crypto assets
    on the blockchain. For example, it could provide the current pricing, trading
    volume, and market cap for the crypto assets. It could associate blockchain accounts
    and smart contracts with identities in the real world. It could monitor accounts
    belonging to key ecosystem players, such as exchanges and super nodes to detect
    and report trading signals. Those data services are of broad interest from users,
    traders, investors, and government regulators.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器还可以提供与区块链上的加密资产相关的链下信息。例如，它可以提供加密资产的当前定价、交易量和市值。它可以将区块链账户和智能合约与现实世界中的身份关联。它可以监控属于关键生态系统参与者的账户，如交易所和超级节点，以检测和报告交易信号。这些数据服务对用户、交易员、投资者和政府监管机构具有广泛的兴趣。
- en: Those explorers, especially open source explorers, are also decentralized applications.
    Everyone with the source code can deploy their own explorer service. All the data
    is from the blockchain and other distributed sources, such as pricing aggregators.
    There is no single point of failure to shut down the explorer software.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这些浏览器，尤其是开源浏览器，也是去中心化应用程序。拥有源代码的每个人都可以部署自己的浏览器服务。所有数据都来自区块链和其他分布式来源，如定价聚合器。没有单一的失败点来关闭浏览器软件。
- en: '[Figure 10.6](ch10.xhtml#ch10fig6) illustrates the overall architecture of
    a typical blockchain explorer. It consists of a harvester and a query interface.
    The harvester retrieves data from the blockchain, normalizes it, associates individual
    records with off-chain sources, and then saves the data in a database. The query
    interface provides a search engine and visualization tools to chart the data.
    It could also support API services for automated queries.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10.6](ch10.xhtml#ch10fig6) 展示了典型区块链浏览器整体架构。它包括一个收割器和一个查询接口。收割器从区块链检索数据，对其进行标准化，将个别记录与链下来源关联，然后将数据保存到数据库中。查询接口提供搜索引擎和可视化工具来绘制数据。它还可以支持
    API 服务以实现自动化查询。'
- en: '![image](Images/yuan_f10_06.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/yuan_f10_06.jpg)'
- en: '**Figure 10.6** The blockchain data explorer architecture view'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 10.6** 区块链数据浏览器架构视图'
- en: In the next sections, I will go into the technology stacks of the blockchain
    explorer software and discuss how you might improve existing explorers and develop
    specialized data services for your own applications.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我将深入探讨区块链浏览器软件的技术堆栈，并讨论你如何可能改进现有的浏览器并为你自己的应用程序开发专业的数据服务。
- en: Harvesting Data
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 收割数据
- en: The harvester application must have access to a full blockchain node. This is
    a node that contains the entire blockchain history data from the genesis block
    to the current head, not just the current account states. The node runs continuously
    and stays in sync with the blockchain’s current head block. I recommend you run
    and sync a full node yourself just for the harvester to use since the harvester’s
    data quality depends on the availability of the node. With your own node, the
    harvester could also potentially access the databases inside the blockchain software
    to directly extract data as opposed to going through the blockchain’s Remote Procedure
    Call (RPC) service interface. [Figure 10.7](ch10.xhtml#ch10fig7) illustrates the
    architecture of the harvester.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 收割器应用程序必须能够访问一个完整的区块链节点。这是一个包含从创世区块到当前区块的全部区块链历史数据的节点，而不仅仅是当前账户状态。该节点持续运行并与区块链当前的头部区块保持同步。我建议你自己运行并同步一个完整的节点，仅为收割器使用，因为收割器的数据质量取决于节点的可用性。有了你自己的节点，收割器还可以潜在地访问区块链软件内的数据库，直接提取数据，而不是通过区块链的远程过程调用（RPC）服务接口。
    [图 10.7](ch10.xhtml#ch10fig7) 展示了收割器的架构。
- en: '![image](Images/yuan_f10_07.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/yuan_f10_07.jpg)'
- en: '**Figure 10.7** The blockchain data harvester'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 10.7** 区块链数据收割器'
- en: The key component in the harvester is a scheduler. It runs every few seconds
    to retrieve information from the blockchain node. The scheduler’s running time
    interval should be shorter than the block time to make sure that it always gets
    the latest block information. There are a variety of technology choices for the
    scheduler.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 收割器的关键组件是一个调度器。它每隔几秒钟运行一次，从区块链节点检索信息。调度器的运行时间间隔应短于区块时间，以确保它总是获取最新的区块信息。调度器有多种技术选择。
- en: For Linux-based systems, you can use cron jobs to run the harvester application
    in fixed intervals.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于基于 Linux 的系统，你可以使用 cron 作业以固定的间隔运行收割器应用程序。
- en: If the harvester is a Java application, you can use the Quartz Scheduler to
    run worker jobs at fixed intervals ([www.quartz-scheduler.org/](http://www.quartz-scheduler.org/)).
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果收割机是一个Java应用程序，你可以使用Quartz调度程序以固定间隔运行工作作业(['www.quartz-scheduler.org/'](http://www.quartz-scheduler.org/))。
- en: If the harvester is a node.js JavaScript application, you can use the egg.js
    framework for scheduled workloads ([https://eggjs.org/](https://eggjs.org/)).
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果收割机是一个node.js JavaScript应用程序，你可以使用egg.js框架来进行计划任务(['https://eggjs.org/'](https://eggjs.org/))。
- en: The scheduler runs a workload to retrieve data through the following means.
    You could build each of them into a connector that plugs into the harvester.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 调度程序通过以下方式运行工作负载以检索数据。你可以将每个功能构建成一个连接器，使其能够插入到收割机中。
- en: '*RPC connector to the node*: For Ethereum-compatible blockchains (e.g., CyberMiles),
    this is the RPC service available via port 8545\. This connector is typically
    done through a web3-compatible library.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**到节点的RPC连接器**：对于与以太坊兼容的区块链（例如，CyberMiles），这是通过端口8545提供的RPC服务。此连接器通常是通过一个与web3兼容的库来完成的。'
- en: '*Database connector to LevelDB*: This is used to directly access the databases
    on the node to read data that is potentially not available (or too cumbersome)
    from the RPC connector.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**到LevelDB的数据库连接器**：此功能用于直接访问节点上的数据库，以读取通过RPC连接器无法获取（或太繁琐）的数据。'
- en: '*Web services connectors*: This is used to access external services such as
    pricing and market intelligence data from the CoinMarketCap API ([https://coinmarketcap.com/api/](https://coinmarketcap.com/api/)).'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Web服务连接器**：此功能用于访问来自CoinMarketCap API（[''https://coinmarketcap.com/api/''](https://coinmarketcap.com/api/)）等外部服务如定价和市场情报数据。'
- en: '*Local database connectors*: This is used to access potentially proprietary
    data stored on the harvester’s local servers. Examples include proprietary databases
    that associate blockchain accounts with names, entities, and exchanges, including
    known criminals.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**本地数据库连接器**：此功能用于访问收割机本地服务器上存储的可能具有专利性质的数据。例如，包括将区块链账户与名称、实体和交易所关联的专利数据库，其中包括已知的罪犯。'
- en: Once the data for each block is retrieved from the connectors, the harvester
    runs a data warehouse operation to combine, clean, and normalize the data. The
    data is organized into a set of logical schema and saved.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦从连接器中检索出每个块的数据，收割机就会运行数据仓库操作来组合、清洗和规范化数据。数据被组织成一套逻辑模式并保存。
- en: Structured results such as blocks, accounts, and transactions can be saved into
    a relational database with well-defined schema to ensure data integrity and query
    efficiency.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有区块、账户和交易等结构化结果可以保存在具有明确模式的关系型数据库中，以确保数据完整性和查询效率。
- en: Unstructured data such as events generated from smart contracts or bytecodes
    and hashes can be saved on NoSQL document stores such as MongoDB and Cassandra.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如来自智能合约或字节码和散列的无结构数据可以保存在MongoDB和Cassandra等NoSQL文档存储上。
- en: '**Note**'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: The Google Blockchain ETL is a fully integrated blockchain data warehousing
    solution. It uses the Google Cloud Composer to orchestrate the harvesting process.
    It starts by making RPC requests to export blockchain data into comma-separated
    value (CSV) files and then loads the CSV files into the Google BigQuery table.
    The data can then be queried from BigQuery. The drawback, however, is that it
    is not a real-time solution. The data is harvested and ingested every 24 hours.
    And it relies on the Google Cloud infrastructure.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌区块链ETL是一个完全集成的区块链数据仓库解决方案。它使用Google Cloud Composer来编排收割过程。它首先通过发起RPC请求将区块链数据导出为逗号分隔值（CSV）文件，然后将CSV文件加载到Google
    BigQuery表中。然后可以从BigQuery查询数据。然而，它的缺点不是实时解决方案。数据每24小时收割和摄入一次。并且依赖于Google Cloud基础设施。
- en: In the rest of this section, we look into various data types the harvester can
    collect and normalize for later queries.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在本文节的剩余部分，我们探讨了收割机可以收集和规范化的各种数据类型，以供以后查询。
- en: Transactions and Accounts
  id: totrans-193
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 交易和账户
- en: Most blockchain platforms provide standard RPC interfaces to get a list of transactions
    by block height. From there, the harvester can get details from each transaction,
    including the from/to accounts, transfer amount, gas amount, success status, and
    data associated with the transaction, such as smart contract function calls.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数区块链平台提供标准RPC接口，通过区块高度获取交易列表。从那里，收割机可以获取每个交易的详细信息，包括发件人/收件人账户、转账金额、燃料金额、成功状态以及与交易相关的信息，例如智能合约函数调用。
- en: All those data elements are highly structured. They can be normalized into a
    relational database with account addresses acting as keys. For example, we could
    query all transactions from and to a specific account. The harvester application
    could perform internal data integrity checks by adding up all the transactions
    for each account and compare them with the account balances reported by the blockchain
    RPC.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些数据元素都高度结构化。它们可以被规范化到以账户地址作为键的关系数据库中。例如，我们可以查询特定账户的所有交易。收割应用程序可以通过将每个账户的所有交易相加，并与区块链RPC报告的账户余额进行比较，执行内部数据完整性检查。
- en: Awards
  id: totrans-196
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 奖项
- en: Most blockchains also “create” crypto tokens over time to award entities that
    run computer servers to secure the blockchain network. That is called *block awards*.
    For (PoW) blockchains, miners compete for the right to create the next block.
    The winner is awarded certain amounts of tokens. For various PoS blockchains,
    including delegated proof-of-stake (DPoS) blockchains, the validators or block
    producers were assigned duties to produce the next block while all other nodes
    validate and agree on the block’s content. The block award goes to the block producer
    or is divided according to stake or voting power.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数区块链还“创建”加密货币代币，以奖励运行计算机服务器以确保区块链网络安全的实体。这称为*区块奖励*。对于（PoW）区块链，矿工争夺创建下一个区块的权利。胜者获得一定数量的代币。对于各种PoS区块链，包括委托权益证明（DPoS）区块链，验证人或区块生产者被分配产生下一个区块的任务，而所有其他节点验证并同意区块内容。区块奖励归区块生产者所有，或根据股份或投票权进行分配。
- en: The harvester needs to understand the algorithm to distribute block awards and
    creates database entries for such events indexed by account addresses. This data
    is also highly structural and relational. The harvester can verify its computed
    block awards distribution against account balances from the blockchain itself.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 收割器需要理解分配区块奖励的算法，并为这些事件创建数据库条目，这些事件按账户地址索引。这些数据也是高度结构化和相关的。收割器可以将其计算的区块奖励分布与区块链本身报告的账户余额进行验证。
- en: Off-Chain Identities
  id: totrans-199
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 链下身份
- en: A key use case of the blockchain data service is to understand the flow and
    exchange of digital assets. It is often important to associate a blockchain address
    with real-world entities that hold its private key. Since blockchain transactions
    are transparent, once you know the real identity of an address, it is often possible
    to figure out the identity of any addresses that ever transferred in and out of
    the known address.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链数据服务的一个关键用例是理解数字资产的流动和交换。通常，将区块链地址与持有其私钥的实体经济体关联是非常重要的。由于区块链交易是透明的，一旦你知道了一个地址的真实身份，通常可能推断出与已知地址有过交易的任何地址的身份。
- en: '**Note**'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The only “anonymous” addresses on blockchain are miner accounts from PoW blockchains.
    However, once a miner starts to spend or exchange tokens with known addresses,
    the miner’s identity could be revealed.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链上唯一的“匿名”地址是来自PoW区块链的矿工账户。然而，一旦矿工开始与已知地址花费或交换代币，矿工的身份可能会被揭露。
- en: The association between off-chain entities and blockchain addresses can come
    from multiple sources.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链地址与链下实体之间的关联可以来自多个来源。
- en: '*Data sharing agreement with crypto exchanges*: Most crypto exchanges require
    know your customer (KYC) checks for all their users. They have broad reach and
    knowledge of blockchain account address ownership as users deposit and withdraw
    tokens from or into their own addresses.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与加密货币交易所的*数据共享协议*：大多数加密货币交易所要求对其所有用户进行了解你的客户（KYC）检查。他们广泛接触并了解区块链账户地址的所有权，因为用户将代币存入或从他们自己的地址中提取。
- en: '*Data sharing agreement with initial coin offering (ICO) projects*: Many ICO
    projects conduct KYC checks for all their initial contributors. They have knowledge
    of each contributor’s source and deposit addresses.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与初始代币发行（ICO）项目的*数据共享协议*：许多ICO项目对其所有初始贡献者进行KYC检查。他们知道每位贡献者的来源和存款地址。
- en: '*Data sharing agreement with crypto payment processors and e-commerce merchants*:
    When users use crypto tokens to pay for goods and services in the real world,
    they leave a trail that we can follow (e.g., shipping address) to determine the
    identity of the accounts related to the real-world transaction.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与加密货币支付处理器和电子商务商家的*数据共享协议*：当用户在现实生活中使用加密货币代币支付商品和服务时，他们留下了我们可以追踪的线索（例如，送货地址），以确定与现实世界交易相关的账户身份。
- en: '*Data mining from social media*: When crypto projects run marketing campaigns,
    it often provides airdrops to followers on social media. Such airdrops require
    users’ addresses.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*社交媒体数据挖掘*：当加密项目运行市场营销活动时，通常会在社交媒体上向关注者提供空投。这样的空投需要用户的地址。'
- en: While the association between blockchain addresses and their off-chain owners’
    identities is structured and relational, the transactions linking one blockchain
    address to the next are not relational. The harvester could put the known address
    associations into a relational database and put connected transactions into a
    graph database, such as Neo4j, for further analysis and queries.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管区块链地址与链下所有者身份之间是结构化和有关系的，但连接一个区块链地址到下一个地址的交易并不是有关系的。收割者可以将已知的地址关联放入关系数据库中，将相关的交易放入图数据库，如Neo4j，进行进一步分析和查询。
- en: '**Note**'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: Monitoring known exchange addresses and large token holders’ addresses can help
    you predict market movements. For example, if a large account holder withdraws
    his stake at a DPoS block producer/validator and moves the tokens to an exchange
    account, you can anticipate increased selling pressure in the near future.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 监控已知的交易所地址和大代币持有者的地址可以帮助你预测市场动向。例如，如果一个大账户持有者在DPoS区块生产者/验证者处提取他的股份，并将代币转移到交易所账户，你可以预测未来不久将会有增加的卖压。
- en: Inside Smart Contracts
  id: totrans-211
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 智能合约内部
- en: Ethereum-compatible blockchains are foremost smart contract platforms. The smart
    contract bytecode and their data structure can be arbitrary. Hence, smart contract
    data is unstructured, and it has been difficult to track the function execution
    and state changes in the blockchain.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊兼容的区块链主要是智能合约平台。智能合约的字节码和数据结构可以是任意的。因此，智能合约数据是无结构的，并且一直难以追踪区块链中的函数执行和状态变化。
- en: '**Note**'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: Etherscan and other Ethereum-compatible blockchain explorers have long provided
    the ability to verify user/community-submitted smart contract source code against
    its bytecode on the blockchain. That helps the community verify that the source
    code and behavior of such contracts are indeed as advertised. But, this method
    provides no insights into the execution of functions and data inside the smart
    contracts.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊兼容的区块链浏览器，如Etherscan，长期以来一直提供了一种能力，即验证用户/社区提交的智能合约源代码与其在区块链上的字节码是否一致。这帮助社区确认智能合约的源代码和行为确实如宣传所言。但是，这种方法并没有提供关于智能合约内部函数执行和数据情况的洞察。
- en: A smart contract can write permanent data to the blockchain by declaring and
    then emitting an event. Emitted event log data will remain intact indefinitely,
    even if that particular smart contract and its global state have been completely
    removed using the previously mentioned opcode `0xff`, known as *self-destruct*.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约可以通过声明并发射一个事件，将永久数据写入区块链。发射的事件日志数据将永久保持，即使那个特定的智能合约及其全局状态已经被完全移除，使用前面提到的操作码`0xff`，也就是*自毁*。
- en: '**Note**'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: The cost of writing to event logs is comparatively cheaper than writing to the
    blockchain’s global state. For example, it costs around 40,000 gas to write a
    single address and a single uint to the blockchain’s state. Alternatively, it
    costs only about 1,000 gas to write that same single address and uint to the blockchain’s
    event logs.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 写入事件日志的成本相对于写入区块链全局状态的成本要低得多。例如，将一个地址和一个uint写入区块链状态的成本大约为40,000个气（Gas）。或者，将同样的地址和uint写入区块链事件日志的成本仅约为1,000个气。
- en: 'The following example in Solidity (and Lity) shows how to define an event in
    your smart contract:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在Solidity（和Lity）中的示例，展示了如何在您的智能合约中定义一个事件：
- en: '[Click here to view code image](Images/ch10_images.xhtml#pro10_1)'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击此处查看代码图片](Images/ch10_images.xhtml#pro10_1)'
- en: '[PRE6]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, to declare the event, we simply type the word `event` followed
    by the name of the event. Then we pass in some data types and data names (in this
    case, the data types of `address` and `uint256`, which relate to the data names
    `endUser` and `amount`, respectively).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，要声明事件，我们只需输入单词`event`，后跟事件的名称。然后我们传递一些数据类型和数据名称（在这个例子中，`address`和`uint256`的数据类型，分别与`endUser`和`amount`的数据名称相关）。
- en: You will notice that we have deliberately specified, in this declaration, that
    the `endUser` data be indexed. Essentially, indexing a parameter allows for efficient
    searching later. Up to three parameters per event declaration can be indexed.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，我们在这个声明中故意指定了`endUser`数据要被索引。本质上，索引参数允许以后进行有效搜索。每个事件声明最多可以索引三个参数。
- en: 'It is wise to index data, such as account addresses, because it’s likely that
    you will be searching for information based on a particular account address. It
    is not a great idea to index other types of data, such as arbitrary amounts (i.e.,
    integers such as 1 or 10). It is completely unnecessary to include (in your event
    logs) any information that can be easily retrieved using predefined global variables
    or functions (e.g., `block.number`). Variables like `block.number` are included
    in standard transaction receipts by default. Let’s now emit the event declared
    earlier, as shown here:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 为诸如账户地址之类的数据建立索引是明智的，因为你很可能需要根据特定的账户地址搜索信息。索引其他类型的数据（例如任意数量，即整数如1或10）并不是一个好主意。在事件日志中包含任何可以通过预定义的全局变量或函数（例如`block.number`）轻松检索的信息是完全不必要的。像`block.number`这样的变量默认包含在标准交易收据中。现在让我们发出之前声明的事件，如下所示：
- en: '[Click here to view code image](Images/ch10_images.xhtml#pro10_2)'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击此处查看代码图片](Images/ch10_images.xhtml#pro10_2)'
- en: '[PRE7]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see from the previous code, to emit an event, you simply type `emit`
    followed by the name of the event (which was declared in the previous code snippet).
    The data to be included in the event log is passed in during a function’s execution.
    The order in which data is passed into the `emit` command must match the order
    of the data, as shown in the event declaration.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 从之前的代码中，你可以看到，要发出一个事件，你只需输入`emit`，后面跟着事件的名称（这个名称在之前的代码片段中声明）。事件日志中要包含的数据在函数执行期间传递。传递到`emit`命令中的数据的顺序必须与事件声明中的数据顺序一致。
- en: 'The following code shows the entire smart contract, thereby providing context
    for the previous snippets:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码展示了整个智能合约，从而为之前的片段提供了上下文：
- en: '[Click here to view code image](Images/ch10_images.xhtml#pro10_3)'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击此处查看代码图片](Images/ch10_images.xhtml#pro10_3)'
- en: '[PRE8]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, every time a user calls the `addPoints()` function on this contract, the
    `pointBalanceUpdated` event is emitted. The event is recorded in transaction receipts
    when you query a transaction via RPC. In fact, the web3 library provides an even
    easier way to query past events, as shown here:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每当用户调用这个合约上的`addPoints()`函数时，就会触发`pointBalanceUpdated`事件。当你通过RPC查询交易时，事件会被记录在交易收据中。实际上，web3库提供了查询过去事件的一种更为简便的方式，如下所示：
- en: '[Click here to view code image](Images/ch10_images.xhtml#pro10_4)'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击此处查看代码图片](Images/ch10_images.xhtml#pro10_4)'
- en: '[PRE9]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The harvester receives JSON objects in the `events` array in the previous code.
    Each event JSON object looks like the following. Please note that I’m showing
    a more complex event from the Uniswap exchange deployed on the CyberMiles blockchain
    here, as opposed to the simple event described earlier.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 收割器接收的是`events`数组中的JSON对象，如之前的代码所示。每个事件JSON对象看起来如下。请注意，我这里展示的是一个比之前描述的简单事件更为复杂的Uniswap交易所事件，该事件部署在CyberMiles区块链上。
- en: '[Click here to view code image](Images/ch10_images.xhtml#pro10_5)'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击此处查看代码图片](Images/ch10_images.xhtml#pro10_5)'
- en: '[PRE10]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The JavaScript Object Notation (JSON) object can be deconstructed and saved
    into a relational database. Or, it can be saved directly into a JSON-aware document
    store for future queries. In this way, we can now harvest data directly from inside
    smart contract function calls.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript对象表示法（JSON）对象可以被解构并保存到关系数据库中。或者，它可以直接保存到支持JSON的文档存储中以供将来查询。这样，我们就可以现在从智能合约函数调用中直接收割数据。
- en: In this next chapter, I will discuss how to directly harvest and track public
    data from smart contracts using a search engine approach.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我将讨论如何使用搜索引擎方法直接从智能合约中收割和跟踪公共数据。
- en: Query Interface
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查询接口
- en: With the harvester in place, it is now possible to query the databases and provide
    data services to end users. A web-based UI can be built with any modern JavaScript
    user interface (UI) framework in front of those back-end data query services.
    The UI simply makes asynchronous data requests to the query interface.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 部署了收割器之后，现在可以查询数据库并向终端用户提供数据服务。可以使用任何现代JavaScript用户界面（UI）框架在那些后端数据查询服务前构建一个基于网页的用户界面。用户界面只需向查询接口发起异步数据请求即可。
- en: But more interestingly, the query interface can be used as web services for
    all applications, not just for the blockchain explorer. For example, a dapp could
    query blockchain and generate charts or maps.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 更有趣的是，查询接口可以作为所有应用程序的Web服务使用，而不仅仅是区块链浏览器。例如，一个去中心化应用（dapp）可以查询区块链并生成图表或地图。
- en: SQL Query
  id: totrans-241
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: SQL查询
- en: You can use SQL to query data from the relational databases the harvester builds.
    For example, it is now easy to find transactions that originate from a specific
    address, transactions that call a specific smart contract function, or transactions
    that block awards from a certain period of time.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 SQL 从收割者构建的关系型数据库中查询数据。例如，现在很容易找到来自特定地址的交易、调用特定智能合约函数的交易或来自某个时间段内的区块奖励交易。
- en: JSON Query
  id: totrans-243
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: JSON 查询
- en: 'Perhaps more interestingly, you can query JSON objects directly from tools
    like Elasticsearch. Here is an example query for Uniswap exchange events in the
    smart contract event log:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 也许更有趣的是，你可以直接从像 Elasticsearch 这样的工具查询 JSON 对象。以下是 Uniswap 交易所事件在智能合约事件日志中的一个查询示例：
- en: '[Click here to view code image](Images/ch10_images.xhtml#pro10_6)'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击此处查看代码图片](Images/ch10_images.xhtml#pro10_6)'
- en: '[PRE11]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The result would look something like this:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 结果可能看起来像这样：
- en: '[Click here to view code image](Images/ch10_images.xhtml#pro10_7)'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击此处查看代码图片](Images/ch10_images.xhtml#pro10_7)'
- en: '[PRE12]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The Elasticsearch framework is a powerful search engine framework. We have found
    that it works well with blockchain data.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: Elasticsearch 框架是一个强大的搜索引擎框架。我们发现它与区块链数据配合得很好。
- en: GraphQL
  id: totrans-251
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: GraphQL
- en: Another promising query interface for blockchain data is GraphQL, an open source
    query language and execution engine that originally was developed by Facebook.
    Leading implementations of GraphQL for blockchain data include TheGraph ([https://thegraph.com/](https://thegraph.com/))
    and Arcblock’s OCAP. In this section, let’s look into how TheGraph handles GraphQL
    queries. You could simply use its hosted service to query data from the public
    Ethereum blockchain or build your own using its open source software ([https://github.com/graphprotocol](https://github.com/graphprotocol)).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链数据的另一个有前景的查询接口是 GraphQL，这是一个由 Facebook 最初开发的开放源代码查询语言和执行引擎。GraphQL 的主要区块链数据实现包括
    TheGraph（[https://thegraph.com/](https://thegraph.com/)）和 Arcblock 的 OCAP。在本节中，让我们深入了解
    TheGraph 是如何处理 GraphQL 查询的。你可以简单地使用其托管服务从公共以太坊区块链查询数据，或者使用其开源软件（[https://github.com/graphprotocol](https://github.com/graphprotocol)）构建你自己的。
- en: 'TheGraph provides, among many other things, a mechanism for a dapp to directly
    fetch and consume only the exact amount of data that the dapp actually requires,
    at any given time. Here is an example of a GraphQL query for TheGraph:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: TheGraph 提供了许多其他功能，其中包括一种机制，允许 dapp 直接获取和消费 dapp 实际需要的确切数据量，无论在任何特定时间。以下是 TheGraph
    的一个 GraphQL 查询示例：
- en: '[Click here to view code image](Images/ch10_images.xhtml#pro10_8)'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击此处查看代码图片](Images/ch10_images.xhtml#pro10_8)'
- en: '[PRE13]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Right off the bat, we can see that TheGraph is different from a traditional
    RESTful web service, in that this GraphQL query is not written in valid JSON.
    In fact, this GraphQL syntax is more lightweight than JSON because it does not
    have to specify whole `key:value` pairs, such as `{"event": true},` and so forth.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '从一开始，我们就可以看出 TheGraph 与传统的 RESTful web 服务不同，因为这个 GraphQL 查询不是用有效的 JSON 编写的。实际上，这个
    GraphQL 语法比 JSON 更轻量，因为它不需要指定整个 `key:value` 对，例如 `{"event": true}` 等。'
- en: 'As examples, let’s use TheGraph to query Uniswap exchange smart contracts deployed
    on the Ethereum blockchain. To echo the earlier discussion in this chapter, TheGraph
    has already harvested event logs from Ethereum smart contracts and is making this
    data available for GraphQL queries. The previous GraphQL query translates to “Considering
    all of the Uniswap transactions to date, please give me only the name of the first
    event log that was ever emitted.” The response is as follows:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 作为例子，让我们使用 TheGraph 查询部署在以太坊区块链上的 Uniswap 交易所智能合约。为了呼应本章前面讨论的内容，TheGraph 已经从以太坊智能合约中收获事件日志，并使这些数据可供
    GraphQL 查询使用。之前的 GraphQL 查询翻译为“考虑到 Uniswap 迄今为止的所有交易，请只给我第一个事件日志的名称。” 响应如下：
- en: '[Click here to view code image](Images/ch10_images.xhtml#pro10_9)'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击此处查看代码图片](Images/ch10_images.xhtml#pro10_9)'
- en: '[PRE14]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The response is, in fact, valid JSON. You also will notice that this data is
    minimalistic. We can build on this first query by expanding the query to ask for
    not only the event but also the block number.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这个响应是有效的 JSON。你还会注意到，这个数据非常简洁。我们可以在此基础上扩展查询，不仅要查询事件，还要查询区块号码。
- en: '[Click here to view code image](Images/ch10_images.xhtml#pro10_10)'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击此处查看代码图片](Images/ch10_images.xhtml#pro10_10)'
- en: '[PRE15]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The following result shows that the event was mined into block 6629139:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 以下结果显示该事件被挖掘到区块 6629139 中：
- en: '[Click here to view code image](Images/ch10_images.xhtml#pro10_11)'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击此处查看代码图片](Images/ch10_images.xhtml#pro10_11)'
- en: '[PRE16]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Another way that we can achieve/confirm this is to return all the event logs,
    ordered by block number in ascending order.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch10_images.xhtml#pro10_12)'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The query returns the following result:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch10_images.xhtml#pro10_13)'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As TheGraph demonstrates, GraphQL could be an important tool for providing blockchain
    data to end-user applications.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: Google BigQuery
  id: totrans-273
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As discussed earlier in this chapter, the Google Blockchain ETL project is a
    fully integrated data warehouse solution to ingest data from multiple blockchains
    into Google BigQuery tables. The data schema is designed to be unified across
    multiple blockchains. On all its blockchain data sets, the Google Blockchain ETL
    project supports the “double entry book” view that lists cryptocurrency transactions
    in traditional accounting formats.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: 'You can then make queries against the data set using any query language that
    BigQuery supports, including SQL-like queries. For example, the following query
    verifies an account balance is indeed the sum of its transactions:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch10_images.xhtml#pro10_14)'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The following query shows the frequency of different transaction fees on the
    Bitcoin blockchain:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch10_images.xhtml#pro10_15)'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The Google Blockchain ETL project provides a SQL-like cloud-based data warehousing
    solution for blockchain data. You can customize it to fit your own needs.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: What’s Next?
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: From a design perspective, let’s briefly think back to the days of the Simple
    Object Access Protocol (SOAP). While SOAP facilitated communication between disparate
    machines, it also relied on a set of predefined application data types that were
    essentially a permanent structure. Any changes (for example, updates to the software
    application or changes to the static configuration) would disrupt or render the
    previously working interoperability inoperable. Simply put, SOAP is a rigid protocol.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: Representational State Transfer (REST), on the other hand, introduced essentially
    an architectural style. Systems that conformed to all six architectural constraints
    were considered RESTful. Further, web services that adhered to the architectural
    constraints were considered RESTful APIs.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: Still, in design mode, while it is tempting to explore ways in which we can,
    say, improve JSON compression (between the data provider and the dapp) and so
    forth, thinking like this takes us down the path of a protocol — a protocol that
    enforces that both sides have to agree on a predefined set of rules and that forces
    the client side (in this case the dapp) to perform additional work (unzipping,
    decoding, etc.).
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: Taking more of an architectural design viewpoint, would it be more effective,
    in terms of flexibility and interoperability, to focus on conventions as opposed
    to static configuration? We must remember that smart contract developers can create
    their own custom event logs that can emit one to many variables of various data
    types. Do we want to be setting up static configuration for each contract that
    is deployed in the blockchain network? Is human-driven static configuration sustainable?
    Can it be avoided altogether through the use of strong conventions and machine
    automation?
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: 'The next wave of blockchain architecture is rising, and right now there are
    big opportunities. I believe that upcoming blockchain data providers and explorer
    projects should do the following:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: Provide a mechanism to autonomously harvest a smart contract’s event log data
    based purely on an application binary interface (ABI) file and a smart contract’s
    address
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatically assign correct data field types (based solely on the smart contract’s
    ABI)
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Require only a minimal amount of configuration and automated schema generation
    as per the previous point
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide sufficient internal querying, filtering, and logic to produce the most
    succinct responses
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatically/dynamically offer autocomplete syntax to the calling software
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide a variety of default visual front-end display portals
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide a library of built-in analytics (not only to explore trends, correlations,
    and so forth, but also to generate data sets for machine learning)
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide a mechanism to interoperate with ubiquitous business software, file
    formats, and content management and software development applications
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is an exciting time. We have an unprecedented amount of information, documentation,
    and software available, as well as the appropriate decentralized infrastructure
    to test and deploy your projects on.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  id: totrans-297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, I discussed how to build a blockchain data service. The blockchain
    explorers are pioneers in this space, but there is much more that can be done
    both on the harvesting side and on the query side. I believe that advanced off-chain
    storage and querying of blockchain data, especially smart contract execution data,
    is going to be a key component in the dapp ecosystem as well. In the next chapter,
    I will cover a new data service that provides real-time updates to public states
    of smart contracts. The data service is provided over a JavaScript library that
    complements web3.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: 11. Smart Contract Search Engine
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first-generation blockchain data browsers were focused primarily on providing
    snapshots of transaction details. For example, in the case of Bitcoin, they displayed
    verbatim records of structured data, as well as the results of valid transactions
    executed at the rigid base protocol layer.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: The unprecedented rise of smart contracts, with customized data fields and unique
    internal programmable logic, has brought about the need for a new mechanism, one
    that can provide an easy way to search and visualize this new rich, unstructured
    blockchain data.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: This mechanism is analogous to the rise of search engines while the Web grew
    in the 1990s. However, blockchain networks are unique in that they record all
    data in a time series of transactions. Smart contract data needs to be indexed
    and made available to both end users and machines in real time. Traditional web
    search engine technology is seldom used in the blockchain world because the World
    Wide Web and blockchain networks are fundamentally different. In this chapter,
    I will introduce an open source smart contract search engine. I will then discuss
    how to leverage it to power new types of dapps.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to the Smart Contract Search Engine
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are many ways to build a search engine for blockchain data. In this chapter,
    we focus on the open source search engine built by Second State. It works with
    all Ethereum-compatible blockchains and is production ready. Most important, it
    serves as an example for the coding and implementation patterns associated with
    smart contract search engines.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: The Second State smart contract search engine has the components illustrated
    in [Figure 11.1](ch11.xhtml#ch11fig1). You can get its complete source code and
    instructions from [https://github.com/second-state/smart-contract-search-engine](https://github.com/second-state/smart-contract-search-engine).
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f11_01.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
- en: '**Figure 11.1** The software components of a smart contract search engine'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: An Elasticsearch instance that indexes application binary interfaces (ABIs)
    and public data fields from contracts against contract addresses
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A full blockchain node that provides contract-related data as a standard JavaScript
    Object Notation–Remote Procedure Call (JSON-RPC) service
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Python-based harvester script that extracts data from a blockchain node and
    then indexes and stores the data in Elasticsearch
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Python-based web service that supports submitting contracts to index and Elasticsearch-like
    queries for real-time smart contract data
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A JavaScript library, es-ss.js, that enables client applications to interact
    with the web services
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is easy to start a new smart contract search engine using Docker, but it
    requires a few hours to fully index a production blockchain and then keep all
    the indexed contracts updated with each new block. To make it easier for developers
    to get started, Second State and the community run a few search engine instances
    for public use.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '*Ethereum mainnet*: [https://eth.search.secondstate.io/](https://eth.search.secondstate.io/)'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Ethereum Classic (ETC) mainnet*: [https://etc.search.secondstate.io/](https://etc.search.secondstate.io/)'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*CyberMiles mainnet*: [https://cmt.search.secondstate.io/](https://cmt.search.secondstate.io/)'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Second State DevChain*: [https://devchain.ss.search.secondstate.io/](https://devchain.ss.search.secondstate.io/)'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can load these URLs in a browser to see the current status of each of the
    public search engines. From there, you can search contract addresses that conform
    to specified contract interfaces (i.e., the ABI code) and then get up-to-date
    values in public fields for a contract address. For example, you could search
    all ERC20-compliant token contracts and see the symbol, supply, and values for
    each. You could also upload new ABIs to be indexed.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: However, the most interesting use of a smart contract search engine is to serve
    as a data aggregator for new types of dapps. You can access the search engine
    functions programmatically from the es-ss.js library from your JavaScript application
    or web page. In the next section, we will look into a dapp that utilizes the search
    engine to interact with multiple smart contracts at the same time.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: Getting Started with a Smart Contract Search Engine
  id: totrans-320
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The best way to get hands-on experience with a smart contract search engine
    and the es-ss.js library is through the BUIDL integrated development environment
    (IDE). See [Chapter 3](ch03.xhtml#ch03) for more on the BUIDL IDE tool. The simple
    dapp I will showcase here displays a number of AccountBalanceDemo contracts deployed
    on the blockchain. Each of these contracts stores a number that can be changed
    by the user. The search engine tracks and displays the tally of those numbers
    inside the contracts in real time. [Figure 11.2](ch11.xhtml#ch11fig2) shows the
    dapp in action in a web browser.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f11_02.jpg)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
- en: '**Figure 11.2** The AccountBalanceDemo dapp'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: The following code listing shows the smart contract. The contract simply stores
    a number that can be updated by the `setAccountBalance()` function call. You can
    copy and paste it into BUIDL’s contract editor.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch11_images.xhtml#pro11_1)'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Compile and deploy the smart contract by clicking the **Compile** and **Deploy
    to the chain** buttons. Make sure you give the account a name in the `_accountName`
    field before you click the **Deploy to the chain** button (see [Figure 11.3](ch11.xhtml#ch11fig3)).
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f11_03.jpg)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
- en: '**Figure 11.3** Deploying a new contract to be managed by the search-based
    dapp'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: Next, the following code listing shows the HTML code for the dapp. You can copy
    and paste it into BUIDL’s dapp/HTML editor. It shows multiple AccountBalanceDemo
    contracts in a table and then the tally of their account balances in another table.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch11_images.xhtml#pro11_2)'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The HTML tables are rendered by JavaScript. As discussed earlier, the JavaScript
    application can use the web3.js library to communicate with a blockchain node.
    It could also use the es-ss.js library to communicate with the search engine.
    Both web3.js and es-ss.js are initialized and made available in the JavaScript
    by BUIDL. The following code listing shows the JavaScript application. You should
    copy and paste it into BUIDL’s dapp/JavaScript editor. You should put the code
    outside of the `/* Don't modify */` section.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch11_images.xhtml#pro11_3)'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: When the page loads, the `reload()` JavaScript function calls the Elasticsearch
    es-ss.js API to get all contracts with the AccountBalanceDemo type from the blockchain.
    It then computes the tally in the total variable. Notice that the current state,
    in other words, the account name and balance, of each contract is contained in
    the search result. We can simply display this information without having to interact
    with the slower blockchain nodes. The `reload()` function constructs HTML Document
    Object Model (DOM) elements to display those contract public data fields.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch11_images.xhtml#pro11_4)'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The Update balance buttons in the table trigger the `setNumber()` JavaScript
    function, which in turn calls the contract’s `setAccountBalance()` function via
    web3\. The JavaScript then calls the `esss.updateStateOfContractAddress()` function
    to explicitly inform the search engine that this contract has changed and calls
    the `reload()` function to refresh data from the search engine.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch11_images.xhtml#pro11_5)'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '**Note**'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: Strictly speaking, the `updateStateOfContractAddress()` function call is not
    necessary, as the search engine works in near real time, and it automatically
    picks up the changes you just made in the `setAccountBalance()` function call
    via web3\. But, as a best practice for improved stability, we recommend you explicitly
    inform the search engine of changes you make whenever you can.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you can hit the **Run** button to run the dapp in BUIDL and use the
    Publish button to publish it on a public web site (see [Figure 11.2](ch11.xhtml#ch11fig2)).
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: The FairPlay Dapp Example
  id: totrans-345
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: FairPlay uses smart contracts to conduct automated prize draws that are fair
    and transparent. It allows anyone to create and participate in product giveaways
    and e-commerce marketing campaigns. It is a dapp running on the CyberMiles public
    blockchain, an Ethereum-compatible blockchain that features low-cost and fast
    consensus (learn more in [Chapter 14](ch14.xhtml#ch14)).
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: The FairPlay dapp can be accessed from any web browser. The dapp runs web3.js
    and es-ss.js to fetch data from public blockchain nodes and search engine Elasticsearch
    nodes. The user does not need any special software (i.e., a crypto wallet) to
    view active and past giveaways. The FairPlay web app is simply a collection of
    HTML and JavaScript files (see [Figure 11.4](ch11.xhtml#ch11fig4)). Any user can
    start a web server on a computer and serve those files locally or publically.
    Hence, FairPlay is decentralized and resistant to censorship.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f11_04.jpg)'
  id: totrans-348
  prefs: []
  type: TYPE_IMG
- en: '**Figure 11.4** FairPlay is a web app that can be hosted by anyone and accessed
    on any web browser.'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: When the user needs to make a smart contract transaction, such as creating a
    new giveaway or participating in an existing giveaway, the web page directs the
    user to open the CyberMiles app to digitally sign and complete the operation (see
    [Figure 11.5](ch11.xhtml#ch11fig5)).
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f11_05.jpg)'
  id: totrans-351
  prefs: []
  type: TYPE_IMG
- en: '**Figure 11.5** The FairPlay web app opens the CyberMiles app to send smart
    contract transactions.'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: FairPlay is a dapp in front of blockchain smart contracts. Under the hood, FairPlay
    has a modular architecture that is easy to develop and maintain. Key to this architecture
    is the smart contract search engine.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: A Modular Architecture
  id: totrans-354
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Most of today’s dapps rely on a single monolithic smart contract to serve as
    the “back end.” The smart contract manages all application users and states. Even
    for systems that consist of multiple contracts, there is typically a registry
    or manager contract that provides aggregated information about the system.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: However, a large smart contract is difficult to write and maintain. It tends
    to be error-prone and nearly impossible to fix when an error or issue is discovered,
    exacerbating the security problems that have plagued dapps today. The registry
    contract is also constrained by the limitations of today’s smart contract programming
    languages and virtual machines. It cannot support complex data query operations.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: The FairPlay dapp took a different approach. The dapp consists of many giveaway
    events, but each event is its own smart contract. When we create a new giveaway,
    we deploy a new instance of the FairPlay smart contract. When an event ends, its
    smart contract instance is discarded. That allows us to continuously improve the
    FairPlay contract to add features and fix bugs, as each future giveaway event
    uses a new smart contract. However, a key challenge in this approach is how the
    dapp organizes all those smart contracts created by different addresses at different
    times and makes the information inside all those contracts available in a unified
    UI. Enter the search engine.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: Using the Smart Contract Search Engine
  id: totrans-358
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The FairPlay dapp home screen displays results from the search engine (see [Figure
    11.6](ch11.xhtml#ch11fig6)). It allows users to find giveaways containing specific
    keywords or tags, as well as giveaways the user previously participated in. The
    search engine indexes information from all FairPlay contracts deployed on the
    blockchain.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f11_06.jpg)'
  id: totrans-360
  prefs: []
  type: TYPE_IMG
- en: '**Figure 11.6** The FairPlay dapp home page is based on search engine results.'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: The smart contract search engine is also decentralized—anyone can create a search
    engine-based dapp in front of all FairPlay smart contracts. Each search engine-based
    dapp could use different algorithms and queries to surface and promote FairPlay
    giveaways tailored to its users and audience. This architecture is illustrated
    in [Figure 11.7](ch11.xhtml#ch11fig7).
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f11_07.jpg)'
  id: totrans-363
  prefs: []
  type: TYPE_IMG
- en: '**Figure 11.7** The decentralized FairPlay dapp'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: Each smart contract in the FairPlay dapp completes a limited set of specific
    business transactions. Smart contracts are small pieces of autonomous code that
    are designed to enforce simple business rules on the blockchain. All related smart
    contracts are aggregated in the search engine to provide a useful UI to users.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: Use Cases
  id: totrans-366
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The FairPlay dapp is an example of how the smart contract engine supports data-intensive
    e-commerce dapps. The following sections present some more use cases.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: Crypto Assets
  id: totrans-368
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Crypto assets are represented by a large number of standard contracts such as
    ERC20, ERC721, and even ERC1400\. A search engine could provide an aggregated
    view of all account balances and transactions across those contracts.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, every ERC smart contract standard could benefit from a search engine
    that aggregates and displays information across all contracts of the same type.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: DeFi
  id: totrans-371
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Decentralized crypto exchanges often have multiple asset pools each represented
    by a smart contract. A search engine can provide deep insights into the history
    and current state of those pools.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: In general, decentralized finance (DeFi) solutions, such as algorithmic stable
    coins, crypto loans, and staking pools, all have asset pools held by smart contracts.
    A search engine could provide deep insights into those pools.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: Gaming
  id: totrans-374
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Blockchains allow participants from anywhere in the world to play games against
    each other without the need for a central operator or a trusted setup. A decentralized
    game is run entirely in accordance with a smart contract’s logic. The smart contract
    will not allow a player to perform an invalid move or participate out of turn.
    The smart contract ensures correctness and fairness, right from the initial rules
    of engagement through to the final payout or reward.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: Dapps, which constitute the front end (a visually stimulating component of the
    game), obtain the real-time state of the game, programmatically, via the smart
    contract search engine API.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: 'The entire ecosystem is safe and reliable. The following steps are repeated
    until a satisfactory outcome is achieved:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: The dapp visually displays the current state of the game to the end users.
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If it is their turn, each end user makes a choice by touching or swiping the
    screen.
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The dapp submits that choice to the smart contract.
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The smart contract validates the instruction set that the dapp sent.
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The smart contract executes the instruction set if valid.
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The smart contract’s state is/isn’t updated accordingly.
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The dapp redisplays the current state of the game (via the API) to the end users.
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Conclusion
  id: totrans-385
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, I discussed how the smart contract search engine can provide
    rich and up-to-date blockchain data to enable complex dapps. For application developers,
    the search engine services (i.e., the es-ss.js library) can supplement web3 and
    support a modular architecture for dapps.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: 12. Smart Contract Security and Best Practices
  id: totrans-387
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By Victor Fang, PhD[*](ch12.xhtml#ch12fn1)
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: '[*](ch12.xhtml#rch12fn1) Victor Fang, PhD, is founder and CEO of AnChain.ai.'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: A smart contract, coined by American computer scientist Nick Szabo, is the revolutionary
    feature that defines blockchain 2.0, compared to the peer-to-peer decentralized
    transactions in the blockchain 1.0 era such as Bitcoin, Ripple, and so on.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: As of 2019, Ethereum is the most widely adopted smart contract-enabled blockchain.
    An Ethereum smart contract is decentralized software that can be executed and
    verified on the Ethereum public blockchain.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: 'Ethereum smart contracts are programmed in Solidity, a JavaScript-like programming
    language (ECMAScript syntax), and they run in the Ethereum Virtual Machine (EVM).
    You can learn more about Ethereum smart contracts in [Chapter 6](ch06.xhtml#ch06).
    Since Ethereum’s launch in 2015, developers have witnessed a plethora of successful
    applications, as follows:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: Tokens, such as initial coin offerings (ICOs), security token offerings (STOs),
    and stable coins
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dapps, such as FOMO3D and CryptoKitties
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decentralized exchanges, such as the Decentralized Ethereum Asset Exchange (IDEX)
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, developers have also experienced major security vulnerabilities that
    caused billions of dollars in losses and concerns among the blockchain communities.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, I will focus on the Ethereum smart contract and discuss the
    following:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: Major Ethereum smart contract hacks and vulnerabilities in history
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Best practices to secure smart contracts
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Major Ethereum Smart Contract Hacks and Vulnerabilities
  id: totrans-400
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since the launch of Ethereum, the community witnessed major hacks that took
    over the headlines. In this chapter, I will review a few major hacks and illustrate
    the vulnerabilities behind those exploitations.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: Decentralized Autonomous Organization Hack
  id: totrans-402
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The decentralized autonomous organization (DAO) hack is probably the most notorious
    hack in Ethereum history. A DAO is a decentralized autonomous organization. Its
    goal is to codify the rules and decision-making apparatus of an organization,
    eliminating the need for documents and people in governing and creating a structure
    with decentralized control.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: In June 2016, an attacker drained 3.5 million ETH (about $50 million) from the
    DAO smart contract, after the ICO token sale had ended. It led to a hard fork
    of Ethereum. The technique the attackers used was reentrancy.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: '*Reentrancy* is also known as *recursive call vulnerability*. It occurs when
    external contract calls are allowed to make new calls to the calling contract
    before the initial execution is complete. For a function, this means that the
    contract state may change in the middle of its execution as a result of a call
    to an untrusted contract or the use of a low-level function with an external address.
    The minimal example for reentrancy is as follows:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch12_images.xhtml#pro12_1)'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this code example, `msg.sender.call.value` can be exploited by hackers. An
    attack contract could recursively call it until all gas is consumed.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: In fact, reentrancy is quite common. In October 2018, SpankChain, a cryptocurrency
    project focused on the adult industry, suffered a breach that saw almost $40,000
    in ETH stolen.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: The AnChain.ai threat research team illustrated the recursive nature of reentrancy
    when SpankChain was attacked, as shown in [Figure 12.1](ch12.xhtml#ch12fig1).
    Note that the hacker launched the attack contract that would cause SpankChain
    to recursively send ETH to the hacker’s address, until all gas was consumed. Each
    `call_0`, `call_1_0`, and `call_1_1_0_0` is an EVM internal transaction indicating
    an external smart contract call. In this case, each internal call stole 0.5 ETH
    from the SpankChain smart contract!
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f12_01.jpg)'
  id: totrans-411
  prefs: []
  type: TYPE_IMG
- en: '**Figure 12.1** The recursive nature of the reentrancy when the SpankChain
    smart contract was attacked'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: BEC Token Hack
  id: totrans-413
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Beauty Chain (BEC) token is particularly interesting because it shows how
    smart contract-based crypto assets can have a massive impact on a centralized
    crypto exchange (OK Exchange) in a subtle way, causing billions of dollars in
    losses.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: BEC was a high-profile cryptocurrency in China, and its stated goal was to be
    “a truly decentralized and beauty-themed ecosystem.”
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: It started trading on OKEX on February 23, 2018\. From its peak market cap of
    around $70 billion, it gradually came down to around $2 billion USD as of April
    22, when its trading value suddenly dropped to zero. OKEX subsequently suspended
    trading of BECs.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: The BEC token hack was because of an *integer overflow* vulnerability in its
    ERC20 smart contract. The annotated code line in the following listing multiplies
    two uint256 numbers and assigns the result to another uint256 variable, `amount`.
    Unfortunately, there is no overflow checking on that line. When a hacker passes
    a legitimate but large uint256 variable, it can cause the product to overflow.
    [Figure 12.2](ch12.xhtml#ch12fig2) shows the transaction that exploits the integer
    overflow vulnerability.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f12_02.jpg)'
  id: totrans-418
  prefs: []
  type: TYPE_IMG
- en: '**Figure 12.2** The exploited overflow vulnerability transaction of the BEC
    smart contract'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch12_images.xhtml#pro12_2)'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The way to prevent this hack is to use SafeMath for all arithmetic. In fact,
    this smart contract used SafeMath in all except this particular function, and
    it caused catastrophic damage not only to BEC but also to all exchanges that traded
    it.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: There are ways to prevent integer overflows in smart contracts. The Lity language
    and virtual machine extensions to Ethereum check for integer overflow at compile
    time and then detect and abort the smart contract when there are integer overflows
    at runtime. See [Chapter 14](ch14.xhtml#ch14) for more.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: The Parity Wallet Hack
  id: totrans-425
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The *Parity multisig bug* vulnerability showcases another way that a cryptographic
    smart contract design bug can damage part of the ecosystem: the wallet. The impacted
    Parity wallet is one popular wallet for Ethereum and tokens.'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: In fact, this bug is one of the common bugs in the top-ten list from Open Web
    Application Security Project (OWASP), categorized under access control. These
    issues are common in all programs, not just smart contracts.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: The Parity multisig bug impacted all users with assets in a multisig wallet
    created in Parity wallet that was deployed after July 20, 2017, worth $155 million
    USD. This bug was patched immediately after the hack.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: The attacker sent two transactions to each of the affected contracts.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 1: Obtain Exclusive Ownership of the Multisig'
  id: totrans-430
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In the wallet contract, the `payable()` function contains a bug that causes
    all public functions from the library to be callable by anyone, including `initWallet`,
    which can change the contract’s owners.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, `initWallet` has no checks to prevent an attacker from calling
    it after the contract was initialized. The attacker exploited this and simply
    changed the contract’s owner state variable to the hacker’s addresses. This modified
    the access control and persisted in the immutable Ethereum blockchain.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 2: Move All of Its Funds'
  id: totrans-433
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: After the hacker took over the ownership, it was just a matter of invoking the
    execute function to send all the funds to the hacker’s account! This execution
    was automatically authorized since the attacker was then the only owner of the
    multisig, effectively draining the contract of all its funds.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: FOMO3D and LastWinner Dapp Hack
  id: totrans-435
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Dapps are a dominant trend enabled by smart contracts. As of March 2019, there
    were 2,667 dapps running on public blockchains, and the number will likely grow
    tremendously. Please see [Chapter 7](ch07.xhtml#ch07) for more on Ethereum dapp
    development.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: 'FOMO3D is a gambling dapp ([Figure 12.3](ch12.xhtml#ch12fig3)) that was so
    popular in July/August 2018 that it even congested the Ethereum blockchain. The
    FOMO3D game rules are simple and as follows:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f12_03.jpg)'
  id: totrans-438
  prefs: []
  type: TYPE_IMG
- en: '**Figure 12.3** FOMO3D dapp, played by Victor Fang in July 2018'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: A user buys a key, in other words, a lottery ticket, to participate.
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When anyone buys a key, the countdown clock adds a few seconds, with 24 hours
    being the maximum.
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The final buyer when the clock hits 0 wins the jackpot!
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each key buyer receives random airdrop bonuses.
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In fact, FOMO3D is a typical Ponzi scheme that theoretically should never stop,
    because it is driven by human nature: greed.'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, FOMO3D, and its copycat LastWinner, were both hacked in August
    2018\. Those hacks led to the discovery of *blockchain advanced persistent threats*
    (BAPTs). *Advanced persistent threat* (APT) is defined as stealthy and continuous
    computer hacking processes, often orchestrated by people targeting a specific
    entity. So, BAPTs are APTs applied to blockchains.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: According to *MIT Technology Review*, “In August 2018, AnChain.ai identified
    five Ethereum addresses behind an extremely sophisticated attack that exploited
    a contract flaw in a popular gambling game to steal $4 million.” In response,
    the creators of FOMO3D, commented that everything worked as intended. “No rules
    we set in place were broken. Our experiments strive to find exploits where human
    nature and blockchain interact. We design our projects around fighting such threats,
    We were not a bank that was robbed. The very goal of our project was for someone
    to win it and run away with everything!”
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: Random number generation (RNG) is commonly used in dapps, just like all online
    Internet games. Think about an online poker game. The house will generate the
    hand based on a random number generator for every play.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: 'A perfect random number should mathematically have high entropy and cannot
    be predicted. However, on-blockchain RNG turns out to be quite challenging because
    of the nature of the blockchain: immutable, decentralized, transparent.'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: Once the dapp has “bad randomness,” it will be exploited by hackers who can
    predict the game play.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: The Lity language and virtual machine extend the Ethereum protocol to provide
    highly secure random number seeds for smart contracts when the underlying blockchain
    consensus is delegated proof of stake (DPoS). Please see [Chapter 14](ch14.xhtml#ch14)
    for more details.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: The following is the code snippet of the FOMO3D `airdrop()` function that will
    generate a random number based on various sources such as `timestamp`, `block
    coinbase`, `sender`, and so on, yielding the result if the participant is the
    winner or not.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch12_images.xhtml#pro12_3)'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Technically, this `airdrop()` function is bug-free. However, in the context
    of a blockchain-based smart contract, this code is vulnerable, as explained here:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: The Ethereum blockchain takes seconds to reach the consensus.
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This code can be executed in milliseconds in a typical computer, which is 1,000
    times faster than on the blockchain.
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This smart contract source code is transparent to everyone on the blockchain.
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the random number seeds used are transparent to everyone on the blockchain;
    in other words, there’s a lack of entropy.
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Based on these facts, it is feasible for a hacker to design a malicious smart
    contract to exploit this bad randomness, by precomputing the `airdrop()` result,
    and participating in FOMO3D only when the result is known to be winning! Brilliant
    idea!
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 12.4](ch12.xhtml#ch12fig4) visualizes the entire hacking campaign.
    There were 2 million transactions involved over the course of 2 weeks, and there
    were 22,000+ Ethereum addresses involved. Most of them were malicious attack smart
    contracts, launched by the five wallet addresses!'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f12_04.jpg)'
  id: totrans-463
  prefs: []
  type: TYPE_IMG
- en: '**Figure 12.4** Visualization of the BAPT-LW hacker group (more than five ETH
    wallet addresses) attacking LastWinner, a FOMO3D copycat dapp, in August 2018'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: Unknowns and Beyond
  id: totrans-465
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Note that these reported vulnerabilities may be only the tip of the iceberg.
    There were more than 1 million smart contracts deployed on Ethereum at the end
    of 2018, while only 50,000 of them contained publicly accessible source code.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: Based on research powered by the AnChain.ai smart contract auditing sandbox,
    more than 0.6 percent of the 50,000 mainnet-deployed smart contract source code
    is vulnerable to a reentrancy attack. There are 57,911 known vulnerabilities among
    all of them.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: Even a known vulnerability can repeat history. On January 16, 2019, the Constantinople
    protocol upgrade was delayed, at the last minute, because of a security vulnerability
    enabled by EIP 1283\. This vulnerability led to the possibility of a new reentrancy
    vector making previously known secure withdrawal patterns (`.send()` and `.transfer()`)
    unsafe in specific situations, where the attacker could hijack the control flow
    and use the remaining gas enabled by EIP 1283\. The upgrade was hence delayed.
    Otherwise, another Ethereum catastrophe would happen.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, there may be unknown vulnerabilities that already exist but
    have not yet been discovered, like zero-day bugs in the cybersecurity industry.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: 'I will conclude this section with the Decentralized Application Security Project
    (DASP) top-ten vulnerabilities of 2018:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: Reentrancy
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access control
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arithmetic
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unchecked low-level calls
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Denial of service
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bad randomness
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Front running
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Time manipulation
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Short addresses
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unknown unknowns
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Best Practices for Securing Smart Contracts
  id: totrans-481
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see from the previously mentioned major smart contract hacks, developing
    secure smart contracts can be quite challenging.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, Steve McConnell’s “Code Complete” shows the following statistics for
    the number of bugs per line of code:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: '*Industry average*: About 15 to 50 errors per 1,000 lines of delivered code'
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Microsoft applications*: About 10 to 20 defects per 1,000 lines of code during
    in-house testing and 0.5 defect per 1,000 lines of code in released products'
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another challenge for the Ethereum blockchain is that it’s hard to change the
    smart contract code once it’s deployed. Think about Microsoft Windows patches
    that arrive weekly to fix known vulnerabilities. There is no such mechanism on
    the blockchain. It’s “code is law.”
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: The Lity project provides a mechanism to upgrade Ethereum-compatible smart contracts
    on Lity-based blockchains. The idea is to declare the contract interface at the
    contract address and then provide proxy implementations of all the functions.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: Hence, it is critical to write secure code in the upcoming smart contract era.
    Fortunately, there are various projects and startups that aim to help developers
    secure their smart contracts by performing auditing to identify vulnerabilities.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: The following are a few best practices.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: Expert Manual Auditing
  id: totrans-491
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The widely adopted way to audit smart contracts, especially the ICO tokens,
    is called *expert manual auditing*. Solidity is new programing language and lacks
    security tools compared to the commercial tools in the well-established cybersecurity
    industry such as Coverity for enterprise C++/Java source code auditing. The experts
    are mostly computer language experts with experience to identify vulnerabilities
    manually.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: Formal Verification
  id: totrans-493
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Formal verification* (FV) is one of the promising fields for smart contract
    auditing that aims to mathematically prove the source code correctness. According
    to an EE Times article by Alok Sanghavi, “Formal verification is the act of proving
    or disproving the correctness of intended algorithms underlying a system with
    respect to a certain formal specification or property, using formal methods of
    mathematics.” In fact, the formal method dates back 40 years ago, and there are
    various applications such as Windows leveraging formal verification to prove some
    of the critical kernel modules’ source code correctness.'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: Sandbox
  id: totrans-495
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A *sandbox*, simply put, is a specially designed virtual machine that can automatically
    execute the opcode instructions in a restricted environment. It’s a proven technology
    in cybersecurity; companies like FireEye and Palo Alto Network develop malware
    sandbox products that can detect the most sophisticated malware like APT32, and
    so on.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: For example, modern advanced malware is polymorphic, which means it will modify
    its own bytes, while most antivirus (AV) software still relies on signature-based
    detection, which is a hash of the payload bytes. Hence, this polymorphic malware
    can bypass the AV detection since they have different hashes, even though they
    function similarly. Alternatively, the sandbox will analyze the code execution
    behaviors and look for suspicious patterns in a fully automated fashion.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: Inspired by the proven success of the malware sandbox, AnChain.ai developed
    the world’s first smart contract auditing sandbox and launched in February 2019\.
    A good sandbox product should have built-in features such as static analysis,
    dynamic execution, statistical analysis, code similarity, and so on.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: Tools
  id: totrans-499
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Based on these best practices, the following are popular open source tools
    that can get you started with secure smart contracts:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: '*Mythril Classic*: This is an open source EVM bytecode security analysis tool.
    See [https://github.com/ConsenSys/mythril-classic](https://github.com/ConsenSys/mythril-classic).'
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Oyente*: This is an alternative for static smart contract security analysis.
    See [https://github.com/melonproject/oyente](https://github.com/melonproject/oyente).'
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Slither*: This is a Solidity static analysis framework. See [https://github.com/crytic/slither](https://github.com/crytic/slither).'
  id: totrans-503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Adelaide*: This is the SECBIT static analysis extension to the Solidity compiler.
    See [https://github.com/sec-bit/Adelaide](https://github.com/sec-bit/Adelaide).'
  id: totrans-504
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Note**'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: The Lity project (see [https://www.litylang.org](https://www.litylang.org))
    provides Ethereum-compatible tools to perform static analysis at compile time,
    using tools like Oyente and ERC Checker. See [Chapter 15](ch15.xhtml#ch15) for
    more details.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  id: totrans-507
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, I covered the major Ethereum smart contract hacks and vulnerabilities
    in its short history and discussed best practices for securing smart contracts.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum is still in its infancy. I consider it to be like 1990’s Internet,
    slow and vulnerable. But it will soon become as mature as 2019’s Internet. However,
    with data breaches and APT hacks occasionally making headlines, even Internet
    security still has a long way to go. Security is a collaborative effort that involves
    many specialized experts, teams, and tools. Are you ready to secure your smart
    contracts?
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: 13. The Future of Ethereum
  id: totrans-510
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By Tim McCallum
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: The creator of Ethereum, Vitalik Buterin, defines *blockchain* as a decentralized
    system that contains shared memory, and as such, a good blockchain application
    is one that needs both a decentralized architecture and shared memory capabilities
    across the network’s architecture. Ethereum’s focus, to date, has been on decentralization
    (philosophically, decentralizing the Internet). The Internet, while possessing
    the design characteristics to be decentralized, has since its inception become
    increasingly centralized. The Ethereum network provides guaranteed decentralized
    computation on a global scale. In addition to this, the Ethereum network holds
    shared memory within the entire network, known as the *state*.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: These attributes, in a technical sense, make Ethereum a “world computer.” It
    has already proven that it can support next-generation decentralized applications
    (dapps) that facilitate customized online payments, authentication mechanisms,
    decentralized storage solutions (swarm), digital currencies, and much more.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I begin by covering the 2018 development of Ethereum. I will
    discuss how the Ethereum foundation’s researchers and Ethereum developers are
    solving present-day challenges. I then step into the future by uncovering developments
    that are at the fringe; these are developments that could materialize as proof
    of concepts for early adoption around 2020\. Before concluding the future of Ethereum,
    I look well into the future at the “hard-to-implement” paradigm shifts that, if
    realized, could propel Ethereum forward, beyond what is even imaginable today
    in terms of privacy, scalability, and security.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: Potential improvements to the Ethereum network go through the Ethereum Improvement
    Proposal (EIP) process before being implemented. The stages for EIPs are draft,
    accepted, final, and differed. Finalized EIPs are proposals that have been adopted.
    For a proposal to succeed, the issuer is required to provide detailed information
    including the motivation, specifications, rationale, and backward compatibility.
    The proposal may also provide code examples.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: One of the most famous EIPs is EIP20, which defines the smart contracts for
    issuing ERC20 tokens on the Ethereum blockchain. You can read the EIP20 standard
    at `https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md`. You can review
    all EIPs at `https://github.com/ethereum/EIPs`.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum 1.0
  id: totrans-518
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There were three main categories of challenges on the table for Ethereum in
    2018\. These are privacy, consensus, and scalability. The Ethereum Foundation’s
    researchers and Ethereum developers have already made inroads into solving these
    problematic areas. As you will read shortly, Ethereum has already released its
    hybrid proof-of-work (PoW)/proof-of-stake (PoS) consensus mechanism known as Casper
    the Friendly Finality Gadget (FFG). The future Ethereum road map is very exciting
    and full of activity. To kick things off, let’s take a look at the problems and
    solutions around privacy, consensus, and scalability in a bit more depth.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: Privacy
  id: totrans-520
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The privacy paradox is such that while lots of nodes are verifying your data
    on the public ledger (providing security through collaborative consensus), having
    your data on the public ledger, in fact, compromises your privacy. Here is an
    example. If somebody knew the date, time, and amount particulars of a transaction
    that you sent or received, that person could inspect the public ledger and identify
    your account’s address (public key). This issue is common to most public distributed
    ledgers (blockchains), not just Ethereum. What is important is, from that moment,
    that person could track your account balance, income, and spending via the public
    ledger. This is an invasion of your privacy. Inroads have been made into resolving
    the privacy problem at the base protocol level. The Byzantium fork released by
    Ethereum in October 2017 introduced new cryptographic algorithms (zero-knowledge
    proofs and ring signatures). These cryptographic tools and other enhancements
    to the Ethereum network such as the introduction of state channels are all going
    to help developers resolve these and other privacy problems.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: Consensus
  id: totrans-522
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Chapter 2](ch02.xhtml#ch02) discussed the PoW and PoS consensus mechanisms
    of blockchains. Ethereum, since its inception, has always been a PoW blockchain.
    However, with the next-generation Ethereum, it is moving toward PoS. The switch
    from PoW to PoS is perhaps the greatest challenge and opportunity facing the Ethereum
    community today.'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: 'The advent of the PoW protocol introduced one of the most revered blockchain
    attributes: immutability. More specifically, it is computationally impractical
    to reverse past transactions while computers (nodes on the peer-to-peer blockchain
    network) are competing to expend their computational energy, creating new blocks
    (mining the blockchain). Ethereum currently also uses the PoW consensus protocol,
    and just like with Bitcoin, the PoW consensus process on the Ethereum network
    thrives as computers all compete on the network, expending their computational
    energy, to create new blocks on top of the blockchain.'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: While PoW has many strengths, it is also criticized in relation to energy efficiency
    and potential centralization of the PoW mining process.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: Proof of Stake
  id: totrans-526
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In October 2017, Ethereum’s Vitalik Buterin and colleague Virgil Griffith released
    a publication called Casper the Friendly Finality Gadget. Casper FFG is a partial
    consensus mechanism that combines PoS algorithm research and Byzantine fault-tolerant
    consensus theory. Importantly, for implementation, Casper FFG was designed to
    overlay an existing operational PoW blockchain. Hence, Casper FFG is a hybrid
    PoW/PoS consensus solution. While a formal move to PoS will only happen on Ethereum
    2.0, the PoS experimentation has already started on Ethereum 1.0.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
- en: There are more than three Ethereum testnets. These Ethereum testnets are sandboxes,
    used to simulate the Ethereum network and the Ethereum Virtual Machine (EVM).
    Ethereum’s hybrid PoW/PoS implementation, Casper FFG, was launched in its own
    testnet (not in production) in January 2018\. The following discussion is an early
    overview of the Casper FFG PoW/PoS hybrid consensus solution.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: 'In PoW mining, a miner is given a challenge: finding a nonce. Finding the nonce
    is done by brute force and involves randomly guessing repeatedly until the nonce
    is discovered. This process is miners’ proof that they have worked. That’s why
    it’s called *proof of work*. In PoS, the blocks are created by validators. Validators
    are allowed to participate in creating blocks only if they put skin in the game.
    This involves staking a large deposit (at this early stage believed to be around
    1,500 ETH). That’s why it’s called *proof of stake*.'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
- en: PoS validation is unlike PoW mining from a hardware perspective as there is
    no specialized competing hardware required. The validators are all virtual (software).
    The process of joining and leaving the role of being a validator in PoS is known
    as *bonding* and *unbonding*, respectively. So, how is the bonding and unbonding
    recorded? Casper FFG saves the bonding and unbonding activity in the blockchain
    state (along with account balances and so forth). Anyone can join the set of validators
    by sending an Ethereum transaction to the Casper contract (along with some parameters
    such as a withdrawal address and of course ETH for gas).
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
- en: The basic premise behind PoS validation involves economic incentives. For example,
    a bonded validator who exerts clearly bad behavior (like creating two blocks at
    the same height) will be penalized economically. On the other hand, a bonded validator
    that does not deliberately attack the network will receive returns, or interest,
    on the deposit that they have staked. In the Casper FFG PoS implementation, the
    number of opportunities where manipulation is more profitable than the costs associated
    with performing the manipulation is small. Ideally, there would be close to zero
    (no) opportunities to manipulate (attack) the network without encountering a severe
    economic penalty. In a given PoW blockchain implementation (where all nodes are
    running the same PoW consensus mechanism), the chain with the most blocks (the
    longest chain) wins (see [Figure 13.1](ch13.xhtml#ch13fig1)). This is because
    it exhibits the most proof of work.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f13_01.jpg)'
  id: totrans-532
  prefs: []
  type: TYPE_IMG
- en: '**Figure 13.1** The PoW algorithm identifies the longest chain as the authoritative
    one.'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
- en: In Casper FFG PoS, the chain with the most value at risk (VaR) supporting it
    wins. The general principle is that if you support a block that does not make
    it into the main chain, instead of being rewarded you get penalized. You lose
    an amount of ETH that is equal to the block reward. In practice, let’s propose
    that there are two blocks available to support. The block on chain A has a 90
    percent chance of succeeding. The block on chain B has a 10 percent chance of
    succeeding. If you support chain A, you will be rewarded. If you support chain
    B, you will be penalized. A potential economic conundrum comes into play if you
    start thinking that you could support both A and B for profit. Ethereum has a
    clever way of making this unappealing. In this case, where you have split your
    bet two ways, you will only be allowed to receive 50 percent of the reward from
    chain A (if it succeeds) and 50 percent of the reward from chain B (if it succeeds).
    This betting on both sides will always net a lesser result than just supporting
    chain A. This economic incentive results in convergence, and this is the desired
    path to ensure a single honest chain via PoS consensus. The following is a simple,
    albeit concrete, example for demonstration purposes.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: Suppose the block reward is 10 ETH. Suppose you, as a validator, support a block
    on chain A and a block on chain B. In a scenario where chain A succeeds, you would
    receive 5 ETH (only 50 percent of the block reward) from your efforts on chain
    A, and you would lose 10 ETH (the entire block reward) for supporting a block
    on chain B. The net result for this scenario would be negative 5 ETH for your
    efforts.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
- en: In PoS, the validator needs to authenticate. It has been proposed that, instead
    of simply using a private key, a validator code function be created. This modular
    design would mean that the validator could choose alternative signatures when
    authenticating. For example, the validator could choose to use a Lamport signature
    as these are believed to be secure against quantum computer threats.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
- en: Scalability
  id: totrans-537
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Blockchain systems trade off against decentralization, scalability, and security.
    It is reasonably easy to solve any two out of these three issues at any one time.
    Vitalik Buterin quips that this is a blockchain “trillema,” whereby you can easily
    solve two issues at the cost of the third, but you can’t easily solve all three.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
- en: Plasma
  id: totrans-539
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Plasma is just one of the strategies that could address blockchain scalability.
    Plasma is different from sharding (covered later in the chapter). A successful
    plasma implementation would send transactions off-chain to improve scalability.
    In this regard, plasma is what is known as a second-layer solution. Second-layer
    solutions are implemented through code that is written outside of the base protocol
    layer (or, commonly known as the layer 1 protocol). More specifically, second-layer
    solutions have no effect on the base protocol layer’s consensus mechanism. Just
    to clarify, plasma differs from sharding in that a successful sharding solution
    would be coded into the base protocol layer. Plasma is designed to be compatible
    with on-chain scaling solutions such as sharding and therefore not only can coexist
    but can even be complementary. In fact, on-chain scalability improvements will
    just further increase the scalability of the second-layer solution.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
- en: Plasma is a set of nested blockchains. These plasma blockchains are created
    using smart contracts on the main Ethereum network. Uploading your smart contract
    onto the public Ethereum blockchain allows you to launch your own specific applications.
    Applications can include decentralized exchanges, social networks, payment networks,
    and even your own private Ethereum blockchain implementation. These plasma blockchains
    (your applications) are all accountable to the public Ethereum blockchain.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
- en: The scalability is brought about by the fact that while processing an extremely
    high volume of transactions, the plasma blockchains do not submit their entire
    transaction volume to the public Ethereum blockchain. Instead, the plasma blockchains
    send only a small amount of data (block header hashes) about the plasma blockchains
    state. Plasma works on the premise that data being submitted to the main chain
    is free from fraudulent activity, while the public Ethereum blockchain is not
    required to perform computation in general. If anyone can publish a proof that
    fraudulent activity took place (a dispute), the public Ethereum blockchain performs
    computation, resolving the dispute and punishing the offending participant.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
- en: State Channels
  id: totrans-543
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: State channels are a mechanism that allow two participants to sign promises,
    at given points in time. These time-based off-chain signed promises provide proof
    of activity. State channels provide an opportunity for decentralized applications
    to interact with other parties (customers) off-chain. This provides a cheap and
    fast user experience, which would not be possible on-chain. State channels are
    smart contracts. State channels are also a second-layer solution to the Ethereum
    scalability problem. From a usability perspective (dapp development), having a
    high volume of off-chain activity means low to negligible gas fees. As such, dapps
    that employ state channels as part of their solution not only offer near real-time
    activity but also the ability for customers to send and receive micro-payments.
    A use case for this could be a gambling application that allows a high volume
    of micro-betting, in real time, for entertainment purposes.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
- en: Raiden
  id: totrans-545
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Raiden network leverages off-chain state channels. The Raiden network offers
    micro payments of ERC20-compliant tokens while taking negligible fees and providing
    responses to transactions in near real time. The difference between state channels
    and the Raiden network is that rather than creating a new state channel for every
    new interaction between two parties, Raiden creates a network of channels whereby
    all participants are transitively connected via a web of ERC20 token–complaint
    payment channels, making use of natural network topology architecture.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
- en: Token Improvements
  id: totrans-547
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The ERC20 tokens have proven to be a great success. ERC20 has found one of the
    first killer applications for Ethereum, as an initial coin offering (ICO) token
    sale platform. The Ethereum community is working on further improving tokens issued
    from the Ethereum smart contracts.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
- en: One of the more interesting ideas is nonfungible tokens (NFTs). A key characteristic
    of money is fungible, meaning that a dollar bill is completely interchangeable
    with another dollar bill. That is the case for blockchain tokens as well. While
    you can trace the use of each token in the ledger, no two tokens are different.
    But with NFTs, a token is truly unique. The famous Ethereum game CryptoKitties
    is a good example of how NFTs can be applied, as each “cat” is completely unique.
    The ERC721 proposes an NFT standard that is compatible with ERC20\. Such NFTs
    could enable many token applications ranging from collectibles trading to real
    estate transactions. To participate in this EIP, please refer to [https://github.com/ethereum/eips/issues/721](https://github.com/ethereum/eips/issues/721).
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
- en: Beyond Ethereum 1.0
  id: totrans-550
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ethereum has had plans for some time to create a blockchain to surpass the current
    second-layer solutions on offer. The overall vision has primarily been to create
    a blockchain solution that is capable of scaling to thousands of on-chain transactions
    per second, with the most promising of the proposed solutions being sharding.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
- en: Sharding
  id: totrans-552
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The original idea for sharding was that the main Ethereum blockchain would publish
    what is known as a *validator manager contract*. In this scenario, the validator
    manager contract would simply be a single smart contract on the Ethereum 1.0 blockchain.
    It was decided (in July 2017) shortly after disparate development processes in
    the areas of both Casper (PoS) and sharding that this architecture would change.
    The most significant change to the original idea was to make the core component
    of the sharding system not just a smart contract but instead a complete PoS chain.
    This shift from a PoW smart contract to a self-sufficient PoS chain would remove
    the need for gas, reduce transaction times, and reduce dependency on the underlying
    EVM.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
- en: The “Ethereum 2.0” section explains this new sharding architecture, namely,
    the introduction of the beacon chain.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
- en: Zero-Knowledge Proofs
  id: totrans-555
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This section explains the basic premise of the zero-knowledge proofs. In a given
    binary situation (where there are only two outcomes available, either yes or no),
    a “prover” with the secret weapon to discern a binary statement from the situation
    must convince a skeptical “verifier” that the binary statement is correct, while
    not revealing the secret. In 2003 a Weizmann Institute of Science faculty member,
    Oded Goldreich, introduced a novel zero-knowledge proof involving a color-blind
    validator. In this scenario, the validator possessed two cards, one red and the
    other green. To the color-blind validator, the cards looked the same, other than
    the fact that the word *red* was written on the back of the red card, and the
    word *green* was written on the back of the other. Let’s play out this scenario
    and assume that the validator is skeptical about the prover’s claim to be able
    to discern the cards without seeing the words on the back. To move this experiment
    forward, the validator would repeatedly show the prover the front side of each
    card, in a random fashion. Each time, the validator would ask the prover what
    color he sees. After some time, the verifier would eventually be convinced that
    the prover is capable of discerning the colors of the two individual cards. This
    is mostly because the verifier performed this over many rounds and the validator
    randomly switched the cards behind his back during each round.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the three properties that a zero-knowledge proof must satisfy:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
- en: '*Completeness*: This is when the honest verifier is convinced that the honest
    prover returned the correct answer in the binary statement.'
  id: totrans-558
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Zero knowledge*: This is where the verifier has no knowledge of how the prover
    came up with the binary statement and learns nothing from the process other than
    that the binary statement provided by the prover is correct.'
  id: totrans-559
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Soundness*: This is where a prover (even a dishonest one who is just guessing
    the answer of the binary statement) is able to convince an honest verifier that
    the answer is correct.'
  id: totrans-560
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While the first two properties can be quite easily satisfied during one round
    of an interactive zero-knowledge proof exercise, there is statistically only a
    50 percent chance of achieving soundness. Put simply, a dishonest prover could
    just take a 50/50 guess to the binary situation and get it right 50 percent of
    the time.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
- en: With this in mind, it is important to remember that zero-knowledge proofs are
    probabilistic. They are not deterministic. They rely on randomness to succeed.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
- en: This information describes a specific type of zero-knowledge protocol known
    as *interactive*. In an interactive zero-knowledge protocol, the verifier and
    the prover must repeat each round until the verifier is convinced, without any
    reasonable doubt, that the prover knows the secret.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
- en: A noninteractive zero-knowledge protocol is different because it requires only
    a single round. A noninteractive zero-knowledge proof, however, requires a “trusted
    setup.” One advantage of the noninteractive zero-knowledge protocol is that it
    allows many verifiers to all independently query the ability of the prover. Think
    of this as a one-to-many relationship between the prover and verifier entities,
    as opposed to the interactive zero-knowledge protocol’s one-to-one relationship.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
- en: ZK-SNARKs
  id: totrans-565
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Zero-Knowledge Succinct Non-interactive ARguments of Knowledge (ZK-SNARKs) are
    able to be satisfied through computer code, and as such zero-knowledge proof implementations
    have tremendous potential in the online space. Just one example of ZK-SNARKs’
    potential is the creation of a decentralized, anonymous, sealed-bid auction. In
    this case, while the logic of determining the winner would execute successfully,
    the winner’s identity and the winning bid amount could both remain confidential.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
- en: You can think of ZK-SNARKs in the following way. ZK-SNARKs are for arbitrary
    computations, just as hashing algorithms are for arbitrary data. Put simply, you
    can turn an arbitrary computation into a ZK-SNARK, and since verifying arbitrary
    computations is at the core of the Ethereum blockchain, ZK-SNARKs are of course
    relevant to Ethereum. If implemented in Ethereum, ZK-SNARKs would not be limited
    to a single computational problem. Enabling ZK-SNARKs for Ethereum would, among
    other things, reduce the gas costs for certain pairing functions and elliptic
    curve operations. Overall, the biggest payoff for enabling ZK-SNARKs would be
    improved (guaranteed) performance of the EVM. Unfortunately, an implementation
    of this magnitude would be extremely difficult to complete and as such might take
    many years to move from proof of concept to early adoption. This may be something
    that will be implemented in the future of Ethereum. Let’s now compare ZK-STARKs.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
- en: ZK-STARKs
  id: totrans-568
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The confidentiality of a zero-knowledge proof is already being used to enhance
    privacy in cryptocurrencies. For example, Zcash already uses the ZK-SNARKs protocol.
    I just mentioned the possibility of an Ethereum implementation of ZK-SNARKs and
    the associated advantages. However, a shinier new cousin, Zero Knowledge Succinct
    Transparent ARguments of Knowledge (ZK-STARKs), looks to resolve one of the primary
    weaknesses of ZK-SNARKs: the reliance on a trusted setup. Interestingly, ZK-STARKs
    have also arrived with much simpler cryptographic assumptions. You may recall
    that ZK-SNARKs were promising advantages in relation to pairing functions and
    elliptical curve operations. Well, ZK-STARKs avoid the need for elliptic curves,
    pairings, and the knowledge-of-exponent assumption; instead, ZK-STARKs rely purely
    on hashes and information theory.'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
- en: This means that while ZK-STARKs bring about efficiency gains and more, they
    are also secure against attackers with quantum computers. Looking toward the future,
    ZK-STARKs could replace ZK-SNARKs, providing superior scalability and privacy,
    specifically to decentralized public ledgers like Ethereum. It is also important
    to note that these advantages all come at a cost. In other words, the size of
    a proof goes up from 288 bytes to a few hundred kilobytes. Further research is
    required in relation to shortening proof length or the aggregation and compression
    of several ZK-STARK proofs.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
- en: In the context of public blockchain applications, there is a high need for trust
    minimization, possibilities that elliptic curves could break, and a seemingly
    real possibility of quantum computers coming around. Given all of these points,
    implementing ZK-STARKs in decentralized public ledgers seems worth it, even if
    there are costs involved.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum 2.0
  id: totrans-572
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ethereum 2.0 comprises many separate components. Casper PoS, sharding, and Ethereum-flavored
    WebAssembly (eWASM) have been on the minds of Ethereum developers for quite some
    time. For example, Vitalik Buterin has been writing about PoS implementation ideas
    since as far back as 2014\. This blend of technologies somehow resulted in Ethereum
    2.0 adopting the unfortunate name of Shasper, a combination of sharding and Casper
    PoW. Thankfully, most of the time nowadays you will see it referred to as either
    Serenity or simply Ethereum 2.0.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
- en: After years of research and development, these Ethereum 2.0 ideas are making
    their way into the code repositories of many Ethereum developers throughout the
    community. For example, there are many individual implementations of the Ethereum
    2.0 specification, such as a Rust implementation of the Ethereum 2.0 beacon chain
    and a Java implementation of the Ethereum 2.0 beacon chain. The official Ethereum
    reference implementation, which these other repositories are modeling, is a Python
    implementation of the Ethereum 2.0 beacon chain.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
- en: The Ethereum 2.0 specification documents indicate that Ethereum 2.0 can initially
    be implemented without any consensus changes to Ethereum 1.0\. This means that
    at this early stage, the Ethereum 1.0 base layer will not undergo a fork or chain
    split while moving these exciting ideas forward into production. As I will discuss
    shortly, a contract (the gateway to the Ethereum 2.0) will be added to Ethereum
    1.0, and deposits into this contract will allow users to become validators on
    the Ethereum 2.0 beacon chain.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
- en: The Beacon Chain
  id: totrans-576
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One of the core components, mentioned in the Ethereum 2.0 specifications, is
    the beacon chain. The *beacon chain* is the central PoS chain that underpins the
    sharding system. The beacon chain stores and maintains a registry of validators.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
- en: Validators
  id: totrans-578
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The beacon chain invites new validators to join Ethereum 2.0\. As previously
    mentioned, validators join the beacon chain by simply depositing ether into the
    appropriate Ethereum 1.0 contract. An actively participating validator is able
    to propose blocks on the beacon chain. A validator who creates an Ethereum 2.0
    beacon chain block is also known as a *proposer*. In addition to proposing blocks,
    validators are also able to sign off on beacon chain blocks. However, to do so,
    the validator has to be part of a committee. Validators cannot self-select to
    be part of a committee. Instead, committees of independent validators are assembled
    in a random fashion. Randomness is generated by the beacon chain itself. A validator
    can exit the beacon chain voluntarily or be forced to exit in the event that the
    validator attacks the chain.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
- en: Shard Chain
  id: totrans-580
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: There are many shard chains. Shard chains are where end-user transactions take
    place and where transaction information is stored. When signing off (attesting
    to) a block, the committee of validators create what is known as a *crosslink*.
    A crosslink is essentially a set of validator signatures, attesting to a block
    in a shard chain that is then confirmed into the beacon chain. A crosslink allows
    updates in a shard chain to be communicated with the beacon chain; in other words,
    crosslinks are used to determine the finality of shards.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
- en: A very interesting implication of sharding is that today’s Ethereum-compatible
    blockchains such as Ethereum Classic and CyberMiles can now interoperate within
    the new Ethereum 2.0 ecosystem. For example, Ethereum Classic and its established
    miner community will stay as a PoW chain within the ecosystem. Its native cryptocurrency,
    the ETC, will become the PoW store-of-value coin in the ecosystem.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
- en: One of the design goals of Ethereum 2.0 is to allow for a typical consumer laptop
    to process (validate) shards, including any system-level validation such as the
    beacon chain. This is made possible because the sharding architecture now uses
    its own PoS chain as opposed to the original idea, mentioned earlier, where the
    old sharding architecture used to consist of a single smart contract on the PoW
    chain.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
- en: You may have already realized by now that Ethereum 2.0/Serenity is a new blockchain,
    albeit it’s one that links to the existing Ethereum 1.0 PoW chain (i.e., the new
    PoS chain is aware of the block hashes of the PoW chain, and so forth). The goal
    for this architecture will allow ether to be moved between the original PoW chain
    and the PoS chain. In addition, the long-term vision would be to allow applications
    from the current blockchain to be redeployed on a shard of the Ethereum 2.0 system.
    This would be implemented via a new EVM interpreter written in eWASM.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
- en: eWASM
  id: totrans-586
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Currently there are separate compilers for each of the smart contract programming
    languages. You can build and install either the Solidity or Vyper compiler software
    and run it on local disk. Alternatively, you can use the free online code editors
    for both Solidity and Vyper.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
- en: The job of a compiler is to convert your high-level smart contract code into
    bytecode and application binary interface (ABI). Once your code is compiled, it
    can be executed by the EVM.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
- en: eWASM is Ethereum’s own implementation of WebAssembly. WebAssembly is currently
    being designed as an open standard by a W3C Community Group.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
- en: eWASM is being developed to replace the EVM. Once eWASM is implemented, developers
    will be able to write smart contracts in other languages such as Rust and C/C++
    as opposed to just Solidity and Vyper. It is important to note that eWASM will
    be completely backward compatible with the current EVM. This means smart contracts
    that are currently written in Solidity or Vyper will still be able to execute
    in the new environment.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
- en: Delivery Phases of Ethereum 2.0
  id: totrans-591
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The delivery phases of Ethereum 2.0 should run something like the following.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
- en: Phase 0
  id: totrans-593
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Ethereum 2.0 is expected to be implemented as follows. Phase 0, which I have
    briefly covered, involves the introduction of the beacon chain, so essentially
    Phase 0 is the beginning of the new PoS chain. More specifically, it’s a PoS beacon
    chain without shards.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
- en: Phase 1
  id: totrans-595
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The next phase, Phase 1, will implement shards as data chains. Phase 1 will
    provide the foundations to create decentralized data applications; however, to
    fully implement any of these types of applications, the benefits of Phase 2 will
    be required. Put simply, Phase 1 is implementing basic sharding without an EVM.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
- en: Phase 2
  id: totrans-597
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: EVM state transition functionality will be introduced in Phase 2\. Phase 2 will
    introduce functionality to create and manage accounts and contracts as well as
    transfer funds between shards and so forth.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
- en: 'The subsequent phases 3, 4, 5, and 6 have plans to introduce the following:'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
- en: A light-client state protocol
  id: totrans-600
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cross-shard transactions
  id: totrans-601
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tight coupling with main chain security
  id: totrans-602
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Super-quadratic or exponential sharding
  id: totrans-603
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is hoped that state transition changes and transaction executions will improve
    significantly because of the implementation of eWASM. There is a comprehensive
    Ethereum 2.0 road map that details each proposed phase. Please keep in mind that
    these specifications do change frequently and that the proof-of-concept algorithms
    and code repositories are under heavy construction.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
- en: Post–Ethereum 2.0 Innovation
  id: totrans-605
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I mentioned ZK-STARKs previously in this chapter. The main difference between
    SNARKs and STARKs is transparency. More specifically, there is no “trusted setup”
    in ZK-STARKs (no secrets in the setup of the system). This is an interesting area
    of research, and there is a chance that Ethereum will eventually upgrade to the
    use of STARKs to perform tasks such as data availability checks, state execution
    correctness checks, and improved base-layer cross-shard transactions, to name
    a few.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  id: totrans-607
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, I discussed the future direction of the Ethereum blockchain.
    Ethereum is not only a decentralized blockchain but also a decentralized developer
    community. It has a robust and democratic upgrade process known as the EIP. We
    are optimistic that Ethereum will remain one of the most widely used and technically
    advanced blockchains in the future.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
