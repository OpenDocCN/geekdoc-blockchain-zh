["```\n**Sample database**\n\nconst mongoose = require('mongoose');\n\nmongoose. connect(\n'mongodb+srv://rishabh1234:rishabh@blockchain-ecommerce.up78i. mongodb. net/blockchain-ecommerce?retryWrites=trueandw=majority', { useNewUrlParser: true, useUnifiedTopology: true }\n);\n\nconst paymentSchema = new mongoose.Schema({\nid: String,\nitemId: String,\npaid: Boolean\n});\n\nconst Payment = mongoose.model('Payment', paymentSchema);\n\nmodule.exports = {\nPayment\n}\n\n```", "```\n**Server**\n\nconst Koa = require(\"koa\");\nconst Router = require(\"@koa/router\");\nconst cors = require(\"@koa/cors\");\nconst ethers = require(\"ethers\");\nconst PaymentProcessor = require(\"../frontend/src/contracts/PaymentProcessor.json\");\nconst { Payment } = require(\"./db.js\");\nconst app = new Koa();\nconst router = new Router();\n\nrouter.get(\"/api/getPaymentId/:itemId\", async ctx => {\n   const paymentId = (Math.random() * 10000).\ntoFixed(0);\n   await Payment.create({\n       id: paymentId,\n       itemId: ctx.params.itemId,\n       paid: false\n   })\n   ctx.body = {\n      paymentId\n   };\n});\n\nconst items = {\n    '1': { id: 1, url: 'http: //UrlToDownloadItem1' },\n    '2': { id: 1, url: 'http; //UrlToDownloadItem2' }\n}\n\nrouter.get(\"/api/getItemUrl/:paymentId\", async ctx => {\n   const payment = awaitPayment.findOne({ id: ctx.\nparams.paymentId });\nif (payment andand payment.paid === true) { \n       ctx.body = {\n          url: items[payment.itemId].url\n     }\n } else {\n    ctx.body = {\n        url: ''\n    }\n }\n})\n\napp. use(cors()).use(router.routes()).use(router.\nallowedMethods());\napp.listen(4000, () => {\n   console.log(\"Server started\");\n});\nconst listenToEvents = () => {\n   const provider = new ethers.providers.\nJsonRpcProvider('http: //localhost:9545');\n   const networkId = '5777';\n\n  const paymentProcessor = new ethers.Contract(\nPaymentProcessor.networks[networkId].address, \n      PaymentProcessor.abi,\n      provider\n);\n\n  paymentProcessor.on('PaymentDone', async(payer,\namount, paymentId, date) => { \n       console.log(`\n       from ${payer}\n       amount ${amount}\n       paymentId ${paymentId}\n       date ${(new Date (date.toNumber()*1000)).\ntoLocaleString()}\n     `);\n\nconst payment = await Payment.findOne({ id: \npaymentId });\n       if (payment) {\n          payment.paid = true;\n          await payment.save();\n        }\n   });\n}\nlistenToEvents();\n\n```", "```\n// SPDX-License-Identifier: BITS\npragma solidity ^0.8.0;\n\nimport '@openzeppelin/contracts/token/ERC20/ERC20.sol';\n\ncontract Dai is ERC20 {\n   constructor() ERC20('Dai Stablecoin', 'DAI')\npublic {}\n   function faucet(address to, uint amount) external {\n      _mint(to, amount);\n   }\n}\n\n```", "```\n// SPDX-License-Identifier: BITS\npragma solidity >=0.4.22 <0.9.0;\n\ncontract Migrations {\n  address public owner = msg.sender;\n  uint public last_completed_migration;\n\nmodifier restricted() {\n  require(\n   msg.sender == owner,\n   \"This function is restricted to the contract's owner\"\n  );\n _;\n}\n\nfunction setCompleted(uint completed) public restricted {\n   last_completed_migration = completed;\n  }\n}\n\n```", "```\n// SPDX-License-Identifier: BITS\npragma solidity ^0.8.0;\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\ncontract PaymentProcessor {\n   address public admin;\n   IERC20 public dai;\n\n   event PaymentDone(\n      address payer,\n      uint amount,\n      uint paymentId,\n      uint date\n   );\n\n   constructor(address adminAddress, address daiAddress) public {\n      admin = adminAddress;\n      dai = IERC20(daiAddress);\n   }\n\nfunction pay(uint amount, uint paymentId) external { \n    dai.transferFrom(msg.sender, admin, amount);\n    emit PaymentDone(msg.sender, amount, paymentId,\nblock.timestamp); \n   }\n}\n\n```", "```\nimport React from \"react\";\nimport { ethers, Contract } from \"ethers\";\nimport PaymentProcessor from \"./contracts/\nPaymentProcessor.json\";\nimport Dai from \"./contracts/Dai.json\"; \nconst getBlockchain = () =>\n  new Promise((resolve, reject) => {\n     window.addEventListener(\"load\", async () => {\n       if(window.ethereum) {\n          await window.ethereum.enable();\n          const provider = new ethers.providers.\nWeb3Provider(window.ethereum);\n          const signer = provider.getSigner();\n\nconst paymentProcessor = new Contract( \n            PaymentProcessor.networks[window.\nethereum.networkVersion].address, \n            PaymentProcessor.abi,\n            signer\n        );\n        const dai = new Contract(\n           Dai.networks[window.ethereum.\nnetworkVersion].address,\n           Dai.abi,\n           signer\n        );\n        resolve({provider, paymentProcessor, dai});\n      }\n      resolve({provider: undefined, payment\nProcessor: undefined, dai:undefined})\n       })\n    })\n    export default getBlockchain;\n\n```", "```\nimport React from 'react';\nimport {ethers} from 'ethers';\nimport axios from 'axios'\nimport { darkviolet } from 'color-name';\n\nconst API_URL = 'http: //localhost:4000';\nconst ITEMS = [ \n   {\n     id: 1,\n     price: ethers.utils.parseEther('100')\n   },\n   {\n     id: 2,\n     price: ethers.utils.parseEther('200')\n   }\n];\nfunction Store() {\n   const buy = async item => {\n      const response1 = await axios.get(`${API_URL}/api/getPayment/${item.id}`);\n     const tx1 = await dai.approve(paymentProcessor.address, item.price);\n     await tx1.wait();\n\n     const tx2 = await paymentProcessor.pay(item.price, response1.data.paymentId);\n     await tx2.wait();\n     await new Promise(resolve => setTimeout(resolve, 5000));\n     const response2 = await axios.get(`${API_URL}/api/getItemUrl/${response1.data.paymentId}`);\n     console.log(response2);\n   }\n}\n\n```"]