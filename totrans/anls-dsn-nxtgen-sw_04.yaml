- en: © Springer Nature Switzerland AG 2020A. M. LangerAnalysis and Design of Next-Generation
    Software Architectures[https://doi.org/10.1007/978-3-030-36899-9_4](https://doi.org/10.1007/978-3-030-36899-9_4)
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: © Springer Nature Switzerland AG 2020A. M. Langer下一代软件架构的分析与设计[https://doi.org/10.1007/978-3-030-36899-9_4](https://doi.org/10.1007/978-3-030-36899-9_4)
- en: 4. Distributed Client/Server and Data
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4. 分布式客户端/服务器和数据
- en: 'Arthur M. Langer^([1](#Aff2) [ ](#ContactOfAuthor2))(1)Center for Technology
    Management, Columbia University, New York, NY, USAArthur M. LangerEmail: [al261@columbia.edu](mailto:al261@columbia.edu)'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 'Arthur M. Langer^([1](#Aff2) [ ](#ContactOfAuthor2))(1)哥伦比亚大学技术管理中心，美国纽约州纽约市Arthur M. LangerEmail:
    [al261@columbia.edu](mailto:al261@columbia.edu)'
- en: 4.1 Client/Server and Object-Oriented Analysis
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1 客户端/服务器和面向对象分析
- en: Client/Server provides another level of sophistication in the implementation
    of systems. The concept of Client/Server is based on distributed processing, where
    programs and data are placed in the most efficient places. Client/server systems
    are typically installed on Local Area Networks (LANs) or Wide Area Networks (WANs).
    LANs can be defined as multiple computers linked together to share processing
    and data. WANs are linked LANs. For purposes of this book, we will restrict our
    discussion about Client/Server within the concepts of application development
    moving to cloud and mobile environments.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端/服务器在系统实现中提供了另一层次的复杂性。客户端/服务器的概念基于分布式处理，其中程序和数据放置在最有效的位置。客户端/服务器系统通常安装在局域网（LAN）或广域网（WAN）上。局域网可以定义为多台计算机连接在一起共享处理和数据。广域网是连接的局域网。在本书中，我们将把对客户端/服务器的讨论限制在应用程序开发概念转移到云和移动环境上。
- en: 'Before you can design effective Client/Server applications for mobility, the
    organization should commit to the object paradigm. Based on an OO implementation,
    Client/Server essentially requires one more step: the determination of what portions
    of an object or class should be moved to client only activities, server only activities,
    or both across vast mobile networks. Many existing client/server applications
    need to be expanded to operate in a much more distributed design and one that
    is not hierarchical.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在你能够为移动性设计有效的客户端/服务器应用程序之前，组织应该致力于对象范式。基于面向对象的实现，客户端/服务器基本上需要多一步：确定对象或类的哪些部分应该移动到仅在客户端活动、仅在服务器活动或跨广阔移动网络的两者都应该活动。许多现有的客户端/服务器应用程序需要扩展以在更分布式的设计中运行，而且这种设计不是分层的。
- en: 4.2 Definition of Client/Server Applications
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2 客户端/服务器应用程序的定义
- en: 'We have already stated that Client/Server is a form of distributed processing.
    Client/Server applications have three components: a client, a server and a network.
    Setting aside the implications of the network for a moment, let us understand
    what clients and servers do. Although Client/Server applications tend to be seen
    as either permanent client or permanent server programs, we will see that this
    is not true in the object paradigm.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经说过客户端/服务器是分布式处理的一种形式。客户端/服务器应用程序有三个组件：客户端、服务器和网络。暂且不谈网络的影响，让我们先了解一下客户端和服务器的作用。尽管客户端/服务器应用程序往往被视为永久客户端或永久服务器程序，但我们将看到在对象范式中这不是真的。
- en: A “server” is something that provides information to a requester. There are
    many Client/Server configurations that have permanent hardware servers. These
    hardware servers typically contain databases and application programs that provide
    services to requesting network computers (as well as other LANs). This configuration
    is called “back-end” processing. On the other hand, we have network computers
    that request the information from servers. We call these computers “clients” and
    categorize this type of processing as “front-end.” When we expand these definitions
    to applications only, we look at the behavior of an object or class and categorize
    it as client (requesting services), server (providing services), or both (providing
    and requesting services).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: “服务器”是为请求者提供信息的东西。有许多客户端/服务器配置具有永久硬件服务器。这些硬件服务器通常包含数据库和应用程序，为请求的网络计算机（以及其他局域网）提供服务。这种配置称为“后端”处理。另一方面，我们有从服务器请求信息的网络计算机。我们称这些计算机为“客户端”，并将这种类型的处理归类为“前端”。当我们将这些定义扩展到仅应用程序时，我们看一下对象或类的行为，并将其归类为客户端（请求服务）、服务器（提供服务）或两者（提供和请求服务）。
- en: Understanding how objects become either permanent servers or clients is fairly
    straightforward. For example, the Cars object in the Car Transmission Types class
    is categorized as a server. If this were the only use of cars, then it would be
    called a “dedicated” server object. On the same basis, the Cars object in the
    Transportation Vehicles class is categorized as a client object. In turn, if it
    were the only use of the object in a class, it would be defined as a “permanent”
    client. However; because it exists in more than one class and is polymorphic,
    the Cars object is really both a client and a server, depending on the placement
    and behavior of the object. Therefore, when we talk about an object’s Client/Server
    behavior we must first understand the “instance” it is in and the class it is
    operating within.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 理解对象如何成为永久服务器或客户端是相当简单的。例如，汽车对象在汽车传输类型类中被归类为服务器。如果这是汽车的唯一用途，那么它将被称为“专用”服务器对象。同样，交通工具类中的汽车对象被归类为客户端对象。反过来，如果它是类中对象的唯一用途，则将其定义为“永久”客户端。但是；由于它存在于多个类中并且是多态的，汽车对象实际上既是客户端又是服务器，具体取决于对象的位置和行为。因此，当我们谈论对象的客户端/服务器行为时，我们必须首先了解它所在的“实例”以及它所在的类。
- en: The difficulty in Client/Server is in the further separation of attributes and
    services for purposes of performance across a network. This means that the server
    services and attributes components of the Cars object might need to be separated
    from the client ones and permanently placed on a physical server machine.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端/服务器的困难在于为了在网络上实现性能而进一步分离属性和服务。这意味着汽车对象的服务器服务和属性组件可能需要与客户端的组件分开，并永久放置在物理服务器机器上。
- en: The client services and attributes will be then be stored on a different physical
    client machine(s). To put this point into perspective, an object may be further
    functionally decomposed based on processing categorization. Therefore, the analyst
    must be involved in the design of the network and must understand how the processing
    will be distributed across the network. Client/Server analysis should employ Rapid
    Application Development (RAD)^([1](#Fn1)) because both analysis and design are
    needed during the requirements phase of the system. Once the analyst understands
    the layout of the network, then further decomposition must be done to produce
    hybrid objects. These hybrid objects break out into dedicated server and object
    functions as shown below (Fig. [4.1](#Fig1)).![../images/480347_1_En_4_Chapter/480347_1_En_4_Fig1_HTML.png](../images/480347_1_En_4_Chapter/480347_1_En_4_Fig1_HTML.png)
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端的服务和属性将被存储在不同的物理客户端机器上。为了使这一点更加清晰，可以根据处理分类进一步对对象进行功能分解。因此，分析员必须参与网络设计，并了解处理将如何在网络上分布。客户端/服务器分析应该采用快速应用程序开发（RAD）^([1](#Fn1))，因为在系统需求阶段需要分析和设计。一旦分析员了解了网络的布局，那么必须进一步分解以产生混合对象。这些混合对象分解为专用服务器和对象功能，如下所示（图 [4.1](#Fig1)）。![../images/480347_1_En_4_Chapter/480347_1_En_4_Fig1_HTML.png](../images/480347_1_En_4_Chapter/480347_1_En_4_Fig1_HTML.png)
- en: Fig. 4.1
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1
- en: Decomposition of Client/Server objects to dedicated client and server objects
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 将客户端/服务器对象分解为专用客户端和服务器对象
- en: Moving to Client/Server is much easier if OO has been completed. Getting the
    analysis team involved in network design early in the process is much more difficult.
    The role of the analyst in Client/Server will continue to expand as the distribution
    of objects in these environments continues to grow and mature.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 移动到客户端/服务器更容易，如果OO已经完成。在过程的早期将分析团队纳入网络设计中要困难得多。分析员在客户端/服务器中的角色将随着这些环境中对象的分布不断增长和成熟而继续扩展。
- en: 4.3 Introduction to Databases
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3 数据库简介
- en: Chapter [3](480347_1_En_3_Chapter.xhtml) focused on application specifications
    as they relate to process. Using DFDs, PDFs, ERDs, etc., I showed how data elements
    are defined in the DD. However, the process of completing the DD and building
    complex relational databases has further steps. This chapter focuses on how to
    design databases for use with ecommerce Web applications. The completion of the
    DD and the creation of the database schematic, called the Entity Relational Diagram,
    provide developers with the data architecture component of the system. We call
    the process of creating this architecture Logic Data Modeling. The process of
    logic data modeling not only defines the architecture, it also provides the construct
    for the actual database, often called the physical database. The physical database
    differs from its logical counterpart in that it is subject to the rules and formats
    of the database product that will be used to implement the system. This means
    that if Oracle is used to implement the logical schema, the database must conform
    to the specific proprietary formats that Oracle requires. Thus, the logical model
    provides the first step in planning for the physical implementation. First, I
    will examine the process of building the appropriate schematic. Even if a packaged
    software product is selected, the chances are that it will need to use a database
    product like Oracle. Thus, many of the analysis and design below will be extremely
    important in determining the best fit for a package.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 第[3](480347_1_En_3_Chapter.xhtml)章集中讨论了与流程相关的应用规范。使用DFD、PDF、ERD等，我展示了数据元素在DD中的定义方式。然而，完成DD并构建复杂的关系数据库还有进一步的步骤。本章重点介绍了如何为电子商务Web应用程序设计数据库。完成DD和创建数据库概要图，称为实体关系图，为开发人员提供了系统的数据架构组件。我们称创建这种架构的过程为逻辑数据建模。逻辑数据建模的过程不仅定义了架构，还为实际数据库提供了构建，通常称为物理数据库。物理数据库与其逻辑对应物不同，因为它受到将用于实现系统的数据库产品的规则和格式的约束。这意味着，如果使用Oracle来实现逻辑模式，数据库必须符合Oracle所需的具体专有格式。因此，逻辑模型为规划物理实施提供了第一步。首先，我将审查构建适当概要的过程。即使选择了打包软件产品，也有可能需要使用像Oracle这样的数据库产品。因此，下面的许多分析和设计对于确定最适合包装的软件非常重要。
- en: 4.4 Logic Data Modeling
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.4 逻辑数据建模
- en: Logic Data Modeling (LDM) is a method that examines a particular data entity
    and determines what data elements need to be associated with it. There are a number
    of procedures, some mathematically based, to determine how and what the analyst
    needs to do. Therefore, LDM only focuses on the stored data with the intent to
    design what can be defined as the “engine” of the system. Often this “engine”
    is called the “backend.” The design of the engine must be independent from the
    process and must be based on the rules of data definition theory. Listed below
    are the eight suggested steps to build the database blueprint. This blueprint
    is typically called the schema, which is defined as a logical view of the database.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑数据建模（LDM）是一种方法，它审查特定的数据实体并确定需要与之关联的数据元素。有许多程序，一些是基于数学的，用于确定分析员需要如何以及需要做什么。因此，LDM只关注存储的数据，并意图设计可以定义为系统“引擎”的内容。通常这个“引擎”被称为“后端”。引擎的设计必须独立于流程，并且必须基于数据定义理论的规则。下面列出了构建数据库蓝图的八个建议步骤。该蓝图通常称为模式，定义为数据库的逻辑视图。
- en: '1.'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '1.'
- en: identify data entities
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确定数据实体
- en: '2.'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '2.'
- en: select primary and alternate keys
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 选择主键和备用键
- en: '3.'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '3.'
- en: determine key business rules
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确定关键业务规则
- en: '4.'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '4.'
- en: apply normalization to 3rd normal form
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将规范化应用到第三范式
- en: '5.'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '5.'
- en: combine user views
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 合并用户视图
- en: '6.'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '6.'
- en: integrate with existing data models (e.g., legacy interfaces)
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与现有数据模型集成（例如，遗留接口）
- en: '7.'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '7.'
- en: determine domains and triggering operations
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确定域和触发操作
- en: '8.'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '8.'
- en: de-normalize as appropriate.
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 根据需要进行反规范化。
- en: 'Prior to providing concrete examples, it is necessary to define the database
    terms used in this chapter. Below are the key concepts and definitions:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在提供具体示例之前，有必要定义本章中使用的数据库术语。以下是关键概念和定义：
- en: 'Entity: an object of interest about which data can be collected. Larson and
    Larson ([2000](#CR2)) define an entity as “a representation of a real-world person,
    event, or concept.” For example, in an ecommerce application, customers, products,
    and suppliers might be entities. The chapter will provide a method of determining
    entities from the DFD. An entity can have many data elements associated with it,
    called attributes.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实体：可以收集数据的感兴趣的对象。Larson和Larson ([2000](#CR2))定义实体为“对真实世界中的人、事件或概念的表示”。例如，在电子商务应用中，客户、产品和供应商可能是实体。本章将提供从DFD中确定实体的方法。一个实体可以与许多与之相关的数据元素关联，称为属性。
- en: 'Attribute: data elements are typically called attributes when they are associated
    with an entity. These attributes, or cells of an entity, belong to or “depend
    on” the entity.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性：当数据元素与实体相关联时，通常称为属性。这些属性或实体的单元格属于实体或“依赖于”实体。
- en: 'Key: a key is an attribute of an entity that uniquely identifies a row. A row
    is defined as a specific record in the database. Therefore, a key is an attribute
    that has a unique value that no other row or record can have. Typical key attributes
    are “Social Security Number,” “Order Number,” etc.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关键字：关键字是唯一标识行的实体属性。行被定义为数据库中的特定记录。因此，关键字是具有唯一值的属性，其他行或记录不能具有。典型的关键字属性包括“社会安全号码”，“订单号”等。
- en: 'Business Rule: this is a rule that is assumed to be true as defined by the
    business. Business rules govern the way keys and other processes behave within
    the database.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 业务规则：这是业务定义为真实的规则。业务规则指导数据库中的键和其他流程的行为。
- en: 'Normalization: a process that eliminates data redundancy and ensures data integrity
    in a database.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规范化：在数据库中消除数据冗余并确保数据完整性的过程。
- en: 'User View: the definition of the data from the perspective of the user. This
    means that how a data element is used, what is its business rules, and whether
    it is a key or not, depends largely on the user’s definition. It is important
    that analysts understand that data definitions are not universal.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户视图：从用户的角度定义数据。这意味着数据元素的使用方式，其业务规则，以及它是否是关键性的，很大程度上取决于用户的定义。分析人员理解数据定义不是普遍的是很重要的。
- en: 'Domains: this relates to a set of values or limits of occurrences within a
    data element or attribute of an entity. An example of a domain would be STATE,
    where there is a domain of 50 acceptable values (i.e., NY, NJ, CA, etc.).'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 领域：这与数据元素或实体属性中的值或发生次数限制相关。领域的一个示例是州，州具有50个可接受值的领域（即NY，NJ，CA等）。
- en: 'Triggers: these are stored procedures or programs that are activated or triggered
    as a result of an event at the database level. In other words, an event (insert,
    delete, update) may require that other elements or records be changed. This change
    would occur by having a program stored by the database product (such as Oracle)
    automatically execute and update the data.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 触发器：这些是作为数据库级别事件的结果而激活或触发的存储过程或程序。换句话说，一个事件（插入、删除、更新）可能需要改变其他元素或记录。通过在数据库产品（如Oracle）中存储的程序自动执行和更新数据来实现此更改。
- en: 'Cardinality: this concept defines the relationship between two entities. This
    relationship is constructed based on the number of occurrences or associations
    that one entity has with another. For example, one customer record could have
    many order records. In this example, both customer and orders are separate entities.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基数：这个概念定义了两个实体之间的关系。此关系是基于一个实体与另一个实体具有的发生次数或关联数目而构建的。例如，一个客户记录可能有许多订单记录。在这个例子中，客户和订单都是不同的实体。
- en: 'Legacy Systems: these are existing applications that are in operation. Legacy
    applications sometimes refer to older and less sophisticated applications that
    need to be interfaced with newer systems or replaced completely (see Chap. [10](480347_1_En_10_Chapter.xhtml)).'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传统系统：这些是正在运行的现有应用程序。传统应用有时指的是较老且不太复杂的应用程序，需要与更新的系统进行接口或完全替换（见第10章[10](480347_1_En_10_Chapter.xhtml)）。
- en: 'Entity Relational Diagram: a schematic of all the entities and their relationships
    using cardinal format. An entity relational diagram provides the blueprint of
    the data, or the diagram of the data engine.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实体关系图：使用基数格式的所有实体及其关系的图表。实体关系图提供了数据的蓝图，或者说是数据引擎的图表。
- en: 4.5 Logic Data Modeling Procedures
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.5逻辑数据建模流程
- en: The first step in LDM is to select the entities that will be used to start the
    normalization process. If DFDs have been completed in accordance with the procedures
    outlined in Chap. [3](480347_1_En_3_Chapter.xhtml), then all data stores that
    represent data files become transformed into data entities. This approach offers
    the major advantage of modeling process before data. If DFDs or some comparable
    process tool is not used, then analysts must rely on the information they can
    obtain from the legacy systems, such as existing data files, screens, and reports.
    The following example depicts how a data store from a DFD becomes an entity. The
    data contained in the data store called “Orders” is represented as an actual form
    containing many data elements (Fig. [4.2](#Fig2)). Thus, this example represents
    a physical form translated into an LE called a data store, which then is transformed
    again into an entity (Fig. [4.3](#Fig3)).![../images/480347_1_En_4_Chapter/480347_1_En_4_Fig2_HTML.png](../images/480347_1_En_4_Chapter/480347_1_En_4_Fig2_HTML.png)
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: LDM（逻辑数据模型）的第一步是选择将用于启动规范化过程的实体。如果DFD（数据流程图）按照第[3](480347_1_En_3_Chapter.xhtml)章概述的程序完成，那么代表数据文件的所有数据存储器都会被转换为数据实体。这种方法的主要优势是在处理数据之前对过程进行建模。如果没有使用DFD或某些类似的流程工具，分析师必须依靠他们可以从旧系统获取的信息，例如现有的数据文件、屏幕和报告。以下示例描述了如何将DFD中的数据存储器转换为实体。名为“订单”的数据存储器中包含的数据被表示为一个包含许多数据元素的实际表单（图[4.2](#Fig2)）。因此，这个示例代表了一个被转换为称为数据存储器的LE的物理形式，然后再次转换为一个实体（图[4.3](#Fig3)）。
- en: Fig. 4.2
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2
- en: Sample customer order form
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 样品客户订单表格
- en: '![../images/480347_1_En_4_Chapter/480347_1_En_4_Fig3_HTML.png](../images/480347_1_En_4_Chapter/480347_1_En_4_Fig3_HTML.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![../images/480347_1_En_4_Chapter/480347_1_En_4_Fig3_HTML.png](../images/480347_1_En_4_Chapter/480347_1_En_4_Fig3_HTML.png)'
- en: Fig. 4.3
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3
- en: Transition of the order data store into an Entity
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 订单数据存储器转换为实体
- en: 4.6 Key Attributes
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.6 关键属性
- en: 'The next step in LDM is to select the primary and alternate keys. A primary
    key is defined as an attribute that will be used to identify a record or occurrence
    in an entity. The primary key, like any key attribute contains a unique value.
    Often there is more than one attribute in an entity that contains unique values.
    We call an attribute that can be a primary key a candidate key attribute. This
    simply means that this attribute can serve in the role of the primary key. If
    there is only one candidate, then there is no issue: that candidate becomes the
    primary key. In the event that there is more than one candidate attribute, then
    one must be selected the primary key, and the others will be called alternate
    or secondary key attributes. These alternate key attributes provide benefit in
    the physical database only. This means that they can be used to identify records
    in the database as an alternative should the primary key not be known. Take the
    following example. Suppose that an employee entity has two candidate keys: Social-Security-Number
    and Employee-ID. Employee-ID is selected as the primary key, so Social-Security-Number
    becomes an alternate key. In the logical entity, Social-Security-Number is treated
    as any other non-key attribute; however, in the physical database, it can be used
    (or indexed) to find a record. This could occur when an employee calls to ask
    someone in Human Resources about accrued vacation time. The Human Resource staff
    would ask the employee for their Employee-ID. If the employee did not know his/her
    Employee-ID, the Human Resource staff could ask them for their Social Security
    Number, and use that information as an alternative way to locate that individual’s
    information. It is important to note that the search on the primary key will be
    substantially faster, because primary key searches use a method called direct
    access, as opposed to index methods, which are significantly slower. This raises
    the question: When there are multiple candidate-key attributes, which key attribute
    should be selected as the primary key? The answer is the attribute that will be
    used most often to find the record. This means that Employee-ID was selected the
    primary key attribute because the users determined that it was the field most
    often used to locate employee information. Therefore, ecommerce analysts must
    ensure that they ask users this question during the interview process. Figure [4.4](#Fig4)
    provides a graphic depiction of the employee entity showing Employee-ID as the
    primary key attribute and Social-Security-Number as a non-key attribute.![../images/480347_1_En_4_Chapter/480347_1_En_4_Fig4_HTML.png](../images/480347_1_En_4_Chapter/480347_1_En_4_Fig4_HTML.png)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在LDM中的下一步是选择主键和备用键。主键被定义为用于标识实体中记录或事件的属性。主键像任何键属性一样包含唯一值。通常一个实体中有多个包含唯一值的属性。我们称可以作为主键的属性为候选键属性。这意味着该属性可以担任主键的角色。如果只有一个候选键，则没有问题：该候选键就成为主键。如果存在多个候选键属性，则必须选择一个作为主键，其他的将被称为备用键属性或次要键属性。这些备用键属性仅在物理数据库中提供好处。这意味着它们可以用作数据库中记录的标识，作为主键未知时的替代方法。接下来举个例子。假设一个员工实体有两个候选键：社会安全号和员工ID。员工ID被选为主键，因此社会安全号成为备用键。在逻辑实体中，社会安全号被视为任何其他非键属性；然而，在物理数据库中，它可以被用于（或索引）查找记录。这可能发生在员工打电话询问人力资源部关于累计休假时间时。人力资源部工作人员会要求员工提供其员工ID。如果员工不知道自己的员工ID，人力资源部工作人员可以要求他们提供其社会安全号，并使用该信息作为替代方法来定位该个人的信息。需要注意的是，基于主键的搜索速度会大大加快，因为主键搜索使用一种称为直接访问的方法，而不是索引方法，后者明显较慢。这引出了一个问题：当存在多个候选键属性时，应选择哪个属性作为主键？答案是最常用于查找记录的属性。这意味着员工ID被选择为主键属性，因为用户确定它是最常用于查找员工信息的字段。因此，电子商务分析师必须确保他们在面试过程中问用户这个问题。图 [4.4](#Fig4)
    提供了一个员工实体的图形描述，显示员工ID为主键属性，社会安全号为非键属性。![../images/480347_1_En_4_Chapter/480347_1_En_4_Fig4_HTML.png](../images/480347_1_En_4_Chapter/480347_1_En_4_Fig4_HTML.png)
- en: Fig. 4.4
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4
- en: Primary key and alternate key attributes
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 主键和备用键属性
- en: There is another type of key attribute called Foreign keys. Foreign keys provide
    a way to link tables and create relationships between them. Since foreign keys
    are created during the process of Normalization, I will defer discussion about
    them to the section on Normalization in this chapter.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '-   还有一种称为外键的键属性。外键提供了一种链接表格并在它们之间创建关系的方法。由于外键是在规范化过程中创建的，我将推迟在本章中关于规范化的部分讨论它们。'
- en: 4.7 Normalization
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '-   4.7 规范化'
- en: While the next step in LDM is to determine key business rules, it is easier
    to explain the process of Normalization first. That is, Normalization occurs after
    Defining Key Business Rules in practice, but not when introducing the topic for
    educational purposes. Therefore, Key Business Rules will be discussed after Normalization.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '-   虽然 LDM 的下一步是确定关键业务规则，但先解释规范化的过程会更容易些。也就是说，在实践中，规范化发生在定义关键业务规则之后，但在教育目的下介绍该主题时不会发生。因此，在规范化之后将讨论关键业务规则。'
- en: Normalization, without question, is the most important aspect of LDM. As mentioned
    above, Normalization is defined as the elimination of redundancies in an entity
    and ensures data integrity. It is the latter point that is critical in understanding
    the value of Normalization in the design of ecommerce database systems. Understanding
    of the LDM process depends largely on understanding how to implement the Normalization
    process.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '-   毫无疑问，规范化是 LDM 中最重要的方面。如上所述，规范化被定义为在实体中消除冗余并确保数据完整性。正是后者在理解规范化在电子商务数据库系统设计中的价值时至关重要。对
    LDM 过程的理解在很大程度上取决于如何实现规范化过程。'
- en: Normalization is constructed in a number of “Normal Forms.” While there are
    five published Normal Forms, Normal Forms 4 and 5 are difficult to implement and
    most professionals avoid them. Therefore, this book omits Normal Forms 4 and 5\.
    The three Normal Forms of Normalization are listed below. Note that a Normal Form
    is notated as “NF.”
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '-   规范化是按照一定的“范式”构建的。虽然有五种已发布的范式，但范式 4 和 5 难以实现，大多数专业人士都会避开它们。因此，本书省略了范式 4
    和 5。规范化的三个范式列在下面。请注意，范式被表示为“NF”。'
- en: '1st NF: No repeating non-key attributes or group of non-key attributes.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '-   第一范式（1st NF）：没有重复的非键属性或非键属性组。'
- en: '2nd NF: No partial dependencies on a part of a concatenated key attribute.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '-   第二范式（2nd NF）：在连接键属性的一部分上没有部分依赖。'
- en: '3rd NF: No dependencies of a non-key attribute on another non-key attribute.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '-   第三范式（3rd NF）：非键属性之间没有依赖关系。'
- en: Each Normal Form is dependent on the one before it, that is, the process of
    completing Normalization is predicated on the sequential satisfaction of the Normal
    Form preceding it. Normalization can be best explained by providing a detailed
    example. Using the Order form provided in Fig. [4.1](#Fig1), we can start the
    process of Normalization. Figure [4.5](#Fig5) shows the Logical Equivalent of
    the Order form in entity format. In this example, the primary key is Order-Number
    (signified by the “PK” notation), which requires that every order have a unique
    Order-Number associated with it. It should also be noted that a repeating group
    made up of five attributes is shown in a separate box. This repeating group of
    attributes correlates to an area on the Order form, which often is referred to
    as an order line item. This means that each item associated with the order appears
    in its own group, namely the item identification, its name, unit price, quantity,
    and amount. The customer order in Fig. [4.1](#Fig1) shows two items associated
    with the Order-Number 12345.![../images/480347_1_En_4_Chapter/480347_1_En_4_Fig5_HTML.png](../images/480347_1_En_4_Chapter/480347_1_En_4_Fig5_HTML.png)
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '-   每个范式都依赖于前面的范式，也就是说，完成规范化的过程取决于满足前面的范式。规范化可以通过提供详细的示例来最好地解释。使用图 [4.1](#Fig1) 中提供的订单表格，我们可以开始规范化的过程。图 [4.5](#Fig5) 显示了订单表的逻辑等价实体格式。在此示例中，主键是订单号（由“PK”标记表示），这要求每个订单都与唯一的订单号相关联。还应注意，由五个属性组成的重复组显示在单独的框中。这个属性的重复组对应于订单表上的一个区域，通常称为订单行项目。这意味着与订单相关的每个项目都显示在其自己的组中，即项目标识、名称、单价、数量和金额。图 [4.1](#Fig1) 中的客户订单显示与订单号
    12345 相关联的两个项目。![../images/480347_1_En_4_Chapter/480347_1_En_4_Fig5_HTML.png](../images/480347_1_En_4_Chapter/480347_1_En_4_Fig5_HTML.png)'
- en: Fig. 4.5
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '-   图 4.5'
- en: Orders entity and its associated attributes
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '-   订单实体及其相关属性'
- en: 'The process of determining compliance with Normalization is to evaluate whether
    each normal form or NF has been satisfied. This can be accomplished by testing
    each NF in turn. Thus, the first question to ask is: Are we in 1st NF? The answer
    is no because of the existence of the repeating attributes: Item-ID, Item-Name,
    Quantity, Unit-Price, and Amount, or as specified above an “order line item.”
    In showing this box, the example exposes the repeating group of items that can
    be associated with a customer order. Another way of looking at this phenomenon
    is to see that within the Order, there really is another entity, which has its
    own key identification. Since there is a repeating group of attributes, there
    is a 1st NF failure. Anytime an NF fails or is violated, it results in the creation
    of another entity. Whenever there is a 1st NF failure, the new entity will always
    have as its primary key a concatenated “group” of attributes. This concatenation,
    or joining of multiple attributes to form a specific value, is composed of the
    primary key from the original entity (Orders) attached with a new key attribute
    from the repeating group of elements. The new key must be an attribute that controls
    the other group of attributes. In this example, the controlling attribute is Item-ID.
    After the new “key attribute” is determined, it is concatenated with the original
    key attribute from the Orders entity. The remaining non-key attributes will be
    removed from the original entity to become non-key attributes of the new entity.
    This new entity is shown in Fig. [4.6](#Fig6).![../images/480347_1_En_4_Chapter/480347_1_En_4_Fig6_HTML.png](../images/480347_1_En_4_Chapter/480347_1_En_4_Fig6_HTML.png)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 确定规范化遵从性的过程是评估是否满足了每个正规形式或 NF。这可以通过逐个测试每个 NF 来完成。因此，第一个要问的问题是：我们是否处于第一范式？答案是否定的，因为存在重复属性：Item-ID、Item-Name、Quantity、Unit-Price
    和 Amount，或者如上所述一个“订单行项目”。在显示此框时，示例暴露了可以与客户订单相关联的项目重复组。观察这种现象的另一种方式是看到在订单内，实际上确实存在另一个实体，该实体具有自己的关键识别。由于存在一组重复的属性，因此存在第一范式失败。每当一个
    NF 失败或违反时，都会导致创建另一个实体。每当第一范式失败时，新实体将始终以连接的“组”属性作为其主键。这种连接，或者将多个属性连接成一个特定值，由原始实体（订单）的主键与重复元素组的新键属性相连接。新键必须是控制其他属性组的属性。在本例中，控制属性是
    Item-ID。确定新的“键属性”后，将其与订单实体的原始键属性连接起来。其余的非键属性将从原始实体中移除，成为新实体的非键属性。这个新实体显示在图 [4.6](#Fig6)
    中。![../images/480347_1_En_4_Chapter/480347_1_En_4_Fig6_HTML.png](../images/480347_1_En_4_Chapter/480347_1_En_4_Fig6_HTML.png)
- en: Fig. 4.6
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6
- en: Orders in 1st NF
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 第一范式的订单
- en: The new entity, called Order Items, has a primary key that reflects the concatenation
    of the original key Order-Number from the entity Orders, combined with Item-ID,
    which represents the controlling attribute for the repeating group. All of the
    other repeating attributes have now been transferred to the new entity. The new
    entity Order Items allows the system to store multiple order line items as required.
    The original entity left without this modification would have limited the number
    of occurrences of items artificially. For example, if the analyst/designer had
    defaulted to five groups of order line items, the database would always have five
    occurrences of the five attributes. If most orders, in reality, had fewer than
    five items, then significant space would be wasted. More significant is the case
    where the order has more than five items. In this case, a user would need to split
    the order into two physical orders so that the extra items could be captured.
    These two issues are the salient benefits of attaining entities in their 1st NF.
    Therefore, leaving the entity Order as is would in effect create an integrity
    problem.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 新实体称为订单项，其主键反映了来自实体订单的原始键 Order-Number 与代表重复组的控制属性 Item-ID 的连接。所有其他重复属性现在都已转移到了新实体。新实体订单项允许系统根据需要存储多个订单行项目。未经此修改的原始实体将限制项目的出现次数。例如，如果分析/设计人员默认为五组订单行项目，则数据库将始终具有五个属性的五次发生。如果大多数订单实际上都少于五个项目，则会浪费大量空间。更重要的是订单有超过五个项目的情况。在这种情况下，用户需要将订单拆分为两个物理订单，以便捕获额外的项目。实现第一范式的实体的这两个问题是显著的优点。因此，保持订单实体不变实际上会创建一种完整性问题。
- en: Once the changes to the entity Orders has been completed, and the new entity
    Order Item has been completed, the system is said to be a database in 1st NF.
    It is important to note that the new primary key of the entity Order Items is
    the combination of two attributes. While the two attributes maintain their independence
    as separate fields of data, they are utilized as one combined value for purposes
    of their role as a key attribute. For example, based on the data in the Order
    form from Fig. [4.1](#Fig1), the entity Order Items would have two records. The
    first record would have the primary key of 1234531, which would be the concatenation
    of Order-Number (12345) with Item-ID (31). The second record would be 1234527,
    which is the same Order-Number, but concatenated with the second Item-ID (27).
    From an SQL feature perspective, while the key attribute concatenates each attribute
    into one address, it can be searched as separate fields. So, a user could search
    for all the items associated with Order 12345, by simply searching on Order Items
    that contain an Order-Number = “12345.” This exemplifies the power of versatility
    in the relational model. Once 1st NF has been reached, the next test must ensue,
    that is, testing for compliance with 2nd NF.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 完成了对实体“订单（Orders）”的更改，以及新实体“订单项（Order Item）”的完成后，系统被称为处于第一范式数据库。需要注意的是，实体“订单项”的新主键是两个属性的组合。虽然这两个属性保持独立作为数据的单独字段，但在作为关键属性的角色时，它们被用作一个组合值。例如，根据图 [4.1](#Fig1) 中订单表中的数据，实体“订单项”将有两条记录。第一条记录将具有主键为1234531，这是订单编号（12345）与商品编号（31）的连接。第二条记录将是1234527，这是相同的订单编号，但与第二个商品编号（27）连接。从
    SQL 功能的角度来看，虽然关键属性将每个属性连接成一个地址，但它可以作为单独的字段进行搜索。因此，用户只需搜索包含订单编号为“12345”的订单项即可搜索与订单12345关联的所有商品。这展示了关系模型的灵活性。一旦达到第一范式，就必须进行下一个测试，即测试是否符合第二范式。
- en: Second NF testing applies only to entities that have concatenated keys. Therefore,
    any entity that is in 1st NF and does not have a concatenated primary key must
    already be in 2nd NF. In our example, then, the entity “Orders” is already in
    2nd NF because it is in 1st NF and does not have a concatenated primary key. The
    entity Order Items, however, is in a different category. Order Items has a concatenated
    primary key attribute and must be tested for compliance with 2nd NF. Second NF
    requires the analyst to ensure that every non-key attribute in the entity is totally
    dependent on all components of the primary key, or all of its concatenated attributes.
    When we apply the test, we find that the attribute “Item-Name” is dependent only
    on the key attribute “Item-ID.” That is, the Order-Number has no effect or control
    over the name of the item. This condition is considered a 2nd NF failure. Once
    again, a new entity must be created. The primary key of the new entity is the
    portion of the concatenated key that controlled the attribute that caused the
    failure. In other words, Item-ID is the primary key of the new entity, because
    “Item-Name” was wholly dependent on the attribute “Item-ID.” It is worthwhile
    at this time to explain further the concept of attribute dependency. For one attribute
    to be dependent on another infers that the controlling attribute’s value can change
    the value of the dependent attribute. Another way of explaining this is to say
    that the controlling attribute, which must be a key, controls the record. That
    is, if the Item-ID changes, then we are looking at a different Item Name, because
    we are looking at a different Item record.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 第二范式测试仅适用于具有连接键的实体。因此，任何处于第一范式且没有连接主键的实体必须已经处于第二范式。在我们的示例中，“订单（Orders）”实体已经处于第二范式，因为它处于第一范式且没有连接主键。然而，“订单项（Order
    Items）”实体属于另一类。订单项具有连接的主键属性，必须测试是否符合第二范式。第二范式要求分析人员确保实体中的每个非键属性完全依赖于主键的所有组成部分，或所有的连接属性。当我们应用测试时，我们发现属性“商品名称（Item-Name）”仅依赖于关键属性“商品编号（Item-ID）”。也就是说，订单编号对商品名称没有影响或控制。这种情况被视为第二范式失败。必须再次创建一个新实体。新实体的主键是导致失败的属性的连接键的一部分。换句话说，商品编号是新实体的主键，因为“商品名称”完全依赖于属性“商品编号”。现在值得进一步解释属性依赖的概念。一个属性对另一个属性的依赖意味着控制属性的值可以更改依赖属性的值。另一种解释这一点的方法是说，必须是一个键的控制属性控制记录。也就是说，如果商品编号发生变化，则我们正在查看不同的商品名称，因为我们正在查看不同的商品记录。
- en: To complete the creation of the new entity, Items, each non-key attribute in
    the original entity Order Items must be tested for 2nd NF violation. Note that
    as a result of this testing, “Quantity” and “Amount” stay in the Order Items entity
    because they are dependent on both Order-Number and Item-ID. That is, the quantity
    associated with any given Order Items occurrence is dependent not only on the
    Item itself, but also the particular order it is associated with. We call this
    being wholly dependent on the concatenated primary key attribute. Thus, the movement
    of non-key attributes is predicated on the testing of each non-key attribute against
    the concatenated primary key. The result of this test establishes the three entities
    shown in Fig. [4.7](#Fig7).![../images/480347_1_En_4_Chapter/480347_1_En_4_Fig7_HTML.png](../images/480347_1_En_4_Chapter/480347_1_En_4_Fig7_HTML.png)
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成新实体Items的创建，必须对原始实体Order Items中的每个非关键属性进行第二范式违规测试。请注意，作为此测试的结果，“Quantity”和“Amount”留在Order
    Items实体中，因为它们依赖于Order-Number和Item-ID。也就是说，与任何给定的Order Items出现相关联的数量不仅依赖于物品本身，还依赖于与其相关联的特定订单。我们称之为完全依赖于连接的主键属性。因此，非关键属性的移动是基于对每个非关键属性与连接的主键的测试。此测试的结果确定了图 [4.7](#Fig7)
    中显示的三个实体！[../images/480347_1_En_4_Chapter/480347_1_En_4_Fig7_HTML.png](../images/480347_1_En_4_Chapter/480347_1_En_4_Fig7_HTML.png)
- en: Fig. 4.7
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.7
- en: Orders in 2nd NF
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 订单在第二范式中
- en: The results of implementing 2nd NF reflect that without it, a new Item (or Item-ID)
    could not have been added to the database without an order. This obviously would
    have caused major problems. Indeed, the addition of a new Item would have to precede
    the creation of that Item with a new Order. Therefore, the new entity represents
    the creation of a separate Item master file as shown in Fig. [4.7](#Fig7).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 实施第二范式的结果表明，如果没有它，无法在没有订单的情况下向数据库中添加新的Item（或Item-ID）。这显然会造成重大问题。确实，必须在创建具有新订单的Item之前添加新Item。因此，新实体表示创建一个单独的Item主文件，如图 [4.7](#Fig7)
    所示。
- en: Figure [4.7](#Fig7) represents Orders in 2nd NF. Once again, we must apply the
    next test-3rd NF to complete Normalization. Third NF tests the relationship between
    two non-key attributes to ensure that there are no dependencies between them.
    Indeed, if this dependency were to exist, it would mean that one of the non-key
    attributes would, in effect, be a key attribute. Should this occur, the controlling
    non-key attribute would become the primary key of the new entity. Testing this
    against the sample entity reflects that Customer-Name and Customer-Address^([2](#Fn2))
    are dependent on Customer-ID. Therefore, the entity Orders fails 3rd NF and a
    new entity must be created. The primary key of the new entity is the non-key attribute
    that controlled the other non-key attributes; in this case Customer-ID. The new
    entity is called Customers, and all of the non-key attributes that depend on Customer-ID
    are moved to that entity as shown in Fig. [4.8](#Fig8).![../images/480347_1_En_4_Chapter/480347_1_En_4_Fig8_HTML.png](../images/480347_1_En_4_Chapter/480347_1_En_4_Fig8_HTML.png)
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 [4.7](#Fig7) 表示第二范式的订单。我们必须再次应用下一个测试-第三范式以完成规范化。第三范式测试两个非关键属性之间的关系，以确保它们之间没有依赖关系。确实，如果存在这种依赖关系，这意味着其中一个非关键属性实际上是一个关键属性。如果发生这种情况，控制非关键属性将成为新实体的主键。针对示例实体的测试反映出Customer-Name和Customer-Address^([2](#Fn2))
    依赖于Customer-ID。因此，实体Orders不符合第三范式，必须创建一个新实体。新实体的主键是控制其他非关键属性的非关键属性；在这种情况下是Customer-ID。新实体称为Customers，并将所有依赖于Customer-ID的非关键属性移动到该实体中，如图 [4.8](#Fig8)
    所示！[../images/480347_1_En_4_Chapter/480347_1_En_4_Fig8_HTML.png](../images/480347_1_En_4_Chapter/480347_1_En_4_Fig8_HTML.png)
- en: Fig. 4.8
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.8
- en: Orders in preliminary 3rd NF
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 订单在初步的第三范式中
- en: 'What is unique about 3rd NF failures is that the new key attribute remains
    as a non-key attribute in the original entity (in this case: Orders). The copy
    of the non-key attribute Customer-ID is called a foreign key and is created to
    allow the Order entity and the new Customer entity to have a relationship. A relationship
    between two entities can exist only if there is at least one common keyed attribute
    between them. Understanding this concept is crucial to what Normalization is intended
    to accomplish. Looking at Fig. [4.8](#Fig8), one can see that the entity Order
    and Order Items have a relationship because both entities have a common keyed
    attribute: Order-ID. The same is true in the creation of the Item entity, which
    resulted from a 2nd NF failure. The relationship here is between the Order Item
    entity and the Item entity, where both entities contain the common key attribute
    Item-ID. Both of these relationships resulted from the propagation of a key attribute
    from the original entity to the newly formed entity during the normalization process.
    By propagation, we mean that a pointer, or copy of the key attribute is placed
    in the new entity. Propagation is implemented using foreign keys and is a natural
    result of the process. Note that the “PK” is followed by an “FK” signifying that
    the keyed attribute is the result of a propagation of the original key attribute.
    Such is not the case in 3rd NF. If Customer-ID were to be removed from the Orders
    entity, then the relationship between Orders and Customers would not exist because
    there would be no common keyed attribute between the two entities. Therefore,
    in 3rd NF, it is necessary to force the relationship because a natural propagation
    has not occurred. This is accomplished by creating a pointer from a non-keyed
    attribute to the primary keyed copy, in this case Customer-ID. The concept of
    a pointer is important. Foreign key structures are typically implemented internally
    in physical databases using indexes. Indexes, or indirect addresses, are a way
    of maintaining database integrity by ensuring that only one copy of an attribute
    value is stored. If two copies of Customer-ID were stored, changing one of them
    could create an integrity problem between Orders and Customers. The solution is
    to have the Customer-ID in Orders “point” indirectly to the Customer-ID key attribute
    in the Customer entity. This ensures that a Customer-ID cannot be added to the
    Orders entity that does not exist in the Customer master entity.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 第三范式失败的独特之处在于新的关键属性仍然作为原始实体（在本例中为：订单）中的非关键属性。非关键属性Customer-ID的副本被称为外键，并且被创建以允许订单实体和新的客户实体建立关系。两个实体之间的关系只有在它们之间至少有一个公共的键属性时才能存在。理解这个概念对于归一化的目的至关重要。观察图[4.8](#Fig8)，可以看到实体订单和订单项目之间存在关系，因为这两个实体都有一个共同的键属性：Order-ID。在创建物品实体时也是如此，这是由于第二范式失败而产生的。这里的关系是订单项目实体和物品实体之间的，这两个实体都包含共同的关键属性Item-ID。这些关系都是在归一化过程中从原始实体传播关键属性而产生的。通过传播，我们指的是将指针或关键属性的副本放置在新实体中。传播是使用外键实现的，并且是该过程的自然结果。注意，“PK”后面跟着一个“FK”，表示键属性是原始键属性的传播结果。在第三范式中不是这种情况。如果从订单实体中删除Customer-ID，则订单和客户之间的关系将不存在，因为两个实体之间没有共同的键属性。因此，在第三范式中，需要强制建立关系，因为自然的传播并未发生。这通过从非键属性到主键副本（在本例中为Customer-ID）创建一个指针来实现。指针的概念很重要。外键结构通常在物理数据库中使用索引内部实现。索引或间接地址是通过确保仅存储一个属性值的副本来维护数据库完整性的一种方式。如果存储了两份Customer-ID副本，则更改其中一份可能会在订单和客户之间创建完整性问题。解决方案是使订单中的Customer-ID间接“指向”客户实体中的Customer-ID键属性。这确保了不能向订单实体添加不存在于客户主实体中的Customer-ID。
- en: 'The question now is whether the entities are in 3rd NF. Upon further review,
    we see the answer is no! Although it is not intuitively obvious, there are three
    non-key attributes that are dependent on other non-key attributes. This occurs
    first in the Order Items entity. The non-key attribute “Amount” is dependent on
    the non-key attribute “Quantity.” Amount represents the total calculated for each
    item in the order. It is not only dependent on “Quantity,” but also dependent
    on “Unit-Price.” This occurs frequently in attributes that are calculations. Such
    attributes are called derived elements, and are eliminated from the database.
    Indeed, if we store Quantity and Unit-Price, “Amount” can be calculated separately
    as opposed to being stored as a separate attribute. Storing the calculation would
    also cause integrity problems. For example, what would happen if the quantity
    or unit price would change? The database would have to recalculate the change
    and update the Amount attribute. While this can be accomplished, and will be discussed
    later in this chapter, it can be problematic to maintain in the database and cause
    performance problems in production ecommerce systems. The Orders entity also contains
    two derived attributes: Subtotal and Total-Due. Again, both of these attributes
    are removed. The issue is whether the removal of derived attributes should be
    seen as a 3rd NF failure. Date ([2000](#CR1)) views these failures as outside
    of 3rd NF, but in my view, they represent indirect dependencies on other non-key
    attributes and should be included as part of the 3rd NF test. In any case, we
    all agree that derived elements should be removed in the process of LDM. The 3rd
    NF LDM is modified to reflect the removal of these three attributes as shown in
    Fig. [4.9](#Fig9).![../images/480347_1_En_4_Chapter/480347_1_En_4_Fig9_HTML.png](../images/480347_1_En_4_Chapter/480347_1_En_4_Fig9_HTML.png)'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的问题是实体是否处于第三范式。经过进一步审查，我们发现答案是否定的！虽然这并不直观，但有三个非键属性依赖于其他非键属性。这首先发生在订单项实体中。非键属性“Amount”依赖于非键属性“Quantity”。Amount
    表示订单中每个商品的总计。它不仅依赖于“Quantity”，还依赖于“Unit-Price”。这在计算属性中经常发生。此类属性称为派生元素，并且从数据库中删除。实际上，如果我们存储
    Quantity 和 Unit-Price，“Amount”可以单独计算，而不是作为单独的属性存储。存储计算还会导致完整性问题。例如，如果数量或单价更改会发生什么？数据库必须重新计算更改并更新
    Amount 属性。虽然这是可以完成的，并且将在本章后面讨论，但在数据库中维护起来可能会出现问题，并导致生产电子商务系统的性能问题。订单实体还包含两个派生属性：Subtotal
    和 Total-Due。同样，这两个属性都被移除了。问题在于是否应将派生属性的移除视为第三范式的失败。Date ([2000](#CR1)) 将这些失败视为第三范式之外的情况，但在我看来，它们代表了对其他非键属性的间接依赖，并应作为第三范式测试的一部分包括在内。无论如何，我们都同意在
    LDM 过程中应删除派生元素。第三范式 LDM 被修改以反映删除这三个属性，如图 [4.9](#Fig9)所示。![../images/480347_1_En_4_Chapter/480347_1_En_4_Fig9_HTML.png](../images/480347_1_En_4_Chapter/480347_1_En_4_Fig9_HTML.png)
- en: Fig. 4.9
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.9
- en: Orders in second phase of 3rd NF
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 第三范式第二阶段的订单
- en: Once 3rd NF is reached the analyst should create the Entity Relational Diagram
    (ERD), which will show the relationships or connections among the entities. The
    relationship between entities is established through associations. Associations
    define the cardinality of the relationship using what is known as the Crow’s Foot
    Method as shown in Fig. [4.10](#Fig10).![../images/480347_1_En_4_Chapter/480347_1_En_4_Fig10_HTML.png](../images/480347_1_En_4_Chapter/480347_1_En_4_Fig10_HTML.png)
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦达到第三范式，分析员应创建实体关系图（ERD），其中将显示实体之间的关系或连接。实体之间的关系通过关联建立。关联使用所谓的 Crow's Foot
    方法定义关系的基数，如图 [4.10](#Fig10)所示。![../images/480347_1_En_4_Chapter/480347_1_En_4_Fig10_HTML.png](../images/480347_1_En_4_Chapter/480347_1_En_4_Fig10_HTML.png)
- en: Fig. 4.10
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.10
- en: The entities in ERD format using crow’s Feet
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Crow's Feet 格式的 ERD 实体
- en: 'The Crow’s Foot Method is only one of many formats. The method contains three
    key symbols:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Crow's Foot 方法只是众多格式之一。该方法包含三个关键符号：
- en: '![../images/480347_1_En_4_Chapter/480347_1_En_4_Figa_HTML.png](../images/480347_1_En_4_Chapter/480347_1_En_4_Figa_HTML.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![../images/480347_1_En_4_Chapter/480347_1_En_4_Figa_HTML.png](../images/480347_1_En_4_Chapter/480347_1_En_4_Figa_HTML.png)'
- en: denotes the cardinality of many occurrences
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 表示许多出现的基数
- en: '![../images/480347_1_En_4_Chapter/480347_1_En_4_Figb_HTML.png](../images/480347_1_En_4_Chapter/480347_1_En_4_Figb_HTML.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![../images/480347_1_En_4_Chapter/480347_1_En_4_Figb_HTML.png](../images/480347_1_En_4_Chapter/480347_1_En_4_Figb_HTML.png)'
- en: denotes zero occurrences
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 表示零次出现
- en: '![../images/480347_1_En_4_Chapter/480347_1_En_4_Figc_HTML.png](../images/480347_1_En_4_Chapter/480347_1_En_4_Figc_HTML.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![../images/480347_1_En_4_Chapter/480347_1_En_4_Figc_HTML.png](../images/480347_1_En_4_Chapter/480347_1_En_4_Figc_HTML.png)'
- en: denotes one occurrence.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 表示一个发生。
- en: 'Therefore, the ERD in Fig. [4.10](#Fig10) depicts the relationships of all
    the entities as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，图 [4.10](#Fig10) 中的 ERD 描述了所有实体之间的关系如下：
- en: '1.'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '1.'
- en: One, and only one (signified by the double lines) Order record can have one
    to many Order Item records. It also shows that any Order in the Order Items entity
    must exist in the Order entity.
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个且仅一个（由双线表示）订单记录可以拥有一到多个订单项目记录。它还显示了订单项目实体中的任何订单必须存在于订单实体中。
- en: '2.'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '2.'
- en: One and only one Item record can have zero to many Order Item records. The difference
    in this relationship and the one established between Orders and Order Items is
    that Items may not have a relationship with Order items, signified by the zero
    in the Crow’s Foot. This would often occur when there is a new item that has not
    yet received any orders.
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个且仅一个物品记录可以拥有零个到多个订单项目记录。这种关系与订单和订单项目之间建立的关系的区别在于，物品可能与订单项目没有关系，由 Crow's Foot
    中的零表示。当存在一个尚未接收任何订单的新物品时，这种情况通常会发生。
- en: '3.'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '3.'
- en: 'The Order Items entity has a primary key, which is a concatenation of two other
    primary keys: Order-ID from the Orders entity, and Item-ID from the Items entity.
    This type of relationship is said to be an “associative” relationship because
    the entity has been created as a result of a relational problem. This relational
    problem exists because the Order entity has a “many-to-many” relationship with
    the Items entity. Thus the 1st NF failure, which created the associative entity
    Order Items, is really the result of a “many-to-many” situation. A many-to-many
    relationship violates Normalization because it causes significant problems with
    SQL coding. Therefore, whenever a many-to-many relationship occurs between two
    entities, an associative entity is created which will have as its primary key
    the concatenation of the two primary keys from each entity. Thus, associative
    entities make many-to-many relationships into two one-to-many relationships so
    that SQL can work properly during search routines. Associative entities are usually
    represented with a diamond box.'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Order Items 实体具有一个主键，该主键是来自订单实体的 Order-ID 和来自物品实体的 Item-ID 两个主键的连接。这种关系被称为“联合”关系，因为该实体是作为一个关系问题的结果而创建的。这种关系问题的存在是因为订单实体与物品实体之间存在“多对多”的关系。因此，创建联合实体
    Order Items 的第一范式失败实际上是“多对多”情况的结果。多对多关系违反了规范化，因为它会导致 SQL 编码中的重大问题。因此，每当两个实体之间存在多对多关系时，都会创建一个联合实体，其主键将是每个实体的两个主键的连接。因此，联合实体将多对多关系转换为两个一对多关系，以便
    SQL 在搜索过程中能够正常工作。联合实体通常用钻石框表示。
- en: '4.'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '4.'
- en: One and only one Customer can have zero-to-many Orders, also showing that a
    Customer may exist who has never placed an order. As an example, this would be
    critical if the business were credit cards, where consumers can obtain a credit
    card even though they have not made a purchase. Note that the Customer-ID is linked
    with Orders through the use of a non-key foreign key attribute.
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个且仅一个客户可以拥有零个到多个订单，还显示了可能存在从未下过订单的客户。例如，如果业务是信用卡，消费者可以获得信用卡，即使他们没有进行购买。请注意，通过非关键外键属性将
    Customer-ID 与订单相关联。
- en: 4.8 Limitations of Normalization
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.8 规范化的限制
- en: 'Although 3rd NF has been attained, there is a major problem with the model.
    The problem relates to the attribute Unit-Price in the Items entity. Should the
    Unit-Price of any Item change, then the calculation of historical Order Item purchases
    would be incorrect. Remember that the attribute “Amount” was eliminated because
    it was a derived element. This might suggest that Normalization does not work
    properly! Such is not the case. First, we need to evaluate whether putting “Amount”
    back in the ERD would solve the problem. If the Unit-Price were to change, then
    Amount would need to be recalculated before it was done. While this might seem
    reasonable, it really does not offer a solution to the problem, just a way around
    it. The actual problem has little to do with the attribute “Amount”, but more
    to do with a missing attribute. The missing attribute is Order-Item-Unit-Price,
    which would represent the price at the time of the order. Order-Item-Unit-Price
    is dependent on both the Order and the Item and therefore would become a non-key
    attribute in the Order Items entity (i.e., it is wholly dependent on the entire
    concatenated primary key). The only relationship between Unit-Price and Order-Item-Unit-Price
    is at the time the order is entered into the system. In this situation, an application
    program would move the value or amount of the Unit-Price attribute into the Order-Item-Unit-Price
    attribute. Thereafter, there is no relationship between the two attributes. Because
    this is a new data element that has been discovered during Normalization, it must
    be entered into the Data Dictionary. Thus, a limitation of Normalization is that
    it cannot normalize what it does not have; it can normalize only the attributes
    that are presented to the formula. However, the limitation of Normalization is
    also an advantage: the process can help the analyst recognize that a data element
    is missing. Therefore, Normalization is a “data-based” tool that the analyst can
    use to reach the Logical Equivalent. Figure [4.11](#Fig11) shows the final ERD
    with the addition of Order-Item-Unit-Price.![../images/480347_1_En_4_Chapter/480347_1_En_4_Fig11_HTML.png](../images/480347_1_En_4_Chapter/480347_1_En_4_Fig11_HTML.png)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管已经达到了第三范式，但是模型存在一个主要问题。问题涉及到Items实体中的Unit-Price属性。如果任何Item的Unit-Price发生变化，那么历史订单项目购买的计算将不正确。请记住，“Amount”属性已被消除，因为它是一个派生元素。这可能表明规范化工作不正常！但事实并非如此。首先，我们需要评估将“Amount”放回ERD是否会解决问题。如果Unit-Price发生变化，那么Amount在计算之前需要重新计算。虽然这可能看起来合理，但实际上并没有提供解决问题的方法，只是绕过了问题。实际的问题与“Amount”属性关系不大，但与一个缺失的属性有更多关系。缺失的属性是Order-Item-Unit-Price，它将代表订单时的价格。Order-Item-Unit-Price取决于订单和项目，因此会成为订单项目实体的非键属性（即，它完全依赖于整个串联主键）。Unit-Price和Order-Item-Unit-Price之间的唯一关系是在订单输入系统时。在这种情况下，应用程序将Unit-Price属性的值或金额移动到Order-Item-Unit-Price属性中。此后，这两个属性之间没有关系。因为这是在规范化过程中发现的新数据元素，所以必须将其输入到数据字典中。因此，规范化的一个限制是它不能规范化它没有的内容；它只能规范化被呈现给公式的属性。但是，规范化的限制也是一个优势：该过程可以帮助分析人员意识到缺少一个数据元素。因此，规范化是分析人员可以使用的“基于数据”的工具，以达到逻辑等价。图[4.11](#Fig11)显示了添加了Order-Item-Unit-Price的最终ERD。![../images/480347_1_En_4_Chapter/480347_1_En_4_Fig11_HTML.png](../images/480347_1_En_4_Chapter/480347_1_En_4_Fig11_HTML.png)
- en: Fig. 4.11
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.11
- en: Final ERD with Order-Item-Unit-Price
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的ERD包含了Order-Item-Unit-Price。
- en: 4.9 The Supertype/Subtype Model
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.9 超类型/子类型模型
- en: A troublesome database issue occurs in the LDM when there are records within
    an entity that can take on different characteristics or have many “types” of attributes.
    “Type” means that a portion of the attributes in a specific record can vary depending
    on the characteristic or identification of the row within that entity. Another
    way of defining type is to describe it as a group of attributes within a given
    record that are different from other records of the same entity depending on the
    type of record it represents. This type is referred to as a “subtype” of the record.
    A subtype, therefore, is the portion of the record that deviates from the standard
    or “supertype” part of the record. The “supertype” portion is always the same
    among all the records in the entity. In other words, the “supertype” represents
    the global part of the attributes in an entity. The diagram below in Fig. [4.12](#Fig12)
    depicts the supertype/subtype relationship.![../images/480347_1_En_4_Chapter/480347_1_En_4_Fig12_HTML.png](../images/480347_1_En_4_Chapter/480347_1_En_4_Fig12_HTML.png)
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在 LDM 中出现了一个麻烦的数据库问题，当实体内有记录可以具有不同特性或具有许多“类型”属性时。 “类型”意味着特定记录中的一部分属性可能会根据该实体内的行的特性或标识而变化。定义类型的另一种方式是将其描述为给定记录中的一组属性，这些属性根据其表示的记录类型而不同于同一实体的其他记录。这种类型被称为记录的“子类型”。因此，子类型是记录中偏离标准或“超类型”部分的部分。
    “超类型”部分在实体的所有记录中始终相同。换句话说，“超类型”代表实体中属性的全局部分。下图[4.12](#Fig12)中的图示了超类型/子类型关系。![../images/480347_1_En_4_Chapter/480347_1_En_4_Fig12_HTML.png](../images/480347_1_En_4_Chapter/480347_1_En_4_Fig12_HTML.png)
- en: Fig. 4.12
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.12
- en: Supertype/subtype relationship
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 超类型/子类型关系
- en: The difference between a subtype and an ordinary type identifier (using a foreign
    key) is the occurrence of at least one non-key attribute that exists only in that
    subtype record. The major reason to create a supertype/subtype relationship is
    the occurrence of multiple permutations of these unique attributes that exist
    in just certain subtype records. Limiting these permutations of attributes within
    one record format can be problematic. First, it can waste storage, especially
    if each subtype has significant numbers of unique attributes. Second, it can create
    significant performance problems particularly with the querying of data. Using
    Fig. [4.12](#Fig12), we can see two ways to store this data. The first (Fig. [4.13](#Fig13))
    is a basic representation where all the permutations exist in one entity called
    “Educators.” The “type” of row is identified by using a foreign key pointer to
    a validation entity called “Educator Type.”![../images/480347_1_En_4_Chapter/480347_1_En_4_Fig13_HTML.png](../images/480347_1_En_4_Chapter/480347_1_En_4_Fig13_HTML.png)
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 子类型和普通类型标识符（使用外键）之间的区别在于至少存在一个非键属性仅存在于该子类型记录中。创建超类型/子类型关系的主要原因是在只有某些子类型记录中存在多个这些唯一属性的排列。限制一条记录格式内的这些属性的排列可能会有问题。首先，它可能会浪费存储空间，特别是如果每个子类型具有大量唯一属性的情况下。其次，它可能会导致数据查询的重大性能问题。使用图[4.12](#Fig12)，我们可以看到存储这些数据的两种方式。第一种（图[4.13](#Fig13)）是一种基本表示，其中所有排列都存在于一个名为“教育者”的实体中。行的“类型”通过使用指向验证实体“教育者类型”的外键指针来标识。![../images/480347_1_En_4_Chapter/480347_1_En_4_Fig13_HTML.png](../images/480347_1_En_4_Chapter/480347_1_En_4_Fig13_HTML.png)
- en: Fig. 4.13
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.13
- en: Educator ERD using Foreign Key Identifier
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 使用外键标识符的教育者 ERD
- en: Although this representation of the data uses only one entity, it wastes storage
    space because all of the attributes of the entity are never needed by any one
    “type” of record. Furthermore, a user must know which attributes need to be entered
    for a particular type of record. This method of logic data modeling violates the
    concepts of normalization, and entrusts the integrity of values of elements in
    an entity to either an application program’s control (stored procedure), or to
    the memory of the user. Neither of these choices is particularly dependable or
    has proven to be a reliable method of data integrity.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然此数据表示仅使用一个实体，但会浪费存储空间，因为实体的所有属性从未被任何一个“类型”的记录所需。此外，用户必须知道哪些属性需要为特定类型的记录输入。这种逻辑数据建模方法违反了归一化的概念，并且将实体中元素的值的完整性委托给应用程序的控制（存储过程）或用户的记忆。这两种选择都不是特别可靠或已被证明是数据完整性的可靠方法。
- en: On the other hand, Fig. [4.14](#Fig14) provides a different solution using the
    Supertype/Subtype model.![../images/480347_1_En_4_Chapter/480347_1_En_4_Fig14_HTML.png](../images/480347_1_En_4_Chapter/480347_1_En_4_Fig14_HTML.png)
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，图 [4.14](#Fig14) 提供了使用超类型/子类型模型的不同解决方案。
- en: Fig. 4.14
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.14
- en: Educator entity supertype/subtype model
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 教育工作者实体超类型/子类型模型
- en: This model constructs a separate entity for each type of educator, linked via
    a special notation in the relational model, known as the supertype/subtype relation.
    The relationship is mutually exclusive, meaning that the supertype entity Educator
    can have only one of the three subtypes for any given supertype occurrence. Therefore,
    the relationship of one record in a supertype must be one-to-one with only one
    subtype. The supertype/subtype model creates a separate subtype entity to carry
    only the specific attributes unique to its subtype.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 该模型为每种类型的教育工作者构建了一个单独的实体，通过关系模型中的特殊符号，称为超类型/子类型关系进行连接。关系是互斥的，这意味着超类型实体教育工作者在任何给定的超类型发生中只能有三个子类型中的一个。因此，一个超类型的记录与一个子类型的关系必须是一对一的。超类型/子类型模型创建了一个单独的子类型实体，以仅携带其子类型特有的特定属性。
- en: There are two major benefits to this entity structure. First, the construct
    saves storage because it stores only the attributes it needs in each entity. Second,
    the subtype information can be directly addressed without accessing its related
    supertype. This is possible because each subtype entity contains the same primary
    key as its parent. This capability is significant because a user can automatically
    obtain the unique information from any subtype without having to search first
    through the supertype entity. This is particularly beneficial when the number
    of records in each subtype varies significantly. Suppose, for example, there are
    6 million educators in the database. The Educator database would therefore contain
    6 million rows. Let’s say that 5 million of the educators are high school teachers,
    and as such, the High School subtype entity has 5 million records. Eight hundred
    thousand educators are professors, and the remaining 200,000 educators are deans;
    therefore, the Professor database and Dean database have 800,000 and 200,000 records,
    respectively. Using the supertype/subtype model applications could access each
    subtype without searching through every record in the database. Furthermore, because
    access to one subtype does not affect the other, performance is greatly improved.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实体结构有两个主要好处。首先，该结构节省存储空间，因为它只存储每个实体所需的属性。其次，子类型信息可以直接访问，而无需访问其相关的超类型。这是可能的，因为每个子类型实体包含与其父类相同的主键。这种能力很重要，因为用户可以从任何子类型自动获取唯一信息，而无需首先通过超类型实体进行搜索。当每个子类型中的记录数量差异显著时，这一点尤为重要。例如，假设数据库中有
    600 万名教育工作者。因此，教育工作者数据库将包含 600 万行。假设其中 500 万名教育工作者是高中教师，因此，高中子类型实体有 500 万条记录。八十万名教育工作者是教授，其余
    20 万名教育工作者是院长；因此，教授数据库和院长数据库分别有 80 万和 20 万条记录。使用超类型/子类型模型应用程序可以访问每个子类型，而无需搜索数据库中的每条记录。此外，由于对一个子类型的访问不会影响其他子类型，因此性能得到了极大的改善。
- en: It is important to note that the Supertype/Subtype model is not limited to mutual
    exclusivity, that is, it can support multiple subtype permutations. For example,
    suppose an educator could be a high school teacher, college professor, and a dean
    at the same time, or any permutation of the three types. The sample model would
    then be modified to show separate one-to-one relationships as opposed to the “T”
    relationship shown in Fig. [4.14](#Fig14). The alternative model is represented
    in Fig. [4.15](#Fig15).![../images/480347_1_En_4_Chapter/480347_1_En_4_Fig15_HTML.png](../images/480347_1_En_4_Chapter/480347_1_En_4_Fig15_HTML.png)
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，超类型/子类型模型并不局限于相互排斥，也就是说，它可以支持多个子类型排列组合。例如，假设教育工作者可以同时是高中教师、大学教授和院长，或者三种类型的任意组合。然后，示例模型将被修改为显示单独的一对一关系，而不是图 [4.14](#Fig14)
    中显示的“T”关系。替代模型在图 [4.15](#Fig15) 中表示。
- en: Fig. 4.15
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.15
- en: Supertype/subtype model without mutual exclusivity
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 没有相互排斥的超类型/子类型模型
- en: Supertype/Subtypes can cascade, that is, they can continue to iterate or decompose
    within each subtype. This is represented in Fig. [4.16](#Fig16).![../images/480347_1_En_4_Chapter/480347_1_En_4_Fig16_HTML.png](../images/480347_1_En_4_Chapter/480347_1_En_4_Fig16_HTML.png)
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 超类型/子类型可以级联，即它们可以在每个子类型内继续迭代或分解。这在图 [4.16](#Fig16) 中表示。![../images/480347_1_En_4_Chapter/480347_1_En_4_Fig16_HTML.png](../images/480347_1_En_4_Chapter/480347_1_En_4_Fig16_HTML.png)
- en: Fig. 4.16
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.16
- en: Cascading subtypes
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 级联子类型
- en: Notice that in the above example the same primary key continues to link the
    “one-to-one” relationships between the entities. In addition, Fig. [4.16](#Fig16)
    also shows another possibility in the supertype/subtype model. This possibility
    reflects that a subtype can exist without containing any non-key attributes. This
    occurs in the example in the subtype entity Adjunct Prof. The “empty” entity serves
    only to identify the existence of the subtype, without having a dedicated non-key
    attribute associated with it. The Adjunct Prof entity, therefore, is created only
    to allow the other two subtypes (Tenured Prof and Contract Prof) to store their
    unique attributes. This example shows how supertype/subtype models can be constructed,
    and how they often have subtypes that are created for the sole purpose of identification.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，请注意相同的主键继续连接实体之间的“一对一”关系。此外，图 [4.16](#Fig16) 还展示了超类型/子类型模型中的另一种可能性。这种可能性反映了子类型可以存在而不包含任何非键属性。这在子类型实体
    Adjunct Prof 的示例中发生。这个“空”实体仅用于标识子类型的存在，而没有与之关联的专用非键属性。因此，Adjunct Prof 实体仅用于允许另外两个子类型（Tenured
    Prof 和 Contract Prof）存储它们的唯一属性。此示例展示了如何构建超类型/子类型模型，以及它们通常为标识目的而创建的子类型。
- en: Cascading subtypes can mix methods, that is, some levels may not be mutually
    exclusive, while other cascade levels can be mutually exclusive as shown in Fig. [4.17](#Fig17).![../images/480347_1_En_4_Chapter/480347_1_En_4_Fig17_HTML.png](../images/480347_1_En_4_Chapter/480347_1_En_4_Fig17_HTML.png)
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 级联子类型可以混合方法，即一些级联级别可能不是相互排他的，而其他级联级别可以是相互排他的，如图 [4.17](#Fig17) 所示。![../images/480347_1_En_4_Chapter/480347_1_En_4_Fig17_HTML.png](../images/480347_1_En_4_Chapter/480347_1_En_4_Fig17_HTML.png)
- en: Fig. 4.17
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.17
- en: Cascading subtypes with alternating exclusivities
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 具有交替排他性的级联子类型
- en: There is a controversial issue among database developers. The controversy relates
    to whether it is necessary to create a special attribute that identifies which
    entity contains the subtype entry for any given supertype. In other words, how
    does the database know which subtype has the continuation information? This dilemma
    is especially relevant when mutually exclusive relationships exist in the supertype/subtype.
    The question is ultimately whether the supertype/subtype model needs to contain
    an identifier attribute that knows which subtype holds the continuation record,
    or is the issue resolved by the physical database product? Fleming and von Halle
    addressed this issue in the Handbook of Database Design, where they suggest that
    the “attribute is at least partially redundant because its meaning already is
    conveyed by the existence of category or subtype relationships” (p. 162). Still,
    the issue of redundancy may vary among physical database products. Therefore,
    I suggest that the logical model contain a subtype identifier for mutually exclusive
    supertype/subtype relationships as shown in Fig. [4.18](#Fig18).![../images/480347_1_En_4_Chapter/480347_1_En_4_Fig18_HTML.png](../images/480347_1_En_4_Chapter/480347_1_En_4_Fig18_HTML.png)
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库开发人员中存在一个有争议的问题。这个争议与是否需要创建一个特殊属性来标识哪个实体包含任何给定超类型的子类型条目有关。换句话说，数据库如何知道哪个子类型包含继续信息？当超类型/子类型中存在互斥关系时，这个困境尤其相关。最终的问题是超类型/子类型模型是否需要包含一个标识符属性，用于知道哪个子类型持有继续记录，或者这个问题是否由物理数据库产品解决？弗莱明和冯·哈勒在《数据库设计手册》中解决了这个问题，他们建议“属性至少在一定程度上是冗余的，因为它的含义已经通过类别或子类型关系传达出来”（第162页）。然而，冗余问题在物理数据库产品之间可能有所不同。因此，我建议逻辑模型包含一个子类型标识符，用于互斥的超类型/子类型关系，如图 [4.18](#Fig18)
    所示。![../images/480347_1_En_4_Chapter/480347_1_En_4_Fig18_HTML.png](../images/480347_1_En_4_Chapter/480347_1_En_4_Fig18_HTML.png)
- en: Fig. 4.18
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.18
- en: Supertype/subtype with subtype identifier element
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 具有子类型标识符元素的超类型/子类型
- en: Note that the above example has the subtype identifier, Professor Types as a
    validation entity in 3rd normal form.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，上述示例将子类型标识符 Professor Types 作为第三范式中的验证实体。
- en: Supertype/subtypes must also be normalized following the rules of Normalization.
    For example, the subtype Educator Types contains elements that are not in 3rd
    NF. Attributes Grade_Level and Subject in the subtype entity High School Teacher
    can be validated using a look-up table. Department, School, and PhD_Subject can
    also be validated. The resulting 3rd NF ERD is shown below in Fig. [4.19](#Fig19).![../images/480347_1_En_4_Chapter/480347_1_En_4_Fig19_HTML.png](../images/480347_1_En_4_Chapter/480347_1_En_4_Fig19_HTML.png)
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 超类型/子类型还必须按照规范化规则进行规范化。例如，子类型 Educator Types 包含不符合第三范式的元素。子实体高中教师的属性 Grade_Level
    和 Subject 可以使用查找表进行验证。部门、学校和 PhD_Subject 也可以进行验证。生成的第三范式 ERD 如下所示，见图[4.19](#Fig19)。![../images/480347_1_En_4_Chapter/480347_1_En_4_Fig19_HTML.png](../images/480347_1_En_4_Chapter/480347_1_En_4_Fig19_HTML.png)
- en: Fig. 4.19
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.19
- en: Supertype/subtype in 3rd NF
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 第三范式中的超类型/子类型
- en: 4.10 Key Business Rules
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.10 关键业务规则
- en: 'Key business rules are the rules that govern the behavior between entities
    when a row is inserted or deleted. These business rules are programmed at the
    database level using stored procedures and triggers (see Step 7: determine domains
    and triggering operations). These procedures are typically notated as constraints.
    Constraints enforce the key business rules that will be defined by the analysts
    and are the basis of what is meant by referential integrity, that is, the integrity
    based on the relations between tables. The process of insertion and deletion focuses
    on the relationship between the parent entity and the child entity. A child entity
    is always the entity that has the Crow’s Foot pointing to it. Based on the ERD
    in Fig. [4.10](#Fig10) the parent-child entity relationships are as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 关键业务规则是在插入或删除行时管理实体之间行为的规则。这些业务规则在数据库级别使用存储过程和触发器进行编程（参见步骤 7：确定域和触发操作）。这些过程通常被标记为约束。约束强制执行分析人员定义的关键业务规则，并且是所谓的引用完整性的基础，即基于表之间关系的完整性。插入和删除的过程侧重于父实体和子实体之间的关系。子实体始终是具有
    Crow’s Foot 指向的实体。根据图[4.10](#Fig10)中的 ERD，父子实体关系如下：
- en: Orders entity is the parent of Order Items entity (child).
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订单实体是订单项实体（子实体）的父实体。
- en: Customer entity is the parent of Orders entity (child).
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户实体是订单实体（子实体）的父实体。
- en: Items entity is the parent of Order Items entity (child).
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Items 实体是 Order Items 实体（子实体）的父实体。
- en: 'When discussing insertion of a row, it is always from the perspective of the
    child entity. That is, key business rules governing the insertion of a child record
    concern what should be done when attempting to insert a child record that does
    not have a corresponding parent record. There are six alternatives:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当讨论插入行时，始终从子实体的角度进行。也就是说，管理插入子记录的关键业务规则涉及尝试插入没有相应父记录的子记录时应执行的操作。有六个选择：
- en: '1.'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '1.'
- en: 'Not Allowed: this means that the constraint is to disallow the transaction.
    For example, in Fig. [4.11](#Fig11), a user could not insert an Order Item (child)
    for an Order-Number that did not exist in the Orders entity (parent). Essentially,
    the integrity of the reference would be upheld, until the Order-Number in the
    Orders entity was inserted first.'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不允许：这意味着约束是不允许事务。例如，在图[4.11](#Fig11)中，用户不能为不存在于订单实体（父实体）中的订单号插入订单项（子实体）。基本上，引用的完整性将被维护，直到订单实体中首先插入订单号。
- en: '2.'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '2.'
- en: 'Add Parent: this means that if the parent key does not exist, it will be added
    at the same time. Using Fig. [4.11](#Fig11), this would mean that the user would
    be prompted to add the Order-Number to the Orders entity before the child Item
    would be inserted. The difference between Not Allowed and Add Parent is that the
    user can enter the parent information during the insertion of the child transaction.
    Using this rule still enforces referential integrity.'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 添加父项：这意味着如果父项键不存在，它将同时被添加。使用图[4.11](#Fig11)，这意味着在插入子项之前，用户将被提示将订单号添加到订单实体中。不允许和添加父项之间的区别在于用户可以在插入子交易时输入父信息。使用此规则仍然强制执行引用完整性。
- en: '3.'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '3.'
- en: 'Default Value: the use of a default value allows a “dummy” row to be inserted
    into the parent. An example of the use of a default occurs when collection agencies
    receive payments from an unknown person. The parent entity is “Account” and the
    child entity is “Payments.” The Account entity would have a key value called “Unapplied”
    which would be used whenever an unidentified payment was collected. In this scenario,
    it is appropriate to have the dummy record because the child transaction is really
    unknown, but at the same time needs to be recorded in the database. It is also
    useful because the user can quickly get a list of “unapplied” payments and it
    upholds referential integrity.'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 默认值：使用默认值允许将“虚拟”行插入到父行中。使用默认值的示例是当收集机构从未知人士那里收到付款时。父实体是“账户”，子实体是“付款”。账户实体将具有一个名为“未分配”的关键值，该值在收集到未知付款时使用。在这种情况下，拥有虚拟记录是合适的，因为子交易实际上是未知的，但同时需要记录在数据库中。这也很有用，因为用户可以快速获取“未分配”付款列表，并且它维护了参照完整性。
- en: '4.'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '4.'
- en: 'Algorithm: an algorithm is an “intelligent” default value. Using the same example
    as (3), suppose the user wanted to track unapplied payments by State. For example,
    if an unapplied payment were received in New York, the parent (Account entity)
    would have a record inserted with a value “Unapplied-New York.” Therefore, each
    State would have its own default. There are also default keys that are based on
    sophisticated algorithms to ensure that there is an understanding to the selection
    of the parent’s key attribute value. Again, this selection ensures referential
    integrity because a record is inserted at both the parent and child entities.'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 算法：算法是一个“智能”的默认值。使用与（3）相同的示例，假设用户想要按州跟踪未分配的付款。例如，如果在纽约收到了未分配的付款，则父项（账户实体）将插入一个带有值“未分配-纽约”的记录。因此，每个州都有自己的默认值。还有基于复杂算法的默认键，以确保对父键属性值的选择有所了解。同样，此选择确保参照完整性，因为记录会被插入到父实体和子实体中。
- en: '5.'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '5.'
- en: 'Null: assigning a null means that the parent does not exist. Most database
    products such as Oracle allow such selection, and while it is maintained within
    the product, it violates referential integrity because the parent is unknown.'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 空值：指定空值意味着父项不存在。大多数数据库产品（如Oracle）允许这样的选择，虽然它在产品内部保持，但它违反了参照完整性，因为父项是未知的。
- en: '6.'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '6.'
- en: 'Don’t Care: this essentially says that the user is willing to accept that referential
    integrity does not exist in the database. The user will tell you that they never
    wish to balance the records in the child with those in the parent. While this
    happens, it should be avoided, because it creates a system without integrity.'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不关心：这基本上表示用户愿意接受数据库中不存在参照完整性。用户会告诉您，他们从不希望平衡子记录与父记录。尽管会发生这种情况，但应该避免，因为它会创建一个没有完整性的系统。
- en: 'When discussing deletion of a row, it is always from the perspective of the
    parent entity. That is, key business rules governing the deletion of a parent
    record concern what should be done when attempting to delete a parent record that
    has corresponding child records. There are similarly six alternatives:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论行的删除时，始终从父实体的角度出发。也就是说，关于删除具有对应子记录的父记录时应该执行的关键业务规则。同样有六个替代方案：
- en: '1.'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '1.'
- en: 'Not Allowed: this means that the constraint is to disallow the deletion of
    the parent record. In other words, if there are children records, the user cannot
    delete the parent. For example, if in Fig. [4.11](#Fig11), a user could not delete
    an Order (parent) if there were corresponding records in the Order Items entity
    (child). This action would require the user first to delete all of the Order Items
    or children records before allowing the parent Order to be deleted.'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '不允许：这意味着约束是不允许删除父记录。换句话说，如果存在子记录，则用户无法删除父记录。例如，在图[4.11](#Fig11)中，如果用户无法删除订单（父项），如果在订单项目实体（子项）中有相应的记录，则此操作将要求用户先删除所有订单项目或子记录，然后才能删除父订单。  '
- en: '2.'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '2.'
- en: 'Delete All: this is also known as cascading, because the system would automatically
    delete all child associations with the parent entity. Using the same example as
    (1), the children records in Order Items would automatically be deleted. While
    this option ensures referential integrity, it can be dangerous because it might
    delete records that are otherwise important to keep.'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 删除所有：这也称为级联，因为系统会自动删除与父实体相关联的所有子关联。使用与（1）相同的示例，订单项目中的子记录将自动删除。虽然此选项确保引用完整性，但它可能会删除其他重要记录。
- en: '3.'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '3.'
- en: 'Default Value: the use of a default value is the same as in insertion, that
    is, it allows a “dummy” row to be inserted into the parent. This means that the
    original parent is deleted, and the child records are redirected to some default
    value row in the parent entity. This is sometimes useful when there are many old
    parent records, such as old part-numbers, that are cluttering up the parent database.
    If keeping the child records is still important, they can be redirected to a default
    parent row, such as “Old Part-Number.”'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 默认值：使用默认值与插入相同，即允许将“虚拟”行插入父级。这意味着原始父级被删除，并且子记录被重定向到父实体中的某个默认值行。当有许多旧的父记录（例如旧的零件编号）杂乱了父数据库时，这有时是有用的。如果保留子记录仍然很重要，则可以将它们重定向到默认父行，例如“旧零件编号”。
- en: '4.'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '4.'
- en: 'Algorithm: the use of the algorithm is the same as with an insertion. As in
    the case of (3) above, the default value might be based on the type of product
    or year it became obsolete.'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 算法：算法的使用与插入时相同。与上述情况（3）一样，默认值可能基于产品类型或其过时年份。
- en: '5.'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '5.'
- en: 'Null: as in the case of insertion, the assigning of a null means that the parent
    does not exist. This creates a situation where the child records become “orphans.”
    Referential integrity is lost.'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 空值：与插入时相同，分配空值意味着父项不存在。这会导致子记录变成“孤立”。引用完整性丢失。
- en: '6.'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '6.'
- en: 'Don’t Care: same as in insertion. The database allows parent records to be
    deleted without checking to see if there are corresponding child records in another
    entity. This also results in losing referential integrity and creates “orphans.”'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 无关紧要：与插入时相同。数据库允许删除父记录，而无需检查其他实体中是否有相应的子记录。这也会导致引用完整性丢失并创建“孤立”记录。
- en: In summary, key business rules are concerned with the behavior of primary keys
    during insert and delete operations. There are six alternative options within
    each operation (insert and delete). Four of the options uphold referential integrity,
    which is defined as the dependability of the relationships between items of data.
    Data integrity is an issue any time there is change to data, which in ecommerce
    systems will be frequent. Thus, the ecommerce analyst must ensure that once primary
    keys have been determined, it is of vital importance that users are interviewed
    regarding their referential integrity needs. Analysts should not make these decisions
    in a vacuum and need to present the advantages of referential integrity appropriately
    to users so that they can make intelligent and well-informed decisions.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，关键业务规则涉及主键在插入和删除操作期间的行为。在每个操作（插入和删除）中有六个备选选项。其中四个选项维护引用完整性，即数据项之间关系的可靠性。数据完整性是数据发生变化时的问题，在电子商务系统中，这种变化是频繁的。因此，电子商务分析师必须确保一旦确定了主键，非常重要的是要对用户的引用完整性需求进行访谈。分析师不应该孤立地做出这些决定，需要适当向用户展示引用完整性的优势，以便他们能够做出明智和充分的决策。
- en: This discussion of key business rules was predicated on using examples derived
    from the discussion on Normalization. As discussed earlier in this section, the
    application of normalization occurs after the determination of key business rules,
    especially since it may indeed affect the design of the ERD, and in the programming
    of stored procedures. This will be discussed further in the Determine Domains
    and Triggering Operations section of this chapter.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 对关键业务规则的讨论是基于使用规范化讨论中提取的示例。正如本章前面讨论的那样，规范化的应用发生在确定关键业务规则之后，特别是因为它可能影响ERD的设计以及存储过程的编程。这将在本章的“确定域和触发操作”部分进一步讨论。
- en: 4.11 Combining User Views
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.11 合并用户视图
- en: The application of Normalization focused on breaking up or decomposing entities
    to include the correct placement of data. Each NF failure resulted in creating
    a new entity; however, there are situations where certain entities may need to
    be combined. This section is labeled “Combining User Views” because the meaning
    of data is strongly dependent on how the user defines a data element. Unfortunately,
    there are circumstances where data elements are called different things and defined
    differently by different users in different departments. The word “different”
    is critical to the example. In cases where we think we have two entities, we may,
    in fact have only one. Therefore, the process of combining user views typically
    results in joining two or more entities as opposed to decomposing them as done
    with Normalization. The best way to understand this concept is to recall the earlier
    discussion on Logical Equivalents. This interpretation of the Logical Equivalent
    will focus on the data rather than the process. Suppose there are two entities
    created from two different departments. The first department defines the elements
    for an entity called “Clients” as shown in Fig. [4.20](#Fig20).![../images/480347_1_En_4_Chapter/480347_1_En_4_Fig20_HTML.png](../images/480347_1_En_4_Chapter/480347_1_En_4_Fig20_HTML.png)
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 规范化的应用侧重于将实体分解或分解以包括数据的正确放置。每个NF故障都会导致创建一个新实体；但是，某些情况下可能需要合并某些实体。本节标为“组合用户视图”，因为数据的含义很大程度上取决于用户如何定义数据元素。不幸的是，有些情况下，数据元素被称为不同的事物，并且由不同部门的不同用户以不同方式定义。这个例子中的“不同”一词对示例至关重要。在我们认为有两个实体的情况下，实际上我们可能只有一个。因此，组合用户视图的过程通常会导致将两个或更多实体合并，而不是像规范化所做的那样对其进行分解。理解这个概念的最佳方法是回顾早期对逻辑等价物的讨论。对逻辑等价物的此解释将侧重于数据而不是过程。假设有两个由两个不同部门创建的实体。第一个部门为名为“客户”的实体定义了元素，如图 [4.20](#Fig20)所示。![../images/480347_1_En_4_Chapter/480347_1_En_4_Fig20_HTML.png](../images/480347_1_En_4_Chapter/480347_1_En_4_Fig20_HTML.png)
- en: Fig. 4.20
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.20
- en: The client entity
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 客户实体
- en: The second department defines an entity called “Customers” as shown in Fig. [4.21](#Fig21).![../images/480347_1_En_4_Chapter/480347_1_En_4_Fig21_HTML.png](../images/480347_1_En_4_Chapter/480347_1_En_4_Fig21_HTML.png)
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个部门定义了一个名为“客户”的实体，如图 [4.21](#Fig21)所示。![../images/480347_1_En_4_Chapter/480347_1_En_4_Fig21_HTML.png](../images/480347_1_En_4_Chapter/480347_1_En_4_Fig21_HTML.png)
- en: Fig. 4.21
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.21
- en: The customer entity
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 客户实体
- en: Upon a closer analysis and review of the data element definitions, it becomes
    apparent that the two departments are looking at the same object. Notwithstanding
    whether the entity is named Client or Customer, these entities must be combined.
    The process of combining two or more entities is not as simple as it might sound.
    In the two examples, there are data elements that are the same with different
    names, and there are unique data elements in each entity. Each department is unaware
    of the other’s view of the same data, and by applying logical equivalencies the
    following single entity results as shown in Fig. [4.22](#Fig22).![../images/480347_1_En_4_Chapter/480347_1_En_4_Fig22_HTML.png](../images/480347_1_En_4_Chapter/480347_1_En_4_Fig22_HTML.png)
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在对数据元素定义进行更详细的分析和审查后，显而易见两个部门正在看同一个对象。无论实体被命名为客户还是客户，这些实体都必须合并。将两个或更多实体合并的过程并不像听起来那么简单。在这两个示例中，存在相同但具有不同名称的数据元素，并且每个实体中还有独特的数据元素。每个部门都不知道对方对相同数据的看法，并通过应用逻辑等价性得到以下单一实体，如图 [4.22](#Fig22)所示。![../images/480347_1_En_4_Chapter/480347_1_En_4_Fig22_HTML.png](../images/480347_1_En_4_Chapter/480347_1_En_4_Fig22_HTML.png)
- en: Fig. 4.22
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.22
- en: Combined client and customer entity
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 组合的客户和客户实体
- en: The above example uses names that made it easier for an analyst to know they
    were the same data elements. In reality, such may not be the case, especially
    when working with legacy systems. In legacy systems, names and definitions of
    elements can vary significantly among departments and applications. Furthermore,
    the data definitions can vary significantly. Suppose Client is defined as VARCHAR2(35)
    and Customer as VARCHAR2(20). The solution is to take the larger definition. In
    still other scenarios, one element could be defined as alphanumeric, and the other
    numeric. In these circumstances the decisions become more involved with user conversations.
    In either situation, it is important that the data elements do get combined and
    that users agree-to-agree. In cases where user agreement is difficult, then analysts
    can take advantage of a data dictionary feature called Alias. An Alias is defined
    as an alternate name for a data element. Multiple Aliases can point to the same
    data dictionary entry. Therefore, screens can display names that are Aliases for
    another element. This alternative can solve many problems when using different
    names is necessary.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例使用的名称使分析人员更容易知道它们是相同的数据元素。然而，在现实中，情况可能并非如此，特别是在处理遗留系统时。在遗留系统中，元素的名称和定义在部门和应用程序之间可能存在显著差异。此外，数据定义也可能存在显著差异。假设
    Client 被定义为 VARCHAR2(35)，而 Customer 被定义为 VARCHAR2(20)。解决方案是采用较大的定义。在其他情况下，一个元素可以被定义为字母数字，而另一个元素则为数字。在这些情况下，决策变得更加复杂，需要进行用户对话。无论是哪种情况，重要的是数据元素确实被合并，并且用户同意这种合并。在用户达成一致意见困难的情况下，分析人员可以利用数据字典功能中的别名。别名被定义为数据元素的替代名称。多个别名可以指向同一个数据字典条目。因此，屏幕可以显示作为另一个元素别名的名称。当需要使用不同的名称时，这种替代方案可以解决许多问题。
- en: Another important issue in combining user views is performance. While analysts
    should not be overly concerned about performance issues during LDM, it should
    not be ignored either. Simply put, the fewer entities, the faster the performance;
    therefore, the least number of entities that can be designed in the ERD the better.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在合并用户视图时，另一个重要问题是性能。虽然分析人员在逻辑数据模型设计期间不应过分关注性能问题，但也不应忽视。简单地说，实体越少，性能越快；因此，在ERD中设计的实体数量越少越好。
- en: 4.12 Integration with Existing Data Models
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.12 与现有数据模型集成
- en: The purpose of this section is to discuss specific analysis and design issues
    relating to how to integrate with existing database applications. The connectivity
    with other database systems is difficult. Indeed, many firms approach the situation
    by phasing each business area over time into a new re-developed operation. In
    these circumstances, each phased area needs a “Legacy Link” which allows the “old”
    applications to work with the new phased-in software.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的目的是讨论与如何与现有数据库应用程序集成相关的特定分析和设计问题。与其他数据库系统的连接是困难的。事实上，许多公司通过逐步将每个业务领域转移到新的重新开发的操作中来应对这种情况。在这种情况下，每个阶段性区域都需要一个“遗留链接”，它允许“旧”应用程序与新的逐步引入的软件一起工作。
- en: 'Linking entities with existing databases may force ecommerce analysts to rethink
    how to preserve integrity while still maintaining the physical link to other corporate
    data. This occurrence is a certainty with ecommerce systems given that certain
    portions of the data are used inside and outside the business. The following example
    shows how this problem occurs:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 将实体与现有数据库链接可能会迫使电子商务分析人员重新考虑如何在保持与其他企业数据的物理链接的同时保持完整性。在电子商务系统中，由于数据的某些部分在企业内外使用，这种情况是确定的。以下示例展示了这个问题的发生方式：
- en: The analyst is designing a website that utilizes the company’s Orders Master
    database. The website needs this information to allow customers to see information
    about their past orders for items so they can match it to a product database supplied
    by the ecommerce system. This feature is provided to customers to allow them to
    understand how items have been utilized to make their products. Unfortunately,
    the master Order Items database holds only orders for the past year and then stores
    them off-line. There is no desire by the Order department to create a historical
    tracking system. The ERD in Fig. [4.23](#Fig23) shows the relationships with the
    corporate Order Items database file.![../images/480347_1_En_4_Chapter/480347_1_En_4_Fig23_HTML.png](../images/480347_1_En_4_Chapter/480347_1_En_4_Fig23_HTML.png)
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 分析员正在设计一个利用公司订单主数据库的网站。该网站需要这些信息，以便允许客户查看有关其过去订单的信息，以便他们可以将其与电子商务系统提供的产品数据库匹配。此功能提供给客户以便他们了解如何利用物品制作产品。不幸的是，主订单项数据库仅保存了过去一年的订单，然后将其存储脱机。订单部门没有创建历史跟踪系统的愿望。图中的ERD显示了与公司订单项数据库文件的关系。![../images/480347_1_En_4_Chapter/480347_1_En_4_Fig23_HTML.png](../images/480347_1_En_4_Chapter/480347_1_En_4_Fig23_HTML.png)
- en: Fig. 4.23
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.23
- en: ERD showing association between web databases and legacy employee master
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 显示Web数据库与遗留员工主数据库之间关联的ERD
- en: Note that the Order Item Products entity has a one or zero relationship with
    the Order Item Master entity. This means that there can be an Order Item in the
    Order Item Product entity that does not exist in the Order item entity. Not only
    does this violate Normalization, it also presents a serious integrity problem.
    For example, if the customer wanted to display information about their products
    and each component Item, all Items that do not exist in the Order Item entity
    will display blanks, since there is no corresponding name information in the Order
    Item file. Obviously, this is a flaw in the database design that needs to be corrected.
    The remedy is to build a subsystem database that will capture all of the Order
    items without purging them. This would entail a system that accesses the Order
    Item database and merges it with the Web version of the file. The merge conversion
    would compare the two files and update or add new Order items without deleting
    the old ones. That is, the master Order Items would be searched daily to pick
    up new Order Items to add to the Web version. Although this is an extra step,
    it maintains integrity, Normalization, and most important, the requirement not
    to modify the original Order Item database. The drawback to this solution is that
    the Web version may not have up-to-date Order items information. This will depend
    on how often records are moved to the Web database. This can be remedied by having
    a replication feature, where the Web Order Item would be created at the same time
    as the master version. The ERD would be reconstructed as shown in Fig. [4.24](#Fig24).![../images/480347_1_En_4_Chapter/480347_1_En_4_Fig24_HTML.png](../images/480347_1_En_4_Chapter/480347_1_En_4_Fig24_HTML.png)
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，订单项产品实体与订单项主实体之间存在一对零或一的关系。这意味着订单项产品实体中可能存在一个订单项，而订单项实体中不存在。这不仅违反了规范化，还带来了严重的完整性问题。例如，如果客户想要显示关于他们的产品和每个组件项的信息，所有在订单项实体中不存在的项目都将显示为空白，因为在订单项文件中没有相应的名称信息。显然，这是数据库设计中的一个缺陷，需要纠正。解决方法是建立一个子系统数据库，以捕获所有的订单项而不会清除它们。这将需要一个访问订单项数据库并将其与文件的Web版本合并的系统。合并转换将比较两个文件，并更新或添加新的订单项，而不删除旧的订单项。也就是说，每天都会搜索主订单项以拾取要添加到Web版本的新订单项。尽管这是一个额外的步骤，但它保持了完整性、规范化，最重要的是，要求不修改原始订单项数据库。这种解决方案的缺点是Web版本可能没有最新的订单项信息。这将取决于记录何时移动到Web数据库。这可以通过具有复制功能来解决，其中Web订单项将与主版本同时创建。ERD将如图所示重建。![../images/480347_1_En_4_Chapter/480347_1_En_4_Fig24_HTML.png](../images/480347_1_En_4_Chapter/480347_1_En_4_Fig24_HTML.png)
- en: Fig. 4.24
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.24
- en: ERD reflecting legacy link to the Order Item entity
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 反映订单项实体的遗留链接的ERD
- en: In the above diagram the Order Item master and its relation to the Web Order
    Item entity are shown for informational purposes only. The master Order Item becomes
    more of an application requirement rather than a permanent part of the ERD. In
    order to “operationalize” this system, the analyst must first have to reconstruct
    the history data from the purged files, or simply offer the historical data as
    of a certain date.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在上图中，显示了订单项主信息及其与 Web 订单项实体的关系，仅供信息目的。主订单项更多地成为应用需求，而不是 ERD 的永久部分。为了使这个系统“操作化”，分析员首先必须从清除的文件中重建历史数据，或者简单地提供某个日期的历史数据。
- en: 4.13 Determining Domains and Triggering Operations
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.13 确定域和触发操作
- en: 'The growth of the relational database model has established processes for storing
    certain application logic at the database level. We have already defined key business
    rules as the vehicle to create constraints at the key attribute level. However,
    there are other constraints and procedures that can occur depending on the behavior
    of non-key attributes. Ultimately, business rules are application logic that is
    coded in the database language, for example PL_SQL for Oracle. These non-key attribute
    rules could enforce such actions as: If CITY is entered, the STATE must also be
    entered. This type of logic rule used to be enforced at the application level.
    Unfortunately, using application logic to enforce business rules is inefficient
    because it requires the code to be replicated in each application program. This
    process also limits control, in that the relational model allows users to “query”
    the database directly. Thus, business rules at the database level need to be written
    only once, and they govern all type of applications, including programs and queries.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 关系型数据库模型的发展已经建立了在数据库级别存储某些应用逻辑的流程。我们已经将关键业务规则定义为创建主键属性级别约束的载体。然而，根据非主键属性的行为，可能会出现其他约束和程序。最终，业务规则是在数据库语言中编码的应用逻辑，例如
    Oracle 的 PL_SQL。这些非主键属性规则可以强制执行诸如：如果输入了 CITY，则必须输入 STATE。这种类型的逻辑规则过去是在应用程序级别强制执行的。不幸的是，使用应用逻辑来执行业务规则是低效的，因为它要求将代码复制到每个应用程序中。这个过程还限制了控制，因为关系模型允许用户直接“查询”数据库。因此，数据库级别的业务规则只需编写一次，它们可以管理所有类型的应用程序，包括程序和查询。
- en: As stated earlier, business rules are implemented at the database level via
    stored procedures. Stored procedures are offered by most database manufacturers,
    and although they are similar, they are not implemented using the same coding
    schemes. Therefore, moving stored procedures from one database to another is not
    trivial. The importance of having portable stored procedures and their relationship
    to partitioning databases across the Internet, Intranets, and distributed networks
    is becoming even more complex in mobile-based architecture. It is important to
    note that distributed network systems are being built under the auspices of client/server
    computing and may require communication among many different database vendor systems.
    If business rules are to be implemented at the database level, the compatibility
    and transportability of such code becomes a challenge. We also see that client/server
    will be addressed more and more as distributed and although normalization remains
    important, the expansion of blockchain will require multiple stored data to exist.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面所述，业务规则是通过存储过程在数据库级别实现的。大多数数据库制造商都提供存储过程，尽管它们相似，但它们不是使用相同的编码方案实现的。因此，将存储过程从一个数据库移动到另一个数据库并不是微不足道的。具有可移植存储过程的重要性及其与在
    Internet、Intranet 和分布式网络上分区数据库的关系变得更加复杂。重要的是要注意，分布式网络系统是在客户/服务器计算的支持下构建的，并且可能需要在许多不同的数据库供应商系统之间进行通信。如果要在数据库级别实现业务规则，则此类代码的兼容性和可传输性将成为一个挑战。我们还看到客户/服务器将越来越多地被视为分布式的，尽管归一化仍然很重要，但区块链的扩展将需要存在多个存储数据。
- en: 'Business rule implementations fall into three categories: Keys, Domains and
    Triggers. Key business rules have already been discussed as part of the normalization
    process. Domains represent the constraints related to an attribute’s range of
    values. If an attribute (key or non-key) can have a range of values from one to
    nine, we say that range is the domain value of the attribute. This is very important
    information to be included and enforced at the database level through a stored
    procedure for the same reasons as discussed above. The third and most powerful
    business rule is Triggers.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 业务规则的实现分为三类：键（Keys）、域（Domains）和触发器（Triggers）。键业务规则已作为规范化过程的一部分进行讨论。域代表与属性值范围相关的约束。如果一个属性（键或非键）的值范围从一到九，我们称该范围是属性的域值。出于上述相同的原因，这是非常重要的信息，需要在数据库级别通过存储过程进行包含和强制执行。第三个、也是最强大的业务规则是触发器。
- en: Triggers are defined as stored procedures that when activated “trigger” one
    or a set of other stored procedures to be executed. Triggers act on other entities,
    although in many database products, triggers are becoming powerful programming
    tools to provide significant capabilities at the database level rather than at
    the application level. Triggers resemble batch type files which when invoked execute
    a “script” or set of logical statements as shown below:![../images/480347_1_En_4_Chapter/480347_1_En_4_Figd_HTML.png](../images/480347_1_En_4_Chapter/480347_1_En_4_Figd_HTML.png)
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 触发器被定义为当激活时会“触发”一个或一组其他存储过程执行的存储过程。触发器作用于其他实体，尽管在许多数据库产品中，触发器正在成为在数据库级别而不是在应用程序级别提供重要功能的强大编程工具。触发器类似于批处理类型的文件，当调用时执行一个“脚本”或一组逻辑语句，如下所示：![../images/480347_1_En_4_Chapter/480347_1_En_4_Figd_HTML.png](../images/480347_1_En_4_Chapter/480347_1_En_4_Figd_HTML.png)
- en: This trigger was implemented in a contact management ecommerce system. The trigger
    is designed to allow corporate information to be marked as confidential only by
    specific executives. This means that an appointed executive of the corporation
    can enter information that is private. The second component of the trigger is
    programmed to automatically ensure that the executive’s contacts are stored as
    private or confidential. These two stored procedures show how application logic
    executes via Oracle triggers. It is important to remember that these business
    rules are enforced by the database regardless of how the information is accessed.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 此触发器已在一家联系管理电子商务系统中实施。该触发器旨在允许将企业信息标记为仅由特定执行人员保密。这意味着公司的指定执行人员可以输入私人信息。触发器的第二个组件被设计为自动确保执行人员的联系人被存储为私人或机密。这两个存储过程展示了应用程序逻辑如何通过
    Oracle 触发器执行。重要的是要记住，这些业务规则是由数据库强制执行的，无论信息如何被访问。
- en: Triggers, however, can cause problems. Because triggers can initiate activity
    among database files, designers must be careful that they do not impair performance.
    For example, suppose a trigger is written that affects 15 different database files.
    Should the trigger be initiated during the processing of other critical applications,
    it could cause significant degradation in processing, and thus affect critical
    production systems.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，触发器可能会引起问题。因为触发器可以在数据库文件之间引发活动，设计人员必须小心，以免损害性能。例如，假设编写了一个影响 15 个不同数据库文件的触发器。如果触发器在处理其他关键应用程序时被激活，它可能导致处理速度显著降低，从而影响关键生产系统。
- en: The subject of business rules is very broad yet must be specific to the actual
    database product to be used. Since analysts may not know which database will ultimately
    be used, specifications for stored procedures should be developed using the specification
    formats presented in Chap. [3](480347_1_En_3_Chapter.xhtml). This is even more
    salient in ecommerce systems given the possibility that different databases can
    be used across the entire system.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 业务规则的主题非常广泛，但必须针对实际使用的数据库产品进行具体说明。由于分析人员可能不知道最终将使用哪个数据库，因此应该使用第 [3](480347_1_En_3_Chapter.xhtml)
    章提出的规范格式来开发存储过程的规范。在电子商务系统中，这一点变得更加重要，因为整个系统可以使用不同的数据库。
- en: 4.14 De-normalization
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.14 反规范化
- en: Third NF databases can often have difficulty with performance. Specifically,
    significant numbers of look-up tables, which are actual 3rd NF failures, create
    too many index links. As a result, while we have reached the integrity needed,
    performance becomes an unavoidable dilemma. In fact, the more integrity, the less
    performance. There are a number of ways to deal with the downsides of normalized
    databases. One is to develop data warehouses and other off-line copies of the
    database. There are many bad ways to de-normalize. Indeed, any de-normalization
    hurts integrity. But there are two types of de-normalization that can be implemented
    without significantly hurting the integrity of the data.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 第三范式数据库通常在性能方面会遇到困难。具体来说，大量的查找表，这些表实际上是第三范式的失败，会创建太多的索引链接。因此，虽然我们已经达到了所需的完整性，但性能成为了一个不可避免的困境。实际上，完整性越高，性能就越低。有许多应对规范化数据库不足的方法。其中一种方法是开发数据仓库和数据库的其他离线副本。有许多不好的去正规化方法。事实上，任何一种去正规化都会损害完整性。但是有两种类型的去正规化可以在不显著损害数据完整性的情况下实施。
- en: The first type of de-normalization is to revisit 3rd NF failures to see if all
    of the validations are necessary. Third NF failures usually create tables that
    ensure that entered values are validated against a master list. For example, in
    Fig. [4.10](#Fig10), the Customers entity, created as a result of a 3rd NF failure
    provides a validation to all customers associated with an Order. This means that
    the user cannot assign any customer, but rather only those residents in the Customer
    entity. The screen to select a Customer would most likely use a “drop-down” menu,
    which would show all of the valid Customers for selection to the Order. However,
    there may be look-up tables that are not as critical. For example, zipcodes may
    or may not be validated. Whether zipcodes need to be validated depends on the
    use of zipcodes by the users. If they are just used to record a Customer’s address,
    then it may not be necessary or worthwhile to have the zipcode validated. If,
    on the other hand, they are used for certain types of geographic analysis or mailing,
    then indeed, validation is necessary. This process—the process of reviewing the
    use and need for a validation table—should occur during the interview process.
    If this step is left out, then there is a high probability that too many non-key
    attributes will contain validation look-up entities that are unnecessary and hurt
    performance.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种去正规化的类型是重新审视第三范式失败，看看所有的验证是否都是必要的。第三范式的失败通常会创建表，以确保输入值与主列表进行验证。例如，在图[4.10](#Fig10)中，作为第三范式失败的结果创建的Customers实体为与订单相关的所有客户提供了验证。这意味着用户不能分配任何客户，而只能分配那些在Customer实体中的客户。选择客户的屏幕很可能会使用“下拉”菜单，其中会显示所有有效的客户供订单选择。然而，并非所有查找表都是关键的。例如，邮政编码可能需要验证，也可能不需要验证。邮政编码是否需要验证取决于用户对邮政编码的使用。如果它们只用于记录客户的地址，则可能没有必要或值得验证邮政编码。如果，另一方面，它们用于某些类型的地理分析或邮寄，则验证是必要的。这个过程——审查验证表的使用和需要的过程——应该在面试过程中进行。如果忽略了这一步，那么非关键属性中将包含太多不必要的验证查找实体的可能性很高，这会影响性能。
- en: The second type of de-normalization is to add back “derived” attributes. While
    this is not the preferred method, it can be implemented without sacrificing integrity.
    This can be accomplished by creating triggers that automatically launch a stored
    procedure to recalculate a derived value when a dependent attribute has been altered.
    For example, if Amount is calculated based on Quantity * Unit-Price, then two
    triggers must be developed (one for Quantity and one for Unit-Price) which would
    recalculate Amount if either Quantity or Unit-Price were changed. While this solves
    the integrity issue, analysts must be cognizant over the performance conflict
    should the trigger be initiated during peak processing times. Therefore, there
    must be a balance between the trigger and when it is allowed to occur.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种去正规化的类型是添加“派生”属性。虽然这不是首选方法，但可以在不牺牲完整性的情况下实现。这可以通过创建触发器来完成，触发器会在依赖属性被更改时自动启动存储过程来重新计算派生值。例如，如果金额是基于数量
    * 单价计算的，则必须开发两个触发器（一个用于数量，一个用于单价），它们会在数量或单价更改时重新计算金额。虽然这解决了完整性问题，但分析人员必须意识到在高峰处理时间触发器启动时可能会发生性能冲突。因此，必须在触发器和允许其发生的时间之间取得平衡。
- en: As stated earlier, denormalization will be occurring more often because of IoT
    and blockchain where portions of data will need to be distributed. I advocate
    for always starting the design with normalization in mind, and then depending
    on the network design to allow duplications based on performance of the network
    and the characteristics of the interface devices.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面所述，由于物联网和区块链，反规范化将更频繁地发生，其中部分数据将需要分布。我主张始终从规范化的角度开始设计，然后根据网络设计允许基于网络性能和接口设备特性的重复。
- en: 4.14.1 Summary
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.14.1 摘要
- en: This chapter has provided the logical equivalent to the data component of the
    ecommerce system. The process of decomposing data is accomplished using LDM, which
    has eight major steps that need to be applied in order to functionally decompose
    the data. Data Flow Diagrams (DFD) are a powerful tool to use during process analysis
    because they provide direct input into the LDM method. Specifically, data flows
    provide data definitions into the Data Dictionary, which is necessary to complete
    LDM. Furthermore, data stores in the DFD represent the major entities, which is
    the first step in LDM. The output of LDM is an ERD, which represents the schematic
    or blueprint of the database. The ERD shows the relationships among entities and
    the cardinality of those relationships.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供了电子商务系统数据组件的逻辑等价物。使用LDM完成数据分解的过程，其中包括八个主要步骤，需要按顺序应用以对数据进行功能分解。数据流图（DFD）是过程分析中的强大工具，因为它们为LDM方法提供直接输入。具体而言，数据流向数据字典提供数据定义，这对完成LDM是必要的。此外，DFD中的数据存储表示主要实体，这是LDM的第一步。LDM的输出是一个ERD，它表示数据库的原理图或蓝图。ERD显示实体之间的关系以及这些关系的基数。
- en: The LDM also makes provisions to develop stored procedures, which are programs
    developed at the database level. These procedures allow “referential integrity”
    to be enforced without developing application programs that operate outside the
    data. Stored procedures can be used to enforce key business rules, domain rules,
    and triggers. Triggers are batch-oriented programs that automatically execute
    when a particular condition has occurred at the database level, typically, when
    an attribute has been altered in some way.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: LDM还规定了开发存储过程的方法，这些存储过程是在数据库级别开发的程序。这些过程允许强制执行“引用完整性”，而无需开发在数据之外运行的应用程序。存储过程可用于强制执行关键业务规则、域规则和触发器。触发器是批处理程序，在发生特定条件时在数据库级别自动执行，通常在某种方式下已更改属性时。
- en: The process of LDM also allows for the de-normalization at the logical design
    level. This is allowed so that analysts can avoid significant known performance
    problems before the physical database is completed. De-normalization should occur
    at the user interface time, as many of the issues will depend on the user’s needs
    and the expansion of IoT and blockchain. Another important issue is the reduction
    in natural keys that are being replaced with hash algorithms to protect security.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: LDM的过程还允许在逻辑设计级别进行反规范化。这是为了分析员能够在物理数据库完成之前避免重大已知性能问题。反规范化应在用户界面时间发生，因为许多问题将取决于用户的需求和物联网和区块链的扩展。另一个重要问题是减少正在被哈希算法替换以保护安全性的自然键。
- en: 4.15 Problems and Exercises
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.15 问题和练习
- en: '1.'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '1.'
- en: What is Logical Data Modeling trying to accomplish?
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 逻辑数据建模试图实现什么？
- en: '2.'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '2.'
- en: Define Normalization. What are the three Normal Forms?
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 定义规范化。什么是三个范式？
- en: '3.'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '3.'
- en: What does Normalization not do?
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 规范化不能做什么？
- en: '4.'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '4.'
- en: What is meant by the term “derived” data element?
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: “衍生”数据元素一词是什么意思？
- en: '5.'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '5.'
- en: Describe the concept of combining user views. What are the political ramifications
    of doing this in many organizations?
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 描述结合用户视图的概念。在许多组织中这样做有什么政治影响？
- en: '6.'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '6.'
- en: What are Legacy Links? Describe how they can be used to enforce data integrity.
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 什么是传统链接？描述它们如何用于强制执行数据完整性。
- en: '7.'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '7.'
- en: Name and define the three types of Business Rules.
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 命名并定义三种业务规则类型。
- en: '8.'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '8.'
- en: Why are Stored Procedures in some ways a contradiction to the rule that data
    and processes need to be separated?
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为什么存储过程在某种程度上违反了数据和过程需要分开的规则？
- en: '9.'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '9.'
- en: What are the disadvantages of database triggers?
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 数据库触发器的缺点是什么？
- en: '10.'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '10.'
- en: What is meant by De-Normalization? Is this a responsibility of the analyst?
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: “反规范化”是什么意思？这是分析员的责任吗？
- en: '4.16 Mini-project #1'
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.16 迷你项目#1
- en: 'The Physician Master File from a DFD contains the following data elements:![../images/480347_1_En_4_Chapter/480347_1_En_4_Fige_HTML.png](../images/480347_1_En_4_Chapter/480347_1_En_4_Fige_HTML.png)Assumptions:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 数据流图中的医生主文件包含以下数据元素：![../images/480347_1_En_4_Chapter/480347_1_En_4_Fige_HTML.png](../images/480347_1_En_4_Chapter/480347_1_En_4_Fige_HTML.png)假设：
- en: a.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a.
- en: A Physician can be associated with many hospitals, but must be associated with
    at least one.
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个医生可以与许多医院相关联，但必须至少与一个相关联。
- en: b.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b.
- en: A Physician can have many specialties, or have no specialty.
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 医生可以有多种专长，也可以没有专长。
- en: 'Assignment: Normalize to 3rd Normal Form.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 分配：归一化为第三范式。
- en: '4.17 Mini-project #2'
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '4.17 迷你项目 #2'
- en: The following enrollment form has been obtained from Southeast University’s
    Computer Science program:![../images/480347_1_En_4_Chapter/480347_1_En_4_Figf_HTML.png](../images/480347_1_En_4_Chapter/480347_1_En_4_Figf_HTML.png)The
    students are choosing their courses from the following Course List:![../images/480347_1_En_4_Chapter/480347_1_En_4_Figg_HTML.png](../images/480347_1_En_4_Chapter/480347_1_En_4_Figg_HTML.png)
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从东南大学计算机科学专业获取的注册表单：![../images/480347_1_En_4_Chapter/480347_1_En_4_Figf_HTML.png](../images/480347_1_En_4_Chapter/480347_1_En_4_Figf_HTML.png)学生们从以下课程列表中选择他们的课程：![../images/480347_1_En_4_Chapter/480347_1_En_4_Figg_HTML.png](../images/480347_1_En_4_Chapter/480347_1_En_4_Figg_HTML.png)
- en: 'Assignment: Using the above form, create a normalized ERD. Make sure you are
    in 3rd Normal Form.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 分配：使用上述形式，创建一个归一化的ERD。确保你处于第三范式。
- en: '**HINT**: You should end up with at least four entities, possibly five.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**：最终你应该至少有四个实体，可能是五个。'
