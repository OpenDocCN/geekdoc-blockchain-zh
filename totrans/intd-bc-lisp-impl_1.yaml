- en: © The Author(s), under exclusive license to APress Media, LLC, part of Springer
    Nature 2021B. SitnikovskiIntroducing Blockchain with Lisp[https://doi.org/10.1007/978-1-4842-6969-5_1](https://doi.org/10.1007/978-1-4842-6969-5_1)
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: © 作者授权 APress Media, LLC, Springer Nature 2021B. Sitnikovski与Lisp介绍区块链[https://doi.org/10.1007/978-1-4842-6969-5_1](https://doi.org/10.1007/978-1-4842-6969-5_1)
- en: 1. Introduction to Blockchain
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1. 区块链简介
- en: Boro Sitnikovski^([1](#Aff2)  )(1)Skopje, North Macedonia![../images/510363_1_En_1_Chapter/510363_1_En_1_Figa_HTML.jpg](../images/510363_1_En_1_Chapter/510363_1_En_1_Figa_HTML.jpg)
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Boro Sitnikovski^([1](#Aff2)  )(1)北马其顿斯科普里![../images/510363_1_En_1_Chapter/510363_1_En_1_Figa_HTML.jpg](../images/510363_1_En_1_Chapter/510363_1_En_1_Figa_HTML.jpg)
- en: '*The blockchain bazaar, by D. Bozhinovski*'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*《区块链集市》，作者 D. Bozhinovski*'
- en: This chapter introduces some important blockchain definitions and examples.
    We will see what properties a blockchain has, what it allows us to do, and what
    it is good for.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了一些重要的区块链定义和示例。我们将看到区块链具有哪些属性，它允许我们做什么，以及它有什么用处。
- en: '![../images/510363_1_En_1_Chapter/510363_1_En_1_Figb_HTML.gif](../images/510363_1_En_1_Chapter/510363_1_En_1_Figb_HTML.gif)
    Definition 1-1'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '![../images/510363_1_En_1_Chapter/510363_1_En_1_Figb_HTML.gif](../images/510363_1_En_1_Chapter/510363_1_En_1_Figb_HTML.gif)
    定义 1-1'
- en: '**Blockchain** is a system in which a record of transactions is maintained
    across several computers that are linked in a peer-to-peer network.^([1](#Fn1))'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '**区块链** 是一个在多台计算机之间维护交易记录的系统，这些计算机连接在一个点对点网络中^([1](#Fn1))。'
- en: We will give an example that will serve as a motivation, as well as define what
    encryption and hashing techniques are and how can they help us with our system.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将提供一个示例，作为动机，并定义加密和哈希技术是什么，以及它们如何帮助我们的系统。
- en: Note that we will hand-wave some of the technical bits in this chapter, as it
    serves as introductory material. The technical bits will be uncovered later when
    we start building the blockchain.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在本章中，我们会简化一些技术细节，因为它作为介绍材料。当我们开始构建区块链时，技术细节将被揭示。
- en: 1.1 Motivation and Basic Definitions
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.1 动机和基本定义
- en: Let’s assume that you and your friends exchange money often, for example, when
    paying for dinner or drinks. It can be inconvenient to exchange cash all the time.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你和你的朋友经常交换钱，例如，在付账或喝酒时。一直用现金交换可能不太方便。
- en: One possible solution is to keep records of all the bills that you and your
    friends have. This is called a *ledger* and is depicted in Figure [1-1](#Fig1).![../images/510363_1_En_1_Chapter/510363_1_En_1_Fig1_HTML.jpg](../images/510363_1_En_1_Chapter/510363_1_En_1_Fig1_HTML.jpg)
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可能的解决方案是记录你和你的朋友所欠的所有账单。这被称为*分类账*，在图 [1-1](#Fig1) 中有所描述。![../images/510363_1_En_1_Chapter/510363_1_En_1_Fig1_HTML.jpg](../images/510363_1_En_1_Chapter/510363_1_En_1_Fig1_HTML.jpg)
- en: Figure 1-1
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-1
- en: A ledger and a set of connected friends (peers)
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一个分类账和一组连接的朋友（同行）
- en: '![../images/510363_1_En_1_Chapter/510363_1_En_1_Figc_HTML.gif](../images/510363_1_En_1_Chapter/510363_1_En_1_Figc_HTML.gif)
    Definition 1-2'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '![../images/510363_1_En_1_Chapter/510363_1_En_1_Figc_HTML.gif](../images/510363_1_En_1_Chapter/510363_1_En_1_Figc_HTML.gif)
    定义 1-2'
- en: A **ledger** is a book that contains a record of transactions.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**分类帐**是一本包含交易记录的书籍。'
- en: Further, at the end of every day, you all sit together and refer to the ledger
    to do the calculations to settle up. Let’s imagine that there is a pot, which
    is the place where all of the money is kept. If you spent more than you received,
    you put money into the pot; otherwise, you take money out.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，每天结束时，你们都会坐在一起并参考分类帐进行计算以结算账目。让我们想象一下，有一个罐子，那是存放所有钱的地方。如果你花费的比你收到的多，你就把钱放进罐子里；否则，你就拿出钱来。
- en: We want to design a system that functions similarly to a regular bank account.
    A holder of a wallet (the bank account) should only be able to send money from
    their wallet to other wallets. Thus, every person in the system will have a *wallet*
    of a kind, which can also be used to determine their balance. Note that with the
    current setup using a ledger, we have to go through all existing records to determine
    the balance of a specific wallet.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望设计一个类似于常规银行账户的系统。一个钱包的持有人（银行账户）只能从他们的钱包向其他钱包发送资金。因此，系统中的每个人都将拥有一种*钱包*，这也可以用来确定他们的余额。请注意，使用当前设置使用分类帐，我们必须查看所有现有记录才能确定特定钱包的余额。
- en: If we want to avoid going through all existing records, there is a way we can
    optimize this, using *unspent transaction outputs* (UTXOs)  , as we will see in
    Section 3.5.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想避免查看所有现有记录，我们可以通过使用*未花费的交易输出*（UTXOs）来优化，正如我们将在第 3.5 节中看到的那样。
- en: A problem that may arise is the so-called *double-spending* problem, where Bob
    can try to send all of his money to Alice and you at the same time. This would
    effectively double the money he sends in relation to what he has. There are several
    ways this can be resolved, and the solution that we will provide will be a simple
    check of the sum of the inputs and the sum of the outputs (UTXO).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 可能出现的问题是所谓的*双重支付*问题，其中 Bob 可以试图同时向 Alice 和你发送所有的钱。这实际上会使他发送的金额翻倍。有几种方法可以解决这个问题，我们将提供的解决方案是对输入和输出（UTXO）的金额进行简单的检查。
- en: Another problem that might appear with this kind of system is that anyone can
    add a transaction. For example, Bob can add a transaction in which Alice pays
    him a few dollars without Alice’s approval. We need to rethink our system so that
    each transaction will be verified/signed.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型系统可能出现的另一个问题是任何人都可以添加交易。例如，Bob 可以添加一笔交易，其中 Alice 向他支付几美元，而不需要 Alice 的批准。我们需要重新思考我们的系统，使每笔交易都经过验证/签名。
- en: '![../images/510363_1_En_1_Chapter/510363_1_En_1_Figd_HTML.gif](../images/510363_1_En_1_Chapter/510363_1_En_1_Figd_HTML.gif)
    Definition 1-3'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '![../images/510363_1_En_1_Chapter/510363_1_En_1_Figd_HTML.gif](../images/510363_1_En_1_Chapter/510363_1_En_1_Figd_HTML.gif)
    定义 1-3'
- en: A **digital signature** is a way to verify the authenticity of digital messages
    and documents.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**数字签名**是验证数字消息和文档真实性的一种方式。'
- en: To sign and verify transactions, we will rely on digital signatures (Figure
    [1-2](#Fig2)). For now, let’s assume that anyone who adds information to the ledger
    also adds a signature with each record, and others have no way to modify the signature,
    but can only verify it. We will cover the technical details in Section 1.2.![../images/510363_1_En_1_Chapter/510363_1_En_1_Fig2_HTML.jpg](../images/510363_1_En_1_Chapter/510363_1_En_1_Fig2_HTML.jpg)
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了签署和验证交易，我们将依赖数字签名（图[1-2](#Fig2)）。现在，让我们假设将信息添加到账本的任何人也都会在每个记录上添加一个签名，其他人无法修改签名，只能验证签名。我们将在1.2节中详细介绍技术细节。![../images/510363_1_En_1_Chapter/510363_1_En_1_Fig2_HTML.jpg](../images/510363_1_En_1_Chapter/510363_1_En_1_Fig2_HTML.jpg)
- en: Figure 1-2
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-2
- en: Our ledger now contains signatures
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的账本现在包含了签名
- en: Now let’s assume that Bob is keeping the ledger to himself, and everybody agrees
    to this. The ledger is now stored in what is called a *centralized place* . If
    Bob is unavailable at the end of the day when everybody gathers to settle up,
    nobody will be able to refer to the ledger.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设 Bob 将账本保留给自己，并且所有人都同意这一点。账本现在存储在所谓的*中心化位置*。如果当大家在一天结束时聚在一起结算时，Bob 不可用，那么没有人将能够参考账本。
- en: We need to find a way to decentralize the ledger, so that at any given time,
    anyone can make a transaction. For this, every person involved will keep a copy
    of the ledger to themselves, and when they meet at the end of the day, they will
    sync their ledgers.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要找到一种去中心化账本的方法，以便在任何时候，任何人都可以进行交易。为此，每个参与者将保留账本的副本，并在一天结束时同步他们的账本。
- en: You are connected to your friends, and so are they to you. Informally, this
    makes it a peer-to-peer network.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你和你的朋友们连接在一起，他们也连接在你身上。非正式地说，这使得它成为一个点对点网络。
- en: '![../images/510363_1_En_1_Chapter/510363_1_En_1_Fige_HTML.gif](../images/510363_1_En_1_Chapter/510363_1_En_1_Fige_HTML.gif)
    Definition 1-4'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '![../images/510363_1_En_1_Chapter/510363_1_En_1_Fige_HTML.gif](../images/510363_1_En_1_Chapter/510363_1_En_1_Fige_HTML.gif)
    定义 1-4'
- en: A **peer-to-peer network** is formed when two or more computers are connected
    to each other.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当两台或更多计算机相互连接时，形成了一个**点对点网络**。
- en: For example, when you are accessing a web page on the Internet using a browser,
    your browser is the “client” and the web page you’re accessing is hosted by a
    “server.” This represents a centralized system since every user is getting the
    information from a single place—the “server.”
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当你使用浏览器在互联网上访问网页时，你的浏览器是“客户端”，而你正在访问的网页是由“服务器”托管的。这代表着一种集中化系统，因为每个用户都是从一个地方——“服务器”获取信息的。
- en: In contrast, in a peer-to-peer network—which represents a decentralized system—the
    distinction between a “client” and a “server” is blurred. Every peer is both a
    “client” and a “server” at the same time.![../images/510363_1_En_1_Chapter/510363_1_En_1_Fig3_HTML.jpg](../images/510363_1_En_1_Chapter/510363_1_En_1_Fig3_HTML.jpg)
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在对比之下，在点对点网络——代表着一种分散化系统——“客户端”和“服务器”的区分变得模糊。每个对等方同时是“客户端”和“服务器”。![../images/510363_1_En_1_Chapter/510363_1_En_1_Fig3_HTML.jpg](../images/510363_1_En_1_Chapter/510363_1_En_1_Fig3_HTML.jpg)
- en: Figure 1-3
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-3
- en: A decentralized ledger
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一个去中心化账本
- en: With a decentralized system (see Figure [1-3](#Fig3)), as the list of peers
    (persons) grows, we might run into a problem of *trust* . When everybody meets
    at the end of the day to sync their ledgers, how can they believe that the transactions
    listed in other people’s ledgers are true? Even if everybody trusts everybody
    else’s ledger, what if a new person wants to join this network? It’s natural for
    existing users to ask this newcomer to prove that they can be trusted. We need
    to modify our system to support this kind of trust. One way to achieve that is
    through a *proof of work*, which we introduce next.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个去中心化系统中（参见图[1-3](#Fig3)），随着节点（人员）列表的增长，我们可能会遇到*信任*问题。当每个人在一天结束时同步他们的账本时，他们如何相信其他人账本中列出的交易是真实的？即使每个人都相信其他人的账本，但如果一个新人想要加入这个网络呢？现有用户自然会要求这位新来者证明他们是可信的。我们需要修改我们的系统以支持这种信任。我们引入*工作证明*，是实现这种信任的一种方式，接下来我们会介绍它。
- en: '![../images/510363_1_En_1_Chapter/510363_1_En_1_Figf_HTML.gif](../images/510363_1_En_1_Chapter/510363_1_En_1_Figf_HTML.gif)
    Definition 1-5'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '![../images/510363_1_En_1_Chapter/510363_1_En_1_Figf_HTML.gif](../images/510363_1_En_1_Chapter/510363_1_En_1_Figf_HTML.gif)
    定义1-5'
- en: A **proof of work** is data that is time-consuming to calculate, and easy for
    others to verify.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**工作证明**是一种耗时计算的数据，易于他人验证。'
- en: For each record we will also include a special number (or a hash) that will
    represent *proof of work*, in that it will provide proof that the transaction
    is valid. We will cover the technical details in Section 1.3.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每条记录，我们还将包括一个特殊的数字（或哈希），它将表示*工作证明*，即它将提供证明交易是有效的。我们将在第1.3节中详细介绍技术细节。
- en: At the end of the day, we agree that we will trust the ledger of the person
    who has put most of the work in it. If Bob has some errands to run, he can catch
    up the next day by trusting the rest of the peers in the network.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在一天结束时，我们同意我们将信任将大部分工作投入其中的人的账本。如果Bob有一些差事要处理，他可以在第二天通过相信网络中的其他节点来赶上进度。
- en: In addition to all this, we want the transactions to have an order, so every
    record will also contain a link to the previous record. This represents the actual
    blockchain, as depicted in Figure [1-4](#Fig4).![../images/510363_1_En_1_Chapter/510363_1_En_1_Fig4_HTML.jpg](../images/510363_1_En_1_Chapter/510363_1_En_1_Fig4_HTML.jpg)
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，我们希望交易有一个顺序，因此每条记录还将包含到前一条记录的链接。这代表了实际的区块链，如图[1-4](#Fig4)所示。![../images/510363_1_En_1_Chapter/510363_1_En_1_Fig4_HTML.jpg](../images/510363_1_En_1_Chapter/510363_1_En_1_Fig4_HTML.jpg)
- en: Figure 1-4
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-4
- en: A chain of blocks, aptly called a blockchain
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一个区块链，恰如其名
- en: If everybody agreed to use this ledger as a source of truth, there would be
    no need to exchange physical money at all. Everybody can just use the ledger to
    put money in or retrieve it.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果每个人都同意使用这个账本作为真相的来源，那么根本就不需要交换实体货币。每个人只需使用账本来存入或取回钱。
- en: To understand the technical bits of digital signatures and proof of work, we
    will be looking at encryption and hashing, respectively. Fortunately for us, the
    programming language that we will be using has built-in functionalities for encryption
    and hashing. We don’t have to dig too deep into how hashing and encryption and
    decryption work, because a basic understanding will be sufficient.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Observe how we started with a simple definition of a ledger and gradually built
    up to a complex system. We will use the same approach in programming.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 1.2 Encryption
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will start by defining encryption and decryption.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '![../images/510363_1_En_1_Chapter/510363_1_En_1_Figg_HTML.gif](../images/510363_1_En_1_Chapter/510363_1_En_1_Figg_HTML.gif)
    Definition 1-6'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '**Encryption** is a method of encoding values so that only authorized persons
    can view the original content. **Decryption** is a method of decoding encrypted
    values.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Note that in this section we will mostly talk about numbers, but characters
    and letters can also be encrypted/decrypted using the same methods, by using the
    ASCII^([2](#Fn2)) values for the characters.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Before we talk about encryption, we first have to recall what *functions* are,
    since encoding/decoding values is achieved by using functions.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 1.2.1 Functions
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Figure [1-5](#Fig5) shows a visual representation of a function  . An input
    goes in the function and an output is produced.![../images/510363_1_En_1_Chapter/510363_1_En_1_Fig5_HTML.jpg](../images/510363_1_En_1_Chapter/510363_1_En_1_Fig5_HTML.jpg)
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1-5
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: A function
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '![../images/510363_1_En_1_Chapter/510363_1_En_1_Figh_HTML.gif](../images/510363_1_En_1_Chapter/510363_1_En_1_Figh_HTML.gif)
    Definition 1-7'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '**Functions** are mathematical entities that assign unique outputs to given
    inputs.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you might have a function that accepts as input a person and then
    returns the person’s age or name as the output. Another example is the function
    f(x) = x + 1. There are many inputs this function can accept: 1, 2, and 3.14\.
    For example, when we input 2 it gives us an output of 3, since f(2) = 2 + 1 =
    3.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可能有一个接受人员作为输入然后返回人员年龄或姓名作为输出的函数。另一个例子是函数 f(x) = x + 1。这个函数可以接受许多输入：1、2 和
    3.14。例如，当我们输入 2 时，它会给我们一个输出 3，因为 f(2) = 2 + 1 = 3。
- en: 'One simple way to think of functions is in the form of tables. For a function
    f(x) accepting a single argument *x*, we have a two-column table where the first
    column is the input and the second column is the output  . For a function f(x,
    y) that’s accepting two arguments *x* and *y,* we have a three-column table where
    the first and second columns represent the input, and the third column is the
    output. Thus, to display the function discussed above in the form of a table,
    it would look like this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一种简单的理解函数的方式是以表格形式呈现。对于接受单个参数 *x* 的函数 f(x)，我们有一个两列的表格，第一列是输入，第二列是输出。对于接受两个参数
    *x* 和 *y* 的函数 f(x, y)，我们有一个三列的表格，其中第一列和第二列表示输入，第三列是输出。因此，要以表格形式显示上述讨论的函数，它看起来像这样：
- en: '| **x** | ***f*****(*****x*****)** |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| **x** | ***f*****(*****x*****)** |'
- en: '| --- | --- |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 1 | 2 |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 2 |'
- en: '| 2 | 3 |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 3 |'
- en: '| … | … |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| … | … |'
- en: 1.2.2 Symmetric-Key Algorithm
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.2 对称密钥算法
- en: 'We can assume  that there exist functions *E*(*x*) and *D*(*x*) for encryption
    and decryption, respectively. We want these functions to have the following properties:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以假设存在加密函数 *E*(*x*) 和解密函数 *D*(*x*)。我们希望这些函数具有以下属性：
- en: '*E*(*x*) ≠ *x*, meaning that the encrypted value should not be the same as
    the original value.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*E*(*x*) ≠ *x*，意味着加密后的值不应该与原始值相同。'
- en: '*E*(*x*) ≠ *D*(*x*), meaning that the encryption and decryption functions produce
    different values.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*E*(*x*) ≠ *D*(*x*)，意味着加密和解密函数生成不同的值。'
- en: '*D*(*E*(*x*)) = *x*, meaning that the decryption of an encrypted value should
    return the original value.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*D*(*E*(*x*)) = *x*，意味着加密值的解密应该返回原始值。'
- en: For example, let’s assume there’s some kind of an encryption scheme, say E(“Boro”)
    = 426f726f. We can “safely” communicate the value 426f726f without actually exposing
    our original value, and only those who know the decryption scheme D(x) will be
    able to see that D(426f726f) = “Boro”.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设有一种加密方案，比如 E(“Boro”) = 426f726f。我们可以“安全地”传递值 426f726f，而不会实际暴露我们的原始值，只有那些知道解密方案
    D(x) 的人才能看到 D(426f726f) = “Boro”。
- en: Another example of an encryption scheme is for *E*(*x*) to shift every character
    in *x* forward, and for *D*(*x*) to shift every character in *x* backward. This
    scheme is known as the *Caesar cipher*. To encrypt the text “abc” we have E(“abc”)
    = “bcd”, and to decrypt it, we have D(“bcd”) = “abc”.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个加密方案的例子是 *E*(*x*) 将 *x* 中的每个字符向前移动，*D*(*x*) 将 *x* 中的每个字符向后移动。这种方案称为凯撒密码。要加密文本
    “abc”，我们有 E(“abc”) = “bcd”，要解密它，我们有 D(“bcd”) = “abc”。
- en: However, this scheme makes a *symmetric algorithm*, as shown in Figure [1-6](#Fig6),
    meaning that we have to share the functions E and D with the parties involved.
    That makes it open to attacks.![../images/510363_1_En_1_Chapter/510363_1_En_1_Fig6_HTML.jpg](../images/510363_1_En_1_Chapter/510363_1_En_1_Fig6_HTML.jpg)
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个方案制造了一个*对称算法*，如图[1-6](#Fig6)所示，这意味着我们必须与涉及的各方分享函数 E 和 D。这使得它容易受到攻击。![../images/510363_1_En_1_Chapter/510363_1_En_1_Fig6_HTML.jpg](../images/510363_1_En_1_Chapter/510363_1_En_1_Fig6_HTML.jpg)
- en: Figure 1-6
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-6
- en: Symmetric-key algorithm
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 对称密钥算法
- en: 1.2.3 Asymmetric-Key Algorithm
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.3 非对称密钥算法
- en: 'To solve the problems that arise with symmetric-key algorithms, we will use
    what is called an *asymmetric algorithm* or *public-key cryptography* (Figure
    [1-7](#Fig7)). In this scheme, we have two kinds of keys: public and private.
    We share the public key with the world and keep the private one to ourselves.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决对称密钥算法引发的问题，我们将使用所谓的*非对称算法*或*公钥密码*（见图[1-7](#Fig7)）。在这个方案中，我们有两种类型的密钥：公钥和私钥。我们与世界分享公钥，并保留私钥给自己。
- en: This algorithm scheme has a neat property in which only the private key can
    decode a message, and only the public key can encode a message.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法方案具有一个很好的属性，即只有私钥才能解码消息，而只有公钥才能编码消息。
- en: 'We have two functions that should have the same properties as those for the
    symmetric-key algorithm:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个函数，应该具有与对称密钥算法相同的属性：
- en: '*E*(*x*, *p*) encrypts a message *x* given a public key *p*'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*E*(*x*, *p*) 用公钥 *p* 加密消息 *x*'
- en: '*D*(*x*′, s) decrypts an encrypted message *x*′ given a private (secret) key
    *s*'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*D*(*x*′, *s*) 解密使用私钥（秘密） *s* 加密的消息 *x*′'
- en: '![../images/510363_1_En_1_Chapter/510363_1_En_1_Fig7_HTML.jpg](../images/510363_1_En_1_Chapter/510363_1_En_1_Fig7_HTML.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![../images/510363_1_En_1_Chapter/510363_1_En_1_Fig7_HTML.jpg](../images/510363_1_En_1_Chapter/510363_1_En_1_Fig7_HTML.jpg)'
- en: Figure 1-7
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-7
- en: Asymmetric-key algorithm
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 非对称密钥算法
- en: In our example, we will rely on the modulo operation. Recall, from high school,
    that *a* mod *b* represents the remainder when *a* is divided by *b*. For example,
    4 mod 2 = 0 because there is no remainder when dividing 4 by 2, however, 5 mod
    2 = 1.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们将依赖于模运算。回想一下，从高中开始，*a* mod *b* 表示当 *a* 被 *b* 整除时的余数。例如，4 mod 2 = 0，因为当4除以2时没有余数，然而，5
    mod 2 = 1。
- en: 'Here’s one example of a basic encryption algorithm based on addition and modulo
    operations:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个基于加法和模运算的基本加密算法的示例：
- en: '1.'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '1.'
- en: Pick one random number, for example 100\. This will represent a common, publicly
    available key.
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 选择一个随机数，例如 100。这将代表一个常见的，公开可用的密钥。
- en: '2.'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '2.'
- en: Pick another random number in the range (1, 100), for example, 97\. This will
    represent the private key *s*.
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在范围 (1, 100) 中选择另一个随机数，例如，97。这将代表私钥 *s*。
- en: '3.'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '3.'
- en: 'The public key *p* is obtained by subtracting the common key from the private
    one: 100 − 97 = 3.'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 公钥 *p* 是通过从私钥中减去常见密钥得到的：100 − 97 = 3。
- en: '4.'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '4.'
- en: To encrypt data, add it to the public key and the take modulo 100\. *E*(*x*,
    *p*) = (*x* + *p*) mod 100.
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要加密数据，将其加到公钥上，然后取模 100。*E*(*x*, *p*) = (*x* + *p*) mod 100。
- en: '5.'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '5.'
- en: To decrypt data, we use the same logic but with our private key, so *D*(*x*′,
    *s*) = (*x*′ + *s*) mod 100.
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要解密数据，我们使用相同的逻辑，但是使用我们的私钥，所以 *D*(*x*′, *s*) = (*x*′ + *s*) mod 100。
- en: For example, suppose we want to encrypt 5\. Then *E*(5, 3) = (5 + 3) mod 100
    = 8\. To decrypt 8, we have *D*(8, 97) = (8 + 97) mod 100 = 105 mod 100 = 5.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们想要加密 5。那么 *E*(5, 3) = (5 + 3) mod 100 = 8。要解密 8，我们有 *D*(8, 97) = (8 +
    97) mod 100 = 105 mod 100 = 5。
- en: 'This example uses a very simple generation pair: (*x* + *y*) mod *c*. But,
    in practice, the pair-generation algorithm is much more complex and harder for
    attackers to break. After all, the complexity of the algorithm’s computation is
    what makes it hard to break.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子使用了一个非常简单的生成对：(*x* + *y*) mod *c*。但是，在实践中，生成对算法要复杂得多，对攻击者更难以突破。毕竟，算法计算的复杂性是导致其难以破解的原因。
- en: 'We can use a similar algorithm for digital signatures:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用类似的算法进行数字签名：
- en: '*S*(*x*, *s*) signs a message *x* given a private key *s* (encryption).'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*S*(*x*, *s*) 使用私钥 *s* 对消息 *x* 进行签名（加密）。'
- en: '*V*(*x*′, *sig*, *p*) verifies a signed message *x*′, given signature sig and
    public key *p* (decryption).'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*V*(*x*′, *sig*, *p*) 使用签名 *sig* 和公钥 *p* 验证已签名的消息 *x*′（解密）。'
- en: As we said earlier, each record will also include a special number (or a hash).
    This hash will be what is produced by *S*(*x*, *s*) (encryption), and it can be
    verified by using the verify function to confirm a record’s ownership (decryption).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所说，每个记录还将包括一个特殊数字（或哈希）。这个哈希将由 *S*(*x*, *s*)（加密）生成，并且可以通过使用验证函数来确认记录的所有权（解密）。
- en: The wallet will contain a pair of public and private keys. These keys will be
    used to receive or send money. With the private key, it is possible to write new
    blocks (or transactions) to the blockchain, effectively spending money. With the
    public key, others can use it to send money to the wallet and verify signatures.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 钱包将包含一对公钥和私钥。这些密钥将用于接收或发送货币。有了私钥，就可以向区块链写入新块（或交易），有效地花费货币。有了公钥，其他人可以使用它向钱包发送货币并验证签名。
- en: '![../images/510363_1_En_1_Chapter/510363_1_En_1_Figi_HTML.gif](../images/510363_1_En_1_Chapter/510363_1_En_1_Figi_HTML.gif)
    Exercise 1-1'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '![../images/510363_1_En_1_Chapter/510363_1_En_1_Figi_HTML.gif](../images/510363_1_En_1_Chapter/510363_1_En_1_Figi_HTML.gif)
    练习 1-1'
- en: 'Come up with a table of functions such that:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 想出一个函数表，使得：
- en: '1.'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '1.'
- en: The input is a number and the output is a number.
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输入是一个数字，输出也是一个数字。
- en: '2.'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '2.'
- en: The input is a number and the output is the name of an employee in a company
    given that number.
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输入是一个数字，输出是公司员工的名字，给定该数字。
- en: '![../images/510363_1_En_1_Chapter/510363_1_En_1_Figj_HTML.gif](../images/510363_1_En_1_Chapter/510363_1_En_1_Figj_HTML.gif)**Exercise
    1-2**'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '![../images/510363_1_En_1_Chapter/510363_1_En_1_Figj_HTML.gif](../images/510363_1_En_1_Chapter/510363_1_En_1_Figj_HTML.gif)**练习
    1-2**'
- en: Check the three properties for a symmetric-key algorithm to ensure that the
    Caesar cipher is compatible with them.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 检查对称密钥算法的三个属性，以确保凯撒密码与它们兼容。
- en: '![../images/510363_1_En_1_Chapter/510363_1_En_1_Figk_HTML.gif](../images/510363_1_En_1_Chapter/510363_1_En_1_Figk_HTML.gif)**Exercise
    1-3**'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '![../images/510363_1_En_1_Chapter/510363_1_En_1_Figk_HTML.gif](../images/510363_1_En_1_Chapter/510363_1_En_1_Figk_HTML.gif)**练习
    1-3**'
- en: Come up with an encryption scheme, based on mathematical substitution.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 设计一种基于数学替换的加密方案。
- en: '![../images/510363_1_En_1_Chapter/510363_1_En_1_Figl_HTML.gif](../images/510363_1_En_1_Chapter/510363_1_En_1_Figl_HTML.gif)**Exercise
    1-4**'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '![../images/510363_1_En_1_Chapter/510363_1_En_1_Figl_HTML.gif](../images/510363_1_En_1_Chapter/510363_1_En_1_Figl_HTML.gif)**练习
    1-4**'
- en: Use the asymmetric-key algorithm we defined to sign a message and verify it.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们定义的非对称密钥算法对消息进行签名和验证。
- en: '**Hint**: This is similar to the encryption/decryption example that we showed.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**：这类似于我们展示的加密/解密示例。'
- en: 1.3 Hashing
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.3 哈希运算
- en: '![../images/510363_1_En_1_Chapter/510363_1_En_1_Figm_HTML.gif](../images/510363_1_En_1_Chapter/510363_1_En_1_Figm_HTML.gif)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![../images/510363_1_En_1_Chapter/510363_1_En_1_Figm_HTML.gif](../images/510363_1_En_1_Chapter/510363_1_En_1_Figm_HTML.gif)'
- en: Definition 1-8
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 1-8
- en: '**Hashing** is a one-way function in that it encodes text without a way to
    retrieve the original value.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**哈希运算**是一种单向函数，它对文本进行编码，没有办法检索到原始值。'
- en: Hashing is simpler than the previously described encryption schemes. One example
    of a hashing function is to return the length of characters - *H*(“abc”) = 3,
    but also *H*(“bcd”) = 3\. This means that we don’t have a way to retrieve the
    original value other than by using the return value 3.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希运算比之前描述的加密方案更简单。一个哈希函数的例子是返回字符长度的函数 - *H*（“abc”）= 3，但是 *H*（“bcd”）= 3。这意味着我们没有办法通过除了使用返回值3之外的其他方式检索原始值。
- en: As we mentioned earlier, the reason to use such a technique is that it has some
    interesting properties, such as providing us with proof of work.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，使用这种技术的原因是它具有一些有趣的特性，比如为我们提供工作证明。
- en: '![../images/510363_1_En_1_Chapter/510363_1_En_1_Fign_HTML.gif](../images/510363_1_En_1_Chapter/510363_1_En_1_Fign_HTML.gif)
    Definition 1-9'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '![../images/510363_1_En_1_Chapter/510363_1_En_1_Fign_HTML.gif](../images/510363_1_En_1_Chapter/510363_1_En_1_Fign_HTML.gif)
    定义 1-9'
- en: '**Mining** is the process of validating transactions. For this effort, successful
    miners obtain money as a reward.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**挖矿**是验证交易的过程。成功的挖矿者将获得货币作为奖励。'
- en: Hashcash is one kind of a proof of work system.^([3](#Fn3)) We will use it to
    implement mining. We will see how this algorithm works in detail in the later
    chapters, when we implement it.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Hashcash是一种工作量证明系统的一种。^([3](#Fn3)) 我们将使用它来实现挖矿。在后面的章节中，当我们实现它时，我们将详细了解此算法的工作原理。
- en: Hashing functions have another useful property that allows us to connect two
    or more distinct blocks by having the information about the current block’s hash
    (current-hash) and the previous block’s hash (previous-hash) in each block. For
    example, block-1 may have a hash such as 123456 and block-2 may have a hash such
    as 345678\. Now, block-2’s previous-hash will be block-1’s current-hash, that
    is, 123456\. Here, we linked these two blocks, effectively creating a linked list
    of blocks containing ledgers with transactions. This linking is depicted in Figure
    [1-4](#Fig4).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希函数还有另一个有用的属性，允许我们通过在每个块中具有当前块哈希（current-hash）和前一个块哈希（previous-hash）的信息来连接两个或更多不同的块。例如，block-1
    可能有一个哈希值，如 123456，而 block-2 可能有一个哈希值，如 345678。现在，block-2 的 previous-hash 将是 block-1
    的 current-hash，也就是 123456。在这里，我们链接了这两个块，有效地创建了一个包含交易账本的块链。此链接在图 [1-4](#Fig4) 中显示。
- en: The hash of the block is based on the block’s data itself, so to verify a hash,
    we can just hash the block’s data and compare it to current-hash.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 块的哈希基于块的数据本身，因此要验证哈希，我们只需哈希块的数据并将其与 current-hash 进行比较。
- en: Two or more blocks (or transactions) that are connected form a blockchain. The
    validity of the blockchain will depend on the validity of each transaction.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 两个或更多连接的块（或交易）形成一个区块链。区块链的有效性将取决于每个交易的有效性。
- en: '![../images/510363_1_En_1_Chapter/510363_1_En_1_Figo_HTML.gif](../images/510363_1_En_1_Chapter/510363_1_En_1_Figo_HTML.gif)
    Exercise 1-5'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '![../images/510363_1_En_1_Chapter/510363_1_En_1_Figo_HTML.gif](../images/510363_1_En_1_Chapter/510363_1_En_1_Figo_HTML.gif)
    练习 1-5'
- en: Come up with your own hashing function.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 想出自己的哈希函数。
- en: '![../images/510363_1_En_1_Chapter/510363_1_En_1_Figp_HTML.gif](../images/510363_1_En_1_Chapter/510363_1_En_1_Figp_HTML.gif)
    Exercise 1-6'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '![../images/510363_1_En_1_Chapter/510363_1_En_1_Figp_HTML.gif](../images/510363_1_En_1_Chapter/510363_1_En_1_Figp_HTML.gif)
    练习 1-6'
- en: How can the linked list depicted in Figure [1-4](#Fig4) be traversed? What are
    the implications of this property?
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图 [1-4](#Fig4) 中所示的链表如何遍历？这一特性的含义是什么？
- en: 1.4 Smart Contracts
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.4 智能合约
- en: '![../images/510363_1_En_1_Chapter/510363_1_En_1_Figq_HTML.gif](../images/510363_1_En_1_Chapter/510363_1_En_1_Figq_HTML.gif)
    Definition 1-10'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '![../images/510363_1_En_1_Chapter/510363_1_En_1_Figq_HTML.gif](../images/510363_1_En_1_Chapter/510363_1_En_1_Figq_HTML.gif)
    定义 1-10'
- en: A **smart contract** is a self-executing contract in which the conditions of
    an agreement between a buyer and a seller are directly expressed by lines of code.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**智能合约**是一种自执行的合约，其中买方和卖方之间的协议条件直接由代码行表达。'
- en: A blockchain is programmable if the transaction conditions themselves can be
    programmed by users. For example, users (not necessarily programmers) can write
    a script to add requirements that must be satisfied before sending money. It could
    look something like this:1   if (user has more than 10 money)2      then approve
    transaction3      else reject transaction
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果交易条件本身可以由用户编程，则区块链是可编程的。例如，用户（不一定是程序员）可以编写一个脚本，以添加在发送资金之前必须满足的要求。它可能看起来像这样：1   if（用户拥有超过
    10 个货币）2      then 批准交易3      else 拒绝交易
- en: Smart contracts are implemented as a computation that takes place on the blockchain.
    We will implement a very basic functionality of smart contracts in the later chapters.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约作为在区块链上进行的计算实现。我们将在后面的章节中实现智能合约的基本功能。
- en: 1.5 Bitcoin
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.5 比特币
- en: 'Bitcoin was the world’s first implementation of a blockchain. In November 2008,
    a paper authored by Satoshi Nakamoto, entitled “Bitcoin: A Peer-to-Peer Electronic
    Cash System,” was published on a cryptography mailing list. Bitcoin’s whitepaper
    is nine pages, however, it is a mostly theoretical explanation of the design,
    and as such may be a bit overwhelming to newcomers.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币是世界上第一个区块链的实现。2008年11月，中本聪（Satoshi Nakamoto）在一个密码学邮件列表上发表了一篇题为《比特币：一个点对点的电子现金系统》的论文。比特币的白皮书有九页，但它主要是对设计的理论解释，对新手来说可能有点压倒性。
- en: The Bitcoin software is open-source code and was released in January 2009 on
    SourceForge. The design of a Bitcoin includes a decentralized network (peer-to-peer
    network), block (mining), blockchain, transactions, and wallets, each of which
    we will look at in detail in this book.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币软件是开源代码，于2009年1月在SourceForge上发布。比特币的设计包括一个分散网络（点对点网络）、区块（挖矿）、区块链、交易和钱包，我们将在本书中详细讨论每个部分。
- en: Although there are many blockchain models and each differs in implementation
    details, the blockchain we will be building upon in this book will look pretty
    similar to Bitcoin, with some parts simplified.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有许多区块链模型，每个模型在实现细节上都有所不同，但我们在本书中将建立在比特币基础上的区块链看起来与比特币相似，只是有些部分被简化了。
- en: 1.6 Example Workflows
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.6 示例工作流程
- en: We will list a few important workflows that our system will use, among others.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将列举一些重要的工作流程，这些工作流程是我们的系统将要使用的，除此之外还有其他的。
- en: '*Mining a block* creates a new block, using Hashcash to calculate the current-hash
    of the block. It also contains previous-hash, which is a link to the previous
    block in the blockchain.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 挖掘一个区块将创建一个新区块，使用Hashcash计算当前区块的哈希值。它还包含了先前的哈希值，这是链中上一个区块的链接。
- en: '*Checking a wallet balance* for person A will first filter all blocks in the
    blockchain (sender = A or receiver = A) and then sum them to calculate the balance.
    The more our blockchain grows, the longer this operation will take. For that purpose,
    we will use the unspent transaction outputs (UTXO) model. This model is a list
    of transactions containing information about the owner and the amount of money.
    Thus, every transaction will consume elements from this list.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 对于个人A检查钱包余额，首先会过滤区块链中的所有区块（发送方=A或接收方=A），然后将它们求和以计算余额。我们的区块链增长得越多，这个操作就会花费越长的时间。为此，我们将使用未花费交易输出（UTXO）模型。该模型是一个包含有关所有者和金额的交易列表。因此，每个交易都将消耗该列表中的元素。
- en: '*Adding a block to a blockchain* consists of sending money from A to B. One
    prerequisite is that A has enough money. We check this using the wallet balance
    workflow. We proceed by creating a transaction (sender = A, receiver = B) and
    signing it. Then we mine a block using this transaction and update the UTXO with
    the rewards.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '*向区块链添加一个区块*包括将钱从 A 转移到 B。一个先决条件是 A 有足够的钱。我们使用钱包余额工作流来检查这一点。我们通过创建一个交易（发送方
    = A，接收方 = B）并对其进行签名来进行。然后我们使用此交易挖掘一个区块，并使用奖励更新 UTXO。'
- en: 1.7 Summary
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.7 总结
- en: The point of this chapter is to provide a vague idea of how the system that
    we will implement looks. Things will become much clearer in the implementation
    chapter (Chapter [3](510363_1_En_3_Chapter.xhtml)), where we have to be explicit
    about the definitions of every component.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的重点是提供一个大致的系统实现的概念。在实施章节（第[3](510363_1_En_3_Chapter.xhtml)章）中，我们将明确定义每个组件的定义，事情会变得更加清晰。
- en: 'Here’s briefly what we learned in this chapter:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在本章中学到的内容的简要概述：
- en: The core component of the system is a block.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统的核心组件是一个区块。
- en: A block contains (among other data) transactions.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个区块包含（除其他数据外）交易。
- en: We have a ledger that is an ordered list of all valid blocks (a blockchain).
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有一个按顺序排列的所有有效区块的分类账（区块链）。
- en: Every peer involved with the ledger has a wallet.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参与分类账的每个对等方都有一个钱包。
- en: Every record in the ledger is signed by the owner and can be verified by the
    public (digital signatures).
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分类账中的每条记录都由所有者签名，并可以由公众验证（数字签名）。
- en: The ledger is in a decentralized location, that is, everybody has a copy of
    it.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分类账位于分散的位置，即每个人都有其副本。
- en: Trust is based on proof of work (mining).
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信任基于工作证明（挖矿）。
