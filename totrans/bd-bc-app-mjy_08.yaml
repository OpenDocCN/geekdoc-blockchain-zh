- en: 'Part V: Building Your Own Blockchain'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this part of the book, I go beyond Ethereum and discuss how to build your
    own blockchains. This enables developers to bypass the virtual machine and bake
    application logic directly into the blockchain itself for maximum efficiency.
    But of course, this type of application blockchain is also much less flexible
    and adaptable than smart contract-based blockchains.
  prefs: []
  type: TYPE_NORMAL
- en: Using the open source Tendermint framework, I illustrate how to build application
    blockchains, as well as user-facing applications for those blockchains.
  prefs: []
  type: TYPE_NORMAL
- en: 19. Getting Started with Tendermint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Tendermint provides infrastructure software that allows developers to build
    their own blockchain solutions. The Tendermint approach has two unique characteristics.
  prefs: []
  type: TYPE_NORMAL
- en: Tendermint utilizes a Byzantine fault tolerant (BFT) algorithm that allows for
    up to one-third of nodes failing or behaving maliciously.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tendermint consensus is reached by designated validator nodes. There are only
    a limited number of validators on the network.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At its core, Tendermint is a high-performance and scalable consensus engine.
    As a trade-off, it is also a weakly centralized solution; it is not completely
    decentralized like Bitcoin, as it requires designated validators and is somewhat
    less fault tolerant (Bitcoin allows 49 percent of nodes to fail while Tendermint
    allows one-third).
  prefs: []
  type: TYPE_NORMAL
- en: Because Tendermint is designed as a consensus engine, it attempts to separate
    the “application logic” and “consensus logic” of blockchain applications. That
    separation allows Tendermint software to be embedded in any other blockchains
    as a drop-in consensus engine replacement; the host blockchain just needs to implement
    the Tendermint API, known as the Application BlockChain Interface (ABCI), to use
    Tendermint’s delegated proof-of-style (DPoS) consensus.
  prefs: []
  type: TYPE_NORMAL
- en: The clean separation between application and consensus logic in Tendermint makes
    it possible to build custom logic into blockchain applications. Those applications
    go far beyond the traditional smart contracts. They can utilize full stacks of
    enterprise software to handle complex application scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: The Substrate framework from Parity and Polkadot is similar to Tendermint and
    Cosmos SDK (see next chapter) in function.
  prefs: []
  type: TYPE_NORMAL
- en: How It Works
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Every node of a Tendermint blockchain needs to run two pieces of software:
    the consensus engine known as Tendermint Core and an ABCI application specifically
    written for the blockchain (see [Figure 19.1](ch19.xhtml#ch19fig1)).'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f19_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 19-1** A Tendermint blockchain node'
  prefs: []
  type: TYPE_NORMAL
- en: The Tendermint Core software is responsible for building and synchronizing the
    blockchain across the network.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ABCI application is responsible for processing and validating all transactions
    that get stored in the blockchain. Each blockchain could have a different ABCI
    application for a different application scenario or logic. For example, a blockchain
    that records cryptocurrency transactions will have a very different ABCI application
    than one that records real estate deeds.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: The ABCI application can be arbitrarily complex and written in any language
    on any software stack. In fact, it can have its own database to store and manage
    its state. In a broad sense, it is a smart contract on steroids.
  prefs: []
  type: TYPE_NORMAL
- en: It Works as Follows
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An external application sends a transaction request to any node on the network.
    The request is received by the Tendermint Core software. Notice that here we do
    not define what exactly is a transaction, as there are many different blockchain
    applications, and they have different definitions for transactions. For instance,
    some applications might define transactions as straight token exchanges, while
    others would consider recording a real-world event as a transaction. For our purposes,
    a transaction is simply a series of bytes to be recorded on the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: Upon receiving the request, the Tendermint Core software immediately forwards
    the transaction request to the ABCI application running on the same node. The
    ABCI application parses the transaction data and makes a preliminary determination
    on whether it is a validate transaction. At this stage, the transaction will not
    result in any state change (i.e., nothing gets written to the database managed
    by the ABCI application).
  prefs: []
  type: TYPE_NORMAL
- en: If the ABCI application’s preliminary determination is valid, the Tendermint
    Core software will broadcast and synchronize the transaction to all nodes on the
    network.
  prefs: []
  type: TYPE_NORMAL
- en: At a fixed time interval, the network creates a new block with all the transactions
    that are validated during this time interval. Validator nodes will vote on the
    new block, and if at least two-thirds of validator nodes agree, the new block
    will be appended to the blockchain and broadcast to all nodes on the network.
  prefs: []
  type: TYPE_NORMAL
- en: Once a new block is added to the blockchain, each node will again rerun all
    the transactions included in the block to the node’s local ABCI application for
    processing. At this time, the ABCI application can update its database to store
    the application state changes caused by those transactions.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 19.2](ch19.xhtml#ch19fig2) summarizes the workflow described.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f19_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 19-2** The workflow'
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: After a block is added to the blockchain, all nodes run the same transactions
    in the same order. Hence, after a block is added, the ABCI application instances
    on all nodes have the same persistent state stored in their databases. For example,
    the ABCI application could update the user accounts database if the transactions
    move tokens/funds between users.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, let’s go through the exercise to set up a single Tendermint
    node to see how the Tendermint Core software and ABCI app work together.
  prefs: []
  type: TYPE_NORMAL
- en: Set Up a Node
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s download the precompiled Tendermint binary applications from the following
    web page: [https://tendermint.com/downloads](https://tendermint.com/downloads).'
  prefs: []
  type: TYPE_NORMAL
- en: 'You will need the `tendermint` and `abci` binaries for this step. Unpack the
    downloaded zip packages, and you will get the following executable binary files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Move the binary files to the `$HOME/bin` directory so that they are accessible
    from the command line. You can now run them to check their versions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `dummy` program is a simple ABCI application. Once running, it listens for
    transactions from Tendermint Core on TCP port 46658\. Being a “dummy” program,
    it will simply approve and validate all transactions. You can run the dummy program
    in a command-line window.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Next, in another command-line window, initialize the Tendermint Core software
    on this machine. The `init` command creates the configuration files for a network
    made up of a single validator node.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have initialized Tendermint Core on this computer before, you could
    either delete the `$HOME/.tendermint` directory and `init` again or use the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: If you encounter an error during Tendermint node startup, make sure you kill
    all Tendermint-related processes on your computer.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you can start the Tendermint node. The node immediately connects to the
    `dummy` ABCI app through port 46658 and starts to create blocks.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch19_images.xhtml#pro19_1)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output from the `dummy` window, showing that a Tendermint
    node is connected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The Tendermint node listens on port 46657 for new transactions. So, let’s now
    send a transaction to the network.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch19_images.xhtml#pro19_2)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The transaction is received by Tendermint Core at port 46657, forwarded to
    the dummy ABCI app at port 46658, validated by `dummy`, and then recorded in the
    blockchain by Tendermint Core. The dummy application stores the key-value pair
    in the transaction in its own database. The Tendermint console shows the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch19_images.xhtml#pro19_4)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: The `broadcast_tx_commit` message sends the transaction (in the `tx` parameter)
    to the network node and waits until the transaction is committed in a new block
    on the blockchain. There are other messages that can send the transaction without
    waiting for confirmation. You will see them in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we can query the blockchain for the transaction we just sent. The query
    is passed to the `dummy` ABCI application. Since the `dummy` application saves
    the value in all transactions it validates, it will be able to interpret and respond
    to the query and pass the results via Tendermint Core.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch19_images.xhtml#pro19_5)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Set Up a Network
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Of course, most blockchain networks have more than one node! To set up a network
    with multiple nodes, you can do the following.
  prefs: []
  type: TYPE_NORMAL
- en: First, run the `tendermint init` commands on all node computers on the network.
    In the `$HOME/.tendermint` directory, you will see the `genesis.json` file, which
    contains this node’s public key. The node’s private key is in the `priv_validator.json`
    file and should never be shared with anyone.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch19_images.xhtml#pro19_6)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Second, edit the `genesis.json` file on each node to add all peer nodes’ public
    key into the `validators` array. Those nodes are known as *initial validators*
    for a network. The network can add or remove validators dynamically once it is
    running.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, on each node computer, you can start `tendermint node` and the ABCI
    application (e.g., `dummy`). The nodes will discover each other by their public
    keys and then form a network. Notice that nodes on a network must run the same
    ABCI app since all nodes must process and validate transactions the same way.
  prefs: []
  type: TYPE_NORMAL
- en: Now you have a private Tendermint blockchain network. You can make it validate
    and record any transaction you like by writing your own ABCI applications, which
    you will see in [Chapter 20](ch20.xhtml#ch20). The Cosmos foundation also runs
    public test networks for developers and validators. For now, let’s review how
    the Tendermint blockchain network works.
  prefs: []
  type: TYPE_NORMAL
- en: A new transaction is received and preliminarily validated on a single node.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At a fixed time interval, validator nodes package all transactions since the
    last block and propose a new block.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once validators agree on a new block, it is broadcast to all nodes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All nodes process all transactions in the same order when a new block is added
    to the blockchain.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a result, the application state of the blockchain (databases managed by the
    ABCI application) on all nodes are in sync.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, I discussed how the Tendermint blockchain works by separating
    the consensus logic and application logic. The application logic, encapsulated
    in an ABCI application, allows developers to write versatile blockchain applications.
    I also demonstrated how to set up a Tendermint node and a network with a simple
    ABCI application.
  prefs: []
  type: TYPE_NORMAL
- en: 20. The Business Logic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous chapter, I explained that the business logic of a Tendermint
    blockchain network is encapsulated in an Application BlockChain Interface (ABCI)
    application. So, as a developer, you just need to write an application to control
    how the network processes and validates transactions. Each ABCI application is
    a blockchain. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: The Binance decentralized exchange is an application blockchain designed for
    crypto exchange operations. It is built on top of Tendermint.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The basecoin application creates a blockchain network with a native cryptocurrency.
    You can extend the token to support your own cryptocurrency features by forking
    the project. See [https://github.com/tendermint/basecoin](https://github.com/tendermint/basecoin).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ETGate` application is built on `basecoin` and enables token exchanges
    between Ethereum and Tendermint blockchains. See [https://github.com/mossid/etgate](https://github.com/mossid/etgate).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ethermint` application allows you to run the Ethereum Virtual Machine (EVM)
    as an ABCI application on top of a Tendermint blockchain. This creates an Ethereum
    blockchain but with Tendermint’s Byzantine fault tolerant (BFT) validators as
    opposed to PoW miners. See [https://github.com/tendermint/ethermint](https://github.com/tendermint/ethermint).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Plasma Cash is a layer 2 network implementation for Ethereum based on the
    Tendermint engine. It is a blockchain that connects to the Ethereum network via
    smart contracts. The Plasma Cash side chain allows for high-speed transactions
    that are impossible on Ethereum.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `merkleeyes` application creates a blockchain network that records transactions
    on a Merkle tree. It simulates a journaled data store. The insert/remove operations
    on the tree are recorded as transactions on the blockchain, and the current data
    on the tree can be queried from the blockchain’s query application programming
    interface (API) as well. See [https://github.com/tendermint/merkleeyes](https://github.com/tendermint/merkleeyes).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The CyberMiles application is a fully fledged ABCI application that incorporates
    delegated proof of stake (DPoS), on-chain governance, security features, and an
    enhanced EVM into a single ABCI application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we explore the ABCI protocol and create a simple ABCI application.
    We will also discuss application frameworks that are built on top of the ABCI,
    such as the Cosmos software development kit (SDK).
  prefs: []
  type: TYPE_NORMAL
- en: The Protocol
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You already learned how a Tendermint network works at a high level. In this
    section, we will look into the detailed mechanism, including the message exchange
    between Tendermint Core, which manages the blockchain, and the ABCI application,
    which manages the application-specific logic.
  prefs: []
  type: TYPE_NORMAL
- en: The ABCI protocol specifies the request/response communication between the Tendermint
    Core software and the ABCI application. By default, the ABCI application listens
    on TCP port 46658\. Tendermint Core sends messages to the ABCI application and
    acts on the responses ([Figure 20.1](ch20.xhtml#ch20fig1)). The protocol defines
    several kinds of messages. They follow the Tendermint Core and ABCI application
    interaction flow outlined in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f20_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 20-1** Tendermint ABCI messages in the consensus flow'
  prefs: []
  type: TYPE_NORMAL
- en: Consensus on the Block
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The first type of message is the `CheckTx` message. When the node receives a
    transaction request (via port 46657, which Tendermint Core listens on by default),
    it forwards the transaction to the ABCI application in a `CheckTx` message for
    preliminary validation. The ABCI application has its own logic to parse, process,
    and validate the transaction and then return a result. If the `CheckTx` result
    is okay, the Tendermint node will broadcast and synchronize the transaction to
    all nodes in the blockchain network.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that every Tendermint node keeps its own pool of transactions
    that successfully passed the node’s `CheckTx`. It is known as the node’s *mempool*.
    The nodes on the network could each have a different set of transactions in the
    mempool. When a node proposes a new block, it packages together transactions in
    its own mempool. When the block is accepted by the network (i.e., consensus),
    all transactions in the block will be removed from all node mempools in the network.
    [Figure 20.2](ch20.xhtml#ch20fig2) outlines the consensus flow of the new block.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f20_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 20-2** Tendermint consensus for each block'
  prefs: []
  type: TYPE_NORMAL
- en: When a Tendermint network reaches consensus on a new block, the nodes are only
    agreeing on the block’s structure and its cryptographic validity with regard to
    the previous blocks on the blockchain. The nodes actually have no idea about the
    validity of the transactions inside the block. To reach consensus on the results
    of the transactions inside the block, we will need the app hash from the `commit`
    message, which we will see next.
  prefs: []
  type: TYPE_NORMAL
- en: Consensus on the Transactions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The second, and most important type of message, is the `DeliverTx` message.
    At fixed-time intervals, all validator nodes in the network will reach consensus
    and determine the next block to be added to the blockchain. This new block contains
    all valid transactions submitted to the network during the time interval, and
    it is broadcast to all nodes on the network. Each node will run all the transactions
    in the block to the node’s local ABCI application instance. Each transaction is
    embedded in a `DeliverTx` message. The block starts with a `StartBlock` message
    to the ABCI, followed by a series of `DeliverTx` messages for all transactions
    in the block, and ends with an `EndBlock` message.
  prefs: []
  type: TYPE_NORMAL
- en: The ABCI application processes the `DeliverTx` messages in the order they are
    received. The ABCI application maintains its own database and updates the database
    as it processes the transactions (e.g., the database could be a ledger for user
    accounts, and each transaction moves funds between accounts). Since all nodes
    process the same set of transactions in the same order, once they are done, the
    ABCI applications on all nodes should have the same persistent state (i.e., their
    database content should be synchronized).
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: It is possible that the `DeliverTx` message to the ABCI application could return
    a failure result. Since the network validators have already reached consensus
    on the block, the blockchain will annotate the failed transaction in this block
    in the block header.
  prefs: []
  type: TYPE_NORMAL
- en: A critical requirement of the ABCI application is that it must be deterministic.
    When it processes a set of transactions, it must reach the same results, in terms
    of the success/failure of each transaction and the overall application state,
    every time regardless of which node did the processing. That means the ACBI application
    logic should not have any dependency on random numbers, timestamps, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The ABCI application does not save to a database after each `DeliverTx` message.
    Instead, it processes the entire block of transactions and saves only at the end
    when it sees a `Commit` message. The `Commit` message should return the current
    state of the node, such as the node’s database hash, known as the *app hash*.
    The blockchain will stop working altogether if two-thirds of the validator nodes
    cannot agree on an app hash at the `Commit` of any block. If a node returns an
    app hash that is different than most nodes, this node is deemed corrupt and will
    not be able to participate in future consensus voting.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Information
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Finally, the ABCI protocol supports a third type of message, the `Query` message,
    which allows the Tendermint Core node to query the persistent state of the ABCI
    application. As mentioned, the ABCI application could maintain its own database,
    and the data stored in the database (i.e., its state) is determined by the history
    of transactions validated by the ABCI application. The blockchain node could query
    this database by issuing a query message.
  prefs: []
  type: TYPE_NORMAL
- en: A Sample Application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the next sections, let’s get into the details by building an ABCI application.
    The application keeps track of a series of facts by their sources and stores the
    tallies in a database. The facts are submitted by external applications to any
    node on the blockchain. If a fact is accepted by the application, it will be recorded
    in the blockchain as a transaction. We will implement this application in the
    Java and GO languages.
  prefs: []
  type: TYPE_NORMAL
- en: Once the blockchain (Tendermint Core) and the facts ABCI application are running,
    you can send a series of facts as transactions to the blockchain. Each fact contains
    a source and a statement. Recall that Tendermint Core listens at port 46657 for
    transactions submitted to the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch20_images.xhtml#pro20_1)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As mentioned in the previous chapter, there are several ways to send the transaction
    data (it could be any byte array in the `tx` parameter field).
  prefs: []
  type: TYPE_NORMAL
- en: '`/broadcast_tx_commit`: This is the message we used. It waits until the blockchain
    has validated the transaction and is added into a new block. When this message
    returns, you will be able to see both `CheckTx` and `DeliverTx` results.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/broadcast_tx_async`: This message sends the transaction data to a blockchain
    node and does not wait for the blockchain’s response.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/broadcast_tx_sync`: This message sends the transaction data to a blockchain
    node and waits for the `CheckTx` to run. This message returns the `CheckTx` result.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the facts application console, you can see the transactions are processed
    and validated. Notice that there are both `CheckTx` and `DeliverTx` messages on
    all nodes. While the transaction is sent to only one node, the node broadcasts
    the transaction to all nodes once it passes the `CheckTx` message. So, each node
    will see this transaction, check it, save it to the mempool, and process it again
    when the new consensus block containing this transaction is received.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: You can also query the blockchain for the current application state. The ABCI
    application returns a tally of facts by sources. Notice that the actual fact statements
    are stored in the blockchain as transactions, and the ABCI application stores
    only the tally in its data store. The `value` field in the response is a Base64-encoded
    string of the response text in the `log` field.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch20_images.xhtml#pro20_2)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Next, let’s look into how to implement this simple facts ABCI application. We
    will discuss both Java and GO language implementations. You can just choose a
    language you are most comfortable with.
  prefs: []
  type: TYPE_NORMAL
- en: Java Implementation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Java application is built on the jTendermint library. When the application
    starts up, it listens on ABCI’s default TCP port 46658 to receive transactions
    from the Tendermint Core software running on the same node.
  prefs: []
  type: TYPE_NORMAL
- en: For the sake of simplicity, we will not use an external relational database
    to store the application state. Instead, we instantiate a global hash table in
    the application as the data store. The hash table key is a unique source of the
    facts, and the value is the number of facts associated with this source. The downside,
    of course, is that the application state is lost if the application crashes. When
    the application starts, it starts a socket server to listen for messages from
    the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch20_images.xhtml#pro20_3)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `ResponseCheckTx` method handles the `CheckTx` messages from Tendermint
    Core. As you probably recall, the `CheckTx` message is sent when the blockchain
    node receives a transaction request. The ABCI application simply parses the fact
    from the message into a source element and a statement element. If the message
    parses successfully, the ABCI application returns `ok`, and the transaction is
    broadcast and synchronized to all nodes on the network. For brevity, I removed
    the statements to log messages to the facts application console, which you saw
    in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch20_images.xhtml#pro20_4)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: The `CheckTx` message in this example is simplistic. In most applications, the
    `CheckTx` message handler method will use the application’s current database state
    to check the transaction. The application state (i.e., the app hash) is updated
    by the last block’s `Commit` message. The `CheckTx` method should never modify
    the application state.
  prefs: []
  type: TYPE_NORMAL
- en: Next, after the network reaches consensus on the next block, each node will
    send transactions in this block as a series of `DeliverTx` messages to the ABCI
    application. The `ResponseDeliverTx` method handles the `DeliverTx` messages.
    It again parses the fact in the message and then tallies by the source in a temporary
    cache. Since all nodes will see the same set of `DeliverTx` messages in the same
    order, they should update the application’s database in sequence. That is, a second
    `DeliverTx` is working off the database after changes have been made by the first
    `DeliverTx`. However, the `DeliverTx` itself should update only a temporary (often
    in-memory) replicate of the database, and the changes are flushed to the permanent
    (often on-disk) database at `Commit`. This is not only efficient but also ensures
    the application’s database state is always set at the `Commit` state of the last
    block. In this simple example, however, our application database is in memory
    and the `DeliverTx` processing does not depend on the current state of the database.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch20_images.xhtml#pro20_5)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: When the ABCI application sees the `Commit` message, it saves all the temporary
    tallies to the `Hashtable`-based data store. It returns the hash code of the data
    store as the app hash. All nodes have to agree on the app hash after committing
    this block. If a node returns a different app hash than other nodes, it is deemed
    corrupt and will not be allowed to participate in the future consensus.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch20_images.xhtml#pro20_6)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Finally, an external application can query the blockchain for the application
    state. In this case, a `Query` message will be passed from Tendermint Core to
    the application. The `ResponseQuery` method handles this message and returns the
    tallies for all sources from the data store.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch20_images.xhtml#pro20_7)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The blockchain itself stores the validated `source : statement` data submitted
    by external applications. The ABCI application stores the tallies of facts based
    on sources, and the tallies are synchronized across all nodes since the ABCI application
    on all nodes run the same set of transactions that get written into the blockchain.'
  prefs: []
  type: TYPE_NORMAL
- en: We use Maven to build an executable binary of the application. You can review
    the `pom.xml` file in the source code repository to see how to build the executable
    JAR file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: You can run the ABCI application from command line and it will automatically
    connect to a Tendermint Core instance running on the same node.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: GO Implementation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Tendermint itself is built on the GO programming language. It is not surprising
    that GO is a well-supported language platform to build ABCI applications. The
    `main` method in the application listens for ABCI messages on port 46658.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch20_images.xhtml#pro20_8)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Similar to the Java application, we will use an in-memory map to store the application
    state (i.e., the facts tallies) for simplicity.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch20_images.xhtml#pro20_10)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `CheckTx` method handles the `CheckTx` messages from Tendermint Core. As
    you probably recall, the `CheckTx` message is sent when the blockchain node receives
    a transaction request. The ABCI application simply parses the fact from the message
    into a source element and a statement element. If the message parses successfully,
    the ABCI application returns okay, and the transaction is broadcast and synchronized
    to all nodes on the network.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch20_images.xhtml#pro20_11)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: The `CheckTx` message in this example is simplistic. In most applications, the
    `CheckTx` message handler method will use the application’s current database state
    to check that the transaction is valid. The application state (i.e., the app hash)
    is updated by the last block’s `Commit` message. The `CheckTx` method should never
    modify the application state.
  prefs: []
  type: TYPE_NORMAL
- en: Next, after the network reaches consensus on the next block, each node will
    send transactions in this block as a series of `DeliverTx` messages to the ABCI
    application. The `DeliverTx` method handles the `DeliverTx` messages. It again
    parses the fact in the message and then tallies by the source in a temporary cache.
    Since all nodes will see the same set of `DeliverTx` messages in the same order,
    they should update the application’s database in sequence. That is, a second `DeliverTx`
    is working off the database after changes have been made by the first `DeliverTx`.
    However, the `DeliverTx` itself should update only a temporary (often in-memory)
    replicate of the database, and the changes are flushed to the permanent (often
    on-disk) database at Commit. This is not only efficient but also ensures the application’s
    database state is always set at the `Commit` state of the last block.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch20_images.xhtml#pro20_12)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: When the ABCI application sees the `Commit` message, it saves all the temporary
    tallies to the map-based data store. It returns the hash of the total count of
    entries in the data store as the app hash. All nodes have to agree on the app
    hash after committing this block. If a node returns a different app hash than
    other nodes, it is deemed corrupt and will not be allowed to participate in the
    future consensus.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch20_images.xhtml#pro20_13)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Finally, an external application can query the blockchain for the application
    state. In this case, a `Query` message will be passed from Tendermint Core to
    the application. The `Query` method handles this message and returns the tallies
    for all sources from the data store.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch20_images.xhtml#pro20_14)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The blockchain itself stores the validated `source : statement` data submitted
    by external applications. The ABCI application stores the tallies of facts based
    on sources, and the tallies are synchronized across all nodes since the ABCI application
    on all nodes run the same set of transactions that get written into the blockchain.'
  prefs: []
  type: TYPE_NORMAL
- en: We use the default tools to compile and build the GO application.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: You can run the application from command line and it will automatically connect
    to a Tendermint Core instance running on the same node.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The Cosmos SDK
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Tendermint provides a flexible framework for building business logic on top
    of its consensus engine. However, as you have seen, we have to write the entire
    application logic from scratch using ABCI. From Tendermint’s point of view, the
    application data is simply a byte array. For many blockchain applications, they
    require the same set of baseline functionalities, such as user accounts/address
    management, token issuance, and PoS-style staking. It is tedious and error prone
    for developers to write those components over and over again for all Tendermint-based
    blockchains. That gives rise to application frameworks on top of the ABCI for
    common business components. The Cosmos SDK is one such component library for Tendermint.
    It is written on the GO language. The Cosmos Hub project itself is built on the
    Cosmos SDK.
  prefs: []
  type: TYPE_NORMAL
- en: The Cosmos SDK is still evolving, and its technical details are beyond the scope
    of this book. I recommend you visit the Cosmos SDK web site for the latest documentation
    and tutorials ([https://github.com/cosmos/cosmos-sdk](https://github.com/cosmos/cosmos-sdk)).
    In this section, I will provide a high-level introduction to the design and functions
    of the SDK. The SDK provides built-in support for basic infrastructure needed
    for most ABCI applications.
  prefs: []
  type: TYPE_NORMAL
- en: The SDK allows developers to easily create and maintain any number of key-value
    data stores known as `KVStore`. Those data stores are used to manage application
    state data during `CheckTx` and `DeliverTx` operations. For example, `DeliverTx`
    needs to process all transactions in the block on a cached copy of the blockchain
    state and Commit those changes when the processing is successfully finished.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The SDK provides a data marshalling and unmarshalling library called go-amino.
    It allows byte array data in transactions to be easily converted to GO objects
    back and forth.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The SDK provides a router object to route all messages from a Remote Procedure
    Call (RPC) connector to different modules in the SDK for further processing. The
    router is set up in the way that allows the messages to be processed by multiple
    modules in any specified order.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In your Cosmos SDK application, you will configure the router for incoming
    messages. The following is an example from the Cosmos SDK tutorial:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch20_images.xhtml#pro20_15)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Incoming messages in transactions are first processed by the `bank` module and
    then the `staking` module. `app.bankKeeper` is a callback method implemented by
    the application developer to process events emitted from the `bank` module. For
    example, it could respond to events when one user transfers funds to another.
    The Cosmos SDK provides a library of modules. Currently, most of them are related
    to handling crypto tokens.
  prefs: []
  type: TYPE_NORMAL
- en: The `auth` module checks and validates signatures in transactions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `bank` module manages user accounts and addresses for holding crypto tokens.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `mint` module manages minting and issues crypto tokens during the operation
    of the blockchain.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `staking` module manages how users could stake their tokens to support network
    security in a proof-of-stake (PoS) manner.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `distribution` module manages how the staking award (interest on staking)
    is distributed to users.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `slashing` module manages how to punish users who staked misbehaving actors
    in the system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ibc` module manages the cross-chain asset exchange protocol supported by
    the Cosmos Hub.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As of April 2019, the Cosmos SDK implements basic functionalities for a generic
    PoS blockchain. It does not yet support any virtual machine functionalities. To
    support programmable blockchains, the Cosmos SDK road map calls for incorporating
    virtual machines as modules to process transactions. The future of Cosmos SDK
    is bright.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we explored the ABCI protocol and demonstrated how to build
    blockchain applications. Those ABCI applications allow the blockchain to offload
    much of the computationally intensive tasks. Developers can now write applications
    with complex transactional logic in a highly efficient manner. An important space
    to watch is the development of the Cosmos SDK, which could dramatically simplify
    the development of Tendermint-based application blockchains.
  prefs: []
  type: TYPE_NORMAL
- en: 21. Creating a Blockchain Client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous chapter, I discussed how to build Application BlockChain Interface
    (ABCI) applications to handle the business logic of a blockchain. That allows
    us to develop complex logic to process, transform, and validate transactions to
    be recorded in the blockchain. For each transaction, the ABCI application can
    apply rules, compute its persistent effects (e.g., changes to account balances
    for a monetary transaction), and save results in an off-chain database. Since
    the ABCI application can be written in any language and on any software stack
    and can support arbitrary transactional logic, it allows us to build a variety
    of different blockchains with specific purposes and optimizations. Each ABCI application
    is a blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: However, with all its power, the ABCI application is still designed around transactions.
    In traditional enterprise software terms, the ABCI application is middleware providing
    business or transactional logic. It does not provide user interface or high-level
    application logic. Similar to Ethereum, the ABCI applications also require a decentralized
    dapp (dapp) layer to be accessible to end users. The dapp utilizes data and functions
    provided by the blockchain (i.e., the ABCI application), and hence the dapp is
    a client to the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: The Tendermint dapp is different from the Ethereum dapp covered in earlier chapters
    of the book. An Ethereum dapp is a client for smart contracts deployed on the
    blockchain. It is limited to invoking public methods exposed by the contract.
    A Tendermint dapp, on the other hand, has full access to the transaction records
    stored in the blockchain, as well as off-chain databases maintained by the ABCI
    application. It is a “dapp on steroids.”
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I will demonstrate how to build a dapp on the Tendermint platform,
    using the facts example from the previous chapter. We will build a web application,
    but the principle is the same for any type of modern user interface.
  prefs: []
  type: TYPE_NORMAL
- en: Overview of the Approach
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The simplest approach to a dapp is to build an external application that interacts
    with the blockchain application programming interface (API). As described in earlier
    chapters, the API commands are sent via TCP/IP port 46657 to any node on the blockchain
    network. The application sends in transactions and queries via the `/broadcast_tx_commit`
    and `/abci_query` API methods, respectively. The dapp exists outside of the blockchain.
    It is not aware of the inner workings of the ABCI application. This is truly a
    blockchain as a service setup ([Figure 21.1](ch21.xhtml#ch21fig1)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f21_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 21-1** The dapp with blockchain as a service'
  prefs: []
  type: TYPE_NORMAL
- en: However, this type of dapp is just another web site or mobile app. It is typically
    created and managed by a central entity. It accesses the blockchain through a
    predefined custom data protocol and lacks in-depth access of the underlying data
    structure.
  prefs: []
  type: TYPE_NORMAL
- en: An alternative is to build a distributed application that runs on each node.
    This application could be deeply integrated with the ABCI application, with local
    access to databases ([Figure 21.2](ch21.xhtml#ch21fig2)). The advantage of this
    approach is a higher level of decentralization and a more efficient application
    architecture. The disadvantages are that it creates a software dependency on the
    applications at the node level, and it increases the potential security risks
    for the blockchain, as nodes are serving application services via the Internet.
    Those disadvantages increase the difficulties of application deployment and management.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f21_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 21-2** A tightly integrated dapp architecture'
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: Even in a decentralized architecture, where the dapp software runs on every
    node, there still needs to be a centralized entry point. For example, if the dapp
    is a web app, it still needs a URL. In this case, a lightweight centralized load
    balancer is needed to direct traffic to the blockchain nodes.
  prefs: []
  type: TYPE_NORMAL
- en: The Sample Application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The sample application shown here is a web app user interface (UI) based on
    the facts application in [Chapter 20](ch20.xhtml#ch20). It allows the user to
    enter facts, with sources and statements, on a web page. And the same page displays
    the current tally of statements by sources ([Figure 21.3](ch21.xhtml#ch21fig3)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/yuan_f21_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 21-3** The dapp web app for facts'
  prefs: []
  type: TYPE_NORMAL
- en: In the next two sections, I will demonstrate how to create this web application
    in PHP and Java. The PHP application is a simple web application that used the
    Blockchain API as a back end. The Java application is tightly integrated with
    the ABCI application.
  prefs: []
  type: TYPE_NORMAL
- en: PHP
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We developed a PHP web app to utilize the blockchain API via the TCP socket
    connection. The blockchain runs Tendermint Core and the facts ABCI application
    described in [Chapter 20](ch20.xhtml#ch20).
  prefs: []
  type: TYPE_NORMAL
- en: The PHP code first checks whether this request is a submission of the form,
    and if it is, the PHP code will send the transaction to the blockchain and wait
    until it commits.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch21_images.xhtml#pro21_1)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Next, the PHP code queries the blockchain via its custom query API to check
    for the tally of facts based on the source. The query is passed to the ABCI application.
    As discussed, the ABCI application is responsible for parsing the query, creating
    a response, and sending the response via the blockchain. The ABCI response is
    in a structured JavaScript Object Notation (JSON) message. The value field in
    the response message contains the results encoded in hex characters. The PHP code
    will parse the hex content and then display the results in a table.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch21_images.xhtml#pro21_2)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Java
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Java web application accomplishes the same functionalities as the PHP application,
    but it is directly integrated with the ABCI application’s data store. In fact,
    the ABCI application runs inside the same JVM as the Java web application. Let’s
    look into how this works.
  prefs: []
  type: TYPE_NORMAL
- en: In the Java web application’s `web.xml` file, we specify that a servlet will
    run as soon as the application loads in Tomcat.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch21_images.xhtml#pro21_3)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: That servlet loads and runs the ABCI application.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch21_images.xhtml#pro21_4)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Next, in the servlet filter in front of the `index.jsp` web page, we first check
    whether a new fact (source and statement) is submitted in this request. If this
    is the case, the filter sends the transaction to the blockchain using its regular
    TCP socket API connection.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch21_images.xhtml#pro21_5)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The filter then queries the ABCI application’s data store directly to get a
    tally of facts by sources. Notice that we do not go through the socket-based blockchain
    query API for this. While for this simple application the data store query is
    simple and well supported by the blockchain query API, I can envision application
    scenarios where the dapp makes heavy use of the off-chain application data store
    for complex business logic and UI logic.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to view code image](Images/ch21_images.xhtml#pro21_6)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The Java application can be found in the book’s GitHub repository. You can
    build a WAR file ready for Apache Tomcat deployment by running the following Maven
    build command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Conclusion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, I showed how to build a complete blockchain application accessible
    to end users. I showed a web application, but it could easily be a web service
    to support rich client (i.e., mobile) applications. While it is possible to build
    completely decentralized dapps, most dapps are created and operated by companies
    offering services to their users.
  prefs: []
  type: TYPE_NORMAL
