- en: Chapter 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Enterprise Blockchains: Hyperledger, R3 Corda, Quorum, and Ethereum'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, I will cover the technical merits of the following enterprise
    blockchains, how they are structured, and where they fit into the enterprise:'
  prefs: []
  type: TYPE_NORMAL
- en: Hyperledger
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: R3 Corda
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quorum
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ethereum
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The technical merits covered in this chapter include security, consensus, virtual
    machines, features, and functions that are critical to understanding the blockchain
    platform. This chapter will cover the architecture at a fundamental level so you
    can understand the blockchain network and services. In [Chapter 3](c03.xhtml),
    “Architecting Your Enterprise Blockchain,” I will focus on the steps of designing
    a blockchain network as well as architecture best practices for the specific blockchains.
  prefs: []
  type: TYPE_NORMAL
- en: '## Comparing Enterprise Blockchains'
  prefs: []
  type: TYPE_NORMAL
- en: Blockchains are used in two main categories of IT solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Public, permissionless blockchains
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Private, enterprise, permissioned blockchains
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A third approach, considered a hybrid solution, combines a myriad of private
    and public blockchain services. Hybrid blockchains will be discussed as a use
    case in [Chapter 8](c08.xhtml), “Blockchain Use Cases.”
  prefs: []
  type: TYPE_NORMAL
- en: Enterprise blockchains have different requirements than public blockchains such
    as Ethereum. I will be discussing the merits of enterprise blockchains throughout
    the book.
  prefs: []
  type: TYPE_NORMAL
- en: As discussed in [Chapter 1](c01.xhtml), “Introduction to Blockchain Technologies,”
    public permissionless blockchains use a networking protocol called the Internet
    Protocol (IP) to communicate with nodes on the blockchain network as well as to
    manage the distribution of transactions. Nodes are other virtual machines that
    are running the blockchain protocol.
  prefs: []
  type: TYPE_NORMAL
- en: A blockchain will run a variation of protocols, and they can be somewhat different
    from each other on each platform. Ethereum uses a peer-to-peer network protocol,
    for example, whereas R3 Corda uses a point-to-point network protocol.
  prefs: []
  type: TYPE_NORMAL
- en: Consensus is also vastly different between blockchains, and I will discuss this
    at a high level in this chapter. It will also be covered in more technical detail
    in [Chapter 4](c04.xhtml), “Understanding Enterprise Blockchain Solutions.”
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 1.2](c01.xhtml#c01-tbl-0002) shows how different public and private
    blockchains can be when it comes to the features and functions of the platform.
    Choosing the right blockchain platform may come down to just one feature.'
  prefs: []
  type: TYPE_NORMAL
- en: '#### HYBRID BLOCKCHAINS'
  prefs: []
  type: TYPE_NORMAL
- en: In a permissionless blockchain, the ledger is open read/write, meaning that
    anyone can access the transaction records. This would be done through a blockchain
    explorer, for example. Other features such as identity, security, and trust are,
    of course, handled differently.
  prefs: []
  type: TYPE_NORMAL
- en: Enterprise blockchains such as Hyperledger Fabric, R3 Corda, and Quorum are
    distributed ledgers in which all participants are known and permissioned to be
    on the blockchain network. Transactions are role-based and determined by consensus
    in the network. Enterprise blockchains generally introduce a form of centralization
    to blockchains but may also be decentralized over a membership consortium. Modular
    components such as consensus or key management systems enable enterprises to determine
    what fits their use cases. Tokens or cryptocurrencies are generally not needed
    in a controlled blockchain ecosystem where membership is controlled. Some consortium
    blockchains such as Hyperledger may provide this capability later.
  prefs: []
  type: TYPE_NORMAL
- en: Enterprise blockchains can utilize “off-chain” data storage services, such as
    the Interplanetary File System (IPFS), to reduce costs. Created by Protocol Labs,
    IPFS is a peer-to-peer protocol where each node stores a collection of hashed
    files. IPFS is actually a fascinating approach to blockchain storage that can
    provide costing efficiencies and programmatic efficiencies. IPFS clearly refers
    to files by using hashes, therefore allowing for much richer programmatic interactions.
  prefs: []
  type: TYPE_NORMAL
- en: Enterprise integration may not require middleware or API changes to establish
    enterprise services. For example, with Enterprise Ethereum and Quorum, there is
    already some capability to extend the blockchain as a hybrid solution. A hybrid
    solution means that the blockchain can be extended from a permissioned to a permissionless
    chain such as Ethereum.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enterprise blockchains are generally accepted to fall into one of several categories,
    the most common of which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Private enterprise blockchains* are managed by a single organization. The
    participants are normally internal users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Consortium enterprise blockchains* are managed by multiple trusted organizations.
    Access requires consensus by multiple participants in the consortium.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Hybrid enterprise blockchains* are generally used for extended off-chain capabilities.
    Hybrid blockchains can be a myriad of private and public extensions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When considering blockchains from a presale's perspective, it is imperative
    that you understand the use cases for the different enterprise blockchains. Not
    every enterprise blockchain has the ability to meet every use case. I will now
    cover the major enterprises blockchains to give you an idea of how they actually
    compare and contrast. I cover each in more technical detail throughout the book
    and also compare and contrast these enterprise blockchain features and use cases.
  prefs: []
  type: TYPE_NORMAL
- en: The really convenient part of getting into the enterprise blockchain space today
    is that there aren't many enterprise blockchains to learn—no more than five, even
    if you include Ripple, which is a payment network for banks. I do not cover Ripple
    in depth in this chapter, mainly because it is a banking and payment network service
    and Ripple does not support smart contracts. Smart contracts provide essentially
    the main benefits for enterprise organizations around blockchain use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, this book will focus on Hyperledger, R3 Corda, Quorum, and Ethereum.
    [Table 2.1](#c02-tbl-0001) shows the five major enterprise-grade blockchains and
    how they compare based on industry, ledger, consensus methods, smart contracts,
    and cryptocurrency support.
  prefs: []
  type: TYPE_NORMAL
- en: You can view the full chart online at `[https://www.horsesforsources.com/top-5-blockchain-platforms_031618](https://www.horsesforsources.com/top-5-blockchain-platforms_031618)`.
    It provides insight into how many solution providers out of 50 surveyed actually
    have engagements in the enterprise blockchains.
  prefs: []
  type: TYPE_NORMAL
- en: '[**TABLE 2.1**](#R_c02-tbl-0001): Comparing enterprise blockchains'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | ETHEREUM | R3 CORDA | QUORUM | HYPERLEDGER | RIPPLE |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **Industry** | Cross-industry | Financials | Cross-industry | Cross-industry
    | Financial |'
  prefs: []
  type: TYPE_TB
- en: '| **Ledger** | Permissionless | Permissioned | Permissioned | Permissioned
    | Permissioned |'
  prefs: []
  type: TYPE_TB
- en: '| **Consensus** | Proof of work | Pluggable | Majority voting | Pluggable |
    Probabilistic voting |'
  prefs: []
  type: TYPE_TB
- en: '| **Smart contract support** | Yes | Yes | Yes | Yes | No |'
  prefs: []
  type: TYPE_TB
- en: '| **Cryptocurrency** | Ether (Eth) | N/A | N/A | N/A | Ripple (XRP) |  ## Introducing
    the Hyperledger Project'
  prefs: []
  type: TYPE_NORMAL
- en: The Linux Foundation hosts Hyperledger and provides a governance structure and
    oversight to the Hyperledger community. It is a global open source project and
    the result of collaboration from technology leaders. Linux Foundation also embraces
    a modular umbrella approach to enterprise blockchains. Hyperledger is an open
    source software licensing model, which allows the user to model code and distribute
    it in an appropriate manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in [Figure 2.1](#c02-fig-0001), Hyperledger uses an umbrella approach
    to manage its open source projects. As an organization, Hyperledger manages more
    than 100 open source collaborations (projects). The Hyperledger structure has
    three modules: Infrastructure, Frameworks, and Tools.'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that Hyperledger has six frameworks and six tools and utilities.
    I will focus mainly on Hyperledger Fabric for this book because of its wide development
    base and the significant enterprise use cases in play now. The umbrella strategy,
    also referred to as the *greenhouse strategy*, is a proven model that the Linux
    Foundation has used repeatedly in the other projects it maintains. Historically,
    the Linux Foundation provides excellent management and insight into how to manage
    an open source project for consortium members.
  prefs: []
  type: TYPE_NORMAL
- en: '### Hyperledger Frameworks'
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned, Hyperledger has six frameworks at the time of writing. Each framework
    is a blockchain. The Hyperledger consortium of members realized that one blockchain
    framework would not meet the requirements of all its members. The five frameworks
    ensure its consortium members have the features, functions, and other requirements
    to deploy an appropriate blockchain for its members' use cases.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 2.2](#c02-tbl-0002) presents the five blockchains that make up the Hyperledger
    frameworks. I will focus on the Fabric framework, which is a permissioned blockchain
    that supports channels. Channels allow for controlled transactions that are private.'
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned, Fabric will be the focus of the book but the other frameworks
    in the Hyperledger blockchain family such as Burrow or Sawtooth will be referenced
    throughout the book mainly as a comparison for use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Hyperledger as an organization empowers its members through the project's blockchain
    frameworks, tools, and organizational infrastructure. Hyperledger Fabric is by
    far the most widely used of the frameworks. For example, if you go to the Hyperledger
    GitHub project, you will see that Fabric has the most forks. GitHub is a collaborative
    web-based platform for software development projects that use the Git revision
    control system. Git is the standard for software development and is the most widely
    used platform.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 2.2](#c02-fig-0002) shows that Fabric has more than 4,700 forks. A
    fork is when developers make a copy of the repository, which is a good sign since
    it shows that developers are making changes to code, testing the code, or using
    the code.'
  prefs: []
  type: TYPE_NORMAL
- en: It's clear that Fabric has the most activity as compared to the other frameworks.
    This is mainly because it's the framework that meets the most use cases. Fabric
    provides some significant features, such as modularity of consensus and encryption
    key management, but it also supports private channels. This book focuses on the
    power and flexibility of Hyperledger Fabric specifically.
  prefs: []
  type: TYPE_NORMAL
- en: '#### HYPERLEDGER INDY'
  prefs: []
  type: TYPE_NORMAL
- en: Hyperledger Indy was created and contributed by the Sovrin Foundation. The Sovrin
    Foundation is a private-sector, international nonprofit that was established intentionally
    to govern the world's first self-sovereign identity (SSI) network.
  prefs: []
  type: TYPE_NORMAL
- en: Indy is a Hyperledger project made to support independent identities on distributed
    ledger platforms. Indy provides a wide breadth of tools, libraries, and reusable
    components for providing digital identities rooted on blockchains or other distributed
    ledgers. The benefits are that the digital identities provide an interoperable
    capacity to enterprises across administrative domains, applications, and any other
    silos. ![An umbrella diagram depicting hyperledger approach includes frameworks
    such as burrow, fabric, grid, indy, iroha, and sawtooth with symbols and descriptions,
    and tools and libraries such as caliper, cello, composer, explorer, quilt, and
    ursa with symbols and descriptions.](images/c02f001.png)
  prefs: []
  type: TYPE_NORMAL
- en: '[**FIGURE 2.1**](#R_c02-fig-0001) Hyperledger approach (Linux Foundation)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Graphic courtesy of Linux Foundation**'
  prefs: []
  type: TYPE_NORMAL
- en: '[**TABLE 2.2**](#R_c02-tbl-0002): Blockchains in the Hyperledger framework'
  prefs: []
  type: TYPE_NORMAL
- en: '| FRAMEWORK | APPLICATION |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Indy | Decentralized identity |'
  prefs: []
  type: TYPE_TB
- en: '| Iroha | Mobile application focused |'
  prefs: []
  type: TYPE_TB
- en: '| Sawtooth | Permissioned and permissionless support; EVM transaction family
    |'
  prefs: []
  type: TYPE_TB
- en: '| Burrow | Permissionable smart contract machine (EVM) |'
  prefs: []
  type: TYPE_TB
- en: '| Fabric | Permissioned with channel support |'
  prefs: []
  type: TYPE_TB
- en: '| Grid | Web Assembly–based project for building supply chain-based solutions
    |'
  prefs: []
  type: TYPE_TB
- en: '![Screen capture depicting the pinned repositories of Hyperledger including
    Fabric with the number of blockchain forks labeled 4.7k encircled.](images/c02f002.png)'
  prefs: []
  type: TYPE_IMG
- en: '[**FIGURE 2.2**](#R_c02-fig-0002) Hyperledger Fabric GitHub forks'
  prefs: []
  type: TYPE_NORMAL
- en: '#### HYPERLEDGER IROHA'
  prefs: []
  type: TYPE_NORMAL
- en: Hyperledger Iroha was created by numerous participating companies, such as Soramitsu,
    Hitachi, NTT Data, and Colu. Iroha is a business blockchain framework specifically
    designed to be efficiently incorporated into mobile projects requiring distributed
    ledger technology. Iroha features a modern, domain-driven C++ design as well as
    a chain-based Byzantine fault-tolerant consensus algorithm called Sumeragi.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sumeragi uses a permissioned-based server reputation system that calculates
    the reliability of servers based on these three specific factors:'
  prefs: []
  type: TYPE_NORMAL
- en: The time each server registered with the membership service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of successful transactions processed by each server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Failures detection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consensus in Sumeragi is performed on individual transactions and on the global
    state resulting from the application of the transaction.  #### HYPERLEDGER FABRIC'
  prefs: []
  type: TYPE_NORMAL
- en: Hyperledger Fabric was mainly developed by IBM. Fabric is clearly intended as
    a foundation for developing applications or solutions with the modular architecture
    that enterprises require. Hyperledger Fabric allows for essentially a modular
    approach to components, such as consensus and membership services, and leverages
    containers to host smart contracts called *chaincode* that comprise the application
    logic of the system.
  prefs: []
  type: TYPE_NORMAL
- en: The permissioned nature of Hyperledger Fabric provides for privacy of operations
    for the participants. The need for privacy does not exclude the need for identification
    and audit ability from regulators. Basically, the encryption of identity (membership)
    is done in a manner that remains “private” from other blockchain participants.
    Auditing is effectively built in and also provides for compliance requirements,
    which is a major concern for enterprises.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hyperledger Fabric does not perform mining, although cryptocurrency support
    is possible via chaincode by referencing an off-chain exchange.  #### HYPERLEDGER
    SAWTOOTH'
  prefs: []
  type: TYPE_NORMAL
- en: Hyperledger Sawtooth was built by Intel and is closer to a proprietary blockchain
    than an open source blockchain. Sawtooth is a modular platform for building, deploying,
    and running distributed ledgers, and it is considered Hyperledger's second most
    widely accepted blockchain framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hyperledger Sawtooth includes a varied consensus algorithm called *proof of
    elapsed time* (PoET), which targets large distributed validator populations with
    minimal resource consumption. This essentially means that it can target distributed
    consensus efficiently.  #### HYPERLEDGER BURROW'
  prefs: []
  type: TYPE_NORMAL
- en: Hyperledger Burrow is a permissionable smart contract machine that was the first
    of its kind when it was released in 2014\. Burrow's main value point is that it
    provides a modular blockchain client with a permissioned smart contract interpreter
    that was built to the specification of the Ethereum Virtual Machine (EVM). Burrow
    was specifically built to be a lightweight, efficient, and fast permissioned smart
    contract machine. Burrow accomplishes this goal by leveraging the hardened and
    speedy Tendermint protocol for consensus working with the Burrow's Apache-licensed
    EVM.
  prefs: []
  type: TYPE_NORMAL
- en: Smart contracts should perform the same across different blockchains that support
    smart contracts. This is really useful for portability since users can easily
    start with Hyperledger Burrow and over time migrate their smart contracts to another
    platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'From this chart, it''s clear that Hyperledger as a portfolio of blockchain
    frameworks has some similar capabilities, but the frameworks have some substantial
    use case differences between them as well.  ## Introducing Hyperledger Fabric'
  prefs: []
  type: TYPE_NORMAL
- en: Hyperledger Fabric has wide acceptance as an enterprise blockchain and is Hyperledger's
    most active project. The number of developers using the GitHub repository is clearly
    well above other blockchain frameworks in Hyperledger.
  prefs: []
  type: TYPE_NORMAL
- en: However, I will compare Hyperledger Fabric to Burrow, Sawtooth, Iroha, and Indy
    since those frameworks all have very specific use cases but also have some functionality
    that overlaps in the framework portfolio as well that are worth noting.
  prefs: []
  type: TYPE_NORMAL
- en: Hyperledger Fabric as a project was started by Digital Asset and IBM and has
    now emerged as a collaborative cross-industry venture that is currently hosted
    by the Linux Foundation. Hyperledger Fabric was actually the first blockchain
    to exit the “Incubation” stage and achieve the “Active” stage in March 2017 within
    the Hyperledger Project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hyperledger Fabric is a blockchain implementation that is designed for deploying
    a modular and extensible architecture. It has a modular subsystem design so that
    different implementations can be added over time. The modular architecture of
    Hyperledger Fabric separates the transaction processing workflow into three different
    stages, as listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: Chaincode invocation and initiation where the client application requests access
    to the blockchain network.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Transaction processing and ordering, where the transactions are processed in
    order first and then validated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Transaction validation and commitment, where the transactions are validated
    and then committed to the blockchain ledger. The world state is updated as part
    of this step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These distinct steps provide multiple benefits to the enterprise such as a reduced
    number of trust levels and verification, which improve network scalability and
    performance. In other blockchains such as Ethereum, transactions are processed
    differently in the sense that they are deterministic, meaning they always yield
    the same result given the same input and the same logic.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 2.3](#c02-fig-0003) shows a typical Fabric network structure. As part
    of the structure you would have a client application, organizations, various types
    of peers, ordering peers, and membership services provider.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Flow chart illustrating the structure of a Hyperledger fabric network for
    trade between a shipper and a receiver. The blockchain flows through the rectangular
    boxes labeled client, order service node, client application, membership services
    provider, finally to Peer1.](images/c02f003.png)'
  prefs: []
  type: TYPE_IMG
- en: '[**FIGURE 2.3**](#R_c02-fig-0003) Hyperledger Fabric overview'
  prefs: []
  type: TYPE_NORMAL
- en: This figure shows a simple Fabric network setup with different peers, two organizations,
    and a client application. Hyperledger Fabric can scale to hundreds of peers, for
    example. I will be discussing scalability and performance around the enterprise
    blockchains in much more detail in [Chapter 3](c03.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: '### Hyperledger Fabric Ledger'
  prefs: []
  type: TYPE_NORMAL
- en: The Hyperledger Fabric ledger is an immutable record of blockchain transactions.
    State transitions are initiated by chaincode invocations that are *transactions*.
    A transaction may also be considered a *request* to update the ledger.
  prefs: []
  type: TYPE_NORMAL
- en: The result of each transaction is a set of asset key-value pairs that are committed
    to the ledger as a create/read/update/delete (CRUD) operation. This is also a
    transaction log.
  prefs: []
  type: TYPE_NORMAL
- en: A key-value pair is an effective way to represent and identify an asset in the
    Fabric ledger. For example, you would specify a key-value pair that is an asset
    such as a car whose data is stored in the Fabric ledger. The data is stored in
    a key-value pair.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of a key pair:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this example, “color” is the key, and “purple” is the value of the color.
    This key-value pair is then stored on the ledger, which maintains a record.
  prefs: []
  type: TYPE_NORMAL
- en: Assets are tracked, identified, or updated via a ledger request (transaction)
    such as a query or update. Simply put, the ledger is the actual blockchain. The
    ledger is a file-based ledger that stores serialized blocks. Hyperledger Fabric
    has some interesting capabilities that are outside the standard behavior for a
    blockchain. For example, the state database can always be rebuilt from reprocessing
    the ledger, and a transaction can be rolled back, for example, if a transaction
    is deemed not valid.
  prefs: []
  type: TYPE_NORMAL
- en: There are currently two options for the state database in Fabric as well. First
    is an embedded database called LevelDB. You can also choose an external CouchDB
    as another option.
  prefs: []
  type: TYPE_NORMAL
- en: Hyperledger Fabric Ledger has two distinct parts.
  prefs: []
  type: TYPE_NORMAL
- en: State data is a representation of the current state of the assets on the blockchain.
    Asset state data can be changed upon changes to the state of the data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Transaction logs record all the transactions in the order they are received
    that modified the state data. Once the data is written to the transaction logs,
    they are immutable and cannot be modified or deleted.  ### Hyperledger Fabric
    Consensus'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hyperledger Fabric's consensus is extensively broad and covers the whole transaction
    flow from start to finish.
  prefs: []
  type: TYPE_NORMAL
- en: In Hyperledger Fabric, nodes and peers can be somewhat confusing since they
    both have several roles. This is in stark contrast to Ethereum, for example, since
    the roles and tasks of nodes participating in reaching consensus are identical
    to each other. In a nutshell, every node in Ethereum does the same thing, but
    in Hyperledger nodes are very different in their missions on the blockchain network.
  prefs: []
  type: TYPE_NORMAL
- en: I discuss Hyperledger nodes in the “Nodes” section later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Consensus algorithms under Hyperledger are pluggable, meaning that users may
    select the algorithm of their choice during deployment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hyperledger Fabric 1.4 supports the following consensus methods at the time
    of writing:'
  prefs: []
  type: TYPE_NORMAL
- en: Kafka/Zab
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Raft
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SOLO
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 4](c04.xhtml) covers the options for consensus methods for Hyperledger,
    Ethereum, Corda, and Quorum.  ### Hyperledger Fabric Transactions'
  prefs: []
  type: TYPE_NORMAL
- en: Transactions in Hyperledger are requests to the blockchain to execute a function
    on the ledger. The function is implemented by chaincode, which is a decentralized
    transactional program running on the validating nodes. Chaincode transactions
    are time-bounded and configured during chaincode deployment, which is similar
    to a database call or a web service invocation.
  prefs: []
  type: TYPE_NORMAL
- en: If a transaction times out, for example, it is considered as an error and will
    not cause state changes on the blockchain ledger. One chaincode function can call
    another chaincode function if the called function has the same restrictive confidentiality
    scope. Basically, a confidential chaincode can call another confidential chaincode
    if they share the same group of validator nodes.
  prefs: []
  type: TYPE_NORMAL
- en: As transactions are run in a new block, a delta from the world state in the
    last block on the blockchain is maintained. A delta is a change in the world state
    of the blockchain. For example, if the last block is block 27000 and there is
    an update to the ledger, then the world state changes. Simply put, a new block
    equals a new state.
  prefs: []
  type: TYPE_NORMAL
- en: Hyperledger supports two types of transactions.
  prefs: []
  type: TYPE_NORMAL
- en: A *code-deploying transaction* is basically the initialization (`Init`) function
    of the blockchain application. `Init` is called when you first deploy your chaincode
    to the blockchain.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *code-invoking transaction* is called when you want to call (Invoke) chaincode
    functions to perform transactions on the blockchain. These transactions will be
    captured as blocks on the blockchain effectively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hyperledger Fabric is generally considered by the blockchain community as one
    of the simpler platforms for developing applications. This is because of the flexibility
    of the blockchain development support.
  prefs: []
  type: TYPE_NORMAL
- en: Transactions in Hyperledger Fabric have the following workflow. This can be
    significantly different from other blockchains.
  prefs: []
  type: TYPE_NORMAL
- en: A transaction proposal that will trigger chaincode is initiated by the client
    application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The transaction proposal will then transmit to the appropriate peers for endorsement
    as specified in policies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The endorsing peer will execute the chaincode and will write the actual transaction
    to the ledger.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The endorsing peer will sign the transaction and return it to the proposer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When comparing Hyperledger Fabric to Ethereum around the transaction workflow,
    you know that, for example, Ethereum uses the sequential execution style, whereas
    Hyperledger Fabric uses a nonsequential execution style for transactions.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 2.4](#c02-fig-0004) shows the contrast between common blockchain transaction
    execution styles. You can see that the two different execution styles vary. For
    example, one difference between the two is that the execute phase is started first
    non-sequentially. This could provide efficiencies in a permissioned blockchain
    that controls its membership but also could provide a response to the requester
    sooner.'
  prefs: []
  type: TYPE_NORMAL
- en: To sum up the Hyperledger Fabric transaction process, the process starts with
    a transaction proposal, which is initiated by a client. A client is a blockchain
    user with a chaincode application requesting access to the blockchain network.
    Then this transaction proposal is transmitted to the appropriate peers for endorsement
    as specified by an endorsement policy. An endorsing peer executes the chaincode,
    which results in an actual transaction for the ledger to maintain. The client
    receives the confirmation from the peers/nodes.
  prefs: []
  type: TYPE_NORMAL
- en: '![Flow charts comparing sequential and nonsequential blockchain execution styles.
    In sequential style, the process flows through three rectangular boxes are labeled
    as order, execute, state update. In nonsequential style, the process flows through
    four rectangular boxes labeled execute, order, validate, and state update.](images/c02f004.png)'
  prefs: []
  type: TYPE_IMG
- en: '[**FIGURE 2.4**](#R_c02-fig-0004) Comparing blockchain execution styles'
  prefs: []
  type: TYPE_NORMAL
- en: In summary, the Fabric network has a clear transaction order that needs to be
    maintained.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information on transactions, refer to the white paper “Hyperledger
    Fabric: A Distributed Operating System for Permissioned Blockchains” (`[https://www.hyperledger.org/wp-content/uploads/2017/08/Hyperledger_Arch_WG_Paper_1_Consensus.pdf](https://www.hyperledger.org/wp-content/uploads/2017/08/Hyperledger_Arch_WG_Paper_1_Consensus.pdf)`).  ###
    Hyperledger Fabric Nodes'
  prefs: []
  type: TYPE_NORMAL
- en: The concept of a node is common in all blockchain technologies. The node becomes
    the communication endpoint in the blockchain technology.
  prefs: []
  type: TYPE_NORMAL
- en: Nodes connect to other nodes, creating a decentralized network. Nodes use a
    form of a peer-to-peer protocol to keep the distributed ledger in sync across
    the network. In Hyperledger Fabric, nodes need a valid certificate to be able
    to communicate to the network, and the participants use applications that connect
    to the network by way of the nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, Hyperledger Fabric is a permissioned blockchain and membership, identity,
    and certificates are validated before transacting on the blockchain. A participant's
    identity is not the same as a node's identity and could be an organization. For
    example, when a participant executes or invokes a transaction, their certificate
    is used for signing that transaction and therefore validated as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important to note that not all nodes in Hyperledger are equal, unlike
    other blockchains where every node maintains a copy of the same ledger. In Hyperledger
    Fabric, there are three distinct types of nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Client nodes* initiate transactions for the client applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Peer nodes* commit transactions and keep the data in sync across the blockchain
    ledger.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Ordered nodes* are the communication backbones and responsible for the distribution
    of the transactions.  ### Hyperledger Fabric Business Networks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A business network models participants, assets, registries, and transactions.
    Transaction processors implement business logic on these elements. Access control
    lists (ACLs) define privacy and sharing settings.
  prefs: []
  type: TYPE_NORMAL
- en: The most efficient way to deploy a Hyperledger Fabric business network model
    is by using Composer Playground, an interactive web tool for testing and deploying
    business networks. Blockchain developers can opt to install it on Docker as well
    as locally if they choose.
  prefs: []
  type: TYPE_NORMAL
- en: 'The business network archive  (BNA) is created by using Hyperledger Composer.
    Composer is a tool that allows blockchain developers to package a few different
    files and generate an archive file, which can then be deployed onto a Fabric network.
    Composer is free for your developers to use and has a version that is available
    on IBM Cloud called Composer Playground.  ### Hyperledger Fabric Chaincode (Smart
    Contracts)'
  prefs: []
  type: TYPE_NORMAL
- en: '*Chaincode* is the term to describe a smart contract in Hyperledger Fabric.
    Smart contracts are fully supported on Hyperledger Fabric, and Golang and JavaScript
    are supported at the time of writing.'
  prefs: []
  type: TYPE_NORMAL
- en: Chaincode is application-level code stored on the ledger as part of a Hyperledger
    transaction. These transactions also modify the ledger state, which is known as
    the *world state*.
  prefs: []
  type: TYPE_NORMAL
- en: Chaincode is instantiated specifically on a channel or can be installed on several
    channels. A channel is a specific communication path used between peers looking
    for privacy. For example, if you have two channels, you can effectively deploy
    two versions of the code, and that code will not be accessible to the other code
    from another channel.
  prefs: []
  type: TYPE_NORMAL
- en: Client applications interact with the blockchain ledger through the chaincode
    methods `Init` and `Invoke`. The chaincode needs to be installed on every peer
    that will endorse a transaction and be instantiated on the channel. Specifying
    your membership policies would also be part of this chaincode strategy.
  prefs: []
  type: TYPE_NORMAL
- en: When creating chaincode, there are two methods that you will need to implement.
  prefs: []
  type: TYPE_NORMAL
- en: '`Init` is initially called when a chaincode receives an instantiate or upgrade
    transaction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Invoke` is called when the invoke transaction is received to process any transaction
    proposals.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you are developing a blockchain application, you will need to understand
    that creating both an `Init` method and an `Invoke` method within your chaincode
    is important.  ### Hyperledger Fabric Development Tools'
  prefs: []
  type: TYPE_NORMAL
- en: Hyperledger Composer is a development framework that is used for writing a blockchain
    network's chaincode and also is used for deploying the business network in Hyperledger
    Fabric.
  prefs: []
  type: TYPE_NORMAL
- en: There are two versions of Hyperledger Composer.
  prefs: []
  type: TYPE_NORMAL
- en: A downloadable local version, called Composer, that you would install on premises
    in a cloud platform.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An online version hosted by IBM Cloud called Hyperledger Playground.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can download Hyperledger Fabric Composer from GitHub at `[https://hyperledger.github.io/composer/latest/](https://hyperledger.github.io/composer/latest/)`.
  prefs: []
  type: TYPE_NORMAL
- en: You can access Hyperledger Fabric Composer Playground at `[https://composer-playground.mybluemix.net/](https://composer-playground.mybluemix.net/)`.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 2.5](#c02-fig-0005) shows the initial login screen to Hyperledger Composer
    Playground.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Screen capture depicting the web version of the initial login screen to Hyperledger
    Composer Playground with descriptions and artwork.](images/c02f005.png)'
  prefs: []
  type: TYPE_IMG
- en: '[**FIGURE 2.5**](#R_c02-fig-0005) Hyperledger Fabric Composer Playground web
    version initial screen'
  prefs: []
  type: TYPE_NORMAL
- en: Composer Playground is a web-based user interface that you can use to model
    and test your business network. Playground is good for modeling simple proof of
    concepts, as it uses the browser's local storage to simulate the blockchain network.
  prefs: []
  type: TYPE_NORMAL
- en: However, if you are running a local Fabric runtime and have deployed a network
    to it, you can also access that using Playground. In this case, Playground isn't
    simulating the network; it's communicating with the local Fabric runtime directly.
  prefs: []
  type: TYPE_NORMAL
- en: There are REST-based application programming interfaces (APIs) that can be used
    by client applications and that allow you to integrate non blockchain applications
    in the network. Representational State Transfer (REST) technology is an architectural
    style and services approach used in web services development.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are also two software development kits (SDK) available for Hyperledger
    Fabric v1.4: Java and Node are the supported languages at the time of writing.
    Other development languages such as Python and Go will likely be supported according
    to the Hyperledger wiki.'
  prefs: []
  type: TYPE_NORMAL
- en: 'SDKs are used to build applications for the blockchain and enable developers
    to have an onramp to the blockchain network to facilitate rapid development.  ###
    Hyperledger Fabric Governance'
  prefs: []
  type: TYPE_NORMAL
- en: 'Because Hyperledger Fabric is a private validator network protocol, all entities
    are required to register with membership services to obtain an identity. This
    identity provides access and a transaction authority on the network. Certificates
    are issued to members. Two certificates are required: enrollment certificates
    and transaction certificates.'
  prefs: []
  type: TYPE_NORMAL
- en: Hyperledger Fabric has permissioning governance built into every layer of the
    architecture. Operations such as starting a new consortium, adding or evicting
    members, defining a new channel, adding and evicting participants from channels
    all require collecting approval signatures from the appropriate organizations.
    The overarching policy model is enforced throughout the blockchain network.
  prefs: []
  type: TYPE_NORMAL
- en: Hyperledger Fabric has two levels of permissioning, and governance support based
    on either the consortium or the channel. A consortium is a membership-based network
    services made up of the membership of the organization.
  prefs: []
  type: TYPE_NORMAL
- en: 'Channels are supported as well, providing enhanced privacy or transactions
    through a point-to-point connection. Channels also provide a separate blockchain
    transaction ledger and network services. [Chapter 9](c09.xhtml), “Blockchain Governance,
    Risk, Compliance (GRC), Privacy, and Legal Concerns,” covers governance around
    Fabric in detail.  ## Introducing R3 Corda'
  prefs: []
  type: TYPE_NORMAL
- en: R3 is an enterprise blockchain software firm being developed by a broad ecosystem
    of more than 200 members and partners across multiple industries from both the
    private and public sectors. Corda is an open source blockchain platform, and Corda
    Enterprise is a commercial version of Corda blockchain platform for enterprise
    usage with Corda support.
  prefs: []
  type: TYPE_NORMAL
- en: The Corda platform was developed in close collaboration with a vast network
    of financial institutions, trade regulators, trade associations, professional
    services firms, and technology companies to leverage the power of blockchain to
    address specific business challenges. Corda was designed to meet the highest standards
    of one of the most complex and highly regulated industries in the world, which
    is the financial sector.
  prefs: []
  type: TYPE_NORMAL
- en: However, its blockchain services can be applied to other areas of business.
    Corda allows you to build interoperable blockchain networks that transact in strict
    privacy from other members.
  prefs: []
  type: TYPE_NORMAL
- en: Corda's smart contract technology (CorDapps) allows businesses to transact directly
    with industry-leading security features. I believe that Corda improves on the
    traditional custodial model that legacy financial services organizations have
    of acting as intermediary.
  prefs: []
  type: TYPE_NORMAL
- en: For example, it defines a standard approach and format for expressing financial
    assets and liabilities. The following are the main benefits of the enterprise
    market utilizing R3 Corda.
  prefs: []
  type: TYPE_NORMAL
- en: Corda smart contracts can be written in Java and other JVM languages and can
    accelerate the development process for enterprises with in-house expertise.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Corda has a flow framework to manage communication and negotiation between network
    participants. This network of participants is communicating via a direct peer-to-peer
    protocol where each node runs the Corda software as well as Corda applications
    known as CorDapps.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Corda has a unique “notary” infrastructure to validate uniqueness and sequencing
    of transactions without global broadcast to all network participants.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Corda enables the rapid development and deployment of distributed apps called
    CorDapps. CorDapps take the structure of a set of JAR files containing class definitions
    written in Java and/or Kotlin.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Corda was specifically designed to maintain a balance of trade-offs for business
    problems and domain concerns around the financial sector such as scalability and
    security.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Corda has a pluggable consensus, which allows blockchain developers to address
    trade-offs such as performance, scalability, security, and privacy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The financial sector is one of the most regulated industries not only in the
    United States but also around the world. Handling customer data while dealing
    with privacy and compliance concerns is a burdensome task for these organizations.
  prefs: []
  type: TYPE_NORMAL
- en: 'R3 Corda handles these challenges with trade-offs that regulated financial
    institutions may find favorable. These trade-offs include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Scalability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Privacy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Confidentiality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Complexity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compliance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling these trade-offs is exactly what R3 Corda was developed to address
    and does well through its structure of CorDapps.
  prefs: []
  type: TYPE_NORMAL
- en: Corda is a strictly engineered shared ledger fabric network for financial services
    use cases that can be deployed within existing legal frameworks and that relies
    on proven technologies that the financial sector depends on. R3 Corda has a strict
    and well-defined philosophy that can be broken down into three categories according
    to the Corda white paper (`[https://docs.corda.net/_static/corda-introductory-whitepaper.pdf](https://docs.corda.net/_static/corda-introductory-whitepaper.pdf)`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The three categories are:'
  prefs: []
  type: TYPE_NORMAL
- en: Engineering for the requirements of institutions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A focus on nonfunctional requirements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extensibility
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are essentially two direct approaches to deploying a blockchain network
    with R3 Corda.
  prefs: []
  type: TYPE_NORMAL
- en: '**Corda** is the open source blockchain platform, enabling businesses to transact
    directly and in strict privacy, reducing transaction and record-keeping costs
    and streamlining business operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Corda Enterprise** is an enterprise-ready commercial distribution of Corda
    specifically optimized to meet the demands of enterprises.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As shown in [Figure 2.6](#c02-fig-0006), the stack of Corda is actually quite
    simple. Corda has two versions: an enterprise or open source version with blockchain
    network services and on top of the stack is the CorDapp.'
  prefs: []
  type: TYPE_NORMAL
- en: '![A stack of four rectangular boxes illustrating the Corda structure, where
    three boxes are labeled as CorDapps, Corda Enterprise, and Corda Open Source (Core
    Components) from top to bottom. On the left side lies a rectangular box labeled
    as Corda Network.](images/c02f006.png)'
  prefs: []
  type: TYPE_IMG
- en: '[**FIGURE 2.6**](#R_c02-fig-0006) Corda stack structure'
  prefs: []
  type: TYPE_NORMAL
- en: R3 Corda certainly has a niche in the financial and insurance sectors but is
    expanding its use cases, for example, to other sectors. Currently, Corda would
    not be a good fit for a logistics company or a government services organization
    because of the overhead it would have compared to other blockchains such as Hyperledger.
    I will discuss more about R3 Corda and its use cases in [Chapter 8](c08.xhtml),
    “Enterprise Blockchain Use Cases.”
  prefs: []
  type: TYPE_NORMAL
- en: '### R3 Corda Blockchain Fundamentals'
  prefs: []
  type: TYPE_NORMAL
- en: From a technical perspective, R3 Corda is perhaps the most straightforward enterprise
    blockchain to understand. In my experience, there are several reasons for its
    clear success. The R3 Corda consortium has clearly defined the features, functions,
    and use cases with their consortium members. Corda is a platform for blockchain
    applications for financial enterprises where many applications share similarities
    with an IOU (payment/debt) use case. Corda maintains a vendor approach to development,
    training, and marketing that is well maintained, professional, and directed.
  prefs: []
  type: TYPE_NORMAL
- en: Corda documentation is clearly defined and professionally developed but also
    maintained by experts assigned by Corda. Finally, R3 Corda is the only enterprise
    blockchain to have a demo tool, Corda DemoBench.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Corda DemoBench tool lets you drive transactions in a blockchain. It is
    useful for performing demos and is free to use.  ### R3 Corda Network'
  prefs: []
  type: TYPE_NORMAL
- en: The Corda network is a fully connected “graph” network and does not use a gossip
    protocol. Corda communications actually occur point to point and, therefore there
    is somewhat less network overhead as compared to a gossip protocol, where broadcasts
    are sent to all network peers. Peers use a specific peer-to-peer Advanced Message
    Queuing Protocol (AMQP). AMQP is an open-standard Application layer protocol that
    is message-oriented and uses TLS for secure communications.
  prefs: []
  type: TYPE_NORMAL
- en: For privacy concerns, the peers do not broadcast to all other network peers,
    but instead they direct to the network peer required in the transaction.
  prefs: []
  type: TYPE_NORMAL
- en: Corda is a permissioned network that is specifically designed to address regulated
    financial institutions' concerns and is a natural fit for the banking sector,
    trading sector, and even the insurance sector.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 2.7](#c02-fig-0007) shows an example of how a Corda blockchain network
    would be set up with the affiliated Corda components. These Corda components are
    generally easy to plan and deploy. The main difference is that Corda has a somewhat
    different approach to naming components such as with a notary or a CorDapp.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Flow chart illustrating a Corda blockchain network from broker, to actuary
    service, to notary pool, finally to bank settlement, oracle service, and issue
    insurance policy.](images/c02f007.png)'
  prefs: []
  type: TYPE_IMG
- en: '[**FIGURE 2.7**](#R_c02-fig-0007) Corda network'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 3](c03.xhtml), “Architecting Your Enterprise Blockchain,” covers the
    deployment and architecture in more detail.  ### R3 Corda Ledger'
  prefs: []
  type: TYPE_NORMAL
- en: R3 Corda is a targeted distributed ledger technology (DLT) platform that uses
    an effective global broadcast and gossip network protocol to propagate data to
    other members in the blockchain network.
  prefs: []
  type: TYPE_NORMAL
- en: Corda uses a point-to-point messaging protocol (called AMPQ) where the broadcast
    is targeted and is not broadcast to all members on the network. Being that the
    protocol is point to point, only the nodes participating in the transaction will
    be privileged to the transaction ledger activity. This provides the main benefits
    of privacy to the members.
  prefs: []
  type: TYPE_NORMAL
- en: The Corda ledger has some significant differences from other blockchains that
    are noteworthy.
  prefs: []
  type: TYPE_NORMAL
- en: The Corda ledger allows for the management and synchronization of business agreements
    between multiple parties that can be designed as a legal contract. The Corda ledger
    was specifically designed to address interparty contracts that are regulated financial
    institutions, which other blockchains just cannot address efficiently.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no centralized ledger operating on behalf of all the nodes on the network,
    which can very different from other blockchains. Instead, each node on the network
    maintains a vault containing all of its known facts. A vault is storage space
    that maintains a secure area for protecting the known facts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Corda Ledger is subjective from each peer''s perspective, meaning that
    the ledger will be accessed differently by each peer depending on membership participation.
    What is somewhat unique is that not all on-ledger facts have to be shared by each
    member for all the other blockchain network members to view. Think about this
    as a “need-to-know” basis or a “compartmentalized” approach to a blockchain ledger.  ###
    R3 Corda Consensus'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Corda, as mentioned, is operating as a permissioned blockchain ledger for its
    financial-sector membership. This provides more fine-grained access control to
    records and enhances privacy for its membership. It also fair to assume that a
    performance benefit is achieved, as only parties (nodes) taking part in a transaction
    have to reach consensus. The transactions are not distributed to all other nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Corda allows potentially distrusting parties to reach consensus about the state
    of a set of shared facts. A mechanism is required to ensure all required parties
    agree on the state of the ledger. This capability for Corda to reach consensus
    is facilitated via a verification consensus or uniqueness consensus in Corda.
    This consensus approach in Corda is remarkably different from other blockchains.
  prefs: []
  type: TYPE_NORMAL
- en: Corda consensus is broken into two processes.
  prefs: []
  type: TYPE_NORMAL
- en: Transaction validity means that the parties involved can reach certainty that
    a proposed update transaction defining output states is valid by checking that
    the associated contract code runs successfully. It also has all the required signatures
    and that any transactions to which this transaction refers to are also valid.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transaction uniqueness is when the parties can reach certainty that the transaction
    in question is the unique and correct consumer of all its input states. That is,
    there are no other transactions around validity and uniqueness that will consume
    any of the same states.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parties can agree on transaction validity by independently running the same
    contract code and validation logic.
  prefs: []
  type: TYPE_NORMAL
- en: '#### CORDA NOTARY'
  prefs: []
  type: TYPE_NORMAL
- en: A *notary* is a network service that is unique to Corda. The notary service
    provides what is effectively a uniqueness consensus. One more way to view a notary
    is that it acts as a trusted party that guarantees a particular state is consumed
    only once. You can think of a state similarly to a funding in a wallet in Ethereum
    or the world state in Hyperledger Fabric.
  prefs: []
  type: TYPE_NORMAL
- en: The notary provides the point of finality in the system and is similar to an
    intermediary. The process a notary goes through to validate uniqueness is called
    *notarization*. Parties cannot be sure that an equally valid but conflicting transaction
    is regarded as a valid attempt to spend the given input state until the notary
    signature is obtained.
  prefs: []
  type: TYPE_NORMAL
- en: For example, each state will have an appointed notary and this notary will notarize
    the transaction only if it is the appointed notary of all the transaction's input
    states. Simply put, notaries are intermediaries who can both block transactions
    and resolve conflicts.
  prefs: []
  type: TYPE_NORMAL
- en: Corda has pluggable uniqueness services that can improve privacy, scalability,
    legal-system compatibility, and algorithmic agility. For example, a single service
    may be composed of many mutually non-trusting nodes coordinating via a Byzantine
    fault tolerant algorithm or it could be a very simple virtual machine.
  prefs: []
  type: TYPE_NORMAL
- en: These uniqueness services are required only to attest to whether the states
    consumed by a given transaction have previously been consumed; they are not required
    to attest to the validity of the transaction itself, which is a matter for the
    parties to the transaction.
  prefs: []
  type: TYPE_NORMAL
- en: What this really means is that the uniqueness services are not required to see
    the full contents of any transactions. This will significantly improve privacy
    and scalability of the system compared with alternative distributed ledger and
    blockchain designs. This Corda design decision represents an impressive choice
    as to the acceptable trade-offs in shared ledger architectures.
  prefs: []
  type: TYPE_NORMAL
- en: 'In short, the point of finality is reached once the notary service signs the
    transaction. However, there can be exceptions. If a transaction has no input states
    or timestamps, then the “uniqueness” of those properties clearly cannot be confirmed
    nor denied. A notary must be assigned to the transaction, but a notary signature
    is only needed when there are input states and/or timestamps.  ### R3 Corda Nodes'
  prefs: []
  type: TYPE_NORMAL
- en: The Java Virtual Machine (JVM) is used for contract execution and validation
    in Corda. This JVM provides several benefits because of the widespread use of
    Java and ease of development. The main point to realize before developing with
    the virtual machine is that it has been augmented with a customized sandbox that
    is more restrictive than the ordinary JVM sandbox. This restrictive virtual machine
    enforces security requirements.
  prefs: []
  type: TYPE_NORMAL
- en: In a nutshell, a Corda node is a JVM runtime environment with a unique identity
    on the blockchain network that hosts Corda services and CorDapps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Corda nodes can have four broad categories of functionality, which can be any
    of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Network map provides a way to resolve identities to physical node addresses
    and associated public keys.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notary acts as a “witness” to the transactions and has the final say in whether
    a transaction is a double-spend.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Oracle is an access point that links the ledger to the outside world by providing
    facts that affect the validity of transactions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Regular mode starts protocols communicating with other nodes, notaries, and
    oracles, and evolves their private ledgers on the network.  ### R3 Corda States'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One of the differentiators between other distributed ledger technologies and
    Corda is how the state of blockchain ledger is actually handled. Corda uses the
    term *state* to mean a representation of immutable objects with shared facts such
    as an agreement or contract at a specific point in time.
  prefs: []
  type: TYPE_NORMAL
- en: The terms *shared facts* and *states* can essentially mean the same thing and
    are generally used interchangeably. Let's clarify what a *state* can be in Corda
    from a ledger perspective. A state may represent anything that the member agrees
    upon, such as a bank note, invoices, and so on at a specific time. This is similar
    to a world state in other blockchains. A static state means that there is no change
    to the representation of the object being defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you are familiar with the financial sector, then you can have
    states representing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Collateralized debt obligations (CDOs)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collateralized loan obligations (CLOs)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Invoices or statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bank credits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Credit default swaps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rate swaps such as interest rates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bonds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basically, in Corda the state model can be used to represent literally anything
    that is part of an agreement. A state can be used to represent financial instruments
    or multilateral agreements, assets, or liabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Different types of states can contain different attributes. For instance, a
    trade bond could have a coupon date, a redemption date, and so on. States are
    immutable and therefore cannot be changed to another state after created. States
    contain data about shared facts at a specific point in time.  ### R3 Corda Transactions'
  prefs: []
  type: TYPE_NORMAL
- en: Transactions in R3 Corda are very specific in the sense that it's clearly defined
    which command is to be issued. For example, in Corda, we would declare intent
    as “Issue” or “Agree” in a CorDapp, and the CorDapp would determine whether the
    transactions are valid.
  prefs: []
  type: TYPE_NORMAL
- en: Assume your organization wants to declare which type of transaction is being
    agreed upon. When you design a CordApp, you need to identify the type of transactions
    appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: Transactions in R3 Corda are propagated around the network but are not broadcast
    to every node. The broadcast is verified more on a need-to-know approach. This
    allows members to ensure that they maintain privacy around transactions.
  prefs: []
  type: TYPE_NORMAL
- en: 'This transaction approach is comparable to channeling in Hyperledger where
    you have nodes in the network that can be placed on a channel to communicate for
    privacy concerns.  ### R3 Corda Client Applications'
  prefs: []
  type: TYPE_NORMAL
- en: When considering client applications to integrate with R3 Corda in your enterprise,
    you must realize that Java or Kotlin is used for the Corda APIs. This is not exactly
    a showstopper but something to be aware of. Corda, however, does provide a full
    client library that allows your developers to write clients in a JVM-compatible
    language to interact with the running nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Corda has provided a sample CorDApp for those that would appreciate a tutorial
    in Corda. You can find it at `[https://docs.corda.net/tutorial-cordapp.html](https://docs.corda.net/tutorial-cordapp.html)`.
    For community-driven applications, visit `[https://www.corda.net/develop/samples.html](https://www.corda.net/develop/samples.html)`.  ###
    R3 Corda Smart Contracts'
  prefs: []
  type: TYPE_NORMAL
- en: In R3 Corda, smart contracts are also referred to as *contracts* and may be
    legally enforceable when the legal prose has been agreed upon by the participants
    in the CordApps. Comparatively, in Ethereum, a smart contract is a singular program
    and not an enforceable contract.
  prefs: []
  type: TYPE_NORMAL
- en: In Corda, these contracts are deployed via a CorDapp, which is simply a collection
    of contracts working together as an application. In Ethereum this is called a
    *distributed application* (dapp).Realize that these contracts are somewhat different
    from the smart contracts of other blockchain platforms such as Ethereum. In Corda,
    these contracts are not stateful objects representing the current state of the
    world but more like real-world contracts that may have legal prose attached as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: States can contain arbitrary data, allowing them to represent facts such as
    a stock trades, bank notes, or loans, for example.
  prefs: []
  type: TYPE_NORMAL
- en: R3 Corda smart contracts (CordApps) consist of computer code but also can contain
    legal prose that is attached. This is a big differentiator between other blockchains
    since this feature was clearly planned for its members.
  prefs: []
  type: TYPE_NORMAL
- en: Above the smart legal contracts is specific legal prose that are formulated
    in a way that they can be expressed and implemented in smart contract code. The
    rationale behind this is to give the code legitimacy that is affiliated in the
    associated legal prose.
  prefs: []
  type: TYPE_NORMAL
- en: This specific construct historically has been called a Ricardian contract in
    the financial sector. The Ricardian contract was devised by Ian Grigg in 1996,
    as a method of recording a document as a contract of law and linking it securely
    to other systems, such as accounting, as an issuance of value.
  prefs: []
  type: TYPE_NORMAL
- en: In the blockchain world, Ricardian contracts are nothing more than digital documents
    that define the detailed terms and conditions of a contract. These contracts are
    usually signed and agreed to by both parties. This Ricardian contract approach
    is used to mitigate current contract issues but also provides clarity to any contract
    challenges in the future.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, a CorDapp is a Ricardian contract that is written with the standard
    legal prose that is required in court and then is cryptographically hashed to
    be available for usage by the application. Corda also has an interesting approach
    that allows a regulatory body to actually be given oversight access. This regulatory
    body can also be brought into the network to act as an observer to verify the
    contract as well (see [Figure 2.8](#c02-fig-0008)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Flow chart illustrating the Corda smart contract legal prose, which involves
    four stages, namely CorDaFlow chart illustrating the Corda smart contract legal
    prose involving four stages, namely cordapp, regulatory, legal body, and settlement.
    The handshake symbol depicts successful agreement and letter symbol depicts the
    attached legal prose.pp, regulatory, legal body, and settlement.](images/c02f008.png)'
  prefs: []
  type: TYPE_IMG
- en: '[**FIGURE 2.8**](#R_c02-fig-0008) Corda smart contract with legal prose'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the benefits of smart contracts (CorDapps) in Corda specifically
    for financial institutions that use Corda:'
  prefs: []
  type: TYPE_NORMAL
- en: Smart contracts regulate and streamline the workflow between the participating
    decentralized firms.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These CorDapps also include supervisory and regulatory nodes that provide an
    observer responsibility.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The consensus algorithms are limited & to the firms involved.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access to the data within an agreement is limited to the permissioned parties
    involved.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The CordApps also validate the transaction solely between the two parties that
    are participating.  ### R3 Corda Development Tools'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: R3 Corda, being a private consortium that was built from the ground up to develop
    enterprise blockchains for its consortium members, has a wealth of documentation,
    tools, and services. Corda has a large following of developers, and Corda as an
    organization provides, in my opinion, superior community events that really help
    drive development.
  prefs: []
  type: TYPE_NORMAL
- en: '**Corda DemoBench** DemoBench is a stand-alone desktop application that makes
    it easy to configure and launch local Corda nodes. It is useful for training sessions,
    demos, and experimentation. To learn more, visit'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[https://www.corda.net/discover/demobench.html](https://www.corda.net/discover/demobench.html)`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Figure 2.9](#c02-fig-0009) shows the starting window after you launch Corda
    DemoBench. We can configure our node and also determine the type of notary in
    Corda Demobench. After you download and install DemoBench, you can start adding
    nodes and notaries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Screen capture depicting the initial window that appears after launching
    Corda DemoBench, where a node can be configured and the type of notary can be
    determined. Left column depicts the cordapp extension, and the right column depicts
    the type of configuration.](images/c02f009.png)'
  prefs: []
  type: TYPE_IMG
- en: '[**FIGURE 2.9**](#R_c02-fig-0009) Corda DemoBench initial screen'
  prefs: []
  type: TYPE_NORMAL
- en: I cover the installation, configuration and walk thru a demo in [Chapter 5](c05.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: '**Node Explorer** “The Node Explorer provides views to the node''s vault and
    transaction data using Corda''s RPC framework.”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[https://ci-artifactory.corda.r3cev.com/artifactory/corda-releases/net/corda/corda-tools-explorer/3.2-corda/](https://ci-artifactory.corda.r3cev.com/artifactory/corda-releases/net/corda/corda-tools-explorer/3.2-corda/)`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Blob Inspector** With Corda 3, R3 Corda has guaranteed a wire stable AMQP
    serialization format. As a binary format, it has various advantages over text-based
    protocols but also has the same downside: lack of human readability. The Blob
    Inspector fills this gap. Given a file path or URL, it will display the contents
    of Corda blobs in YAML or JSON.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can find documentation for the Blob Inspector here:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`[https://docs.corda.net/head/blob-inspector.html](https://docs.corda.net/head/blob-inspector.html)`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can download the Blob Inspector from here:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`[https://ci-artifactory.corda.r3cev.com/artifactory/corda-releases/net/corda/corda-blob-inspector/3.2-corda/corda-blob-inspector-3.2-corda.jar](https://ci-artifactory.corda.r3cev.com/artifactory/corda-releases/net/corda/corda-blob-inspector/3.2-corda/corda-blob-inspector-3.2-corda.jar)`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Network Bootstrapper** “This is a tool that scans all the node configurations
    from a common directory to generate the network parameters file, which is then
    copied to all the nodes'' directories. It also copies each node''s node-info file
    to every other node so that they can all be visible to each other. You can find
    the documentation for the Network Bootstrapper here:”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[https://docs.corda.net/head/network-bootstrapper.html](https://docs.corda.net/head/network-bootstrapper.html)`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: “You can download the latest version from here:”
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`[https://ci-artifactory.corda.r3cev.com/artifactory/corda-releases/net/corda/corda-network-bootstrapper/3.2-corda/corda-network-bootstrapper-3.2-corda-executable.jar](https://ci-artifactory.corda.r3cev.com/artifactory/corda-releases/net/corda/corda-network-bootstrapper/3.2-corda/corda-network-bootstrapper-3.2-corda-executable.jar)`.  ###
    R3 Corda Governance'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Governance in Corda is clearly an important priority because of the nature of
    its financial sector clients where compliance and liability are a great concern
    to its consortium members.
  prefs: []
  type: TYPE_NORMAL
- en: Corda uses a unique approach to transaction oversight through the use of a notary
    oversight procedure. A notary is considered a trusted party that guarantees that
    a particular state is consumed only once in Corda. This guarantee of state in
    Corda from the notary eliminates challenges such as any double spending issues,
    over drafting your account, and even can deal with currency exchange–based issues.
  prefs: []
  type: TYPE_NORMAL
- en: Notaries are the main blockchain network's governance structure in a sense because
    they validate the transaction uniqueness and the participation in the network.
  prefs: []
  type: TYPE_NORMAL
- en: In Corda, there is no unified blockchain that contains a record of all the transactions.
    Corda has a different approach where the Corda nodes will see only those transactions
    in which they are directly involved or which they depend on historically for validation
    purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, the Corda nodes are responsible for checking transaction correctness
    and authorizing the transactions. The Corda nodes fully rely on notaries to verify
    the uniqueness of transactions and provide governance of the blockchain, which
    is a critical part of the governance structure.  ## Introducing Quorum'
  prefs: []
  type: TYPE_NORMAL
- en: Quorum is an open source blockchain solution built by enhancing the existing
    Ethereum blockchain. Quorum is based on the official Go implementation of the
    Ethereum protocol, which provides almost a mirror of Ethereum features and benefits.
  prefs: []
  type: TYPE_NORMAL
- en: Quorum provides an additional layer on top of Ethereum that enables it to perform
    private transactions but also makes it more flexible by using different consensus
    algorithms. Quorum overall was designed as a permissioned implementation of Ethereum
    that supports the enterprise requirements of transaction privacy and contract
    privacy.
  prefs: []
  type: TYPE_NORMAL
- en: The main use case for Quorum is that it can achieve data privacy through the
    introduction of a new “private” transaction identifier with modifications to the
    Ethereum codebase. These modifications are provided in the Go-Ethereum codebase,
    which includes modifications to the block proposal and validation processes. Data
    privacy in Quorum is achieved through cryptography and also through an intentional
    segmentation of the nodes similar to sandboxing.
  prefs: []
  type: TYPE_NORMAL
- en: The main reason an enterprise would choose Quorum over Ethereum is privacy;
    a secondary reason is that Quorum is based on Ethereum, which has a robust and
    active development base making it easy to find expertise.
  prefs: []
  type: TYPE_NORMAL
- en: Quorum supports private transactions and private contracts through public and
    private state segmentation. Quorum supports privacy by using a newer messaging
    exchange called Constellation. Constellation is a peer-to-peer encrypted message
    exchange used for the targeted transfer of private data to network participants.
    This messaging exchange is similar to what we have in Hyperledger with the implementation
    of Kafka.
  prefs: []
  type: TYPE_NORMAL
- en: Quorum offers options for consensus mechanisms that are considered desirable
    for a consortium use case. For example, Istanbul Byzantine fault tolerance and
    a Raft-based consensus are two consensus methods that support enterprise features
    such as fault tolerance and availability.
  prefs: []
  type: TYPE_NORMAL
- en: Quorum Chain is a new consensus that is based on a majority voting and time-based
    mechanism that supports Ethereum-based transactions that can be propagated through
    the network.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 2.10](#c02-fig-0010) shows the high-level components of the Quorum
    blockchain. You can see that there is a Quorum node with Go-Ethereum, which extends
    the capabilities to the Ethereum network.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Schematic diagram illustrating the components of Quorum blockchain. The boxes
    labeled Node, Go-Ethereum, Constellation, Transaction Manger, Enclave, Private
    Ethereum Network, Client Apps are the blockchain components.](images/c02f010.png)'
  prefs: []
  type: TYPE_IMG
- en: '[**FIGURE 2.10**](#R_c02-fig-0010) Quorum blockchain components'
  prefs: []
  type: TYPE_NORMAL
- en: 'Constellation is a mechanism for submitting information and allows encrypted
    communication between peers. Constellation consists of two parts: a transaction
    manager and Enclave.'
  prefs: []
  type: TYPE_NORMAL
- en: Permissions at the node level are governed by smart contract code. The main
    benefit is that it provides a higher level of performance compared to the public
    Ethereum blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: 'The primary features of Quorum over public Ethereum are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Transaction and contract privacy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple voting-based consensus mechanisms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network/peer permissions management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Better performance and scalability because of its simple consensus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Quorum, a transaction has to be either public or private. If the transaction
    is private, all the data within that transaction is private for that set of entities
    in the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: In a nutshell, Quorum is open source and more approachable for some organizations
    than implementing a custom private blockchain on other platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Quorum aims to be a platform that allows integration and experimentation with
    not only the financial industry, but also other companies interested in the blockchain
    technology using a proven platform on Ethereum.
  prefs: []
  type: TYPE_NORMAL
- en: '### Quorum Blockchain Fundamentals'
  prefs: []
  type: TYPE_NORMAL
- en: Quorum is a private/permissioned blockchain platform based on the official Go
    implementation of the Ethereum protocol with an enterprise focus. Quorum was built
    on top of an existing Ethereum blockchain and inherits the maturity of the production-hardened
    “go-Ethereum” code base. Quorum has brought together the public and enterprise
    development communities on a common protocol to work for the financial sectors.
  prefs: []
  type: TYPE_NORMAL
- en: Quorum uses a voting-based consensus algorithm extremely effectively and then
    achieves data privacy through the introduction of a new “private” transaction
    identifier.
  prefs: []
  type: TYPE_NORMAL
- en: One of the clearly stated design goals of Quorum was to reuse as much existing
    technology as possible from Ethereum to minimize the changes required for Go-Ethereum
    to work efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: Strategically, for example, this plan actually reduced the effort required to
    keep in sync with future versions of the public Ethereum codebase. Much of the
    logic responsible for the additional privacy functionality resides in a layer
    that sits on top of the standard Ethereum protocol layer.
  prefs: []
  type: TYPE_NORMAL
- en: Based on its official description, Quorum is essentially an extension of Ethereum
    through a strategic fork of its code base. The Quorum blockchain has many similarities
    to Ethereum. Quorum has a clear mission to provide the best features of a permissionless
    blockchain with the added privacy, security, and performance of a permissioned
    blockchain for a targeted audience.
  prefs: []
  type: TYPE_NORMAL
- en: Quorum was developed by J.P. Morgan Chase and its consortium members. Quorum
    is one of the first major steps toward the common adoption of blockchain among
    financial industries.
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, Quorum functions similarly to Ethereum but has four very significant
    differences or areas to appreciate when compared to native Ethereum.
  prefs: []
  type: TYPE_NORMAL
- en: Network and peer permissions management to sandbox transactions on a private
    Ethereum platform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increased transaction and contract privacy through private transactions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Voting-based consensus mechanisms not available in Ethereum
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Higher performance due to limited nodes  ### Quorum Ledger'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This system has two distinct types of possible transactions in Quorum, which
    are public and private transactions. *Public transactions* are transactions where
    the payload is fully visible to all participants. These publicly viewable transactions
    are the standard Ethereum transactions you're expecting on the Ethereum blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: '*Private transactions* are different where the payload is visible only to participants
    whose public keys are specified in the `privateFor` parameter of the transaction.  ###
    Quorum Consensus'
  prefs: []
  type: TYPE_NORMAL
- en: Consensus in Quorum is somewhat more flexible than other blockchains. For example,
    Quorum offers options for consensus mechanisms that are considered desirable for
    consortium use cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'These consensus choices are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Istanbul Byzantine fault tolerance and raft-based consensus are consensus methods
    that support enterprise features such as fault tolerance and availability.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quorum Chain is a newer consensus based on a majority voting and time-based
    mechanisms that support Ethereum-based transactions that can be propagated through
    the network, for example.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There exists two blockchain states in Quorum. The first state is the public
    state shared by all nodes of public transactions, and the second state is the
    private state local to each node for the private transactions the nodes are authorized
    for.  ### Quorum Smart Contracts'
  prefs: []
  type: TYPE_NORMAL
- en: As previously mentioned, Quorum is based on Ethereum and is a fork of the Ethereum
    blockchain. With that being said, implementing and using Ethereum smart contracts
    will be quite familiar to Ethereum developers.
  prefs: []
  type: TYPE_NORMAL
- en: Quorum uses the standard Solidity language for writing smart contracts. This
    provides immense value since you can design as you have been in Ethereum.
  prefs: []
  type: TYPE_NORMAL
- en: One of the differentiators is that smart contracts can be either public or private
    to one or more network participants on the Quorum blockchain network.
  prefs: []
  type: TYPE_NORMAL
- en: The main difference is that with Quorum you can send a private transaction using
    the Ethereum network protocols. In Quorum, you can send a private transaction
    by coding your smart contract to address this requirement for a private transaction.
  prefs: []
  type: TYPE_NORMAL
- en: On a Quorum network you would send a standard Ethereum transaction but set the
    `privateFor` parameter on the message to be the public key of the participant
    that should be able to view and execute the transaction or contract code.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 2.11](#c02-fig-0011) shows a private transaction in a know your customer
    (KYC) use case.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image described by caption and surrounding text.](images/c02f011.png)'
  prefs: []
  type: TYPE_IMG
- en: '[**FIGURE 2.11**](#R_c02-fig-0011) KYC private transaction in Quorum'
  prefs: []
  type: TYPE_NORMAL
- en: For more on this, go to `[https://github.com/jpmorganchase/quorum/wiki/Using-Quorum](https://github.com/jpmorganchase/quorum/wiki/Using-Quorum)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Private contracts cannot update public contracts. This is intentional, as not
    all participants will be able to execute a private contract. It is important to
    note that once a contract has been made public, the contract cannot be made private
    later. For a public contract to become private, it would need to be deleted from
    the blockchain and a new private contract would have to be created.  ### Quorum
    Tools and Utilities'
  prefs: []
  type: TYPE_NORMAL
- en: Quorum is based on Ethereum, as we already know, so this allows smart contracts
    to be built with Solidity. Quorum also shares some core development tools with
    Ethereum. One of those tools is Truffle, which is exactly what the majority of
    Ethereum developers are likely using already.
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, an Ethereum developer will have very little development ramp-up
    time and learning curve for integrating the Quorum blockchain solution due to
    the use of Ethereum tools and utilities.
  prefs: []
  type: TYPE_NORMAL
- en: One tool that was built specifically for Quorum is called Cakeshop. Cakeshop
    provides an easy-to-use graphic interface (GUI) for working with Quorum networks,
    smart contracts, and Quorum APIs. Cakeshop can start up a Geth node, which you
    can then interact with using the Cakeshop front end or can be connected to an
    Ethereum-like node, such as Quorum, that you already have running. The given Cakeshop
    instance will connect with only one node on the blockchain network you specify.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can download the Cakeshop GUI from `[https://github.com/jpmorganchase/cakeshop/wiki/Cakeshop-Overview](https://github.com/jpmorganchase/cakeshop/wiki/Cakeshop-Overview)`.
    For more about Quorum development and tools, please refer to [Chapter 10](c10.xhtml).  ###
    Quorum Governance'
  prefs: []
  type: TYPE_NORMAL
- en: Quorum's permissioned chain is a consortium blockchain and was devised to be
    implemented between participants who are pre-approved by a designated authority.
  prefs: []
  type: TYPE_NORMAL
- en: Because Quorum is a fork of the Ethereum blockchain, governance is not exactly
    supported well. For example, as in Ethereum, a per-node permissioning capability
    can be set up via smart contracts to provide some governance. It is expected,
    as funding comes from the Enterprise Ethereum Alliance (EEA), that governance,
    compliance, and other enterprise concerns will be addressed more in detail.
  prefs: []
  type: TYPE_NORMAL
- en: It's important to note that the Quorum road map of private transactions and
    smart contracts is on the project list for the development team to work on.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also important to note that Quorum has been working with the Zcash team
    to integrate the zero-knowledge security layer (ZSL) into the Quorum protocol.
    These important and highly requested future features could provide some additional
    benefits around compliance, security, and privacy.  ## Introducing Ethereum'
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum is an open source platform based on blockchain technology that enables
    developers to build and deploy decentralized applications (smart contracts).
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum is essentially a world computer that is distributed between thousands
    of nodes. This computer of many distributed nodes is accessible to anyone, anywhere,
    with Internet access. There are no membership requirements to address, and it
    is truly a public blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: The first public beta prerelease network was known as Olympic. The Olympic network
    provided users with a bug bounty of 25,000 Ethers for stress testing the limits
    of the Ethereum blockchain. Ether is the token utilized for using the Ethereum
    network.
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum is software running on a network of world computers that ensures that
    data and small computer programs called *smart contracts* are replicated and processed
    on all the computers on the network, without a central coordinator. The founders'
    vision was to create an unstoppable censorship-resistant self-sustaining decentralized
    world computer. For example, if you download Ethereum to your computer, it will
    become an Ethereum “node” on the network, running an EVM, and will behave equivalently
    to all the other nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Note that Ethereum is a peer-to-peer network, and there is no centralization;
    therefore, all computers have equivalent status to other nodes. [Figure 2.12](#c02-fig-0012)
    shows the peer-to-peer decentralized network of Ethereum. The network nodes for
    Ethereum run the Ethereum virtual machine. Note that the network structure is
    not flat or hierarchical, like in common networking.
  prefs: []
  type: TYPE_NORMAL
- en: '![Schematic diagram of ethereum peer-to-peer decentralized network consists
    of ledger, mining node, and dapp as symbols, and hexagonally interlinked with
    one another.](images/c02f012.png)'
  prefs: []
  type: TYPE_IMG
- en: '[**FIGURE 2.12**](#R_c02-fig-0012) Ethereum peer-to-peer decentralized network'
  prefs: []
  type: TYPE_NORMAL
- en: '### Ethereum Blockchain Fundamentals'
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum is the blockchain platform, and ether is the token for using the Ethereum
    virtual machines on the Ethereum platform. Ethereum is a permissionless blockchain
    and has a different approach than the other blockchains discussed earlier in the
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: While all blockchains have the ability to process code, most of the blockchains
    are severely limited by restrictions. Ethereum approaches code differently by
    allowing developers to create whatever operations they want. This means developers
    can build thousands of different applications that go outside the typical blockchain
    structures.
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum contracts have memory and can also have loops, which I will address
    in more detail from a development perspective in [Chapter 10](c10.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum implements smart contracts, which are usually deployed via distributed
    applications that are known as *dapps*. Dapps are applications running directly
    on the blockchain. They are decentralized and not in the control of any one party.
    Their purpose is clearly to use simple logic for peer-to-peer value transfers
    to extend over to more complicated token structures and much more.
  prefs: []
  type: TYPE_NORMAL
- en: These smart contracts and dapps work similarly from an application perspective
    to any other web application. A client application will access an Ethereum application
    via the HTTP protocol through an API. The smart contract will then be invoked
    and will run on the EVM.
  prefs: []
  type: TYPE_NORMAL
- en: Because the economics and the logic are on the same layer, it makes value transfer
    extremely easy. You can save hardware and configuration by deploying the logic
    directly on the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: Ether tokens are created by a schedule that was set by its 2014 presale structure.
    Ether tokens are mined and thus require a miner. For example, 5 ether tokens are
    created for every block mined, which is approximately every 15 seconds. These
    5 ether tokens are sent to the miners that mine the block. Ether can also be sent
    to another miner that participates in the transaction since it is possible that
    several miners to compete for the mining of the blocks. Ether is considered the
    “fuel” that runs the Ethereum network.
  prefs: []
  type: TYPE_NORMAL
- en: '#### PROOF-OF-WORK MINING'
  prefs: []
  type: TYPE_NORMAL
- en: In proof-of-work (PoW) mining, the miners compete to create valid blocks by
    spending electricity to find solutions to a mathematical puzzle. Ethereum's PoW
    math challenge called Ethash works slightly differently than Bitcoin's PoW mining.
    This allows common hardware to be used for mining and lowers the barrier to mining
    at least from a cost perspective. The downside to this is that it reduces the
    efficiency edge of task-specific hardware known as ASICs, which are common in
    Bitcoin mining.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a plan to move from energy-intensive PoW mining to a more energy-efficient
    proof-of-stake protocol called Casper. This was scheduled to start to occur in
    2018 and early 2019, but was postponed because of several factors. The updated
    version of the Ethereum software will be called Serenity.  #### TOKEN STANDARDS'
  prefs: []
  type: TYPE_NORMAL
- en: In Ethereum, tokens must adhere to token standards, which define a common list
    of protocols that an Ethereum token has to implement. The most common token standard
    is the ERC20 standard.
  prefs: []
  type: TYPE_NORMAL
- en: The ERC20 standard is basically a set of six functions that can be recognized
    and identified by other smart contracts for interactions with the smart contracts.
    Some of the functions are to get the total token supply, get the account balance
    of the wallet, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: This token standard gives developers the ability to program behavior of new
    tokens within the Ethereum ecosystem. Second, this approach is common with crowdfunding
    companies via initial coin offerings (ICOs). An ICO is a similar concept to an
    initial public offering (IPO) in stock markets.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find out more about ether tokens at `[https://etherscan.io/tokens](https://etherscan.io/tokens)`.  ###
    Ethereum Ledger'
  prefs: []
  type: TYPE_NORMAL
- en: In Ethereum, consensus is when the distributed ledger has been updated and all
    nodes maintain their own identical copy of the ledger. This architecture allows
    for a new capacity as a system of record-keeping that goes beyond being a simple
    database. Blocks form a chain by referring to the hash or fingerprint of the previous
    block and are written to the ledger.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that every node in the network holds a copy of the transaction and
    smart contract history of the network. The nodes also keep track of the current
    “state” on the ledger. Every time a user performs some action, all the nodes on
    the network need to come to agreement that this change took place and have it
    written to the ledger.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, every time a program (smart contract application) is used, a network
    of thousands of computers processes it. Contracts written in a smart contract–specific
    programming language that are compiled into what is called *bytecode* will be
    read by the EVM. Then all the nodes execute this contract using their EVMs, which
    in turn update the ledger.  ### Ethereum Node EVM'
  prefs: []
  type: TYPE_NORMAL
- en: The Ethereum Virtual Machine (EVM) is computer software that runs on an abstraction
    layer right above the underlying hardware that is deployed such as a physical
    server or a container.
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum uses a virtual machine to deploy the blockchain services. This virtual
    machine type is considered a Turing complete virtual machine that will run and
    compile the code directly. Turing complete means the software is agile enough
    to run any code defined by the developer. In the development world, this Turing
    complete machine is also considered a flexible virtual machine.
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum itself is a protocol defining how the communication should work. It
    is neither proprietary software nor patented. Instead, it is open, and there are
    several different implementations of the Ethereum protocol.
  prefs: []
  type: TYPE_NORMAL
- en: Two of the most popular implementations are Go-Ethereum (Geth), which is written
    in Go, and Parity, which is written in Rust.
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum nodes communicate with each other using the Ethereum protocol. There
    are several different ways to connect to an Ethereum node.
  prefs: []
  type: TYPE_NORMAL
- en: You can connect via HTTP and IPC protocols; WebSocket connections as well may
    be supported.
  prefs: []
  type: TYPE_NORMAL
- en: The Ethereum node accepts requests in a JSON-RPC format via HTTP. This is a
    standardized way of communicating with Ethereum nodes from clients. Using this
    approach, any software that implements the JSON-RPC calls should be able to connect
    to the blockchain via an Ethereum node.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some important notes about the EVM:'
  prefs: []
  type: TYPE_NORMAL
- en: The only real limitation the EVM has that a typical Turing complete machine
    does not is that the EVM is intrinsically bound by gas.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The power of the EVM is limited only by the amount of gas that is provided by
    the developer request.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The EVM is a stack-based VM, meaning that it uses an ordering structure that
    processes last-in, first-out ordering.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flexibility around the development of smart contracts can be in Python, Java,
    or C++ at the time of writing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Isolation is achieved when fully deployed since smart contracts are fully isolated
    from the blockchain network.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Figure 2.13](#c02-fig-0013) shows how the EVM fits into the stack.'
  prefs: []
  type: TYPE_NORMAL
- en: '![The rectangular box contains two columns. The first column divided into five
    rows labeling wallet application; decentralized application; swarm, whisper, and
    EVM in individual box; distributed client hardware; and internet. The second column
    labeled ethereum.](images/c02f013.png)'
  prefs: []
  type: TYPE_IMG
- en: '[**FIGURE 2.13**](#R_c02-fig-0013) EVM in the Ethereum stack'
  prefs: []
  type: TYPE_NORMAL
- en: When joining the Ethereum network, you have some options from a blockchain node
    perspective.
  prefs: []
  type: TYPE_NORMAL
- en: '**Light nodes** are nodes that do not verify every block or transaction and
    do not have a copy of the current blockchain state. These nodes are generally
    used for development.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Full nodes** verify every block that is broadcast onto the blockchain network.
    When you set up a full node, the full blockchain is also downloaded to that node.
    This could be significant storage space since at the time of writing is more than
    180 GB.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Archive nodes** are full nodes that preserve the entire history of transactions
    and could be used for compliance requirements in some cases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Ethernode.org](http://ethernode.org) displays the current state of network
    nodes connected to the blockchain. At the time of writing, there are more than
    13,600 nodes. The site also displays the mainnet and testnet. To find out the
    current Ethereum nodes on the blockchain, visit `[https://www.ethernodes.org/network/1](https://www.ethernodes.org/network/1)`.  ###
    Ethereum Client Apps'
  prefs: []
  type: TYPE_NORMAL
- en: 'Developing applications to interface with the Ethereum APIs is straightforward.
    Generally, the following front-end development languages are used with Ethereum:'
  prefs: []
  type: TYPE_NORMAL
- en: HTML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CSS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following backend tools are commonly used:'
  prefs: []
  type: TYPE_NORMAL
- en: Solidity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Truffle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can download Solidity or compile with your browser.
  prefs: []
  type: TYPE_NORMAL
- en: '#### SOLIDITY'
  prefs: []
  type: TYPE_NORMAL
- en: Solidity is the development language behind Ethereum and is specifically designed
    to utilize the EVM. Developers who are working on the Ethereum-based applications
    will be developing their smart contracts in Solidity.
  prefs: []
  type: TYPE_NORMAL
- en: Solidity uses a large number of programming features, concepts, and methods
    that exist in other development languages. For example, Solidity has, as you would
    expect in a programming language, specific variables, functions, classes, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: One common API used with Ethereum is the JSON API, which is a lightweight data-interchange
    format that can represent numbers, strings, ordered sequences of values, and collections
    of name-value pairs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some additional tools and applications used with Ethereum:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Languages**—Solidity, Serpent, Mutant'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IDEs**—Solidity Browser, Ethereum Studio'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Clients**—Geth, eth, parity, Ethereum Wallet'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Storage**—IPFS, Swarm, and Storj'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dapp Browsers**—Metamask or Mist'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Testing**—Testnet, TestRPC'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 10](c10.xhtml) includes more details about these toolsets as well
    as Solidity.  ### Ethereum Transactions'
  prefs: []
  type: TYPE_NORMAL
- en: Transactions in Ethereum are the way the external world interacts with the Ethereum
    network. A transaction is used when you want to modify or update the state stored
    in the Ethereum network. It is important to note that Ethereum is an account-based
    blockchain implementation, which is different from other blockchains such as Hyperledger.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two types of accounts used in Ethereum to be aware of from a development
    perspective: an externally owned account (EOA) and a contract account.'
  prefs: []
  type: TYPE_NORMAL
- en: An externally owned account is effectively an individual user in the external
    world like a buyer and a seller. This user in the Ethereum network is represented
    by a 20-byte (160-bit) address.
  prefs: []
  type: TYPE_NORMAL
- en: The contract account has some similarities and differences to the EOA. A contract
    account is created by referring to a deployed contract. This contract account
    is identified by a contract address, and an EOA account is still represented by
    a 20-byte address (160 bit). This is the address that interacts with this deployed
    account.
  prefs: []
  type: TYPE_NORMAL
- en: The contract account can also keep ethers when appropriate to the business logic
    at hand. The contract is the “smart contract” capability in the Ethereum network,
    which is where the business logic is actually implemented.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 2.14](#c02-fig-0014) represents the high-level steps an Ethereum transaction
    takes for a blockchain user to authorize and access an Ethereum application. You
    can see in the diagram that a user is initiating a web application hosted on Ethereum,
    so this is not particularly complex. From a technical perspective, this is what
    would be expected when invoking an Ethereum application and would require “ether”
    to be able to run an application on the Ethereum blockchain. Ether, of course,
    is required to power the EVM through the use of “gas.”'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image described by caption and surrounding text.](images/c02f014.png)'
  prefs: []
  type: TYPE_IMG
- en: '[**FIGURE 2.14**](#R_c02-fig-0014) Ethereum authorization transaction overview'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 4](c04.xhtml) provides a deeper dive into Ethereum consensus and how
    transactions are handled from a smart contract invocation.  ### Ethereum Smart
    Contracts'
  prefs: []
  type: TYPE_NORMAL
- en: Smart contracts are contracts that can be converted to code, stored, and reproduced
    on the network nodes. With smart contracts, you can exchange money, shares, property,
    and anything that is valued in a transparent manner without the services of an
    intermediary. For example, through the use of an Ethereum smart contract, you
    could provide payment for products and have an immutable record of the transactions.
    Smart contracts define the penalties and rules surrounding an agreement just like
    traditional contracts would when properly designed.
  prefs: []
  type: TYPE_NORMAL
- en: When you deploy several smart contracts together as an application, it is known
    as a *distributed application* (a *dapp* in Ethereum).
  prefs: []
  type: TYPE_NORMAL
- en: 'Smart contracts in Ethereum provide some significant benefits to the users
    of the platform, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Autonomy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trust
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Backup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Safety
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Speed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Savings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accuracy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The basics of Ethereum state are that all modifications to a contract's data
    must be performed by its code. Modifying a contract's data requires a blockchain
    user to send requests to its code. This process kickoff determines whether and
    how to fulfill those requests. Smart contracts on the Ethereum network run on
    the Ethereum Virtual Machine.
  prefs: []
  type: TYPE_NORMAL
- en: Dapps running on the Ethereum network are basically complex smart contracts.
    Ethereum smart contracts have some properties to be aware of, especially when
    your development team is designing a smart contract for an application. First,
    Ethereum smart contracts are deployed in an automated fashion and can act as a
    complement to an agreement between two parties.
  prefs: []
  type: TYPE_NORMAL
- en: Second, the terms of the smart contract are to be clearly written in a computer
    language as a set of instructions recorded to an immutable distributed ledger.
  prefs: []
  type: TYPE_NORMAL
- en: Smart contracts when deployed on Ethereum will act as triggered events. For
    example, when a user sends funds of $100 to another Ethereum user to pay for,
    let's say, tickets to a concert, these tickets will be sent to the buyer only
    after the $100 is received from the buyer and deposited in the seller's Ethereum
    wallet. If the $100 is not received from the buyer, then the smart contract will
    not be triggered, and the contract process is stopped.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 2.15](#c02-fig-0015) shows the workflow of an Ethereum transaction.
    There are four main steps to a transaction in Ethereum, and each step must be
    executed properly for the next step to continue. Settlement of the transaction
    can occur only if the execution of the smart contract occurs as programmed.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Flow chart depicting smart contract workflow in symbols from defined contract
    to events, then to execute and transfer, and then to transferred cash settlement
    with the down arrow labeling on-chain or off-chain settlement.](images/c02f015.png)'
  prefs: []
  type: TYPE_IMG
- en: '[**FIGURE 2.15**](#R_c02-fig-0015) Smart contract workflow'
  prefs: []
  type: TYPE_NORMAL
- en: When writing smart contracts in Ethereum, developers use a programming language
    called Solidity. [Chapter 10](c10.xhtml) covers smart contracts and the basics
    of Solidity in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'Essentially, a smart contract in the implementation of Solidity is a collection
    of code and data residing at a specific address on the Ethereum blockchain. Solidity
    is a programming language native to Ethereum that was specifically designed for
    Ethereum and was released to the development community in 2015.  ### Ethereum
    Wallets'
  prefs: []
  type: TYPE_NORMAL
- en: One significant difference between Ethereum and the other enterprise blockchains
    is the fact that Ethereum is a permissionless platform, and it also has a cryptocurrency
    (token) called *ether*. As mentioned, ether is the token that is used for running
    your smart contracts on the Ethereum platform. To send and receive ether, you
    need to have a wallet.
  prefs: []
  type: TYPE_NORMAL
- en: A *wallet* is a program that allows you to gain access to, send, and receive
    cryptocurrency on the blockchain networks. There are several types of Ethereum
    wallets, including hardware, software, and web wallets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Common Ethereum wallets include MyEtherwallet, Jaxx, and Metamask. You can
    also go to an online exchange, such as Coinbase (which is focused on the US market
    at the time of writing) to get an online wallet (`[www.coinbase.com](http://www.coinbase.com)`).  ###
    Ethereum Tools and Utilities'
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum has a robust ecosystem of tools and utilities because of its large
    developer base and because it's the most successful permissionless smart contract
    blockchain. Finding what you need in the Ethereum ecosystem as a developer won't
    be an issue.
  prefs: []
  type: TYPE_NORMAL
- en: Let's review some of the top tools and utilities that are almost required to
    get going on Ethereum.
  prefs: []
  type: TYPE_NORMAL
- en: '**Mist Browser Wallet (Deprecated)** Mist Browser Wallet was used to store
    ether, send transactions, and deploy contracts but has recently been deprecated.
    Because of the wide usage of Mist, it clearly deserves a mention. Historically
    significant as well is that Mist was the first GUI wallet and was clearly the
    standard token base at the time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can download Mist Browser Wallet from `[https://github.com/ethereum/mist/releases](https://github.com/ethereum/mist/releases)`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Geth and Eth** These are command-line tools for the Ethereum Network. Essentially
    these command-line tools will allow you to connect your Ethereum server to or
    run your application on the Ethereum blockchain. Geth and Eth are two separate
    command-line tools that can run a full Ethereum, public or private, node. Both
    of these software tools provide multiple user interfaces.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can download the Geth CLI tools from `[https://www.ethereum.org/cli](https://www.ethereum.org/cli)`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Parity** Party is an advanced Ethereum client written in the new low-level
    language Rust. Parity was created by Dr. Gavin Wood, who is the former CTO of
    Ethereum.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can download the Parity client from `[https://www.parity.io/](https://www.parity.io/)`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Metamask** Metamask is a Google Chrome browser extension that allows you
    to experience Ethereum in your browser today.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is really useful is that it allows you to run Ethereum dapps right in your
    browser without running a full Ethereum node.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Figure 2.16](#c02-fig-0016) shows the Metamask interface. You can see that
    there is an ether balance and that there have been some contract interactions.
    Contract interactions are essentially using the EVM on the Ethereum mainnet.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Screen capture depicting metamask interface of main ethereum network with
    an ether balance of deposit and send options at next, and also listing the history
    of contract interactions at the bottom.](images/c02f016.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '[**FIGURE 2.16**](#R_c02-fig-0016) Metamask interface'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can download the Metamask extension from `[https://metamask.io/](https://metamask.io/)`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Truffle** Truffle is a well-tested and utilized development environment,
    testing framework, and asset pipeline for blockchains using the EVM.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can download the Truffle framework from `[https://truffleframework.com/](https://truffleframework.com/)`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Note that this is not an inclusive list of tools. However, I will be discussing
    in more detail Ethereum tools and development-focused frameworks in [Chapter 10](c10.xhtml).  ###
    Ethereum Governance'
  prefs: []
  type: TYPE_NORMAL
- en: Enterprise Ethereum clients must superimpose a permissioning layer since it's
    based on a decentralized platform, which is permissionless. At the time of writing,
    the Enterprise Ethereum Alliance (EEA) is working on version 3.0 of the standard
    specification where chain-wide permissioning configuration and enforcement will
    be enabled.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, a per-node permissioning capability can be set up via implementation
    through smart contracts to provide some governance. Because funding comes from
    the EEA, it''s expected that governance, compliance, and other enterprise concerns
    will be addressed in more detail at the organization’s pace. In a nutshell, if
    you need strict governance, then you may need to consider permissioned blockchains.  ##
    Summary'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter covered the four most widely used enterprise blockchain platforms
    and distributed ledgers. Enterprise blockchains have different requirements than
    public permissionless blockchains such as Ethereum.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enterprise blockchains generally fall into one of several categories: private
    permissioned, public or permissionless, or even hybrid such as Quorum.'
  prefs: []
  type: TYPE_NORMAL
- en: Hyperledger is the umbrella project run by the Linux Foundation, and Hyperledger
    Fabric is the mostly widely used blockchain in the Hyperledger portfolio according
    to the number of GitHub forks.
  prefs: []
  type: TYPE_NORMAL
- en: R3 is an enterprise blockchain software firm working with a broadly targeted
    ecosystem of more than 200 members and partners. These members are across multiple
    industries from both the private and public sectors. R3 has developed Corda, which
    is an open source blockchain platform, and Corda Enterprise, which is a commercial-grade
    version for enterprise usage with support.
  prefs: []
  type: TYPE_NORMAL
- en: Quorum is an open source blockchain solution built by enhancing the existing
    Ethereum blockchain. It provides an additional layer on top of Ethereum, which
    enables it to perform private transactions but also makes it more flexible by
    using different consensus algorithms. The main reason enterprises may want to
    use Quorum is for the privacy and performance capabilities that can easily extend
    to Ethereum applications.
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum is an open source software platform based on blockchain technology
    that enables blockchain developers to build and deploy decentralized applications
    (smart contracts). Ethereum is clearly the most widely used permissionless smart
    contract blockchain platform and has a wide developer following.
  prefs: []
  type: TYPE_NORMAL
- en: Each of the blockchains discussed have very different technical merits and use
    cases for the enterprise, so consider each one carefully.
  prefs: []
  type: TYPE_NORMAL
