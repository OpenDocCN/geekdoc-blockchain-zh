- en: © The Author(s), under exclusive license to APress Media, LLC, part of Springer
    Nature 2022J. T. GeorgeIntroducing Blockchain Applications[https://doi.org/10.1007/978-1-4842-7480-4_6](https://doi.org/10.1007/978-1-4842-7480-4_6)
  prefs: []
  type: TYPE_NORMAL
- en: 6. Hyperledger Fabric
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Joseph Thachil George^([1](#Aff2)  )(1)Rome, Italy
  prefs: []
  type: TYPE_NORMAL
- en: The success of public blockchains, such as Bitcoin and Ethereum, has led to
    growing interest in Blockchain technology and its application as a distributed
    system in the most innovative business use cases.
  prefs: []
  type: TYPE_NORMAL
- en: However, corporate prerogatives are based on principles and characteristic that
    public and permissionless blockchains still cannot deliver.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, private and authorized blockchains were born, capable to satisfy
    business compromises.
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, private and authorized blockchains allow you to design systems in
    which:'
  prefs: []
  type: TYPE_NORMAL
- en: The networks are authorized
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Participants are identified and identifiable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a guarantee of privacy and confidentiality of the data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is low transaction confirmation latency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are therefore many different blockchain projects authorized for corporate
    use. Hyperledger Fabric is a free software enterprise accounting system based
    on distributed ledger, with certain important variations from other famous distributed
    ledgers as well as blockchain systems.
  prefs: []
  type: TYPE_NORMAL
- en: However, it is critical to distinguish Hyperledger from Hyperledger Fabric.
    The Hyperledger project is an open source blockchain program started by the Linux
    Foundation.
  prefs: []
  type: TYPE_NORMAL
- en: Hyperledger Fabric is aimed at serving as a foundation for application development
    or modular architecture solutions. Hyperledger Fabric enables plug-and-play components
    such as consent and membership services. Its modular and adaptable design accommodates
    a wide range of industry use cases. It takes a novel approach to consent, allowing
    full-scale performance while protecting privacy.
  prefs: []
  type: TYPE_NORMAL
- en: It is an enterprise solution for the development of applications for a wide
    variety of use cases, as promoted by IBM, it allows innovation and versatility
    for various fields of application.
  prefs: []
  type: TYPE_NORMAL
- en: It is an *authorized* solution and therefore the participants are known, without
    the problems arising from a public network and without permits. So, there is trust
    among the participants.
  prefs: []
  type: TYPE_NORMAL
- en: This has a significant impact on consent. In one system authorized and managed
    by a trusted authority, consent is not required. Indeed, in these cases, it would
    be inefficient in terms of performance and speed.
  prefs: []
  type: TYPE_NORMAL
- en: This allows the Hyperledger Fabric platform high performance. This blockchain
    was specially designed to be highly modular, configurable, and customizable according
    to the various business needs.
  prefs: []
  type: TYPE_NORMAL
- en: 6.1 High-Level Perspective
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This section introduces Hyperledger Fabric by providing a high-level perspective.
    It includes the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: A company move that establishes system consensus by determining the order of
    transactions and, as a result, transmits new blocks to peers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A subscription network operator is in charge of using cryptographic identifiers
    to validate network identities.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An extra peer-to-peer gossip channel for broadcasting and ordering service result
    blocks to those other peers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ledger may be configured to work with a variety of database management systems.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The customizable endorsement policy for each application. Therefore, every aspect
    of the platform is modular and configurable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Hyperledger Fabric, smart contracts are known to as *chaincode*. The execute-consensus
    architecture of Hyperledger Fabric is known as *execute-order-validate* .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Indeed, it divides the transaction flow into three stages:'
  prefs: []
  type: TYPE_NORMAL
- en: Carry out a transaction and verify its validity, approving it in this manner.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Order the transactions using a programmable consensus protocol.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before registering transactions in the ledger, they must be validated according
    to the application blockchain’s policies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hyperledger Fabric provides a channel structure. Let’s say that each channel
    corresponds to one and only one blockchain. Therefore, a blockchain is associated
    only and exclusively to a channel. This means that only organizations that are
    part of a channel are authorized to the data of the channel itself, and therefore
    to the data of the blockchain of that channel.
  prefs: []
  type: TYPE_NORMAL
- en: This, together with the concept of private data, provides some guarantee of
    data security and privacy.
  prefs: []
  type: TYPE_NORMAL
- en: The task of categorizing entries is delegated to a modular component that is
    conceptually distinct from the peers who conduct the transactions and maintain
    the ledger. This is how the ordering process works.
  prefs: []
  type: TYPE_NORMAL
- en: Consent can be adjusted to the assumption of trust in a particular distribution
    or solutions as long as this is modular.
  prefs: []
  type: TYPE_NORMAL
- en: In discussing the concepts and mechanisms behind Hyperledger Fabric, the chapter
    follows and trusts the official Hyperledger Fabric documentation available on
    the web, when trying to summarize the concepts. So everything that is reported
    about Hyperledger Fabric derives from the study from the analysis of its official
    documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 6.2 Assets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Hyperledger Fabric allows you to construct any type of asset using *chaincode*
    , whether it’s physical (property, goods, products, etc.) or intangible (contract
    terms, intellectual property, documents, etc.).
  prefs: []
  type: TYPE_NORMAL
- en: Assets are specified as a number of essential pairs in Hyperledger Fabric, with
    state changes being stored as transactions on a ledger (tied to the canal). Binary
    and/or JSON representations are available for assets.
  prefs: []
  type: TYPE_NORMAL
- en: 6.3 Chaincode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Chaincode  is a type of software that specifies business logic. In other words,
    it defines an activity or set of activities and the transaction instructions for
    changing the activities. The chaincode therefore defines the operations that alter
    the status of the activity. It uses rules to read or change key-value pairs.
  prefs: []
  type: TYPE_NORMAL
- en: A settlement proposal triggers the chaincode functions, which are performed
    on the current database ledger. When the chaincode is run, it creates a set of
    writing that can be broadcast over the network and added to all peers’ ledgers.
  prefs: []
  type: TYPE_NORMAL
- en: 6.4 Characteristics of the Ledger
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The ledger keeps track of all network state transitions in a sequential order.
    Chaincode invocations (transactions) supplied by the parties produce state transitions.
    Every operation contains a set of session keys for the resources in the ledger
    which are created, updated, or eliminated in the ledger.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ledger consists of:'
  prefs: []
  type: TYPE_NORMAL
- en: A chain to store unchangeable data in blocks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A state database that records the present position of the blockchain. Each channel
    has its own ledger, as previously mentioned. For each channel in which they participate,
    each peer has a copy of the data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some ledger features:'
  prefs: []
  type: TYPE_NORMAL
- en: Perform key-based searches and enquiries, as well as range and generally relied
    inquiries.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a sophisticated query language to do read-only questions. (CouchDB).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Perform read-only questions from history and query the ledger’s record for a
    key, allowing options for where the data came from.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transactions contain the signatures of each peer who approves them before being
    forwarded to the service for placing orders.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transactions contain the signatures of each peer who approves them before they
    are forwarded to the ordering service.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Entries are sorted into blocks and “distributed” to peers on the channel by
    an ordering service.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Peers enforce approval policies by checking events against them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before adding a block, a version check is conducted to confirm that the statuses
    of the read assets have not changed since the chaincode code was executed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once a transaction has been verified and committed, it is immutable. A configuration
    block in the channel ledger defines policies, access controls, and other relevant
    information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Channels are membership provider instances that allow cryptographic materials
    to be obtained from multiple certifying bodies.
  prefs: []
  type: TYPE_NORMAL
- en: 6.5 Privacy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I previously said that a ledger only exists in one channel  and in a channel
    there is only one ledger. Only the members of a channel can therefore access the
    ledger of this channel. This allows you to do a lot of things while ensuring privacy
    and confidentiality.
  prefs: []
  type: TYPE_NORMAL
- en: For example, let’s imagine the scenario in which there is a supplier company
    and various client companies. If the supplier company applies different prices
    depending on the client company, but does not want to reveal this detail, then
    the channel is the solution. In fact, it would be enough to implement a channel
    for each commercial relationship, and the confidentiality of any information is
    guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, within the channel itself it is possible to obtain an additional
    level of confidentiality. In fact, chaincode can define an asset the functions
    that alter the state of the latter. Well, in this area, only the peers who own
    the chaincode can read the asset related to that chaincode.
  prefs: []
  type: TYPE_NORMAL
- en: If a subgroup of organizations in that channel needs to keep financial data
    secret, they can gather (collect) the data and store it in a private database
    that is conceptually distinct from the channel registers and only accessible to
    a limited number of people inside the institution.
  prefs: []
  type: TYPE_NORMAL
- en: In this way, channels maintain private transactions for the rest of the network,
    and collections store private data between organizational subsets of channels.
  prefs: []
  type: TYPE_NORMAL
- en: Before submitting a transaction to the ordering service and adding the block
    to the account, the value of the chaincode can be encrypted with a cryptographic
    method to further obscure the data. Only a user with the key correspondent used
    to produce the ciphertext may decode encrypted data once it has been printed to
    the ledger.
  prefs: []
  type: TYPE_NORMAL
- en: 6.6 Identity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once the encrypted data has been decrypted, a blockchain is made up of multiple
    actors:'
  prefs: []
  type: TYPE_NORMAL
- en: Peers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Orderers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Client applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Directors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A trusted authority is required for an identity to be verifiable. A Membership
    Service Provider (MSP) is Fabric’s most trusted authority. A MSP is an element
    that sets the rules that govern this organization’s authorized identities. The
    standard PKI (Public Key Infrastructure) model is used in the default implementation,
    which employs X.509 identity certificates.
  prefs: []
  type: TYPE_NORMAL
- en: 6.6.1 Infrastructure with Public Keys (PKI)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *public key infrastructure*  is one of the safety architectures that allows
    for the generation, management, and use of encryption keys and digital certificates.
    As a consequence, it’s a set of technologies that allows for secure network connections.
    (See Figure [6-1](#Fig1).)
  prefs: []
  type: TYPE_NORMAL
- en: 'The elements of the PKI are:'
  prefs: []
  type: TYPE_NORMAL
- en: A certification authority (CA)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Public key and private key
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Digital certificates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Revocation of certificates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The certification authority (CA) issues the certificates. The MSP determines
    the benefits of the trusted members of a certain organization.![../images/520777_1_En_6_Chapter/520777_1_En_6_Fig1_HTML.jpg](../images/520777_1_En_6_Chapter/520777_1_En_6_Fig1_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6-1
  prefs: []
  type: TYPE_NORMAL
- en: Example of CA e-digital certificate
  prefs: []
  type: TYPE_NORMAL
- en: 6.6.2 Digital Certificates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A digital certificate is a collection of information about the certificate holder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Among the elements of an X: 509 digital certificate are:'
  prefs: []
  type: TYPE_NORMAL
- en: Version
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serial number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ID of the algorithm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Issuing body
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Subject
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Information on the subject’s public key
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Certificate signing algorithm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Certificate signature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The certificate is encrypted and therefore proof against tampering. A change
    would invalidate the certificate. In fact, it is signed with the private key of
    the certification authority, and in this way, verifiable through the public key
    of the same authority. A change would invalidate the verification process. (See
    Figure [6-2](#Fig2).)![../images/520777_1_En_6_Chapter/520777_1_En_6_Fig2_HTML.jpg](../images/520777_1_En_6_Chapter/520777_1_En_6_Fig2_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6-2
  prefs: []
  type: TYPE_NORMAL
- en: Example of CA and a digital certificate
  prefs: []
  type: TYPE_NORMAL
- en: It certifies the unique association between a public key and the identity of
    a subject.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of the digital certificate is to guarantee that a key public is
    associated with the true identity of the subject claiming it. In fact, the applied
    signature certifies that the public key declared is accurate.
  prefs: []
  type: TYPE_NORMAL
- en: In effect, the applied signature checks that the certificate’s public key matches
    the topic specified in the certificate’s contents.
  prefs: []
  type: TYPE_NORMAL
- en: In the beginning, therefore, if Mario Rossi wanted to digitally sign a document,
    he had to divulge his public key to the other actors of the communication. Any
    person who possessed it could receive from him documents signed with the private
    key and then verify the signature with the aforementioned public key; however
    any individual could disclose a different public key, of which he knew the relative
    private key, and declare that it was Mario Rossi’s public key.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid this problem, each user then enters their key in a certificate signed
    by a reliable third party (in the PKI case, the certificate authorities). All
    those who recognize this third party simply have to check its signature to decide
    if the public key really belongs to that user.
  prefs: []
  type: TYPE_NORMAL
- en: 6.7 Certificate Authorities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Identity (public key pair and private key) and certificates are distributed
    by a certification authority to various actors. This certificate, which connects
    the plaintiff to the actor’s public key, is digitally signed by the certification
    authority (and optionally with a complete property). As a result, if the CA is
    trusted (and the public key is known), the individual actor may be trusted. As
    a consequence, if one trusts the CA (and knows its public key), one may be sure
    that the identified actor is related to the public key supplied in the certificate
    and possesses the included characteristics, therefore verifying the CA’s signature
    on the plaintiff’s certificate. The CA is responsible for ensuring that all actors
    in an organization have a verified digital identity. (See Figure [6-3](#Fig3).)![../images/520777_1_En_6_Chapter/520777_1_En_6_Fig3_HTML.jpg](../images/520777_1_En_6_Chapter/520777_1_En_6_Fig3_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6-3
  prefs: []
  type: TYPE_NORMAL
- en: Certificate authority
  prefs: []
  type: TYPE_NORMAL
- en: 6.8 Membership Service Provider (MSP)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MSPs are able to verify identity. In other words, they determine whether an
    identity belongs to a certain organization or not, and the role it covers within
    the organization. So although the CAs can issue identities and digital certificates,
    MSPs can recognize these identities on the network.
  prefs: []
  type: TYPE_NORMAL
- en: MSPs also provide members with a variety of roles and permissions inside the
    network.
  prefs: []
  type: TYPE_NORMAL
- en: The MSP is the method through which an organization’s identification is linked
    to its membership. The public key of a member (also called a certificate, certificate
    signature) is added to the organization’s MSP to gain membership.
  prefs: []
  type: TYPE_NORMAL
- en: MSPs are also used to assign various roles and permissions to network participants.
    The MSP is the mechanism that connects identity to organizational membership.
    The member’s public key (also called a certificate, certificate signature) is
    added to the organization’s MSP to gain membership.
  prefs: []
  type: TYPE_NORMAL
- en: An MSP’s capabilities, on the other hand, go beyond merely listing who is a
    network or channel member. By identifying an actor’s unique rights on a node or
    channel, the MSP is responsible for converting an identity into a role. A user
    must be allocated a role when registering with a CA Fabric, such as administrator,
    peer, client, order, or member.
  prefs: []
  type: TYPE_NORMAL
- en: 6.8.1 Local MSP
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: MSPs for clients and nodes are specified on a per-client and per-node basis
    (peers and orderers). Local MSPs control a node’s permissions (the peer administrators
    who can run the node). At the MSP’s client premises, the users can authenticate
    themselves as a member of a channel (for example, in chaincode transactions) or
    as the holder of a certain role in the system (as an administrator organization).
  prefs: []
  type: TYPE_NORMAL
- en: A customer local MSP is set in the system files of the node and only applies
    to that node. Because orderers, like peer nodes, are part of a single institution,
    they have a single MSP to identify the actors or nodes they trust.
  prefs: []
  type: TYPE_NORMAL
- en: 6.8.2 Channel MSP
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On the other hand, channel MSPs  establish administrative and participation
    rights at the channel level. Peers and ordering nodes on an applications channel
    share the same viewpoint as channel MSPs, allowing them to authenticate channel
    guests properly. This implies that if a firm wants to join the channel, the channel
    setup should include an MSP who works with the organization’s internal personnel.
    Therefore, transactions involving the identities of this organization will be
    rejected.
  prefs: []
  type: TYPE_NORMAL
- en: Local MSPs are documented in a channel configuration, whereas channel MSPs are
    represented on the file system as a folder structure. Channel MSPs determine who
    has power at the channel level. The channel MSP defines the connection between
    channel members’ identities and the execution of channel-level rules.
  prefs: []
  type: TYPE_NORMAL
- en: The MSP channel links the MSPs of all participating organizations to a single
    ordering system. An ordering service will most likely have ordering nodes from
    many businesses, with the ordering service as a whole being handled by the businesses.
  prefs: []
  type: TYPE_NORMAL
- en: 6.8.3 Storing MSP Data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Local MSPs are documented in a channel configuration, whereas channel MSPs are
    represented on the file system as a folder structure. Channel MSPs determine who
    has power at the channel level. The channel MSP defines the connection between
    channel members’ identities and the execution of channel-level rules.
  prefs: []
  type: TYPE_NORMAL
- en: The MSP channel links the MSPs of all participating organizations to a single
    ordering system. An ordering service will most likely have ordering nodes from
    many businesses, with the ordering service as a whole being handled by the businesses.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, a channel MSP logically resides and is handled from the channel
    or network, but each node’s local file system contains a copy of every channel
    MSP.
  prefs: []
  type: TYPE_NORMAL
- en: 6.9 Peers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A blockchain is mostly made up of nodes that communicate with one another. Because
    they have ledgers as well as smart contracts, peers are critical components of
    the network. The ledger records all smart contract transactions in an immutable
    manner. It is possible to add, remove, restart, reconfigure, and delete peers.![../images/520777_1_En_6_Chapter/520777_1_En_6_Fig4_HTML.jpg](../images/520777_1_En_6_Chapter/520777_1_En_6_Fig4_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6-4
  prefs: []
  type: TYPE_NORMAL
- en: Ledger and chaincode
  prefs: []
  type: TYPE_NORMAL
- en: A peer therefore has one or more instances of the ledger and one or more instances
    of different chaincodes. (See Figure [6-4](#Fig4).)
  prefs: []
  type: TYPE_NORMAL
- en: In fact, a peer can participate in different channels, and therefore have different
    instances of the ledger (each channel corresponds to an independent ledger).
  prefs: []
  type: TYPE_NORMAL
- en: In addition, depending on how the network is configured and for what purposes
    it is designed, there can be multiple chaincodes. Consequently, a peer can host
    multiple instances of chaincode.![../images/520777_1_En_6_Chapter/520777_1_En_6_Fig5_HTML.jpg](../images/520777_1_En_6_Chapter/520777_1_En_6_Fig5_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6-5
  prefs: []
  type: TYPE_NORMAL
- en: Applications and peers
  prefs: []
  type: TYPE_NORMAL
- en: Then, to obtain access to the ledger, you show how apps connect with peers.
    (See Figure [6-5](#Fig5).) Hyperledger Fabric makes the Fabric APIs available
    to developers Software Development Kits (SDKs), which allow them to interact with
    the peers, the chaincodes, and therefore the ledger.
  prefs: []
  type: TYPE_NORMAL
- en: Chaincode can be used by applications to query or update a ledger over a peer
    connection. A ledger query proposed transaction result is returned quickly, but
    ledger updates need more complex interaction between apps, peers, and orderers.
  prefs: []
  type: TYPE_NORMAL
- en: Figure [6-6](#Fig6) shows this in a very basic way.![../images/520777_1_En_6_Chapter/520777_1_En_6_Fig6_HTML.jpg](../images/520777_1_En_6_Chapter/520777_1_En_6_Fig6_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6-6
  prefs: []
  type: TYPE_NORMAL
- en: Apps connecting to peers
  prefs: []
  type: TYPE_NORMAL
- en: In Figure [6-6](#Fig6), application A links to P1 and uses the chaincode S1
    to query or modify the L1 ledger. P1 requests a response from S1 with the outcome
    of the planned ledger query or update. Application A has received the proposal
    response, and the query phase of the procedure is now complete.
  prefs: []
  type: TYPE_NORMAL
- en: Application A generates a transaction from all update replies and sends it to
    O1 to sort. O1 gathers and distributes transactions in blocks from all peers,
    including P1\. P1 verifies the transaction before committing it to L1\. Once L1
    has been changed, as received from A, P1 creates an event to signal completion.
  prefs: []
  type: TYPE_NORMAL
- en: In most cases, applications must connect to the peers they represent in order
    for the book update master to be approved. This is demonstrated in the “Transaction
    Flow” section.
  prefs: []
  type: TYPE_NORMAL
- en: 6.9.1 Peers and Organizations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Different companies control blockchain networks, or a single company manages
    them all. Because they are owned by these companies, peers are crucial in the
    construction of this form of distributed network. Peers are also the connection
    points for an organization’s network.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, a network is formed by four contributing organizations and eight
    peers. The five peers in network N that are connected via channel C are P1, P3,
    P5, P7, and P8\. Although the other peers of these companies have not entered
    this channel, they are generally members of at least one other channel. The applications
    developed by a company will link employees within that company as well as employees
    from other companies. For clarity, an ordering node is not shown in Figure [6-7](#Fig7).![../images/520777_1_En_6_Chapter/520777_1_En_6_Fig7_HTML.jpg](../images/520777_1_En_6_Chapter/520777_1_En_6_Fig7_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6-7
  prefs: []
  type: TYPE_NORMAL
- en: Connecting organizations and peers
  prefs: []
  type: TYPE_NORMAL
- en: Multiple contributing organizations with resources establish and administer
    the network. The resources in this topic are peers; however the resources supplied
    by an organization are more than just peers. The collaborative network would not
    exist without the organizations that offer their unique resources to it. The network
    grows and narrows as a result of the resources provided by these member entities.
  prefs: []
  type: TYPE_NORMAL
- en: 6.9.2 Peers and Identity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Peers are assigned an identity through a digital certificate of one certain
    certification authority. When a peer connects to a blockchain via a channel, the
    peer’s rights are determined by a rule in the channel configuration based on their
    identity.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, the (channel) MSP recognizes the organization to which it belongs
    through its *digital certificate* . (See Figure [6-8](#Fig8).)![../images/520777_1_En_6_Chapter/520777_1_En_6_Fig8_HTML.jpg](../images/520777_1_En_6_Chapter/520777_1_En_6_Fig8_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6-8
  prefs: []
  type: TYPE_NORMAL
- en: Identity of the peers
  prefs: []
  type: TYPE_NORMAL
- en: CA1 has provided identities to P1 and P2 in this case. The identities issued
    by CA1 are related with Org1 using ORG1.MSP, as determined by Channel C utilizing
    the MSP channel. ORG2.MSP also recognizes P3/P4 as Org2 components.
  prefs: []
  type: TYPE_NORMAL
- en: 6.9.3 Peer, Consensus, and Order
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To guarantee that almost all peers on a network blockchain retain their information
    in sync, applications that want to modify the ledger go through a three-step process.
  prefs: []
  type: TYPE_NORMAL
- en: In the first step, the app connects with a limited set of supporting peers,
    who individually provide a proposed response that isn’t yet applied to the ledger.
    The subset of endorsing peers that the application interacts with to update the
    ledger is determined by network policies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These proposal answers are collected in the second step by an application that:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verifies its consistency.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Sends the transaction to the ordering service as a consequence.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In the third and final stage, the ordering service orders all incoming transactions
    to be combined into a block, which is then sent to each neighbor, where each transaction
    is verified before being recorded.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a result, the ordering nodes that make up the ordering service are at the
    center of everything. The section that follows takes a deeper look at this procedure.
  prefs: []
  type: TYPE_NORMAL
- en: 6.10 Hyperledger Fabric Consensus
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consent in Hyperledger Fabric goes through three stages:'
  prefs: []
  type: TYPE_NORMAL
- en: Proposal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ordering and packing of transactions in blocks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validation and commit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '6.10.1 Stage 1: Proposal'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Initially  , the program selects a set of peers to generate updates to the proposed
    ledger.
  prefs: []
  type: TYPE_NORMAL
- en: The approval policy (given for a chaincode) determines which organizations must
    approve a suggested ledger transaction before it can be accepted by the networks
    and therefore registered.
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s what it means to attain consensus: every relevant organization must
    agree the proposed ledger update before it can be accepted into any peer’s ledger.'
  prefs: []
  type: TYPE_NORMAL
- en: Applications develop transactions which are suggested, which they transmit to
    every one of the peer groups that must approve it. Each of these is unique. The
    supporting peer then generates a response to the settlement proposal by independently
    executing a transaction proposal-based chaincode. This update is not applied to
    the book master; instead, it is signed and returned to the application. (See Figure
    [6-9](#Fig9).)![../images/520777_1_En_6_Chapter/520777_1_En_6_Fig9_HTML.jpg](../images/520777_1_En_6_Chapter/520777_1_En_6_Fig9_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6-9
  prefs: []
  type: TYPE_NORMAL
- en: Proposal
  prefs: []
  type: TYPE_NORMAL
- en: A peer accepts a proposed answer by signing the whole payload with his private
    key and attaching its digital signature. This permission can later be used to
    demonstrate that a certain response was generated by a peer inside the company.
  prefs: []
  type: TYPE_NORMAL
- en: Phase 1 concludes when the application obtains a enough number of peer replies.
    Note that various peers can return to the application with different transaction
    answers, making the settlement proposal contradictory.
  prefs: []
  type: TYPE_NORMAL
- en: There are two possible causes for this. Because of the chaincode’s nondeterminism
    (a feature to avoid in chaincodes), or because of peer inconsistency.
  prefs: []
  type: TYPE_NORMAL
- en: If an application tries to update the ledger with an inconsistent set of reply
    transactions, it will be refused. If the proposition is successful, each response
    is consistent and thus equivalent to the others.
  prefs: []
  type: TYPE_NORMAL
- en: '6.10.2 Stage 2: Transactions Are Ordered and Packaged in Blocks'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The transaction workflow continues with the packaging stage. Because he receives
    transactions comprising replies to settlement offers accepted by various applications
    and arranges them into pieces, the payer is crucial to this process.
  prefs: []
  type: TYPE_NORMAL
- en: Among other things, the authorizing officers have the responsibility of gathering
    proposed transaction changes, arranging them, and packaging them into blocks for
    delivery to peers. (See Figure [6-10](#Fig10).)![../images/520777_1_En_6_Chapter/520777_1_En_6_Fig10_HTML.jpg](../images/520777_1_En_6_Chapter/520777_1_En_6_Fig10_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6-10
  prefs: []
  type: TYPE_NORMAL
- en: Ordering transactions
  prefs: []
  type: TYPE_NORMAL
- en: 'Stage 3 begins with the computer distributing the blocks to all peers connected
    to it. When a new block is produced, the peers are linked to the orderers via
    channels in such a way that a copy of the new block is disseminated to all peers
    connected to the originator. Each peer will process this block individually, but
    in the same way as every other peer on the channel. Figure [6-11](#Fig11) illustrates
    how to keep the ledger constant in this way. It’s also worth noting that not all
    peers need to be connected to a computer: peers can connect to cascade to other
    peers via the gossip protocol.![../images/520777_1_En_6_Chapter/520777_1_En_6_Fig11_HTML.jpg](../images/520777_1_En_6_Chapter/520777_1_En_6_Fig11_HTML.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6-11
  prefs: []
  type: TYPE_NORMAL
- en: Verification and finalization
  prefs: []
  type: TYPE_NORMAL
- en: When a peer gets a block, it processes each transaction in the block in the
    order that it occurs. For each transaction, each peer will check if the transaction
    has been authorized by the organization requested according to the approval rules
    of the chaincode that started the transaction. (See Figure [6-11](#Fig11).)
  prefs: []
  type: TYPE_NORMAL
- en: A few transactions, for example, may just require clearance from a single organization,
    while others may necessitate several approvals before being declared genuine.
  prefs: []
  type: TYPE_NORMAL
- en: This validation procedure ensures that all relevant companies produced the same
    outcome. This validation is distinct from the approval check in Stage 1, in which
    the application receives answers from the peers it authorizes and chooses whether
    or not to transmit the proposed transactions. If the application violates the
    approval rules by submitting erroneous transactions, the peer might still refuse
    the transaction at Stage 3, validation.
  prefs: []
  type: TYPE_NORMAL
- en: If the transaction has been correctly accepted, the peer will seek to enforce
    it on the blockchain. To do so, a peer must conduct a check ledger consistency
    to confirm that the current state of the book master corresponds to the ledger
    state at the time the proposed update was created.
  prefs: []
  type: TYPE_NORMAL
- en: Even though the transaction has been fully approved, this may not always be
    doable. Another transaction, for example, the identical resource in the ledger,
    may have been changed to the point that the transaction update is no longer applicable
    and so cannot be implemented. Because all peers in the channel follow the same
    standards for validating transactions, the ledger is kept constant.
  prefs: []
  type: TYPE_NORMAL
- en: 6.11 Ledger
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Hyperledger Fabric’s IA ledger is made up of two separate but interconnected
    parts: a blockchain and a global state. (See Figure [6-12](#Fig12).)'
  prefs: []
  type: TYPE_NORMAL
- en: Both represent a bundle of information on a group of business items.![../images/520777_1_En_6_Chapter/520777_1_En_6_Fig12_HTML.jpg](../images/520777_1_En_6_Chapter/520777_1_En_6_Fig12_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6-12
  prefs: []
  type: TYPE_NORMAL
- en: Ledger
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to use the blockchain. A transaction log records all of the
    events that have led to the world’s present state. Transactions are collected
    in blocks that are added to the blockchain, which allows you to view the path
    of events that led to the present situation. Because it is immutable once written,
    the blockchain’s data structure varies considerably from that of the rest of the
    world.
  prefs: []
  type: TYPE_NORMAL
- en: Second, a global state exists. The current values of a set of business object
    states are stored in a database. Instead of having to calculate the current value
    of a state by crossing the entire register of transactions, a program can directly
    access it using the world state. By default, accounting states are expressed as
    key-value pairs. States can be generated, updated, and eliminated, so the world
    state can change frequently.
  prefs: []
  type: TYPE_NORMAL
- en: As a consequence, the global state is generated from a subset of the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: 6.11.1 Blockchain
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The blockchain keeps track of the events that led to the current status of assets.
  prefs: []
  type: TYPE_NORMAL
- en: The blockchain has always been implemented as a file, unlike the state, which
    utilizes a database. (See Figure [6-13](#Fig13).)![../images/520777_1_En_6_Chapter/520777_1_En_6_Fig13_HTML.jpg](../images/520777_1_En_6_Chapter/520777_1_En_6_Fig13_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6-13
  prefs: []
  type: TYPE_NORMAL
- en: Ledger with database
  prefs: []
  type: TYPE_NORMAL
- en: A config transaction providing the network’s initial condition of the channel
    is included in the ledger’s genesis frame. The block structure is standard, as
    you saw in “Blockchain Fundamentals.”
  prefs: []
  type: TYPE_NORMAL
- en: 6.11.2 Transaction
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The structure of transactions, on the other hand, is fascinating. Their design
    is depicted in Figure [6-14](#Fig14).![../images/520777_1_En_6_Chapter/520777_1_En_6_Fig14_HTML.jpg](../images/520777_1_En_6_Chapter/520777_1_En_6_Fig14_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6-14
  prefs: []
  type: TYPE_NORMAL
- en: Ledger with a transaction
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, you can see the following fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Header:** Contains some critical transaction metadata, such as the transaction’s
    chaincode name and version.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Signature:** The application client generates a digital signature, which
    is provided. This feature is used to verify that the transaction information has
    not been altered because it requires the application’s private key to create.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Proposal:** Encodes an application’s input parameters into the chaincode
    that generates the proposed ledger’s update.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When chaincode is executed, this proposal offers a set of input variables that,
    when coupled with the existing world state, produce the new world state.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Response:** Encompasses the values of the world before and after. Is the
    outcome of a smart contract, and if the transaction is correctly validated, it
    will be added to the ledger to update the global system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Endorsements:** This is a list of all approved transaction answers that must
    adhere to the approval policy for each company. There will be no change in global
    status if enough people sign a transaction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 6.11.3 World State
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *World State* reflects the primary value of a business object’s characteristics
    as a single accounting state. Most applications demand the current value of an
    object; measuring the real worth of an item over the whole blockchain would be
    cumbersome; instead, you obtain it straight from the global state. (See Figure
    [6-15](#Fig15).)![../images/520777_1_En_6_Chapter/520777_1_En_6_Fig15_HTML.jpg](../images/520777_1_En_6_Chapter/520777_1_En_6_Fig15_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6-15
  prefs: []
  type: TYPE_NORMAL
- en: State
  prefs: []
  type: TYPE_NORMAL
- en: A database keeps track of the present status of the planet. This is understandable
    because a database provides a wide range of archiving operators as well as fast
    state recovery.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the global state database, there are two options: LevelDB and CouchDB.
    Each chaincode has its own global status, which is unique from the status of all
    other chaincodes. This means that the world’s states are stored in a namespace,
    which can only be accessed by contracts intelligent from the same chaincode. As
    a result, a chaincode can’t see another chaincode’s world state.'
  prefs: []
  type: TYPE_NORMAL
- en: 6.12 Ordering Service Implementations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The ordering service  in the latest version of Hyperledger Fabric is a crash
    fault-tolerant provider. It's called *Raft* .
  prefs: []
  type: TYPE_NORMAL
- en: The “leader and follower” paradigm is used by Raft, in which the ordering nodes
    of a channel dynamically elect a leader, who then duplicates messages to the channel’s
    follower nodes. Raft is crash fault-tolerant because it can withstand the loss
    of some nodes, such as leader nodes, as long as the bulk of the ordered nodes
    are still operational (CFT).
  prefs: []
  type: TYPE_NORMAL
- en: 6.13 Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This chapter discussed Hyperledger Fabric in detail. It started with Hyperledger
    Fabric features and then deepened your understanding of Hyperledger Fabric. The
    hyperledger concept is important for the following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: Permissioned blockchain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Good performance and low transaction latency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modular and configurable according to your needs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database abstraction to speed up interactions with the World State
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ability to create different channels and therefore ledgers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ability to develop applications and chaincode in different languages programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are no particular drawbacks to this platform. When discussing hyperledger,
    you must also consider the distributed system and how the hyperledger can be used
    in a distributed system. That’s where the concept of a consensus algorithm comes
    in. The next chapter focuses on the consensus algorithm in a distributed environment.
  prefs: []
  type: TYPE_NORMAL
