- en: © The Author(s), under exclusive license to Springer Nature Switzerland AG 2021Y.
    Maleh et al. (eds.)Artificial Intelligence and Blockchain for Future Cybersecurity
    ApplicationsStudies in Big Data90[https://doi.org/10.1007/978-3-030-74575-2_8](https://doi.org/10.1007/978-3-030-74575-2_8)
  prefs: []
  type: TYPE_NORMAL
- en: 'IFIFDroid: Important Features Identification Framework in Android Malware Detection'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Takia Islam^([1](#Aff7), [2](#Aff8), [3](#Aff9) [ ](#ContactOfAuthor1)), Sheikh Shah Mohammad Motiur Rahman^([2](#Aff8),
    [3](#Aff9) [ ](#ContactOfAuthor2)) and Md. Ismail Jabiullah^([1](#Aff7) [ ](#ContactOfAuthor3))(1)Department
    of Computer Science and Engineering, Daffodil International University, Dhaka,
    Bangladesh(2)Department of Software Engineering, Daffodil International University,
    Dhaka, Bangladesh(3)nFuture Research Lab, Dhaka, BangladeshTakia Islam (Corresponding
    author)Email: [takia35-1014@diu.edu.bd](mailto:takia35-1014@diu.edu.bd)Sheikh Shah Mohammad Motiur Rahman (Corresponding
    author)Email: [motiur.swe@diu.edu.bd](mailto:motiur.swe@diu.edu.bd)Md. Ismail JabiullahEmail:
    [drismail.cse@diu.edu.bd](mailto:drismail.cse@diu.edu.bd)'
  prefs: []
  type: TYPE_NORMAL
- en: Abstract
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Android Malware has grown dramatically day by day because of the rising trends
    of android operating based smartphones. It has become the main attraction point
    by attackers now-a-days. Thus, android malware detection has become a major field
    of investigation among the researchers and academicians who are working with in
    the field of cyber security. As there are lots of research works have done already,
    it is still major matter of concern to improve the anti-malware tools. In addition,
    during the development of anti-malware framework the features of android malware
    plays the major role. During this study, an important features identification
    and selection technique has been proposed named IFIFDroid and evaluated which
    is based on wrapper method. However, the proposed approach can minimize the number
    of features which helps to machine learning (ML) techniques to learn from less
    features but perform better. It’s found that IFIFDroid can ranking features based
    on the capacity of individual ML algorithms and comparatively provide better result
    than existing wrapper method. IFIFDroid proves that there is still way to improve
    the features selection scheme and provide a strong basement of minimizing the
    power, execution time during the training by ML algorithms. Though if there is
    less features to fit without losing accuracy then it will minimize the processing
    resources as well.
  prefs: []
  type: TYPE_NORMAL
- en: KeywordsAndroid malware detectionFeatures ranking schemeAndroid malware analysisStatic
    analysis
  prefs: []
  type: TYPE_NORMAL
- en: 1 Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The usage of mobile devices has been rapidly increasing day by day which is
    also getting attracted in terms of basic need for its end-user. One report mentioned
    that android which is a Linux kernel-based operating system (OS) developed by
    Google, was in the leading position with 82% of total mobile OS in 2016 [[1](#CR1)].
    Besides that, Android is dominating the mobile market with 85% of the share and
    has become top positioned in smartphone platforms in 2017 [[2](#CR2), [3](#CR3)]
    whereas 74% of the universal mobile OS market share is in August 2020 according
    to StatCounter [[4](#CR4)]. Even, Google play contains around 3 million applications
    that have more than 65 billion downloads [[5](#CR5)]. However, because of the
    vast popularity of android devices, they are being targeted by attackers. In some
    cases, android devices allow the installation of third-party apps from unknown
    sources which is also a possible risk to get attacked. In 2016, the rate of attacks
    in android increased to 40% of total attacks by attackers [[1](#CR1)]. In 2017,
    there was one claim that a total of 316 weaknesses they found on only android
    operating systems [[6](#CR6)]. The statistics from literature and various reports
    are clearly shown that the popularity of Android OS is growing to customers as
    well as to the attackers. Attackers are targeting android devices by spreading
    malware to users. Because of the peak trends of spreading android malwares, it’s
    been a gigantic area of concern among the information security researchers to
    detect and prevent the malwares in android devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'To perform a particular task on the device, for instance, sending a text message,
    each application has to request permission from the user during the installation.
    However, the majority number of users tend to blindly grant permissions to exotic
    applications and thereby undermine the purpose of the verification system. As
    a consequence, malicious applications are hardly enforced by the Android permission
    system in practice. Android malware detection technology can be divided into three
    categories: static detection, dynamic detection, and hybrid detection which are
    found from the state-of-art. Static detection is found on the analysis of defendant
    code without running the android application. That can obtain high system coverage
    but faces several countermeasures like code obfuscation and dynamic code loading.
    As an alternative, dynamic detection contains the analysis of the Android application
    by running the code. Those can prove compromises that are not easy to explore
    by static analysis, but the computational assets and time cost of dynamic disclosure
    are almost high. Hybrid detection is the approach that connects static detection
    and dynamic detection to obtain an equal between detection effectiveness and efficiency.'
  prefs: []
  type: TYPE_NORMAL
- en: Machine learning concept is extensively applied in the detection of Android
    malware, even based on static, dynamic, or hybrid analysis approaches. The malware
    detection method which is based on reverse engineering means a classification
    of general static detection technology. The approach of reverses the implementation
    based on the semantic features of malicious applications. To decide whether the
    sample to be detected is a malicious application, it pairs by the specific properties
    of the recognized malicious applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Android malicious applications can execute similar malicious behaviour it called
    by the APIs [[7](#CR7)–[9](#CR9)]. It’s been identified that there are lots of
    research works have already done by world renowned researchers but with different
    features set where different features had influence on the learning base of different
    machine learning techniques. Thus, the following research questions are considered
    during this study:'
  prefs: []
  type: TYPE_NORMAL
- en: How can be identified the important features set from an android application
    for every specific machine learning technique?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How much influence the features set has on any specific machine learning algorithms?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can make a uniform framework for identifying the features set in a random
    state as it has changed its ranking on every training phase for randomly picking
    the train set?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, the major contribution of this research project is proposed a uniform
    framework to identify important features set before training with machine learning
    techniques. The framework will help researchers or anti-malware system developers
    to obtain minimum set of features with maximum detection accuracy. The contributions
    also include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It’s been found that it is possible to minimize the features set to reach maximum
    accuracy of any model with minimum features training.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For producing or generating a model with machine learning algorithms needed
    more execution time and processing power. Thus, it also can be claimed that as
    the feature set is less than the learning will take less time and power.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The structure of this chapter is organized as follows. The background and related
    works are broadly described at Sect. [2](#Sec2). Section [3](#Sec3) represents
    the proposed framework and research methodology in details. In Sect. [4](#Sec11),
    evaluation parameters and the Machine Learning (ML) techniques which are used
    during the implementation and assessment are described. Experimental results and
    discussion of proposed approach are described with the evaluation of the proposed
    framework in Sect. [5](#Sec14). Finally, Sect. [6](#Sec15) concludes the chapter
    with and future directions.
  prefs: []
  type: TYPE_NORMAL
- en: 2 Background Study
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, background study and related works will be discussed and broadly
    debated.
  prefs: []
  type: TYPE_NORMAL
- en: Alzaylaee [[9](#CR9)] proposed a framework based on the deep learning algorithm
    named DL-Droid. They considered both dynamic and static features for developing
    their approach. The experiments with more than 30,000 android applications have
    been performed by them. They also used InfoGain feature ranking algorithm for
    selecting the important features. Their approach outperformed the combination
    of dynamic and static features (99.6% accuracy) whereas only the dynamic features
    provide 97.8% of accuracy. It is mentioned that they performed dynamic analysis
    using stateful input generation.
  prefs: []
  type: TYPE_NORMAL
- en: Four malware detection methods based on entropy (PDME) and the FalDroid algorithms
    by using Hamming distance to find similarities between samples proposed by Tehari
    [[10](#CR10)]. They considered their experiments in a different type of features
    such as API, intent, and permission features on these three datasets. Based on
    three datasets, including benign and malware Android apps like Drebin, Contagio,
    and Genome have performed their experiments. The experiment outcomes ensure that
    their verification accuracy rates of proposed algorithms are more than 90% whereas
    in some cases, accuracy rates are above 99%.
  prefs: []
  type: TYPE_NORMAL
- en: Ma proposes a combination method for Android malware detection based on the
    machine learning algorithm and constructed by three detection models for Android
    malware detection concerning API calls, API frequency, and API sequence. They
    compared the accuracy and stability of their detection models through a large
    number of examinations and their experiment’s outcome acquired that high accuracy
    and clearness rate is 98.98% [[11](#CR11)].
  prefs: []
  type: TYPE_NORMAL
- en: An anti-malware system that uses customized learning models proposed by Amin
    which is based on End-to-End deep learning architectures. On that system, operational
    codes extracted from application attributes of android malware. They have selected
    to work with independent deep learning models leveraging sequence specialists
    like recurrent neural networks, Long Short-Term Memory networks, and its Bidirectional
    variation for static malware analysis on Android. A large number of datasets over
    1.8 million android applications show their report an accuracy of 0.999 and F1-score
    of 0.996 on whereas it can lead to better design of malware detectors [[12](#CR12)].
  prefs: []
  type: TYPE_NORMAL
- en: Another android malware detection tool is proposed by McLaughlin using the deep
    convolutional neural network (CNN) technique. The raw operational code sequences
    have been extracted from reverse engineering and counted as features during their
    study. They performed static analysis during the feature’s extraction. Though
    their primary goal was to scan numerous files quickly, they claimed their model
    to perform on large data with better accuracy [[13](#CR13)].
  prefs: []
  type: TYPE_NORMAL
- en: Li introduce Significant Permission IDentification (SigPID), a malware detection
    system that stands on permission usage analysis to survive the rapidly growing
    number of Android malware. They proposed three levels of permission data to identify
    the most significant permissions. Finally, their evaluation finds that their assessment
    that only 22 permissions are significant and compared another performance of their
    approach, using only 22 permissions, against a baseline approach that examines
    all permissions. It is mentioned that they achieve over 90% precision, recall,
    accuracy, and F-measure, and the analysis times are 4–32 times less than those
    of using all permissions [[2](#CR2)].
  prefs: []
  type: TYPE_NORMAL
- en: MalDozer, a family attribution framework that depends on a sequence classification
    and automatic Android malware detection using deep learning techniques proposed
    by Karbab. Based on deep learning techniques they select various malware datasets
    ranging from 1,000 to 33,000 malware application, and 38,000 benign apps by MalDozer.
    The solution mentioned that MalDozer accurately detects malware with a false positive
    rate of 0.06–2, under their all evaluation with multiple datasets, and attributes
    them to their real families with the F1-Score of 96–99 in percentage [[14](#CR14)].
  prefs: []
  type: TYPE_NORMAL
- en: Kim proposes a novel framework for Android malware detection and uses various
    kinds of features. Those features are clarified using their existence-based extraction
    method for successful feature representation on malware detection. As a malware
    detection model, they worked as a multi-modal deep learning technique. Besides,
    to estimate the performance, they execute several experiments based on 41,260
    samples and then compare the accuracy of their model with other deep neural network
    models. They also evaluated their approach in various aspects between their feature
    representation method and the usefulness of several features’ efficiency in model
    updates [[15](#CR15)].
  prefs: []
  type: TYPE_NORMAL
- en: Based on deep learning algorithms, Ren proposed two end-to-end methods for Android
    malware detection which have the advantage of their continuous learning activity.
    They claimed that their proposed methods have the benefit of their continuous
    learning activity and they evaluated by comparing with some existing detection
    methods. A dataset containing 8,000 benign and the same number of malicious applications
    in total 16000 applications used to evaluate their performed. They achieved the
    detection validity of 93.4 and 95.8 in percentage [[16](#CR16)].
  prefs: []
  type: TYPE_NORMAL
- en: Wu introduced an Android malicious application detection structured name called
    multiview information integration technology (MVIIDroid). On the other hand, their
    approach extracts applications’ multiple components, transforms them into embedding
    feature vectors and trains a multiple Kernel learning model as the classifier.
    To describe the effectiveness of their representation, they assess MVIIDroid on
    two Android malware datasets of 6820 benign applications and 6820 malwares. Besides
    separating malware from benign applications that they have to achieve superior
    classification performances [[17](#CR17)].
  prefs: []
  type: TYPE_NORMAL
- en: Hou illustrated the Android applications, concerned APIs, and their rich connections
    as a structured heterogeneous information network (HIN). Instead of using Application
    Programming Interface (API) calls only, it detects Android malware and further
    examines it shows that the several connections between them, and create higher-level
    semantics that requires more effort for attackers to evade the detection. It performed
    their experimental results to exhibit that their developed system HinDroid outperforms
    other replacements for Android malware detection techniques [[18](#CR18)].
  prefs: []
  type: TYPE_NORMAL
- en: Innovative detection models, proposed by Arora named PermPair, establish and
    contrast the graphs for malware. Besides extracting a standard sample with the
    permission pairs from the manifest file of an application. They analyze mainly
    the pairs of permissions that can be dangerous. It mentioned that they implemented
    an efficient edge elimination algorithm that was 41% from the normal graph and
    removed 7% of the useless edges from the malware graph. In addition, the 28% number
    of decreases in the detection time and shows minimum space utility [[19](#CR19)].
  prefs: []
  type: TYPE_NORMAL
- en: Xu performed a detection of DroidEvolver that evaluated on a dataset of 34,722
    malicious applications developed over six years and 33,294 benign applications.
    Based on using the online learning technique, it evolves with feature sets and
    pseudo label that DroidEvolver makes necessary and lightweight updates. DroidEvolver
    obtains high detection feature measure (95.27%), which only declines by 1.06%
    on average per year by the next five years for classifying 57,539 newly presented
    applications. Their performance ability of DroidEvolver is 28.58 times higher
    than MAMADROID by malware detection and then compared with the state-of-the-art
    extra time malware detection method MAMADROID. Finally, the F-measure of DroidEvolver
    is 2.19 times higher on average [[20](#CR20)].
  prefs: []
  type: TYPE_NORMAL
- en: A hybrid model based on deep autoencoder (DAE) proposed by Wang where convolutional
    neural network (CNN) is used. They recreate the high-dimensional features of Android
    applications and employ multiple CNN to detect Android malware. They analyzed
    13,000 malicious applications and 10,000 benign applications. It mentioned that
    the accuracy with the CNN-S model is improved by 5%, compared with SVM, while
    the training time using the DAE-CNN model is reduced by 83% compared with the
    CNN-S model [[21](#CR21)].
  prefs: []
  type: TYPE_NORMAL
- en: Rana assessed four tree-based machine learning algorithms for detecting Android
    malware in conjunction with a substring-based feature selection approach for the
    classifiers. For research, they contain 5,560 malware samples where they used
    the DREBIN dataset with 11,120 applications. Based on machine learning algorithms,
    they established their performed results While being the Random Forest classifier
    outperforms the best previously reported solutions. It provides a strong basis
    for building efficient tools for Android malware detection [[22](#CR22)].
  prefs: []
  type: TYPE_NORMAL
- en: Rahman performed a multi-level architecture using stacking concept StackDroid
    and evaluate which minimizes the error rate. They used the Stacked Generalization
    process. They used machine learning algorithms and Extreme Gradient Boosting used
    in level 2 as the final predictor. It mentioned that 97% detection accuracy on
    the DREBIN dataset and provides an energetic basement for the development of an
    android malware scanner whichever they obtained 99% of AUC (Area Under Curve),
    1.67% of FPR (False Positive Rate) [[23](#CR23)].
  prefs: []
  type: TYPE_NORMAL
- en: Russel determined the pattern that is used by attackers to distract malware.
    They proposed python scripts to extract the pattern of Application (App) components
    from an obfuscated android malware dataset. Based on the App component pattern,
    they initiated a matrix form that amassed in a Comma Separated Values (CSV) file.
    It will conduct to the primary basis of detecting the obfuscated malware [[24](#CR24)].
  prefs: []
  type: TYPE_NORMAL
- en: A simulation-based investigation of permissions in obfuscated android malware
    that was proposed. Based on python scripts to extract the pattern of permissions
    from an obfuscated malware dataset named Android PRAGuard Dataset. The experimented
    result shows that the patterns in a matrix form have been found and reserved in
    a Comma Separated Values (CSV) file which will lead to the fundamental basis of
    detecting the obfuscated malware [[25](#CR25)].
  prefs: []
  type: TYPE_NORMAL
- en: Islam classified the effectiveness of unigram, bigram, and trigram with stacked
    generalization and unigram provide more than 97% accuracy which is the highest
    detection rate against bigram and trigram. It mentioned that they were used as
    a final predictor and meta estimator eXtreme Gradient Boosting (XGBoost). They
    proved an active foundation to use n-gram techniques in developing android malware
    detection has been determined from this experiment [[26](#CR26)].
  prefs: []
  type: TYPE_NORMAL
- en: Learning-based Android malware detection methods (TLAMD) for IoT Devices was
    a testing framework proposed by Liu. The proposed framework used on Machine learning
    techniques. It can perform black-box testing on the system and the evaluation
    framework can develop adversarial samples for the IoT Android application with
    a profit rate of nearly 100% [[27](#CR27)].
  prefs: []
  type: TYPE_NORMAL
- en: Millar establish three contributions also experimentally exhibit strong against
    a selection of four prevalent and real-world obfuscation techniques. They propose
    DANdroid, an innovative Android malware detection that using a deep learning Discriminative
    Adversarial Network (DAN). It categorizes both obfuscated and unobfuscated applications
    as each of two malicious or benign. It mentioned that they used three feature
    sets such as raw opcodes, permissions, and API calls, that are combined in a multi-view
    deep learning architecture to rise this obfuscation resilience. They performed
    the dataset of 68,880 obfuscated and unobfuscated malicious and benign samples
    and multi-view DAN model obtains an F-score of 0.973 and contrast enthusiastically
    with the state-of-the-art, despite being exposed to the selected obfuscation approach
    tested both individually and in combination [[28](#CR28)].Table 1
  prefs: []
  type: TYPE_NORMAL
- en: Used features in literature
  prefs: []
  type: TYPE_NORMAL
- en: '| S/L | Reference | Used features |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | [[28](#CR28)] | Raw opcodes, permissions and API calls |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | [[29](#CR29)] | Applications behaviors in event level |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | [[30](#CR30)] | Static features, dynamic features, and hybrid features
    |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | [[31](#CR31)] | API call graph embedding |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | [[32](#CR32)] | URL feature mining |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | [[33](#CR33)] | Content-based features, runtime API sequences |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | [[34](#CR34)] | System call sequences |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | [[35](#CR35)] | Manifest properties, API calls, opcode sequences |'
  prefs: []
  type: TYPE_TB
- en: '| 9 | [[36](#CR36)] | Discussed about various features of static analysis including
    opcode |'
  prefs: []
  type: TYPE_TB
- en: '| 10 | [[37](#CR37)] | Permissions, API calls, intents, network traffic, Java
    classes, and inter-process communication |'
  prefs: []
  type: TYPE_TB
- en: '| 11 | [[38](#CR38)] | Call graphs |'
  prefs: []
  type: TYPE_TB
- en: '| 12 | [[39](#CR39)] | Network flows and API calls |'
  prefs: []
  type: TYPE_TB
- en: '| 13 | [[40](#CR40)] | n-gram features from App’s smali code |'
  prefs: []
  type: TYPE_TB
- en: '| 14 | [[41](#CR41)] | Permissions, API calls, Network Address and so on |'
  prefs: []
  type: TYPE_TB
- en: '| 15 | [[42](#CR42)] | Static features, API package call features and Dynamic
    Features |'
  prefs: []
  type: TYPE_TB
- en: '| 16 | [[43](#CR43)] | Dangerous permissions and components |'
  prefs: []
  type: TYPE_TB
- en: '| 17 | [[44](#CR44)] | Opcode sequences |'
  prefs: []
  type: TYPE_TB
- en: '| 18 | [[45](#CR45)] | System call |'
  prefs: []
  type: TYPE_TB
- en: '| 19 | [[46](#CR46)] | Discuss about permission, intent, uses-feature, application
    and API including kernel level features |'
  prefs: []
  type: TYPE_TB
- en: '| 20 | [[47](#CR47)] | Permission requests and API calls |'
  prefs: []
  type: TYPE_TB
- en: EveDroid, a scalable and event-aware Android malware detection system, utilizes
    the behavioral patterns in several cases to effectively detect recent malware
    based on the observation proposed by Lei. Their events can also reflect apps’
    possible running activities. On the other hand, they also mention using event
    groups to describe apps’ behaviors at the event level, which can capture a higher
    level of semantics than in API level and their approaches using API calls as features
    directly. The performance was based on a dataset that was 14 956 benign and 28
    848 malicious Android applications [[29](#CR29)].
  prefs: []
  type: TYPE_NORMAL
- en: The used features in the literature are tabulated in Table [1](#Tab1) which
    prove that the features have significant influence on android malware detection.
  prefs: []
  type: TYPE_NORMAL
- en: '3 IFIFDroid: The Proposed Approach'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Proposed Framework or proposed methodology will be described step by step
    in details in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 3.1 Dataset Description
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are lots of public datasets [[52](#CR52)–[59](#CR59)] available publicly
    to conduct or experiment during research works. ‘DREBIN’ dataset is one of the
    most used datasets among them which is used during the validation or test of the
    proposed framework. This dataset consists of 123,453 real android applications
    including 5,560 malware applications with 179 malware families. From early days
    of android malware analysis, this dataset performed as a strong basement to study
    different types of malwares as those malware samples were collected from August
    2010 to October 2012 [[7](#CR7), [8](#CR8)].
  prefs: []
  type: TYPE_NORMAL
- en: 3.2 Test Bed Setup
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The test bed setup is about an experimental environment which includes a Processor
    of Intel(R) Core (TM) i5-6500 CPU @ 3.20 GHz, 64-bit PC with 16 GB RAM. Linux
    Mint 18.3 Sylvia was the operating system. Scikit-learn, NumPy, panda and so on
    which are the packages of python have been used during this study where Python
    was the programming language.
  prefs: []
  type: TYPE_NORMAL
- en: 3.3 Pre-processing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It has been mentioned that the dataset has an imbalance in the number of data
    where only 5560 are malware. Thus, it is necessary to make it balance where there
    will be equal numbers of malware and benign applications. In this stage, balance
    operation has been performed using the following formula:![$$ f(dataset)= \sigma
    {\left\{ \begin{array}{ll} \frac{n}{,}&amp;{} \text {if } count(malware) = count(benign)\\
    0, &amp;{} \text {otherwise} \end{array}\right. } $$](../images/507793_1_En_8_Chapter/507793_1_En_8_Chapter_TeX_Equ1.png)After
    preprocess final dataset has selected based on the equal number of malware and
    benign. Where (Fig. [1](#Fig1)),![$$\begin{aligned} \sigma = Select, \qquad \qquad
    \qquad \\ 0...\mathrm{n} = \text {All samples,} \qquad \qquad \\ \text {count
    }= \text { Calculate number of sample.} \end{aligned}$$](../images/507793_1_En_8_Chapter/507793_1_En_8_Chapter_TeX_Equ2.png)![../images/507793_1_En_8_Chapter/507793_1_En_8_Fig1_HTML.png](../images/507793_1_En_8_Chapter/507793_1_En_8_Fig1_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 1
  prefs: []
  type: TYPE_NORMAL
- en: Proposed framework
  prefs: []
  type: TYPE_NORMAL
- en: 3.4 Features Extraction
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Reverse engineering has been performed to extract the features from the APK
    file in this stage using Androguard Reverse Engineering Tools [[60](#CR60)]. There
    are two major parts from which the features can be extracted based on the dataset:
    one is the Manifest.xml (all the permissions are listed there) file and another
    is the classes.dex (the main source of codes to execute) file. Based on the used
    dataset, there are total eight features set from those sources depicted in Fig. [2](#Fig2)
    explained below:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hardware Components (HC):** Android HC also supports VideoCamera, GPS, 3d-accelerometer,
    compass and provides rich APIs for location and map related functions as well
    as users can flexibly access, control and process the free Google map. Hardware
    components implement location based mobile service at low rate cost in mobile
    systems.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Requested Permissions (RP):** The list of Android permissions which are asked
    to get permitted from users. Android permissions play an important role in the
    security mechanism allowed by users the installation of an application. Each Malicious
    Application has run Android 6.0 to request dangerous permission by which it can
    get access to essential information. For Example: Request CAMERA access permission
    which is a hardware related permission, for instance Google Play store assumes
    that the underlying hardware features are required by user’s application and filters
    the application from devices that do not offer it.![../images/507793_1_En_8_Chapter/507793_1_En_8_Fig2_HTML.png](../images/507793_1_En_8_Chapter/507793_1_En_8_Fig2_HTML.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 2
  prefs: []
  type: TYPE_NORMAL
- en: Reverse engineering process
  prefs: []
  type: TYPE_NORMAL
- en: '**App Components (AC):** Android app has an app component it is the essential
    building block. Every component is an entry point through which the system or
    a user can enter an application. App components are 4 types of such as services,
    activities, broadcast receivers and content providers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filtered Intents (FI):** An Intent is a messaging object user can use to
    request an action from another app component and during inter process and intra
    process communication in android, intents are performed. Number of malicious applications
    or malicious activities after rebooting the android phone using BOOT_COMPLETED.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Restricted API Calls (RAC):** RAC is performed depend on the allowed permissions
    of android during the application installation. Malicious activities such as root
    exploits are indicated by the usage of RAC where the permissions in manifest.xml
    file aren’t requested.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Used Permissions (UP):** Whether any application directed to malicious activities
    or not, it can be identified initially from UP and RAC. Android can define new
    permissions that are distinct from the pre-installed system permissions and are
    used to regulate access its.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Suspicious API Calls (SAC):** Suspicious API calls means getDeviceId(), Cipher.getInstance(),
    Runtime.exec() and so on which allows to get access sensitive information about
    device related to malicious API calls and some of those are used for obfuscation.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Network Addresses (NA):** Network addresses which are regularly used by malware
    to execute external commands or pass data and it minimizes the amount of personal
    or sensitive data that anyone can transmit over the network.'
  prefs: []
  type: TYPE_NORMAL
- en: 3.5 Feature Ranking
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this stage, from the rankings list of the features, a high ranked features
    set has been selected to train a machine learning model and test. The number of
    high ranked features set such as 1, 2, 3, 4, 5, 6, 7 and 8 features set has been
    selected sequentially. Initially, Features ranking calculate by CART algorithm
    and based on coefficient value of each features during training the machine learning
    techniques. Then, calculate that score for every features 100 times to get more
    stable scoring from making an average score.
  prefs: []
  type: TYPE_NORMAL
- en: 3.6 Features Performance Checking
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this stage, the performance of the selected features with respective machine
    learning techniques will be evaluated. It’s been noticed that here also the machine
    learning techniques are providing different results for every simulation as the
    test train was random. To make it reasonable, 100 times loop have been applied
    and from that the average accuracy for every features set has been calculated.
  prefs: []
  type: TYPE_NORMAL
- en: 3.7 Final Selection Based on Performance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: From the feature performance, it can be easily selected for which machine learning
    techniques which features influenced more during the training of that model which
    will lead a strong basement to develop anti-malware tools.
  prefs: []
  type: TYPE_NORMAL
- en: It’s been mentioned that for feature ranking and for training, same ML techniques
    are applied and evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: 4 Evaluation Parameters and Used Machine Learning Techniques
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 4.1 Evaluation Matrices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Binary classification such as the data as either negative or positive labels
    has been performed during this study labeled as malware or benign. The decision
    of this classification has been represented by a structure. Confusion matrix is
    that structure by which the decision of classifiers can be evaluated [[48](#CR48)]
    Townsend. It consists of with 4 attributes: True positives (TP), True negatives
    (TN), False positives (FP) and False Negative (FN). True positives (TP) mean correctly
    identified the benign applications as benign. Identified the malware as benign
    is defined as False positives (FP). To identify malware as malware correctly referred
    to True negatives (TN). False negatives (FN) mean the benign one is identified
    as malware Davis [[49](#CR49)]. F1-Score, Precision, Recall, ROC curve, Precision-Recall
    Curve, Confusion Matrix, False Positive Rate and AUC Sokolova and Boyd. [[50](#CR50),
    [51](#CR51)] are used during this study to evaluate the effectiveness of IFIFDroid.'
  prefs: []
  type: TYPE_NORMAL
- en: '**ROC Curve:** A curve with two plots where False Positive Rate is on the x-axis
    and True Positive Rate in on the y-axis. The ratio of malware or the fraction
    of negative values those get wrongly classified as benign or positive is False
    Positive Rate - FPR. Whereas, TPR - True Positive Rate is the opposite of FPR.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Precision-Recall Curve:** A curve with two plots where recall is on the x-axis
    and precision in on the y-axis. Recall is exactly same as TPR. The rate of correctly
    identified the true value as true is referred to precision.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Accuracy:** The ratio of correctly identified data according to the total
    amount of data is known as accuracy defined as follows.![$$\begin{aligned} \text
    {Accuracy} = (\mathrm{TP} + \mathrm{TN}) / (\mathrm{TP} + \mathrm{TN} + \mathrm{FP}
    + \mathrm{FN}) \end{aligned}$$](../images/507793_1_En_8_Chapter/507793_1_En_8_Chapter_TeX_Equ3.png)'
  prefs: []
  type: TYPE_NORMAL
- en: 4.2 Machine Learning Algorithms
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Machine learning can be defined as a ponder of making machines obtain modern
    information, unused abilities, reorganize current information. It is utilized
    in an awfully common way and it alludes to common strategies to extrapolate patterns
    from large sets or to the capacity to create predictions on new records primarily
    based on what is learned with the aid of inspecting accessible recognized data.
    Machine learning techniques can be generally partitioned into two classes: supervised
    and unsupervised learning. The following are some of the algorithms used for machine
    learning during this study as followed:'
  prefs: []
  type: TYPE_NORMAL
- en: Extremely Randomized Tree – Extra Tree (ET)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Random Forest (RF)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decision Tree (DT)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ada Boost (ADA)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gradient Boost (GB)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These algorithms have different categories including: Machine Learning, Ensemble
    (Bagging Classifiers) and Boosting tree which are used during this study.'
  prefs: []
  type: TYPE_NORMAL
- en: 5 Experimental Results Analysis and Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, the result obtained from the implementation and assessment
    of the proposed approach will be described and evaluated briefly. For making the
    clear representation, the features are labeled as Table [2](#Tab2).Table 2
  prefs: []
  type: TYPE_NORMAL
- en: Representation of features set
  prefs: []
  type: TYPE_NORMAL
- en: '| S/L | Feature set name | Short form | Set format |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | Hardware components | HC | {HC[1], HC[2],............, HC[n]} |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | Requested permissions | RP | {RP[1], RP[2],............., RP[n]} |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | App components | AC | {AC[1], AC[2],............., AC[n]} |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | Filtered intents | FI | {FI[1], FI[2],................, FI[n]} |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | Restricted API calls | RAC | {RAC[1], RAC[2],........., RAC[n]} |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | Used permissions | UP | {UP[1], UP[2],.............., UP[n]} |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | Suspicious API calls | SAC | {SAC[1], SAC[2],..........., SAC[n]} |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | Network addresses | NA | {NA[1], NA[2],............., NA[n]} |'
  prefs: []
  type: TYPE_TB
- en: Table [2](#Tab2) represents the features labeling with short form of all features
    set and the constructions of features in a set. For instance, hardware components
    may be a set of multiple components like {GPS, camera,.....,touchscreen}. The
    representation of this set in the dataset is {1, 0, ......, 1} where 1 represents
    that the components are used in that application if not used then labeled as 0.![../images/507793_1_En_8_Chapter/507793_1_En_8_Fig3_HTML.png](../images/507793_1_En_8_Chapter/507793_1_En_8_Fig3_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 3
  prefs: []
  type: TYPE_NORMAL
- en: Comparison of features set in average ranking of all implemented ML techniques
  prefs: []
  type: TYPE_NORMAL
- en: In comparison of all algorithms it’s been found that 7 features set on an average
    from total 8 features set provide maximum accuracy. The top most influenced number
    of features and accuracy of different machine learning techniques are depicted
    in Figs. [3](#Fig3) and [4](#Fig4) respectively.![../images/507793_1_En_8_Chapter/507793_1_En_8_Fig4_HTML.png](../images/507793_1_En_8_Chapter/507793_1_En_8_Fig4_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 4
  prefs: []
  type: TYPE_NORMAL
- en: Comparison of accuracy based on features ranking of all implemented ML techniques
  prefs: []
  type: TYPE_NORMAL
- en: Table 3
  prefs: []
  type: TYPE_NORMAL
- en: Features ranking by each machine learning technique
  prefs: []
  type: TYPE_NORMAL
- en: '| Feature set | ET | RF | DT | GB | ADA | Average ranking |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| RP | 1 | 1 | 1 | 1 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| NA | 2 | 2 | 2 | 2 | 4 | 2.4 |'
  prefs: []
  type: TYPE_TB
- en: '| HC | 4 | 6 | 5 | 5 | 7 | 5.4 |'
  prefs: []
  type: TYPE_TB
- en: '| AC | 5 | 3 | 3 | 4 | 5 | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| SAC | 3 | 5 | 4 | 3 | 2 | 3.4 |'
  prefs: []
  type: TYPE_TB
- en: '| RAC | 7 | 7 | 7 | 6 | 3 | 6 |'
  prefs: []
  type: TYPE_TB
- en: '| UP | 8 | 8 | 8 | 8 | 8 | 8 |'
  prefs: []
  type: TYPE_TB
- en: '| FI | 6 | 4 | 6 | 7 | 6 | 5.8 |'
  prefs: []
  type: TYPE_TB
- en: It’s been claimed that UP has lower influence on an average for all classifiers
    from Table [3](#Tab3). On the other hand, RP which is also a set of permissions
    stand in the first position as a feature set to detect android malwares. Furthermore,
    RAC only get third position with ADA boost algorithm ranking whereas SAC has fluctuation
    of ranking by each algorithm. In sum, the feature set of RP, NA, SAC, AC, HC,
    FI and RAC are the most influenced feature set and top ranked. Finally, traditional
    wrapper method has been implemented to validate the proposed model and found that
    proposed approach can improve the accuracy of detection rather than the traditional
    wrapper method. It’s been also obtained that the accuracy difference is not that
    much compare to the traditional wrapper method. However, this model indicates
    that it is possible to improve the traditional wrapper method. The overall comparison
    of proposed method with traditional wrapper method has been tabulated in Table [4](#Tab4).Table
    4
  prefs: []
  type: TYPE_NORMAL
- en: Comparison between the performance of proposed approach and wrapper method
  prefs: []
  type: TYPE_NORMAL
- en: '| ML techniques | Wrapper method - accuracy | Proposed method - accuracy |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| ET | 92.87% | 93% with 7 feature set |'
  prefs: []
  type: TYPE_TB
- en: '| RF | 92.15% | 92.73% with 7 features set |'
  prefs: []
  type: TYPE_TB
- en: '| DT | 90.12% | 90.49% with 6 features set |'
  prefs: []
  type: TYPE_TB
- en: '| GB | 88.43% | 88.73% with 7 features set |'
  prefs: []
  type: TYPE_TB
- en: '| ADA | 84.56% | 84.68% with 7 feature set |'
  prefs: []
  type: TYPE_TB
- en: 6 Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A feature selection framework named IFIFDroid is proposed and which performed
    by machine learning methods with multiple algorithms such as Decision Tree, Random
    Forest, Extremely Randomized Tree, and Gradient Tree Boosting to detect malware
    on Android by performing static analysis on the DREBIN dataset. Whereas, a static
    analysis of Android malware applications has been performed considering the features
    including permission, API call, Intent filter, App component, and System call
    features are analyzed. In this paper, only eight types of features set are considered.
    However, there are more features set which will be examined and evaluated with
    IFIFDroid. There is also a major point to mention that the difference with the
    accuracy still not significant with existing wrapper method and in future the
    framework will be improve by changing some parameters to gain more accuracy in
    feature ranking, selection and then detection.
  prefs: []
  type: TYPE_NORMAL
