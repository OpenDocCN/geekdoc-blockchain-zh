© 2020 斯普林格自然瑞士公司 A. M. 兰格下一代软件架构的分析与设计[`doi.org/10.1007/978-3-030-36899-9_3`](https://doi.org/10.1007/978-3-030-36899-9_3)

# 3. **复习对象范例**

阿瑟·M·兰格^(1  )(1)哥伦比亚大学技术管理中心，美国纽约阿瑟·M·兰格电子邮件：al261@columbia.edu

本章将提供导致对象范例的历史结构化分析和设计方法论。在演进方法的核心是一组传统工具，需要扩展以满足移动物联网市场中敏捷架构的需求。

## 3.1 **逻辑等价的概念**

分析员或系统设计师的主要任务是提取用户的物理需求并将其转换为软件。所有软件都可以追溯到一个物理行为或一个物理需求。物理行为可以定义为发生在人们互动中的事情，也就是说，人们创造了大多数系统的根需求，尤其是商业系统。例如，当玛丽告诉我们她从供应商那里收到发票并在三十天后支付时，她正在解释她在接收和支付发票过程中的物理活动。当分析员创建代表玛丽物理需求的技术规范时，规范被设计为允许将她的物理需求转化为自动化环境中的需求。我们知道软件必须在计算机的限制内运行，并且这种系统必须根据逻辑运行。逻辑解决方案并不总是使用与物理世界中使用的相同程序来处理过程。换句话说，实施用于提供玛丽物理所做功能的软件系统可能与玛丽本人的操作方式不同且更有效。因此，软件可以被看作是物理世界的逻辑等价物。我称之为逻辑等价（LE）的抽象概念是分析员必须使用的一种过程，用于创建系统需求的有效性。LE 可以类比为计划的原理图或技术设备工作原理的图表。

任何在创建一个需要程序员开发的简洁准确的软件示意图方面取得的成功，都将与分析员掌握 Langer（1997）的逻辑等价概念的程度成正比。通常情况下，需求是由分析员使用各种方法开发的，这些方法并不总是包含一致性、协调和维护的基础。通常使用太多的散文，而不是工程师所采用的具体的图表化标准。毕竟，我们是通过软件应用程序的开发来设计一个系统。获取 LE 的最关键步骤是理解功能分解的过程。功能分解是找到系统最基本部分的过程，就像定义汽车的所有部分一样，以便能够构建它。可以不从看汽车的图片，而是从所有功能分解部分的图表来看。开发和设计软件并没有什么不同，必须创建可重用的组件应用程序，以在物联网环境中运行。

以下是使用功能分解的类似过程的示例，以及其应用于 LE。

在从用户那里获取物理信息时，可以使用许多建模工具。每个工具都提供了一个特定的函数来推导 LE。这里的“推导”一词具有特殊的含义。它与长除法的过程有关，或者我们在将一个数字除以另一个数字时应用的过程或公式。考虑以下示例：![../images/480347_1_En_3_Chapter/480347_1_En_3_Figa_HTML.png](img/480347_1_En_3_Figa_HTML.png)

上面的示例展示了应用于除法问题的公式。我们称这个公式为长除法。它提供了答案，如果我们改变问题的任何部分，我们只需重新应用公式并生成一个新的结果。最重要的是，一旦我们得到了答案，公式步骤的价值只是文档中的一部分。也就是说，如果有人质疑结果的有效性，我们可以向他们展示公式以证明答案是正确的（基于输入）。

现在让我们通过功能分解应用长除法来获取 LE。以下是对乔（一位记账员）关于处理退票的物理程序的采访结果。

> 记账员乔从银行收到了退票支票。他填写了一个余额更正表格，并将其转发给更正部门，以便更正未清余额。乔给客户发送了一封退票信，要求换发支票并支付 15.00 美元的罚款（这现在包括在未清余额的一部分中）。退票支票永远不会重新存入。

在这种情况下使用的适当建模工具是数据流程图（DFD）。DFD 是一种显示数据如何进入和离开特定流程的工具。我们要研究的流程是处理退票。DFD 有四个可能的组成部分：

![../images/480347_1_En_3_Chapter/480347_1_En_3_Figb_HTML.png](img/480347_1_En_3_Figb_HTML.png) 流程：

这表示正在执行的实际功能的名称。有效的流程是其中数据从一种形式转换为另一种形式的流程。

![../images/480347_1_En_3_Chapter/480347_1_En_3_Figc_HTML.png](img/480347_1_En_3_Figc_HTML.png) 数据流：

这表示进入或离开一个流程、外部或数据存储的数据。箭头表示流动的方向。数据流有时被称为“运动中的数据”。

![../images/480347_1_En_3_Chapter/480347_1_En_3_Figd_HTML.png](img/480347_1_En_3_Figd_HTML.png) 数据存储：

通常保存在文件中的存储数据。它代表可以从特定区域访问的数据。数据存储有时被称为“静止的数据”。

![../images/480347_1_En_3_Chapter/480347_1_En_3_Fige_HTML.png](img/480347_1_En_3_Fige_HTML.png) 外部：

不属于系统的数据提供者或用户。因此，它代表了一个边界。

现在让我们使用 DFD 工具绘制 Joe 过程的 LE，如图 3.1 所示。![../images/480347_1_En_3_Chapter/480347_1_En_3_Fig1_HTML.png](img/480347_1_En_3_Fig1_HTML.png)

图 3.1

处理退票的数据流程图

上述 DFD 显示了退票从银行到达，更新账户主文件，通知更正部门和客户收到一封信。银行、更正部门和客户被视为“系统外部”，因此在逻辑上表示为外部。该图被认为是功能分解的第一级或“Level 1”。您将发现所有建模工具都采用一种功能分解方法。DFD 使用一种称为“分层”的方法。

问题是我们是否已经达到了这个过程的最基本部分，或者我们应该进一步分层。许多分析人员认为，完全分解的 DFD 应该只有一个数据流输入和一个数据流输出。我们的图当前有许多输入和输出，因此可以进一步分层。将功能分解到第二级（Level 2）的结果如图 3.2 所示。![../images/480347_1_En_3_Chapter/480347_1_En_3_Fig2_HTML.png](img/480347_1_En_3_Fig2_HTML.png)

图 3.2

用于处理退票的二级数据流程图

注意，功能分解向我们展示了 Process 1：Handling Bounced Checks 实际上由两个名为 1.1 Update Balance 和 1.2 Send Letter 的子过程组成。Externals 中包围两个过程的框反映它们作为前一级或父级的组件。Level 1 中的双向箭头现在被分解为两个分别指向不同方向的箭头，因为它用于连接 Process 1.1 和 1.2。新的级别更加功能分解，更好地表示了 LE。

再次，我们必须问自己，Level 2 是否可以进一步分解。答案是肯定的。Process 1.1 有两个输出到一个输入。另一方面，Process 1.2 有一个输入和一个输出，因此是完整的。1.2 被称为 Functional Primitive，一个不能进一步分解的 DFD。因此，只有 1.1 将被分解。

让我们按照 3.3 中描述的方式分解 1.1。![../images/480347_1_En_3_Chapter/480347_1_En_3_Fig3_HTML.png](img/480347_1_En_3_Fig3_HTML.png)

图 3.3

处理退票的 Level 3 数据流程图

现在，Process 1.1 被分解为两个子过程：1.1.1 更新账户主文件 和 1.1.2 通知更正部门。Process 1.1.2 是一个 Functional Primitive，因为它有一个输入和一个输出。Process 1.1.1 也被认为是 Functional Primitive，因为“Bounced Check Packet” 流是两个过程之间的流，并且仅用于显示连通性。功能分解处于 Level-3，现在已经完成。

功能分解的结果是以下 DFD（图见 3.4）。![../images/480347_1_En_3_Chapter/480347_1_En_3_Fig4_HTML.png](img/480347_1_En_3_Fig4_HTML.png)

图 3.4

处理退票的功能分解的 Level 3 数据流程图

就像长除法一样，只有上面表示的完整结果被用作答案。前面的步骤是我们用来得到逻辑等效的最低、最简单表示的公式。Level 1、2 和 3 仅用于记录最终 DFD 的确定方式。

逻辑等效是一种出色的方法，允许分析员和系统设计师组织从用户获取的信息，并系统地推导出其过程的最基本表示。它还减轻了立即理解详细流程的不必要压力，并提供了最终原理图的开发文档。

## 3.2 结构化分析工具

现在，我们已经确定了逻辑等效性的重要性和目标，我们可以转而讨论可用于协助分析人员的方法。这些方法就像外科医生的工具一样，外科医生在手术过程中只使用最合适的工具。重要的是要了解，外科医生有时会面临关于使用哪种外科手术器械的选择；特别是对于新的程序，有时外科医生之间对哪种器械最有效存在分歧。对于分析和数据处理的工具的选择也是如此；事实上，它可能变化更大，更加混乱。医学行业和许多其他行业一样，都受到其自身管理机构的管辖。美国医学协会和美国内科医师和外科医师学会，以及州和联邦监管机构，代表了外科医生的标准来源。数据处理行业没有这样的控制机构，也不太可能在不久的将来出现这样的机构。因此，该行业试图在自己的领导者中间建立标准。这样做的结果通常是，最具主导地位的公司和组织制定了其他公司不得不遵守的标准。例如，微软凭借其软件的统治地位确立了自己作为行业领导者的地位。在这里，权利即是权力！

由于行业中没有真正的正式标准，因此本文讨论的分析工具将基于它们的优点和缺点来介绍。因此，重要的是要认识到，没有任何分析工具（或方法论）能够完成整个工作，也没有任何一个在其所做的事情上是完美的。为了确定合适的工具，分析人员必须充分了解环境、用户的技术专长和项目所施加的时间限制。所谓“环境”，是指现有系统和技术、计算机操作以及新系统的技术和地理逻辑，包括技术和地理逻辑。用户界面的处理应与第二章讨论的指南保持一致。

时间限制问题也许是最关键的问题。你理想情况下想应用于项目的工具可能不符合规定的时间框架。那么，如果时间不够，会发生什么？分析人员现在面临的是选择第二选择工具的问题，毫无疑问，这个工具将不会像第一个工具那样有效。还有一个问题是工具的实施方式，也就是说，当时间限制阻止了所需工具的完全实施时，是否可以使用工具的混合体？

## 3.3 进行变更和修改

在分析工具主题内部，包含维护建模的组成部分，或者如何在对现有产品进行更改或增强时应用建模工具。维护建模分为两类：

1.  1.

    预先建模：现有系统已经具有可用于对软件进行新更改的模型。

1.  2.

    传统系统：现有系统从未进行过建模；因此，任何新的建模都将首次将分析工具纳入其中。

*预先建模*：

简而言之，预先建模的产品已经处于结构化格式中。结构化格式是指采用特定格式和方法论的格式，例如数据流图。

更改预先建模工具最具挑战性的方面是：

1.  1.

    保持它们与之前版本一致，并

1.  2.

    实施一个版本控制系统，提供分析变更的审计跟踪以及它们与之前版本的不同之处。该行业许多专业人士称之为版本控制；然而，在指定版本控制是否用于维护分析工具时，应该小心。不幸的是，版本控制也可以用于其他情境，尤其是跟踪程序版本和软件文档。对于这些情况，市场上存在特殊产品，提供特殊的自动化“版本控制”功能。我们在这里不关心这些产品，而是关心允许我们在不丢失先前分析文档的情况下整合变更的程序和流程。这种程序可以被视为与长除法示例一致，其中每次值改变时，我们只需重新应用公式（方法）来计算新答案。因此，分析版本控制必须具有将对软件所做的修改与所有现有模型集成的能力，必要时。

*保持一致*：

在软件产品的生命周期中更改建模方法和/或 CASE 工具是困难的。因此，我们的主要目标之一是尽量避免这样做。如何？当然，简单的答案是第一次选择正确的工具和 CASE 软件。然而，我们都会犯错误，更重要的是，系统架构可能会有新的发展，这可能会使新的 CASE 产品具有吸引力。您应该预见到这种可能性，并为不一致的工具实施做好准备。在这里最好的策略是：

+   确保您的 CASE 产品具有通过 ASCII 文件或剪切/粘贴方法传输模型的能力。许多产品都通过“导出”功能进行接口。在这里，分析人员至少可以将图表和数据元素转换为另一种产品。

+   保留一组图表和元素，可以用于建立将来的链接，即，可以重新输入到另一个工具中的一组手动信息。这可以通过简单地打印图表的文档来完成；然而，经验表明，难以保持此类信息的最新性。因此，分析师应确保有一个打印最新图表和数据元素的程序。

如果组织决定使用不同的工具，例如流程依赖图而不是数据流图，或者使用实体关系图中的不同方法，比如“鸟脚法”，那么分析师必须进行一定程度的重新工程。这意味着将新的建模工具映射到现有工具，以确保一致性和准确性。这绝非易事，强烈建议您记录这些图表，以便进行对比调和。

*版本控制*：

本书并不打算重点讨论版本控制的通用方面；但是，结构化方法必须具有审计跟踪。当新流程更改时，应为以前的版本创建一个目录。目录名称通常由版本和日期组成，例如：xyz1.21295，其中 xyz 是产品或程序的名称，1.2 是版本，1295 是版本日期。通过这种方式，以前的版本可以很容易地重新创建或查看。当然，保存每个版本的完整集可能不可行，或者可能过于昂贵（以磁盘空间等方面计算）。在这些情况下，建议以允许轻松恢复的方式备份以前的版本。无论如何，必须存在一个流程，并且非常重要的是必须有一个定期进行备份的过程。

## 3.4 什么是面向对象分析？

面向对象分析是设计成功移动应用程序的关键分析工具。毫无疑问，它是创建所谓的“完整”需求敏捷系统的最重要因素。行业中使用了许多方法，可能存在关于应该使用哪种方法和工具来创建移动对象系统的争议。本章将重点讨论开发对象系统的需求以及将遗留系统转换的挑战。因此，许多术语将基于它们的基本功能以及实践分析员如何使用它们来定义（而不是理论家！）。

面向对象（OO）基于一个概念，即每个需求最终必须属于一个对象。因此，首先定义什么是对象非常重要。在面向对象分析的上下文中，对象是由两个基本组件构成的任何具有内聚性的整体：数据和过程（图 3.5）。![../images/480347_1_En_3_Chapter/480347_1_En_3_Fig5_HTML.png](img/480347_1_En_3_Fig5_HTML.png)

图 3.5

汽车是物理对象的一个示例

传统的分析方法通常基于一系列事件的审查。我们通过首先与用户进行访谈，然后开发所介绍的逻辑等价概念，将这些事件从物理世界翻译过来。尽管我们绝不放弃这种必要性，但面向对象的范式要求这些事件属于可识别的对象。让我们利用下面所示的对象，一个我们通常称之为“汽车”的对象，来扩展一下这种差异。

上述汽车可能代表某种品牌和型号，但它也包含所有汽车都含有的常见组件（例如发动机）。如果我们将汽车视为组织的业务实体，我们可能会发现以下三个系统是多年来开发的。

上述图表告诉我们，这三个系统是在 21 年的时间内构建的。每个系统都设计为为负责特定任务的一组用户提供服务。图表显示，系统 1 的需求基于汽车的发动机和前端。这个项目的用户对汽车的其他部分没有兴趣或需求。另一方面，系统 2 着重于汽车的下部中心和后部。然而，请注意，系统 2 和系统 1 存在重叠。这意味着两个系统都有共同的部件和程序。最后，系统 3 反映了汽车的上部中心和后部，并且与系统 2 存在重叠。还值得注意的是，汽车的某些组件尚未定义，可能是因为没有用户需要它们。我们可以将汽车视为一个对象，将系统 1-3 视为围绕该对象定义的软件。我们的观察还应该告诉我们，整个对象尚未定义，并且更重要的是，已经开发的系统之间可能存在数据和功能的重叠。这种情况是大多数开发系统的历史的典型例子。应该清楚的是，陈述其需求的用户从未意识到自己的情况属于一个更大的复合对象。内部用户往往根据自己的工作职能和在这些职能中的经验来建立需求。因此，对用户事件进行访谈的分析人员面临着一些风险：

+   用户倾向于只识别他们经历过的事物，而不是推测未来可能发生的其他事件。这在移动世界中以及试图理解未来消费者可能想要的东西时是一个重要的限制。我们知道这样的事件可能发生，尽管它们还没有发生过（你应该记得使用 STD 作为建模工具来识别未预见到的可能性的讨论）。例如，考虑一个必须得到公司控制器批准的 50000 美元的分析情况。这个事件可能只显示批准，而不是拒绝。用户的回答是，控制器在检查发票时从未拒绝过一张，因此不存在拒绝流程。你可能会问为什么。嗯，在这种情况下，控制器不是因为拒绝而审查发票，而是在他/她确信公司的现金流能够支持发票的开具之前一直保留着它们。显然，控制器可以决定拒绝一张发票。在这种情况下，软件将需要进行更改以适应这个新的流程。从软件的角度来看，我们称之为系统增强，它将导致对现有系统的修改。

+   公司其他部分可能会受到控制器审查发票的影响。此外，我们能确定在此之前没有其他人自动化此过程吗？有人可能会认为这样的先前自动化永远不会被忽视，尤其是在一个小公司，但是当用户对同一事物有不同的名称时（记得客户和客户端！），这种情况很可能会发生。在这个例子中，有两种情况是不同系统在功能上重叠的。

+   系统之间在数据和流程定义方面会存在冲突。最糟糕的是，这些差异可能直到系统交付后几年才会被发现。

上面的例子告诉我们，基于个人事件获得的需求需要另一层协调来确保它们的准确性。当需求定义整个对象时，称之为“完整”。它们越不完整，后续可能需要的修改就越多。系统中的修改越多，不同应用程序之间的数据和流程可能发生冲突的可能性就越高。最终，这将导致一个不太可靠、质量较低的系统。最重要的是，仅仅通过事件分析很容易忽略用户从未经历过的事件。在汽车示例中，未包含在任何三个系统中的汽车部分就代表了这种情况。系统功能和组件也可能被忽略，因为用户在面试时缺席或不可用，或者因为没有人觉得有必要自动化对象的某个方面。无论哪种情况，情况都应该是明确的。在进行事件分析之前，我们需要先确定对象。

在讨论识别对象的程序之前，值得看看对象方法与早期方法之间的重大差异。最初的主要系统是在 60 年代开发的，被称为批处理，意味着它们通常按事务处理。事务被收集，然后用于更新主文件。批处理系统在金融行业，包括银行，非常有用。我们可能还记得在银行交易后等待到第二天早上才能看到我们的账户余额，因为批处理过程在夜间更新主账户文件。这些系统是基于事件访谈构建的，程序员/分析员与用户会面并设计系统。大多数这些业务系统都是使用 COBOL 开发和维护的。

在 70 年代初，新的热词是“在线，实时”，意味着许多过程现在可以立即更新数据或根据“实时”更新。尽管系统已经修改以提供这些服务，但重要的是要理解它们没有重新设计。也就是说，现有系统是基于事件访谈构建的，经过修改但没有重新设计。

在 80 年代末和 90 年代初，热门术语变成了“客户端/服务器”。这些系统，稍后将讨论，基于复杂的分布式系统概念。信息和流程分布在许多本地和广域网络之间。许多这些客户端/服务器系统是从 60 年代的批处理系统发展而来的在线实时系统的重建。关键在于，我们一直在将新技术应用于设计已有 30 多年的系统，而没有考虑设计的过时性。

通过这三代系统，分析员基本上是从外部看向内部（见图 3.6）。分析的完整性取决于——并且实际上是由——内部用户定义其业务需求的方式所决定的。![../images/480347_1_En_3_Chapter/480347_1_En_3_Fig6_HTML.png](img/480347_1_En_3_Fig6_HTML.png)

图 3.6

需求通常由分析员从外部视角开发。因此，规范取决于用户视角的完整性。

![../images/480347_1_En_3_Chapter/480347_1_En_3_Fig7_HTML.png](img/480347_1_En_3_Fig7_HTML.png)

图 3.7

此图反映了为支持汽车对象开发的三个系统

另一方面，面向对象要求分析员从内部向外部看。我们在这里的意思是，分析员首先需要定义对象的通用方面，然后将用户视图映射到对象本身存在的特定组件（图 3.7）。下面的图示显示了可能成为银行的通用组件的概念视图。

图 3.8 展示了银行的基本功能。分析师在与用户进行访谈时处于组织内部，因此将能够将特定需求映射到一个或多个基本功能上。在这种方法中，任何用户需求都必须至少符合一个基本组件。如果用户有一个不属于基本组件的需求，则必须将其标记为缺失（因此将其添加为基本组件）或将其视为不适当。![../images/480347_1_En_3_Chapter/480347_1_En_3_Fig8_HTML.png](img/480347_1_En_3_Fig8_HTML.png)

图 3.8

使用对象方法，分析师从内部向外部访问用户进行访谈

将用户需求并将其功能放置到适当的基本组件中的过程称为映射。映射的重要性在于，需求的功能被逻辑地放置在它们通常属于的位置，而不是根据它们如何物理实现。例如，假设约瑟夫在一家银行工作，需要向客户提供有关银行投资产品的信息。约瑟夫需要从系统中获取投资信息。如果使用 OO 方法来设计系统，所有与银行投资相关的信息都将被通用地分组在一起。以这种方式进行允许授权人员访问投资信息，而不管他们在银行做什么。如果仅使用事件分析，约瑟夫可能会拥有自己的子系统，用于定义访问投资信息的特定需求。问题在于，首先，该子系统不包含与投资相关的所有功能。如果约瑟夫需要额外的信息，则可能需要增强或需要在银行使用其他人的系统。其次，约瑟夫的子系统可能会定义已在另一个子系统中定义的功能。OO 的优势在于，它将一个基本组件的所有功能集中在一起，并允许这些功能被所有需要其信息的过程“重用”。计算机行业称这种能力为可重用对象。

## 3.5 识别对象和类

成功实现 OO 的最重要挑战是理解和选择对象的能力。我们已经使用了一个将汽车识别为对象的示例。这个示例是可以称为有形对象或行业称之为“物理对象”的东西。不幸的是，还有另一种类型的对象，称为“抽象”或无形对象。无形对象是你无法触摸的对象，或者正如 Grady Booch 最初描述的：“可以在智力上理解的…朝向思想或行动的东西。”^(1) 无形对象的一个示例是银行基本要素中的安全组件。在许多情况下，OO 分析将从识别有形对象开始，这将进而更容易地发现无形对象。

OO 在某种程度上与过程和数据的架构一致，因为所有对象都包含它们自己的数据和进程，分别称为属性和服务。属性实际上是数据元素的列表，它们是对象的永久组成部分。例如，方向盘是对象“汽车”的永久属性的数据元素。而服务（或操作）则定义了所有永久地属于对象或“拥有”的进程。“启动汽车”是在对象汽车中定义的服务。该服务包含启动汽车所需的算法。服务是通过方法定义和调用的。方法是操作（服务）的过程规范。^(2) 例如，“驾驶汽车”可以是汽车对象的一个方法。 “驾驶汽车”的方法将调用一个名为“启动汽车”的服务以及其他服务，直到满足整个方法的要求。虽然服务和方法可能具有一对一的关系，但更可能的是一个服务将是一个方法的子集或构成方法的操作之一。

当对象放置在同一个类中时，它们有能力从其他对象那里继承属性和方法。类是具有相似属性和方法的对象的组合，通常被放在一起执行特定任务。为了进一步理解这些概念，我们将建立“汽车”的对象，并将其放置在专注于汽车变速器使用的对象类中。

图 3.9 表示一个名为车辆传输的对象类。它有三个组件对象：车辆、自动传输和标准传输。车辆对象被称为父对象。自动传输和标准传输是对象类型。自动传输和标准传输将继承其父对象车辆的所有属性和服务。对象技术中的继承意味着子对象实际上包含了父对象的所有功能。继承被实现为树结构^(3)；然而，与树结构中信息向上流动的情况不同，数据向下流向最低级别的子对象。因此，对象继承图被称为倒置树。因为树的最低级别继承了其所有父级别的信息，只需执行最低级别即可，也就是说，执行最低级别将自动允许应用程序根据需要继承所有的父级别信息和应用程序。我们称最低级别的对象为具体对象，而类中的所有其他对象都称为抽象对象。类内的对象可以通过简单地添加一个新对象而改变。假设我们的例子增加了另一个级别。新级别包含了特定类型的自动和标准传输对象。![../images/480347_1_En_3_Chapter/480347_1_En_3_Fig9_HTML.png](img/480347_1_En_3_Fig9_HTML.png)

图 3.9

车辆传输类

图 3.10 中的类已经修改，包括了一个新的具体层。因此，自动传输对象和标准传输对象现在是抽象的。四个新的具体对象不仅继承了各自父对象，还继承了它们的共同祖先车辆。同时，重要的是要认识到类可以继承自其他类。因此，同样的例子可以展示每个对象都是一个类：也就是说，车辆代表着一类车辆对象，而自动传输代表另一类对象。因此，自动传输类将以上述相同方式继承车辆类。我们称之为“类继承”。![../images/480347_1_En_3_Chapter/480347_1_En_3_Fig10_HTML.png](img/480347_1_En_3_Fig10_HTML.png)

图 3.10

车辆传输类型类

我之前提到了 OO 对象可重用（可重用对象）的能力。这在于它允许一个定义好的对象成为另一个类的一部分，同时保持其自身的原始身份和独立性。下面的示例演示了如何在另一个类中重用车辆（图 3.11）。![../images/480347_1_En_3_Chapter/480347_1_En_3_Fig11_HTML.png](img/480347_1_En_3_Fig11_HTML.png)

图 3.11

车辆运输类

请注意，对象 Car 现在已成为另一个称为 Transportation Vehicles 的类的一部分。但是，Car 不再是其类中的抽象对象，而是具体的，因此从其父类 Transportation Vehicles 继承。对象 Cars 具有的方法可能会根据它所在的类而执行不同。因此，在 Transportation Vehicle 类中的 Cars 可能会将对“驾驶汽车”的请求解释为与一般交通工具相关。具体地说，它可能会调用一个显示如何在汽车行驶时操纵汽车的服务。另一方面，在 Transmission 类中的 Cars 可能会将来自其子对象之一的相同消息解释为当人们驾驶时变速器如何换档。这种现象称为多态性。多态性允许对象在不同情况下在相同的方法中改变其行为。更重要的是，多态性是动态的行为，因此它的操作变化是在对象执行或运行时确定的。

因为对象可以被重用，保持在不同类中相同对象的每个副本中的相同版本是很重要的。幸运的是，对象通常存储在动态链接库（DLL）中。DLL 的重要性在于它始终存储对象的当前版本。因为对象在每次执行之前都是动态链接的，所以确保当前版本始终是使用的版本。因此，DLL 工具避免了记住哪些应用程序包含相同子程序的维护噩梦。遗留系统通常需要重新链接发生更改的每个模块中子程序的每个副本。这个问题继续困扰着 COBOL 应用程序社区。

对象系统中的另一个重要特性是实例化和持久性。实例化允许同一类的多个执行独立于另一个执行发生。这意味着同一类的多个副本正在同时执行。这些执行的重要性在于它们是互斥的，并且可以在该类中执行不同的具体对象。由于这种能力，我们说对象可以在其所属类的每个执行副本中具有多个*实例*。有时，尽管类的执行已经完成，但组件对象继续运行或*持久化*。因此，持久性是在调用它的类或操作完成后继续运行的对象。系统必须跟踪每个这样的对象实例。

对象和类具有继承、多态行为、实例化和持久性等能力，这些是开发人员在构建面向对象系统时可以利用的一些新机制。[⁴] 因此，分析师不仅必须了解面向对象的方法论，还必须应用新的方法和工具，以便为系统开发人员制定适当的方案。

## 3.6 对象建模

另一个分析建模工具被称为状态转换图（STD），对于建模事件驱动和时间依赖系统非常有用。状态非常类似于对象/类，因此可以用来描绘对象的流程和关系而无需进行大量修改。对象和状态之间的主要区别在于对象负责其自身的数据（我们在面向对象中称之为属性）。对象的属性被称为*封装*在其方法后面，也就是说，用户不能直接请求数据。封装的概念是对象的访问仅允许出于目的而不是为了获取特定的数据元素。方法及其组件服务的责任是确定为满足对象请求所需的适当属性。无论使用何种方法，对象图本质上都是 STD 和实体关系图（ERD）的混合体。STD 代表对象的方法以及从一个对象到另一个对象的移动的标准。另一方面，ERD 则定义了存储数据模型之间属性的关系。下面通过订单处理示例来展示结果。

图 3.12 反映了一个客户对象向订单对象提交订单的情况。客户与订单之间的关系同时反映了 STD 和 ERD 的特征。 "提交订单" 指定了改变订单对象状态或转移到订单对象的条件。方向箭头还告诉我们订单对象不能向客户对象发送订单。众所周知，crow's foot 基数表明客户对象必须至少有一个订单才能与订单对象建立关系。订单处理完毕后，订单就准备好发货了。请注意，每个订单都有一个相关的发货对象；但是多个仓库物品可以成为一个发货的一部分。上面描述的对象也可以表示类，这表明它们由许多组件对象组成。这些组件对象可能进一步分解为其他原始对象。这与逻辑等价的概念和功能分解(Fig. 3.13)一致。![../images/480347_1_En_3_Chapter/480347_1_En_3_Fig12_HTML.png](img/480347_1_En_3_Fig12_HTML.png)

图 3.12

一个对象/类图

![../images/480347_1_En_3_Chapter/480347_1_En_3_Fig13_HTML.png](img/480347_1_En_3_Fig13_HTML.png)

图 3.13

仓库类的组件对象

分析人员必须明确指定建模图中是表示类还是对象。不建议在同一级别混合类和对象。显然，类级别可以用于用户验证，但最终的分析和工程需要对象。

## 3.7 与结构化分析的关系

许多分析人士假设在面向对象分析中不需要传统的结构化工具。这简直是不正确的，正如我们在前面的例子中所展示的那样。为了进一步强调继续使用结构化技术的必要性，我们需要理解面向对象范式的基本好处，以及结构化工具如何必要来映射到对象和类的创建。轻易地说：“找到所有基本组件中的对象”; 实际上，有一个流程来做到这一点是另一回事。在提供确定对象的方法之前，让我们首先了解问题。

### 3.7.1 应用耦合

耦合可以被定义为应用程序对另一个应用程序的依赖性的度量。简单地说，一个应用程序的更改是否需要另一个应用程序的更改？许多已知的系统故障都是由高度耦合的系统引起的。问题归结到分析功能，决定应该连接哪些服务以形成一个单一的应用程序。耦合绝不是我们想做的事情，但没有一个系统可以仅由一个程序组成。因此，耦合是现实，分析人员必须专注于此。让我们通过以下示例详细说明耦合问题（图 3.14）。![../images/480347_1_En_3_Chapter/480347_1_En_3_Fig14_HTML.png](img/480347_1_En_3_Fig14_HTML.png)

图 3.14

应用耦合

通过变量 Y 的传递，程序 A 和 B 相互耦合。随后，在 B 中使用 Y 来计算 R。如果 A 中的变量 Y 发生变化，不会强制要求 B 中也要做出改变。这被认为是良好的耦合。然而，现在让我们来看看 X。我们发现 X 在 A 和 B 中都有定义。尽管 X 的值在当前版本的 A 和 B 中不会引起问题，但后续更改 X 的值将导致程序员需要记住在 B 中更改该值。这是一个维护的噩梦。在大型企业级系统中，分析人员和程序员无法“记住”所有这些耦合发生的地方，特别是当原始开发人员已不再与组织合作时。解决这个问题的方法也是从程序 A 中传递 X，如图 3.15 所示。![../images/480347_1_En_3_Chapter/480347_1_En_3_Fig15_HTML.png](img/480347_1_En_3_Fig15_HTML.png)

图 3.15

使用变量 X 和 Y 进行应用耦合

现在我们看到 X 和 Y 都被传递了，程序 A 和 B 被称为耦合度低。此外，程序 A 被称为更*内聚*。

### 3.7.2 应用内聚

内聚是衡量程序对自身处理的独立程度的标准。也就是说，一个内聚的程序包含完成其应用所需的所有必要数据和逻辑，而不受另一个程序的直接影响；另一个程序的更改不应该需要对内聚的程序进行更改。此外，内聚的程序不应该导致对另一个程序的更改。因此，内聚的程序是独立的程序，它们根据消息做出反应以确定需要做什么；然而，它们保持自包含性。当程序 A 也传递 X 时，它变得更内聚，因为对 X 的更改不再需要对另一个程序进行更改。此外，B 更具内聚性，因为它自动从 A 获取 X 的更改。设计更具内聚性的系统被认为更易维护。它们的代码也可以作为组件被重用或改装到其他应用程序中，因为它们是完全独立的。一个内聚的程序可以与汽车的可互换标准零件进行比较。例如，如果一辆车需要标准的 14 英寸轮胎，通常可以使用符合规格的任何轮胎。因此，轮胎不是与特定的汽车结合在一起，而是许多汽车的内聚组件。

内聚在许多方面都与耦合相反。内聚度越高，耦合度越低。分析员必须明白，内聚度或耦合度的极端都是不存在的。这在下图中显示出来（图 3.16）。![../images/480347_1_En_3_Chapter/480347_1_En_3_Fig16_HTML.png](img/480347_1_En_3_Fig16_HTML.png)

图 3.16

耦合和内聚关系

图表显示，我们永远无法达到 100% 的内聚度；那将意味着整个系统只有一个程序，这种情况是不太可能的。然而，可以有一个获得 75% 内聚比率的系统。

现在我们需要将这个讨论与 OO 相关联。显然，OO 非常基于内聚的概念。对象是独立的可重用模块，控制其自身的属性和服务。对象耦合完全基于通过继承或协作的消息处理。^(5) 因此，一旦对象被识别出来，分析员必须以一种内聚的方式定义其所有过程。一旦定义了内聚的过程，就可以将对象所需的属性添加到对象中。下表显示了如何组合过程以创建最佳的内聚（图 3.17）。![../images/480347_1_En_3_Chapter/480347_1_En_3_Fig17_HTML.png](img/480347_1_En_3_Fig17_HTML.png)

图 3.17

选择内聚对象的方法

上述层次基于最佳到最差，其中 By Function 是最理想的，By Lines of Code 是最不理想的。Tier 1 和 Tier 2 将产生最佳的对象凝聚性。可以从以下示例中看出这一点。

图 3.18 描述了一个包括四个对象的四屏系统，即每个屏幕是一个单独的对象。事务处理对象是使用 Tier 2，By Same Data 设计的，因为它只处理事务文件。该对象具有凝聚力，因为它在处理过程中不依赖于或影响另一个模块。它提供了所有必要的事务数据方法。![../images/480347_1_En_3_Chapter/480347_1_En_3_Fig18_HTML.png](img/480347_1_En_3_Fig18_HTML.png)

图 3.18

具有不同类型对象凝聚力的应用程序

财务对象是 By Function 的一个示例，因为资产负债表依赖于利润表，而利润表依赖于试算平衡表。因此，该对象在所有产生财务信息所需的功能内是自包含的（在这个例子中）。

另一方面，系统编辑器是 Tier 3 的一个示例，表明它处理系统的所有编辑（数据质量验证）。虽然将类似代码放在一个对象中似乎有一些好处，但我们可以看到它影响了许多不同的组件。因此，它被认为是一个高度耦合的对象，不一定是最容易维护的。

我们可以得出结论，Tier 1 和 Tier 2 为分析人员提供了最具吸引力的确定对象属性和服务的方式。尽管 Tier 3 和 Tier 4 虽然被实践，但在面向对象编程中并没有提供任何真正的好处，应尽量避免使用。现在的问题是，我们在开发逻辑对象时应该遵循什么样的技术来开始提供必要的服务和属性？

第三章讨论的结构化工具为我们提供了与 OO 分析和设计一起工作的基本能力。STD 可用于确定初始对象以及一个对象如何耦合或关联到另一个对象的条件。一旦准备好 STD，它可以发展成本章前面讨论过的对象模型。对象模型可以分解到最低级别；然后必须定义每个对象的属性和服务。现在所有的 DFD 功能原语都可以映射到它们各自的对象，作为它们方法中的服务。这也是确定对象是否缺失的一种方法（是否应该有一个没有相关对象的 DFD）。分析员应尝试使用 Tier 1 By Function 方法组合每个 DFD。这有时可能非常困难，这取决于系统的大小。如果 Tier 1 方法太困难，分析员应尝试 Tier 2，根据它们相似的数据存储组合 DFD。这是一种非常有效的方法；由于 Tier 1 暗示了 Tier 2，它是确定进程应该如何映射到其适当对象的一种非常有效的方法。这并不意味着分析员不应该首先尝试 Tier 1。

下一个活动是确定对象的属性或数据元素。ERD 作为对象中属性与其在数据库中的实际存储之间的链接。重要的是要注意，对象中的属性设置可能与逻辑和物理数据实体中的设置毫无相似之处。数据实体侧重于元素的有效存储和完整性，而对象中的属性数据基于其与对象服务的凝聚性。

对象到 DFD 和 ERD 的映射可以最好地在下面的图形中显示（图 3.19）。![../images/480347_1_En_3_Chapter/480347_1_En_3_Fig19_HTML.png](img/480347_1_En_3_Fig19_HTML.png)

图 3.19

对象与 ERD 和 DFD 之间的关系

因此，功能原始的 DFD 和标准化过程产生的 ERD 提供了描述对象属性和服务的工具。

## 3.8 面向对象的数据库

工业界曾有一股运动，试图用面向对象数据库管理系统（OODBMS）取代传统的关系数据库管理系统（RDBMS）。对象数据库与关系模型大不相同，因为对象的属性和服务是一起存储的。因此，归一化数据的列和行的概念变得消失了。OODBMS 的支持者认为，对象数据库的一个主要优势在于它们还可以保存有关对象的图形和多媒体信息，而这是关系数据库无法做到的。结果是创建了不同的数据存储方式，其中许多不需要行和列的架构，但预计关系模型将继续使用一段时间。然而，大多数 RDBMS 产品将变得更加面向对象。这意味着它们将使用关系引擎，但利用更多的面向对象功能，即构建关系混合模型。在任何情况下，分析师应继续关注捕获需求的逻辑方面。随着区块链架构的演变以及使用自然语言方法使用非格式化数据的增加，预计 OO 方法学的变化将继续发生。

## 3.9 使用用例分析和设计设计分布式对象

用例最早于 1986 年提出，这是由于面向对象范式的流行。如今，用例在开发基于 Web 的系统中被广泛使用，并且是移动 IoT 应用程序开发的适当方法。用例的设计目的是在定义产品的当前和潜在行为时非常有效。也就是说，用例可以用于建模可能从未发生在系统中的活动，但在技术上是可能的。事实上，许多系统缺陷是因为用户尝试首次执行某项操作而发生的。这些类型的情况有时被称为补充规格。在许多方面，用例方法代表了本章前面讨论的状态转换图（STD）的下一代。

### 3.9.1 用例模型

用例模型包含三个基本组件：用例、演员和关系（Bittner 和 Spence 2003）。

### 3.9.2 演员

演员表示系统的用户。当与系统进行交互时，“用户”可以是内部（传统的）、消费者或另一个系统。它们使用图 3.20 中的符号进行标注。![../images/480347_1_En_3_Chapter/480347_1_En_3_Fig20_HTML.png](img/480347_1_En_3_Fig20_HTML.png)

图 3.20

用例演员符号

## 3.10 用例

用例标识了 Actor 与系统进行的特定接口或“用途”，以满足某种需求。在许多方面，所有用例的总和代表了系统可以完成的所有可能交易和事件的清单。它实际上复制了所有可能发生的排列组合。在其最分解的形式中，每个用例定义了一个交易。用例必须产生某种形式的输出。显然，用例可能会有限制；某些可能的 actor 请求可能需要某些授权。如图 3.21 所示，用例用一个球形符号表示（注意其与 DFD 过程的相似性）。![../images/480347_1_En_3_Chapter/480347_1_En_3_Fig21_HTML.png](img/480347_1_En_3_Fig21_HTML.png)

图 3.21

用例符号

图 3.22 显示了一个基本的 Actor/用例图。![../images/480347_1_En_3_Chapter/480347_1_En_3_Fig22_HTML.png](img/480347_1_En_3_Fig22_HTML.png)

图 3.22

Actor/用例流

请注意，图 3.22 中的用例模型实际上包含两个交易。它可以分解为两个单独的用例模型，如图 3.23 所示。![../images/480347_1_En_3_Chapter/480347_1_En_3_Fig23_HTML.png](img/480347_1_En_3_Fig23_HTML.png)

图 3.23

用例作为功能原语

用例建模的第三个组件是由数据流线指定的关系，通常具有箭头以表示方向性。类似于 DFD，数据流携带将由用例过程球转换的数据。方向性表明数据是由 Actor 提供还是由 Actor 从用例过程中接收，或者两者都有！这些关系数据流显示在图 3.22 和 3.23 中。

尽管用例模型具有三个基本符号，但还有另一个关键组成部分。一些分析人员将其称为描述，然而，这个概念再次源于 DFD，在其中进程内的实际算法被称为进程规范。进程规范通常包含两种形式的描述：(1) 伪代码的实际算法形式，或者 (2) 前置条件和后置条件。根据进程的复杂程度，可以同时使用两者。许多分析人员将进程规范定义为有关进程的其他所有内容，而其他建模工具中已经包含的内容不包括在内。事实上，它必须包含通常包括业务规则和应用逻辑的剩余信息。德马科建议，每个功能原语 DFD 指向一个“Minispec”，其中包含该进程的应用逻辑。我们将遵循这一规则，并扩展对编写良好应用逻辑的重要性的讨论，即使在用例中也是如此。当然，有不同的风格，以及少数解释分析人员理解这些需要如何开发和呈现的重要性的教科书。与其他建模工具一样，每种进程规范风格都有其优点、缺点和不足之处。

## 3.11 伪代码

最详细和严格的进程规范是伪代码或“结构化英语”。它的格式旨在要求分析人员具有编写算法的扎实理解。该格式非常“类似 COBOL”，最初是作为编写 COBOL 编程规范的一种方式设计的。规定伪代码的规则如下：

+   使用 Do While 和 Enddo 来显示迭代

+   使用 If-Then-Else 来显示条件，并确保每个 If 后有一个 End-If

+   对初始化变量和其他详细处理要求要具体。

伪代码的设计旨在使分析人员对代码设计具有极大的控制权。以以下示例为例：

> 有一个要求，为在第一班上班的员工计算 5% 的奖金，为在第二或第三班上班的工人计算 10% 的奖金。管理层对列出收到 10% 奖金的员工数量的报告感兴趣。该过程还生成奖金支票。

伪代码将是：![../images/480347_1_En_3_Chapter/480347_1_En_3_Figg_HTML.png](img/480347_1_En_3_Figg_HTML.png)上述算法使分析人员能够对程序设计具有极大的控制权。例如，请注意，伪代码要求程序员在发生记录不包含第一班、第二班或第三班员工的情况时具有错误条件。如果有一个新的班次未通知信息系统部门，可能会发生这种情况。许多程序员可能省略了最后的“If”检查，如下所示：![../images/480347_1_En_3_Chapter/480347_1_En_3_Figh_HTML.png](img/480347_1_En_3_Figh_HTML.png)

上述算法简单地假设如果员工不在第一班，则他们必须是第二班或第三班的员工。如果分析员没有明确指定这一点，程序员可能会忽略这一关键逻辑，这可能导致第四班的工人获得 10%的奖金！正如前面提到的，每种流程规范的风格都有其优点和缺点，换句话说，有好有坏，也有丑陋。

*优点*：

使用这种方法的分析员几乎已经编写了程序，因此程序员在确定逻辑设计方面将几乎没有什么可做的。

*缺点*：

该算法非常详细，分析员可能需要很长时间来开发。许多专业人士提出了一个有趣的观点：我们需要分析员将流程规范写得这么详细吗？此外，许多程序员可能会感到受到侮辱，并认为分析员没有掌握设计这种逻辑的技能集。

*丑陋的部分*：

分析员花费了时间，程序员不支持，逻辑是错误的。结果将是程序员的“*我早就告诉过你*”的评论，并且敌意可能会随着时间的推移而增加。

### 3.11.1 Case

Case^(8) 是另一种传达应用逻辑的方法。虽然这种技术不需要像伪代码那样的技术格式，但它仍然需要分析员提供算法的详细结构。使用与伪代码讨论中相同的示例，我们可以看到格式上的差异：![../images/480347_1_En_3_Chapter/480347_1_En_3_Figi_HTML.png](img/480347_1_En_3_Figi_HTML.png)

上述格式提供了控制，因为它仍然允许分析员指定错误检查的需求；然而，逻辑的确切格式和顺序更多地掌握在程序员手中。现在让我们看看这种方法的好坏和丑陋：

*优点*：

分析员提供了算法的详细描述，而无需了解编程中逻辑的格式。由于这种优势，CASE 所需的时间比伪代码少。

*缺点*：

尽管这可能很难想象，但分析员可能会错过算法中的一些可能条件，比如忘记了一个班次！这是因为分析员只是列出条件，而不是编写规范。如果没有像我们在伪代码中那样制定逻辑，那么忘记或忽视条件检查的可能性就会增加。

*丑陋的部分*：

Case 逻辑可以设计而不用担心逻辑的顺序，即逻辑的实际进行而不只是可能性。因此，逻辑可能变得更加混乱，因为它缺乏实际的进展结构。正如前面所述，由于分析员实际上没有遵循每个条件测试的进展，因此错过条件的可能性更大。因此，规范不完整的风险更高。

## 3.12 前后条件

Pre-Post 基于这样一种信念，即分析人员不应该对逻辑的细节负责，而应该对所需的总体要点负责。因此，Pre-Post 方法缺乏细节，并期望程序员在开发应用软件时提供必要的细节。该方法有两个组成部分：前置条件和后置条件。前置条件表示假定为真或必须存在的算法工作的事物。例如，前置条件可能指定用户必须输入变量 X 的值。另一方面，后置条件必须定义所需的输出以及计算输出值与其数学组件之间的关系。假设算法计算了一个称为 Total_Amount 的输出值。后置条件将说明 Total_Amount 是通过将数量乘以价格而产生的。下面是奖金算法的前后置条件等效项：![../images/480347_1_En_3_Chapter/480347_1_En_3_Figj_HTML.png](img/480347_1_En_3_Figj_HTML.png)

我们可以看到，上述规范未显示实际算法应如何设计或编写。它要求程序员或开发团队找到这些细节并实现适当的逻辑来处理。因此，分析人员对应用程序的设计方式或功能方式没有真正的影响。

*优点*：

分析人员不需要具备技术知识来编写算法，也不需要花费过多的时间来开发被认为是编程责任的内容。因此，不那么技术导向的分析人员可以参与规范的制定。

*不足之处*：

对逻辑设计没有控制，因此误解和错误的机会更大。分析人员和项目更加依赖于开发人员的才能。

*缺点*：

或许我们误解了规范。由于前后置条件的格式不太具体，因此存在更多的歧义空间。

## 3.13 矩阵

矩阵或表格方法是一种以表格形式显示应用逻辑的方法。每一行反映了一个条件的结果，每一列代表要测试的条件的组件。解释矩阵规范的最佳方法是展示一个示例，如图. 3.24 所示。![../images/480347_1_En_3_Chapter/480347_1_En_3_Fig24_HTML.png](img/480347_1_En_3_Fig24_HTML.png)

图. 3.24

示例矩阵规范

尽管这是一个简单的例子，使用与其他规范样式相同的算法，但它确实展示了矩阵如何描述应用程序的要求，而不使用句子和伪代码。

*优点*：

分析员可以使用矩阵以表格形式显示复杂条件。许多程序员更喜欢表格格式，因为它易于阅读、组织并且通常易于维护。矩阵往往与许多编程语言使用的数组和表格格式相似。

*不好的*：

在矩阵中显示完整规范很难，甚至是不可能的。上面的例子支持了这一点，因为奖金申请的剩余逻辑没有显示出来。因此，分析员必须集成其他规范样式之一来完成规范。

*丑陋的*：

矩阵用于描述复杂的条件级别，在这些级别上有许多要测试的“如果”条件。这些复杂的条件通常需要比矩阵中显示的更详细的分析。问题出现在分析员觉得矩阵可能足够时，他没有提供足够的细节。结果是：在开发过程中，程序员可能会误解条件。

*结论*：

必须再次问这个问题：什么是一个好的规范？我们将继续探讨这个问题。在本章中，我们已经检查了逻辑的各种替代方案。哪种逻辑方法最好？这取决于情况！我们从例子中看到，每种方法都有其优点和缺点。最好的方法是能够将它们全部使用，并为手头的任务选择最合适的方法。要有效地做到这一点，意味着清楚地认识到每种风格在你正在处理的系统部分中提供了哪些好处，以及谁将进行开发工作。下表试图客观地说明优点和缺点。

## 3.14 问题与练习

1.  1.

    什么是对象？

1.  2.

    描述方法和服务之间的关系。

1.  3.

    什么是类？

1.  4.

    对象范式如何改变分析员的方法？

1.  5.

    描述两种类型的对象，并提供每种类型的示例。

1.  6.

    什么是基本功能？

1.  7.

    什么是对象类型，以及它如何用于开发特定类型的类？

1.  8.

    什么是对象和类的继承？

1.  9.

    ERD 和对象图之间的关联差异是什么？

1.  10.

    函数分解如何与类和对象相关联？

1.  11.

    耦合和内聚是什么？它们彼此之间的关系是什么？

1.  12.

    结构化方法如何与对象模型中的内聚性概念相关联？

1.  13.

    可以用哪四种方法来设计一个内聚的对象？

1.  14.

    什么是对象数据库？

1.  15.

    什么是客户/服务器？

1.  16.

    对象如何与客户/服务器设计相关联？

1.  17.

    为什么在客户/服务器设计中需要混合对象？

1.  18.

    什么是用例分析和设计？

1.  19.

    分布式对象是什么意思？

## 3.15 迷你项目

你被要求自动化应付账款流程。在与用户的面试中，你确定了四个主要事件如下：

1.  I. *采购订单流程*

    1.  1.

        市场部门向应付账款系统（APS）发送书籍的采购订单（P.O.）表格。

    1.  2.

        APS 分配一个 P.O. #并将 P.O.-White 副本发送给供应商，并将 P.O.-Pink 副本归档在 P.O.#.sequence 文件柜中。

1.  II.*发票收据*

    1.  1.

        供应商发送书籍购买的付款发票给 APS。

    1.  2.

        APS 将发票发送到市场部门进行授权。

    1.  3.

        市场部门将发票返回给 APS 进行批准，或者如果未经授权，则退回给供应商。

    1.  4.

        如果发票退回到 APS，则会与原始 P.O.-Pink 进行匹配。然后将采购订单和供应商发票合并成一个数据包，并准备好进行凭证处理。

1.  III.*凭证启动*

    1.  1.

        APS 收到凭证数据包进行凭证。它通过分配凭证号码开始此过程。

    1.  2.

        总会计必须批准金额超过$5,000 的凭证。

    1.  3.

        APS 从批准的凭证中准备另一个数据包。此数据包包括 P.O.-Pink、授权发票和批准的凭证。

1.  IV.*支票准备*

    1.  1.

        打字员接收批准的凭证数据包，并检索编号空白支票以支付供应商。

    1.  2.

        打字员使用批准凭证的数据键入双联支票（蓝色、绿色），并在支票存根上输入发票号码。

    1.  3.

        APS 将带有支票–绿色的批准数据包归档在永久支付文件中。

    1.  4.

        检查可以直接领取或邮寄给供应商。

分配：

1.  1.

    为四个事件提供 DFDs。每个事件应显示为单个 DFD，分别在不同的纸张上。

1.  2.

    将每个事件级别化到其功能原语。

1.  3.

    为每个功能原始 DFD 制定流程规范。
