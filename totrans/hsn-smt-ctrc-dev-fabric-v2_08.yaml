- en: Chapter 5\. Smart Contract Invocation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter equips you with the knowledge you need to invoke smart contracts.
    We’ll use the prerequisites installed in [Chapter 4](ch04.xhtml#smart_contract_development).
    Then, using a script, we’ll start and stop a local Fabric test network and deploy
    the Fabcar smart contract.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Since we are leveraging Fabcar and the Fabric test network, we start with a
    review of *fabric-samples*, the Fabcar smart contract, and the Fabric test network.
    We’ll then start our test network and deploy the Fabcar smart contract. Next,
    we’ll go through the steps executed by the script. Once our test network is up
    and running with the Fabcar smart contract deployed, we’ll invoke Fabcar smart
    contract functions. We’ll use the `peer invoke` command as well as a command-line
    Node.js application to execute a Fabcar smart contract function. The Node.js application
    will use the Fabric Client SDK for Node.js.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will help you achieve the following practical goals:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Invoking smart contracts via the command- line interface
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Evaluating transaction functions for queries
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Submitting transactions and query transaction history
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and issuing an application contract
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overview of fabric-samples, Fabcar, and the Test Network
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you’ll learn how to start, deploy, and invoke a smart contract
    on the Hyperledger Fabric test network. We’ll first look at the structure and
    components of *fabric-samples*. Then we’ll walk through the essential steps for
    deploying our sample smart contract, Fabcar. Once Fabric is set up and running,
    we will start invoking the Fabric smart contract through the `peer` command and
    Node.js methods. The Fabric test network is a great place for experimenting and
    running essential operations on smart contracts before moving your Fabric application
    to production.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: fabric-samples
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Installing the prerequisites in [Chapter 4](ch04.xhtml#smart_contract_development)
    included *fabric-samples*, which is Hyperledger Fabric’s project for helping developers
    learn Fabric smart contract development. It contains many smart contract samples
    and tools for the rapid development of Fabric smart contracts. Included is a complete
    development Fabric network comprising two organizations. Each organization has
    a peer and CA. The network is containerized using Docker, which makes it easy
    and fast to launch and manage.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: If you followed the instructions in [Chapter 4](ch04.xhtml#smart_contract_development)
    to install the prerequisites, you should have the *fabric-samples* directory.
    We will use the *bin*, *test-network*, *chaincode*, and *fabcar* subdirectories
    with this chapter and [Chapter 6](ch06.xhtml#testing_and_maintenance).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Hyperledger Fabric has shown firm support for *fabric-samples*. Fabric continues
    to introduce new functionality, improve existing code, and advance tools that
    together make *fabric-samples* the primary project for Hyperledger Fabric smart
    contract developers.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: The *bin* subdirectory contains the `peer` executable, which we will use as
    the first method to invoke the Fabcar smart contract. The *chaincode* subdirectory
    contains the Fabcar smart contract, and the *fabcar* directory contains the command-line
    client for the Fabcar smart contract. We will use *test-network* to deploy the
    *fabcar* smart contract. Once the contract is deployed, we can invoke it.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will launch a test network for Fabcar with the help of the
    *fabcar* script. Every Fabric smart contract needs a Fabric network. You can continue
    to advance your skills by leveraging the test network and apply what you learn
    in this chapter to the additional smart contracts in *fabric-samples*.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Fabcar
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Fabric smart contract, Fabcar, is one the earliest and simplest sample smart
    contracts in *fabric-samples*. It is great for learning the basics of Fabric smart
    contract operation and development. Getting hands-on with Fabric smart contract
    development is easy and fast with Fabcar because it is mature, stable, and simple
    in design, but fully functional. It implements the core functionality we need
    to understand and develop Fabric smart contracts.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Fabcar has two parts. The first part is the Fabcar smart contract, which we
    examined in [Chapter 4](ch04.xhtml#smart_contract_development). The other part
    is the Fabcar client. The client invokes the smart contract.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Fabcar client
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see in [Figure 5-1](#fabcar_client_implementations), the Fabcar client
    has multiple implementations. We are interested in the JavaScript implementation.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '![Fabcar client implementations](Images/HLF_0501.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
- en: Figure 5-1\. Fabcar client implementations
  id: totrans-22
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Provided are two shell scripts, *startFabric.sh* and *networkDown.sh,* to start
    and stop our Fabcar test network. The *startFabric.sh* script prepares and runs
    a new environment; then it deploys and initializes our Fabcar smart contract.
    The *networkDown.sh* script shuts down all Docker containers, removes them, and
    cleans up the environment.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  id: totrans-24
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: When the Fabric network restarts, it typically cleans all of the data. If you
    need to persist any work that’s in a container that’s part of your Fabcar test
    network, you need to persist your data prior to starting or stopping the test
    network. Typically, you need to mount a volume for the directory */var/hyperledger/production*
    in the orderer and peer Docker containers.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: The Fabcar client is implemented as four Node.js command-line applications,
    highlighted in [Figure 5-2](#fabcar_nodedotjs_applications). Two of the applications,
    *enrollAdmin.js* and *registerUser.js,* handle enrolling an administrator and
    registering an application user. The other two Node.js applications, *invoke.js*
    and *query.js*, handle an invoke transaction and a query evaluation, respectively.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '![Fabcar Node.js applications](Images/HLF_0502.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
- en: Figure 5-2\. Fabcar Node.js applications
  id: totrans-28
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: These are the four Node.js applications we will examine and execute to invoke
    the Fabcar smart contract. In [Chapter 6](ch06.xhtml#testing_and_maintenance),
    we will refactor and incorporate them into a new Node.js Express web application
    we develop, called Fabcar UI.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是我们将要检查并执行以调用 **Fabcar** 智能合约的四个 Node.js 应用程序。在第 [6 章](ch06.xhtml#testing_and_maintenance)中，我们将重构并将它们整合到一个我们开发的新的
    Node.js Express web 应用程序中，称为 Fabcar UI。
- en: 'Fabric smart contract clients use a language-specific version of the Fabric
    Client SDK. Clients developed in JavaScript can use the [Fabric Client SDK for
    Node.js](https://github.com/hyperledger/fabric-sdk-node) to incorporate the Fabric
    smart contract functionality to authenticate, submit transactions, and evaluate
    queries. Because of these Node.js package dependencies from the *package.json*
    file, npm installs the four Node.js modules highlighted in [Figure 5-3](#fabcar_client_fabric_sdk_for_nodedotjs):'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 使用特定语言版本的 Fabric 客户端 SDK 的 Fabric 智能合约客户端。用 JavaScript 开发的客户端可以使用 [Fabric 客户端
    SDK for Node.js](https://github.com/hyperledger/fabric-sdk-node) 来整合 Fabric 智能合约功能，进行身份验证、提交交易和评估查询。由于这些
    Node.js 包依赖关系来自 *package.json* 文件，npm 安装了 [图 5-3](#fabcar_client_fabric_sdk_for_nodedotjs)
    中突出显示的四个 Node.js 模块：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![Fabcar client Fabric SDK for Node.js modules](Images/HLF_0503.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![Fabcar 客户端 Fabric SDK for Node.js 模块](Images/HLF_0503.png)'
- en: Figure 5-3\. Fabcar client Fabric SDK for Node.js modules
  id: totrans-33
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-3. Fabcar 客户端 Fabric SDK for Node.js 模块
- en: The two packages we will directly use are *fabric-ca-client*, which handles
    the interaction with the authority to enroll, register, and administrate identities;
    and *fabric-network*, which provides `gateway`, `network` (channel), and `contract`
    objects to interact with the Fabric smart contract.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将直接使用的两个包是 *fabric-ca-client*，它处理与权威机构进行注册、注册和管理身份的交互；以及 *fabric-network*，它提供了
    `gateway`、`network`（通道）和 `contract` 对象来与 Fabric 智能合约交互。
- en: Fabcar smart contract
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Fabcar** 智能合约'
- en: The Fabcar smart contract, *fabcar.js*, like the client, is implemented in several
    languages; we discussed its implementation in [Chapter 4](ch04.xhtml#smart_contract_development).
    The *chaincode/fabcar/javascript* subdirectory with the *lib* subdirectory should
    be selected. The Fabcar smart contract that we will deploy and invoke in this
    chapter is in the *lib* subdirectory.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**fabcar.js** 是一个 Fabcar 智能合约，和客户端一样，它也实现了多种语言；我们在[第 4 章](ch04.xhtml#smart_contract_development)讨论了它的实现。应选择带有
    *lib* 子目录的 *chaincode/fabcar/javascript* 子目录。本章我们将部署和调用的 Fabcar 智能合约位于 *lib* 子目录中。'
- en: 'The Node,js smart contract has dependencies:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 智能合约有依赖关系：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'These two dependencies, *fabric-contract-api* and *fabric-shim*, result in
    the Node.js packages being imported into the project. Only one import is required
    for Fabric smart contracts, *fabcar.js*:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个依赖项，**fabric-contract-api** 和 **fabric-shim**，导致了 Node.js 包被导入到项目中。对于 Fabric
    智能合约，只需要一个导入，即 *fabcar.js*：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The package *fabric-shim* is a low-level interface to the chaincode, and *fabric-shim-api*
    is used by both *fabric-shim* and *fabric-contract-api* to provide type definitions.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**fabric-shim** 包是一个提供给链码的低级接口，而**fabric-shim-api** 则被**fabric-shim** 和 **fabric-contract-api**
    共同使用，用于提供类型定义。'
- en: Fabric test network
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Fabric 测试网络
- en: The Fabric test network will launch a working Fabric network that can be used
    for smart contract deployment. The *network.sh* script is used indirectly when
    we use the Fabcar script, *startFabric.sh*, to start, and *networkDown.sh* to
    stop the test network. This script is modular and can be refactored into a set
    of granular tools, suitable to your workflow and style. It can also serve as a
    good example for learning how to develop a script or scripts to launch and manage
    your own custom Fabric network. For our development, it is a quick start and takes
    the pain out of designing, configuring, and managing all the resources required
    to implement a functional Fabric network.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Fabric 测试网络将启动一个可用的 Fabric 网络，用于智能合约的部署。当我们使用 Fabcar 脚本 *startFabric.sh* 启动和
    *networkDown.sh* 停止测试网络时，间接使用 *network.sh* 脚本。这个脚本是模块化的，可以重构为一系列细粒度的工具，适合你的工作流程和风格。它也可以作为一个很好的例子，学习如何开发脚本来启动和管理你自己的自定义
    Fabric 网络。对于我们开发来说，这是一个快速启动，减轻了设计、配置和管理实现功能性 Fabric 网络所需的所有资源的痛苦。
- en: Once you develop a production-ready smart contract, you can package and promote
    it to production. The process of deploying it is dependent on the network it is
    being deployed to. Each production network will be different, but the functioning
    of your smart contract will be consistent across each network. In [Chapter 9](ch09.xhtml#hyperledger_fabric_vtwo_integration),
    we discuss test networks for Hyperledger Fabric v2\. As applications grow in complexity,
    you will need to architect new custom networks to suit your specific requirements.
    The Fabric test network is a minimal network, but fully functional. It is designed
    with two organizations, and each runs a peer. Each organization has a CA to issue
    X.509 certificates to the members of the organization.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Docker Container and CouchDB databases
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The test network configuration for Fabcar in the Docker Dashboard has the following
    servers running in Docker containers:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '*ca_org2*'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: The credential authority for organization 2
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '*ca_orderer*'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: The credential authority for the network orderer
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '*ca_org1*'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: The credential authority for organization 1
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '*couchdb1*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: The world state database for organization 2
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '*orderer.example.com*'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: The network order that creates blocks and sends them for commit
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '*couchdb0*'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: The world state database for organization 1
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '*peer0.org2.example.com*'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: The peer for organization 2
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '*peer0.org1.example.com*'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: The peer for organization 1
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: The two top containers are the smart contract runtime containers for each organization’s
    peer.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'The world state database for the organizations in our test network is CouchDB.
    We can access CouchDB with our browser by using the Fauxton web application, which
    is part of CouchDB. Open your browser and go to the following CouchDB URL: [*http://127.0.0.1:5984/_utils/*](http://127.0.0.1:5984/_utils/)#.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: You will receive a page to log in to CouchDB. You can enter `**admin**` for
    username, and `**adminpw**` for the password, which are the defaults. These would
    be changed and secured with limited access in production, but for development,
    this works well. Also, the username and password will be part of network configurations
    and will be available in your *.yaml* file.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: After the login, you will receive the page displaying the *couchdb0* databases
    for organization 1\. The ninth row displays *mychannel_fabcar*. This is our Fabcar
    world state database. *mychannel* is the name of the Fabcar Fabric channel, and
    *fabcar* is the name of our chaincode.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Each CouchDB instance in our test network can be accessed by changing the port
    number in the URL to the port number displayed in the Docker Dashboard list of
    Fabric containers, which shows port 5984 is *couchdb0*, and port 7984 is *couchdb1*.
    So changing the port to `**7984**` in the CouchDB URL gives us access to *couchdb1,*
    the world state database for organization 2\. Notice they are identical, as they
    should be, since they represent the world state for Fabcar.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a summary of key takeaway points:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Every organization in a Fabric network can have one or multiple channels.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each channel will have a world state (like a database) per smart contract.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The world state database (and likely its contents) will be different for each
    channel.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each instance of a smart contract will run simultaneously on all channels in
    a Fabric network.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that you understand the basics of *fabric-samples*, *fabcar*, and *test-network*,
    we’re ready to launch a Fabcar test network and deploy the Fabcar smart contract.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Deploying a Smart Contract
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need a Fabric network to deploy our Fabcar smart contract. For development,
    it is convenient to use *test-network,* part of *fabric-samples*. While you can
    execute *test-network*’s *network.sh* to start a default network, we use *startFabric.sh*
    to start *test-network* and *networkDown.sh* to stop *test-network*.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: When *startFabric.sh* is executed, the first thing it does, besides setting
    the default implementation language, is stop the network. This is to prevent runtime
    issues relating to resources and their runtime states.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  id: totrans-77
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The test network has no persistence, and each execution brings up a new network.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: Understand the startFabric.sh Anatomy
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we execute *startFabric.sh*, let’s examine it. The default implementation
    language is Go. This line from the script sets the default implementation to Go:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can choose another supported implementation language, like JavaScript,
    by supplying a supported argument as shown here:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'After setting the implementation language, run the following command:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, all implementations have their *wallet* subdirectory contents
    removed. We will discuss wallets when we execute the Fabcar client applications.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the script executes:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you see, *startFabric.sh* calls the *network.sh* script three times, supplying
    various arguments. The first call instructs *network.sh* to shut down the network.
    It does not matter if the network is not running; no errors are generated. It
    always runs and is a safety measure to ensure that a new error-free network is
    launched.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: The second execution, or `createChannel` command, brings up the network, creates
    a channel (network), and sets the world state database to CouchDB. After this
    command completes, the network is up and running.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: The third execution deploys the Fabcar chaincode (smart contract) to the network.
    The network provides many default *.sh* scripts—for example, the channel name,
    which is *mychannel*. Once completed, the Fabcar network is up and running, and
    our Fabcar smart contract is deployed and initialized.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Execute startFabric.sh
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have looked at the *startFabric.sh* script and understand what it
    does, let’s execute it and briefly review the output. It’s verbose but informative,
    so becoming familiar with it will help us better understand what the *network.sh*
    script is accomplishing for us.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a shell and make sure Docker is running. You can check whether Docker
    is running by executing the following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Change to the *fabric-samples/fabcar* directory located where you installed
    the prerequisites described in [Chapter 4](ch04.xhtml#smart_contract_development)
    and execute this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Your console will begin scrolling text output and continue to completion. The
    script will take a few minutes to complete. Once it’s completed, you can save
    the text output for use and study. It contains the step-by-step sequence used
    to bring up the network. We are interested in the last command and the sequence
    of commands used to deploy the Fabcar smart contract.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we look at the smart contract deployment, let’s take a quick look at
    the first part of the output, because it provides useful information, including
    the channel name and versions:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We see our channel name is *mychannel*, and the Fabric version is 2.3.0, indicated
    by `LOCAL_VERSION` and `DOCKER_IMAGE_VERSION`. The credential authority is version
    1.4.9.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Generate Fabric Certificate Authorities
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, we are informed the script is going to generate certificates for CAs,
    create the network, and create Docker containers for organization 1, organization
    2, and the orderer credential authorities (as shown in the following output).
    Credential authorities play an important role in managing identities for each
    organization and the orderer:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Then we are informed that the script is going to create the identities for organization
    1\. This will take several commands to accomplish. The script repeats these steps
    for organization 2 and the orderer.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Create Org1 Identities
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can use this output to capture commands and have a record of their expected
    result. You can use a simple pattern to make this easy. First, the script employs
    descriptive and informative text to guide the reader. Second, the script commands
    are clearly identified by a leading `+` sign. For example, the following informative
    text tells us the action is to enroll the CA admin, and it is followed by the
    `+` character and command on the next line. The command to perform this action
    is `fabric-ca-client`. The command is followed by command output:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The commands the script executes, including `fabric-ca-client`, are contained
    in the *bin* subdirectory of *fabric-samples*. This means we can execute these
    commands by using this output as a model or guide. This pattern repeats for each
    command and group of commands. The script groups repeatable sequences; for example,
    we use a common sequence to create org1 identities, create org2 identities, and
    create orderer identities but supply different arguments.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Invoke the Peer Chaincode
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will discuss the smart contract deployment after we look at the last command
    executed by the script, which is `peer chaincode invoke`*.* We use this last command
    to initialize the Fabcar smart contract:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `peer` command has many subcommands, and one we are interested in is `peer
    chaincode invoke`. The `invoke` subcommand can invoke smart contract functions,
    which we will do shortly. The last parameter switch is `-c`. It is followed by
    an argument that designates the smart contract function to execute and any optional
    arguments. We will use this command as one method to invoke a smart contract transaction
    and evaluate a query.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Our primary purpose for this script is to start up our fully functional Fabric
    network, so we can develop Fabric smart contracts. The secondary purpose is to
    capture and leverage the script output. Toward this secondary purpose, we already
    have a command we can use to invoke our smart contract and query it. Next, we
    can leverage the script output’s smart contract deployment section by leveraging
    it in maintenance and testing, which we’ll discuss in [Chapter 6](ch06.xhtml#testing_and_maintenance).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: When developing smart contracts, we want a fast iteration cycle. When we need
    to deploy or redeploy smart contracts repeatedly, starting and stopping the network
    will not work, so we need to customize the script and customize how we execute
    our deployment to facilitate fast iterations. Hyperledger Fabric v2 comes with
    external builders and launchers, which allow chaincodes to be deployed and executed
    independently ([Chapter 9](ch09.xhtml#hyperledger_fabric_vtwo_integration) covers
    this in more detail). First, we can examine the script output at the point where
    it deploys the smart contract, in order to capture the steps that show us how
    to deploy it.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'To locate the deployment section of the script output, go to the end of the
    output and scroll up to the beginning of the last command:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'From there, scroll up until you see this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This is the end of the script output’s deployment section. To locate the start
    of the script output’s deployment section, scroll up until you see this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This is the beginning of the script output’s deployment section.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 6](ch06.xhtml#testing_and_maintenance), we will look at the commands
    we need, and use the script output to help us deploy for maintenance and testing.
    Right now, let’s look at the six-step deployment sequence the script executed:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Chaincode is packaged on *peer0.org1*
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chaincode is installed on *peer0.org1*
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chaincode is installed on *peer0.org2*
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chaincode definition is approved on *peer0.org1* on channel *mychannel*
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chaincode definition is approved on *peer0.org2* on channel *mychannel*
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chaincode definition is committed on channel *mychannel*
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'These six steps are the required actions we need to perform to deploy our smart
    contracts so we can invoke them. We do not include the checks or queries the script
    executed because they are only informative on status. From the six actions, we
    can derive four groups of actions we need to execute for deployment:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Package
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Approve
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Commit
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need to do the package action only once—in this case, on *peer0.org1*. We
    can then distribute the package as needed to organizations (*peer0.org2*). The
    install action must be executed for every peer that endorses. The approve action
    must be performed by all organizations as stated in policies, and the commit action
    is executed once but includes all organizations’ endorsing peers in the command.
    In [Chapter 7](ch07.xhtml#building_supply_chain_dapps_with_hyperl), we provide
    script files to execute all these commands.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: With the successful completion of *startFabric.sh,* the Fabcar test network
    is up and running. You can generate this output anytime you need an example of
    a command or need to verify changes you may make.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Our Fabcar smart contract is deployed and initialized. The script executed a
    command that invoked Fabcar. We can also use the command to invoke Fabcar, which
    we will see next. But before we leave, we should appreciate the utility of this
    output. It maps out the commands and command responses for creating from scratch
    a Fabric network with an orderer; orderer credential authority; and two organizations,
    each with a peer, a database, and a credential authority. The *network.sh* script
    responsible for the output is a resource we can put to good use as our needs change.
    For now, all we need is provided by this script. It has launched our test network,
    deployed the Fabcar smart contract, and initialized it.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: We can now invoke the smart contract functions of Fabcar.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Invoking Smart Contract Transactions
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `peer chaincode invoke` command is the first method we will look at and
    execute to invoke our Fabcar smart contract functions. The next method we will
    look at and use incorporates the Hyperledger Fabric SDK for Node.js, which can
    be used for developing smart contract clients.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: By using the Hyperledger Fabric SDK for Node.js, you can develop both command-line
    Fabric smart contract clients, like Fabcar, and Fabric smart contract clients
    that incorporate a UI into the design of the Fabric smart contract client application.
    We discuss a UI version of the command-line Fabcar smart contract client in `[Chapter 6](ch06.xhtml#testing_and_maintenance)`.
    Let’s now look at and execute the `peer chaincode invoke` method.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Peer Command
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `peer` command is a Hyperledger Fabric core binary. When you installed
    the prerequisites, the *peer* binary along with several other binaries were downloaded
    and placed into the *bin* subdirectory of *fabric-samples*. This binary has five
    functions, or subcommands, it performs:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `peer node` command is the subcommand used to function as a Fabric node
    or Fabric peer:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Examining *docker-compose-test-net.yaml* in the *docker* subdirectory of *test-network,*
    you see the startup command executed to start the node:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `peer` subcommand we are interested in is the `chaincode` subcommand. This
    subcommand also has several subcommands:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We want to use the `invoke` subcommand. Some other `peer chaincode` subcommands
    were used in the script that launches the test network and can be found by searching
    the output text we saved from the launch.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Using the `peer` command involves many parameters, so in a practice environment,
    we use variables to minimize the length of the resulting `peer` command-line text.
    We will use environment variables so we can execute `peer chaincode invoke` against
    our Fabcar test network.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 'When we executed *startFabric.sh,* we were in the *fabric-samples/fabcar* subdirectory.
    The script executes a change directory command while saving the current directory,
    which is *fabric-samples/fabcar.* The script changes to *fabric-samples/test-network.*
    This makes *fabric-samples/test-network* the current directory for the execution
    of the script. This is important to us because we are going to reuse the `peer
    chaincode invoke` command from the script to execute our `invoke command`. For
    this to work, we need to open a shell and change the directory to *fabric-samples/test-network*.
    Then execute these export commands to configure your environment to find the *peer*
    binary in the *bin* subdirectory, the created *test-network* configuration in
    *fabric-samples/config*, and additional information `peer` needs to find in order
    to execute correctly:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Once you execute these, your environment is configured to execute `peer`. To
    test this, execute the following:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Your versions may be different, but you should see a result like this:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Locate the `peer chaincode invoke` command that initializes the Fabcar smart
    contract and copy it to your editor, so we can refactor it. Remember, it is at
    the last command executed in the launch script output and looks like this, except
    your paths will be different:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We want to modify the following text at the end of this command
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'into this:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Make sure you delete the `--isInit` switch. Since we removed the command to
    be executed for initialization, it will fail and error, because this switch is
    informing the peer to perform an initialization.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you modify the command text, it should look like this:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now copy the command to your shell and execute it. The output will look like
    this:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We just invoked the Fabcar smart contract. What we invoked was a query, which
    is a read transaction. When we invoke, we execute either a write or a read transaction.
    The read transactions are not committed to the ledger; only write transactions
    are committed, provided they get properly endorsed and validated.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: 'The Fabcar smart contract transaction we invoked was the `queryAllCars` transaction.
    Looking at *fabcar.js*, this Fabcar transaction is calling `getStateByRange` with
    the arguments set to an empty string. This will return all data for a specific
    car key, which we see in the result:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Remember, the `ctx` object is the first argument passed to every smart contract
    transaction.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: 'It provides access to the `stub` object, which instantiates a `ChaincodeStub`
    class (an implementation of `IChaincodeStub`), and the `clientIdentity` object,
    which instantiates a `ClientIdentity` class (which implements `IClientIdentity`):'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'These two classes, `ChaincodeStub` and `ClientIdentity`, are part of the *fabric-shim*
    package, a Node.js module. We do not directly use the *fabric-shim* module, because
    we use the *fabric-contract-api* package, which provides the `Contract` object
    for our use:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `Contract` object provides access to both `ChaincodeStub` and `ClientIdentity`
    via the `Context` object `ctx`, which all smart contract functions receive as
    their first argument. The `Contract` object also provides functions we can use
    as interceptors before and after an invoked transaction. We look at these in the
    next chapter, when we discuss maintenance and testing.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s use `peer chaincode invoke` to invoke a Fabcar write transaction.
    We can use the same command we used for the query. All we need to do is change
    the argument to the `-c` switch. Let’s execute `changeCarOwner`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'After you change the `-c` switch argument, you should have a command like this:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now execute it and see this for the result:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This shows the transaction executed successfully. Since we change the owner
    of `CAR0`, let’s check it with another query, but this time for specific data.
    Again using the same `peer` command, we just need to change the `-c` switch argument:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'After executing, you should see this:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'It worked! We changed the owner. Later you will see how to get the history
    of transactions that are associated with the same key. The key for our write transaction,
    `changeCarOwner`, is `CAR0`. Remember, the ledger has two parts: the world state
    and the blockchain ledger (a file-based implementation of an immutable linked
    list, in simple terms). The world state is the current state of the blockchain
    for a given key. Our world state is implemented by CouchDB for our Fabcar test
    network.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see our change by using the CouchDB browser interface we discussed earlier
    in the chapter. Let’s view our change in the world state database. As we have
    already discussed accessing CouchDB earlier in this chapter, open your browser
    and log in to CouchDB with the username `**admin**` and password `**adminpw**`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[*http://127.0.0.1:5984/_utils/#login*](http://127.0.0.1:5984/_utils/#login)'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'Then go to this URL in CouchDB:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[*http://127.0.0.1:5984/_utils/#database/mychannel_fabcar/CAR0*](http://127.0.0.1:5984/_utils/#database/mychannel_fabcar/CAR0)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: You should see that the owner of `CAR0` is `Mark`, as displayed in [Figure 5-4](#carzero_record_in_couchdb).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '![CAR0 record in CouchDB](Images/HLF_0504.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
- en: Figure 5-4\. `CAR0` record in CouchDB
  id: totrans-196
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We’ll use the `peer chaincode invoke` command for more advanced purposes in
    the next chapter. Now let’s look at the Fabcar client and see how it invokes the
    Fabcar smart contract.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Fabric SDK for Node.js Command-Line Application
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In [Chapter 4](ch04.xhtml#smart_contract_development), we examined the Fabcar
    smart contract in depth. Now we are going to examine the Fabcar smart contract
    client and use it to invoke the contract. The Fabcar smart contract client, as
    discussed earlier in this chapter, is a group of four Node.js JavaScript command-line
    applications: *enrollAdmin.js, invoke.js, query.js,* and *registerUser.js*.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'We will execute each one and look at how they work to invoke the Fabcar smart
    contract. To begin, open a shell and change to the directory *fabric-samples/fabcar/javascript*.
    The Fabcar client is a Node.js command-line application, so we need to execute
    the following:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This command will install project dependencies into our Fabcar project. When
    the command completes, you should have a *node_modules* subdirectory. This is
    where the dependencies listed here are placed:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'If we look in the *node_modules* subdirectory for installed Fabric modules,
    we find the Fabric modules listed here:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: These modules, which represent the Hyperledger Fabric SDK for Node.js, can be
    found in the [Fabric GitHub repo](https://github.com/hyperledger/fabric-sdk-node)
    *[fabric-sdk-node](https://github.com/hyperledger/fabric-sdk-node)*. The *fabric-protos*
    module implements the Protocol Buffers protocol, which is a binary encoded communication
    protocol. We don’t have to worry about this module, and we don’t directly use
    it. The *fabric-common* module contains code used by both *fabric-ca-client* and
    *fabric-network* modules. The *fabric-ca-client* module is used by the Fabcar
    client, but is not required for a Fabric smart contract client. You need to import
    and use *fabric-ca-client* only if your smart contract client needs to interact
    with Fabric CA to manage the life cycle of user certificates. This includes the
    ability to enroll, register, renew, and revoke users. If your smart contract client
    does not perform any of these functions, you do not need *fabric-ca-client*.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: The *fabric-network* module is the only Fabric module required for a Fabric
    smart contract client. It connects your client to the network, and provides the
    ability to invoke transactions including writing to the ledger, and querying the
    world state and ledger.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that our dependencies are installed, we can perform the following:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Enroll our application administrator.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Register our application user.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Invoke a write transaction.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Query the world state.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We first need to enroll an application admin to create an admin-level wallet.
    Then we can register users in an application with an assigned user wallet to secure
    network access.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Enroll our application administrator
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To enroll our administrator, we execute the *enrollAdmin.js* application:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'You should see the following result:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now we can execute *registerUser.js* to register our user:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'You should see the following result:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Great! We can now invoke our smart contract by using the user identity we just
    registered. But first let’s look at what happened here. We need to understand
    what’s going on with these two applications to invoke transactions, because we
    use identities when we invoke our transactions.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'The identities associate us with an organization as a member and permit us
    to perform transactions. Let’s start with the *enrollAdmin.js* application because
    it must be executed first. Open *enrollAdmin.js* in your editor. We are not going
    to parse every line but rather focus on the important ones. The imports are first:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We can see the imports from *fabric-ca-client* and *fabric-network*. We import
    all of *fabric-ca-client* and only *Wallets* from *fabric-network*. This is a
    Node.js command-line application, so we have a `main` function that executes all
    the application logic. This will come in handy when we look at the Fabcar UI,
    which we ported Fabcar to. Now the main logic begins:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: First, the filesystem path to the connection profile for organization 1 is assembled
    and read. This path typically uses the *ccp-template.json* and *ccp-template.yaml*
    files as templates, passing organization name, peer port, CA port, and CA Privacy
    Enhanced Mail (PEM) certificates to generate organization connection files. [Chapter 7](ch07.xhtml#building_supply_chain_dapps_with_hyperl)
    discusses this in more detail. This defines the network configuration to the client.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Once the connection profile is loaded, the certificate authority info and certificate
    authority TLS certificate are set. Using the CA information and TLS certificate,
    the CA object is created. We are using self-signed certificates, so we set the
    `verify` parameter to `false`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'After we have created our CA, we create our wallet:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'First, we create a path. The code is using the current path, which should be
    where our *fabric-samples/fabcar/javascript* subdirectory is located. The code
    appends to the path *wallet*. This is the *wallet* subdirectory in our *fabric-samples/fabcar/javascript*
    subdirectory. Using the full path as an argument to the `Wallets.newFileSystemWallet`
    function, we create a wallet object that we will use to store identities. Next,
    we check whether the *admin* is already enrolled:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We can enroll only once by design. If the admin is not enrolled, we continue
    and enroll the admin:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The CA we created is now used to execute the enroll function. We can see it
    takes the user ID and password for our `admin` as the `enrollmentID` and `enrollmentSecret`.
    Then we create an `x509Identity` object by using the enrollment object we just
    created. We are creating an `x509Identity` that contains the credentials—an object
    containing the certificate and private key, both of which were created and returned
    by the CA enroll function.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Along with the credentials, we add object metadata that identifies the organization
    this identity belongs to and the type of identity. Here `x509Identity` indicates
    a certificate containing a public key paired with a private key. With the identity
    created, we pass it to the wallet we created, which will store it.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: You should see a file called *admin.id* in the *wallet* subdirectory. If you
    view it, you can see the data structure we just went over. This is it for the
    *enrollAdmin.js* application. Its purpose is to enroll the admin. To accomplish
    this, it requires a CA and a wallet. The CA comes from *fabric-ca-client*, and
    the wallet comes from *fabric-network*. This sequence is specific to the admin.
    Now let’s look at *registerUser.js* and see what’s different.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Register our application user
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The beginning of *registerUser.js* contains the same imports as *enrollAdmin.js*,
    but in a different order, which does not matter. Like *enrollAdmin.js,* its logic
    is contained in a `main` function. The `main` logic starts off as in *enrollAdmin.js,*
    loading the network configuration, creating the certificate authority, and creating
    a wallet. We can see a pattern:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: Load the network configuration.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create the certificate authority.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create the wallet.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'What then follows is a check to determine whether the user has an identity
    in the wallet, which indicates the user is already registered and enrolled:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We return if the user is already in the wallet. This will happen if you execute
    *startFabric.sh* and the *wallet* subdirectory contains these identities. At this
    point, these identities do not exist in the Fabcar test network. The Fabcar application
    is not designed for multiple enrollments by a user. When this happens, you need
    to delete the contents of the *wallet* subdirectory and try the client again.
    The *wallet* subdirectory is then checked for the `admin` identity, which should
    exist because we always execute *enrollAdmin.js* first. If the `admin` is not
    found*,* we return. At this point in the code, *registerUser.js* and *enrollAdmin.js*
    differ. They differ because building the identity for the user differs from building
    the admin identity.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: 'To build the user identity, we begin by using *wallet* to get a `provider`
    of the `x509` type and use it to create a `User` object from the `admin` identity.
    We will use this identity to authenticate to the CA when we register our application
    user:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Next we register our application user with the CA, providing our organization,
    our ID, and our role. We supply the `admin` user we created with the `x509 provider`.
    The CA registers our application user and returns an enrollment secret:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: From this point on, the logic is the same as in *enrollAdmin.js,,* except *enrollAdmin.js*
    used the admin password for the enrollment secret, and *registerUser.js* will
    use the secret we got back from the CA when we registered using the admin user
    to authenticate to the certificate authority. Therefore, we need the admin identity
    because it is used to register users. The application user secret is like a password,
    except the user will not know it and does not care to know. They have an identity,
    which in this implementation is type `x509`, and it is stored in the wallet, which
    is a filesystem-based store. We are now ready to execute *invoke.js* and then
    *query.js* and compare the two.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Invoke a write transaction
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The *invoke.js* application has a main function, and all logic is contained
    within the main function. The application imports from only *fabric-network*:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This means it requires no interaction with the CA to invoke transactions. Like
    *enrollAdmin.js* and *registerUser.js,* it too makes use of *Wallets* from *fabric-network*.
    This makes sense because we need an identity to submit requests to the network,
    and identities for a client are stored in a *wallet*.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-256
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A user can have several identities, each with a unique name and purpose, like
    a driver’s license, school ID, passport, and so forth.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: The `Gateway` from *fabric-network* is our means to connect to the network,
    as we will see shortly.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: 'The logic begins with familiar-looking code we saw in *enrollAdmin.js* and
    *registerUser.js* to load the network configuration, which contains the information
    for connecting to the network, creating the wallet, and checking for an identity.
    We are seeing boilerplate code here that cross-cuts applications and is something
    we would want to pull out and place in common code:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We need the user identity to exist so the gateway can find it, if it does not
    we return. To connect to the network, we use the `Gateway` we imported from *fabric-network*
    to create a `gateway` object and use it to connect. The arguments we pass to the
    `connect` function are the connection information, the wallet, the name of the
    identity to use, and some discovery options used to locate peers:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'After connecting, we use the gateway to get the network, which is our channel
    identified by our channel name:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'With the `network` object, we get a connection to our Fabcar smart contract:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Finally, we get to invoke our smart contract. We are performing a transaction
    that will change the ledger, so this is a write transaction, and we expect it
    to be committed. The `contract` API function we want to use is `submitTransaction`.
    This will call our `createCar` smart contract function with these arguments:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: As you can see, we invoke our smart contract indirectly through the `contract`
    API. This design pattern is powerful but also risky if mitigations are not implemented
    to prevent unwanted side effects from unexpected character or binary data. The
    best industry practices should be implemented to validate and protect data integrity.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end, the gateway is disconnected, and the application exits:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Now let’s execute *invoke.js:*
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'You should see the following result:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Did you notice the time to process and return? There is a large difference in
    the processing time to commit versus query, as we will see next when we execute
    *query.js* and return the results of our committed transaction, which created
    a new car.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: Query the world state
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s execute *query.js* and compare its logic to *invoke.js* to see any differences
    and commonalities between them:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'You should see the following result:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Can you find the car we created, `CAR12`? It’s the third one right after `CAR1`.
    Great, our `submitTransaction` was committed. If we looked in CouchDB, we would
    see this data in our world state database: *mychannel_fabcar*.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the code. The code is the same except for the contract API function
    called:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: For the query, we use `evaluateTransaction` because a query transaction is not
    committed to the ledger. A query does not follow the same processing path as a
    write transaction, which will use `submitTransaction`, so the transaction is processed
    for committing to the ledger.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: Did you notice the difference in processing speed compared to *invoke.js*? Queries
    are much faster and can get cached, making them even faster because they do not
    access the database. Writes are much longer and may never be committed. As a Fabric
    smart contract developer, you will need to design for this long latency and for
    no guarantee of being committed. In [Chapter 6](ch06.xhtml#testing_and_maintenance),
    we will look at how events can help with these operating constraints.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: We have executed the four applications that make up the Fabcar smart contract
    client. We saw the differences and common code they use. Each performs one application
    function, and has dependencies that determine the order they are executed. You
    learned we need to first enroll an application administrator, and then use the
    administrator to register and enroll application users. Once we have a user identity,
    we can submit transactions to commit data to the ledger and query the world state.
    These applications serve as good examples for solutions that are best implemented
    with a command-line application, like batch jobs or serverless commands.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to invoke a Fabric smart contract. We began
    with a review of the Hyperledger *fabric-samples*, Fabcar smart contract, and
    Fabric test network. This provided you with the background needed to understand
    the resources used for this chapter and the next.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: We then launched our Fabric test network and discussed the launch script and
    its output to gain an understanding of what it takes to stand up a Fabric network
    for developing Fabric smart contracts. Besides launching the test network, the
    script also deployed the Fabcar smart contract. We went through the steps used
    by the script to deploy a smart contract, which will help you to understand and
    perform the deployment task for your own smart contracts.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: Next, we executed each of the four Fabcar client’s Node.js command-line applications
    that together make up the Fabcar smart contract client. At the same time, we examined
    each Fabcar application’s code, noting the common code and differences in the
    applications, and their use of the Fabric SDK for Node.js. The Fabcar applications
    use the SDK to call the Fabric APIs for interacting with Fabric smart contracts,
    credential authorities, wallets, and invoking smart contracts.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will take these four applications and refactor them
    into Node.js modules we can import into a Node.js and Express.js web application
    called Fabcar UI. This application mirrors the functionality of the four command-line
    Fabcar applications, but with a UI. You’ll continue to learn more about the Fabric
    SDK for Node.js and the API available to Fabric smart contract developers.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
