- en: © The Editor(s) (if applicable) and The Author(s), under exclusive license to
    Springer Nature Switzerland AG 2020K. S. MohamedNew Frontiers in Cryptography[https://doi.org/10.1007/978-3-030-58996-7_4](https://doi.org/10.1007/978-3-030-58996-7_4)
  prefs: []
  type: TYPE_NORMAL
- en: '4. New Trends in Cryptography: Quantum, Blockchain, Lightweight, Chaotic, and
    DNA Cryptography'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Khaled Salah Mohamed^([1](#Aff2) )(1)A Siemens Business, Fremont, CA, USAKeywordsQuantum
    cryptographyDNA cryptographyLightweight cryptographyBlockchain cryptographyChaotic
    cryptographyBitcoinHardwarePRESENTFactorizationSmart contractIn this chapter,
    various trends in cryptographic approaches are surveyed and analyzed. Moreover,
    pros and cons of each approach are highlighted.
  prefs: []
  type: TYPE_NORMAL
- en: 4.1 DNA Cryptography
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'DNA cryptography is a promising and rapid emerging field in data security.
    DNA cryptography may bring forward a new hope for unbreakable algorithms. DNA
    cryptology combines cryptology and modern biotechnology. To encrypt using DNA,
    sender generates a DNA encoding table, and receiver generates another table through
    the same encoding technique and sends a clue to the sender to be able to generate
    it locally. The plaintext to be encoded is divided into two halves equally. If
    the plaintext is not even, we insert random padding. One half of the plaintext
    is converted into DNA sequence using sender-based table, and the other half of
    the plaintext is converted into DNA sequence using receiver-based table. DNA cryptography
    is a bio-inspired novel technique used for securing end to end communication,
    where DNA is used as an information carrier. DNA cryptography is assumed to be
    unbreakable algorithm [[23](#CR23)–[26](#CR26)]. The advantages of DNA computing
    over traditional computing are as follows [[27](#CR27)]:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Speed:* Conventional computers  have been known to perform approximately 10⁸
    instructions per second (MIPS). Combining DNA strands has been predicted to make
    computations equivalent to 10⁹.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Storage:* DNA stores memory at the rate of 1 bit/nm³, whereas conventional
    storage media can store 1 bit/10^(12) nm³.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Power Requirements:* DNA computing does not require power, while computation
    is taking place. The chemical reactions that create the building blocks of DNA
    take place without any external power source.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a nutshell, DNA computing has the characteristics of high parallelism, large
    storage capacity, and low-energy consumption [[33](#CR33)–[35](#CR35)]. DNA cryptography
    has a wide range of applications and can be implemented in various fields like
    mobile networks, cloud computing, IoT devices, real-time applications, the Internet,
    and multicast applications to secure plaintext messages, images, videos, servers,
    etc. [[36](#CR36), [37](#CR37)].
  prefs: []
  type: TYPE_NORMAL
- en: 4.1.1 Fundamentals of DNA Computing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: DNA means deoxyribonucleic acid formed using four basic nucleic acids, namely,
    adenine (A), cytosine (C), guanine (G), and thymine (T) as depicted in Fig. [4.1](#Fig1).
    The pairs as (A, T) and (C, G) complement each other. These alphabets can be easily
    assigned to binary values *(A-00, C-01, G-10, T-11*). By these encoding rules,
    there are 4! = 24 possible encoding methods. However, only eight coding combinations
    are suitable for the principle of complementarity. Because the binary numbers
    “0” and “1” are complementary, “00” and “11” and “01” and “10” are also complementary
    [[23](#CR23), [24](#CR24)].![../images/501530_1_En_4_Chapter/501530_1_En_4_Fig1_HTML.png](../images/501530_1_En_4_Chapter/501530_1_En_4_Fig1_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 4.1
  prefs: []
  type: TYPE_NORMAL
- en: Bases of DNA block
  prefs: []
  type: TYPE_NORMAL
- en: 4.1.2 DNA Cryptography Algorithm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'DNA encryption  can be performed through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Convert the plaintext message into an ASCII form and then convert it to 8 bits
    binary coded form (Fig. [4.2](#Fig2)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Represent the binary data in the DNA coded form (A-00, C-01, G-10, T-11): *convert
    encode binary information into DNA strands*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apply complementary rule to the sequence (A → C, C → G, G → T, T → A).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Convert it back to binary.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generate random key and convert it into DND strands then into binary format.
    The random key has to be a number between 1 and 256\. This random key determines
    the permutation of the four characters A, T, G, and C. For example, when the random
    key is 1, there is a table for the conversion of ASCII code to nucleotide sequences,
    and when it is 2, there is another table and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XORing the key with the data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![../images/501530_1_En_4_Chapter/501530_1_En_4_Fig2_HTML.png](../images/501530_1_En_4_Chapter/501530_1_En_4_Fig2_HTML.png)'
  prefs: []
  type: TYPE_IMG
- en: Fig. 4.2
  prefs: []
  type: TYPE_NORMAL
- en: ASCII symbols and their corresponding DNA sequence
  prefs: []
  type: TYPE_NORMAL
- en: DNA decryption  is the reverse operation of DNA encryption. The total key space
    results is approximating to *10*^(*23*). With such huge key space, the reliability
    and effectiveness of the algorithm are established as the *key* associated is
    quite unpredictable and resistant against brute force attacks. Figure [4.3](#Fig3)
    shows the results of encryption of an image using DNA cryptography.![../images/501530_1_En_4_Chapter/501530_1_En_4_Fig3_HTML.jpg](../images/501530_1_En_4_Chapter/501530_1_En_4_Fig3_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 4.3
  prefs: []
  type: TYPE_NORMAL
- en: (**a**) unencrypted image, (**b**) DNA-based encrypted image
  prefs: []
  type: TYPE_NORMAL
- en: 4.2 Quantum Cryptography
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Quantum cryptography uses physics to develop a cryptosystem completely secure
    against being compromised without the knowledge of the sender or the receiver
    of the messages. The word *quantum*  itself refers to the most fundamental behavior
    of the smallest particles of matter and energy. In 1982, Richard Feynman came
    up with the idea of quantum computer, a computer that uses the effects of quantum
    mechanics to its advantage. In quantum cryptography, two remote parties can communicate
    securely by using the laws of quantum physics. Quantum cryptography is different
    from traditional cryptographic systems in that it relies more on physics, rather
    than mathematics, as a key aspectof its security model.
  prefs: []
  type: TYPE_NORMAL
- en: 4.2.1 Properties of Quantum Information
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Quantum cryptography rests on two pillars quantum mechanics [[28](#CR28)–[31](#CR31)]:'
  prefs: []
  type: TYPE_NORMAL
- en: '*The Heisenberg uncertainty principle*: it is not possible to measure the quantum
    state  of any system without disturbing that system. Thus, the polarization of
    a photon or light particle can only be known at the point when it is measured.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The photon polarization principle:* how light photons  can be oriented or
    polarized in specific directions. Moreover, a photon filter with the correct polarization
    can only detect a polarized photon or else the photon will be destroyed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quantum computer exploits a kind of massive parallelism that cannot be approached
    by any classical computer. So, it is faster [[17](#CR17)]. Quantum technology
    is a promising solution to overcome information security risks. Key distribution
    is one of the most important challenges of cryptography. Quantum cryptography
    can help in solving this problem. In quantum cryptography information is transmitted
    by quantum bit, also called qubit, which is actually a single photon particle.
  prefs: []
  type: TYPE_NORMAL
- en: The current methods for breaking RSA are not very effective. One method is to
    factor the N described by the public key. However, with the magnitude of the primes
    chosen, factoring takes near-infinite time with current methods and technologies
    (factoring time grows exponentially with input length in bits). In the present
    day, RSA cannot be broken. However, theoretically it is vulnerable, if a fast
    algorithm of semi-prime factoring was discovered. So, quantum computing is a threat
    for RSA encryption.
  prefs: []
  type: TYPE_NORMAL
- en: For years, quantum computers have just been research, theory, and proposals.
    D-Wave is one of the companies that are making quantum computers a reality.
  prefs: []
  type: TYPE_NORMAL
- en: 'A regular bit is a transistor that registers either a high or low voltage,
    which corresponds to 1 or 0, respectively. A quantum bit is a 2-state quantum.
    Many things can be used as qubits, such as a photon’s horizontal and vertical
    polarization or the spin up or spin down of an electron. Qubits also have very
    important properties [[38](#CR38)]:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Superposition*: this is where a qubit is, while left unobserved, all of its
    possible states. Once observed, it will collapse into one of the possible states.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Entanglement*: This is where one qubit’s state is linked to another. When
    entangled with each other, a change in one of the entangled qubits will change
    the other instantly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4.2.2 Quantum Algorithms
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The promise of quantum computing is that it will help us solve some of the world’s
    most complex challenges. Quantum systems will have capabilities that exceed our
    most powerful supercomputers. The two basic algorithms of quantum cryptography
    are Shor’s algorithm and the Grover’s algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 4.2.2.1 Grover’s Algorithm
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Grover’s algorithm  is a quantum algorithm that finds with high probability
    the unique input to a black box function that produces a particular output value.
  prefs: []
  type: TYPE_NORMAL
- en: 4.2.2.2 Shor’s Algorithm
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Shor’s algorithm  provides a dramatic improvement in the efficiency of factoring
    large numbers. Thus, Shor’s algorithm can be used to attack RSA encryption and
    related problems. It solves the following problem: Given an integer N, find its
    prime factors [[39](#CR39)].'
  prefs: []
  type: TYPE_NORMAL
- en: '4.2.2.3 Quantum Cryptography Algorithm: The BB84 Protocol'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The fundamental concept of quantum cryptography is sending secret key in the
    form of photons  through an insecure channel. Binary data (zero and one) is encoded
    to a quantum state based on physics theories. Quantum cryptography is also well-known
    as quantum key distribution (*QKD*)  . There are two channels in this system.
    The first channel is used to transmit the quantum secret key with a single photon.
    The second channel is a public channel like a telephone line or the Internet used
    to exchange cryptography protocols. The lasers, specifically diode lasers, in
    the area of QKD [[47](#CR47), [48](#CR48)].
  prefs: []
  type: TYPE_NORMAL
- en: The BB84 protocol  is the historical first protocol for quantum key, whose security
    is based on the principles of quantum mechanics, making it absolutely safe if
    there is no noise in the quantum channel. The absence of noise in a given situation
    assumes that the quantum state of particles does not change along the quantum
    channel. The BB84 protocol is formulated in the language of individual photons,
    although it can be applied to other realizations of a qubit.
  prefs: []
  type: TYPE_NORMAL
- en: The essence of the BB84 protocol  is that one of the users (Alice) randomly
    selects a series of bits and a series of bases and then sends a user (Bob) a string
    of photons each of which encodes one bit from the selected string in the base
    corresponding to the prime number of that bit. In obtaining a photon, Bob randomly
    selects the measurement base for each photon and, independently of Alice, analogously
    interprets the result of his measurement for each photon in two ways, as a zero
    or one. In accordance with the laws of quantum mechanics and following the measuring
    of the diagonal photon in a rectangular base, its polarization turns into the
    horizontal or vertical line and vice versa, with random results. In this way,
    Bob obtains the results coinciding with the state of the photons sent in about
    half the cases (50%), that is, when he correctly hits the base.
  prefs: []
  type: TYPE_NORMAL
- en: The next stage of the protocol is realized via a public channel, through which
    Alice and Bob can openly convey classical information to each other. At this stage,
    we assume that Eva can listen to the announcements by both parties, but she cannot
    change them or send notifications instead of them. To begin with, Alice and Bob
    determine (via a public channel) which photons were successfully obtained by Bob
    and which of them were measured in the correct base. After that, Alice and Bob
    have the same bit values encoded in these photons, regardless of the fact that
    this information has never been established in the open communication channel.
    In other words, each of these photons carries a bit of random information, which
    is known only to Alice and Bob and no one else. Information about the photons
    measured in the wrong base is rejected, so Alice and Bob get the so-called sieved
    key, which, in the event that Eva did not intercept the information, should be
    the same for both parties. Suppose Eva is eavesdropping on a quantum channel.
    Due to the random selection of a rectangular or diagonal base, Eva influences
    the information in such a way that it changes the bits of the sieved key, which
    would have to be the same for Alice and Bob if there was no Eve [[49](#CR49)].
  prefs: []
  type: TYPE_NORMAL
- en: 4.2.3 Quantum Cryptography Challenges
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we compare post-quantum cryptography with the currently used asymmetric
    algorithms, we find that post-quantum cryptography mostly have larger key and
    signature sizes and require more operations and memory. Still, they are very practical
    for everything except perhaps very constrained Internet of Things devices and
    radio. Some other challenges are summarized below:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Expensive: need specialized hardware.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Complex.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Difficult to implement over long distance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Subjected to decoherence. Qubits can retain their quantum state for a short
    period of time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quantum algorithms are mainly probabilistic. This means that in one operation,
    a quantum computer returns many solutions where only one is the correct.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4.3 Chaotic Cryptography
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Embedded systems are the driving force for most technological development in
    many domains such as automotive and healthcare. An example of embedded system
    architecture is shown in Fig. [4.4](#Fig4).![../images/501530_1_En_4_Chapter/501530_1_En_4_Fig4_HTML.png](../images/501530_1_En_4_Chapter/501530_1_En_4_Fig4_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 4.4
  prefs: []
  type: TYPE_NORMAL
- en: Example of embedded system architecture
  prefs: []
  type: TYPE_NORMAL
- en: Almost 10% of all embedded system products are counterfeit which leads to huge
    revenue loss. Several attacks methods have been developed, which made it possible
    to learn the ROM-based keys. Protecting soft IPs is much more challenging because
    it can be easily copied and even be sold at lower levels of abstraction [[11](#CR11)].
    Types of attacks on the hardware/software level can be classified into virus/worms,
    reverse engineering, fault injection, memory modification (Trojan insertion, bus
    modification, side channel, and bus probing).
  prefs: []
  type: TYPE_NORMAL
- en: Many strong ciphers  have been applied widely, such as DES, AES, and RSA. But
    most of them cannot be directly used to encrypt real-time embedded systems because
    their encryption speed is not fast enough and they are computationally intensive.
    So, in this work we present a fast chaotic-based encryption algorithm which is
    suitable for real-time embedded systems in terms of performance, area, and power
    efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: 4.3.1 Chaotic Theory
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'All systems can be basically divided into three types [[42](#CR42)]:'
  prefs: []
  type: TYPE_NORMAL
- en: '1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Deterministic systems: these are systems for which for a given set of conditions
    the result can be predicted and the output does not vary much with change in initial
    conditions. Examples are computers.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Stochastic/random systems: these systems, which are not as reliable as deterministic
    systems. Their output can be predicted only for a certain range of values. Examples
    are genetic algorithms.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '3.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Chaotic systems: these systems are the most unpredictable of the three systems.
    Moreover they are very sensitive to initial conditions, and a small change in
    initial conditions can bring about a great change in its output. Examples of chaotic
    systems are the solar system, population growth, stock market, and weather.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Chaos is derived from the Greek word “Xαos,” which is meaning a state without
    predictability or order. A chaotic system is a nonlinear, dynamical, and deterministic
    system which has high sensitive to initial conditions of the system. Chaos system
    is deterministic system with small change in input results in enormous change
    in the output, so the system looks as if it is random and prediction becomes impossible
    (it looks like a noise). It is like butterfly effect. Due to these properties,
    chaos theory has been used in cryptography/encryption. In this work, chaotic theory
    is used for providing security at HW level.
  prefs: []
  type: TYPE_NORMAL
- en: 4.3.2 Chaotic Encryption System
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The proposed chaotic-based encryption is taken from chaotic interleaving in
    communication [[12](#CR12)–[14](#CR14)]. Here, we proposed to use the algorithm
    for IP protection in embedded systems. Chaotic encryption of an *N* × *N* square
    matrix of data can be summarized as follows
  prefs: []
  type: TYPE_NORMAL
- en: '1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An *N* × *N* square matrix is divided into k vertical rectangles of height *N*
    and width *n*[*i*] such that *n*[1] + *n*[2] + … + *n*[*k*] = *N*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These vertical rectangles are stretched in the horizontal direction and contracted
    vertically to obtain *n*[*i*] × *N* horizontal rectangle.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '3.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These rectangles are stacked such as the left one is put at the bottom and the
    right one at the top.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '4.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each vertical rectangle *n*[*i*] × *N* is divided into n[i] boxes of dimensions
    ![$$ \frac{N}{n_i}\times {n}_i $$](../images/501530_1_En_4_Chapter/501530_1_En_4_Chapter_TeX_IEq1.png)
    containing exactly *N* points.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '5.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each of these boxes is mapped column by column into a row of data items. Inside
    each rectangle, the scan begins from the bottom left corner toward upper elements.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure [4.5](#Fig5) shows an example of chaotic encryption of an (8 × 8) square
    matrix. The secret key *S*[key](*n*[1], *n*[2], *n*[3]) = (2, 4, 2). The security
    abstraction levels are shown in Table [4.1](#Tab1). The proposed algorithm is
    working at the algorithm level.![../images/501530_1_En_4_Chapter/501530_1_En_4_Fig5_HTML.png](../images/501530_1_En_4_Chapter/501530_1_En_4_Fig5_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 4.5
  prefs: []
  type: TYPE_NORMAL
- en: An illustrating example of the proposed chaotic map. (**a**) Raw data 8 bits
    × 8bits, (**b**) the chaotic map creation 2 × 4 × 2, (**c**) the encrypted matrix
  prefs: []
  type: TYPE_NORMAL
- en: Table 4.1
  prefs: []
  type: TYPE_NORMAL
- en: The security abstraction levels
  prefs: []
  type: TYPE_NORMAL
- en: '| Security abstraction level | Security objective | Side channel attack |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Protocol | Authenticated communications | Main-in-the-middle, traffic analysis
    |'
  prefs: []
  type: TYPE_TB
- en: '| Algorithm | Encryption/hashing | Known-plaintext, known-cryptext |'
  prefs: []
  type: TYPE_TB
- en: '| Architecture | Functional integration | Stack smashing |'
  prefs: []
  type: TYPE_TB
- en: '| Micro-architecture | Architecture integration | Bus probing |'
  prefs: []
  type: TYPE_TB
- en: '| Circuit | Implementation | Differential power analysis |'
  prefs: []
  type: TYPE_TB
- en: To evaluate the resistance against security threats, security analysis of proposed
    encryption algorithm is done. The system proves to be efficient against different
    types of attacks. If the matrix size becomes 1024 × 8, then the total key space
    comes out to be sufficient to resist brute force attacks. Based on the proposed
    architecture, we can represent the key space as a series:![$$ {\mathrm{Key}}_{\mathrm{space}}=\left(n-1\right).\left(1+\sum
    \limits_{j=1}^{j=n-2}\sum \limits_{i=1}^{i={2}^{\left(n-j-1\right)}-1}\left({2}^{n-j}-2.j\right)\right)
    $$](../images/501530_1_En_4_Chapter/501530_1_En_4_Chapter_TeX_Equ1.png)(4.1)
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming the key size = 1024 = 2^(10) (*n* = 10), so: key[space] ≅ 1.575 M.'
  prefs: []
  type: TYPE_NORMAL
- en: 4.3.3 Hardware Implementation of Chaotic Algorithm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, the proposed algorithm is implemented in MATLAB for performance evaluation
    against conventional encryption methods. Then it is implemented using Verilog.
    The key can be hardwired. Chaotic encryption  is a symmetric encryption scheme,
    since it uses same parameters/MAP for encryption and decryption process. Block
    diagram of the proposed encryption algorithm is shown in Fig. [4.6](#Fig6). The
    proposed encryption architecture consists of four sub-modules:'
  prefs: []
  type: TYPE_NORMAL
- en: 'FIFO: to store the incoming data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Vector to matrix: as Verilog does not accept 2D matrix as an input or output
    port (Fig. [4.7](#Fig7)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Reshape: applying the chaotic map.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Matrix to vector: convert matrix to vector.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![../images/501530_1_En_4_Chapter/501530_1_En_4_Fig6_HTML.png](../images/501530_1_En_4_Chapter/501530_1_En_4_Fig6_HTML.png)'
  prefs: []
  type: TYPE_IMG
- en: Fig. 4.6
  prefs: []
  type: TYPE_NORMAL
- en: Block diagram of the proposed encryption algorithm
  prefs: []
  type: TYPE_NORMAL
- en: '![../images/501530_1_En_4_Chapter/501530_1_En_4_Fig7_HTML.png](../images/501530_1_En_4_Chapter/501530_1_En_4_Fig7_HTML.png)'
  prefs: []
  type: TYPE_IMG
- en: Fig. 4.7
  prefs: []
  type: TYPE_NORMAL
- en: Vector to matrix block diagram as Verilog does not accept 2D matrix as an input
    or output port
  prefs: []
  type: TYPE_NORMAL
- en: The decryption process is the inverse operation. The architecture of the decryption
    process is shown in Fig. [4.8](#Fig8).![../images/501530_1_En_4_Chapter/501530_1_En_4_Fig8_HTML.png](../images/501530_1_En_4_Chapter/501530_1_En_4_Fig8_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 4.8
  prefs: []
  type: TYPE_NORMAL
- en: Block diagram of the proposed decryption algorithm
  prefs: []
  type: TYPE_NORMAL
- en: 'It consists of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'FIFO: to store the incoming data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Vector to Matrix: as Verilog does not accept 2D matrix as an input or output
    port.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Reshape: applying the chaotic map.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Matrix to vector: convert matrix to vector.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4.3.4 Evaluation of the Proposed Algorithm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We synthesized the design over a Xilinx Virtex-6 FPGA as depicted in Fig. [4.9](#Fig9).
    A direct implementation of the design gave a clock frequency of 400 MHz. The throughput
    is 3.2 Gbps. Compared to conventional encryption methods, the performance of our
    proposed method is better. A snapshot of the simulation results is shown in Fig.
    [4.10](#Fig10) where a back-to-back configuration of the encryption/decryption
    modules is used to ensure that the decrypted data is the same as the plain data.
    There is a trade-off between the area/latency/power overhead and the provided
    level of security. Our proposed algorithm provides a good level of security with
    low area/power/latency overhead. The area is about 5% of AES area. The power consumption
    is less than AES. The comparison between our proposed algorithm and AES in terms
    of decryption time for different file sizes is shown in Table [4.2](#Tab2), where
    our proposed algorithm shows better and fast performance. Moreover, area, delay,
    and power overhead for our proposed encryption method are shown in Tables [4.3](#Tab3)
    and [4.4](#Tab4). The resources used by the encryptor including the total number
    of lookup tables (LUTs), slice registers, and digital signal processing blocks
    (DSPs), as well as the throughput obtained, are shown in Table [4.5](#Tab5).![../images/501530_1_En_4_Chapter/501530_1_En_4_Fig9_HTML.jpg](../images/501530_1_En_4_Chapter/501530_1_En_4_Fig9_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 4.9
  prefs: []
  type: TYPE_NORMAL
- en: FPGA evaluation board used to perform the proposed algorithm implementation
  prefs: []
  type: TYPE_NORMAL
- en: '![../images/501530_1_En_4_Chapter/501530_1_En_4_Fig10_HTML.png](../images/501530_1_En_4_Chapter/501530_1_En_4_Fig10_HTML.png)'
  prefs: []
  type: TYPE_IMG
- en: Fig. 4.10
  prefs: []
  type: TYPE_NORMAL
- en: Simulation results for a back-to-back configuration of the encryption/decryption
    modules
  prefs: []
  type: TYPE_NORMAL
- en: Table 4.2
  prefs: []
  type: TYPE_NORMAL
- en: Comparison between our proposed algorithm and AES
  prefs: []
  type: TYPE_NORMAL
- en: '| File (KB) | Decryption time (m Sec) |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Our proposed chaotic encryption | AES |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1.5 | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 2.8 | 6 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | 4.7 | 9 |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | 6 | 12 |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | 7.7 | 15 |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | 9.1 | 18 |'
  prefs: []
  type: TYPE_TB
- en: Table 4.3
  prefs: []
  type: TYPE_NORMAL
- en: Area, delay, and power overhead for our proposed encryption method
  prefs: []
  type: TYPE_NORMAL
- en: '| Our proposed chaotic encryption | AES |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Area | Delay (ns) | Power (nW) | Area | Delay (ns) | Power (nW) |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 5% | 0.1 | 0.3 | 40% | 0.4 | 2.6 |'
  prefs: []
  type: TYPE_TB
- en: Table 4.4
  prefs: []
  type: TYPE_NORMAL
- en: Area, delay, and power overhead for our proposed encryption method
  prefs: []
  type: TYPE_NORMAL
- en: '| Platform | Virtex 7 |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| LUTs | 600 |'
  prefs: []
  type: TYPE_TB
- en: '| Registers | 54 |'
  prefs: []
  type: TYPE_TB
- en: '| Total DSPs | – |'
  prefs: []
  type: TYPE_TB
- en: '| Freq (MHz) | 400 |'
  prefs: []
  type: TYPE_TB
- en: '| Throughput (Gbps) | 3.2 |'
  prefs: []
  type: TYPE_TB
- en: '| Slices | 180 |'
  prefs: []
  type: TYPE_TB
- en: Table 4.5
  prefs: []
  type: TYPE_NORMAL
- en: Comparison with related work
  prefs: []
  type: TYPE_NORMAL
- en: '| Metric | [1] | [2] | [3] | This work |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Latency (clock cycles) | 33 | 133 | 295 | 21 |'
  prefs: []
  type: TYPE_TB
- en: '| Max Freq (MHz) | 306 | 375 | 236 | 400 |'
  prefs: []
  type: TYPE_TB
- en: '| Throughput (Mbps) | 595 | 180 | 50 | 600 |'
  prefs: []
  type: TYPE_TB
- en: '| FPGA slices (Vertex 7) | 112 | 124 | 62 | 40 |'
  prefs: []
  type: TYPE_TB
- en: '| Power (mW) | – | 245 | – | 210 |'
  prefs: []
  type: TYPE_TB
- en: 4.4 Lightweight Cryptography
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Lightweight cryptography works between the trade-offs of security, cost, and
    performance and is focused at devices and systems on edge. The increase in Internet-connected
    devices requires to build smarter systems that are secure using low-cost hardware
    solutions. The symmetric and asymmetric ciphers are essentially a major topic
    of study in hardware cryptography, each having a different set of applications.
    Hardware for asymmetric ciphers are more complex than symmetric ones and consume
    more area on chip and power. For example, in terms of computational complexity,
    symmetric cipher such as AES algorithm is about 1000 much faster than an optimized
    elliptic curve cryptography that is an asymmetric algorithm. The Internet of Things
    (IoT)  is one of the most promising research topics in the engineering field.
    IoT is believed to facilitate the way people live in the near future by distantly
    connecting objects with each other and establishing communication channels between
    them. According to Cisco’s Internet of Things Group (IoTG), the number of connected
    devices is expected to reach 50 billion by 2020\. IoT has much potential to revolutionize
    the industry and everyday life in the near future, but some challenges hinder
    its advancements such as power consumption and security issues. Without sufficient
    security and privacy, all the benefits of IoT could prove disadvantageous if misused.
    Different algorithms have been presented in the literature that meets security
    requirements. Most of the studies have focused on popular algorithms such as AES,
    Rijndael, DES, Twofish, RSA, and more. However, IoT low area and power requirements
    make these algorithms unsuitable [[22](#CR22)]. So, more IoT-oriented algorithms
    have been presented to provide better performance in terms of power and area;
    those are known as lightweight cryptographic algorithms such as PRESENT, RECTANGLE,
    SIT, HIGHT, CLEFIA, SPECK, SIMON, and KHUDRA algorithm [[1](#CR1)–[10](#CR10)].
  prefs: []
  type: TYPE_NORMAL
- en: 4.4.1 PRESENT Algorithm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'PRESENT  is an ultralow power encryption algorithm that is based on substitution
    permutation (SP) network. PRESENT has a 64 bit input plaintext and either 80 bit
    or 128 bit key. PRESENT was standardized by NIST in 2012, which provide the algorithm
    more credibility in its use [[46](#CR46)]. PRESENT is a 31-round operation in
    which an XOR operation is introduced with round Key Ki. It consists of linear
    transformation called permutation (Fig. [4.11](#Fig11)) and nonlinear transformation
    called substitution (Fig. [4.12](#Fig12)). The substitution and permutation are
    performed once every round. A new key is generated for each round. Decryption
    is the inverse of the encryption process [[18](#CR18)]. Pseudo-code for PRESENT
    algorithm is shown in Fig. [4.13](#Fig13). To test the proposed encryption/decryption
    algorithm, we connect them back to back (Fig. [4.14](#Fig14)). The power consumption
    is about 210 mW which is less power than the related work. Moreover, the overall
    area is less than the related work. For encryption (Fig. [4.15](#Fig15)), there
    are four main blocks for the PRESENT: AddRoundKey  , S-box, P-layer, and key schedule.
    They are working in the following manner [[51](#CR51), [52](#CR52)].'
  prefs: []
  type: TYPE_NORMAL
- en: 'Step1: plaintext and the key are stored in a register.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Step2: the plaintext is XORed with the key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Step3: a substitutional step is done to provide the confusion needed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Step4: the data is permuted and stored in the register and the counter is increased
    by 1 and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![../images/501530_1_En_4_Chapter/501530_1_En_4_Fig11_HTML.png](../images/501530_1_En_4_Chapter/501530_1_En_4_Fig11_HTML.png)'
  prefs: []
  type: TYPE_IMG
- en: Fig. 4.11
  prefs: []
  type: TYPE_NORMAL
- en: Permutation
  prefs: []
  type: TYPE_NORMAL
- en: '![../images/501530_1_En_4_Chapter/501530_1_En_4_Fig12_HTML.png](../images/501530_1_En_4_Chapter/501530_1_En_4_Fig12_HTML.png)'
  prefs: []
  type: TYPE_IMG
- en: Fig. 4.12
  prefs: []
  type: TYPE_NORMAL
- en: Substitution
  prefs: []
  type: TYPE_NORMAL
- en: '![../images/501530_1_En_4_Chapter/501530_1_En_4_Fig13_HTML.png](../images/501530_1_En_4_Chapter/501530_1_En_4_Fig13_HTML.png)'
  prefs: []
  type: TYPE_IMG
- en: Fig. 4.13
  prefs: []
  type: TYPE_NORMAL
- en: Pseudo-code for PRESENT algorithm
  prefs: []
  type: TYPE_NORMAL
- en: '![../images/501530_1_En_4_Chapter/501530_1_En_4_Fig14_HTML.png](../images/501530_1_En_4_Chapter/501530_1_En_4_Fig14_HTML.png)'
  prefs: []
  type: TYPE_IMG
- en: Fig. 4.14
  prefs: []
  type: TYPE_NORMAL
- en: Back-to-back configuration
  prefs: []
  type: TYPE_NORMAL
- en: '![../images/501530_1_En_4_Chapter/501530_1_En_4_Fig15_HTML.png](../images/501530_1_En_4_Chapter/501530_1_En_4_Fig15_HTML.png)'
  prefs: []
  type: TYPE_IMG
- en: Fig. 4.15
  prefs: []
  type: TYPE_NORMAL
- en: PRESENT encryption core
  prefs: []
  type: TYPE_NORMAL
- en: For the decryption core (Fig. [4.16](#Fig16)), the overall steps are similar
    to the ones explained in the case of encryption  but with some key differences.
  prefs: []
  type: TYPE_NORMAL
- en: The s-box, permutation, and key scheduling units are replaced with their inverse
    modules.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The inverse permutation layer is carried out before the inverse s-box layer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![../images/501530_1_En_4_Chapter/501530_1_En_4_Fig16_HTML.png](../images/501530_1_En_4_Chapter/501530_1_En_4_Fig16_HTML.png)'
  prefs: []
  type: TYPE_IMG
- en: Fig. 4.16
  prefs: []
  type: TYPE_NORMAL
- en: PRESENT decryption core
  prefs: []
  type: TYPE_NORMAL
- en: 4.4.2 SIT Algorithm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SIT  is a symmetric key block cipher that constitutes of 64 bit key and plaintext.
    In symmetric key algorithm, the encryption process consists of encryption rounds;
    each round is based on some mathematical functions to create confusion and diffusion.
    Increase in number of rounds ensures better security but eventually results in
    increase in the consumption of constrained energy [[21](#CR21)]. The cryptographic
    algorithms are usually designed to take on an average 10 to 20 rounds to keep
    the encryption process strong enough that suits the requirement of the system.
    However the proposed algorithm is restricted to just five rounds only; to further
    improve the energy efficiency, each encryption round includes mathematical operations
    that operate on 4 bits of data. To create sufficient confusion and diffusion of
    data in order to confront the attacks, the algorithm utilizes the Feistel network
    of substitution diffusion functions [[15](#CR15)].
  prefs: []
  type: TYPE_NORMAL
- en: 4.4.3 HIGHT Algorithm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: High security lightweight (HIGHT) algorithm  is based on Feistel network structure
    instead of SPN. HIGHT operates on a 64 bit block size with 128 bit key size. The
    algorithm is comprised of 32 rounds, each is based on basic operations such as
    XOR and addition mod 28 [[19](#CR19)].
  prefs: []
  type: TYPE_NORMAL
- en: 4.4.4 KHUDRA Algorithm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: KHUDRA  is an FPGA-oriented lightweight algorithm. It’s optimized for balancing
    LUTs and registers to minimize the FPGA slices. The algorithm is based on recursive
    Feistel [[20](#CR20)].
  prefs: []
  type: TYPE_NORMAL
- en: 4.4.5 CAMELLIA Algorithm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is somehow similar to the standard AES, as it’s a symmetric key block cipher
    with a fixed block size of 128 bits and three different key sizes of 128, 192,
    and 256 bits. Unlike other algorithms that focus on hardware implementation, CAMELLIA  was
    designed for both software and hardware. It can be used for both low-cost and
    high-speed applications [[40](#CR40)].
  prefs: []
  type: TYPE_NORMAL
- en: 4.4.6 Attribute-Based Encryption (ABE)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: ABE  is a type of encryption that provides the IoT network with privacy and
    security through a policy between the attributes of the users in the system. ABE
    consists of two types, key policy ABE (KP-ABE) and ciphertext policy ABE (CP-ABE).
    In CP-ABE, the sender’s data access policy is embedded in the ciphertext, and
    a recipient’s attributes are associated with its private keys. A sender can decrypt
    the ciphertext only if the attributes associated with its private key satisfy
    the access policy embedded in the encrypted data [[44](#CR44), [45](#CR45)].
  prefs: []
  type: TYPE_NORMAL
- en: 4.5 Blockchain Cryptography
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Blockchain is a distributed database that allows direct transactions between
    two parties without the need for an authoritative mediator. Blockchain is a way
    to encapsulate transactions in the form of blocks where blocks are linked through
    the cryptographic hash, hence forming a chain of blocks (Fig. [4.17](#Fig17)).
    Blockchain is used for integrity as depicted in Fig. [4.18](#Fig18). Blockchain
    relies on different constituents which serve different purposes. The blockchain
    consists of a sequence of blocks that are stored on and copied between publicly
    accessible servers. Each block consists of four fundamental elements: the hash
    of the preceding block; the data content of the block (i.e., the ledger entries);
    the nonce that is used to give a particular form to the hash; and the hash of
    the block. By including the hash of the preceding block, each successive block
    strengthens the authenticity claim for the preceding block. Blocks early in the
    chain cannot be modified without modifying all subsequent blocks, or the modification
    will appear as an inconsistency in the hashes. Similarly, adding the data to the
    hash makes the data unmodifiable without breaking the consistency of the block
    sequence. Adding a nonce that is used to impose a signature structure to the hash
    requires significant work to be performed to generate a new block [[41](#CR41)].
    Assume an attacker is able to change the data present in the block n. Correspondingly,
    the hash of the block also changes. But, block *n* + 1 still contains the old
    hash of the block *n*. This makes block *n* + 1 and all succeeding blocks invalid
    as they do not have correct hash the previous block. Blockchain technology has
    become so popular due to the following advantages [[43](#CR43)]:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Resilience:* Blockchain is often replicated architecture. The chain is still
    operated by most nodes in the event of a massive attack against the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Time reduction:* In the financial industry, blockchain can play a vital role
    by allowing the quicker settlement of trades as it does not need a lengthy process
    of verification, settlement, and clearance because a single version of agreed-upon
    data of the share ledger is available between all stack holders.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Reliability:* Blockchain certifies and verifies the identities of the interested
    parties. This removes double records, reduces rates, and accelerates transactions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Unchangeable transactions:* By registering transactions in chronological order,
    blockchain certifies the unalterability of all operations which means when any
    new block has been added to the chain of ledgers, it cannot be removed or modified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Fraud prevention:* The concepts of shared information and consensus prevent
    possible losses due to fraud or embezzlement. In logistics-based industries, blockchain
    as a monitoring mechanism acts to reduce costs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Security:* Attacking a traditional database is the bringing down of a specific
    target. With the help of distributed ledger technology, each party holds a copy
    of the original chain, so the system remains operative, even the large number
    of other nodes fall.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Transparency:* Changes to public blockchain are publicly viewable to everyone.
    This offers greater transparency, and all transactions are immutable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Collaboration:* Allows parties to transact directly with each other without
    the need for mediating third parties.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Decentralized:* There are standard rules on how every node exchanges the blockchain
    information. This method ensures that all transactions are validated and all valid
    transactions are added one by one [[50](#CR50)].'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![../images/501530_1_En_4_Chapter/501530_1_En_4_Fig17_HTML.png](../images/501530_1_En_4_Chapter/501530_1_En_4_Fig17_HTML.png)'
  prefs: []
  type: TYPE_IMG
- en: Fig. 4.17
  prefs: []
  type: TYPE_NORMAL
- en: Basic blockchain structure. A block has a hash (fingerprint) which is unique
    to each block. It identifies a block and all of its contents, and it’s always
    unique. So once a block is created, any change inside the block will cause the
    hash to change
  prefs: []
  type: TYPE_NORMAL
- en: '![../images/501530_1_En_4_Chapter/501530_1_En_4_Fig18_HTML.png](../images/501530_1_En_4_Chapter/501530_1_En_4_Fig18_HTML.png)'
  prefs: []
  type: TYPE_IMG
- en: Fig. 4.18
  prefs: []
  type: TYPE_NORMAL
- en: 'Blockchain: integrity'
  prefs: []
  type: TYPE_NORMAL
- en: 4.5.1 Limitations of Blockchain Technology Can Be Summarized as Follows
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Higher costs:* Nodes seek higher rewards for completing transactions in a
    business which work on the principle of supply and demand.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Slower transactions:* Nodes prioritize transactions with higher rewards; backlogs
    of transactions build up.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Smaller ledger:* It is not possible to a full copy of the blockchain, potentially
    which can affect immutability, consensus, etc.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Transaction costs and network speed:* The transactions cost of Bitcoin is
    quite high after being touted as “nearly free” for the first few years.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Risk of error:* There is always a risk of error, as long as the human factor
    is involved. In case a blockchain serves as a database, all the incoming data
    has to be of high quality. However, human involvement can quickly resolve the
    error.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Wasteful:* Every node that runs the blockchain has to maintain consensus across
    the blockchain. This offers very low downtime and makes data stored on the blockchain
    forever unchangeable. However, all this is wasteful, because each node repeats
    a task to reach consensus.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4.5.2 Prime Number Factorization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The mathematical principle behind prime number factorization  is that any number,
    no matter how large, can be produced by multiplying prime numbers. It’s relatively
    easy to produce any number using prime numbers. However, it’s vastly more difficult
    to reverse the process and work out which prime numbers were multiplied to produce
    a particular value once the numbers become large. This reversal is called prime
    number factorization (Fig. [4.19](#Fig19)). *Blockchain cryptography relies on
    prime number* factorization for linking the public and private key. The prime
    number factors of the public key are what form the private key [[16](#CR16)].![../images/501530_1_En_4_Chapter/501530_1_En_4_Fig19_HTML.png](../images/501530_1_En_4_Chapter/501530_1_En_4_Fig19_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 4.19
  prefs: []
  type: TYPE_NORMAL
- en: Prime number factors example
  prefs: []
  type: TYPE_NORMAL
- en: 4.5.3 Applications of Blockchain Cryptography
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 4.5.3.1 Money Transfer
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Blockchain is a groundbreaking technology that optimizes the way money is transferred
    and transactions are processed. While it has been used in many fields since its
    introduction in 2009, blockchain technology is still most widely used in money
    transfers and transaction reconciliation.
  prefs: []
  type: TYPE_NORMAL
- en: 4.5.3.2 Smart Contract
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The new key concepts are smart contracts  , small computer programs that “live”
    in the blockchain. They are free computer programs that execute automatically
    and check conditions defined earlier like facilitation, verification, or enforcement.
    It is used as a replacement for traditional contracts.
  prefs: []
  type: TYPE_NORMAL
- en: 4.5.3.3 Safety of Food
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Food companies implement traceability because they see that the consumers require
    transparency and credibility. Blockchain’s immutability helps them to prove that
    the information the different supply chain companies provide is uncorrupted.
  prefs: []
  type: TYPE_NORMAL
- en: 4.5.3.4 Cryptocurrency
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Bitcoin  , the first decentralized cryptocurrency, has gained a large attention
    since its inception in 2009\. Built upon blockchain technology, it has established
    itself as the leader of cryptocurrencies and shows no signs of slowing down. Instead
    of being based on traditional trust, the currency is based on cryptographic proof
    which provides many advantages over traditional payment methods (such as Visa
    and Mastercard) including high liquidity and lower transaction costs [[32](#CR32)].
    The blockchain is the technology behind Bitcoin. Bitcoin  is the digital token,
    and blockchain is the ledger that keeps track of who owns the digital tokens.
    You can’t have Bitcoin without blockchain, but you can have blockchain without
    Bitcoin.
  prefs: []
  type: TYPE_NORMAL
- en: 4.6 Conclusions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter discusses the cutting-edge cryptographic techniques such as quantum
    cryptography, DNA cryptography, chaotic cryptography, lightweight cryptography,
    and blockchain cryptography. All these cryptography techniques are promising and
    rapid emerging fields in data security.
  prefs: []
  type: TYPE_NORMAL
