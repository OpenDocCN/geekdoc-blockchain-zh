© Bikramaditya Singhal, Gautam Dhameja, Priyansu Sekhar Panda 2018Bikramaditya Singhal, Gautam Dhameja 和 Priyansu Sekhar Panda 区块链入门`doi.org/10.1007/978-1-4842-3444-0_6`

# 6.构建以太坊 DApp

Bikramaditya Singhal^(1 ), Gautam Dhameja² 和 Priyansu Sekhar Panda¹(1)班加罗尔，卡纳塔克邦，印度(2)柏林，柏林，德国在上一章中，我们学习了如何使用 JavaScript 程序化地与比特币和以太坊区块链互动。我们还涉及了如何创建和部署以太坊智能合约的内容。在本章中，我们将通过学习如何开发和部署基于以太坊区块链的 DApp，将我们的区块链应用程序编程提升到下一个水平。在创建这个 DApp 的过程中，我们将建立一个私有以太坊网络，然后我们将使用这个网络作为我们 DApp 的基础区块链。这个 DApp 将包含其业务逻辑在以太坊智能合约中，并且这个逻辑将通过连接到私有以太坊网络的 Web 应用程序执行。这样，我们打算涵盖以太坊应用开发的所有方面——从设置节点和网络，到创建和部署智能合约，到使用客户端应用程序执行智能合约功能。

## DApp

在我们深入开发 DApp 之前，我们需要定义 DApp 的使用场景。我们还需要定义将是我们 DApp 一部分的各种组件。所以，让我们先做这件事。我们 DApp 的使用场景是一个投票应用程序，可以允许选民对在公共领域发布的投票进行投票。使用中心化系统进行投票并不是非常可靠，因为它暴露了一个数据腐败和失败的中心点。因此，我们 DApp 的目标是实现去中心化投票。这样，每个选民都掌握自己的选票，并且每个投票都在区块链上的每个节点上处理，所以没有办法篡改投票数据。虽然这可以通过使用公共以太坊区块链轻松完成，但为了使我们的练习更有趣，我们将把我们的投票 DApp 部署在私有以太坊网络上，为此我们也将设置这个私有网络。听起来有趣吗？让我们来做这件事。首先，我们将设置一个私有以太坊网络。然后，为了托管业务逻辑和投票结果，我们将创建一个智能合约，它将部署在这个私有以太坊网络上。为了与这个智能合约互动，我们将使用 web3 库创建一个前端 Web 应用程序。就是这样。根据刚刚描述的计划，我们的 DApp 开发练习将包括以下步骤：

1.  1.设置私有以太坊网络

1.  2.为投票功能创建智能合约

1.  3.将智能合约部署到私有网络

1.  4.创建一个前端 Web 应用程序与智能合约互动

在以下部分中，我们将详细查看所提到的每个步骤。注意如前所述，我们也可以使用公共以太坊网络进行这个 DApp 开发。此外，我们还可以使用许多工具，如 Metamask 和 Truffle 框架，以加快以太坊 DApp 的开发。这些工具以及其他工具使我们能够更好地管理我们的代码和部署。读者被鼓励探索这些和其他工具，以尝试找到创建舒适且富有成效的开发环境的最佳组合。本文主要让读者了解在创建以太坊 DApp 时幕后发生的事情，因此所有在 DApp 开发过程之上提供抽象的工具有意被排除在外。

## 设置私有以太坊网络

为了设置一个私有以太坊网络，我们需要其中的一个以太坊客户端。简单地说，以太坊客户端是一个实现以太坊区块链协议的应用程序。如今，互联网上有许多以太坊客户端可供选择；其中一个流行的是 go-ethereum，也被称为 geth。我们将使用 geth 来设置我们的私有网络。为此练习，我们使用运行 Ubuntu Linux 16.04 版本的虚拟机。

### 安装 go-ethereum（geth）

第一步是在我们本地机器上安装 geth。为了安装 geth，我们将从官方网站获取 geth 可执行安装程序[`geth.ethereum.org/downloads/`](https://geth.ethereum.org/downloads/)。这个官方网站下载页列出了所有主要平台（Windows，macOS，Linux）的安装器包。下载适用于您平台的安装程序包并在您的本地机器上安装 geth。如果您不想在本地机器上安装，也可以选择在远程（云托管）服务器/虚拟机上安装 geth。一旦在您的本地机器上成功安装了 geth，您可以通过在终端/命令提示符中运行以下命令来检查安装情况。geth version 根据您的平台操作系统和安装的 geth 版本，此命令应给出与以下类似的输出：GethVersion: 1.7.3-stableGit Commit: 4bb3c89d44e372e6a9ab85a8be0c9345265c763aArchitecture: amd64Protocol Versions: [63 62]Network Id: 1Go Version: go1.9Operating System: linuxGOPATH=GOROOT=/usr/lib/go-1.9

### 创建 geth 数据目录

默认情况下，geth 将有自己的工作目录，但我们将创建一个自定义的目录，以便我们可以轻松跟踪它。简单地创建一个目录并随时准备好这个目录的路径。mkdir mygeth

### 创建 geth 账户

我们首先需要一个可以持有以太币的以太坊账户。在 DApp 开发过程中，我们将需要这个账户来创建智能合约和交易。我们可以使用以下命令创建新账户。

### 创建 genesis.json 配置文件

在安装 geth 并创建新账户之后，下一步是定义我们私有网络的创世配置。正如我们在前几章所看到的，区块链有一个创世区块，它作为区块链的起点，所有交易和区块都要根据创世区块进行验证。对于我们私有网络，我们将有一个自定义的创世区块，因此也有一个自定义的创世配置。这个配置为区块链定义了一些关键值，比如难度级别，块的 gas 限制等。以太坊的创世配置如下所示，作为一个 JSON 对象。这个对象中每个键都是一个驱动网络的配置值。

### 运行私有网络的第一个节点

为了运行私有区块链的第一个节点，让我们首先复制上一步的 JSON，并将其保存为一个名为 genesis.json 的文件。为了简单起见，我们将这个文件保存在我们用作 geth 数据目录的同一个目录中。首先，我们需要用 genesis.json 初始化 geth。这个初始化是为了为我们的私有网络设置自定义创世配置。将 genesis.json 文件所在的目录更改为`cd mygeth`，然后运行以下命令将初始化 geth 与我们定义的自定义配置。`sudo geth --datadir "/mygeth" init genesis.json`geth 将在以下屏幕截图（图 6-2）中确认自定义创世配置设置。![A440588_1_En_6_Fig2_HTML.jpg](img/A440588_1_En_6_Fig2_HTML.jpg)图 6-2 使用 genesis.json 中的配置初始化 geth 接下来，我们需要使用以下命令和参数运行 geth。我们将详细查看这些参数中的每一个。`sudo geth --datadir "/mygeth" --networkid 8956 --ipcdisable --port 30307 --rpc --rpcapi "eth,web3,personal,net,miner,admin,debug" --rpcport 8507 --mine --minerthreads=1 --etherbase=0xbaf735f889d603f0ec6b1030c91d9033e60525c3`让我们看看我们给 geth 命令的每个参数。

+   `datadir`：这是为了指定数据目录，就像我们在前面的步骤中做的那样。

+   `networkid`：这是网络的标识符，它区分了我们的私有区块链与其他以太坊网络。这类似于我们在 genesis.json 文件中定义的 chainId，但提供了网络之间另一层区分。正如我们所看到，我们为这个值使用了另一个自定义数字。

+   `ipcdisable`：通过这个参数，我们禁用了 geth 的进程间通信端口，以便在同一台本地机器上运行多个 geth 实例（节点）时，我们不应该遇到任何冲突问题。

+   端口：我们为与 geth 交互选择了一个自定义值作为端口。

+   `rpc`、`--rpcapi`、`--rpcport`：这三个参数定义了 geth 暴露的 RPC API 配置。我们希望启用它；我们希望通过 RPC 暴露 geth 的 eth,web3,personal,net,miner,admin,debug API；并且我们想要在自定义端口 8507 上运行它。

+   `mine` – `minerthreads` – `etherbase`：通过这三个参数，我们指示 geth 将此节点作为矿工节点启动，将矿工进程线程限制为只有一个（这样我们就不会消耗太多的 CPU 功率），并将挖矿奖励发送到我们在第一步创建的以太坊账户。

至此，我们已经完成了运行私有网络中第一个 geth 节点的所有配置。当我们带上所有参数运行这个命令时，geth 将会给出以下输出（如图 6-3 所示的屏幕截图所示）。![A440588_1_En_6_Fig3_HTML.jpg](img/A440588_1_En_6_Fig3_HTML.jpg)图 6-3 运行第一个节点注意输出中的 UDP 监听器启动日志语句。INFO [02-11|18:00:57] UDP 监听器已启动 self=enode://e03b50e9b1b2579904f2bbdff7dd0826bd4e4eb2e225c1d1cb1a765195474d7418f3e8fbfeefd55bd85722973d17626f0e53208c62e38d1099bb583e702b3b48@[::]:30307 这包含了刚刚启动的节点的地址。为了将其他节点连接到这个节点，我们需要这个地址。请在某个地方记下它。下一行是从之前的日志语句中提取的地址。enode://e03b50e9b1b2579904f2bbdff7dd0826bd4e4eb2e225c1d1cb1a765195474d7418f3e8fbfeefd55bd85722973d17626f0e53208c62e38d1099bb583e702b3b48@[::]:30307 注意我们在命令中定义的端口号之前的[::]。如果我们在同一台机器上运行其他节点，用本地主机 IP 地址替换这个，否则用机器的外部 IP 地址替换。由于我们将在同一台机器上运行另一个网络节点（出于开发目的），我们用本地主机 IP 地址替换它。所以，第一个节点的最终地址将是 enode://e03b50e9b1b2579904f2bbdff7dd0826bd4e4eb2e225c1d1cb1a765195474d7418f3e8fbfeefd55bd85722973d17626f0e53208c62e38d1099bb583e702b3b48@127.0.0.1:30307

### 运行网络的第二节点

一个节点无法构成网络；至少需要两个节点。所以，我们在同一台机器上再运行一个 geth 实例，它将与我们刚才启动的节点交互，这两个节点将共同构成我们的以太坊私有网络。要运行另一个节点，首先我们需要另一个目录，它可以作为第二个节点的数据目录。让我们创建一个。`mkdir mygeth2`现在，我们也将用与第一个节点相同的 genesis.json 配置初始化这个节点。让我们创建这个 genesis.json 文件的另一个副本并保存在我们之前创建的新目录中。我们还需要切换到这个目录。现在，让我们为第二个节点初始化创世纪配置。`sudo geth --datadir "/mygeth2" init genesis.json`我们将会得到与第一个节点类似的输出。见下方的截图（图 6-4）。![A440588_1_En_6_Fig4_HTML.jpg](img/A440588_1_En_6_Fig4_HTML.jpg)图 6-4 为第二个节点初始化 Geth 配置现在，我们的第二个节点也已使用创世纪配置初始化。让我们运行它。为了运行第二个节点，我们将向 geth 命令传递几个不同的参数。这个第二个节点不会作为矿工运行，因此我们将跳过我们给第一个节点命令的最后三个参数。此外，我们希望在运行此节点时暴露 geth 控制台，因此我们将添加一个参数来实现这一点。运行第二个节点的命令将是`sudo geth --datadir "/mygeth2" --networkid 8956 --ipcdisable --port 30308 --rpc --rpcapi "eth,web3,personal,net,miner,admin,debug" --rpcport 8508 console`正如我们所见，数据目录和端口已为第二个节点更改。我们还为命令添加了控制台标志，以便我们可以为这个节点获取 geth 控制台。当我们运行这个命令时，第二个节点也将开始运行，我们将在终端中看到以下输出（图 6-5）。![A440588_1_En_6_Fig5_HTML.jpg](img/A440588_1_En_6_Fig5_HTML.jpg)图 6-5 运行 geth 第二个节点此时，我们的两个 geth 节点都在运行，但它们彼此不知道。如果我们运行第二个节点的 geth 控制台上的 admin.peers 命令，我们将得到一个空数组作为结果（图 6-6）。![A440588_1_En_6_Fig6_HTML.jpg](img/A440588_1_En_6_Fig6_HTML.jpg)图 6-6Geth 控制台—检查对等节点这意味着节点之间没有连接。让我们连接节点。为此，我们将在第二个节点的 geth 控制台上发送 admin.addPeer()命令，并以第一个节点的节点地址作为参数。记住我们运行它后记下了第一个节点的地址。让我们在第二个节点的 geth 控制台上运行这个命令。`admin.addPeer("enode://e03b50e9b1b2579904f2bbdff7dd0826bd4e4eb2e225c1d1cb1a765195474d7418f3e8fbfeefd55bd85722973d17626f0e53208c62e38d1099bb583e702b3b48@127.0.0.1:30307")`我们在第二个节点上运行这个命令后，它立刻返回了 true。另外，几秒钟后它开始与第一个节点同步。以下截图（图 6-7）显示了第二个节点的控制台输出。![A440588_1_En_6_Fig7_HTML.jpg](img/A440588_1_En_6_Fig7_HTML.jpg)图 6-7Geth 控制台—添加对等节点现在，我们的两个节点都已连接，我们的私有以太坊网络已建立。为了进一步验证这一点，我们将在第二个节点上再次运行 admin.peers 命令，这次我们将看到一个包含显示第一个节点为对等节点的对象在内的 JSON 数组（图 6-8）。![A440588_1_En

## 创建智能合约

这段 Solidity 代码不应被视为参考。Solidity 最佳实践的详细讨论超出了本文本的范围。对于 Solidity 最佳实践，我们建议遵循官方 Solidity 文档和 Solidity 特定的文本。

## 部署智能合约

在本节中，我们将把上一节中开发的智能合约部署到我们创建的私有以太坊网络中。部署智能合约的过程与我们在上一章中所做的相同。唯一的区别是，这次我们将部署到私有网络而不是公共网络。在本章中，我们也将使用相同的 web3.js 库来使用 JavaScript 进行以太坊编程。我们建议读者如果还没有这么做，就去阅读上一章。

### 设置 web3 库和连接

首先，我们将在 node.js 应用程序中安装 web3 库。这正是我们在上一章中所做的。这个 node.js 应用程序将用于部署智能合约。

### 将合约部署到私有网络

现在我们已经有了我们的智能合约及其详细信息，我们将准备一个带有此合约详细信息的 web3 合约对象，然后通过在合约对象上调用 deploy 方法将此合约部署到以太坊区块链上。我们需要创建一个 web3.eth.Contract 类的对象，该对象可以代表我们的合约。以下代码片段创建了一个合约实例，该实例的构造函数接收我们合约的 ABI 作为输入。

## 客户端应用程序

在上一章中，我们使用 web3 库来调用智能合约上的函数。但是，在上一次我们使用的是 node.js 应用程序，而不是浏览器应用程序。在本节中，我们将使用 web3 在浏览器应用程序中调用我们部署的智能合约的投票函数。

## -   总结

在本章中，我们编写了基于以太坊区块链开发去中心化应用的编程练习。我们还学习了如何搭建私有以太坊网络以及如何使用 DApp 与之交互。

## -   参考资料

web3.js 文档[`web3js.readthedocs.io/en/1.0/index.html`](http://web3js.readthedocs.io/en/1.0/index.html) .Solidity 文档[`solidity.readthedocs.org/`](https://solidity.readthedocs.org/) .以太坊私有网络教程[`github.com/ethereumproject/go-ethereum/wiki/Private-Networking-Tutorial`](https://github.com/ethereumproject/go-ethereum/wiki/Private-Networking-Tutorial) .
