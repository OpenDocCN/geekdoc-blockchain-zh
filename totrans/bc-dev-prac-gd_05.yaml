- en: © Elad Elrom 2019Elad ElromThe Blockchain Developer[https://doi.org/10.1007/978-1-4842-4847-8_5](https://doi.org/10.1007/978-1-4842-4847-8_5)
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: © Elad Elrom 2019Elad Elrom区块链开发者[https://doi.org/10.1007/978-1-4842-4847-8_5](https://doi.org/10.1007/978-1-4842-4847-8_5)
- en: 5. Ethereum Wallets and Smart Contracts
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5. 以太坊钱包和智能合约
- en: Elad Elrom^([1](#Aff2) )(1)New York, NY, USA
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Elad Elrom^([1](#Aff2) )(1)纽约，纽约，美国
- en: In Chapter [1](475651_1_En_1_Chapter.xhtml), I introduced Ethereum when I covered
    bitcoin, altcoins, and different consensus mechanisms. Specifically, I covered
    Ethereum’s PoW consensus and how utilizing Ethereum enables developers to create
    their own smart contracts and tokens. I mentioned that the Ethereum tokens can
    be generated as Ethereum requests for comment (ERCs) such as ERC-20, ERC-223,
    or ERC-777\. In Chapter [3](475651_1_En_3_Chapter.xhtml), you created your own
    blockchain, and I covered bitcoin wallets and transactions.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在第[1](475651_1_En_1_Chapter.xhtml)章中，当我介绍比特币、替代币和不同的共识机制时，我介绍了以太坊。具体来说，我涵盖了以太坊的PoW共识以及利用以太坊使开发者能够创建自己的智能合约和代币。我提到以太坊代币可以作为以太坊请求评论（ERCs）生成，如ERC-20、ERC-223或ERC-777。在第[3](475651_1_En_3_Chapter.xhtml)章中，你创建了自己的区块链，我介绍了比特币钱包和交易。
- en: 'In this chapter, I will be expanding on Ethereum in more detail. Ethereum allows
    you to create code (*smart contracts*) to handle funds utilizing blockchain technology
    to overcome downtime and third-party interference. The Ethereum platform is mostly
    credited to Vitalik Buterin and Gavin Wood. According to the Ethereum web site,
    the definition of Ethereum is as follows:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将详细扩展讲解以太坊。以太坊允许你编写代码（智能合约）来处理资金，利用区块链技术来克服停机和第三方干预的问题。以太坊平台主要归功于维塔利克·布特林和加文·伍德。根据以太坊网站的定义，以太坊的定义如下：
- en: '*“Ethereum is a decentralized platform that runs smart contracts: applications
    that run exactly as programmed without any possibility of downtime, censorship,
    fraud or third-party interference.”*'
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “以太坊是一个去中心化的平台，它运行智能合约：应用程序严格按照编程运行，没有任何停机、审查、欺诈或第三方干预的可能性。”
- en: ''
  id: totrans-6
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —Ethereum.org
  id: totrans-7
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: —Ethereum.org
- en: In previous chapters, you were able to pass and store data such as the bitcoin
    colored coins use case with the OP_RETURN param. This is useful because you’re
    able to generate an MD5 hash of a file and store it on bitcoin’s network. The
    MD5 you stored could be of a document, a contract, or anything you want. However,
    as you saw, bitcoin is limited to only storing the information, and you were unable
    to interact with the data. Specifically, you are able to pass and store data on
    the network, but you are unable to run code against your file such as to perform
    operations against your data. Ethereum solves this lack of functionality by allowing
    you to create a smart contract utilizing the power of blockchain.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，你能够传递和存储数据，如比特币彩色硬币使用案例中的OP_RETURN参数。这很有用，因为你能够生成一个文件的MD5散列值并将其存储在比特币网络上。你所存储的MD5可以是文件、合同或任何你想要的东西。然而，正如你所看到的，比特币只能存储信息，你无法与数据互动。具体来说，你能够在网络上传递和存储数据，但你无法针对你的文件运行代码，如对你的数据执行操作。以太坊通过允许你利用区块链的力量创建智能合约来解决这一功能缺失。
- en: Note
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Smart contracts are programmable code used to handle funds. The code runs on
    its own, absent of the need of third parties. Solidity is a popular Ethereum contact-oriented
    programming language and can be used to write smart contracts and deploy the code
    on multiple blockchains.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约是用于处理资金的可编程代码。该代码独立运行，无需第三方参与。Solidity是一种流行的以太坊合约编程语言，可以用来编写智能合约并将代码部署在多个区块链上。
- en: At the heart of Ethereum is the Ethereum Virtual Machine (EVM). The EVM is where
    the smart contracts run in Ethereum. A good way to help you understand the EVM
    is to think about the EVM as a distributed global computer where the smart contracts
    can be executed.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊的核心是以太坊虚拟机（EVM）。EVM是以太坊中智能合约运行的地方。帮助你理解EVM的一个好方法是想成一个分布式全球计算机，智能合约可以在其中执行。
- en: Note
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The EVM is a distributed global computer to run arbitrary, algorithmic, complex
    code. More simply, the EVM consists of all the nodes in the Ethereum network connected
    as a singular consensus and able to take a smart contract’s code, process it,
    and execute it. The EVM uses 256 bits as the fundamental consensus mechanism;
    it can handle a 1 TB block, and the standard block time is 15 seconds.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊虚拟机（EVM）是一个分布式全球计算机，用于运行任意的、算法的、复杂的代码。简单地说，EVM由以太坊网络中所有节点组成，这些节点通过单一共识连接，能够接收智能合约的代码，处理它并执行它。EVM使用256位作为基本共识机制；它可以处理1
    TB的区块，标准区块时间为15秒。
- en: Decentralized application developers write smart contracts and then run the
    code on the EVM with the help of front-end code. See Figure [5-1](#Fig1). The
    EVM executes the code in parallel connections on all the connected Ethereum nodes.
    This ensures the consensus of the nodes. The size of the Ethereum blockchain can
    be as big as 1 TB at the time of writing versus bitcoin’s block height, which
    is limited to 4 MB per block. Additionally, bitcoin takes about 10 minutes to
    create a new block versus 15 seconds on the EVM.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 去中心化应用开发者编写智能合约，然后借助前端代码在EVM上运行代码。见图[5-1](#Fig1)。EVM在所有连接的以太坊节点上并行连接中执行代码。这确保了节点的共识。以太坊区块链的大小可以高达1
    TB，而比特币的区块高度限制在每块4 MB。此外，比特币创建新区块大约需要10分钟，而EVM上只需要15秒。
- en: Although it is advantageous for the decentralized code to run as a singular
    consensus, there are also drawbacks. For instance, the smart contract’s code is
    slower and more expensive than a traditional computer as it runs on all nodes.![../images/475651_1_En_5_Chapter/475651_1_En_5_Fig1_HTML.jpg](../images/475651_1_En_5_Chapter/475651_1_En_5_Fig1_HTML.jpg)
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管让去中心化代码作为单一共识运行是有优势的，但也存在缺点。例如，智能合约的代码在所有节点上运行时比传统计算机更慢、更昂贵。![../images/475651_1_En_5_Chapter/475651_1_En_5_Fig1_HTML.jpg](../images/475651_1_En_5_Chapter/475651_1_En_5_Fig1_HTML.jpg)
- en: Figure 5-1
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-1
- en: 'Ethereum 10,000-foot perspective. Photo credit: xbt.net.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊10,000英尺视角。图片来源：xbt.net。
- en: To run an Ethereum miner, you need to run a full-node EVM. The miners are running
    a PoW consensus mechanism to verify transactions just like bitcoin. During the
    mining process, five coins are mined on every block. Just as you saw with NEO
    in Chapter [1](475651_1_En_1_Chapter.xhtml), the Ethereum miners get paid for
    running smart contracts with Ethereum coins, which get changed into what is called
    *gas*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行一个以太坊矿工，你需要运行一个完整的EVM节点。矿工们正在运行一种类似于比特币的工作量证明（PoW）共识机制来验证交易。在挖矿过程中，每个区块会挖出五枚硬币。正如你在第[1](475651_1_En_1_Chapter.xhtml)章中看到的，以太坊矿工通过运行智能合约并获得以太币来获得报酬，这些以太币会转化为所谓的*燃料*。
- en: Note
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Ethereum gas is a fraction of an Ethereum token. Ethereum gas is changed and
    used by the contract to pay the miner for their efforts. Think of a car. It needs
    gas to operate, and so does Ethereum. Absent Ethereum gas, you cannot execute
    the smart contract.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊燃料是以太坊代币的一个部分。以太坊燃料被合同使用，以支付矿工的努力。想象一辆车。它需要汽油来运行，以太坊也是。没有以太坊燃料，你不能执行智能合约。
- en: Because Ethereum offers the ability to build interesting applications, the platform
    has been acknowledged for its potential and is utilized in one way or another
    by Microsoft, Intel, Amazon, J.P. Morgan, and even governments. This has turned
    Ethereum into an extensive ecosystem with many options to choose from to help
    you create your smart contracts easily. You can choose from a large number of
    development tools, apps communicating with other tools, best practices, infrastructure,
    testing, security, monitoring tools, and much more.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 由于以太坊能够提供构建有趣应用的能力，该平台因其潜力而得到了认可，并被微软、英特尔、亚马逊、摩根大通，甚至政府以一种或另一种方式使用。这使得以太坊变成了一个广泛的选择众多的生态系统，帮助你轻松创建智能合约。你可以从大量的开发工具、与其他工具通信的应用程序、最佳实践、基础设施、测试、安全、监控工具等中进行选择。
- en: 'It can be overwhelming and confusing to choose tools to use, especially when
    many of the tools are still in alpha, beta, or not fully tested. However, keep
    in mind that by now you are already equipped with a good fundamental understanding
    of blockchain technologies, including transactions, wallets, and how it all works.
    Additionally, the blockchain you developed in Chapter [3](475651_1_En_3_Chapter.xhtml)
    was in JavaScript utilizing Node.js, which is fundamental for many Ethereum tools.
    There are two lists that I recommend you bookmark, listed here:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 选择使用工具可能会让人感到不知所措和困惑，尤其是当许多工具仍处于alpha、beta阶段或未完全测试时。然而，请记住，到现在为止，你已经具备了关于区块链技术，包括交易、钱包以及它们是如何工作的良好基础理解。此外，你在第[3](475651_1_En_3_Chapter.xhtml)章中开发的区块链是用JavaScript和Node.js实现的，这是许多以太坊工具的基础。我建议你收藏以下两个列表：
- en: '[https://github.com/ConsenSys/ethereum-developer-tools-list](https://github.com/ConsenSys/ethereum-developer-tools-list)'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/ConsenSys/ethereum-developer-tools-list](https://github.com/ConsenSys/ethereum-developer-tools-list)'
- en: '[https://github.com/ConsenSys/ethereum-developer-tools-list/blob/master/EcosystemResources.md](https://github.com/ConsenSys/ethereum-developer-tools-list/blob/master/EcosystemResources.md)'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/ConsenSys/ethereum-developer-tools-list/blob/master/EcosystemResources.md](https://github.com/ConsenSys/ethereum-developer-tools-list/blob/master/EcosystemResources.md)'
- en: These resources provide an extensive list of all the development tools and resources
    related to Ethereum. It’s beyond the scope of this book to cover all these different
    tools, but I recommend you review these tools at some point if you focus on Ethereum
    development so you can make your own determination about which tool fits your
    project best.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这些资源提供了所有与以太坊相关的开发工具和资源的一份详尽列表。鉴于本书的范围，不可能涵盖所有这些不同的工具，但我建议如果你专注于以太坊开发，在一定程度上要回顾这些工具，这样你就可以自行判断哪个工具最适合你的项目。
- en: In this chapter, I will be focusing on Ethereum smart contracts and running
    them on a testnet, just as you have done in the previous chapters for bitcoin.
    I will show how to set up your development tools and IDE and give you basic information
    for dapp mainnet deployment, which I will expand upon in later chapters in this
    book.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将重点介绍以太坊智能合约，并在测试网上运行它们，正如你在前一章中为比特币所做的那样。我将展示如何设置你的开发工具和IDE，并为你提供基本的dapp主网部署信息，我将在本书的后续章节中进一步扩展这些内容。
- en: Ganache Simulated Full-Node Client
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ganache模拟全节点客户端
- en: Ganache (previously known as ethereumjs-testrpc) allows you to run a simulated
    full-node client of Ethereum on your machine and to interact with your contract
    via a CLI. This tool is useful because you will be setting up a development network
    and a private testnet network to test your smart contract code.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Ganache（之前称为ethereumjs-testrpc）允许你在本地机器上运行一个模拟的以太坊全节点客户端，并通过CLI与你的合约进行交互。这个工具很有用，因为你将设置一个开发网络和一个私有的测试网网络，以测试你的智能合约代码。
- en: Just as you saw in the previous chapter, setting up a testnet network allows
    you to test your code with pretend money before committing your code to mainnet.
    I decided to use Ganache in this chapter as it is part of the Truffle development
    suite and integrates well with Truffle.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在前一章所看到的那样，设置测试网网络允许你在将代码提交到主网之前，使用虚拟货币测试你的代码。我决定在本章使用Ganache，因为它属于Truffle开发套件的一部分，并且与Truffle集成得很好。
- en: Install Ganache
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装Ganache
- en: 'To get started, you can install Ganache globally with npm and confirm it’s
    working correctly by calling the help command.> npm install -g ganache-cli> ganache-cli
    helpIf you have installation issues or want to get more information regarding
    the tool, visit the Ganache GitHub page: [https://github.com/trufflesuite/ganache-cli](https://github.com/trufflesuite/ganache-cli)
    . You can also check the version of CLI by running this command:> ganache-cli
    -v'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 开始使用时，你可以使用npm将Ganache全局安装，并通过调用帮助命令确认它是否正常工作。> npm install -g ganache-cli>
    ganache-cli help如果你遇到安装问题或想了解更多关于该工具的信息，请访问Ganache的GitHub页面：[https://github.com/trufflesuite/ganache-cli](https://github.com/trufflesuite/ganache-cli)。你还可以通过运行以下命令来检查CLI的版本：>
    ganache-cli -v
- en: 'This command outputs the version. At the time of writing, the Ganache CLI is
    version v6.4.3 (ganache-core: 2.5.5).'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '这个命令会输出版本信息。在撰写本文时，Ganache CLI的版本为v6.4.3（ganache-core: 2.5.5）。'
- en: 'Ganache CLI: Listen to Port'
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Ganache CLI：监听端口
- en: You can run Ganache on your machine while you develop and debug your contracts.
    To do this, you set up the Ganache CLI in Terminal to listen to the port you will
    be setting in truffle.js later in this chapter.> ganache-cli -p 8584Notice that
    at this point there is nothing running on port 8584, so let’s assume you will
    be setting up port 8584\. The command should output the following:Listening on
    127.0.0.1:8584
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在开发和调试合同时在您的机器上运行Ganache。为此，您需要在终端中设置Ganache CLI以监听稍后在本书中设置的truffle.js中的端口。>
    ganache-cli -p 8584请注意，此时8584端口上没有任何运行的东西，所以假设您将设置8584端口。命令应输出以下内容：监听127.0.0.1:8584
- en: IntelliJ IDEA Plugin for Solidity
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IntelliJ IDEA的Solidity插件
- en: 'In Chapter [3](475651_1_En_3_Chapter.xhtml), you downloaded and used WebStorm
    as your IDE to develop your blockchain. WebStorm is a subset of IntelliJ IDEA
    and has a plugin for the Solidity language, which provides an easy way to write
    your contracts. Also, it provides highlights and code completion to make development
    easier. You can use the WebStorm version you previously installed and just add
    the Solidity plugin. To do so, first download the plugin here: [https://plugins.jetbrains.com/plugin/9475-intellij-solidity](https://plugins.jetbrains.com/plugin/9475-intellij-solidity)
    .'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在第[3](475651_1_En_3_Chapter.xhtml)章中，您下载并使用WebStorm作为您的IDE来开发您的区块链。WebStorm是IntelliJ
    IDEA的一个子集，并且有一个Solidity语言插件，它提供了一种轻松编写您合约的方法。此外，它还提供高亮和代码补全，使开发更加容易。您可以使用之前安装的WebStorm版本，只需添加Solidity插件。为此，首先在此处下载插件：[https://plugins.jetbrains.com/plugin/9475-intellij-solidity](https://plugins.jetbrains.com/plugin/9475-intellij-solidity)
    。
- en: 'To get the plugin installed, follow these steps:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了安装插件，请按照以下步骤操作：
- en: '1.'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '1.'
- en: Select WebStorm ➤ Preferences (or press command + ,).
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 选择WebStorm➤首选项（或按命令+ ,）。
- en: '2.'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '2.'
- en: Select Plugins.
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 选择“插件”。
- en: '3.'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '3.'
- en: Search in “Plugins” for “*Solidity*”. It will say “No Plugins founds.” With
    a link to “Search in repositories”. Click the “Search in repositories” link. “Intellij-Solidity”
    plugin will show. See Figure [5-2](#Fig2).
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在“插件”中搜索“*Solidity*”。它会显示“没有找到插件”。有一个链接到“在仓库中搜索”。点击“在仓库中搜索”链接。“Intellij-Solidity”插件将显示。请参阅图[5-2](#Fig2)。
- en: '4.'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '4.'
- en: 'Install both “Intellij-Solidity” plugins: LANGUAGES and INSPECTION. See Figure
    [5-2](#Fig2).'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 安装“Intellij-Solidity”插件：语言和检查。请参阅图[5-2](#Fig2)。
- en: 5.Click IntelliJ-Solidity ➤ install. See Figure [5-2](#Fig2).![../images/475651_1_En_5_Chapter/475651_1_En_5_Fig2_HTML.jpg](../images/475651_1_En_5_Chapter/475651_1_En_5_Fig2_HTML.jpg)
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 5.点击IntelliJ-Solidity➤安装。请参阅图[5-2](#Fig2)。![../images/475651_1_En_5_Chapter/475651_1_En_5_Fig2_HTML.jpg](../images/475651_1_En_5_Chapter/475651_1_En_5_Fig2_HTML.jpg)
- en: Figure 5-2
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图5-2
- en: Installing IntelliJ-Solidity and Solidity Solhint in WebStorm
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在WebStorm中安装IntelliJ-Solidity和Solidity Solhint
- en: '6.'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '6.'
- en: Under Plugins search for Solidity Solhint. It will say “No Plugins founds.”
    With a link to “Search in repositories”. Click the “Search in repositories” link.
    Click Solidity Solhint INSPECTION ➤ and then click Install.
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在插件中搜索Solidity Solhint。它会显示“没有找到插件”。有一个链接到“在仓库中搜索”。点击“在仓库中搜索”链接。点击Solidity Solhint检查➤然后点击安装。
- en: '7.'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '7.'
- en: Restart WebStorm.
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重启WebStorm。
- en: Note that if you are a Visual Studio fan, there is also a Solidity extension
    for Visual Studio; see [https://marketplace.visualstudio.com/items?itemName=ConsenSys.Solidity](https://marketplace.visualstudio.com/items%253FitemName%253DConsenSys.Solidity)
    . At the time of writing, the plugin works only for Visual Studio 2015 or earlier.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果您是Visual Studio的粉丝，还有一个Solidity扩展适用于Visual Studio；请参阅[https://marketplace.visualstudio.com/items?itemName=ConsenSys.Solidity](https://marketplace.visualstudio.com/items%253FitemName%253DConsenSys.Solidity)。在撰写本文时，该插件仅适用于Visual
    Studio 2015或更早版本。
- en: Keep in mind that, as always, you can use your favorite IDE, text editor, or
    even vim to write your code; there’s no need to buy an IDE.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，像往常一样，您可以使用您喜欢的IDE，文本编辑器，甚至vim来编写您的代码；没有必要购买IDE。
- en: Truffle Suite
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Truffle套件
- en: You will be using Truffle as it’s one of the most popular tools and has integrated
    libraries that help expedite the development cycle. Truffle Suite includes Truffle,
    Ganache, and Drizzle; see Figure [5-3](#Fig3).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 您将使用Truffle，因为它是最受欢迎的工具之一，并且具有集成的库，可以帮助加快开发周期。Truffle套件包括Truffle、Ganache和Drizzle；请参阅图[5-3](#Fig3)。
- en: '*“Truffle is a development environment, testing framework and asset pipeline
    for Ethereum, aiming to make life as an Ethereum developer easier.”*'
  id: totrans-57
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “Truffle是一个开发环境，测试框架和资产管道，用于Ethereum，旨在使Ethereum开发者的生活更加轻松。”
- en: '*—* [https://github.com/trufflesuite/truffle](https://github.com/trufflesuite/truffle)'
  id: totrans-58
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*—* [https://github.com/trufflesuite/truffle](https://github.com/trufflesuite/truffle)'
- en: The Truffle documentation includes installation instructions, which can be found
    at [https://truffleframework.com/docs](https://truffleframework.com/docs) .![../images/475651_1_En_5_Chapter/475651_1_En_5_Fig3_HTML.jpg](../images/475651_1_En_5_Chapter/475651_1_En_5_Fig3_HTML.jpg)
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Truffle文档包括安装说明，可以在[https://truffleframework.com/docs](https://truffleframework.com/docs)找到！[../images/475651_1_En_5_Chapter/475651_1_En_5_Fig3_HTML.jpg](../images/475651_1_En_5_Chapter/475651_1_En_5_Fig3_HTML.jpg)
- en: Figure 5-3
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-3
- en: Truffle Suite documentation
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Truffle套件文档
- en: 'To get started, open a new Terminal window and install Truffle globally on
    your machine (at the time of writing, the current Truffle version is 5.0.14).
    Then ensure it’s installed correctly by running the help command to view a list
    of all available commands.> npm install -g truffle+ truffle@5.0.14> truffle helpTruffle
    v5.0.14 - a development framework for EthereumUsage: truffle <command> [options]'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 开始之前，打开一个新的终端窗口并在你的机器上全局安装Truffle（在撰写本文时，当前的Truffle版本是5.0.14）。然后确保它正确安装，通过运行帮助命令来查看所有可用的命令列表。>
    npm install -g truffle+ truffle@5.0.14> truffle helpTruffle v5.0.14 - 以太坊开发框架使用：truffle
    <命令> [选项]
- en: Create Your Smart Contracts
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建你的智能合约
- en: To get started, let’s create your folder and initialize the Truffle wizard to
    generate all the code needed to get started. In Terminal, type the following:>
    mkdir MySmartContract && cd $_> truffle initThese commands create a folder named
    MySmartContract and change the directory location to the new project; then the
    truffle init command initializes the project. You can see the output in Figure
    [5-4](#Fig4).![../images/475651_1_En_5_Chapter/475651_1_En_5_Fig4_HTML.jpg](../images/475651_1_En_5_Chapter/475651_1_En_5_Fig4_HTML.jpg)
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 开始之前，让我们创建你的文件夹并初始化Truffle向导以生成所有开始所需的所有代码。在终端中，输入以下命令：> mkdir MySmartContract
    && cd $_> truffle init这些命令创建一个名为MySmartContract的文件夹并更改目录位置到新项目；然后truffle init命令初始化项目。你可以在图[5-4](#Fig4)中看到输出！[../images/475651_1_En_5_Chapter/475651_1_En_5_Fig4_HTML.jpg](../images/475651_1_En_5_Chapter/475651_1_En_5_Fig4_HTML.jpg)
- en: Figure 5-4
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-4
- en: Creating the MySmartContract project and initializing with the truffle init
    command
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 创建MySmartContract项目和用truffle init命令初始化
- en: Next, open WebStorm and open the project you created by selecting File ➤ Open.
    Navigate to the MySmartContract project directory and click Open. WebStorm will
    open the project, as shown in Figure [5-5](#Fig5).![../images/475651_1_En_5_Chapter/475651_1_En_5_Fig5_HTML.jpg](../images/475651_1_En_5_Chapter/475651_1_En_5_Fig5_HTML.jpg)
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，打开WebStorm，通过选择“文件”➤“打开”来打开你创建的项目。导航到MySmartContract项目目录，并点击“打开”。WebStorm将打开该项目，如图[5-5](#Fig5)所示！[../images/475651_1_En_5_Chapter/475651_1_En_5_Fig5_HTML.jpg](../images/475651_1_En_5_Chapter/475651_1_En_5_Fig5_HTML.jpg)
- en: Figure 5-5
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-5
- en: MySmartContract open in WebStorm
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: MySmartContract在WebStorm中打开
- en: EVM supports many programming languages such as Solidity, JavaScript, GO, C++,
    Python, Java, Ruby, Web Assembly, Rust, and Haskell. In this section, you will
    be using Solidity as it’s the most popular Ethereum programming language for smart
    contracts at the time of writing. Solidity is based on ECMAScript and influenced
    by JavaScript, C++, and Python. Solidity has an advantage as you are able to deploy
    your smart contract transactions on other various blockchain platforms beside
    Ethereum, such as Ethereum Classic, Tendermint, ErisDB, and Counterparty.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: EVM支持许多编程语言，如Solidity、JavaScript、GO、C++、Python、Java、Ruby、Web Assembly、Rust和Haskell。在本节中，你将使用Solidity，因为它是编写智能合约最流行的以太坊编程语言。Solidity基于ECMAScript，并受到JavaScript、C++和Python的影响。Solidity的一个优势在于你能够将你的智能合约交易部署在除了以太坊之外的其它各种区块链平台上，如以太坊经典、Tendermint、ErisDB和Counterparty。
- en: Solidity uses the .sol file extension; in fact, if you check in the contracts
    folder of your project, you will find a file called Migrations.sol, as shown in
    Figure [5-5](#Fig5). This file was generated automatically for you when you initialized
    the Truffle wizard. The migration files help you deploy contracts to the Ethereum
    network. As your project progresses, you will create new migration files.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Solidity使用.sol文件扩展名；事实上，如果你检查你项目中的合约文件夹，你会找到一个名为Migrations.sol的文件，如图[5-5](#Fig5)所示。这个文件是在你初始化Truffle向导时自动为你生成的。迁移文件帮助你将合约部署到以太坊网络。随着你的项目进展，你会创建新的迁移文件。
- en: Connect Truffle to the Ganache Network
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将Truffle连接到Ganache网络
- en: Next, you will customize your environment by calling your network development
    and setting the URL and port. As you recall, you are already running Ganache and
    have programmed your network to listen on 127.0.0.1, port 8584\. You’ll use these
    settings for deploying your contracts on your Ethereum blockchain network.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您将通过调用您的网络开发并设置URL和端口来自定义您的环境。如您所回忆，您已经运行了Ganache，并且已经编程您的网络以监听127.0.0.1，端口8584。您将使用这些设置在您的以太坊区块链网络上部署您的合约。
- en: 'To get started, open MySmartContract/truffle-config.js and inside the network
    object add a development object with these configuration settings:module.exports
    = {    networks: {        development: {            host: "127.0.0.1",            port:
    8584,            network_id: "∗",            gas: 4712388,            gasPrice:
    100000000000        }}You set the host, port, and network ID, as well as the gas
    and gasPrice parameters. The following is according to Truffle docs ( [https://truffleframework.com/docs/truffle/reference/configuration#networks](https://truffleframework.com/docs/truffle/reference/configuration%2523networks)
    ):'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，打开MySmartContract/truffle-config.js，在network对象中添加一个开发对象，并设置这些配置：
- en: 'gas: This is the gas limit used for deploys. The default is 4712388.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: gas：此参数用于部署时的石墨烯限制。默认值为4712388。
- en: 'gasPrice: This is the gas price used for deploys. The default is 100000000000
    (100 Shannon).'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: gasPrice：此参数用于部署时的石墨烯价格。默认值为100000000000（100 Shannon）。
- en: You are setting the default values, which you can achieve also by omitting the
    gas and gasPrice tags; however, for the live mainnet network, at the time of writing,
    I recommend setting a 21,000 gas price that is a reasonable value. Check the ETH
    Gas Station ( [https://ethgasstation.info/](https://ethgasstation.info/) ) to
    figure out how much the gasPrice value should be, as shown in Figure [5-6](#Fig6).![../images/475651_1_En_5_Chapter/475651_1_En_5_Fig6_HTML.jpg](../images/475651_1_En_5_Chapter/475651_1_En_5_Fig6_HTML.jpg)
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 您正在设置默认值，您也可以通过省略gas和gasPrice标签来实现；然而，对于live主网络，在撰写本文时，我建议设置一个21,000的石墨烯价格，这是一个合理的值。查看ETH
    Gas Station（[https://ethgasstation.info/](https://ethgasstation.info/)）以确定石墨烯价格值应该是多少，如图5-6所示。
- en: Figure 5-6
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-6
- en: Ethgasstation.info calculates a recommended gas price
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Ethgasstation.info计算推荐的石墨烯价格
- en: As you can see, at the time of writing, paying a fiat of $0.014 provides a standard
    5.6 transaction time.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，在撰写本文时，支付1美元的法定货币可以提供标准的5.6次交易时间。
- en: You have set up a development environment only; however, as you move your code
    from development to a public testnet network and then production, you can add
    more environments to the truffle-config.js file.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你只设置了一个开发环境；然而，当你将你的代码从开发转移到公共测试网络，然后是生产环境时，你可以在truffle-config.js文件中添加更多环境。
- en: “Hello, World” Smart Contract
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: “你好，世界”智能合约
- en: As mentioned, smart contracts are account objects on the Ethereum blockchain;
    you can write functions to interact with other contracts, send coins, make decisions,
    and store data. Generally speaking, the contracts are built to be decentralized;
    however, keep in mind they can be programmed with a regulated option, making them
    centralized. For instance, the Ethereum Gemini dollar has the option to freeze
    transactions or even reverse them, and other coins can be built with a self-destruct
    function by the owner.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，智能合约是Ethereum区块链上的账户对象；你可以编写函数与其他合约互动、发送代币、做出决策和存储数据。总的来说，合约是为了去中心化而构建的；然而，要记住它们可以被编程为具有受监管的选项，使它们变得中心化。例如，以太坊Gemini美元有一个冻结交易或甚至撤销交易的选项，其他代币可以由所有者构建具有自毁功能的。
- en: You’ll start by creating a simple “Hello, World” contract. This is the minimum
    code, and the intention here is not to create anything useful but to help you
    understand how to create a smart contract.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你将从一个简单的“你好，世界”合约开始。这是最少的代码，这里的目的是不是创建任何有用的东西，而是帮助你理解如何创建一个智能合约。
- en: In Terminal, at the project location, create a new contract and call it HelloWorldContract
    using the command truffle.> truffle create contract HelloWorldContract
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中，在项目位置，使用truffle命令创建一个新的合约，并将其命名为HelloWorldContract。
- en: If the CLI worked correctly and without errors, it doesn’t output anything.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果CLI正确无误地工作，则不输出任何内容。
- en: Next, open the contract you created; it will show up under contracts/HelloWorldContract.sol.
    As you can see, the Truffle wizard created your contract for you.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，打开您创建的合约；它将出现在contracts/HelloWorldContract.sol下。正如您所看到的，Truffle向导已经为您创建了您的合约。
- en: This first smart contract is a minimal working example; it just holds a message
    and allows you to retrieve the message by calling your main function. Replace
    the existing code in contracts/HelloWorldContract.sol with the following below;pragma
    solidity ^0.5.0;contract HelloWorldContract {  string greeting;  constructor()
    public {    greeting = 'Hello World';  }  function greet() public view returns
    (string memory) {    return greeting;  }}
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这个第一个智能合约是一个最小化的工作示例；它只是保存一个消息，并通过调用您的main函数允许您检索消息。用下面的代码替换contracts/HelloWorldContract.sol中的现有代码；pragma
    solidity ^0.5.0;contract HelloWorldContract {  string greeting;  constructor()
    public {    greeting = 'Hello World';  }  function greet() public view returns
    (string memory) {    return greeting;  }}
- en: As you can see, Solidity scripting is similar to JavaScript or C++, and it’s
    easy to read. The first line of code is the Solidity compiler version; you will
    be using 0.5.0\. In the HelloWorldContract constructor  , you are setting the
    greeting variable to 'Hello World'. The main function is greet(). Once you call
    the main function, you can retrieve the value of the greeting variable.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，Solidity脚本与JavaScript或C++相似，且易于阅读。代码的第一行是Solidity编译器版本；您将使用0.5.0。在HelloWorldContract构造函数中，您将greeting变量设置为'Hello
    World'。主要函数是greet()。一旦您调用主要函数，您就可以检索greeting变量的值。
- en: “MD5SmartContract” Smart Contract
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: “MD5智能合约”智能合约
- en: Now you will create a second contract that is more practical. This contact will
    allow you to store the MD5 hash you stored in the previous chapter, but this time
    you will be able to interact with it instead of just storing the MD5 data on the
    blockchain.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您将创建一个更实用的第二个合约。这个合约将允许您存储前一章中存储的MD5散列值，但这次您将能够与之交互，而不仅仅是将MD5数据存储在区块链上。
- en: In Terminal, at the project level, create a new contract called MD5SmartContract
    using the command truffle.> truffle create contract MD5SmartContractNext, open
    the contract you created called contracts/RegisterContract.sol. You will be running
    the following contact:pragma solidity ^0.5.0;contract MD5SmartContract {  bytes32
    public signature;  event signEvent(bytes32 signature);  constructor() public {  }  function
    sign(string memory document) public {    signature = sha256(bytes(document));    emit
    signEvent(signature);  }}
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中，在项目级别，使用命令truffle创建一个名为MD5SmartContract的新合约。truffle create contract MD5SmartContract接下来，打开您创建的名为contracts/RegisterContract.sol的合约。您将运行以下合约：pragma
    solidity ^0.5.0;contract MD5SmartContract {  bytes32 public signature;  event
    signEvent(bytes32 signature);  constructor() public {  }  function sign(string
    memory document) public {    signature = sha256(bytes(document));    emit signEvent(signature);  }}
- en: The code creates a variable call signature. Then your main function signs your
    document. You pass the document MD5, and using SHA256, you sign the document.
    You create an event to get dispatched once you sign your document.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 代码创建了一个名为signature的变量。然后您的main函数签署您的文档。您传递文档的MD5，并使用SHA256签署文档。您创建了一个事件，一旦签署文档就会被调度。
- en: Note
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Secure Hash Algorithm (SHA) is one of a number of cryptographic hash functions.
    A cryptographic hash function acts as a signature for text or data; it is one-way
    and cannot be decrypted. The generated SHA256 hash is a fixed-size, 256 bits (32
    bytes), and almost unique.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 安全散列算法（SHA）是众多加密散列函数中的一个。加密散列函数作为文本或数据的签名；它是单向的，无法被解密。生成的SHA256散列值是一个固定大小的，256位（32字节），几乎唯一。
- en: Create Truffle Migration Files for Your Smart Contract Deployment
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为您的智能合约部署创建Truffle迁移文件
- en: 'As mentioned, Truffle migration files help you deploy your contracts on the
    Ethereum network. You will create a migration file for your deployment. To do
    so, create a new deployment file; call it 2_deploy_contracts.js, and place the
    file here: migrations/2_deploy_contracts.js. You can point to the smart contract
    code you created as follows:const HelloWorldContract = artifacts.require("HelloWorldContract.sol");module.exports
    = function(deployer) {    deployer.deploy(HelloWorldContract);};Create another
    deployment file, called 3_deploy_contracts.js, and place the file here: migrations/3_deploy_contracts.js.const
    MD5SmartContract = artifacts.require("MD5SmartContract.sol");module.exports =
    function(deployer) {    deployer.deploy(MD5SmartContract);};At this point, your
    project includes two smart contracts and migration files. You can compare your
    project directory and files with mine; see Figure [5-7](#Fig7).![../images/475651_1_En_5_Chapter/475651_1_En_5_Fig7_HTML.jpg](../images/475651_1_En_5_Chapter/475651_1_En_5_Fig7_HTML.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Truffle 迁移文件帮助您在以太坊网络上部署您的合约。您将为您部署创建一个迁移文件。为此，创建一个新的部署文件，命名为 2_deploy_contracts.js，并将文件放在这里：migrations/2_deploy_contracts.js。您可以像这样指向您创建的智能合约代码：const
    HelloWorldContract = artifacts.require("HelloWorldContract.sol");module.exports
    = function(deployer) {    deployer.deploy(HelloWorldContract);};创建另一个名为 3_deploy_contracts.js
    的部署文件，并将文件放在这里：migrations/3_deploy_contracts.js。const MD5SmartContract = artifacts.require("MD5SmartContract.sol");module.exports
    = function(deployer) {    deployer.deploy(MD5SmartContract);};至此，您的项目包括了两个智能合约和迁移文件。您可以比较您的项目目录和文件与我的一致；如图
    [5-7](#Fig7) 所示。![../images/475651_1_En_5_Chapter/475651_1_En_5_Fig7_HTML.jpg](../images/475651_1_En_5_Chapter/475651_1_En_5_Fig7_HTML.jpg)
- en: Figure 5-7
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-7
- en: MySmartContract including two smart contracts and migration files
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 包含两个智能合约和迁移文件的 MySmartContract
- en: Another technique for lazier developers is to use the Truffle create wizard
    to generate the migration file.> truffle create migration deploy_my_contract
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更懒惰的开发人员，另一种技巧是使用 Truffle 创建向导来生成迁移文件。> truffle create migration deploy_my_contract
- en: This command generates the migration file automatically for you.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令会自动为你生成迁移文件。
- en: Compile Your Smart Contract with Truffle
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Truffle 编译智能合约
- en: 'In a separate Terminal window, you will run Truffle to compile your smart contract.
    The compile command  turns your Solidity code to bytecode, which can be interpreted
    by the EVM. For now, Ganache simulates the EVM.> truffle compileYou can see your
    contract’s bytecode in the JSON file found here: build/contracts/HelloWorldContract.json
    and build/contracts/MD5SmartContract.json. Look for the bytecode tag shown here:"bytecode":
    "0x608060405234801561001057600080fd5b5061031...",'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '在另一个终端窗口中，您将运行 Truffle 来编译您的智能合约。编译命令将您的 Solidity 代码转换为字节码，该字节码可以被 EVM 解释。现在，Ganache
    模拟 EVM。> truffle compile您可以在以下 JSON 文件中看到您合约的字节码：build/contracts/HelloWorldContract.json
    和 build/contracts/MD5SmartContract.json。请在此查找所示的字节码标签："bytecode": "0x608060405234801561001057600080fd5b5061031..."'
- en: Note
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Keep in mind that ideally you should delete the contract’s contracts/∗.json
    file manually before compiling again. This will ensure the latest code gets compiled
    because the CLI does not always recognize changes right away.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，理想情况下你应该在再次编译之前手动删除合约的 contracts/*.json 文件。这将确保最新的代码被编译，因为 CLI 不总是立即识别更改。
- en: Deploy the Smart Contract to Your Development Network
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将智能合约部署到您的开发网络
- en: Now that you have bytecode compiled from your smart contract, you can migrate
    the bytecode into your development environment so you can run the migration command
    to switch to the network you set in the truffle.js file.> truffle migrate --network
    developmentRunning this command will return the response shown in Figure [5-8](#Fig8).
    This shows you that three migration files have been deployed successfully on the
    network. You have a successful deployment for each contract.![../images/475651_1_En_5_Chapter/475651_1_En_5_Fig8_HTML.jpg](../images/475651_1_En_5_Chapter/475651_1_En_5_Fig8_HTML.jpg)
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经从你的智能合约中编译出了字节码，你可以将字节码迁移到你的开发环境中，这样你就可以运行迁移命令来切换到 truffle.js 文件中设置的网络。>
    truffle migrate --network development运行这个命令将返回如图 [5-8](#Fig8) 所示的响应。这表明三个迁移文件已成功在网络上部署。每个合约都有一个成功的部署。![../images/475651_1_En_5_Chapter/475651_1_En_5_Fig8_HTML.jpg](../images/475651_1_En_5_Chapter/475651_1_En_5_Fig8_HTML.jpg)
- en: Figure 5-8
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-8
- en: Truffle migrate command response
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Truffle migrate 命令响应
- en: Keep in mind that the --reset flag is useful when you change your code, as you
    need to recompile, and re-deploy.> truffle migrate --reset
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，--reset 标志在您更改代码时很有用，因为您需要重新编译和部署。> truffle migrate --reset
- en: Truffle Console
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Truffle 控制台
- en: Now that your contract has been deployed to your development network you can
    communicate with your smart contract via the Truffle CLI. To do so, you can open
    a console and connect it to your development network.> truffle console --network
    developmentOnce you run the console command  , your Terminal shows you are in
    Truffle CLI development mode.truffle(development)>
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你的合约已经部署到了你的开发网络，你就可以通过Truffle CLI与你的智能合约互动了。为此，你可以打开一个控制台并连接到你的开发网络。> truffle
    console --network development一旦你运行了控制台命令，你的终端显示你处于
- en: To get out of CLI mode, click Control+C twice or type .exit in the console.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要退出CLI模式，点击Control+C两次或者在控制台里输入.exit。
- en: Interact with Your Smart Contract via the Truffle CLI
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过Truffle CLI与你的智能合约互动
- en: You set two variables, hello and sign, for your smart contracts so that you
    can interact with them.truffle(development)> HelloWorldContract.deployed().then(_app
    => { hello = _app })undefinedtruffle(development)> MD5SmartContract.deployed().then(_app
    => { doc = _app })undefinedTo interact with your HelloWorldContract contract,
    you can call the main public function you created because you exposed the function
    greet.truffle(development)> hello.greet()'Hello World'Similarly, you can interact
    with the MD5SmartContract.sol contract. You will pass the same MD5 hash you generated
    in Chapter [3](475651_1_En_3_Chapter.xhtml) (634ef85e038cea45bd20900fc97e09dc)
    and call your main function called sign. That function will generate an SHA256
    hash, as shown in Figure [5-9](#Fig9).truffle(development)> doc.sign('634ef85e038cea45bd20900fc97e09dc')![../images/475651_1_En_5_Chapter/475651_1_En_5_Fig9_HTML.jpg](../images/475651_1_En_5_Chapter/475651_1_En_5_Fig9_HTML.jpg)
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为你的智能合约设置了两个变量hello和sign，这样你就可以与它们互动了。truffle(development)> HelloWorldContract.deployed().then(_app
    => { hello = _app })undefinedtruffle(development)> MD5SmartContract.deployed().then(_app
    => { doc = _app })undefined要与你的HelloWorldContract合约互动，你可以调用你创建的主要公共函数，因为你暴露了函数greet。truffle(development)>
    hello.greet()'Hello World'同样，你可以与MD5SmartContract.sol合约互动。你将传递在第[3](475651_1_En_3_Chapter.xhtml)章中生成的相同的MD5散列值（634ef85e038cea45bd20900fc97e09dc），并调用你的主函数sign。那个函数将生成一个SHA256散列值，如图[5-9](#Fig9)所示。truffle(development)>
    doc.sign('634ef85e038cea45bd20900fc97e09dc')![../images/475651_1_En_5_Chapter/475651_1_En_5_Fig9_HTML.jpg](../images/475651_1_En_5_Chapter/475651_1_En_5_Fig9_HTML.jpg)
- en: Figure 5-9
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-9
- en: Creating a doc.sign transaction
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 创建doc.sign交易
- en: Now you can confirm that you have an SHA256 hash by calling the signature function;
    see the output in Figure [5-10](#Fig10).truffle(development)> doc.signature()'0x7869cd540ff8c3b2635ec87251f361e21ad3c72fbc2f79897b9816bec54b0a48'![../images/475651_1_En_5_Chapter/475651_1_En_5_Fig10_HTML.jpg](../images/475651_1_En_5_Chapter/475651_1_En_5_Fig10_HTML.jpg)
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以通过调用签名函数来确认你有一个SHA256散列值；查看输出在图[5-10](#Fig10)。truffle(development)> doc.signature()'0x7869cd540ff8c3b2635ec87251f361e21ad3c72fbc2f79897b9816bec54b0a48'![../images/475651_1_En_5_Chapter/475651_1_En_5_Fig10_HTML.jpg](../images/475651_1_En_5_Chapter/475651_1_En_5_Fig10_HTML.jpg)
- en: Figure 5-10
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-10
- en: Interacting with the MD5SmartContract smart contract to produce a signature
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 与MD5SmartContract智能合约互动以生成签名
- en: 'You can download the entire smart contract project from here: [https://github.com/Apress/the-blockchain-developer/chapter5/step1/](https://github.com/Apress/the-blockchain-developer/chapter5/step1/)
    .'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从这里下载整个智能合约项目：[https://github.com/Apress/the-blockchain-developer/chapter5/step1/](https://github.com/Apress/the-blockchain-developer/chapter5/step1/)。
- en: Compile with Remix
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Remix编译
- en: So far you used the Truffle tools, Ganache network, and WebStorm IDE to create,
    compile, deploy, and interact with your contract; however, there is another even
    easier way. Remix offers an online IDE that can do the same as WebStorm and Truffle.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经使用了Truffle工具、Ganache网络和WebStorm IDE来创建、编译、部署和与你的合约互动；然而，还有一种更简单的方法。Remix提供了一个在线IDE，可以做到和WebStorm和Truffle一样的事情。
- en: 'To see this work, go to the Remix site: [https://remix.ethereum.org](https://remix.ethereum.org)
    .'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看这个工作原理，请访问Remix网站：[https://remix.ethereum.org](https://remix.ethereum.org)。
- en: Paste in the “Hello, World” smart contract code from your example. Ensure that
    the right-side panel is set to the correct compiler; you will be using “Current
    version:0.4.22.” Then click “Start to compile (Ctrl-S).” See Figure [5-11](#Fig11).![../images/475651_1_En_5_Chapter/475651_1_En_5_Fig11_HTML.jpg](../images/475651_1_En_5_Chapter/475651_1_En_5_Fig11_HTML.jpg)
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 粘贴你的示例中的“你好，世界”智能合约代码。确保右侧面板设置为正确的编译器；你将使用“当前版本：0.4.22。”然后点击“开始编译（Ctrl-S）。”见图[5-11](#Fig11)。![../images/475651_1_En_5_Chapter/475651_1_En_5_Fig11_HTML.jpg](../images/475651_1_En_5_Chapter/475651_1_En_5_Fig11_HTML.jpg)
- en: Figure 5-11
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-11
- en: “Hello, World” smart contract
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: “你好，世界”智能合约
- en: Create a new folder in your project and name it remix; then create a file and
    name it HelloWorldContract.js. Click the Details button in Remix Online IDE and
    copy and paste the WEB3DEPLOY content into the HelloWorldRemix.js file you created,
    as shown in Figure [5-12](#Fig12).![../images/475651_1_En_5_Chapter/475651_1_En_5_Fig12_HTML.jpg](../images/475651_1_En_5_Chapter/475651_1_En_5_Fig12_HTML.jpg)
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的项目中创建一个新文件夹，命名为remix；然后在该文件夹中创建一个名为HelloWorldContract.js的文件。在Remix Online
    IDE中点击“详情”按钮，将WEB3DEPLOY内容复制并粘贴到你创建的HelloWorldRemix.js文件中，如图[5-12](#Fig12)所示！[../images/475651_1_En_5_Chapter/475651_1_En_5_Fig12_HTML.jpg](../images/475651_1_En_5_Chapter/475651_1_En_5_Fig12_HTML.jpg)
- en: Figure 5-12
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-12
- en: “Hello, World” smart contract WEB3DEPLOY code
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约“Hello, World”的WEB3DEPLOY代码
- en: Note
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: web3.js is Ethereum JavaScript API; its libraries allow you to interact with
    an Ethereum node via an HTTP or IPC connection. The WEB3DEPLOY code can be deployed
    on a local or remote node.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: web3.js是一个以太坊JavaScript API；其库允许你通过HTTP或IPC连接与以太坊节点进行交互。WEB3DEPLOY代码可以部署在本地或远程节点上。
- en: Private Ethereum Blockchain with Geth
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 私有以太坊区块链的Geth搭建
- en: You have interacted with your smart contract on your local machine. Next, it’s
    advisable to run a full node and test your smart contract on a testnet blockchain;
    this tests it in a more realistic environment. Geth offers a full Ethereum node
    implemented in Go that you can run locally. This private testnet will allow you
    to develop and test your current smart contract in isolation from the real Ethereum
    blockchain.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经在你本地机器上与你的智能合约进行了交互。接下来，建议运行一个完整的节点，并在测试网区块链上测试你的智能合约；这可以在一个更真实的环境中测试它。Geth提供了一个用Go实现的完整的以太坊节点，你可以在本地运行。这个私有测试网将允许你在与真实以太坊区块链隔离的环境中开发和测试你当前的智能合约。
- en: 'To get started, first install Geth using Brew.> brew tap ethereum/ethereum>
    brew install ethereumTo ensure installation went well, run the --version command
    for the current Geth version (I am using 1.8.27 at the time of writing).> geth
    versionVersion: 1.8.27-stable'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '首先，使用Brew安装Geth。> brew tap ethereum/ethereum> brew install ethereum为确保安装成功，运行当前Geth版本（我写这篇文章时使用的是1.8.27版本）的--version命令。>
    geth versionVersion: 1.8.27-stable'
- en: Initialized Geth Private Blockchain
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 初始化Geth私有区块链
- en: 'Now that you have Geth installed, you will create your first block, or block
    0, which is called the *genesis* block  . Create a file called genesis_block.json
    and place it in the project root. For now just paste the provided JSON, but note
    that you can generate a custom genesis block with the Python script found here:
    [https://blog.ethereum.org/2015/07/27/final-steps/](https://blog.ethereum.org/2015/07/27/final-steps/)
    .'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经安装了Geth，接下来将创建你的第一个区块，即区块0，也称为*创世区块*。在项目根目录下创建一个名为genesis_block.json的文件。现在只需粘贴提供的JSON即可，但请注意，你可以使用此处提供的Python脚本生成自定义的创世区块：[https://blog.ethereum.org/2015/07/27/final-steps/](https://blog.ethereum.org/2015/07/27/final-steps/)。
- en: 'For the scope of this book, you will use this script and set a low difficulty
    of 1000 and gas limit of 1000000 for easy mining and low gas fees; however, feel
    free to adjust as needed in your own experiments. See genesis_block.json.{  "config":
    {  "chainId": 1,  "homesteadBlock": 0,  "eip155Block": 0,  "eip158Block": 0},  "difficulty":
    "0x1000",  "gasLimit": "0x1000000",    "alloc": {      "0x44dc998cbc1c7504bec0a96af4a9aef6606a768a":      {"balance":
    "0x1337000000000000000000"}    }}Next you will create your private testnet. In
    Terminal, run this command:> geth --identity "MyTestNet" --nodiscover --networkid
    1999 --datadir testnet-blockchain init genesis_block.jsonYou will need an account
    for your testnet-blockchain; use the account command. Select a simple password
    as you are running a local test network, but on mainnet you need to be mindful
    of security; here I’m choosing password 123.> geth account new --datadir testnet-blockchainPassphrase:
    123Repeat passphrase: 123Address: { a8eceb3e2dd7af9c6fdb12edd8a7e84290932c2d}As
    you can see, you received a wallet address after picking a password. You can compare
    your output with mine, as shown in Figure [5-13](#Fig13).![../images/475651_1_En_5_Chapter/475651_1_En_5_Fig13_HTML.jpg](../images/475651_1_En_5_Chapter/475651_1_En_5_Fig13_HTML.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '在本书的范围内，您将使用此脚本并将难度设置为1000，将燃料限制设置为1000000，以便轻松挖矿和低燃料费用；然而，在您自己的实验中，可以根据需要进行调整。请参阅genesis_block.json。{  "config":
    {  "chainId": 1,  "homesteadBlock": 0,  "eip155Block": 0,  "eip158Block": 0},  "difficulty":
    "0x1000",  "gasLimit": "0x1000000",    "alloc": {      "0x44dc998cbc1c7504bec0a96af4a9aef6606a768a":      {"balance":
    "0x1337000000000000000000"}    }}接下来，您将创建您的私有测试网。在终端中，运行此命令：> geth --identity
    "MyTestNet" --nodiscover --networkid 1999 --datadir testnet-blockchain init genesis_block.json您需要为您的测试网区块链创建一个账户；使用账户命令。选择一个简单的密码，因为您正在运行一个本地测试网络，但在主网上，您需要关注安全性；在这里，我选择密码123。>
    geth account new --datadir testnet-blockchain密码：123重复密码：123地址：{ a8eceb3e2dd7af9c6fdb12edd8a7e84290932c2d}正如您所看到的，在选择密码后，您收到了一个钱包地址。您可以将自己的输出与我显示的进行比较，如图[5-13](#Fig13)所示。![../images/475651_1_En_5_Chapter/475651_1_En_5_Fig13_HTML.jpg](../images/475651_1_En_5_Chapter/475651_1_En_5_Fig13_HTML.jpg)'
- en: Figure 5-13
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-13
- en: Creating a private testnet and wallet with Geth
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Geth创建私有测试网和钱包
- en: Geth Console
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Geth控制台
- en: Now that you have your account set and testnet-blockchain chain, you can open
    a Geth console to interact with the chain.> geth --identity "MyTestNet" --datadir
    testnet-blockchain --nodiscover --networkid 1999 console 2>> geth.log
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经设置了账户和测试网区块链，您可以打开一个Geth控制台与区块链互动。> geth --identity "MyTestNet" --datadir
    testnet-blockchain --nodiscover --networkid 1999 console 2>> geth.log
- en: Notice that I used the 2>> geth.log param to output the logs into a custom file
    location. Once the Geth console starts, you can run the eth.syncing command  to
    check the current block being synced. In this case, it will return false because
    there is nothing to sync; you are starting from block 0 on a local network.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我使用了2>> geth.log参数将日志输出到自定义文件位置。一旦Geth控制台启动，您可以运行eth.syncing命令来检查当前正在同步的区块。在这种情况下，它将返回false，因为没有要同步的内容；您正在本地网络上从区块0开始。
- en: 'You will receive a pop-up alert asking you the following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 您将收到一个弹出警告，询问以下内容：
- en: '*“Do you want the application “geth” to accept incoming network connections?
    Clicking Deny may limit the application’s behaviour. This setting can be changed
    in the Firewall pane of Security & Privacy preferences.” Select “Allow”.*'
  id: totrans-145
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “您想要应用程序“geth”接受传入的网络连接吗？点击拒绝可能会限制应用程序的行为。此设置可以在“安全与隐私”首选项的防火墙面板中更改。”请选择“允许”。
- en: Next, in the Geth terminal, run the syncing command.geth> eth.syncingfalseIf
    you run the eth.blockNumber command  , it will return a zero as you have not mined
    any blocks yet.geth> eth.blockNumber0
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在Geth终端中运行同步命令。geth> eth.syncingfalse如果您运行eth.blockNumber命令，它将返回0，因为您还没有挖出任何区块。geth>
    eth.blockNumber0
- en: Mine Ethereum for Your Private Testnet
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为您的私有测试网挖以太坊
- en: You can then confirm you have a balance in your account with the getBalance
    command.geth> eth.getBalance(eth.accounts[0])0With the eth.accounts command, you
    will get the new account you created.geth> eth.accounts["0xa2a6d8fe7e39645613e74fe19c79071ee52009ba"]You
    can either generate or mine ether coins on the private Ethereum chain you created.
    Regardless, you need to know how to mine coins, because you will need transactions
    to be included in mined blocks as you test your code. To start mining, just run
    the miner.start command  .geth> miner.start()nullSimilarly, to stop mining, simply
    run the miner.stop command  .> miner.stop()nullIf you let the mining run, you
    will mine some blocks, so when you check the block number, you will now see results
    as well as funds.geth> eth.blockNumber1672geth> eth.getBalance(eth.accounts[0])8.36e+21
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以使用getBalance命令确认你的账户里是否有余额。`geth> eth.getBalance(eth.accounts[0])` `0`
    使用`eth.accounts`命令，你将得到你创建的新账户。`geth> eth.accounts["0xa2a6d8fe7e39645613e74fe19c79071ee52009ba"]`
    你可以在你创建的私有以太坊链上生成或挖出以太币。无论如何，你需要知道如何挖矿，因为你测试代码时需要交易被包含在挖出的区块中。要开始挖矿，只需运行`miner.start`命令。`geth>
    miner.start()` `null` 同样地，要停止挖矿，只需运行`miner.stop`命令。`> miner.stop()` `null` 如果你让挖矿运行，你将挖出一些区块，所以当你检查区块号码时，你将现在也看到结果以及资金。`geth>
    eth.blockNumber` `1672` `geth> eth.getBalance(eth.accounts[0])` `8.36e+21`
- en: Deploy Remix to Geth
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将Remix部署到Geth
- en: 'Now that your node is synced and you know how to mine, you can deploy your
    contracts to the testnet. First, you need to unlock your main Geth account to
    be able to use it. Ensure your account holds a balance; otherwise, you won’t be
    able to deploy your contract on the network. On Geth, unlock your account with
    your password so Geth can use it.geth> personal.unlockAccount(eth.accounts[0],
    "123", 24∗3600)trueI used the password 123, but you need to change it to your
    password if you used a different password. Next, load the web3.js script you generated
    on Remix.> loadScript("remix/HelloWorldContract.js")null [object Object]trueIt
    takes a few seconds to mine the next block and include this contract; once it’s
    mined, you will receive the following message:Contract mined! address: 0x9905f1663f1b808d52dca42ce26e0d2648f8be07
    transactionHash: 0x66b80787eb3eae16c9535a1bd86ff1a623c1914ac9ffc2addde74655aed09157If
    you are not seeing this message, make sure you are mining.geth> miner.start()Once
    the contact is mined, you will get the following message in Terminal, which includes
    the address and transaction hash:Contract mined! address: 0xe49da16551c5c5735de46e07e8ab9e713310a13b
    transactionHash: 0x36d3ec593f63280ca6aae1b079bfb6f00eea719468e04960643c23f39cbef5b3'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '既然你的节点已经同步，你也知道如何挖矿，接下来你可以将你的智能合约部署到测试网上了。首先，你需要解锁你的主Geth账户以便使用。确保你的账户里有一定的余额，否则你将无法在网络上部署你的合约。在Geth上，使用你的密码解锁你的账户以便Geth可以调用它。`geth>
    personal.unlockAccount(eth.accounts[0], "123", 24∗3600)` `true` 我使用了密码123，但如果你使用了不同的密码，你需要将其改为你的密码。接下来，加载你在Remix上生成的web3.js脚本。`>
    loadScript("remix/HelloWorldContract.js")` `null [object Object]` `true` 挖出下一个区块并包含这个合约需要几秒钟；一旦挖出，你将收到以下消息：`Contract
    mined! address: 0x9905f1663f1b808d52dca42ce26e0d2648f8be07 transactionHash: 0x66b80787eb3eae16c9535a1bd86ff1a623c1914ac9ffc2addde74655aed09157`
    如果你没有看到这条消息，确保你在挖矿。`geth> miner.start()` 合约一旦挖出，你将在终端中收到以下消息，其中包括地址和交易哈希：`Contract
    mined! address: 0xe49da16551c5c5735de46e07e8ab9e713310a13b transactionHash: 0x36d3ec593f63280ca6aae1b079bfb6f00eea719468e04960643c23f39cbef5b3`'
- en: Deploy Truffle to Geth
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将Truffle部署到Geth
- en: Similarly, to deploy the web3.js contract’s script via Truffle, you run the
    migrate --reset command. The --reset flag tells Truffle to run all the migrations
    from the beginning. Ensure you use .exit to exit the Truffle console prior to
    running the migrate command. Truffle will compile your contract automatically.truffle(development)>
    .exit> truffle migrate --resetUsing network 'development'.Network up to date.Now
    you can open a development console again.> truffle console --network developmenttruffle(development)>
    HelloWorldContract.deployed().then(_app => { hello = _app })undefinedtruffle(development)>
    hello.greet() 'Hello World'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，通过Truffle部署web3.js合约的脚本，你需要运行migrate --reset命令。`--reset`标志告诉Truffle从头开始运行所有迁移。确保在运行migrate命令之前使用`.exit`退出Truffle控制台。Truffle将自动编译你的合约。`truffle(development)>
    .exit` `> truffle migrate --reset` `Using network 'development'.Network up to
    date.` `Now you can open a development console again.` `> truffle console --network
    development` `truffle(development)> HelloWorldContract.deployed().then(_app =>
    { hello = _app })` `undefined` `truffle(development)> hello.greet()` `'Hello World'`
- en: 'The contract is redeployed, and you can interact with your contract again.
    You can download this step from here: [https://github.com/Apress/the-blockchain-developer/chapter5/step2/](https://github.com/Apress/the-blockchain-developer/chapter5/step2/)
    .'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 合约已重新部署，你可以再次与你的合约互动。你可以从这里下载这一步：[https://github.com/Apress/the-blockchain-developer/chapter5/step2/](https://github.com/Apress/the-blockchain-developer/chapter5/step2/)。
- en: Useful Commands in Geth
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Geth 中实用的命令
- en: You can stop the Geth process by pressing Command+C and then exit, or you can
    stop the process via aux to check whether there are any processes open. Or you
    can use the killall command  to stop the process.> ps aux | grep geth> killall
    -HUP gethAt any time, you can run the help flag to get a list of commands.> geth
    –helpTo get a list of the pending transactions, run the following:> geth --identity
    "MyTestNet" --datadir testnet-blockchain --nodiscover --networkid 1999 console
    2>> geth.loggeth> eth.pendingTransactionsTo remove your locally synced blockchain
    data from the public testnet, use this:geth> geth removedbTo remove your private
    blockchain testnet data, use this:geth> geth removedb --datadir test-net-blockchainTo
    synchronize the blockchain more quickly, use the  --fast flag to perform a fast
    Ethereum sync. Note that you will not retain the past transaction data with this
    command. The cache flag sets the cache limit.geth> geth --fast --cache=1024
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过按下 Command+C 来停止 Geth 进程，然后退出，或者你可以通过 aux 来检查是否有任何进程打开。或者你可以使用 killall
    命令来停止进程。> ps aux | grep geth> killall -HUP geth在任何时候，你可以运行帮助标志来获取命令列表。> geth –help要获取待处理的交易列表，请运行以下命令：>
    geth --identity "MyTestNet" --datadir testnet-blockchain --nodiscover --networkid
    1999 console 2>> geth.loggeth> eth.pendingTransactions要删除公共测试网上的本地同步区块链数据，使用这个命令：geth>
    geth removedb要删除你的私有区块链测试网数据，使用这个命令：geth> geth removedb --datadir test-net-blockchain为了更快地同步区块链，使用
     --fast 标志来执行快速以太坊同步。请注意，使用这个命令你将无法保留过去的交易数据。缓存标志设置了缓存限制。geth> geth --fast --cache=1024
- en: Connect the Mist Ethereum Wallet to Your Private Network
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 Mist Ethereum 钱包连接到你的私有网络
- en: It would be useful to have a wallet to connect to your private network. That’s
    where Mist is helpful. You can connect your private blockchain to Mist and perform
    transactions, conducting realistic transactions as if people were using your contracts.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个可以连接到你的私有网络的钱包会很有用。那就是 Mist 的作用所在。你可以将你的私有区块链连接到 Mist 并进行交易，就像人们正在使用你的合约一样进行真实的交易。
- en: 'To get started, download Mist from here: [https://github.com/ethereum/mist/releases](https://github.com/ethereum/mist/releases)
    .'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 开始使用，从这里下载 Mist：[https://github.com/ethereum/mist/releases](https://github.com/ethereum/mist/releases)。
- en: For Mac, the file to download is called Mist-macosx-0-11-1.dmg at the time of
    writing. Note that you can also achieve the same results with an Ethereum wallet,
    which you can download from the same URL.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Mac，在撰写本文时，要下载的文件名为 Mist-macosx-0-11-1.dmg。请注意，你也可以通过从同一个网址下载以太坊钱包来实现相同的结果。
- en: Next, you will be starting Mist and connecting it to your testnet blockchain.
    At the command line, point to Mist’s location and the geth.ipc database.> /Applications/Mist.app/Contents/MacOS/Mist
    --rpc /[project location]/MySmartContract/testnet-blockchain/geth.ipcMist opens
    and shows your active account and balance, as shown in Figure [5-14](#Fig14).![../images/475651_1_En_5_Chapter/475651_1_En_5_Fig14_HTML.jpg](../images/475651_1_En_5_Chapter/475651_1_En_5_Fig14_HTML.jpg)
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将启动 Mist 并将其连接到你的测试网区块链。在命令行中，指向 Mist 的位置和 geth.ipc 数据库。> /Applications/Mist.app/Contents/MacOS/Mist
    --rpc /[项目位置]/MySmartContract/testnet-blockchain/geth.ipcMist 打开并显示你的活动账户和余额，如图
    [5-14](#Fig14) 所示。![../images/475651_1_En_5_Chapter/475651_1_En_5_Fig14_HTML.jpg](../images/475651_1_En_5_Chapter/475651_1_En_5_Fig14_HTML.jpg)
- en: Figure 5-14
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-14
- en: Mist active account and balance
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Mist 活动账户和余额
- en: Others to Interact with Your Smart Contract
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与你的智能合约互动的其他人
- en: Once the contract is published, anyone can use the address and application binary
    interface (ABI) to connect and interact with the contract. You can start and interact
    with your contract as if an actual person is using your contract prior to publishing
    it to mainnet.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦合约发布，任何人都可以使用地址和应用程序二进制接口（ABI）来连接和与合约互动。你可以在将合约发布到主网之前，像一个实际的人一样启动并与你合约互动。
- en: Mist is a desktop app that can be used for testing. To watch a contract, in
    Mist, click the Contracts link at the top right and then click Watch Contract,
    as shown in Figure [5-15](#Fig15).![../images/475651_1_En_5_Chapter/475651_1_En_5_Fig15_HTML.jpg](../images/475651_1_En_5_Chapter/475651_1_En_5_Fig15_HTML.jpg)
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5-15
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Mist’s Watch Contract button
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: For others to run your contract, they need two things.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Contract address
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application binary interface
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An ABI describes the contract’s functions. This description is needed in order
    to know how to call the function. Think of it as a user manual.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: You can retrieve the contract address, as shown here:truffle(development)>var
    hello = HelloWorldContract.deployed().then(_app => { hello = _app })truffle(development)>hello.address'0x0b4f69f88390bc8cec93e730128a5e5c5dffd56c'Similarly,
    you can retrieve the contract’s ABI with this command:truffle(development)>JSON.stringify(hello.abi)'[{"inputs":[],"payable":false,"stateMutability":"nonpayable","type":"constructor","signature"
    '[{"inputs":[],"payable":false,"stateMutability":"nonpayable","type":"constructor","signature":"constructor"},{"constant":true,"inputs":[],"name":"greet","outputs":[{"name":"","type":"string"}],"payable":false,"stateMutability":"view","type":"function","signature":"0xcfae3217"}]'Then
    pass the contract address and ABI in Mist, as shown in Figure [5-16](#Fig16).![../images/475651_1_En_5_Chapter/475651_1_En_5_Fig16_HTML.jpg](../images/475651_1_En_5_Chapter/475651_1_En_5_Fig16_HTML.jpg)
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5-16
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Passing info in Mist
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Notice that you omit the single quote from the ABI and address before pasting
    it into Mist.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Now click OK, and you can see your contract in the watched contracts list. See
    Figure [5-17](#Fig17).![../images/475651_1_En_5_Chapter/475651_1_En_5_Fig17_HTML.jpg](../images/475651_1_En_5_Chapter/475651_1_En_5_Fig17_HTML.jpg)
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5-17
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Mist’s watched contracts
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: You have your contract in Mist, and you can interact with it, send funds, listen
    to events, and interact with functions, just as users will interact with your
    contract on mainnet.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: MetaMask
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Similar to Mist, another way to interact with your contracts, without even downloading
    a desktop app, is in your Chrome or Firefox browser with a plugin called MetaMask.
    Just as with Mist, you can utilize MetaMask to connect your contract to mainnet,
    a public testnet, and a local blockchain (such as the one you created with Ganache),
    or you can even connect to Truffle Develop. To get started, download the MetaMask
    plugin for Chrome or Firefox.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '*Chrome Web Store*: [https://chrome.google.com/webstore/detail/metamask/nkbihfbeogaeaoehlefnkodbefgpgknn](https://chrome.google.com/webstore/detail/metamask/nkbihfbeogaeaoehlefnkodbefgpgknn)
    . Click the Add to Chrome button. See Figure [5-18](#Fig18).'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Firefox Add-ons page*: [https://addons.mozilla.org/en-US/firefox/addon/ether-metamask](https://addons.mozilla.org/en-US/firefox/addon/ether-metamask)
    . Click the Add to Firefox button.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![../images/475651_1_En_5_Chapter/475651_1_En_5_Fig18_HTML.jpg](../images/475651_1_En_5_Chapter/475651_1_En_5_Fig18_HTML.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![../images/475651_1_En_5_Chapter/475651_1_En_5_Fig18_HTML.jpg](../images/475651_1_En_5_Chapter/475651_1_En_5_Fig18_HTML.jpg)'
- en: Figure 5-18
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-18
- en: MetaMask beta Chrome add-on
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: MetaMask beta Chrome插件
- en: Click the MetaMask icon and then the Continue button. Next, select a password,
    accept the terms, save your secret backup phrase, and create your account.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 点击MetaMask图标，然后点击继续按钮。接下来，选择一个密码，接受条款，保存你的秘密备份短语，并创建你的账户。
- en: Now that the account is created, you have an option in the top drop-down of
    which network to connect to, as shown in Figure [5-19](#Fig19).![../images/475651_1_En_5_Chapter/475651_1_En_5_Fig19_HTML.jpg](../images/475651_1_En_5_Chapter/475651_1_En_5_Fig19_HTML.jpg)
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在账户已经创建，你在顶部的下拉菜单中有选项选择连接到哪个网络，如图[5-19](#Fig19)所示。![../images/475651_1_En_5_Chapter/475651_1_En_5_Fig19_HTML.jpg](../images/475651_1_En_5_Chapter/475651_1_En_5_Fig19_HTML.jpg)
- en: Figure 5-19
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-19
- en: MetaMask beta Chrome network drop-down
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: MetaMask beta Chrome网络下拉菜单
- en: As you might recall, you programmed the truffle.js values to set a network on
    localhost port 8584, which matches the default network; however, you can set a
    custom RPC or connect to testnet or mainnet.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能回忆的，你编程了truffle.js的值来在localhost端口8584上设置一个网络，这与默认网络匹配；然而，你可以设置一个自定义RPC或连接到测试网络或主网络。
- en: For more information regarding connecting Truffle with Metamask, visit the Truffle
    framework docs;
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 有关将Truffle与MetaMask连接的更多信息，请访问Truffle框架文档；
- en: '[https://truffleframework.com/docs/truffle/getting-started/truffle-with-metamask](https://truffleframework.com/docs/truffle/getting-started/truffle-with-metamask)'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://truffleframework.com/docs/truffle/getting-started/truffle-with-metamask](https://truffleframework.com/docs/truffle/getting-started/truffle-with-metamask)'
- en: Public Testnet
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 公共测试网络
- en: Now that you are able to run your smart contract on a development network, you
    can take an additional step prior to going to mainnet. You can run your contract
    on a public testnet network.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你能够在开发网络上运行你的智能合约，你可以在主网上线之前再迈出一小步。你可以将你的合约在公共测试网络上运行。
- en: Syncing Blocks
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 区块同步
- en: 'There are three well-known testnets: Ropsten, Kovan, and Rinkeby. You can program
    Geth to connect to a testnet with the --testnet flag, which will connect to the
    public testnet network (Ropsten).> geth --testnet --syncmode "fast" --cache=512
    console'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个著名的测试网络：Ropsten、Kovan和Rinkeby。你可以让Geth通过--testnet标志连接到测试网络，这将连接到公共测试网络（Ropsten）。>
    geth --testnet --syncmode "fast" --cache=512 console
- en: As before, the rpc flag is needed to accept the Geth RPC connections and for
    Truffle to be able to connect to Geth. You are also setting it to fast sync and
    limiting the cache size to 512\. This command includes starting the Geth console.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 和之前一样，需要rpc标志来接受Geth RPC连接，让Truffle能够连接到Geth。你还把它设置为快速同步并将缓存大小限制为512\. 这个命令包括启动Geth控制台。
- en: 'To check the status of the syncing command, use this:geth> eth.syncing{  currentBlock:
    1011878,  highestBlock: 3569550,  knownStates: 2058862,  pulledStates: 2056745,  startingBlock:
    968873}'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '要检查同步命令的状态，使用这个：geth> eth.syncing{    currentBlock: 1011878,    highestBlock:
    3569550,    knownStates: 2058862,    pulledStates: 2056745,    startingBlock:
    968873}'
- en: Once complete, the syncing command  will return false. Keep in mind that there
    are millions of state entries and 3,569,550 blocks at the time of writing, which
    could take hours depending on your connection speed. The currentBlock value is
    the current block being retrieved out of a total number of blocks (the highest
    block). This can give you an idea of how long the download will take.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，同步命令将返回false。记住，在撰写本文时，有数百万个状态条目和3,569,550个区块，这可能需要数小时，具体取决于你的连接速度。currentBlock值是正在检索的当前区块，总区块数（最高区块）。这可以让你知道下载需要多长时间。
- en: As you recall, you can check current block number being sync by running the
    eth.blockNumber command in a Geth console, as well as check your balance in your
    account to see whether it has been updated yet.> eth.blockNumber> eth.getBalance(eth.accounts[0])
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所回忆的，你可以在Geth控制台中运行eth.blockNumber命令来查看当前正在同步的区块号码，以及检查你的账户余额是否已经更新。> eth.blockNumber>
    eth.getBalance(eth.accounts[0])
- en: Public Testnet Faucet
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 公共测试网络水龙头
- en: In addition to the testnet coins, you can get additional testnet coins via a
    faucet, just as you did with bitcoin. Go to [https://faucet.ropsten.be/](https://faucet.ropsten.be/)
    , as shown in Figure [5-20](#Fig20), and request coins to your wallet address
    set in Mist.![../images/475651_1_En_5_Chapter/475651_1_En_5_Fig20_HTML.jpg](../images/475651_1_En_5_Chapter/475651_1_En_5_Fig20_HTML.jpg)
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 除了测试网货币外，你还可以通过水龙头获得额外的测试网货币，正如你用比特币所做的那样。访问[https://faucet.ropsten.be/](https://faucet.ropsten.be/)，如图[5-20](#Fig20)所示，请求将硬币发送到你设置在Mist中的钱包地址！[../images/475651_1_En_5_Chapter/475651_1_En_5_Fig20_HTML.jpg](../images/475651_1_En_5_Chapter/475651_1_En_5_Fig20_HTML.jpg)
- en: Figure 5-20
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-20
- en: Ropsten Ethereum faucet
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Ropsten以太坊水龙头
- en: Ethereum Mainnet
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 以太坊主网
- en: From the Ganache console, you were able to publish to a public testnet network
    (Ropsten). The next step is to publish to the Ethereum mainnet  . To do so, you
    will restart Geth and connect this time to the mainnet.> geth --fast --cache=512Just
    as with the public testnet, you will have to wait for Geth to sync. Once syncing
    is complete, you can call the Truffle migrate command to deploy, and as before,
    you need your account to have ether coins.> truffle migrate --reset
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 从Ganache控制台，你能够发布到一个公共测试网网络（Ropsten）。下一步是发布到以太坊主网。为此，你需要重新启动Geth，这次连接到主网。> geth
    --fast --cache=512就像公共测试网一样，你得等待Geth同步完成。一旦同步完成，你可以调用Truffle migrate命令来部署，和之前一样，你需要你的账户有以太币硬币。>
    truffle migrate --reset
- en: Recommended Tools for Smart Contracts
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 推荐用于智能合约的工具
- en: In this chapter, I covered Ganache, Solidity, IntelliJ, Truffle, Geth, Remix,
    and MetaMask; however, there are other tools worth mentioning.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我介绍了Ganache、Solidity、IntelliJ、Truffle、Geth、Remix和MetaMask；然而，还有其他值得提及的工具。
- en: '*Solium*: Solidity code cleaning solution'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Solium*：Solidity代码清理解决方案'
- en: '*conteract.io*: Interacting with smart contracts'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*conteract.io*：与智能合约互动'
- en: '*Populus*: Development framework for Ethereum smart contracts'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Populus*：适用于以太坊智能合约的开发框架'
- en: '*Parity*: Light-weight Ethereum node'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Parity*：轻量级以太坊节点'
- en: '*Drizzle*: Front-end dapp solution'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Drizzle*：前端dapp解决方案'
- en: Summary
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, I covered how to utilize Ganache to simulate a full-node Ethereum
    client. You installed Ganache, and once you were able to connect to the Ganache
    CLI, you were able to create a network and listen to a port. You learned how to
    use the IntelliJ IDEA plugin for Solidity to easily develop smart contracts with
    autocomplete and highlights. You also learned about the Truffle Suite and how
    to create your own smart contracts using the command-line wizard. You connected
    Truffle to the Ganache network and then created a “Hello, World” smart contract
    as well as “MD5SmartContract” smart contract.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我介绍了如何使用Ganache来模拟一个完整的以太坊客户端。你安装了Ganache，一旦你能够连接到Ganache CLI，你就可以创建一个网络并监听一个端口。你学会了如何使用IntelliJ
    IDEA插件 for Solidity以轻松地开发带有自动补全和高亮功能的智能合约。你还了解了Truffle套件以及如何使用命令行向导创建自己的智能合约。你把Truffle连接到Ganache网络，然后创建了一个“Hello,
    World”智能合约以及一个“MD5SmartContract”智能合约。
- en: Once you created your contracts, you were able to migrate your smart contract
    utilizing the Truffle deployment process. You compiled and deployed your smart
    contract code with Truffle to your development network. Then, you used the Truffle
    console to interact with your smart contract via the Truffle CLI. Next, you created
    a private Ethereum blockchain with Geth and initialized the blockchain. You utilize
    the Geth console and mined pretend Ethereum on your Geth private testnet.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了你的合约，你就可以使用Truffle部署过程将你的智能合约迁移。你使用Truffle编译并部署你的智能合约代码到你的开发网络。然后，你使用Truffle控制台通过Truffle
    CLI与你的智能合约互动。接下来，你使用Geth创建了一个私有的以太坊区块链并初始化了这个区块链。你使用Geth控制台并在你的Geth私有测试网上挖出了假以太坊。
- en: Next, you deployed your Remix web3.js to the Geth private testnet you created,
    as well as deployed your Truffle contracts. In addition, you looked at some useful
    Geth commands that will help you while developing smart contracts. You connected
    your Mist Ethereum wallet to the private Geth network you created and were able
    to interact with your smart contract. You were able to use MetaMask in your browser
    as a replacement for a desktop client.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你把你用Remix web3.js部署到你自己创建的Geth私有测试网，以及部署你的Truffle合约。此外，你看了一些在开发智能合约时会有帮助的Geth命令。你把你用的Mist以太坊钱包连接到你创建的私有Geth网络，并能够与你的智能合约互动。你能够在你浏览器的MetaMask中使用MetaMask作为桌面客户端的替代品。
- en: Once you were able to see your contract working, you set a public testnet and
    synced blocks as well as got coins via a faucet. Lastly, you learned how to migrate
    your code to the Ethereum mainnet.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你能够看到你的合约在运行，你就设置了一个公共测试网络，并同步区块以及通过水龙头获取硬币。最后，你学会了如何将你的代码迁移到以太坊主网。
- en: In next chapters, you will learn how to build front-end code for smart contracts
    and publish a complete dapp.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，你将学习如何为智能合约构建前端代码并发布一个完整的去中心化应用（dapp）。
