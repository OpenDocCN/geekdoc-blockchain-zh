- en: © Elad Elrom 2019Elad ElromThe Blockchain Developer[https://doi.org/10.1007/978-1-4842-4847-8_5](https://doi.org/10.1007/978-1-4842-4847-8_5)
  prefs: []
  type: TYPE_NORMAL
- en: 5. Ethereum Wallets and Smart Contracts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Elad Elrom^([1](#Aff2) )(1)New York, NY, USA
  prefs: []
  type: TYPE_NORMAL
- en: In Chapter [1](475651_1_En_1_Chapter.xhtml), I introduced Ethereum when I covered
    bitcoin, altcoins, and different consensus mechanisms. Specifically, I covered
    Ethereum’s PoW consensus and how utilizing Ethereum enables developers to create
    their own smart contracts and tokens. I mentioned that the Ethereum tokens can
    be generated as Ethereum requests for comment (ERCs) such as ERC-20, ERC-223,
    or ERC-777\. In Chapter [3](475651_1_En_3_Chapter.xhtml), you created your own
    blockchain, and I covered bitcoin wallets and transactions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, I will be expanding on Ethereum in more detail. Ethereum allows
    you to create code (*smart contracts*) to handle funds utilizing blockchain technology
    to overcome downtime and third-party interference. The Ethereum platform is mostly
    credited to Vitalik Buterin and Gavin Wood. According to the Ethereum web site,
    the definition of Ethereum is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*“Ethereum is a decentralized platform that runs smart contracts: applications
    that run exactly as programmed without any possibility of downtime, censorship,
    fraud or third-party interference.”*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —Ethereum.org
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In previous chapters, you were able to pass and store data such as the bitcoin
    colored coins use case with the OP_RETURN param. This is useful because you’re
    able to generate an MD5 hash of a file and store it on bitcoin’s network. The
    MD5 you stored could be of a document, a contract, or anything you want. However,
    as you saw, bitcoin is limited to only storing the information, and you were unable
    to interact with the data. Specifically, you are able to pass and store data on
    the network, but you are unable to run code against your file such as to perform
    operations against your data. Ethereum solves this lack of functionality by allowing
    you to create a smart contract utilizing the power of blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Smart contracts are programmable code used to handle funds. The code runs on
    its own, absent of the need of third parties. Solidity is a popular Ethereum contact-oriented
    programming language and can be used to write smart contracts and deploy the code
    on multiple blockchains.
  prefs: []
  type: TYPE_NORMAL
- en: At the heart of Ethereum is the Ethereum Virtual Machine (EVM). The EVM is where
    the smart contracts run in Ethereum. A good way to help you understand the EVM
    is to think about the EVM as a distributed global computer where the smart contracts
    can be executed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The EVM is a distributed global computer to run arbitrary, algorithmic, complex
    code. More simply, the EVM consists of all the nodes in the Ethereum network connected
    as a singular consensus and able to take a smart contract’s code, process it,
    and execute it. The EVM uses 256 bits as the fundamental consensus mechanism;
    it can handle a 1 TB block, and the standard block time is 15 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Decentralized application developers write smart contracts and then run the
    code on the EVM with the help of front-end code. See Figure [5-1](#Fig1). The
    EVM executes the code in parallel connections on all the connected Ethereum nodes.
    This ensures the consensus of the nodes. The size of the Ethereum blockchain can
    be as big as 1 TB at the time of writing versus bitcoin’s block height, which
    is limited to 4 MB per block. Additionally, bitcoin takes about 10 minutes to
    create a new block versus 15 seconds on the EVM.
  prefs: []
  type: TYPE_NORMAL
- en: Although it is advantageous for the decentralized code to run as a singular
    consensus, there are also drawbacks. For instance, the smart contract’s code is
    slower and more expensive than a traditional computer as it runs on all nodes.![../images/475651_1_En_5_Chapter/475651_1_En_5_Fig1_HTML.jpg](../images/475651_1_En_5_Chapter/475651_1_En_5_Fig1_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5-1
  prefs: []
  type: TYPE_NORMAL
- en: 'Ethereum 10,000-foot perspective. Photo credit: xbt.net.'
  prefs: []
  type: TYPE_NORMAL
- en: To run an Ethereum miner, you need to run a full-node EVM. The miners are running
    a PoW consensus mechanism to verify transactions just like bitcoin. During the
    mining process, five coins are mined on every block. Just as you saw with NEO
    in Chapter [1](475651_1_En_1_Chapter.xhtml), the Ethereum miners get paid for
    running smart contracts with Ethereum coins, which get changed into what is called
    *gas*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ethereum gas is a fraction of an Ethereum token. Ethereum gas is changed and
    used by the contract to pay the miner for their efforts. Think of a car. It needs
    gas to operate, and so does Ethereum. Absent Ethereum gas, you cannot execute
    the smart contract.
  prefs: []
  type: TYPE_NORMAL
- en: Because Ethereum offers the ability to build interesting applications, the platform
    has been acknowledged for its potential and is utilized in one way or another
    by Microsoft, Intel, Amazon, J.P. Morgan, and even governments. This has turned
    Ethereum into an extensive ecosystem with many options to choose from to help
    you create your smart contracts easily. You can choose from a large number of
    development tools, apps communicating with other tools, best practices, infrastructure,
    testing, security, monitoring tools, and much more.
  prefs: []
  type: TYPE_NORMAL
- en: 'It can be overwhelming and confusing to choose tools to use, especially when
    many of the tools are still in alpha, beta, or not fully tested. However, keep
    in mind that by now you are already equipped with a good fundamental understanding
    of blockchain technologies, including transactions, wallets, and how it all works.
    Additionally, the blockchain you developed in Chapter [3](475651_1_En_3_Chapter.xhtml)
    was in JavaScript utilizing Node.js, which is fundamental for many Ethereum tools.
    There are two lists that I recommend you bookmark, listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/ConsenSys/ethereum-developer-tools-list](https://github.com/ConsenSys/ethereum-developer-tools-list)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/ConsenSys/ethereum-developer-tools-list/blob/master/EcosystemResources.md](https://github.com/ConsenSys/ethereum-developer-tools-list/blob/master/EcosystemResources.md)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These resources provide an extensive list of all the development tools and resources
    related to Ethereum. It’s beyond the scope of this book to cover all these different
    tools, but I recommend you review these tools at some point if you focus on Ethereum
    development so you can make your own determination about which tool fits your
    project best.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I will be focusing on Ethereum smart contracts and running
    them on a testnet, just as you have done in the previous chapters for bitcoin.
    I will show how to set up your development tools and IDE and give you basic information
    for dapp mainnet deployment, which I will expand upon in later chapters in this
    book.
  prefs: []
  type: TYPE_NORMAL
- en: Ganache Simulated Full-Node Client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ganache (previously known as ethereumjs-testrpc) allows you to run a simulated
    full-node client of Ethereum on your machine and to interact with your contract
    via a CLI. This tool is useful because you will be setting up a development network
    and a private testnet network to test your smart contract code.
  prefs: []
  type: TYPE_NORMAL
- en: Just as you saw in the previous chapter, setting up a testnet network allows
    you to test your code with pretend money before committing your code to mainnet.
    I decided to use Ganache in this chapter as it is part of the Truffle development
    suite and integrates well with Truffle.
  prefs: []
  type: TYPE_NORMAL
- en: Install Ganache
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To get started, you can install Ganache globally with npm and confirm it’s
    working correctly by calling the help command.> npm install -g ganache-cli> ganache-cli
    helpIf you have installation issues or want to get more information regarding
    the tool, visit the Ganache GitHub page: [https://github.com/trufflesuite/ganache-cli](https://github.com/trufflesuite/ganache-cli)
    . You can also check the version of CLI by running this command:> ganache-cli
    -v'
  prefs: []
  type: TYPE_NORMAL
- en: 'This command outputs the version. At the time of writing, the Ganache CLI is
    version v6.4.3 (ganache-core: 2.5.5).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Ganache CLI: Listen to Port'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can run Ganache on your machine while you develop and debug your contracts.
    To do this, you set up the Ganache CLI in Terminal to listen to the port you will
    be setting in truffle.js later in this chapter.> ganache-cli -p 8584Notice that
    at this point there is nothing running on port 8584, so let’s assume you will
    be setting up port 8584\. The command should output the following:Listening on
    127.0.0.1:8584
  prefs: []
  type: TYPE_NORMAL
- en: IntelliJ IDEA Plugin for Solidity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Chapter [3](475651_1_En_3_Chapter.xhtml), you downloaded and used WebStorm
    as your IDE to develop your blockchain. WebStorm is a subset of IntelliJ IDEA
    and has a plugin for the Solidity language, which provides an easy way to write
    your contracts. Also, it provides highlights and code completion to make development
    easier. You can use the WebStorm version you previously installed and just add
    the Solidity plugin. To do so, first download the plugin here: [https://plugins.jetbrains.com/plugin/9475-intellij-solidity](https://plugins.jetbrains.com/plugin/9475-intellij-solidity)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the plugin installed, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select WebStorm ➤ Preferences (or press command + ,).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Plugins.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '3.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Search in “Plugins” for “*Solidity*”. It will say “No Plugins founds.” With
    a link to “Search in repositories”. Click the “Search in repositories” link. “Intellij-Solidity”
    plugin will show. See Figure [5-2](#Fig2).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '4.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Install both “Intellij-Solidity” plugins: LANGUAGES and INSPECTION. See Figure
    [5-2](#Fig2).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 5.Click IntelliJ-Solidity ➤ install. See Figure [5-2](#Fig2).![../images/475651_1_En_5_Chapter/475651_1_En_5_Fig2_HTML.jpg](../images/475651_1_En_5_Chapter/475651_1_En_5_Fig2_HTML.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 5-2
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Installing IntelliJ-Solidity and Solidity Solhint in WebStorm
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '6.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under Plugins search for Solidity Solhint. It will say “No Plugins founds.”
    With a link to “Search in repositories”. Click the “Search in repositories” link.
    Click Solidity Solhint INSPECTION ➤ and then click Install.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '7.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Restart WebStorm.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note that if you are a Visual Studio fan, there is also a Solidity extension
    for Visual Studio; see [https://marketplace.visualstudio.com/items?itemName=ConsenSys.Solidity](https://marketplace.visualstudio.com/items%253FitemName%253DConsenSys.Solidity)
    . At the time of writing, the plugin works only for Visual Studio 2015 or earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that, as always, you can use your favorite IDE, text editor, or
    even vim to write your code; there’s no need to buy an IDE.
  prefs: []
  type: TYPE_NORMAL
- en: Truffle Suite
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will be using Truffle as it’s one of the most popular tools and has integrated
    libraries that help expedite the development cycle. Truffle Suite includes Truffle,
    Ganache, and Drizzle; see Figure [5-3](#Fig3).
  prefs: []
  type: TYPE_NORMAL
- en: '*“Truffle is a development environment, testing framework and asset pipeline
    for Ethereum, aiming to make life as an Ethereum developer easier.”*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*—* [https://github.com/trufflesuite/truffle](https://github.com/trufflesuite/truffle)'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The Truffle documentation includes installation instructions, which can be found
    at [https://truffleframework.com/docs](https://truffleframework.com/docs) .![../images/475651_1_En_5_Chapter/475651_1_En_5_Fig3_HTML.jpg](../images/475651_1_En_5_Chapter/475651_1_En_5_Fig3_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5-3
  prefs: []
  type: TYPE_NORMAL
- en: Truffle Suite documentation
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, open a new Terminal window and install Truffle globally on
    your machine (at the time of writing, the current Truffle version is 5.0.14).
    Then ensure it’s installed correctly by running the help command to view a list
    of all available commands.> npm install -g truffle+ truffle@5.0.14> truffle helpTruffle
    v5.0.14 - a development framework for EthereumUsage: truffle <command> [options]'
  prefs: []
  type: TYPE_NORMAL
- en: Create Your Smart Contracts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To get started, let’s create your folder and initialize the Truffle wizard to
    generate all the code needed to get started. In Terminal, type the following:>
    mkdir MySmartContract && cd $_> truffle initThese commands create a folder named
    MySmartContract and change the directory location to the new project; then the
    truffle init command initializes the project. You can see the output in Figure
    [5-4](#Fig4).![../images/475651_1_En_5_Chapter/475651_1_En_5_Fig4_HTML.jpg](../images/475651_1_En_5_Chapter/475651_1_En_5_Fig4_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5-4
  prefs: []
  type: TYPE_NORMAL
- en: Creating the MySmartContract project and initializing with the truffle init
    command
  prefs: []
  type: TYPE_NORMAL
- en: Next, open WebStorm and open the project you created by selecting File ➤ Open.
    Navigate to the MySmartContract project directory and click Open. WebStorm will
    open the project, as shown in Figure [5-5](#Fig5).![../images/475651_1_En_5_Chapter/475651_1_En_5_Fig5_HTML.jpg](../images/475651_1_En_5_Chapter/475651_1_En_5_Fig5_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5-5
  prefs: []
  type: TYPE_NORMAL
- en: MySmartContract open in WebStorm
  prefs: []
  type: TYPE_NORMAL
- en: EVM supports many programming languages such as Solidity, JavaScript, GO, C++,
    Python, Java, Ruby, Web Assembly, Rust, and Haskell. In this section, you will
    be using Solidity as it’s the most popular Ethereum programming language for smart
    contracts at the time of writing. Solidity is based on ECMAScript and influenced
    by JavaScript, C++, and Python. Solidity has an advantage as you are able to deploy
    your smart contract transactions on other various blockchain platforms beside
    Ethereum, such as Ethereum Classic, Tendermint, ErisDB, and Counterparty.
  prefs: []
  type: TYPE_NORMAL
- en: Solidity uses the .sol file extension; in fact, if you check in the contracts
    folder of your project, you will find a file called Migrations.sol, as shown in
    Figure [5-5](#Fig5). This file was generated automatically for you when you initialized
    the Truffle wizard. The migration files help you deploy contracts to the Ethereum
    network. As your project progresses, you will create new migration files.
  prefs: []
  type: TYPE_NORMAL
- en: Connect Truffle to the Ganache Network
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Next, you will customize your environment by calling your network development
    and setting the URL and port. As you recall, you are already running Ganache and
    have programmed your network to listen on 127.0.0.1, port 8584\. You’ll use these
    settings for deploying your contracts on your Ethereum blockchain network.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, open MySmartContract/truffle-config.js and inside the network
    object add a development object with these configuration settings:module.exports
    = {    networks: {        development: {            host: "127.0.0.1",            port:
    8584,            network_id: "∗",            gas: 4712388,            gasPrice:
    100000000000        }}You set the host, port, and network ID, as well as the gas
    and gasPrice parameters. The following is according to Truffle docs ( [https://truffleframework.com/docs/truffle/reference/configuration#networks](https://truffleframework.com/docs/truffle/reference/configuration%2523networks)
    ):'
  prefs: []
  type: TYPE_NORMAL
- en: 'gas: This is the gas limit used for deploys. The default is 4712388.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'gasPrice: This is the gas price used for deploys. The default is 100000000000
    (100 Shannon).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You are setting the default values, which you can achieve also by omitting the
    gas and gasPrice tags; however, for the live mainnet network, at the time of writing,
    I recommend setting a 21,000 gas price that is a reasonable value. Check the ETH
    Gas Station ( [https://ethgasstation.info/](https://ethgasstation.info/) ) to
    figure out how much the gasPrice value should be, as shown in Figure [5-6](#Fig6).![../images/475651_1_En_5_Chapter/475651_1_En_5_Fig6_HTML.jpg](../images/475651_1_En_5_Chapter/475651_1_En_5_Fig6_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5-6
  prefs: []
  type: TYPE_NORMAL
- en: Ethgasstation.info calculates a recommended gas price
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, at the time of writing, paying a fiat of $0.014 provides a standard
    5.6 transaction time.
  prefs: []
  type: TYPE_NORMAL
- en: You have set up a development environment only; however, as you move your code
    from development to a public testnet network and then production, you can add
    more environments to the truffle-config.js file.
  prefs: []
  type: TYPE_NORMAL
- en: “Hello, World” Smart Contract
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As mentioned, smart contracts are account objects on the Ethereum blockchain;
    you can write functions to interact with other contracts, send coins, make decisions,
    and store data. Generally speaking, the contracts are built to be decentralized;
    however, keep in mind they can be programmed with a regulated option, making them
    centralized. For instance, the Ethereum Gemini dollar has the option to freeze
    transactions or even reverse them, and other coins can be built with a self-destruct
    function by the owner.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll start by creating a simple “Hello, World” contract. This is the minimum
    code, and the intention here is not to create anything useful but to help you
    understand how to create a smart contract.
  prefs: []
  type: TYPE_NORMAL
- en: In Terminal, at the project location, create a new contract and call it HelloWorldContract
    using the command truffle.> truffle create contract HelloWorldContract
  prefs: []
  type: TYPE_NORMAL
- en: If the CLI worked correctly and without errors, it doesn’t output anything.
  prefs: []
  type: TYPE_NORMAL
- en: Next, open the contract you created; it will show up under contracts/HelloWorldContract.sol.
    As you can see, the Truffle wizard created your contract for you.
  prefs: []
  type: TYPE_NORMAL
- en: This first smart contract is a minimal working example; it just holds a message
    and allows you to retrieve the message by calling your main function. Replace
    the existing code in contracts/HelloWorldContract.sol with the following below;pragma
    solidity ^0.5.0;contract HelloWorldContract {  string greeting;  constructor()
    public {    greeting = 'Hello World';  }  function greet() public view returns
    (string memory) {    return greeting;  }}
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, Solidity scripting is similar to JavaScript or C++, and it’s
    easy to read. The first line of code is the Solidity compiler version; you will
    be using 0.5.0\. In the HelloWorldContract constructor  , you are setting the
    greeting variable to 'Hello World'. The main function is greet(). Once you call
    the main function, you can retrieve the value of the greeting variable.
  prefs: []
  type: TYPE_NORMAL
- en: “MD5SmartContract” Smart Contract
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you will create a second contract that is more practical. This contact will
    allow you to store the MD5 hash you stored in the previous chapter, but this time
    you will be able to interact with it instead of just storing the MD5 data on the
    blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: In Terminal, at the project level, create a new contract called MD5SmartContract
    using the command truffle.> truffle create contract MD5SmartContractNext, open
    the contract you created called contracts/RegisterContract.sol. You will be running
    the following contact:pragma solidity ^0.5.0;contract MD5SmartContract {  bytes32
    public signature;  event signEvent(bytes32 signature);  constructor() public {  }  function
    sign(string memory document) public {    signature = sha256(bytes(document));    emit
    signEvent(signature);  }}
  prefs: []
  type: TYPE_NORMAL
- en: The code creates a variable call signature. Then your main function signs your
    document. You pass the document MD5, and using SHA256, you sign the document.
    You create an event to get dispatched once you sign your document.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Secure Hash Algorithm (SHA) is one of a number of cryptographic hash functions.
    A cryptographic hash function acts as a signature for text or data; it is one-way
    and cannot be decrypted. The generated SHA256 hash is a fixed-size, 256 bits (32
    bytes), and almost unique.
  prefs: []
  type: TYPE_NORMAL
- en: Create Truffle Migration Files for Your Smart Contract Deployment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As mentioned, Truffle migration files help you deploy your contracts on the
    Ethereum network. You will create a migration file for your deployment. To do
    so, create a new deployment file; call it 2_deploy_contracts.js, and place the
    file here: migrations/2_deploy_contracts.js. You can point to the smart contract
    code you created as follows:const HelloWorldContract = artifacts.require("HelloWorldContract.sol");module.exports
    = function(deployer) {    deployer.deploy(HelloWorldContract);};Create another
    deployment file, called 3_deploy_contracts.js, and place the file here: migrations/3_deploy_contracts.js.const
    MD5SmartContract = artifacts.require("MD5SmartContract.sol");module.exports =
    function(deployer) {    deployer.deploy(MD5SmartContract);};At this point, your
    project includes two smart contracts and migration files. You can compare your
    project directory and files with mine; see Figure [5-7](#Fig7).![../images/475651_1_En_5_Chapter/475651_1_En_5_Fig7_HTML.jpg](../images/475651_1_En_5_Chapter/475651_1_En_5_Fig7_HTML.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5-7
  prefs: []
  type: TYPE_NORMAL
- en: MySmartContract including two smart contracts and migration files
  prefs: []
  type: TYPE_NORMAL
- en: Another technique for lazier developers is to use the Truffle create wizard
    to generate the migration file.> truffle create migration deploy_my_contract
  prefs: []
  type: TYPE_NORMAL
- en: This command generates the migration file automatically for you.
  prefs: []
  type: TYPE_NORMAL
- en: Compile Your Smart Contract with Truffle
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In a separate Terminal window, you will run Truffle to compile your smart contract.
    The compile command  turns your Solidity code to bytecode, which can be interpreted
    by the EVM. For now, Ganache simulates the EVM.> truffle compileYou can see your
    contract’s bytecode in the JSON file found here: build/contracts/HelloWorldContract.json
    and build/contracts/MD5SmartContract.json. Look for the bytecode tag shown here:"bytecode":
    "0x608060405234801561001057600080fd5b5061031...",'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Keep in mind that ideally you should delete the contract’s contracts/∗.json
    file manually before compiling again. This will ensure the latest code gets compiled
    because the CLI does not always recognize changes right away.
  prefs: []
  type: TYPE_NORMAL
- en: Deploy the Smart Contract to Your Development Network
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you have bytecode compiled from your smart contract, you can migrate
    the bytecode into your development environment so you can run the migration command
    to switch to the network you set in the truffle.js file.> truffle migrate --network
    developmentRunning this command will return the response shown in Figure [5-8](#Fig8).
    This shows you that three migration files have been deployed successfully on the
    network. You have a successful deployment for each contract.![../images/475651_1_En_5_Chapter/475651_1_En_5_Fig8_HTML.jpg](../images/475651_1_En_5_Chapter/475651_1_En_5_Fig8_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5-8
  prefs: []
  type: TYPE_NORMAL
- en: Truffle migrate command response
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that the --reset flag is useful when you change your code, as you
    need to recompile, and re-deploy.> truffle migrate --reset
  prefs: []
  type: TYPE_NORMAL
- en: Truffle Console
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that your contract has been deployed to your development network you can
    communicate with your smart contract via the Truffle CLI. To do so, you can open
    a console and connect it to your development network.> truffle console --network
    developmentOnce you run the console command  , your Terminal shows you are in
    Truffle CLI development mode.truffle(development)>
  prefs: []
  type: TYPE_NORMAL
- en: To get out of CLI mode, click Control+C twice or type .exit in the console.
  prefs: []
  type: TYPE_NORMAL
- en: Interact with Your Smart Contract via the Truffle CLI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You set two variables, hello and sign, for your smart contracts so that you
    can interact with them.truffle(development)> HelloWorldContract.deployed().then(_app
    => { hello = _app })undefinedtruffle(development)> MD5SmartContract.deployed().then(_app
    => { doc = _app })undefinedTo interact with your HelloWorldContract contract,
    you can call the main public function you created because you exposed the function
    greet.truffle(development)> hello.greet()'Hello World'Similarly, you can interact
    with the MD5SmartContract.sol contract. You will pass the same MD5 hash you generated
    in Chapter [3](475651_1_En_3_Chapter.xhtml) (634ef85e038cea45bd20900fc97e09dc)
    and call your main function called sign. That function will generate an SHA256
    hash, as shown in Figure [5-9](#Fig9).truffle(development)> doc.sign('634ef85e038cea45bd20900fc97e09dc')![../images/475651_1_En_5_Chapter/475651_1_En_5_Fig9_HTML.jpg](../images/475651_1_En_5_Chapter/475651_1_En_5_Fig9_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5-9
  prefs: []
  type: TYPE_NORMAL
- en: Creating a doc.sign transaction
  prefs: []
  type: TYPE_NORMAL
- en: Now you can confirm that you have an SHA256 hash by calling the signature function;
    see the output in Figure [5-10](#Fig10).truffle(development)> doc.signature()'0x7869cd540ff8c3b2635ec87251f361e21ad3c72fbc2f79897b9816bec54b0a48'![../images/475651_1_En_5_Chapter/475651_1_En_5_Fig10_HTML.jpg](../images/475651_1_En_5_Chapter/475651_1_En_5_Fig10_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5-10
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with the MD5SmartContract smart contract to produce a signature
  prefs: []
  type: TYPE_NORMAL
- en: 'You can download the entire smart contract project from here: [https://github.com/Apress/the-blockchain-developer/chapter5/step1/](https://github.com/Apress/the-blockchain-developer/chapter5/step1/)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Compile with Remix
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far you used the Truffle tools, Ganache network, and WebStorm IDE to create,
    compile, deploy, and interact with your contract; however, there is another even
    easier way. Remix offers an online IDE that can do the same as WebStorm and Truffle.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see this work, go to the Remix site: [https://remix.ethereum.org](https://remix.ethereum.org)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Paste in the “Hello, World” smart contract code from your example. Ensure that
    the right-side panel is set to the correct compiler; you will be using “Current
    version:0.4.22.” Then click “Start to compile (Ctrl-S).” See Figure [5-11](#Fig11).![../images/475651_1_En_5_Chapter/475651_1_En_5_Fig11_HTML.jpg](../images/475651_1_En_5_Chapter/475651_1_En_5_Fig11_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5-11
  prefs: []
  type: TYPE_NORMAL
- en: “Hello, World” smart contract
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder in your project and name it remix; then create a file and
    name it HelloWorldContract.js. Click the Details button in Remix Online IDE and
    copy and paste the WEB3DEPLOY content into the HelloWorldRemix.js file you created,
    as shown in Figure [5-12](#Fig12).![../images/475651_1_En_5_Chapter/475651_1_En_5_Fig12_HTML.jpg](../images/475651_1_En_5_Chapter/475651_1_En_5_Fig12_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5-12
  prefs: []
  type: TYPE_NORMAL
- en: “Hello, World” smart contract WEB3DEPLOY code
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: web3.js is Ethereum JavaScript API; its libraries allow you to interact with
    an Ethereum node via an HTTP or IPC connection. The WEB3DEPLOY code can be deployed
    on a local or remote node.
  prefs: []
  type: TYPE_NORMAL
- en: Private Ethereum Blockchain with Geth
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have interacted with your smart contract on your local machine. Next, it’s
    advisable to run a full node and test your smart contract on a testnet blockchain;
    this tests it in a more realistic environment. Geth offers a full Ethereum node
    implemented in Go that you can run locally. This private testnet will allow you
    to develop and test your current smart contract in isolation from the real Ethereum
    blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, first install Geth using Brew.> brew tap ethereum/ethereum>
    brew install ethereumTo ensure installation went well, run the --version command
    for the current Geth version (I am using 1.8.27 at the time of writing).> geth
    versionVersion: 1.8.27-stable'
  prefs: []
  type: TYPE_NORMAL
- en: Initialized Geth Private Blockchain
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that you have Geth installed, you will create your first block, or block
    0, which is called the *genesis* block  . Create a file called genesis_block.json
    and place it in the project root. For now just paste the provided JSON, but note
    that you can generate a custom genesis block with the Python script found here:
    [https://blog.ethereum.org/2015/07/27/final-steps/](https://blog.ethereum.org/2015/07/27/final-steps/)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the scope of this book, you will use this script and set a low difficulty
    of 1000 and gas limit of 1000000 for easy mining and low gas fees; however, feel
    free to adjust as needed in your own experiments. See genesis_block.json.{  "config":
    {  "chainId": 1,  "homesteadBlock": 0,  "eip155Block": 0,  "eip158Block": 0},  "difficulty":
    "0x1000",  "gasLimit": "0x1000000",    "alloc": {      "0x44dc998cbc1c7504bec0a96af4a9aef6606a768a":      {"balance":
    "0x1337000000000000000000"}    }}Next you will create your private testnet. In
    Terminal, run this command:> geth --identity "MyTestNet" --nodiscover --networkid
    1999 --datadir testnet-blockchain init genesis_block.jsonYou will need an account
    for your testnet-blockchain; use the account command. Select a simple password
    as you are running a local test network, but on mainnet you need to be mindful
    of security; here I’m choosing password 123.> geth account new --datadir testnet-blockchainPassphrase:
    123Repeat passphrase: 123Address: { a8eceb3e2dd7af9c6fdb12edd8a7e84290932c2d}As
    you can see, you received a wallet address after picking a password. You can compare
    your output with mine, as shown in Figure [5-13](#Fig13).![../images/475651_1_En_5_Chapter/475651_1_En_5_Fig13_HTML.jpg](../images/475651_1_En_5_Chapter/475651_1_En_5_Fig13_HTML.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5-13
  prefs: []
  type: TYPE_NORMAL
- en: Creating a private testnet and wallet with Geth
  prefs: []
  type: TYPE_NORMAL
- en: Geth Console
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you have your account set and testnet-blockchain chain, you can open
    a Geth console to interact with the chain.> geth --identity "MyTestNet" --datadir
    testnet-blockchain --nodiscover --networkid 1999 console 2>> geth.log
  prefs: []
  type: TYPE_NORMAL
- en: Notice that I used the 2>> geth.log param to output the logs into a custom file
    location. Once the Geth console starts, you can run the eth.syncing command  to
    check the current block being synced. In this case, it will return false because
    there is nothing to sync; you are starting from block 0 on a local network.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will receive a pop-up alert asking you the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*“Do you want the application “geth” to accept incoming network connections?
    Clicking Deny may limit the application’s behaviour. This setting can be changed
    in the Firewall pane of Security & Privacy preferences.” Select “Allow”.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Next, in the Geth terminal, run the syncing command.geth> eth.syncingfalseIf
    you run the eth.blockNumber command  , it will return a zero as you have not mined
    any blocks yet.geth> eth.blockNumber0
  prefs: []
  type: TYPE_NORMAL
- en: Mine Ethereum for Your Private Testnet
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can then confirm you have a balance in your account with the getBalance
    command.geth> eth.getBalance(eth.accounts[0])0With the eth.accounts command, you
    will get the new account you created.geth> eth.accounts["0xa2a6d8fe7e39645613e74fe19c79071ee52009ba"]You
    can either generate or mine ether coins on the private Ethereum chain you created.
    Regardless, you need to know how to mine coins, because you will need transactions
    to be included in mined blocks as you test your code. To start mining, just run
    the miner.start command  .geth> miner.start()nullSimilarly, to stop mining, simply
    run the miner.stop command  .> miner.stop()nullIf you let the mining run, you
    will mine some blocks, so when you check the block number, you will now see results
    as well as funds.geth> eth.blockNumber1672geth> eth.getBalance(eth.accounts[0])8.36e+21
  prefs: []
  type: TYPE_NORMAL
- en: Deploy Remix to Geth
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that your node is synced and you know how to mine, you can deploy your
    contracts to the testnet. First, you need to unlock your main Geth account to
    be able to use it. Ensure your account holds a balance; otherwise, you won’t be
    able to deploy your contract on the network. On Geth, unlock your account with
    your password so Geth can use it.geth> personal.unlockAccount(eth.accounts[0],
    "123", 24∗3600)trueI used the password 123, but you need to change it to your
    password if you used a different password. Next, load the web3.js script you generated
    on Remix.> loadScript("remix/HelloWorldContract.js")null [object Object]trueIt
    takes a few seconds to mine the next block and include this contract; once it’s
    mined, you will receive the following message:Contract mined! address: 0x9905f1663f1b808d52dca42ce26e0d2648f8be07
    transactionHash: 0x66b80787eb3eae16c9535a1bd86ff1a623c1914ac9ffc2addde74655aed09157If
    you are not seeing this message, make sure you are mining.geth> miner.start()Once
    the contact is mined, you will get the following message in Terminal, which includes
    the address and transaction hash:Contract mined! address: 0xe49da16551c5c5735de46e07e8ab9e713310a13b
    transactionHash: 0x36d3ec593f63280ca6aae1b079bfb6f00eea719468e04960643c23f39cbef5b3'
  prefs: []
  type: TYPE_NORMAL
- en: Deploy Truffle to Geth
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Similarly, to deploy the web3.js contract’s script via Truffle, you run the
    migrate --reset command. The --reset flag tells Truffle to run all the migrations
    from the beginning. Ensure you use .exit to exit the Truffle console prior to
    running the migrate command. Truffle will compile your contract automatically.truffle(development)>
    .exit> truffle migrate --resetUsing network 'development'.Network up to date.Now
    you can open a development console again.> truffle console --network developmenttruffle(development)>
    HelloWorldContract.deployed().then(_app => { hello = _app })undefinedtruffle(development)>
    hello.greet() 'Hello World'
  prefs: []
  type: TYPE_NORMAL
- en: 'The contract is redeployed, and you can interact with your contract again.
    You can download this step from here: [https://github.com/Apress/the-blockchain-developer/chapter5/step2/](https://github.com/Apress/the-blockchain-developer/chapter5/step2/)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Useful Commands in Geth
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can stop the Geth process by pressing Command+C and then exit, or you can
    stop the process via aux to check whether there are any processes open. Or you
    can use the killall command  to stop the process.> ps aux | grep geth> killall
    -HUP gethAt any time, you can run the help flag to get a list of commands.> geth
    –helpTo get a list of the pending transactions, run the following:> geth --identity
    "MyTestNet" --datadir testnet-blockchain --nodiscover --networkid 1999 console
    2>> geth.loggeth> eth.pendingTransactionsTo remove your locally synced blockchain
    data from the public testnet, use this:geth> geth removedbTo remove your private
    blockchain testnet data, use this:geth> geth removedb --datadir test-net-blockchainTo
    synchronize the blockchain more quickly, use the  --fast flag to perform a fast
    Ethereum sync. Note that you will not retain the past transaction data with this
    command. The cache flag sets the cache limit.geth> geth --fast --cache=1024
  prefs: []
  type: TYPE_NORMAL
- en: Connect the Mist Ethereum Wallet to Your Private Network
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It would be useful to have a wallet to connect to your private network. That’s
    where Mist is helpful. You can connect your private blockchain to Mist and perform
    transactions, conducting realistic transactions as if people were using your contracts.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, download Mist from here: [https://github.com/ethereum/mist/releases](https://github.com/ethereum/mist/releases)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: For Mac, the file to download is called Mist-macosx-0-11-1.dmg at the time of
    writing. Note that you can also achieve the same results with an Ethereum wallet,
    which you can download from the same URL.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you will be starting Mist and connecting it to your testnet blockchain.
    At the command line, point to Mist’s location and the geth.ipc database.> /Applications/Mist.app/Contents/MacOS/Mist
    --rpc /[project location]/MySmartContract/testnet-blockchain/geth.ipcMist opens
    and shows your active account and balance, as shown in Figure [5-14](#Fig14).![../images/475651_1_En_5_Chapter/475651_1_En_5_Fig14_HTML.jpg](../images/475651_1_En_5_Chapter/475651_1_En_5_Fig14_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5-14
  prefs: []
  type: TYPE_NORMAL
- en: Mist active account and balance
  prefs: []
  type: TYPE_NORMAL
- en: Others to Interact with Your Smart Contract
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once the contract is published, anyone can use the address and application binary
    interface (ABI) to connect and interact with the contract. You can start and interact
    with your contract as if an actual person is using your contract prior to publishing
    it to mainnet.
  prefs: []
  type: TYPE_NORMAL
- en: Mist is a desktop app that can be used for testing. To watch a contract, in
    Mist, click the Contracts link at the top right and then click Watch Contract,
    as shown in Figure [5-15](#Fig15).![../images/475651_1_En_5_Chapter/475651_1_En_5_Fig15_HTML.jpg](../images/475651_1_En_5_Chapter/475651_1_En_5_Fig15_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5-15
  prefs: []
  type: TYPE_NORMAL
- en: Mist’s Watch Contract button
  prefs: []
  type: TYPE_NORMAL
- en: For others to run your contract, they need two things.
  prefs: []
  type: TYPE_NORMAL
- en: Contract address
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application binary interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An ABI describes the contract’s functions. This description is needed in order
    to know how to call the function. Think of it as a user manual.
  prefs: []
  type: TYPE_NORMAL
- en: You can retrieve the contract address, as shown here:truffle(development)>var
    hello = HelloWorldContract.deployed().then(_app => { hello = _app })truffle(development)>hello.address'0x0b4f69f88390bc8cec93e730128a5e5c5dffd56c'Similarly,
    you can retrieve the contract’s ABI with this command:truffle(development)>JSON.stringify(hello.abi)'[{"inputs":[],"payable":false,"stateMutability":"nonpayable","type":"constructor","signature"
    '[{"inputs":[],"payable":false,"stateMutability":"nonpayable","type":"constructor","signature":"constructor"},{"constant":true,"inputs":[],"name":"greet","outputs":[{"name":"","type":"string"}],"payable":false,"stateMutability":"view","type":"function","signature":"0xcfae3217"}]'Then
    pass the contract address and ABI in Mist, as shown in Figure [5-16](#Fig16).![../images/475651_1_En_5_Chapter/475651_1_En_5_Fig16_HTML.jpg](../images/475651_1_En_5_Chapter/475651_1_En_5_Fig16_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5-16
  prefs: []
  type: TYPE_NORMAL
- en: Passing info in Mist
  prefs: []
  type: TYPE_NORMAL
- en: Notice that you omit the single quote from the ABI and address before pasting
    it into Mist.
  prefs: []
  type: TYPE_NORMAL
- en: Now click OK, and you can see your contract in the watched contracts list. See
    Figure [5-17](#Fig17).![../images/475651_1_En_5_Chapter/475651_1_En_5_Fig17_HTML.jpg](../images/475651_1_En_5_Chapter/475651_1_En_5_Fig17_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5-17
  prefs: []
  type: TYPE_NORMAL
- en: Mist’s watched contracts
  prefs: []
  type: TYPE_NORMAL
- en: You have your contract in Mist, and you can interact with it, send funds, listen
    to events, and interact with functions, just as users will interact with your
    contract on mainnet.
  prefs: []
  type: TYPE_NORMAL
- en: MetaMask
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Similar to Mist, another way to interact with your contracts, without even downloading
    a desktop app, is in your Chrome or Firefox browser with a plugin called MetaMask.
    Just as with Mist, you can utilize MetaMask to connect your contract to mainnet,
    a public testnet, and a local blockchain (such as the one you created with Ganache),
    or you can even connect to Truffle Develop. To get started, download the MetaMask
    plugin for Chrome or Firefox.
  prefs: []
  type: TYPE_NORMAL
- en: '*Chrome Web Store*: [https://chrome.google.com/webstore/detail/metamask/nkbihfbeogaeaoehlefnkodbefgpgknn](https://chrome.google.com/webstore/detail/metamask/nkbihfbeogaeaoehlefnkodbefgpgknn)
    . Click the Add to Chrome button. See Figure [5-18](#Fig18).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Firefox Add-ons page*: [https://addons.mozilla.org/en-US/firefox/addon/ether-metamask](https://addons.mozilla.org/en-US/firefox/addon/ether-metamask)
    . Click the Add to Firefox button.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![../images/475651_1_En_5_Chapter/475651_1_En_5_Fig18_HTML.jpg](../images/475651_1_En_5_Chapter/475651_1_En_5_Fig18_HTML.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-18
  prefs: []
  type: TYPE_NORMAL
- en: MetaMask beta Chrome add-on
  prefs: []
  type: TYPE_NORMAL
- en: Click the MetaMask icon and then the Continue button. Next, select a password,
    accept the terms, save your secret backup phrase, and create your account.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the account is created, you have an option in the top drop-down of
    which network to connect to, as shown in Figure [5-19](#Fig19).![../images/475651_1_En_5_Chapter/475651_1_En_5_Fig19_HTML.jpg](../images/475651_1_En_5_Chapter/475651_1_En_5_Fig19_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5-19
  prefs: []
  type: TYPE_NORMAL
- en: MetaMask beta Chrome network drop-down
  prefs: []
  type: TYPE_NORMAL
- en: As you might recall, you programmed the truffle.js values to set a network on
    localhost port 8584, which matches the default network; however, you can set a
    custom RPC or connect to testnet or mainnet.
  prefs: []
  type: TYPE_NORMAL
- en: For more information regarding connecting Truffle with Metamask, visit the Truffle
    framework docs;
  prefs: []
  type: TYPE_NORMAL
- en: '[https://truffleframework.com/docs/truffle/getting-started/truffle-with-metamask](https://truffleframework.com/docs/truffle/getting-started/truffle-with-metamask)'
  prefs: []
  type: TYPE_NORMAL
- en: Public Testnet
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you are able to run your smart contract on a development network, you
    can take an additional step prior to going to mainnet. You can run your contract
    on a public testnet network.
  prefs: []
  type: TYPE_NORMAL
- en: Syncing Blocks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are three well-known testnets: Ropsten, Kovan, and Rinkeby. You can program
    Geth to connect to a testnet with the --testnet flag, which will connect to the
    public testnet network (Ropsten).> geth --testnet --syncmode "fast" --cache=512
    console'
  prefs: []
  type: TYPE_NORMAL
- en: As before, the rpc flag is needed to accept the Geth RPC connections and for
    Truffle to be able to connect to Geth. You are also setting it to fast sync and
    limiting the cache size to 512\. This command includes starting the Geth console.
  prefs: []
  type: TYPE_NORMAL
- en: 'To check the status of the syncing command, use this:geth> eth.syncing{  currentBlock:
    1011878,  highestBlock: 3569550,  knownStates: 2058862,  pulledStates: 2056745,  startingBlock:
    968873}'
  prefs: []
  type: TYPE_NORMAL
- en: Once complete, the syncing command  will return false. Keep in mind that there
    are millions of state entries and 3,569,550 blocks at the time of writing, which
    could take hours depending on your connection speed. The currentBlock value is
    the current block being retrieved out of a total number of blocks (the highest
    block). This can give you an idea of how long the download will take.
  prefs: []
  type: TYPE_NORMAL
- en: As you recall, you can check current block number being sync by running the
    eth.blockNumber command in a Geth console, as well as check your balance in your
    account to see whether it has been updated yet.> eth.blockNumber> eth.getBalance(eth.accounts[0])
  prefs: []
  type: TYPE_NORMAL
- en: Public Testnet Faucet
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In addition to the testnet coins, you can get additional testnet coins via a
    faucet, just as you did with bitcoin. Go to [https://faucet.ropsten.be/](https://faucet.ropsten.be/)
    , as shown in Figure [5-20](#Fig20), and request coins to your wallet address
    set in Mist.![../images/475651_1_En_5_Chapter/475651_1_En_5_Fig20_HTML.jpg](../images/475651_1_En_5_Chapter/475651_1_En_5_Fig20_HTML.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5-20
  prefs: []
  type: TYPE_NORMAL
- en: Ropsten Ethereum faucet
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum Mainnet
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From the Ganache console, you were able to publish to a public testnet network
    (Ropsten). The next step is to publish to the Ethereum mainnet  . To do so, you
    will restart Geth and connect this time to the mainnet.> geth --fast --cache=512Just
    as with the public testnet, you will have to wait for Geth to sync. Once syncing
    is complete, you can call the Truffle migrate command to deploy, and as before,
    you need your account to have ether coins.> truffle migrate --reset
  prefs: []
  type: TYPE_NORMAL
- en: Recommended Tools for Smart Contracts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, I covered Ganache, Solidity, IntelliJ, Truffle, Geth, Remix,
    and MetaMask; however, there are other tools worth mentioning.
  prefs: []
  type: TYPE_NORMAL
- en: '*Solium*: Solidity code cleaning solution'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*conteract.io*: Interacting with smart contracts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Populus*: Development framework for Ethereum smart contracts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Parity*: Light-weight Ethereum node'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Drizzle*: Front-end dapp solution'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, I covered how to utilize Ganache to simulate a full-node Ethereum
    client. You installed Ganache, and once you were able to connect to the Ganache
    CLI, you were able to create a network and listen to a port. You learned how to
    use the IntelliJ IDEA plugin for Solidity to easily develop smart contracts with
    autocomplete and highlights. You also learned about the Truffle Suite and how
    to create your own smart contracts using the command-line wizard. You connected
    Truffle to the Ganache network and then created a “Hello, World” smart contract
    as well as “MD5SmartContract” smart contract.
  prefs: []
  type: TYPE_NORMAL
- en: Once you created your contracts, you were able to migrate your smart contract
    utilizing the Truffle deployment process. You compiled and deployed your smart
    contract code with Truffle to your development network. Then, you used the Truffle
    console to interact with your smart contract via the Truffle CLI. Next, you created
    a private Ethereum blockchain with Geth and initialized the blockchain. You utilize
    the Geth console and mined pretend Ethereum on your Geth private testnet.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you deployed your Remix web3.js to the Geth private testnet you created,
    as well as deployed your Truffle contracts. In addition, you looked at some useful
    Geth commands that will help you while developing smart contracts. You connected
    your Mist Ethereum wallet to the private Geth network you created and were able
    to interact with your smart contract. You were able to use MetaMask in your browser
    as a replacement for a desktop client.
  prefs: []
  type: TYPE_NORMAL
- en: Once you were able to see your contract working, you set a public testnet and
    synced blocks as well as got coins via a faucet. Lastly, you learned how to migrate
    your code to the Ethereum mainnet.
  prefs: []
  type: TYPE_NORMAL
- en: In next chapters, you will learn how to build front-end code for smart contracts
    and publish a complete dapp.
  prefs: []
  type: TYPE_NORMAL
