- en: Part 4\.
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第4部分
- en: '[Part 4](#part04) is aimed at readers who are eager to build their own Dapp
    and are planning to deploy it onto MAINNET, the production Ethereum network. [Chapter
    13](kindle_split_027.xhtml#ch13) covers important operational aspects, such as
    event logging and contract upgradeability. You’ll go through different techniques
    that allow you to amend a deployed contract after discovering a bug or security
    vulnerability. [Chapter 14](kindle_split_028.xhtml#ch14) is entirely focused on
    security and describes common vulnerabilities and typical forms of smart contract
    attack. [Chapter 15](kindle_split_029.xhtml#ch15) is for all readers who want
    to keep learning about Ethereum and blockchain technology in general. It gives
    an overview of alternative Ethereum implementations aimed at enterprise use. It
    also briefly presents other blockchain and distributed ledger platforms. You’ll
    have plenty of options to consider if you want to continue your journey beyond
    Ethereum.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '[第4部分](#part04) 针对那些急于构建自己的Dapp并计划将其部署到以太坊主网（MAINNET，生产以太坊网络）的读者。 [第13章](kindle_split_027.xhtml#ch13)
    涵盖了重要的运营方面，例如事件日志和合约的可升级性。您将了解不同的技术，这些技术允许您在发现错误或安全漏洞后修改已部署的合约。 [第14章](kindle_split_028.xhtml#ch14)
    完全专注于安全性，并描述常见的漏洞和智能合约攻击的典型形式。 [第15章](kindle_split_029.xhtml#ch15) 适合所有希望继续学习以太坊和区块链技术一般内容的读者。它概述了针对企业使用的不同以太坊实现。它还简要介绍了其他区块链和分布式账本平台。如果您想继续超越以太坊的旅程，您将有很多选择可以考虑。'
- en: Chapter 13\. Making a Dapp production ready
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第13章. 使Dapp达到生产准备状态
- en: '|  |'
  id: totrans-3
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**This chapter covers**'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章内容**'
- en: How to generate event logs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何生成事件日志
- en: How to upgrade your libraries after deploying them
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署库后如何升级
- en: How to upgrade your contracts after deploying them
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署后如何升级您的合约
- en: '|  |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: In the previous chapter, you built an end-to-end Dapp from scratch for the first
    time, using most of the knowledge you’d acquired throughout the book and most
    of the available Ethereum development tools. Although it was a good exercise that
    helped you to consolidate your Ethereum development skills, you might not be ready
    to deploy your first Dapp into the public production network. Before doing so,
    you might want to consider strengthening your Dapp so it can cope with real-world
    operational requirements, such as being able to generate, store (on the blockchain),
    and query (from the blockchain) event logs; upgrade your libraries after deploying
    them; and upgrade your contracts after deploying them.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，您第一次从零开始构建了一个完整的Dapp，使用了您在整本书中学到的知识，以及大多数可用的以太坊开发工具。尽管这是一个很好的练习，有助于您巩固以太坊开发技能，但您可能还没有准备好将您的第一个Dapp部署到公共生产网络。在这样做之前，您可能想要考虑加强您的Dapp，使其能够处理现实世界的运营需求，例如能够生成、在区块链上存储和在区块链上查询事件日志；在部署后升级您的库；在部署后升级您的合约。
- en: I’ve already touched on some of these topics briefly, but in this chapter, I’ll
    revisit them in more detail. I’ll keep my usual pragmatic approach, and I’ll walk
    you through examples and code. Designing an upgradeable library or contract, though,
    requires advanced techniques whose implementation touches Solidity syntax that’s
    outside the scope of this book. But I still believe you should be aware of the
    concepts, which I’ll try to explain by sketching some contract or sequence diagrams.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经简要接触过这些主题中的某些内容，但在这一章中，我将更详细地重新讨论它们。我将保持我通常的务实方法，并通过示例和代码引导您。设计一个可升级的库或合约，尽管需要高级技术，其实施触及了超出本书范围的Solidity语法。但我仍然认为您应该了解这些概念，我将尝试通过绘制一些合约或序列图来说明它们。
- en: You might be surprised I haven’t included security in the list. I consider it
    such an important topic that I’m dedicating the entire next chapter to it.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会惊讶我没有把安全性包括在内。我认为这是一个如此重要的主题，以至于我打算用下一整章来专门介绍它。
- en: 13.1\. Event logging
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.1. 事件日志
- en: Let’s start with event logging. You already know how to declare and raise events
    on smart contracts. In the previous chapter, you saw how to handle contract events
    from a web UI.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从事件日志开始。您已经知道如何在智能合约上声明和引发事件。在上一章中，您看到了如何从Web UI处理合约事件。
- en: For example, you refreshed the workflow status description at the top of both
    admin and voter pages every time you moved to a new step of the voting process.
    Also, you refreshed the proposals table at the top of the voter page every time
    a voter registered a new proposal. The entire workflow of the proposal registration,
    with related event handling, is illustrated in [figure 13.1](#ch13fig01), which,
    if you remember, is similar to [figure 1.8](kindle_split_012.xhtml#ch01fig08)
    from [chapter 1](kindle_split_012.xhtml#ch01). If you didn’t fully get it in [chapter
    1](kindle_split_012.xhtml#ch01), it should definitely click now.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，每次投票过程移动到新步骤时，你都会在管理员和选民页面的顶部刷新工作流状态描述。另外，每当一个选民注册一个新的提案时，你会在选民页面的顶部刷新提案表格。提案注册的工作流，以及相关的事件处理，如图13.1[所示](#ch13fig01)，如果你还记得，它与第1章的[图1.8](kindle_split_012.xhtml#ch01fig08)非常相似。如果你在第1章没有完全理解，现在应该恍然大悟了。
- en: 'If you’ve done any event-driven or reactive programming before, you might think
    there’s nothing unusual about how contracts publish events and how a client subscribed
    to them, such as a web page, can handle them. But contracts differ in an important
    way: whereas in most languages, events are transient objects that disappear from
    the system after being handled, Ethereum events are logged permanently on the
    blockchain. As a result, you can also retrieve events that happened before starting
    up the UI client, if you want. Curious to see how? Keep reading!'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前做过事件驱动或反应式编程，你可能会认为合约发布事件的方式以及合约的客户端（例如一个网页）处理它们的方式并没有什么不寻常的。但合约在重要方面有所不同：在大多数语言中，事件处理后就会从系统中消失，而以太坊事件则被永久记录在区块链上。因此，如果你想的话，你也可以在启动UI客户端之前检索发生的事件。想知道怎么做吗？继续阅读！
- en: 13.1.1\. Retrieving past events
  id: totrans-16
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.1.1\. 检索过去的事件
- en: 'You’ve already seen how to register listeners of contract events on your JavaScript
    with `eventFilter.watch`. For example, you wrote this code at the top of SimpleVoting.js
    (though I’m slightly simplifying it here) for registering a callback to a workflow
    status change event:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了如何用`eventFilter.watch`在JavaScript上注册合约事件的监听器。例如，你在SimpleVoting.js顶部写了这样的代码来注册一个工作流状态变更事件的回调（虽然这里我稍微简化了一下）：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '***1*** **Sets an event filter listening to events of type WorkflowStatusChangeEvent**'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **设置一个事件过滤器，监听工作流状态变更事件**'
- en: '***2*** **Registers a callback to the event filter**'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **向事件过滤器注册回调**'
- en: Figure 13.1\. Event handling on the voter page. A new proposal is submitted
    from the web page to the voting contract. The contract then fires a `ProposalRegisteredEvent`
    event on registration completion. The event is propagated throughout the network
    until it reaches the node the web page is communicating with. Finally, the webpage
    handles the event, and a new item is added on the proposal table.
  id: totrans-21
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图13.1\. 选民页面的事件处理。从网页提交新的提案到投票合约。合约在注册完成时触发`ProposalRegisteredEvent`事件。事件在整个网络上传播，直到它到达与网页通信的节点。最后，网页处理事件，并在提案表格中添加新条目。
- en: '![](Images/fig13-01_alt.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig13-01_alt.jpg)'
- en: The variable `workflowStatusChangeEvent` is known as an *event filter* because
    it defines the set of events to listen to—in our case, all events of type `WorkflowStatusChangeEvent`.
    As you’ll see later, you can define the filter in a more restrictive way.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`workflowStatusChangeEvent`被称为*事件过滤器*，因为它定义了要监听的事件集合——在我们这个例子中，所有类型为`WorkflowStatusChangeEvent`的事件。正如你稍后看到的，你可以以更严格的方式定义过滤器。
- en: 'When you register a callback to an event filter through `eventFilter.watch`,
    you’ll handle events that take place from the moment the web page is opened. If
    you want to access past events—for example, to verify that all the workflow status
    changes took place in the correct sequence—you can do so through `eventFilter.get`,
    which accepts a similar callback as `watch`. First of all, you must define the
    filter in a slightly different way, by specifying the starting block and final
    block of your event search:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当你通过`eventFilter.watch`为一个事件过滤器注册回调时，你会处理从网页打开时刻开始发生的事件。如果你想访问过去的事件——例如，为了验证工作流状态变更是否按正确的顺序发生——你可以通过`eventFilter.get`来实现，它接受一个与`watch`类似的回调。首先，你必须以稍微不同方式定义过滤器，通过指定事件搜索的起始区块和最终区块：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '***1*** **Only gets the events from block 5000 onwards**'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **只获取区块5000之后的事件**'
- en: 'Then you register the callback to the event filter with `get` rather than `watch`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你用`get`而不是`watch`向事件过滤器注册回调：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '***1*** **Retrieves the past events**'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **检索过去的事件**'
- en: '***2*** **Displays the past event arguments to the console**'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **将过去的事件参数显示在控制台**'
- en: 'If you want to retrieve *all* past events the contract has broadcast, not only
    the `WorkflowStatusChangeEvent` events, you can create the event filter using
    the `allEvents` function, as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想检索*所有*合约广播的过去事件，不仅仅是`WorkflowStatusChangeEvent`事件，你可以使用`allEvents`函数创建事件过滤器，如下所示：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '***1*** **Filter on all event logs raised by the contract since block 1000000**'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **过滤自合约成立以来产生的所有事件日志**'
- en: 'Then you can register a callback on them through `get`, as before:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以通过`get`注册一个回调，就像以前一样：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If you want to retrieve only a subset of past events—for example, only the proposals
    that a certain voter registered—you can perform the search more efficiently by
    indexing some of the parameters of the event in question. You’ll see how in a
    moment.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想检索过去事件的一个子集——例如，某个特定选民注册的提案——你可以通过索引所讨论事件的某些参数，更高效地执行搜索。你马上就会看到如何操作。
- en: 13.1.2\. Event indexing
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.1.2\. 事件索引
- en: When declaring an event on a contract, you can index up to three of its parameters.
    Event filters associated with these parameters will perform much better. For example,
    in the case of SimpleCoin, you might remember from [section 3.5.1](kindle_split_014.xhtml#ch03lev2sec17)
    that the `Transfer` event was defined as
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当在合约上声明一个事件时，你可以索引其中的最多三个参数。与这些参数相关的事件过滤器将表现得更好。例如，在SimpleCoin的情况下，你可能还记得从[第3.5.1节](kindle_split_014.xhtml#ch03lev2sec17)得知`Transfer`事件被定义为
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This allows you to efficiently filter transfer events against specific source
    and destination addresses when retrieving event logs:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许你在检索事件日志时，高效地过滤出针对特定源地址和目标地址的转账事件：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the case of `SimpleVoting`, you might remember that the `ProposalRegisteredEvent`
    event was defined as
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在`SimpleVoting`的情况下，你可能还记得`ProposalRegisteredEvent`事件被定义为
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As it stands, you can’t use this event in a meaningful way as a log. How would
    you modify its definition so that you could query it to provide useful information?
    Think about it for a few seconds.... You could amend it like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，你不能将此事件作为日志以有意义的方式使用。你会如何修改其定义，以便你可以查询它以提供有用的信息？思考几秒钟......你可以这样修改：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As an exercise, here’s a question for you: How would you index this event to
    efficiently retrieve all the proposals that have been registered from a specific
    address? Take your time... Yes, you’re right! Obviously, you’d index the author
    parameter as'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个练习，这里有一个问题供你思考：你会如何索引这个事件，以便高效地检索出特定地址注册的所有提案？慢慢思考...是的，你说得对！显然，你会把作者参数作为**索引**。
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let’s now move to a completely different topic, also important from an operational
    point of view: What do you do when something goes wrong in your contract? Is it
    possible to fix it and redeploy it as you would for a conventional software component,
    such as a library or a microservice? I’ll discuss the answer to that question
    in the next few sections.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们转换到一个完全不同的主题，从操作角度来看这也是非常重要的：当你的合约中出现问题时，你应该怎么做？是否可以像对待传统软件组件（如库或微服务）一样修复它并重新部署？我将在接下来的几节中讨论这个问题的答案。
- en: 13.2\. Designing an upgradeable library
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.2\. 设计可升级的库
- en: 'When developing a new contract, some of your requirements might be similar
    to those of other contracts that other developers have already deployed on the
    blockchain. You saw in [chapter 7](kindle_split_019.xhtml#ch07) how you can place
    common functionality into libraries and reference it from various contracts, therefore
    avoiding wasted reimplementation effort and code duplication. For example, you
    practiced how to perform safe arithmetic operations with a copy of the OpenZeppelin
    SafeMath library. What you did, though, is still not ideal: your deployment of
    OpenZeppelin libraries may be only one of the many instances present on the blockchain.
    Other developers, like you, may have included a copy of such libraries in their
    solution and may have performed their own private deployment, as shown in [figure
    13.2](#ch13fig02).'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当开发一个新的合约时，你的一些要求可能与其他开发者在区块链上已经部署的合约的要求相似。你在[第7章](kindle_split_019.xhtml#ch07)中看到了如何将公共功能放入库中，并从各种合约中引用它，从而避免了重复实现的努力和代码重复。例如，你实践了如何使用OpenZeppelin
    SafeMath库的副本执行安全的算术操作。然而，你所做的一切仍然不是理想的：你部署的OpenZeppelin库可能是区块链上存在的许多实例中的一个。像你这样的其他开发者可能已经将此类库的副本包含在他们的解决方案中，并可能进行了自己的私有部署，如图[13.2](#ch13fig02)所示。
- en: Figure 13.2\. Duplicated deployment of an OpenZeppelin library. Only one client
    contract uses each privately deployed instance.
  id: totrans-51
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 13.2。OpenZeppelin库的重复部署。只有每个私有部署的实例的一个客户端合约使用。
- en: '![](Images/fig13-02_alt.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig13-02_alt.jpg)'
- en: 'You can imagine how many instances of OpenZeppelin libraries are out there
    on TESTNET and MAINNET! The drawbacks of this approach include the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以想象一下在TESTNET和MAINNET上有多少OpenZeppelin库的实例！这种方法的危害包括以下几点：
- en: '*Unnecessary costs*—Each separate deployment of the same library has to pay
    for its own deployment transaction gas fees.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*不必要的成本*——每个相同的库的单独部署都必须支付自己的部署交易燃气费。'
- en: '*Unnecessary bytecode duplication*—The same bytecode is associated on the blockchain
    with different deployment addresses (although nodes in fact deduplicate identical
    bytecode).'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*不必要的字节码复制*——相同的字节码与区块链上的不同部署地址相关联（尽管节点实际上会去重相同的字节码）。'
- en: '*Uncoordinated maintenance*—If a problem in the library is detected, you can’t
    fix it centrally; the owner of each contract instance has to patch it independently,
    with obvious consequences.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*不协调的维护*——如果检测到库中的问题，您不能集中修复它；每个合约实例的所有者必须独立修补，后果显然。'
- en: 'The most obvious solution to these issues is to have one official *golden instance*
    of the library on the blockchain and expect all its clients to reference it at
    that single address, as you saw briefly in [chapter 7](kindle_split_019.xhtml#ch07),
    [section 7.5.2](kindle_split_019.xhtml#ch07lev2sec13). This solution has one major
    drawback: once you’ve deployed a library, you can’t patch it. If you find a problem,
    a new deployment is necessary, with the consequence that all its client contracts
    must also be repointed to the new library address and redeployed, as shown in
    [figure 13.3](#ch13fig03). This is far from an ideal solution!'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题最明显的解决方案是，在区块链上有一个官方的*黄金实例*，并期望所有客户端都引用这个单一地址，正如你在第7章中简要看到的，[7.5.2节](kindle_split_019.xhtml#ch07lev2sec13)。这个解决方案有一个主要缺点：一旦部署了一个库，你就无法修复它。如果你发现一个问题，一个新的部署是必要的，结果是所有客户端合约也必须重新指向新的库地址并重新部署，如图
    13.3 所示。这远非理想的解决方案！
- en: Figure 13.3\. Fixing a shared library means redeploying it at a new address,
    which requires client contracts to be modified and redeployed.
  id: totrans-58
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 13.3。修复共享库意味着将其部署到新地址，这需要修改并重新部署客户端合约。
- en: '![](Images/fig13-03_alt.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig13-03_alt.jpg)'
- en: An elegant solution that Manuel Araoz, CTO of Zeppelin, presented in an article
    on Medium^([[1](#ch13fn01)]) is to create a proxy to the library. His solution
    is a library proxy contract that acts as a layer of indirection between a client
    contract using the library and the library itself, as illustrated in [figure 13.4](#ch13fig04).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一个优雅的解决方案，由Zeppelin的CTO曼努埃尔·阿罗兹在一篇Medium文章中提出（[[1](#ch13fn01)])，是创建一个库的代理。他的解决方案是一个库代理合约，作为使用库的客户端合约与库本身之间的间接层，如图
    13.4 所示。
- en: ¹
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-62
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: See “Proxy Libraries in Solidity,” March 6, 2017, [http://mng.bz/Xgd1](http://mng.bz/Xgd1).
  id: totrans-63
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 参见“Solidity中的代理库”，2017年3月6日，[http://mng.bz/Xgd1](http://mng.bz/Xgd1)。
- en: Figure 13.4\. When you introduce a proxy to the library, client contracts no
    longer directly reference an instance of the library; they communicate with the
    proxy (or library dispatcher), which gets from another contract the latest valid
    address of the library and then forwards calls to the valid instance.
  id: totrans-64
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 13.4。当你向库引入一个代理时，客户端合约不再直接引用库的一个实例；它们与代理（或库调度器）通信，从另一个合约获取库的最新有效地址，然后将调用转发给有效的实例。
- en: '![](Images/fig13-04_alt.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig13-04_alt.jpg)'
- en: 'These are the components of the proxy library solution:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这是代理库解决方案的组件：
- en: A client contract references the address of a library proxy (or dispatcher)
    contract (`SafeMathProxy`) rather than directly referencing an instance of the
    library.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端合约引用的是库代理（或调度器）合约（`SafeMathProxy`）的地址，而不是直接引用库的实例。
- en: The *library proxy* (`SafeMathProxy`) is a contract that retrieves the address
    of the latest valid deployed library instance from a library proxy registry contract
    (`SafeMathProxyRegistry`) and then forwards the call to the latest deployed library
    instance.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*库代理*（`SafeMathProxy`）是一个合约，它从库代理注册合约（`SafeMathProxyRegistry`）中检索最新有效部署的库实例的地址，然后将调用转发到最新部署的库实例。'
- en: The *library proxy registry contract* (`SafeMathProxyRegistry`) is a contract
    containing a list of addresses for different versions of the library. It also
    possibly contains a state variable holding the default address, which is typically
    the latest address that has been added to the list. The library owner updates
    the address list and the default address at each new deployment of the library.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a client contract invokes a library function, it performs a corresponding
    `delegatecall` on the library proxy instead. This retrieves the correct library
    address for the client contract to use from the library proxy registry and then
    performs a `delegatecall` on the relevant instance of the library. From the point
    of view of the client contract, the whole call chain behaves exactly like a normal
    library function invocation.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
- en: Note
  id: totrans-72
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Library functions are implicitly invoked through the `delegatecall` EVM opcode,
    which executes in the context of the caller, as explained in [section 3.2.5](kindle_split_014.xhtml#ch03lev2sec7),
    and as I’ll further explain in [chapter 14](kindle_split_028.xhtml#ch14) on security.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
- en: In summary, if you find that a library you’d like to use provides a proxy, use
    it rather than hardwiring to a specific deployed instance. You’ll gain maintainability.
    The catch, though, is that you must trust the contract owner won’t maliciously
    forward your calls to a new implementation of the library that has nothing to
    do with the original one.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: If you find the idea of designing an upgradeable library interesting and want
    to learn further, I encourage you to review Araoz’s Medium article, where you
    can find code samples.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
- en: Warning
  id: totrans-78
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'You should thoroughly understand the proxy library technique before you attempt
    to implement it; weak implementations have been found subject to malicious attacks.
    I recommend reading the Medium post “Malicious backdoors in Ethereum Proxies,”
    by Patricio Palladino, to make sure you’re aware of the weak spots: [http://mng.bz/vNz1](http://mng.bz/vNz1).'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
- en: 13.3\. Designing an upgradeable contract
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As you might have already guessed, contracts suffer from the same limitation
    as libraries: once you deploy a contract, you’re stuck with it. If you discover
    a bug or security vulnerability after deployment, you can at most freeze it or
    destroy it—if you included this kind of panic button functionality. The best bet
    is to plan for the worst-case scenario beforehand and design your contract with
    built-in upgradeability.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: As in the case of proxy libraries, although this solution makes the contract
    safer from your side, from the point of view of the users, you’re introducing
    a layer of obfuscation. The most security-conscious users might not trust your
    good intentions and might fear the possibility that, all of a sudden, you could
    start redirecting client calls to a malicious contract.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ll illustrate for you these two main techniques for making a contract upgradeable:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Use the same proxy technique I’ve shown you for libraries
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Separate state and logic into two contracts, both inherited from an abstract
    `Upgradeable` contract
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将状态和逻辑分成两个合同，都继承自抽象的`Upgradeable`合同
- en: 13.3.1\. Connecting to the upgraded contract through a proxy
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.3.1\. 通过代理连接到升级后的合同
- en: Imagine various contracts, among which `SimpleCrowdsale`, from [chapters 6](kindle_split_018.xhtml#ch06)
    and [7](kindle_split_019.xhtml#ch07), would like to use your marvelous `SimpleCoin`
    contract. You decide to make `SimpleCoin` upgradeable through a `SimpleCoinProxy`
    contract to avoid headaches not only to you, but also to all of your clients.
    As you can see in [figure 13.5](#ch13fig05), the solution is identical to what
    you saw for SafeMath.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下各种合同，其中`SimpleCrowdsale`，在[第6章](kindle_split_018.xhtml#ch06)和[第7章](kindle_split_019.xhtml#ch07)中，想要使用你神奇的`SimpleCoin`合同。你决定通过一个`SimpleCoinProxy`合同使`SimpleCoin`可升级，以避免给包括你在内的所有客户带来头疼的问题。正如[图13.5](#ch13fig05)所示，这个解决方案与SafeMath中你看到的一致。
- en: Figure 13.5\. If you decide to make `SimpleCoin` upgradeable through `SimpleCoinProxy`,
    client contracts such as `SimpleCrowdsale` will call functions on `SimpleCoinProxy`,
    which will dispatch them to a specific deployed version of `SimpleCoin`, generally
    the latest one.
  id: totrans-89
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图13.5\. 如果你决定通过`SimpleCoinProxy`使`SimpleCoin`可升级，像`SimpleCrowdsale`这样的客户合同将会在`SimpleCoinProxy`上调用函数，它会调度到`SimpleCoin`的具体部署版本，通常是最新版本。
- en: '![](Images/fig13-05_alt.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig13-05_alt.jpg)'
- en: 13.3.2\. Inheriting from an abstract Upgradeable contract
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.3.2\. 从抽象的Upgradeable合同继承
- en: Nick Johnson, the author of ENS, has taken a slightly different approach to
    making a contract upgradeable.^([[2](#ch13fn02)]) He has proposed to split the
    state (storage and Ether) and the
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ENS的创作者Nick Johnson采取了一种略有不同的方法来使合同可升级。^([[2](#ch13fn02)])他提议将状态（存储和以太币）和合同的逻辑分成两个分开的合同，都继承自同一个名为`Upgradeable`的抽象合同：
- en: ²
  id: totrans-93
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ²
- en: ''
  id: totrans-94
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'See “Mad blockchain science: A 100% upgradeable contract,” Reddit+r/ethereum,
    May 24, 2016, [http://mng.bz/y1Yo](http://mng.bz/y1Yo).'
  id: totrans-95
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '参见“Mad blockchain science: A 100% upgradeable contract，” Reddit+r/ethereum，May
    24, 2016， [http://mng.bz/y1Yo](http://mng.bz/y1Yo)。'
- en: 'logic of a contract into two separate contracts, both inherited from a common
    abstract contract called `Upgradeable`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 合同的逻辑分成两个分开的合同，都继承自抽象的`Upgradeable`合同：
- en: '*A dispatcher*—This would hold the state and would dispatch all the calls to
    a target contract through the Solidity `delegatecall()` function (which explicitly
    executes the EVM `delegatecall` opcode). Consequently, the function would execute
    in the context of the dispatcher. You’ll see more about `delegatecall()` in [chapter
    14](kindle_split_028.xhtml#ch14) on security.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*一个调度器*——这将保存状态，并通过Solidity `delegatecall()`函数（执行显式的EVM `delegatecall`操作码）将所有调用调度到目标合同。因此，该函数将在调度器的上下文中执行。你将在[第14章](kindle_split_028.xhtml#ch14)中看到更多关于`delegatecall()`的内容，关于安全方面。'
- en: '*A target* *contract*—You would delegate the entire functionality to this contract,
    which you could upgrade later on. This contract would also control the upgrade
    process.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*一个目标合同* *合同*——你将把全部功能委托给这个合同，以后可以升级。这个合同还将控制升级过程。'
- en: With this design, illustrated in [figure 13.6](#ch13fig06), when the target
    contract got upgraded, the dispatcher would still keep an unaltered state while
    it transferred all the calls to the latest version of the target contract.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如图[13.6](#ch13fig06)所示，在目标合同升级时，调度器仍然保持未更改的状态，同时将所有调用传递到目标合同的最新版本。
- en: 'Figure 13.6\. Upgradeability by splitting a contract into two contracts, both
    inherited from the same abstract `Upgradeable` contract: a dispatcher holding
    the state and a target contract holding the functionality. The dispatcher forwards
    all calls to the target contract. If an upgrade occurs, the dispatcher keeps holding
    the same unaltered state and forwards the calls to the latest version of the target.'
  id: totrans-100
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图13.6\. 通过将合同分成两个继承自同一抽象`Upgradeable`合同的合同来实现升级性：一个保存状态的调度器和一个保存功能的 target contract。调度器将所有调用转发给目标合同。如果发生升级，调度器将保持相同的未更改状态并将调用转发给目标合同的最新版本。
- en: '![](Images/fig13-06_alt.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig13-06_alt.jpg)'
- en: 'If you’re eager to try out this approach, I encourage you to look at Nick’s
    code at [http://mng.bz/4OZD](http://mng.bz/4OZD). If you’re interested in learning
    more about solutions around library or contract upgradeability, I recommend the
    Medium article “Summary of Ethereum Upgradeable Smart Contract R&D,” by Jack Tanner,
    based on his research across all the currently known techniques: [http://mng.bz/QQmR](http://mng.bz/QQmR).'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你急于尝试这种方法，我鼓励你查看尼克在[http://mng.bz/4OZD](http://mng.bz/4OZD)的代码。如果你对围绕库或合约可升级性的解决方案感兴趣，我推荐基于他研究所有目前已知技术的Medium文章“以太坊可升级智能合约研发总结”，作者是杰克·坦纳：[http://mng.bz/QQmR](http://mng.bz/QQmR)。
- en: '|  |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Warning
  id: totrans-104
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: Designing an upgradeable contract using Nick’s technique requires a thorough
    understanding of the inner workings of EVM and EVM assembly, which is outside
    the scope of this book. Also, using an upgradeable contract poses risks, as I
    explained earlier.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 使用尼克的技术设计一个可升级的合约需要对以太坊虚拟机（EVM）及其汇编语言有深入的了解，这超出了本书的范围。此外，使用可升级的合约存在风险，我之前已经解释过了。
- en: '|  |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Summary
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Whereas in most languages events are transient objects that disappear from the
    system after being handled, Ethereum events are logged permanently on the blockchain.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在大多数语言中，事件是短暂的对象，在处理后从系统中消失，而以太坊事件则永久记录在区块链上。
- en: You can replay and query past events by registering a handler on the event filter
    with `get` rather than `watch`.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过在事件过滤器上注册`get`而不是`watch`来重新播放和查询过去的事件。
- en: You can improve the performance of past-event retrieval by indexing some of
    the event parameters when defining the event.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过在定义事件时索引一些事件参数来提高过去事件检索的性能。
- en: You can make a library upgradeable by introducing a proxy to it. Client contracts
    no longer directly reference an instance of the library, but rather communicate
    with the proxy (or library dispatcher), which gets the latest valid address of
    the library from a registry contract and then forwards calls to the valid instance.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过向库中引入代理来使库可升级。客户端合约不再直接引用库的实例，而是与代理（或库调度器）通信，代理从注册合约获取库的最新有效地址，然后将调用转发给有效的实例。
- en: You can make a contract upgradeable by using a proxy contract (as for libraries)
    or by separating state and logic into two contracts, both inherited from an abstract
    `Upgradeable` contract.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过使用代理合约（就像库一样）或将状态和逻辑分离到两个合约中，这两个合约都继承自抽象的`Upgradeable`合约，使合约可升级。
- en: Making a contract upgradeable makes it safer on one hand; for example, if you
    discover a problem after deployment, you can fix the contract and route the calls
    to the new amended version. But it might introduce security risks if you don’t
    implement it correctly.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使合约可升级一方面使其更安全；例如，如果在部署后发现问题，你可以修复合约并将调用路由到新的修订版本。但如果不正确实现，它可能会引入安全风险。
- en: Using an upgradeable library raises security concerns from the point of view
    of the contract user, who might worry about being routed to unintended functionality.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用可升级的库从合约用户的角度来看会引发安全担忧，用户可能会担心被引导到非预期的功能。
- en: Chapter 14\. Security considerations
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第14章。安全考虑
- en: '|  |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**This chapter covers**'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章内容**'
- en: Understanding Solidity weak spots and risks associated with external calls
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Solidity的弱点以及与外部调用的相关风险
- en: Performing safe external calls
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行安全的外部调用
- en: Avoiding known security attacks
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免已知的攻击手段
- en: General security guidelines
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用安全指南
- en: '|  |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: In the previous chapter, I gave you some advice on areas you should look at
    before deploying your Dapp on the production network. I believe security is such
    an important topic that it should be presented separately, so I’ve decided to
    dedicate this entire chapter to it.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我给你提供了一些建议，告诉你部署你的Dapp到生产网络之前应该关注哪些方面。我相信安全是如此重要的话题，应该单独介绍，因此我决定将整章都献给它。
- en: I’ll start by reminding you of some limitations in the Solidity language that,
    if you overlook them, can become security vulnerabilities. Among these limitations,
    I’ll particularly focus on external calls and explain various risks you might
    face when executing them, but I’ll also try to give you some tips for avoiding
    or minimizing such risks. Finally, I’ll present classic attacks that might be
    launched against Ethereum Dapps so that you can avoid costly mistakes, especially
    when Ether is at stake.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我会先提醒你一些在Solidity语言中的限制，如果你忽视它们，它们可能会变成安全漏洞。在这些限制中，我将特别关注外部调用，并解释在执行它们时你可能面临的各种风险，但我也会尝试给你一些避免或最小化这些风险的技巧。最后，我会介绍可能针对以太坊Dapps发起的经典攻击，这样你就可以避免在以太币受到威胁时犯下昂贵的错误。
- en: 14.1\. Understanding general security weak spots
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1. 理解一般的网络安全弱点
- en: 'You should pay attention to certain limitations in the Solidity language because
    they’re generally exploited as the first line of attack by malicious participants
    against unaware developers:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该关注Solidity语言中的一些限制，因为它们通常被恶意参与者作为攻击的第一步，针对不知情的开发者：
- en: '*Data privacy*—If privacy is a requirement, you should store data in encrypted
    form rather than clear form.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据隐私**——如果隐私是一个要求，你应该以加密形式存储数据，而不是明文形式。'
- en: '*Randomness*—Some Dapps, for example, betting games, occasionally need to randomize.
    You must ensure equal processing on all nodes without exposing the application
    to manipulation that takes advantage of the predictability of pseudo-random generators,
    and that can be tricky.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**随机性**——一些Dapps，例如，赌博游戏，偶尔需要随机化。你必须确保在所有节点上进行平等的处理，而不暴露应用程序以利用伪随机生成器的可预测性，这可能会很棘手。'
- en: '*View functions*—You should be aware that functions defined as `view` might
    modify state variables, as mentioned in [chapter 5](kindle_split_017.xhtml#ch05),
    [section 5.3.5](kindle_split_017.xhtml#ch05lev2sec8).'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图函数**——你应该知道定义为`view`的函数可能会修改状态变量，如在第[5章](kindle_split_017.xhtml#ch05)中提到的[5.3.5节](kindle_split_017.xhtml#ch05lev2sec8)。'
- en: '*Gas limits*—You should be careful when setting the gas limits of your transactions,
    whether they’re low or high, because attackers might try to exploit them to their
    advantage.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**燃料限制**——你在设置交易的燃料限制时应该小心，无论它们是低还是高，因为攻击者可能会试图利用它们的优势。'
- en: Some of these vulnerabilities, such as those around randomness, might have more
    severe consequences, such as losing Ether. Other vulnerabilities, such as those
    around gas limits, have less severe consequences; for example, they can be exploited
    for denial of service attacks that can only cause temporary malfunctions. Whether
    they seem severe or not, you shouldn’t underestimate *any* of these vulnerabilities.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 一些漏洞，比如与随机性相关的漏洞，可能会导致更严重的后果，比如丢失以太币。其他的漏洞，比如与燃料限制相关的漏洞，后果不那么严重；例如，它们可以被利用来进行服务拒绝攻击，只能造成暂时的故障。无论它们看起来是否严重，你不应该低估*这些漏洞*中的任何一个。
- en: 14.1.1\. Private information
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.1.1. 私人信息
- en: As you already know, data stored on the blockchain is always public, regardless
    of the level of access of the contract state variables it has been stored against.
    For example, everybody can still see the value of a contract state variable declared
    as private.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所知，存储在区块链上的数据总是公开的，不管它是对合约状态变量的访问级别如何。例如，每个人仍然可以看到被声明为私有的合约状态变量的值。
- en: 'If you need privacy, you need to implement a *hash commit–reveal* scheme like
    the one that the MAINNET ENS domain registration uses, as described in [chapter
    9](kindle_split_022.xhtml#ch09), [section 9.3.2](kindle_split_022.xhtml#ch09lev2sec2).
    For example, to conceal a bid in an auction, the original value must not be submitted.
    Instead, the bid should be structured in two phases, as shown in [figure 14.1](#ch14fig01):'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要隐私，你需要实现一个*哈希提交-揭露*方案，就像MAINNET ENS域名注册使用的那个一样，在第[9章](kindle_split_022.xhtml#ch09)中描述的[9.3.2节](kindle_split_022.xhtml#ch09lev2sec2)。例如，为了在拍卖中隐藏一个出价，原始值不必提交。相反，出价应该分为两个阶段，如图[14.1](#ch14fig01)所示：
- en: '*Hash commit*—You should initially *commit* the hash of the original value,
    and possibly of some unique data identifying the sender.'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**哈希提交**——你首先应该*提交*原始值的哈希，以及可能标识发送者的某些独特数据。'
- en: '*Reveal*—You’ll *reveal* the original value in a second stage, when the auction
    closes and the winner must be determined.'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**揭露**——你在第二阶段*揭露*原始值，那时拍卖结束，必须确定赢家。'
- en: Figure 14.1\. A hash commit–reveal scheme used for auction bid privacy. 1\.
    During the commit phase, you commit a hash of a document containing the sender
    address, the bid value, and a secret instead of the bid value in clear. 2\. During
    the reveal phase you reveal the bid values together with their secrets. 3\. The
    winner is determined by finding the highest revealed bid. You then verify the
    results by calculating the hash from its sender address, bid value, and password
    and comparing it against the previously submitted hash.
  id: totrans-137
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 14.1. 用于拍卖出价隐私的哈希提交-揭示方案。1. 在提交阶段，你提交包含发送者地址、出价值和秘密（而不是明文中的出价值）的文档的哈希。2. 在揭示阶段，你揭示出价值和它们的秘密。3.
    赢家由揭示的最高出价确定。然后你通过计算从其发送者地址、出价值和密码生成的哈希，并与之前提交的哈希进行比较，来验证结果。
- en: '![](Images/fig14-01_alt.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig14-01_alt.jpg)'
- en: 14.1.2\. Randomness
  id: totrans-139
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.1.2. 随机性
- en: If you want the state of your decentralized application to depend on randomness,
    you’ll face the same challenges associated with concealing private information
    that you saw in the previous section. The main concern is preventing miners from
    manipulating randomness to their advantage while also making sure the logic of
    your contract is executed exactly in the same way on all nodes.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望去中心化应用程序的状态依赖于随机性，你将面临与隐藏私有信息相关的相同挑战，如前一部分所述。主要关注的是防止矿工操纵随机性以获得优势，同时确保在所有节点上以完全相同的方式执行你的合约逻辑。
- en: 'Consequently, the way you should handle randomness in a Dapp should be similar
    to the commit–reveal scheme for private data. For example, as you can see in [figure
    14.2](#ch14fig02), in a decentralized roulette game the following should happen:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在 Dapp 中处理随机性的方式应类似于私有数据的提交-揭示方案。例如，如您在[图 14.2](#ch14fig02)中看到的，在去中心化轮盘赌游戏中应该发生以下情况：
- en: All players submit their bets (specific number, color, odd, or pair).
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有玩家提交他们的赌注（特定的数字、颜色、奇数或对）。
- en: A random value provider is requested to supply a random number and, so as to
    keep the number secret until the last moment, the provider initially returns (commits)
    the number encoded using a one-way hash algorithm.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请求随机值提供者提供一个随机数，为了在最后一刻之前保持数字的秘密，提供者最初返回（提交）使用单向哈希算法编码的数字。
- en: The completed transaction, including bets and the generated random number, is
    processed identically by all nodes, which will query the randomness provider for
    the original number associated with the hash. The provider reveals the original
    random number, and the winners are determined. If the randomness provider supplies
    a random number incompatible with the hash, the roulette spinning transaction
    fails.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成的交易，包括赌注和生成的随机数，所有节点都会处理，这些节点将查询随机性提供者与哈希相关联的原始数字。提供者揭示原始随机数，确定赢家。如果随机性提供者提供一个与哈希不兼容的随机数，轮盘赌旋转交易失败。
- en: Figure 14.2\. A hash commit–reveal scheme used for providing reproducible randomness.
    1\. All players submit their bets. 2\. A randomness provider commits the hash
    of a generated random number, emulating a roulette spin. 3\. A transaction, including
    bets and a random number hash, is processed. All nodes query the provider, which
    reveals the random number so that winners and losers can be determined.
  id: totrans-145
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 14.2. 用于提供可复现随机性的哈希提交-揭示方案。1. 所有玩家提交他们的赌注。2. 随机数提供者提交生成的随机数的哈希，模仿轮盘赌的旋转。3.
    处理包括赌注和随机数哈希的交易。所有节点查询提供者，该提供者揭示随机数，以便确定赢家和输家。
- en: '![](Images/fig14-02_alt.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig14-02_alt.jpg)'
- en: 14.1.3\. Calling view functions
  id: totrans-147
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.1.3. 调用视图函数
- en: Defining a function as a `view` doesn’t guarantee that nothing can modify the
    contract state while you’re running it. The compiler doesn’t perform such a check
    (but version 0.5.0 or higher of the Solidity compiler will perform this check),
    nor does the EVM. The compiler will only return a warning. For example, if you
    define the `authorize()` function of SimpleCoin as
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 将函数定义为 `view` 并不能保证在您运行它时合同状态不会被修改。编译器不执行此类检查（但 Solidity 编译器的版本 0.5.0 或更高版本将执行此检查），EVM
    也不执行。编译器只会返回一个警告。例如，如果您定义 SimpleCoin 的 `authorize()` 函数为
- en: '[PRE10]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'you’ll get the following warning, because the state of the allowance mapping
    is being modified:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到以下警告，因为允许映射的状态正在被修改：
- en: '[PRE11]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If the contract state gets modified, a transaction is executed (rather than
    a simple call), and this consumes gas. An attacker might take advantage of the
    fact that the contract owner didn’t foresee gas expenditure for this function
    and might cause consequences, ranging from a few transaction failures to sustained
    DoS attacks. To avoid
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果合同状态被修改，执行交易（而不是简单调用），这会消耗gas。攻击者可能会利用合同所有者没有预见到此功能的gas消耗，可能会导致从几个交易失败到持续的DoS攻击等一系列后果。为了避免
- en: this mistake, you should pay attention to compiler warnings and make sure you
    rectify the code accordingly.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写代码时，你应该注意编译器警告，并确保相应地修正代码。
- en: 14.1.4\. Gas limits
  id: totrans-154
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.1.4\. Gas限制
- en: As you know, to be processed successfully, a transaction must not exceed the
    block gas limit that the sender set. If a transaction fails because it hits the
    gas limit, the state of the contract is reverted, but the sender must pay transaction
    costs, and they don’t get refunded.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所知，为了成功处理，交易发送者设置的区块gas限制不能超过。如果交易失败是因为达到了gas限制，合同状态将回滚，但发送者必须支付交易费用，并且不会退款。
- en: 'The gas limit that the transaction sender sets can be favorable or detrimental
    to security, depending on how it’s used. Here are the two extreme cases, as illustrated
    in [figure 14.3](#ch14fig03):'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 交易发送者设置的gas限制可能对安全有利或不利，这取决于如何使用。以下是对立面案例，如图14.3所示：
- en: '*High gas limit*—This makes it more likely that a transaction completes without
    running out of gas, and it’s safer against attacks trying to fail the transaction
    by blowing the gas limit. On the other hand, a high gas limit allows a malicious
    attacker to manipulate the transaction more easily, because they can use more
    costly resources and computation to alter the expected course of the transaction.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*高gas限制*——这使得交易在不耗尽gas的情况下完成的可能性更大，它对试图通过耗尽gas来失败的攻击更安全。另一方面，高gas限制允许恶意攻击者更容易地操纵交易，因为他们可以利用更昂贵的资源和计算来改变交易的预期流程。'
- en: '*Low gas limit*—This makes it more likely that a transaction can fail to complete
    because it runs out of gas, especially if something unexpected happens. Consequently,
    a transaction would be more exposed to attacks trying to fail it by blowing the
    gas limit. On the other hand, a low gas limit restricts how a malicious attacker
    can manipulate a transaction.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*低gas限制*——这使得交易因为耗尽gas而失败的可能性更大，特别是如果发生意外情况。因此，如果出现意外，交易将更容易受到试图通过耗尽gas来失败的攻击。另一方面，低gas限制限制了恶意攻击者如何操纵交易。'
- en: Figure 14.3\. Pros and cons of high and low gas limits
  id: totrans-159
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图14.3\. 高低gas限制的利弊
- en: '![](Images/fig14-03_alt.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig14-03_alt.jpg)'
- en: In general, the best advice is to set the lowest possible gas limit that allows
    all genuine transactions to be completed against the expected logic. But it’s
    hard to nail a reasonable gas estimate that’s safe for both completion and security.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，最好的建议是设置尽可能低的gas限制，以允许所有真实交易完成预期的逻辑。但是，很难确定一个既安全又能完成交易的合理gas估计。
- en: For example, if the logic executing a transaction includes loops, the transaction
    sender might decide to set a relatively high gas limit to cover the eventuality
    of a high number of loops. But it would be difficult to figure out in advance
    whether the gas limit would be hit, especially if the number of loops was determined
    dynamically and depended on state variables. If any of the state variables were
    subject to user input, an attacker could manipulate them so that the number of
    loops became very big, and the transaction would be more likely to run out of
    gas. Trying to bypass this problem by setting a very high gas limit defeats the
    purpose of the limit itself and isn’t the right solution. In the next few sections,
    we’ll explore correct solutions.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果执行交易的逻辑包含循环，交易发送者可能会决定设置一个相对较高的gas限制，以覆盖循环次数多的可能性。但是，预先判断gas限制是否会达到很难，特别是如果循环次数是动态确定的，并取决于状态变量。如果状态变量中任何一个受到用户输入的影响，攻击者可以操纵它们，使循环次数变得非常大，交易更有可能耗尽gas。通过设置一个非常高的gas限制来试图绕过这个问题，实际上否定了限制本身的目的，这不是正确的解决方案。在接下来的几节中，我们将探讨正确的解决方案。
- en: 14.2\. Understanding risks associated with external calls
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.2\. 理解与外部调用相关的风险
- en: Calls to external contracts introduce several potential threats to your application.
    This section will help you avoid or minimize them.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 对外部合同的调用引入了几个潜在的对您应用程序的威胁。本节将帮助您避免或最小化这些威胁。
- en: The first word of advice is to avoid calling external contracts if you can use
    alternative solutions. External calls transfer the flow of your logic to untrusted
    parties that might be malicious, even if only indirectly. For example, even if
    the external contract you’re calling isn’t malicious, its functions might in turn
    call a malicious contract, as shown in [figure 14.4](#ch14fig04).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 首先的建议是，如果可以使用替代解决方案，则避免调用外部合约。外部调用将您的逻辑流程转移到可能具有恶意的不信任方，即使只是间接的。例如，即使您调用的外部合约本身不是恶意的，其功能可能会进而调用一个恶意合约，如图14.4所示([图14.4](#ch14fig04))。
- en: Figure 14.4\. Your contract might get manipulated by an external malicious contract,
    even when you’re confident the contract it directly interacts with is legit.
  id: totrans-166
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Figure 14.4. 即使您确信与之直接交互的合约是合法的，您的合约仍可能被外部恶意合约操纵。
- en: '![](Images/fig14-04_alt.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig14-04_alt.jpg)'
- en: Because you lose direct control of the execution of your logic, you’re exposed
    to attacks based on *race conditions* and *reentrancy*, which we’ll examine later.
    Also, after the external call is complete, you must be careful about how to handle
    return values, especially in case of exceptions. But often, even if it might feel
    risky, you have no choice but to interact with external contracts, for example,
    at the beginning of a new project, when you want to make quick progress by taking
    advantage of tried and tested components. In that case, the safest approach is
    to learn about the related potential pitfalls and write your code to prevent them—read
    on!
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您失去了对逻辑执行的直接控制，您容易受到基于*竞态条件*和*重入*的攻击，我们稍后会进行探讨。此外，在外部调用完成后，您必须小心处理返回值，尤其是在异常情况下。但是通常，即使可能感觉有风险，您也没有选择，只能与外部合约进行交互，例如，在项目开始时，您希望通过利用经过验证的组件来快速取得进展。在这种情况下，最安全的做法是了解相关的潜在陷阱，并编写代码预防它们——继续阅读！
- en: 14.2.1\. Understanding external call execution types
  id: totrans-169
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.2.1. 理解外部调用执行类型
- en: You can perform external calls to invoke a function on an external contract
    or to send Ether to an external contract. It’s also possible to invoke the execution
    of code while simultaneously transferring Ether. [Table 14.1](#ch14table01) summarizes
    the characteristics of each way of performing an external call.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以执行外部调用以调用外部合约中的函数或向外部合约发送以太币。同时发送以太币并执行代码也是可能的。表14.1总结了执行外部调用的每种方式的特点。
- en: '|  |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Warning
  id: totrans-172
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: Both `send()` and `call()` are becoming obsolete starting with version 0.5 of
    the Solidity compiler.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`send()`和`call()`从Solidity编译器的0.5版本开始逐渐被淘汰。'
- en: '|  |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Table 14.1\. Characteristics of each external call execution type
  id: totrans-175
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Table 14.1. 每种外部调用执行类型的特点
- en: '| Call execution type | Purpose | External function called | Throws exception
    | Execution context | Message object | Gas limit |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| 调用执行类型 | 目的 | 调用的外部函数 | 抛出异常 | 执行上下文 | 消息对象 | 气体限制 |'
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- |'
- en: '| externalContractAddress .send(etherAmount) | Raw Ether transfer | Fallback
    | No | N/A | N/A | 2,300 |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| externalContractAddress .send(etherAmount) | 原始以太币转账 | 回退函数 | 否 | N/A | N/A
    | 2,300 |'
- en: '| externalContractAddress .transfer(etherAmount) | Safe Ether transfer | Fallback
    | Yes | N/A | N/A | 2,300 |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| externalContractAddress .transfer(etherAmount) | 安全的以太币转账 | 回退函数 | 是 | N/A
    | N/A | 2,300 |'
- en: '| externalContractAddress .call.(bytes4(sha3( "externalFunction()"))) | Raw
    function call in context of external contract | Specified function | No | External
    contract | Original msg. | Gas limit of orig. call |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| externalContractAddress .call.(bytes4(sha3( "externalFunction()"))) | 外部合约上下文中的原始函数调用
    | 指定函数 | 否 | 外部合约 | 原始消息 | 原始调用的气体限制 |'
- en: '| externalContractAddress .callcode.(bytes4(sha3( "externalFunction()"))) |
    Raw function call in context of caller | Specified function | No | Calling contract
    | New msg. created by caller | Gas limit of orig. call |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| externalContractAddress .callcode.(bytes4(sha3( "externalFunction()"))) |
    调用者上下文中的原始函数调用 | 指定函数 | 否 | 调用合约 | 调用者创建的新消息 | 原始调用的气体限制 |'
- en: '| externalContractAddress .delegatecall.(bytes4(sha3("externalFunction()")))
    | Raw function call in context of caller | Specified function | No | Calling contract
    | Original msg. | Gas limit of orig. call |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| externalContractAddress .delegatecall.(bytes4(sha3("externalFunction()")))
    | 调用者上下文中的原始函数调用 | 指定函数 | 否 | 调用合约 | 原始消息 | 原始调用的气体限制 |'
- en: '| ExternalContract(external ContractAddress).externalFunction() | Safe function
    call | Specified function | Yes | External contract | Original msg. | Gas limit
    of orig. call |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| ExternalContract(external ContractAddress).externalFunction() | 安全的函数调用 |
    指定函数 | 是 | 外部合约 | 原始消息 | 原始调用的气体限制 |'
- en: 'When using `call()`, `callcode()`, and `delegatecall()`, you can transfer Ether
    simultaneously with the call invocation by specifying the Ether amount with the
    `value` keyword, as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`call()`、`callcode()`和`delegatecall()`时，你可以通过使用`value`关键字指定以太币金额，同时调用调用，如下：
- en: '[PRE12]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'It’s also possible to transfer Ether without calling any function, in this
    way:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以不调用任何函数而纯粹地转移以太币，这样做：
- en: '[PRE13]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This way of sending Ether has advantages and disadvantages: it allows the recipient
    to have a more complex fallback function, but for the same reason, it exposes
    the sender to malicious manipulation. As you can understand from [table 14.1](#ch14table01),
    various aspects of external calls might affect security when performing an external
    call:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这种发送以太币的方式有其优点和缺点：它允许接收者拥有更复杂的后备函数，但出于同样的原因，它也使发送者面临恶意操纵的风险。正如你可以从[表14.1](#ch14table01)理解的那样，外部调用的各个方面可能会在执行外部调用时影响安全性：
- en: What external function can you call?
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以调用哪个外部函数？
- en: Is an exception thrown if the external call fails?
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果外部调用失败，是否会抛出异常？
- en: In which context is the external call executed?
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部调用在什么上下文中执行？
- en: What’s the message object received?
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接收到的消息对象是什么？
- en: What’s the gas limit?
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是气体限制？
- en: Let’s examine them one by one.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一检查它们。
- en: 14.2.2\. What external function can you call?
  id: totrans-195
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.2.2. 你可以调用哪个外部函数？
- en: 'It’s possible to group call execution types into two sets: those only allowing
    you to transfer Ether and those allowing you to call any function.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将调用执行类型分组为两组：一组只允许转移以太币，另一组允许调用任何函数。
- en: Pure Ether transfer
  id: totrans-197
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 纯以太币转移
- en: 'The `send()` and `transfer()` calls can only call (implicitly) the `fallback()`
    function of the external contract, as shown here:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`send()`和`transfer()`调用只能调用（隐式地）外部合约的`fallback()`函数，如下所示：'
- en: '[PRE14]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '***1*** **This is the fallback function, which send() calls implicitly, as
    explained in [section 5.3.2](kindle_split_017.xhtml#ch05lev2sec5).**'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1** **这是一个后备函数，send()会隐式调用，如[5.3.2节](kindle_split_017.xhtml#ch05lev2sec5)所解释的那样。**'
- en: In general, a fallback function can contain logic of any complexity. But `send()`
    and `transfer()`impose a gas limit of 2,300 on the execution of the fallback function
    by transferring only a budget of 2,300 to the external function. This is such
    a low gas limit that, aside from transferring Ether, the fallback function can
    only perform a logging operation.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，后备函数可以包含任何复杂度的逻辑。但`send()`和`transfer()`对后备函数的执行施加了2,300的气体限制，通过只向外部函数预算2,300来执行。这是一个如此低的气体限制，除了转移以太币外，后备函数只能执行日志操作。
- en: 'The low limit reassures the sender against potential *reentrancy* attacks (which
    I’ll describe shortly). It does so because when the control flow is transferred
    to the fallback function, the external contract isn’t able to perform any operations
    other than accepting the Ether transfer. On the other hand, this means you can’t
    use `send()` and `transfer()`if you need to execute any substantial logic around
    the Ether payment. If you haven’t fully understood this point yet, don’t worry:
    it’ll become clear when you learn about reentrancy attacks in the pages that follow.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 低限制确保了发送者免受潜在的*重入*攻击（我稍后会描述）。之所以这样做，是因为当控制流传递给后备函数时，外部合约无法执行除了接受以太币转移之外的其他操作。另一方面，这意味着如果你需要在以太币支付周围执行任何实质性的逻辑，你不能使用`send()`和`transfer()`。如果你还没有完全理解这个观点，不要担心：当你在学习接下来的页面中的重入攻击时，这将变得清晰。
- en: Invocation of custom functions
  id: totrans-203
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 调用自定义函数
- en: All other execution types can invoke custom external functions while transferring
    Ether to the external contract. The downside of such flexibility is that although
    you can associate logic of any complexity with an Ether transfer (thanks to a
    gas limit that can be as high as the sender wishes), the risk of a malicious manipulation
    of the external call, and consequently of diversion of Ether, is also higher.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 所有其他执行类型都可以在向外部合约转移以太币时调用自定义外部函数。这种灵活性的缺点是，尽管你可以将任何复杂度的逻辑与以太币转移关联（感谢可以高达发送者愿望的气体限制），但外部调用的恶意操纵风险，以及因此导致的以太币转移风险，也会更高。
- en: 'As I explained earlier, it’s possible to also purely transfer Ether without
    calling any function, as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前解释的，也可以纯粹地转移以太币而不调用任何函数，如下：
- en: '[PRE15]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This way of sending Ether has the advantages and disadvantages associated with
    external calls through `call()`. The unrestricted gas limit on `call()` allows
    the recipient to have a more complex fallback function that can also access contract
    state, but for the same reason, it exposes the sender to potential malicious external
    manipulation.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`call()`进行外部调用的优缺点都与这种发送以太币的方式有关。`call()`上的无限制燃料限制允许接收方拥有更复杂的回退函数，该函数也可以访问合约状态，但出于同样的原因，它使发送方面临潜在的恶意外部操纵风险。
- en: '|  |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-209
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: The safest way to make an Ether transfer is to execute it through `send()` or
    `transfer()` and consequently to have it completely decoupled from any business
    logic.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以太币转账最安全的方式是通过`send()`或`transfer()`执行，并且相应地使其完全与任何业务逻辑解耦。
- en: '|  |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 14.2.3\. Is an exception thrown if the external call fails?
  id: totrans-212
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.2.3\. 如果外部调用失败，是否会抛出异常？
- en: From the point of view of the behavior when errors occur in external calls,
    you can divide call execution types into raw and safe. I’ll discuss those types
    here and then move on to discuss the different contexts that you can execute calls
    in.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 从外部调用出错时的行为角度来看，你可以将调用执行类型分为原始和安全的。我将在这里讨论这些类型，然后继续讨论可以执行调用的不同上下文。
- en: Raw calls
  id: totrans-214
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原始调用
- en: 'Most call execution types are considered *raw* because if the external function
    throws an exception, they return a Boolean `false` result but don’t revert the
    contract state automatically. Consequently, if no action is taken after the unsuccessful
    call, the state of the calling contract may be incorrect, and any Ether you sent
    will be lost without having produced the expected economic benefit. Here are some
    examples of unhandled external calls:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数调用执行类型都被认为是*原始*的，因为如果外部函数抛出异常，它们会返回一个布尔`false`结果，但不会自动回滚合约状态。因此，如果在失败调用后没有采取任何行动，调用合约的状态可能是不正确的，你发送的任何以太币都会丢失，而没有产生预期的经济效益。以下是一些未处理的外部调用的示例：
- en: '[PRE16]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '***1*** **If send() fails and isn’t handled, etherAmount is lost; the 2,300
    gas budget transferred to the external fallback function is lost.**'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **如果send()失败并且没有处理，以太币金额会丢失；转移到外部回退函数的2,300燃料预算也会丢失。**'
- en: '***2*** **If call() fails and isn’t handled, etherAmount is lost; all the gas
    is transferred to the external fallback function and is lost.**'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **如果call()失败并且没有处理，以太币金额会丢失；所有的燃料都会转移到外部回退函数并且丢失。**'
- en: '***3*** **If externalFunction fails, the etherAmount sent isn’t returned and
    is lost; all the gas transferred to externalFunction is also lost.**'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **如果外部函数失败，发送的以太币金额不会返回并且丢失；转移给外部函数的所有燃料也同样丢失。**'
- en: Following the external call, you have two ways to revert the contract state
    if the call fails. You can use `require` or `revert()`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在外部调用失败后，你有两种方法可以回滚合约状态。你可以使用`require`或`revert()`。
- en: 'The first way to manually revert the state if errors occur is to introduce
    `require()` conditions on some of the state variables. You must design the `require()`
    condition to fail if the external call fails, so the contract state gets reverted
    automatically, as shown in this snippet:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在错误发生时手动回滚状态的第一种方法是引入一些状态变量的`require()`条件。你必须设计`require()`条件，使其在外部调用失败时失败，因此合约状态会自动回滚，如下面的片段所示：
- en: '[PRE17]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '***1*** **Something wrong happens here, and externalFunction throws an exception.**'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **出错了，外部函数抛出了一个异常。**'
- en: '***2*** **An external function is called and following its failure, a Boolean
    false value is returned.**'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **调用了外部函数，在其失败后返回了一个布尔值false。**'
- en: '***3*** **Two require () conditions are set against the Ether balance and the
    state of the contract. If any condition isn’t met, both the Ether balance and
    the contract state are reverted.**'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **针对以太币余额和合约状态设置了两个`require()`条件。如果任何条件不满足，以太币余额和合约状态都会被回滚。**'
- en: 'The second way is to perform explicit checks followed by a call to `revert()`
    if the checks are unsuccessful, as shown in this code:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法是先执行显式的检查，如果检查不成功，则调用`revert()`，如下面的代码所示：
- en: '[PRE18]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '***1*** **Something wrong happens here, and externalFunction throws an exception.**'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **出错了，外部函数抛出了一个异常。**'
- en: Safe calls
  id: totrans-229
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 安全调用
- en: Two types of external calls are considered *safe* in that the failure of the
    external call propagates the exception to the calling code, and this reverts the
    contract state and Ether balance. The first type of safe call is
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种外部调用被认为是*安全的*，因为外部调用的失败会将异常传播到调用代码，并且这将回滚合约状态和以太币余额。安全调用的第一种类型是
- en: '[PRE19]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '***1*** **If transfer() fails, the external failure triggers a local exception,
    which reverts the state and balance of the calling contract.**'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **如果transfer()失败，外部失败将触发一个本地异常，回滚调用合约的状态和余额。**'
- en: 'The second type of safe call is a high-level call to the external contract:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种安全调用类型是对外部合约的高级调用：
- en: '[PRE20]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '***1*** **If externalFunction fails, this triggers a local exception, which
    reverts the state and balance of the calling contract.**'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **如果externalFunction失败，这将触发一个本地异常，回滚调用合约的状态和余额。**'
- en: '|  |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-237
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: Favor safe calls through `transfer()`, for transferring Ether, or through direct
    high-level custom contract functions, for executing logic. Avoid unsafe calls
    such as `send()` for sending Ether and `call()` for executing logic. If a safe
    call fails, the contract state will be reverted cleanly, whereas if an unsafe
    call fails, you’re responsible for handling the error and reverting the state.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 建议通过`transfer()`安全调用进行以太币转账，或通过直接高级自定义合约函数进行逻辑执行。避免使用像`send()`进行以太币发送和`call()`进行逻辑执行的不安全调用。如果安全调用失败，合约状态将干净地回滚，而如果安全调用失败，您需要负责处理错误并回滚状态。
- en: '|  |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 14.2.4\. Which context is the external call executed in?
  id: totrans-240
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.2.4\. 外部调用是在哪个上下文中执行的？
- en: You can execute a call in the *context of the calling contract*, which means
    it affects (and uses) the state of the calling contract. You can also execute
    it in the *context of the external contract*, which means it affects (and uses)
    the state of the external contract.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在*调用合约的上下文中*执行一个调用，这意味着它影响（并使用）调用合约的状态。您还可以在外部合约的*上下文中*执行它，这意味着它影响（并使用）外部合约的状态。
- en: Execution in the context of the external contract
  id: totrans-242
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 外部合约上下文的执行
- en: If you scan through the values in the execution context column of [table 14.1](#ch14table01),
    you’ll realize that most call execution types involve execution in the context
    of the external contract. The code in the following listing shows an external
    call taking place in the context of the external contract.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您浏览[表14.1](#ch14table01)的执行上下文列，您会意识到大多数调用执行类型都涉及在外部合约的上下文中执行。以下列表显示了在外部合约上下文中发生的
    external call。
- en: Listing 14.1\. Example of execution in the context of an external contract
  id: totrans-244
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表14.1\. 外部合约上下文执行示例
- en: '[PRE21]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '***1*** **State variables**'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **状态变量**'
- en: '***2*** **External call performed on ExternalContract.setValue ()**'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **在外部合约.setValue()上执行的外部调用**'
- en: '***3*** **State variables defined on contract A**'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **在合约A上定义的状态变量**'
- en: '***4*** **Modifies ExternalContract.value and sets it to _value**'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **修改ExternalContract.value并将其设置为_value**'
- en: '***5*** **Modifies ExternalContract.msgSender and sets it to the original msg.sender
    sent to contract A**'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **修改ExternalContract.msgSender并将其设置为发送到合约A的原始msg.sender。**'
- en: Through the example illustrated in [figure 14.5](#ch14fig05), I’ll show you
    how the state of `ContractA` and `ExternalContract` change following the external
    call implemented in [listing 14.1](#ch14ex01).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 通过[图14.5](#ch14fig05)所示的例子，我将向你展示如何在外部调用[列表14.1](#ch14ex01)中实现的外部合约调用后，`ContractA`和`ExternalContract`的状态发生变化。
- en: Figure 14.5\. Example illustrating execution in the context of an external contract
  id: totrans-252
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图14.5\. 外部合约上下文执行示例
- en: '![](Images/fig14-05_alt.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig14-05_alt.jpg)'
- en: The addresses of the user and contract accounts used in the example are summarized
    in [table 14.2](#ch14table02).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 例子中使用的用户和合约账户地址总结在[表14.2](#ch14table02)中。
- en: Table 14.2\. User and contract account addresses
  id: totrans-255
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表14.2\. 用户和合约账户地址
- en: '| Account | Address |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| 账户 | 地址 |'
- en: '| --- | --- |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| user1 | 0x1 |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| user1 | 0x1 |'
- en: '| user2 | 0x2 |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| user2 | 0x2 |'
- en: '| ContractA | 0x3 |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| ContractA | 0x3 |'
- en: '| ContractB | 0x4 |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| ContractB | 0x4 |'
- en: '| ExternalContract | 0x5 |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| ExternalContract | 0x5 |'
- en: The initial state of the contracts before the external call takes place is summarized
    in [table 14.3](#ch14table03). The state of the contracts will change to that
    shown in [table 14.4](#ch14table04).
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 外部调用发生前合约的初始状态总结在[表14.3](#ch14table03)中。合约的状态将变为[表14.4](#ch14table04)所示的状态。
- en: Table 14.3\. Initial state of the contracts
  id: totrans-264
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表14.3\. 合约的初始状态
- en: '|  | ContractA | ExternalContract |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '|  | ContractA | ExternalContract |'
- en: '| --- | --- | --- |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Value | 16 | 24 |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| 值 | 16 | 24 |'
- en: 'Now imagine user1 performs the following call on `ContractA`; for example,
    from a web UI, through Web3.js, as you saw in [chapter 12](kindle_split_025.xhtml#ch12):'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一下，user1在`ContractA`上执行以下调用；例如，从一个网络用户界面，通过Web3.js，正如你在[第12章](kindle_split_025.xhtml#ch12)所看到的：
- en: '[PRE22]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Table 14.4\. State of the contracts and `msg` object following an external call
  id: totrans-270
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表14.4. 外部调用之后合同的状态和`msg`对象
- en: '|  | ContractA | ExternalContract |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '|  | ContractA | ExternalContract |'
- en: '| --- | --- | --- |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Value | 16 | **33** |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| 值 | 16 | **33** |'
- en: '| msg sender | 0x1 | **0x1** |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| msg发送者 | 0x1 | **0x1** |'
- en: In summary, the state of `ContractA` hasn’t changed, whereas the state of `ExternalContract`
    has been modified, as shown in [table 14.4](#ch14table04). The `msg` object that
    `ExternalContract` handles is the original `msg` object that user1 generated while
    calling `ContractA`.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，`ContractA`的状态没有改变，而`ExternalContract`的状态却被修改了，正如[表14.4](#ch14table04)所展示的。`ExternalContract`处理的`msg`对象就是用户1在调用`ContractA`时生成的原始`msg`对象。
- en: Execution in the context of the calling contract with delegatecall
  id: totrans-276
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在调用合同中的上下文执行`delegatecall`
- en: Execution through `delegatecall` takes place in context of the calling contract.
    The code in the following listing shows an external call taking place in the context
    of the external contract.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`delegatecall`的执行是在调用合同的上下文中进行的。下列清单中的代码显示了一个外部合同在调用合同的上下文中发生的外部调用。
- en: Listing 14.2\. Example of `delegatecall` execution in the context of a calling
    contract
  id: totrans-278
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 清单14.2. 在调用合同中上下文执行`delegatecall`的例子
- en: '[PRE23]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '***1*** **External call performed on ExternalContract.setValue ()**'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **对外部合同 ExternalContract.setValue () 的调用**'
- en: '***2*** **External call performed on ExternalContract.setValue ()**'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **对外部合同 ExternalContract.setValue () 的调用**'
- en: '***3*** **State variables defined as in ContractA**'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **定义为ContractA的状态变量**'
- en: '***4*** **Modifies ContractA.value and sets it to _value**'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **修改 ContractA.value 并将其设置为 _value**'
- en: '***5*** **Modifies ContractA.msgSender and sets it to the original msg.Sender
    sent to ContractA**'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **修改 ContractA.msgSender 并将其设置为发送到 ContractA 的原始 msg.Sender**'
- en: As I did earlier, through the example illustrated in [figure 14.6](#ch14fig06),
    I’ll show you how the state of `ContractA` and `ExternalContract` change following
    the external call implemented in [listing 14.2](#ch14ex02).
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 像我之前做的那样，通过[图14.6](#ch14fig06)这个例子，我会向你展示在[清单14.2](#ch14ex02)中实现的外部调用之后`ContractA`和`ExternalContract`状态的变化。
- en: Figure 14.6\. Example illustrating `delegatecall` execution in the context of
    the calling contract
  id: totrans-286
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图14.6. 调用合同中执行`delegatecall`的例子
- en: '![](Images/fig14-06_alt.jpg)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig14-06_alt.jpg)'
- en: The initial state of the contracts before the external call takes place is summarized
    in [table 14.5](#ch14table05).
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在外部调用发生之前的合同初始状态总结在[表14.5](#ch14table05)中。
- en: Table 14.5\. Initial state of the contracts
  id: totrans-289
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表14.5. 合同的初始状态
- en: '|  | ContractA | ExternalContract |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '|  | ContractA | ExternalContract |'
- en: '| --- | --- | --- |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Value | 16 | 24 |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| 值 | 16 | 24 |'
- en: 'Now imagine user1 performs the following call on `ContractA`, for example,
    from a web UI:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象用户1在`ContractA`上执行以下调用，例如，从一个网络UI中：
- en: '[PRE24]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In summary, the state of `ContractA` has been modified, whereas the state of
    `External-Contract` hasn’t changed, as shown in [table 14.6](#ch14table06). The
    `msg` object that `External-Contract` handles is still the original `msg` object
    that user1 generated while calling `ContractA`.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，`ContractA`的状态已经被修改，而`ExternalContract`的状态却没有改变，正如[表14.6](#ch14table06)所展示的。`ExternalContract`处理的`msg`对象仍然是用户1在调用`ContractA`时生成的原始`msg`对象。
- en: Table 14.6\. State of the contracts and `msg` object following an external call
    through `delegatecall`
  id: totrans-296
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表14.6. 外部通过`delegatecall`调用之后合同的状态和`msg`对象
- en: '|  | ContractA | ExternalContract |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '|  | ContractA | ExternalContract |'
- en: '| --- | --- | --- |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Value | 33 | 24 |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '| 值 | 33 | 24 |'
- en: '| msg sender | 0x1 | 0x1 |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: '| msg发送者 | 0x1 | 0x1 |'
- en: Execution in the context of the calling contract with callcode
  id: totrans-301
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在调用合同中的上下文执行`callcode`
- en: 'The last case to examine is when the implementation of `ContractA.setValue()`
    uses `callcode` rather than `delegatecall`, as shown here:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个要检查的情况是`ContractA.setValue()`的实现使用了`callcode`而不是`delegatecall`，如下所示：
- en: '[PRE25]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Assuming the same initial state as before, after user1’s call, illustrated in
    [figure 14.7](#ch14fig07), the state of the contracts will be that shown in [table
    14.7](#ch14table07).
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 假设和之前一样的初始状态，在用户1的调用后，如图14.7所示，合同的状态将变为[表14.7](#ch14table07)中所示。
- en: Figure 14.7\. Example illustrating `callcode` execution in the context of the
    calling contract
  id: totrans-305
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图14.7. 调用合同中执行`callcode`的例子
- en: '![](Images/fig14-07_alt.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig14-07_alt.jpg)'
- en: Table 14.7\. State of the contracts following an external call through `callcode`
  id: totrans-307
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表14.7. 通过`callcode`的外部调用之后合同的状态
- en: '|  | ContractA | ExternalContract |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '|  | ContractA | ExternalContract |'
- en: '| --- | --- | --- |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Value | 33 | 24 |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| 值 | 33 | 24 |'
- en: '| msg sender | 0x1 | 0x3 |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| msg发送者 | 0x1 | 0x3 |'
- en: As you can see, an external function that `callcode` calls is still executed
    in the context of the caller, as when the call was performed through `delegatecall`.
    But `ContractA` generates a new `msg` object when the external call takes place,
    and the message sender is `ContractA`.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`callcode`调用的外部函数仍然在调用者的上下文中执行，就像通过`delegatecall`执行调用一样。但是当外部调用发生时，`ContractA`生成了一个新的`msg`对象，消息发送者是`ContractA`。
- en: From a security point of view, execution in the context of the external contract
    is clearly safer than in the context of the calling contract. When execution takes
    place in the context of the calling contract, such as when calling external functions
    through `callcode` or `delegatecall`, the caller is allowing the external contract
    read/write access to its state variables. As you can imagine, it’s safe to do
    so only in limited circumstances-, mainly when the external contract is under
    your direct control (for example, you’re the contract owner). You can find a summary
    of the context and the `msg` object used for each call type in [table 14.8](#ch14table08).
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 从安全角度来看，在调用合约的上下文中执行明显比在外部合约的上下文中执行更安全。当在调用合约的上下文中执行时，例如通过`callcode`或`delegatecall`调用外部函数，调用者允许外部合约对其状态变量进行读/写访问。正如你可以想象，仅在有限的情况下才安全这样做，主要是当外部合约在你的直接控制之下（例如，你是合约所有者）。您可以在[表14.8](#ch14table08)中找到每种调用类型使用的上下文和`msg`对象的总结。
- en: Table 14.8\. Summary of execution context and `msg` object in each call type
  id: totrans-314
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表14.8\. 每种调用类型中执行上下文和`msg`对象的总结
- en: '| Call type | Execution context | msg object |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| 调用类型 | 执行上下文 | msg对象 |'
- en: '| --- | --- | --- |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| call | External contract | Original msg object |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| 调用 | 外部合约 | 原始msg对象 |'
- en: '| delegatecall | Caller contract | Original msg object |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '| delegatecall | 调用者合约 | 原始msg对象 |'
- en: '| callcode | Caller contract | Caller contract-generated msg object |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '| callcode | 调用者合约 | 调用者合约生成的msg对象 |'
- en: '|  |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-321
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: If you need to use `call()`, favor calls through `call()`, in the context of
    the external contract rather than in the context of the calling contract. Bear
    in mind, though, that `call()` will become obsolete starting with version 0.5
    of Solidity.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要使用`call()`，倾向于通过`call()`在外部合约的上下文中调用，而不是在调用合约的上下文中调用。不过，要注意从Solidity 0.5版本开始，`call()`将变得过时。
- en: '|  |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 14.2.5\. What’s the msg object received?
  id: totrans-324
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.2.5\. 接收到的msg对象是什么？
- en: In general, a message object is supposed to flow from its point of creation
    up to the last contract of an external-call chain, which might span several contracts.
    This is true when invoking external calls through all external call types, apart
    from `callcode`, which generates a new message instead, as you saw when comparing
    the external call execution under `callcode` and `delegatecall`. The `delegatecall`
    opcode was introduced as a bug fix for the unwanted message-creating behavior
    of `callcode`. Consequently, you should avoid using `callcode` if possible.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，消息对象应该从其创建点流向外部调用链的最后一个合约，这可能跨越多个合约。当通过所有外部调用类型调用外部调用时，这是正确的，除了`callcode`，它生成一个新的消息，正如你在比较`callcode`和`delegatecall`下的外部调用执行时所看到的那样。`delegatecall`操作码是为了修复`callcode`的意外消息创建行为而引入的。因此，您应该尽可能避免使用`callcode`。
- en: '|  |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-327
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: Avoid `callcode` if possible and choose `delegatecall` instead.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能避免`callcode`，选择`delegatecall`。
- en: '|  |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 14.2.6\. What’s the gas limit?
  id: totrans-330
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.2.6\. 燃料限制是多少？
- en: Apart from `send()` and `transfer()`, which impose a gas limit of 2,300 gas
    on the external call that’s only sufficient to perform an Ether transfer and a
    log operation, all the other external call types transfer to the external call
    the full gas limit present in the original call. As I explained previously, both
    low and high gas limits have security implications, but when it comes to transferring
    Ether, a lower limit is preferable because it prevents external manipulation when
    Ether is at stake.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`send()`和`transfer()`对外部调用的燃料限制为2300燃料，这仅足以执行以太币传输和日志操作外，所有其他外部调用类型都将原始调用中的全部燃料限制传递给外部调用。如我之前解释过，低燃料限制和高燃料限制都有安全含义，但当涉及到传输以太币时，较低的限制更受欢迎，因为它在以太币处于危险时防止外部操纵。
- en: '|  |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-333
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: Favor a lower gas limit over a higher gas limit.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 倾向于较低的燃料限制而不是较高的燃料限制。
- en: '|  |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 14.3\. How to perform external calls more safely
  id: totrans-336
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.3\. 如何更安全地执行外部调用
- en: You should now have a better idea of the characteristics and tradeoffs associated
    with each external call type, and you might be able to choose the most appropriate
    one for your requirements. But even if you pick the correct call type, you might
    end up in trouble if you don’t use it correctly. In this section, I’ll show you
    some techniques for performing external calls safely. You’ll see how even performing
    an Ether transfer through the apparently safe and inoffensive `transfer()` can
    end up in a costly mistake if you don’t think through all the scenarios that could
    lead your call to fail.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该对每种外部调用类型的特性和权衡有更好的了解，并且你可能能够根据你的需求选择最合适的一种。但是，即使你选择了正确的调用类型，如果你不正确地使用它，你可能会遇到麻烦。在本节中，我将向你展示一些安全执行外部调用的技术。你将看到，即使通过看似安全无害的`transfer()`进行以太币转账，如果你没有考虑所有可能导致调用失败的场景，最终也可能犯下昂贵的错误。
- en: 14.3.1\. Implementing pull payments
  id: totrans-338
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.3.1\. 实现拉取支付
- en: Imagine you’ve developed an auction Dapp and you’ve implemented an `Auction`
    contract like the one shown in the open source *Ethereum Smart Contract Best Practices*
    guide coordinated by ConsenSys,^([[1](#ch14fn01)]) which I’ve provided in the
    following listing. Have a good look at this listing, because I’ll reference it
    a few times in this chapter.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 想象你已经开发了一个拍卖Dapp，并且你已经实现了一个像开源项目Ethereum Smart Contract Best Practices指南中由ConsenSys协调的`Auction`合约。我在下面的列表中提供了一个示例。仔细研究这个列表，因为我在本章中会多次引用它。
- en: ¹
  id: totrans-340
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-341
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: See “Recommendations for Smart Contract Security in Solidity,” [http://mng.bz/MxXD](http://mng.bz/MxXD),
    licensed under Apache License, Version 2.0.
  id: totrans-342
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 参见“Solidity中的智能合约安全建议”，[http://mng.bz/MxXD](http://mng.bz)， Apache License 2.0
    许可。
- en: Listing 14.3\. Incorrect implementation of an `Auction` contract
  id: totrans-343
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表14.3\. `Auction`合约的不正确实现
- en: '[PRE26]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '***1*** **Reverts the transaction if the current bid isn’t the highest one**'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **如果当前出价不是最高的，则回滚交易**'
- en: '***2*** **If the current bid is the highest, refunds the previous highest bidder**'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **如果当前出价最高，退还给之前的最高出价者**'
- en: '***3*** **Updates the details of the highest bid and bidder**'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **更新最高出价和出价者的细节**'
- en: What happens if one of the bidders has implemented a fallback, as shown in the
    following listing, and then they submit a bid higher than the highest one?
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 如果其中一个出价者实现了回退函数，如下面的列表所示，然后他们提交了一个比最高出价还要高的出价会发生什么？
- en: Listing 14.4\. A malicious contract calling the `Auction` contract
  id: totrans-349
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表14.4\. 恶意合约调用`Auction`合约
- en: '[PRE27]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '***1*** **This contract will revert its state and throw an exception every
    time it receives an Ether payment.**'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **此合约每次收到以太币支付时都会回滚其状态并抛出异常。**'
- en: As soon as the `MaliciousBidder` contract submits the highest bid through `submitBid()`,
    `Auction.bid()` refunds the previous highest bidder then sets the address and
    value of the highest bid to those of the `MaliciousBidder`. So far, so good. What
    happens next?
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`MaliciousBidder`合约通过`submitBid()`提交了最高出价，`Auction.bid()`将退还给之前的最高出价者，然后将最高出价的地址和价值设置为`MaliciousBidder`的地址和价值。到目前为止，一切顺利。接下来会发生什么？
- en: 'A new bidder now makes the highest bid. `Auction.bid()` will consequently try
    to refund `MaliciousBidder`, but the following line of code fails, even if the
    new bidder has done nothing wrong and the logic of the `bid()` function seems
    correct:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有一个新的出价者提出了最高出价。`Auction.bid()`将尝试退还给`MaliciousBidder`，但是下面的代码行失败了，即使新的出价者没有做错任何事，并且`bid()`函数的逻辑似乎是正确的：
- en: '[PRE28]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This line fails because the current `highestBidder` is still the address of
    `MaliciousBidder`, and its fallback, which `highestBidder.transfer()` calls, throws
    an exception.If you think about it, no new bidder will ever be able to pass this
    line, because a refund to `MaliciousBidder` will be attempted on every occasion.
    Also, the call to `highestBidder.transfer()` will keep failing before the address
    and value of a new highest bid can ever be updated, as illustrated in [figure
    14.8](#ch14fig08). That’s why `MaliciousBidder` is . . . malicious!
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码行失败是因为当前的`highestBidder`仍然是`MaliciousBidder`的地址，其回退函数在`highestBidder.transfer()`调用时抛出了异常。如果你仔细思考，任何新的出价者都不可能通过这一行，因为在每次尝试退款给`MaliciousBidder`的情况下。同时，`highestBidder.transfer()`的调用将一直失败，在地址和价值更新为新的最高出价之前，如图14.8[所示](#ch14fig08)。这就是为什么`MaliciousBidder`是恶意的。
- en: 'What about replacing `transfer()` with `send()`? An exception will be thrown
    in the `bid()` function following a failure in `send()`. As a result, using `send()`
    instead of `transfer()` in the recommended way, as shown in the following line
    of code, doesn’t solve the problem:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 那么用`send()`替换`transfer()`怎么样？在`send()`失败后，`bid()`函数将抛出异常。因此，按照推荐的方式使用`send()`而不是`transfer()`，如以下代码行所示，并不能解决问题：
- en: '[PRE29]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Figure 14.8\. After the malicious contract has become the highest bidder, the
    `Auction` contract becomes unusable because it will unsuccessfully try to refund
    the malicious contract at every new higher bid and will never be able to set the
    new highest bidder.
  id: totrans-358
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图14.8。在恶意合约成为最高出价者之后，`Auction`合约变得无法使用，因为它会尝试向恶意合约退款（每次新的更高出价都会失败），并且永远无法设置新的最高出价者。
- en: '![](Images/fig14-08_alt.jpg)'
  id: totrans-359
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig14-08_alt.jpg)'
- en: 'With your current `bid()` implementation, you don’t even need a malicious external
    bidder contract to end up in trouble. Also, unintentional exceptions that are
    thrown by any external bidding contract that has a faulty `fallback()` can rock
    the boat. For example, a sloppy developer of a bidder contract, unaware of the
    gas limitations associated with `transfer()` (or `send()`) might have decided
    to implement a complex fallback function, such as the one shown in the code that
    follows, that accepts the refund and processes it by modifying its own contract
    state. That would consequently blow the `transfer()` 2,300 gas stipend and almost
    immediately throw a “ran out of gas” exception:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 使用您当前的`bid()`实现，您甚至不需要一个恶意的外部出价者合约就会遇到麻烦。此外，任何具有错误`fallback()`的外部出价合约抛出的非故意异常都可能颠覆船只。例如，一个粗心的出价合约开发者，没有意识到与`transfer()`（或`send()`）相关的气体限制，可能已经决定实现一个复杂的回退函数，如以下代码所示，该函数接受退款并通过修改其自己的合约状态来处理它。这将进而耗尽`transfer()`的2,300气体配额，并几乎立即抛出一个“气体耗尽”的异常：
- en: '[PRE30]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '***1*** **As soon as the state variable refund is updated, the function execution
    runs out of the 2,300 gas stipend imposed by transfer() and fails.**'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **一旦状态变量refund被更新，函数执行就会耗尽`transfer()`施加的2,300气体配额并失败。**'
- en: As you can see, the current implementation of `bid()` relies heavily on the
    assumption that you’re dealing with honest and competent external contract developers.
    That might not always be the case.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，`bid()`的当前实现严重依赖于您正在与诚实和有能力的外部合约开发者合作的假设。这可能并不总是实际情况。
- en: A safer way to accept a bid is to separate the logic that updates the highest
    bidder from the execution of the refund to the previous highest bidder. The refund
    will no longer be pushed automatically to the previous highest bidder but should
    now be pulled with a separate request by them, as shown in the following listing.
    (This solution also comes from the ConsenSys guide I mentioned earlier.)
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 接受出价的一种更安全的方法是将更新最高出价者的逻辑与向前任最高出价者执行退款分离。现在退款不再自动推送到前任最高出价者，而应该通过单独的请求由他们拉取，如下面的列表所示。（这个解决方案也来自我之前提到的ConsenSys指南。）
- en: Listing 14.5\. Correct implementation of an `Auction` contract
  id: totrans-365
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表14.5。`Auction`合约的正确实现
- en: '[PRE31]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '***1*** **Now this function only stores the amount to refund because of a new
    higher bidder in the refund mapping. No Ether transfer takes place.**'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **现在这个函数只存储因新的更高出价者而产生的退款金额。没有以太币的转移。**'
- en: '***2*** **The update of the new highest bid and bidder will now succeed because
    bid() no longer contains external operations that might get hijacked, such as
    the previous transfer() call.**'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **现在更新新的最高出价和出价者将会成功，因为`bid()`不再包含可能被劫持的外部操作，例如之前的`transfer()`调用。**'
- en: '***3*** **If this transfer fails—for example, when paying MaliciousBidder—the
    state of the Auction contract is now unaffected.**'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **如果这个转移失败——例如，当支付给MaliciousBidder时——`Auction`合约的状态现在不受影响。**'
- en: Pull payments also come in handy in case the function that makes a payment performs
    a number of payments in a loop. An example would be a function that refunds all
    the accounts of the investors in an unsuccessful crowdsale, as shown in the following
    listing.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 拉取支付在函数执行循环中执行多次支付时也很有用。一个例子可能是退款所有投资者在失败的众筹中的账户，如下面的列表所示。
- en: Listing 14.6\. Incorrect implementation of a function making several payments
  id: totrans-371
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表14.6。一个执行多次支付的函数的不正确实现
- en: '[PRE32]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If an attacker makes very small investments from a very high number of accounts,
    the number of items in the investors array might become so big that the `for`
    loop will run out of gas before completing, because each step of the loop has
    a fixed gas cost. This is a form of DoS attack exploiting gas limits. A safer
    implementation is to keep only the refund assignment in `refundAllInvestors()`
    and to move the Ether transfer operation into a separate pull payment function
    called `withdrawalRefund()`. This is similar to the one you saw earlier in the
    `Auction` contract, as you can see in the following listing.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 如果攻击者从一个很高的账户数量中进行非常小的投资，投资者数组中的项目数量可能会变得如此之大，以至于 `for` 循环在完成之前会耗尽燃料，因为循环的每一步都有固定的燃料成本。这是一种利用燃料限制的
    DoS 攻击。一个更安全的实现是，在 `refundAllInvestors()` 中只保留退款分配，并将以太币转账操作移动到一个名为 `withdrawalRefund()`
    的单独提取支付函数中。这与你在 `Auction` 合约中看到的类似，正如你在下面的清单中所看到的。
- en: Listing 14.7\. Improved `refundAllInvestors()` implementation
  id: totrans-374
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 清单 14.7. 改进的 `refundAllInvestors()` 实现
- en: '[PRE33]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 14.3.2\. Implementing a minimal fallback function
  id: totrans-376
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.3.2. 实现一个最小的回退函数
- en: 'Although pull payments are a good solution from the point of view of the contract
    that’s transferring Ether out, now put yourself in the shoes of the bidder. If
    you’re expecting Ether from an external contract, such as the `Auction` contract,
    don’t assume the external contract is implementing safe pull-payment functionality,
    as shown in [listing 14.7](#ch14ex07). Assume instead that the external contract
    has been implemented in a suboptimal way, as in [listing 14.6](#ch14ex06), the
    initial implementation you looked at. In this case, if you want to make sure the
    refund operation executed with `transfer()` (or `send()`) succeeds, you must provide
    a minimal fallback function: empty or at most with a single log operation, as
    shown here:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管从合约转移以太币的角度来看，提取支付是一个不错的解决方案，但设身处地为出价者考虑一下。如果你期望从外部合约（如拍卖合约）获得以太币，不要假设外部合约实现了安全的提取支付功能，正如[清单
    14.7](#ch14ex07) 所示。相反，假设外部合约是以一种次优的方式实现的，就像你之前看到的[清单 14.6] 中的初始实现。在这种情况下，如果你想确保使用
    `transfer()`（或 `send()`）执行的退款操作成功，你必须提供一个最小的回退函数：为空或者最多包含单个日志操作，如图所示：
- en: '[PRE34]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 14.3.3\. Beware of Ether coming to you through selfdestruct()
  id: totrans-379
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.3.3. 小心通过 `selfdestruct()` 来到你这里的以太币
- en: 'Unfortunately, you can’t make sure your contract doesn’t receive Ether from
    unknown sources. You might think that having a fallback that always throws an
    exception or reverts the state of your contract when called, as shown here, should
    be sufficient to stop this undesired inflow of Ether:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，你不能确保你的合约不会从未知来源接收以太币。你可能会认为，拥有一个总是在被调用时抛出异常或回滚合约状态的回退函数，如所示，应该足以阻止这种不受欢迎的以太币流入：
- en: '[PRE35]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: But I’m afraid there’s a way to transfer Ether to any address that doesn’t require
    any payable function on the receiving side—not even a fallback function. This
    can be achieved by calling
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我担心有一种方法可以将以太币转移到任何地址，而不需要在接收方实现任何可支付函数——甚至不需要回退函数。这可以通过调用
- en: '[PRE36]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `selfdestruct()` function was introduced to provide a way to destroy a contract
    in case of emergency, and with the same operation, to transfer all the Ether associated
    with the contract account to a specified address. Typically, this would be executed
    when a critical bug was discovered or when a contract was being hacked.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '`selfdestruct()` 函数是为了在紧急情况下提供一种摧毁合约的方法，并通过同一操作，将合约账户关联的所有以太币转移到指定地址。通常，这会在发现关键错误或合约被黑客攻击时执行。'
- en: Unfortunately, `selfdestruct()` also lends itself to misuse. If an external
    contract contains at least 1 Wei and self-destructs, targeting the address of
    your contract, there isn’t much you can do. You might think receiving unwanted
    Ether wouldn’t be a serious issue, but if the logic of your contract depends on
    checks and reconciliations performed on the Ether balance, for example, through
    `require()`, you might be in trouble.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，`selfdestruct()` 也容易遭到滥用。如果外部合约包含至少 1 Wei 并自我销毁，目标是你的合约地址，你几乎无能为力。你可能会认为接收不受欢迎的以太币不是一个严重的问题，但如果你的合约逻辑依赖于对以太币余额的检查和协调，例如，通过
    `require()`，你可能会有麻烦。
- en: 14.4\. Avoiding known security attacks
  id: totrans-386
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.4. 避免已知的网络安全攻击
- en: Now that we’ve reviewed Solidity’s known security weak spots associated with
    external calls, it’s time to analyze known attacks that have taken place exploiting
    such weaknesses. You can group attacks on Solidity contracts into three broad
    categories, depending on the high-level objective of the attacker. The objective
    can be to
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经回顾了与外部调用相关联的Solidity已知的安全漏洞，接下来是分析利用这些弱点的已知攻击。你可以根据攻击者的高级目标，把Solidity合约的攻击分为三大类。目标是
- en: manipulate the outcome of an individual transaction
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操纵单个交易的输出结果
- en: favor one transaction over other transactions
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 偏袒某笔交易
- en: make a contract unusable
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使合约不可用
- en: '[Table 14.9](#ch14table09) summarizes manipulation techniques associated with
    each attack category. The next few sections will define and present in detail
    each attack technique included in the table.'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '[表14.9](#ch14table09) 总结了与每种攻击类别相关的操纵技术。接下来的几节将定义并详细介绍表中包含的每种攻击技术。'
- en: Table 14.9\. Security attacks, strategies, and techniques
  id: totrans-392
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表14.9. 安全攻击、策略和技术
- en: '| Attack objective | Attack strategy | Attack technique |'
  id: totrans-393
  prefs: []
  type: TYPE_TB
  zh: '| 攻击目标 | 攻击策略 | 攻击技术 |'
- en: '| --- | --- | --- |'
  id: totrans-394
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Individual transaction manipulation | Race condition | Reentrancy, cross-function
    race condition |'
  id: totrans-395
  prefs: []
  type: TYPE_TB
  zh: '| 个别交易操纵 | 竞态条件 | 重入，跨函数竞态条件 |'
- en: '| Favoring one transaction over others | Front-running | Front-running |'
  id: totrans-396
  prefs: []
  type: TYPE_TB
  zh: '| 偏袒某笔交易 | 抢跑 | 抢跑 |'
- en: '| Making contract unusable | Denial of service | Fallback calling revert(),
    exploiting gas limits |'
  id: totrans-397
  prefs: []
  type: TYPE_TB
  zh: '| 使合约不可用 | 服务拒绝 | 回退调用revert()，利用燃料限制 |'
- en: '|  |'
  id: totrans-398
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Warning
  id: totrans-399
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: This section only covers the most common attacks, mainly to give you an idea
    of how malicious participants can manipulate a contract. Also, new security attacks
    are continuously discovered, so you must learn about and constantly keep up to
    date with the latest security breaches by consulting the official Solidity documentation
    and the many other websites and blogs that cover the topic. I’ll point you to
    some resources in [section 14.5](#ch14lev1sec5).
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 本节只涵盖最常见的攻击，主要是让你了解恶意参与者如何操纵合约。此外，新的安全攻击正在不断被发现，因此你必须通过查阅官方Solidity文档和其他许多涵盖该主题的网站和博客，了解并不断更新最新的安全漏洞。我会在[第14.5节](#ch14lev1sec5)中为你指出一些资源。
- en: '|  |'
  id: totrans-401
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 14.4.1\. Reentrancy
  id: totrans-402
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.4.1. 重入
- en: Reentrancy attacks target functions containing an external call and exploit
    a race condition between simultaneous calls to this function caused by the possible
    time lag that takes place during the external call. The objective of the attack
    is generally to manipulate the state of the contract, often having to do with
    an Ether or custom cryptocurrency balance, by calling back the targeted function
    many times simultaneously while the attacker hijacks the execution of the external
    call. If we go back to the example of the auction Dapp I showed you earlier, an
    attacker could launch a reentrancy attack on an incorrect implementation of `withdrawRefund()`
    by requesting a refund many times in parallel while hijacking each refund call,
    as illustrated in [figure 14.9](#ch14fig09).
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 重入攻击针对包含外部调用的函数，并利用此函数同时调用之间可能发生的时间延迟引起的竞态条件。攻击的目标通常是操纵合约的状态，通常与Ether或自定义加密货币余额有关，通过同时多次回调目标函数，而攻击者劫持外部调用的执行。如果我们回到我之前向你展示的拍卖Dapp的例子，攻击者可以通过并行地多次请求退款，同时劫持每个退款调用，对`withdrawRefund()`的错误实现发起重入攻击，如图14.9所示。
- en: Figure 14.9\. If you were to implement `Auction.withdrawRefund()` incorrectly,
    for example, by clearing the balance of the caller only after the Ether transfer
    has been completed, an attacker could attempt to call it many times in parallel
    while hijacking each call, by slowing down the execution of the receiving `fallback()`
    function. Various of these simultaneous Ether transfers are allowed and can complete
    successfully until one of them finally completes and the balance of the caller
    is cleared. Before this happens, many illegitimate refunds might take place.
  id: totrans-404
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图14.9. 如果你错误地实现`Auction.withdrawRefund()`，例如，在Ether转移完成后才清除调用者的余额，攻击者可以并行地多次调用它，同时劫持每个调用，通过减慢接收`fallback()`函数的执行。这些同时的Ether转移被允许，并且可以成功完成，直到其中一个最终完成并清除调用者的余额。在这之前，可能会发生许多不正当的退款。
- en: '![](Images/fig14-09_alt.jpg)'
  id: totrans-405
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig14-09_alt.jpg)'
- en: 'The following code shows an incorrect implementation of `withdrawRefund()`
    (also from the ConsenSys guide) that will put your contract in danger:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了`withdrawRefund()`的错误实现（也来自ConsenSys指南），这将使你的合约处于危险之中：
- en: '[PRE37]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '***1*** **Calls to an external contract fallback function, which might take
    a relatively long time**'
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **对外部合约回退函数的调用可能会相对较慢**'
- en: '***2*** **Executes only after the previous external call is complete**'
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **仅在之前的 external call 完成后执行**'
- en: 'As I mentioned, an attacker contract might call `withdrawRefund()` several
    times while hijacking each external call to the fallback function that enables
    the payment, as shown here:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我提到的，攻击者合约可能会在劫持每个执行支付的回退函数的外部调用时多次调用`withdrawRefund()`，如下所示：
- en: '[PRE38]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '***1*** **The fallback contains only code to delay its completion. Before this
    completes, the attacker calls withdrawRefund() several times.**'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **回退函数中只包含延迟完成的代码。在它完成之前，攻击者多次调用withdrawRefund()。**'
- en: 'Such a slow execution of the Ether transfer would prevent `withdrawRefund()`
    from reaching the code line that clears the caller balance for a long time:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 以太币转账的这种缓慢执行将阻止`withdrawRefund()`在很长时间内达到清除调用者余额的代码行：
- en: '[PRE39]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Until this line is reached, various Ether transfers might take place, each equal
    to the amount owed to the caller. As a result, the caller could receive more Ether
    than they’re owed, as shown in the sequence diagram in [figure 14.10](#ch14fig10).
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 在这行代码之前，可能会发生各种以太币转账，每个转账金额都与调用者应得的金额相等。因此，调用者可能会收到比应得的更多的以太币，如[图 14.10](#ch14fig10)中的序列图所示。
- en: '|  |'
  id: totrans-416
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-417
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The reason why I wanted to include in this chapter the auction Dapp from the
    ConsenSys guide, and particularly its incorrect implementation of the `withdrawRefund()`
    function, is that this code shows one of the vulnerabilities that contributed
    to the initial success of the DAO attack.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 我之所以想在本书中包含来自ConsenSys指南的拍卖Dapp，特别是其`withdrawRefund()`函数的错误实现，是因为这段代码展示了导致DAO攻击最初成功的其中一个漏洞。
- en: '|  |'
  id: totrans-419
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Figure 14.10\. Sequence diagram of parallel invocations of an incorrect implementation
    of `withdrawRefund()` by an attacker
  id: totrans-420
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 14.10. 攻击者并行调用`withdrawRefund()`错误实现的序列图
- en: '![](Images/fig14-10_alt.jpg)'
  id: totrans-421
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig14-10_alt.jpg)'
- en: 'You can prevent this attack using a couple of methods:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下几种方法防止这种攻击：
- en: If you can, use `transfer()` or `send()` instead of `call.value()()`, so the
    attacker will have a gas limit of 2,300 and be prevented from implementing any
    transfer-delaying code in their `fallback()` function.
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你能的话，使用`transfer()`或`send()`而不是`call.value()()`，这样攻击者的gas限制将是2300，从而阻止他们在`fallback()`函数中实现任何转账延迟代码。
- en: Place the external call performing the Ether transfer as the last operation,
    so the Ether balance can be cleared before the call takes place rather than after,
    as shown in [listing 14.8](#ch14ex08). If the attacker tried to call `withdrawRefund()`
    again, the value of `refunds[msg.sender]` would be zero, and consequently the
    refund would be set to zero. Therefore, the new Ether payment wouldn’t have any
    effect.
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将执行以太币转账的外部调用作为最后操作，这样在调用发生前而不是发生后清空以太币余额，正如[列表 14.8](#ch14ex08)所示。如果攻击者再次尝试调用`withdrawRefund()`，`refunds[msg.sender]`的值将变为零，因此退款也将被设置为零。因此，新的以太币支付将不会产生任何效果。
- en: Listing 14.8\. Correct `withdrawRefund` implementation
  id: totrans-425
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 14.8. `withdrawRefund()`的正确实现
- en: '[PRE40]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '***1*** **Now the transfer takes place after the balance has been cleared,
    so subsequent calls to withdraw-Refund() have no effect.**'
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **现在转账在余额被清空后进行，所以随后调用withdrawRefund()将没有效果。**'
- en: 14.4.2\. Cross-function race conditions
  id: totrans-428
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.4.2. 跨函数竞态条件
- en: You’ve learned that reentrancy attacks exploit a race condition between simultaneous
    calls to the same function. But an attacker can also exploit race conditions between
    simultaneous calls on separate functions that try to modify the same contract
    state—for example, the Ether balance of a specific account.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经了解到，重入攻击利用了同一函数同时调用的竞态条件。但攻击者也可以利用尝试修改同一合同状态的分离函数之间的竞态条件——例如，特定账户的以太币余额。
- en: 'A cross-race condition also could happen on `SimpleCoin`. Recall `SimpleCoin`’s
    `transfer()` function:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 在`SimpleCoin`上，跨竞态条件也可能发生。回顾`SimpleCoin`的`transfer()`函数：
- en: '[PRE41]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, imagine you decided to provide a `withdrawFullBalance()` function, which
    closed the SimpleCoin account of the caller and sent them back the equivalent
    amount in Ether. If you implemented this function as follows, you’d expose the
    contract to a potential cross-function race condition:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想象一下你决定提供一个`withdrawFullBalance()`函数，该函数关闭调用者的SimpleCoin账户，并将等值的以太币发送给他们。如果你像下面这样实现这个函数，你会使合约面临潜在的跨函数竞态条件：
- en: '[PRE42]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '***1*** **The attacker contract calls transfer() at this point of the execution
    of withdrawFullBalance().**'
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **攻击者在执行withdrawFullBalance()函数时调用transfer()函数。**'
- en: 'A cross-function race condition attack works in a similar way to the reentrancy
    attack shown earlier. An attacker would first call `withdrawFullBalance()` and,
    while they were hijacking the external call from their fallback function, as shown
    in the following code, they’d call `transfer()` to move the full SimpleCoin balance
    to another address they own before the execution of `withdrawBalance()`cleared
    this balance. In this way, they’d both keep the full SimpleCoin balance and get
    the equivalent Ether amount:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 跨函数竞态条件攻击的方式与之前看到的递归性攻击类似。攻击者首先调用`withdrawFullBalance()`，在他们从回退函数中劫持外部调用时，他们会调用`transfer()`，将完整的SimpleCoin余额移动到他们拥有的另一个地址，在`withdrawBalance()`执行清除这个余额之前。这样，他们既能保留完整的SimpleCoin余额，又能得到等值的以太币金额：
- en: '[PRE43]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The solution is, as was the case for the reentrancy attack, to replace `call.value()()`
    with `send()` or `transfer()`. You would also need to make sure the external call
    that performs the balance withdrawal takes place in the last line of the function,
    after the caller balance has already been set to 0:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案，正如递归性攻击的情况一样，用`send()`或`transfer()`替换`call.value()()`。你还需要确保执行余额提现的外部调用发生在函数的最后一行，在调用者余额已经被设置为0之后：
- en: '[PRE44]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '***1*** **The external call is now performed after the caller balance has been
    cleared.**'
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **现在外部调用在调用者余额被清除之后执行。**'
- en: More complex cases of reentrancy involve call chains spanning several contracts.
    The general recommendation is always to place external calls or calls to functions
    containing external calls at the end of the function body.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 更复杂的递归性攻击案例涉及多个合约之间的调用链。一般的建议总是将外部调用或包含外部调用的函数放在函数体的最后。
- en: 14.4.3\. Front-running attacks
  id: totrans-441
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.4.3. 前置运行攻击
- en: The attacks based on race conditions you’ve seen so far try to manipulate the
    outcome of a transaction by altering its expected execution flow, generally by
    hijacking the part of the execution that takes place externally.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止你所看到的基于竞态条件的攻击试图通过改变交易的预期执行流程来操纵交易的结果，通常是通过劫持在外部执行的部分。
- en: Other attack strategies work at a higher level and target decentralized applications
    for which the ordering of the execution of the transactions is important. Attackers
    try to influence the timing or ordering of transaction executions by favoring
    and prioritizing certain transactions over others. For example, a malicious miner
    might manipulate a decentralized stock market-making application by creating new
    buy order transactions when detecting in the memory pool many buy orders for a
    certain stock. The miner would then include only their own buy order transactions
    on the new block, so their transactions would get executed before any other similar
    order present in the memory pool, as illustrated in [figure 14.11](#ch14fig11).
    If the miner’s PoW was successful, their buy order would become official. Subsequently,
    the stock price would rise because of the many buy orders that have been submitted
    but not executed yet. This would generate an instant profit for the miner.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 其他的攻击策略在更高层次，针对的是交易执行顺序重要的去中心化应用。攻击者试图通过偏袒和优先处理某些交易来影响交易执行的时间或顺序。例如，一个恶意矿工可能会在内存池中发现许多对某只股票的买入订单时，创建新的买入订单交易。矿工会将他们自己的买入订单交易包含在新块中，这样他们的交易就会在内存池中任何其他类似订单之前执行，如图[14.11](#ch14fig11)所示。如果矿工的PoW成功，他们的买入订单就会成为正式的。随后，由于提交了许多但尚未执行的买入订单，股票价格会上涨。这将给矿工带来即时利润。
- en: Figure 14.11\. An example of a front-running attack. A malicious miner could
    detect big buy or sell orders being sent to a stock market-making Dapp and still
    in the memory pool. They could then decide to front run them by ignoring these
    big orders and including their own orders in the new block they would try to create,
    therefore making an unfair profit if the block got mined.
  id: totrans-444
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图14.11\. 前端运行攻击的一个例子。恶意矿工可以检测到发送到股票市场制造Dapp且仍处于内存池中的大买入或卖出订单。他们可以决定通过忽略这些大订单并在尝试创建的新区块中包含自己的订单来前端运行它们，如果区块被挖出，他们就能获得不公平的利润。
- en: '![](Images/fig14-11_alt.jpg)'
  id: totrans-445
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig14-11_alt.jpg)'
- en: This manipulation is an example of *front running*, which is the practice of
    malicious stock brokers who place the execution of their own orders ahead of those
    of their clients. A way to avoid this attack is to design the order clearing logic
    on *batch execution* rather than individual execution, with an implementation
    similar to batch auctions. With this setup, the auction contract collects all
    bids and then determines the winner with a single operation. Another solution
    is to implement a commit–reveal scheme similar to that described earlier in this
    chapter to disguise order information.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 这种操纵是*前端运行*的一个例子，这是恶意股票经纪人将他们自己的订单执行放在客户订单之前的行为。避免这种攻击的方法之一是设计基于*批量执行*的订单清算逻辑，而不是单个执行，实现方式与批量拍卖类似。采用这种设置，拍卖合约收集所有出价，然后通过单一操作确定赢家。另一种解决方案是实现一个类似于本章早期描述的提交-揭示方案，以掩盖订单信息。
- en: 14.4.4\. Denial of service based on revert() in fallback
  id: totrans-447
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.4.4\. 基于revert()的DoS攻击
- en: Some attacks aim to bring down a contract completely. These are known as denial
    of service (DoS) attacks.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 一些攻击旨在完全摧毁合约，这些被称为服务拒绝（DoS）攻击。
- en: 'As I’ve already shown you in the `Auction` contract, at the beginning of this
    chapter, an attacker could make a contract unusable by implementing the following
    fallback and then calling the targeted contract in such a way that it triggers
    an incoming payment:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在本章开头在`Auction`合约中向你展示的，攻击者可以通过实现以下回退函数，然后以触发传入支付的方式调用目标合约，从而使合约无法使用：
- en: '[PRE45]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '***1*** **This contract will revert its state and throw an exception every
    time it receives an Ether payment.**'
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **每当此合约收到以太币支付时，它将回滚其状态并抛出异常。**'
- en: 'If the targeted contract implements a function as shown here, it will become
    unusable as soon as it tries to send Ether to the attacker:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 如果目标合约实现了如下所示的函数，那么它在尝试向攻击者发送以太币时将变得无法使用：
- en: '[PRE46]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '***1*** **Checks if the current bid is higher than the current highest bid**'
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **检查当前出价是否高于当前最高出价**'
- en: '***2*** **The previous highest bidder is refunded, but when the previous highest
    bidder is the malicious contract, the transfer fails, and a new higher bidder
    and bid value can no longer be set.**'
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **前一个最高出价者将被退款，但当前一个最高出价者是恶意合约时，转账失败，无法再设置新的最高出价者和出价值.**'
- en: '***3*** **Sets new higher bidder and bid values**'
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **设置新的最高出价者和出价值**'
- en: As you already know, you can avoid this attack by implementing a pull payment
    facility rather than an automated push payment. (See [section 14.3.1](#ch14lev2sec11)
    for more details.)
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所知，你可以通过实现拉取支付功能而不是自动推送支付来避免这种攻击。（更多详情请参见[14.3.1节](#ch14lev2sec11)）
- en: 14.4.5\. Denial of service based on gas limits
  id: totrans-458
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.4.5\. 基于燃料限制的DoS攻击
- en: 'In the section on pull payments, you saw the example of an incorrectly implemented
    function that refunds all the accounts of the investors in an unsuccessful crowdsale:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 在拉取支付部分，你看到了一个错误实现的函数，该函数在众筹失败时向所有投资者退款示例：
- en: '[PRE47]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: I already warned you that this implementation lends itself to manipulation by
    an attacker who makes very small investments from a very high number of accounts.
    The high number of `for` loops required by the large investments array will damage
    the contract permanently, because any invocation of the function will blow the
    gas limit. This is a form of DoS attack exploiting gas limits. Refunds based on
    pull payment functionality also prevent this attack.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经警告过你，这个实现方式容易受到攻击者通过从一个很高的账户中进行非常小的投资来进行操纵。大量投资数组所需的`for`循环数量将永久损害合约，因为任何函数的调用都会耗尽燃料限制。这是一种利用燃料限制的DoS攻击。基于拉取支付功能的退款也能防止这种攻击。
- en: You’ve learned about the pitfalls associated with external calls and how to
    avoid the most common forms of attack. Now I’ll close the chapter by sharing with
    you some security recommendations I’ve been collecting over time from various
    sources.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经了解了与外部调用相关的陷阱以及如何避免最常见的安全攻击形式。现在，我将通过分享一些我从各种来源收集的安全建议来结束本章。
- en: 14.5\. General security guidelines
  id: totrans-463
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.5 通用安全指南
- en: The official Solidity documentation has an entire section dedicated to security
    considerations and recommendations,^([[2](#ch14fn02)]) which I invite you to consult
    before deploying your contract on public networks. Other excellent resources are
    available, such as the open source *Ethereum Smart Contract Best Practices* guide
    ([http://mng.bz/dP4g](http://mng.bz/dP4g)), initiated and maintained by the Diligence
    ([https://consensys.net/diligence/](https://consensys.net/diligence/)) division
    of ConsenSys, which focuses on security and aims at raising awareness around best
    practices in this field. This guide, which I’ve referenced in various places in
    this chapter, is widely considered to be the main reference on Ethereum security.
    I’ve decided to adopt its terminology to make sure you can look up concepts easily,
    if you decide you want to learn more about anything I’ve covered here.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 官方Solidity文档有一个完整的部分致力于安全考虑和建议，^([[2](#ch14fn02)])在将您的合约部署到公共网络之前，我建议您参考该部分。还有其他优秀的资源，例如由Diligence([https://consensys.net/diligence/](https://consensys.net/diligence/))部门发起和维护的开源*以太坊智能合约最佳实践*指南([http://mng.bz/dP4g](http://mng.bz/dP4g))，该指南专注于安全并旨在提高在此领域的最佳实践方面的意识。我在本章的各个地方引用了这本指南，它被认为是以太坊安全的主要参考资料。我决定采用其术语，以确保您如果决定想了解更多关于我这里涵盖的内容，可以轻松查找概念。|
- en: ²
  id: totrans-465
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ²
- en: ''
  id: totrans-466
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: See “Security Considerations” at [http://mng.bz/a7o9](http://mng.bz/a7o9).
  id: totrans-467
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 参见“安全考虑”中的[http://mng.bz/a7o9](http://mng.bz/a7o9)。
- en: In [table 14.10](#ch14table10), I’ve listed an additional set of useful free
    resources on Ethereum security that ConsenSys Diligence has created. Presentations
    and posts by Christian Reitwiessner,^([[3](#ch14fn03)]) the head of Solidity at
    Ethereum, are also a must-read.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 在[表14.10](#ch14table10)中，我列出了ConsenSys Diligence创建的另外一些有用的免费以太坊安全资源。Ethereum的Solidity负责人Christian
    Reitwiessner的演讲和帖子也是必读的。|
- en: ³
  id: totrans-469
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ³
- en: ''
  id: totrans-470
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: See “Smart Contract Security,” June 10,2016, [http://mng.bz/GWxA](http://mng.bz/GWxA),
    and “How to Write Safe Smart Contracts,” November 10, 2015, [http://mng.bz/zMx6](http://mng.bz/zMx6).
  id: totrans-471
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 参见“智能合约安全”，2016年6月10日，[http://mng.bz/GWxA](http://mng.bz/GWxA)和“如何编写安全的智能合约”，2015年11月10日，[http://mng.bz/zMx6](http://mng.bz/zMx6)。
- en: Table 14.10\. Ethereum security resources ConsenSys Diligence has distributed
  id: totrans-472
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表14.10. ConsenSys Diligence分发的以太坊安全资源|
- en: '| Resource | Description |'
  id: totrans-473
  prefs: []
  type: TYPE_TB
  zh: '| 资源 | 描述 |'
- en: '| --- | --- |'
  id: totrans-474
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Secure smart contract philosophy¹ | Series of *Medium* articles written by
    ConsenSys Diligence on how to approach smart contract security |'
  id: totrans-475
  prefs: []
  type: TYPE_TB
  zh: '| 安全的智能合约哲学¹ | ConsenSys Diligence在Medium上发表的一系列文章，介绍如何对待智能合约安全|'
- en: '| EIP 1470: SWC² | Standardized weakness classification for smart contracts,
    so tool vendors and security practitioners can classify weaknesses in a more consistent
    way |'
  id: totrans-476
  prefs: []
  type: TYPE_TB
  zh: '| EIP 1470: SWC² | 对智能合约的标准化弱点分类，使工具供应商和安全从业者可以以更一致的方式对弱点进行分类|'
- en: '| 0x security audit report³ | Full security audit of ConsenSys 0x smart contract
    system, carried out by ConsenSys Diligence. This gives a good idea of the weaknesses
    assessed during a thorough security audit. |'
  id: totrans-477
  prefs: []
  type: TYPE_TB
  zh: '| 0x安全审计报告³ |ConsenSys 0x智能合约系统的全面安全审计，由ConsenSys Diligence执行。这为您提供了一个在彻底的安全审计中评估弱点的良好思路。|'
- en: '| Audit readiness guide⁴ | Guidelines on how to prepare for a smart contract
    security audit |'
  id: totrans-478
  prefs: []
  type: TYPE_TB
  zh: '| 审计准备指南⁴ |关于如何为智能合约安全审计做准备的指导方针|'
- en: '| 1\. See “Building a Philosophy of Secure Smart Contracts,” [http://mng.bz/ed5G](http://mng.bz/ed5G).
    |'
  id: totrans-479
  prefs: []
  type: TYPE_TB
  zh: '| 1. 参见“构建安全的智能合约哲学”，[http://mng.bz/ed5G](http://mng.bz/ed5G)。|'
- en: '| 2\. See these GitHub pages: [https://github.com/ethereum/EIPs/issues/1469andhttp://mng.bz/pgVR](https://github.com/ethereum/EIPs/issues/1469andhttp://mng.bz/pgVR).
    |'
  id: totrans-480
  prefs: []
  type: TYPE_TB
  zh: '| 2. 参见这些GitHub页面：[https://github.com/ethereum/EIPs/issues/1469andhttp://mng.bz/pgVR](https://github.com/ethereum/EIPs/issues/1469andhttp://mng.bz/pgVR)。|'
- en: '| 3\. See http://mng.bz/O2Ej. |'
  id: totrans-481
  prefs: []
  type: TYPE_TB
  zh: '| 3. 参见http://mng.bz/O2Ej。|'
- en: '| 4\. See Maurelian’s “Preparing for a Smart Contract Code Audit,” September
    6, 2017, at [http://mng.bz/YPqj](http://mng.bz/YPqj). |'
  id: totrans-482
  prefs: []
  type: TYPE_TB
  zh: '| 4. 参见Maurelian的“为智能合约代码审计做准备”，2017年9月6日，[http://mng.bz/YPqj](http://mng.bz/YPqj)。|'
- en: 'I’ll summarize in a short list the most important points all the resources
    I’ve mentioned tend to agree on. I reiterate, though, that it’s important to constantly
    keep up to date with the latest security exploits and discovered vulnerabilities
    on sites such as [http://hackingdistributed.com](http://hackingdistributed.com),
    [https://cryptonews.com](https://cryptonews.com), or [https://cryptoslate.com](https://cryptoslate.com).
    Here’s the list:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 我会用一个简短的列表总结所有我提到的资源倾向于同意的最重要观点。不过，我要重申，不断跟上最新的安全漏洞和被发现的漏洞，如[http://hackingdistributed.com](http://hackingdistributed.com)，[https://cryptonews.com](https://cryptonews.com)，或[https://cryptoslate.com](https://cryptoslate.com)等网站的信息是非常重要的。列表如下：
- en: '*Favor a simple contract design*. The same design recommendations that generally
    apply to object-oriented classes are also valid for smart contracts. Aim for small
    contracts, focused on only one piece of functionality, with a small number of
    state variables and with short functions. This will help you avoid mistakes and
    will help fellow developers understand your code correctly.'
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优先设计简单的合约**。通常适用于面向对象类的相同设计建议也适用于智能合约。力求小型合约，专注于单一功能，状态变量数量少，函数简短。这将帮助你避免错误，并帮助其他开发者正确理解你的代码。'
- en: '*Amend code that raises compiler warnings*. Understand any compiler warnings
    and amend your code accordingly. Aim to remove all the warnings you get, if possible,
    especially those related to deprecated functionality. Solidity syntax has been
    amended often because of security concerns, so take the advice from warnings seriously.'
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**修正引发编译器警告的代码**。理解任何编译器警告并相应修正你的代码。如果可能的话，力求移除你收到的所有警告，尤其是与弃用功能相关的。Solidity语法经常因为安全问题而修改，所以要认真对待警告的建议。'
- en: '*Call external contracts as late as possible*. As you’ve learned in the sections
    dedicated to reentrancy, you should avoid changing the state of your contract
    after returning from an external call. This call might get hijacked, and you might
    not be able to return from it safely. The recommended pattern to adopt is called
    *check–effects–interaction*, according to which you structure a function on the
    following ordered steps:'
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽可能晚地*调用外部合约*。正如你在关于重入性的章节中学习到的，你应该避免在从外部调用返回后改变你的合约状态。这次调用可能会被劫持，你可能无法安全地返回。建议采用的模式称为*检查-效果-交互*，根据这个模式，你应按照以下有序步骤结构一个函数：
- en: '*Check*—Validate that the message sender is authorized, function input parameters
    are valid, Ether being transferred is available, and so on. You generally do this
    directly through `require` statements or indirectly through function modifiers.'
  id: totrans-487
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**检查**—验证消息发送者是授权的，函数输入参数有效，转移的以太币可用等。你通常直接通过`require`语句或间接通过函数修饰符来做这个。'
- en: '*Effects*—Change the state of your contract based on the validated function
    input.'
  id: totrans-488
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**效果**—根据验证过的函数输入改变你的合约状态。'
- en: '*Interaction*—Call external contracts or libraries using the new contract state.'
  id: totrans-489
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交互**—使用新的合约状态调用外部合约或库。'
- en: '*Plan for disaster*. As you learned in the previous chapter, once a contract
    has been deployed, you can’t modify it. If you discover a bug or, even worse,
    a security flaw, and Ether is at risk, you can’t apply a hot-fix as you’d do on
    a conventional centralized application. You should plan for this eventuality beforehand
    and provide the contract owner with an emergency function, such as `freeze()`
    or `selfDestruct()`, as I mentioned in [chapters 6](kindle_split_018.xhtml#ch06)
    and [7](kindle_split_019.xhtml#ch07) when presenting `Simple-Crowdsale`. Such
    functions can disable the contract temporarily, until you understand the defect,
    or even permanently. Some developers have taken a more proactive approach and
    have implemented auto-freezing (or fail-safe) functionality based on contract
    state pre- or postcondition checks on each contract function. If the condition
    isn’t met, the contract moves into a fail-safe mode in which all or most of its
    functionality is disabled. Regardless of whether you decided to fit your contract
    with an interactive or automated emergency stop, ideally you should also plan
    for an upgrade strategy, as I discussed in [chapter 13](kindle_split_027.xhtml#ch13).'
  id: totrans-490
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规划灾难。正如你在上一章所学的，一旦合约部署完成，你就无法修改它。如果你发现了一个错误，或者是更糟糕的安全漏洞，并且Ether处于风险之中，你不能像对待传统的集中式应用程序那样应用热修复。你应该提前为此可能性做好准备，并为合约所有者提供一个紧急函数，如`freeze()`或`selfDestruct()`，正如我在[第6章](kindle_split_018.xhtml#ch06)和[第7章](kindle_split_019.xhtml#ch07)介绍`Simple-Crowdsale`时提到的那样。这些函数可以暂时禁用合约，直到你理解了缺陷，或者甚至永久性地禁用。一些开发者采取了更为主动的方法，并在每个合约函数的预先或后置条件检查的基础上实现了自动冻结（或安全保护）功能。如果条件未满足，合约将进入安全保护模式，其中所有或大部分其功能被禁用。无论你决定为你的合约配备交互式或自动紧急停车装置，理想情况下你也应该计划一个升级策略，正如我在[第13章](kindle_split_027.xhtml#ch13)讨论的那样。
- en: '*Use linters*. A linter is a static code analysis tool that aims at catching
    breaches against recommended style, efficient implementation, or known security
    vulnerabilities. The two most well-known Solidity linters are Solium (now Ethlint)
    ([https://github.com/duaraghav8/Solium](https://github.com/duaraghav8/Solium))
    and Solint ([https://github.com/SilentCicero/solint](https://github.com/SilentCicero/solint)).
    They both provide integration plugins for most common general code editors, such
    as Atom, Sublime, VS Code, and JetBrains IDEA. Apart from highlighting security
    vulnerabilities, these tools give feedback on coding style and best practices
    in general, so they can help you learn Solidity quickly.'
  id: totrans-491
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用代码审查工具。代码审查工具是一种静态代码分析工具，旨在捕捉违反推荐风格、高效实现或已知安全漏洞的情况。Solidity最著名的两个代码审查工具是Solium（现在称为Ethlint）([https://github.com/duaraghav8/Solium](https://github.com/duaraghav8/Solium))和Solint([https://github.com/SilentCicero/solint](https://github.com/SilentCicero/solint))。它们都为大多数常见的通用代码编辑器（如Atom、Sublime、VS
    Code和JetBrains IDEA）提供了集成插件。除了突出安全漏洞外，这些工具还提供了关于编码风格和最佳实践的反馈，因此它们可以帮助你快速学习Solidity。
- en: '*Use security analysis frameworks*. If you want to go the extra mile, don’t
    stop at linters. Instead, aim at integrating security analysis into your development
    cycle with frameworks such as the Mythril Platform,^([[4](#ch14fn04)]) which combines
    a variety of static and dynamic analyzers.'
  id: totrans-492
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用安全分析框架。如果你想要更进一步，不要止步于代码审查工具。相反，目标应该是在你的开发周期中整合安全分析，使用诸如Mythril平台，^([[4](#ch14fn04)])它结合了各种静态和动态分析器。
- en: ⁴
  id: totrans-493
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁴
- en: ''
  id: totrans-494
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: See Bernhard Mueller, “MythX Is Upping the Smart Contract Security Game,” [http://mng.bz/0WmE](http://mng.bz/0WmE),
    for an introduction to Mythril.
  id: totrans-495
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 参见Bernhard Mueller，“MythX正在提升智能合约安全游戏的水平，”[http://mng.bz/0WmE](http://mng.bz/0WmE)，了解Mythril的入门知识。
- en: '*Follow the wisdom of the crowds*. If you’re not sure about the safety of smart
    contracts you’d like to connect to, you could look up their ratings in Panvala,^([[5](#ch14fn05)])
    a system that attempts to gather the level of security of smart contracts from
    their users.'
  id: totrans-496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遵循群体智慧。如果你对你想要连接的智能合约的安全性不够自信，你可以查阅Panvala的评分，^([[5](#ch14fn05)])这是一个试图从用户那里收集智能合约安全级别的系统。
- en: ⁵
  id: totrans-497
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁵
- en: ''
  id: totrans-498
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: See “Introducing Panvala,” [http://mng.bz/K1Mg](http://mng.bz/K1Mg), for an
    introduction to Panvala.
  id: totrans-499
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 参见“介绍Panvala，”[http://mng.bz/K1Mg](http://mng.bz/K1Mg)，了解Panvala的入门知识。
- en: '*Commission a formal security audit*. If your smart contract handles anything
    valuable, such as cryptocurrency or tokens, before going into production you should
    consider commissioning a formal security audit from one of the many consultancies
    that are starting to specialize in this area.'
  id: totrans-500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '```Commission a formal security audit```. If your smart contract handles anything
    valuable, such as cryptocurrency or tokens, before going into production you should
    consider commissioning a formal security audit from one of the many consultancies
    that are starting to specialize in this area.'
- en: Summary
  id: totrans-501
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: Attackers generally exploit limitations in the Solidity language, the EVM, and
    the blockchain as the first line of attack against unaware developers, especially
    around data privacy, random numbers, integer overflows, and gas limits.
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 攻击者通常会利用Solidity语言、EVM和区块链中的限制作为对不知情的开发者的第一攻击线，特别是在数据隐私、随机数、整数溢出和燃料限制等方面。
- en: If not well understood, external calls can expose a contract to manipulation
    by malicious participants. For example, some external calls throw exceptions,
    whereas others don’t, or some execute in the context of the caller contract, and
    others in the context of the called contract. You must understand the risks of
    each type and handle returned value and contract state accordingly.
  id: totrans-503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果不被充分理解，外部调用可能会使合约受到恶意参与者的操纵。例如，一些外部调用会抛出异常，而另一些则不会，或者一些在调用者合约的上下文中执行，而另一些则在被调用合约的上下文中执行。你必须了解每种类型的风险，并相应地处理返回值和合约状态。
- en: Various techniques are available to perform safer external calls and reduce
    the chance of external manipulation. Examples include pull payment (rather than
    automated payment) functionality and Ether transfer based on `transfer()` and
    `send()`, which restrict the gas limit on an external fallback function.
  id: totrans-504
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有多种技术可用于执行更安全的远程调用并减少外部操纵的机会。例如，拉取支付（而不是自动支付）功能以及基于`transfer()`和`send()`的以太币传输，后者在外部回退函数上限制了燃料限制。
- en: The minimum line of defense is to prepare at least against well-known attacks,
    such as reentrancy, front-running attacks, and denial of service (DoS) attacks.
  id: totrans-505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最基本的防御线是要至少准备好防御已知攻击，比如重入攻击、抢跑攻击和服务拒绝（DoS）攻击。
- en: The official Solidity documentation and various online security guides, sites,
    and blogs provide up-to-date information on the latest attacks and guidelines
    for avoiding them.
  id: totrans-506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 官方Solidity文档和各种在线安全指南、网站和博客提供了关于最新攻击和避免它们的指南的最新信息。
- en: Chapter 15\. Conclusions
  id: totrans-507
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第15章。结论
- en: '|  |'
  id: totrans-508
  prefs: []
  type: TYPE_TB
  zh: '```'
- en: '**This chapter covers**'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章内容**'
- en: The evolution of Ethereum
  id: totrans-510
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以太坊的演变
- en: Alternative Ethereum implementations
  id: totrans-511
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以太坊替代实现
- en: Capabilities beyond the Ethereum blockchain
  id: totrans-512
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 超越以太坊区块链的能力
- en: '|  |'
  id: totrans-513
  prefs: []
  type: TYPE_TB
  zh: '```'
- en: You’ve finally reached the end of this book. I’m sure you’ve learned a lot,
    and you should now feel equipped to continue the journey by yourself. Don’t rest
    on your laurels, though. Both Ethereum and the landscape around it are constantly
    changing.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 你终于读完了这本书。我相信你已经学到了很多知识，现在你应该感觉到有装备可以自己继续旅程了。不过，你不要沾沾自喜。以太坊及其周围的环境都在不断变化。
- en: Before I say goodbye, I’d like to give you a heads-up on topics you should particularly
    keep an eye on if you’re considering building your own Dapp. I’d also like to
    briefly present you with some alternative forks of mainstream Ethereum, in case
    you have needs the mainstream implementation can’t fulfill. Finally, I’ll give
    you a quick view of the current blockchain landscape, in case you want to explore
    alternative blockchain offerings.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 在我告别之前，我想提醒你，如果你正在考虑构建自己的Dapp，你应该特别关注一些话题。我还想简要向你介绍一些主流以太坊的分叉，以防主流实现无法满足你的需求。最后，我会给你一个区块链现状的快速概述，以防你想探索其他区块链产品。
- en: 'Before I start, I’d like to be clear on one thing: this chapter is only meant
    to give you ideas for further learning, so I’m not aiming to cover any topic in
    depth. I’ll only try to stimulate your mind and enthusiasm.'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，我想澄清一点：本章只是为了给你提供进一步学习的想法，所以我不会深入覆盖任何话题。我只试图激发你的思想和热情。
- en: 15.1\. Evolution of Ethereum
  id: totrans-517
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.1。以太坊的演变
- en: As I’ve repeated various times throughout the book, Ethereum is continuously
    evolving, and at this stage many of its building blocks are still in flux, such
    as the EVM, the Solidity language, the Web3.js library, the consensus algorithm,
    and some elements of the ecosystem. I’ll give you an idea of how these elements
    are likely to evolve, but I strongly recommend you keep updated through online
    resources.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在书中多次重复的那样，以太坊在不断发展，在这个阶段，它的许多构件仍然在变化中，比如EVM、Solidity语言、Web3.js库、共识算法以及生态系统的一些元素。我会给你一个这些元素可能如何演变的概述，但我强烈建议您通过在线资源保持更新。
- en: 15.1.1\. Evolution of EVM
  id: totrans-519
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.1.1 节：EVM的演变
- en: The current implementation of the EVM supports dynamic jumps (which means the
    address is supplied as an argument on the stack), but they make control-flow and
    data-flow analysis complicated and slow. Ethereum Improvement Proposal 615^([[1](#ch15fn01)])
    aims at a partial redesign of the EVM (version 1.5) targeted at introducing subroutines
    (through static jumps and `return`) and disallowing dynamic jumps and other misuses
    of the stack. This would bring several benefits, including better compilation
    from Solidity, faster interpretation, improved optimization to native code, and
    better static analysis and formal verification tools. It would also allow better
    compilation from and to eWASM.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的EVM实现支持动态跳转（这意味着地址作为栈上的参数提供），但这会使控制流和数据流分析变得复杂且缓慢。以太坊改进提案615（EIP 615）([[1](#ch15fn01)])旨在对EVM（版本1.5）进行部分重新设计，引入子例程（通过静态跳转和`return`）并禁止动态跳转和其他栈的滥用。这将带来几个好处，包括更好的Solidity到原生代码的编译、更快的解释、改进到原生代码的优化，以及更好的静态分析和形式验证工具。它还将允许更好的Solidity到eWASM的编译。
- en: ¹
  id: totrans-521
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-522
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: See EIPs/eip-615.md on GitHub at [http://mng.bz/9OMq](http://mng.bz/9OMq).
  id: totrans-523
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 请参阅GitHub上的EIPs/eip-615.md文件，网址为[http://mng.bz/9OMq](http://mng.bz/9OMq)。
- en: If you’re wondering what eWASM is, WASM stands for WebAssembly ([https://webassembly.org/](https://webassembly.org/)),
    and it’s a new binary instruction format that W3C is designing as an open standard.
    This standard specifies an instruction set, an intermediate source format (WAST),
    and a binary encoded format (WASM). Most mainstream JavaScript engines, including
    those behind Node.js, Chrome, Edge, and Firefox, will provide native support for
    WebAssembly. eWASM ([https://github.com/ewasm](https://github.com/ewasm)) is a
    subset of WASM designed to support Ethereum smart contracts. The ultimate objective
    is, among other benefits, to provide a library and instructions to write Ethereum
    contracts in C and in Rust.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道eWASM是什么，WASM代表WebAssembly([https://webassembly.org/](https://webassembly.org/))，它是一种新的二进制指令格式，W3C正在将其设计为开放标准。这个标准定义了一个指令集、一个中间源格式（WAST）和一个二进制编码格式（WASM）。包括Node.js、Chrome、Edge和Firefox在内的主流JavaScript引擎将提供对WebAssembly的本地支持。eWASM([https://github.com/ewasm](https://github.com/ewasm))是WASM的一个子集，旨在支持以太坊智能合约。最终目标是，提供库和指令，以便用C和Rust编写以太坊合约。
- en: 15.1.2\. Evolution of Solidity
  id: totrans-525
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.1.2 节：Solidity的演变
- en: If you’re among the MEAP readers of this book, you might have noticed Solidity
    has been changing frequently since you started playing with it. The developers
    of Solidity have often introduced new keywords and deprecated others. This continuous
    evolution is making Solidity a more robust language, especially from a security
    point of view. The biggest change that’s taking place, and you should be aware
    of, is the deprecation of `send()` and `call()`, so I strongly encourage you to
    use `transfer()` instead.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是本书MEAP读者之一，你可能会注意到自从你开始研究Solidity以来，它已经发生了许多变化。Solidity开发者经常引入新关键字并废弃旧关键字。这种持续的演变使Solidity成为一个更健壮的语言，特别是在安全方面。目前正在发生的最重大变化是`send()`和`call()`的废弃，所以我强烈鼓励你使用`transfer()`。
- en: 15.1.3\. Evolution of Web3.js
  id: totrans-527
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.1.3 节：Web3.js的演变
- en: Although throughout the book I’ve been referencing Web3.js version 0.24 because
    it works reliably with all the current tools, you should try to move to version
    1.0 as soon as you can. This is still in beta at the time of writing, but the
    candidate release is coming soon.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在这本书中我一直引用Web3.js版本0.24，因为它能与所有现有工具可靠地工作，但您应该尽可能快地尝试升级到版本1.0。截至写作时，它仍处于测试阶段，但候选版本即将发布。
- en: 15.1.4\. Evolution of the consensus algorithm
  id: totrans-529
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.1.4 节：共识算法的演变
- en: MAINNET, the public production network, is still based on the Proof of Work
    (PoW) consensus algorithm. As you might recall, the PoW algorithm is designed
    so that many miners are competing to append a new block to the blockchain by simultaneously
    trying to solve a cryptographic puzzle. They keep re-hashing the proposed new
    block until they find a *nonce* that generates a correct hash (for example, a
    hash with many leading zeros). The hashing process is CPU-intensive and therefore
    energy-intensive. The simultaneous re-hashing of a new block performed trillions
    of times per second throughout the Ethereum network has been widely blamed for
    being energy-wasteful. Developers are experimenting with a couple of alternative
    consensus algorithms to overcome this issue, namely *Proof of Stake* (PoS) and
    *Proof of Authority* (PoA).
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 主网络（MAINNET），公共生产网络，仍然基于工作量证明（PoW）共识算法。正如您可能回忆起来的，PoW算法设计成让许多矿工竞争性地将新区块添加到区块链上，同时尝试解决一个密码学难题。他们不断重新哈希拟议的新区块，直到找到一个*nonce*，它生成了一个正确的哈希值（例如，一个有很多前导零的哈希值）。哈希过程是CPU密集型的，因此也是能耗密集型的。在整个以太坊网络上每秒执行万亿次的新区块同时重新哈希操作，已经被广泛指责为能源浪费。开发者正在尝试几种替代的共识算法来解决这一问题，即*权益证明*（PoS）和*权威证明*（PoA）。
- en: Proof of Stake
  id: totrans-531
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 权益证明（Proof of Stake，PoS）
- en: 'The *Proof of Stake* algorithm^([[2](#ch15fn02)]) is designed so that only
    one miner has the right to append a new block during a certain time slot. A new
    block is consequently processed only once every few seconds throughout the network,
    rather than trillions of times per second, which eliminates the problem of electricity
    consumption. As you can imagine, the term “miner” no longer applies under this
    algorithm: candidates for appending blocks are called *validators* instead, as
    shown in [figure 15.1](#ch15fig01).'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 权益证明算法*（Proof of Stake algorithm）*设计成在一定时间槽内只有唯一一个矿工有权添加一个新区块。因此，整个网络每几秒钟处理一次新区块，而不是每秒万亿次，这消除了电力消耗的问题。如您所想象的，在这种算法下，“矿工”这个术语不再适用：添加区块的候选者被称为*验证者*，如图15.1所示。
- en: ²
  id: totrans-533
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ²
- en: ''
  id: totrans-534
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: See “Proof of Stake FAQs” on the Ethereum wiki on GitHub at [http://mng.bz/jO48](http://mng.bz/jO48).
  id: totrans-535
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 有关权益证明的常见问题，请参阅GitHub上以太坊维基的“Proof of Stake FAQs”页面：[http://mng.bz/jO48](http://mng.bz/jO48)。
- en: Figure 15.1\. PoS versus PoW. Whereas under PoW, many miners perform work (and
    consume electricity) simultaneously to append a block, under PoS only one node,
    called a validator, proposes a new block during a time slot.
  id: totrans-536
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图15.1\. 权益证明与工作量证明对比。在PoW下，许多矿工同时执行工作（消耗电力）以添加一个区块，而在PoS下，在一个时间槽内只有一个节点，称为验证者，提出一个新的区块。
- en: '![](Images/fig15-01_alt.jpg)'
  id: totrans-537
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig15-01_alt.jpg)'
- en: 'Validators submit a deposit in Ether, which represents their stake in the infrastructure.
    The chosen validator, selected through a randomizer or round-robin function weighted
    on the stake, proposes a new block. Then, depending on the specific implementation
    of the PoS algorithm, the validator submits the proposed block to several secondary
    validators for approval. They vote on the block (the vote might be weighted on
    their stake) and, if the outcome is positive, the block is appended to the blockchain
    and the validator is rewarded in Ether. On the other hand, if the block is found
    to be incorrect, the initial (main) validator might get blacklisted and lose their
    deposit. Also, secondary validators are encouraged to be honest: if their vote
    diverges too much from that of their peers, they might get penalized and lose
    some of their deposit, as you can see in [figure 15.2](#ch15fig02).'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 验证者向以太坊提交存款，这笔存款代表了他们在基础设施中的股份。通过一个随机数生成器或按股份权重轮询函数选出的验证者提出一个新的区块。然后，根据PoS算法的具体实现，验证者将拟议的区块提交给几个次级验证者以求得批准。他们就区块进行投票（投票可能会根据他们的股份加权），如果结果是积极的，该区块将被添加到区块链上，并奖励以太坊给验证者。另一方面，如果区块被证明是错误的，初始（主）验证者可能会被列入黑名单并失去他们的存款。此外，次级验证者也鼓励诚实：如果他们的投票与同行的投票相差太大，他们可能会受到惩罚并失去部分存款，正如您在[图15.2](#ch15fig02)中所看到的。
- en: The PoS algorithm, with its incentives and disincentives, might provide various
    benefits, such as reductions in dependency of the network on advanced hardware,
    risk of centralized processing by a few miners, and likelihood of a 51% attack
    (which would become much costlier). The project name for the PoS algorithm is
    called Casper, and the project released a test network in January 2018.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: PoS 算法，及其激励和抑制措施，可能提供各种好处，例如减少网络对先进硬件的依赖，降低由少数矿工进行集中处理的风险，以及降低 51% 攻击的可能性（这将变得非常昂贵）。PoS
    算法的项目名称是 Casper，该项目在 2018 年 1 月发布了一个测试网络。
- en: Figure 15.2\. PoS algorithm. First, validators submit a deposit. Then the selected
    validator proposes a new block and submits it to secondary validators for approval.
    If they score the block as correct, it’s appended to the blockchain. The main
    validator or secondary validators might get penalized in Ether if they’re found
    to be dishonest.
  id: totrans-540
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 15.2. PoS 算法。首先，验证者提交一笔存款。然后，被选中的验证者提出一个新的区块并提交给次级验证者审批。如果他们认为这个区块是正确的，它就会被添加到区块链上。如果主验证者或次级验证者被发现不诚实，他们可能会在以太币上受到惩罚。
- en: '![](Images/fig15-02_alt.jpg)'
  id: totrans-541
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig15-02_alt.jpg)'
- en: Proof of Authority
  id: totrans-542
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Proof of Authority
- en: Many practitioners and researchers have criticized the nature of PoS’s incentives
    for being potentially unbalanced because they don’t take into account the total
    holdings of each validator. A state-sponsored validator, for example, might have
    committed an amount of Ether considered large by the designers of the algorithm.
    But if that amount is relatively small with respect to the value of their total
    assets (including cryptocurrency and conventional assets), they might not be discouraged
    from acting dishonestly.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 许多实践者和研究者批评了 PoS 激励措施的本质，认为它可能是不平衡的，因为它没有考虑到每个验证者的总持有量。例如，一个国家赞助的验证者可能已经承诺了一定数量的以太币，而这个数量对于算法的设计者来说被认为是大的。但是，如果与他们的总资产（包括加密货币和传统资产）的价值相比，这个数量相对较小，他们可能不会被阻止行为不诚实。
- en: '*Proof of Authority*^([[3](#ch15fn03)]) is an alternative form of consensus
    algorithm that is still based on a pool of validators, but in this case each validator
    puts at stake their reputation rather than their Ether. Nodes that want to take
    part in the validators pool apply through a formal identification process: they
    disclose their real identity, which is verified through the same checks a conventional
    notary would perform. Once a node has been approved as a validator, it becomes
    an *Authority* (hence the name of the algorithm). The idea is that linking the
    block verification process to the node’s reputation rather than to the perceived
    value of their deposit is more robust, as shown in [figure 15.3](#ch15fig03).'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 证明 of Authority*^([[3](#ch15fn03)]) 是一种基于验证者池的共识算法的替代形式，但在这个情况下，每个验证者投入的是他们的声誉而不是他们的以太币。想要加入验证者池的节点需要通过正式的识别过程：他们披露他们的真实身份，这通过与传统公证人相同的方式来验证。一旦一个节点被批准为验证者，它就成为了一个*权威*（因此这个算法的名称）。该算法的核心思想是将区块验证过程与节点的声誉而不是他们存款的预期价值相链接，这更为健壮，如图
    15.3 所示。
- en: ³
  id: totrans-545
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ³
- en: ''
  id: totrans-546
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: See the Wikipedia “Proof-of-Authority” page at [https://en.wikipedia.org/wiki/Proof-of-authority](https://en.wikipedia.org/wiki/Proof-of-authority).
  id: totrans-547
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 请参阅维基百科的“Proof-of-Authority”页面：[https://en.wikipedia.org/wiki/Proof-of-authority](https://en.wikipedia.org/wiki/Proof-of-authority)。
- en: Figure 15.3\. PoA versus PoS. When a malicious node loses their Ether deposit
    under PoS, their sponsor can set up a new node and continue with malicious behavior.
    Under PoA, once an authority has been detected as malicious, their sponsor (and
    all associated identities) is prevented from reentering the network.
  id: totrans-548
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 15.3. PoA 与 PoS 对比。在 PoS 下，一个恶意节点失去他们的以太币存款后，他们的赞助商可以建立一个新的节点并继续恶意行为。在 PoA
    下，一旦发现一个权威节点具有恶意，他们的赞助商（及其所有相关身份）将无法重新进入网络。
- en: '![](Images/fig15-03_alt.jpg)'
  id: totrans-549
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig15-03_alt.jpg)'
- en: 'Currently, two public test networks support different implementations of PoA:
    Rinkeby and Kovan. In August 2018, Microsoft released Ethereum PoA on Azure, targeting
    private and consortium permissioned networks. (See [section 15.2](#ch15lev1sec2)
    for more details on permissioned networks.)'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，两个公共测试网络支持 PoA 的不同实现：Rinkeby 和 Kovan。2018 年 8 月，微软在 Azure 上发布了 Ethereum PoA，针对私人化和联合授权的网络。（更多有关授权网络的详细信息请参见第
    15.2 节。）
- en: 15.1.5\. Evolution of the ecosystem
  id: totrans-551
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.1.5. 生态系统的发展
- en: Many of the components of the Ethereum ecosystem I presented in [chapter 9](kindle_split_022.xhtml#ch09)
    are evolving. For example, on the ENS website ([https://ens.domains/](https://ens.domains/)),
    you can find a roadmap that indicates the production ENS registrar, currently
    based on a commit–reveal auction, will be replaced in the next few months with
    a simplified version. Also, the Swarm team has published a roadmap^([[4](#ch15fn04)])
    for the future development of the decentralized file system. A more dramatic evolution
    is that of Zeppelin. What started as an open source Ethereum smart contract library
    is becoming ZeppelinOS ([https://zeppelinos.org/](https://zeppelinos.org/)), a
    full-blown operating system for smart contracts.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 我在[第9章](kindle_split_022.xhtml#ch09)中介绍的以太坊生态系统的许多组件都在发展变化。例如，在ENS网站上([https://ens.domains/](https://ens.domains/)），你可以找到一个路线图，指示目前基于提交-揭示拍卖的生产ENS注册商将在未来几个月内被简化版本所取代。另外，Swarm团队发布了一个未来发展的路线图^([[4](#ch15fn04)])，用于去中心化文件系统。更戏剧性的变化是Zeppelin。最初作为一个开源的以太坊智能合约库，现在正在发展成为ZeppelinOS([https://zeppelinos.org/](https://zeppelinos.org/)），一个为智能合约提供完整功能的操作系统。
- en: ⁴
  id: totrans-553
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁴
- en: ''
  id: totrans-554
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: See the Swarm “Roadmap” on GitHub at [https://github.com/ethersphere/swarm/wiki/roadmap](https://github.com/ethersphere/swarm/wiki/roadmap).
  id: totrans-555
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 请参见GitHub上的Swarm“路线图”[https://github.com/ethersphere/swarm/wiki/roadmap](https://github.com/ethersphere/swarm/wiki/roadmap)。
- en: 15.2\. Alternative Ethereum implementations
  id: totrans-556
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.2. 替代以太坊实现
- en: 'Although you might have been fascinated by the technology, if you work in an
    enterprise, you might think Ethereum would be difficult to adopt. One good reason
    is that it doesn’t offer out of the box three features most enterprise applications
    require: scalability, permissioning, and data privacy. The Enterprise Ethereum
    Alliance is an organization trying to extend the public Ethereum implementation
    with such features.'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可能被这项技术迷住了，但如果你在企业工作，你可能会认为以太坊很难采用。一个很好的原因是，它没有提供开箱即用的三个企业应用程序最需要的特性：可扩展性、权限管理和数据隐私。企业以太坊联盟是一个试图将此类特性扩展到公共以太坊实现的机构。
- en: 15.2.1\. Enterprise Ethereum Alliance
  id: totrans-558
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.2.1. 企业以太坊联盟
- en: The Enterprise Ethereum Alliance (EEA) ([https://entethalliance.org/](https://entethalliance.org/))
    is a nonprofit consortium of around 500 companies that formed in March 2017 from
    a core of 30 founding members, including technology corporations (Microsoft, INTEL),
    research institutes (Toyota Research Institute), consultancies (Deloitte, Accenture,
    Samsung SDS), and financial institutions (Banco Santander, ING). The mission of
    the consortium is to propose and drive a roadmap for enterprise features and requirements;
    to shape a governance model for licensing around the open source technology; and
    to provide businesses with resources to help them learn Ethereum and address industry
    use cases that can take advantage of the technology.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 企业以太坊联盟（EEA）([https://entethalliance.org/](https://entethalliance.org/)）是一个由约500家公司组成的非盈利性组织，该组织于2017年3月由30个创始成员组成，包括科技公司（微软、英特尔），研究机构（丰田研究院），咨询公司（德勤、埃森哲、三星SDS）以及金融机构（桑坦德银行、ING）。该组织的任务是提出并推动企业特性和需求路线图；塑造围绕开源技术的许可治理模型；为企业提供资源，帮助它们学习以太坊并解决可以利用该技术的行业用例。
- en: The EEA has published the Enterprise Ethereum Architecture Stack (EEAS), which
    presents a standardized view of the Enterprise Ethereum ecosystem, from the network
    layer to the application layer. This is illustrated in [table 15.1](#ch15table01),
    which compares the public Ethereum building blocks with the corresponding Enterprise
    Ethereum ones. (A more comprehensive view is available in the official documentation.)
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 企业以太坊联盟发布了企业以太坊架构堆栈（EEAS），该堆栈提供了一个标准化的企业以太坊生态系统视图，从网络层到应用层。这在[表15.1](#ch15table01)中有所说明，该表比较了公共以太坊构建模块与企业以太坊对应的构建模块。（更全面的视图可在官方文档中找到。）
- en: Table 15.1\. Public Ethereum versus Enterprise Ethereum building blocks
  id: totrans-561
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表15.1. 公共以太坊与企业以太坊构建模块对比
- en: '| Level | Public Ethereum | Enterprise Ethereum |'
  id: totrans-562
  prefs: []
  type: TYPE_TB
  zh: '| 级别 | 公共以太坊 | 企业以太坊 |'
- en: '| --- | --- | --- |'
  id: totrans-563
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Permissioning and credentials | Key management | Permissioning and authentication
    |'
  id: totrans-564
  prefs: []
  type: TYPE_TB
  zh: '| 权限和凭证 | 密钥管理 | 权限和认证 |'
- en: '| Integration and deployment tools | Integration libraries | Enterprise management
    systems |'
  id: totrans-565
  prefs: []
  type: TYPE_TB
  zh: '| 集成和部署工具 | 集成库 | 企业管理系统 |'
- en: '| Privacy | On-chain | Private transactions and off-chain transactions |'
  id: totrans-566
  prefs: []
  type: TYPE_TB
  zh: '| 隐私 | 链上 | 私人和链下交易 |'
- en: '| Storage | On-chain public state and storage; off-chain storage | On-chain
    private state |'
  id: totrans-567
  prefs: []
  type: TYPE_TB
  zh: '| 存储 | 链上公共状态和存储；链下存储 | 链上私有状态 |'
- en: '| Execution | EVM | Trusted execution |'
  id: totrans-568
  prefs: []
  type: TYPE_TB
  zh: '| 执行 | EVM | 可信执行 |'
- en: '| Consensus | Public consensus | Private consensus |'
  id: totrans-569
  prefs: []
  type: TYPE_TB
  zh: '| 共识 | 公共共识 | 私人共识 |'
- en: '| Network | DevP2P | Enterprise P2P |'
  id: totrans-570
  prefs: []
  type: TYPE_TB
  zh: '| 网络 | DevP2P | 企业P2P |'
- en: The first version of the Enterprise Ethereum Client Specification (EECS), detailing
    extensions to the public Ethereum blockchain to support permissioning, privacy,
    and scalability required for enterprise deployments, was published in May 2018,
    and you can download it from the EEA website. The objective of this specification,
    whose broad requirements are summarized in [table 15.2](#ch15table02), is to serve
    as a flexible standard that can allow different vendor implementations. For example,
    the specification defines various levels of privacy, identified with A, B, and
    C, that depend on the requirements for connectivity between nodes, permissioning,
    and transaction privacy. The vendor can decide which level to target and gets
    certified accordingly.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 企业以太坊客户端规范（EECS）的第一个版本（EECS），详细介绍了支持企业部署所需的权限控制、隐私和可扩展性对公共以太坊区块链的扩展，于2018年5月发布，你可以从EEA网站下载。这个规范的目标是作为一个灵活的标准，可以允许不同供应商的实现。例如，该规范定义了各种隐私级别，用A、B和C表示，这取决于节点之间的连接性、权限控制和交易隐私的需求。供应商可以决定针对哪个级别，并相应地获得认证。
- en: Table 15.2\. Broad requirements of EECS
  id: totrans-572
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表15.2\. EECS的广泛要求
- en: '| Requirement | Description |'
  id: totrans-573
  prefs: []
  type: TYPE_TB
  zh: '| 要求 | 描述 |'
- en: '| --- | --- |'
  id: totrans-574
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Permissioning | A blockchain system is defined as permissioned when its network
    isn’t public, but its nodes are owned by a restricted group of known participants.
    |'
  id: totrans-575
  prefs: []
  type: TYPE_TB
  zh: '| 权限控制 | 一个区块链系统当其网络不公开，但节点由一个受限的、已知的参与者群体所拥有时，被称为权限控制的。 |'
- en: '| Privacy | The content of a transaction should be visible only to the parties
    involved in the transaction. |'
  id: totrans-576
  prefs: []
  type: TYPE_TB
  zh: '| 隐私 | 交易的內容只应 visible to the parties involved in the transaction. |'
- en: '| Scalability | The performance of the blockchain infrastructure shouldn’t
    degrade with an increasing number of transactions, and it should ideally be equivalent
    to that of major enterprise systems, such as those handling credit card transactions.
    |'
  id: totrans-577
  prefs: []
  type: TYPE_TB
  zh: '| 可扩展性 | 区块链基础设施的性能不应该随着交易数量的增加而下降，并且理想情况下应该与处理信用卡交易的大型企业系统相当。 |'
- en: 15.2.2\. Quorum
  id: totrans-578
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.2.2\. Quorum
- en: One of the first Enterprise Ethereum implementations is Quorum ([www.jpmorgan.com/global/Quorum](http://www.jpmorgan.com/global/Quorum)).
    This is a fork of Ethereum that two members of the EEA—AMIS (a joint venture of
    Taiwanese financial institutions) and the bank JP Morgan—created in 2016\. Quorum
    extends a shared private Ethereum network with a *constellation network* that
    handles permissioning and data privacy, as you can see in [figure 15.4](#ch15fig04).
    When a transaction takes place between two or more participants, the constellation
    network deploys the relevant smart contract only across the members of the transaction.
    The content of the transaction is encrypted and stored off-chain by a transaction
    manager, and a hash is stored on the shared Ethereum blockchain.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 企业以太坊的第一个实现之一是Quorum([www.jpmorgan.com/global/Quorum](http://www.jpmorgan.com/global/Quorum))。这是一个由台湾金融机构的合资企业AMIS和银行摩根大通在2016年创建的以太坊分叉。Quorum通过一个星群网络扩展了共享的私有以太坊网络，该网络处理权限控制和数据隐私，正如你在[图15.4](#ch15fig04)中看到的。当两个或更多的参与者之间发生交易时，星群网络只在交易的成员之间部署相关的智能合约。交易的内容由交易管理器加密并存储在链下，其哈希存储在共享的以太坊区块链上。
- en: Figure 15.4\. A constellation network allows Quorum to handle permissioning
    and privacy. A smart contract is deployed only across the parties involved in
    a transaction; the transaction is encrypted and stored off-chain, and its hash
    is stored on the shared Ethereum blockchain.
  id: totrans-580
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图15.4\. 星群网络允许Quorum处理权限控制和隐私。只有涉及交易的各方才会部署智能合约；交易是加密的，存储在链下，其哈希存储在共享的以太坊区块链上。
- en: '![](Images/fig15-04_alt.jpg)'
  id: totrans-581
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig15-04_alt.jpg)'
- en: Quorum has been one of the first Ethereum-based platforms to
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: Quorum是第一个
- en: take advantage of geth’s pluggable consensus interface to allow a *configurable
    consensus algorithm*.
  id: totrans-583
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用geth的可插拔共识接口允许一个*可配置的共识算法*。
- en: use *zk-SNARKs’* cryptographic privacy technology to provide zero-knowledge
    verification of smart contract transactions, which means verification of the correctness
    of the execution of a transaction without learning what has been computed. The
    project’s participants have used this technology to build the *zero-knowledge
    security layer* (ZSL), which provides Quorum the ability to transfer digital assets
    on the blockchain without revealing any information about the sender and recipient
    assets themselves, therefore guaranteeing complete privacy.
  id: totrans-584
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用*zk-SNARKs*的加密隐私技术提供智能合约交易的零知识验证，这意味着验证交易的正确执行，而无需学习已计算出什么。项目参与者已经使用这项技术构建了*零知识安全层*（ZSL），它为Quorum提供了在区块链上转移数字资产的能力，而不会透露发件人和收件人资产本身的信息，从而保证完全的隐私。
- en: '|  |'
  id: totrans-585
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-586
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: zk-SNARKs is the technology that makes ZCash a truly anonymous cryptocurrency,
    contrary to Bitcoin, whose transactions can be traced to their owner.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: zk-SNARKs是使ZCash成为一个真正匿名的加密货币的技术，与比特币不同，比特币的交易可以追溯到其所有者。
- en: '|  |'
  id: totrans-588
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 15.3\. Beyond the Ethereum blockchain
  id: totrans-589
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.3. 超越以太坊区块链
- en: 'As you know, blockchain technology is well suited to solving problems related
    to proving ownership and traceability of assets. But as you learned earlier, public
    blockchains like Ethereum might not be suitable for enterprise applications designed
    to solve these problems because of their lack of focus on enterprise needs, such
    as those listed in [table 15.2](#ch15table02): permissioning, privacy, and scalability.
    Although the EEA is trying to fit the Ethereum blockchain to such requirements
    with various extensions (Quorum is one such example), other organizations have
    decided to take a completely different approach. Vendors agree that a decentralized
    database would be the core component of any solution, but they disagree on many
    implementation aspects of an architecture:'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所知，区块链技术非常适合解决与证明资产所有权和可追溯性相关的问题。但是，正如你之前所学的，像以太坊这样的公共区块链可能不适合解决这些问题的企业应用，因为它们没有关注企业需求，例如[表15.2](#ch15table02)中列出的那些：权限管理、隐私和可扩展性。尽管EEA正在通过各种扩展尝试使以太坊区块链满足这些要求（Quorum就是一个例子），但其他组织决定采取完全不同的方法。供应商同意分布式数据库将是任何解决方案的核心组件，但在架构的许多实现方面他们存在分歧：
- en: '*Decentralized database technology*—This isn’t necessarily based on a blockchain
    structure, so the industry has come up with the more general term of *distributed
    ledger technology* (DLT).'
  id: totrans-591
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*分布式数据库技术*——这并不一定基于区块链结构，因此行业提出了更一般的术语*分布式账本技术*（DLT）。'
- en: '*Permissioning*—Vendors agree that a distributed ledger can be accessed securely
    and with acceptable scalability only through a restricted network of known participants.'
  id: totrans-592
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*权限管理*——供应商同意，只有通过限制在已知参与者的受限网络中，才能安全且可接受地扩展地访问分布式账本。'
- en: '*Consensus*—Consensus in the blockchain space has evolved from PoW, based on
    a large group of anonymous miners processing the same transactions simultaneously,
    to PoS, based on a smaller group of participants that have submitted a deposit
    and process different sets of transactions in a coordinated fashion, to PoA, based
    on a limited set of known participants. The commonality among these approaches
    is they involve fundamentally two network roles: transaction submitters (any node)
    and validators (or miners). Consensus in a distributed ledger, on the other hand,
    might involve a more complex interaction among many roles to provide better scalability
    without compromising the integrity of the stored data.'
  id: totrans-593
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*共识*——区块链领域的共识机制已经从PoW演变而来，基于大量匿名矿工同时处理相同的交易，到PoS，基于较小的一组参与者提交押金并以协调的方式处理不同集成的交易，再到PoA，基于一组有限的已知参与者。这些方法之间的共同点是，它们都涉及到两个根本的网络角色：交易提交者（任何节点）和验证者（或矿工）。另一方面，分布式账本的共识可能涉及许多角色之间的更复杂交互，以提供更好的可扩展性，同时不损害存储数据的完整性。'
- en: '*Cryptocurrency*—The consensus algorithm of distributed ledgers not based on
    a blockchain structure isn’t based on PoW or PoS, so cryptocurrency isn’t needed,
    but some platforms still allow the generation of cryptocurrency or tokens to facilitate
    the exchange of monetary value, when needed.'
  id: totrans-594
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*加密货币*——基于非区块链结构的分布式账本的共识算法不是基于PoW或PoS，因此不需要加密货币，但某些平台仍然允许生成加密货币或代币，以在需要时促进货币价值的交换。'
- en: Two distributed ledger initiatives that have gathered considerable traction
    are Hyperledger and Corda. I’ll briefly sketch what they offer so you can get
    a better idea of what’s happening with alternative blockchain-based distributed
    ledgers.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 两个已经获得相当关注的分布式账本倡议是超账本和Corda。我会简要介绍它们提供的内容，以便你可以更好地了解基于区块链的分布式账本的发展情况。
- en: 15.3.1\. Hyperledger
  id: totrans-596
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.3.1. 超账本
- en: Around December 2015, the Linux foundation started a project called Hyperledger,
    whose strategic objective is to stimulate cross-industry collaboration through
    the development of distributed ledgers. Various distributed ledger frameworks
    have been tested under this successful project, sponsored by around 250 member
    organizations that provide funding and technical expertise. Two examples are Hyperledger
    Burrow, which includes its own implementation of the Ethereum Virtual Machine,
    and Hyperledger Iroha, whose focus is on mobile applications.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 大约在2015年12月，Linux基金会启动了一个名为超账本的项目，其战略目标是通过分布式账本的发展促进跨行业合作。在这个成功的项目中，已经有大约250个成员组织提供了资金和技术
    expertise。其中的两个例子是Hyperledger Burrow，它包括自己的以太坊虚拟机实现，以及Hyperledger Iroha，它专注于移动应用。
- en: Hyperledger Fabric ([www.hyperledger.org/projects/fabric](http://www.hyperledger.org/projects/fabric)),
    probably the most popular among the Hyperledger projects, was started with the
    objective of building a framework for enterprise blockchain applications. Its
    codebase was seeded with code developed by IBM, Digital Asset, and Blockstream
    during a hackathon that had taken place a few months earlier. Hyperledger Fabric
    is based on blockchain technology, but it’s designed on an open plug-and-play
    framework that allows you to change and customize many components of the architecture
    and adapt the platform to many industry use cases. For example, the consensus
    algorithm is pluggable by design, and you can write smart contracts in a variety
    of mainstream languages, such as Java, Java-Script, and Go. If you have time,
    the official documentation ([https://hyperledger-fabric.readthedocs.io](https://hyperledger-fabric.readthedocs.io))
    provides comprehensive information, from the high-level architecture to low-level
    implementation details of the platform.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 超账本Fabric（[www.hyperledger.org/projects/fabric](http://www.hyperledger.org/projects/fabric)），可能是超账本项目中最受欢迎的一个，其目标是构建企业区块链应用的框架。其代码库是在几个月前举行的一次黑客马拉松中由IBM、Digital
    Asset和Blockstream开发的一些代码的基础上建立起来的。超账本Fabric基于区块链技术，但它是一个开放的插件式框架，允许你更改和定制架构中的许多组件，并将平台适应于许多行业用例。例如，共识算法的设计是可插拔的，你可以用多种主流语言编写智能合约，如Java、JavaScript和Go。如果你有时间，官方文档（[https://hyperledger-fabric.readthedocs.io](https://hyperledger-fabric.readthedocs.io)）提供了从高级架构到平台低级实现细节的全面信息。
- en: 'Here are the main characteristics of Hyperledger Fabric that differ from traditional
    blockchain systems, such as Ethereum:'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是与以太坊等传统区块链系统相比，Hyperledger Fabric的主要特点：
- en: Up to four roles could take part in a transaction and contribute to the consensus:^([[5](#ch15fn05)])
  id: totrans-600
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个交易中可以有四个角色参与并共同达成共识：（见[[5](#ch15fn05)])
- en: ⁵
  id: totrans-601
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁵
- en: ''
  id: totrans-602
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: See “Transaction Flow” in the Hyperledger Fabric documentation at [http://mng.bz/Wadl](http://mng.bz/Wadl).
  id: totrans-603
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 参见超账本Fabric文档中的“交易流程”[http://mng.bz/Wadl](http://mng.bz/Wadl)。
- en: '*A submitting client* is a node that submits a transaction.'
  id: totrans-604
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提交客户端是一个提交交易的节点。
- en: '*An endorser* (or endorsing peer) is a node that verifies the electronic signature
    and endorses a transaction through an endorsing policy before it gets committed
    on the ledger; endorsers are generally all the parties that have to approve the
    transaction.'
  id: totrans-605
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 背书者（或背书对等节点）是一个通过背书策略在交易提交到账本之前验证电子签名并背书的节点；背书者通常是所有必须批准交易的一方。
- en: '*An orderer* is a node that runs the messaging service that provides ordering
    and delivery guarantees, when the transaction requires it.'
  id: totrans-606
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排序者是一个在交易需要时运行消息服务的节点，提供排序和交付保证。
- en: '*A committer* (or peer) is a node that commits a transaction and holds a copy
    of the ledger.'
  id: totrans-607
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提交者（或对等节点）是一个提交交易并持有账本副本的节点。
- en: The details of a transaction are private to only the interested participants.
    This is achieved through *channels*, subnetworks that provide isolated and confidential
    communication only among a number of authorized participants—a little bit like
    a WhatsApp group.
  id: totrans-608
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交易的详细信息仅对感兴趣的参与者私有。这是通过*通道*实现的，通道是提供隔离和保密通信的子网络—有点像WhatsApp群组。
- en: 'Another interesting blockchain framework that the Hyperledger project has developed
    under its umbrella is Hyperledger Sawtooth,^([[6](#ch15fn06)]) which introduces
    the following innovative features:'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的区块链框架是Hyperledger项目在其伞下开发的其他区块链框架Hyperledger Sawtooth，([[6](#ch15fn06)])，它引入了以下创新特性：
- en: ⁶
  id: totrans-610
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁶
- en: ''
  id: totrans-611
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: See “Hyperledger Releases Hyperledger Sawtooth 1.0,” January 30, 2018, [http://mng.bz/Ee2X](http://mng.bz/Ee2X).
  id: totrans-612
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 参见“Hyperledger发布Hyperledger Sawtooth 1.0，”2018年1月30日，[http://mng.bz/Ee2X](http://mng.bz/Ee2X)。
- en: '*Parallel transaction execution*—Most blockchain systems can only process transactions
    sequentially.'
  id: totrans-613
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*并行事务执行*—大多数区块链系统只能按顺序处理事务。'
- en: '*On-chain governance*—Participants can actively configure their network through
    smart-contract–based voting.'
  id: totrans-614
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*链上治理*—参与者可以通过基于智能合约的投票积极配置自己的网络。'
- en: '*Ethereum support*—As Hyperledger Burrow does, Sawtooth offers a compliant
    EVM capable of running Solidity contracts.'
  id: totrans-615
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*对以太坊的支持*—与Hyperledger Burrow一样，Sawtooth提供了一个符合EVM的智能合约运行环境，能够运行Solidity合约。'
- en: '*Dynamic consensus*—This goes beyond Fabric’s plug-in consensus design, as
    you can change consensus algorithms on the fly.'
  id: totrans-616
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*动态共识*—这超出了Fabric的插件共识设计，因为你可以随时更改共识算法。'
- en: '*Wider smart-contract language* *choice*—On top of the languages that Fabric
    supports, Sawtooth also supports Python.'
  id: totrans-617
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*更广泛的智能合约语言选择*—除了Fabric支持的语言之外，Sawtooth还支持Python。'
- en: The Hyperledger initiative has also coordinated the development of blockchain
    tools such as Hyperledger Composer, focused on helping users create smart contracts,
    and Hyperledger Explorer, which allows users to view and analyze block and transaction
    information.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: Hyperledger项目还协调了区块链工具的开发，如Hyperledger Composer，专注于帮助用户创建智能合约，以及Hyperledger
    Explorer，允许用户查看和分析区块和交易信息。
- en: 15.3.2\. Corda
  id: totrans-619
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.3.2\. Corda
- en: R3 is a consortium of companies formed in 2015 that has grown to around 200
    members, initially mainly from the financial sector but increasingly from other
    industries. They started Corda in 2016 as an open source project.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: R3是一个成立于2015年的公司联盟，现已增长到约200个成员，最初主要来自金融部门，但越来越多地来自其他行业。他们于2016年开始将Corda作为一个开源项目。
- en: The approach they took for creating Corda was different from that taken in the
    EEA and Hyperledger initiatives. In the first place, the technical stack is made
    of standard off-the-shelf parts, such as the Java Virtual Machine, relational
    databases, and message queues. Second, Corda achieves privacy by sharing data
    not among a group of participants, such as those interacting in a Hyperledger
    channel, but only at the level of individual transactions. Specifically, two or
    more nodes can share one or more facts, and each node maintains its own local
    copy of such facts. There’s no central database containing all facts, as illustrated
    in [figure 15.5](#ch15fig05) and described more extensively in the official documentation.^([[7](#ch15fn07)])
    This fine level of data sharing is provided through a *notary*, a network role
    that provides transaction ordering and timestamping.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 他们为创建Corda采取的方法与EEA和Hyperledger项目的做法不同。首先，技术堆栈由标准的现成组件组成，如Java虚拟机、关系数据库和消息队列。其次，Corda通过在个体交易层面而不是在Hyperledger通道中交互的一组参与者之间共享数据来实现隐私。具体来说，两个或更多节点可以共享一个或多个事实，每个节点都维护其自己的本地事实副本。没有包含所有事实的中心数据库，如图15.5和官方文档中更详细地描述的那样。[图15.5](#ch15fig05)展示了Corda网络中事实是如何共享的。每个节点都维护其自己的事实副本，但它可以与其他节点共享一些事实。例如，事实1和5在节点A和B之间共享；事实4只有节点C、D和E可见，而A和B不可见。
- en: ⁷
  id: totrans-622
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁷
- en: ''
  id: totrans-623
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: See “The ledger” in the Corda documentation at [https://docs.corda.net/key-concepts-ledger.html](https://docs.corda.net/key-concepts-ledger.html).
  id: totrans-624
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 参见Corda文档中的“账本”[https://docs.corda.net/key-concepts-ledger.html](https://docs.corda.net/key-concepts-ledger.html)。
- en: Figure 15.5\. How facts are shared in the Corda network. Each node maintains
    its own copy of its own facts, but it can share some facts with other nodes. For
    example, facts 1 and 5 are shared between nodes A and B; fact 4 is only visible
    to nodes C, D, and E, but not A and B.
  id: totrans-625
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图15.5\. Corda网络中事实的共享方式。每个节点都维护其自己的事实副本，但它可以与其他节点共享一些事实。例如，事实1和5在节点A和B之间共享；事实4只有节点C、D和E可见，而A和B不可见。
- en: '![](Images/fig15-05_alt.jpg)'
  id: totrans-626
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig15-05_alt.jpg)'
- en: As you can see, this is a domain that’s constantly evolving, and there are many
    different ways to solve problems. Hold tight and expect further innovation!
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这是一个不断发展的领域，有许多不同的解决问题的方法。紧握不放，期待更多的创新！
- en: Summary
  id: totrans-628
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: The EVM is being upgraded to a more general version supporting eWASM that ultimately
    will be able to execute code compiled from Rust and C.
  id: totrans-629
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EVM正在升级到一个更通用的版本，支持eWASM，最终能够执行从Rust和C编译的代码。
- en: Continuous improvements in Solidity syntax are resulting in changes such as
    the deprecation of `send()` and `call()` in favor of `transfer()`.
  id: totrans-630
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Solidity语法的持续改进导致了诸如`send()`和`call()`被废弃，转而使用`transfer()`等变化。
- en: Web3.js version 1.0, which is in beta at the time of writing, is about to become
    the official version to be used across the Ethereum ecosystem. I strongly advise
    you to reference it as soon as it’s released.
  id: totrans-631
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处于撰写时正处于测试阶段的Web3.js 1.0版本即将成为以太坊生态系统的官方版本。我强烈建议您一旦它发布就立即参考。
- en: 'Some alternative Ethereum networks are based on consensus algorithms different
    from Proof of Work: Kovan and Rinkeby support Proof of Authority, whereas the
    Casper project is introducing Proof of Stake.'
  id: totrans-632
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些以太坊网络采用了不同于工作量证明的共识算法：Kovan和Rinkeby支持权威证明，而Casper项目正在引入股份证明。
- en: An Enterprise Ethereum platform, such as Quorum, supports enterprise Dapp requirements
    such as scalability, permissioning, and privacy.
  id: totrans-633
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个企业以太坊平台，如Quorum，支持企业Dapp需求，如可扩展性、权限管理和隐私。
- en: Other distributed ledger platforms, such as Hyperledger or Corda, offer alternatives
    to Enterprise Ethereum.
  id: totrans-634
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他分布式账本平台，如Hyperledger或Corda，提供了企业以太坊的替代方案。
