- en: 6   Fast-Track Application Tutorial
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6   快速通道应用教程
- en: Whenever new technology comes along, especially for us developers, the first
    thing we want to learn is how to use the language to invoke its functionality
    and manipulate its data types. We want to know how to develop, validate, and deploy
    the application. The blockchain is no different. At the current time, the Bitcoin
    blockchain does not provide the comprehensive functionality required by lots of
    applications where blockchain can be applied and helpful. Ethereum, however, does
    provide a comprehensive functionality via its smart contracts capability using
    Solidity. In this chapter, we will introduce Solidity the language, a browser-based
    integrated development environment (IDE) to write and deploy Ethereum contracts.
    At the writing of this book mid-2017, Ethereum IDEs are not matured. That has
    been typical for new technologies and development, such as Java. When Java development
    started in the late 1980s, developers used tools like Notepad text editors to
    write Java programs and deploy them to application servers. It was a tough time
    for development. Ten or so years later, IDEs like Eclipse facilitate the development,
    testing, and deployment of Java applications. This evolution will no doubt take
    place with blockchain Ethereum and Solidity. It is merely a matter of time.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 每当新技术出现，尤其是对于我们开发者来说，我们首先想要学习的是如何使用这门语言来调用其功能和操作其数据类型。我们想要知道如何开发、验证和部署应用。区块链也不例外。在当前时间，比特币区块链并不提供许多应用所需的大量功能，而区块链的应用可以非常有益。然而，以太坊通过使用Solidity的智能合约功能确实提供了这些综合功能。在本章中，我们将介绍Solidity这门语言，以及一个基于浏览器的集成开发环境（IDE）来编写和部署以太坊合约。在本书撰写于2017年年中时，以太坊IDE尚未成熟。这在新技术和开发中很常见，就像Java一样。当Java开发在20世纪80年代末开始时，开发者使用像记事本这样的文本编辑器来编写Java程序，并将它们部署到应用服务器上。那是一个艰难的开发者时期。十年后，像Eclipse这样的IDE简化了Java应用程序的开发、测试和部署。这种演变无疑会在区块链以太坊和Solidity上发生。这只是时间问题。
- en: Introducing Solidity
  id: totrans-2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 介绍Solidity
- en: '*Solidity* the word means the quality or state of being firm or strong in structure.
    Solidity the language is a contract-oriented, high-level language whose syntax
    is similar to that of JavaScript. It is designed to target the Ethereum Virtual
    Machine (EVM). Solidity is statically typed and supports inheritance, libraries,
    and complex user-defined types among other features. This chapter provides a basic
    introduction to Solidity and assumes some knowledge of programming in general.
    You can start using Solidity in your browser, with no need to download or compile
    anything. This application only supports compilation—if you want to run the code
    or inject it into the blockchain, you have to use a client or blockchain gateway
    service such as INFURA.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '**Solidity**这个词语指的是结构坚固或强劲的品质或状态。Solidity语言是一种以合约为中心的高级语言，其语法与JavaScript相似。它被设计用来针对以太坊虚拟机（EVM）。Solidity是静态类型的，并支持继承、库以及复杂的自定义类型等众多特性。本章将为Solidity提供基本的介绍，并假定读者对编程有一定的了解。您可以在浏览器中开始使用Solidity，无需下载或编译任何内容。这个应用程序只支持编译——如果您想要运行代码或将其注入区块链，您必须使用像INFURA这样的客户端或区块链网关服务。'
- en: Solidity Basics
  id: totrans-4
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Solidity基础
- en: As mentioned, Solidity is an object-oriented programming language for writing
    smart contracts. Developers ask the question, “Is Solidity Turing complete?” An
    imperative language is Turing complete if it has conditional branching (such as
    `if`, `while`, `for`), conditional looping statements, and the ability to change
    an arbitrary amount of memory, such as the ability to maintain an arbitrary number
    of variables. Since this is almost always the case, most if not all imperative
    languages are Turing complete if the limitations of finite memory are ignored.
    The commonly used development languages C, C++, C#, Java, Lua, and Python are
    all Turing complete, as is Solidity. That said, most of the control structures
    from C/JavaScript are available in Solidity except for `switch`.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Solidity是一种用于编写智能合约的对象导向编程语言。开发者会问这样的问题，“Solidity是图灵完备的吗？” 命令式语言如果是图灵完备的，那么它具有条件分支（如`if`、`while`、`for`）、条件循环语句，以及改变任意内存的能力，比如维护任意数量变量的能力。由于这些特性几乎总是存在，如果忽略有限内存的限制，大多数或全部的命令式语言都是图灵完备的。常用的开发语言C、C++、C#、Java、Lua和Python都是图灵完备的，Solidity也是如此。话说回来，除了`switch`，Solidity中大多数控制结构都来自C/JavaScript。
- en: Let’s start with some basic code examples. The first question to ask is what
    is the current release of Solidity. When starting, one should always go to the
    GitHub site ([https://github.com/ethereum/solidity/releases](https://github.com/ethereum/solidity/releases)),
    which lists the releases and new functionality for Solidity. Once you know that,
    then the second statement in the contract would be the release. If you look at
    the sample code below, you’ll notice the specification of the current release
    of Solidity at the time of this writing.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一些基本代码示例开始。首先要问的是当前Solidity的版本是什么。在开始时，你应该总是去GitHub网站([https://github.com/ethereum/solidity/releases](https://github.com/ethereum/solidity/releases))，该网站列出了Solidity的发布和新功能。一旦你知道了，合同中的第二行就是版本。如果你看下面的示例代码，你会注意到指定了在撰写本文时Solidity的当前版本。
- en: '![Images](p0126-01.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![图片](p0126-01.jpg)'
- en: As mentioned, the first line indicates that the source code is written for Solidity
    version 0.4.16\. The keyword or directive `pragma` (from “pragmatic”) is a language
    construct that specifies how a compiler or translator should process its input.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，第一行表明源代码是为Solidity版本0.4.16编写的。关键词或指令`pragma`（来自“实用主义”）是一个语言结构，用于指定编译器或转换器应如何处理其输入。
- en: A contract in Solidity is code that includes the functionality and data that
    execute and record the state of the contract. The contract resides at a specific
    address on the Ethereum blockchain. This contract, StorageState, if it were written
    in Java would be a bean. Java beans declare some variables and include a getter
    and a setter for each of the variables used to modify or retrieve the value of
    the variable. The bean is usually a data structure that is passed around class
    to class containing data we wish to share. The line `uint stateData`; declares
    a state variable called stateData of type uint which is an unsigned integer of
    length 32 bytes. This contract, as mentioned, is a bean allowing anyone to store
    a single number that is accessible by anyone publishing this number. Just as in
    Java, by declaring the variable private we pose access restrictions such that
    only the internal contract code can modify the variable. As you would expect,
    single-line comments (//) and multi-line comments (/*...*/) are specified as depicted
    here.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在Solidity中的合约是包括执行和记录合约状态的功能和数据的代码。合约位于以太坊区块链上的特定地址。这个合约，StorageState，如果用Java编写，就是一个bean。Java
    bean声明一些变量，并为每个变量包括一个getter和一个setter，用于修改或检索变量的值。bean通常是一个在类与类之间传递的数据结构，包含我们希望共享的数据。`uint
    stateData`;这行代码声明了一个名为stateData的状态变量，其类型为uint，是一个32字节的无符号整数。这个合约，如前所述，是一个bean，允许任何人存储一个可以被任何人发布的数字。正如在Java中一样，通过将变量声明为private，我们设置了访问限制，使得只有内部合约代码可以修改变量。正如你所期望的，单行注释(//)和多行注释(/*...*/)如所示。
- en: Solidity Control and Flow Statements
  id: totrans-10
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Solidity控制和流语句
- en: 'As with most of the current computer languages, there are the familiar constructs:
    the Aristotelian conditional if-then-else, the loop functionality of while and
    for with the break, continue, return. See [Table 6-1](ch6.xhtml#ch6tab1) for descriptions
    and examples.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 与当前大多数计算机语言一样，有熟悉的构造：亚里士多德条件if-then-else，循环功能while和for以及break、continue、return。请参阅[表6-1](ch6.xhtml#ch6tab1)描述和示例。
- en: '**TABLE 6-1** Functionality and Control of Execution'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**表6-1** 执行的功能和控制'
- en: '![Images](tab6-1.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图片](tab6-1.jpg)'
- en: '![Images](tab6-1a.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图片](tab6-1a.jpg)'
- en: Data Types
  id: totrans-15
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 数据类型
- en: Solidity is a statically typed language, which means that the data type of each
    variable (state and local) needs to be specified at compile time. The following
    data types are also known as value types because they will always be passed by
    value as opposed to reference, i.e., they are always copied when they are used
    as function arguments or in assignments. See [Table 6-2](ch6.xhtml#ch6tab2) for
    descriptions and examples.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Solidity是一种静态类型语言，这意味着每个变量（状态和本地）的数据类型需要在编译时指定。以下数据类型也被称为值类型，因为它们总是按值传递，而不是按引用，即它们在作为函数参数或在赋值中使用时总是被复制。请参阅[表6-2](ch6.xhtml#ch6tab2)描述和示例。
- en: '**TABLE 6-2** Solidity Data Types and Related Functions'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**表6-2** Solidity数据类型及相关函数'
- en: '![Images](tab6-2.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图片](tab6-2.jpg)'
- en: '![Images](tab6-2a.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图片](tab6-2a.jpg)'
- en: '![Images](tab6-2b.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图片](tab6-2b.jpg)'
- en: '![Images](tab6-2c.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图片](tab6-2c.jpg)'
- en: Visibility Specifiers
  id: totrans-22
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 可见性指定符
- en: Functions and storage variables can be specified as being public, internal,
    or private, where the default for functions is public and for storage variables
    is internal. In addition, functions can also be specified as external. See [Table
    6-3](ch6.xhtml#ch6tab3) for descriptions and examples.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 函数和存储变量可以被指定为公共的、内部的或私有的，其中函数的默认属性是公共的，存储变量的默认属性是内部的。此外，函数还可以被指定为外部的。详见[表6-3](ch6.xhtml#ch6tab3)对于描述和示例。
- en: '**TABLE 6-3** Visibility of Constants and Variables'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**表6-3** 常量和变量的可见性'
- en: '![Images](tab6-3.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图片](tab6-3.jpg)'
- en: Block and Transaction Properties
  id: totrans-26
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 区块和交易属性
- en: There are special variables and functions that exist in the global namespace.
    They provide information about the blockchain. See [Table 6-4](ch6.xhtml#ch6tab4)
    for syntax and descriptions.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在全局命名空间中存在特殊的变量和函数。它们提供了关于区块链的信息。详见[表6-4](ch6.xhtml#ch6tab4)对于语法和描述。
- en: '**TABLE 6-4** Block and Transaction Properties'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**表6-4** 区块和交易属性'
- en: '![Images](tab6-4.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图片](tab6-4.jpg)'
- en: Order of Operations
  id: totrans-30
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 运算顺序
- en: The evaluation order of expressions is not specified (more formally, the order
    in which the children of one node in the expression tree are evaluated is not
    specified, but they are of course evaluated before the node itself). It is only
    guaranteed that statements are executed in order and short-circuiting for boolean
    expressions is done. See [Table 6-5](ch6.xhtml#ch6tab5) for descriptions and operators.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式的求值顺序未指定（更正式地说，表达式树中一个节点的子节点的求值顺序未指定，但当然它们会在节点本身之前被求值）。唯一保证的是语句按顺序执行，并且布尔表达式的短路求值已经完成。详见[表6-5](ch6.xhtml#ch6tab5)对于描述和操作符。
- en: '**TABLE 6-5** Order of Operations'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**表6-5** 运算顺序'
- en: '![Images](tab6-5.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图片](tab6-5.jpg)'
- en: Solidity Functions and Parameters
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 智能合约函数和参数
- en: A function is defined with the function keyword, followed by a name, followed
    by parentheses (). Function names can contain letters, digits, underscores, and
    dollar signs (same rules as variables). The parentheses may include parameter
    names separated by commas (parameter1, parameter2, ...). The code to be executed
    by the function is placed inside curly brackets {}. When the function reaches
    a return statement, the function will stop executing.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是用函数关键字定义的，后面跟着一个名称，后面跟着一对括号（）。函数名称可以包含字母、数字、下划线和美元符号（与变量相同的规则）。括号内可以包括由逗号分隔的参数名称（parameter1,
    parameter2, ...）。函数要执行的代码放在花括号{}内。当函数达到一个返回语句时，函数将停止执行。
- en: If the function was invoked from a statement, the contract will “return” to
    execute the code after the invoking statement. Functions often compute a return
    value. The return value is “returned” back to the “caller”. See [Table 6-6](ch6.xhtml#ch6tab6)
    for descriptions and examples.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数是从一个语句中调用的，合约将会“返回”在调用语句之后执行代码。函数通常会计算一个返回值。返回值被“返回”给“调用者”。详见[表6-6](ch6.xhtml#ch6tab6)对于描述和示例。
- en: '**TABLE 6-6** Functions and Parameters'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**表6-6** 函数和参数'
- en: '![Images](tab6-6.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图片](tab6-6.jpg)'
- en: Cryptographic Functions
  id: totrans-39
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 密码学函数
- en: A cryptographic hash function is a special class of hash function with properties
    that make it suitable for use in cryptography. It is a mathematical algorithm
    that maps data of arbitrary size to a bit string of a fixed size (a hash function),
    which is designed to also be a one-way function—that is, a function which is infeasible
    to invert. The only way to recreate the input data from an ideal cryptographic
    hash function’s output is to attempt a brute-force search of possible inputs to
    see if they produce a match, or to use a rainbow table of matched hashes.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 密码学哈希函数是一类具有使其适用于密码学特性的特殊哈希函数。它是一种将任意大小的数据映射到固定大小的位字符串（哈希函数）的数学算法，旨在也成为一个单向函数——即，一个难以逆向的函数。从理想的密码学哈希函数的输出重建输入数据唯一的方式是尝试可能的输入进行暴力搜索以查看它们是否产生匹配，或者使用匹配哈希的彩虹表。
- en: The secure hash algorithms are a family of cryptographic hash functions published
    by the National Institute of Standards and Technology (NIST) as a US Federal Information
    Processing Standard (FIPS). See [Table 6-7](ch6.xhtml#ch6tab7) for syntax and
    descriptions.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 安全哈希算法是一系列由美国国家标准与技术研究院（NIST）发布的密码学哈希函数，作为美国联邦信息处理标准（FIPS）。详见[表6-7](ch6.xhtml#ch6tab7)对于语法和描述。
- en: '**TABLE 6-7** Cryptographic Functions'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**表6-7** 密码学函数'
- en: '![Images](tab6-7.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图片](tab6-7.jpg)'
- en: Contract-Related Functions
  id: totrans-44
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 与合约相关的函数
- en: All functions of the current contract are callable directly, including the current
    function. See [Table 6-8](ch6.xhtml#ch6tab8) for syntax and descriptions.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当前合约的所有函数都可以直接调用，包括当前函数。有关语法和描述，请参见[表 6-8](ch6.xhtml#ch6tab8)。
- en: '**TABLE 6-8** Contract-Related Functions'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 6-8** 合约相关函数'
- en: '![Images](tab6-8.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图像](tab6-8.jpg)'
- en: Functions on Addresses
  id: totrans-48
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 地址上的函数
- en: It is possible to query the balance of an address using the property balance
    and to send ether (in units of wei) to an address using the send function. See
    [Table 6-9](ch6.xhtml#ch6tab9) for syntax and descriptions.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过属性 balance 查询地址的余额，并通过 send 函数向地址发送以太币（以 wei 为单位）。有关语法和描述，请参见[表 6-9](ch6.xhtml#ch6tab9)。
- en: '**TABLE 6-9** Functions on Addresses'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 6-9** 地址上的函数'
- en: '![Images](tab6-9.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图像](tab6-9.jpg)'
- en: Constructor Arguments
  id: totrans-52
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 构造函数参数
- en: A Solidity contract expects constructor arguments after the end of the contract
    data itself. This means that you pass the arguments to a contract by putting them
    after the compiled bytes as returned by the compiler in the usual application
    binary interface (ABI) format. The ABI is how you call functions in a contract
    and get data returned. An ABI is like an application program interface (API).
    It dictates how functions are called and in which binary format parameters are
    passed. An Ethereum smart contract is bytecode on the Ethereum blockchain. There
    are usually many functions in a contract. An ABI provides the specification regarding
    how functions in the contract are invoked, and a guarantee that the function will
    return data in the expected format.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Solidity 合约期望在合约数据本身结束之后提供构造函数参数。这意味着您通过在编译器返回的通常的应用二进制接口（ABI）格式的编译字节之后放置这些参数来调用合约。ABI
    是您如何调用合约中的函数以及如何返回数据的途径。ABI 就像一个应用程序编程接口（API）。它规定了函数是如何被调用的，以及参数是以哪种二进制格式传递的。以太坊智能合约是运行在以太坊区块链上的字节码。一个合约中通常有许多函数。ABI
    提供了关于如何调用合约中的函数的规范，并确保函数将返回预期格式的数据。
- en: 'From Ethereum’s ABI specification, an example:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 从以太坊 ABI 规范中，一个例子：
- en: '![Images](p0136-01.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图像](p0136-01.jpg)'
- en: 'If we wanted to call abc with the parameters 77 and true, we would pass 68
    bytes total, which can be broken down into the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要用参数 77 和 true 调用 abc，我们会传递总共 68 个字节，这可以分解为以下内容：
- en: '•   The method ID: This is derived as the first 4 bytes of the Keccak-256 hash
    of the ASCII form of the signature `abc(uint32,bool)`.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: •   方法 ID：这是由 ASCII 格式的签名 `abc(uint32,bool)` 的 Keccak-256 哈希的前 4 个字节生成的。
- en: '•   0x000000000000000000000000000000000000000000000000000000000000004D: The
    first parameter, a uint32 value 77 padded to 32 bytes.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: •   0x000000000000000000000000000000000000000000000000000000000000004D：第一个参数，一个
    uint32 值 77 填充至 32 个字节。
- en: '•   0x0000000000000000000000000000000000000000000000000000000000000001: The
    second parameter, boolean true, padded to 32 bytes.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '•   0x0000000000000000000000000000000000000000000000000000000000000001: 第二个参数，布尔值
    true，填充至 32 个字节。'
- en: Using a higher-level library such as web3.js abstracts most of these details,
    but the ABI in JSON format still needs to be provided to web3.js.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 使用像 web3.js 这样的高级库抽象了大多数这些细节，但仍然需要以 JSON 格式的 ABI 提供给 web3.js。
- en: ABI is an abstraction and not part of the core Ethereum protocol. Anyone can
    define their own ABI for their contracts. That said, it is simpler for all developers
    to use Solidity, Serpent, and web3.js, which all comply with the ABI above.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ABI 是一种抽象，不是以太坊核心协议的一部分。任何人都可以为其合约定义自己的 ABI。不过，所有开发者使用 Solidity、Serpent 和 web3.js
    会更简单，这些工具都符合上述 ABI。
- en: Accessor Functions
  id: totrans-62
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 访问器函数
- en: The compiler automatically creates accessor functions for all public state variables.
    The contract given below will have a function called `data` that does not take
    any arguments and returns a uint, the value of the state variable data. The initialization
    of state variables can be done at declaration.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器会自动为所有公共状态变量创建访问器函数。下面给出的合约将有一个名为 `data` 的函数，该函数不接受任何参数并返回一个 uint 类型，即状态变量
    data 的值。状态变量的初始化可以在声明时完成。
- en: '![Images](p0137-01.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图像](p0137-01.jpg)'
- en: Layout of Storage
  id: totrans-65
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 存储布局
- en: 'Statically sized variables (everything except mapping and dynamically sized
    array types) are laid out contiguously in storage starting from position 0\. Multiple
    items that need less than 32 bytes are packed into a single storage slot if possible,
    according to the following rules:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 静态大小的变量（除了映射和动态大小的数组类型之外的所有类型）从位置 0 开始在存储中连续布局。如果可能的话，多个需要少于 32 字节的项会被打包到单个存储槽中，遵循以下规则：
- en: •   The first item in a storage slot is stored lower-order aligned.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: •   存储槽中的第一个项目是低位对齐存储。
- en: •   Elementary types use only as many bytes as are necessary to store them.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: •   基本类型只使用存储它们所必需的字节数。
- en: •   If an elementary type does not fit the remaining part of a storage slot,
    it is moved to the next storage slot.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: •   如果一个基本类型不适合存储槽的剩余部分，它会被移动到下一个存储槽。
- en: •   Structs and array data always start a new slot and occupy whole slots, but
    items inside a struct or array are packed tightly according to these rules.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: •   结构体和数组数据总是开始一个新的槽位，并占用整个槽位，但结构体或数组内的项目是根据这些规则紧密打包的。
- en: The elements of structs and arrays are stored after each other, just as if they
    were given explicitly.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体（struct）和数组（array）的元素是按照顺序存储的，就像它们被明确给出一样。
- en: Due to their unpredictable size, mapping and dynamically sized array types use
    a `sha3` computation to find the starting position of the value or the array data.
    These starting positions are always full stack slots.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们的大小不可预测，映射和动态大小的数组类型使用`sha3`计算来找到值或数组数据的起始位置。这些起始位置总是完整的栈槽位。
- en: The mapping or the dynamic array itself occupies an (unfilled) slot in storage
    at some position according to the above rule (or by recursively applying this
    rule for mappings to mappings or arrays of arrays). For a dynamic array, this
    slot stores the number of elements in the array. For a mapping, the slot is unused,
    but it is needed so that two equal mappings after each other will use a different
    hash distribution. Array data is located at `sha3(p)` and the value corresponding
    to a mapping key is located at `sha3(k . p)` where . is concatenation. If the
    value is again a non-elementary type, the positions are found by adding an offset
    of `sha3(k . p)`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 映射或动态数组本身根据上述规则（或通过递归应用此规则对映射到映射或数组）在存储中占用某个位置的（未填充）槽位。对于动态数组，此槽位存储数组中的元素数量。对于映射，该槽位未使用，但它是为了使两个相等的映射紧随其后时会使用不同的哈希分布而必需的。数组数据位于`sha3(p)`，与映射键对应的值位于`sha3(k
    . p)`，其中.是连接。如果值再次是非基本类型，通过添加`sha3(k . p)`的偏移量来找到位置。
- en: 'So for the following contract snippet:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 所以对于下面的合约片段：
- en: '![Images](p0138-01.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0138-01.jpg)'
- en: Run Ethereum Dapps in Your Browser
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在您的浏览器中运行以太坊Dapps
- en: 'Prior to blockchain, the application development life cycle, which facilitated
    large “Web2” applications, was built using tools like HTML, CSS, JavaScript, REST
    web services, Java, SQL, and NOSQL data stores. Now it is being amended to integrate
    the blockchain onto that stack. Ethereum enables the decentralized web, referred
    to as “Web3.” What makes it different from Web2 is that on Ethereum the web servers
    are gone except where used to access some verifiable condition needed to support
    smart contract execution. So the new dapp (“decentralized application”) is just
    like most applications. It consists of two parts: classic front-end and back-end
    architecture. As you would expect the frontend is written to either handle web
    services like REST or provide an HTML/CSS user experience to handle user requests
    and provide a response. The other part of the application is the backend, which
    interacts with the blockchain, the new “database.” So how does a web browser application
    converse with the blockchain?'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在区块链之前，构建大型“Web2”应用程序的应用开发生命周期是使用HTML、CSS、JavaScript、REST web服务、Java、SQL和NOSQL数据存储等工具构建的。现在它被修改以将区块链集成到该堆栈中。以太坊使去中心化的网络，即“Web3”成为可能。与Web2不同的地方在于，在以太坊上，除了用于访问支持智能合约执行的某些可验证条件所需的web服务器外，web服务器都不存在。所以新的dapp（去中心化应用程序）就像大多数应用程序一样。它由两部分组成：经典的
    前端和后端架构。正如您所预期的，前端要么处理像REST这样的web服务，要么提供HTML/CSS用户体验以处理用户请求并提供响应。应用程序的另一个部分是后端，它与区块链交互，新的“数据库”。那么，网络浏览器应用程序是如何与区块链交流的呢？
- en: MetaMask solves that key blockchain usability point of friction by providing
    a way for normal browsers to access the blockchain and propose transactions, to
    help anyone accomplish any action on the blockchain, easily and securely, enabling
    a new kind of web browsing experience.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: MetaMask通过为普通浏览器提供访问区块链和提出交易的方式，解决了区块链关键的易用性问题，帮助任何人轻松、安全地在区块链上完成任何操作，从而启用了一种新的网页浏览体验。
- en: MetaMask is a browser extension that injects the web3 API into every website
    you visit. Using MetaMask, you can use the browser you are comfortable with to
    browse the emerging decentralized web. The key advantage of using MetaMask is
    simplified key management. It encrypts your private key locally and asks users
    to confirm and sign transactions and messages as requested before relaying them
    to the Ethereum blockchain.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: MetaMask 是一个浏览器扩展，它将 web3 API 注入到你访问的每个网站。使用 MetaMask，你可以使用你熟悉的浏览器来浏览新兴的去中心化网络。使用
    MetaMask 的关键优势是简化的密钥管理。它本地加密你的私钥，并要求用户在请求之前确认和签署交易和消息，然后将其传达给以太坊区块链。
- en: In order to interact with the blockchain, a client needs access to the entire
    chain. This implies that for MetaMask to interact with the blockchain, it would
    need to download the entire blockchain locally for use. To circumvent this, a
    “zero-client” gateway can be used for instant access via RPC to and from the blockchain.
    The JSON-RPC API was discussed in the previous chapter. MetaMask uses INFURA as
    its gateway, which allows for instant setup simply by installing an extension.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与区块链互动，客户端需要访问整个链。这意味着MetaMask要与区块链互动，需要在本地下载整个区块链供使用。为了避免这个问题，可以使用“零客户端”网关，通过RPC即时访问区块链。上一章讨论了JSON-RPC
    API。MetaMask 使用 INFURA 作为其网关，通过安装一个扩展就可以简单地进行即时设置。
- en: Installing MetaMask
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 安装MetaMask
- en: MetaMask is currently available as a Chrome extension, with other browser support
    under active development. The technology is advancing rapidly that could ultimately
    allow for MetaMask to function within a browser without requiring an extension.
    To install MetaMask, simply visit the Chrome Web Store, search for and install
    MetaMask.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: MetaMask 目前作为 Chrome 扩展提供，其他浏览器支持正在积极开发中。技术正在快速发展，最终可能允许MetaMask在不需要扩展的情况下在浏览器内运行。要安装MetaMask，只需访问
    Chrome 网上应用店，搜索并安装MetaMask。
- en: Developing a Contract Using MetaMask
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用MetaMask开发合约
- en: After installing, you will see the MetaMask fox logo in the browser toolbar.
    The first time using the application you will need to generate your wallet public
    and private keys. The private key will be encrypted locally using a password you
    set. You will also be given a recovery seed phrase which you should save and store
    securely if you plan to use MetaMask to store real value. If you forget your wallet
    password, lose your computer, or otherwise can’t get access to your MetaMask wallet,
    you will be able to restore to a fresh browser using this seed phrase.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 安装后，你将在浏览器工具栏看到MetaMask狐狸标志。第一次使用应用程序时，你需要生成你的钱包公钥和私钥。私钥将使用你设置的密码在本地加密。你还将被提供一个恢复种子短语，如果你计划使用MetaMask存储真实价值，你应该安全地保存和存储这个短语。如果你忘记你的钱包密码，丢失你的电脑，或者以其他方式无法访问你的MetaMask钱包，你将能够使用这个种子短语恢复到一个新的浏览器。
- en: The Ethereum wallet is a gateway to decentralized applications on the Ethereum
    blockchain. It allows you to hold and secure ether and other crypto-assets built
    on Ethereum, as well as write, deploy, and use smart contracts. MetaMask provides
    an Ethereum wallet inside your browser. Metamask hosts a wallet with your private
    key—an Ethereum wallet—and allows you to access sites directly in your Chrome
    browser and trade as if you had your wallet right there with you on the site.
    The MetaMask user interface is quite simple, as seen in [Figure 6-1](ch6.xhtml#ch6fig1).
    Your Ethereum account address is available, with links to a more detailed view
    of the account activity on a popular blockchain explorer. When on the Ethereum
    Main Net, you have the option to buy the ether token via integrations with popular
    exchanges such as Coinbase, where you can buy ether for fiat currency such as
    USD, or ShapeShift, where you can convert existing cryptocurrencies such as bitcoin
    to ether. You can send transactions as well, including sending the ether token
    to another account or smart contract.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Ethereum 钱包是进入以太坊区块链上去中心化应用的门户。它允许你持有和保管以太币和其他建立在以太坊上的加密资产，以及编写、部署和使用智能合约。MetaMask
    在你的浏览器内部提供了以太坊钱包。MetaMask 托管了一个包含你私钥的钱包——一个以太坊钱包——并允许你直接在 Chrome 浏览器中访问网站并进行交易，就好像你的钱包就在网站旁边一样。MetaMask
    用户界面相当简单，如图[6-1](ch6.xhtml#ch6fig1)所示。你的以太坊账户地址可用，附有链接到流行区块链浏览器上账户活动的更详细视图。在以太坊主网上，你有通过与
    Coinbase 等流行交易所的集成选项购买以太币代币，你可以在那里用法定货币如 USD 购买以太币，或者通过 ShapeShift 转换现有的加密货币如比特币到以太币。你也可以发送交易，包括将以太币代币发送到另一个账户或智能合约。
- en: '![Images](fig6-1.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![Images](fig6-1.jpg)'
- en: '**FIGURE 6-1   MetaMask user interface**'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 6-1   MetaMask 用户界面**'
- en: In order to interact with the Ethereum blockchain, it is necessary to pay “gas”
    costs for each computational step a smart contract takes. Since this could become
    quite costly during development, test networks exist where the ether has no real-world
    value. In this way, development and testing can occur without risk of lost value.
    One such test network is called Ropsten. MetaMask supports Ropsten natively with
    INFURA on the backend communicating with the Ropsten chain. For now, you can switch
    MetaMask to use the Ropsten network on the top navigation bar of the MetaMask
    interface.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与以太坊区块链交互，有必要为智能合约的每个计算步骤支付“燃气”费用。由于在开发过程中这可能变得相当昂贵，因此存在测试网络，在这些网络中，以太币没有实际价值。这样，开发和测试可以在不承担价值损失风险的情况下进行。这样一个测试网络被称为
    Ropsten。MetaMask 原生支持 Ropsten，使用 INFURA 在后台与 Ropsten 链通信。现在，你可以在 MetaMask 界面的顶部导航栏上切换
    MetaMask 以使用 Ropsten 网络。
- en: In the next step, we will start to write our first smart contract. To deploy
    that to the Ropsten test network we will need some Ropsten test ether. You can
    click the Buy button in MetaMask to get a link to the Ropsten faucet. At the faucet,
    you can request 1 ether. As soon as that transaction is included on the Ropsten
    blockchain, your ether balance in MetaMask will be 1\. We will come back to this
    later when we deploy a smart contract.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步中，我们将开始编写我们的第一个智能合约。为了将其部署到 Ropsten 测试网络，我们需要一些 Ropsten 测试以太币。你可以在 MetaMask
    中点击购买按钮获取 Ropsten 喷泉的链接。在喷泉处，你可以请求 1 以太币。一旦这笔交易包含在 Ropsten 区块链上，你MetaMask 中的以太币余额将是
    1。我们稍后会回到这里，当我们部署一个智能合约时。
- en: MetaMask is the gateway that allows your web-based decentralized application
    to interact with the blockchain. Deployed smart contracts on the blockchain are
    the backbone of the decentralized web. Now that we have a gateway to interact
    with these smart contracts, we can look more closely at how to write and deploy
    them.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: MetaMask 是允许你的基于网页的去中心化应用程序与区块链交互的网关。部署在区块链上的智能合约是去中心化网络的支柱。现在我们已经有了与这些智能合约交互的网关，我们可以更详细地了解如何编写和部署它们。
- en: Remix/Browser Solidity
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Remix/Browser Solidity
- en: 'Smart contracts for the Ethereum blockchain are written in high-level languages
    and compiled to bytecode interpreted by the Ethereum Virtual Machine (EVM). Compilers
    exist for the following languages, developed specifically for Ethereum: LLL, Serpent,
    and Solidity. There are active efforts to further the development of LLL and Serpent,
    but for now Solidity is the most popular language used by Ethereum developers.
    The easiest way to get your feet wet with Solidity is through the Remix Solidity
    IDE and compiler.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊区块链上的智能合约是用高级语言编写的，并编译成由以太坊虚拟机（EVM）解释的字节码。为以太坊专门开发的以下语言有编译器：LLL、Serpent 和
    Solidity。人们正在积极努力进一步开发 LLL 和 Serpent，但目前 Solidity 是以太坊开发者中最受欢迎的语言。深入了解 Solidity
    的最简单方法是通过 Remix Solidity IDE 和编译器。
- en: Remix is an online Solidity editor that enables compilation of Solidity code
    and even deployment to the blockchain using MetaMask. To access Remix, visit [https://remix.ethereum.org](https://remix.ethereum.org).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Remix 是一个在线 Solidity 编辑器，它支持编译 Solidity 代码，甚至可以使用 MetaMask 将其部署到区块链上。要访问 Remix，请访问[https://remix.ethereum.org](https://remix.ethereum.org)。
- en: When you first visit the Remix interface, you will see sample Solidity code
    in the editor window. For this exercise, we will be starting with a much more
    basic smart contract.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当你第一次访问 Remix 界面时，你将在编辑器窗口中看到示例 Solidity 代码。对于这个练习，我们将从一个更基本的智能合约开始。
- en: Develop a Simple Smart Contract
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 开发一个简单的智能合约
- en: 'Let’s write our first smart contract! Open Remix in a browser and create an
    empty new file by clicking the + at the top left. Enter the following Solidity
    code into the editor:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写我们的第一个智能合约！在浏览器中打开 Remix，并通过点击顶部左侧的+创建一个空的新文件。将以下 Solidity 代码输入编辑器：
- en: '![Images](p0140-01.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![Images](p0140-01.jpg)'
- en: This is a very simple smart contract that when executed writes “Hello World!”
    to the transaction log for that contract address. By default, Remix is set to
    autocompile as you are typing. When you have completely entered the code with
    no syntax errors, the Contract tab on the right side of the Remix interface will
    show the compiled bytecode and the application binary interface (ABI) needed to
    interact with the contract. The ABI is a JSON-formatted text string you will use
    in your code that interacts with a smart contract.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的智能合约，当执行时会在该合约地址的交易日志中写入“Hello World!”。默认情况下，Remix设置为在你输入时自动编译。当你完全输入了代码且没有语法错误时，Remix界面右侧的合约标签页将显示编译后的字节码和与合约交互所需的应用程序二进制接口（ABI）。ABI是一个你将在与智能合约交互的代码中使用的JSON格式文本字符串。
- en: Remix provides a whole set of other features, including a debugger, formal verification,
    and of course links to complete documentation of the Solidity language. Remix
    has integrated deployment capabilities, which coupled with MetaMask make deployment
    painless.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Remix提供了一系列其他功能，包括调试器、形式验证，当然还有对Solidity语言完整文档的链接。Remix集成了部署功能，与MetaMask结合使得部署变得无痛。
- en: Deploy the Smart Contract
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 部署智能合约
- en: As previously mentioned, the Remix compiler auto-compiles as you type into the
    editor window. When the smart contract is syntactically correct, the right panel
    Contract tab will provide the compiled bytecode; the ABI and web3 deploy JavaScript
    code on the Contract Details tab. You should see something similar to [Figure
    6-2](ch6.xhtml#ch6fig2). The bytecode is what is actually sent to the blockchain.
    This transaction must first be signed by your private key. MetaMask makes this
    easy.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Remix编译器在你在编辑器窗口中输入时自动编译。当智能合约语法正确时，右侧的合约标签页会提供编译后的字节码；在合约详情标签页上有ABI和web3部署JavaScript代码。你应该看到类似于[图6-2](ch6.xhtml#ch6fig2)的东西。字节码是实际发送到区块链的内容。这个交易首先必须用你的私钥签署。MetaMask使这变得简单。
- en: '![Images](fig6-2.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![Images](fig6-2.jpg)'
- en: '**FIGURE 6-2   Remix compiler with smart contract Solidity code**'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**图6-2   Remix编译器带有智能合约Solidity代码**'
- en: First, in Remix, select Injected Web3 in the option to select execution environment.
    This tells Remix that you want to rely on MetaMask in your browser to intercept
    and handle any interactions with the web3 APIs. Now you are ready to deploy Hello
    World to the Ropsten network. Assuming you have pointed MetaMask at Ropsten and
    your Hello World contract has compiled successfully, you can click the Create
    button.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在Remix中，选择注入Web3在选择执行环境选项中。这告诉Remix你想要依靠MetaMask在你的浏览器中拦截和处理与web3 API的任何交互。现在你准备将Hello
    World部署到Ropsten网络。假设你已经将MetaMask指向Ropsten，并且你的Hello World合约已经成功编译，你可以点击创建按钮。
- en: When you click Create, Remix will create a transaction to send to the Ropsten
    test network. That transaction must first be signed, so a MetaMask window will
    pop up asking you to accept the transaction (see [Figure 6-3](ch6.xhtml#ch6fig3)).
    By accepting, you are effectively signing the transaction with your private key
    in your MetaMask wallet and sending the signed transaction to the Ethereum blockchain.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当你点击创建时，Remix会在Ropsten测试网络上创建一个交易。那个交易首先必须被签署，所以一个MetaMask窗口会弹出，要求你接受交易（参见[图6-3](ch6.xhtml#ch6fig3)）。通过接受，你实际上是用你MetaMask钱包里的私钥签署了交易，并将签署的交易发送到以太坊区块链。
- en: '![Images](fig6-3.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![Images](fig6-3.jpg)'
- en: '**FIGURE 6-3   MetaMask transaction signing**'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**图6-3   MetaMask交易签署**'
- en: After accepting, you will see Remix telling you that the transaction is waiting
    to be mined. As soon as this pending transaction is mined, or included in a block,
    you will see the contract address where this newly deployed smart contract can
    be found on the blockchain. In this case, the contract address is `0x2f8eb76Db701a36f8F44C1cEf0402bD329F6C03B`.
    Once this contract has been deployed to the blockchain, it cannot be changed,
    deleted, or tampered with. It is now an immutable piece of software that when
    executed will do exactly what it should. Namely, log Hello World.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 接受之后，你会看到Remix告诉你交易正在等待被挖掘。一旦这个待处理的交易被挖掘，或者包含在一个区块中，你就能在区块链上找到这个新部署的智能合约的合约地址。在这个例子中，合约地址是`0x2f8eb76Db701a36f8F44C1cEf0402bD329F6C03B`。一旦这个合约被部署到区块链上，它就不能被更改、删除或篡改。现在它是一个不可变的软件片段，当执行时会精确地完成它应该做的事情。具体来说，记录“Hello
    World”。
- en: Validate the Smart Contract
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 验证智能合约
- en: To validate that our Hello World smart contract has been deployed, we can look
    it up in a block explorer. Recall that a property of most blockchains is complete
    transparency to the blocks and the data in each transaction. A block explorer
    is like a search engine that allows you to look into all of the data contained
    on the chain. The leading explorer in the Ethereum ecosystem is Etherscan (etherscan.io).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证我们的Hello World智能合约是否已部署，我们可以在区块浏览器中查找它。回想一下，大多数区块链的一个特性是对区块和每个交易中的数据完全透明。区块浏览器就像一个搜索引擎，允许你查看链上包含的所有数据。以太坊生态系统的领先浏览器是Etherscan（etherscan.io）。
- en: Etherscan supports multiple test networks, in addition to the main Ethereum
    network. To search for your newly deployed contract, first select the Ropsten
    network in Etherscan. On the MISC menu, you will be able to choose Ropsten. Then
    you can search for the contract address you received from Remix when you deployed
    the contract. Etherscan should identify the address as a contract, as opposed
    to a user account. The contract is holding 0 ether and has had one transaction,
    which was the contract creation we just did. You’ll be able to see what block
    this contract was created on as well, which can be useful in proving a timeline
    of activity. Furthermore, you’ll see who created the contract—this is your MetaMask
    wallet address as MetaMask was the wallet that signed the transaction and sent
    it to the test network.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Etherscan支持多个测试网络，除了主要的以太坊网络。要搜索你新部署的合约，首先在Etherscan中选择Ropsten网络。在MISC菜单上，你可以选择Ropsten。然后，你可以输入你在部署合约时从Remix接收的合约地址进行搜索。Etherscan应该将该地址标识为合约，而不是用户账户。合约持有0个以太币，并完成了一次交易，即我们刚刚完成的合约创建。你还将能够查看这个合约是在哪个区块中创建的，这可以在证明活动的时间线时很有用。此外，你将看到谁创建了合约——这是你的MetaMask钱包地址，因为MetaMask是签署交易并将其发送到测试网络的钱包。
- en: Now that we know the contract exists, let’s execute it so we can validate that
    it behaves as we expect. To execute the contract, we need to send a transaction
    to the contract itself. There is no need to send any ether to the contract—in
    fact, if you do, that ether will be lost forever because the contract isn’t written
    to do anything with any ether sent to it. Therefore, we can send an empty transaction
    to the contract address to execute it. How will we send a transaction? The answer
    again is MetaMask.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们知道合约存在，让我们执行它，以便我们可以验证它是否如我们预期的那样行为。要执行合约，我们需要向合约本身发送一个交易。向合约发送以太币是没有必要的——事实上，如果你这样做，那些以太币将永远丢失，因为合约没有写入处理发送给它的任何以太币。因此，我们可以向合约地址发送一个空交易来执行它。我们将如何发送交易？答案又是MetaMask。
- en: Back in MetaMask, ensure you are on the Ropsten network. You should still have
    plenty of ether left since the last transaction used just a tiny bit. To create
    a transaction, click Send in MetaMask. For the Recipient Address, enter the address
    of your smart contract. For Amount, leave that at 0 and click Send. Again, you
    will be prompted to accept the transaction. After acceptance, the transaction
    will be sent to Ropsten and eventually included in a block and written to the
    blockchain.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 回到MetaMask，确保你处于Ropsten网络。由于上一次交易只用了一点以太币，你应该还剩下很多以太币。要创建交易，在MetaMask中点击发送。在收件人地址处，输入你的智能合约地址。在金额处，保持为0并点击发送。再次，你会被提示接受交易。接受后，交易将被发送到Ropsten，并最终包含在一个区块中并写入区块链。
- en: 'Back at Etherscan, you will notice now there are two transactions for this
    smart contract. The first is the contract creation, and the most recent is our
    transaction we just sent causing the code to execute. If we drill into the details
    for that most recent transaction, we see a handful of metadata about the transaction
    itself. In Etherscan, they also provide the event logs. In the event log for our
    contract, the data payload is stored in hexadecimal format. Etherscan conveniently
    provides a conversion to text, and we see what we are expecting to see: Hello
    World! Congratulations on successfully deploying your first smart contract!'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 回到Etherscan，你会注意到现在这个智能合约有两个交易记录。第一个是合约的创建，最近的一个是我们刚刚发送的交易，导致代码执行。如果我们深入查看最近这个交易的细节，我们会看到一些关于交易本身的元数据。在Etherscan中，他们还提供了事件日志。在我们合约的事件日志中，数据负载以十六进制格式存储。Etherscan便利地提供了文本转换，我们看到了我们所期望看到的内容：Hello
    World! 恭喜你成功部署了你的第一个智能合约！
- en: 'Next Step: Try Truffle'
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 下一步：尝试Truffle
- en: 'If you’re interested in some interesting tutorials or you want to start building
    web-based applications with the Ethereum blockchain, you will find the Truffle
    web framework to be a nice fit for your needs. For many types of dapps, Truffle
    does everything you could want: it compiles your blockchain contracts, injects
    them into your web app, and can even run a test suite against them! See [http://truffleframework.com/](http://truffleframework.com/)
    for documentation and tutorials.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对一些有趣的教程感兴趣，或者你想开始使用以太坊区块链构建基于网页的应用程序，你会发现Truffle网络框架非常符合你的需求。对于许多类型的去中心化应用（DApps），Truffle能做你想要的一切：它编译你的区块链合约，将它们注入到你的网页应用中，甚至可以针对它们运行测试套件！查看[http://truffleframework.com/](http://truffleframework.com/)获取文档和教程。
- en: Summary
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we introduced the Solidity smart contract programming language
    and tools that make it simple and easy to fast-track deploy a smart contract to
    the Ethereum blockchain. In the next chapter, we will introduce tools that are
    a little more complex and support a development workflow to handle more complex
    development.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了Solidity智能合约编程语言以及使它简单易行、快速部署到以太坊区块链的工具。在下一章中，我们将介绍一些更复杂的支持处理更复杂开发工作流程的工具。
