- en: © Santiago Palladino 2019S. PalladinoEthereum for Web Developers[https://doi.org/10.1007/978-1-4842-5278-9_4](https://doi.org/10.1007/978-1-4842-5278-9_4)
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: © Santiago Palladino 2019S. Palladino《面向 Web 开发者的以太坊》[https://doi.org/10.1007/978-1-4842-5278-9_4](https://doi.org/10.1007/978-1-4842-5278-9_4)
- en: 4. Querying the Network
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询网络
- en: Santiago Palladino^([1](#Aff2) )(1)Ciudad Autónoma de Buenos Aires, Argentina
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Santiago Palladino^([1](#Aff2) )(1)阿根廷布宜诺斯艾利斯自治市
- en: After a not-so-brief interlude on writing smart contracts, we will review the
    different ways to connect to the Ethereum network to retrieve data. We will cover
    different connection methods, as well as patterns for listening to changes, and
    put it all together in a sample application for monitoring transfers of an ERC20
    token.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在对编写智能合约进行了不那么简要的插曲之后，我们将审查连接到以太坊网络以检索数据的不同方法。我们将涵盖不同的连接方法，以及监听更改的模式，并在一个用于监视
    ERC20 代币转账的示例应用程序中将它们整合起来。
- en: Connecting to the Network
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接到网络
- en: The first step in retrieving data from the network is to actually connect to
    an Ethereum node. Since web applications do not connect directly to the network,
    they depend on a node to answer any queries on the blockchain state. We will start
    by reviewing node types, connection methods, and the provider object.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 从网络中检索数据的第一步是实际连接到以太坊节点。由于 Web 应用程序不能直接连接到网络，它们依赖于节点来回答对区块链状态的任何查询。我们将从审查节点类型、连接方法和提供者对象开始。
- en: About Full and Light Nodes
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关于完整节点和轻节点
- en: A typical Ethereum node is a Geth or Parity instance^([1](#Fn1)) that has its
    own copy (partial or full) of the blockchain, can answer queries from clients
    (such as a DApp), and relays transactions (more on this in the next chapter).
    A node with a full copy of the blockchain is called a *full node* . These nodes
    either have or can recompute any data from the blockchain history. Most clients
    run in this mode by default.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的以太坊节点是 Geth 或 Parity 实例^([1](#Fn1))，它拥有自己的区块链副本（部分或全部），可以回答客户端（如 DApp）的查询，并转发交易（更多内容请参阅下一章）。具有区块链完整副本的节点称为*完整节点*。这些节点可以获取或重新计算区块链历史中的任何数据。大多数客户端默认以此模式运行。
- en: Full nodes may also store all historical data. These nodes are called *archive
    nodes* , and they are much more infrequent, due to the large amount of disk size
    needed to support them – nearly 2TB at the time of this writing. They are required
    in case you want to query particular information from older blocks, such as the
    state of a contract or a balance of an account from a year ago.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 完整节点也可能存储所有历史数据。这些节点被称为*归档节点*，由于需要支持它们的大量磁盘空间，它们相对较少见——在撰写本文时约为 2TB。它们是必需的，以防您想要查询旧区块的特定信息，例如一年前合约的状态或帐户的余额。
- en: As an alternative to full nodes, some nodes may run in *light client* mode.
    These nodes keep only the block headers, and request information from the network
    as needed. They are much lighter to run than full nodes, which make them suitable
    for mobile devices, but make a poor choice for the back end of a DApp, since queries
    take longer to resolve.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 作为完整节点的替代方案，一些节点可能以*轻客户端*模式运行。这些节点仅保留区块头，并根据需要从网络请求信息。它们比完整节点轻得多，适合于移动设备，但不适合于
    DApp 的后端，因为查询需要更长时间解决。
- en: Infura and Public Nodes
  id: totrans-10
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Infura 和公共节点
- en: The next question about nodes is which ones are available for our applications.
    In an ideal decentralized scenario, every user should be running their own full
    Ethereum node, in order to validate all transactions themselves, and avoid trusting
    a third party. Users on mobile or IOT devices may choose to run light nodes instead,
    which would trust other nodes to relay the information but nevertheless verify
    it.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 关于节点的下一个问题是哪些节点适用于我们的应用程序。在理想的去中心化场景中，每个用户都应该运行自己的完整以太坊节点，以便自己验证所有交易，并避免信任第三方。移动设备或物联网设备上的用户可以选择运行轻节点，这些节点会信任其他节点来中继信息，但仍然会进行验证。
- en: In the current landscape, a small fraction of our users will actually be running
    an Ethereum node  . Most of them will be just learning what Ethereum is about,
    and wondering how to buy their first ETH to pay for the gas to fuel their initial
    transactions. Having them running their own nodes is still out of the question.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前格局中，我们的用户中只有很小一部分实际上会运行以太坊节点。他们中的大部分人只是在了解以太坊是什么，并想知道如何购买他们的第一个 ETH 以支付其初始交易的手续费。让他们自己运行节点仍然不可能。
- en: As such, and in order to help the Ethereum adoption process easier, there are
    a number of *public nodes* available. An Ethereum node is said to be a public
    node when it holds no private keys, is available to the public, and is used to
    answer blockchain queries and relay pre-signed transactions.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了让以太坊的采用过程更加容易，有许多*公共节点*可用。当以太坊节点不持有私钥、对公众开放，并用于回答区块链查询和中继预签名交易时，称其为公共节点。
- en: In particular, **Infura** (Japanese for “infrastructure”) is a service that
    provides HTTP  and websocket endpoints to public full nodes for the Ethereum Mainnet,
    as well as for the Kovan, Ropsten, and Rinkeby testnets. Due to its reliability,
    and to the fact that it is free to use, it is widely used by many decentralized
    apps and wallets.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 特别地，**Infura**（日语意为“基础设施”）是一项服务，为以太坊主网以及 Kovan、Ropsten 和 Rinkeby 测试网络提供 HTTP
    和 WebSocket 终端节点。由于其可靠性以及免费使用的事实，它被许多去中心化应用程序和钱包广泛使用。
- en: The JSON-RPC Interface
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JSON-RPC 接口
- en: All Ethereum nodes, regardless of the particular implementation, expose a set
    of well-known methods, which compose the *JSON-RPC interface*. As the name implies,
    this is a JSON-based API for executing remote procedure calls, and constitutes
    the low-level interface for a client to interact with a node. Common methods include
    call, sendTransaction, getBlockByNumber, accounts, or getBalance. There are even
    methods for querying the state of the node itself, such as whether its syncing
    or how many peers it is connected to.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 所有以太坊节点，无论特定的实现如何，都暴露了一组众所周知的方法，这些方法组成了*JSON-RPC 接口*。顾名思义，这是一个基于 JSON 的 API，用于执行远程过程调用，并构成了客户端与节点交互的低级接口。常见方法包括
    call、sendTransaction、getBlockByNumber、accounts 或 getBalance。甚至还有一些查询节点本身状态的方法，比如它是否在同步或连接了多少对等体。
- en: Note
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Given it is a low-level interface, it is odd that you will find yourself building
    JSON-RPC calls manually. Most libraries (such as web3.js or ethers.js) will take
    care of generating the calls on your behalf and provide you with the responses.
    Nevertheless, it is always useful to understand what is going on under the hood
    in case you stumble upon a dreadful abstraction leakage.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于它是一个低级接口，你会发现自己手动构建 JSON-RPC 调用有些奇怪。大多数库（如 web3.js 或 ethers.js）将为你生成调用并提供响应。然而，了解底层发生了什么总是有用的，以防你遇到可怕的抽象泄漏。
- en: It is worth mentioning that certain nodes may not implement all methods. For
    instance, the Infura HTTP endpoint does not offer costly operations such as newFilter
    (more on filters later in this chapter). This will be important to keep in mind
    when we discuss how to connect our app to the Ethereum network.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，某些节点可能不实现所有方法。例如，Infura HTTP 端点不提供诸如 newFilter（本章后面将更多介绍过滤器）等昂贵的操作。在讨论如何将我们的应用连接到以太坊网络时，这一点将非常重要。
- en: Connection Protocols
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 连接协议
- en: There are three different protocols that can be used as a transport for interchanging
    JSON-RPC messages. Nodes can be configured to handle any of them.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种不同的协议可以用作交换 JSON-RPC 消息的传输。节点可以配置为处理其中任何一种。
- en: The **HTTP** protocol  is the simplest one. It provides a simple HTTP-based
    interface for POSTing JSON messages. Certain nodes may be set up behind HTTPS-encrypted
    connections, and may require basic authentication to access them. A simple HTTPS
    connection string looks like the following:"https://user:password@example.com:8545/"A
    more interesting alternative is the **websocket** protocol  . A websocket connection
    is a persistent two-way connection between a client and a server. This allows
    a client to not only perform all the available JSON-RPC calls but also to subscribe
    to changes that are pushed from the node to the client (more on this later). Like
    HTTP connections, websockets may also be established over SSL, and potentially
    include basic authentication:"wss://user:password@example.com:8545/ws"Finally,
    the **IPC** (inter-process communication) protocol  is based on a local UNIX domain
    socket created by the node. Clients with access to the socket may connect to it
    via its filename. These connections are meant to be used by processes with access
    to the same filesystem as the node, and as such are not used on web apps."ipc://home/ubuntu/.ethereum/geth.ipc"
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**HTTP** 协议是最简单的协议之一。它提供了一个简单的基于 HTTP 的接口来 POST JSON 消息。某些节点可能设置在 HTTPS 加密连接之后，并且可能需要基本身份验证来访问它们。一个简单的
    HTTPS 连接字符串如下所示："https://user:password@example.com:8545/"一个更有趣的选择是 **websocket**
    协议。Websocket 连接是客户端和服务器之间的持久双向连接。这使得客户端不仅可以执行所有可用的 JSON-RPC 调用，还可以订阅从节点推送到客户端的更改（稍后会详细介绍）。像
    HTTP 连接一样，websocket 也可以在 SSL 上建立，并且可能包括基本身份验证："wss://user:password@example.com:8545/ws"最后，**IPC**（进程间通信）协议基于节点创建的本地
    UNIX 域套接字。具有对套接字访问权限的客户端可以通过其文件名连接到它。这些连接旨在由具有对节点相同文件系统访问权限的进程使用，因此不会在 Web 应用程序上使用。"ipc://home/ubuntu/.ethereum/geth.ipc"'
- en: Alternative APIs
  id: totrans-23
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 备选 API
- en: As an alternative to establishing a connection to the JSON-RPC interface of
    a node, you may opt to query blockchain data from a different source.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 作为与节点的 JSON-RPC 接口建立连接的替代方案，您可以选择从不同的源查询区块链数据。
- en: '**Etherscan** (etherscan.io) is a centralized service that provides not only
    a web-based blockchain explorer where you can visually check all transactions
    sent to and from an account but also a plain HTTP API (Listing [4-1](#PC4)) that
    implements many of the methods present in the JSON-RPC interface.# Etherscan APIcurl
    "https://api.etherscan.io/api?module=proxy&action=eth_getTransactionCount&address=$ADDRESS&tag=latest&apikey=YourApiKeyToken"#
    Regular JSON-RPC call{"jsonrpc":"2.0","method":"eth_getTransactionCount","params":["$ADDRESS","latest"],"id":1}Listing
    4-1'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**Etherscan**（etherscan.io）是一个集中式服务，不仅提供了一个基于 Web 的区块链浏览器，在这里您可以直观地检查发送到和从帐户发送的所有交易，还提供了一个普通的
    HTTP API（见 [4-1](#PC4)）实现了 JSON-RPC 接口中的许多方法。# Etherscan APIcurl "https://api.etherscan.io/api?module=proxy&action=eth_getTransactionCount&address=$ADDRESS&tag=latest&apikey=YourApiKeyToken"#
    普通的 JSON-RPC 调用{"jsonrpc":"2.0","method":"eth_getTransactionCount","params":["$ADDRESS","latest"],"id":1}列表
    4-1'
- en: Example of executing a getTransactionCount call to the etherscan API (preceding)
    vs. the standard JSON-RPC call (following). Both return the same JSON object as
    a response
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 getTransactionCount 调用到 etherscan API 的示例（前文）与标准 JSON-RPC 调用（后文）的区别。两者都返回相同的
    JSON 对象作为响应
- en: Certain javascript libraries, such as ethers.js, even include *provider* objects
    that abstract a connection to the Etherscan API, so it can be used seamlessly
    as any other standard JSON-RPC connection. Let’s now go into the role of the provider.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 某些 JavaScript 库，如 ethers.js，甚至包括抽象连接到 Etherscan API 的 *provider* 对象，因此它可以像任何其他标准
    JSON-RPC 连接一样无缝使用。现在让我们深入了解提供程序的角色。
- en: Note
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We are not dwelling into domain-specific APIs at this point. A project may decide
    to offer an API to query relevant data from its domain. You may also choose to
    set up a centralized server that aggregates blockchain data from your protocol,
    and relays it to client-side apps.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们暂时不深入讨论特定领域的 API。项目可能决定提供一个 API 来查询其领域的相关数据。您还可以选择设置一个集中式服务器，从您的协议中聚合区块链数据，并将其中继到客户端应用程序。
- en: The Provider Object
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提供程序对象
- en: As we briefly saw in Chapter [2](476252_1_En_2_Chapter.xhtml) while building
    our first sample DApp, the connection to a node is managed by a *provider* javascript
    object. It is the provider’s responsibility to abstract the connection protocol
    being used and offer a minimal interface for sending JSON-RPC messages and subscribing
    to notifications.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在第 [2](476252_1_En_2_Chapter.xhtml) 章中简要介绍的，构建我们的第一个示例 DApp 时，与节点的连接由 *provider*
    JavaScript 对象管理。提供程序负责抽象正在使用的连接协议，并提供一个用于发送 JSON-RPC 消息和订阅通知的最小接口。
- en: Note
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: At the moment of this writing, providers from different libraries have slightly
    different APIs. There is an effort to standardize the minimal provider as EIP
    1193, but is still a draft.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，不同库的提供程序具有略有不同的 API。正在努力将最小提供程序标准化为 EIP 1193，但仍然是草案。
- en: For example, the web3 javascript library^([2](#Fn2)) offers the following providers
    for connecting to HTTP, websocket, or IPC interfaces (Listing [4-2](#PC5)). The
    provider is then used to initialize an instance of the full web3 object.const
    Web3 = require('web3');const httpProvider = newWeb3.providers.HttpProvider("https://example.com");const
    wsProvider = newWeb3.providers.WebsocketProvider("wss://example.com");const ipcProvider
    = newWeb3.providers.IpcProvider("/home/ubuntu/.ethereum/geth.ipc");const web3
    = new Web3(provider);Listing 4-2
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，web3 JavaScript 库^([2](#Fn2)) 提供了以下提供程序用于连接 HTTP、websocket 或 IPC 接口（见列表 [4-2](#PC5)）。然后使用提供程序来初始化完整的
    web3 对象。const Web3 = require('web3');const httpProvider = newWeb3.providers.HttpProvider("https://example.com");const
    wsProvider = newWeb3.providers.WebsocketProvider("wss://example.com");const ipcProvider
    = newWeb3.providers.IpcProvider("/home/ubuntu/.ethereum/geth.ipc");const web3
    = new Web3(provider);列表 4-2
- en: Example web3@1.2.0 code for creating a provider and initializing a web3 instance
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 创建提供程序和初始化 web3 实例的示例 web3@1.2.0 代码
- en: You will only need to create a provider instance if you have to manually set
    up a connection to a node. In most scenarios, you will actually delegate this
    responsibility to the user’s web3-enabled browser.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在需要手动设置与节点的连接时，您才需要创建提供者实例。在大多数情况下，您实际上会将这个责任委托给用户的 Web3 可用浏览器。
- en: Metamask and Web3-enabled Browsers
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Metamask 和 Web3 可用浏览器
- en: After Chapter [2](476252_1_En_2_Chapter.xhtml), you should now be familiar with
    Metamask  , the browser extension that acts as a bridge for a web application
    and the Ethereum network. There are other options as well, such as the Cipher
    or the Opera browsers for Android, though we will focus on Metamask throughout
    the book, as it is the most widespread tool at the moment.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 [2](476252_1_En_2_Chapter.xhtml) 章之后，您现在应该对 Metamask 有所了解，这是一个作为 Web 应用程序与以太坊网络之间桥梁的浏览器扩展。还有其他选择，比如
    Cipher 或 Opera 浏览器用于 Android，不过我们将在本书中专注于 Metamask，因为它目前是最广泛使用的工具。
- en: Web3-enabled browsers work by injecting a *provider* instance in the global
    scope. How this provider works or how it is backed should not be of importance
    for your DApp. The DApp should be able to query whichever information it needs
    and let the provider resolve it.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Web3 可用浏览器通过在全局范围内注入 *提供者* 实例来工作。这个提供者的工作方式或者它的后台支持方式对于您的 DApp 来说并不重要。DApp 应该能够查询它需要的任何信息，并让提供者解决它。
- en: Note that this provider may need to be *enabled* in order to gain access to
    the user’s accounts or request to sign transactions (Listing [4-3](#PC6)), which
    will prompt the user to accept a request from the DApp to access his accounts
    information.// Metamask injects the web3 provider as window.ethereumconst Web3
    = require('web3');const provider = window.ethereum;if (provider) {  try {    //
    Request access to querying the accounts of the user    await provider.enable();  }
    catch (error) {    // User denied account access, but we can still    // run queries
    to the network  }  const web3 = new Web3(provider);}Listing 4-3
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，为了访问用户的帐户或请求签署交易（见 [4-3](#PC6)），可能需要 *启用* 这个提供者，这将提示用户接受 DApp 请求访问他的帐户信息。//
    Metamask 将 web3 提供者注入为 window.ethereumconst Web3 = require('web3');const provider
    = window.ethereum;if (provider) {  try {    // 请求访问用户的帐户    await provider.enable();  }
    catch (error) {    // 用户拒绝了帐户访问，但我们仍然可以    // 运行查询到网络  }  const web3 = new Web3(provider);}Listing
    4-3
- en: Snippet for instantiating a web3 object using a provider injected by Metamask
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Metamask 注入的提供者实例实例化 web3 对象的片段
- en: Metamask connects by default to the Infura public servers via HTTPS. This allows
    any user who has downloaded the extension to have a connection to the Ethereum
    network up and running right away, without needing to maintain and sync their
    own nodes. Nevertheless, Metamask also allows advanced users to set up their own
    custom connections to other nodes, such as their own (Figures [4-1](#Fig1) and
    [4-2](#Fig2)).![../images/476252_1_En_4_Chapter/476252_1_En_4_Fig1_HTML.jpg](../images/476252_1_En_4_Chapter/476252_1_En_4_Fig1_HTML.jpg)
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Metamask 通过 HTTPS 连接到 Infura 公共服务器。这允许任何已下载扩展的用户立即连接到以太坊网络，而无需维护和同步自己的节点。尽管如此，Metamask
    还允许高级用户设置自己的连接到其他节点的自定义连接，例如他们自己的（见图 [4-1](#Fig1) 和 [4-2](#Fig2)）。![../images/476252_1_En_4_Chapter/476252_1_En_4_Fig1_HTML.jpg](../images/476252_1_En_4_Chapter/476252_1_En_4_Fig1_HTML.jpg)
- en: Figure 4-1
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-1
- en: Metamask settings tab allows a user to configure their own connection to a node
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Metamask 设置选项卡允许用户配置自己与节点的连接
- en: '![../images/476252_1_En_4_Chapter/476252_1_En_4_Fig2_HTML.jpg](../images/476252_1_En_4_Chapter/476252_1_En_4_Fig2_HTML.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![../images/476252_1_En_4_Chapter/476252_1_En_4_Fig2_HTML.jpg](../images/476252_1_En_4_Chapter/476252_1_En_4_Fig2_HTML.jpg)'
- en: Figure 4-2
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-2
- en: Metamask control for choosing the node to connect to, displayed when clicking
    the network drop-down at the top of the extension dialog. The first four are connections
    to public nodes hosted by Infura
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Metamask 控制选择连接节点的方式，在扩展对话框顶部点击网络下拉时显示。前四个是由 Infura 托管的公共节点连接。
- en: Subproviders
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 子提供程序
- en: Certain web3 providers may also be composed of *subproviders* . A subprovider
    is a non-standard object that intercepts calls made via the provider. Among other
    uses, subproviders help provide a common interface by filling in any gaps in the
    feature set of the Ethereum node being used. In this sense, subproviders act as
    polyfills hidden within the provider.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 某些 web3 提供程序也可能由 *子提供程序* 组成。子提供程序是拦截通过提供程序发出的调用的非标准对象。除了其他用途外，子提供程序还通过填补所使用的以太坊节点功能集中的任何空白来提供一个常见的接口。在这个意义上，子提供程序就像隐藏在提供程序中的填充物。
- en: 'As an example, a provider that connects to a node that does not offer the *filters*
    API (used for polling for specific changes) may include a *filter subprovider*
    that emulates that feature client-side. Such is the case with the web3 provider
    injected by Metamask: since Infura does not offer the filters API, Metamask adds
    that feature at the provider level via a custom subprovider. This way, you as
    a developer do not need to worry about which APIs are supported, and are given
    a consistent interface regardless of the node answering your queries.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，连接到不提供 *filters* API（用于轮询特定更改）的节点的提供程序可能包含一个 *filter 子提供程序*，它在客户端模拟该功能。这是
    Metamask 注入的 web3 提供程序的情况：由于 Infura 不提供 filters API，Metamask 通过自定义子提供程序在提供程序级别添加了该功能。这样，作为开发者，你不需要担心支持哪些
    API，并且无论哪个节点回答你的查询，都会得到一致的接口。
- en: We will revisit subproviders in the next chapter, where we discuss about providers
    and signers, since Metamask implements its signer as another subprovider.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章节中，我们将重新讨论子提供者，其中我们将讨论提供者和签名者，因为 Metamask 将其签名者实现为另一个子提供者。
- en: Choosing the Right Connection
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择正确的连接
- en: Up to this point, we have reviewed different kinds of nodes (full and light,
    public and private), as well as different connection protocols (ipc, http, and
    websockets). We have also learned how to set up a provider object and how to enable
    the one injected by a web3-enabled browser. Given all these options, it begs the
    question of which connection we should choose for *querying information from a
    DApp*.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经审查了不同类型的节点（完整和轻量级，公共和私有），以及不同的连接协议（ipc、http 和 websockets）。我们还学习了如何设置提供者对象以及如何启用
    web3 启用的浏览器注入的提供者。在考虑了所有这些选项后，我们需要考虑的一个问题是从 DApp 中查询信息应选择哪种连接方式。
- en: Respecting the Choice of the User
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 尊重用户的选择
- en: First and foremost, if our user is using a web3-enabled browser, our DApp should
    rely on the provider injected by it. A web3-enabled browser means the user is
    already part of the Ethereum ecosystem, and could be potentially running a node
    of their own. As such, we need to provide them with the means to choose which
    node they want to use when browsing our DApp.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果我们的用户正在使用支持 web3 的浏览器，我们的 DApp 应依赖于其注入的提供者。支持 web3 的浏览器意味着用户已经是以太坊生态系统的一部分，并且可能正在运行自己的节点。因此，我们需要为他们提供选择要在浏览我们的
    DApp 时使用哪个节点的手段。
- en: While we could reimplement Metamask’s interface for choosing a network connection,
    it makes little sense to do so. A user who wishes to connect to an alternative
    node will already be running Metamask or another web3-enabled browser, and have
    already preconfigured their own nodes. Therefore, an injected web3 provider should
    always be our first choice for connecting to the network.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以重新实现 Metamask 的网络连接界面，但这样做没有多大意义。希望连接到另一个节点的用户已经在运行 Metamask 或其他支持 web3
    的浏览器，并且已经预先配置了自己的节点。因此，注入的 web3 提供者应始终是我们连接到网络的首选。
- en: Keep in mind that providers need to be enabled in order to access the list of
    accounts of the user. Nevertheless, if the application does not need this information,
    this step can be skipped.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，需要启用提供者才能访问用户的账户列表。尽管如此，如果应用程序不需要这些信息，这一步可以省略。
- en: Using a Public Node
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用公共节点
- en: 'The next option is simple: connect to a public node. You can either set up
    your own for your DApp or use one from Infura. Going with your own node has all
    the benefits and drawbacks of rolling out your own infrastructure: you do not
    depend on a third party, but you need to watch out for the health of your nodes.
    Remember that nothing prevents an arbitrary number of users from connecting to
    your node, so you should be prepared for surges in traffic. Because of this, it
    may be easier to just rely on an external infrastructure provider.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个选项很简单：连接到公共节点。你可以为你的 DApp 设置自己的节点，或者使用 Infura 的节点。选择使用自己的节点具有自己的基础设施的所有利与弊：你不依赖于第三方，但需要注意节点的健康情况。请记住，没有什么可以阻止任意数量的用户连接到您的节点，因此您应该为流量激增做好准备。因此，仅依赖外部的基础设施提供者可能更容易些。
- en: As an alternative to Infura, you can also rely on a public API such as that
    of Etherscan. Ethers.js, an alternative to web3.js, connects by default to Infura,
    and falls back to Etherscan if the connection fails.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 Infura 的替代方案，你也可以依赖于像 Etherscan 这样的公共 API。Ethers.js，作为 web3.js 的一种替代方案，默认连接到
    Infura，并在连接失败时退而使用 Etherscan。
- en: Note that in all cases where your DApp relies on a third party, it is relying
    on a foreign centralized service for fetching data from the blockchain. Since
    one of the strong points of DApps is precisely decentralization, adding a component
    that needs to be trusted may be a step backward in this direction. It is up to
    you to decide on the trade-off between convenience and decentralization for the
    users of your DApp. As such, a good rule of thumb is to use an injected provider
    if found, and fall back to a centralized service otherwise.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在您的 DApp 依赖第三方的所有情况下，它都依赖于外部的集中式服务来从区块链获取数据。由于 DApp 的一个强大之处恰恰在于去中心化，添加一个需要信任的组件可能是朝相反方向迈出的一步。决定在便利性和用户的
    DApp 的去中心化之间权衡的问题取决于您。因此，一个很好的经验法则是如果找到了注入式提供者，则使用注入式提供者，否则回退到一个集中式服务。
- en: Putting it all Together
  id: totrans-62
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将其整合起来
- en: The code in Listing [4-4](#PC7) attempts to load the injected provider from
    a web3 browser, both modern and legacy ones. If it fails, it falls back to using
    an Infura secure websocket endpoint. The provider is used to create a web3.js
    instance, but the same code can be repurposed for other libraries.async function
    getWeb3() {  // Modern web3 browsers  if (window.ethereum) {    const web3 = new
    Web3(window.ethereum);    // Only if we need access to user accounts    try {      await
    window.ethereum.enable();    } catch (error) {      console.error("No access to
    user accounts");    }    return web3;  }  // Legacy web3 browsers  else if (window.web3)
    {    return new Web3(window.web3.currentProvider);  }  // Standard browser  else
    {    return new Web3("wss://mainnet.infura.io/ws/v3/TOKEN");  }}Listing 4-4
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [4-4](#PC7) 中的代码尝试从 web3 浏览器中加载注入的提供程序，无论是现代的还是旧版的。 如果失败，它将回退到使用 Infura 安全
    websocket 端点。 提供程序用于创建 web3.js 实例，但相同的代码可以被重新用于其他库。async function getWeb3() {  //
    现代 web3 浏览器  if (window.ethereum) {    const web3 = new Web3(window.ethereum);    //
    仅当我们需要访问用户账户时    try {      await window.ethereum.enable();    } catch (error)
    {      console.error("No access to user accounts");    }    return web3;  }  //
    旧版 web3 浏览器  else if (window.web3) {    return new Web3(window.web3.currentProvider);  }  //
    标准浏览器  else {    return new Web3("wss://mainnet.infura.io/ws/v3/TOKEN");  }}Listing
    4-4
- en: Code snippet for initializing a web3 connection for a DApp, based on the code
    provided by metamask.io
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 基于 metamask.io 提供的代码，用于初始化 DApp 的 web3 连接的代码片段。
- en: Retrieving Data
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检索数据
- en: Now that we know how to connect to the network, we can start actually retrieving
    data. We will review how to access network information, account balances, perform
    static calls, and subscribe to events. As before, we will be using web3@1.2.0
    as a library to interact with the Ethereum network, but other libraries should
    provide similar features.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何连接到网络，我们可以开始实际检索数据。 我们将查看如何访问网络信息、账户余额、执行静态调用和订阅事件。 与之前一样，我们将使用 web3@1.2.0
    作为与以太坊网络交互的库，但其他库应该提供类似的功能。
- en: Network Information
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 网络信息
- en: We can start out by querying general network information. To begin with, it
    is a good practice to always check that you are connected to the expected network.
    If your application is meant to be used on the Rinkeby test network, you do not
    want a user to be accidentally using a connection to Mainnet. To do this, you
    can get the identifier of the network you are connected to and compare it to the
    identifier of the expected network.> await web3.eth.net.getId()1
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过查询一般的网络信息开始。 首先，总是检查您是否连接到预期的网络是一个好习惯。 如果您的应用程序意在在 Rinkeby 测试网络上使用，您不希望用户意外地使用与主网的连接。
    为此，您可以获取您连接的网络的标识符，并将其与预期网络的标识符进行比较。> await web3.eth.net.getId()1
- en: Networks are identified by a numeric identifier. Mainnet is 1, Ropsten is 3,
    Rinkeby is 4, and Kovan is 42\. Ephemeral development networks are typically set
    up with higher IDs.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 网络通过数字标识符进行识别。 主网为 1，Ropsten 为 3，Rinkeby 为 4，Kovan 为 42。 临时开发网络通常使用较高的 ID 设置。
- en: Note
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注
- en: Like most requests to an external data source in javascript, calls to the Ethereum
    network are asynchronous operations. Different libraries may have different ways
    to handle this, either by using callbacks or returning promises. In particular,
    web3.js supports traditional error-first callbacks as well as promi-events. Promi-events
    are promise objects which double as an event emitter, allowing you to listen to
    different stages of the asynchronous operation. They will become more relevant
    in the next chapter. For now, we will simply use the async-await syntax for working
    with promises.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 像大多数 JavaScript 中对外部数据源的请求一样，对以太坊网络的调用都是异步操作。不同的库可能有不同的处理方式，可以使用回调函数或返回 promises。特别是，web3.js
    支持传统的错误优先回调以及 Promi-events。Promi-events 是同时充当事件发射器的 promise 对象，允许你监听异步操作的不同阶段。它们将在下一章变得更加相关。目前，我们将简单地使用
    async-await 语法来处理 promises。
- en: 'Another piece of information we can get from the network is the current block
    number. Polling this value can let us know when a new block was added to the chain,
    potentially including transactions that have modified the state of the contracts
    we are working with, thus triggering a re-read in our app.> await web3.eth.getBlockNumber()7059809^([3](#Fn3))We
    can also get detailed information from a block, such as its hash, the total gas
    used, its miner, and a list of all the transactions included in it. Note that
    we can refer to a block either by number, hash, or the string latest to signal
    that we want the latest block on the chain.> await web3.eth.getBlock(''latest''){
    author: ''0xea674fdde...'',  gasLimit: 8000029,  gasUsed: 1808896,  hash: ''0xcdb2699b240ece675611aa...'',  number:
    7059810,  transactions:   [ ''0xca7d315abc76988ddcfa49...'',     ''0x9b72090bbabe017d4bcf5b...'',     ''0xa50150e448a0cc40a29986...'',     ...
    ],  ... }We can also get information not on the network but on the node itself.
    For instance, we can query the software version that a node is running, and even
    warn our users if there is a known issue on that release.> await web3.eth.getNodeInfo()''Parity-Ethereum//v2.1.11-stable-e9194b0-20190107/x86_64-linux-gnu/rustc1.31.1''Another
    potentially useful check is whether the node is up to date with the rest of the
    chain. Nodes that have been just set up may not have synced yet, so they will
    not be able to return recent information from the network. If a node is no longer
    syncing, you can safely rely on it.> await web3.eth.isSyncing()false'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '我们还可以从网络中获取另一种信息，即当前区块编号。轮询此值可以让我们知道何时向链中添加了新的区块，可能包括已修改我们正在处理的合约状态的交易，从而触发我们应用程序中的重新读取。>
    await web3.eth.getBlockNumber()7059809^([3](#Fn3))我们还可以从一个区块中获取详细信息，例如其哈希值、总用气量、矿工和其中包含的所有交易列表。请注意，我们可以通过数字、哈希值或字符串“latest”来引用一个区块，以示我们要获取链上最新的区块。>
    await web3.eth.getBlock(''latest''){ author: ''0xea674fdde...'',  gasLimit: 8000029,  gasUsed:
    1808896,  hash: ''0xcdb2699b240ece675611aa...'',  number: 7059810,  transactions:   [
    ''0xca7d315abc76988ddcfa49...'',     ''0x9b72090bbabe017d4bcf5b...'',     ''0xa50150e448a0cc40a29986...'',     ...
    ],  ... }我们还可以获取不在网络上而是在节点本身的信息。例如，我们可以查询节点正在运行的软件版本，甚至在该版本存在已知问题时通知我们的用户。> await
    web3.eth.getNodeInfo()''Parity-Ethereum//v2.1.11-stable-e9194b0-20190107/x86_64-linux-gnu/rustc1.31.1''另一个可能有用的检查是节点是否与链的其余部分保持同步。刚刚设置的节点可能尚未同步，因此它们将无法从网络中返回最新的信息。如果一个节点不再同步，你可以放心地依赖它。>
    await web3.eth.isSyncing()false'
- en: There is more information you can query from a node. Make sure to check out
    the web3.js reference^([4](#Fn4)) for additional methods.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 从节点中可以查询到更多的信息。务必查看 web3.js 参考文档^([4](#Fn4))以获取额外的方法。
- en: Account Balances and Code
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 账户余额和代码
- en: Given an address, you can query the ETH stored by that account, regardless of
    it being an externally owned account or a contract. Furthermore, since blockchain
    history is indelible, you can even query the balance of the account in an earlier
    point in time (Listing [4-5](#PC13)). The number of blocks you can go back will
    depend on whether you are working with an archive or a regular node.> const addr
    = '0xcafE1A77e84698c83CA8931F54A755176eF75f2C';> const block = await web3.eth.getBlockNumber()
    - 10;> await web3.eth.getBalance(addr, block);'180300794957635301822239'Listing
    4-5
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个地址，你可以查询该账户存储的 ETH，无论它是外部拥有账户还是合约。此外，由于区块链历史是不可更改的，你甚至可以查询账户在以前某个时间点的余额（见清单
    [4-5](#PC13)）。你可以回溯的区块数量取决于你是否使用归档或常规节点。> const addr = '0xcafE1A77e84698c83CA8931F54A755176eF75f2C';>
    const block = await web3.eth.getBlockNumber() - 10;> await web3.eth.getBalance(addr,
    block);'180300794957635301822239'清单 4-5
- en: Querying the balance of an address from ten blocks ago
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 查询十个区块之前的地址余额
- en: Note that ETH balances are **always** expressed in Wei, which is the smallest
    unit in which an ETH can be subdivided. One ETH is equivalent to 1e18 Wei (i.e.,
    1 followed by 18 zeros). You can use the web3 utils module (Listing [4-6](#PC14))
    to convert between them.> const balance = await web3.eth.getBalance(addr, block)>
    web3.utils.fromWei(balance)'180300.794957635301822239'Listing 4-6
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，ETH 余额**总是**以 Wei 表示，这是 ETH 可以细分的最小单位。1 ETH 相当于 1e18 Wei（即，后面跟着 18 个零）。你可以使用
    web3 utils 模块（见清单 [4-6](#PC14)）在它们之间进行转换。> const balance = await web3.eth.getBalance(addr,
    block)> web3.utils.fromWei(balance)'180300.794957635301822239'清单 4-6
- en: Using web3.utils.fromWei for converting from Wei to ETH. The reverse method
    is toWei
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `web3.utils.fromWei` 将 Wei 转换为 ETH。反向方法是 `toWei`。
- en: You may have noted from the preceding snippets that ETH balance is returned
    not as a number but as a **string**. This is meant to avoid losing precision when
    dealing with very large numbers, since javascript numbers cannot deal with very
    large magnitudes. As an example, 1822239 wei are lost in the conversion to integer
    in the following code.> parseInt(balance).toLocaleString();'180,300,794,957,635,300,000,000'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到前面的片段中，ETH 余额返回的不是一个数字，而是一个**字符串**。这是为了在处理非常大的数字时避免丢失精度，因为 JavaScript
    数字无法处理非常大的数量级。举例来说，在下面的代码中，将 1822239 wei 转换为整数时会丢失精度。> parseInt(balance).toLocaleString();'180,300,794,957,635,300,000,000'
- en: This decision is specific to the web3.js library. Other libraries rely on javascript
    bignumber implementations, such as bignumber.js^([5](#Fn5)) or bn.js^([6](#Fn6)).
    It is most likely that once support for native bignumbers^([7](#Fn7)) is stabilized
    in the language, libraries will switch to it. Either way, what is important is
    that you keep in mind that most numbers in Ethereum cannot be handled using regular
    javascript numbers, or you risk losing precision.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这个决定是针对 web3.js 库的。其他库依赖于 JavaScript 的大数实现，比如 bignumber.js^([5](#Fn5)) 或 bn.js^([6](#Fn6))。一旦语言中对本机大数的支持稳定下来，很可能这些库会切换到它。无论哪种方式，重要的是要记住，以太坊中的大多数数字不能使用常规
    JavaScript 数字来处理，否则可能会失去精度。
- en: Besides balances, you can also get the code at an address, and use it to check
    whether an address is a contract or an externally owned account. You can also
    check the code itself to see if it matches the binary from a known contract.>
    await web3.eth.getCode(addr);'0x6060604052361561011...'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 除了余额之外，您还可以获取地址上的代码，并使用它来检查地址是合约还是外部拥有的帐户。您还可以检查代码本身，以查看它是否与已知合约的二进制代码匹配。> await
    web3.eth.getCode(addr);'0x6060604052361561011...'
- en: 'Keep in mind that this method for checking whether an account is a contract
    or not is far from robust. If you get no code from an address, it does not necessarily
    mean it is externally owned: a contract may be deployed to that address later,
    or a contract may have been deployed there but was eventually self-destructed.
    All in all, you should avoid relying on whether an arbitrary address is externally
    owned or not for particularly sensitive operations.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，用于检查帐户是否为合约的方法远非健壮。如果从地址中获取不到代码，则不一定意味着它是外部拥有的：可能稍后会将合约部署到该地址，或者合约可能已在该处部署，但最终已自毁。总而言之，您应避免依赖任意地址是否为外部拥有的帐户来进行特别敏感的操作。
- en: Calling into a Contract
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调用合约
- en: As we saw in Chapter [2](476252_1_En_2_Chapter.xhtml), you can call into a contract
    to query information from it by issuing a JSON-RPC call to its address. Most contracts
    expose getter functions that return information on their current state or perform
    pure calculations; these functions can be identified as they are tagged with the
    view or pure modifiers in Solidity. Like all the functions listed in this chapter,
    calling into them does not cost any gas, since the call can be answered by any
    node in the network, and does not need to introduce a change on the blockchain.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第二章](476252_1_En_2_Chapter.xhtml)中看到的，您可以通过向其地址发出 JSON-RPC 调用来从合约中查询信息。大多数合约都公开了返回其当前状态或执行纯计算的
    getter 函数；这些函数可以通过 Solidity 中的 view 或 pure 修饰符进行标记。与本章中列出的所有函数一样，调用它们不会花费任何 gas，因为任何网络中的节点都可以回答该调用，并且不需要在区块链上引入更改。
- en: 'These calls can be executed at a low level using the call function  from web3.js,
    which requires manually providing the target address and the raw data to send
    to the target contract. As an example, 0x18160ddd is the function selector^([8](#Fn8))
    for accessing the totalSupply of an ERC20 token contract, so we can test it against
    an existing contract on mainnet, such as the BAT token on mainnet, which returns
    the hexadecimal representation of 1.5e27.> const addr = ''0x0d8775f648430679a709e98d2b0cb6250d2887ef'';>
    await web3.eth.call({ to: addr, data: ''0x18160ddd'' });''0x00000000...0004d8c55aefb8c05b5c000000''However,
    we will typically rely on the web3 Contract abstraction for interacting with a
    contract (Listing [4-7](#PC18)). Creating one of these, as we saw before, requires
    the contract’s ABI and its address. We will replicate the preceding example using
    the ABI for the ERC20.^([9](#Fn9))> const abi = [  {    "constant": true,    "inputs":
    [],    "name": "totalSupply",    "outputs": [{"name": "", "type": "uint256"}],    "payable":
    false,    "stateMutability": "view",    "type": "function"  }, ...];> const erc20
    = new web3.eth.Contract(abi, addr);> await erc20.methods.totalSupply().call()''1500000000000000000000000000''Listing
    4-7'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '这些调用可以使用`web3.js`中的`call`函数在低级别执行，该函数需要手动提供目标地址和要发送到目标合约的原始数据。例如，`0x18160ddd`是访问
    ERC20 代币合约的`totalSupply`的函数选择器[^8]，因此我们可以对主网上的现有合约进行测试，例如主网上的 BAT 代币，它返回 1.5e27
    的十六进制表示。> `const addr = ''0x0d8775f648430679a709e98d2b0cb6250d2887ef'';`> `await
    web3.eth.call({ to: addr, data: ''0x18160ddd'' });``0x00000000...0004d8c55aefb8c05b5c000000`但是，我们通常会依赖于`web3`合约抽象来与合约进行交互（见清单
    [4-7](#PC18)）。如前所述，创建其中一个需要合约的 ABI 和其地址。我们将使用 ERC20 的 ABI 复制前面的示例。[^9]> `const
    abi = [  {    "constant": true,    "inputs": [],    "name": "totalSupply",    "outputs":
    [{"name": "", "type": "uint256"}],    "payable": false,    "stateMutability":
    "view",    "type": "function"  }, ...];`> `const erc20 = new web3.eth.Contract(abi,
    addr);`> `await erc20.methods.totalSupply().call()`''1500000000000000000000000000''清单
    4-7'
- en: Accessing the same token’s total supply via the web3 Contract object. Note how
    the output is formatted based on its type instead of returned as a raw hexadecimal
    value
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`web3`合约对象访问相同代币的总供应量。请注意，输出的格式是基于其类型而不是作为原始十六进制值返回的。
- en: Note
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Like getBalance, all calls to a contract can also include an optional block
    parameter, in case you want to query a contract’s state at a previous point in
    time. Remember that requesting changes for a block too long ago in the chain requires
    a connection to an archive node, which is not always available. Also keep in mind
    that, depending on your use case, it may be prudent to only display information
    from a dozen blocks ago, to shield yourself against possible chain reorgs. Data
    this recent is usually always available, regardless of the node keeping an archive
    or not.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 像`getBalance`一样，对合约的所有调用也可以包括一个可选的区块参数，以便在以前的某个时间点查询合约的状态。请记住，请求链中太久之前的块的更改需要连接到归档节点，而这并不总是可用的。另外，请记住，根据您的用例，仅显示一段时间之前的信息可能是明智的，以防止可能的链重组。这种最近的数据通常始终可用，无论节点是否保留了归档。
- en: 'The Contract object can also be used to obtain the function selectors that
    can be plugged into low-level calls or raw transactions. In the following line,
    the encodeABI method returns the data selector that we used at the beginning of
    this section.> await erc20.methods.totalSupply().encodeABI()''0x18160ddd''Contracts
    also expose a handy interface to all events declared on the ABI (Listing [4-8](#PC20)),
    making it easy to query all events in a block range.> const block = await web3.eth.getBlockNumber();>
    const opts = { fromBlock: block - 100, toBlock: block };> await erc20.getPastEvents(''Transfer'',
    opts);[{address: ''0x0D8775F648430679A709E98d2b0Cb6250d2887EF'',  blockNumber:
    7060651,  logIndex: 91,  removed: false,  transactionHash: ''0x3bd37...'',  transactionIndex:
    96,  transactionLogIndex: ''0x0'',  type: ''mined'',  returnValues:    Result
    {      ''0'': ''0xAAAAA6...'',      ''1'': ''0x664753...'',      ''2'': ''1905510325611397921584'',      from:
    ''0xAAAAA6...'',      to: ''0x664753...'',      value: ''1905510325611397921584''
    },  event: ''Transfer''}, ... ]Listing 4-8'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 'Contract 对象还可以用于获取可以插入低级调用或原始交易的函数选择器。在下一行中，encodeABI 方法返回了我们在本节开头使用的数据选择器。>
    await erc20.methods.totalSupply().encodeABI()''0x18160ddd''合约还公开了对 ABI 上声明的所有事件的便捷接口（见列表
    [4-8](#PC20)），从而可以轻松查询区块范围内的所有事件。> const block = await web3.eth.getBlockNumber();>
    const opts = { fromBlock: block - 100, toBlock: block };> await erc20.getPastEvents(''Transfer'',
    opts);[{address: ''0x0D8775F648430679A709E98d2b0Cb6250d2887EF'',  blockNumber:
    7060651,  logIndex: 91,  removed: false,  transactionHash: ''0x3bd37...'',  transactionIndex:
    96,  transactionLogIndex: ''0x0'',  type: ''mined'',  returnValues:    Result
    {      ''0'': ''0xAAAAA6...'',      ''1'': ''0x664753...'',      ''2'': ''1905510325611397921584'',      from:
    ''0xAAAAA6...'',      to: ''0x664753...'',      value: ''1905510325611397921584''
    },  event: ''Transfer''}, ... ]列表 4-8'
- en: Obtaining the transfer events on the BAT token on mainnet that occurred in the
    past 100 blocks. In this example, the address starting with 0xAAAAA6 transferred
    1.9e21 tokens to address 0x664753
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 获取在过去 100 个区块中发生的主网上 BAT 代币的转账事件。在此示例中，以 0xAAAAA6 开头的地址将 1.9e21 代币转账给地址 0x664753
- en: Each log object informs of the block and the transaction where it occurred,
    as well as the name of the event (in this case, Transfer), and includes the parameters
    with which it was emitted.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 每个日志对象都会提供发生事件的区块和交易信息，以及事件的名称（在本例中为 Transfer），并包括其发出时的参数。
- en: Detecting Changes
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检测变化
- en: We will now go deeper into events. Even though we now know how to query past
    events, listening to new events is a useful method to detect changes to a contract
    in our application in real time. We will see three different ways for monitoring
    changes.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将深入探讨事件。即使我们现在知道如何查询过去的事件，但监听新事件是实时检测合约在我们应用程序中的变化的一种有用方法。我们将看到三种不同的监视变化的方法。
- en: Polling for New Blocks
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 轮询新区块
- en: Polling is a simple yet effective method for reacting to changes (Listing [4-9](#PC21)).
    Given that any change in the Ethereum network needs to be introduced via a new
    block in the chain, a perfectly valid approach is to just poll for new blocks,
    and re-read the contract state that you are interested in whenever a new block
    is mined. Since Ethereum blocks are generated every few seconds, a 1-second interval
    can be good enough.let block = null,    totalSupply = null;const interval = setInterval(async
    function() {  const newBlock = await web3.eth.getBlockNumber();  if (newBlock
    !== block) {    // update block number    block = newBlock;    // re-read relevant
    data from contract    totalSupply = await erc20.methods.totalSupply().call();  }},
    1000);Listing 4-9
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 轮询是一种简单但有效的方法来对变化做出反应（见[4-9](#PC21)）。鉴于以太坊网络中的任何变化都需要通过链中的新块引入，一个完全有效的方法是只轮询新块，并在挖掘新块时重新读取您感兴趣的合约状态。由于以太坊块每隔几秒钟生成一次，1
    秒的间隔可能就足够了。let block = null,    totalSupply = null;const interval = setInterval(async
    function() {  const newBlock = await web3.eth.getBlockNumber();  if (newBlock
    !== block) {    // 更新块编号    block = newBlock;    // 从合约中重新读取相关数据    totalSupply
    = await erc20.methods.totalSupply().call();  }}, 1000);[4-9]清单
- en: Polling for new blocks to update the totalSupply of an ERC20 contract. Though
    we could directly poll for the total supply, this approach is more efficient if
    there is more data that we need to update on every block
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 轮询新块以更新 ERC20 合约的 totalSupply。虽然我们可以直接轮询总供应量，但如果有更多需要在每个块上更新的数据，则此方法更有效率
- en: Whenever a new block is spotted, you can query the contract your app is interacting
    with to retrieve its latest state and update your app accordingly if there were
    any changes. An alternative would be to run getPastEvents on the new block and
    only react if there were any events that affect your contract.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 每当发现新块时，您可以查询您的应用正在交互的合约以检索其最新状态，并根据需要更新您的应用程序，如果有任何更改。另一种方法是在新块上运行 getPastEvents，并且只有在有任何影响您的合约的事件时才做出反应。
- en: Installing Event Filters
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装事件过滤器
- en: '*Event filters* are a mechanism provided by Ethereum nodes for retrieving new
    events that match a specified set of conditions. It works by allowing you to install
    an event filter **on a node** and then polling for any new events that match that
    filter. At a JSON-RPC level, this pattern is supported mainly by the following
    methods:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*事件过滤器*是以太坊节点提供的一种机制，用于检索与指定条件匹配的新事件。它通过允许你在**节点上**安装事件过滤器，然后轮询与该过滤器匹配的任何新事件来工作。在
    JSON-RPC 层面上，该模式主要由以下方法支持：'
- en: newFilter to install a new event filter on a node, which returns a filter ID
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: newFilter 在节点上安装新事件过滤器，返回一个过滤器 ID
- en: getFilterChanges that returns all new logs for a given filter ID since the last
    time this method was called
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取过滤器更改，返回自上次调用此方法以来给定过滤器 ID 的所有新日志
- en: uninstallFilter to remove a filter given its ID
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: uninstallFilter 通过其 ID 删除过滤器
- en: Event filters still rely on polling a node for new changes, but they are more
    convenient to use, since it is now the node that keeps track of exactly what new
    events need to be sent to the client. This saves the client from needing to issue
    regular getPastLogs calls to check for new events and allows the node to precalculate
    the data to send if needed. It is also possible to install filters for new blocks
    and pending transactions that are sent to the node.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 事件过滤器仍然依赖于轮询节点以获取新更改，但它们更方便使用，因为现在节点会准确跟踪需要发送到客户端的新事件。这使得客户端无需定期发出 getPastLogs
    调用以检查新事件，并允许节点在需要时预先计算要发送的数据。还可以为发送到节点的新区块和待处理事务安装过滤器。
- en: Warning
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 警告
- en: Some public nodes, such as the ones offered by Infura, may not support installing
    event filters. To work around this, Metamask ships with a web3 subprovider to
    fake the behavior of filters completely on the client side. This allows you to
    code your application using event filters without needing to worry about whether
    the node you are connecting to actually supports them. However, keep in mind that
    the performance gain you could get by using filters is completely lost in this
    scenario.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一些公共节点，如 Infura 提供的节点，可能不支持安装事件过滤器。为了解决这个问题，Metamask 配备了一个 web3 子提供程序，完全在客户端上模拟过滤器的行为。这使您可以使用事件过滤器编写应用程序，而无需担心连接的节点实际上是否支持它们。但是，请记住，在这种情况下，通过使用过滤器获得的性能增益完全丧失。
- en: 'At this point, it is worth going into what options can be specified for retrieving
    and polling events. These options can be used both when creating new filters and
    when getting past logs:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，值得讨论一下可用于检索和轮询事件的选项。这些选项既可在创建新过滤器时使用，也可在获取过去日志时使用：
- en: '**Block ranges** can be used to specify which blocks to monitor for events.
    By default, filters are created to monitor the latest block mined.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**区块范围**可用于指定要监视事件的区块。默认情况下，会创建过滤器以监视最新挖掘的区块。'
- en: One or more **addresses** where the logs originate from. Retrieving events from
    a web3 Contract object will automatically restrict the logs to the address of
    the contract instance.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个或多个日志来源的**地址**。从 web3 合约对象检索事件将自动将日志限制为合约实例的地址。
- en: The **topics** used to filter the events. Remember from Chapter [3](476252_1_En_3_Chapter.xhtml)
    that EVM logs can have up to four indexed topics – these are used for filtering
    them during queries. The first topic is always the event selector, while the remaining
    topics are the indexed arguments from Solidity. A filter can impose restrictions
    on any of the topics, requesting a topic to optionally match a set of values.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于过滤事件的**主题**。请记住，从[第三章](476252_1_En_3_Chapter.xhtml)中可以得知 EVM 日志最多可以有四个索引主题，这些主题在查询期间用于过滤它们。第一个主题始终是事件选择器，而其余的主题是来自
    Solidity 的索引参数。过滤器可以对任何主题施加限制，要求主题可选择匹配一组值。
- en: 'As an example, the following filter object can be used to retrieve all transfers
    of an ERC20 token sent to a group of three token holders during the last 1000
    blocks.> const block = await web3.eth.getBlockNumber();> const filter = { to:
    [holder1, holder2, holder3] };> const opts = { fromBlock: block - 1000, filter:
    filter };> await erc20.getPastEvents(''Transfer'', opts);'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '例如，以下过滤器对象可用于检索发送到三个代币持有者组的 ERC20 代币的所有转账，在最后的 1000 个区块中。> const block = await
    web3.eth.getBlockNumber();> const filter = { to: [holder1, holder2, holder3] };>
    const opts = { fromBlock: block - 1000, filter: filter };> await erc20.getPastEvents(''Transfer'',
    opts);'
- en: 'The web3 library has no support for event filters. Instead, monitoring for
    events is done via the third and last mechanism for listening to changes: subscriptions.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: web3 库不支持事件过滤器。相反，监听事件是通过第三种也是最后一种监听更改的机制实现的：订阅。
- en: Creating Subscriptions
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建订阅
- en: A more advanced option to monitor events is to create a subscription. Event
    subscriptions work similar to event filters in that they are created in a node
    from a set of filters (block range, addresses, and topics) to indicate which events
    are of interest to the client. However, subscriptions do not require the client
    to poll for changes, but rely on two-way connections to directly push new events
    to the client. For this reason, subscriptions are only available on websockets
    or IPC connections and not on HTTP ones.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 监听事件的更高级选项是创建订阅。事件订阅的工作方式类似于事件过滤器，即它们在节点中从一组过滤器（区块范围、地址和主题）创建，以指示哪些事件对客户端感兴趣。但是，订阅不需要客户端轮询更改，而是依靠双向连接直接将新事件推送到客户端。因此，订阅仅在
    websocket 或 IPC 连接上可用，而不在 HTTP 连接上可用。
- en: Note
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Unlike event filters, Infura does support websocket connections, via the URL
    wss://mainnet.infura.io/ws/v3/PROJECTID. Still, in the event that the user chooses
    a custom node via a regular HTTP connection, Metamask also ships with a subprovider
    to fake subscriptions client-side by relying on polling. Again, this allows you
    to transparently use event subscriptions on your app, having a subprovider polyfill
    the feature if the connection or node does not support it.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 与事件过滤器不同，Infura 支持 websocket 连接，通过 URL wss://mainnet.infura.io/ws/v3/PROJECTID。然而，如果用户选择通过常规
    HTTP 连接使用自定义节点，Metamask 也配备了一个子提供程序来模拟客户端订阅，依靠轮询实现。同样，这使您能够在应用程序中透明地使用事件订阅，在连接或节点不支持时，子提供程序会填充该功能。
- en: 'Under the hood, web3 uses subscriptions when you listen to an event (Listing
    [4-10](#PC23)). This means that you will only be able to rely on events if you
    are running on a websocket or IPC connection, or you have a subprovider to polyfill
    for subscriptions. The web3 event emitter will report whenever a new event that
    matches the filter is available, when an error occurs, and when an event is removed
    from the blockchain due to a reorganization.> const filter = { to: [holder1, holder2,
    holder3] };> const sub = erc20.events.Transfer({ filter })  .on(''data'', (evt)
    =>    console.log(`New tx from ${evt.returnValues.from}`)  )  .on(''error'', (err)
    =>    console.error(err)  )  .on(''changed'', (evt) =>    console.log(`Removed
    tx from ${evt.returnValues.from}`)  )Listing 4-10'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，当你监听事件时，web3 使用订阅（见[4-10](#PC23)）。这意味着只有在 websocket 或 IPC 连接上运行，或者你有一个子提供程序来填充订阅时，你才能依赖事件。web3
    事件发射器将在匹配过滤器的新事件可用时报告，发生错误时以及由于重新组织而从区块链中删除事件时报告。
- en: Setting up a subscription to monitor Transfer events on an ERC20 token contract.
    The `data` handler fires on every new event, while `error` fires upon an error
    in the subscription. Events removed from the chain due to a reorganization are
    fired in `changed`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 设置一个订阅以监视 ERC20 代币合约上的转账事件。`data` 处理程序在每个新事件上触发，而 `error` 在订阅出错时触发。由于重组而从链上移除的事件会在
    `changed` 中触发。
- en: Subscriptions are automatically cleared when the connection to the server is
    closed. Alternatively, they can be removed via the unsubscribe() method  on the
    subscription object, or by using web3.eth.clearSubscriptions(), which removes
    all active subscriptions.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当与服务器的连接关闭时，订阅会自动清除。或者，可以通过取消订阅对象上的 unsubscribe() 方法或使用 web3.eth.clearSubscriptions()
    来删除所有活动订阅。
- en: As with event filters, it is possible to set up subscriptions for events from
    multiple addresses, as well as for new pending transactions or new blocks. Using
    the latter, a similar pattern to polling can be implemented, in which a subscription
    is installed to monitor for new blocks, and upon every block the state of the
    contract is re-read. Nevertheless, if the contract emits events for all state
    changes, monitoring them is much more efficient.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 与事件过滤器一样，可以为来自多个地址的事件以及新挂起的交易或新区块设置订阅。使用后者，可以实现类似轮询的模式，其中安装一个订阅以监视新块，然后在每个块上重新读取合约的状态。然而，如果合约为所有状态更改发出事件，则监视它们会更加高效。
- en: Example Application
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 例子应用
- en: We will now put together everything we learned in this chapter and build a web
    application for monitoring transfers on an ERC20 token. This application will
    just retrieve data from the token and not provide any interface for actually sending
    transactions.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将整合本章学到的所有内容，并构建一个用于监视 ERC20 代币转账的 Web 应用程序。此应用程序将仅从代币中检索数据，而不提供实际发送交易的界面。
- en: Setup
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置
- en: We will once again use the create-react-app package to bootstrap our application.
    Needless to say, using this package is not required, but will simplify our setup
    and let us focus on building the app itself.npm init react-app erc20-app
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次使用 create-react-app 包来引导我们的应用程序。毫无疑问，使用这个包并不是必须的，但会简化我们的设置，并让我们专注于构建应用本身。npm
    init react-app erc20-app
- en: Dependencies
  id: totrans-124
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 依赖项
- en: Besides web3, we will install the openzeppelin-solidity package as a dependency.
    OpenZeppelin is an open source library of secure reusable smart contracts, and
    includes vetted implementations for some standards. We will use it to obtain the
    ABI of the ERC20 contract that we need to create the web3 Contract instance. We
    will also add bignumber.js for manipulating a few numeric values throughout the
    app.npm install web3@1.2.0 openzeppelin-solidity@2.1 bignumber.js@8.0
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 web3，我们还将 openzeppelin-solidity 包安装为依赖项。OpenZeppelin 是一个开源的安全可重用智能合约库，包含了一些标准的审核实现。我们将使用它来获取我们需要创建
    web3 Contract 实例的 ERC20 合约的 ABI。我们还将添加 bignumber.js 来在整个应用程序中操纵一些数值。npm install
    web3@1.2.0 openzeppelin-solidity@2.1 bignumber.js@8.0
- en: As before, try running npm start to make sure that the sample react-app runs
    successfully. We can now start coding.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 像以前一样，尝试运行 npm start 确保示例 react-app 成功运行。现在我们可以开始编码了。
- en: Initializing Web3
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 初始化 Web3
- en: We will create a network.js file  as before to manage a web3 object to connect
    to the network. We will rely on the injected web3 provider, falling back to a
    websocket connection to Infura. Note that since we will not request access to
    user accounts, we can skip the ethereum.enable() call.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将像以前一样创建一个 network.js 文件来管理连接到网络的 web3 对象。我们将依赖于注入的 web3 提供者，如果需要，会回退到 Infura
    的 WebSocket 连接。请注意，由于我们不会请求用户账户访问权限，我们可以跳过 ethereum.enable() 调用。
- en: // src/eth/network.jsimport Web3 from 'web3';let web3;export function getWeb3()
    {  if (!web3) {    web3 = new Web3(window.ethereum              || (window.web3
    && window.web3.currentProvider)              || "wss://mainnet.infura.io/ws/v3/PROJECT_ID");  }
    return web3;}
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: // src/eth/network.jsimport Web3 from 'web3';let web3;export function getWeb3()
    {  if (!web3) {    web3 = new Web3(window.ethereum              || (window.web3
    && window.web3.currentProvider)              || "wss://mainnet.infura.io/ws/v3/PROJECT_ID");  }
    return web3;}
- en: Note
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Make sure to use a valid URL for the fallback provider, by filling in with your
    Infura token, in case the user browsing the site does not have Metamask or a web3
    compatible browser. Note that it is websocket-based, since we will be using event
    subscriptions later on the app.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在回退提供者的有效URL中填入你的 Infura 令牌，以防用户浏览站点时没有 Metamask 或兼容 web3 的浏览器。请注意，这是基于 WebSocket
    的，因为我们将在应用程序后期使用事件订阅。
- en: The ERC20 Contract
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ERC20 合约
- en: We will create a small function for initializing new web3 contract objects for
    ERC20s. Recall that in order to do this, we needed access to the web3 object (which
    we have already set up), the contract ABI, and the address.// src/contracts/ERC20.jsimport
    ERC20Artifact from 'openzeppelin-solidity/build/contracts/ERC20Detailed.json';export
    default function ERC20(web3, address = null) {  const { abi } = ERC20Artifact;  return
    new web3.eth.Contract(abi, address);}
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个小函数，用于为ERC20初始化新的web3合约对象。请记住，为了做到这一点，我们需要访问web3对象（我们已经设置好了），合约ABI和地址。//
    src/contracts/ERC20.jsimport ERC20Artifact from 'openzeppelin-solidity/build/contracts/ERC20Detailed.json';export
    default function ERC20(web3, address = null) {  const { abi } = ERC20Artifact;  return
    new web3.eth.Contract(abi, address);}
- en: We retrieve the contract ABI from OpenZeppelin, while we’ll leave the address
    as a parameter for now. Now that we have all basic components set up, we can get
    started with the application views.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从OpenZeppelin检索合约ABI，而将地址留作参数。现在我们已经设置好了所有基本组件，我们可以开始使用应用程序视图了。
- en: Building the Application
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建应用程序
- en: We will start with a main App component that will initialize the connection
    and set up the ERC20 contract instance that we will be monitoring. Once we have
    the contract instance ready, we will begin by retrieving some information from
    it.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个主要的应用程序组件开始，该组件将初始化连接并设置我们将要监视的ERC20合约实例。一旦我们准备好了合约实例，我们将开始从中检索一些信息。
- en: Root Component
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 根组件
- en: The App component will be the root of our component tree (Listing [4-11](#PC28)).
    This component will manage the connection to the network and the ERC20 contract
    instance, both of which will be set up on the componentDidMount lifecycle method.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序组件将成为我们组件树的根（见[4-11](#PC28)）列表。该组件将管理与网络和ERC20合约实例的连接，这两者都将在componentDidMount生命周期方法中设置。
- en: 'Remember that this method is automatically fired by React when the component
    has mounted, and is the suggested event for retrieving async data. Of course,
    if you are using a particular state management library (such as Redux), your strategy
    for loading async data may be different.// src/App.jsimport React, { Component
    } from ''react'';import ERC20Contract from ''./contracts/ERC20'';import { getWeb3
    } from ''./eth/network'';const ERC20_ADDRESS = "0x1985365e9f78359a9B6AD760e32412f4a445E862";class
    App extends Component {  state = { loading: true };  async componentDidMount()
    {    const web3 = getWeb3();    **const erc20 = await ERC20Contract(web3, ERC20_ADDRESS);**    this.setState({
    erc20, loading: false });  }  render() {    return (      <div className="App">        {
    this.getAppContent() }      </div>    );  }  getAppContent() {    const { erc20
    } = this.state;    if (!erc20) {      return (<div>Connecting to network...</div>);    }
    else {      return (<div>ERC20 at {erc20.options.address}</div>);    }  }}Listing
    4-11'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '请记住，此方法会在组件挂载后由 React 自动触发，并且是检索异步数据的建议事件。当然，如果您使用特定的状态管理库（如 Redux），您加载异步数据的策略可能会有所不同。//
    src/App.jsimport React, { Component } from ''react'';import ERC20Contract from
    ''./contracts/ERC20'';import { getWeb3 } from ''./eth/network'';const ERC20_ADDRESS
    = "0x1985365e9f78359a9B6AD760e32412f4a445E862";class App extends Component {  state
    = { loading: true };  async componentDidMount() {    const web3 = getWeb3();    **const
    erc20 = await ERC20Contract(web3, ERC20_ADDRESS);**    this.setState({ erc20,
    loading: false });  }  render() {    return (      <div className="App">        {
    this.getAppContent() }      </div>    );  }  getAppContent() {    const { erc20
    } = this.state;    if (!erc20) {      return (<div>连接到网络中...</div>);    } else
    {      return (<div>ERC20 在 {erc20.options.address}</div>);    }  }}Listing 4-11'
- en: Initial version of the root App component for our application. Note that the
    highlighted line in componentDidMount that is setting up the ERC20 contract is
    using the factory method we built earlier
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序的根组件的初始版本。请注意`componentDidMount`中突出显示的行，该行正在设置我们之前构建的工厂方法
- en: Since the address in the preceding example refers to a contract on mainnet,
    the app will only work if we have a connection to the Ethereum main network. If
    we are connecting to another network, the contract will probably not exist at
    the address listed, causing the app to fail.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 由于上例中的地址指的是主网上的一个合约，所以只有当我们连接到以太坊主网络时，应用程序才能正常工作。如果我们连接到另一个网络，该地址上的合约可能不存在，导致应用程序失败。
- en: Note
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you are curious about the ERC20 address chosen, it is the Augur REP token.
    Augur is a decentralized oracle and prediction market, and its main token is used
    reporting and disputing the outcome of events. If you want to experiment with
    other ERC20s, Etherscan provides a handy list of top tokens at etherscan.io/tokens.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对所选的 ERC20 地址感兴趣，它是 Augur REP 代币。 Augur 是一个去中心化的预言机和预测市场，其主要代币用于报告和争议事件的结果。如果您想尝试其他
    ERC20 代币，Etherscan 在 etherscan.io/tokens 提供了一个方便的代币列表。
- en: 'To handle this case, we will add a few lines to detect the current network,
    and validate that we are indeed on mainnet (Listing [4-12](#PC29)). You can play
    with this by changing the current network on metamask while on the application.  async
    componentDidMount() {    const web3 = getWeb3();    **const networkId = await
    web3.eth.net.getId();**    **const isMainnet = (networkId === 1);**    **this.setState({
    isMainnet });**    if (isMainnet) {      const erc20 = await ERC20Contract(web3,
    ERC20_ADDRESS);      this.setState({ erc20 });    }    this.setState({ loading:
    false });  }Listing 4-12'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '要处理这种情况，我们将添加几行代码来检测当前网络，并验证我们确实在主网络上（见[4-12](#PC29)）。您可以在应用程序上使用 Metamask
    更改当前网络来测试此功能。  async componentDidMount() {    const web3 = getWeb3();    **const
    networkId = await web3.eth.net.getId();**    **const isMainnet = (networkId ===
    1);**    **this.setState({ isMainnet });**    if (isMainnet) {      const erc20
    = await ERC20Contract(web3, ERC20_ADDRESS);      this.setState({ erc20 });    }    this.setState({
    loading: false });  }列表 4-12'
- en: Checking that we are currently connected to mainnet. Note that the contract
    is only instantiated if we are on the correct network
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 检查我们当前是否连接到主网络。请注意，只有在我们连接到正确的网络时才会实例化合约。
- en: 'The render method needs to be changed accordingly to handle not just the loading
    and loaded states but also the state where we are not on mainnet.  getAppContent()
    {    const { loading, isMainnet, erc20 } = this.state;    if (loading) {      return
    (<div>Connecting to network...</div>);    } else if (!isMainnet) {      return
    (<div>Please connect to Mainnet</div>);    } else {      return (<div>ERC20 at
    {erc20.options.address}</div>);    }  }We still have another issue to tackle:
    what if the connection just fails? The node we are connecting to may be offline,
    or the contract address could just be incorrect. We need to add proper error handling
    when we are retrieving blockchain data (Listing [4-13](#PC31)).  async componentDidMount()
    {    const web3 = getWeb3();    await this.checkNetwork(web3);    await this.retrieveContract(web3);    this.setState({
    loading: false });  }  async checkNetwork(web3) {    try {      const networkId
    = await web3.eth.net.getId();      const isMainnet = (networkId === 1);      this.setState({
    isMainnet });    } catch (error) {      console.error(error);      **this.setState({
    error: `Error connecting to network` })**    }  }  async retrieveContract(web3)
    {    if (!this.state.isMainnet) return;    try {      const erc20 = await ERC20Contract(web3,
    ERC20_ADDRESS);      this.setState({ erc20 });    } catch (error) {      console.error(error);      **this.setState({
    error: `Error retrieving contract` })**    }  }Listing 4-13'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '渲染方法需要相应更改，以处理不仅是加载和已加载状态，还包括我们不在主网的状态。`getAppContent() {`    `const { loading,
    isMainnet, erc20 } = this.state;`    `if (loading) {`      `return (<div>连接到网络中...</div>);`    `}
    else if (!isMainnet) {`      `return (<div>请连接到主网</div>);`    `} else {`      `return
    (<div>ERC20在 {erc20.options.address}</div>);`    `}`  `}我们还有另一个问题要解决：如果连接失败怎么办？我们连接的节点可能已离线，或者合约地址可能不正确。当我们检索区块链数据时，我们需要添加适当的错误处理（见[4-13](#PC31)）。`async
    componentDidMount() {`    `const web3 = getWeb3();`    `await this.checkNetwork(web3);`    `await
    this.retrieveContract(web3);`    `this.setState({ loading: false });`  `}`  `async
    checkNetwork(web3) {`    `try {`      `const networkId = await web3.eth.net.getId();`      `const
    isMainnet = (networkId === 1);`      `this.setState({ isMainnet });`    `} catch
    (error) {`      `console.error(error);`      **`this.setState({ error: ''连接网络时出错''
    })`**    `}`  `}`  `async retrieveContract(web3) {`    `if (!this.state.isMainnet)
    return;`    `try {`      `const erc20 = await ERC20Contract(web3, ERC20_ADDRESS);`      `this.setState({
    erc20 });`    `} catch (error) {`      `console.error(error);`      **`this.setState({
    error: ''检索合约时出错'' })`**    `}`  `}`[4-13](#PC31)'
- en: Updated componentDidMount method to add error handling. Note that the render
    method also needs to be updated accordingly to display the error message if it
    is present in the component state
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 更新了`componentDidMount`方法以添加错误处理。请注意，渲染方法也需要相应更新，以便根据组件状态显示错误消息（如果存在）。
- en: We can now focus on the token itself. Let’s create a new component named ERC20,
    display it instead of the contract’s address (Listing [4-14](#PC32)), and start
    working on it.  getAppContent() {    const { loading, error, isMainnet, erc20
    } = this.state;    if (error) {      return (<div>{error}</div>);    } else if
    (loading) {      return (<div>Connecting to network...</div>);    } else if (!isMainnet)
    {      return (<div>Please connect to Mainnet</div>);    } else {      **return
    (<ERC20 contract={erc20} />);**    }  }Listing 4-14
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以专注于代币本身。让我们创建一个名为ERC20的新组件，显示它而不是合约地址（见列表 [4-14](#PC32)），并开始处理它。 getAppContent()
    { const { loading, error, isMainnet, erc20 } = this.state; if (error) { return
    (<div>{error}</div>); } else if (loading) { return (<div>Connecting to network...</div>);
    } else if (!isMainnet) { return (<div>Please connect to Mainnet</div>); } else
    { **return (<ERC20 contract={erc20} />);** } }Listing 4-14
- en: Updated render helper method to display an ERC20 component, which expects the
    erc20 contract instance as a property
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 更新渲染辅助方法以显示ERC20组件，该方法期望erc20合约实例作为属性
- en: ERC20 Component
  id: totrans-150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ERC20 组件
- en: This component shall receive the contract instance, knowing that all connection
    details have been settled by the parent component, and display it. We will start
    by retrieving some static information, such as the name, symbol, and number of
    decimals (Listing [4-15](#PC33)). These are optional attributes according to the
    ERC20 standard, since they are never used as part of the contract’s logic; nevertheless,
    most tokens do implement them.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件应接收合约实例，知道所有连接细节已由父组件解决，并将其显示出来。我们将从检索一些静态信息开始，例如名称、符号和小数位数（见列表 [4-15](#PC33)）。根据ERC20标准，这些是可选属性，因为它们从不作为合约逻辑的一部分使用；然而，大多数代币确实会实现它们。
- en: 'We will also retrieve the token’s total supply. This is the total number of
    tokens created for this contract. Unlike the name, symbol, and decimals, there
    is no guarantee that this value will stay constant: some tokens have a continuous
    issuance model, which causes the total supply to increase on every block, while
    others may have a deflationary model where certain events actually burn tokens.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将检索代币的总供应量。这是为该合约创建的代币总数。与名称、符号和小数点不同，不能保证此值会保持不变：一些代币具有连续发行模型，导致总供应量在每个区块上增加，而其他代币可能采用通缩模型，在某些事件实际上会销毁代币。
- en: For the sake of this app, we will work only with tokens with a fixed supply,
    so we will not need to refresh the total supply. Nevertheless, you could easily
    add a polling mechanism for updating the total supply on every call, as we have
    seen earlier in this chapter.class ERC20 extends Component {  async componentDidMount()
    {    const { contract } = this.props;    **const [name, symbol, decimals, totalSupply]
    =**      **await Promise.all([**        **contract.methods.name().call(),**        **contract.methods.symbol().call(),**        **contract.methods.decimals().call(),**        **contract.methods.totalSupply().call(),**      **]);**    this.setState({
    name, symbol, decimals, totalSupply });  }}Listing 4-15
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个应用程序，我们将仅使用固定供应量的代币，因此我们不需要刷新总供应量。尽管如此，您可以轻松地添加一个轮询机制，在每次调用时更新总供应量，就像我们在本章前面看到的那样。class
    ERC20 extends Component {  async componentDidMount() {    const { contract } =
    this.props;    **const [name, symbol, decimals, totalSupply] =**      **await
    Promise.all([**        **contract.methods.name().call(),**        **contract.methods.symbol().call(),**        **contract.methods.decimals().call(),**        **contract.methods.totalSupply().call(),**      **]);**    this.setState({
    name, symbol, decimals, totalSupply });  }}列表 4-15
- en: React component for displaying information on the ERC20 token. Once again, we
    rely on the componentDidMount method to load async information to populate the
    state. By using Promise.all(), we fire all four requests simultaneously and only
    set the return values once we have obtained all of them
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 用于显示 ERC20 代币信息的 React 组件。再次，我们依赖 componentDidMount 方法来加载异步信息以填充状态。通过使用 Promise.all()，我们同时触发所有四个请求，并仅在获取到所有请求的返回值后设置它们。
- en: We can now render this information by showing the token name and symbol to our
    users, as well as the total supply (Listing [4-16](#PC34)). We will rely on the
    decimals of the token to format all the values we display.render() {  if (!this.state.totalSupply)
    return "Loading...";  const { name, totalSupply, decimals, symbol } = this.state;  const
    formattedSupply = formatValue(totalSupply, decimals);  return (<div>    <h1>{name}
    Token</h1>    <div>Total supply of {formattedSupply} {symbol}</div>  </div>);}Listing
    4-16
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过向用户显示代币名称和符号以及总供应量来呈现此信息（列表 [4-16](#PC34)）。我们将依赖代币的小数位数来格式化我们显示的所有值。render()
    {  if (!this.state.totalSupply) return "Loading...";  const { name, totalSupply,
    decimals, symbol } = this.state;  const formattedSupply = formatValue(totalSupply,
    decimals);  return (<div>    <h1>{name} 代币</h1>    <div>{formattedSupply} {symbol}
    的总供应量</div>  </div>);}列表 4-16
- en: Render method to display the static information of an ERC20 token. Note that
    the totalSupply is adjusted by the decimals of the token
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染方法用于显示 ERC20 代币的静态信息。请注意，totalSupply 受代币的小数位数调整影响。
- en: 'For the auxiliary formatValue function (Listing [4-17](#PC35)), we will rely
    on bignumber.js, a library for manipulating and formatting big numbers in javascript.
    We will convert the total supply value to a bignumber instance, right-shift it
    (on base 10) by the number of decimals, and format the result as a string.// src/utils/format.jsimport
    BigNumber from ''bignumber.js'';BigNumber.config({ DECIMAL_PLACES: 4 });export
    function formatValue(value, decimals) {  const bn = new BigNumber(value);  return
    bn.shiftedBy(-decimals).toString(10);}Listing 4-17'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '对于辅助的 formatValue 函数（见[4-17](#PC35)），我们将依赖于 bignumber.js，这是一个用于操作和格式化 JavaScript
    中大数的库。我们将把总供应量值转换为一个大数实例，按小数点的数量（以 10 为基数）进行右移，然后将结果格式化为字符串。// src/utils/format.jsimport
    BigNumber from ''bignumber.js'';BigNumber.config({ DECIMAL_PLACES: 4 });export
    function formatValue(value, decimals) {  const bn = new BigNumber(value);  return
    bn.shiftedBy(-decimals).toString(10);}列表 4-17'
- en: Auxiliary function to format token amounts based on the decimals property of
    the contract
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 根据合约的小数属性格式化代币金额的辅助函数
- en: The output so far should look like Figure [4-3](#Fig3), assuming you did not
    change the token address from the example.![../images/476252_1_En_4_Chapter/476252_1_En_4_Fig3_HTML.jpg](../images/476252_1_En_4_Chapter/476252_1_En_4_Fig3_HTML.jpg)
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止的输出应该看起来像图 [4-3](#Fig3)，假设你没有改变示例中的代币地址。![../images/476252_1_En_4_Chapter/476252_1_En_4_Fig3_HTML.jpg](../images/476252_1_En_4_Chapter/476252_1_En_4_Fig3_HTML.jpg)
- en: Figure 4-3
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-3
- en: 'Our sample application displaying the static information of the Augur REP token:
    name (Reputation), symbol (REP), and total supply (1.1e25) formatted with the
    token decimals (18)'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例应用程序显示 Augur REP 代币的静态信息：名称（声誉）、符号（REP）和总供应量（1.1e25），并根据代币小数（18）进行格式化
- en: Displaying Transfer Events
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 显示转账事件
- en: We will now add the last component of our application that will display the
    latest transfers of the token and listen for any new ones in real time.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将添加我们应用程序的最后一个组件，它将显示代币的最新转账，并实时监听任何新的转账。
- en: Loading Past Transfers
  id: totrans-164
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 加载过往转账
- en: 'Let’s start by adding a Transfers component to the ERC20 component we already
    have (Listing [4-18](#PC36)), that will start out by loading past transfers. This
    component will receive the contract, decimals, and symbol as props from its parent:
    the first one to monitor for events and the other two to format values.render()
    {  if (!this.state.totalSupply) return "Loading...";  const { name, totalSupply,
    decimals, symbol } = this.state;  const { contract } = this.props;  const formattedSupply
    = formatValue(totalSupply, decimals);  return (    <div className="ERC20">      <h1>{name}
    Token</h1>      <div>Total supply of {formattedSupply} {symbol}</div>      <div>        **<h2>Transfers</h2>**        **<Transfers
    contract={contract}**           **decimals={decimals} symbol={symbol} />**      </div>    </div>  );}Listing
    4-18'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从给已有的 ERC20 组件添加一个 Transfers 组件开始（见 [4-18](#PC36)）,它将首先加载过去的转账。该组件将从其父组件接收合约、小数点和符号作为
    props：第一个用于监视事件，另外两个用于格式化数值。render() {  if (!this.state.totalSupply) return "Loading...";  const
    { name, totalSupply, decimals, symbol } = this.state;  const { contract } = this.props;  const
    formattedSupply = formatValue(totalSupply, decimals);  return (    <div className="ERC20">      <h1>{name}
    Token</h1>      <div>Total supply of {formattedSupply} {symbol}</div>      <div>        **<h2>转账</h2>**        **<Transfers
    contract={contract}**           **decimals={decimals} symbol={symbol} />**      </div>    </div>  );}Listing
    4-18
- en: Updated render method from the ERC20 component to include the new Transfers
    component
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 更新了 ERC20 组件的 render 方法以包含新的 Transfers 组件
- en: 'We will be loading all transfer events from the past 1000 blocks to seed the
    component. Attempting to load all transfers in history will probably fail, given
    that REP has over 75,000 transfers at the time of this writing, which is too large
    an amount to query from the node in a single request. There are other tokens with
    even more transfers, such as OMG, which is at over 2 million at the time of this
    writing.// src/components/Transfers.jsimport React, { Component } from ''react'';import
    { getWeb3 } from ''../eth/network'';export default class Transfers extends Component
    {  async componentDidMount() {    const { contract } = this.props;    const blockNumber
    = await getWeb3().eth.getBlockNumber();    const EVENT = ''Transfer'';    **const
    pastEvents = await contract.getPastEvents(EVENT, {**      **fromBlock: blockNumber
    - 1000,**      **toBlock: blockNumber**    **});**    this.setState({      loading:
    false,      transfers: pastEvents.reverse()    });  }}'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '我们将加载过去 1000 个区块的所有转账事件来初始化该组件。尝试加载所有历史转账可能会失败，因为 REP 在撰写本文时已有超过 75,000 次转账，这是一个太大的数量，在单个请求中查询节点可能会失败。还有其他代币，比如
    OMG，在撰写本文时已有超过 200 万次转账。// src/components/Transfers.jsimport React, { Component
    } from ''react'';import { getWeb3 } from ''../eth/network'';export default class
    Transfers extends Component {  async componentDidMount() {    const { contract
    } = this.props;    const blockNumber = await getWeb3().eth.getBlockNumber();    const
    EVENT = ''Transfer'';    **const pastEvents = await contract.getPastEvents(EVENT,
    {**      **fromBlock: blockNumber - 1000,**      **toBlock: blockNumber**    **});**    this.setState({      loading:
    false,      transfers: pastEvents.reverse()    });  }}'
- en: Note
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For the sake of this application, we are just loading the events from an arbitrary
    number of blocks ago, in order to seed the component with initial data as it loads.
    Depending on your use case, you may want to add an option to load more events
    (for instance, when the user scrolls to the end of the list) by firing subsequent
    getPastEvents calls.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 出于本应用程序的目的，我们只是从任意数量的块中加载事件，以便在加载时为组件提供初始数据。根据您的用例，您可能希望通过连续调用getPastEvents来添加加载更多事件的选项（例如，当用户滚动到列表末尾时）。
- en: 'The render method for this component is straightforward: we will show a pure
    component to display each transfer in a list (Listing [4-19](#PC38)). We will
    pass down the symbol and decimals to format the amount of tokens transferred in
    each event.  render() {    const { loading, transfers } = this.state;    const
    { decimals, symbol } = this.props;    if (loading) return "Loading...";    return
    (<div className="Transfers">      { transfers.map(transfer => (        <Transfer          key={getLogId(transfer)}          transfer={transfer}          decimals={decimals}          symbol={symbol}
    />      )) }    </div>)  }Listing 4-19'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 该组件的渲染方法很简单：我们将展示一个纯组件以在列表中显示每个转账（见[4-19](#PC38)）。我们将传递符号和小数点以格式化每个事件中转移的代币数量。
    render() {    const { loading, transfers } = this.state;    const { decimals,
    symbol } = this.props;    if (loading) return "Loading...";    return (<div className="Transfers">      {
    transfers.map(transfer => (        <Transfer          key={getLogId(transfer)}          transfer={transfer}          decimals={decimals}          symbol={symbol}
    />      )) }    </div>)  }Listing 4-19
- en: Displaying each transfer in the collection by using a pure component that simply
    displays the data received
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 使用纯组件显示集合中的每个转账，该组件仅显示接收到的数据。
- en: Keep in mind that React requires us to assign a unique key to each element in
    a collection. To generate this key, we are using a getLogId helper function (Listing
    [4-20](#PC39)) that combines the transaction hash in which the event occurred
    and the log index (i.e., the index of the particular event in the array of all
    logs emitted in the transaction). This combination is guaranteed to be unique.function
    getLogId(log) {  return `${log.transactionHash}.${log.logIndex}`;}Listing 4-20
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，React要求我们为集合中的每个元素分配一个唯一的键。为了生成此键，我们使用一个名为getLogId的帮助函数（见[4-20](#PC39)），该函数组合了事件发生的事务哈希和日志索引（即，数组中发出的所有日志的特定事件的索引）。此组合保证是唯一的。
    function getLogId(log) {  return `${log.transactionHash}.${log.logIndex}`;}Listing
    4-20
- en: Simple function for generating a unique identifier for a log. Note that web3.js
    already assigns an ID to a log entry, calculated as a hash over the same parameters.
    However, the hash is then truncated to 4 bytes, which may yield collisions if
    we are dealing with a large number of events
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 为日志生成唯一标识符的简单函数。请注意，web3.js已经为日志条目分配了一个ID，计算方式是对相同参数的哈希。然而，该哈希然后被截断为4个字节，如果我们处理大量事件，可能会导致碰撞。
- en: For the Transfer pure component (Listing [4-21](#PC40)), we will just rely on
    the formatValue helper function we used previously and fetch the from, to, and
    value arguments from the transfer object. As an extra, we will include a link
    to the transaction on etherscan so our users can review the transaction there,
    so they can perform an additional check on the data we display on our app.^([10](#Fn10))const
    ETHERSCAN_URL = 'https://etherscan.io/tx/';export default function Transfer (props)
    {  const { decimals, symbol, transfer } = props;  const { from, to, value } =
    transfer.returnValues;  const roundedValue = formatValue(value, decimals);  const
    url = ETHERSCAN_URL + transfer.transactionHash;  return (    <div>      <a href={url}>        {from}
    to {to} for {roundedValue} {symbol}      </a>    </div>  );}Listing 4-21
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Transfer 纯组件（见 [4-21](#PC40)） ，我们只需依赖之前使用的 formatValue 辅助函数，并从转移对象中获取 from、to
    和 value 参数。作为额外内容，我们将包含一个到 etherscan 上交易的链接，这样我们的用户可以在那里查看交易，以便他们可以对我们在应用程序上显示的数据进行额外的检查。^([10](#Fn10))常量
    ETHERSCAN_URL = 'https://etherscan.io/tx/';export default function Transfer (props)
    {  const { decimals, symbol, transfer } = props;  const { from, to, value } =
    transfer.returnValues;  const roundedValue = formatValue(value, decimals);  const
    url = ETHERSCAN_URL + transfer.transactionHash;  return (    <div>      <a href={url}>        {from}
    到 {to} 为 {roundedValue} {symbol}      </a>    </div>  );}4-21 列表
- en: Transfer component for displaying a single Transfer event loaded from the ERC20
    token contract
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 显示从 ERC20 代币合约加载的单个 Transfer 事件的转移组件
- en: With this code, every time we reload the page, we will see the transfers from
    the last 1000 blocks for the token. We can now add support for listening to new
    transfers as they occur.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这段代码，每次重新加载页面时，我们都会看到该令牌最近 1000 个区块的转移。现在，我们可以添加支持以在发生时监听新的转移。
- en: Monitoring New Transfers
  id: totrans-177
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 监控新的转移
- en: 'In order to monitor new transfers, we will install a *subscription* for Transfer
    events of this contract (Listing [4-22](#PC41)), as we have already seen previously
    in this chapter. We will listen to all transfers starting from the block right
    after the one we used for fetching past events and unsubscribe once the component
    is unmounted (Listing [4-23](#PC42)).  subscribe(contract, fromBlock) {    const
    eventSub = contract.events.Transfer({ fromBlock })      .on(''data'', (event)
    => {        this.setState(state => ({          ...state,          transfers: [event,
    ...state.transfers]        }));      });    this.setState({ eventSub });  }Listing
    4-22'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '为了监视新的转移，我们将安装一个 *subscription*，监听此合约的 Transfer 事件（见 [4-22](#PC41)），正如我们在本章中之前已经看到的那样。我们将监听从我们用于获取过去事件的区块之后的所有转移，并在组件取消挂载时取消订阅（见
    [4-23](#PC42)）。  subscribe(contract, fromBlock) {    const eventSub = contract.events.Transfer({
    fromBlock })      .on(''data'', (event) => {        this.setState(state => ({          ...state,          transfers:
    [event, ...state.transfers]        }));      });    this.setState({ eventSub });  }4-22
    列表'
- en: Subscription function to listen for new transfer events, to be called from componentDidMount,
    using erc20 and blockNumber+1 as arguments. Note that we are storing the subscription
    object in state to be able to unsubscribe later
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 用于监听新的转账事件的订阅函数，应该从 componentDidMount 中调用，使用 erc20 和 blockNumber+1 作为参数。注意，我们将订阅对象存储在状态中以便以后取消订阅
- en: componentWillUnmount() {    const { eventSub } = this.state;    if (eventSub)
    eventSub.unsubscribe();  }Listing 4-23
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: componentWillUnmount() {    const { eventSub } = this.state;    if (eventSub)
    eventSub.unsubscribe();  }示例 4-23
- en: Code to stop listening for events when the component is to be unmounted from
    the tree. Even though we will never unmount the component in this particular application,
    it is a good practice to always remove the subscriptions when they are no longer
    used
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当组件从树上卸载时停止监听事件的代码。即使在这个特定的应用程序中我们永远不会卸载组件，但始终在不再使用时移除订阅是一个好的做法
- en: 'Your application should now show new transactions as they occur, without the
    need for refreshing the page. However, to make sure we properly handle all scenarios,
    we will add handlers for when a transfer event is removed from the blockchain
    due to a reorganization and for when the subscription fails (Listing [4-24](#PC43)).  subscribe(contract,
    fromBlock) {    const eventSub = contract.events.Transfer({ fromBlock })      .on(''data'',
    (event) => {        this.setState(state => ({          ...state,          transfers:
    [event, ...state.transfers]        }));      })      **.on(''changed'', (event)
    => {**        **this.setState(state => ({**          **...state,**          **transfers:
    state.transfers.filter(t =>**            **t.transactionHash !== event.transactionHash**            **||
    t.logIndex !== event.logIndex**        **)}))**      **})**      **.on(''error'',
    (error) => {**        **this.setState({ error })**      **});**    this.setState({
    eventSub });  }Listing 4-24'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '您的应用程序现在应该在发生新交易时立即显示，无需刷新页面。但是，为了确保我们正确处理所有情况，我们将为从区块链中删除转账事件以进行重新组织和当订阅失败时添加处理程序（示例
    [4-24](#PC43)）  subscribe(contract, fromBlock) {    const eventSub = contract.events.Transfer({
    fromBlock })      .on(''data'', (event) => {        this.setState(state => ({          ...state,          transfers:
    [event, ...state.transfers]        }));      })      **.on(''changed'', (event)
    => {**        **this.setState(state => ({**          **...state,**          **transfers:
    state.transfers.filter(t =>**            **t.transactionHash !== event.transactionHash**            **||
    t.logIndex !== event.logIndex**        **)}))**      **})**      **.on(''error'',
    (error) => {**        **this.setState({ error })**      **});**    this.setState({
    eventSub });  }示例 4-24'
- en: Adding handlers for the changed and error events of the subscription. The former
    fires whenever an event is removed from the blockchain, so we remove it from our
    state, while the latter fires upon an error, which we add to our state to be displayed
    to the user
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为订阅的更改事件和错误事件添加处理程序。前者在从区块链中删除事件时触发，因此我们将其从状态中删除，而后者在出现错误时触发，我们将其添加到状态中以显示给用户
- en: Awaiting Confirmations
  id: totrans-184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 等待确认
- en: As the last step in the application, we will avoid displaying unconfirmed transfers
    to the user. Instead of showing a transfer event as soon as we receive it, we
    will instead wait for a certain number of blocks to be added to the chain before
    rendering it in our list.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 作为应用程序的最后一步，我们将避免向用户显示未确认的转账。我们不会在收到转账事件后立即显示它，而是在链上添加一定数量的区块后再在列表中呈现它。
- en: 'In order to do this, we first need to monitor the current block number. We
    will add a subscription specifically for that (Listing [4-25](#PC44)), though
    we could also poll the getBlockNumber method every second to achieve a similar
    result.  async componentDidMount() {    const blockNumber = await getWeb3().eth.getBlockNumber();    this.setState({
    blockNumber });    const HEADERS = ''newBlockHeaders'';    **const blockSub =
    getWeb3().eth.subscribe(HEADERS)**      **.on(''data'', ({ number }) => {**        **if
    (number) this.setState({ blockNumber: number});**      **});**    this.setState({
    blockSub });    // Subscribe to new transfers and load previous ones    // ...  }Listing
    4-25'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '为了做到这一点，我们首先需要监视当前的区块编号。我们将专门为此添加一个订阅（见[4-25](#PC44)），虽然我们也可以每秒轮询 getBlockNumber
    方法以实现类似的结果。  async componentDidMount() {    const blockNumber = await getWeb3().eth.getBlockNumber();    this.setState({
    blockNumber });    const HEADERS = ''newBlockHeaders'';    **const blockSub =
    getWeb3().eth.subscribe(HEADERS)**      **.on(''data'', ({ number }) => {**        **if
    (number) this.setState({ blockNumber: number});**      **});**    this.setState({
    blockSub });    // 订阅新的转账并加载之前的转账    // ...  }Listing 4-25'
- en: Updated section of componentDidMount to set the initial block number in the
    component’s state, and add a subscription to update it as new blocks are received
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 更新 componentDidMount 部分以在组件状态中设置初始区块编号，并添加订阅以在接收到新区块时更新它
- en: Now we can limit our component to just render the transfer events that happened
    at least a number of blocks ago (Listing [4-26](#PC45)). By checking the block
    number in which the transaction occurred against current block number, we can
    easily implement this filter.  render() {    const { transfers, blockNumber }
    = this.state;    **const confirmed = transfers.filter((transfer) => (**      **blockNumber
    - transfer.blockNumber > 12**    **));**    // Render only confirmed transfers    //
    ...  }Listing 4-26
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将我们的组件限制为只渲染发生在一定数量区块之前的转账事件（见[4-26](#PC45)）。通过检查交易发生的区块编号与当前区块编号，我们可以很容易地实现此过滤器。  render()
    {    const { transfers, blockNumber } = this.state;    **const confirmed = transfers.filter((transfer)
    => (**      **blockNumber - transfer.blockNumber > 12**    **));**    // 仅渲染已确认的转账    //
    ...  }Listing 4-26
- en: Updated render method to show only transfers with at least 12 confirmations
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 更新 render 方法以仅显示至少有 12 个确认的转账
- en: Note
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Different applications will have different requirements for the number of confirmations,
    some of them going up to hundreds of blocks. This will depend strictly on your
    use case.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的应用程序对于确认数会有不同的要求，有些甚至需要数百个区块。这将严格依赖于你的用例。
- en: Summary
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概要
- en: In this chapter, we have gone in-depth into how to extract data from the Ethereum
    network and feed it into our app. We started out by reviewing how connections
    to nodes work, listing the protocols available for the JSON-RPC interface, and
    looking into the Provider object used by web3 and other libraries to manage the
    underlying connection. We also learned that there are different types of nodes
    available and how a Provider, such as the one injected by web3-enabled browsers,
    may abstract away some of these differences via the usage of subproviders.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了如何从以太坊网络中提取数据并将其馈送到我们的应用程序中。我们首先回顾了与节点的连接方式，列出了 JSON-RPC 接口可用的协议，并研究了由
    web3 和其他库用于管理底层连接的 Provider 对象。我们还了解到有不同类型的节点可用，以及 Provider（例如由 web3 启用的浏览器注入的
    Provider）如何通过使用子提供者来抽象出其中一些差异。
- en: 'Using web3.js as a sample library, we studied what kind of queries we could
    issue to the blockchain: general network information, address-specific data such
    as balance and code, and calls to existing contracts. When connecting to an archive
    node, these queries can be issued to any block in the past, not just the most
    recent ones.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 web3.js 作为示例库，我们研究了向区块链发出的查询类型：一般网络信息，地址特定的数据如余额和代码，以及对现有合约的调用。连接到存档节点时，这些查询可以发出到过去的任何一个区块，而不仅仅是最近的几个。
- en: We also studied different ways for monitoring changes to contracts in real time
    in our applications. While polling is a classic method that is always available,
    event filters or subscriptions may be more interesting options due to better performance
    or faster notification times.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还研究了在我们的应用程序中实时监视合约变化的不同方法。虽然轮询是一种始终可用的经典方法，但由于性能更好或通知时间更快，事件过滤器或订阅可能是更有趣的选择。
- en: To wrap up the chapter, we built an application for retrieving information from
    an ERC20 token contract, and monitor all its transfer events using subscriptions.
    In the next chapter, we will learn how to make changes to the blockchain, going
    into all the details involved in sending a new transaction to the network.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结本章，我们构建了一个应用程序，用于从 ERC20 代币合约中检索信息，并使用订阅监视其所有转账事件。在下一章中，我们将学习如何对区块链进行更改，详细介绍向网络发送新交易涉及的所有细节。
