- en: © The Editor(s) (if applicable) and The Author(s), under exclusive license to
    Springer Nature Switzerland AG 2020K. S. MohamedNew Frontiers in Cryptography[https://doi.org/10.1007/978-3-030-58996-7_3](https://doi.org/10.1007/978-3-030-58996-7_3)
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: © 版权编辑（如适用）和作者，独家许可给 Springer Nature Switzerland AG 2020K. S. Mohamed
- en: '3. Cryptography Concepts: Integrity, Authentication, Availability, Access Control,
    and Non-repudiation'
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 密码学概念：完整性、认证、可用性、访问控制和不可否认
- en: Khaled Salah Mohamed^([1](#Aff2) )(1)A Siemens Business, Fremont, CA, USAKeywordsHashAuthenticationNon-repudiationMACAccess
    controlDigital signatureHDCPIntrusion detectionHMACImmune
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Khaled Salah Mohamed^([1](#Aff2))(1) 美国加利福尼亚州弗里蒙特市西门子业务关键词哈希认证不可否认MAC访问控制数字签名HDCP入侵检测HMAC免疫
- en: '3.1 Integrity: Hashing Concept'
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1 完整性：哈希概念
- en: To validate the integrity of the data transmitted over the channel, message
    authentication code (MAC) is used for checking the messages and the authentication,
    ensuring that the integrity of the information has not been modified under the
    transmission.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证在通道上传输的数据的完整性，使用消息认证码（MAC）来检查消息和认证，确保信息的完整性在传输过程中没有被修改。
- en: 'Hash functions are mathematical functions which map values in the domain values
    in the range. Hash functions are special mathematical functions that satisfy the
    following three properties:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希函数是将域中的值映射到范围值的数学函数。哈希函数是满足以下三个属性的特殊数学函数：
- en: Inputs can be any size.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入可以是任意大小的。
- en: Outputs are fixed.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出是固定的。
- en: Efficiently computable, i.e., the mapping should be efficiently computable.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高效可计算，即映射应该是高效可计算的。
- en: The purpose of a hash function is to produce a “fingerprint” of a message or
    data for authentication. A hash function *H*(*m*) maps an input message *m* to
    a hash value *h* as described by eq. ([3.1](#Equ1)). Message *m* is of any arbitrary
    length. Hash *h* is fixed length. Often, *h* is called as the *message digest*
    of *m*. Figure [3.1](#Fig1) shows the abstract level of hashing functionalities:![$$
    h=H(m) $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equ1.png)(3.1)![../images/501530_1_En_3_Chapter/501530_1_En_3_Fig1_HTML.png](../images/501530_1_En_3_Chapter/501530_1_En_3_Fig1_HTML.png)
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希函数的目的是为了产生消息或数据的“指纹”以进行认证。哈希函数 *H*(*m*) 将输入消息 *m* 映射到哈希值 *h*，如方程 ([3.1](#Equ1))
    所描述的那样。消息 *m* 的长度是任意的。哈希 *h* 是固定长度的。通常，*h* 被称为 *m* 的 *消息摘要*。图 [3.1](#Fig1) 展示了哈希功能的抽象层次！[$$
    h=H(m) $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equ1.png)(3.1)![../images/501530_1_En_3_Chapter/501530_1_En_3_Fig1_HTML.png](../images/501530_1_En_3_Chapter/501530_1_En_3_Fig1_HTML.png)
- en: Fig. 3.1
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1
- en: Hashing
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希
- en: Cryptographic hash functions are one-way function as finding hash *h* from *m*
    is easy, but not vice-versa. Given a message, it is hard to find another message
    that has the same hash value. Given a hash function, it is hard to find two messages
    with the same hash value. In cryptography, the avalanche effect is a term associated
    with a specific behavior of mathematical functions used for encryption.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 密码散列函数是单向函数，因为从*m*找到哈希*h*易，但反之则不易。给定一条消息，很难找到另一条具有相同哈希值的消息。给定一个哈希函数，很难找到具有相同哈希值的两条消息。在密码学中，雪崩效应是与用于加密的数学函数的特定行为相关的术语。
- en: 3.1.1 SHA-3
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.1 SHA-3
- en: SHA was designed by NIST and NSA in 1993, revised 1995 as **SHA-1**. The algorithm
    produces 160 bit hash values. Now, it is the most preferred hash algorithm. **SHA-2**
    uses the Davies–Meyer structure, an instance of the Merkle–Damgård structure,
    with a block cipher (sometimes called SHACAL-2) built out of an ARX network, like
    MD4\. **SHA-3** (Secure Hash Algorithm 3) is the latest member of the Secure Hash
    Algorithm family of standards. SHA-3 uses the sponge construction in which is
    “absorbed” into the sponge, and then the result is “squeezed” out. In the absorbing
    phase, message blocks are XORed into a subset of the state, which is then transformed
    as a whole using a permutation function. In the “squeeze” phase, output blocks
    are read from the same subset of the state, alternated with the state transformation
    function. The size of the part of the state that is written and read is called
    the rate, and the size of the part that is untouched by input/output is called
    the capacity. The capacity determines the security of the scheme. The maximum
    security level is half the capacity. To ensure the message can be evenly divided
    into r-bit blocks, padding is required. Changing a single bit causes each bit
    in the output to change with 50% probability, demonstrating an **avalanche effect**
    [[1](#CR1), [2](#CR2)]. In a nutshell, SHA2 (and SHA1) are built using the Merkle–Damgård
    structure. SHA3 on the other hand is built using a sponge function.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: SHA是由NIST和NSA于1993年设计的，1995年修订为**SHA-1**。该算法生成160位散列值。现在，它是最受欢迎的散列算法。**SHA-2**使用了Davies–Meyer结构，这是Merkle–Damgård结构的一个实例，其中包含一个由ARX网络构建的分组密码（有时称为SHACAL-2），类似于MD4。**SHA-3**（安全哈希算法3）是安全哈希算法标准家族的最新成员。SHA-3使用海绵构造，其中“吸收”到海绵中，然后结果被“挤出”。在吸收阶段，消息块被异或到状态的子集中，然后作为整体使用排列函数进行变换。在“挤压”阶段，输出块从相同的状态子集中读取，与状态变换函数交替。写入和读取的状态部分的大小称为速率，而不受输入/输出影响的部分的大小称为容量。容量决定了方案的安全性。最大安全级别是容量的一半。为了确保消息可以被均匀地分成r位块，需要填充。改变一个位会导致输出中的每个位以50%的概率发生变化，展示了**雪崩效应**[[1](#CR1),
    [2](#CR2)]。简而言之，SHA2（和SHA1）是使用Merkle–Damgård结构构建的。另一方面，SHA3是使用海绵函数构建的。
- en: 3.1.1.1 Merkle–Damgård Construction
  id: totrans-15
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.1.1.1 Merkle–Damgård构造
- en: In cryptography, the Merkle–Damgård construction or Merkle–Damgård hash function
    is a method of building collision-resistant cryptographic hash functions from
    collision-resistant one-way compression functions. This construction was used
    in the design of many popular hash algorithms such as MD5, SHA1, and SHA2\. The
    Merkle–Damgård hash function first applies an MD-compliant padding function to
    create an input whose size is a multiple of a fixed number (e.g., 512 or 1024) –
    this is because compression functions cannot handle inputs of arbitrary size.
    The hash function then breaks the result into blocks of fixed size and processes
    them one at a time with the compression function, each time combining a block
    of the input with the output of the previous round. In order to make the construction
    secure, Merkle and Damgård proposed that messages be padded with a padding that
    encodes the length of the original message [[3](#CR3)–[5](#CR5)].
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在密码学中，默克尔-达姆高德构造或默克尔-达姆高德哈希函数是一种从抗碰撞的单向压缩函数构建抗碰撞密码哈希函数的方法。 此构造在设计许多流行的哈希算法（如MD5，SHA1和SHA2）时使用。
    默克尔-达姆高德哈希函数首先应用MD兼容的填充函数来创建大小是固定数字的输入（例如512或1024）的输入 - 这是因为压缩函数无法处理任意大小的输入。 然后，哈希函数将结果分成固定大小的块，并使用压缩函数逐个处理它们，每次将一个输入块与前一轮的输出结合起来。
    为了使构造安全，默克尔和达姆高德建议使用填充对消息进行填充，该填充编码了原始消息的长度[[3](#CR3)–[5](#CR5)]。
- en: 3.1.1.2 Sponge Function
  id: totrans-17
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.1.1.2 海绵函数
- en: 'In cryptography, a sponge function or sponge construction is any of a class
    of algorithms with finite internal state that take an input bit stream of any
    length and produce an output bit stream of any desired length. Sponge functions
    have both theoretical and practical uses. They can be used to model or implement
    many cryptographic primitives, including cryptographic hashes, message authentication
    codes, mask generation functions, stream ciphers, pseudorandom number generators,
    and authenticated encryption. A sponge function is built from three components:
    a state memory, a function that transforms the state memory, and a padding function.
    The state memory is divided into two sections: the bitrate and the capacity. The
    padding function appends enough bits to the input string so that the length of
    the padded input is a whole multiple of the bitrate [[6](#CR6)].'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在密码学中，海绵函数或海绵构造是一类具有有限内部状态的算法，它们接受任意长度的输入比特流，并生成任意所需长度的输出比特流。 海绵函数具有理论和实际用途。
    它们可用于模拟或实现许多密码原语，包括密码哈希函数，消息认证码，掩码生成函数，流密码，伪随机数生成器和认证加密。 海绵函数由三个组件构建：状态存储器，用于转换状态存储器的函数和填充函数。
    状态存储器分为两个部分：比特率和容量。 填充函数附加足够的位到输入字符串，使得填充输入的长度为比特率的整数倍[[6](#CR6)]。
- en: 'The sponge function operates as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 海绵函数的运作如下：
- en: The state *S* is initialized to zero.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态* S *被初始化为零。
- en: The input string is padded.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入字符串被填充。
- en: 'For each *r*-bit block *B* of the padded input:'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个* r *比特块* B *的填充输入：
- en: '*R* is replaced with *R* XOR *B*'
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*R*被*R* XOR *B*替换'
- en: '*S* is replaced by *f*(*S*)'
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*S*被*f*(*S*)替换。'
- en: The *R* portion of the state memory is output.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态存储器的*R*部分被输出。
- en: 'repeat until enough bits are output:'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重复直到输出足够的比特为止：
- en: '*S* is replaced by *f*(*S*)'
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*S*被*f*(*S*)替换。'
- en: The *R* portion of the state memory is output
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态存储器的*R*部分被输出
- en: If less than *r* bits remain to be output, then *R* will be truncated.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果剩余的比特少于*r*位，则*R*将被截断。
- en: 3.1.2 HMAC-SHA256 (Hashed Message Authentication Code, Secure Hash Algorithm)
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.2 HMAC-SHA256（散列消息认证码，安全散列算法）
- en: 3.1.2.1 Nomenclature
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.1.2.1 术语
- en: B
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: B
- en: Block size (in bytes) of the input to the approved hash function.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 输入到批准的哈希函数的块大小（以字节为单位）。
- en: '*H*'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*H*'
- en: SHA-256 hash function.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: SHA-256哈希函数。
- en: ipad
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: ipad
- en: Inner pad; the byte x′36′ repeated B times.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 内部填充；字节x′36′重复了B次。
- en: '*K*'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*K*'
- en: Secret key shared between the host and the device.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 主机和设备之间共享的秘密密钥。
- en: '*K*[0]'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*K*[0]'
- en: The key *K* after any necessary pre-processing to form a *B*-byte key.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 经过任何必要的预处理以形成*B*字节密钥的密钥*K*。
- en: '*L*'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*L*'
- en: Block size (in bytes) of the output of the approved hash function.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 批准的哈希函数的输出的块大小（以字节为单位）。
- en: opad
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: opad
- en: Outer pad; the byte x′5c′ repeated B times.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 外部填充；字节x′5c′重复了B次。
- en: '*t*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*t*'
- en: The number of bytes of MAC.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: MAC的字节数。
- en: text
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 文本
- en: The message on which the HMAC is calculated; text does not include the padded
    key.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: HMAC计算的消息；文本不包括填充密钥。
- en: x′N′
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: x′N′
- en: Hexadecimal notation, where each symbol in the string “N” represents four binary
    bits.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 十六进制表示法，其中字符串“N”中的每个符号代表四个二进制位。
- en: '||'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '||'
- en: Concatenation.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 连接。
- en: xor
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: xor
- en: Exclusive-OR operation.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 异或操作。
- en: a, b, c
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: a、b、c
- en: Working variables that are the w-bit words used in the computation of the hash
    values, *H*^(*(i)*).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算哈希值*H*^(*i*)时使用的w位字的工作变量。
- en: '*H*^((*i*))'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*H*^((*i*))'
- en: The *i*th hash value. *H*^(*(0)*) is the initial hash value; *H*^(*(N)*) is
    the final hash value and is used to determine the message digest.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 第*i*个哈希值。*H*^(*0*)是初始哈希值；*H*^(*N*)是最终哈希值，并用于确定消息摘要。
- en: '*H*[*j*]^((*i*))'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*H*[*j*]^((*i*))'
- en: The *j*th word of the *i*th hash value, where *H*[*0*]^(*(i)*) is the left-most
    word of hash value *i*.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 第*i*个哈希值的第*j*个字，其中*H*[*0*]^(*i*)是哈希值*i*的最左边的字。
- en: '*K*[*t*]'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*K*[*t*]'
- en: Constant value to be used for iteration *t* of the hash computation.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 用于哈希计算的迭代*t*的常量值。
- en: '*k*'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*k*'
- en: Number of zeroes appended to a message during the padding step.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在填充步骤期间附加到消息中的零的数量。
- en: '*l*'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*l*'
- en: Length of the message, *M*, in bits.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 消息*M*的长度（以比特为单位）。
- en: '*m*'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*m*'
- en: Number of bits in a message block, *M*^((*i*)).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 消息块*M*^((*i*)）中的比特数。
- en: '*M*'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*M*'
- en: Message to be hashed.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行哈希处理的消息。
- en: '*M*^(*(i)*)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*M*^(*i*)'
- en: Message block *i*, with a size of *m* bits.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 大小为*m*比特的消息块*i*。
- en: '*M*[*j*]^(*(i)*)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*M*[*j*]^(*i*)'
- en: The *j*th word of the *i*th message block, where *M*[*0*]^(*(i)*) is the left-most
    word of message block *i*
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 第*i*个消息块的第*j*个字，其中*M*[*0*]^(*i*)是消息块*i*的最左边的字。
- en: '*n*'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*n*'
- en: Number of bits to be rotated or shifted when a word is operated upon.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当对单词进行操作时要旋转或移位的比特数。
- en: '*N*'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*N*'
- en: Number of blocks in the padded message.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 填充消息中的块数。
- en: '*T*'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*T*'
- en: Temporary *w*-bit word used in the hash computation.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在哈希计算中使用的临时 *w-* 位单词。
- en: '*w*'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*w*'
- en: Number of bits in a word.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 单词中的比特数。
- en: '*W*[*t*]'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*W*[*t*]'
- en: The *t*th *w-*bit word of the message schedule.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 消息调度的第 *t* 个 *w-* 位单词。
- en: ^
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: ^
- en: Bitwise AND operation.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 按位与运算。
- en: '*Or*'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*或*'
- en: Bitwise OR (“inclusive-OR”) operation.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 按位或（“包容性或”）运算。
- en: '*Xor*'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*异或*'
- en: Bitwise XOR (“Exclusive-OR”) operation.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 按位异或（“排他或”）运算。
- en: '!'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '!'
- en: Bitwise complement operation.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 按位补码运算。
- en: +
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: +
- en: Addition modulo 2^(*w*).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 模 2^(*w*) 的加法。
- en: ≪
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ≪
- en: Left-shift operation, where *x* ≪ *n* is obtained by discarding the left-most
    *n* bits of the word *x* and then padding the result with *n* zeroes on the right.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 左移位运算，其中 *x* ≪ *n* 是通过丢弃字 *x* 的左端 *n* 位，然后在右侧用 *n* 个零进行填充来获得的。
- en: ≫
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: ≫
- en: Right-shift operation, where *x* ≫ *n* is obtained by discarding the rightmost
    *n* bits of the word *x* and then padding the result with *n* zeroes on the left.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 右移位运算，其中 *x* ≫ *n* 是通过丢弃字 *x* 的右端 *n* 位，然后在左侧用 *n* 个零进行填充来获得的。
- en: 3.1.2.2 Introduction
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.1.2.2 介绍
- en: HMAC_SHA is a secure cryptographic hash function-based message and shared key
    authentication protocols. It can effectively prevent data being intercepted and
    tampered with during transmissions.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: HMAC_SHA 是基于安全的密码哈希函数的消息和共享密钥认证协议。它可以有效防止在传输过程中数据被拦截和篡改。
- en: The message authentication code (MAC)  is calculated using HMAC SHA-256 as defined
    in [[7](#CR7)–[9](#CR9)]. The HMAC SHA-256 calculation takes as input a key and
    a message. The resulting MAC is 256 bits (32 bytes), which are embedded in the
    data frame as part of the request or response. The key used for the MAC calculation
    is 256 bit authentication key. The receiver computes the MAC on the received data
    using the same key and HMAC function as was used by the transmitter and compares
    the result computed with the received MAC. If the two values match, then the data
    has been correctly received.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 消息认证码（MAC）是使用 HMAC SHA-256 计算的，如 [[7](#CR7)–[9](#CR9)] 所定义。HMAC SHA-256 计算以密钥和消息作为输入。生成的
    MAC 是 256 位（32 字节），作为请求或响应的一部分嵌入到数据帧中。用于 MAC 计算的密钥是 256 位认证密钥。接收器使用与发射器相同的密钥和
    HMAC 函数对接收到的数据进行 MAC 计算，并将计算结果与接收到的 MAC 进行比较。如果两个值匹配，则数据已被正确接收。
- en: The HMAC-SHA-256 is the implementation of the HMAC message authentication code
    calculation using the SHA-256 hash function. The hash function can be iterative
    and breaks up the message into blocks of a fixed size and iterates over them.
    For SHA-256, the message size is less than 2^(64). Each message block has 512
    bits. The message is padded so that it can be parsed into N x 512 blocks. The
    output of HMAC calculation is the same as the underlying hash function which in
    our case is 256 bits (32 bytes) wide. In this paper, we present a low latency
    hardware implementation of HMAC-SHA-256(Hashed Message Authentication Code, Secure
    Hash Algorithm) algorithm for Internet of Things (Io) applications. Figure [3.2](#Fig2)
    and Table [3.1](#Tab1) illustrates the step-by-step process in the HMAC algorithm.
    SHA-256 is SHA-2 with 256-bit output.![../images/501530_1_En_3_Chapter/501530_1_En_3_Fig2_HTML.png](../images/501530_1_En_3_Chapter/501530_1_En_3_Fig2_HTML.png)
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: HMAC-SHA-256 是使用 SHA-256 哈希函数计算 HMAC 消息认证码的实现。哈希函数可以是迭代的，并将消息分解为固定大小的块，并对它们进行迭代处理。对于
    SHA-256，消息大小小于 2^(64)。每个消息块有 512 位。消息被填充，以便可以将其解析为 N x 512 块。HMAC 计算的输出与底层哈希函数相同，在我们的情况下为
    256 位（32 字节）宽。在本文中，我们提出了用于物联网（Io）应用的 HMAC-SHA-256（散列消息认证码，安全哈希算法）算法的低延迟硬件实现。图
    [3.2](#Fig2) 和表格 [3.1](#Tab1) 描述了 HMAC 算法的逐步过程。SHA-256 是带有 256 位输出的 SHA-2。![../images/501530_1_En_3_Chapter/501530_1_En_3_Fig2_HTML.png](../images/501530_1_En_3_Chapter/501530_1_En_3_Fig2_HTML.png)
- en: Fig. 3.2
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2
- en: Illustration of the HMAC construction
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: HMAC 构造的图解
- en: Table 3.1
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 表格 3.1
- en: General HMAC algorithm
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 通用 HMAC 算法
- en: '| Steps | Step-by-step description |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| 步骤 | 逐步描述 |'
- en: '| --- | --- |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| *Step 1* | *K* = 32 bytes, B = 64 bytes, *K* ≠ *B* |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| *步骤 1* | *K* = 32 字节，B = 64 字节，*K* ≠ *B* |'
- en: '| *Step 2* | *K* < *B*: append zeros to the end of *K* to create a *B*-byte
    string *K*[0] (*K* will be appended with 32 zero bytes 0x00) |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| *步骤 2* | *K* < *B*：在 *K* 的末尾追加零，以创建一个 *B* 字节的字符串 *K*[0]（*K* 将被追加 32 个零字节
    0x00） |'
- en: '| *Step 3* | Exclusive-OR *K*0 with *ipad* to produce a *B*-byte string: ***K***[**0**]
    xor ***ipad*** |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| *步骤 3* | 用 *ipad* 对 *K*0 进行异或运算以生成一个 *B* 字节的字符串：***K***[**0**] xor ***ipad***
    |'
- en: '| *Step 4* | Append the stream of data *text* to the string resulting from
    step 4: **(*****K***[**0**] xor ***ipad*****) &#124;&#124;** ***text*** |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| *步骤 4* | 将数据流 *text* 追加到步骤 4 的结果字符串：**(*****K***[**0**] xor ***ipad*****)
    &#124;&#124;** ***text*** |'
- en: '| *Step 5* | Apply *H* to the stream generated in step 5: **H((*****K***[**0**]
    xor ***ipad*****) &#124;&#124;** ***text*****)** |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| *步骤 5* | 将步骤 5 生成的流应用于 *H*：**H((*****K***[**0**] xor ***ipad*****) &#124;&#124;**
    ***text*****)** |'
- en: '| *Step 6* | Exclusive-OR *K*[*0*] with *opad*: ***K***[**0**] xor ***opad***
    |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| *步骤 6* | 用 *opad* 对 *K*[*0*] 进行异或运算：***K***[**0**] xor ***opad*** |'
- en: '| *Step 7* | Append the result from step 5 to step 6: **(*****K***[**0**] xor
    ***opad*****) &#124;&#124; H((*****K***[**0**] xor ***ipad*****) &#124;&#124;**
    ***text*****)** |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| *步骤 7* | 将步骤 5 的结果追加到步骤 6：**(*****K***[**0**] xor ***opad*****) &#124;&#124;
    H((*****K***[**0**] xor ***ipad*****) &#124;&#124;** ***text*****)** |'
- en: '| *Step 8* | Apply *H* to the result from step 7: ***H*****((*****K***[**0**]
    xor ***opad*****) &#124;&#124;** ***H*****((*****K***[**0**] xor ***ipad*****)
    &#124;&#124;** ***text*****))** |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| *步骤8* | 对步骤7的结果应用*H*：***H*****((*****K***[**0**] xor ***opad*****) &#124;&#124;**
    ***H*****((*****K***[**0**] xor ***ipad*****) &#124;&#124;** ***text*****))**
    |'
- en: '| *Step 9* | Select the leftmost *t* bytes of the result of step 8 as the MAC
    |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| *步骤9* | 将步骤8的结果的最左边的*t*字节选择为MAC |'
- en: 3.1.2.3 HMAC Algorithm
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.1.2.3 HMAC算法
- en: As specified in [[7](#CR7)], the size of a message block for Secure Hash Algorithm
    SHA-256 is 512 bits (i.e., *B* = 64 bytes). To compute a MAC over the data “text”
    using the HMAC function, the following operation is performed:![$$ {\displaystyle
    \begin{array}{c}\mathrm{MAC}\left(\mathrm{text}\right)t=\mathrm{HMAC}\left(K,\kern0.5em
    \mathrm{text}\right)t\\ {}=H\left(\left(K0\kern0.5em \mathrm{xor}\kern0.5em \mathrm{opad}\right)\parallel
    H\left(\left(K0\kern0.5em \mathrm{xor}\kern0.5em \mathrm{ipad}\right)\parallel
    \mathrm{text}\right)\right)t\end{array}} $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equ2.png)(3.2)
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如[[7](#CR7)]所指定的，安全哈希算法SHA-256的消息块大小为512位（即，*B* = 64字节）。 使用HMAC函数计算数据“text”的MAC时，执行以下操作：![$$
    {\displaystyle \begin{array}{c}\mathrm{MAC}\left(\mathrm{text}\right)t=\mathrm{HMAC}\left(K,\kern0.5em
    \mathrm{text}\right)t\\ {}=H\left(\left(K0\kern0.5em \mathrm{xor}\kern0.5em \mathrm{opad}\right)\parallel
    H\left(\left(K0\kern0.5em \mathrm{xor}\kern0.5em \mathrm{ipad}\right)\parallel
    \mathrm{text}\right)\right)t\end{array}} $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equ2.png)(3.2)
- en: 3.1.2.4 SHA-256 Algorithm
  id: totrans-121
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.1.2.4 SHA-256算法
- en: '1.'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '1.'
- en: 'Pad the message, *M*:'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 填充消息*M*：
- en: The message, *M*, shall be padded before hash computation begins. The purpose
    of this padding is to ensure that the padded message is a multiple of 512 or 1024
    bits, depending on the algorithm. Suppose that the length of the message, *M*,
    is l bits. Append the bit “1” to the end of the message, followed by k zero bits,
    where k is the smallest, nonnegative solution to the equation l + 1 + k = 448mod
    512\. Then append the 64 bit block that is equal to the number l expressed using
    a binary representation. For example, the (8 bit ASCII) message “abc” has length
    8 × 3 = 24, so the message is padded with a one bit, then 448 − (24 + 1) = 423
    zero bits, and then the message length, to become the 512-bit padded message as
    shown in Fig. [3.3](#Fig3).![../images/501530_1_En_3_Chapter/501530_1_En_3_Fig3_HTML.png](../images/501530_1_En_3_Chapter/501530_1_En_3_Fig3_HTML.png)
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在哈希计算开始之前，消息*M*将被填充。 这种填充的目的是确保填充后的消息是512位或1024位的倍数，具体取决于算法。 假设消息*M*的长度为l位。
    在消息末尾附加位“1”，然后附加k个零位，其中k是满足等式l + 1 + k = 448mod 512的最小非负解。 然后附加一个64位块，该块等于用二进制表示的数字l。
    例如，（8位ASCII）消息“abc”的长度为8 × 3 = 24，因此消息用一个位“1”填充，然后是448 − (24 + 1) = 423个零位，然后是消息长度，形成如图[3.3](#Fig3)所示的512位填充消息。![../images/501530_1_En_3_Chapter/501530_1_En_3_Fig3_HTML.png](../images/501530_1_En_3_Chapter/501530_1_En_3_Fig3_HTML.png)
- en: Fig. 3.3
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3
- en: SHA-256 message example
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: SHA-256消息示例
- en: '2.'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '2.'
- en: Parse the padded message into N 512-bit message blocks, *M*^((1)), *M*^((2)),
    …, *M*^((*N*)).
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将填充消息解析为N个512位消息块，*M*^((1)), *M*^((2)), …, *M*^((*N*)).
- en: '3.'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '3.'
- en: 'Set the initial hash value, *H*^((0)):'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 设置初始哈希值，*H*^((0))：
- en: Before hash computation begins for each of the secure hash algorithms, the initial
    hash value, *H*^((0)), must be set. The size and number of words in *H*^((0))
    depends on the message digest size.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在为每个安全哈希算法计算哈希之前，必须设置初始哈希值，*H*^((0))。*H*^((0)) 中的字数和数量取决于消息摘要大小。
- en: For SHA-256, the initial hash value, *H*^((0)), shall consist of the following
    eight 32 bit words, in hex:![$$ {H_0}^{(0)}=\kern0.62em 6\mathrm{a}09\mathrm{e}667
    $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equa.png)![$$ {H_1}^{(0)}=\kern0.62em
    \mathrm{bb}67\mathrm{ae}85 $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equb.png)![$$
    {H_2}^{(0)}=\kern0.62em 3\mathrm{c}6\mathrm{ef}372 $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equc.png)![$$
    {H_3}^{(0)}=\kern0.62em \mathrm{a}54\mathrm{ff}53\mathrm{a} $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equd.png)![$$
    {H_4}^{(0)}=\kern0.62em 510\mathrm{e}527\mathrm{f} $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Eque.png)![$$
    {H_5}^{(0)}=\kern0.62em 9\mathrm{b}05688\mathrm{c} $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equf.png)![$$
    {H_6}^{(0)}=\kern0.62em 1\mathrm{f}83\mathrm{d}9\mathrm{ab} $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equg.png)![$$
    {H_7}^{(0)}=\kern0.62em 5\mathrm{be}0\mathrm{cd}19 $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equh.png)
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 SHA-256，初始哈希值 *H*^((0)) 应由以下八个 32 位字组成，以十六进制表示：![公式图片](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equa.png)![公式图片](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equb.png)![公式图片](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equc.png)![公式图片](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equd.png)![公式图片](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Eque.png)![公式图片](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equf.png)![公式图片](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equg.png)![公式图片](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equh.png)
- en: '4.'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '4.'
- en: 'After preprocessing is completed, each message block, *M*^((1)), *M*^((2)),
    …, *M*^((*N*)), is processed in order, using the following steps:'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预处理完成后，按顺序处理每个消息块，*M*^((1))、*M*^((2))、…、*M*^((*N*))，使用以下步骤：
- en: 'For *i* = 1 to *N*:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 *i* = 1 到 *N*：
- en: '{'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '1.'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '1.'
- en: Prepare the message schedule, {*W*[*t*]}
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 准备消息调度，{*W*[*t*]}
- en: '![$$ {W}_t=\left\{\begin{array}{ll}{M}_t^{(t)}&amp; 0\le t\le 15\\ {}{\sigma}_1^{\left\{256\right\}}\left({W}_{t-2}\right)+{W}_{t-7}+{\sigma}_0^{\left\{256\right\}}\left({W}_{t-15}\right)+{W}_{t-16}&amp;
    16\le t\le 63\end{array}\right. $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equi.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![公式图片](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equi.png)'
- en: '2.'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '2.'
- en: 'Initialize the eight working variables, *a, b, c, d, e, f, g,* and *h*, with
    the (*i* − 1)st hash value:'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 初始化八个工作变量，*a, b, c, d, e, f, g,* 和 *h*，使用（*i* − 1）的哈希值：
- en: '![$$ a={H}_0^{\left(i-1\right)} $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equj.png)![$$
    b={H}_1^{\left(i-1\right)} $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equk.png)![$$
    c={H}_2^{\left(i-1\right)} $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equl.png)![$$
    d={H}_3^{\left(i-1\right)} $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equm.png)![$$
    e={H}_4^{\left(i-1\right)} $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equn.png)![$$
    f={H}_5^{\left(i-1\right)} $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equo.png)![$$
    g={H}_6^{\left(i-1\right)} $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equp.png)![$$
    h={H}_7^{\left(i-1\right)} $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equq.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![$$ a={H}_0^{\left(i-1\right)} $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equj.png)![$$
    b={H}_1^{\left(i-1\right)} $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equk.png)![$$
    c={H}_2^{\left(i-1\right)} $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equl.png)![$$
    d={H}_3^{\left(i-1\right)} $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equm.png)![$$
    e={H}_4^{\left(i-1\right)} $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equn.png)![$$
    f={H}_5^{\left(i-1\right)} $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equo.png)![$$
    g={H}_6^{\left(i-1\right)} $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equp.png)![$$
    h={H}_7^{\left(i-1\right)} $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equq.png)'
- en: '3.'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '3.'
- en: For *t* = 0 to 63
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于 *t* = 0 到 63
- en: '{'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: '![$$ {T}_1=h+\sum \limits_1^{\left\{256\right\}}(e)+ Ch\left(e,f,g\right)+{K}_t^{\left\{256\right\}}+{W}_t
    $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equr.png)![$$ {T}_2=\sum
    \limits_0^{\left\{256\right\}}(a)+ Maj\left(a,b,c\right) $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equs.png)![$$
    h=g $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equt.png)![$$
    g=f $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equu.png)![$$
    f=e $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equv.png)![$$
    e=d+{T}_1 $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equw.png)![$$
    d=c $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equx.png)![$$
    c=b $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equy.png)![$$
    b=a $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equz.png)![$$
    a={T}_1+{T}_2 $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equaa.png)}'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '![$$ {T}_1=h+\sum \limits_1^{\left\{256\right\}}(e)+ Ch\left(e,f,g\right)+{K}_t^{\left\{256\right\}}+{W}_t
    $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equr.png)![$$ {T}_2=\sum
    \limits_0^{\left\{256\right\}}(a)+ Maj\left(a,b,c\right) $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equs.png)![$$
    h=g $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equt.png)![$$
    g=f $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equu.png)![$$
    f=e $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equv.png)![$$
    e=d+{T}_1 $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equw.png)![$$
    d=c $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equx.png)![$$
    c=b $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equy.png)![$$
    b=a $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equz.png)![$$
    a={T}_1+{T}_2 $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equaa.png)}'
- en: '4.'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '4.'
- en: 'Compute the *i*th intermediate hash value *H*^((*i*)):'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '计算第 *i* 个中间哈希值 *H*^((*i*)):'
- en: '![$$ {H}_0^{(i)}=a+{H}_0^{\left(i-1\right)} $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equab.png)![$$
    {H}_1^{(i)}=b+{H}_1^{\left(i-1\right)} $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equac.png)![$$
    {H}_2^{(i)}=c+{H}_2^{\left(i-1\right)} $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equad.png)![$$
    {H}_3^{(i)}=d+{H}_3^{\left(i-1\right)} $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equae.png)![$$
    {H}_4^{(i)}=e+{H}_4^{\left(i-1\right)} $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equaf.png)![$$
    {H}_5^{(i)}=f+{H}_5^{\left(i-1\right)} $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equag.png)![$$
    {H}_6^{(i)}=g+{H}_6^{\left(i-1\right)} $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equah.png)![$$
    {H}_7^{(i)}=h+{H}_7^{\left(i-1\right)} $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equai.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![$$ {H}_0^{(i)}=a+{H}_0^{\left(i-1\right)} $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equab.png)![$$
    {H}_1^{(i)}=b+{H}_1^{\left(i-1\right)} $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equac.png)![$$
    {H}_2^{(i)}=c+{H}_2^{\left(i-1\right)} $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equad.png)![$$
    {H}_3^{(i)}=d+{H}_3^{\left(i-1\right)} $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equae.png)![$$
    {H}_4^{(i)}=e+{H}_4^{\left(i-1\right)} $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equaf.png)![$$
    {H}_5^{(i)}=f+{H}_5^{\left(i-1\right)} $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equag.png)![$$
    {H}_6^{(i)}=g+{H}_6^{\left(i-1\right)} $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equah.png)![$$
    {H}_7^{(i)}=h+{H}_7^{\left(i-1\right)} $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equai.png)'
- en: '}'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: After repeating steps one through four a total of *N* times (i.e., after processing
    *M*^(*(N)*)), the resulting 512 bit message digest of the message, *M*, is
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在重复执行一至四步总共 *N* 次（即处理 *M*^(*(N)*)) 后，消息 *M* 的结果为 512 位消息摘要，
- en: '![$$ {H}_0^{(N)}{H}_1^{(N)}{H}_2^{(N)}{H}_3^{(N)}{H}_4^{(N)}\left|{H}_5^{(N)}{H}_6^{(N)}\left|{H}_7^{(N)}\right.\right..
    $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equaj.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![$$ {H}_0^{(N)}{H}_1^{(N)}{H}_2^{(N)}{H}_3^{(N)}{H}_4^{(N)}\left|{H}_5^{(N)}{H}_6^{(N)}\left|{H}_7^{(N)}\right.\right..
    $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equaj.png)'
- en: 3.1.2.5 HMAC-SHA256 Illustrative Example
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.1.2.5 HMAC-SHA256 举例说明
- en: This example for the HMAC-SHA256 calculation uses one message of 284 bytes and
    a key of 32 bytes.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '此 HMAC-SHA256 计算示例使用 284 字节的消息和 32 字节的密钥。 '
- en: '*Input:*'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '*输入*：'
- en: '***Text***: 284 bytes message'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***文本***：284 字节的消息'
- en: 000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f404142434445464748494a4b4c4d4e4f505152535455565758595a5b5c5d5e5f606162636465666768696a6b6c6d6e6f707172737475767778797a7b7c7d7e7f808182838485868788898a8b8c8d8e8f909192939495969798999a9b9c9d9e9fa0a1a2a3a4a5a6a7a8a9aaabacadaeafb0b1b2b3b4b5b6b7b8b9babbbcbdbebfc0c1c2c3c4c5c6c7c8c9cacbcccdcecfd0d1d2d3d4d5d6d7d8d9dadbdcdddedfe0e1e2e3e4e5e6e7e8e9eaebecedeeeff0f1f2f3f4f5f6f7f8f9fafbfcfdfeff00000000000000000000000000000000000000010000000100000003.
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f404142434445464748494a4b4c4d4e4f505152535455565758595a5b5c5d5e5f606162636465666768696a6b6c6d6e6f707172737475767778797a7b7c7d7e7f808182838485868788898a8b8c8d8e8f909192939495969798999a9b9c9d9e9fa0a1a2a3a4a5a6a7a8a9aaabacadaeafb0b1b2b3b4b5b6b7b8b9babbbcbdbebfc0c1c2c3c4c5c6c7c8c9cacbcccdcecfd0d1d2d3d4d5d6d7d8d9dadbdcdddedfe0e1e2e3e4e5e6e7e8e9eaebecedeeeff0f1f2f3f4f5f6f7f8f9fafbfcfdfeff00000000000000000000000000000000000000010000000100000003.
- en: '***Key***: 32 bytes.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***密钥***：32 字节。'
- en: '0000000000000000000000000000000000000000011010110110010101111001'
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '0000000000000000000000000000000000000000011010110110010101111001'
- en: '*Steps:*'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤：*'
- en: '1.K[0]: append 32 bytes of zeros to the end of the key to create a 64 byte
    message'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1.K[0]：在密钥末尾附加 32 字节的零，以创建一个 64 字节的消息
- en: '00000000000000000000000000000000000000000110101101100101011110010000000000000000000000000000000000000000000000000000000000000000'
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '00000000000000000000000000000000000000000110101101100101011110010000000000000000000000000000000000000000000000000000000000000000'
- en: 2.Create a 64 byte ipad pattern of repeating the hexadecimal value 0x36.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2.创建一个 64 字节的 ipad 模式，重复十六进制值 0x36。
- en: '36363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636'
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '36363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636'
- en: 3.Create a 64 byte opad pattern of repeating the hexadecimal value 0x5c.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3.创建一个 64 字节的 opad 模式，重复十六进制值 0x5c。
- en: 5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c
- en: '4.XOR K[0] with ipad: ***K***[**0**] xor ***ipad***.'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 4.将 K[0] 与 ipad 进行异或运算：***K***[**0**] xor ***ipad***。
- en: '36363636363636363636363636363636363636363726262737263737372726373636363636363636363636363636363636363636363636363636363636363636'
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '36363636363636363636363636363636363636363726262737263737372726373636363636363636363636363636363636363636363636363636363636363636'
- en: '5.Concatenate text at the end: **(*****K***[**0**] xor ***ipad*****) ||** ***text***'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 5.在末尾连接文本：**(*****K***[**0**] xor ***ipad*****) ||** ***text***
- en: 36363636363636363636363636363636363636363726262737263737372726373636363636363636363636363636363636363636363636363636363636363636000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f404142434445464748494a4b4c4d4e4f505152535455565758595a5b5c5d5e5f606162636465666768696a6b6c6d6e6f707172737475767778797a7b7c7d7e7f808182838485868788898a8b8c8d8e8f909192939495969798999a9b9c9d9e9fa0a1a2a3a4a5a6a7a8a9aaabacadaeafb0b1b2b3b4b5b6b7b8b9babbbcbdbebfc0c1c2c3c4c5c6c7c8c9cacbcccdcecfd0d1d2d3d4d5d6d7d8d9dadbdcdddedfe0e1e2e3e4e5e6e7e8e9eaebecedeeeff0f1f2f3f4f5f6f7f8f9fafbfcfdfeff00000000000000000000000000000000000000010000000100000003
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 36363636363636363636363636363636363636363726262737263737372726373636363636363636363636363636363636363636363636363636363636363636000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f404142434445464748494a4b4c4d4e4f505152535455565758595a5b5c5d5e5f606162636465666768696a6b6c6d6e6f707172737475767778797a7b7c7d7e7f808182838485868788898a8b8c8d8e8f909192939495969798999a9b9c9d9e9fa0a1a2a3a4a5a6a7a8a9aaabacadaeafb0b1b2b3b4b5b6b7b8b9babbbcbdbebfc0c1c2c3c4c5c6c7c8c9cacbcccdcecfd0d1d2d3d4d5d6d7d8d9dadbdcdddedfe0e1e2e3e4e5e6e7e8e9eaebecedeeeff0f1f2f3f4f5f6f7f8f9fafbfcfdfeff00000000000000000000000000000000000000010000000100000003
- en: 6.Hash the value above using SHA-256 algorithm.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 6.对上面的值使用 SHA-256 算法进行哈希。
- en: The message is extended as shown above. In this case the data message to be
    hashed is 2784 bits (348 bytes). To achieve a padded message that is a multiple
    of 512 bits, the 2784 bits message is padded with one bit, then 223 zero bits,
    and then 64 bits representing the message length. The message now becomes a 6*512
    bit padded message. This padded message is then processed using the SHA-256 algorithm
    explained above to obtain the hash value.
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上述方式扩展了消息。在这种情况下，待散列的数据消息为 2784 位（348 字节）。为了获得一个长度是 512 位倍数的填充消息，将 2784 位的消息填充为一个比特，然后是
    223 个零比特，然后是表示消息长度的 64 位。消息现在变成了一个 6*512 位的填充消息。然后使用上述的 SHA-256 算法处理该填充消息以获得哈希值。
- en: 663cb567af6aeb40a9948a1621c129b69ffbd41244596df0b2729bac5ac0fbb1
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 663cb567af6aeb40a9948a1621c129b69ffbd41244596df0b2729bac5ac0fbb1
- en: '7.XOR appended key with opad: ***K***[**0**] xor ***opad***'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 7.将附加密钥与 opad 进行异或运算：***K***[**0**] xor ***opad***
- en: 5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5d4c4c4d5d4c5d5d5d4d4c5d5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5d4c4c4d5d4c5d5d5d4d4c5d5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c
- en: '8.Concatenate the result from step 6 and step 7:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 8.连接步骤 6 和步骤 7 的结果：
- en: '**(*****K***[**0**] xor ***opad*****) || H((*****K***[**0**] xor ***ipad*****)
    ||** ***text*****)**'
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**(*****K***[**0**] xor ***opad*****) || H((*****K***[**0**] xor ***ipad*****)
    ||** ***text*****)**'
- en: 5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5d4c4c4d5d4c5d5d5d4d4c5d5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c663cb567af6aeb40a9948a1621c129b69ffbd41244596df0b2729bac5ac0fbb1
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5d4c4c4d5d4c5d5d5d4d4c5d5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c663cb567af6aeb40a9948a1621c129b69ffbd41244596df0b2729bac5ac0fbb1
- en: 9.Hash the output of step 8 using SHA-256
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 9.对步骤 8 的输出进行哈希，使用 SHA-256
- en: The message should be padded before hashing of SHA-256 algorithm. In this case
    the message length is 768 bits (96 bytes). To achieve a padded message that is
    a multiple of 512 bits, the message is padded with one bit and then 191 zero bits
    and then 64 bits representing the message length. The message is now 2*512 bit
    padded message. This padded message is then processed using the SHA-256 algorithm
    explained above to obtain the hash value.a771af5ea520f789c0e6668c4c9cb6f30111d381503917af47af37c53b7adca2.
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在进行 SHA-256 算法的哈希之前，消息应进行填充。在本例中，消息长度为 768 位（96 字节）。为了获得一个多于 512 位的填充消息，消息被填充了一个位，然后是
    191 个零位，然后是表示消息长度的 64 位。消息现在是 2*512 位的填充消息。然后，使用上面解释的 SHA-256 算法处理这个填充的消息，以获得哈希值。a771af5ea520f789c0e6668c4c9cb6f30111d381503917af47af37c53b7adca2。
- en: 3.1.3 MD5 Algorithm
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.3 MD5 算法
- en: 'MED5 algorithm  works as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: MED5 算法的工作原理如下：
- en: Pad message so its length is 448 mod 512.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 填充消息，使其长度为 448 mod 512。
- en: Append a 64 bit length value to message.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将一个 64 位长度值附加到消息上。
- en: Initialize four-word (128 bit) MD buffer (A, B, C, D).
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化四字（128 位）MD 缓冲区（A、B、C、D）。
- en: 'Process message in 16-word (512 bit) blocks: using four rounds of 16 bit operations
    on message block and buffer. Add output to buffer input to form new buffer value.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 16 字（512 位）块中处理消息：在消息块和缓冲区上进行四轮 16 位操作。将输出添加到缓冲区输入以形成新的缓冲区值。
- en: Output hash value is the final buffer value.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出哈希值是最终缓冲区值。
- en: 3.1.4 Blake
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.4 布莱克
- en: BLAKE is a cryptographic hash function based on Dan Bernstein’s ChaCha stream
    cipher, but a permuted copy of the input block, XORed with round constants, is
    added before each ChaCha round. Like SHA-2, there are two variants differing in
    the word size. ChaCha operates on a 4 × 4 array of words. BLAKE repeatedly combines
    an 8-word hash value with 16 message words, truncating the ChaCha result to obtain
    the next hash value. BLAKE-256 and BLAKE-224 use 32 bit words and produce digest
    sizes of 256 bits and 224 bits, respectively, while BLAKE-512 and BLAKE-384 use
    64 bit words and produce digest sizes of 512 bits and 384 bits, respectively.
    The BLAKE2 hash function, based on BLAKE, was announced in 2012\. The BLAKE3 hash
    function, based on BLAKE2, was announced in 2020\. BLAKE2 is a cryptographic hash
    function **faster than MD5, SHA-1, SHA-2, and SHA-3** (Fig. [3.4](#Fig4)), yet
    is at least as secure as the latest standard SHA-3 [[11](#CR11)].![../images/501530_1_En_3_Chapter/501530_1_En_3_Fig4_HTML.png](../images/501530_1_En_3_Chapter/501530_1_En_3_Fig4_HTML.png)
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: BLAKE 是一种基于丹·伯恩斯坦的 ChaCha 流密码的密码哈希函数，但在每个 ChaCha 轮之前会添加一个输入块的置换副本，与轮常量进行异或运算。与
    SHA-2 一样，有两种不同字长的变体。ChaCha 在一个 4 × 4 的字数组上操作。BLAKE 重复地将一个 8 个字的哈希值与 16 个消息字结合在一起，将
    ChaCha 结果截断以获得下一个哈希值。BLAKE-256 和 BLAKE-224 使用 32 位字，并分别产生 256 位和 224 位的摘要大小，而
    BLAKE-512 和 BLAKE-384 使用 64 位字，并分别产生 512 位和 384 位的摘要大小。基于 BLAKE 的 BLAKE2 哈希函数于
    2012 年宣布。基于 BLAKE2 的 BLAKE3 哈希函数于 2020 年宣布。BLAKE2 是一个密码哈希函数，**比 MD5、SHA-1、SHA-2
    和 SHA-3 更快**（图 [3.4](#Fig4)），但至少与最新的标准 SHA-3 一样安全[[11](#CR11)]。![../images/501530_1_En_3_Chapter/501530_1_En_3_Fig4_HTML.png](../images/501530_1_En_3_Chapter/501530_1_En_3_Fig4_HTML.png)
- en: Fig. 3.4
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4
- en: Hash functions speed [[10](#CR10)]
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希函数速度 [[10](#CR10)]
- en: '3.2 Integrity: Digital Signature'
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2 完整性：数字签名
- en: In digital signature, we reverse the role of public and private keys. An encrypted
    hash is called a “digital signature” as shown in Fig. [3.5](#Fig5). Digital signature
    is used I e-commerce. For the real system, we are sending the message with the
    digital signature as shown in Fig. [3.6](#Fig6).![../images/501530_1_En_3_Chapter/501530_1_En_3_Fig5_HTML.png](../images/501530_1_En_3_Chapter/501530_1_En_3_Fig5_HTML.png)
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在数字签名中，我们颠倒了公钥和私钥的角色。加密的哈希被称为“数字签名”，如图 [3.5](#Fig5) 所示。数字签名在电子商务中使用。对于真实系统，我们正在发送带有数字签名的消息，如图
    [3.6](#Fig6) 所示。![../images/501530_1_En_3_Chapter/501530_1_En_3_Fig5_HTML.png](../images/501530_1_En_3_Chapter/501530_1_En_3_Fig5_HTML.png)
- en: Fig. 3.5
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5
- en: Digital signature
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 数字签名
- en: '![../images/501530_1_En_3_Chapter/501530_1_En_3_Fig6_HTML.png](../images/501530_1_En_3_Chapter/501530_1_En_3_Fig6_HTML.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![../images/501530_1_En_3_Chapter/501530_1_En_3_Fig6_HTML.png](../images/501530_1_En_3_Chapter/501530_1_En_3_Fig6_HTML.png)'
- en: Fig. 3.6
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6
- en: Sending the message with the digital signature
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 带数字签名的消息发送
- en: 3.3 Authentication
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3 鉴权
- en: Authentication answers the following question “how does a receiver know that
    remote communicating entity is who it is claimed to be?”. Authentication ensures
    that message has not been altered. Message is from alleged sender. Message sequence
    is unaltered. An example to show an authenticated email is shown in Fig. [3.7](#Fig7)
    where Alice wants to provide sender authentication message integrity, so Alice
    digitally signs message and sends both message and digital signature.![../images/501530_1_En_3_Chapter/501530_1_En_3_Fig7_HTML.png](../images/501530_1_En_3_Chapter/501530_1_En_3_Fig7_HTML.png)
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴权回答以下问题“接收方如何知道远程通信实体是声称的那个实体？”。鉴权确保消息未被更改。消息来自所谓的发送方。消息序列未被更改。示例显示了一个鉴权邮件，如图
    [3.7](#Fig7)，其中 Alice 想要提供发送者鉴权消息完整性，因此 Alice 对消息进行数字签名并发送消息和数字签名。![../images/501530_1_En_3_Chapter/501530_1_En_3_Fig7_HTML.png](../images/501530_1_En_3_Chapter/501530_1_En_3_Fig7_HTML.png)
- en: Fig. 3.7
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7
- en: Authenticated email
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴权邮件
- en: 3.3.1 HDCP
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.1 HDCP
- en: HDCP is an acronym for High-Bandwidth Digital Content Protection. HDCP is a
    specification developed by Intel Corporation to protect digital entertainment
    content across the DVI/HDMI interface.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: HDCP 是高带宽数字内容保护的缩写。HDCP 是由英特尔公司开发的规范，用于保护通过 DVI/HDMI 接口的数字娱乐内容。
- en: Digital Content Protection LLC (DCP) is the organization that licenses HDCP.
    How HDCP works is explained in Fig. [3.8](#Fig8). Each HDCP transmitter and receiver
    has 40 unique 56 bit private keys. These keys are provided by DCP to licensed
    HDCP chip vendors, who preload the keys onto the chips before selling them to
    device manufacturers. These keys must never leave the chip and may not be read
    by any other device.![../images/501530_1_En_3_Chapter/501530_1_En_3_Fig8_HTML.png](../images/501530_1_En_3_Chapter/501530_1_En_3_Fig8_HTML.png)
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 数字内容保护有限责任公司（DCP）是授权 HDCP 的组织。HDCP 的工作原理在图 [3.8](#Fig8) 中有解释。每个 HDCP 发射器和接收器都有
    40 个唯一的 56 位私钥。这些密钥由 DCP 提供给经许可的 HDCP 芯片供应商，在将芯片销售给设备制造商之前将密钥预装到芯片上。这些密钥绝不能离开芯片，也不能被任何其他设备读取。![../images/501530_1_En_3_Chapter/501530_1_En_3_Fig8_HTML.png](../images/501530_1_En_3_Chapter/501530_1_En_3_Fig8_HTML.png)
- en: Fig. 3.8
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.8
- en: How HDCP works. **It consists of authentication, data encryption**
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: HDCP 的工作原理。**它由认证、数据加密组成**。
- en: Each HDCP chip also has a public 40 bit value known as the Key Selection Vector
    (KSV). Each KSV consists of 20 binary 1 s and 20 binary 0 s. The KSVs and keys
    of all licensed HDCP devices are mathematically related according to a cryptographic
    key exchange protocol. In this scheme, any two licensed devices can swap KSVs
    and use them, along with their private keys, to come up with a shared secret key.
    This shared key can be used to encrypt and decrypt the TMDS stream.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 HDCP 芯片还有一个称为密钥选择向量（KSV）的公共 40 位值。每个 KSV 由 20 个二进制 1 和 20 个二进制 0 组成。所有经许可的
    HDCP 设备的 KSV 和密钥根据密码密钥交换协议在数学上相关联。在此方案中，任何两个经许可的设备都可以交换 KSV，并使用它们及其私钥来生成共享密钥。这个共享密钥可以用来加密和解密
    TMDS 流。
- en: 3.3.2 CAPTCHA Codes
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.2 验证码
- en: CAPTCHA is a verification process that requires users to enter a predetermined
    code. CAPTCHA stands for *Completely Automated Public Turing test to tell Computers
    and Humans Apart*. CAPTCHA exists to prevent spam from automated form submissions
    that can fill your site with junk postings, spam user accounts, or worse feel
    for security holes to be exploited on your website. CAPTCHAs work by providing
    a question that is simple for a human to answer but difficult for a bot to answer.
    Different types of CAPTCHAs have been developed, including simple math questions
    and classification problems [[12](#CR12)].
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: CAPTCHA 是一个需要用户输入预先确定代码的验证过程。CAPTCHA 代表*Completely Automated Public Turing test
    to tell Computers and Humans Apart*。CAPTCHA 的存在是为了防止垃圾邮件通过自动表单提交填充您的站点，垃圾用户帐户，或更糟的是感觉到站点上可以利用的安全漏洞。CAPTCHA
    的工作原理是提供一个对人类来说简单但对机器人来说难以回答的问题。已经开发了不同类型的 CAPTCHA，包括简单的数学问题和分类问题[[12](#CR12)]。
- en: '3.4 Availability: Intrusion Detection'
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.4 可用性：入侵检测
- en: 3.4.1 Artificial Immune System
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.1 人工免疫系统
- en: 'Any human are exposed to a huge range of harmful microorganisms (pathogens
    or antigens) which can be either single cell or multicellular such as bacteria,
    parasites, and viruses. These microorganisms can damage the human body. The human
    natural immune system (NIS) is a very complex defense system that can prevent
    this damage. There is no central organ controlling the functionality of the immune
    system. The parts of the NIS are:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 人类暴露于一系列有害微生物（病原体或抗原）中，可以是单细胞或多细胞，如细菌、寄生虫和病毒。这些微生物可以损害人体。人体的天然免疫系统（NIS）是一个非常复杂的防御系统，可以防止这种损害。没有一个中央器官来控制免疫系统的功能。NIS的部分包括：
- en: '1.'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '1.'
- en: 'Blood: white blood cells in particular.'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 血液：尤其是白细胞。
- en: '2.'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '2.'
- en: 'Lymph nodes: stores T and B cells and **traps** antigens/pathogens.'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 淋巴结：储存T细胞和B细胞，并**捕获**抗原/病原体。
- en: '3.'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '3.'
- en: 'Thymus Gland: produces T Lymphocytes that circulating throughout the body looking
    for abnormalities.'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 胸腺：产生T淋巴细胞，循环于全身寻找异常。
- en: '4.'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '4.'
- en: 'Bone Marrow: produces B lymphocytes.'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 骨髓：产生B淋巴细胞。
- en: Immune organs as positioned throughout the body are shown in Fig. [3.9](#Fig9).![../images/501530_1_En_3_Chapter/501530_1_En_3_Fig9_HTML.png](../images/501530_1_En_3_Chapter/501530_1_En_3_Fig9_HTML.png)
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 免疫器官分布于全身，见图 [3.9](#Fig9)。![../images/501530_1_En_3_Chapter/501530_1_En_3_Fig9_HTML.png](../images/501530_1_En_3_Chapter/501530_1_En_3_Fig9_HTML.png)
- en: Fig. 3.9
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.9
- en: Immune organs are positioned throughout the body
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 免疫器官分布于全身。
- en: The immune system has a learning phase over the years. Every element that can
    be recognized by the immune system is called an ***antigen*** **.** The cells
    that originally belong to our body and are harmless to its functionality are termed
    *(****self-antigens***), while the disease causing elements are named (***non-self-antigens***).
    As the body is attacked by certain microorganisms, the immune system memorizes
    them to be able to differentiate between foreign cells and the body cells.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 免疫系统在多年间有一个学习阶段。免疫系统能识别的每一个元素被称为***抗原*** **。** 最初属于我们身体并且对其功能无害的细胞被称为*(****自身抗原***），而导致疾病的元素被称为(***非自身抗原***）。当身体受到某些微生物的攻击时，免疫系统会记住它们以便能够区分外来细胞和身体细胞。
- en: The immune system is composed of two different cells which are called B cell
    and T cell. These two types of cells are rather similar but differ with relation
    to how they recognize antigens and by their functional roles. B cells can recognize
    antigens in the blood stream, while T cells require antigens to be presented by
    other accessory cells. Antigens are covered with molecules, named *epitopes.*
    These allow them to be recognized by the receptor molecules on the surface of
    B cells, called *antibodies (Ab).*
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 免疫系统由两种不同的细胞组成，称为B细胞和T细胞。这两种细胞在识别抗原的方式和功能角色方面相似但不同。B细胞可以识别血液中的抗原，而T细胞需要其他辅助细胞呈现抗原。抗原被分子覆盖，称为*表位（epitopes）*。这使它们可以被B细胞表面的受体分子所识别，称为*抗体（Ab）*。
- en: 'NIS is multilayered system. The human immune system (HIS) consists of three
    levels: skin, innate immunity, and adaptive immunity. The skin is the first barrier.
    The second barrier is physiological conditions such as temperature which provides
    inappropriate living conditions for harmful organisms. Once pathogens have entered
    the body, they are dealt with by the innate such as phagocytes which are cells
    that protect the body by ingesting harmful foreign particles and by the acquired
    immune response system (lymphocyte) which is considered as a detector.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: NIS 是多层次的系统。人体免疫系统（HIS）由三个层次组成：皮肤、先天免疫和后天免疫。皮肤是第一个屏障。第二个屏障是诸如温度之类的生理条件，为有害生物提供不适宜的生存条件。一旦病原体进入体内，它们将被先天免疫系统如嗜吞细胞（一种通过吞噬有害异物来保护身体的细胞）和后天免疫应答系统（淋巴细胞）处理，后者被认为是一种检测器。
- en: Pathogens are detected when a molecular bond is established between the pathogen
    and receptors that cover the surface of the lymphocyte. The number of receptors
    that bind to pathogens will determine the affinity that the lymphocyte has for
    a given pathogen. If a bond is very likely to occur, then many receptors will
    bind to pathogen epitopes, resulting in a high affinity for that pathogen; if
    a bond is unlikely to occur, then few receptors will bind to epitopes, and the
    lymphocyte will have a low affinity for that pathogen. Lymphocytes can only be
    activated by a pathogen if the lymphocyte’s affinity for the pathogen exceeds
    a certain affinity threshold. The layers are shown in Fig. [3.10](#Fig10). How
    B cells recognizes an antigen is shown in Fig. [3.11](#Fig11) and an illustrative
    example is shown in Fig. [3.12](#Fig12). Moreover, Fig. [3.13](#Fig13) shows the
    binding process.![../images/501530_1_En_3_Chapter/501530_1_En_3_Fig10_HTML.png](../images/501530_1_En_3_Chapter/501530_1_En_3_Fig10_HTML.png)
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 当病原体与覆盖淋巴细胞表面的受体建立分子键时，病原体就被检测到。与病原体结合的受体数量将决定淋巴细胞对给定病原体的亲和力。如果结合很可能发生，则许多受体将与病原体表位结合，导致对该病原体的高亲和力；如果结合不太可能发生，则很少的受体将与表位结合，淋巴细胞对该病原体的亲和力较低。只有当淋巴细胞对病原体的亲和力超过某一亲和力阈值时，淋巴细胞才能被病原体激活。这些层次显示在图
    [3.10](#Fig10) 中。B细胞如何识别抗原的过程显示在图 [3.11](#Fig11) 中，图 [3.12](#Fig12) 显示了一个说明性示例。此外，图
    [3.13](#Fig13) 显示了结合过程。![../images/501530_1_En_3_Chapter/501530_1_En_3_Fig10_HTML.png](../images/501530_1_En_3_Chapter/501530_1_En_3_Fig10_HTML.png)
- en: Fig. 3.10
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.10
- en: Layers of protection in the human body
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 人体内的保护层
- en: '![../images/501530_1_En_3_Chapter/501530_1_En_3_Fig11_HTML.png](../images/501530_1_En_3_Chapter/501530_1_En_3_Fig11_HTML.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![../images/501530_1_En_3_Chapter/501530_1_En_3_Fig11_HTML.png](../images/501530_1_En_3_Chapter/501530_1_En_3_Fig11_HTML.png)'
- en: Fig. 3.11
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.11
- en: B cell recognizes an antigen
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: B细胞识别抗原
- en: '![../images/501530_1_En_3_Chapter/501530_1_En_3_Fig12_HTML.png](../images/501530_1_En_3_Chapter/501530_1_En_3_Fig12_HTML.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![../images/501530_1_En_3_Chapter/501530_1_En_3_Fig12_HTML.png](../images/501530_1_En_3_Chapter/501530_1_En_3_Fig12_HTML.png)'
- en: Fig. 3.12
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.12
- en: (**a**) Lymphocyte recognizes the red pathogen, (**b**) lymphocyte does not
    recognize the red pathogen
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: (**a**) 淋巴细胞识别红色病原体，(**b**) 淋巴细胞不识别红色病原体
- en: '![../images/501530_1_En_3_Chapter/501530_1_En_3_Fig13_HTML.png](../images/501530_1_En_3_Chapter/501530_1_En_3_Fig13_HTML.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![../images/501530_1_En_3_Chapter/501530_1_En_3_Fig13_HTML.png](../images/501530_1_En_3_Chapter/501530_1_En_3_Fig13_HTML.png)'
- en: Fig. 3.13
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.13
- en: Pathogens are detected when a molecular bond is established between the pathogen
    and receptors that cover the surface of the lymphocyte
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 当病原体与覆盖淋巴细胞表面的受体之间建立分子键时，病原体被检测到。
- en: In the 1990s**,** **artificial immune system (AIS)** that is inspired by the
    natural or biological immune system has emerged as a new branch in computational
    intelligence systems. AIS as a connecting two domains are shown in Fig. [3.14](#Fig14).
    Until now a significant number of AIS-based algorithms have been developed for
    different applications such as pattern recognition, computer security, fault detection,
    and so many other applications [[13](#CR13)–[30](#CR30)]. In this paper and for
    the first time, AIS is proposed for security at RTL level. The proposed system
    is implemented by Verilog and tested on Xilinx FPGA as it provides an efficient
    and flexible platform for fast implementation of hardware architecture and fast
    reprogramming and experimental testing of various revised versions of the same
    hardware architectures. Other artificial machine learning algorithms can be used
    too [[31](#CR31)].![../images/501530_1_En_3_Chapter/501530_1_En_3_Fig14_HTML.png](../images/501530_1_En_3_Chapter/501530_1_En_3_Fig14_HTML.png)
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在 1990 年代，受到自然或生物免疫系统启发的**人工免疫系统（AIS）**已经成为计算智能系统中的一个新分支。AIS 作为连接两个领域的桥梁如图 [3.14](#Fig14)
    所示。到目前为止，已经为不同应用开发了大量基于 AIS 的算法，例如模式识别、计算机安全、故障检测等各种应用 [[13](#CR13)–[30](#CR30)]。在本文中，首次提出了将
    AIS 用于 RTL 级安全。所提出的系统由 Verilog 实现，并在 Xilinx FPGA 上进行测试，因为它为快速实现硬件架构和快速重新编程以及对同一硬件架构的各种修改版本进行实验测试提供了高效灵活的平台。也可以使用其他人工机器学习算法
    [[31](#CR31)]。![../images/501530_1_En_3_Chapter/501530_1_En_3_Fig14_HTML.png](../images/501530_1_En_3_Chapter/501530_1_En_3_Fig14_HTML.png)
- en: Fig. 3.14
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.14
- en: AIS is connecting two domains
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: AIS 是连接两个领域的桥梁
- en: Three basic concepts in artificial immune system (AIS) are affinity, clonal
    selection algorithm, and negative selection algorithm.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 人工免疫系统（AIS）中的三个基本概念是亲和力、克隆选择算法和负选择算法。
- en: A.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: A.
- en: Affinity
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 亲和力
- en: In AIS, the affinity between antibodies and antigens is calculated using Euclidean
    distance.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在 AIS 中，抗体和抗原之间的亲和力是用欧几里得距离计算的。
- en: If the coordinates of an antibody are given by:![$$ \mathrm{Ab}=\left({\mathrm{Ab}}_1,{\mathrm{Ab}}_2,\dots,
    {\mathrm{Ab}}_{\mathrm{n}}\right) $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equ3.png)(3.3)and
    the coordinates of an antigen are given by:![$$ \mathrm{Ag}=\left({\mathrm{Ag}}_1,{\mathrm{Ag}}_2,\dots,
    {\mathrm{Ag}}_{\mathrm{n}}\right) $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equ4.png)(3.4)then
    the distance between them is obtained by the following equation:![$$ \mathrm{D}=\sqrt{\sum
    \limits_{i=o}^n{\left(\mathrm{A}{b}_i-\mathrm{A}{g}_i\right)}^2\;} $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equ5.png)(3.5)
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如果抗体的坐标给定为:![$$ \mathrm{Ab}=\left({\mathrm{Ab}}_1,{\mathrm{Ab}}_2,\dots, {\mathrm{Ab}}_{\mathrm{n}}\right)
    $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equ3.png)(3.3)，抗原的坐标给定为:![$$
    \mathrm{Ag}=\left({\mathrm{Ag}}_1,{\mathrm{Ag}}_2,\dots, {\mathrm{Ag}}_{\mathrm{n}}\right)
    $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equ4.png)(3.4)，那么它们之间的距离由以下方程得出:![$$
    \mathrm{D}=\sqrt{\sum \limits_{i=o}^n{\left(\mathrm{A}{b}_i-\mathrm{A}{g}_i\right)}^2\;}
    $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equ5.png)(3.5)
- en: B.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: B.
- en: Negative Selection Algorithm and **Clonal Selection**
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 负选择算法和**克隆选择**
- en: 'The negative selection algorithm is the main algorithm used for NIS. *P* is
    the self set. *C* is the generated candidate to be non-self. *M* is the detector.
    *P** is the patterns to be protected (suspicion). The algorithm can be summarized
    as follows (Fig. [3.15](#Fig15)):'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 负选择算法是用于NIS的主要算法。*P*是自集合。*C*是生成的候选非自集合。*M*是检测器。*P**是要保护的模式（怀疑）。该算法可以总结如下（图 [3.15](#Fig15)）：
- en: '1.'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '1.'
- en: Generate random candidate elements (*C*).
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 生成随机候选元素(*C*)。
- en: '2.'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '2.'
- en: Compare the elements in *C* with the elements in *P*. If a match occurs, then
    reject it. It is a self. Else store this element of *C* in the detector set *M*.
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将*C*中的元素与*P*中的元素进行比较。如果匹配发生，则拒绝它。它是一个自模式。否则将*C*的这个元素存储在检测器集合*M*中。
- en: '3.'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '3.'
- en: After generating the set of detectors (*M*), the next stage of the algorithm
    consists in monitoring the system for the presence of non-self patterns. For all
    elements of the detector set, that corresponds to the non-self patterns, check
    if it matches an element of *P** and, if yes, then a non-self pattern was recognized.
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在生成检测器集合(*M*)后，算法的下一阶段是监视系统是否存在非自模式。对于检测器集合的所有元素，即对应于非自模式的元素，检查它是否与*P**的元素匹配，如果是，则识别出非自模式。
- en: '4.'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '4.'
- en: An action has to be taken. When a B-cell receptor recognizes a non-self antigen
    with a certain affinity, it is selected to proliferate and produce antibodies
    in high volumes.
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 必须采取行动。当B细胞受体识别具有一定亲和力的非自身抗原时，它被选择增殖并产生大量抗体。
- en: '5.'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '5.'
- en: The activated B cells with high antigenic affinities are selected to become
    memory cells with long life spans. These memory cells are pre-eminent in future
    responses to this same antigenic pattern, or a similar one this is called **clonal
    selection**.
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 具有高抗原亲和力的激活的B细胞被选中成为具有长寿命的记忆细胞。这些记忆细胞在将来对相同抗原模式或类似抗原模式的反应中占主导地位，这被称为**克隆选择**。
- en: '![../images/501530_1_En_3_Chapter/501530_1_En_3_Fig15_HTML.png](../images/501530_1_En_3_Chapter/501530_1_En_3_Fig15_HTML.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![../images/501530_1_En_3_Chapter/501530_1_En_3_Fig15_HTML.png](../images/501530_1_En_3_Chapter/501530_1_En_3_Fig15_HTML.png)'
- en: Fig. 3.15
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.15
- en: The **negative selection algorithm is the main algorithm used for NIS**. (**a**)
    Generating the set of detectors. (**b**) Monitoring for the presence of undesired
    (non-self) patterns. *P* is the self set. *C* is the generated candidate to be
    non-self. *M* is the detector. *P** is the patterns to be protected (suspicion)
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '**负选择算法是NIS中主要使用的算法**。 (**a**) 生成探测器集合。 (**b**) 监控不希望的（非自身）模式的存在。 *P*是自身集合。
    *C*是生成的候选非自身。 *M*是探测器。 *P**是要保护的模式（怀疑）'
- en: 3.5 Access Control
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.5 访问控制
- en: Security levels and solutions are summarized in Table [3.2](#Tab2) and Fig.
    [3.16](#Fig16). Passwords are shared secret between two parties. Smart cards  are
    electronics embedded in card capable of providing long passwords or satisfying
    challenge. It may have display to allow reading of password or can be plugged
    in directly. Biometrics uses of one or more intrinsic physical or behavioral traits
    to identify someone such as fingerprint reader, palm reader, retinal scan, or
    biometrics in general. A VPN, or virtual private network, allows you to create
    a secure connection to another network over the Internet. VPNs can be used to
    access region-restricted websites, shield your browsing activity from prying eyes
    on public Wi-Fi, and more. When you connect your computer (or another device,
    such as a smartphone or tablet) to a VPN, the computer acts as if it’s on the
    same local network as the VPN. All your network traffic is sent over a secure
    connection to the VPN. Because your computer behaves as if it’s on the network,
    this allows you to securely access local network resources even when you’re on
    the other side of the world. You’ll also be able to use the Internet as if you
    were present at the VPN’s location, which has some benefits if you’re using pubic
    Wi-Fi or want to access geo-blocked websites [[32](#CR32)].Table 3.2
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 安全级别和解决方案总结在表[3.2](#Tab2)和图[3.16](#Fig16)中。密码是两个方之间共享的秘密。智能卡是内嵌电子元件的卡片，能够提供长密码或满足挑战要求。它可能具有显示屏，以允许读取密码，或者可以直接插入。生物识别使用一个或多个内在的身体特征或行为特征来识别某人，例如指纹识读器、手掌识读器、视网膜扫描或生物识别技术。虚拟专用网络（VPN）允许您在互联网上创建与另一个网络的安全连接。VPN可用于访问受区域限制的网站，保护您在公共Wi-Fi上的浏览活动等。当您连接您的计算机（或其他设备，如智能手机或平板电脑）到VPN时，计算机会表现得好像它在同一个本地网络上一样。您所有的网络流量都通过安全连接发送到VPN。因为您的计算机表现得好像它在网络上，这使得您可以安全地访问本地网络资源，即使您身在世界的另一边。您还可以像在VPN所在地一样使用互联网，这在您使用公共Wi-Fi或想要访问地理限制的网站时有一些好处[[32](#CR32)]。表3.2
- en: Security levels and solutions
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 安全级别和解决方案
- en: '| Security level | Solution |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| 安全级别 | 解决方案 |'
- en: '| --- | --- |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Low | Something you know (pin, password) |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| 低 | 你所知道的东西（PIN码、密码） |'
- en: '| Medium | Something you know + something you have (access card) |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| 媒介 | 你所知道的东西 + 你所拥有的东西（门禁卡） |'
- en: '| High | Something you know + something you have + something you are (fingerprint)
    |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| 高级 | 你知道的东西 + 你拥有的东西 + 你的本质（指纹） |'
- en: '![../images/501530_1_En_3_Chapter/501530_1_En_3_Fig16_HTML.png](../images/501530_1_En_3_Chapter/501530_1_En_3_Fig16_HTML.png)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![../images/501530_1_En_3_Chapter/501530_1_En_3_Fig16_HTML.png](../images/501530_1_En_3_Chapter/501530_1_En_3_Fig16_HTML.png)'
- en: Fig. 3.16
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.16
- en: 'Access control: security levels'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 访问控制：安全级别
- en: '3.6 Non-repudiation: Trusted Third Party'
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.6 不可否认性：可信第三方
- en: The ability to ensure that a party to a contract or a communication cannot deny
    the authenticity of their signature on a document or the sending of a message
    that they originated. You can’t deny doing something you did. To mitigate the
    risk of people repudiating their own signatures, the standard approach is to involve
    a trusted third party. For digital information, the most commonly employed **TTP**
    is a certificate authority, which issues public key certificates. A public key
    certificate can be used by anyone to verify digital signatures without a shared
    secret between the signer and the verifier. The role of the certificate authority
    is to authoritatively state to whom the certificate belongs, meaning that this
    person or entity possesses the corresponding private key. However, a digital signature
    is forensically identical in both legitimate and forged uses. Someone who possesses
    the private key can create a valid digital signature [[33](#CR33)].
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 确保合同或通信的一方无法否认其在文件上的签名的真实性或其起源的消息的发送。你不能否认自己做过的事情。为了减轻人们否认自己签名的风险，标准做法是涉及到一个可信的第三方。对于数字信息，最常用的**TTP**是证书颁发机构，它颁发公钥证书。任何人都可以使用公钥证书来验证数字签名，而不需要签名者和验证者之间的共享密钥。证书颁发机构的作用是权威地声明证书属于谁，意味着这个人或实体拥有相应的私钥。然而，数字签名在合法和伪造用途上在法庭上是相同的。拥有私钥的人可以创建有效的数字签名[[33](#CR33)]。
- en: 3.7 Conclusions
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.7 结论
- en: This chapter explores different cryptography concepts such as authentication,
    integrity, availability, access control, and non-repudiation. It presents concepts
    of digital signatures, hash functions, and message authentication codes (MACs).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了不同的密码学概念，如认证、完整性、可用性、访问控制和不可否认性。它介绍了数字签名、哈希函数和消息认证码（MAC）的概念。
