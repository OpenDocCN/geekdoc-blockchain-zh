- en: © The Editor(s) (if applicable) and The Author(s), under exclusive license to
    Springer Nature Switzerland AG 2020K. S. MohamedNew Frontiers in Cryptography[https://doi.org/10.1007/978-3-030-58996-7_3](https://doi.org/10.1007/978-3-030-58996-7_3)
  prefs: []
  type: TYPE_NORMAL
- en: '3. Cryptography Concepts: Integrity, Authentication, Availability, Access Control,
    and Non-repudiation'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Khaled Salah Mohamed^([1](#Aff2) )(1)A Siemens Business, Fremont, CA, USAKeywordsHashAuthenticationNon-repudiationMACAccess
    controlDigital signatureHDCPIntrusion detectionHMACImmune
  prefs: []
  type: TYPE_NORMAL
- en: '3.1 Integrity: Hashing Concept'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To validate the integrity of the data transmitted over the channel, message
    authentication code (MAC) is used for checking the messages and the authentication,
    ensuring that the integrity of the information has not been modified under the
    transmission.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hash functions are mathematical functions which map values in the domain values
    in the range. Hash functions are special mathematical functions that satisfy the
    following three properties:'
  prefs: []
  type: TYPE_NORMAL
- en: Inputs can be any size.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Outputs are fixed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Efficiently computable, i.e., the mapping should be efficiently computable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The purpose of a hash function is to produce a “fingerprint” of a message or
    data for authentication. A hash function *H*(*m*) maps an input message *m* to
    a hash value *h* as described by eq. ([3.1](#Equ1)). Message *m* is of any arbitrary
    length. Hash *h* is fixed length. Often, *h* is called as the *message digest*
    of *m*. Figure [3.1](#Fig1) shows the abstract level of hashing functionalities:![$$
    h=H(m) $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equ1.png)(3.1)![../images/501530_1_En_3_Chapter/501530_1_En_3_Fig1_HTML.png](../images/501530_1_En_3_Chapter/501530_1_En_3_Fig1_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 3.1
  prefs: []
  type: TYPE_NORMAL
- en: Hashing
  prefs: []
  type: TYPE_NORMAL
- en: Cryptographic hash functions are one-way function as finding hash *h* from *m*
    is easy, but not vice-versa. Given a message, it is hard to find another message
    that has the same hash value. Given a hash function, it is hard to find two messages
    with the same hash value. In cryptography, the avalanche effect is a term associated
    with a specific behavior of mathematical functions used for encryption.
  prefs: []
  type: TYPE_NORMAL
- en: 3.1.1 SHA-3
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SHA was designed by NIST and NSA in 1993, revised 1995 as **SHA-1**. The algorithm
    produces 160 bit hash values. Now, it is the most preferred hash algorithm. **SHA-2**
    uses the Davies–Meyer structure, an instance of the Merkle–Damgård structure,
    with a block cipher (sometimes called SHACAL-2) built out of an ARX network, like
    MD4\. **SHA-3** (Secure Hash Algorithm 3) is the latest member of the Secure Hash
    Algorithm family of standards. SHA-3 uses the sponge construction in which is
    “absorbed” into the sponge, and then the result is “squeezed” out. In the absorbing
    phase, message blocks are XORed into a subset of the state, which is then transformed
    as a whole using a permutation function. In the “squeeze” phase, output blocks
    are read from the same subset of the state, alternated with the state transformation
    function. The size of the part of the state that is written and read is called
    the rate, and the size of the part that is untouched by input/output is called
    the capacity. The capacity determines the security of the scheme. The maximum
    security level is half the capacity. To ensure the message can be evenly divided
    into r-bit blocks, padding is required. Changing a single bit causes each bit
    in the output to change with 50% probability, demonstrating an **avalanche effect**
    [[1](#CR1), [2](#CR2)]. In a nutshell, SHA2 (and SHA1) are built using the Merkle–Damgård
    structure. SHA3 on the other hand is built using a sponge function.
  prefs: []
  type: TYPE_NORMAL
- en: 3.1.1.1 Merkle–Damgård Construction
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In cryptography, the Merkle–Damgård construction or Merkle–Damgård hash function
    is a method of building collision-resistant cryptographic hash functions from
    collision-resistant one-way compression functions. This construction was used
    in the design of many popular hash algorithms such as MD5, SHA1, and SHA2\. The
    Merkle–Damgård hash function first applies an MD-compliant padding function to
    create an input whose size is a multiple of a fixed number (e.g., 512 or 1024) –
    this is because compression functions cannot handle inputs of arbitrary size.
    The hash function then breaks the result into blocks of fixed size and processes
    them one at a time with the compression function, each time combining a block
    of the input with the output of the previous round. In order to make the construction
    secure, Merkle and Damgård proposed that messages be padded with a padding that
    encodes the length of the original message [[3](#CR3)–[5](#CR5)].
  prefs: []
  type: TYPE_NORMAL
- en: 3.1.1.2 Sponge Function
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In cryptography, a sponge function or sponge construction is any of a class
    of algorithms with finite internal state that take an input bit stream of any
    length and produce an output bit stream of any desired length. Sponge functions
    have both theoretical and practical uses. They can be used to model or implement
    many cryptographic primitives, including cryptographic hashes, message authentication
    codes, mask generation functions, stream ciphers, pseudorandom number generators,
    and authenticated encryption. A sponge function is built from three components:
    a state memory, a function that transforms the state memory, and a padding function.
    The state memory is divided into two sections: the bitrate and the capacity. The
    padding function appends enough bits to the input string so that the length of
    the padded input is a whole multiple of the bitrate [[6](#CR6)].'
  prefs: []
  type: TYPE_NORMAL
- en: 'The sponge function operates as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The state *S* is initialized to zero.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The input string is padded.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For each *r*-bit block *B* of the padded input:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*R* is replaced with *R* XOR *B*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*S* is replaced by *f*(*S*)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The *R* portion of the state memory is output.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'repeat until enough bits are output:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*S* is replaced by *f*(*S*)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The *R* portion of the state memory is output
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If less than *r* bits remain to be output, then *R* will be truncated.
  prefs: []
  type: TYPE_NORMAL
- en: 3.1.2 HMAC-SHA256 (Hashed Message Authentication Code, Secure Hash Algorithm)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 3.1.2.1 Nomenclature
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: B
  prefs: []
  type: TYPE_NORMAL
- en: Block size (in bytes) of the input to the approved hash function.
  prefs: []
  type: TYPE_NORMAL
- en: '*H*'
  prefs: []
  type: TYPE_NORMAL
- en: SHA-256 hash function.
  prefs: []
  type: TYPE_NORMAL
- en: ipad
  prefs: []
  type: TYPE_NORMAL
- en: Inner pad; the byte x′36′ repeated B times.
  prefs: []
  type: TYPE_NORMAL
- en: '*K*'
  prefs: []
  type: TYPE_NORMAL
- en: Secret key shared between the host and the device.
  prefs: []
  type: TYPE_NORMAL
- en: '*K*[0]'
  prefs: []
  type: TYPE_NORMAL
- en: The key *K* after any necessary pre-processing to form a *B*-byte key.
  prefs: []
  type: TYPE_NORMAL
- en: '*L*'
  prefs: []
  type: TYPE_NORMAL
- en: Block size (in bytes) of the output of the approved hash function.
  prefs: []
  type: TYPE_NORMAL
- en: opad
  prefs: []
  type: TYPE_NORMAL
- en: Outer pad; the byte x′5c′ repeated B times.
  prefs: []
  type: TYPE_NORMAL
- en: '*t*'
  prefs: []
  type: TYPE_NORMAL
- en: The number of bytes of MAC.
  prefs: []
  type: TYPE_NORMAL
- en: text
  prefs: []
  type: TYPE_NORMAL
- en: The message on which the HMAC is calculated; text does not include the padded
    key.
  prefs: []
  type: TYPE_NORMAL
- en: x′N′
  prefs: []
  type: TYPE_NORMAL
- en: Hexadecimal notation, where each symbol in the string “N” represents four binary
    bits.
  prefs: []
  type: TYPE_NORMAL
- en: '||'
  prefs: []
  type: TYPE_NORMAL
- en: Concatenation.
  prefs: []
  type: TYPE_NORMAL
- en: xor
  prefs: []
  type: TYPE_NORMAL
- en: Exclusive-OR operation.
  prefs: []
  type: TYPE_NORMAL
- en: a, b, c
  prefs: []
  type: TYPE_NORMAL
- en: Working variables that are the w-bit words used in the computation of the hash
    values, *H*^(*(i)*).
  prefs: []
  type: TYPE_NORMAL
- en: '*H*^((*i*))'
  prefs: []
  type: TYPE_NORMAL
- en: The *i*th hash value. *H*^(*(0)*) is the initial hash value; *H*^(*(N)*) is
    the final hash value and is used to determine the message digest.
  prefs: []
  type: TYPE_NORMAL
- en: '*H*[*j*]^((*i*))'
  prefs: []
  type: TYPE_NORMAL
- en: The *j*th word of the *i*th hash value, where *H*[*0*]^(*(i)*) is the left-most
    word of hash value *i*.
  prefs: []
  type: TYPE_NORMAL
- en: '*K*[*t*]'
  prefs: []
  type: TYPE_NORMAL
- en: Constant value to be used for iteration *t* of the hash computation.
  prefs: []
  type: TYPE_NORMAL
- en: '*k*'
  prefs: []
  type: TYPE_NORMAL
- en: Number of zeroes appended to a message during the padding step.
  prefs: []
  type: TYPE_NORMAL
- en: '*l*'
  prefs: []
  type: TYPE_NORMAL
- en: Length of the message, *M*, in bits.
  prefs: []
  type: TYPE_NORMAL
- en: '*m*'
  prefs: []
  type: TYPE_NORMAL
- en: Number of bits in a message block, *M*^((*i*)).
  prefs: []
  type: TYPE_NORMAL
- en: '*M*'
  prefs: []
  type: TYPE_NORMAL
- en: Message to be hashed.
  prefs: []
  type: TYPE_NORMAL
- en: '*M*^(*(i)*)'
  prefs: []
  type: TYPE_NORMAL
- en: Message block *i*, with a size of *m* bits.
  prefs: []
  type: TYPE_NORMAL
- en: '*M*[*j*]^(*(i)*)'
  prefs: []
  type: TYPE_NORMAL
- en: The *j*th word of the *i*th message block, where *M*[*0*]^(*(i)*) is the left-most
    word of message block *i*
  prefs: []
  type: TYPE_NORMAL
- en: '*n*'
  prefs: []
  type: TYPE_NORMAL
- en: Number of bits to be rotated or shifted when a word is operated upon.
  prefs: []
  type: TYPE_NORMAL
- en: '*N*'
  prefs: []
  type: TYPE_NORMAL
- en: Number of blocks in the padded message.
  prefs: []
  type: TYPE_NORMAL
- en: '*T*'
  prefs: []
  type: TYPE_NORMAL
- en: Temporary *w*-bit word used in the hash computation.
  prefs: []
  type: TYPE_NORMAL
- en: '*w*'
  prefs: []
  type: TYPE_NORMAL
- en: Number of bits in a word.
  prefs: []
  type: TYPE_NORMAL
- en: '*W*[*t*]'
  prefs: []
  type: TYPE_NORMAL
- en: The *t*th *w-*bit word of the message schedule.
  prefs: []
  type: TYPE_NORMAL
- en: ^
  prefs: []
  type: TYPE_NORMAL
- en: Bitwise AND operation.
  prefs: []
  type: TYPE_NORMAL
- en: '*Or*'
  prefs: []
  type: TYPE_NORMAL
- en: Bitwise OR (“inclusive-OR”) operation.
  prefs: []
  type: TYPE_NORMAL
- en: '*Xor*'
  prefs: []
  type: TYPE_NORMAL
- en: Bitwise XOR (“Exclusive-OR”) operation.
  prefs: []
  type: TYPE_NORMAL
- en: '!'
  prefs: []
  type: TYPE_NORMAL
- en: Bitwise complement operation.
  prefs: []
  type: TYPE_NORMAL
- en: +
  prefs: []
  type: TYPE_NORMAL
- en: Addition modulo 2^(*w*).
  prefs: []
  type: TYPE_NORMAL
- en: ≪
  prefs: []
  type: TYPE_NORMAL
- en: Left-shift operation, where *x* ≪ *n* is obtained by discarding the left-most
    *n* bits of the word *x* and then padding the result with *n* zeroes on the right.
  prefs: []
  type: TYPE_NORMAL
- en: ≫
  prefs: []
  type: TYPE_NORMAL
- en: Right-shift operation, where *x* ≫ *n* is obtained by discarding the rightmost
    *n* bits of the word *x* and then padding the result with *n* zeroes on the left.
  prefs: []
  type: TYPE_NORMAL
- en: 3.1.2.2 Introduction
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: HMAC_SHA is a secure cryptographic hash function-based message and shared key
    authentication protocols. It can effectively prevent data being intercepted and
    tampered with during transmissions.
  prefs: []
  type: TYPE_NORMAL
- en: The message authentication code (MAC)  is calculated using HMAC SHA-256 as defined
    in [[7](#CR7)–[9](#CR9)]. The HMAC SHA-256 calculation takes as input a key and
    a message. The resulting MAC is 256 bits (32 bytes), which are embedded in the
    data frame as part of the request or response. The key used for the MAC calculation
    is 256 bit authentication key. The receiver computes the MAC on the received data
    using the same key and HMAC function as was used by the transmitter and compares
    the result computed with the received MAC. If the two values match, then the data
    has been correctly received.
  prefs: []
  type: TYPE_NORMAL
- en: The HMAC-SHA-256 is the implementation of the HMAC message authentication code
    calculation using the SHA-256 hash function. The hash function can be iterative
    and breaks up the message into blocks of a fixed size and iterates over them.
    For SHA-256, the message size is less than 2^(64). Each message block has 512
    bits. The message is padded so that it can be parsed into N x 512 blocks. The
    output of HMAC calculation is the same as the underlying hash function which in
    our case is 256 bits (32 bytes) wide. In this paper, we present a low latency
    hardware implementation of HMAC-SHA-256(Hashed Message Authentication Code, Secure
    Hash Algorithm) algorithm for Internet of Things (Io) applications. Figure [3.2](#Fig2)
    and Table [3.1](#Tab1) illustrates the step-by-step process in the HMAC algorithm.
    SHA-256 is SHA-2 with 256-bit output.![../images/501530_1_En_3_Chapter/501530_1_En_3_Fig2_HTML.png](../images/501530_1_En_3_Chapter/501530_1_En_3_Fig2_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 3.2
  prefs: []
  type: TYPE_NORMAL
- en: Illustration of the HMAC construction
  prefs: []
  type: TYPE_NORMAL
- en: Table 3.1
  prefs: []
  type: TYPE_NORMAL
- en: General HMAC algorithm
  prefs: []
  type: TYPE_NORMAL
- en: '| Steps | Step-by-step description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| *Step 1* | *K* = 32 bytes, B = 64 bytes, *K* ≠ *B* |'
  prefs: []
  type: TYPE_TB
- en: '| *Step 2* | *K* < *B*: append zeros to the end of *K* to create a *B*-byte
    string *K*[0] (*K* will be appended with 32 zero bytes 0x00) |'
  prefs: []
  type: TYPE_TB
- en: '| *Step 3* | Exclusive-OR *K*0 with *ipad* to produce a *B*-byte string: ***K***[**0**]
    xor ***ipad*** |'
  prefs: []
  type: TYPE_TB
- en: '| *Step 4* | Append the stream of data *text* to the string resulting from
    step 4: **(*****K***[**0**] xor ***ipad*****) &#124;&#124;** ***text*** |'
  prefs: []
  type: TYPE_TB
- en: '| *Step 5* | Apply *H* to the stream generated in step 5: **H((*****K***[**0**]
    xor ***ipad*****) &#124;&#124;** ***text*****)** |'
  prefs: []
  type: TYPE_TB
- en: '| *Step 6* | Exclusive-OR *K*[*0*] with *opad*: ***K***[**0**] xor ***opad***
    |'
  prefs: []
  type: TYPE_TB
- en: '| *Step 7* | Append the result from step 5 to step 6: **(*****K***[**0**] xor
    ***opad*****) &#124;&#124; H((*****K***[**0**] xor ***ipad*****) &#124;&#124;**
    ***text*****)** |'
  prefs: []
  type: TYPE_TB
- en: '| *Step 8* | Apply *H* to the result from step 7: ***H*****((*****K***[**0**]
    xor ***opad*****) &#124;&#124;** ***H*****((*****K***[**0**] xor ***ipad*****)
    &#124;&#124;** ***text*****))** |'
  prefs: []
  type: TYPE_TB
- en: '| *Step 9* | Select the leftmost *t* bytes of the result of step 8 as the MAC
    |'
  prefs: []
  type: TYPE_TB
- en: 3.1.2.3 HMAC Algorithm
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As specified in [[7](#CR7)], the size of a message block for Secure Hash Algorithm
    SHA-256 is 512 bits (i.e., *B* = 64 bytes). To compute a MAC over the data “text”
    using the HMAC function, the following operation is performed:![$$ {\displaystyle
    \begin{array}{c}\mathrm{MAC}\left(\mathrm{text}\right)t=\mathrm{HMAC}\left(K,\kern0.5em
    \mathrm{text}\right)t\\ {}=H\left(\left(K0\kern0.5em \mathrm{xor}\kern0.5em \mathrm{opad}\right)\parallel
    H\left(\left(K0\kern0.5em \mathrm{xor}\kern0.5em \mathrm{ipad}\right)\parallel
    \mathrm{text}\right)\right)t\end{array}} $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equ2.png)(3.2)
  prefs: []
  type: TYPE_NORMAL
- en: 3.1.2.4 SHA-256 Algorithm
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Pad the message, *M*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The message, *M*, shall be padded before hash computation begins. The purpose
    of this padding is to ensure that the padded message is a multiple of 512 or 1024
    bits, depending on the algorithm. Suppose that the length of the message, *M*,
    is l bits. Append the bit “1” to the end of the message, followed by k zero bits,
    where k is the smallest, nonnegative solution to the equation l + 1 + k = 448mod
    512\. Then append the 64 bit block that is equal to the number l expressed using
    a binary representation. For example, the (8 bit ASCII) message “abc” has length
    8 × 3 = 24, so the message is padded with a one bit, then 448 − (24 + 1) = 423
    zero bits, and then the message length, to become the 512-bit padded message as
    shown in Fig. [3.3](#Fig3).![../images/501530_1_En_3_Chapter/501530_1_En_3_Fig3_HTML.png](../images/501530_1_En_3_Chapter/501530_1_En_3_Fig3_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 3.3
  prefs: []
  type: TYPE_NORMAL
- en: SHA-256 message example
  prefs: []
  type: TYPE_NORMAL
- en: '2.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Parse the padded message into N 512-bit message blocks, *M*^((1)), *M*^((2)),
    …, *M*^((*N*)).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '3.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the initial hash value, *H*^((0)):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Before hash computation begins for each of the secure hash algorithms, the initial
    hash value, *H*^((0)), must be set. The size and number of words in *H*^((0))
    depends on the message digest size.
  prefs: []
  type: TYPE_NORMAL
- en: For SHA-256, the initial hash value, *H*^((0)), shall consist of the following
    eight 32 bit words, in hex:![$$ {H_0}^{(0)}=\kern0.62em 6\mathrm{a}09\mathrm{e}667
    $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equa.png)![$$ {H_1}^{(0)}=\kern0.62em
    \mathrm{bb}67\mathrm{ae}85 $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equb.png)![$$
    {H_2}^{(0)}=\kern0.62em 3\mathrm{c}6\mathrm{ef}372 $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equc.png)![$$
    {H_3}^{(0)}=\kern0.62em \mathrm{a}54\mathrm{ff}53\mathrm{a} $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equd.png)![$$
    {H_4}^{(0)}=\kern0.62em 510\mathrm{e}527\mathrm{f} $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Eque.png)![$$
    {H_5}^{(0)}=\kern0.62em 9\mathrm{b}05688\mathrm{c} $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equf.png)![$$
    {H_6}^{(0)}=\kern0.62em 1\mathrm{f}83\mathrm{d}9\mathrm{ab} $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equg.png)![$$
    {H_7}^{(0)}=\kern0.62em 5\mathrm{be}0\mathrm{cd}19 $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equh.png)
  prefs: []
  type: TYPE_NORMAL
- en: '4.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After preprocessing is completed, each message block, *M*^((1)), *M*^((2)),
    …, *M*^((*N*)), is processed in order, using the following steps:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For *i* = 1 to *N*:'
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Prepare the message schedule, {*W*[*t*]}
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![$$ {W}_t=\left\{\begin{array}{ll}{M}_t^{(t)}&amp; 0\le t\le 15\\ {}{\sigma}_1^{\left\{256\right\}}\left({W}_{t-2}\right)+{W}_{t-7}+{\sigma}_0^{\left\{256\right\}}\left({W}_{t-15}\right)+{W}_{t-16}&amp;
    16\le t\le 63\end{array}\right. $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equi.png)'
  prefs: []
  type: TYPE_IMG
- en: '2.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Initialize the eight working variables, *a, b, c, d, e, f, g,* and *h*, with
    the (*i* − 1)st hash value:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![$$ a={H}_0^{\left(i-1\right)} $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equj.png)![$$
    b={H}_1^{\left(i-1\right)} $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equk.png)![$$
    c={H}_2^{\left(i-1\right)} $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equl.png)![$$
    d={H}_3^{\left(i-1\right)} $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equm.png)![$$
    e={H}_4^{\left(i-1\right)} $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equn.png)![$$
    f={H}_5^{\left(i-1\right)} $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equo.png)![$$
    g={H}_6^{\left(i-1\right)} $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equp.png)![$$
    h={H}_7^{\left(i-1\right)} $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equq.png)'
  prefs: []
  type: TYPE_IMG
- en: '3.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For *t* = 0 to 63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![$$ {T}_1=h+\sum \limits_1^{\left\{256\right\}}(e)+ Ch\left(e,f,g\right)+{K}_t^{\left\{256\right\}}+{W}_t
    $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equr.png)![$$ {T}_2=\sum
    \limits_0^{\left\{256\right\}}(a)+ Maj\left(a,b,c\right) $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equs.png)![$$
    h=g $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equt.png)![$$
    g=f $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equu.png)![$$
    f=e $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equv.png)![$$
    e=d+{T}_1 $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equw.png)![$$
    d=c $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equx.png)![$$
    c=b $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equy.png)![$$
    b=a $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equz.png)![$$
    a={T}_1+{T}_2 $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equaa.png)}'
  prefs: []
  type: TYPE_NORMAL
- en: '4.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Compute the *i*th intermediate hash value *H*^((*i*)):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![$$ {H}_0^{(i)}=a+{H}_0^{\left(i-1\right)} $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equab.png)![$$
    {H}_1^{(i)}=b+{H}_1^{\left(i-1\right)} $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equac.png)![$$
    {H}_2^{(i)}=c+{H}_2^{\left(i-1\right)} $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equad.png)![$$
    {H}_3^{(i)}=d+{H}_3^{\left(i-1\right)} $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equae.png)![$$
    {H}_4^{(i)}=e+{H}_4^{\left(i-1\right)} $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equaf.png)![$$
    {H}_5^{(i)}=f+{H}_5^{\left(i-1\right)} $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equag.png)![$$
    {H}_6^{(i)}=g+{H}_6^{\left(i-1\right)} $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equah.png)![$$
    {H}_7^{(i)}=h+{H}_7^{\left(i-1\right)} $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equai.png)'
  prefs: []
  type: TYPE_IMG
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: After repeating steps one through four a total of *N* times (i.e., after processing
    *M*^(*(N)*)), the resulting 512 bit message digest of the message, *M*, is
  prefs: []
  type: TYPE_NORMAL
- en: '![$$ {H}_0^{(N)}{H}_1^{(N)}{H}_2^{(N)}{H}_3^{(N)}{H}_4^{(N)}\left|{H}_5^{(N)}{H}_6^{(N)}\left|{H}_7^{(N)}\right.\right..
    $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equaj.png)'
  prefs: []
  type: TYPE_IMG
- en: 3.1.2.5 HMAC-SHA256 Illustrative Example
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This example for the HMAC-SHA256 calculation uses one message of 284 bytes and
    a key of 32 bytes.
  prefs: []
  type: TYPE_NORMAL
- en: '*Input:*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Text***: 284 bytes message'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f404142434445464748494a4b4c4d4e4f505152535455565758595a5b5c5d5e5f606162636465666768696a6b6c6d6e6f707172737475767778797a7b7c7d7e7f808182838485868788898a8b8c8d8e8f909192939495969798999a9b9c9d9e9fa0a1a2a3a4a5a6a7a8a9aaabacadaeafb0b1b2b3b4b5b6b7b8b9babbbcbdbebfc0c1c2c3c4c5c6c7c8c9cacbcccdcecfd0d1d2d3d4d5d6d7d8d9dadbdcdddedfe0e1e2e3e4e5e6e7e8e9eaebecedeeeff0f1f2f3f4f5f6f7f8f9fafbfcfdfeff00000000000000000000000000000000000000010000000100000003.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Key***: 32 bytes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '0000000000000000000000000000000000000000011010110110010101111001'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Steps:*'
  prefs: []
  type: TYPE_NORMAL
- en: '1.K[0]: append 32 bytes of zeros to the end of the key to create a 64 byte
    message'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '00000000000000000000000000000000000000000110101101100101011110010000000000000000000000000000000000000000000000000000000000000000'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 2.Create a 64 byte ipad pattern of repeating the hexadecimal value 0x36.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '36363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 3.Create a 64 byte opad pattern of repeating the hexadecimal value 0x5c.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '4.XOR K[0] with ipad: ***K***[**0**] xor ***ipad***.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '36363636363636363636363636363636363636363726262737263737372726373636363636363636363636363636363636363636363636363636363636363636'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '5.Concatenate text at the end: **(*****K***[**0**] xor ***ipad*****) ||** ***text***'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 36363636363636363636363636363636363636363726262737263737372726373636363636363636363636363636363636363636363636363636363636363636000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f404142434445464748494a4b4c4d4e4f505152535455565758595a5b5c5d5e5f606162636465666768696a6b6c6d6e6f707172737475767778797a7b7c7d7e7f808182838485868788898a8b8c8d8e8f909192939495969798999a9b9c9d9e9fa0a1a2a3a4a5a6a7a8a9aaabacadaeafb0b1b2b3b4b5b6b7b8b9babbbcbdbebfc0c1c2c3c4c5c6c7c8c9cacbcccdcecfd0d1d2d3d4d5d6d7d8d9dadbdcdddedfe0e1e2e3e4e5e6e7e8e9eaebecedeeeff0f1f2f3f4f5f6f7f8f9fafbfcfdfeff00000000000000000000000000000000000000010000000100000003
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 6.Hash the value above using SHA-256 algorithm.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The message is extended as shown above. In this case the data message to be
    hashed is 2784 bits (348 bytes). To achieve a padded message that is a multiple
    of 512 bits, the 2784 bits message is padded with one bit, then 223 zero bits,
    and then 64 bits representing the message length. The message now becomes a 6*512
    bit padded message. This padded message is then processed using the SHA-256 algorithm
    explained above to obtain the hash value.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 663cb567af6aeb40a9948a1621c129b69ffbd41244596df0b2729bac5ac0fbb1
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '7.XOR appended key with opad: ***K***[**0**] xor ***opad***'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5d4c4c4d5d4c5d5d5d4d4c5d5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '8.Concatenate the result from step 6 and step 7:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**(*****K***[**0**] xor ***opad*****) || H((*****K***[**0**] xor ***ipad*****)
    ||** ***text*****)**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5d4c4c4d5d4c5d5d5d4d4c5d5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c663cb567af6aeb40a9948a1621c129b69ffbd41244596df0b2729bac5ac0fbb1
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 9.Hash the output of step 8 using SHA-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The message should be padded before hashing of SHA-256 algorithm. In this case
    the message length is 768 bits (96 bytes). To achieve a padded message that is
    a multiple of 512 bits, the message is padded with one bit and then 191 zero bits
    and then 64 bits representing the message length. The message is now 2*512 bit
    padded message. This padded message is then processed using the SHA-256 algorithm
    explained above to obtain the hash value.a771af5ea520f789c0e6668c4c9cb6f30111d381503917af47af37c53b7adca2.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 3.1.3 MD5 Algorithm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'MED5 algorithm  works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Pad message so its length is 448 mod 512.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Append a 64 bit length value to message.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initialize four-word (128 bit) MD buffer (A, B, C, D).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Process message in 16-word (512 bit) blocks: using four rounds of 16 bit operations
    on message block and buffer. Add output to buffer input to form new buffer value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Output hash value is the final buffer value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3.1.4 Blake
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: BLAKE is a cryptographic hash function based on Dan Bernstein’s ChaCha stream
    cipher, but a permuted copy of the input block, XORed with round constants, is
    added before each ChaCha round. Like SHA-2, there are two variants differing in
    the word size. ChaCha operates on a 4 × 4 array of words. BLAKE repeatedly combines
    an 8-word hash value with 16 message words, truncating the ChaCha result to obtain
    the next hash value. BLAKE-256 and BLAKE-224 use 32 bit words and produce digest
    sizes of 256 bits and 224 bits, respectively, while BLAKE-512 and BLAKE-384 use
    64 bit words and produce digest sizes of 512 bits and 384 bits, respectively.
    The BLAKE2 hash function, based on BLAKE, was announced in 2012\. The BLAKE3 hash
    function, based on BLAKE2, was announced in 2020\. BLAKE2 is a cryptographic hash
    function **faster than MD5, SHA-1, SHA-2, and SHA-3** (Fig. [3.4](#Fig4)), yet
    is at least as secure as the latest standard SHA-3 [[11](#CR11)].![../images/501530_1_En_3_Chapter/501530_1_En_3_Fig4_HTML.png](../images/501530_1_En_3_Chapter/501530_1_En_3_Fig4_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 3.4
  prefs: []
  type: TYPE_NORMAL
- en: Hash functions speed [[10](#CR10)]
  prefs: []
  type: TYPE_NORMAL
- en: '3.2 Integrity: Digital Signature'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In digital signature, we reverse the role of public and private keys. An encrypted
    hash is called a “digital signature” as shown in Fig. [3.5](#Fig5). Digital signature
    is used I e-commerce. For the real system, we are sending the message with the
    digital signature as shown in Fig. [3.6](#Fig6).![../images/501530_1_En_3_Chapter/501530_1_En_3_Fig5_HTML.png](../images/501530_1_En_3_Chapter/501530_1_En_3_Fig5_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 3.5
  prefs: []
  type: TYPE_NORMAL
- en: Digital signature
  prefs: []
  type: TYPE_NORMAL
- en: '![../images/501530_1_En_3_Chapter/501530_1_En_3_Fig6_HTML.png](../images/501530_1_En_3_Chapter/501530_1_En_3_Fig6_HTML.png)'
  prefs: []
  type: TYPE_IMG
- en: Fig. 3.6
  prefs: []
  type: TYPE_NORMAL
- en: Sending the message with the digital signature
  prefs: []
  type: TYPE_NORMAL
- en: 3.3 Authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Authentication answers the following question “how does a receiver know that
    remote communicating entity is who it is claimed to be?”. Authentication ensures
    that message has not been altered. Message is from alleged sender. Message sequence
    is unaltered. An example to show an authenticated email is shown in Fig. [3.7](#Fig7)
    where Alice wants to provide sender authentication message integrity, so Alice
    digitally signs message and sends both message and digital signature.![../images/501530_1_En_3_Chapter/501530_1_En_3_Fig7_HTML.png](../images/501530_1_En_3_Chapter/501530_1_En_3_Fig7_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 3.7
  prefs: []
  type: TYPE_NORMAL
- en: Authenticated email
  prefs: []
  type: TYPE_NORMAL
- en: 3.3.1 HDCP
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: HDCP is an acronym for High-Bandwidth Digital Content Protection. HDCP is a
    specification developed by Intel Corporation to protect digital entertainment
    content across the DVI/HDMI interface.
  prefs: []
  type: TYPE_NORMAL
- en: Digital Content Protection LLC (DCP) is the organization that licenses HDCP.
    How HDCP works is explained in Fig. [3.8](#Fig8). Each HDCP transmitter and receiver
    has 40 unique 56 bit private keys. These keys are provided by DCP to licensed
    HDCP chip vendors, who preload the keys onto the chips before selling them to
    device manufacturers. These keys must never leave the chip and may not be read
    by any other device.![../images/501530_1_En_3_Chapter/501530_1_En_3_Fig8_HTML.png](../images/501530_1_En_3_Chapter/501530_1_En_3_Fig8_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 3.8
  prefs: []
  type: TYPE_NORMAL
- en: How HDCP works. **It consists of authentication, data encryption**
  prefs: []
  type: TYPE_NORMAL
- en: Each HDCP chip also has a public 40 bit value known as the Key Selection Vector
    (KSV). Each KSV consists of 20 binary 1 s and 20 binary 0 s. The KSVs and keys
    of all licensed HDCP devices are mathematically related according to a cryptographic
    key exchange protocol. In this scheme, any two licensed devices can swap KSVs
    and use them, along with their private keys, to come up with a shared secret key.
    This shared key can be used to encrypt and decrypt the TMDS stream.
  prefs: []
  type: TYPE_NORMAL
- en: 3.3.2 CAPTCHA Codes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: CAPTCHA is a verification process that requires users to enter a predetermined
    code. CAPTCHA stands for *Completely Automated Public Turing test to tell Computers
    and Humans Apart*. CAPTCHA exists to prevent spam from automated form submissions
    that can fill your site with junk postings, spam user accounts, or worse feel
    for security holes to be exploited on your website. CAPTCHAs work by providing
    a question that is simple for a human to answer but difficult for a bot to answer.
    Different types of CAPTCHAs have been developed, including simple math questions
    and classification problems [[12](#CR12)].
  prefs: []
  type: TYPE_NORMAL
- en: '3.4 Availability: Intrusion Detection'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 3.4.1 Artificial Immune System
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Any human are exposed to a huge range of harmful microorganisms (pathogens
    or antigens) which can be either single cell or multicellular such as bacteria,
    parasites, and viruses. These microorganisms can damage the human body. The human
    natural immune system (NIS) is a very complex defense system that can prevent
    this damage. There is no central organ controlling the functionality of the immune
    system. The parts of the NIS are:'
  prefs: []
  type: TYPE_NORMAL
- en: '1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Blood: white blood cells in particular.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Lymph nodes: stores T and B cells and **traps** antigens/pathogens.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '3.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Thymus Gland: produces T Lymphocytes that circulating throughout the body looking
    for abnormalities.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '4.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Bone Marrow: produces B lymphocytes.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Immune organs as positioned throughout the body are shown in Fig. [3.9](#Fig9).![../images/501530_1_En_3_Chapter/501530_1_En_3_Fig9_HTML.png](../images/501530_1_En_3_Chapter/501530_1_En_3_Fig9_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 3.9
  prefs: []
  type: TYPE_NORMAL
- en: Immune organs are positioned throughout the body
  prefs: []
  type: TYPE_NORMAL
- en: The immune system has a learning phase over the years. Every element that can
    be recognized by the immune system is called an ***antigen*** **.** The cells
    that originally belong to our body and are harmless to its functionality are termed
    *(****self-antigens***), while the disease causing elements are named (***non-self-antigens***).
    As the body is attacked by certain microorganisms, the immune system memorizes
    them to be able to differentiate between foreign cells and the body cells.
  prefs: []
  type: TYPE_NORMAL
- en: The immune system is composed of two different cells which are called B cell
    and T cell. These two types of cells are rather similar but differ with relation
    to how they recognize antigens and by their functional roles. B cells can recognize
    antigens in the blood stream, while T cells require antigens to be presented by
    other accessory cells. Antigens are covered with molecules, named *epitopes.*
    These allow them to be recognized by the receptor molecules on the surface of
    B cells, called *antibodies (Ab).*
  prefs: []
  type: TYPE_NORMAL
- en: 'NIS is multilayered system. The human immune system (HIS) consists of three
    levels: skin, innate immunity, and adaptive immunity. The skin is the first barrier.
    The second barrier is physiological conditions such as temperature which provides
    inappropriate living conditions for harmful organisms. Once pathogens have entered
    the body, they are dealt with by the innate such as phagocytes which are cells
    that protect the body by ingesting harmful foreign particles and by the acquired
    immune response system (lymphocyte) which is considered as a detector.'
  prefs: []
  type: TYPE_NORMAL
- en: Pathogens are detected when a molecular bond is established between the pathogen
    and receptors that cover the surface of the lymphocyte. The number of receptors
    that bind to pathogens will determine the affinity that the lymphocyte has for
    a given pathogen. If a bond is very likely to occur, then many receptors will
    bind to pathogen epitopes, resulting in a high affinity for that pathogen; if
    a bond is unlikely to occur, then few receptors will bind to epitopes, and the
    lymphocyte will have a low affinity for that pathogen. Lymphocytes can only be
    activated by a pathogen if the lymphocyte’s affinity for the pathogen exceeds
    a certain affinity threshold. The layers are shown in Fig. [3.10](#Fig10). How
    B cells recognizes an antigen is shown in Fig. [3.11](#Fig11) and an illustrative
    example is shown in Fig. [3.12](#Fig12). Moreover, Fig. [3.13](#Fig13) shows the
    binding process.![../images/501530_1_En_3_Chapter/501530_1_En_3_Fig10_HTML.png](../images/501530_1_En_3_Chapter/501530_1_En_3_Fig10_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 3.10
  prefs: []
  type: TYPE_NORMAL
- en: Layers of protection in the human body
  prefs: []
  type: TYPE_NORMAL
- en: '![../images/501530_1_En_3_Chapter/501530_1_En_3_Fig11_HTML.png](../images/501530_1_En_3_Chapter/501530_1_En_3_Fig11_HTML.png)'
  prefs: []
  type: TYPE_IMG
- en: Fig. 3.11
  prefs: []
  type: TYPE_NORMAL
- en: B cell recognizes an antigen
  prefs: []
  type: TYPE_NORMAL
- en: '![../images/501530_1_En_3_Chapter/501530_1_En_3_Fig12_HTML.png](../images/501530_1_En_3_Chapter/501530_1_En_3_Fig12_HTML.png)'
  prefs: []
  type: TYPE_IMG
- en: Fig. 3.12
  prefs: []
  type: TYPE_NORMAL
- en: (**a**) Lymphocyte recognizes the red pathogen, (**b**) lymphocyte does not
    recognize the red pathogen
  prefs: []
  type: TYPE_NORMAL
- en: '![../images/501530_1_En_3_Chapter/501530_1_En_3_Fig13_HTML.png](../images/501530_1_En_3_Chapter/501530_1_En_3_Fig13_HTML.png)'
  prefs: []
  type: TYPE_IMG
- en: Fig. 3.13
  prefs: []
  type: TYPE_NORMAL
- en: Pathogens are detected when a molecular bond is established between the pathogen
    and receptors that cover the surface of the lymphocyte
  prefs: []
  type: TYPE_NORMAL
- en: In the 1990s**,** **artificial immune system (AIS)** that is inspired by the
    natural or biological immune system has emerged as a new branch in computational
    intelligence systems. AIS as a connecting two domains are shown in Fig. [3.14](#Fig14).
    Until now a significant number of AIS-based algorithms have been developed for
    different applications such as pattern recognition, computer security, fault detection,
    and so many other applications [[13](#CR13)–[30](#CR30)]. In this paper and for
    the first time, AIS is proposed for security at RTL level. The proposed system
    is implemented by Verilog and tested on Xilinx FPGA as it provides an efficient
    and flexible platform for fast implementation of hardware architecture and fast
    reprogramming and experimental testing of various revised versions of the same
    hardware architectures. Other artificial machine learning algorithms can be used
    too [[31](#CR31)].![../images/501530_1_En_3_Chapter/501530_1_En_3_Fig14_HTML.png](../images/501530_1_En_3_Chapter/501530_1_En_3_Fig14_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 3.14
  prefs: []
  type: TYPE_NORMAL
- en: AIS is connecting two domains
  prefs: []
  type: TYPE_NORMAL
- en: Three basic concepts in artificial immune system (AIS) are affinity, clonal
    selection algorithm, and negative selection algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: A.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Affinity
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In AIS, the affinity between antibodies and antigens is calculated using Euclidean
    distance.
  prefs: []
  type: TYPE_NORMAL
- en: If the coordinates of an antibody are given by:![$$ \mathrm{Ab}=\left({\mathrm{Ab}}_1,{\mathrm{Ab}}_2,\dots,
    {\mathrm{Ab}}_{\mathrm{n}}\right) $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equ3.png)(3.3)and
    the coordinates of an antigen are given by:![$$ \mathrm{Ag}=\left({\mathrm{Ag}}_1,{\mathrm{Ag}}_2,\dots,
    {\mathrm{Ag}}_{\mathrm{n}}\right) $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equ4.png)(3.4)then
    the distance between them is obtained by the following equation:![$$ \mathrm{D}=\sqrt{\sum
    \limits_{i=o}^n{\left(\mathrm{A}{b}_i-\mathrm{A}{g}_i\right)}^2\;} $$](../images/501530_1_En_3_Chapter/501530_1_En_3_Chapter_TeX_Equ5.png)(3.5)
  prefs: []
  type: TYPE_NORMAL
- en: B.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Negative Selection Algorithm and **Clonal Selection**
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The negative selection algorithm is the main algorithm used for NIS. *P* is
    the self set. *C* is the generated candidate to be non-self. *M* is the detector.
    *P** is the patterns to be protected (suspicion). The algorithm can be summarized
    as follows (Fig. [3.15](#Fig15)):'
  prefs: []
  type: TYPE_NORMAL
- en: '1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generate random candidate elements (*C*).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compare the elements in *C* with the elements in *P*. If a match occurs, then
    reject it. It is a self. Else store this element of *C* in the detector set *M*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '3.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After generating the set of detectors (*M*), the next stage of the algorithm
    consists in monitoring the system for the presence of non-self patterns. For all
    elements of the detector set, that corresponds to the non-self patterns, check
    if it matches an element of *P** and, if yes, then a non-self pattern was recognized.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '4.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An action has to be taken. When a B-cell receptor recognizes a non-self antigen
    with a certain affinity, it is selected to proliferate and produce antibodies
    in high volumes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '5.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The activated B cells with high antigenic affinities are selected to become
    memory cells with long life spans. These memory cells are pre-eminent in future
    responses to this same antigenic pattern, or a similar one this is called **clonal
    selection**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![../images/501530_1_En_3_Chapter/501530_1_En_3_Fig15_HTML.png](../images/501530_1_En_3_Chapter/501530_1_En_3_Fig15_HTML.png)'
  prefs: []
  type: TYPE_IMG
- en: Fig. 3.15
  prefs: []
  type: TYPE_NORMAL
- en: The **negative selection algorithm is the main algorithm used for NIS**. (**a**)
    Generating the set of detectors. (**b**) Monitoring for the presence of undesired
    (non-self) patterns. *P* is the self set. *C* is the generated candidate to be
    non-self. *M* is the detector. *P** is the patterns to be protected (suspicion)
  prefs: []
  type: TYPE_NORMAL
- en: 3.5 Access Control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Security levels and solutions are summarized in Table [3.2](#Tab2) and Fig.
    [3.16](#Fig16). Passwords are shared secret between two parties. Smart cards  are
    electronics embedded in card capable of providing long passwords or satisfying
    challenge. It may have display to allow reading of password or can be plugged
    in directly. Biometrics uses of one or more intrinsic physical or behavioral traits
    to identify someone such as fingerprint reader, palm reader, retinal scan, or
    biometrics in general. A VPN, or virtual private network, allows you to create
    a secure connection to another network over the Internet. VPNs can be used to
    access region-restricted websites, shield your browsing activity from prying eyes
    on public Wi-Fi, and more. When you connect your computer (or another device,
    such as a smartphone or tablet) to a VPN, the computer acts as if it’s on the
    same local network as the VPN. All your network traffic is sent over a secure
    connection to the VPN. Because your computer behaves as if it’s on the network,
    this allows you to securely access local network resources even when you’re on
    the other side of the world. You’ll also be able to use the Internet as if you
    were present at the VPN’s location, which has some benefits if you’re using pubic
    Wi-Fi or want to access geo-blocked websites [[32](#CR32)].Table 3.2
  prefs: []
  type: TYPE_NORMAL
- en: Security levels and solutions
  prefs: []
  type: TYPE_NORMAL
- en: '| Security level | Solution |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Low | Something you know (pin, password) |'
  prefs: []
  type: TYPE_TB
- en: '| Medium | Something you know + something you have (access card) |'
  prefs: []
  type: TYPE_TB
- en: '| High | Something you know + something you have + something you are (fingerprint)
    |'
  prefs: []
  type: TYPE_TB
- en: '![../images/501530_1_En_3_Chapter/501530_1_En_3_Fig16_HTML.png](../images/501530_1_En_3_Chapter/501530_1_En_3_Fig16_HTML.png)'
  prefs: []
  type: TYPE_IMG
- en: Fig. 3.16
  prefs: []
  type: TYPE_NORMAL
- en: 'Access control: security levels'
  prefs: []
  type: TYPE_NORMAL
- en: '3.6 Non-repudiation: Trusted Third Party'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The ability to ensure that a party to a contract or a communication cannot deny
    the authenticity of their signature on a document or the sending of a message
    that they originated. You can’t deny doing something you did. To mitigate the
    risk of people repudiating their own signatures, the standard approach is to involve
    a trusted third party. For digital information, the most commonly employed **TTP**
    is a certificate authority, which issues public key certificates. A public key
    certificate can be used by anyone to verify digital signatures without a shared
    secret between the signer and the verifier. The role of the certificate authority
    is to authoritatively state to whom the certificate belongs, meaning that this
    person or entity possesses the corresponding private key. However, a digital signature
    is forensically identical in both legitimate and forged uses. Someone who possesses
    the private key can create a valid digital signature [[33](#CR33)].
  prefs: []
  type: TYPE_NORMAL
- en: 3.7 Conclusions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter explores different cryptography concepts such as authentication,
    integrity, availability, access control, and non-repudiation. It presents concepts
    of digital signatures, hash functions, and message authentication codes (MACs).
  prefs: []
  type: TYPE_NORMAL
