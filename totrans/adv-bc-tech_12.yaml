- en: © The Author(s), under exclusive license to Springer Nature Switzerland AG 2022Y.
    Maleh et al. (eds.)Advances in Blockchain Technology for Cyber Physical SystemsInternet
    of ThingsTechnology, Communications and Computing[https://doi.org/10.1007/978-3-030-93646-4_12](https://doi.org/10.1007/978-3-030-93646-4_12)
  prefs: []
  type: TYPE_NORMAL
- en: Developing Instrument for Investigation of Blockchain Technology
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dmitry Kushnir^([1](#Aff7)  ), Maxim Kovtsur^([1](#Aff7)), Ammar Muthanna^([1](#Aff7)),
    Anastasiia Kistruga^([1](#Aff7)), Mark Akilov^([1](#Aff7)) and Anton Batalov^([1](#Aff7))(1)M.
    A. Bonch-Bruevich Saint Petersburg State University of Telecommunications, Saint
    Petersburg, RussiaKeywordsBlockchainDistributed databaseHash functionMerkle rootNoncePrivate
    keyPublic keyConsensusProof of workCPS
  prefs: []
  type: TYPE_NORMAL
- en: 1 Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Blockchain originally appeared as a distributed registry of the Bitcoin system
    [[1](#CR1)]. Such a register allowed to solve the problem of double spending of
    cryptocurrency. One of the key features of the blockchain is the immutability
    of the distributed registry. This property allows for the exchange of data between
    interested parties, ensuring trust among the initially distrustful parties of
    information interaction. The rapid success of Bitcoin has attracted a lot of attention
    of researchers to the new technology underlying it, the blockchain. Despite the
    fact that the blockchain originated as an infrastructure for cryptocurrency, it
    has become a technology of distributed systems, which has led to a shift in emphasis
    from centralized systems to decentralized ones. A decentralized and open architecture
    is formed on the basis of the blockchain, since it is implemented on a large number
    of distributed nodes, each of which contains a copy of cryptographically linked
    records. Such records are organized into blocks agreed by some consensus protocols
    among blockchain nodes. A cryptographically linked block chain, together with
    a distributed consensus protocol, ensures the immutability of the blockchain.
    The openness and immutability of the blockchain allow anyone to check the history
    of records in the blockchain, which prevents any attempts to interfere with the
    stored data and protects the information from being changed after being added
    to the blocks. Thus, trust among untrusted parties of information interaction
    can also be created on the basis of a decentralized architecture. The decentralized,
    open, and unmodifiable nature of the blockchain makes it a transparent, publicly
    verifiable system. In addition, since records are replicated to many distributed
    nodes, the blockchain architecture allows you to get rid of the problem of a single
    point of failure. The combination of these properties allows us to consider the
    blockchain technology as the basis for a wide range of applications. Such applications
    can be solutions for the Internet of things (IoT) and cyber-physical systems (CPS)
    in which the possibility of interaction between a huge number of heterogeneous
    devices is required. Traditional centralized solutions may face such difficulties
    as distrust of information exchange nodes to each other, a huge number of interactions,
    the presence of a single point of failure, and a number of others. If we pay attention
    to CPS, it is also important to note that many existing industrial networks have
    only now begun to depart from the standards created in the 1970s of the last century,
    and the search for solutions based on blockchain can potentially effectively solve
    many problems in this area.
  prefs: []
  type: TYPE_NORMAL
- en: The widespread use of various systems that use or claim the use of blockchain
    for the implementation of certain tasks creates a new reality in the modern digital
    world. If the first of the well-known blockchain implementations was associated
    with the creation of a cryptocurrency [[1](#CR1)], then today’s projects have
    long gone beyond this narrow framework. A huge number of projects [[2](#CR2)–[4](#CR4)]
    created on the basis of long-existing platforms or their own implementations create
    significant difficulties in classifying certain systems and evaluating potential
    opportunities. In addition, it makes sense to note that from time to time there
    are projects that only claim to be based on a functioning blockchain or any other
    mechanisms with similar functionality, but do not have the appropriate technologies.
    Such projects try to exploit this problem and attract potential customers to themselves,
    diverting significant resources from real tasks. One of the most famous examples
    of this kind is a pyramid scheme, which was covered by the pseudo-cryptocurrency
    OneCoin [[5](#CR5)].
  prefs: []
  type: TYPE_NORMAL
- en: In addition, it is important to note that even the presence of a successfully
    working blockchain does not guarantee the success of a project implemented on
    its basis. Depending on the application, different parameters may be required
    from the blockchain. Such parameters can be the amount of data that can be written
    to blocks and speed and delay during recording. High speed of reaction to events,
    in particular, is necessary for many solutions in IoT and in CPS, for example,
    in the Internet of vehicles (IoV). It is also necessary to keep in mind that in
    some cases, the transition to the blockchain or an unsuccessful choice of its
    specific implementation can only increase overhead costs and efficiency of interaction
    within the system. However, small improvements to traditional solutions could
    more effectively overcome existing problems.
  prefs: []
  type: TYPE_NORMAL
- en: In this regard, one of the tasks facing researchers is the creation and active
    use of tools that implement and analyze the main mechanisms underlying the construction
    of the blockchain. In the future, this will allow us to build the formation of
    approaches that make it possible to assess the availability and effectiveness
    of certain blockchain construction technologies in software to solve specific
    problems when building IoT/CPS solutions.
  prefs: []
  type: TYPE_NORMAL
- en: 2 Problematics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Currently, the construction of various systems operating on the basis of the
    blockchain has become a noticeable phenomenon in digital data storage systems.
    In this regard, an important aspect is the analysis of existing and future solutions
    for the correct implementation of the declared functionality and, in addition,
    the very fact of the presence of such functionality.
  prefs: []
  type: TYPE_NORMAL
- en: A number of studies [[6](#CR6), [7](#CR7)] concentrate on the possibility of
    building various blockchain-based application solutions in the field of IoT and
    CPS. A feature of such developments is the focus on the already-made selection
    in advance of one or two or three specific distributed ledgers for IoT/CPS applications,
    such as Ethereum, Hyperledger Fabric, and IOTA. On the one hand, this approach
    is justified, since it is impossible to build a solution without taking into account
    the peculiarities of specific components, but on the other hand, such an approach
    can potentially limit the functionality of the final solution by excluding certain
    mechanisms of blockchain formation in the solutions being developed.
  prefs: []
  type: TYPE_NORMAL
- en: However, there are studies in the field of building solutions with a choice
    of blockchain for IoT in smart city, in which the development of their own blockchain
    architecture is carried out [[8](#CR8)]. The development is justified by the redundancy
    of the traditional blockchain and the high computational load on individual nodes
    of the system, which a significant number of smart city elements cannot afford.
    This approach may be quite appropriate in some applications, but it can significantly
    complicate the development of the final solution, introduce additional errors
    into it, and delay implementation.
  prefs: []
  type: TYPE_NORMAL
- en: In this regard, the question of the possibility of a deliberate selection or
    development of a blockchain with the necessary characteristics in the framework
    of solving a specific problem remains relevant. Also, understanding the essence
    of the functioning of the blockchain is important for all participants in building
    a complete solution from developers at all levels to service personnel and even
    users, and only then can the maximum effect be achieved from the implementation
    of distributed ledgers in various IoT/CPS solutions.
  prefs: []
  type: TYPE_NORMAL
- en: One of the approaches that allows us to solve some of these problems is a demonstration
    implementation of the main functionality associated with the formation of a block
    chain. The projects existing in the research area in most cases are ready-made
    solutions that are difficult to analyze. This applies both to cryptocurrencies
    and related blockchains [[1](#CR1), [9](#CR9), [10](#CR10)] and to other decentralized
    systems [[11](#CR11)].
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of solutions, both educational and demonstration, and researches,
    which allow analyzing the main stages of block formation, node interaction, and
    consensus building [[12](#CR12)–[14](#CR14)]. However, all these solutions either
    simplify the essence of block formation too much or work for the user in the form
    of a black box, which, in fact, without changing the source code, does not allow
    them to be used effectively for research purposes. Table [1](#Tab1) summarizes
    the main characteristics of the designated solutions in the field of research
    modeling of blockchain construction. In this paper, we analyze a software model
    of blockchain formation, designed to partially fill these gaps.Table 1
  prefs: []
  type: TYPE_NORMAL
- en: Characteristics of solutions in the field of research modeling of blockchain
    construction
  prefs: []
  type: TYPE_NORMAL
- en: '| Solutions | Config/install required | Ability to add nodes arbitrarily |
    Implementation of the consensus-building mechanism | Viewing block parameters
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Blockchain demo 2.0 | X | √ | X | ~ |'
  prefs: []
  type: TYPE_TB
- en: '| Visual demo of blockchain technology | X | X | ~ | √ |'
  prefs: []
  type: TYPE_TB
- en: '| Building a blockchain by Daniel van Flyman | √ | √ | ~ | ~ |'
  prefs: []
  type: TYPE_TB
- en: √ yes, X no, ~ partially implemented or requires code editing for analysis
  prefs: []
  type: TYPE_NORMAL
- en: 'Developed tools should have the following functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: Do not require complex configuration and installation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simulate a decentralized distributed system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be able to add nodes arbitrarily
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conduct transactions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Send transactions to all network participants
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check transactions received from other network participants
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support a consensus-building mechanism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create blocks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Send blocks for verification
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check blocks, including displaying their parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add blocks to the database, if the check is successful
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Have a graphical representation for clarity of work
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3 Materials and Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Various development/programming environments can be chosen to study the methods
    of building a blockchain, but from the point of view of development efficiency
    and a number of requirements for speed indicators due to the implementation of
    different nodes of a distributed network on one researcher’s computing device,
    the choice of C++ with the cross-platform Qt framework looks more preferable.
    For this study, the task of ensuring cross-platform compatibility is important
    from the point of view of expanding the use of the proposed methods to various
    platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Since the study of the main stages of building a blockchain requires the implementation
    of cryptographic functions, a library is needed in which there would be functionality
    for working with cryptography. OpenSSL is a universal cryptographic library. It
    supports almost all low-level hashing, encryption, and electronic signature algorithms
    and also implements most popular cryptographic standards. OpenSSL is written in
    the C programming language, which allows it to be used in C++ projects and guarantees
    high performance and speed of work.
  prefs: []
  type: TYPE_NORMAL
- en: The possibility of researching the constructed block chain assumes that each
    node stores blocks, both created independently and received from other participants
    (in this analysis, each node is assumed to be complete, i.e., it stores the entire
    block chain). In this case, the research is supposed to be carried out within
    the framework of a single computing device, and all nodes are formed on the same
    computer (see Fig. [1](#Fig1)). This condition allows you to approach the choice
    of a data storage system for the block chain on each node using an embedded cross-platform
    database management system (DBMS), such as SQLite. Choosing this solution for
    data storage allows you to potentially increase the performance of the final solution,
    in particular, due to the absence of a client-server architecture, which is not
    required in this case.![](../images/513458_1_En_12_Chapter/513458_1_En_12_Fig1_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 1
  prefs: []
  type: TYPE_NORMAL
- en: Implementation of all network nodes within the framework of the developed toolkit
  prefs: []
  type: TYPE_NORMAL
- en: 4 Methodology for Analyzing Blockchain Model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As part of the study, it is necessary to determine the functions that will be
    analyzed [[15](#CR15), [16](#CR16)]. The corresponding functions are shown in
    Fig. [2](#Fig2).![](../images/513458_1_En_12_Chapter/513458_1_En_12_Fig2_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 2
  prefs: []
  type: TYPE_NORMAL
- en: The main stages of modeling a decentralized distributed system
  prefs: []
  type: TYPE_NORMAL
- en: 'The necessary functions within the framework of the developed solution include
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Forming nodes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating a secret key.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculating the public key.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Formation of the node address.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Generating data for writing to blocks:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preparation of the data itself.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking the correctness/balance.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a digital signature.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Distribution of the prepared data to all nodes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking the received data from other nodes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Forming a block:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collecting data from other nodes in the preliminary version of the block
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a Merkle tree for block data
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding service information to a block, including the hash of the previous block
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting the nonce value to fulfill the condition for the hash value at the
    current complexity parameter
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Distribution of the received block to other nodes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking the blocks received from other nodes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding correct blocks to the blockchain of the current node
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The nodes will be responsible for the main functionality, i.e., work with the
    formation of data for writing to blocks (transactions), blocks, and the database.
    Each node will have its own database to demonstrate that the network is coming
    to a consensus. In checking, the databases must be the same.
  prefs: []
  type: TYPE_NORMAL
- en: The nodes and the program core will model a decentralized distributed system
    [[17](#CR17)]; the nodes will communicate with each other using the core. In this
    case, the kernel can be represented as a data transfer medium between network
    nodes.
  prefs: []
  type: TYPE_NORMAL
- en: The control will be carried out using the graphical interface. Control signals
    will be sent to the program core, and the core will either redirect the signal
    to the nodes or perform other necessary actions.
  prefs: []
  type: TYPE_NORMAL
- en: The graphical interface has the form shown in Fig. [3](#Fig3).![](../images/513458_1_En_12_Chapter/513458_1_En_12_Fig3_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 3
  prefs: []
  type: TYPE_NORMAL
- en: The main window of the program
  prefs: []
  type: TYPE_NORMAL
- en: 'The interface has the following elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: “Add Node” button – this adds a new node.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The “Start” button – when pressed, all added nodes begin to continuously calculate
    blocks.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '3.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The “Stop” button – this stops the calculation of blocks.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '4.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The “Accept” button – this applies the hash complexity specified in (5) for
    the block.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '5.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The widget for entering the complexity of the calculated block hash is set by
    a number from 2 to 8\. This number determines the number of zeros at the beginning
    for a 16-bit hash entry.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '6.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: “Send Tokens” – this opens a window for making a transaction.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '7.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: “Make block” – when clicked, all nodes start calculating the block hash, but
    only once. This function is used for step-by-step operation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '8.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The log field of the selected node – it displays information for tracking the
    current operation of this node.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '9.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tabs for switching between network nodes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '10.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Information about the currently selected node (Fig. [4](#Fig4)).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](../images/513458_1_En_12_Chapter/513458_1_En_12_Fig4_HTML.png)'
  prefs: []
  type: TYPE_IMG
- en: Fig. 4
  prefs: []
  type: TYPE_NORMAL
- en: Window for preparing data for entering into the block (performing a transaction)
  prefs: []
  type: TYPE_NORMAL
- en: '1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Information about the sender
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Field for entering the recipient’s address
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '3.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Input field for the number of tokens to be transferred
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '4.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Send button
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '5.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Cancel button
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To implement the program, six classes were created in total, of which three
    main classes can be distinguished, mainCore, acting as the application core (see
    Fig. [5](#Fig5)); MainWindow, representing the main window (see Fig. [5](#Fig5));
    and Client, implementing node functions (see Fig. [6](#Fig6)).![](../images/513458_1_En_12_Chapter/513458_1_En_12_Fig5_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 5
  prefs: []
  type: TYPE_NORMAL
- en: Diagram of the mainCore class and the MainWindows class
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/513458_1_En_12_Chapter/513458_1_En_12_Fig6_HTML.png)'
  prefs: []
  type: TYPE_IMG
- en: Fig. 6
  prefs: []
  type: TYPE_NORMAL
- en: Diagram of the Client class
  prefs: []
  type: TYPE_NORMAL
- en: Let us consider some features of the developed tools.
  prefs: []
  type: TYPE_NORMAL
- en: In Qt, the signal and slot technique is used for communication between objects.
    A signal is emitted when a certain event occurs. A slot is a function called in
    response to a certain signal. The signal and slot mechanism is a central feature
    of Qt and probably the part that differs the most from the functions provided
    by other frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: Signals are emitted by an object when its internal state has changed in any
    way. Signals are public functions and can be emitted from anywhere, but it is
    recommended to emit them only from the class that defines the signal and its subclasses.
  prefs: []
  type: TYPE_NORMAL
- en: The slot is called when the associated signal is issued. Slots are ordinary
    C++ functions and can be called in the usual way; their only feature is that signals
    can be connected to them.
  prefs: []
  type: TYPE_NORMAL
- en: 'mainCore and MainWindow interact with each other with the following signals:
    news, generateWallet, wallet, start, changeBalance, sendTokens, stop, makeBlock,
    setHashLevel, and logMessage.'
  prefs: []
  type: TYPE_NORMAL
- en: The generateWallet(int num) signal is emitted when the “add node” button is
    pressed. This signal is associated with the addNode slot(int num) and passes the
    “int num” parameter – this parameter means the number of the nodes to be added,
    and it is needed for interaction between the nodes and the graphical interface.
    When the generateWallet signal is emitted, the “addNode” slot is executed. Let
    us look at it in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: “addNode” creates new nodes. Keys are generated for new nodes, and this is where
    the OpenSSL library is used. The EC_KEY_new_by_curve_name () function allocates
    memory and binds the EC_KEY object to the specified curve. In our case, the secp256k1
    curve is selected. EC_KEY_generate_key () generates a new private and public key.
    We get the address by taking the SHA-256 hash from the public key.
  prefs: []
  type: TYPE_NORMAL
- en: The QSqlDatabase db object is used to create a database for a new node. The
    database is created under the name corresponding to the public key of the node.
  prefs: []
  type: TYPE_NORMAL
- en: Next, a new node is created, and its initialization is performed using the generated
    keys. For each new node, a separate thread is created in which it will work.
  prefs: []
  type: TYPE_NORMAL
- en: The client type object shown in Fig. [7](#Fig7) simulates client actions and
    also uses the startBlock slot and the makeBlock function to generate new blocks.![](../images/513458_1_En_12_Chapter/513458_1_En_12_Fig7_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 7
  prefs: []
  type: TYPE_NORMAL
- en: Client type object
  prefs: []
  type: TYPE_NORMAL
- en: First, a signal is emitted with a log message that the calculation of blocks
    begins, and then the makeBlock () function is called, shown in Fig. [8](#Fig8).![](../images/513458_1_En_12_Chapter/513458_1_En_12_Fig8_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 8
  prefs: []
  type: TYPE_NORMAL
- en: makeBlock function
  prefs: []
  type: TYPE_NORMAL
- en: In this function, the block header is formed, and creator is initialized by
    the block header structure, and the startCreateHashBlock () signal is emitted.
  prefs: []
  type: TYPE_NORMAL
- en: Creator is an object of the HashBlockCreator type shown in Fig. [9](#Fig9).
    HashBlockCreator is a class created for selecting a hash of a given complexity.
    The init() method initializes a new block header. The hash is selected in the
    start slot, and this slot is called when the start Create Hash Block () signal
    is triggered.![](../images/513458_1_En_12_Chapter/513458_1_En_12_Fig9_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 9
  prefs: []
  type: TYPE_NORMAL
- en: HashBlockCreator source code
  prefs: []
  type: TYPE_NORMAL
- en: In this slot, the block header is hashed, the block structure is written to
    the QByteArray header object, and hashing is performed using the QCryptographicHash::hash
    function, according to the Sha-256 algorithm. The resulting hash is converted
    to a 16-bit form and checked. If the received hash does not satisfy the specified
    complexity and there is no signal that it is necessary to stop the hash selection,
    the actions are repeated, but the fields of the block header structure such as
    nonce and timestamp are changed. The nonce field is incremented by 1, and timestamp
    gets a new timestamp. Otherwise, it is checked whether a stop signal has been
    received. If not, a createdCorrectHash signal is emitted that a hash of the desired
    complexity has been selected.
  prefs: []
  type: TYPE_NORMAL
- en: The start slot is executed in a separate thread, so that at the time of hash
    selection, the node can process transactions and receive signals from other nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 5 Developed Application of the Analysis Blockchain Technique
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The tool for analyzing the main stages of building a blockchain at the first
    stage forms the necessary number of nodes involved in further research (Fig. [10](#Fig10)).![](../images/513458_1_En_12_Chapter/513458_1_En_12_Fig10_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 10
  prefs: []
  type: TYPE_NORMAL
- en: Adding new nodes. Checking the creation of the corresponding databases
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to create new blocks. Blocks can be created both automatically
    and step-by-step. Blocks are created, validated, and added to the node databases.
    The network comes to a consensus. This can be seen from the same data in the databases
    of the nodes.
  prefs: []
  type: TYPE_NORMAL
- en: For the possibility of a detailed study of the performed actions at each step
    of the simulation, all operations are saved in a log file for further analysis.
  prefs: []
  type: TYPE_NORMAL
- en: The introduction of arbitrary records into the blockchain in this simulation
    is implemented in the form of creating transactions. Transactions are formed,
    signed, added to blocks, and written to node databases. The balance of nodes changes,
    and tokens come to the destination address (Figs. [11](#Fig11) and [12](#Fig12)).![](../images/513458_1_En_12_Chapter/513458_1_En_12_Fig11_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 11
  prefs: []
  type: TYPE_NORMAL
- en: The balance of node number 2 before and after the formation of a new block
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/513458_1_En_12_Chapter/513458_1_En_12_Fig12_HTML.png)'
  prefs: []
  type: TYPE_IMG
- en: Fig. 12
  prefs: []
  type: TYPE_NORMAL
- en: Transaction records in the database
  prefs: []
  type: TYPE_NORMAL
- en: An important parameter for each blockchain system is the average block creation
    time and possible deviations from the expected value. These parameters can affect
    the time to reach a network consensus, the necessary time delays for recognition
    by system participants, and the possibility of certain types of attacks. In some
    technologies of blockchain formation, the main parameter that affects the formation
    time of the block creation is the complexity parameter. In the model under study,
    the complexity is set as the upper bound of the calculated hash value, given as
    the number of leading zeros in the hexadecimal representation of the boundary,
    and an additional parameter will be the number of nodes involved. The effect of
    complexity on the time of making entries in the distributed registry for a network
    of four nodes and complexity 6 is shown in Fig. [13](#Fig13), and for complexity
    7 in Fig. [14](#Fig14). The dots indicate the time spent on creating the next
    block in the system.![](../images/513458_1_En_12_Chapter/513458_1_En_12_Fig13_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 13
  prefs: []
  type: TYPE_NORMAL
- en: The time spread during the formation of blocks on difficulty 6
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/513458_1_En_12_Chapter/513458_1_En_12_Fig14_HTML.png)'
  prefs: []
  type: TYPE_IMG
- en: Fig. 14
  prefs: []
  type: TYPE_NORMAL
- en: The time spread during the formation of blocks on difficulty 7
  prefs: []
  type: TYPE_NORMAL
- en: The graphs clearly show the dependence of the average time spent on creating
    the next block on the complexity parameter with characteristic outliers corresponding
    to the Poisson distribution law.
  prefs: []
  type: TYPE_NORMAL
- en: 6 Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The analyzed tool for performing research on blockchain technologies combines
    the ease of use and the ability to track each step of building a blockchain with
    checking current parameters and obtaining aggregating data, which gives certain
    advantages over similar solutions considered earlier. The presented stages allow
    us to evaluate the possibilities of traditional approaches and the potential advantages
    of the latest developments in this area. The paper presents and studies, in particular,
    such components of this technology as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating keys to confirm the authenticity of entries in the distributed registry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Formation of nodes, i.e., participants of a decentralized network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing the network complexity parameter, to influence the average speed of
    generating records in a distributed registry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Construction of the Merkle tree, formation of the source block, and selection
    of the nonce parameter to obtain the final block of the system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking the created blocks for compliance with the current system rules by
    the block creator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Independent view of the status of the block chain at each node of the network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking the correctness of the created blocks by other participants of the
    distributed network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An important feature of the analysis is the ability to switch the mode from
    analyzing the general parameters of the system to the step-by-step execution mode
    and monitoring all parameters of operations at each completed step. Thus, the
    results presented in the paper allow, on the one hand, to advance in the field
    of evaluating the functionality of various implementations of blockchain construction
    methods and, on the other hand, to solve the problem of detailed analysis and
    demonstration of the capabilities of the fundamental components of blockchain
    technology. The result of the analysis of distributed registry methods and technologies
    underlying the implementation of the blockchain allows you to choose a solution
    for specific tasks in IoT/CPS or smart city.
  prefs: []
  type: TYPE_NORMAL
