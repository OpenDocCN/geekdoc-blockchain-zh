- en: Part 2\.
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第二部分
- en: '[Part 2](#part02) is all about smart contracts. This innovative technology
    has allowed Ethereum to move from single-purpose blockchains, supporting only
    cryptocurrencies, to multipurpose blockchains you can use to develop any decentralized
    application.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '[第二部分](#part02) 主要讲述智能合约。这种创新技术使得以太坊能够从单一用途的区块链，仅支持加密货币，转变为多用途的区块链，你可以用它来开发任何去中心化应用。'
- en: '[Chapter 5](kindle_split_017.xhtml#ch05) introduces Solidity, the most popular
    language for writing smart contracts on the Ethereum Virtual Machine. [Chapter
    6](kindle_split_018.xhtml#ch06) describes the structure of a typical smart contract
    through a sample crowdsale. This includes a constructor, state variables, functions,
    and events. Toward the end of this chapter, you’ll learn to generalize contract
    functionality through inheritance. [Chapter 7](kindle_split_019.xhtml#ch07) focuses
    on more advanced object-oriented features, such as abstract contracts and interfaces,
    which I introduce progressively so you can improve and extend the initial crowdsale
    application and make it more maintainable. This chapter also presents libraries,
    which provide another way to make contracts more maintainable. [Chapter 8](kindle_split_020.xhtml#ch08)
    explains how to deploy a smart contract to a public test network and interact
    with it through Web3, an Ethereum communication library; the Go Ethereum console;
    Node.js; and a web user interface. It also explains how to perform the same operations
    on a private network and on a mock network client, such as Ganache.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 5 章](kindle_split_017.xhtml#ch05) 介绍了 Solidity，是编写以太坊虚拟机上智能合约最受欢迎的语言。[第
    6 章](kindle_split_018.xhtml#ch06) 通过一个众售示例描述了典型智能合约的结构，包括构造函数、状态变量、函数和事件。在本章末尾，你将学习如何通过继承泛化合约功能。
    [第 7 章](kindle_split_019.xhtml#ch07) 关注更高级的面向对象特性，例如抽象合约和接口，我会逐步介绍，以便你可以改进和扩展初始众售应用，并使其更易于维护。本章还介绍了库，这是使合约更易于维护的另一方式。[第
    8 章](kindle_split_020.xhtml#ch08) 解释了如何将智能合约部署到公共测试网络，并通过 Web3（一个以太坊通信库）、Go Ethereum
    控制台、Node.js 和网页用户界面与其交互。它还解释了如何在私有网络和模拟网络客户端（如 Ganache）上执行相同的操作。'
- en: Chapter 5\. Programming smart contracts in Solidity
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 5 章。使用 Solidity 编程智能合约
- en: '|  |'
  id: totrans-4
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**This chapter covers**'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章内容涵盖**'
- en: Understanding EVM languages
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 EVM 语言
- en: Understanding the structure of a contract
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解合约结构
- en: Learning core Solidity syntax
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习 Solidity 核心语法
- en: '|  |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Thanks to SimpleCoin, the basic cryptocurrency you’ve been building, you’ve
    learned the basics of Solidity through example. By now, you know Solidity is a
    high-level EVM language that allows you to write contracts. You also know a smart
    contract (or, simply, contract) is equivalent to a class in other languages and
    contains state variables, a constructor, functions, and events. In this chapter,
    you’ll learn Solidity’s main language constructs in a more structured way and
    develop a progressively deeper understanding of the language.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢 SimpleCoin，这个你一直在构建的基本加密货币，你已经通过示例了解了 Solidity 的基础知识。到目前为止，你知道 Solidity 是一个允许你编写合约的高阶
    EVM 语言。你还知道智能合约（或简称合约）在其他语言中相当于一个类，并包含状态变量、构造函数、函数和事件。在本章中，你将更加结构化地学习 Solidity
    的主要语言结构，并逐步深入理解该语言。
- en: This chapter lays the foundation for the next chapter, where you’ll learn how
    to implement complex contracts and multicontract Dapps in Solidity. By the end
    of this chapter, you’ll be able to improve and extend SimpleCoin’s functionality
    with the knowledge you’ve acquired.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章为下一章奠定了基础，你将在其中学习如何使用 Solidity 实现复杂的合约和多合约 Dapps。在本章结束时，你将能够利用所学的知识改进和扩展 SimpleCoin
    的功能。
- en: 5.1\. EVM contract languages
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1. EVM 合约语言
- en: Before diving into Solidity, let’s take a little step back and explore briefly
    some alternative EVM languages. Solidity isn’t the only EVM high-level language
    for writing contracts. Although it’s the most popular option among Ethereum developers,
    mainly because it’s frequently upgraded, well maintained, and recommended in the
    official Ethereum documentation, other alternatives exist, namely LLL, Serpent,
    and Viper. Let’s see what these languages look like and when it would make sense
    to use them instead of Solidity.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入 Solidity 之前，让我们退后一步，简要探索一些其他的 EVM 语言。Solidity 并不是编写合约的唯一 EVM 高阶语言。尽管它是以太坊开发者中最受欢迎的选项，这主要是因为它经常升级，维护良好，并且在官方以太坊文档中被推荐，但还有其他替代方案，分别是
    LLL、Serpent 和 Viper。让我们看看这些语言的样子，以及何时使用它们而不是 Solidity 会有意义。
- en: 5.1.1\. LLL
  id: totrans-14
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.1.1. LLL
- en: 'LLL, whose acronym stands for lovely little language, is a Lisp-like language
    (which LLL also stands for) that provides low-level functions close to the EVM
    opcodes and simple control structures (such as `for`, `if`, and so on). These
    functions allow you to write low-level contract code without having to resort
    to handwriting EVM assembly. If you’ve ever seen Lisp code or you’re familiar
    with Clojure, you’ll recognize the distinctive prefix notation and heavy parentheses
    used in the following LLL listing:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: LLL，其缩写代表可爱的 little language，是一种类似Lisp的语言（LLL也代表）提供了接近EVM操作码的低级函数和简单的控制结构（如`for`、`if`等）。这些函数允许您编写不需要手动编写EVM汇编的低级合约代码。如果你曾经看过Lisp代码或者熟悉Clojure，你将会认出以下LLL列表中独特的前缀表示法和大量的括号：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '***1*** **Instructs the LLL compiler to evaluate expressions below this line
    in order**'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **指示LLL编译器按顺序评估下面的表达式**'
- en: '***2*** **Declares a variable named value at memory location 0x00**'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **在内存位置0x00声明一个名为value的变量**'
- en: '***3*** **Declares a function called dummy at memory location 0xbc23ecab**'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **在内存位置0xbc23ecab声明一个名为dummy的函数**'
- en: '***4*** **Defines a macro in the LLL compiler to return the code below it**'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **在LLL编译器中定义一个返回其下代码的宏**'
- en: '***5*** **Starts defining the function ‘dummy’**'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **开始定义‘dummy’函数**'
- en: '***6*** **Reads the location 0 of the data passed in when calling the function
    (call data) and stores it in a variable named value**'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** **读取传递给函数的数据的地址0（调用数据）并将其存储在一个名为value的变量中**'
- en: '***7*** **Returns 32 bytes from the variable value**'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7*** **从变量value中返回32字节**'
- en: 'This is roughly equivalent to the following Solidity code:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这大致相当于以下Solidity代码：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '|  |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Warning
  id: totrans-27
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: Strictly speaking, these two pieces of code aren’t entirely equivalent because
    the LLL code doesn’t check the function signature or prevent Ether transfer, among
    other things.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，这两段代码并不完全等价，因为LLL代码没有检查函数签名或防止以太币转账等功能。
- en: '|  |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: LLL was the first EVM language that the Ethereum core team provided because,
    given the similarity between how the stack-based Lisp language and the EVM work,
    it allowed them to deliver it more quickly than any other language. Currently,
    the main benefit of using LLL would be to get a more compact bytecode, which might
    be cheaper to run.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: LLL是Ethereum核心团队提供的第一个EVM语言，因为鉴于基于栈的Lisp语言和EVM之间的工作方式的相似性，它允许他们比任何其他语言更快地交付。目前，使用LLL的主要好处是得到更紧凑的字码，这可能会更便宜地运行。
- en: After the first public release of the platform, the focus shifted to higher-level
    languages that would provide a simpler syntax to contract developers. Serpent
    was the first to be developed.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在平台首次公开发布后，重点转向了为合约开发者提供更简单语法的更高层次语言。Serpent是第一个被开发的语言。
- en: 5.1.2\. Serpent and Viper
  id: totrans-32
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.1.2\. Serpent和Viper
- en: Serpent is a Python-like language that was popular for a few months after its
    release. It was praised for its minimalistic philosophy and for offering the efficiency
    of a low-level language through simple syntax.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Serpent是一种发布后流行了几个月的Python类似语言。它因其极简主义哲学和通过简单语法提供低级语言的效率而受到赞誉。
- en: 'If you’re familiar with Python, these are the main limitations you’ll find
    in Serpent:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉Python，你会在Serpent中找到这些主要限制：
- en: It doesn’t provide list comprehensions (elegant syntax to create lists from
    existing sequences and lists) and complex data structures.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不提供列表推导（优雅的语法从现有序列和列表创建列表）和复杂的数据结构。
- en: It doesn’t support first-class functions, therefore limiting your ability to
    use a functional programming style.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不支持一等函数，因此限制了您使用函数式编程风格的能力。
- en: 'The following listing shows how `SimpleCoin` would look in Serpent:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表展示了`SimpleCoin`在Serpent中的样子：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Even if you don’t know Python, you should be able to understand this code. The
    only variable you might be confused about is `self.storage`. This is a dictionary
    containing the contract state. It holds the equivalent of all the state variables
    in Solidity.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你不知道Python，你也应该能够理解这段代码。你可能会对`self.storage`这个变量感到困惑。这是一个包含合约状态的字典。它包含了Solidity中所有状态变量的等效值。
- en: '|  |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-41
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: A `dict` (or dictionary) is the Python implementation of a hash map (or hash
    table).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`dict`（或字典）是Python实现的字典映射（或哈希表）。'
- en: '|  |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Serpent’s popularity began to fade when the focus shifted to Solidity, which
    programmers started to maintain more regularly. A new experimental Python-like
    language, called Viper, is currently being researched and is publicly available
    on GitHub. Its aim is to provide a more extended type set than that offered by
    Serpent and easier bound and overflow checking on arithmetic operations and arrays.
    It will also allow you to write first-class functions, although with some limitations,
    and therefore write more functional code. The main benefit of using Viper is to
    get more compact and safer bytecode than you’d get from compiling Solidity.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Serpent的流行开始消退，当焦点转移到Solidity时，程序员开始更频繁地维护它。一种新的实验性Python式语言Viper目前正在研究中，并在GitHub上公开可用。它的目标是提供比Serpent更广泛的类型集，并在算术操作和数组上提供更简单的边界和溢出检查。它还将允许您编写一等函数，尽管有些限制，因此您可以编写更功能的代码。使用Viper的主要好处是获得比编译Solidity更紧凑、更安全的字节码。
- en: Now that you have a better understanding of EVM languages, let’s move back to
    Solidity. Open up Remix and enjoy the tour.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您对EVM语言有了更好的了解，让我们回到Solidity。打开Remix并享受这次旅行。
- en: 5.2\. High-level contract structure
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2。高级合约结构
- en: Before diving into the various aspects of Solidity, I’ll present the high-level
    structure of a contract so you can appreciate the purpose of each language feature.
    This will also give you some context you can refer back to.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入探讨Solidity的各种方面之前，我将介绍合约的高级结构，以便您可以理解每个语言特性的目的。这还将为您提供一些您可以回溯的上下文。
- en: 5.2.1\. Contract declarations
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.1。合约声明
- en: 'The contract definition for `AuthorizedToken`, an example token similar to
    SimpleCoin, shown in the next listing, summarizes all the possible declarations
    that can appear on a contract. Don’t worry if you don’t fully understand this
    code: the point of this listing is to give you an idea of what all contract constructs
    look like.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 下面列出的是`AuthorizedToken`示例，这是一个与SimpleCoin相似的示例代币，总结了合约上可能出现的所有可能的声明。如果您不完全理解此代码，请不要担心：这个列表的目的是让您了解所有合约构造的样子。
- en: Listing 5.1\. High-level contract structure
  id: totrans-50
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.1。高级合约结构
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '***1*** **Enum definition**'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **枚举定义**'
- en: '***2*** **Struct definition**'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **结构体定义**'
- en: '***3*** **State variable definitions**'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **状态变量定义**'
- en: '***4*** **Event definitions**'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **事件定义**'
- en: '***5*** **Function modifier definition**'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **函数修饰符定义**'
- en: '***6*** **Constructor definition**'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** **构造函数定义**'
- en: '***7*** **Function definitions**'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7*** **函数定义**'
- en: '***8*** **Functions defined with modifiers**'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8*** **带修饰符的函数定义**'
- en: 'In summary, these are the possible items you can declare:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，您可以声明以下可能的项目：
- en: State variables
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态变量
- en: Events
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件
- en: Enums
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 枚举
- en: Struct types
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构体类型
- en: Functions
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数
- en: Function modifiers
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数修饰符
- en: Let’s go quickly through each of them. After we complete a high-level contract
    overview, we’ll delve into each language feature.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速地逐一了解它们。在我们完成高级合约概述之后，我们将深入探讨每个语言特性。
- en: State variables
  id: totrans-68
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 状态变量
- en: State variables hold the contract state. You can declare them with any of the
    types that the language supports. Some types, such as mapping, are only allowed
    for state variables. The declaration of a state variable also includes, explicitly
    or implicitly, its access level.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 状态变量持有合约状态。您可以使用语言支持的任何类型来声明它们。一些类型，如映射，只能用于状态变量。状态变量的声明也隐含或明确地包括其访问级别。
- en: Events
  id: totrans-70
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 事件
- en: An event is a contract member that interacts with the EVM transaction log and
    whose invocation is then propagated to clients subscribed to it, often triggering
    related callbacks. An event declaration looks more similar to a declaration of
    Java or C# events than a declaration of JavaScript events.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 事件是合约成员，与EVM交易日志交互，其调用随后传播到订阅它的客户端，通常触发相关回调。事件声明与Java或C#事件声明更为相似，而不是JavaScript事件声明。
- en: Enums
  id: totrans-72
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 枚举
- en: An enum defines a custom type with a specified set of allowed values. An `enum`
    declaration is similar to that of Java and C# enums.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举定义了一个具有指定允许值的自定义类型。`enum`声明与Java和C#枚举声明相似。
- en: Struct types
  id: totrans-74
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 结构体类型
- en: A struct defines a custom type that includes a set of variables, each in general
    of a different type. A struct declaration is similar to that of a C struct.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体定义了一个包括一组变量的自定义类型，每个变量通常属于不同类型。结构体声明与C结构体声明相似。
- en: Functions
  id: totrans-76
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 函数
- en: Functions encapsulate the logic of a contract, are altered by modifiers, have
    access to state variables, and can raise the events declared on the contract.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 函数封装了智能合约的逻辑，可以被修饰符修改，可以访问状态变量，并且可以引发智能合约上声明的事件。
- en: Function modifiers
  id: totrans-78
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 函数修饰符
- en: A function modifier allows you to modify the behavior of a function, typically
    to restrict its applicability to only certain input, in a declarative way. A contract
    might declare many modifiers that you might use on several functions.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 函数修饰符允许你以声明性方式修改函数的行为，通常是为了限制其只适用于某些输入。一个合约可能会声明许多修饰符，你可能会在多个函数上使用它们。
- en: 5.3\. Solidity language essentials
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3. Solidity语言基础
- en: 'During this initial tour of Solidity, you’ll get a firm foundation in the language
    by learning about most of its syntax and constructs:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次Solidity的初步之旅中，你将通过学习大多数其语法和构造来坚实基础语言：
- en: Data types
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据类型
- en: The global namespace
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局命名空间
- en: State variables
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态变量
- en: Functions
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数
- en: Function modifiers
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数修饰符
- en: Variable declaration, initialization, and assignment
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量声明、初始化和赋值
- en: Events
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件
- en: Conditional statements
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件语句
- en: You’ll explore more advanced object-oriented features and concepts in the next
    chapter.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在下一章探索更多高级的面向对象特性和概念。
- en: Like most statically typed languages, Solidity requires you to explicitly declare
    the type of each variable, or at least needs the type to be inferred unequivocally
    by the compiler. Its data type system includes both value types and reference
    types, which I’ll present in the next few sections.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 像大多数静态类型语言一样，Solidity要求你显式声明每个变量的类型，或者至少需要编译器明确推断出类型。它的数据类型系统包括值类型和引用类型，我将在接下来的几节中介绍。
- en: 5.3.1\. Value types
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.3.1. 值类型
- en: A *value type* variable is stored on the EVM stack, which allocates a single
    memory space to hold its value. When a value type variable is assigned to another
    variable or passed to a function as a parameter, its value is copied into a new
    and separate instance of the variable. Consequently, any change in the value of
    the assigned variable doesn’t affect the value of the original variable. Value
    types include most native types, enums, and functions.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*值类型*变量存储在EVM栈上，为其值分配一个单一的内存空间。当一个值类型变量被赋给另一个变量或作为参数传递给函数时，它的值会被复制到一个新的独立变量的实例中。因此，赋值变量的值的任何更改都不会影响原始变量的值。值类型包括大多数原生类型、枚举和函数。
- en: bool
  id: totrans-94
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: bool
- en: Variables declared as `bool` can have either a `true` or `false` value; for
    example
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 声明为`bool`的变量可以有一个`true`或`false`的值；例如
- en: '[PRE4]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '|  |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-98
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Logical expressions must resolve to true or false, so trying to use integer
    values of 0 and 1 for false and true, as in JavaScript, C, or C++, isn’t allowed
    in Solidity.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑表达式必须解析为真或假，因此像JavaScript、C或C++那样使用整数值0和1作为假和真是不允许的。
- en: '|  |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Integer types
  id: totrans-101
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 整数类型
- en: You can declare integer variables either as `int` (signed) or `uint` (unsigned).
    You also can specify an exact size, ranging from 8 to 256 bits, in multiples of
    8\. For example, `int32` means signed 32-bit integer, and `uint128` means unsigned
    128-bit integer. If you don’t specify a size, it’s set to 256 bits. The sidebar
    explains how the assignment between variables of different integer types works.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将整数变量声明为`int`（有符号）或`uint`（无符号）。你还可以指定一个确切的大小，范围从8到256位，以8的倍数为单位。例如，`int32`意味着有符号的32位整数，`uint128`意味着无符号的128位整数。如果你没有指定大小，则设置为256位。边栏解释了不同整数类型变量之间赋值是如何工作的。
- en: '|  |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Implicit and explicit integer conversions**'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**隐式和显式整数转换**'
- en: 'Assignments between variables of different integer types is possible only if
    it’s meaningful, which generally means the type of the receiving variable is less
    restrictive or is larger. If that’s the case, an implicit conversion happens.
    The contract shown here, which you can enter into the Remix editor, shows some
    examples of valid and invalid assignments leading to implicit conversions when
    successful:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当有意义时，不同整数类型变量之间的赋值才是可能的，这意味着接收变量的类型更宽松或者更大。如果是这样，会发生隐式转换。这里展示的合约，你可以将其输入到Remix编辑器中，展示了成功时有效和无效赋值导致隐式转换的一些示例：
- en: '[PRE5]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '***1*** **Compile error because newSmallNumber is too small to contain bigNumber**'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1** **编译错误，因为newSmallNumber太小，无法包含bigNumber**'
- en: '***2*** **Compiler error because uint64 can only hold positive numbers**'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**2** **编译错误，因为uint64只能存储正数**'
- en: '***3*** **smallPositiveNumber is implicitly converted from uint16 to uint32;
    newMediumNumber =15,678**'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**3** **smallPositiveNumber从uint16隐式转换为uint32；newMediumNumber = 15,678**'
- en: '***4*** **mediumNegativeNumber is implicitly converted from int32 to int256;
    newBigNumber =-450,000**'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**4** **mediumNegativeNumber从int32隐式转换为int256；newBigNumber = -450,000**'
- en: To compile this code, remove the two lines that are causing errors, such as
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 编译此代码时，可以删除导致错误的两行，例如
- en: '[PRE6]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Then instantiate the contract (click Deploy). Finally, get the values of `newMedium-Number`
    and `newBigNumber` by clicking the corresponding buttons.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然后实例化合约（点击部署）。最后，通过点击相应按钮获取`newMedium-Number`和`newBigNumber`的值。
- en: 'When an implicit conversion isn’t allowed, it’s still possible to perform explicit
    conversions. In such cases, it’s your responsibility to make sure the conversion
    is meaningful to your logic. To see an example of explicit conversions in action,
    add the following two lines to the IntConversions contract:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当不允许隐式转换时，仍然可以执行显式转换。在这种情况下，确保转换对您的逻辑有意义是您的责任。要查看显式转换的一个例子，请将以下两行添加到IntConversions合约中：
- en: '[PRE7]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '***1*** **The explicit conversion and assignment are successful, but newSmallNumber
    = 23,552.**'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1** **显式转换和赋值成功，但newSmallNumber = 23,552.**'
- en: '***2*** **The explicit conversion and assignment are successful, but newMediumPositiveNumber
    = 18,446,744,073,709,101,616.**'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**2** **显式转换和赋值成功，但newMediumPositiveNumber = 18,446,744,073,709,101,616.**'
- en: 'Reinstantiate the contract (by clicking Create again), then get the value of
    `newSmallNumber` and `newMediumPositiveNumber` by clicking the corresponding buttons.
    The results of the explicit integer conversions aren’t intuitive: they wrap the
    original value around the size of the target integer type (if its size is smaller
    than that of the source integer type) rather than overflowing.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 重新实例化合约（再次点击创建），然后通过点击相应按钮获取`newSmallNumber`和`newMediumPositiveNumber`的值。显式整数转换的结果并不直观：它们将原始值围绕目标整数类型的大小（如果它的大小小于源整数类型的大小）进行包装，而不是溢出。
- en: The principles behind implicit and explicit conversions between integer types
    apply also to other noninteger types.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 整数类型之间的隐式和显式转换背后的原则也适用于其他非整数类型。
- en: '|  |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Static byte arrays
  id: totrans-121
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 静态字节数组
- en: You can declare byte arrays of a fixed size with a size ranging from 1 to 32—for
    example, `bytes8` or `bytes12`. By itself, `byte` is an array of a single byte
    and is equivalent to `bytes1`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以声明一个固定大小的字节数组，大小范围从1到32，例如`bytes8`或`bytes12`。单独的`byte`是一个单个字节的数组，与`bytes1`等效。
- en: '|  |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Warning
  id: totrans-124
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: If no size is specified, `bytes` declares a dynamic size byte array, which is
    a reference type.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有指定大小，`bytes`声明一个动态大小的字节数组，这是一个引用类型。
- en: '|  |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Address
  id: totrans-127
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 地址
- en: 'Address objects, which you generally declare using a literal containing up
    to 40 hexadecimal digits prefixed by 0x, hold 20 bytes; for example:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 通常使用包含最多40个十六进制数字的文本表示的地址对象，前缀为0x，占用20字节；例如：
- en: '[PRE8]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '|  |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Warning
  id: totrans-131
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: A hexadecimal literal is recognized as an address only if it has a valid checksum.
    This is determined by hashing the hexadecimal literal with the `sha3` function
    (provided by the Web3 library) and then verifying that the alphabetic characters
    in the literal are uppercase or lowercase, depending on the value of the bits
    in the hash at the same index position. This means an address is case-sensitive
    and you can’t validate it visually. Some tools, such as Remix, will warn you if
    an address isn’t valid but will still process an invalid address.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当十六进制字面量具有有效的校验和时，它才被识别为地址。这是通过使用`sha3`函数（由Web3库提供）对十六进制字面量进行哈希，然后验证字面量中的字母字符是大写还是小写，取决于哈希中相同索引位置的位值来确定的。这意味着地址是大小写敏感的，你不能直观地验证它。一些工具，如Remix，如果地址无效会警告你，但仍会处理无效地址。
- en: '|  |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'It’s possible to get the Ether balance in Wei (the smallest Ether denomination)
    associated with an address by querying the `balance` property. You can try it
    by putting the following sample contract in Remix and executing the `getOwnerBalance()`
    function:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过查询`balance`属性来获取与地址关联的以太币余额（以太币的最小单位），你可以尝试在Remix中放入以下示例合约并执行`getOwnerBalance()`函数：
- en: '[PRE9]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You’ll see the return value in the output panel at the bottom left of the Remix
    screen, after you click the Details button next to the output line corresponding
    to the function call. The address type exposes various functions for transferring
    Ether. [Table 5.1](#ch05table01) explains their purposes.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在Remix屏幕左下角的输出面板中看到返回值，在你点击对应函数调用的输出行的详细信息按钮后。地址类型暴露了各种用于传输以太币的函数。[表5.1](#ch05table01)解释了它们的目的。
- en: Table 5.1\. Functions provided by the address type
  id: totrans-137
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表5.1\. 地址类型提供的函数
- en: '| Function | Purpose |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 目的 |'
- en: '| --- | --- |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| transfer() | *To transfer Ether in Wei*—If the transaction fails on the receiving
    side, an exception is thrown to the sender and the payment is automatically reverted
    (although any spent gas isn’t refunded), so no error handling code is necessary;
    transfer() can spend only up to a maximum of 2300 gas. |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| transfer() | *以 Wei 传输以太币*—如果接收方交易失败，向发送者抛出异常，并且支付会自动逆转（尽管任何已花费的gas不会退款），所以不需要错误处理代码；transfer()最多只能花费2300个gas。|'
- en: '| send() | *To send Ether in Wei*—If the transaction fails on the receiving
    side, a value of false is returned to the sender but the payment isn’t reverted,
    so it must be handled correctly and reverted with further instructions; send()
    can spend only up to a maximum of 2,300 gas. |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| send() | *以 Wei 发送以太币*—如果接收方交易失败，发送者会返回一个值为false的结果，但支付不会被逆转，所以必须正确处理并随进一步的指示逆转；send()最多只能花费2300个gas。|'
- en: '| call() | *To invoke a function on the target contract associated with the
    address (the target account is assumed to be a contract)*—An amount of Ether can
    be sent together with the function call by specifying it in this way: call.value(10)("contractName",
    "functionName"); call() transfers the entire gas budget from the sender to the
    called function. If call() fails, it returns false, so failure must be handled
    in a similar way to send(). |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| call() | *调用与地址相关联的目标合约上的函数（假设目标账户是一个合约）*—通过这种方式指定可以发送以太币：call.value(10)("contractName",
    "functionName"); call()会将发送者所有的gas预算转给被调用函数。如果call()失败，它会返回false，所以失败的处理方式要类似于send()。|'
- en: '|  |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Warning
  id: totrans-144
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: Because of security concerns, `send()` and `call()` are being deprecated, and
    it won’t be possible to use them in future versions of Solidity.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 由于安全问题，`send()`和`call()`正在被弃用，在Solidity未来的版本中，将无法使用它们。
- en: '|  |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'This is an example of an Ether transfer using `transfer()`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用`transfer()`的以太币传输示例：
- en: '[PRE10]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '***1*** **Sends 10 Wei to destinationAddress**'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **向destinationAddress发送10 Wei**'
- en: 'If sending Ether with `send()`, you must have error handling to avoid losing
    Ether:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用`send()`发送以太币，你必须有错误处理以避免失去以太币：
- en: '[PRE11]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '***1*** **If the send() operation fails, it returns false and must be handled,
    in this case by reverting the state and consequently the payment.**'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **如果send()操作失败，它返回false并且必须被处理，在本例中通过逆转状态和随之的支付。**'
- en: 'Another way of ensuring a transfer failure reverts the payment is by using
    the global `require()` function, which reverts the state if the input condition
    is false:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 确保传输失败逆转支付的另一种方法是使用全局`require()`函数，如果输入条件为假，则逆转状态：
- en: '[PRE12]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '***1*** **Reverts the payment if send fails and returns false**'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **如果send失败返回false，则逆转支付**'
- en: 'You can invoke a function on an external contract with `call()` as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像下面这样用`call()`调用外部合约的函数：
- en: '[PRE13]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '***1*** **Invokes an external contract function**'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **调用外部合约函数**'
- en: 'You can send Ether during the external call as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在外部调用期间发送以太币如下：
- en: '[PRE14]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '***1*** **Sends an amount of Ether expressed in Wei with the external call()
    by specifying it with value()**'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **通过value()指定发送的以太币数量，用外部调用的send()发送**'
- en: 'You must have handling for a failure of the external function call, as for
    `send()`, to ensure the state (including Ether payment) is reverted:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须像处理`send()`失败一样处理外部函数调用的失败，以确保状态（包括以太币支付）被逆转：
- en: '[PRE15]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '***1*** **Reverts the state and consequently the payment**'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **逆转状态和随之的支付**'
- en: '[Chapter 15](kindle_split_029.xhtml#ch15) on security will cover in detail
    how to invoke `transfer()`, `send()`, and `call()` correctly and how to handle
    errors safely.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '[第15章](kindle_split_029.xhtml#ch15)将详细介绍如何正确调用`transfer()`、`send()`和`call()`以及如何安全地处理错误。'
- en: Enums
  id: totrans-166
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 枚举
- en: 'An enum is a custom data type including a set of named values; for example:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举是一种自定义数据类型，包括一组命名值；例如：
- en: '[PRE16]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You can then define an enum-based variable as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你可以像下面这样定义一个基于枚举的变量：
- en: '[PRE17]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The integer value of each enum item is implicitly determined by its position
    in the enum definition. In the previous example, the value of High is 0 and the
    value of Low is 2\. You can retrieve the integer value of an enum type variable
    by explicitly converting the enum variable to an int variable as shown here:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 每个枚举项的整数值隐式由其在枚举定义中的位置确定。在前一个示例中，High 的值是 0，Low 的值是 2\. 您可以通过显式将枚举变量转换为整变量来检索枚举类型变量的整数值，如下所示：
- en: '[PRE18]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Implicit conversions aren’t allowed:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 不允许隐式转换：
- en: '[PRE19]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '***1*** **Doesn’t compile**'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **无法编译**'
- en: 5.3.2\. Reference types
  id: totrans-176
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.3.2\. 引用类型
- en: '*Reference type* variables are accessed through their reference (the location
    of their first item). You can store them in either of the following two data locations,
    which you can, in some cases, explicitly specify in their declaration:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '*引用类型* 变量通过它们的引用（它们第一个项目的位置）进行访问。您可以在以下两个数据位置之一存储它们，在某些情况下，您可以在它们的声明中显式指定它们：'
- en: '*Memory*—Values aren’t persisted permanently and only live in memory.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*内存*——值不会永久保存，只存在于内存中。'
- en: '*Storage*—Values are persisted permanently on the blockchain, like state variables.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*存储*——值永久保存在区块链上，类似于状态变量。'
- en: 'A third type of data location is available that you can’t explicitly specify:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种您无法显式指定的数据位置：
- en: '*Calldata*—This is an area dedicated to holding the values of function parameters
    of external functions. Objects held in this area behave like objects stored in
    memory.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Calldata*—这是用于持有外部函数参数值的区域。在这个区域中存储的对象表现得像存储在内存中的对象。'
- en: The following listing shows various reference type variables declared in different
    data locations.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了在不同数据位置声明的各种引用类型变量。
- en: Listing 5.2\. Reference types with location declared implicitly or explicitly
  id: totrans-183
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.2\. 数据位置隐式或显式声明的引用类型
- en: '[PRE20]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '***1*** **The data location of storageArray implicitly defined as storage**'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **storageArray 的数据位置隐式定义为存储**'
- en: '***2*** **The data location of fArray implicitly defined as memory**'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **fArray 的数据位置隐式定义为内存**'
- en: '***3*** **The data location of gArray explicitly defined as storage**'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **gArray 的数据位置显式定义为存储**'
- en: '***3*** **The data location of hArray explicitly defined as memory**'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **hArray 的数据位置显式定义为内存**'
- en: Before looking at code snippets focused on data locations, have a look at [table
    5.2](#ch05table02), which summarizes the default data location of variables, depending
    on whether they’re local or state variables, and of function parameters, depending
    on whether the function has been declared internal or external.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看关注数据位置的代码片段之前，请查看 [表 5.2](#ch05table02)，该表总结了根据它们是局部变量还是状态变量，以及根据函数是内部声明还是外部声明，函数参数的默认数据位置。
- en: Table 5.2\. Default data location of variables and function parameters
  id: totrans-190
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 5.2\. 变量和函数参数的默认数据位置
- en: '| Case | Data location | Default |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| 案例 | 数据位置 | 默认 |'
- en: '| --- | --- | --- |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Local variable | Memory or storage | Storage |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| 局部变量 | 内存或存储 | 存储 |'
- en: '| State variable | Only storage | Not applicable |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| 状态变量 | 仅存储 | 不适用 |'
- en: '| Parameter of internal function | Memory or storage | Memory |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| 内部函数参数 | 内存或存储 | 内存 |'
- en: '| Parameter of external function | Calldata | Not applicable |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| 外部函数参数 | Calldata | 不适用 |'
- en: The behavior of reference type variables, specifically whether they get cloned
    or referenced directly when assigned to other variables or passed to function
    parameters, depends on the source and target data location. The best way to understand
    what happens in the various cases is to look at some code. The following code
    snippets all assume the `ReferenceTypesSample` contract definition given in [listing
    5.2](#ch05ex02).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 引用类型变量的行为，特别是当它们被赋值给其他变量或传递给函数参数时，是否会进行克隆或直接引用，取决于源和目标数据位置。理解各种情况中会发生什么的最佳方式是查看一些代码。以下代码片段都假设了给出的
    `ReferenceTypesSample` 合约定义，如 [列表 5.2](#ch05ex02) 中所示。
- en: 'The first case is the assignment of a state variable (whose data location is,
    as you know, the storage) to a local variable:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个案例是将一个状态变量（其数据位置，你知道的，是存储）赋值给一个局部变量：
- en: '[PRE21]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '***1*** **localArray is defined implicitly in the storage and points directly
    to storageArray.**'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **localArray 隐式地定义在存储中，直接指向 storageArray。**'
- en: If `localArray` is modified, `storageArray` is consequently modified.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果修改了 `localArray`，`storageArray` 也会相应地被修改。
- en: 'The next example is the assignment of a function parameter defined in memory
    to a local variable:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例是将定义在内存中的函数参数赋值给一个局部变量：
- en: '[PRE22]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '***1*** **fArray is implicitly defined in memory.**'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **fArray隐式定义在内存中。**'
- en: '***2*** **localArray is defined in memory and points directly to fArray.**'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **localArray定义在内存中，直接指向fArray。**'
- en: If `localArray` is modified, `fArray` is consequently modified.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`localArray`被修改，`fArray`也会相应地被修改。
- en: 'The following example shows what happens if you assign a function parameter
    defined in memory to a storage variable:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例展示了如果你将一个定义在存储中的函数参数赋值给一个存储变量会发生什么：
- en: '[PRE23]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '***1*** **fArray is implicitly defined in memory.**'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **fArray隐式定义在内存中。**'
- en: '***2*** **storageArray stores a full copy of fArray.**'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **storageArray存储了fArray的完整副本。**'
- en: 'If you pass a state variable to a function parameter defined in storage, the
    function parameter directly references the state variable:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将一个状态变量传递给定义在存储中的函数参数，该函数参数将直接引用状态变量：
- en: '[PRE24]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '***1*** **fArray is implicitly defined in memory.**'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **fArray隐式定义在内存中。**'
- en: '***2*** **During the call, gArray points directly to storageArray.**'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **在调用期间，gArray直接指向storageArray。**'
- en: '***3*** **gArray is defined explicitly in storage.**'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **gArray明确定义在存储中。**'
- en: If `gArray` is modified, `storageArray` is consequently modified.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`gArray`被修改，`storageArray`也会相应地被修改。
- en: 'If you pass a state variable to a function parameter defined in memory, the
    function parameter creates a local clone of the state variable:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将一个状态变量传递给定义在存储中的函数参数，该函数参数将创建状态变量的本地克隆：
- en: '[PRE25]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '***1*** **fArray is implicitly defined in memory.**'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **fArray隐式定义在内存中。**'
- en: '***2*** **During the call, hArray is assigned to a clone of storageArray.**'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **在调用期间，hArray被赋值为storageArray的克隆。**'
- en: '***3*** **hArray is defined explicitly in memory.**'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **hArray明确定义在内存中。**'
- en: 'There are four classes of reference types:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 引用类型有四个类别：
- en: Arrays
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组
- en: Strings
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串
- en: Structs
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构体
- en: Mappings
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射
- en: Arrays can be static (of fixed size) or dynamic and are declared and initialized
    in slightly different ways.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 数组可以是静态的（固定大小）或动态的，并且以略微不同的方式声明和初始化。
- en: Static arrays
  id: totrans-228
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 静态数组
- en: 'You must specify the size of a static array in its declaration. The following
    code declares and allocates a static array of five elements of type `int32`:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须在静态数组的声明中指定其大小。以下代码声明并分配了一个类型为`int32`的五个元素的静态数组：
- en: '[PRE26]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You can also allocate a static array and set it inline, as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以分配一个静态数组并在内联中设置它，如下所示：
- en: '[PRE27]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '|  |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-234
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'Inline arrays are automatically defined as to memory data location and are
    sized with the smallest possible type of their biggest item. In the inline static
    array example, imagine you hadn’t enforced the item in the first cell as `int32:
    int32[5] memory fixedSlots = [5, 9, 1, 3, 4]`. In this case, the inline array
    would have been implicitly declared as `int4[] memory`, and it would have failed
    the assignment to the `fixedSlots` variable. Therefore, it would have produced
    a compilation error.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 内联数组自动定义为内存数据位置，并用其最大项的尽可能小的类型调整大小。在内联静态数组的示例中，假设你没有强制第一个单元格的项为`int32`：`int32[5]
    memory fixedSlots = [5, 9, 1, 3, 4]`。在这种情况下，内联数组将隐式声明为`int4[] memory`，并且它将无法分配给`fixedSlots`变量。因此，它将产生编译错误。
- en: '|  |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Dynamic arrays
  id: totrans-237
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 动态数组
- en: 'You don’t need to specify the size in the declaration of dynamic arrays, as
    shown in the following snippet:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要在动态数组的声明中指定大小，如下面的片段所示：
- en: '[PRE28]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You can then append items to a dynamic array by calling the `push` member function:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以通过调用`push`成员函数向动态数组添加项目：
- en: '[PRE29]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If you need to resize a dynamic array, you must do so in different ways depending
    on whether its data location is memory or storage. If the data location is storage,
    you can reset its length, as shown in the following snippet:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要调整动态数组的大小，你必须根据其数据位置是在存储还是内存中以不同的方式进行。如果数据位置在存储中，你可以像下面的片段所示重置其长度：
- en: '[PRE30]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '***1*** **Implicitly declares it with storage data location**'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **显式声明，数据位置为存储。**'
- en: '***2*** **Resizes it by resetting its length**'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **通过重置其长度来调整大小**'
- en: 'If the data location of a dynamic array is memory, you have to resize it with
    `new`, as shown in the following snippet:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如果动态数组的数据位置在存储中，你需要用`new`对其进行调整大小，如下面的片段所示：
- en: '[PRE31]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '***1*** **Explicitly declares it with memory data location**'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **显式声明，数据位置为内存。**'
- en: '***2*** **Resizes it with new**'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **用new调整大小**'
- en: '|  |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-251
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: As you saw earlier, `bytes` is an unlimited byte array and is a reference type.
    This is equivalent to `byte[]`, but it’s optimized for space, and its use is recommended.
    It also supports `length` and `push()`.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你之前所看到的，`bytes`是一个无限的字节数组，是一个引用类型。这相当于`byte[]`，但它优化了空间，并且建议使用。它还支持`length`和`push()`。
- en: '|  |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: If an array is exposed as a public state variable, its getter accepts the array
    positional index as an input.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个数组作为公共状态变量暴露出来，它的获取器接受数组位置索引作为输入。
- en: String
  id: totrans-255
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 字符串
- en: '`string` is in fact equivalent to `bytes` but with no length and `push()` members.
    You can initialize it with a string literal:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`string`实际上与`bytes`等效，但没有长度和`push()`成员。你可以用字符串字面量来初始化它：'
- en: '[PRE32]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Struct
  id: totrans-258
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 结构体
- en: A `struct` is a user-defined type that contains a set of elements that in general
    are each of a different type. The following listing shows a contract declaring
    various structs that get referenced in its state variables. This example also
    shows how you can use enums in a struct.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`struct`是一个用户定义的类型，包含了一组元素，这些元素通常是不同类型的。以下列表显示了一个声明了各种结构体的合约，这些结构体在其状态变量中被引用。这个例子还展示了如何在结构体中使用枚举。'
- en: Listing 5.3\. Contract containing various struct definitions
  id: totrans-260
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.3. 包含各种结构体定义的合约
- en: '[PRE33]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'You can initialize a `struct` object as follows:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以按照以下方式初始化一个`struct`对象：
- en: '[PRE34]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Mapping
  id: totrans-264
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 映射
- en: '`mapping` is a special reference type that you can only use in the storage
    data location, which means you can declare it only as a state variable or a storage
    reference type. You might remember `mapping` is the Solidity implementation of
    a hash table, which stores values against keys. The hash table is strongly typed,
    which means you must declare the type of the key and the type of the value at
    its declaration:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`mapping`是一种特殊的引用类型，你只能在其存储数据位置使用它，这意味着你只能将其声明为状态变量或存储引用类型。你可能还记得`mapping`是Solidity实现的一个哈希表，它按照键存储值。哈希表是强类型的，这意味着你在其声明时必须声明键的类型和值的类型：'
- en: '[PRE35]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In general, you can declare the value of any type, including primitive types,
    arrays, structs, or mappings themselves.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你可以声明任何类型的值，包括基本类型、数组、结构体或映射本身。
- en: 'Contrary to hash table implementations of other languages, mapping has no `contains-Key()`
    function. If you try to get the value associated with a missing key, it will return
    the default value. For example, your `coinBalance` mapping will return `0` when
    trying to get the balance of an address missing from the mapping:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他语言的哈希表实现相反，映射没有`contains-Key()`函数。如果你尝试获取与缺失键相关的值，它会返回默认值。例如，你的`coinBalance`映射在尝试获取映射中缺失的地址的余额时将返回`0`：
- en: '[PRE36]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '***1*** **missingAddressBalance == 0;**'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **missingAddressBalance == 0;**'
- en: This completes your tour of data types. You’ve seen how to declare and instantiate
    value type and reference type variables. A certain set of variables are declared
    implicitly, and you can always access them from your contract. They’re part of
    the so-called *global namespace* that we’re going to explore next.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你数据类型之旅的结束。你已经看到了如何声明和实例化值类型和引用类型变量。有一组变量是隐式声明的，你总是可以直接从你的合约中访问它们。它们是所谓的*全局命名空间*的一部分，接下来我们将探索它。
- en: 5.3.3\. Global namespace
  id: totrans-272
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.3.3. 全局命名空间
- en: The global namespace is a set of implicitly declared variables and functions
    that you can reference and use in your contract code directly.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 全局命名空间是一组隐式声明的变量和函数，你可以在你的合约代码中直接引用和使用它们。
- en: Implicitly declared variables
  id: totrans-274
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 隐式声明的变量
- en: 'The global namespace provides the following five variables:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 全局命名空间提供了以下五个变量：
- en: '`block` holds information about the latest blockchain block.'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`block`持有关于最新区块链区块的信息。'
- en: '`msg` provides data about the incoming message.'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`msg`提供了关于传入消息的数据。'
- en: '`tx` provides transaction data.'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tx`提供了交易数据。'
- en: '`this` is a reference to the current contract. You can use it to call internal
    functions as if they were defined `external` and therefore store the message call
    on the blockchain. (`internal` and `external` are function accessibility levels
    that I’ll explain later, in the functions section.) If you use it by itself, it’s
    implicitly converted to the address of the current contract.'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`this`是对当前合约的引用。你可以使用它来调用内部函数，就好像它们是定义为`external`的一样，因此可以在区块链上存储消息调用。（`internal`和`external`是我稍后将在函数部分解释的函数访问级别。）如果你单独使用它，它会被隐式转换为当前合约的地址。'
- en: '`now` is the time associated with the creation of the latest block, expressed
    as a Unix epoch.'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`now`是与最新区块的创建相关联的时间，表示为Unix纪元。'
- en: '[Table 5.3](#ch05table03) summarizes the functions and properties that global
    variables expose.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Table 5.3\. Members of the main global variables
  id: totrans-282
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Global variable | Type | Member | Return type | Description |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
- en: '| block | function | blockhash(uint blocknumber) | bytes32 | Hash of given
    block (only available for last 256 blocks, as specified in the *Yellow Paper*,
    for simplicity of design and performance reasons) |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
- en: '| property | coinbase | address | Block’s miner’s address |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
- en: '| property | gaslimit | uint | Block’s gas limit |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
- en: '| property | number | uint | Block’s number |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
- en: '| property | timestamp | uint | Block’s timestamp as UNIX epoch |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
- en: '| msg | property | data | bytes | Full calldata body |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
- en: '| property | sender | address | Message sender (who is performing the current
    call) |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
- en: '| property | gas | uint | Remaining gas |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
- en: '| property | value | uint | Amount of Ether sent with the message, in Wei |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
- en: '| tx | property | gasprice | uint | Transaction gas price |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
- en: '| property | origin | address | Transaction sender (who originated the full
    call chain) |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
- en: '| now | property | N/A | uint | Although the name of this variable might lead
    you to believe that this might return the current time (perhaps as a UNIX epoch),
    now is in fact an alias for block.timestamp, which is the time at which the current
    latest block was created. |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
- en: Implicitly declared functions
  id: totrans-297
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The following two functions, available from the global namespace, throw an
    exception and revert the contract state if the associated condition isn’t met.
    Although they work exactly the same way, their intention is slightly different:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '`require(bool condition)`—This is used to validate function input. You’ve already
    seen it when validating the input of `SimpleCoin.transfer()`.'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assert(bool condition)`—This is used to validate contract state or function
    state.'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can also terminate the execution and revert the contract state explicitly
    by calling `revert()`.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: If you want to remove the current contract instance from the blockchain, for
    example because you’ve realized your contract has a security flaw that’s being
    actively exploited by hackers, you can call `selfdestruct`(Ether recipient address).
    This will uninstall the current instance from the blockchain and move the Ether
    present at the associated account to the specified recipient address.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: What does uninstalling a contract mean in the context of a blockchain? It means
    that the contract will be removed from the current state of the blockchain and
    will become unreachable. But its trace will remain in the blockchain history.
    The contract is considered fully removed only after the `selfdestruct`(recipient
    address) transaction has been mined and the related block has been propagated
    throughout the network.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
- en: Warning
  id: totrans-305
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You should be aware that the recipient address has no way of rejecting Ether
    coming from a `selfdestruct()` call; the destruction of the contract and the crediting
    of the recipient account are a single atomic operation. As you’ll see in a later
    chapter dedicated to security, this can be maliciously exploited to perform sophisticated
    attacks.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该意识到接收者地址无法拒绝来自`selfdestruct()`调用的以太币；合约的销毁和接收者账户的信用是一个单一的原子操作。正如你在后面专门讨论安全的章节中看到的，这可以被恶意利用来执行复杂的攻击。
- en: '|  |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The global namespace also provides various cryptographic hash functions, such
    as `sha256()`(from the SHA-2 family) and `keccak256()` (from the SHA-3 family).
    More on those in a later chapter, but for now let’s move on to state variables.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 全局命名空间还提供了各种加密哈希函数，如`sha256()`（来自SHA-2家族）和`keccak256()`（来自SHA-3家族）。关于这些内容将在后面的章节中详细介绍，但现在让我们继续讨论状态变量。
- en: 5.3.4\. State variables
  id: totrans-309
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.3.4. 状态变量
- en: You already know state variables hold the contract state. What I haven’t covered
    so far is the access level that you can specify when declaring them. [Table 5.4](#ch05table04)
    summarizes the available options.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经知道状态变量持有合约的状态。到目前为止，我还没有覆盖的是你在声明它们时可以指定的访问级别。[表5.4](#ch05table04) 总结了可用的选项。
- en: Table 5.4\. Access levels of a state variable
  id: totrans-311
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表5.4. 状态变量的访问级别
- en: '| Access level | Description |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| 访问级别 | 描述 |'
- en: '| --- | --- |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| public | The compiler automatically generates a getter function for each
    public state variable. You can use public state variables directly from within
    the contract and access them through the related getter function from external
    contract or client code. |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| 公共 | 编译器会为每个公共状态变量自动生成一个获取器函数。你可以从合约内部直接使用公共状态变量，并通过相关获取器函数从外部合约或客户端代码访问它们。
    |'
- en: '| internal | The contract and any inherited contract can access Internal state
    variables. This is the default level for state variables. |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| 内部 | 合约及其继承的合约可以访问内部状态变量。这是状态变量的默认级别。 |'
- en: '| private | Only members of the same contract—not inherited contracts—can access
    private state variables. |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '| 私有 | 只有同一个合约的成员——不是继承的合约——可以访问私有状态变量。 |'
- en: The `StateVariablesAccessibility` contract in the following listing shows examples
    of state variable declarations, including their accessibility level.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表中的`StateVariablesAccessibility`合约展示了状态变量的声明示例，包括它们的访问级别。
- en: Listing 5.4\. Examples of state variables declared with various accessibility
    levels
  id: totrans-318
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.4. 使用各种访问级别声明的状态变量示例
- en: '[PRE37]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '***1*** **You can access frozenAccount only from within this contract, not
    from inherited contracts.**'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **你只能从这个合约中访问frozenAccount，不能从继承的合约中访问。**'
- en: '***2*** **isContractLocked is implicitly defined as internal, so it’s accessible
    from within this contract and inherited contracts.**'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **isContractLocked默认为内部定义，所以可以从本合约和继承的合约中访问。**'
- en: '***3*** **tokenBalance is accessible externally, and the Solidity compiler
    automatically generates a getter function.**'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **tokenBalance对外可见，Solidity编译器会自动生成一个获取器函数。**'
- en: Constant state variables
  id: totrans-323
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 常量状态变量
- en: It’s possible to declare a state variable as constant. In this case, you have
    to set it to a value that isn’t coming from storage or from the blockchain in
    general, so values from other state variables or from properties of the block
    global variable aren’t allowed.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 可以声明一个状态变量为常量。在这种情况下，你必须将其设置为一个不是来自存储或区块链本身的值，所以不允许来自其他状态变量或块全局变量的属性的值。
- en: 'This code shows some examples of constant state variables:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码展示了常量状态变量的几个示例：
- en: '[PRE38]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '***1*** **You can declare a value type or string state variable as constant.**'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **你可以将值类型或字符串状态变量声明为常量。**'
- en: '***2*** **You can assign the result of a stateless built-in mathematical or
    cryptographic function to a constant state variable.**'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **你可以将无状态的内置数学或加密函数的结果赋值给一个常量状态变量。**'
- en: Although you’ve already come across functions, there are various aspects of
    functions that I haven’t covered yet. I’ll cover them in the next section.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你已经接触过函数，但函数有许多方面我还没有涉及。我将在下一节中介绍它们。
- en: 5.3.5\. Functions
  id: totrans-330
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.3.5. 函数
- en: You can specify function input and output parameters in various ways. Let’s
    see how.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以以各种方式指定函数的输入和输出参数。让我们来看看如何操作。
- en: Input parameters declaration
  id: totrans-332
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 输入参数声明
- en: 'You declare input parameters in Solidity, as in other statically typed languages,
    by providing a list of typed parameter names, as shown in the following example:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If you don’t use some of the parameters in the implementation, you can leave
    them unnamed (or anonymous), like the second and third parameter in the following
    example:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: You’ll understand better the purpose of anonymous parameters in [chapter 6](kindle_split_018.xhtml#ch06),
    when you’ll learn about abstract functions of abstract contracts and how to override
    them in concrete contracts. (Some overridden functions might not need all the
    parameters specified in the abstract function of the base abstract contract.)
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
- en: Note
  id: totrans-339
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You might find, as I did initially, the naming convention for parameters a bit
    odd, because in other languages, such as Java or C#, you might have used an underscore
    prefix to identify member variables. In Solidity, an underscore prefix is used
    to identify parameters and local variables. But it seems this convention is fading
    away, and underscore prefixes might disappear altogether from Solidity naming
    conventions.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
- en: Output parameters declaration
  id: totrans-342
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In Solidity, a function can in general return multiple output parameters, in
    a tuple data structure. You specify output parameters after the `returns` keyword
    and declare them like input parameters, as shown here:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '***1*** **Here, _alpha, _beta, and _gamma are declared as returned parameters.**'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **No return statement is necessary to return the result tuple to the
    caller.**'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
- en: Note
  id: totrans-348
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A tuple is an ordered list of elements, in general each of a different type.
    This is an example of a tuple: `23,` `true, "PlanA", 57899, 345`'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
- en: 'As you can see in the code example, contrary to most languages, no `return`
    statement is necessary when you can write the logic in such a way that you’ve
    set all output parameters correctly before the execution of the function is complete.
    You can think of the output parameters as local variables initialized to their
    default value, in this case 0, at the beginning of the function execution. If
    you prefer, though, and if the logic requires you to do so, you can return output
    from a function using `return`, as shown here:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '***1*** **Only the types of the return tuple are declared.**'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **You define and assign _alpha and _beta in the body of the function.**'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **The result tuple is returned to the caller explicitly with a return
    statement.**'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function access levels
  id: totrans-356
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As for state variables, functions also can be declared with different access
    levels, as summarized in [table 5.5](#ch05table05).
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: Table 5.5\. Access levels of a function
  id: totrans-358
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Access level | Description |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
- en: '| external | An external function is exposed in the contract interface, and
    you can only call it from external contracts or client code but not from within
    the contract. |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
- en: '| public | A public function is exposed in the contract interface, and you
    can call it from within the contract or from external contracts or client code.
    This is the default accessibility level for functions. |'
  id: totrans-362
  prefs: []
  type: TYPE_TB
  zh: '| 公开 | 公开函数在合约接口中暴露，你可以在合约内部或外部合约或客户端代码中调用它。这是函数的默认可访问性级别。 |'
- en: '| internal | An internal function isn’t part of the contract interface, and
    it’s only visible to contract members and inherited contracts. |'
  id: totrans-363
  prefs: []
  type: TYPE_TB
  zh: '| 内部函数 | 内部函数不属于合约接口的一部分，它只能被合约成员和继承的合约看到。 |'
- en: '| private | A private function can only be called by members of the contract
    where it’s been declared, not by inherited contracts. |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
  zh: '| 私有 | 私有函数只能被声明它的合约成员调用，不能被继承的合约调用。 |'
- en: 'The following contract code shows some function declarations, including the
    accessibility level:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 以下合约代码显示了一些函数声明，包括可访问性级别：
- en: '[PRE43]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '***1*** **A public function, accessible internally and externally**'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **一个公开的函数，内部和外部都可访问**'
- en: '***2*** **A private function, only accessible from within this contract**'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **一个私有的函数，只能从这个合约内部访问**'
- en: '***3*** **A private function, accessible from this and inherited contracts**'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **一个可以从这个合约和继承的合约访问的私有函数**'
- en: '***3*** **An external function, only accessible externally**'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **一个只能从外部访问的外部函数**'
- en: Internal function invocation
  id: totrans-371
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 内部函数调用
- en: 'Functions can be invoked internally or externally. For example, a function
    can invoke another function directly within the same contract, as shown here:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以被内部或外部调用。例如，一个函数可以在同一个合约内部直接调用另一个函数，如所示：
- en: '[PRE44]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '***1*** **This invocation results in a call: _y and _z are accessed directly
    through memory references.**'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **这种调用导致一个调用：_y和_z直接通过内存引用访问。**'
- en: '***2*** **This is an internal function, not accessible from outside the contract.**'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **这是一个内部函数，不能从合约外部访问。**'
- en: This way of invoking a function is known as a *call*. With a call, the body
    of the function accesses parameters directly through memory references.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 这种调用函数的方式称为*调用*。通过调用，函数体直接通过内存引用访问参数。
- en: External function invocation
  id: totrans-377
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 外部函数调用
- en: 'A function can call a function of an external contract through the contract
    reference, as shown here:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 一个合约可以通过合约引用调用另一个外部合约的函数，如所示：
- en: '[PRE45]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '***1*** **GammaCalculator is an external contract with respect to TaxCalculator2.**'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **对于TaxCalculator2来说，GammaCalculator是一个外部合约。**'
- en: '***2*** **gammaCalculator points to an instance deployed at address _gammaCalculatorAddress.**'
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **gammaCalculator指向部署在地址_gammaCalculatorAddress的实例。**'
- en: '***3*** **This is an external function invocation, which results in a ‘transaction
    message’ that gets stored on the blockchain.**'
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **这是一个外部函数调用，其结果是一个‘交易消息’，存储在区块链上。**'
- en: In this case, parameters are sent to `GammaCalculator` through a *transaction
    message* that’s then stored on the blockchain, as you can see in the sequence
    diagram in [figure 5.1](#ch05fig01).
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，参数通过*交易消息*发送给`GammaCalculator`，然后存储在区块链上，正如你在[图5.1](#ch05fig01)的序列图中看到的。
- en: Figure 5.1\. Sequence diagram illustrating an external function invocation.
    The `calculateAlpha()` function of the `TaxCalculator2` contract calls the external
    `calculateGamma()` function on the `GammaCalculator` contract. Because the call
    is external, the function parameters are sent to the external contract through
    a transaction that’s stored on the blockchain.
  id: totrans-384
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.1\. 序列图，说明外部函数调用。`TaxCalculator2`合约的`calculateAlpha()`函数调用`GammaCalculator`合约的外部`calculateGamma()`函数。因为调用是外部的，所以函数参数通过存储在区块链上的交易发送到外部合约。
- en: '![](Images/fig05-01_alt.jpg)'
  id: totrans-385
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig05-01_alt.jpg)'
- en: 'You can force a call to a `public` function to appear as an external invocation,
    and therefore execute through a transaction message, if it’s performed through
    `this`, the reference to the current contract, as shown here:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过`this`，即对当前合约的引用，强制一个`public`函数的调用看起来像一个外部调用，从而通过交易消息执行，如所示：
- en: '[PRE46]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '***1*** **The call on calculateGamma through ''this'' behaves as a call on
    an external contract, so a transaction message is generated and this gets stored
    on the blockchain.**'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **通过''this''调用calculateGamma的行为就像是对一个外部合约的调用，所以生成一个交易消息，并存储在区块链上。**'
- en: '***2*** **To be called through this, you must declare calculateGamma as public.**'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **要通过这个调用，你必须将calculateGamma声明为公开的。**'
- en: Changing parameters order at function invocation
  id: totrans-390
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 改变函数调用中的参数顺序
- en: 'When invoking a function, you can pass the parameters in any order if you specify
    their name, as shown in the following listing:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用函数时，如果您指定了它们的名称，您可以任意顺序传递参数，如下面的列表所示：
- en: '[PRE47]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '***1*** **You can pass the parameters of calculateGamma in an arbitrary order,
    but in this case, you must also specify the parameter names.**'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **您可以任意顺序传递 calculateGamma 的参数，但在此情况下，您也必须指定参数名称。**'
- en: View and pure functions
  id: totrans-394
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 视图和纯函数
- en: It’s possible to declare a function as `view`, with the intent that it doesn’t
    perform any action that might modify state, as defined in [table 5.6](#ch05table06).
    But the compiler doesn’t check whether any state modification takes place, so
    the `view` keyword is currently used on functions mainly for documentation purposes.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将函数声明为`view`，意图是它不执行可能修改状态的任何操作，如[表 5.6](#ch05table06)中所定义。但编译器不检查是否发生了状态修改，所以目前`view`关键字主要用于文档目的。
- en: Table 5.6\. Actions that lead to a state modification
  id: totrans-396
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 5.6. 导致状态修改的操作
- en: '| State modifying action |'
  id: totrans-397
  prefs: []
  type: TYPE_TB
  zh: '| 修改状态的操作 |'
- en: '| --- |'
  id: totrans-398
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| Writing to state variables |'
  id: totrans-399
  prefs: []
  type: TYPE_TB
  zh: '| 向状态变量写入 |'
- en: '| Raising events |'
  id: totrans-400
  prefs: []
  type: TYPE_TB
  zh: '| 触发事件 |'
- en: '| Creating or destroying contracts |'
  id: totrans-401
  prefs: []
  type: TYPE_TB
  zh: '| 创建或销毁合约 |'
- en: '| Transferring Ether (through send() or transfer()) |'
  id: totrans-402
  prefs: []
  type: TYPE_TB
  zh: '| 通过 send() 或 transfer() 发送以太币 |'
- en: '| Calling any function not declared as view or pure |'
  id: totrans-403
  prefs: []
  type: TYPE_TB
  zh: '| 调用未声明为 view 或纯的任何函数 |'
- en: '| Using low-level calls (for example call()) or certain inline assembly opcodes
    |'
  id: totrans-404
  prefs: []
  type: TYPE_TB
  zh: '| 使用低级调用（例如 call()）或某些内联汇编指令 |'
- en: '|  |'
  id: totrans-405
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-406
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: In earlier versions of Solidity, the `view` keyword was named `constant.` Many
    developers argued that `constant` was misleading because it wasn’t clear whether
    it meant, as in other languages, that the function would return only constant
    results. So, although you can still use `constant` instead of `view`, the latter
    is recommended.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期的 Solidity 版本中，`view`关键字被称为`constant`。许多开发人员认为`constant`具有误导性，因为它不清楚它是否意味着，如其他语言一样，函数将只返回常量结果。因此，尽管您仍然可以使用`constant`代替`view`，但后者是推荐使用的。
- en: '|  |'
  id: totrans-408
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: It’s possible to declare a function as `pure`, with the intent that it doesn’t
    perform any action that might modify state (as seen for `view` functions) or read
    state, as defined in [table 5.7](#ch05table07). As with `view` functions, the
    compiler doesn’t check that `pure` functions don’t modify or read state, so for
    now, the `pure` keyword has only a documentation purpose.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将函数声明为`pure`，意图是它不执行可能修改状态的任何操作（如`view`函数所示）或读取状态，如[表 5.7](#ch05table07)中所定义。与`view`函数一样，编译器不检查`pure`函数是否修改或读取状态，所以目前`pure`关键字只具有文档目的。
- en: Table 5.7\. Actions that can be interpreted as reading from state
  id: totrans-410
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 5.7. 被解释为从状态中读取的操作
- en: '| State reading actions |'
  id: totrans-411
  prefs: []
  type: TYPE_TB
  zh: '| 读取状态的操作 |'
- en: '| --- |'
  id: totrans-412
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| Reading from state variables |'
  id: totrans-413
  prefs: []
  type: TYPE_TB
  zh: '| 从状态变量中读取 |'
- en: '| Accessing account balance (through this.balance or address.balance) |'
  id: totrans-414
  prefs: []
  type: TYPE_TB
  zh: '| 访问账户余额（通过 this.balance 或 address.balance） |'
- en: '| Accessing the members of block, tx, and most of the members of msg |'
  id: totrans-415
  prefs: []
  type: TYPE_TB
  zh: '| 访问区块、交易和大多数 msg 成员 |'
- en: '| Calling any function not declared as pure |'
  id: totrans-416
  prefs: []
  type: TYPE_TB
  zh: '| 调用任何未声明为纯的函数 |'
- en: '| Using certain inline assembly opcodes |'
  id: totrans-417
  prefs: []
  type: TYPE_TB
  zh: '| 使用某些内联汇编指令 |'
- en: The code in the following listing highlights in bold, functions of [listing
    5.1](#ch05ex01) that you can declare as `view` or `pure`.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表中的代码以粗体突出显示了[列表 5.1](#ch05ex01)中您可以声明为`view`或`pure`的函数。
- en: Listing 5.5\. Functions you can declare as `view` or `pure`
  id: totrans-419
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.5. 可以声明为`view`或`pure`的函数
- en: '[PRE48]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '***1*** **Doesn’t alter state variable, so you can declare this function as
    view**'
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **不修改状态变量，所以您可以将此函数声明为 view**'
- en: '***2*** **Alters the state variable tokenBalance, so you can’t declare transfer()
    as view or pure**'
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **修改状态变量 tokenBalance，所以您不能将 transfer() 声明为 view 或纯**'
- en: '***3*** **Doesn’t read or alter state, so you can declare this function as
    pure**'
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **不读取或修改状态，因此您可以将此函数声明为纯**'
- en: '***3*** **Alters state variable frozenAccount, so you can’t declare freezeAccount()
    as view or pure**'
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **修改状态变量 frozenAccount，所以您不能将 freezeAccount() 声明为 view 或纯**'
- en: Payable functions
  id: totrans-425
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 可支付函数
- en: 'You declare a function as payable if you want to allow it to receive Ether.
    The following example shows how to declare a function as payable:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望允许函数接收以太币，则应将函数声明为可支付。以下示例显示如何将函数声明为可支付：
- en: '[PRE49]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '***1*** **Quote price in Wei, which the caller must send when invoking getStockPrice()**'
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **引号价格以 Wei 计，调用者必须在调用 getStockPrice() 时发送**'
- en: '***2*** **Checks the Ether amount sent (in Wei) to cover the fee for the service
    to verify it’s correct**'
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **检查发送的以太币金额（以 Wei 计）以覆盖服务费用，确保它是正确的**'
- en: '***3*** **If the fee sent is incorrect, reverts the transaction and the sender
    isn’t charged**'
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **如果发送的费 用不正确，则撤销交易，并且发送者不会被收费**'
- en: 'The following code shows how to send Ether together with the input when calling
    the `getStockPrice()` function:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码展示了如何调用`getStockPrice()`函数时发送以太币和输入：
- en: '[PRE50]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '***1*** **Sends Ether while invoking an external function with call()**'
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **在调用外部函数时发送以太币**'
- en: '***2*** **If call() fails, it returns false, and the state is reverted with
    revert();.**'
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **如果call()失败，它返回false，并且通过revert()恢复状态；。**'
- en: Fallback function
  id: totrans-435
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 回退函数
- en: A contract can declare one unnamed (or anonymous) payable function that can’t
    have any input or output parameters. This becomes a *fallback* function in case
    a client call doesn’t match any of the available contract functions, or in case
    only plain Ether is sent to the contract via `send()`, `transfer(),` or `call()`.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 合约可以声明一个未命名（或匿名）的支付函数，该函数不能有任何输入或输出参数。如果客户端调用不匹配任何可用的合约函数，或者仅通过`send()`、`transfer()`或`call()`向合约发送普通以太币，这个函数就成为了一个*回退*函数。
- en: The gas budget transferred to the fallback function is minimal if you call the
    fallback function by `send()` or `transfer()`. In this case, its implementation
    must avoid any costly operations, such as writing to storage, sending Ether, or
    calling internal or external functions that have complex or lengthy logic. A `send()`
    or `transfer()` call on a nonminimal fallback implementation is likely to run
    out of gas and fail almost immediately. You must avoid this situation because
    it puts Ether at risk of getting lost or even stolen, as you’ll see in the chapter
    dedicated to security.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你通过`send()`或`transfer()`调用回退函数，传递给回退函数的gas预算是最小的。在这种情况下，其实现必须避免任何成本高昂的操作，如写入存储、发送以太币或调用具有复杂或繁琐逻辑的内部或外部函数。在一个非最小的回退实现上的`send()`或`transfer()`调用很可能会耗尽gas并几乎立即失败。你必须避免这种情况，因为这将使以太币面临丢失或甚至被盗的风险，正如你在专门讲述安全的章节中所看到的。
- en: 'The following code shows the classic *minimal fallback* function implementation,
    which allows incoming `send()` and `transfer()` calls to complete an Ether transfer
    successfully:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码展示了经典的*最小回退*函数实现，它允许传入的`send()`和`transfer()`调用成功完成以太币转账：
- en: '[PRE51]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'You also can implement a fallback function so that it prevents the contract
    from accepting Ether if it isn’t meant to:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以实现一个回退函数，以防止合约在不应该接受以太币的情况下接受以太币：
- en: '[PRE52]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '|  |'
  id: totrans-442
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Warning
  id: totrans-443
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: As you’ll see in the chapter dedicated to security, the fallback function offers
    malicious participants various ways of attacking a contract, so if you decide
    to provide a fallback, you must learn how to implement it correctly.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在专门讲述安全的章节中看到的，回退函数为恶意参与者提供了攻击合约的各种方式，所以如果你决定提供回退函数，你必须学会如何正确实现它。
- en: '|  |'
  id: totrans-445
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Getter functions
  id: totrans-446
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 获取器函数
- en: As I mentioned earlier, the compiler automatically generates a getter function
    for each public state variable declared in the contract. The getter function gets
    the name of the state variable it exposes. For example, given the usual contract
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前提到的，编译器会自动为合约中声明的每个公共状态变量生成一个获取器函数。获取器函数获得它暴露的状态变量的名称。例如，给定一个通常的合约
- en: '[PRE53]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'you can consult the balance of an account as follows:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以如下查询一个账户的余额：
- en: '[PRE54]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'A getter function is implicitly declared as `public` and `view`, so it’s possible
    to invoke it from within the contract through `this`, as shown in the following
    code:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 获取器函数默认声明为`public`和`view`，因此可以通过`this`在合约内调用它，如下面代码所示：
- en: '[PRE55]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '***1*** **This check is performed with a getter, but you could have it performed
    by accessing the mapping directly: this.coinBalance[_account], the only difference
    being parentheses versus square brackets.**'
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **这个检查是通过一个获取器来完成的，但你也可以直接访问映射来实现：this.coinBalance[_account]，两者唯一的区别在于括号和方括号的使用。**'
- en: You can alter the behavior of functions with function modifiers. Keep reading
    to see how.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过函数修改器来改变函数的行为。继续阅读了解具体方法。
- en: 5.3.6\. Function modifiers
  id: totrans-455
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.3.6. 函数修改器
- en: A function modifier alters the behavior of a function by performing some pre-
    and postprocessing around the execution of the function using it. As an example
    of a preprocessing modifier, the code in [listing 5.6](#ch05ex06) shows `onlyOwner,`
    a typical modifier that allows the function to be called only if the caller is
    the contract owner, which is the account that instantiated the contract. `isActive`
    is a parameterized modifier that checks if the input user account isn’t frozen.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 函数修改器通过在函数执行前后执行一些预处理和后处理来改变函数的行为。作为一个预处理修改器的示例，[列表5.6](#ch05ex06)中的代码显示了`onlyOwner,`这是一个典型的修改器，它只允许合约的创建者（即实例化合约的账户）调用函数。`isActive`是一个参数化修改器，它检查输入的用户账户是否没有冻结。
- en: Listing 5.6\. Example of a contract with function modifiers
  id: totrans-457
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.6\. 带有函数修改器的合约示例
- en: '[PRE56]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '***1*** **Sets the contract owner address at instantiation**'
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **实例化时设置合约拥有者地址**'
- en: '***2*** **Modifier definition**'
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **修改器定义**'
- en: '***3*** **Associates a modifier with a function in this way**'
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **通过这种方式将修改器与函数关联**'
- en: '***3*** **A function can have more than one modifier.**'
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **函数可以有多个修改器。**'
- en: 'From a certain point of view, you can look at a modifier as an implementation
    of the classic *decorator* design pattern, as it adds behavior to a function without
    modifying its logic. As for decorators, you can chain modifiers, and you can attach
    several of them to a function, as shown in the `refund()` function, which can
    execute only if the caller is the contract owner and the user account isn’t frozen:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 从某个角度来看，你可以将修改器视为经典*装饰器*设计模式的实现，因为它在不修改函数逻辑的情况下为函数添加了行为。正如装饰器一样，你可以链接修改器，也可以将几个修改器附加到一个函数上，如`refund()`函数所示，它只能由合约拥有者调用，且用户账户没有冻结才能执行：
- en: '[PRE57]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '|  |'
  id: totrans-465
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Warning
  id: totrans-466
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: Modifiers get called in the reverse order from how they’ve been placed on the
    function definition. In the example, `isActive` is applied first and `onlyOwner`
    second.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 修改器按照在函数定义中的放置顺序相反的顺序被调用。在示例中，`isActive`是首先应用的，`onlyOwner`是第二个。
- en: '|  |'
  id: totrans-468
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 5.3.7\. Variable declaration, initialization, and assignment
  id: totrans-469
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.3.7\. 变量声明、初始化与赋值
- en: Earlier, I explained how the calling code respectively sets and handles the
    input and output function parameters. I also illustrated relatively complex cases,
    such as how you can assign multiple variables from tuple results. In this section,
    I’ll present more information about the declaration, initialization, and assignment
    of local function variables. Some of the considerations also apply to state variables.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 早些时候，我解释了调用代码如何分别设置和处理输入和输出函数参数。我还展示了相对复杂的情况，比如你是如何可以从元组结果中分配多个变量的。在本节中，我将提供更多关于局部函数变量的声明、初始化和赋值的信息。一些考虑也适用于状态变量。
- en: Implicit initialization
  id: totrans-471
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 隐式初始化
- en: Contrary to most statically typed languages, which force the developer to explicitly
    initialize variables, when you declare a variable in Solidity, it’s implicitly
    initialized to its default value, corresponding to its bits being all set to zero,
    as summarized in [table 5.8](#ch05table08).
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数静态类型语言不同，这些语言强制开发者显式初始化变量，当你在Solidity中声明一个变量时，它会隐式初始化为它的默认值，对应于其位全部设置为零，如[表5.8](#ch05table08)所总结。
- en: Table 5.8\. Default values of solidity types
  id: totrans-473
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表5.8\. Solidity类型的默认值
- en: '| Type | Default value | Example |'
  id: totrans-474
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 默认值 | 示例 |'
- en: '| --- | --- | --- |'
  id: totrans-475
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| int and uint (all sizes) | 0 | int32 a; //0 |'
  id: totrans-476
  prefs: []
  type: TYPE_TB
  zh: '| int和uint（所有大小） | 0 | int32 a; //0 |'
- en: '| bool | false | bool flag; //false |'
  id: totrans-477
  prefs: []
  type: TYPE_TB
  zh: '| bool | false | bool flag; //false |'
- en: '| bytes1 to bytes32 | All bytes set to 0 | bytes4 byteArray; // 0x00000000
    |'
  id: totrans-478
  prefs: []
  type: TYPE_TB
  zh: '| bytes1到bytes32 | 所有字节设置为0 | bytes4 byteArray; // 0x00000000 |'
- en: '| Static array | All items set to zero value | bool [3] flags; // [false, false,
    false] |'
  id: totrans-479
  prefs: []
  type: TYPE_TB
  zh: '| 静态数组 | 所有项设置为零值 | bool [3] flags; // [false, false, false] |'
- en: '| bytes | Empty byte array | [] |'
  id: totrans-480
  prefs: []
  type: TYPE_TB
  zh: '| bytes | 空字节数组 | [] |'
- en: '| Dynamic array | Empty array | int [] values; // [] |'
  id: totrans-481
  prefs: []
  type: TYPE_TB
  zh: '| 动态数组 | 空数组 | int [] values; // [] |'
- en: '| string | Empty string | "" |'
  id: totrans-482
  prefs: []
  type: TYPE_TB
  zh: '| string | 空字符串 | "" |'
- en: '| struct | Each element set to the default value |  |'
  id: totrans-483
  prefs: []
  type: TYPE_TB
  zh: '| 结构体 | 每个元素设置为默认值 |  |'
- en: '|  |'
  id: totrans-484
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-485
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: As explained in [table 5.8](#ch05table08), initialized variables are set to
    a zero-like value. There is no `null` value in Solidity.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 如[表5.8](#ch05table08)所解释，初始化的变量被设置为零值类似的数值。Solidity中没有`null`值。
- en: '|  |'
  id: totrans-487
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Delete
  id: totrans-488
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 删除
- en: 'You can reinitialize the value of a variable to its default value, as shown
    in [table 5.8](#ch05table08), by calling `delete` on it, as shown in the following
    code:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过调用`delete`将其值重新初始化为默认值，如[表5.8](#ch05table08)所示，如下面的代码所示：
- en: '[PRE58]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '***1*** **Implicitly reinitializes fixedSlots to [int32 (0), 0, 0, 0, 0]**'
  id: totrans-491
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **隐式重新初始化 fixedSlots 为 [int32 (0), 0, 0, 0, 0]**'
- en: You can execute this in Remix. Make sure you check the final value of `fixedSlots`
    in the output panel on the bottom left, as usual.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 Remix 中执行这个操作。确保你检查左下角输出面板中`fixedSlots`的最终值，像往常一样。
- en: Implicitly typed declaration
  id: totrans-493
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 隐式类型声明
- en: 'You can declare the type of a variable implicitly with `var` if this can be
    inferred from an explicit initialization, as shown in this code:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你可以从显式初始化中推断出变量的类型，你可以使用`var`隐式声明变量，如下面的代码所示：
- en: '[PRE59]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '***1*** **Implicitly declares _gammaParams as int32 [2]**'
  id: totrans-496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **隐式声明 _gammaParams 为 int32 [2]**'
- en: '***2*** **Implicitly declares _gamma as int**'
  id: totrans-497
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **隐式声明 _gamma 为 int**'
- en: '|  |'
  id: totrans-498
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-499
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Implicitly typed variable declaration with `var` doesn’t mean Solidity supports
    dynamic typing. It means you can perform the type declaration implicitly rather
    than explicitly, but still at compile time.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`var`隐式声明变量并不意味着 Solidity 支持动态类型。这意味着你可以隐式地而不是显式地进行类型声明，但仍然是在编译时。
- en: '|  |'
  id: totrans-501
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Multiple implicitly typed declarations are also possible when *destructuring*
    a tuple returned from a function to multiple variables. For example, given the
    following `calculate()` function
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 当*解构*一个函数返回的元组到多个变量时，也可以隐式地声明多个类型。例如，考虑以下 `calculate()` 函数
- en: '[PRE60]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '***1*** **Returns a tuple including three items**'
  id: totrans-504
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **返回一个包含三个项目的元组**'
- en: '***2*** **Sets the tuple items within the function body**'
  id: totrans-505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **在函数体内设置元组项**'
- en: 'it’s possible to *destructure* the tuple result into three variables, as follows:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将元组结果解构到三个变量中，如下所示：
- en: '[PRE61]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '***1*** **Assigns the tuple returned by calculate() to three variables**'
  id: totrans-508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **将 calculate() 返回的元组分配给三个变量**'
- en: '|  |'
  id: totrans-509
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-510
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: '*Destructuring* means decomposing a tuple into its individual constituents,
    which are then assigned to separate variables.'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 解构意味着将元组分解为其各个组成部分，然后将它们分配给单独的变量。
- en: '|  |'
  id: totrans-512
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tuple assignment
  id: totrans-513
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 元组分配
- en: 'When assigning a tuple to several implicitly or explicitly typed variables,
    the assignment will work if the number of items in the tuple is at least equal
    to the number of variables on the left-hand side of the assignment. This code
    shows examples of correct and incorrect assignments, given the `calculate()` function
    defined earlier:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 当将元组分配给几个隐式或显式类型的变量时，如果元组中的项目数至少等于赋值左侧变量的数量，赋值将生效。这段代码展示了在给定的 `calculate()`
    函数定义的情况下，正确和错误的赋值示例：
- en: '[PRE62]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '***1*** **Ignores the _ok flag but will be successful**'
  id: totrans-516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **忽略 _ok 标志但将成功**'
- en: '***2*** **Will fail with an error because it’s trying to assign four variables
    from a three-item tuple**'
  id: totrans-517
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **将失败并出现错误，因为它试图从三个项目的元组中分配四个变量**'
- en: It’s also possible to set various properties of a `struct` from a tuple. For
    example, given this `struct`
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以从元组中设置 `struct` 的各种属性。例如，给定这个 `struct`
- en: '[PRE63]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'it’s possible to set its properties as follows:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 可以像以下这样设置其属性：
- en: '[PRE64]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '***1*** **Destructures the tuple result into the properties of a Factors struct
    object. (Note that, as in the previous example, the _ok flag that calculate()
    returns has been ignored.)**'
  id: totrans-522
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **将元组结果解构为 Factors 结构对象的属性。（注意，与之前的示例一样，calculate() 返回的 _ok 标志已被忽略。）**'
- en: 5.3.8\. Events
  id: totrans-523
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.3.8. 事件
- en: 'An event allows a contract to notify another contract or a contract client,
    such as a Dapp user interface, that something of interest has occurred. You declare
    events like you do in C# and Java and publish them with the `emit` keyword, as
    you can see in the following code extract from `SimpleCoin`:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 事件允许合约通知另一个合约或合约客户端，例如一个 Dapp 用户界面，发生了感兴趣的事情。你像在 C# 和 Java 中一样声明事件，并使用 `emit`
    关键字发布它们，正如你在 `SimpleCoin` 中的以下代码片段所看到的那样：
- en: '[PRE65]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '***1*** **Defines the Transfer event**'
  id: totrans-526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **定义 Transfer 事件**'
- en: '***2*** **Publishes the Transfer event with emit**'
  id: totrans-527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **使用 emit 发布 Transfer 事件**'
- en: 'Events in Ethereum haven’t only a real-time notification purpose, but also
    a long-term logging purpose. Events are logged on the transaction log of the blockchain,
    and you can retrieve them later for analysis. To allow quick retrieval, events
    are indexed against a key that you can define when you declare the event. The
    key can be composite and contain up to three of its input parameters, as you can
    see in the definition of Transfer shown previously:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: Ethereum中的事件不仅有实时通知的作用，还有长期记录的作用。事件被记录在区块链的交易日志上，你可以稍后 retrieve 它们进行分析。为了快速检索，事件会根据一个你可以在其声明时定义的键进行索引。该键可以是复合的，并包含多达三个其输入参数，正如你之前在`Transfer`的定义中看到的：
- en: '[PRE66]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: In [chapter 6](kindle_split_018.xhtml#ch06), you’ll see how to listen and react
    to Solidity events from client JavaScript code. In [chapter 13](kindle_split_027.xhtml#ch13),
    you’ll learn more about how events get logged on the blockchain and how you can
    reply to them and retrieve them.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](kindle_split_018.xhtml#ch06)中，你将了解如何监听并从客户端JavaScript代码中响应Solidity事件。在[第13章](kindle_split_027.xhtml#ch13)中，你将了解更多关于事件如何在区块链上记录，以及你如何回复和检索它们的信息。
- en: 5.3.9\. Conditional statements
  id: totrans-531
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.3.9. 条件语句
- en: 'Solidity supports all classic conditional statements available in C-like and
    Java-like languages:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: Solidity支持所有在C-like和Java-like语言中可用的经典条件语句：
- en: '`if ... else`'
  id: totrans-533
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if ... else`'
- en: '`while`'
  id: totrans-534
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`while`'
- en: '`do ... while`'
  id: totrans-535
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`do ... while`'
- en: '`for`'
  id: totrans-536
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for`'
- en: Loops support both continue and break statements.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 循环支持`continue`和`break`语句。
- en: You’ve completed the first part of your tour of Solidity. If you want to learn
    more about the syntax I’ve introduced in this chapter, I encourage you to consult
    the official documentation at [https://solidity.readthedocs.io/en/develop/](https://solidity.readthedocs.io/en/develop/).
    In the next section, you’ll apply what you’ve learned in this chapter to improve
    `SimpleCoin`. The Solidity tour will then continue in the next chapter, where
    you’ll start writing code in an object-oriented way and learn about other advanced
    features of the language.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经完成了Solidity之旅的第一部分。如果你想要了解更多关于我在这章中介绍的语法，我鼓励你参考官方文档[https://solidity.readthedocs.io/en/develop/](https://solidity.readthedocs.io/en/develop/)。在下一节中，你将应用本章学到的知识来改进`SimpleCoin`。Solidity之旅将在下一章继续，你将开始以面向对象的方式编写代码，并学习该语言的其他高级特性。
- en: '|  |'
  id: totrans-539
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Warning
  id: totrans-540
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: Although you might think that because transactions are executed sequentially
    within the EVM, concurrency issues might not come up within a contract, this isn’t
    entirely true. A contract might invoke a function on an external contract, and
    this might lead to concurrency issues, especially if the external contract calls
    back the caller, as you’ll see in [chapter 14](kindle_split_028.xhtml#ch14) on
    security.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可能认为，因为交易在EVM中是顺序执行的，所以在合约内部可能不会出现并发问题，但这并不完全正确。一个合约可能会调用外部合约上的一个函数，这可能会导致并发问题，特别是在外部合约回调调用者的情况下，正如你在[第14章](kindle_split_028.xhtml#ch14)关于安全性的内容中将会看到的那样。
- en: '|  |'
  id: totrans-542
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 5.4\. Time to improve and refactor SimpleCoin
  id: totrans-543
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4. 是时候改进和重构SimpleCoin了
- en: 'In this section, you’ll extend `SimpleCoin`’s functionality as follows:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将按照以下方式扩展`SimpleCoin`的功能：
- en: You’ll let the owner of an account authorize an allowance to another account.
  id: totrans-545
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你会让账户的所有者授权另一个账户使用允许额度。
- en: You’ll restrict certain operations, such as minting coins or freezing accounts,
    only to the contract owner.
  id: totrans-546
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你会限制某些操作，如铸币或冻结账户，只能由合约所有者执行。
- en: Before making any changes, open Remix and enter the latest version of the `SimpleCoin`
    code from [chapter 4](kindle_split_015.xhtml#ch04), as shown in the following
    listing, into the editor.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行任何更改之前，打开Remix并将[第4章](kindle_split_015.xhtml#ch04)中的`SimpleCoin`最新代码版本输入到编辑器中，如下面的列表所示。
- en: Listing 5.7\. Latest version of `SimpleCoin` from [chapter 4](kindle_split_015.xhtml#ch04)
  id: totrans-548
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.7. `SimpleCoin`的最新版本来自[第4章](kindle_split_015.xhtml#ch04)
- en: '[PRE67]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Now you can try letting the owner of an account authorize an allowance that
    another account can use. This means that if account A has 10,000 coins, its owner
    can authorize account B to transfer a certain amount of coins (say up to a total
    of 200 in separate transfer operations) to other accounts.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以尝试让一个账户的所有者授权另一个账户使用允许额度。这意味着如果账户A有10,000枚硬币，其所有者可以授权账户B转移一定数量的硬币（比如说总共在单独的转移操作中达到200枚）到其他账户。
- en: 5.4.1\. Implementing an allowance facility
  id: totrans-551
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.4.1. 实现授权设施
- en: 'You can model a token allowance with a nested mapping:'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用嵌套映射来建模代币允许额度：
- en: '[PRE68]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'This means that an account allows one or more accounts to manage a specified
    number of coins; for example:'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着一个账户允许一个或多个账户管理一定数量的硬币；例如：
- en: '[PRE69]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '***1*** **address2 can manage 200 coins of the address1 balance.**'
  id: totrans-556
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **address2可以管理address1余额中的200个硬币。**'
- en: '***2*** **address3 can manage 150 coins of the address1 balance.**'
  id: totrans-557
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **address3可以管理address1余额中的150个硬币。**'
- en: 'You can authorize an allowance by calling the following function:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过调用以下函数授权允许额：
- en: '[PRE70]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '***1*** **Allows authorizedAccount to manage a number of coins equal to _allowance**'
  id: totrans-560
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **允许authorizedAccount管理等于_allowance的硬币数量**'
- en: 'Once an account has been authorized an allowance, it can transfer a number
    of coins, up to the unused allowance, to another account, with the following function:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦一个账户被授权了允许额，它就可以将一定数量的硬币（不超过未使用的允许额）转给另一个账户，通过以下函数：
- en: '[PRE71]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '***1*** **Prevents transfer to 0x0 address, which is a default address if not
    specified explicitly**'
  id: totrans-563
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **防止向0x0地址转账，这是一个如果没有明确指定就会默认的地址**'
- en: '***2*** **Checks if the source account has enough coins**'
  id: totrans-564
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **检查源账户是否有足够的硬币**'
- en: '***3*** **Checks for overflow**'
  id: totrans-565
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **检查溢出**'
- en: '***4*** **Checks unused allowance**'
  id: totrans-566
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **检查未使用允许额**'
- en: '***5*** **Debits source account**'
  id: totrans-567
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **从源账户扣款**'
- en: '***6*** **Increases recipient account**'
  id: totrans-568
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** **增加接收账户**'
- en: '***7*** **Decreases unused allowance**'
  id: totrans-569
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7*** **减少未使用允许额**'
- en: '***8*** **Raises Transfer event**'
  id: totrans-570
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8*** **触发转账事件**'
- en: The implementation of the allowance facility was relatively simple. Now you
    can see how to restrict some `SimpleCoin` functionality only to the contract owner.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 允许额度的实施相对简单。现在你可以看到如何限制一些`SimpleCoin`功能仅限于合约所有者。
- en: 5.4.2\. Restricting operations only to the contract owner
  id: totrans-572
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.4.2\. 限制操作仅限于合约所有者
- en: 'The contract owner is the account from which the contract gets deployed. `SimpleCoin`
    already has an operation that’s executed against the contract owner. As you’ll
    remember, the constructor assigns the initial token supply to the contract owner,
    although this assignment is implicit:'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 合约所有者是部署合约的账户。`SimpleCoin`已经有一个针对合约所有者的操作。正如你所记得的，构造函数将初始代币供应分配给合约所有者，尽管这个分配是隐含的：
- en: '[PRE72]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: You can make the intention of the code more explicit by declaring the contract
    owner as address public owner; then you can change the constructor to
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过声明合约所有者为公开地址public owner，使代码的意图更加明确；然后你可以更改构造函数为：
- en: '[PRE73]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '***1*** **Initializes the contract owner with the address of the account deploying
    the contract**'
  id: totrans-577
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **初始化合约所有者为部署合约的账户地址**'
- en: '***2*** **Assigns the initial token supply explicitly to the contract owner**'
  id: totrans-578
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **显式将初始代币供应分配给合约所有者**'
- en: Minting coins
  id: totrans-579
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 铸币硬币
- en: 'After you’ve initialized the `owner` variable, you can restrict the execution
    of some functions to require that the contract owner invoke them. For example,
    you could extract the constructor code assigning the initial supply to the owner
    into a new, more general function:'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化`owner`变量之后，你可以限制某些函数的执行仅限于合约所有者调用它们。例如，你可以将分配初始供应给所有者的构造函数代码提取到一个更通用的新函数中：
- en: '[PRE74]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '***1*** **Restricts the invocation of this function only to the contract owner**'
  id: totrans-582
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **限制此函数的调用仅限于合约所有者**'
- en: '***2*** **Assigns the minted amount to the recipient**'
  id: totrans-583
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **将铸币金额分配给接收者**'
- en: 'Then you can change the constructor as follows:'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你可以按照以下方式更改构造函数：
- en: '[PRE75]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '***1*** **The initial supply is now generated through the mint() function.**'
  id: totrans-586
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **现在初始供应通过mint()函数生成。**'
- en: The `mint()` function now allows the owner to generate coins at will, not only
    at construction. The check performed on the first line of `mint()` makes sure
    only the owner can generate mint coins.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`mint()`函数允许所有者随意生成硬币，不仅在构造时。`mint()`函数第一行执行的检查确保只有所有者可以生成铸币硬币。
- en: '|  |'
  id: totrans-588
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-589
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: When looking at the code of token modeling smart contracts, you’ll often find
    that functions that generate new coins or tokens are named `mint()`, after the
    English verb that’s associated with making conventional metallic coins as currency.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看代币建模智能合约的代码时，你经常会发现生成新硬币或代币的功能被命名为`mint()`，这个名字来源于英语动词，与制作传统金属货币有关。
- en: '|  |'
  id: totrans-591
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Freezing accounts
  id: totrans-592
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 冻结账户
- en: 'You might want to further extend the powers of the contract owner and grant
    them the exclusive ability to freeze accounts. You can model the set of accounts
    that have been frozen with the following mapping:'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想要进一步扩大合约所有者的权力，并授予他们独家冻结账户的能力。你可以通过以下映射建模已经被冻结的账户集合：
- en: '[PRE76]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The ideal data structure probably would be a Python set (or a C# `Set` or a
    Java `HashSet`), which would allow you to store frozen addresses (the keys of
    the mapping above) and check them efficiently without having to store any associated
    value (for example, the Boolean flag in the previous mapping). But a mapping of
    an address to a Boolean can be considered a close approximation to a set of addresses.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 理想的数据结构可能是一个Python集合（或C# `Set`或Java `HashSet`），这将允许你存储冻结地址（上面映射的键）并有效地检查它们，而无需存储任何关联值（例如，前面映射中的布尔标志）。但是，可以将地址到布尔值的映射视为地址集合的一个近似。
- en: 'You also can declare an event you can publish when freezing an account:'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以声明一个事件，在冻结账户时发布：
- en: '[PRE77]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The owner would then freeze an account with the following function:'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，所有者可以使用以下函数冻结账户：
- en: '[PRE78]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '***1*** **Restricts the invocation of this function only to the contract owner**'
  id: totrans-600
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **只允许合约所有者调用这个函数**'
- en: '***2*** **Adds the target account to the set of frozen accounts**'
  id: totrans-601
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **将目标账户添加到冻结账户集合中**'
- en: '***3*** **Raises the event**'
  id: totrans-602
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **引发事件**'
- en: '|  |'
  id: totrans-603
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-604
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: You can use the `freezeAccount()` function to freeze or unfreeze accounts depending
    on the value of the Boolean parameter.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`freezeAccount()`函数根据布尔参数的值来冻结或解冻账户。
- en: '|  |'
  id: totrans-606
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: You might have noticed that the check being performed on `msg.sender`, which
    restricts the caller of this function to only the owner, is exactly the same as
    what you have on `mint()`. Wouldn’t it be nice to encapsulate this check in a
    reusable way? Hold on ... this is exactly the purpose of function modifiers!
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，正在对`msg.sender`执行的检查， restricts the caller of this function to only
    the owner，与你在`mint()`上执行的完全一样。难道不好把它封装成一种可复用的方法吗？等等...这正是函数修饰语的目的！
- en: Creating the onlyOwner modifier
  id: totrans-608
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 创建`onlyOwner`修饰语
- en: 'I know, I know! If you’re among the readers who paid attention to the `onlyOwner`
    modifier I presented in [listing 5.6](#ch05ex06), I bet you were wondering with
    frustration why I hadn’t used it since the beginning of this section. Well, I
    wanted to show you the usefulness of modifiers the hard way. Now you can refactor
    the duplicated check of the message sender’s address against the owner’s address
    into the `onlyOwner` modifier:'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道，我知道！如果你是那些关注我在[列表 5.6](#ch05ex06)中介绍的`onlyOwner`修饰语的读者，我敢打赌你会气愤地想知道为什么我从这一部分一开始就没有使用它。嗯，我就是想让你艰难地了解修饰语的实用性。现在你可以将消息发送者地址与所有者地址的重复检查重构为`onlyOwner`修饰语：
- en: '[PRE79]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '***1*** **Won’t allow message callers who aren’t the contract owner to call
    the modified function.**'
  id: totrans-611
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **不允许合约所有者之外的调用者调用修改后的函数。**'
- en: 'You can then simplify `mint()` and `freezeAccount()` as follows:'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以简化`mint()`和`freezeAccount()`如下：
- en: '[PRE80]'
  id: totrans-613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '***1*** **The onlyOwner modifier replaces the previous check on msg.sender.**'
  id: totrans-614
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **`onlyOwner`修饰语替换了之前的对`msg.sender`的检查。**'
- en: You can see the improved `SimpleCoin` contract, including allowance setting
    and restricted coin minting and account freezing functionality, in the following
    listing.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到改进后的`SimpleCoin`合约，包括允许设置和限制币铸造、账户冻结功能的以下列表。
- en: Listing 5.8\. Refactored version of `SimpleCoin` with extended functionality
  id: totrans-616
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.8\. `SimpleCoin`的扩展功能的重构版本
- en: '[PRE81]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: You’ve completed the implementation of the proposed improvements. Along the
    way, you’ve seen a function modifier in action. In the next chapter, which will
    focus on Solidity’s more advanced object-oriented features, you’ll further improve
    `SimpleCoin`’s code.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经完成了提议的改进的实现。在这个过程中，你看到了一个函数修饰语的实际应用。在下一章中，将重点介绍Solidity的高级面向对象特性，你将进一步改进`SimpleCoin`的代码。
- en: Summary
  id: totrans-619
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: Various EVM languages have been developed, but Solidity is the most popular
    one.
  id: totrans-620
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然已经开发出了各种EVM语言，但Solidity是最受欢迎的。
- en: The structure of a Solidity smart contract is similar to the structure of an
    object-oriented class.
  id: totrans-621
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Solidity智能合约的结构与面向对象类结构相似。
- en: 'Solidity has two main groups of types: value types, which include enums, primitive
    types (integer types, `bool`, `address`), and functions; and reference types,
    which include arrays, strings, structs, and mapping.'
  id: totrans-622
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Solidity有两大类类型：值类型，包括枚举、原始类型（整数类型、`bool`、`address`）和函数；以及引用类型，包括数组、字符串、结构体和映射。
- en: You can store reference type objects in any memory or in storage.
  id: totrans-623
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以将引用类型对象存储在任何内存或存储中。
- en: You always store state variables in storage, never in memory.
  id: totrans-624
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你总是将状态变量存储在存储中，从不存储在内存中。
- en: Functions are the equivalent of object-oriented methods; they can accept several
    parameters and can return a single result or several results in a tuple.
  id: totrans-625
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An unassigned variable is set with a default value depending on its type.
  id: totrans-626
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can destructure a tuple returned from a function into separate variables.
  id: totrans-627
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can define both state variables and functions with a specific accessibility
    level: private, internal, public, or external. (The latter only applies to functions.)'
  id: totrans-628
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chapter 6\. Writing more complex smart contracts
  id: totrans-629
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-630
  prefs: []
  type: TYPE_TB
- en: '**This chapter covers**'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
- en: Building a crowdsale management Dapp showing how to structure complex contracts
  id: totrans-632
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending the crowdsale management Dapp through single and multiple inheritance
  id: totrans-633
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-634
  prefs: []
  type: TYPE_TB
- en: The purpose of the previous chapter was to give you a foundation in Solidity,
    so I focused mainly on the basic syntax that the language offers. In the next
    two chapters, I’ll introduce more advanced object-oriented (OO) features. I’ll
    start with inheritance in [chapter 6](#ch06) and follow with abstract contracts
    and interfaces in [chapter 7](kindle_split_019.xhtml#ch07). These OO features
    allow you to reduce code duplication and make your contracts more composable.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
- en: The contract side of real-world Dapps is generally more complex than the single-contract
    Dapp you’ve seen so far with SimpleCoin. They often span many contracts interacting
    with each other, with each contract being a concrete instance of a potentially
    complex inheritance structure. In this chapter, I’ll help you build Simple-Crowdsale,
    a basic crowdsale management Dapp. A crowdsale is the process through which investors
    fund a Dapp by buying tokens issued by the organization that’s developing it.
    This sample application will give you an idea of how complex the smart contract
    layer of a realistic Dapp can be and how inheritance, abstract classes, and interfaces
    can help you model it appropriately.
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
- en: I’ll try to keep my presentation of inheritance and polymorphism as pragmatic
    as possible, so if you’re among the readers who need a refresher on object-oriented
    programming, you’ll still be able to follow easily. I’ll start by building an
    application made of a simple contract, and I’ll keep extending it throughout this
    chapter by introducing all the object features I’ve mentioned, bit by bit.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
- en: 6.1\. Introducing SimpleCrowdsale, a crowdsale contract
  id: totrans-638
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I bet you’ve heard the term crowdfunding, which is a way of funding a project
    or a cause through relatively small contribution amounts from a relatively large
    number of people. You might have even invested some funds toward the design of
    a new cool gadget at [Kickstarter.com](http://Kickstarter.com), [Indiegogo.com](http://Indiegogo.com),
    or [Microventures.com](http://Microventures.com). If so, depending on the amount
    of money you contributed and whether the project was successful, you might have
    been given an early version of the gadget, or you might have been given a considerable
    discount on the final official price of the product. This type of scheme is called
    *reward-based* crowdfunding.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 我敢打赌你一定听过众筹这个词，这是一种通过相对较小的金额来自相对较多的人的资金筹集方式来资助一个项目或一个原因。你甚至可能在[Kickstarter.com](http://Kickstarter.com)、[Indiegogo.com](http://Indiegogo.com)或[Microventures.com](http://Microventures.com)投资一些资金用于设计一个新潮的小玩意。如果是这样，根据你投资的金额和项目是否成功，你可能会得到这个玩意的早期版本，或者你可能会在产品的最终官方价格上得到相当大的折扣。这种方案称为*基于奖励*的众筹。
- en: Lately, a new crowdfunding scheme called *crowdsale* has emerged, mainly geared
    toward the funding of startup companies. Rather than being given a discounted
    product or service in recognition for your early contribution, you’re offered
    some equity in the venture, generally in the form of a monetary token similar
    to SimpleCoin, whose value the organizers can set before the sale starts. Alternatively,
    the value can be determined dynamically during the campaign, depending on market
    factors such as initial token supply and actual demand. Often, the token or coin
    crowdsale is called an *initial coin offering (ICO)*, an expression that mirrors
    the more conventional initial public offering (IPO) of shares by companies that
    enter the stock market for the first time.
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，一种名为*代币众筹*的新众筹模式出现，主要面向初创公司的资金筹集。你不是因为早期贡献而获得打折的产品或服务，而是被提供一些创业公司的股权，通常以类似于SimpleCoin的货币代币的形式出现，其价值组织者在销售开始前可以设定。或者，价值可以在活动期间根据市场因素，如初始代币供应量和实际需求动态确定。通常，代币或硬币众筹被称为*首次代币发行
    (ICO)*，这个表达反映了更传统的公司首次上市时股票的首次公开募股（IPO）。
- en: 'In this section, you’ll build SimpleCrowdsale, a decentralized crowdsale management
    application that will teach you how to design Dapps based on multiple Solidity
    contracts and libraries. In a nutshell, the following list describes the minimum
    functionality a crowdsale contract generally provides, as illustrated in the diagram
    of the core crowdsale workflow in [figure 6.1](#ch06fig01):'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将构建SimpleCrowdsale，一个去中心化的众筹管理应用程序，它将教你如何基于多个Solidity合约和库设计Dapps。简而言之，以下列表描述了一个众筹合约通常提供的最小功能，如图6.1中的核心众筹工作流程所示：[图6.1](#ch06fig01)。
- en: It manages the funding that crowdsale investors provide during the funding stage,
    generally in the form of cryptocurrency. It also converts the cryptocurrency received
    into tokens and assigns them to the respective investors.
  id: totrans-642
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它管理众筹投资者在资金阶段提供的资金，通常以加密货币的形式。它还将收到的加密货币转换为代币，并将它们分配给相应的投资者。
- en: If the crowdsale objectives, such as a minimum investment target or a time limit,
    have been met, it releases the tokens to the investors. The organization developing
    the Dapp keeps the Ether collected and will use it to fund project costs. A token
    bonus might be granted to the organizers, the development team, or other parties
    involved with the token sale. Releasing tokens means activating them so they can
    be used. *Investors can exchange tokens* through a token exchange for real cash
    as soon as the token has become profitable with respect to the initial investment.
    This process is similar to that of a company that goes public and issues shares
    to investors in exchange for cash, which it will then use to fund its activities.
    Investors can subsequently trade their shares in a secondary market, and those
    shares can become more or less valuable depending on the success of the company.
  id: totrans-643
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果众筹目标，如最低投资额或时间限制等，已达成，它将释放代币给投资者。开发Dapp的组织保留所收集的以太币，并将其用于资助项目成本。可能会向组织者、开发团队或参与代币销售的其它方授予代币奖励。释放代币意味着激活它们，使它们能够被使用。*投资者可以通过代币交易所*用代币换取现金，一旦代币相对于初始投资变得有利可图。这一过程与公司上市并发行股票给投资者以换取现金类似，随后它将用这些现金来资助其活动。投资者可以在随后的事务市场上交易他们的股票，这些股票的价值可能会根据公司的成功与否而增加或减少。
- en: If the crowdsale is unsuccessful—the target investment isn’t met, for example—the
    contract allows the investors to have their investments refunded.
  id: totrans-644
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果众售不成功——例如没有达到目标投资额——合约允许投资者要求退款。
- en: 'Figure 6.1\. The core crowdsale workflow: 1) investors book crowdsale tokens
    by paying for them in cryptocurrency; 2) if the crowdsale has met the minimum
    funding target, tokens are released to the investors; a token bonus might be granted
    to the organizers, the development team, or other parties involved with the token
    sale; and the project organization keeps the Ether received and will use it to
    fund project costs; 3) if the crowdsale is unsuccessful, investors can be refunded.'
  id: totrans-645
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.1\. 众售的核心工作流程：1) 投资者通过支付加密货币来预订众售代币；2) 如果众售达到了最低融资目标，代币将被释放给投资者； 代币奖金可能会授予组织者，开发团队或参与代币销售的其它方；
    项目组织保留收到的以太币，并将其用于资助项目成本；3) 如果众售不成功，投资者可以获得退款。
- en: '![](Images/fig06-01_alt.jpg)'
  id: totrans-646
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fig06-01_alt.jpg)'
- en: '[listing 6.1](#ch06ex01) gives you an idea of the functions a crowdsale Solidity
    contract would need to fulfill these requirements. (Don’t enter the code in Remix
    yet!) In case you’re wondering, `onlyOwner` is the same modifier I introduced
    earlier in 5.4.2 for `SimpleCoin`: only the contract owner is allowed to execute
    the `finalize()` function.'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表6.1](#ch06ex01) 让你对众售Solidity合约需要实现的功能有一个大致的了解。 （现在还不要在Remix中输入代码！） 如果你好奇，`onlyOwner`
    是我在5.4.2节的`SimpleCoin`中介绍过的同一个修改器：只有合约所有者被允许执行`finalize()`函数。'
- en: Listing 6.1\. Core functionality a crowdsale contract provides
  id: totrans-648
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.1\. 众售合约提供的核心功能
- en: '[PRE82]'
  id: totrans-649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '***1*** **Allows an investor to book crowdsale tokens. (No parameter is necessary
    to specify the amount of Ether being invested because it’s being sent through
    the msg.value property.)**'
  id: totrans-650
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **允许投资者预订众售代币。（不需要参数来指定投资以太币的数量，因为它是通过msg.value属性发送的。）**'
- en: '***2*** **Allows the crowdsale organizer, who is the contract owner, to release
    tokens to the investors, in case of successful completion, and grant a bonus to
    the development team, if applicable**'
  id: totrans-651
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **允许众售的组织者，即合约所有者，在众售成功完成后向投资者释放代币，如有需要，向开发团队发放奖金**'
- en: '***3*** **Allows an investor to get a refund in case of unsuccessful completion**'
  id: totrans-652
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **允许投资者在众售不成功时获得退款**'
- en: Let’s build a basic implementation of this functionality, which we’ll use as
    a starting point for a later discussion on advanced object-oriented features.
    I’m not expecting you to start entering the code into Remix until you reach 6.1.9,
    as I’ll be refactoring the code progressively to explain concepts step-by-step.
    Then I’ll recap everything in [listing 6.5](#ch06ex05), which is fully executable.
    But if you want to give it a try as I go along, you’re welcome to.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建这个功能的基本实现，我们将把它作为后来讨论高级面向对象特性时的起点。在你达到6.1.9之前，我期望你不要把代码输入到Remix中，因为我会逐步重构代码以逐步解释概念。然后我在[列表6.5](#ch06ex05)中回顾所有内容，这个列表是可以完全执行的。但是如果你想在我进行的过程中尝试一下，你可以这么做。
- en: 6.1.1\. State variables
  id: totrans-654
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.1.1\. 状态变量
- en: 'A crowdsale contract needs to maintain some configuration regarding the funding
    period during which investment contributions are accepted, the price of the token
    being sold, the minimum investment objective, and the address of the account accepting
    the investments. It also needs to keep a record of the contributions that investors
    submit. This data should be visible from the whole contract, so you should express
    it in the following state variables:'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 众售合约需要维护一些关于资金期间的信息，在此期间接受投资贡献，出售代币的价格，最低投资目标以及接受投资的账户地址。 它还需要记录投资者提交的贡献。 这些数据应该可以从整个合约中可见，所以你应该用以下状态变量来表达它：
- en: '[PRE83]'
  id: totrans-656
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '***1*** **Start time, in UNIX epoch, of the crowdsale funding stage**'
  id: totrans-657
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **众售资金阶段的开始时间，以UNIX纪元表示**'
- en: '***2*** **End time, in UNIX epoch, of the crowdsale funding stage**'
  id: totrans-658
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **众售资金阶段的结束时间，以UNIX纪元表示**'
- en: '***3*** **Price of the token being sold**'
  id: totrans-659
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **出售的代币价格**'
- en: '***4*** **Minimum investment objective, which defines if the crowdsale is successful**'
  id: totrans-660
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **最低投资目标，这定义了众售是否成功**'
- en: '***5*** **Amount of Ether received from each investor**'
  id: totrans-661
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **来自每位投资者的以太币金额**'
- en: '***6*** **Total Ether received from the investors**'
  id: totrans-662
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** **从投资者那里收到的总以太币**'
- en: '***7*** **Total Ether refunded to the investors**'
  id: totrans-663
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7*** **向投资者退还的总以太币**'
- en: '***8*** **Flag indicating if the contract has been finalized**'
  id: totrans-664
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8*** **表示合约是否已最终化的标志**'
- en: '***9*** **Flag indicating whether refunding is allowed**'
  id: totrans-665
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***9*** **允许退款的标志**'
- en: '***10*** **Account of the crowdsale contract owner**'
  id: totrans-666
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***10*** **众售合约所有者的账户**'
- en: '***11*** **Instance of the contract of the token being sold. (You’ll use SimpleCoin
    as we left it in [chapter 5](kindle_split_017.xhtml#ch05) for the moment.)**'
  id: totrans-667
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***11*** **众售合约中待售代币的实例。（此刻你将使用我们在第5章中留下的SimpleCoin。）**'
- en: 6.1.2\. Constructor
  id: totrans-668
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.1.2\. 构造函数
- en: 'The contract constructor should take all the input configurations I’ve described,
    validate them, and instantiate the contract of the token being sold. To make things
    easy, you’ll use SimpleCoin, because you’re already familiar with it. You shouldn’t
    find anything surprising in the following code:'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 合约构造函数应该接受我描述的所有输入配置，验证它们，并实例化待售代币的合约。为了简化事情，你将使用SimpleCoin，因为你已经熟悉它。你不会在下面的代码中找到任何令人惊讶的东西：
- en: '[PRE84]'
  id: totrans-670
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '***1*** **Validates input configurations**'
  id: totrans-671
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **验证输入配置**'
- en: '***2*** **Sets input configurations into state variables**'
  id: totrans-672
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **将输入配置设置为状态变量**'
- en: '***3*** **Instantiates the contract of the token being sold in the crowdsale**'
  id: totrans-673
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **实例化众售中的待售代币合约**'
- en: '***3*** **Sets the contract owner, as seen in SimpleCoin**'
  id: totrans-674
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **设置合约所有者，如SimpleCoin所示**'
- en: 6.1.3\. Implementing invest()
  id: totrans-675
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.1.3\. 实现invest()
- en: This is the most important function of the contract. Its purpose is to accept
    Ether funds from investors and convert them into crowdsale tokens. These tokens
    won’t be released to their respective owners, though, until the crowdsale has
    completed successfully.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 这是合约最重要的功能。它的目的是接受投资者提供的以太坊资金并将它们转换成众售代币。不过，这些代币要等到众售成功完成后才会释放给各自的所有者。
- en: 'As you can see in the following implementation, you’ve declared the `invest()`
    function as `payable` and placed validation logic and token conversion logic in
    three internal functions. You’ve also declared a couple of events that these functions
    raise:'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在下面的实现中所看到的，你已经将`invest()`函数声明为`payable`，并在三个内部函数中放置了验证逻辑和代币转换逻辑。你还声明了几个这些函数引发的事件：
- en: '[PRE85]'
  id: totrans-678
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '***1*** **Declares the invest() function as payable to accept Ether**'
  id: totrans-679
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **将invest()函数声明为可支付，以接受以太坊**'
- en: '***2*** **Checks if the investment is valid**'
  id: totrans-680
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **检查投资是否有效**'
- en: '***3*** **Records the investment that each investor contributes and the total
    investment**'
  id: totrans-681
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **记录每个投资者的投资和总投资**'
- en: '***4*** **Converts the Ether investment into crowdsale tokens**'
  id: totrans-682
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **将以太坊投资转换为众售代币**'
- en: '***5*** **Logs the investment event**'
  id: totrans-683
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **记录投资事件**'
- en: '***6*** **Validates the investment**'
  id: totrans-684
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** **验证投资**'
- en: '***7*** **Checks that this is a meaningful investment**'
  id: totrans-685
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7*** **检查这是否是有意义的投资**'
- en: '***8*** **Checks that this is taking place during the crowdsale funding stage**'
  id: totrans-686
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8*** **检查是否在众售融资阶段进行**'
- en: '***9*** **Calculates the number of tokens corresponding to the investment**'
  id: totrans-687
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***9*** **计算与投资相对应的代币数量**'
- en: '***10*** **Generates the tokens in the investor account**'
  id: totrans-688
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***10*** **在投资者账户中生成代币**'
- en: '***11*** **Calculates the number of tokens**'
  id: totrans-689
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***11*** **计算代币数量**'
- en: 6.1.4\. Implementing finalize()
  id: totrans-690
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.1.4\. 实现finalize()
- en: The purpose of the `finalize()` function is to execute the closing actions of
    a crowdsale. If the crowdsale has met its minimum investment objective, the contract
    releases the tokens to the investors so they can be used. Additionally, a token
    bonus that depends on the total investment collected could be assigned and released
    to the development team. On the other hand, if the crowdsale is unsuccessful,
    it moves to a refunding state, and the investors are allowed to get their investments
    refunded to their accounts.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: '`finalize()`函数的目的是执行众售的关闭动作。如果众售达到了最低投资目标，合约将释放代币给投资者，以便它们可以使用。另外，根据总收集到的投资金额，可能会分配并释放给开发团队的代币奖励。另一方面，如果众售不成功，它将进入退款状态，并允许投资者将他们的投资退款到他们的账户中。'
- en: 'Before tokens are released to the investors, they should stay locked down,
    in an unusable state: token owners shouldn’t be able to perform any operations
    on them, such as transferring them to other accounts. The contract should only
    release the initially locked tokens if the crowdsale is successful.'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 在代币释放给投资者之前，它们应该保持锁定状态，处于不可用状态：代币所有者不应该能够对它们执行任何操作，比如将它们转移到其他账户。只有在众售成功的情况下，智能合约才应释放最初锁定的代币。
- en: As you know, SimpleCoin operations (apart from `minting()`, which is restricted
    to the contract owner) aren’t constrained in any way and don’t depend on the contract
    owner unlocking any functionality. Consequently, SimpleCoin, as it stands, isn’t
    suitable for a crowdsale. It seems you must create a modified version of `SimpleCoin`—say,
    `ReleasableSimpleCoin`—whose operations, such as `transfer()` and `transferFrom()`,
    aren’t allowed to work unless the token has been released, as shown in the following
    listing.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
- en: Listing 6.2\. `ReleasableSimpleCoin`, with locked `transfer()` and `transferFrom()`
  id: totrans-694
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-695
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '***1*** **Flag determining whether the token is released**'
  id: totrans-696
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **Same SimpleCoin code as before, omitted for brevity. (In case you’re
    expecting inheritance..., it hasn’t come yet.)**'
  id: totrans-697
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **New function to release the coin. (Only the contract owner can call
    it.)**'
  id: totrans-698
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***4*** **Now the transfer logic can be executed only if the token has been
    released.**'
  id: totrans-699
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***5*** **If the token hasn’t been released, the state is reverted.**'
  id: totrans-700
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '6.1.5\. Small detour: Introducing inheritance'
  id: totrans-701
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `ReleasableSimpleCoin` implementation in [listing 6.2](#ch06ex02) works
    but has a major problem: it’s duplicating most of `SimpleCoin`’s code, with obvious
    maintenance disadvantages. If you decide to make a change in `SimpleCoin`, you
    must remember to replicate the same change in `ReleasableSimpleCoin`, which is
    time-consuming and error-prone. A way to avoid this is to *derive* `ReleasableSimpleCoin`
    from `SimpleCoin` through single inheritance and introduce the `isReleased` modifier,
    as shown in the following listing.'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
- en: Listing 6.3\. `ReleasableSimpleCoin` inherited from `SimpleCoin`
  id: totrans-703
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-704
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '***1*** **Directive to reference the file where SimpleCoin is defined ([listing
    5.8](kindle_split_017.xhtml#ch05ex08) downloadable from the book website)**'
  id: totrans-705
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **Makes ReleasableSimpleCoin inherited from SimpleCoin**'
  id: totrans-706
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **Flag determining whether the token is released**'
  id: totrans-707
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***4*** **Modifier encapsulating check on released flag**'
  id: totrans-708
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***5*** **Calls the base constructor to initialize the initialSupply state
    variable in SimpleCoin**'
  id: totrans-709
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***6*** **New function to release the coin. (Only the contract owner can call
    it.)**'
  id: totrans-710
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***7*** **Overrides the original implementation. (Thanks to the isReleased
    modifier, this can be called successfully only if the token has been released.)**'
  id: totrans-711
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***8*** **You call the original SimpleCoin implementation through super. The
    original implementation is now constrained by the isReleased modifier, though.**'
  id: totrans-712
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `ReleasableSimpleCoin` contract has given you a concrete example of single
    inheritance in Solidity. Let’s summarize the main Solidity keywords involved in
    inheritance:'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
- en: A contract is *derived* from another contract with the `is` keyword, as in
  id: totrans-714
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-715
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'The constructor of the derived contract must feed the *base constructor* all
    the necessary parameters, as shown here:'
  id: totrans-716
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-717
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: A derived contract inherits all the public and internal functions from the parent
    contract. It’s possible to *override* a function by reimplementing it in the child
    contract, as in
  id: totrans-718
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-719
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: An overridden function can *call the original implementation* from the base
    contract using the `super` keyword, as in
  id: totrans-720
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-721
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: If you’re not entirely familiar with object-oriented terminology, [table 6.1](#ch06table01)
    can help you understand it.
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
- en: Table 6.1\. Inheritance terminology
  id: totrans-723
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Definition | Explanation |'
  id: totrans-724
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-725
  prefs: []
  type: TYPE_TB
- en: '| To derive a contract | To inherit a contract—Acquire public and internal
    state variables and functions from the parent contract. |'
  id: totrans-726
  prefs: []
  type: TYPE_TB
- en: '| Derived contract | Inherited contract, subcontract, or child contract. |'
  id: totrans-727
  prefs: []
  type: TYPE_TB
- en: '| Base contract | Parent contract. |'
  id: totrans-728
  prefs: []
  type: TYPE_TB
- en: '| Overridden function | Function reimplemented in a derived contract—The overridden
    function is used instead of the parent one when the derived contract calls the
    function. |'
  id: totrans-729
  prefs: []
  type: TYPE_TB
- en: You can see the inheritance relationship between `ReleasableSimpleCoin` and
    `Simple-Coin` in the contract diagram in [figure 6.2](#ch06fig02). I’ve used the
    same drawing convention used in UML class diagrams. Although you may be able to
    understand UML class diagrams intuitively, if you’re not familiar with them and
    want to learn more, check out the related sidebar.
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.2\. Contract diagram illustrating the token contract hierarchy: `SimpleCoin`
    is a base contract, and `ReleasableSimpleCoin` has been inherited from it.'
  id: totrans-731
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig06-02_alt.jpg)'
  id: totrans-732
  prefs: []
  type: TYPE_IMG
- en: '|  |'
  id: totrans-733
  prefs: []
  type: TYPE_TB
- en: '**UML class diagrams**'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
- en: The Unified Modeling Language (UML) is a general-purpose modeling language that
    aims at standardizing the visualization of the design of a software system. It
    was developed in the 1990s by Grady Booch, Ivar Jacobson, and James Rumbaugh at
    Rational Software. It became an ISO standard in 2005.
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
- en: 'UML covers a wide range of diagrams, including these categories:'
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
- en: '*Behavior diagrams*—Describe how a system works (how the components of the
    system interact with each other and with external agents)'
  id: totrans-737
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Structure diagrams*—Describe the structure of the system at different levels
    (packages to be deployed, components within a package, and object-oriented classes
    within a component)'
  id: totrans-738
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this book, I’ll only show you *contract diagrams*, which, given the similarity
    between the concepts of contract and class, are based on UML *class diagrams*,
    the lowest-level structure diagrams.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
- en: 'A contract diagram describes the content of a contract (state variables and
    functions) and the two main relationships between contracts:'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
- en: '*Generalization*—A contract is inherited from a more general contract (its
    base or parent contract) or, as you’ll learn later, from an interface.'
  id: totrans-741
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Dependency*—One of the state variables is an instance of another contract.'
  id: totrans-742
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I’ve annotated every section of text and every symbol in the sample contract
    diagram you see here, so you can refer back to it if you have any trouble understanding
    the contract diagrams that follow in the coming pages. I’ll explain new symbols
    as I introduce them in the coming sections.
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/f0176-01_alt.jpg)'
  id: totrans-744
  prefs: []
  type: TYPE_IMG
- en: Contract diagram, with symbols and conventions adapted from the UML class diagram
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to learn more about UML diagrams, I encourage you to look up the
    *UML Quick Reference Card*, at [http://tnerual.eriogerg.free.fr/umlqrc.pdf](http://tnerual.eriogerg.free.fr/umlqrc.pdf),
    or this convenient *UML Cheatsheet*: [http://mng.bz/jO5p](http://mng.bz/jO5p).
    The best book on UML is The Unified Modeling Language User Guide, by Grady Booch,
    et al, published by Addison-Wesley.'
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-747
  prefs: []
  type: TYPE_TB
- en: 6.1.6\. Implementing finalize(), take 2
  id: totrans-748
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that you’ve implemented a token suitable for a crowdsale, you can go back
    to the state variables section and replace the definition of `crowdsaleToken`
    with
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-750
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: and amend the token instantiation in the crowdsale constructor with
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-752
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Now I can show you a possible implementation for the `finalize()` function:'
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-754
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '***1*** **Allows only the crowdsale contract owner to call finalize()**'
  id: totrans-755
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **Prevents calling finalize() on a finalized contract**'
  id: totrans-756
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **Conditions determining if a crowdsale has been successful**'
  id: totrans-757
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***4*** **Releases crowdsale tokens so investors can use them**'
  id: totrans-758
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***5*** **Allows investors to get refunded if the funding objective hasn’t
    been met**'
  id: totrans-759
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As I mentioned earlier, `onlyOwner` is the same modifier I introduced in SimpleCoin
    at the end of [chapter 5](kindle_split_017.xhtml#ch05) to restrict the execution
    of some functions only to the contract owner:'
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-761
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 6.1.7\. Implementing refund()
  id: totrans-762
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last function you must implement to complete the first version of your
    crowdsale contract is `refund()`, which investors would call after an unsuccessful
    crowdsale:'
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-764
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '***1*** **Only allows refunding if this has been allowed at the crowdsale finalization**'
  id: totrans-765
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **Only allows refunding if the investor has contributed a meaningful
    amount**'
  id: totrans-766
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **Keeps a record of all refunds**'
  id: totrans-767
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***4*** **Transfers Ether back to the investor and handles possible transfer
    error**'
  id: totrans-768
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-769
  prefs: []
  type: TYPE_TB
- en: Note
  id: totrans-770
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: I’ve decided to refund investors through `send()` rather than `transfer()`,
    only because `transfer()` has some quirks in Remix (at the time of writing) and
    might generate unwanted error messages that would slow down your learning experience.
    In a production environment, `transfer()` is recommended.
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-772
  prefs: []
  type: TYPE_TB
- en: 6.1.8\. Eliminating code duplication with inheritance
  id: totrans-773
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As I noted, `SimpleCoin` and `SimpleCrowdsale` use the same `onlyOwner` modifier
    to restrict access to some operations to only the contract owner. The advantage
    is that you’re using `onlyOwner` consistently across the two contracts. The downside
    is that you had to introduce the `owner` state variable and implement the `onlyOwner`
    modifier in both contracts. Wouldn’t it be nice to place this modifier somewhere
    so you could then drop it into both `SimpleCoin` and `SimpleCrowdsale` without
    introducing code duplication? Fortunately, you can by encapsulating the ownership
    state and `onlyOwner` modifier into a separate contract, called `Ownable`, as
    shown in the following listing.
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
- en: Listing 6.4\. `Ownable` contract extracted from `SimpleCrowdsale` and `SimpleCoin`
  id: totrans-775
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-776
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '***1*** **Keeps the address of the contract owner in a state variable**'
  id: totrans-777
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **Assigns the contract owner at construction**'
  id: totrans-778
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **Checks if the function caller using this modifier is the owner**'
  id: totrans-779
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now you can remove the owner state variable and the `onlyOwner()` modifier
    from both `SimpleCoin` and `SimpleCrowdsale` and inherit both contracts from `Ownable`,
    as shown in the contract diagram in [figure 6.3](#ch06fig03) and in this code:'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-781
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Figure 6.3\. After moving ownership functionality into the `Ownable` contract,
    both `SimpleCoin` and `Simple-Crowdsale` can still use the `onlyOwner` modifier
    by inheriting it from `Ownable`.
  id: totrans-782
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig06-03_alt.jpg)'
  id: totrans-783
  prefs: []
  type: TYPE_IMG
- en: You can see the refactored `SimpleCoin` contract inheriting from `Ownable` in
    [appendix A](kindle_split_030.xhtml#app01). Congratulations! You’ve completed
    your first implementation of a crowdsale contract, which you can fully appreciate
    in the contract diagram in [figure 6.4](#ch06fig04) and in [listing 6.5](#ch06ex05).
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-785
  prefs: []
  type: TYPE_TB
- en: Note
  id: totrans-786
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The arrow between `SimpleCrowdsale` and `ReleasableSimpleCoin` in [figure 6.4](#ch06fig04)
    is a UML symbol that stands for *depends on*. I’ve included the arrow because
    the `SimpleCrowdsale` contract has a state variable of type `Releasable-SimpleCoin`,
    so it depends on `ReleasableSimpleCoin`.
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-788
  prefs: []
  type: TYPE_TB
- en: Figure 6.4\. Crowdsale’s contract diagram, including `Ownable` contract and
    token contract. Both `SimpleCrowdsale` and `SimpleCoin` are inherited from `Ownable`.
    `SimpleCrowdsale` has a `ReleasableSimpleCoin` state variable, so it depends on
    `ReleasableSimpleCoin`. (If you’re unfamiliar with objectoriented class diagrams,
    the hollow-headed arrow means “inherited from,” and the filled arrow means “depends
    on.”)
  id: totrans-789
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig06-04_alt.jpg)'
  id: totrans-790
  prefs: []
  type: TYPE_IMG
- en: Listing 6.5\. Initial implementation of a crowdsale contract
  id: totrans-791
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-792
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '***1*** **References Solidity code from other files or from other Remix code
    tabs**'
  id: totrans-793
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 6.1.9\. Running SimpleCrowdsale
  id: totrans-794
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You’ve just started implementing `SimpleCrowdsale`, but if you want to see
    what you’ve built so far in action, copy [listing 6.5](#ch06ex05) into a new Remix
    code tab (perhaps named Listing6_5_SimpleCrowdsale.sol). Make sure you’ve placed
    the dependent code specified in the import directives in related code tabs named
    appropriately:'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
- en: Listing5_8_SimpleCoin.sol (needed for Listing6_3_ReleasableSimpleCoin.sol)
  id: totrans-796
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listing6_3_ReleasableSimpleCoin.sol
  id: totrans-797
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listing6_4_Ownable.sol
  id: totrans-798
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (You can find these files in the code downloadable from the book website.)
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
- en: Disabling date checks temporarily
  id: totrans-800
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Before instantiating `SimpleCrowdsale`, I recommend you pick version 0.4.24
    in the Remix Compiler tab because this is the Solidity version I’ve used. I also
    suggest you temporarily disable checks on `startDate` and `endDate` to make your
    interaction with Remix easier. Modify this line in `isValidInvestment()`
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-802
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: to read
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-804
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: and this line in `finalize()`
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-806
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: to read
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-808
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Instantiating the contract
  id: totrans-809
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Now you can feed `SimpleCrowdsale`’s constructor parameters in the text box
    next to the Deploy button. For example, I’ll set a token price of 2,000,000,000,000,000
    Wei and a funding objective of 15,000 Ether as follows:'
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-811
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Because of your earlier modification, the 2003526559 and 2003526600 start and
    end dates will be ignored.
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
- en: 'Now pick `SimpleCrowdsale` from the contract drop-down list and click Deploy.
    If `SimpleCrowdsale` doesn’t appear, click the Compile tab and then Start to Compile.
    Take a note of which account is currently selected in the Account drop-down list
    at the top of the screen: this will be the contract owner of both `SimpleCrowdsale`
    and `ReleasableSimpleCoin`. `SimpleCrowdsale` will be activated, and a number
    of buttons corresponding to its state variables and functions will appear at the
    bottom of the screen.'
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
- en: Investing into the crowdsale
  id: totrans-814
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'You can simulate investors’ activity by calling the `invest()` function as
    follows:'
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
- en: Click the SimpleCrowdsale drop-down in the Deployed Contracts bottom section
    generated after you clicked Deploy earlier.
  id: totrans-816
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pick an Account from the drop-down list—perhaps the one starting with 0x147.
  id: totrans-817
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter an amount in the Value box at the top of the screen, specify the unit
    (100 Ether, for example), and click the invest button in the SimpleCrowdsale panel
    within the Deployed Contract bottom section. (You can see this button in [figure
    6.5](#ch06fig05).)
  id: totrans-818
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the total investment received by clicking investmentReceived.
  id: totrans-819
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat these three steps with different accounts and investment amounts.
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
- en: Checking that tokens have been assigned to investors
  id: totrans-821
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Although investors at this point have received a number of tokens corresponding
    to the amount of Ether contributed, they aren’t able to transfer them yet because
    the owner hasn’t finalized the crowdsale. If you want to check that tokens have
    been assigned to each investor, you must activate the `ReleasableSimpleCoin` contract
    instance referenced in `SimpleCrowdsale`.
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, get its address by clicking crowdsaleToken. Copy this address
    and paste it in the textbox next to the Activate button (*not wrapped* with double
    quotes), as shown in [figure 6.5](#ch06fig05) (but your address will be different):'
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.5\. Place in Releasable-SimpleCoin’s At Address text box the address
    from `SimpleCrowdsale's crowdsaleToken` state variable.
  id: totrans-824
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig06-05_alt.jpg)'
  id: totrans-825
  prefs: []
  type: TYPE_IMG
- en: Now click At Address, and a new panel showing `ReleasableSimpleCoin`’s functionality,
    mostly inherited from SimpleCoin, will appear at the bottom part of the screen,
    as shown in [figure 6.6](#ch06fig06). You must click ReleasableSimpleCoin to expand
    the panel.
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now check the number of tokens assigned to each investor in the following
    way:'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
- en: Pick the address from the Account drop-down corresponding to an investor you
    want to check, copy it by clicking the copy icon next to it, and paste it into
    the text box next to the coinBalance button. (Remember to wrap it with double
    quotes.)
  id: totrans-828
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click coinBalance, and the expected number of tokens will appear next to it.
  id: totrans-829
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat this for all accounts in the drop-down. In my case, I have the token
    breakdown shown in [table 6.2](#ch06table02).
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.6\. `ReleasableSimpleCoin's` state variables and functions
  id: totrans-831
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig06-06_alt.jpg)'
  id: totrans-832
  prefs: []
  type: TYPE_IMG
- en: Table 6.2\. Number of tokens assigned to each investor
  id: totrans-833
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Investor account | Number of tokens |'
  id: totrans-834
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-835
  prefs: []
  type: TYPE_TB
- en: '| 0xca35b7d915458ef540ade6068dfe2f44e8fa733c | 10,100,000 |'
  id: totrans-836
  prefs: []
  type: TYPE_TB
- en: '| 0x14723a09acff6d2a60dcdf7aa4aff308fddc160c | 150,000 |'
  id: totrans-837
  prefs: []
  type: TYPE_TB
- en: '| 0x4b0897b0513fdc7c541b6d9d7e929c4e5364d2db | 653,500 |'
  id: totrans-838
  prefs: []
  type: TYPE_TB
- en: '| 0x583031d1113ad414f02576bd6afabfb302140225 | 284,000 |'
  id: totrans-839
  prefs: []
  type: TYPE_TB
- en: '| 0xdd870fa1b7c4700f2bd7f44238821c26f7392148 | 56,000 |'
  id: totrans-840
  prefs: []
  type: TYPE_TB
- en: Checking that tokens are still locked
  id: totrans-841
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As I explained, tokens that get assigned to investors during the crowdsale are
    unusable until it’s been finalized successfully. This means an investor won’t
    be able to transfer tokens to another account. Let’s check that this is the case
    by trying to transfer some tokens from one account to another.
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
- en: Pick an account from the Account drop-down, copy its address, and paste it into
    the transfer text box (wrapped, as usual, with double quotes). This will be the
    destination account for the token transfer. Then pick a different account from
    the Account drop-down. This will be the source of the token transfer.
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
- en: 'Click Transfer. Now check the number of tokens associated with the source and
    destination account again, as you did earlier. You’ll notice they haven’t changed.
    Because the value of `released` is still `false` (the crowdsale hasn’t been finalized
    yet), the transfer won’t take place (but no error will be thrown), as you can
    see in the code extract from `transfer()`:'
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-845
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '***1*** **The value of released is still false, so the token transfer isn’t
    executed.**'
  id: totrans-846
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finalizing a successful crowdsale
  id: totrans-847
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If you want to test a successful crowdsale, make sure the amount of investment
    is above the investment objective (15,000 Ether in my example, equivalent to 15,000,000,000,000,000,000,000
    Wei). Bear in mind, the amount shown next to the `investmentReceived` button is
    expressed in Wei. You can reach it quickly by making a few large Ether investments.
    Once the investment received is higher than the funding objective, select the
    `SimpleCrowdsale` contract owner account (the account you used to instantiate
    `SimpleCrowdsale`) and click Finalize.
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
- en: Verify the crowdsale has been finalized by clicking isFinalized. The value displayed
    should be `true`. Verify `ReleasableSimpleCoin` has been released by clicking
    Released. The value displayed again should be `true`.
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
- en: Now you can try to make a token transfer, as you did earlier. This time, though,
    the transfer will work because the value of `released` is now `true` and the transfer
    logic can get executed. You can verify that the number of tokens associated with
    the source and destination accounts have changed accordingly. In my case, I moved
    three coins from the account starting with 0x1472 to the account starting with
    0x4b089\. You can see their amended balances in [table 6.3](#ch06table03).
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
- en: Table 6.3\. Amended `ReleasableSimpleCoin` token balance after a token transfer
  id: totrans-851
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Investor account | Number of tokens |'
  id: totrans-852
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-853
  prefs: []
  type: TYPE_TB
- en: '| 0xca35b7d915458ef540ade6068dfe2f44e8fa733c | 10,100,000 |'
  id: totrans-854
  prefs: []
  type: TYPE_TB
- en: '| 0x14723a09acff6d2a60dcdf7aa4aff308fddc160c | 149,997 |'
  id: totrans-855
  prefs: []
  type: TYPE_TB
- en: '| 0x4b0897b0513fdc7c541b6d9d7e929c4e5364d2db | 653,503 |'
  id: totrans-856
  prefs: []
  type: TYPE_TB
- en: '| 0x583031d1113ad414f02576bd6afabfb302140225 | 284,000 |'
  id: totrans-857
  prefs: []
  type: TYPE_TB
- en: '| 0xdd870fa1b7c4700f2bd7f44238821c26f7392148 | 56,000 |'
  id: totrans-858
  prefs: []
  type: TYPE_TB
- en: Finalizing an unsuccessful crowdsale
  id: totrans-859
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If you’re up for it, you can also test the scenario of an unsuccessful crowdsale.
    I recommend you restart from scratch and go through all the steps you took earlier
    up to the point you contribute Ether to the crowdsale through the `invest()` function
    from various investor accounts. This time, though, don’t reach the funding objective.
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, when you call `finalize()` by clicking the related button, `fundingObjectiveMet`
    is `false`. Consequently, the `isRefundingAllowed` gets enabled, as you can see
    in this extract from the `finalize()` code:'
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-862
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: You can double-check this is the case by clicking isRefundingAllowed. With that
    enabled, you’ll be able to successfully call the `refund()` function, as you’ll
    see next. But before doing so, as an exercise I invite you to test that tokens
    haven’t been released and it isn’t possible to transfer them from one account
    to another, as you saw earlier.
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
- en: Getting a refund
  id: totrans-864
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Following unsuccessful finalization, investors are allowed to get refunded.
    Pick an address from the Account drop-down, check the amount of Ether associated
    with it (shown next to the address), and click Refund. You’ll see that the Ether
    value next to the account address will increase because it has been transferred
    from the crowdsale contract back to the investor.
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
- en: In the next few sections, you’ll improve the functionality of the crowdsale
    contract by taking advantage of Solidity object-oriented features, such as single
    inheritance, which you’ve already used in the `ReleasableSimpleCoin` contract,
    multiple inheritance, and abstract classes.
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
- en: 6.2\. Extending functionality with inheritance
  id: totrans-867
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The current crowdsale implementation assumes the price of the token being bought
    by the investors is fixed throughout the crowdsale, from start to end. A way to
    incentivize and reward early investors is to provide tranche-based pricing.
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
- en: 6.2.1\. Implementing a new token pricing contract with inheritance
  id: totrans-869
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A *tranche* is a certain amount of total investment received. A different token
    price applies to each tranche, as shown in [figure 6.7](#ch06fig07), so that early
    investors are attracted with a lower initial price. As the sale progresses, the
    token price rises when moving from one tranche to the next and eventually becomes
    constant after the minimum funding target has been met.
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.7\. Tranche-based token pricing. The total investment up to the minimum
    funding objective is divided into several tranches, each with a different token
    price. The token price rises as the total investment received moves from one tranche
    to the next.
  id: totrans-871
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig06-07_alt.jpg)'
  id: totrans-872
  prefs: []
  type: TYPE_IMG
- en: In the example shown in [figure 6.7](#ch06fig07), the minimum funding target
    has been set at 15,000 Ether, and the organizers have decided to create four tranches,
    as defined in [table 6.4](#ch06table04).
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 6.4\. Token-based pricing: example of different prices at different points
    in the funding process'
  id: totrans-874
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Total investment received (in Ether) | Token price (in Ether) |'
  id: totrans-875
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-876
  prefs: []
  type: TYPE_TB
- en: '| Above 15,000 | 0.005 |'
  id: totrans-877
  prefs: []
  type: TYPE_TB
- en: '| From 10,000 to 15,000 | 0.004 |'
  id: totrans-878
  prefs: []
  type: TYPE_TB
- en: '| From 3,000 to 10,000 | 0.003 |'
  id: totrans-879
  prefs: []
  type: TYPE_TB
- en: '| From 0 to 3,000 | 0.002 |'
  id: totrans-880
  prefs: []
  type: TYPE_TB
- en: Tranche-based token pricing logic
  id: totrans-881
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Now that you understand the principle of tranche-based pricing, let’s see how
    you can implement it in Solidity. If you look back at [listing 6.5](#ch06ex05),
    you’ll notice that the only function that’s directly accessing the token price
    is
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-883
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '***1*** **weiTokenPrice is fixed because it isn’t modified during the crowdsale.**'
  id: totrans-884
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You’ll also notice that the value of `weiTokenPrice` is never modified from
    within the crowdsale contract, so you can consider it fixed throughout the whole
    crowdsale.
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a small challenge: How would you modify the implementation of `calculate-NumberOfTokens()`
    so the pricing becomes tranche-based according to the tranches defined in [table
    6.4](#ch06table04)? Here are some hints you could consider before attempting a
    solution:'
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
- en: You could configure the tranches with a `struct` type, such as
  id: totrans-887
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-888
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '***1*** **Higher funding limit of the tranche**'
  id: totrans-889
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **Token price associated with the tranche**'
  id: totrans-890
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You could store the entire tranche structure in a state variable defined with
    the following mapping
  id: totrans-891
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-892
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: and initialize the state variable in the contract constructor as follows
  id: totrans-893
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-894
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: with the tranche limits and token price defined in Ether.
  id: totrans-895
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You could maintain the current active tranche in a state variable
  id: totrans-896
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE111]'
  id: totrans-897
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'and you’d initialize this state variable in the constructor as follows:'
  id: totrans-898
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-899
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: You could update `currentTrancheLevel` and `weiTokenPrice` within `calculate-NumberOfTokens()`.
  id: totrans-900
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I strongly encourage you to give tranche-based pricing a try! Finished? You
    can compare your modified `calculateNumberOfTokens()` with that in the following
    listing.
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
- en: Listing 6.6\. `calculateNumberOfTokens()` based on tranche-based pricing
  id: totrans-902
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE113]'
  id: totrans-903
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '***1*** **The only change to calculateNumberOfTokens()**'
  id: totrans-904
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **Updates the current tranche and, consequently, the current token
    price**'
  id: totrans-905
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **Tests tranches to identify where investmentReceived falls**'
  id: totrans-906
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***4*** **Updates weiTokenPrice with the value from the current tranche-based
    pricing crowdsale contract**'
  id: totrans-907
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see in [listing 6.6](#ch06ex06), only one extra function is necessary
    to calculate the token price based on a tranche basis. The rest of the code stays
    unaltered. I’m sure you might be wondering where you should place the amended
    `calculateNumberOfTokens()` and new `updateCurrentTrancheAndPrice()` functions.
    The simple answer is in a new crowdsale contract called `TranchePricingCrowdsale`,
    because you might still want to use the flat token pricing in other crowdsales.
    The next question is should I copy `Simple-Crowdsale`’s code, paste it into `TranchePricingCrowdsale`,
    and apply in it the modifications from [listing 6.6](#ch06ex06)? The answer is
    no, you shouldn’t! As I explained when you created `ReleasableSimpleCoin` based
    on SimpleCoin, you’ll be *inheriting* `TranchePricingCrowdsale` from `SimpleCrowdsale`,
    as shown in the following listing.
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
- en: Listing 6.7\. `TranchePricingCrowdsale` derived from `SimpleCrowdsale`
  id: totrans-909
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE114]'
  id: totrans-910
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '***1*** **TranchePricingCrowdsale is inherited from SimpleCrowdsale.**'
  id: totrans-911
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **Configuration of tranche structure**'
  id: totrans-912
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **Current tranche level with respect to the investment received so
    far**'
  id: totrans-913
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***4*** **Calling constructor on base contractor to complete the contract initialization**'
  id: totrans-914
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***5*** **Initialization of tranche structure. (I’ve hardcoded this for simplicity,
    but it could be fed through constructor parameters.)**'
  id: totrans-915
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***6*** **Overrides the original calculateNumberOfTokens() implementation present
    in SimpleCrowdsale**'
  id: totrans-916
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***7*** **New function to update the token price based on the current tranche**'
  id: totrans-917
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By inheriting `TranchePricingCrowdsale` from `SimpleCrowdsale`, I’ve shown
    you another example of single inheritance. I’ll give you a quick summary of the
    inheritance features of Solidity you can appreciate in `TranchePricingCrowdsale`.
    This is almost a repeat of what you’ve already seen in `ReleasableSimpleCoin`,
    and hopefully it will help you consolidate the concepts:'
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
- en: '`TranchePricingCrowdsale` is *inherited* from `SimpleCrowdsale` with the `is`
    keyword:'
  id: totrans-919
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE115]'
  id: totrans-920
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: You’ve added *additional state variables* `trancheStructure` and `currentTranche-Level`
    to the inherited contract to handle tranche-specific functionality.
  id: totrans-921
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TranchePricingCrowdsale`’s constructor sets tranche-related state but also
    feeds the *base* `SimpleCrowdsale` constructor with the required parameters:'
  id: totrans-922
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE116]'
  id: totrans-923
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: You’ve *overridden* `calculateNumberOfTokens()`in `TranchePricingCrowdsale`
    by providing a new implementation. Contrary to other languages, no special keywords
    are necessary to override a function in Solidity.
  id: totrans-924
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can see the inheritance relationship between `TranchePricingCrowdsale` and
    `SimpleCrowdsale` in the contract diagram in [figure 6.8](#ch06fig08).
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.8\. Contract diagram illustrating the crowdsale contract hierarchy,
    with the latest addition of `TranchePricing-Crowdsale`, derived from `SimpleCrowdsale`
  id: totrans-926
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig06-08_alt.jpg)'
  id: totrans-927
  prefs: []
  type: TYPE_IMG
- en: I invite you to copy `TranchePricingCrowdsale`’s code from [listing 6.7](#ch06ex07)
    into a new code tab of Remix and instantiate this contract. Then you can check
    how the token price rises when the tranche thresholds are hit.
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed I’ve used the expression single inheritance a few times.
    The reason I’ve done so is because Solidity also supports *multiple inheritance*.
    We’ll explore this in the next section.
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
- en: 6.2.2\. Composing functionality with multiple inheritance
  id: totrans-930
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Solidity is a young language that’s still in the early stages of its development.
    Its syntax is continuously improving, and consequently best practice recommendations
    change frequently. Even the most experienced Solidity developers, who might have
    a length of experience that would make them barely junior developers in more established
    languages, have to continuously keep up with learning the latest techniques and
    recommendations, especially around security.
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
- en: Realistically, once a contract has been deployed into the public production
    Ethereum network, it’s unlikely to be modified on a regular basis. But a security
    flaw might be discovered, either because its developers weren’t aware of a recent
    recommendation on safer syntax or because someone finds the flaw at the community,
    node client, or language level.
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
- en: Given that the possibility of things going wrong is real and the consequent
    risk of Ether being lost or stolen isn’t negligible, it has become common practice
    to include various forms of panic buttons in contracts. These range from a pause
    or halt function, which freezes the state and functionality of the contract until
    the contract owner decides to switch it on again, to a complete self-destruct
    function, which transfers the Ether stored in the contract to a safe account before
    making the contract permanently unusable.
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
- en: Making a token contract pausable
  id: totrans-934
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Enough talking! The following listing shows how to add pausing functionality
    to `ReleasableSimpleCoin`, assuming you don’t want to add it to `SimpleCoin` as
    well.
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
- en: Listing 6.8\. Adding pausable functionality to `ReleasableSimpleCoin`
  id: totrans-936
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE117]'
  id: totrans-937
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '***1*** **Same code as before**'
  id: totrans-938
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **Flag holding the paused state**'
  id: totrans-939
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **Modifiers holding the paused state**'
  id: totrans-940
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***4*** **Same code as before**'
  id: totrans-941
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***5*** **Guarantees a transfer can only take place when the token contract
    hasn’t been paused**'
  id: totrans-942
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extracting pausability functionality
  id: totrans-943
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: After making `ReleasableSimpleCoin` pausable, you might want to do the same
    with `SimpleCrowdsale`. You might be tempted to duplicate the pausing functionality
    code you’ve written into `SimpleCrowdsale`. A smarter way to make both `ReleasableSimple-Coin`
    and `SimpleCrowdsale` pausable—without introducing code duplication—is to extract
    the pausable functionality from `ReleasableSimpleCoin` into a separate contract
    (called `Pausable`, for example) and then inherit both `ReleasableSimpleCoin`
    and `SimpleCrowdsale` from `Pausable`.
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
- en: You can see the new Pausable contract extracted from `ReleasableSimpleCoin`
    in the following listing.
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
- en: Listing 6.9\. Pausable contract extracted from `ReleasableSimpleCoin`
  id: totrans-946
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE118]'
  id: totrans-947
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '***1*** **State variable holding paused state**'
  id: totrans-948
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **Modifier allowing function to run depending on paused state**'
  id: totrans-949
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **Functions changing paused state**'
  id: totrans-950
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composing base contracts with multiple inheritance
  id: totrans-951
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Now you can reapply pausability to `ReleasableSimpleCoin` by inheriting `Releasable-SimpleCoin`
    from `Pausable`, which, by the way, I’ve inherited from `Ownable` so it can use
    the `onlyOwner` modifier. But, hold on, as you’ll remember, you’re already inheriting
    `ReleasableSimpleCoin` from `SimpleCoin`. Is that a problem? The answer is no.
    Solidity supports *multiple inheritance*, so you can inherit a contract from several
    contracts, as shown here:'
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  id: totrans-953
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '***1*** **ReleasableSimpleCoin is inherited from SimpleCoin and Pausable.**'
  id: totrans-954
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple inheritance can make your code composable because you can create more
    complex contracts by inheriting from multiple simpler contracts. On the other
    hand, you should try to compose your contracts so they have only minimal cross
    dependencies, to avoid circular reference issues.
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-956
  prefs: []
  type: TYPE_TB
- en: Note
  id: totrans-957
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A circular reference happens when contract C is inherited from contract P, which
    in turn is inherited indirectly from contract C.
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-959
  prefs: []
  type: TYPE_TB
- en: You can see the multiple inheritance relationships present in `ReleasableSimpleCoin`
    in [figure 6.9](#ch06fig09).
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.9\. `Releasable-SimpleCoin` is inherited both from `SimpleCoin` and
    `Pausable`, which is in turn inherited from Ownable.
  id: totrans-961
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig06-09_alt.jpg)'
  id: totrans-962
  prefs: []
  type: TYPE_IMG
- en: Making a crowdsale contract pausable
  id: totrans-963
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'After extracting the pausable functionality into a standalone contract, it’s
    easy to apply it to other contracts. For example:'
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  id: totrans-965
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: By inheriting `SimpleCrowdsale` from `Pausable`, you’ve also made `TranchePricingCrowdsale`
    pausable. You can see the amended crowdsale contract structure in [figure 6.10](#ch06fig10).
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.10\. Amended crowdsale contract structure including `Pausable` contract
  id: totrans-967
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig06-10_alt.jpg)'
  id: totrans-968
  prefs: []
  type: TYPE_IMG
- en: Making a contract destructible
  id: totrans-969
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If you’re not comfortable with the `Pausable` functionality, and you prefer,
    in case of emergency, to immediately transfer the Ether stored in the contract
    to a safe address and then destroy the contract so that malicious attackers can
    no longer manipulate it, you can encapsulate this functionality in a `Destructible`
    contract, as shown in the following listing.
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
- en: Listing 6.10\. A `Destructible` contract
  id: totrans-971
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE121]'
  id: totrans-972
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '***1*** **Destroys the contract after having transferred Ether to a safe specified
    account using the implicitly declared function selfdestruct() (as explained in
    5.3.3)**'
  id: totrans-973
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can now also make both `ReleasableSimpleCoin` and `SimpleCrowdsale` destructible
    by inheriting them from `Destructible`, as shown in [figure 6.11](#ch06fig11)
    and the following snippet:'
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  id: totrans-975
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '***1*** **ReleasableSimpleCoin and SimpleCrowdsale inheriting from Destructible**'
  id: totrans-976
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Figure 6.11\. `ReleasableSimpleCoin` and `SimpleCrowdsale` are now also `Destructible`.
  id: totrans-977
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig06-11_alt.jpg)'
  id: totrans-978
  prefs: []
  type: TYPE_IMG
- en: So far, you’ve learned how to take advantage of single and multiple inheritance
    to implement contracts with increasing functionality while avoiding code duplication.
    In the next chapter, you’ll see how abstract classes and interfaces can help you
    further toward the maintainability of your contract code base.
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-980
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The contract side of real-world Ethereum Dapps is generally made of many contracts
    that interact with each other.
  id: totrans-981
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A crowdsale management application is an example of a multicontract Dapp.
  id: totrans-982
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can extend contract functionality while avoiding code duplication by using
    inheritance.
  id: totrans-983
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple inheritance allows you to compose a complex contract from several simpler
    contracts.
  id: totrans-984
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chapter 7\. Generalizing functionality with abstract contracts and interfaces
  id: totrans-985
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-986
  prefs: []
  type: TYPE_TB
- en: '**This chapter covers**'
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
- en: Generalizing contracts by making them abstract
  id: totrans-988
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving contract extensibility through interfaces
  id: totrans-989
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A summary of Solidity object-oriented features
  id: totrans-990
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving maintainability of utility code using libraries
  id: totrans-991
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-992
  prefs: []
  type: TYPE_TB
- en: The previous chapter introduced `SimpleCrowdsale`, which presented an example
    of a multicontract decentralized application, with a crowdsale management contract
    (`SimpleCrowdsale`) interacting with a token contract (`ReleasableSimpleCoin`).
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
- en: You started to extend the functionality of `SimpleCrowdsale` by adding a new,
    more complex pricing strategy, and took advantage of contract inheritance to do
    so. You further extended the functionality by implementing pausability and destructibility
    as separate contracts and composing them into `SimpleCrowdsale` through multiple
    inheritance.
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll keep extending `SimpleCrowdsale`’s functionality by
    using other object-oriented features, such as abstract contracts and interfaces.
    I’ll show you how an abstract contract can help you generalize a contract while
    avoiding code duplication. I’ll also demonstrate how interfaces can add flexibility
    to the design of your contract so you can choose to plug in one of many possible
    implementations of a specific aspect of the contract functionality.
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
- en: As with most languages, you achieve code reuse in Solidity by grouping and organizing
    functions you use often into shared libraries. I’ll give you an idea of what Solidity
    libraries look like, and I’ll explain how to call their functions.
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
- en: You’ll close this chapter by making further improvements to SimpleCoin using
    some of the object-oriented techniques you’ll have learned in this chapter and
    the previous chapter. Specifically, I’ll show you how to refactor SimpleCoin so
    it can comply with the Ethereum ERC20 token standard.
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
- en: 7.1\. Making a contract abstract
  id: totrans-998
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At the moment, your crowdsale contracts can handle different pricing strategies.
    You derived `TranchedSimpleCrowdsale` from `SimpleCrowdsale` to provide specific
    (tranche-based) token pricing not available in the parent contract.
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
- en: 7.1.1\. Implementing funding limit with inheritance
  id: totrans-1000
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s imagine a client is interested in your crowdsale contracts, but they’d
    like a new feature: the ability to cap the crowdsale funding at a maximum total
    amount above which no further investments are accepted. A quick way to implement
    this would be to derive a new contract called `CappedCrowdsale` from `SimpleCrowdsale`,
    as shown in the following listing.'
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
- en: Listing 7.1\. First implementation of `CappedCrowdsale`
  id: totrans-1002
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE123]'
  id: totrans-1003
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '***1*** **State variable for configuring funding cap**'
  id: totrans-1004
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **Configures the rest of the state variables through the base constructor**'
  id: totrans-1005
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **Overrides isValidInvestment()**'
  id: totrans-1006
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***4*** **Copies validations from SimpleCrowdsale.isValidInvestment()**'
  id: totrans-1007
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***5*** **Checks that the cap limit hasn’t been breached**'
  id: totrans-1008
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Issues with the current implementation
  id: totrans-1009
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'This implementation might feel simple and satisfactory at first, but at closer
    look it has a couple of issues:'
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
- en: The implementation of `isValidInvestment()` has been partially copied from `SimpleCrowdsale.isValidInvestment()`,
    creating some code duplication.
  id: totrans-1011
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The current implementation of `CappedCrowdsale` is inheriting the default token
    pricing code from `SimpleCrowdsale`, so you can’t use it as it stands for a capped
    crowdsale with tranche-based token pricing (because `TranchePricingCrowdsale`
    is a child of `SimpleCrowdsale`).
  id: totrans-1012
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing duplication with a template method
  id: totrans-1013
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s try to tackle these issues one by one. First, you can avoid the partial
    code duplication within `isValidInvestment()`by reimplementing `SimpleCrowdsale.isValid-Investment()`
    as
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  id: totrans-1015
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '***1*** **Previous checks on investment validity**'
  id: totrans-1016
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **Generic check against full investment received so far**'
  id: totrans-1017
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **The default implementation doesn’t perform any check at all; overridden
    implementations in inherited classes will do, as you’ll see later.**'
  id: totrans-1018
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Following this change, `CappedCrowdsale` no longer needs to override `isValid-Investment()`,
    but only `isFullInvestmentWithinLimit()`, as shown in the following listing.
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
- en: Listing 7.2\. Refactored `CappedCrowdsale`
  id: totrans-1020
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE125]'
  id: totrans-1021
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '***1*** **References a modified version of SimpleCrowdsale implementing isFull-InvestmentWithinLimit**'
  id: totrans-1022
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **This is the check that was being performed previously in the overridden
    isValidInvestment() function.**'
  id: totrans-1023
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `isValidInvestment()` function has now become a *template method*: it’s
    a high-level function that dictates high-level steps whose logic is delegated
    to lower level functions, such as `isFullInvestmentWithinLimit()`, which you override
    with specific implementations in each derived contract.'
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-1025
  prefs: []
  type: TYPE_TB
- en: Note
  id: totrans-1026
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A template method is a classic design pattern that appeared in the so-called
    *Gang of Four* book: *Design Patterns: Elements of Reusable Object-Oriented Software*,
    published by Addison-Wesley.'
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-1028
  prefs: []
  type: TYPE_TB
- en: Limitations of the current funding limit strategy implementation
  id: totrans-1029
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As I hinted previously, the current functionality to check the cap limit isn’t
    composable as it stands. If you wanted to cap funding on a crowdsale with tranche-based
    token pricing, you’d have to implement the `CappedTranchePricingCrowdsale` contract,
    as shown in the next listing.
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
- en: Listing 7.3\. Capped funding and tranche-based pricing
  id: totrans-1031
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE126]'
  id: totrans-1032
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '***1*** **The same state variable introduced in CappedCrowdsale**'
  id: totrans-1033
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **The same implementation written for CappedCrowdsale**'
  id: totrans-1034
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, I’ve copied the code entirely from `CappedCrowdsale`. This is
    far from an ideal solution from a maintenance point of view.
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
- en: 'Aside from duplication, the current crowdsale contract hierarchy shows another
    subtler issue: as you can see in [figure 7.1](#ch07fig01), the hierarchy is asymmetrical,
    and not all contract names tell explicitly what token pricing strategy or funding
    limit strategy they’re employing. For example, `CappedCrowdsale`, whose name doesn’t
    make any reference to any token pricing strategy, inherits from `SimpleCrowdsale`,
    which implements fixed token pricing. A more precise name for this contract probably
    would be `CappedFixedPricingCrowdsale`. Equally, `TranchePricingCrowdsale`, whose
    name doesn’t make any reference to any funding strategy, also inherits from `SimpleCrowdsale`,
    which implements an unlimited funding strategy. A more precise name for this contract
    probably would be `UncappedTranchePricingCrowdsale`.'
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
- en: 7.1.2\. Generalizing funding limit strategy with an abstract contract
  id: totrans-1037
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now I’ll show you a better solution for implementing `CappedCrowdsale` and `CappedTranchePricingCrowdsale`
    based on the concept of abstract classes. I’ll also show you how abstract classes
    can make the crowdsale contract hierarchy you saw in [figure 7.1](#ch07fig01)
    symmetric and more explicit. This involves first encapsulating the funding limit
    strategy functionality into a completely separate contract, which I’ll sketch
    for the moment as
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.1\. A UML contract diagram showing asymmetry in the crowdsale contract
    hierarchy and ambiguity regarding token pricing strategy or funding limit strategy
    in the name of some contracts. For clarity's sake, I’ve omitted ownable, pausable,
    and destructible base contracts.
  id: totrans-1039
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig07-01_alt.jpg)'
  id: totrans-1040
  prefs: []
  type: TYPE_IMG
- en: '[PRE127]'
  id: totrans-1041
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '***1*** **This is the function that performs the check on the funding cap,
    although it’s not yet implemented at this stage.**'
  id: totrans-1042
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can imagine this is a base contract for all possible funding limit strategies.
    Here are two possible funding limit strategies:'
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
- en: '*CappedFundingStrategy*—Crowdsale with funding capped by `fundingCap` limit,
    as seen earlier in the `CappedTranchePricingCrowdsale` contract'
  id: totrans-1044
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*UnlimitedFundingStrategy*—Crowdsale with unlimited (or uncapped) funding'
  id: totrans-1045
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can derive the implementation for a capped crowdsale from `FundingLimitStrategy`
    as follows:'
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  id: totrans-1047
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '***1*** **Funding cap limit**'
  id: totrans-1048
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **This is the same implementation you saw earlier in CappedTranche-PricingCrowdsale.**'
  id: totrans-1049
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The implementation for an unlimited funding strategy is
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  id: totrans-1051
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '***1*** **No check is performed because the funding is unlimited.**'
  id: totrans-1052
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Obviously, you can derive other funding limit strategies from `FundingLimitStrategy`.
    For example, you could implement a strategy with a dynamic funding limit, readjusted
    depending on various factors that might change during the crowdsale.
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
- en: '`FundingLimitStrategy` is considered an *abstract contract* because you’ve
    declared its `isFullInvestmentWithinLimit()` function but haven’t implemented
    it. On the other hand, `CappedFundingStrategy` and `UnlimitedFundingStrategy`
    are considered *concrete contracts* because all of their functions have been implemented.'
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-1055
  prefs: []
  type: TYPE_TB
- en: Definition
  id: totrans-1056
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A contract is considered *abstract* if it contains at least one declared but
    unimplemented function. An abstract contract is used as a base class for other
    contracts, but it can’t be instantiated. A contract whose functions have all been
    implemented is considered a *concrete* contract.
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-1058
  prefs: []
  type: TYPE_TB
- en: The UML contract diagram in [figure 7.2](#ch07fig02) shows the inheritance hierarchy
    of funding limit strategy contracts.
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-1060
  prefs: []
  type: TYPE_TB
- en: Note
  id: totrans-1061
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You might have noticed that the name of *FundingLimitStrategy* in [figure 7.2](#ch07fig02)
    is in italic. This is the UML convention for writing the name of abstract classes.
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-1063
  prefs: []
  type: TYPE_TB
- en: Figure 7.2\. Funding limit strategy contract hierarchy, including an abstract
    base contract and two concrete child contracts
  id: totrans-1064
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig07-02_alt.jpg)'
  id: totrans-1065
  prefs: []
  type: TYPE_IMG
- en: 7.1.3\. Improving the token pricing strategy with an abstract contract
  id: totrans-1066
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can apply the approach you took to make the funding limit base strategy
    contract abstract to tidy up the crowdsale contract hierarchy and make the token
    pricing strategy used by each contract more explicit, as shown in [figure 7.3](#ch07fig03).
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.3\. Making the crowdsale contract hierarchy symmetrical and more explicit.
    `SimpleCrowdsale` has been made abstract by pushing the implementation of fixed
    token pricing down to a new `FixedPricingCrowdsale` contract.
  id: totrans-1068
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig07-03_alt.jpg)'
  id: totrans-1069
  prefs: []
  type: TYPE_IMG
- en: 'This is the main change taking place in `SimpleCrowdsale`:'
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  id: totrans-1071
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '***1*** **This function has become abstract and has made SimpleCrowdsale abstract.**'
  id: totrans-1072
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The fixed token pricing strategy previously in `SimpleCrowdsale` has been pushed
    down to the new `FixedPricingCrowdsale` contract:'
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  id: totrans-1074
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '***1*** **This formula was in SimpleCrowdsale, and now it has been moved here.**'
  id: totrans-1075
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Meanwhile, `TranchePricingCrowdsale` is unaltered from the previous implementation.
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
- en: 7.1.4\. Reimplementing capped crowdsales with no duplication
  id: totrans-1077
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After having encapsulated the crowdsale funding limit strategy in the `FundingLimitStrategy`
    contract hierarchy, and having slightly refactored the crowdsale contract hierarchy,
    you can attempt to reimplement `CappedCrowdsale` and `CappedTranchePricingCrowdsale`,
    this time avoiding duplication.
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you have to add the funding limit strategy to `SimpleCrowdsale` as a
    state variable: `fundingLimitStrategy`. You can instantiate a specific funding
    limit strategy in the constructor through a new function called `createFundingLimitStrategy()`,
    which here is declared as abstract and you must implement in the inherited contracts.
    Then you can use `fundingLimitStrategy` in the `isValidInvestment()` function:'
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  id: totrans-1080
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '***1*** **State variable holding the funding limit strategy**'
  id: totrans-1081
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **A specific funding limit strategy is instantiated through createFundingLimitStrategy(),
    which is declared here as abstract.**'
  id: totrans-1082
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **Instantiates a specific FundingLimitStrategy. It’s abstract, and
    you must implement it in inherited contracts.**'
  id: totrans-1083
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***4*** **The check against the funding limit is performed through the appropriate
    FundingLimitStrategy contract.**'
  id: totrans-1084
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It’s now possible to implement the four concrete crowdsale contracts that result
    from combining the token pricing strategy and the funding limit strategy in different
    ways, as shown in the amended crowdsale contract hierarchy in [figure 7.4](#ch07fig04):'
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.4\. Reorganized crowdsale contract hierarchy, with two layers of abstract
    contracts at the top and a bottom layer of concrete contracts encapsulating all
    combinations of the contract pricing and funding limit options. The `FundingLimitStrategy`
    contract hierarchy now encapsulates the checks on the funding limit in an efficient
    way that avoids code duplication.
  id: totrans-1086
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig07-04_alt.jpg)'
  id: totrans-1087
  prefs: []
  type: TYPE_IMG
- en: '`UnlimitedFixedPricingCrowdsale`—Derived from `FixedPricingCrowdsale`, with
    `UnlimitedFundingStrategy` instance'
  id: totrans-1088
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CappedFixedPricingCrowdsale`—Derived from `FixedPricingCrowdsale`, with `CappedFundingStrategy`
    instance'
  id: totrans-1089
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UnlimitedTranchePricingCrowdsale`—Derived from `TranchePricingCrowdsale`,
    with `UnlimitedFundingStrategy` instance'
  id: totrans-1090
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CappedTranchePricingCrowdsale`—Derived from `TranchePricingCrowdsale`, with
    `CappedFundingStrategy` instance'
  id: totrans-1091
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-1092
  prefs: []
  type: TYPE_TB
- en: Note
  id: totrans-1093
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The two intermediate `FixedPricingCrowdsale` and `TranchePricingCrowdsale` contracts
    have become abstract because they don’t implement `createFundingLimitStrategy()`.
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-1095
  prefs: []
  type: TYPE_TB
- en: The implementation of these four concrete contracts, which you can appreciate
    in [listing 7.4](#ch07ex04), is succinct. These contracts derive from the abstract
    crowdsale contract with the relevant token pricing strategy (either `FixedPricingCrowdsale`
    or `TranchePricingCrowdsale`) and implement `createFundingLimitStrategy()` by
    returning a specific funding limit strategy. All the work is then delegated to
    the abstract contracts they derive from.
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
- en: Listing 7.4\. Crowdsale contracts combining different pricing and funding limit
    options
  id: totrans-1097
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE133]'
  id: totrans-1098
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '***1*** **Only feeds the parent contract**'
  id: totrans-1099
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **The only function implemented; overrides the abstract one in SimpleCrowdsale
    and provides a specific funding limit strategy**'
  id: totrans-1100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.2\. Allowing multiple contract implementations with interfaces
  id: totrans-1101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before we leave `SimpleCrowdsale`, I’d like to show you one last object-oriented
    feature: interfaces. If you’re familiar with other OO languages, you’ll understand
    immediately how interfaces work in Solidity. If not, I’ll explain them through
    an example, so you should still be able to pick up the concept quickly.'
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
- en: 7.2.1\. Setting functional requirements with interfaces
  id: totrans-1103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Imagine the client who asked you to customize the crowdsale with the capped
    funding strategy now wants another change. They’re happy about your crowdsale
    contract, but they want to support other tokens, not necessarily your `ReleasableSimpleCoin`.
    You think this is a fair request that will also provide flexibility to new clients.
    After analyzing your current code, you realize your crowdsale contracts have only
    minimal interaction with `ReleasableSimpleCoin`. The only references to it are
    in `SimpleCrowdsale`, the base contract of the hierarchy, as highlighted here:'
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  id: totrans-1105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '***1*** **Defines crowdsaleToken as a state variable**'
  id: totrans-1106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **Initializes crowdsaleToken in the SimpleCrowdsale constructor**'
  id: totrans-1107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **Mints tokens bought from the investor into their account**'
  id: totrans-1108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***4*** **Releases (unlocks) the token contract so investors can transfer their
    tokens**'
  id: totrans-1109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'From your point of view, as the crowdsale contract developer, you only care
    that the token used in the crowdsale supports the following two functions:'
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  id: totrans-1111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'Obviously, to be useful to the investor, the token contract should also support
    at least the following function:'
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  id: totrans-1113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'The syntax construct that defines the minimum set of functions the token contract
    should support is called an *interface*. The token interface that `SimpleCrowdsale`
    would reference would look like this:'
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  id: totrans-1115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 7.2.2\. Referencing a contract through an interface
  id: totrans-1116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can define a contract that implements this interface by inheriting from
    it. Here’s an example:'
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  id: totrans-1118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '***1*** **ReleasableSimpleCoin already implements ReleasableToken as it stands.**'
  id: totrans-1119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You also can create other implementations:'
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  id: totrans-1121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[Figure 7.5](#ch07fig05) shows the relationship between an interface and its
    implementations. As you can see, you can represent in two ways how a concrete
    contract implements an interface.'
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
- en: Now you can modify `SimpleCrowdsale` so that it references the `ReleasableToken`
    interface rather than a concrete token contract. You should also instantiate the
    token contract in an overridden internal function rather than directly in the
    constructor, as you can see in the following listing.
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.5\. Relationships between an interface and its concrete implementations.
    You can represent this relationship in two ways. The first one resembles inheritance,
    with the interface being the parent of its implementations. The second one uses
    an explicit interface symbol that’s useful if you don’t want to show all the interface
    implementations.
  id: totrans-1124
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig07-05_alt.jpg)'
  id: totrans-1125
  prefs: []
  type: TYPE_IMG
- en: Listing 7.5\. `SimpleCrowdsale` referencing `ReleasableToken`
  id: totrans-1126
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE140]'
  id: totrans-1127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '***1*** **Now the crowdsale contract can be any token implementing ReleasableToken.**'
  id: totrans-1128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **Instantiates the token contract in a function that can be overridden**'
  id: totrans-1129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **The default implementation that the SimpleCrowdsale abstract contract
    offers still instantiates ReleasableSimpleCoin.**'
  id: totrans-1130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-1131
  prefs: []
  type: TYPE_TB
- en: Note
  id: totrans-1132
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You also could have declared `createToken()` as an abstract function within
    `SimpleCrowdsale`. This would have been the purest approach, but it would have
    forced you to implement `createToken()` in all concrete contracts (such as `UnlimitedFixedPricingCrowdsale`).
    The individual implementation of `createToken()` in each concrete contract would
    have been the same as in [listing 7.5](#ch07ex05). This duplication might seem
    unnecessary, though, given that in most cases you’d want to reference `ReleasableSimpleCoin`
    anyway. There’s no right or wrong design in this regard, and the solution you
    choose depends on how you want to balance requirements and technical tradeoffs.
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-1134
  prefs: []
  type: TYPE_TB
- en: So far, nothing seems to have changed. You start enjoying the benefit of referencing
    an interface rather than a concrete contract when you implement a crowdsale contract
    that needs a custom token. Imagine your client wants to use a different token
    contract, such as
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  id: totrans-1136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'You can easily implement a new crowdsale contract that supports this token
    by overriding the `createToken()` function:'
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  id: totrans-1138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '***1*** **To support a different token contract, you need to override this
    function.**'
  id: totrans-1139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can see `UnlimitedFixedPricingCrowdsaleWithComplexCoin`’s contract diagram
    in [figure 7.6](#ch07fig06).
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.6\. A contract diagram of `UnlimitedFixedPricingCrowdsaleWithComplexCoin`.
    You can appreciate the relationships between the abstract `SimpleCrowdsale` contract
    and the `ReleasableToken` token interface and between the concrete `UnlimitedFixedPricing-CrowdsaleWithComplexCoin`
    crowdsale contract and the concrete `ReleasableComplexCoin` token contract.
  id: totrans-1141
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig07-06_alt.jpg)'
  id: totrans-1142
  prefs: []
  type: TYPE_IMG
- en: As you can see, an interface is a useful construct that increases the flexibility
    of one element or aspect of your contract (for example, the specific token used
    in your crowdsale). By referencing an interface rather than a concrete contract
    (`ReleasableToken` rather than `ReleasableSimpleCoin` in our example), your main
    contract (`Simple-Crowdsale`) can work seamlessly with any implementation of the
    interface (`ReleasableSimpleCoin` or `ReleasableComplexCoin,` for example). As
    a result, you’re free to change the behavior of one element of your main contract
    (in the case we’ve been reviewing, the behavior of the crowdsale token used) without
    requiring any changes to the contract itself. This ability to switch seamlessly
    between different implementations of an interface is called *polymorphism*, and
    it’s one of the main principles of object-oriented programming.
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
- en: I’m sure you’re wondering whether you could have achieved the same by making
    `ReleasableToken` an abstract contract rather than an interface. You’re right;
    it would have worked equally well, but by doing so you’d introduce in your code
    base a contract you don’t fully need yet. What you need at this stage is only
    the definition of the minimum functionality that `SimpleCrowdsale` requires to
    interact with a token. That’s exactly the purpose of an interface.
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
- en: 'Before leaving interfaces, let me quickly summarize how they work:'
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
- en: 'An interface defines the set of functions that must be implemented; you must
    declare them with `external` visibility:'
  id: totrans-1146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE143]'
  id: totrans-1147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'A contract implements an interface by inheriting from it:'
  id: totrans-1148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE144]'
  id: totrans-1149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE144]'
- en: A contract must implement all the functions present in the interface it inherits
    from.
  id: totrans-1150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Congratulations! You’ve now completed a full implementation of a crowdsale contract
    hierarchy. This allows you to set up crowdsales with different token contracts,
    token pricing strategies, or funding limit strategies. The fruits of your hard
    work are shown in [appendix B](kindle_split_031.xhtml#app02). I encourage you
    to take a break, browse through the code, and try to digest it slowly. You’ll
    appreciate how all the pieces of the puzzle you’ve built in the last two chapters
    have come together. I’m sure that by looking at the entire code all the concepts
    you’ve learned will settle further into your head.
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
- en: 7.3\. Real-world crowdsale contracts
  id: totrans-1152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Although `SimpleCrowdsale` is a good starting point, real-world crowdsale contracts
    can get much more complex because they offer much more functionality, such as
    the following:'
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
- en: A prefunding stage, during which early investors provide initial funding, which
    gets converted into tokens, possibly at a special price, at the beginning of the
    public crowdsale
  id: totrans-1154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More sophisticated token pricing strategies
  id: totrans-1155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A funding limit based on the number of tokens purchased
  id: totrans-1156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finalization strategies, including the possibility of distributing additional
    tokens to the development team, the organizers, or the legal and advisory team
  id: totrans-1157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tokens with various characteristics
  id: totrans-1158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-1159
  prefs: []
  type: TYPE_TB
- en: Warning
  id: totrans-1160
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In these two introductory chapters on Solidity, I haven’t touched on security
    aspects you must be aware of before deploying a contract onto the public Ethereum
    network. I’ll cover them in [chapter 14](kindle_split_028.xhtml#ch14).
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-1162
  prefs: []
  type: TYPE_TB
- en: The main objective of `SimpleCrowdsale` was to teach you inheritance, abstract
    classes, and interfaces in Solidity through a realistic use case, as well as to
    give you some technical details of how a crowdsale works. If you’re interested
    in learning more about how to build a decentralized crowdsale management application,
    or you’re curious to see how complex a real-world Dapp can be, I strongly encourage
    you to study the code of the TokenMarketNet ICO^([[1](#ch07fn01)]) GitHub repository,
    one of the best open source Ethereum crowdsale implementations, at [https://github.com/TokenMarketNet/ico](https://github.com/TokenMarketNet/ico).
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
- en: ¹
  id: totrans-1164
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1165
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Copyright © 2017 TokenMarket Ltd., Gibraltar, [https://tokenmarket.net](https://tokenmarket.net).
    Licensed under the Apache License, V2.0.
  id: totrans-1166
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: I encourage you to quickly review the contracts in this repository and compare
    them with the respective `SimpleCrowdsale` ones you saw earlier. You’ll realize
    how complex a real-world Dapp can become both in size (number of contracts) and
    implementation.
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
- en: A little challenge
  id: totrans-1168
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As an exercise, I now leave you to try on your own to implement different finalization
    strategies, which you could encapsulate in yet another contract hierarchy with
    a base abstract contract, such as `FinalizationStrategy`. You could then create
    a new set of concrete contracts in which you inject such strategy at construction,
    as you’ve done when injecting the funding strategy.
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
- en: 7.4\. Recap of Solidity’s object-oriented features
  id: totrans-1170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you’re still alive after the hard work you’ve done so far in this chapter,
    I’m going to give you a break now. I’ll summarize and generalize all you’ve learned
    through `Simple-Crowdsale`. In case you forget some details, you won’t have to
    dig through the previous code listings and snippets to find the syntax associated
    with object-oriented features such as inheritance, abstract classes, and interfaces.
    Sit back and relax.
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
- en: 7.4.1\. Inheritance
  id: totrans-1172
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Solidity supports multiple inheritance, so a derived contract can inherit state
    variables and functions from one or more contracts, as shown here:'
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  id: totrans-1174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '***1*** **Child inherits the state variables stateVar1, stateVar2, stateVarA,
    and stateVarB, and the functions operation1() and operationA() from its parent
    contracts, Parent1 and ParentA**'
  id: totrans-1175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling base constructors
  id: totrans-1176
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The constructor of a derived contract must call all the parent constructors
    (in the order you want them to be called):'
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  id: totrans-1178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: Overriding functions
  id: totrans-1179
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A derived contract can override any function inherited from its parent contracts
    by reimplementing it:'
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  id: totrans-1181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '***1*** **New implementation that replaces ParentA.operationA()**'
  id: totrans-1182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a function is called on a contract, its most overridden implementation,
    at the bottom of the inheritance hierarchy, will get executed.
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
- en: Calling base functions
  id: totrans-1184
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'An overridden function can call a function located in a base contract, as follows:'
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  id: totrans-1186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '***1*** **Calls ParentA.operationA()**'
  id: totrans-1187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In some cases, you might want to make sure all the base implementations of
    a function are called. In those cases, you can call all of them implicitly with
    the `super` keyword:'
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  id: totrans-1189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '***1*** **Calls Parent1.initialize() followed by ParentA.initialize()**'
  id: totrans-1190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.4.2\. Abstract contracts
  id: totrans-1191
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A contract is considered *abstract*, rather than concrete, if at least one
    of its functions is abstract, which means it has been declared but not implemented,
    as is the case with `operationA()` in this contract:'
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  id: totrans-1193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '***1*** **This is an abstract function, which makes AbstractContract abstract.**'
  id: totrans-1194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As in other statically typed languages, Solidity abstract contracts can’t be
    instantiated; they can only be used as base contracts for other abstract or concrete
    contracts.
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
- en: 7.4.3\. Interfaces
  id: totrans-1196
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Interfaces in Solidity are similar to those offered in Java and C#. An interface
    defines the set of functions and events that must be implemented in their derived
    contracts, but it doesn’t provide any implementation. All the functions declared
    on an interface are abstract, as shown here:'
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  id: totrans-1198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'A contract derived from an interface must implement all of its functions, as
    shown here:'
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  id: totrans-1200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '***1*** **Implementation of operation1**'
  id: totrans-1201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **Constructor definition**'
  id: totrans-1202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-1203
  prefs: []
  type: TYPE_TB
- en: Note
  id: totrans-1204
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You can’t define any variables, structs, or enums on an interface. Also, you
    can’t derive an interface from other interfaces.
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-1206
  prefs: []
  type: TYPE_TB
- en: Although you can avoid code duplication by factoring a good class hierarchy
    where contracts at the bottom reuse function implementations located in their
    base classes, often common shareable logic isn’t specific to the domain of a contract
    hierarchy and has a more generic purpose. For example, functions that manipulate
    low-level data structures, such as arrays, byte arrays, or strings, in a generic
    way might be useful in any contract. The naive way to import such functionality
    is to copy and paste the required functions from a function repository into the
    contracts that need them. But there’s a much smarter way. Enter libraries.
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
- en: 7.4.4\. A word of caution
  id: totrans-1208
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'I’ve presented in this chapter all of Solidity’s object-oriented features,
    and I’ve shown you how real-world Dapps, such as TokenMarketNet, have been designed
    using advanced object-oriented principles. But remember that Solidity is meant
    to be used only to implement smart contracts and not rich general-purpose applications,
    so in most cases, you might not need a complex OO design after all. People fall
    into different schools of thought when it comes to designing smart contracts:
    whereas some are comfortable with taking advantage of Solidity’s rich OO feature
    set, most Ethereum developers prioritize simplicity and security and are willing
    to sacrifice long-term maintainability to gain short-term predictability. I believe
    the latter approach is sensible, especially while you’re still learning this new
    technology.'
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
- en: 7.5\. Libraries
  id: totrans-1210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A Solidity library is a shared function repository similar in purpose to a Java
    class package or a .NET class library. The code of a library looks like that of
    a C# or C++ static class, and it contains a collection of stateless functions.
    It can also include struct and enum definitions. You can get an idea of what a
    library looks like in [listing 7.6](#ch07ex06), which shows SafeMath, a collection
    of functions to execute math operations that include safety checks around incorrect
    input or overflows. This library is part of OpenZeppelin,^([[2](#ch07fn02)]) an
    open source framework to build secure smart contracts in Solidity, which aims
    at standardizing common functionality required by most Solidity developers.
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
- en: ²
  id: totrans-1212
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1213
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Copyright © 2016 Smart Contract Solutions, Inc., [http://mng.bz/oNPv](http://mng.bz/oNPv),
    under The MIT License (MIT).
  id: totrans-1214
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Listing 7.6\. SafeMath library for performing checked math operations
  id: totrans-1215
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE153]'
  id: totrans-1216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '***1*** **Uses the library keyword instead of the contract keyword**'
  id: totrans-1217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **Functions in a library are defined exactly as in contracts.**'
  id: totrans-1218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **Checks on the input or on the result of the arithmetic operation**'
  id: totrans-1219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***4*** **Functions in a library are defined exactly as in contracts.**'
  id: totrans-1220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***5*** **Checks on the input or on the result of the arithmetic operation**'
  id: totrans-1221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A library has the following limitations, compared to a contract:'
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
- en: It can’t have state variables.
  id: totrans-1223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It doesn’t support inheritance.
  id: totrans-1224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can’t receive Ether. (You can’t decorate a function with the `payable` keyword
    and send Ether to it while invoking it.)
  id: totrans-1225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.5.1\. Library function invocation
  id: totrans-1226
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A contract can reference a local copy of a library (located in the same `.sol`
    code file) directly by its name, as shown in [listing 7.7](#ch07ex07). As you
    can see, you invoke library functions by prefixing them with the library name,
    like you invoke static functions in other languages. You also have to prefix library
    structs and enums with the library name.
  id: totrans-1227
  prefs: []
  type: TYPE_NORMAL
- en: Listing 7.7\. How to call library functions
  id: totrans-1228
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE154]'
  id: totrans-1229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '***1*** **SafeMath library functions are all prefixed with SafeMath.**'
  id: totrans-1230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.5.2\. Deployed libraries
  id: totrans-1231
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: True code reuse takes place when only one instance of the library is deployed
    on the network and all contracts accessing it reference it through its deployment
    address (conceptually the same as a contract address). Once deployed, the functions
    of a library are exposed with implicit *external* visibility to all the contracts
    referencing it. The usual way of calling a deployed library from a contract is
    to define a local abstract contract that matches the signature of the deployed
    library. Then you communicate with the library through this local abstract contract,
    which acts as a strongly typed proxy to the library, as shown in the following
    listing. The alternative would be to invoke the library functions directly through
    `call()`, but by doing so, you wouldn’t guarantee type safety.
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
- en: Listing 7.8\. How to call library functions from a contract
  id: totrans-1233
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE155]'
  id: totrans-1234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '***1*** **This local abstract contract emulates the functionality offered by
    the library.**'
  id: totrans-1235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **These are the same function declarations present in the SafeMath
    library.**'
  id: totrans-1236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **SafeMath library address (copied from Remix, as show in [figure 7.8](#ch07fig08))**'
  id: totrans-1237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***4*** **References the SafeMath library deployed at the specified address
    through an implicit constructor available for all contracts that takes the contract
    address as a parameter**'
  id: totrans-1238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***5*** **Calls to the deployed SafeMath library**'
  id: totrans-1239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before trying this code, put the [listing 7.6](#ch07ex06) code into a Remix
    code tab and instantiate the SafeMath library (by clicking Deploy, as for contracts).
    Copy the address by clicking the copy icon next to the contract instance panel,
    as shown in [figure 7.7](#ch07fig07).
  id: totrans-1240
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.7\. Get the SafeMath library address from Remix by clicking the copy
    icon.
  id: totrans-1241
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig07-07_alt.jpg)'
  id: totrans-1242
  prefs: []
  type: TYPE_IMG
- en: Now enter the code from [listing 7.7](#ch07ex07) into a new Remix code tab.
    Then paste the SafeMath library address you copied earlier into the Calculator
    constructor text box next to the Deploy button, as show in [figure 7.8](#ch07fig08).
    (Remember to wrap it with double quotes.) Click Deploy, and the `Calculator` contract
    gets instantiated. Now you can call `calculate-Theta()` by entering a couple of
    values into its input parameters text box—for example, 200, 33—and clicking calculateTheta.
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.8\. Copy the SafeMath library address into the Calculator constructor
    text box.
  id: totrans-1244
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig07-08_alt.jpg)'
  id: totrans-1245
  prefs: []
  type: TYPE_IMG
- en: 'After you click calculateTheta, various calls to remote `SafeMath` functions
    are performed through the `safeMath` proxy instance: `sub()`, `add()`, `mul()`,
    and `div()` are executed in sequence and `result` is calculated. The output panel
    on the bottom left of the screen shows that `calculateTheta()`’s function completed
    successfully. You can then see the result by clicking the arrow next to the Debug
    button and checking the Decoded Output field, as shown in [figure 7.9](#ch07fig09).'
  id: totrans-1246
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.9\. After the call to `calculateTheta()` completes, you can click Details
    and check the result in the Decoded Output field.
  id: totrans-1247
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig07-09_alt.jpg)'
  id: totrans-1248
  prefs: []
  type: TYPE_IMG
- en: 7.5.3\. Library function execution
  id: totrans-1249
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When a library function is called, its code is executed within the context of
    the calling contract. For example, if the code of a function library references
    `msg`, this isn’t the message sent by the contract to the library, but the message
    received by the contract from its caller. Also, during a library function invocation,
    only the calling contract, not the library itself, accesses storage directly.
    This means library functions manipulate the value of any reference type variables
    with storage data locations passed to the functions. As mentioned earlier, libraries
    don’t permanently hold any objects at all.
  id: totrans-1250
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-1251
  prefs: []
  type: TYPE_TB
- en: Note
  id: totrans-1252
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A library function is executed in the context of the calling contract because
    it’s invoked through the `DELEGATECALL` opcode rather than the `CALL` opcode.
  id: totrans-1253
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-1254
  prefs: []
  type: TYPE_TB
- en: In the previous chapter, I introduced a small improvement to `SimpleCoin` by
    extracting the ownership functionality out to the `Ownable` contract. In this
    chapter, I’ll present a new enhancement related to token standardization.
  id: totrans-1255
  prefs: []
  type: TYPE_NORMAL
- en: 7.6\. Making SimpleCoin ERC20 compliant
  id: totrans-1256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Creating a custom cryptocurrency or token contract has become such a common
    requirement for most decentralized applications that a standard token interface
    has been proposed. Such an interface would allow any contract (such as your `Simple-Crowdsale`
    contract) to interact with a token contract in a predictable way. The standard
    Ethereum token contract is called `ERC20`. The following listing shows the standard
    token functionality every `ERC20`-compliant token is expected to provide, expressed
    as an abstract contract.
  id: totrans-1257
  prefs: []
  type: TYPE_NORMAL
- en: Listing 7.9\. `ERC20` abstract contract, defining the Ethereum standard token
  id: totrans-1258
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE156]'
  id: totrans-1259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: If you compare this with your latest implementation of `SimpleCoin`, shown in
    [appendix A](kindle_split_030.xhtml#app01), which includes the modifications around
    contract ownership I introduced in [chapter 5](kindle_split_017.xhtml#ch05), you’ll
    notice your token is almost `ERC20`-compliant. [Table 7.1](#ch07table01) summarizes
    the main differences between `SimpleCoin` and the `ERC20` specification.
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
- en: Table 7.1\. Differences between the `ERC20` specification and `SimpleCoin`
  id: totrans-1261
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| ERC20 specification | SimpleCoin equivalent |'
  id: totrans-1262
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-1263
  prefs: []
  type: TYPE_TB
- en: '| totalSupply | Not available |'
  id: totrans-1264
  prefs: []
  type: TYPE_TB
- en: '| balanceOf() | coinBalance() |'
  id: totrans-1265
  prefs: []
  type: TYPE_TB
- en: '| approve() | authorize() |'
  id: totrans-1266
  prefs: []
  type: TYPE_TB
- en: '| allowance() | Not available (direct use of allowance state variable) |'
  id: totrans-1267
  prefs: []
  type: TYPE_TB
- en: '| Approval | Not available |'
  id: totrans-1268
  prefs: []
  type: TYPE_TB
- en: You can use [table 7.1](#ch07table01) to refactor `SimpleCoin` into a fully
    compliant ERC20 token. The following listing shows what such an implementation
    would look like, also taking into account the standard parameter names of functions
    and events.
  id: totrans-1269
  prefs: []
  type: TYPE_NORMAL
- en: Listing 7.10\. `SimpleCoin` refactored to an `ERC20` token
  id: totrans-1270
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE157]'
  id: totrans-1271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '***1*** **These state variables have become internal. They’re now exposed externally
    through dedicated functions.**'
  id: totrans-1272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **New event associated with approving an allowance**'
  id: totrans-1273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **Allows you to check coinBalance externally**'
  id: totrans-1274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***4*** **Raises an event when a balance is approved**'
  id: totrans-1275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***5*** **Allows you to check allowances externally**'
  id: totrans-1276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Although the token constructor isn’t part of the interface and consequently
    isn’t included in the standard, ERC20 recommends initializing a token with the
    following useful information:'
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  id: totrans-1278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '***1*** **Number of decimal digits to consider in fractional token amounts**'
  id: totrans-1279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ERC20` wiki ([http://mng.bz/5NaD](http://mng.bz/5NaD)) also shows a recommended
    implementation. Although this is similar to `SimpleCoin`, I still encourage you
    to review it. I suggest you also have a look at the OpenZeppelin section on tokens
    at [http://mng.bz/6jQ6](http://mng.bz/6jQ6).
  id: totrans-1280
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-1281
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Abstract contracts generalize contract functionality and help minimize code
    duplication by providing default function implementations when appropriate.
  id: totrans-1282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An interface provides the declaration of the minimum set of functions a contract
    should provide.
  id: totrans-1283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can seamlessly change the behavior of one element or aspect of a contract
    by modeling it with an interface. By doing so, you can instantiate a different
    implementation of the interface without having to alter the code of the contract
    using it.
  id: totrans-1284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can organize general purpose Solidity functions in libraries, which you
    can share across different contracts or applications.
  id: totrans-1285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a custom cryptocurrency or token contract is such a common requirement
    for most decentralized applications that a standard token interface called `ERC20`
    has been proposed. Any decentralized application can use a token contract that
    follows the `ERC20` standard in a predictable way.
  id: totrans-1286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chapter 8\. Managing smart contracts with Web3.js
  id: totrans-1287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-1288
  prefs: []
  type: TYPE_TB
- en: '**This chapter covers**'
  id: totrans-1289
  prefs: []
  type: TYPE_NORMAL
- en: Deploying contracts and interacting with them through geth’s console
  id: totrans-1290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simplifying console-based deployment with Node.js
  id: totrans-1291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying on a private network
  id: totrans-1292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying on a mock network
  id: totrans-1293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-1294
  prefs: []
  type: TYPE_TB
- en: In [chapter 4](kindle_split_015.xhtml#ch04), you had a first taste of deploying
    a smart contract on the Ethereum network. You did so through the Ethereum wallet
    and through Remix (with MetaMask). It looked relatively easy, as it involved only
    a few clicks on a well-designed screen. On the other hand, the convenience and
    simplicity of the user interface hid from you the key steps that take place on
    the network when contract deployment is in progress. Did you ask yourself, for
    example, how the code you entered on the code editor (of the wallet or Remix)
    got compiled, packaged, and sent to the Ethereum network, and how it finally got
    installed on each node?
  id: totrans-1295
  prefs: []
  type: TYPE_NORMAL
- en: In the last three chapters, you learned in depth how to develop a smart contract
    with Solidity. It’s time to learn the deployment process in depth as well. It’s
    important knowledge to have if you want to truly understand how decentralized
    applications work under the hood, and if you want to be able to troubleshoot postdeployment
    issues you might experience.
  id: totrans-1296
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll learn how to deploy and communicate with a smart contract
    through the geth console, using explicit Web3.js instructions. By doing so, you’ll
    perform all the commands and operations the wallet UI did magically for you while
    deploying the contract or moving tokens between accounts. Not only will you deploy
    a contract the hard way on a public test network, but you’ll go the extra mile
    and even set up a full private network and redeploy the contract on it. All of
    this will take much more effort than clicking a few buttons on the wallet UI,
    but you’ll be rewarded by gaining a much deeper knowledge of how an Ethereum network
    and related blockchain are set up and configured, as well as firsthand insight
    into the deployment process and client-to-network interaction. Along the way,
    I’ll also show you how to simplify the deployment process a little by running
    operations on Node.js.
  id: totrans-1297
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after you’ve deployed a contract on a public test network and a private
    test network, you’ll also learn how to deploy a contract on Ganache, a special
    client that emulates (or mocks) a full Ethereum network on a single host. This
    is a convenient environment for developing and system-testing your contracts without
    having to pay for the latency of operations that take place on a real network,
    such as waiting for transactions to be mined and added on a new block, especially
    through times of network instability.
  id: totrans-1298
  prefs: []
  type: TYPE_NORMAL
- en: Before leaving the chapter, we’ll revisit `SimpleCoin`. This time, I’ll take
    advantage of the fact that you’ll have already learned how to deploy it on the
    network and communicate with it through Web3.js commands on the geth console.
    I’ll be able to show you how to build a simple UI that uses the same Web3 commands,
    but from within an HTML page.
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
- en: 8.1\. Revisiting deployment through geth’s interactive console
  id: totrans-1300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you installed geth, in [chapter 3](kindle_split_014.xhtml#ch03), you were
    pointing to MAINNET, the production Ethereum network. During development, I strongly
    advise you to point your tools, including your Ethereum client, to a test network
    instead, at least to avoid spending any real Ether directly or indirectly through
    accidental transactions or gas consumption. Various test networks are available
    at any given time, with a couple current examples being Ropsten and Rinkeby. Each
    test network is related to a slightly different version of the Ethereum platform,
    and you might find you have to upgrade geth to be able to run on a specific network.
    For the purposes of this chapter, I’ll refer to a test network as TESTNET.
  id: totrans-1301
  prefs: []
  type: TYPE_NORMAL
- en: 'To point geth to TESTNET, you must shut down any instance running against MAINNET
    (if you have any) and restart geth from a new command shell with the `--testnet`
    option:'
  id: totrans-1302
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  id: totrans-1303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: Geth will start synchronizing to the test network in exactly the same way it
    did when you started it in MAINNET.
  id: totrans-1304
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-1305
  prefs: []
  type: TYPE_TB
- en: Note
  id: totrans-1306
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In case you want to experiment and point to the Rinkeby test network based on
    the Proof of Stake consensus algorithm, use the `--rinkeby` option instead of
    `–-testnet` by typing `C:\Program Files\geth>geth –-rinkeby`. The rest of the
    chapter assumes you’re using `––testnet`.
  id: totrans-1307
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-1308
  prefs: []
  type: TYPE_TB
- en: '|  |'
  id: totrans-1309
  prefs: []
  type: TYPE_TB
- en: '**Using bootnodes to connect to specific peers**'
  id: totrans-1310
  prefs: []
  type: TYPE_NORMAL
- en: 'Occasionally your geth client might take a long time to discover peers that
    can send you the blockchain blocks. In that case, try using the `--bootnodes`
    option, which will force geth to access the network by connecting to specific
    peers, rather than discovering all peers by itself. I’ve found these nodes to
    be up most of the time:'
  id: totrans-1311
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  id: totrans-1312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'If you want to sync up your blockchain more quickly, you can also add these
    options:'
  id: totrans-1313
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  id: totrans-1314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '|  |'
  id: totrans-1315
  prefs: []
  type: TYPE_TB
- en: 'From a separate command shell, you can now start an interactive console pointing
    to the test network exactly as you did when you were pointing to the main network:'
  id: totrans-1316
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  id: totrans-1317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: (Note that since geth 1.8.0, you have to specify the IPC path.) When the console
    starts up, it shows environmental information about the network it’s pointing
    to. As you can see in [figure 8.1](#ch08fig01), `datadir` is pointing to `testnet`,
    which confirms you’re now in TESTNET.
  id: totrans-1318
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.1\. The geth interactive console showing it’s connected to TESTNET
  id: totrans-1319
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig08-01_alt.jpg)'
  id: totrans-1320
  prefs: []
  type: TYPE_IMG
- en: Deploying a contract through geth’s console for the first time is slightly more
    involved than doing it with a few clicks on Ethereum’s wallet. The wallet hides
    some of the steps that happen under the hood. By performing those steps explicitly,
    you’ll learn how the contract build and deployment process works in detail. Also,
    once you’ve scripted the entire process, future redeployment will become much
    quicker and less error-prone.
  id: totrans-1321
  prefs: []
  type: TYPE_NORMAL
- en: 8.1.1\. Contract build and deployment process
  id: totrans-1322
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The diagram in [figure 8.2](#ch08fig02) shows all the main steps required to
    build and deploy the contract through the interactive console:'
  id: totrans-1323
  prefs: []
  type: TYPE_NORMAL
- en: Compile the contract with the Solidity compiler.
  id: totrans-1324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Push the contract’s *binary interface* (`abi`) and *bytecode* (`bin`) from the
    compiler to an output file.
  id: totrans-1325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run a Web3.js command that creates a *contract factory* of the contract from
    its binary interface.
  id: totrans-1326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run a Web3.js command that instantiates the contract by invoking the `new()`
    method of the contract factory and feeding it the bytecode.
  id: totrans-1327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 8.2\. The contract build and deployment process: 1\. the contract is
    compiled with the Solidity compiler; 2\. the contract binary interface and bytecode
    are pushed to an output file; and 3\. a JavaScript using Web3 is created. This
    does three things: a. creates a contract factory of the contract from its binary
    interface (ABI); b. instantiates the contract by invoking `new()` on the contract
    factory; and c. feeds the bytecode to it.'
  id: totrans-1328
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig08-02_alt.jpg)'
  id: totrans-1329
  prefs: []
  type: TYPE_IMG
- en: 8.1.2\. Deploying SimpleCoin through geth’s console
  id: totrans-1330
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s go through the steps from [figure 8.2](#ch08fig02) in detail by redeploying
    `SimpleCoin` to the test network. Following the build and deployment diagram,
    you must first compile the contract using solc.
  id: totrans-1331
  prefs: []
  type: TYPE_NORMAL
- en: Compiling a contract using solc
  id: totrans-1332
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'You can download the solc compiler from this GitHub page: [https://github.com/ethereum/solidity/releases](https://github.com/ethereum/solidity/releases).
    (I’ve downloaded solidity-windows.zip from the Version 0.4.24 section—please download
    an equivalent or later.) After downloading it, copy the executable into a folder;
    for example, C:\Ethereum\solidity-windows. (Feel free to name the folder after
    your OS.)'
  id: totrans-1333
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new folder for your `SimpleCoin` code: C:\Ethereum\SimpleCoin. Then
    create a new text file called SimpleCoin.sol and, for simplicity, paste in it
    one of the early versions of the contract code you wrote, like the one shown in
    the following listing.'
  id: totrans-1334
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.1\. SimpleCoin.sol, containing an early version of `SimpleCoin`
  id: totrans-1335
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE163]'
  id: totrans-1336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'Place this file in the `SimpleCoin` code folder you created. Then open a command-line
    shell and move to the `SimpleCoin` code folder. From there, invoke the compiler
    as follows:'
  id: totrans-1337
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  id: totrans-1338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[Table 8.1](#ch08table01) explains the compiler options you’ve used.'
  id: totrans-1339
  prefs: []
  type: TYPE_NORMAL
- en: Table 8.1\. The solc compiler options used to compile `SimpleCoin`
  id: totrans-1340
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Compiler option | Purpose |'
  id: totrans-1341
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-1342
  prefs: []
  type: TYPE_TB
- en: '| --bin | Produces the binary of the contract in hex format |'
  id: totrans-1343
  prefs: []
  type: TYPE_TB
- en: '| -o bin | Creates the binary output in the bin folder |'
  id: totrans-1344
  prefs: []
  type: TYPE_TB
- en: '| --combined-json abi,bin | Produces JSON output, including the ABI interface
    and the binary |'
  id: totrans-1345
  prefs: []
  type: TYPE_TB
- en: 'The JSON output shown here will be redirected to the bin\combined.json file:'
  id: totrans-1346
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  id: totrans-1347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'The JSON output includes two members:'
  id: totrans-1348
  prefs: []
  type: TYPE_NORMAL
- en: '`abi`—This is the contract application binary interface (ABI). It shows the
    API that your contract exposes and that client applications that interact with
    the contract should use.'
  id: totrans-1349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bin`—This is the contract bytecode in hex format. You’ll need the contract’s
    ABI and bytecode to deploy it.'
  id: totrans-1350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying a contract through the interactive console
  id: totrans-1351
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Open geth’s interactive console, which is pointing to TESTNET, and enter the
    code in [listing 8.2](#ch08ex02). (Please make sure you use the code from the
    [listing 8.2](#ch08ex02) file downloaded from the book website, as I’ve shortened
    it for brevity here.) You might have noticed that `simpleCoinAbi` has been assigned
    to the content of `abi` from combined.json, and `data` has been assigned to the
    content of `bin`, prefixed by `0x`.
  id: totrans-1352
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.2\. The geth interactive JavaScript instructions to deploy a contract
  id: totrans-1353
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE166]'
  id: totrans-1354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '***1*** **SimpleCoin constructor input**'
  id: totrans-1355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **Contract ABI, copied from the abi member of the SimpleCoin.out compilation
    output file**'
  id: totrans-1356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **Initializes contract factory with the contract ABI**'
  id: totrans-1357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***4*** **Instantiates the contract**'
  id: totrans-1358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***5*** **The contract bytecode, copied from the bin member of the SimpleCoin.out
    compilation output file**'
  id: totrans-1359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***6*** **Triggers registration of callback at completion of the deployment
    process**'
  id: totrans-1360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After executing these instructions, you’ll get the following error message:'
  id: totrans-1361
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  id: totrans-1362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: To deploy the contract, you have to unlock the account it’s being deployed through,
    `web3.eth.accounts[0]` (specified in the `from` property in [listing 8.2](#ch08ex02)).
    This will become the account owner.
  id: totrans-1363
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don’t remember what `accounts[0]` refers to, you can list on the interactive
    console the TESTNET accounts you created from the Ethereum wallet in the previous
    chapters. The first one in the results list is `accounts[0]`, and it’s named in
    the wallet as Main Account. This is what I got:'
  id: totrans-1364
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  id: totrans-1365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: 'Enter the following command to unlock the account:'
  id: totrans-1366
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  id: totrans-1367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '|  |'
  id: totrans-1368
  prefs: []
  type: TYPE_TB
- en: '**Secure account unlocking**'
  id: totrans-1369
  prefs: []
  type: TYPE_NORMAL
- en: 'The most secure way of unlocking an account is through a geth command in the
    operating system shell:'
  id: totrans-1370
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  id: totrans-1371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: This avoids potential security concerns due to the interactive console recording
    a history of all the operations that have taken place on it.
  id: totrans-1372
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-1373
  prefs: []
  type: TYPE_TB
- en: 'Try to re-execute the script in [listing 8.2](#ch08ex02). This time, you won’t
    get any error message. Wait for a few seconds, and the geth console will show
    a message similar to the following one:'
  id: totrans-1374
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  id: totrans-1375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: 'Well done! You’ve deployed `SimpleCoin` on TESTNET through the geth interactive
    console. You can now examine the content of `simpleCoinInstance`:'
  id: totrans-1376
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  id: totrans-1377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'An important property of the `simpleCoinInstance` object, which you’ll reference
    later, is its blockchain address:'
  id: totrans-1378
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  id: totrans-1379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: For now, let’s start interacting with `SimpleCoin` through `simpleCoinInstance`.
  id: totrans-1380
  prefs: []
  type: TYPE_NORMAL
- en: 8.2\. Interacting with SimpleCoin through geth’s console
  id: totrans-1381
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once you’ve deployed `SimpleCoin` on TESTNET, you can perform the same operations
    you did manually through the wallet in [chapter 4](kindle_split_015.xhtml#ch04),
    [section 4.2](kindle_split_015.xhtml#ch04lev1sec2), but this time through the
    console.
  id: totrans-1382
  prefs: []
  type: TYPE_NORMAL
- en: 8.2.1\. Checking coin balances
  id: totrans-1383
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First of all, check the balance of `accounts[0]` (or Main Account), which you
    used to deploy the contract, using the `coinBalance` getter property, as seen
    in the previous sections:'
  id: totrans-1384
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  id: totrans-1385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: Then check the balance of all the other accounts in the same way. You’ll get,
    as expected, the balances shown in [table 8.2](#ch08table02).
  id: totrans-1386
  prefs: []
  type: TYPE_NORMAL
- en: Table 8.2\. Expected account balances
  id: totrans-1387
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Account address | Account balance |'
  id: totrans-1388
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-1389
  prefs: []
  type: TYPE_TB
- en: '| 0xedDE06bC0e45645e2f105972BDefC220ED37Ae10 | 10,000 |'
  id: totrans-1390
  prefs: []
  type: TYPE_TB
- en: '| 0x4e6C30154768b6bc3Da693b1B28C6bd14302b578 | 0 |'
  id: totrans-1391
  prefs: []
  type: TYPE_TB
- en: '| 0x70e36bE8AB8f6Cf66C0C953cF9c63aB63f3FeF02 | 0 |'
  id: totrans-1392
  prefs: []
  type: TYPE_TB
- en: '| 0xc99048E9B98D3FcF8b5f0D5644794B562f9A2ea4 | 0 |'
  id: totrans-1393
  prefs: []
  type: TYPE_TB
- en: 'Try to check, as you did in the wallet, the balance of an invalid address,
    again obtained by modifying the last digit of the Main Account address:'
  id: totrans-1394
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  id: totrans-1395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: In this case, you won’t get the validation error that the wallet returned—it
    doesn’t allow you to enter invalid addresses—you’ll get a zero balance. This is
    because the `coin-Balance()` getter doesn’t perform any validation on the input
    address. (The wallet performs that validation instead.) It returns a valid balance
    for valid addresses contained in the `coinBalance` mapping, and the default `int256`
    value (`0`) for anything else.
  id: totrans-1396
  prefs: []
  type: TYPE_NORMAL
- en: 8.2.2\. Transferring coins
  id: totrans-1397
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The next operation you’ll perform is a coin transfer. Try moving 150 coins
    from the Main Account to `accounts[2]` through `SimpleCoin`’s `transfer()` function.
    To execute this, you also have to specify the maximum gas amount allowed for the
    operation:'
  id: totrans-1398
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  id: totrans-1399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: 'When you attempt this operation, you’ll get the following message:'
  id: totrans-1400
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  id: totrans-1401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: 'You must unlock the Main Account to digitally sign the transaction, as you
    did earlier (replace, as usual, your `accounts[0]` password):'
  id: totrans-1402
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  id: totrans-1403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '|  |'
  id: totrans-1404
  prefs: []
  type: TYPE_TB
- en: Warning
  id: totrans-1405
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Although I’m showing you how to unlock an account through the geth console,
    this isn’t entirely safe because the password is in clear text (it’s not encrypted)
    and each operation is logged in the console history. See the “Secure account unlocking”
    sidebar earlier in this chapter for more information.
  id: totrans-1406
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-1407
  prefs: []
  type: TYPE_TB
- en: When you retry the transfer, the transaction will be successful, and you’ll
    get the transaction hash. In my case, I got
  id: totrans-1408
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  id: totrans-1409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: Recheck the balances of all of your accounts. You’ll get, as expected, the balances
    shown in [table 8.3](#ch08table03).
  id: totrans-1410
  prefs: []
  type: TYPE_NORMAL
- en: Table 8.3\. Expected new account balances
  id: totrans-1411
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Account address | Account balance |'
  id: totrans-1412
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-1413
  prefs: []
  type: TYPE_TB
- en: '| 0xedDE06bC0e45645e2f105972BDefC220ED37Ae10 | 9,850 |'
  id: totrans-1414
  prefs: []
  type: TYPE_TB
- en: '| 0x4e6C30154768b6bc3Da693b1B28C6bd14302b578 | 0 |'
  id: totrans-1415
  prefs: []
  type: TYPE_TB
- en: '| 0x70e36bE8AB8f6Cf66C0C953cF9c63aB63f3FeF02 | 150 |'
  id: totrans-1416
  prefs: []
  type: TYPE_TB
- en: '| 0xc99048E9B98D3FcF8b5f0D5644794B562f9A2ea4 | 0 |'
  id: totrans-1417
  prefs: []
  type: TYPE_TB
- en: 'Now move 50 coins from `accounts[2]` to `accounts[1]` after unlocking `accounts[2]`:'
  id: totrans-1418
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  id: totrans-1419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: After getting the transaction hash, you can recheck the balances. You’ll get
    the balances shown in [table 8.4](#ch08table04).
  id: totrans-1420
  prefs: []
  type: TYPE_NORMAL
- en: Table 8.4\. Expected account balances
  id: totrans-1421
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Account address | Account balance |'
  id: totrans-1422
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-1423
  prefs: []
  type: TYPE_TB
- en: '| 0xedDE06bC0e45645e 2f105972BDefC220ED37Ae10 | 9,850 |'
  id: totrans-1424
  prefs: []
  type: TYPE_TB
- en: '| 0x4e6C30154768b6bc3Da693b1B28C6bd14302b578 | 50 |'
  id: totrans-1425
  prefs: []
  type: TYPE_TB
- en: '| 0x70e36bE8AB8f6Cf66C0C953cF9c63aB63f3FeF02 | 100 |'
  id: totrans-1426
  prefs: []
  type: TYPE_TB
- en: '| 0xc99048E9B98D3FcF8b5f0D5644794B562f9A2ea4 | 0 |'
  id: totrans-1427
  prefs: []
  type: TYPE_TB
- en: Before we close this section, you’ll learn how to reference a contract that
    has already been deployed, such as `SimpleCoin`. First you’ll close the geth console
    and reattach it.
  id: totrans-1428
  prefs: []
  type: TYPE_NORMAL
- en: 8.2.3\. Referencing a running contract
  id: totrans-1429
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Close the interactive geth console and reattach it from the operating system
    command-line shell:'
  id: totrans-1430
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  id: totrans-1431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: 'As you’ll remember from the end of [section 8.1.2](#ch08lev2sec2), when you
    deployed `SimpleCoin` on TESTNET from the geth console, the console returned the
    contract address:'
  id: totrans-1432
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  id: totrans-1433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: 'If you now want to interact with that deployed instance of `SimpleCoin` from
    the geth console, you must create a proxy to contract from its ABI and connect
    to the remote instance by feeding the address of the deployed contract to the
    `at()` method:'
  id: totrans-1434
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  id: totrans-1435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '***1*** **The abi interface from solc SimpleCoin output**'
  id: totrans-1436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **Creates a proxy to the SimpleCoin contract**'
  id: totrans-1437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **Connects to the instance of SimpleCoin deployed earlier**'
  id: totrans-1438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting to a deployed contract from another contract is slightly different
    and is explained in the sidebar.
  id: totrans-1439
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-1440
  prefs: []
  type: TYPE_TB
- en: '**Referencing a deployed contract from another contract**'
  id: totrans-1441
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re focusing on the interaction between a Web3.js client
    (such as the geth console or, as you’ll see later, the Node.js console or an HTML
    + JS web page) and a deployed Solidity contract. If you want to interact with
    a deployed Solidity contract from another Solidity contract, you’ll use a technique
    similar to the one you saw in the previous chapter for connecting to a deployed
    library from a contract:'
  id: totrans-1442
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  id: totrans-1443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: In this case, you define a local proxy contract as an abstract contract mirroring
    the public interface of the remote contract. Then you instantiate the proxy by
    feeding the address of the deployed remote contract to its constructor.
  id: totrans-1444
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-1445
  prefs: []
  type: TYPE_TB
- en: 'To double-check that you’re truly connected to the previously deployed `SimpleCoin`
    instance, recheck the value of the `coinBalance` property against all accounts,
    starting from:'
  id: totrans-1446
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  id: totrans-1447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: You’ll get the balances shown in [table 8.5](#ch08table05).
  id: totrans-1448
  prefs: []
  type: TYPE_NORMAL
- en: Table 8.5\. Expected account balances
  id: totrans-1449
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Account address | Account balance |'
  id: totrans-1450
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-1451
  prefs: []
  type: TYPE_TB
- en: '| 0xedDE06bC0e45645e2f105972BDefC220ED37Ae10 | 9,850 |'
  id: totrans-1452
  prefs: []
  type: TYPE_TB
- en: '| 0x4e6C30154768b6bc3Da693b1B28C6bd14302b578 | 50 |'
  id: totrans-1453
  prefs: []
  type: TYPE_TB
- en: '| 0x70e36bE8AB8f6Cf66C0C953cF9c63aB63f3FeF02 | 100 |'
  id: totrans-1454
  prefs: []
  type: TYPE_TB
- en: '| 0xc99048E9B98D3FcF8b5f0D5644794B562f9A2ea4 | 0 |'
  id: totrans-1455
  prefs: []
  type: TYPE_TB
- en: At this point, you can perform a new transfer operation; for example, move some
    coins from `accounts[2]` to `accounts[3]`. I leave it to you as an exercise.
  id: totrans-1456
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ve learned how to deploy a contract on TESTNET from geth’s
    interactive console. Deploying on MAINNET, the production Ethereum network, is
    identical to deploying on TESTNET, except for needing real Ether to run transactions
    (to fund the gas consumed) on MAINNET.
  id: totrans-1457
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have found command-based deployment through geth’s console inefficient
    and manually intensive: you had to compile the contract separately with the solc
    compiler, copy the ABI and bytecode manually from the compiler’s output, and paste
    them into some Web3 instructions. It’s possible to simplify deployment if you’re
    willing to change the toolset and start using Node.js instead of the geth interactive
    console. This is what we’ll explore in the next section.'
  id: totrans-1458
  prefs: []
  type: TYPE_NORMAL
- en: 8.3\. Simplifying command-based deployment with Node.js
  id: totrans-1459
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Node.js is a cross-platform runtime for developing server-side applications
    in Java-Script. If you’re not familiar with Node.js, the sidebar tells a little
    more about it. You might be wondering why Node.js is relevant for Ethereum development.
    It’s relevant because it can serve as an enhanced geth console that you can use
    to connect to the geth client and import many packages that will help improve
    and simplify your development efforts.
  id: totrans-1460
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-1461
  prefs: []
  type: TYPE_TB
- en: '**Node.js**'
  id: totrans-1462
  prefs: []
  type: TYPE_NORMAL
- en: Node.js is a server-side runtime environment for JavaScript. It’s based on an
    event-driven architecture capable of handling asynchronous I/O. It includes a
    set of standard modules that are libraries of functions for networking (including
    TCP/IP, HTTP), binary data, file system I/O operations, data streams, and many
    others. You can create and distribute custom modules through the node package
    manager, also known as *npm*.
  id: totrans-1463
  prefs: []
  type: TYPE_NORMAL
- en: The platform has two main objectives. The first is to allow JavaScript developers
    to write server-side applications using their favorite language. The second is
    to provide a server-side web scripting environment with increased scalability
    through asynchronous programming rather than explicit multithreading.
  id: totrans-1464
  prefs: []
  type: TYPE_NORMAL
- en: You can download Node.js from [https://nodejs.org/](https://nodejs.org/).
  id: totrans-1465
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-1466
  prefs: []
  type: TYPE_TB
- en: If you haven’t already, I recommend you install the latest version of Node.js,
    if you can, or at least version 8.0 or higher. Once you’ve installed Node.js,
    it’s a good idea to install the Web3 module through the node package manager (npm),
    so you can reference it from any JavaScript code you run on Node.js.
  id: totrans-1467
  prefs: []
  type: TYPE_NORMAL
- en: 8.3.1\. Installing Web3 and solc on Node.js
  id: totrans-1468
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before installing Web3, create a new folder, and initialize it for npm as follows:'
  id: totrans-1469
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  id: totrans-1470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: 'You’ll be asked to set up various properties of the package.json file that
    the initialization command (`npm init`) is going to create. Set the name as simple_coin
    and the version as 1.0.0 and leave all the other fields blank:'
  id: totrans-1471
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  id: totrans-1472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: 'When asked to confirm whether the file being created is correct, type yes and
    press Enter:'
  id: totrans-1473
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  id: totrans-1474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: 'Then you can install Web3 (version 0.20.4, as I have done), as follows:'
  id: totrans-1475
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  id: totrans-1476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: 'You’ll get output like this:'
  id: totrans-1477
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  id: totrans-1478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: 'To test that Web3 is working as expected, you can try to retrieve a list of
    your TESTNET accounts through the Node.js console. Before doing so, you must have
    a geth instance running. You have to open a separate OS console, start geth on
    TESTNET, and expose RPC and various RPC interfaces:'
  id: totrans-1479
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  id: totrans-1480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: Remember to also use the `–-bootnodes` option from earlier if the geth console
    seems stale.
  id: totrans-1481
  prefs: []
  type: TYPE_NORMAL
- en: 'Now go back to the console you used to install the Web3 node package and start
    the interactive node console, as follows:'
  id: totrans-1482
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  id: totrans-1483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: 'You’ll see a node console prompt:'
  id: totrans-1484
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  id: totrans-1485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: 'Then you can retrieve your TESTNET account addresses, as follows:'
  id: totrans-1486
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  id: totrans-1487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: 'You’ll get output like:'
  id: totrans-1488
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  id: totrans-1489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: 'This confirms that Web3 is working as expected. Get out of the node console
    as follows (note the dot before `exit`):'
  id: totrans-1490
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  id: totrans-1491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: 'You should see the OS prompt:'
  id: totrans-1492
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  id: totrans-1493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: 'Then you can install the Solidity compiler solc (version 0.4.24, as I have
    done):'
  id: totrans-1494
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  id: totrans-1495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: Now you’re ready to create a deployment script to simplify the build and deployment
    process.
  id: totrans-1496
  prefs: []
  type: TYPE_NORMAL
- en: 8.3.2\. Building and deploying interactively through the Node.js console
  id: totrans-1497
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The best way to create a build and deployment script is to try to compile and
    deploy a contract interactively on the Node.js shell and then place the sequence
    of commands you’ve proved to work in a file. You can later execute this file as
    a single task.
  id: totrans-1498
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, place SimpleCoin’s code from [listing 8.1](#ch08ex01) in the
    following file:'
  id: totrans-1499
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  id: totrans-1500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: 'Now start the node console:'
  id: totrans-1501
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  id: totrans-1502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: 'Then you can reference the node JavaScript packages you’ll be using, as follows:'
  id: totrans-1503
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  id: totrans-1504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: '***1*** **File system package**'
  id: totrans-1505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **Solidity compiler package**'
  id: totrans-1506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **Web3 package**'
  id: totrans-1507
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following command creates an instance of the web3 object:'
  id: totrans-1508
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  id: totrans-1509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: 'Set the initial SimpleCoin supply that will be fed to the `SimpleCoin` constructor:'
  id: totrans-1510
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  id: totrans-1511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: 'Then you can set `account2` as the sender of the deployment transaction:'
  id: totrans-1512
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  id: totrans-1513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: 'Load the source code of `SimpleCoin` and assign it to the `source` variable:'
  id: totrans-1514
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  id: totrans-1515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: 'Then you can compile the contract and assign it to `compiledContract`:'
  id: totrans-1516
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  id: totrans-1517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: 'Extract the ABI and bytecode from the compiled contract and assign them to
    two new variables (note that you must place `''0x''` before the bytecode):'
  id: totrans-1518
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  id: totrans-1519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: 'Assign the gas estimate to a variable after having increased it, so you make
    sure the transaction runs to completion:'
  id: totrans-1520
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  id: totrans-1521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: 'Now you can create a contract factory (or generator) initialized with `SimpleCoin`’s
    ABI:'
  id: totrans-1522
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  id: totrans-1523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: 'Before deploying the contract, unlock the account that will sign and send the
    deployment transaction:'
  id: totrans-1524
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  id: totrans-1525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: 'You’re now ready to deploy the contract and instantiate it in a single operation
    with the `new()` function, which also takes two callbacks: one called after successful
    deployment, the other one in case of errors:'
  id: totrans-1526
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]'
  id: totrans-1527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: 'In the meantime, observe the geth console (not the Node.js console!). You should
    see output similar to this:'
  id: totrans-1528
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  id: totrans-1529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: 'Then, after a few seconds, in the Node.js console you should see something
    like this:'
  id: totrans-1530
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  id: totrans-1531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: Well done! Now that you’ve managed to deploy the `SimpleCoin` contract through
    the node console, you can automate all the steps you performed interactively.
  id: totrans-1532
  prefs: []
  type: TYPE_NORMAL
- en: 8.3.3\. Creating a build and deployment script
  id: totrans-1533
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Copy all the commands you entered previously, collected in [listing 8.3](#ch08ex03),
    into the following file:'
  id: totrans-1534
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE214]'
  id: totrans-1535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: (Make sure you replace the password of your account 2 in the `senderPassword`
    assignment.)
  id: totrans-1536
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.3\. `SimpleCoin` Node.js deployment script
  id: totrans-1537
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE215]'
  id: totrans-1538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: 'Now you can redeploy (and reinstantiate) `SimpleCoin` by running the script
    you’ve created from the OS command shell, as follows:'
  id: totrans-1539
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  id: totrans-1540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: 'You should see the same output as before on both the geth and Node.js consoles:'
  id: totrans-1541
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  id: totrans-1542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: You can adapt this script easily to compile other contracts, or multiple contracts,
    as required.
  id: totrans-1543
  prefs: []
  type: TYPE_NORMAL
- en: 8.3.4\. Interacting with a contract from Node.js
  id: totrans-1544
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Once you’ve deployed the contract, you can interact with it through `simpleCoin-Instance`.
    For example, you can move some tokens from one account to another. Try to do this
    first interactively, so you can produce a script, as you did earlier.
  id: totrans-1545
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, reference the necessary JavaScript packages, as you did earlier:'
  id: totrans-1546
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE218]'
  id: totrans-1547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: 'Then also create a contract factory, as you did earlier:'
  id: totrans-1548
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE219]'
  id: totrans-1549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: 'Now assign the address of the `SimpleCoin` instance that you deployed interactively
    to an address variable:'
  id: totrans-1550
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE220]'
  id: totrans-1551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: 'Then you can connect to that SimpleCoin instance with the `at()` function:'
  id: totrans-1552
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE221]'
  id: totrans-1553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: 'Now assign `accounts[1]` and `accounts[2]` to two variables:'
  id: totrans-1554
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE222]'
  id: totrans-1555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: 'Then do the same for the related balances:'
  id: totrans-1556
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE223]'
  id: totrans-1557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: 'You can display these balances as follows:'
  id: totrans-1558
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE224]'
  id: totrans-1559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: 'Finally, unlock `account2` so you can sign and execute the transfer transaction
    from it:'
  id: totrans-1560
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE225]'
  id: totrans-1561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: 'Then you can execute the transfer transaction and assign its hash to a variable:'
  id: totrans-1562
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE226]'
  id: totrans-1563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: 'Poll the status of the transaction until completion as follows:'
  id: totrans-1564
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE227]'
  id: totrans-1565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: 'Then display information on the completed transaction:'
  id: totrans-1566
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE228]'
  id: totrans-1567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: 'You can now update the values of the account balance variables:'
  id: totrans-1568
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE229]'
  id: totrans-1569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: 'Finally, you can display the new balances after the transfer:'
  id: totrans-1570
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE230]'
  id: totrans-1571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: Having proven that the commands you’ve entered work correctly, you can move
    them into a file called transferTokens.js. The code appears in the following listing.
  id: totrans-1572
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.4\. transferTokens.js script, which transfers coins between two accounts
  id: totrans-1573
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE231]'
  id: totrans-1574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: 'Run it as follows:'
  id: totrans-1575
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE232]'
  id: totrans-1576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: Before I close the topic of deployment, in the next section you’ll learn how
    to deploy a contract on a private network. A private network is an Ethereum environment
    completely under your control.
  id: totrans-1577
  prefs: []
  type: TYPE_NORMAL
- en: 8.4\. Deploying on a private network
  id: totrans-1578
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A private network can be useful if, during development, you don’t want to deal
    with the delays involved in working with a public test network. For example, on
    the public test network, you generally have to wait a number of
  id: totrans-1579
  prefs: []
  type: TYPE_NORMAL
- en: minutes to mine Ether through CPU mining
  id: totrans-1580
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: minutes to resynchronize to the network, if you’ve disconnected and then reconnected
    after a few hours or days
  id: totrans-1581
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: seconds for contract deployment or transactions confirmation
  id: totrans-1582
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Occasionally, when you reconnect after a few days, TESTNET doesn’t sync correctly
    due to major development or a fork that has happened in the meantime. In that
    case, you have to restart from scratch by deleting the whole blockchain stored
    on your node.
  id: totrans-1583
  prefs: []
  type: TYPE_NORMAL
- en: Another benefit of running against a private network is that you can efficiently
    test contracts whose logic depends on time-based expiration. Because contracts
    are isolated from external services, such as external clocks, you’ll commonly
    emulate time with a number of blocks, under the assumption that it takes around
    14 seconds to generate a new block.
  id: totrans-1584
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a private network means starting up a custom blockchain, disconnected
    from the official Ethereum TESTNET or MAINNET blockchains. Before doing so, you
    should learn how geth manages the blockchain—how it records its history and what
    happens during synchronization.
  id: totrans-1585
  prefs: []
  type: TYPE_NORMAL
- en: 8.4.1\. How geth accesses the blockchain
  id: totrans-1586
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you start it up, geth looks at your Ethereum data folder before connecting
    to the network. As you know from [chapter 3](kindle_split_014.xhtml#ch03), when
    I presented the keystore, the Ethereum data folder is located in one of the following
    directories:'
  id: totrans-1587
  prefs: []
  type: TYPE_NORMAL
- en: 'Windows: C:\Users\username\%appdata%\Roaming\Ethereum\'
  id: totrans-1588
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Linux: ~/.ethereum/'
  id: totrans-1589
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Mac: ~/Library/Ethereum/'
  id: totrans-1590
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This folder contains the following folders:'
  id: totrans-1591
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE233]'
  id: totrans-1592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: '***1*** **The geth data folder for public production network**'
  id: totrans-1593
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **The keystore folder for public production network**'
  id: totrans-1594
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **Folder for the Ropsten public test network**'
  id: totrans-1595
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***4*** **Each test folder contains a geth data folder and a keystore folder.**'
  id: totrans-1596
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***6*** **Folder for the Rinkeby public test network**'
  id: totrans-1597
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You already examined the content of the keystore back in [chapter 3](kindle_split_014.xhtml#ch03).
    Let’s have a look at the content of each geth folder:'
  id: totrans-1598
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE234]'
  id: totrans-1599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: '***1*** **The chaindata folder contains the blockchain data files.**'
  id: totrans-1600
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **The ethash folder contains data structure files necessary for mining.**'
  id: totrans-1601
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **The nodes folder contains data about discovered network nodes.**'
  id: totrans-1602
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-1603
  prefs: []
  type: TYPE_TB
- en: Note
  id: totrans-1604
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As for the keystore, each geth folder is specific to a single network, so ethereum/geth
    and ethereum/testnet/geth contain completely different data. As a result, if you
    want to back up the blockchain and keystore for a specific environment, you need
    to take a copy of only the relevant geth and keystore folders.
  id: totrans-1605
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-1606
  prefs: []
  type: TYPE_TB
- en: 8.4.2\. Setting up a private test network
  id: totrans-1607
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that you’ve learned where the public (test or main) blockchain is stored
    on your geth node, you’ll be able to understand more easily the steps needed to
    set up a test network. We’ll go through each of these steps in detail:'
  id: totrans-1608
  prefs: []
  type: TYPE_NORMAL
- en: Create a custom genesis file.
  id: totrans-1609
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a custom blockchain data folder.
  id: totrans-1610
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose a name to identify your node.
  id: totrans-1611
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Launch geth with a custom configuration to generate the genesis block.
  id: totrans-1612
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Launch geth with a custom configuration to run a private network node.
  id: totrans-1613
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the Etherbase account.
  id: totrans-1614
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start mining to get Ether on the Etherbase account.
  id: totrans-1615
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating a custom genesis file
  id: totrans-1616
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A blockchain starts from a master or *genesis* block that has no parent and
    seeds the chain. All nodes in your private network will have to reference the
    same genesis block to agree with each other.
  id: totrans-1617
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new folder—for example, called C:\privatenetdev—and create within
    it a file called genesis.json. Then paste into it the following content:'
  id: totrans-1618
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE235]'
  id: totrans-1619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: '***1*** **Parameters to configure a specific Ethereum protocol version (Homestead,
    for example)**'
  id: totrans-1620
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **Identifier of the network being created**'
  id: totrans-1621
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **Protocol-specific parameters**'
  id: totrans-1622
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***4*** **Difficulty: how easy it is for a miner to find a valid nonce; the
    lower, the easier**'
  id: totrans-1623
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***5*** **Maximum gas limit allowed; the lower the limit, the more likely transactions
    can fail**'
  id: totrans-1624
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***6*** **You can preallocate Ether to specific addresses in this section.**'
  id: totrans-1625
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The most important settings are explained in [table 8.6](#ch08table06).
  id: totrans-1626
  prefs: []
  type: TYPE_NORMAL
- en: Table 8.6\. Genesis file settings
  id: totrans-1627
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Setting | Description |'
  id: totrans-1628
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-1629
  prefs: []
  type: TYPE_TB
- en: '| chainId | After you create this identifier, you can connect to the private
    network through it. |'
  id: totrans-1630
  prefs: []
  type: TYPE_TB
- en: '| difficulty | A higher value increases the number of attempts a mining node
    needs to perform before finding a valid nonce so it can add a new block to the
    blockchain. To give you an idea, a value of 4000, for example, makes mining easy
    because it allows any miner to generate a new block roughly every five seconds.
    You’d have to increment the difficulty value exponentially if you wanted a node
    to be able to generate a new block only every few minutes or hours. |'
  id: totrans-1631
  prefs: []
  type: TYPE_TB
- en: '| gasLimit | This is the maximum limit allowed for a transaction, regardless
    of the limit set on the transaction itself. The higher it is, the less likely
    it is that transactions will fail with the following error: “Error: exceeds block
    gas limit.” |'
  id: totrans-1632
  prefs: []
  type: TYPE_TB
- en: Creating a custom blockchain data folder
  id: totrans-1633
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Create a folder in a different area with respect to the standard Ethereum data.
    An example would be C:\privatenet.
  id: totrans-1634
  prefs: []
  type: TYPE_NORMAL
- en: Choosing a name for the test node
  id: totrans-1635
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Assigning a name to the first node of your private network makes it easy to
    identify if you decide to add more nodes later on. For this example, try `PrivateNetMaster`.
  id: totrans-1636
  prefs: []
  type: TYPE_NORMAL
- en: Launching geth with custom configuration to generate the genesis block
  id: totrans-1637
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: So far, you’ve always started geth with the default configuration. At most,
    you’ve specified whether to start it against testnet, with the `--testnet` option,
    or in console mode, by specifying the `console` or `attach` command.
  id: totrans-1638
  prefs: []
  type: TYPE_NORMAL
- en: 'To generate the custom genesis block of your private network, launch geth with
    the `init` command, as follows:'
  id: totrans-1639
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE236]'
  id: totrans-1640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: '[Table 8.7](#ch08table07) describes every option this geth launch command used.
    After launching geth, you should see output similar to that in the screenshot
    in [figure 8.3](#ch08fig03).'
  id: totrans-1641
  prefs: []
  type: TYPE_NORMAL
- en: Table 8.7\. The options used to start geth against a private network
  id: totrans-1642
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| geth option | Description |'
  id: totrans-1643
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-1644
  prefs: []
  type: TYPE_TB
- en: '| --networkid | This identifies a specific Ethereum network. For example, TESTNET
    and MAINNET have their own networkid (default: 1, which is MAINNET). |'
  id: totrans-1645
  prefs: []
  type: TYPE_TB
- en: '| --identity | This is useful to identify a specific node of the private network.
    |'
  id: totrans-1646
  prefs: []
  type: TYPE_TB
- en: '| --rpc | This enables the JSON-RPC interface on the node (default: enabled).
    |'
  id: totrans-1647
  prefs: []
  type: TYPE_TB
- en: '| --rpcapi | You enable the API over RPC (default: web3). |'
  id: totrans-1648
  prefs: []
  type: TYPE_TB
- en: '| --datadir | The blockchain data folder |'
  id: totrans-1649
  prefs: []
  type: TYPE_TB
- en: '| --port | The network listening port other peers of the same network use to
    connect to this node |'
  id: totrans-1650
  prefs: []
  type: TYPE_TB
- en: '| --nodiscover | This disables discovery of the node by clients that are pointing
    to the same networkid and are referencing the same genesis block. You must add
    other nodes to this network manually. |'
  id: totrans-1651
  prefs: []
  type: TYPE_TB
- en: '| --maxpeers | The maximum number of peers allowed from this node. By setting
    it to zero, you explicitly state you’ll have only one node. If you need to add
    more network nodes, you must change this setting later. |'
  id: totrans-1652
  prefs: []
  type: TYPE_TB
- en: Figure 8.3\. The output from geth after generating the genesis block of your
    private network
  id: totrans-1653
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig08-03_alt.jpg)'
  id: totrans-1654
  prefs: []
  type: TYPE_IMG
- en: Launching geth with custom configuration to run a private network node
  id: totrans-1655
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Now that you’ve generated the genesis block, you can launch geth using the
    same parameters as before, except from the `init` command:'
  id: totrans-1656
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE237]'
  id: totrans-1657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: '|  |'
  id: totrans-1658
  prefs: []
  type: TYPE_TB
- en: Tip
  id: totrans-1659
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You might have to close down any running geth instances pointing to MAINNET
    or TESTNET and/or any running wallet instance, depending on how you’ve configured
    port numbers.
  id: totrans-1660
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-1661
  prefs: []
  type: TYPE_TB
- en: If geth starts successfully, you should see a screen similar to the screenshot
    in [figure 8.4](#ch08fig04). You’ll notice the screen doesn’t show any progress—no
    blocks are being generated. I’m sure you know why. It’s because yours is the only
    node of the private network, and it’s not mining!
  id: totrans-1662
  prefs: []
  type: TYPE_NORMAL
- en: You don’t have any new accounts yet on your brand new blockchain. Before starting
    mining, you must create at least the Etherbase (or coinbase) account.
  id: totrans-1663
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.4\. The output from geth after launching it against the private network
    you’ve created
  id: totrans-1664
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig08-04_alt.jpg)'
  id: totrans-1665
  prefs: []
  type: TYPE_IMG
- en: Creating the Etherbase account
  id: totrans-1666
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Attach to the private network node by opening a new command-line console and
    then launching geth attach as usual. When the geth console opens, it will display
    the name and data directory of your private network, respectively, in the `instance`
    and `datadir` output, which confirms you’re attached to the private network node:'
  id: totrans-1667
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE238]'
  id: totrans-1668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: 'You can now create an account as you saw in [chapter 3](kindle_split_014.xhtml#ch03),
    [section 3.4.3](kindle_split_014.xhtml#ch03lev2sec15) (entering your own password
    in place of the text “PASSWORD OF ETHERBASE ACCOUNT”):'
  id: totrans-1669
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE239]'
  id: totrans-1670
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: 'You can set this account as an Etherbase account with the `setEtherbase` method
    of the `miner` object. Pass the address of the account you’ve created as an input:'
  id: totrans-1671
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE240]'
  id: totrans-1672
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: 'Before starting to mine, you can create additional accounts. For the moment,
    create one more account. You’ll use it to interact with `SimpleCoin` on the private
    network (also here entering your own password instead of the text “PASSWORD OF
    ACCOUNT 2”):'
  id: totrans-1673
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE241]'
  id: totrans-1674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: Start mining to get Ether on the Etherbase account
  id: totrans-1675
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'You can now start mining as you saw in the CPU mining section of [chapter 3](kindle_split_014.xhtml#ch03):'
  id: totrans-1676
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE242]'
  id: totrans-1677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: Let the miner run for a few seconds and check the output from the main geth
    shell. You’ll see the DAG gets generated (see [chapter 3](kindle_split_014.xhtml#ch03),
    [section 3.3.4](kindle_split_014.xhtml#ch03lev2sec11) to refresh your memory on
    the DAG, if needed), as shown in the screenshot in [figure 8.5](#ch08fig05).
  id: totrans-1678
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.5\. As soon as you launch mining for the first time, the DAG gets generated.
  id: totrans-1679
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig08-05_alt.jpg)'
  id: totrans-1680
  prefs: []
  type: TYPE_IMG
- en: 'If you check the balance of the Etherbase account in the interactive shell,
    it will still be zero:'
  id: totrans-1681
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE243]'
  id: totrans-1682
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: After a few seconds you should see the first blocks being mined in the main
    geth shell, as shown in the screenshot in [figure 8.6](#ch08fig06).
  id: totrans-1683
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-1684
  prefs: []
  type: TYPE_TB
- en: Note
  id: totrans-1685
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You might wonder where these initial blocks are coming from, as you haven’t
    submitted any transactions yet. A miner will always try to create a block even
    if no transaction is available in its memory pool. Creating an empty block is
    perfectly legal and can happen in periods of low transaction activity. As you
    know, though, a miner is encouraged to include in a block as many transactions
    as possible through the collection of transaction fees, so empty blocks are rare
    in practice and tend to appear mainly in private networks.
  id: totrans-1686
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-1687
  prefs: []
  type: TYPE_TB
- en: Figure 8.6\. After the DAG has been generated and the first blocks get created
  id: totrans-1688
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig08-06_alt.jpg)'
  id: totrans-1689
  prefs: []
  type: TYPE_IMG
- en: The Etherbase balance will now show Ether (expressed in Wei)
  id: totrans-1690
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE244]'
  id: totrans-1691
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: 'and you can stop the mining, if you want:'
  id: totrans-1692
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE245]'
  id: totrans-1693
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: You’ve created your local private network. Now you can try to deploy `SimpleCoin`
    on it.
  id: totrans-1694
  prefs: []
  type: TYPE_NORMAL
- en: 8.4.3\. Deploying SimpleCoin on the private network
  id: totrans-1695
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Working on a private network is identical to working on a public network, so
    you should be able to deploy the contract by yourself. But you should check to
    make sure everything goes as expected. [Table 8.8](#ch08table08) shows the accounts
    you have in the private network.
  id: totrans-1696
  prefs: []
  type: TYPE_NORMAL
- en: Table 8.8\. Accounts in the private network
  id: totrans-1697
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Account | Address |'
  id: totrans-1698
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-1699
  prefs: []
  type: TYPE_TB
- en: '| Main account | 0x3f9e54337cce348607b76200fc19f3f6e3e8e358 |'
  id: totrans-1700
  prefs: []
  type: TYPE_TB
- en: '| Account 2 | 0x336a008e3a3b099bcd125cd54fc193070fe1d177 |'
  id: totrans-1701
  prefs: []
  type: TYPE_TB
- en: 'Make sure account 2 has some Ether, so you can deploy from it. You can get
    some from the Main account, which has acquired Ether through mining:'
  id: totrans-1702
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE246]'
  id: totrans-1703
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: 'You can now deploy from account 2 by running the script you created in [section
    8.3.3](#ch08lev2sec8) from the OS command shell, as follows:'
  id: totrans-1704
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE247]'
  id: totrans-1705
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: 'Although you don’t get any error messages, something seems to have gone wrong:
    the contract address appears as undefined. Remember, when you deployed on TESTNET,
    after a few seconds you got this output:'
  id: totrans-1706
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE248]'
  id: totrans-1707
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: But now you haven’t received confirmation of the contract address. If you check
    on the output of the main geth shell, you’ll see the screen hanging on
  id: totrans-1708
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE249]'
  id: totrans-1709
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: 'Think about what might be causing this problem. Yes, you’re right: no mining
    is taking place! To complete the deployment transaction, this needs to get mined.'
  id: totrans-1710
  prefs: []
  type: TYPE_NORMAL
- en: 'Go back to the geth interactive console and restart mining:'
  id: totrans-1711
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE250]'
  id: totrans-1712
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: '(Remember, earlier you stopped mining through `miner.stop().`) The expected
    completion message will appear immediately:'
  id: totrans-1713
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE251]'
  id: totrans-1714
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: 'If you now inspect `simpleCoinInstance`, it contains the contract address:'
  id: totrans-1715
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE252]'
  id: totrans-1716
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: Now that you’ve deployed the contract, if you want to save on electricity and
    keep your CPU cool, you can stop mining. Remember, though, that to interact with
    the contract, mining must be on; otherwise, transactions will never complete.
  id: totrans-1717
  prefs: []
  type: TYPE_NORMAL
- en: As an exercise, try to move some SimpleCoins from the Main Account to Account
    `2` while no mining is taking place, then check the coin balance of your two accounts.
    You’ll prove that the transaction will get completed only when you switch mining
    back on.
  id: totrans-1718
  prefs: []
  type: TYPE_NORMAL
- en: 8.5\. Making development more efficient by deploying on mock networks
  id: totrans-1719
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although running a contract on a private network makes development relatively
    faster, especially if you configure the mining difficulty level appropriately,
    you still need to manage the private network correctly. For example, accounts
    you’re using for development or testing must have some Ether, even if only test
    Ether, to make sure you can execute transactions to completion. Also, at least
    one node of the test network must perform some mining continuously.
  id: totrans-1720
  prefs: []
  type: TYPE_NORMAL
- en: One way to improve the efficiency of your development cycle is to deploy your
    contract on a mock network. A mock network, such as Ganache, runs in-memory, generally
    on the developer computer, and emulates or bypasses, where applicable, all infrastructural
    aspects of an Ethereum network, such as account management, transaction costs,
    mining, and connectivity. By deploying your contract on Ganache, you can focus
    only on the development and testing of the functionality of your contract, and
    by doing so you can speed up your development cycle considerably. But once the
    contract is working as expected from a functional point of view, you still need
    to retest it within a private network and ultimately, on the public test network,
    to make sure the contract is also sound from an infrastructural point of view.
  id: totrans-1721
  prefs: []
  type: TYPE_NORMAL
- en: 8.5.1\. Installing and starting up Ganache
  id: totrans-1722
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'It turns out that installing and setting up Ganache is easier than setting
    up a private network: Ganache is written in JavaScript, it uses `Ethereumjs` to
    emulate client behavior, and it’s distributed as a Node.js package, which makes
    its installation easy.'
  id: totrans-1723
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming you have an instance of Node.js (you must have at least version 6.9.1
    at the time of writing), you can install Ganache with the Node.js console, as
    follows:'
  id: totrans-1724
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE253]'
  id: totrans-1725
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: 'That’s it! Now you should stop geth if it’s running, and you can start Ganache
    from a new OS console:'
  id: totrans-1726
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE254]'
  id: totrans-1727
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: On start-up, Ganache will list the accounts it’s going to support, as shown
    in the screenshot in [figure 8.7](#ch08fig07).
  id: totrans-1728
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.7\. Ganache accounts and related private keys, shown at startup
  id: totrans-1729
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig08-07_alt.jpg)'
  id: totrans-1730
  prefs: []
  type: TYPE_IMG
- en: 8.5.2\. Deploying SimpleCoin on Ganache
  id: totrans-1731
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Because Ganache is emulating the Ethereum network, you can’t use the geth console
    to deploy `SimpleCoin`’s contract on it. Your new console to the (mocked) Ethereum
    network is now the Node.js console.
  id: totrans-1732
  prefs: []
  type: TYPE_NORMAL
- en: Now you can deploy `SimpleCoin` exactly as you did when deploying on a public
    or private test network, as shown in the following listing, which has been adapted
    slightly for Ganache from [listing 8.3](#ch08ex03).
  id: totrans-1733
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.5\. Deploying SimpleCoinOnGanache.js
  id: totrans-1734
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE255]'
  id: totrans-1735
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: If you have a running geth instance, stop it. Make sure Ganache is running in
    a separate OS shell. Otherwise, start it again with
  id: totrans-1736
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE256]'
  id: totrans-1737
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: 'Then run the deployment script in this way:'
  id: totrans-1738
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE257]'
  id: totrans-1739
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: 'In the meantime, observe the OS shell running Ganache. You should see the following:'
  id: totrans-1740
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE258]'
  id: totrans-1741
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: 'Then you should see this in the Node.js console almost immediately:'
  id: totrans-1742
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE259]'
  id: totrans-1743
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: 'Can you spot the differences between deploying a contract on a public or private
    network and deploying it on Ganache? Yes, you’re right:'
  id: totrans-1744
  prefs: []
  type: TYPE_NORMAL
- en: Deployment on Ganache was instantaneous, whereas deployment on a network was
    performed with some latency.
  id: totrans-1745
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You didn’t need to unlock the account deploying the contract, contrary to what
    you did when deploying on a public or private network.
  id: totrans-1746
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here’s an exercise for you before we continue. Try transferring coins between
    two accounts on Ganache, either interactively or through a script.
  id: totrans-1747
  prefs: []
  type: TYPE_NORMAL
- en: 8.6\. Smoother interaction with SimpleCoin through a web UI
  id: totrans-1748
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So far, you’ve been interacting with deployed Ethereum smart contracts through
    various development tools, as shown in [figure 8.8](#ch08fig08): manually through
    the Ethereum wallet and Remix (with the injected Web3 option) and through explicit
    Web3.js instructions from a geth console or a Node.js console. An end user can
    also interact with an Ethereum contract through Web3.js indirectly from a web
    UI. In this section, you’ll build a web UI for `SimpleCoin` and, as a result,
    complete a minimal end-to-end decentralized application for the first time.'
  id: totrans-1749
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.8\. It’s possible to interact with Ethereum smart contracts through
    development tools such as the Ethereum wallet and Remix. Alternatively, you can
    perform contract operations through explicit Web3.js instructions issued from
    the geth console or the Node.js console. You can execute the same Web3.js instructions
    implicitly from an HTML web UI.
  id: totrans-1750
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig08-08_alt.jpg)'
  id: totrans-1751
  prefs: []
  type: TYPE_IMG
- en: 8.6.1\. Building a minimalistic web UI for SimpleCoin
  id: totrans-1752
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To keep things simple, you’ll initially connect the web UI to an instance of
    `SimpleCoin` deployed on Ganache. If you’ve shut down Ganache, please start it
    up again and redeploy `SimpleCoin` on it, following the steps described in [section
    8.4.3](#ch08lev2sec12).
  id: totrans-1753
  prefs: []
  type: TYPE_NORMAL
- en: 'Once `SimpleCoin` gets deployed, you should see, as before, a confirmation
    message similar to this:'
  id: totrans-1754
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE260]'
  id: totrans-1755
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: '|  |'
  id: totrans-1756
  prefs: []
  type: TYPE_TB
- en: Note
  id: totrans-1757
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Take a note of the contract address. You’ll need to place it in the JavaScript
    code you’ll be writing shortly.
  id: totrans-1758
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-1759
  prefs: []
  type: TYPE_TB
- en: 'You can build a minimalistic web UI with a small piece of HTML referencing
    a Java-Script script that handles coin transfers between accounts. In short, you
    need to implement two files:'
  id: totrans-1760
  prefs: []
  type: TYPE_NORMAL
- en: simplecoin.js
  id: totrans-1761
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: simplecoin.html
  id: totrans-1762
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simplecoin.js
  id: totrans-1763
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The JavaScript code required to handle the coin transfers between accounts,
    shown in [listing 8.6](#ch08ex06), is similar to what you’ve already executed
    several times in this chapter—for example, what you saw earlier in [listing 8.2](#ch08ex02).
    Make sure you replace the address of the contract in [listing 8.6](#ch08ex06)
    with the one from the contract you deployed earlier on Ganache.
  id: totrans-1764
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.6\. simplecoin.js
  id: totrans-1765
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE261]'
  id: totrans-1766
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: '***1*** **Replace this with the address of the SimpleCoin contract you just
    deployed on Ganache.**'
  id: totrans-1767
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **Reports an updated account balance**'
  id: totrans-1768
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **Builds the HTML account balance table dynamically**'
  id: totrans-1769
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***4*** **All accounts are iterated to build the account balance HTML.**'
  id: totrans-1770
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***5*** **Calls the coin balance getter**'
  id: totrans-1771
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***6*** **Gets the input from the UI and feeds it to the coin transfer contract
    function**'
  id: totrans-1772
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***7*** **Invokes the coin transfer contract function**'
  id: totrans-1773
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***8*** **The callback associated with a successful transfer refreshes the
    account balance table.**'
  id: totrans-1774
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***9*** **Renders the account balance table on opening the page**'
  id: totrans-1775
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a folder on your machine, for example named C:\Ethereum\SimpleCoinWebUI.
    Within this folder, create a file called simplecoin.js and copy into it the code
    from [listing 8.6](#ch08ex06).
  id: totrans-1776
  prefs: []
  type: TYPE_NORMAL
- en: Simplecoin.html
  id: totrans-1777
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The HTML page required to collect the input and show the outcome of coin transfer
    operations is basic. It contains a few text boxes to gather the input and a button
    to trigger the transfer. Apart from the basic HTML, you need to reference the
    Web3.js and jQuery JavaScript libraries and the simplecoin.js script you just
    created. You can import Web3.js and jQuery locally with Bower ([https://bower.io/](https://bower.io/)),
    a package manager for building websites. Install Bower with npm as follows:'
  id: totrans-1778
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE262]'
  id: totrans-1779
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: 'Now import the Web3.js and JQuery libraries in the current directory:'
  id: totrans-1780
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE263]'
  id: totrans-1781
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: 'At this point, Bower will have downloaded Web3 and jQuery into respective directories
    within the bower_components folder:'
  id: totrans-1782
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE264]'
  id: totrans-1783
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: You can now reference the JavaScript libraries as shown at the top of the following
    listing, which contains the entire HTML code you need.
  id: totrans-1784
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.7\. simplecoin.html
  id: totrans-1785
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE265]'
  id: totrans-1786
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: Within the SimpleCoinWebUI folder, create a file called simplecoin.html. Copy
    into it the code from [listing 8.7](#ch08ex07).
  id: totrans-1787
  prefs: []
  type: TYPE_NORMAL
- en: 8.6.2\. Running the SimpleCoin web UI
  id: totrans-1788
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Open simplecoin.html with your browser. You’ll see the screen shown in [figure
    8.9](#ch08fig09).
  id: totrans-1789
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.9\. SimpleCoin web UI
  id: totrans-1790
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig08-09_alt.jpg)'
  id: totrans-1791
  prefs: []
  type: TYPE_IMG
- en: The screen shows the balance of all the accounts Ganache supports. As specified
    on the deployment script shown in [listing 8.5](#ch08ex05), `accounts[1]`, which
    is the contract owner, has 10,000 SimpleCoin tokens, and the other accounts have
    a nil balance.
  id: totrans-1792
  prefs: []
  type: TYPE_NORMAL
- en: 'Performing a transfer through the UI is simple. Specify the source and destination
    address, respectively, in the From and To text boxes and the number of tokens
    you want to transfer in the Amount text box. Then click the Transfer button. As
    an exercise, perform this transfer:'
  id: totrans-1793
  prefs: []
  type: TYPE_NORMAL
- en: 'From: 0xbb6ae4d3af3112374f570509347dd470866c1495'
  id: totrans-1794
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To: 0x495961050c21bb2511f0550315aa9b070e90fa4e'
  id: totrans-1795
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Amount: 150'
  id: totrans-1796
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After you click Transfer, the `transfer()` contract function is invoked and,
    if the operation completes successfully, the associated callback (mapped to the
    local `refresh-AccountsTable()` JavaScript function) updates the account balances
    table, as you can see in [figure 8.10](#ch08fig10).
  id: totrans-1797
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.10\. The balance of the source and destination accounts have changed
    following a successful coin transfer.
  id: totrans-1798
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig08-10_alt.jpg)'
  id: totrans-1799
  prefs: []
  type: TYPE_IMG
- en: Summary
  id: totrans-1800
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Tools such as the Ethereum wallet and Remix allow you to deploy contracts and
    perform operations on them, but they hide the communication between the client
    and the Ethereum network.
  id: totrans-1801
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can deploy contracts with explicit Web3.js instructions from geth’s console.
  id: totrans-1802
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You also can execute contract operations through Web3.js instructions from geth’s
    console.
  id: totrans-1803
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because of the limitations of geth’s console, deploying contracts and performing
    operations on them from it is a manually intensive and time-consuming process
    that isn’t easy to automate.
  id: totrans-1804
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s easier to compile and deploy contracts from Node.js, which also allows
    you to completely automate build and deployment Web3.js scripts.
  id: totrans-1805
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can improve the development cycle by deploying contracts on a private Ethereum
    network completely under the control of the development team.
  id: totrans-1806
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can further improve the development cycle by deploying contracts on a mock
    network, such as Ganache, which emulates accounts and bypasses high-latency operations
    such as mining.
  id: totrans-1807
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s possible to execute contract operations from an HTML UI, through the same
    Web3.js instructions performed using a geth or Node.js console.
  id: totrans-1808
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
