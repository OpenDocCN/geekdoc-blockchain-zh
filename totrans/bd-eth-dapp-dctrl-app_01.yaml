- en: Part 2\.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Part 2](#part02) is all about smart contracts. This innovative technology
    has allowed Ethereum to move from single-purpose blockchains, supporting only
    cryptocurrencies, to multipurpose blockchains you can use to develop any decentralized
    application.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 5](kindle_split_017.xhtml#ch05) introduces Solidity, the most popular
    language for writing smart contracts on the Ethereum Virtual Machine. [Chapter
    6](kindle_split_018.xhtml#ch06) describes the structure of a typical smart contract
    through a sample crowdsale. This includes a constructor, state variables, functions,
    and events. Toward the end of this chapter, you’ll learn to generalize contract
    functionality through inheritance. [Chapter 7](kindle_split_019.xhtml#ch07) focuses
    on more advanced object-oriented features, such as abstract contracts and interfaces,
    which I introduce progressively so you can improve and extend the initial crowdsale
    application and make it more maintainable. This chapter also presents libraries,
    which provide another way to make contracts more maintainable. [Chapter 8](kindle_split_020.xhtml#ch08)
    explains how to deploy a smart contract to a public test network and interact
    with it through Web3, an Ethereum communication library; the Go Ethereum console;
    Node.js; and a web user interface. It also explains how to perform the same operations
    on a private network and on a mock network client, such as Ganache.'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 5\. Programming smart contracts in Solidity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: '**This chapter covers**'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding EVM languages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the structure of a contract
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning core Solidity syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Thanks to SimpleCoin, the basic cryptocurrency you’ve been building, you’ve
    learned the basics of Solidity through example. By now, you know Solidity is a
    high-level EVM language that allows you to write contracts. You also know a smart
    contract (or, simply, contract) is equivalent to a class in other languages and
    contains state variables, a constructor, functions, and events. In this chapter,
    you’ll learn Solidity’s main language constructs in a more structured way and
    develop a progressively deeper understanding of the language.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter lays the foundation for the next chapter, where you’ll learn how
    to implement complex contracts and multicontract Dapps in Solidity. By the end
    of this chapter, you’ll be able to improve and extend SimpleCoin’s functionality
    with the knowledge you’ve acquired.
  prefs: []
  type: TYPE_NORMAL
- en: 5.1\. EVM contract languages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before diving into Solidity, let’s take a little step back and explore briefly
    some alternative EVM languages. Solidity isn’t the only EVM high-level language
    for writing contracts. Although it’s the most popular option among Ethereum developers,
    mainly because it’s frequently upgraded, well maintained, and recommended in the
    official Ethereum documentation, other alternatives exist, namely LLL, Serpent,
    and Viper. Let’s see what these languages look like and when it would make sense
    to use them instead of Solidity.
  prefs: []
  type: TYPE_NORMAL
- en: 5.1.1\. LLL
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'LLL, whose acronym stands for lovely little language, is a Lisp-like language
    (which LLL also stands for) that provides low-level functions close to the EVM
    opcodes and simple control structures (such as `for`, `if`, and so on). These
    functions allow you to write low-level contract code without having to resort
    to handwriting EVM assembly. If you’ve ever seen Lisp code or you’re familiar
    with Clojure, you’ll recognize the distinctive prefix notation and heavy parentheses
    used in the following LLL listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **Instructs the LLL compiler to evaluate expressions below this line
    in order**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **Declares a variable named value at memory location 0x00**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **Declares a function called dummy at memory location 0xbc23ecab**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***4*** **Defines a macro in the LLL compiler to return the code below it**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***5*** **Starts defining the function ‘dummy’**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***6*** **Reads the location 0 of the data passed in when calling the function
    (call data) and stores it in a variable named value**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***7*** **Returns 32 bytes from the variable value**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is roughly equivalent to the following Solidity code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Warning
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Strictly speaking, these two pieces of code aren’t entirely equivalent because
    the LLL code doesn’t check the function signature or prevent Ether transfer, among
    other things.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: LLL was the first EVM language that the Ethereum core team provided because,
    given the similarity between how the stack-based Lisp language and the EVM work,
    it allowed them to deliver it more quickly than any other language. Currently,
    the main benefit of using LLL would be to get a more compact bytecode, which might
    be cheaper to run.
  prefs: []
  type: TYPE_NORMAL
- en: After the first public release of the platform, the focus shifted to higher-level
    languages that would provide a simpler syntax to contract developers. Serpent
    was the first to be developed.
  prefs: []
  type: TYPE_NORMAL
- en: 5.1.2\. Serpent and Viper
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Serpent is a Python-like language that was popular for a few months after its
    release. It was praised for its minimalistic philosophy and for offering the efficiency
    of a low-level language through simple syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re familiar with Python, these are the main limitations you’ll find
    in Serpent:'
  prefs: []
  type: TYPE_NORMAL
- en: It doesn’t provide list comprehensions (elegant syntax to create lists from
    existing sequences and lists) and complex data structures.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It doesn’t support first-class functions, therefore limiting your ability to
    use a functional programming style.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following listing shows how `SimpleCoin` would look in Serpent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Even if you don’t know Python, you should be able to understand this code. The
    only variable you might be confused about is `self.storage`. This is a dictionary
    containing the contract state. It holds the equivalent of all the state variables
    in Solidity.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A `dict` (or dictionary) is the Python implementation of a hash map (or hash
    table).
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Serpent’s popularity began to fade when the focus shifted to Solidity, which
    programmers started to maintain more regularly. A new experimental Python-like
    language, called Viper, is currently being researched and is publicly available
    on GitHub. Its aim is to provide a more extended type set than that offered by
    Serpent and easier bound and overflow checking on arithmetic operations and arrays.
    It will also allow you to write first-class functions, although with some limitations,
    and therefore write more functional code. The main benefit of using Viper is to
    get more compact and safer bytecode than you’d get from compiling Solidity.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a better understanding of EVM languages, let’s move back to
    Solidity. Open up Remix and enjoy the tour.
  prefs: []
  type: TYPE_NORMAL
- en: 5.2\. High-level contract structure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before diving into the various aspects of Solidity, I’ll present the high-level
    structure of a contract so you can appreciate the purpose of each language feature.
    This will also give you some context you can refer back to.
  prefs: []
  type: TYPE_NORMAL
- en: 5.2.1\. Contract declarations
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The contract definition for `AuthorizedToken`, an example token similar to
    SimpleCoin, shown in the next listing, summarizes all the possible declarations
    that can appear on a contract. Don’t worry if you don’t fully understand this
    code: the point of this listing is to give you an idea of what all contract constructs
    look like.'
  prefs: []
  type: TYPE_NORMAL
- en: Listing 5.1\. High-level contract structure
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **Enum definition**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **Struct definition**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **State variable definitions**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***4*** **Event definitions**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***5*** **Function modifier definition**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***6*** **Constructor definition**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***7*** **Function definitions**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***8*** **Functions defined with modifiers**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In summary, these are the possible items you can declare:'
  prefs: []
  type: TYPE_NORMAL
- en: State variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enums
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Struct types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function modifiers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s go quickly through each of them. After we complete a high-level contract
    overview, we’ll delve into each language feature.
  prefs: []
  type: TYPE_NORMAL
- en: State variables
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: State variables hold the contract state. You can declare them with any of the
    types that the language supports. Some types, such as mapping, are only allowed
    for state variables. The declaration of a state variable also includes, explicitly
    or implicitly, its access level.
  prefs: []
  type: TYPE_NORMAL
- en: Events
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: An event is a contract member that interacts with the EVM transaction log and
    whose invocation is then propagated to clients subscribed to it, often triggering
    related callbacks. An event declaration looks more similar to a declaration of
    Java or C# events than a declaration of JavaScript events.
  prefs: []
  type: TYPE_NORMAL
- en: Enums
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: An enum defines a custom type with a specified set of allowed values. An `enum`
    declaration is similar to that of Java and C# enums.
  prefs: []
  type: TYPE_NORMAL
- en: Struct types
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A struct defines a custom type that includes a set of variables, each in general
    of a different type. A struct declaration is similar to that of a C struct.
  prefs: []
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Functions encapsulate the logic of a contract, are altered by modifiers, have
    access to state variables, and can raise the events declared on the contract.
  prefs: []
  type: TYPE_NORMAL
- en: Function modifiers
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A function modifier allows you to modify the behavior of a function, typically
    to restrict its applicability to only certain input, in a declarative way. A contract
    might declare many modifiers that you might use on several functions.
  prefs: []
  type: TYPE_NORMAL
- en: 5.3\. Solidity language essentials
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'During this initial tour of Solidity, you’ll get a firm foundation in the language
    by learning about most of its syntax and constructs:'
  prefs: []
  type: TYPE_NORMAL
- en: Data types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The global namespace
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: State variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function modifiers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variable declaration, initialization, and assignment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conditional statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You’ll explore more advanced object-oriented features and concepts in the next
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Like most statically typed languages, Solidity requires you to explicitly declare
    the type of each variable, or at least needs the type to be inferred unequivocally
    by the compiler. Its data type system includes both value types and reference
    types, which I’ll present in the next few sections.
  prefs: []
  type: TYPE_NORMAL
- en: 5.3.1\. Value types
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A *value type* variable is stored on the EVM stack, which allocates a single
    memory space to hold its value. When a value type variable is assigned to another
    variable or passed to a function as a parameter, its value is copied into a new
    and separate instance of the variable. Consequently, any change in the value of
    the assigned variable doesn’t affect the value of the original variable. Value
    types include most native types, enums, and functions.
  prefs: []
  type: TYPE_NORMAL
- en: bool
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Variables declared as `bool` can have either a `true` or `false` value; for
    example
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Logical expressions must resolve to true or false, so trying to use integer
    values of 0 and 1 for false and true, as in JavaScript, C, or C++, isn’t allowed
    in Solidity.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Integer types
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You can declare integer variables either as `int` (signed) or `uint` (unsigned).
    You also can specify an exact size, ranging from 8 to 256 bits, in multiples of
    8\. For example, `int32` means signed 32-bit integer, and `uint128` means unsigned
    128-bit integer. If you don’t specify a size, it’s set to 256 bits. The sidebar
    explains how the assignment between variables of different integer types works.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: '**Implicit and explicit integer conversions**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Assignments between variables of different integer types is possible only if
    it’s meaningful, which generally means the type of the receiving variable is less
    restrictive or is larger. If that’s the case, an implicit conversion happens.
    The contract shown here, which you can enter into the Remix editor, shows some
    examples of valid and invalid assignments leading to implicit conversions when
    successful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **Compile error because newSmallNumber is too small to contain bigNumber**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **Compiler error because uint64 can only hold positive numbers**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **smallPositiveNumber is implicitly converted from uint16 to uint32;
    newMediumNumber =15,678**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***4*** **mediumNegativeNumber is implicitly converted from int32 to int256;
    newBigNumber =-450,000**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To compile this code, remove the two lines that are causing errors, such as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Then instantiate the contract (click Deploy). Finally, get the values of `newMedium-Number`
    and `newBigNumber` by clicking the corresponding buttons.
  prefs: []
  type: TYPE_NORMAL
- en: 'When an implicit conversion isn’t allowed, it’s still possible to perform explicit
    conversions. In such cases, it’s your responsibility to make sure the conversion
    is meaningful to your logic. To see an example of explicit conversions in action,
    add the following two lines to the IntConversions contract:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **The explicit conversion and assignment are successful, but newSmallNumber
    = 23,552.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **The explicit conversion and assignment are successful, but newMediumPositiveNumber
    = 18,446,744,073,709,101,616.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Reinstantiate the contract (by clicking Create again), then get the value of
    `newSmallNumber` and `newMediumPositiveNumber` by clicking the corresponding buttons.
    The results of the explicit integer conversions aren’t intuitive: they wrap the
    original value around the size of the target integer type (if its size is smaller
    than that of the source integer type) rather than overflowing.'
  prefs: []
  type: TYPE_NORMAL
- en: The principles behind implicit and explicit conversions between integer types
    apply also to other noninteger types.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Static byte arrays
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You can declare byte arrays of a fixed size with a size ranging from 1 to 32—for
    example, `bytes8` or `bytes12`. By itself, `byte` is an array of a single byte
    and is equivalent to `bytes1`.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Warning
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If no size is specified, `bytes` declares a dynamic size byte array, which is
    a reference type.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Address
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Address objects, which you generally declare using a literal containing up
    to 40 hexadecimal digits prefixed by 0x, hold 20 bytes; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Warning
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A hexadecimal literal is recognized as an address only if it has a valid checksum.
    This is determined by hashing the hexadecimal literal with the `sha3` function
    (provided by the Web3 library) and then verifying that the alphabetic characters
    in the literal are uppercase or lowercase, depending on the value of the bits
    in the hash at the same index position. This means an address is case-sensitive
    and you can’t validate it visually. Some tools, such as Remix, will warn you if
    an address isn’t valid but will still process an invalid address.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: 'It’s possible to get the Ether balance in Wei (the smallest Ether denomination)
    associated with an address by querying the `balance` property. You can try it
    by putting the following sample contract in Remix and executing the `getOwnerBalance()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: You’ll see the return value in the output panel at the bottom left of the Remix
    screen, after you click the Details button next to the output line corresponding
    to the function call. The address type exposes various functions for transferring
    Ether. [Table 5.1](#ch05table01) explains their purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Table 5.1\. Functions provided by the address type
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Function | Purpose |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| transfer() | *To transfer Ether in Wei*—If the transaction fails on the receiving
    side, an exception is thrown to the sender and the payment is automatically reverted
    (although any spent gas isn’t refunded), so no error handling code is necessary;
    transfer() can spend only up to a maximum of 2300 gas. |'
  prefs: []
  type: TYPE_TB
- en: '| send() | *To send Ether in Wei*—If the transaction fails on the receiving
    side, a value of false is returned to the sender but the payment isn’t reverted,
    so it must be handled correctly and reverted with further instructions; send()
    can spend only up to a maximum of 2,300 gas. |'
  prefs: []
  type: TYPE_TB
- en: '| call() | *To invoke a function on the target contract associated with the
    address (the target account is assumed to be a contract)*—An amount of Ether can
    be sent together with the function call by specifying it in this way: call.value(10)("contractName",
    "functionName"); call() transfers the entire gas budget from the sender to the
    called function. If call() fails, it returns false, so failure must be handled
    in a similar way to send(). |'
  prefs: []
  type: TYPE_TB
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Warning
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Because of security concerns, `send()` and `call()` are being deprecated, and
    it won’t be possible to use them in future versions of Solidity.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: 'This is an example of an Ether transfer using `transfer()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **Sends 10 Wei to destinationAddress**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If sending Ether with `send()`, you must have error handling to avoid losing
    Ether:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **If the send() operation fails, it returns false and must be handled,
    in this case by reverting the state and consequently the payment.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Another way of ensuring a transfer failure reverts the payment is by using
    the global `require()` function, which reverts the state if the input condition
    is false:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **Reverts the payment if send fails and returns false**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can invoke a function on an external contract with `call()` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **Invokes an external contract function**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can send Ether during the external call as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **Sends an amount of Ether expressed in Wei with the external call()
    by specifying it with value()**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You must have handling for a failure of the external function call, as for
    `send()`, to ensure the state (including Ether payment) is reverted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **Reverts the state and consequently the payment**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 15](kindle_split_029.xhtml#ch15) on security will cover in detail
    how to invoke `transfer()`, `send()`, and `call()` correctly and how to handle
    errors safely.'
  prefs: []
  type: TYPE_NORMAL
- en: Enums
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'An enum is a custom data type including a set of named values; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then define an enum-based variable as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The integer value of each enum item is implicitly determined by its position
    in the enum definition. In the previous example, the value of High is 0 and the
    value of Low is 2\. You can retrieve the integer value of an enum type variable
    by explicitly converting the enum variable to an int variable as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Implicit conversions aren’t allowed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **Doesn’t compile**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.3.2\. Reference types
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Reference type* variables are accessed through their reference (the location
    of their first item). You can store them in either of the following two data locations,
    which you can, in some cases, explicitly specify in their declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Memory*—Values aren’t persisted permanently and only live in memory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Storage*—Values are persisted permanently on the blockchain, like state variables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A third type of data location is available that you can’t explicitly specify:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Calldata*—This is an area dedicated to holding the values of function parameters
    of external functions. Objects held in this area behave like objects stored in
    memory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following listing shows various reference type variables declared in different
    data locations.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 5.2\. Reference types with location declared implicitly or explicitly
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **The data location of storageArray implicitly defined as storage**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **The data location of fArray implicitly defined as memory**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **The data location of gArray explicitly defined as storage**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **The data location of hArray explicitly defined as memory**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before looking at code snippets focused on data locations, have a look at [table
    5.2](#ch05table02), which summarizes the default data location of variables, depending
    on whether they’re local or state variables, and of function parameters, depending
    on whether the function has been declared internal or external.
  prefs: []
  type: TYPE_NORMAL
- en: Table 5.2\. Default data location of variables and function parameters
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Case | Data location | Default |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Local variable | Memory or storage | Storage |'
  prefs: []
  type: TYPE_TB
- en: '| State variable | Only storage | Not applicable |'
  prefs: []
  type: TYPE_TB
- en: '| Parameter of internal function | Memory or storage | Memory |'
  prefs: []
  type: TYPE_TB
- en: '| Parameter of external function | Calldata | Not applicable |'
  prefs: []
  type: TYPE_TB
- en: The behavior of reference type variables, specifically whether they get cloned
    or referenced directly when assigned to other variables or passed to function
    parameters, depends on the source and target data location. The best way to understand
    what happens in the various cases is to look at some code. The following code
    snippets all assume the `ReferenceTypesSample` contract definition given in [listing
    5.2](#ch05ex02).
  prefs: []
  type: TYPE_NORMAL
- en: 'The first case is the assignment of a state variable (whose data location is,
    as you know, the storage) to a local variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **localArray is defined implicitly in the storage and points directly
    to storageArray.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `localArray` is modified, `storageArray` is consequently modified.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next example is the assignment of a function parameter defined in memory
    to a local variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **fArray is implicitly defined in memory.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **localArray is defined in memory and points directly to fArray.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `localArray` is modified, `fArray` is consequently modified.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows what happens if you assign a function parameter
    defined in memory to a storage variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **fArray is implicitly defined in memory.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **storageArray stores a full copy of fArray.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you pass a state variable to a function parameter defined in storage, the
    function parameter directly references the state variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **fArray is implicitly defined in memory.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **During the call, gArray points directly to storageArray.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **gArray is defined explicitly in storage.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `gArray` is modified, `storageArray` is consequently modified.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you pass a state variable to a function parameter defined in memory, the
    function parameter creates a local clone of the state variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **fArray is implicitly defined in memory.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **During the call, hArray is assigned to a clone of storageArray.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **hArray is defined explicitly in memory.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are four classes of reference types:'
  prefs: []
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mappings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arrays can be static (of fixed size) or dynamic and are declared and initialized
    in slightly different ways.
  prefs: []
  type: TYPE_NORMAL
- en: Static arrays
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'You must specify the size of a static array in its declaration. The following
    code declares and allocates a static array of five elements of type `int32`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also allocate a static array and set it inline, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Inline arrays are automatically defined as to memory data location and are
    sized with the smallest possible type of their biggest item. In the inline static
    array example, imagine you hadn’t enforced the item in the first cell as `int32:
    int32[5] memory fixedSlots = [5, 9, 1, 3, 4]`. In this case, the inline array
    would have been implicitly declared as `int4[] memory`, and it would have failed
    the assignment to the `fixedSlots` variable. Therefore, it would have produced
    a compilation error.'
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Dynamic arrays
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'You don’t need to specify the size in the declaration of dynamic arrays, as
    shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then append items to a dynamic array by calling the `push` member function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'If you need to resize a dynamic array, you must do so in different ways depending
    on whether its data location is memory or storage. If the data location is storage,
    you can reset its length, as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **Implicitly declares it with storage data location**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **Resizes it by resetting its length**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the data location of a dynamic array is memory, you have to resize it with
    `new`, as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **Explicitly declares it with memory data location**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **Resizes it with new**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As you saw earlier, `bytes` is an unlimited byte array and is a reference type.
    This is equivalent to `byte[]`, but it’s optimized for space, and its use is recommended.
    It also supports `length` and `push()`.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: If an array is exposed as a public state variable, its getter accepts the array
    positional index as an input.
  prefs: []
  type: TYPE_NORMAL
- en: String
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`string` is in fact equivalent to `bytes` but with no length and `push()` members.
    You can initialize it with a string literal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Struct
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A `struct` is a user-defined type that contains a set of elements that in general
    are each of a different type. The following listing shows a contract declaring
    various structs that get referenced in its state variables. This example also
    shows how you can use enums in a struct.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 5.3\. Contract containing various struct definitions
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'You can initialize a `struct` object as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Mapping
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`mapping` is a special reference type that you can only use in the storage
    data location, which means you can declare it only as a state variable or a storage
    reference type. You might remember `mapping` is the Solidity implementation of
    a hash table, which stores values against keys. The hash table is strongly typed,
    which means you must declare the type of the key and the type of the value at
    its declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In general, you can declare the value of any type, including primitive types,
    arrays, structs, or mappings themselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'Contrary to hash table implementations of other languages, mapping has no `contains-Key()`
    function. If you try to get the value associated with a missing key, it will return
    the default value. For example, your `coinBalance` mapping will return `0` when
    trying to get the balance of an address missing from the mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **missingAddressBalance == 0;**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This completes your tour of data types. You’ve seen how to declare and instantiate
    value type and reference type variables. A certain set of variables are declared
    implicitly, and you can always access them from your contract. They’re part of
    the so-called *global namespace* that we’re going to explore next.
  prefs: []
  type: TYPE_NORMAL
- en: 5.3.3\. Global namespace
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The global namespace is a set of implicitly declared variables and functions
    that you can reference and use in your contract code directly.
  prefs: []
  type: TYPE_NORMAL
- en: Implicitly declared variables
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The global namespace provides the following five variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '`block` holds information about the latest blockchain block.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`msg` provides data about the incoming message.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tx` provides transaction data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`this` is a reference to the current contract. You can use it to call internal
    functions as if they were defined `external` and therefore store the message call
    on the blockchain. (`internal` and `external` are function accessibility levels
    that I’ll explain later, in the functions section.) If you use it by itself, it’s
    implicitly converted to the address of the current contract.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`now` is the time associated with the creation of the latest block, expressed
    as a Unix epoch.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Table 5.3](#ch05table03) summarizes the functions and properties that global
    variables expose.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 5.3\. Members of the main global variables
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Global variable | Type | Member | Return type | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| block | function | blockhash(uint blocknumber) | bytes32 | Hash of given
    block (only available for last 256 blocks, as specified in the *Yellow Paper*,
    for simplicity of design and performance reasons) |'
  prefs: []
  type: TYPE_TB
- en: '| property | coinbase | address | Block’s miner’s address |'
  prefs: []
  type: TYPE_TB
- en: '| property | gaslimit | uint | Block’s gas limit |'
  prefs: []
  type: TYPE_TB
- en: '| property | number | uint | Block’s number |'
  prefs: []
  type: TYPE_TB
- en: '| property | timestamp | uint | Block’s timestamp as UNIX epoch |'
  prefs: []
  type: TYPE_TB
- en: '| msg | property | data | bytes | Full calldata body |'
  prefs: []
  type: TYPE_TB
- en: '| property | sender | address | Message sender (who is performing the current
    call) |'
  prefs: []
  type: TYPE_TB
- en: '| property | gas | uint | Remaining gas |'
  prefs: []
  type: TYPE_TB
- en: '| property | value | uint | Amount of Ether sent with the message, in Wei |'
  prefs: []
  type: TYPE_TB
- en: '| tx | property | gasprice | uint | Transaction gas price |'
  prefs: []
  type: TYPE_TB
- en: '| property | origin | address | Transaction sender (who originated the full
    call chain) |'
  prefs: []
  type: TYPE_TB
- en: '| now | property | N/A | uint | Although the name of this variable might lead
    you to believe that this might return the current time (perhaps as a UNIX epoch),
    now is in fact an alias for block.timestamp, which is the time at which the current
    latest block was created. |'
  prefs: []
  type: TYPE_TB
- en: Implicitly declared functions
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The following two functions, available from the global namespace, throw an
    exception and revert the contract state if the associated condition isn’t met.
    Although they work exactly the same way, their intention is slightly different:'
  prefs: []
  type: TYPE_NORMAL
- en: '`require(bool condition)`—This is used to validate function input. You’ve already
    seen it when validating the input of `SimpleCoin.transfer()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assert(bool condition)`—This is used to validate contract state or function
    state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can also terminate the execution and revert the contract state explicitly
    by calling `revert()`.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to remove the current contract instance from the blockchain, for
    example because you’ve realized your contract has a security flaw that’s being
    actively exploited by hackers, you can call `selfdestruct`(Ether recipient address).
    This will uninstall the current instance from the blockchain and move the Ether
    present at the associated account to the specified recipient address.
  prefs: []
  type: TYPE_NORMAL
- en: What does uninstalling a contract mean in the context of a blockchain? It means
    that the contract will be removed from the current state of the blockchain and
    will become unreachable. But its trace will remain in the blockchain history.
    The contract is considered fully removed only after the `selfdestruct`(recipient
    address) transaction has been mined and the related block has been propagated
    throughout the network.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Warning
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You should be aware that the recipient address has no way of rejecting Ether
    coming from a `selfdestruct()` call; the destruction of the contract and the crediting
    of the recipient account are a single atomic operation. As you’ll see in a later
    chapter dedicated to security, this can be maliciously exploited to perform sophisticated
    attacks.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: The global namespace also provides various cryptographic hash functions, such
    as `sha256()`(from the SHA-2 family) and `keccak256()` (from the SHA-3 family).
    More on those in a later chapter, but for now let’s move on to state variables.
  prefs: []
  type: TYPE_NORMAL
- en: 5.3.4\. State variables
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You already know state variables hold the contract state. What I haven’t covered
    so far is the access level that you can specify when declaring them. [Table 5.4](#ch05table04)
    summarizes the available options.
  prefs: []
  type: TYPE_NORMAL
- en: Table 5.4\. Access levels of a state variable
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Access level | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| public | The compiler automatically generates a getter function for each
    public state variable. You can use public state variables directly from within
    the contract and access them through the related getter function from external
    contract or client code. |'
  prefs: []
  type: TYPE_TB
- en: '| internal | The contract and any inherited contract can access Internal state
    variables. This is the default level for state variables. |'
  prefs: []
  type: TYPE_TB
- en: '| private | Only members of the same contract—not inherited contracts—can access
    private state variables. |'
  prefs: []
  type: TYPE_TB
- en: The `StateVariablesAccessibility` contract in the following listing shows examples
    of state variable declarations, including their accessibility level.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 5.4\. Examples of state variables declared with various accessibility
    levels
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **You can access frozenAccount only from within this contract, not
    from inherited contracts.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **isContractLocked is implicitly defined as internal, so it’s accessible
    from within this contract and inherited contracts.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **tokenBalance is accessible externally, and the Solidity compiler
    automatically generates a getter function.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constant state variables
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: It’s possible to declare a state variable as constant. In this case, you have
    to set it to a value that isn’t coming from storage or from the blockchain in
    general, so values from other state variables or from properties of the block
    global variable aren’t allowed.
  prefs: []
  type: TYPE_NORMAL
- en: 'This code shows some examples of constant state variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **You can declare a value type or string state variable as constant.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **You can assign the result of a stateless built-in mathematical or
    cryptographic function to a constant state variable.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although you’ve already come across functions, there are various aspects of
    functions that I haven’t covered yet. I’ll cover them in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 5.3.5\. Functions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can specify function input and output parameters in various ways. Let’s
    see how.
  prefs: []
  type: TYPE_NORMAL
- en: Input parameters declaration
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'You declare input parameters in Solidity, as in other statically typed languages,
    by providing a list of typed parameter names, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'If you don’t use some of the parameters in the implementation, you can leave
    them unnamed (or anonymous), like the second and third parameter in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: You’ll understand better the purpose of anonymous parameters in [chapter 6](kindle_split_018.xhtml#ch06),
    when you’ll learn about abstract functions of abstract contracts and how to override
    them in concrete contracts. (Some overridden functions might not need all the
    parameters specified in the abstract function of the base abstract contract.)
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You might find, as I did initially, the naming convention for parameters a bit
    odd, because in other languages, such as Java or C#, you might have used an underscore
    prefix to identify member variables. In Solidity, an underscore prefix is used
    to identify parameters and local variables. But it seems this convention is fading
    away, and underscore prefixes might disappear altogether from Solidity naming
    conventions.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Output parameters declaration
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In Solidity, a function can in general return multiple output parameters, in
    a tuple data structure. You specify output parameters after the `returns` keyword
    and declare them like input parameters, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **Here, _alpha, _beta, and _gamma are declared as returned parameters.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **No return statement is necessary to return the result tuple to the
    caller.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A tuple is an ordered list of elements, in general each of a different type.
    This is an example of a tuple: `23,` `true, "PlanA", 57899, 345`'
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: 'As you can see in the code example, contrary to most languages, no `return`
    statement is necessary when you can write the logic in such a way that you’ve
    set all output parameters correctly before the execution of the function is complete.
    You can think of the output parameters as local variables initialized to their
    default value, in this case 0, at the beginning of the function execution. If
    you prefer, though, and if the logic requires you to do so, you can return output
    from a function using `return`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **Only the types of the return tuple are declared.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **You define and assign _alpha and _beta in the body of the function.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **The result tuple is returned to the caller explicitly with a return
    statement.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function access levels
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As for state variables, functions also can be declared with different access
    levels, as summarized in [table 5.5](#ch05table05).
  prefs: []
  type: TYPE_NORMAL
- en: Table 5.5\. Access levels of a function
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Access level | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| external | An external function is exposed in the contract interface, and
    you can only call it from external contracts or client code but not from within
    the contract. |'
  prefs: []
  type: TYPE_TB
- en: '| public | A public function is exposed in the contract interface, and you
    can call it from within the contract or from external contracts or client code.
    This is the default accessibility level for functions. |'
  prefs: []
  type: TYPE_TB
- en: '| internal | An internal function isn’t part of the contract interface, and
    it’s only visible to contract members and inherited contracts. |'
  prefs: []
  type: TYPE_TB
- en: '| private | A private function can only be called by members of the contract
    where it’s been declared, not by inherited contracts. |'
  prefs: []
  type: TYPE_TB
- en: 'The following contract code shows some function declarations, including the
    accessibility level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **A public function, accessible internally and externally**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **A private function, only accessible from within this contract**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **A private function, accessible from this and inherited contracts**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **An external function, only accessible externally**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internal function invocation
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Functions can be invoked internally or externally. For example, a function
    can invoke another function directly within the same contract, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **This invocation results in a call: _y and _z are accessed directly
    through memory references.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **This is an internal function, not accessible from outside the contract.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This way of invoking a function is known as a *call*. With a call, the body
    of the function accesses parameters directly through memory references.
  prefs: []
  type: TYPE_NORMAL
- en: External function invocation
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A function can call a function of an external contract through the contract
    reference, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **GammaCalculator is an external contract with respect to TaxCalculator2.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **gammaCalculator points to an instance deployed at address _gammaCalculatorAddress.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **This is an external function invocation, which results in a ‘transaction
    message’ that gets stored on the blockchain.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this case, parameters are sent to `GammaCalculator` through a *transaction
    message* that’s then stored on the blockchain, as you can see in the sequence
    diagram in [figure 5.1](#ch05fig01).
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.1\. Sequence diagram illustrating an external function invocation.
    The `calculateAlpha()` function of the `TaxCalculator2` contract calls the external
    `calculateGamma()` function on the `GammaCalculator` contract. Because the call
    is external, the function parameters are sent to the external contract through
    a transaction that’s stored on the blockchain.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig05-01_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can force a call to a `public` function to appear as an external invocation,
    and therefore execute through a transaction message, if it’s performed through
    `this`, the reference to the current contract, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **The call on calculateGamma through ''this'' behaves as a call on
    an external contract, so a transaction message is generated and this gets stored
    on the blockchain.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **To be called through this, you must declare calculateGamma as public.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing parameters order at function invocation
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'When invoking a function, you can pass the parameters in any order if you specify
    their name, as shown in the following listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **You can pass the parameters of calculateGamma in an arbitrary order,
    but in this case, you must also specify the parameter names.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: View and pure functions
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: It’s possible to declare a function as `view`, with the intent that it doesn’t
    perform any action that might modify state, as defined in [table 5.6](#ch05table06).
    But the compiler doesn’t check whether any state modification takes place, so
    the `view` keyword is currently used on functions mainly for documentation purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Table 5.6\. Actions that lead to a state modification
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| State modifying action |'
  prefs: []
  type: TYPE_TB
- en: '| --- |'
  prefs: []
  type: TYPE_TB
- en: '| Writing to state variables |'
  prefs: []
  type: TYPE_TB
- en: '| Raising events |'
  prefs: []
  type: TYPE_TB
- en: '| Creating or destroying contracts |'
  prefs: []
  type: TYPE_TB
- en: '| Transferring Ether (through send() or transfer()) |'
  prefs: []
  type: TYPE_TB
- en: '| Calling any function not declared as view or pure |'
  prefs: []
  type: TYPE_TB
- en: '| Using low-level calls (for example call()) or certain inline assembly opcodes
    |'
  prefs: []
  type: TYPE_TB
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In earlier versions of Solidity, the `view` keyword was named `constant.` Many
    developers argued that `constant` was misleading because it wasn’t clear whether
    it meant, as in other languages, that the function would return only constant
    results. So, although you can still use `constant` instead of `view`, the latter
    is recommended.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: It’s possible to declare a function as `pure`, with the intent that it doesn’t
    perform any action that might modify state (as seen for `view` functions) or read
    state, as defined in [table 5.7](#ch05table07). As with `view` functions, the
    compiler doesn’t check that `pure` functions don’t modify or read state, so for
    now, the `pure` keyword has only a documentation purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Table 5.7\. Actions that can be interpreted as reading from state
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| State reading actions |'
  prefs: []
  type: TYPE_TB
- en: '| --- |'
  prefs: []
  type: TYPE_TB
- en: '| Reading from state variables |'
  prefs: []
  type: TYPE_TB
- en: '| Accessing account balance (through this.balance or address.balance) |'
  prefs: []
  type: TYPE_TB
- en: '| Accessing the members of block, tx, and most of the members of msg |'
  prefs: []
  type: TYPE_TB
- en: '| Calling any function not declared as pure |'
  prefs: []
  type: TYPE_TB
- en: '| Using certain inline assembly opcodes |'
  prefs: []
  type: TYPE_TB
- en: The code in the following listing highlights in bold, functions of [listing
    5.1](#ch05ex01) that you can declare as `view` or `pure`.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 5.5\. Functions you can declare as `view` or `pure`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **Doesn’t alter state variable, so you can declare this function as
    view**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **Alters the state variable tokenBalance, so you can’t declare transfer()
    as view or pure**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **Doesn’t read or alter state, so you can declare this function as
    pure**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **Alters state variable frozenAccount, so you can’t declare freezeAccount()
    as view or pure**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Payable functions
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'You declare a function as payable if you want to allow it to receive Ether.
    The following example shows how to declare a function as payable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **Quote price in Wei, which the caller must send when invoking getStockPrice()**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **Checks the Ether amount sent (in Wei) to cover the fee for the service
    to verify it’s correct**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **If the fee sent is incorrect, reverts the transaction and the sender
    isn’t charged**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code shows how to send Ether together with the input when calling
    the `getStockPrice()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **Sends Ether while invoking an external function with call()**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **If call() fails, it returns false, and the state is reverted with
    revert();.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fallback function
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A contract can declare one unnamed (or anonymous) payable function that can’t
    have any input or output parameters. This becomes a *fallback* function in case
    a client call doesn’t match any of the available contract functions, or in case
    only plain Ether is sent to the contract via `send()`, `transfer(),` or `call()`.
  prefs: []
  type: TYPE_NORMAL
- en: The gas budget transferred to the fallback function is minimal if you call the
    fallback function by `send()` or `transfer()`. In this case, its implementation
    must avoid any costly operations, such as writing to storage, sending Ether, or
    calling internal or external functions that have complex or lengthy logic. A `send()`
    or `transfer()` call on a nonminimal fallback implementation is likely to run
    out of gas and fail almost immediately. You must avoid this situation because
    it puts Ether at risk of getting lost or even stolen, as you’ll see in the chapter
    dedicated to security.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows the classic *minimal fallback* function implementation,
    which allows incoming `send()` and `transfer()` calls to complete an Ether transfer
    successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'You also can implement a fallback function so that it prevents the contract
    from accepting Ether if it isn’t meant to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Warning
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As you’ll see in the chapter dedicated to security, the fallback function offers
    malicious participants various ways of attacking a contract, so if you decide
    to provide a fallback, you must learn how to implement it correctly.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Getter functions
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As I mentioned earlier, the compiler automatically generates a getter function
    for each public state variable declared in the contract. The getter function gets
    the name of the state variable it exposes. For example, given the usual contract
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'you can consult the balance of an account as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'A getter function is implicitly declared as `public` and `view`, so it’s possible
    to invoke it from within the contract through `this`, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **This check is performed with a getter, but you could have it performed
    by accessing the mapping directly: this.coinBalance[_account], the only difference
    being parentheses versus square brackets.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can alter the behavior of functions with function modifiers. Keep reading
    to see how.
  prefs: []
  type: TYPE_NORMAL
- en: 5.3.6\. Function modifiers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A function modifier alters the behavior of a function by performing some pre-
    and postprocessing around the execution of the function using it. As an example
    of a preprocessing modifier, the code in [listing 5.6](#ch05ex06) shows `onlyOwner,`
    a typical modifier that allows the function to be called only if the caller is
    the contract owner, which is the account that instantiated the contract. `isActive`
    is a parameterized modifier that checks if the input user account isn’t frozen.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 5.6\. Example of a contract with function modifiers
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **Sets the contract owner address at instantiation**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **Modifier definition**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **Associates a modifier with a function in this way**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **A function can have more than one modifier.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'From a certain point of view, you can look at a modifier as an implementation
    of the classic *decorator* design pattern, as it adds behavior to a function without
    modifying its logic. As for decorators, you can chain modifiers, and you can attach
    several of them to a function, as shown in the `refund()` function, which can
    execute only if the caller is the contract owner and the user account isn’t frozen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Warning
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Modifiers get called in the reverse order from how they’ve been placed on the
    function definition. In the example, `isActive` is applied first and `onlyOwner`
    second.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: 5.3.7\. Variable declaration, initialization, and assignment
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Earlier, I explained how the calling code respectively sets and handles the
    input and output function parameters. I also illustrated relatively complex cases,
    such as how you can assign multiple variables from tuple results. In this section,
    I’ll present more information about the declaration, initialization, and assignment
    of local function variables. Some of the considerations also apply to state variables.
  prefs: []
  type: TYPE_NORMAL
- en: Implicit initialization
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Contrary to most statically typed languages, which force the developer to explicitly
    initialize variables, when you declare a variable in Solidity, it’s implicitly
    initialized to its default value, corresponding to its bits being all set to zero,
    as summarized in [table 5.8](#ch05table08).
  prefs: []
  type: TYPE_NORMAL
- en: Table 5.8\. Default values of solidity types
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Type | Default value | Example |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| int and uint (all sizes) | 0 | int32 a; //0 |'
  prefs: []
  type: TYPE_TB
- en: '| bool | false | bool flag; //false |'
  prefs: []
  type: TYPE_TB
- en: '| bytes1 to bytes32 | All bytes set to 0 | bytes4 byteArray; // 0x00000000
    |'
  prefs: []
  type: TYPE_TB
- en: '| Static array | All items set to zero value | bool [3] flags; // [false, false,
    false] |'
  prefs: []
  type: TYPE_TB
- en: '| bytes | Empty byte array | [] |'
  prefs: []
  type: TYPE_TB
- en: '| Dynamic array | Empty array | int [] values; // [] |'
  prefs: []
  type: TYPE_TB
- en: '| string | Empty string | "" |'
  prefs: []
  type: TYPE_TB
- en: '| struct | Each element set to the default value |  |'
  prefs: []
  type: TYPE_TB
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As explained in [table 5.8](#ch05table08), initialized variables are set to
    a zero-like value. There is no `null` value in Solidity.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Delete
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'You can reinitialize the value of a variable to its default value, as shown
    in [table 5.8](#ch05table08), by calling `delete` on it, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **Implicitly reinitializes fixedSlots to [int32 (0), 0, 0, 0, 0]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can execute this in Remix. Make sure you check the final value of `fixedSlots`
    in the output panel on the bottom left, as usual.
  prefs: []
  type: TYPE_NORMAL
- en: Implicitly typed declaration
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'You can declare the type of a variable implicitly with `var` if this can be
    inferred from an explicit initialization, as shown in this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **Implicitly declares _gammaParams as int32 [2]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **Implicitly declares _gamma as int**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Implicitly typed variable declaration with `var` doesn’t mean Solidity supports
    dynamic typing. It means you can perform the type declaration implicitly rather
    than explicitly, but still at compile time.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Multiple implicitly typed declarations are also possible when *destructuring*
    a tuple returned from a function to multiple variables. For example, given the
    following `calculate()` function
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **Returns a tuple including three items**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **Sets the tuple items within the function body**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'it’s possible to *destructure* the tuple result into three variables, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **Assigns the tuple returned by calculate() to three variables**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Destructuring* means decomposing a tuple into its individual constituents,
    which are then assigned to separate variables.'
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Tuple assignment
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'When assigning a tuple to several implicitly or explicitly typed variables,
    the assignment will work if the number of items in the tuple is at least equal
    to the number of variables on the left-hand side of the assignment. This code
    shows examples of correct and incorrect assignments, given the `calculate()` function
    defined earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **Ignores the _ok flag but will be successful**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **Will fail with an error because it’s trying to assign four variables
    from a three-item tuple**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s also possible to set various properties of a `struct` from a tuple. For
    example, given this `struct`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'it’s possible to set its properties as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **Destructures the tuple result into the properties of a Factors struct
    object. (Note that, as in the previous example, the _ok flag that calculate()
    returns has been ignored.)**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.3.8\. Events
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An event allows a contract to notify another contract or a contract client,
    such as a Dapp user interface, that something of interest has occurred. You declare
    events like you do in C# and Java and publish them with the `emit` keyword, as
    you can see in the following code extract from `SimpleCoin`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **Defines the Transfer event**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **Publishes the Transfer event with emit**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Events in Ethereum haven’t only a real-time notification purpose, but also
    a long-term logging purpose. Events are logged on the transaction log of the blockchain,
    and you can retrieve them later for analysis. To allow quick retrieval, events
    are indexed against a key that you can define when you declare the event. The
    key can be composite and contain up to three of its input parameters, as you can
    see in the definition of Transfer shown previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: In [chapter 6](kindle_split_018.xhtml#ch06), you’ll see how to listen and react
    to Solidity events from client JavaScript code. In [chapter 13](kindle_split_027.xhtml#ch13),
    you’ll learn more about how events get logged on the blockchain and how you can
    reply to them and retrieve them.
  prefs: []
  type: TYPE_NORMAL
- en: 5.3.9\. Conditional statements
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Solidity supports all classic conditional statements available in C-like and
    Java-like languages:'
  prefs: []
  type: TYPE_NORMAL
- en: '`if ... else`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`while`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`do ... while`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`for`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loops support both continue and break statements.
  prefs: []
  type: TYPE_NORMAL
- en: You’ve completed the first part of your tour of Solidity. If you want to learn
    more about the syntax I’ve introduced in this chapter, I encourage you to consult
    the official documentation at [https://solidity.readthedocs.io/en/develop/](https://solidity.readthedocs.io/en/develop/).
    In the next section, you’ll apply what you’ve learned in this chapter to improve
    `SimpleCoin`. The Solidity tour will then continue in the next chapter, where
    you’ll start writing code in an object-oriented way and learn about other advanced
    features of the language.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Warning
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Although you might think that because transactions are executed sequentially
    within the EVM, concurrency issues might not come up within a contract, this isn’t
    entirely true. A contract might invoke a function on an external contract, and
    this might lead to concurrency issues, especially if the external contract calls
    back the caller, as you’ll see in [chapter 14](kindle_split_028.xhtml#ch14) on
    security.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: 5.4\. Time to improve and refactor SimpleCoin
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this section, you’ll extend `SimpleCoin`’s functionality as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: You’ll let the owner of an account authorize an allowance to another account.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You’ll restrict certain operations, such as minting coins or freezing accounts,
    only to the contract owner.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before making any changes, open Remix and enter the latest version of the `SimpleCoin`
    code from [chapter 4](kindle_split_015.xhtml#ch04), as shown in the following
    listing, into the editor.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 5.7\. Latest version of `SimpleCoin` from [chapter 4](kindle_split_015.xhtml#ch04)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Now you can try letting the owner of an account authorize an allowance that
    another account can use. This means that if account A has 10,000 coins, its owner
    can authorize account B to transfer a certain amount of coins (say up to a total
    of 200 in separate transfer operations) to other accounts.
  prefs: []
  type: TYPE_NORMAL
- en: 5.4.1\. Implementing an allowance facility
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can model a token allowance with a nested mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that an account allows one or more accounts to manage a specified
    number of coins; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **address2 can manage 200 coins of the address1 balance.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **address3 can manage 150 coins of the address1 balance.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can authorize an allowance by calling the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **Allows authorizedAccount to manage a number of coins equal to _allowance**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once an account has been authorized an allowance, it can transfer a number
    of coins, up to the unused allowance, to another account, with the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **Prevents transfer to 0x0 address, which is a default address if not
    specified explicitly**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **Checks if the source account has enough coins**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **Checks for overflow**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***4*** **Checks unused allowance**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***5*** **Debits source account**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***6*** **Increases recipient account**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***7*** **Decreases unused allowance**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***8*** **Raises Transfer event**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The implementation of the allowance facility was relatively simple. Now you
    can see how to restrict some `SimpleCoin` functionality only to the contract owner.
  prefs: []
  type: TYPE_NORMAL
- en: 5.4.2\. Restricting operations only to the contract owner
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The contract owner is the account from which the contract gets deployed. `SimpleCoin`
    already has an operation that’s executed against the contract owner. As you’ll
    remember, the constructor assigns the initial token supply to the contract owner,
    although this assignment is implicit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: You can make the intention of the code more explicit by declaring the contract
    owner as address public owner; then you can change the constructor to
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **Initializes the contract owner with the address of the account deploying
    the contract**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **Assigns the initial token supply explicitly to the contract owner**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minting coins
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'After you’ve initialized the `owner` variable, you can restrict the execution
    of some functions to require that the contract owner invoke them. For example,
    you could extract the constructor code assigning the initial supply to the owner
    into a new, more general function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **Restricts the invocation of this function only to the contract owner**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **Assigns the minted amount to the recipient**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then you can change the constructor as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **The initial supply is now generated through the mint() function.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `mint()` function now allows the owner to generate coins at will, not only
    at construction. The check performed on the first line of `mint()` makes sure
    only the owner can generate mint coins.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: When looking at the code of token modeling smart contracts, you’ll often find
    that functions that generate new coins or tokens are named `mint()`, after the
    English verb that’s associated with making conventional metallic coins as currency.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Freezing accounts
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'You might want to further extend the powers of the contract owner and grant
    them the exclusive ability to freeze accounts. You can model the set of accounts
    that have been frozen with the following mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: The ideal data structure probably would be a Python set (or a C# `Set` or a
    Java `HashSet`), which would allow you to store frozen addresses (the keys of
    the mapping above) and check them efficiently without having to store any associated
    value (for example, the Boolean flag in the previous mapping). But a mapping of
    an address to a Boolean can be considered a close approximation to a set of addresses.
  prefs: []
  type: TYPE_NORMAL
- en: 'You also can declare an event you can publish when freezing an account:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The owner would then freeze an account with the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **Restricts the invocation of this function only to the contract owner**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **Adds the target account to the set of frozen accounts**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **Raises the event**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You can use the `freezeAccount()` function to freeze or unfreeze accounts depending
    on the value of the Boolean parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: You might have noticed that the check being performed on `msg.sender`, which
    restricts the caller of this function to only the owner, is exactly the same as
    what you have on `mint()`. Wouldn’t it be nice to encapsulate this check in a
    reusable way? Hold on ... this is exactly the purpose of function modifiers!
  prefs: []
  type: TYPE_NORMAL
- en: Creating the onlyOwner modifier
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'I know, I know! If you’re among the readers who paid attention to the `onlyOwner`
    modifier I presented in [listing 5.6](#ch05ex06), I bet you were wondering with
    frustration why I hadn’t used it since the beginning of this section. Well, I
    wanted to show you the usefulness of modifiers the hard way. Now you can refactor
    the duplicated check of the message sender’s address against the owner’s address
    into the `onlyOwner` modifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **Won’t allow message callers who aren’t the contract owner to call
    the modified function.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can then simplify `mint()` and `freezeAccount()` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **The onlyOwner modifier replaces the previous check on msg.sender.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can see the improved `SimpleCoin` contract, including allowance setting
    and restricted coin minting and account freezing functionality, in the following
    listing.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 5.8\. Refactored version of `SimpleCoin` with extended functionality
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: You’ve completed the implementation of the proposed improvements. Along the
    way, you’ve seen a function modifier in action. In the next chapter, which will
    focus on Solidity’s more advanced object-oriented features, you’ll further improve
    `SimpleCoin`’s code.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Various EVM languages have been developed, but Solidity is the most popular
    one.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The structure of a Solidity smart contract is similar to the structure of an
    object-oriented class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Solidity has two main groups of types: value types, which include enums, primitive
    types (integer types, `bool`, `address`), and functions; and reference types,
    which include arrays, strings, structs, and mapping.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can store reference type objects in any memory or in storage.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You always store state variables in storage, never in memory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions are the equivalent of object-oriented methods; they can accept several
    parameters and can return a single result or several results in a tuple.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An unassigned variable is set with a default value depending on its type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can destructure a tuple returned from a function into separate variables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can define both state variables and functions with a specific accessibility
    level: private, internal, public, or external. (The latter only applies to functions.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chapter 6\. Writing more complex smart contracts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: '**This chapter covers**'
  prefs: []
  type: TYPE_NORMAL
- en: Building a crowdsale management Dapp showing how to structure complex contracts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending the crowdsale management Dapp through single and multiple inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: The purpose of the previous chapter was to give you a foundation in Solidity,
    so I focused mainly on the basic syntax that the language offers. In the next
    two chapters, I’ll introduce more advanced object-oriented (OO) features. I’ll
    start with inheritance in [chapter 6](#ch06) and follow with abstract contracts
    and interfaces in [chapter 7](kindle_split_019.xhtml#ch07). These OO features
    allow you to reduce code duplication and make your contracts more composable.
  prefs: []
  type: TYPE_NORMAL
- en: The contract side of real-world Dapps is generally more complex than the single-contract
    Dapp you’ve seen so far with SimpleCoin. They often span many contracts interacting
    with each other, with each contract being a concrete instance of a potentially
    complex inheritance structure. In this chapter, I’ll help you build Simple-Crowdsale,
    a basic crowdsale management Dapp. A crowdsale is the process through which investors
    fund a Dapp by buying tokens issued by the organization that’s developing it.
    This sample application will give you an idea of how complex the smart contract
    layer of a realistic Dapp can be and how inheritance, abstract classes, and interfaces
    can help you model it appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: I’ll try to keep my presentation of inheritance and polymorphism as pragmatic
    as possible, so if you’re among the readers who need a refresher on object-oriented
    programming, you’ll still be able to follow easily. I’ll start by building an
    application made of a simple contract, and I’ll keep extending it throughout this
    chapter by introducing all the object features I’ve mentioned, bit by bit.
  prefs: []
  type: TYPE_NORMAL
- en: 6.1\. Introducing SimpleCrowdsale, a crowdsale contract
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I bet you’ve heard the term crowdfunding, which is a way of funding a project
    or a cause through relatively small contribution amounts from a relatively large
    number of people. You might have even invested some funds toward the design of
    a new cool gadget at [Kickstarter.com](http://Kickstarter.com), [Indiegogo.com](http://Indiegogo.com),
    or [Microventures.com](http://Microventures.com). If so, depending on the amount
    of money you contributed and whether the project was successful, you might have
    been given an early version of the gadget, or you might have been given a considerable
    discount on the final official price of the product. This type of scheme is called
    *reward-based* crowdfunding.
  prefs: []
  type: TYPE_NORMAL
- en: Lately, a new crowdfunding scheme called *crowdsale* has emerged, mainly geared
    toward the funding of startup companies. Rather than being given a discounted
    product or service in recognition for your early contribution, you’re offered
    some equity in the venture, generally in the form of a monetary token similar
    to SimpleCoin, whose value the organizers can set before the sale starts. Alternatively,
    the value can be determined dynamically during the campaign, depending on market
    factors such as initial token supply and actual demand. Often, the token or coin
    crowdsale is called an *initial coin offering (ICO)*, an expression that mirrors
    the more conventional initial public offering (IPO) of shares by companies that
    enter the stock market for the first time.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, you’ll build SimpleCrowdsale, a decentralized crowdsale management
    application that will teach you how to design Dapps based on multiple Solidity
    contracts and libraries. In a nutshell, the following list describes the minimum
    functionality a crowdsale contract generally provides, as illustrated in the diagram
    of the core crowdsale workflow in [figure 6.1](#ch06fig01):'
  prefs: []
  type: TYPE_NORMAL
- en: It manages the funding that crowdsale investors provide during the funding stage,
    generally in the form of cryptocurrency. It also converts the cryptocurrency received
    into tokens and assigns them to the respective investors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the crowdsale objectives, such as a minimum investment target or a time limit,
    have been met, it releases the tokens to the investors. The organization developing
    the Dapp keeps the Ether collected and will use it to fund project costs. A token
    bonus might be granted to the organizers, the development team, or other parties
    involved with the token sale. Releasing tokens means activating them so they can
    be used. *Investors can exchange tokens* through a token exchange for real cash
    as soon as the token has become profitable with respect to the initial investment.
    This process is similar to that of a company that goes public and issues shares
    to investors in exchange for cash, which it will then use to fund its activities.
    Investors can subsequently trade their shares in a secondary market, and those
    shares can become more or less valuable depending on the success of the company.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the crowdsale is unsuccessful—the target investment isn’t met, for example—the
    contract allows the investors to have their investments refunded.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Figure 6.1\. The core crowdsale workflow: 1) investors book crowdsale tokens
    by paying for them in cryptocurrency; 2) if the crowdsale has met the minimum
    funding target, tokens are released to the investors; a token bonus might be granted
    to the organizers, the development team, or other parties involved with the token
    sale; and the project organization keeps the Ether received and will use it to
    fund project costs; 3) if the crowdsale is unsuccessful, investors can be refunded.'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig06-01_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[listing 6.1](#ch06ex01) gives you an idea of the functions a crowdsale Solidity
    contract would need to fulfill these requirements. (Don’t enter the code in Remix
    yet!) In case you’re wondering, `onlyOwner` is the same modifier I introduced
    earlier in 5.4.2 for `SimpleCoin`: only the contract owner is allowed to execute
    the `finalize()` function.'
  prefs: []
  type: TYPE_NORMAL
- en: Listing 6.1\. Core functionality a crowdsale contract provides
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **Allows an investor to book crowdsale tokens. (No parameter is necessary
    to specify the amount of Ether being invested because it’s being sent through
    the msg.value property.)**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **Allows the crowdsale organizer, who is the contract owner, to release
    tokens to the investors, in case of successful completion, and grant a bonus to
    the development team, if applicable**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **Allows an investor to get a refund in case of unsuccessful completion**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s build a basic implementation of this functionality, which we’ll use as
    a starting point for a later discussion on advanced object-oriented features.
    I’m not expecting you to start entering the code into Remix until you reach 6.1.9,
    as I’ll be refactoring the code progressively to explain concepts step-by-step.
    Then I’ll recap everything in [listing 6.5](#ch06ex05), which is fully executable.
    But if you want to give it a try as I go along, you’re welcome to.
  prefs: []
  type: TYPE_NORMAL
- en: 6.1.1\. State variables
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A crowdsale contract needs to maintain some configuration regarding the funding
    period during which investment contributions are accepted, the price of the token
    being sold, the minimum investment objective, and the address of the account accepting
    the investments. It also needs to keep a record of the contributions that investors
    submit. This data should be visible from the whole contract, so you should express
    it in the following state variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **Start time, in UNIX epoch, of the crowdsale funding stage**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **End time, in UNIX epoch, of the crowdsale funding stage**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **Price of the token being sold**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***4*** **Minimum investment objective, which defines if the crowdsale is successful**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***5*** **Amount of Ether received from each investor**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***6*** **Total Ether received from the investors**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***7*** **Total Ether refunded to the investors**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***8*** **Flag indicating if the contract has been finalized**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***9*** **Flag indicating whether refunding is allowed**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***10*** **Account of the crowdsale contract owner**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***11*** **Instance of the contract of the token being sold. (You’ll use SimpleCoin
    as we left it in [chapter 5](kindle_split_017.xhtml#ch05) for the moment.)**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 6.1.2\. Constructor
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The contract constructor should take all the input configurations I’ve described,
    validate them, and instantiate the contract of the token being sold. To make things
    easy, you’ll use SimpleCoin, because you’re already familiar with it. You shouldn’t
    find anything surprising in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **Validates input configurations**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **Sets input configurations into state variables**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **Instantiates the contract of the token being sold in the crowdsale**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **Sets the contract owner, as seen in SimpleCoin**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 6.1.3\. Implementing invest()
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This is the most important function of the contract. Its purpose is to accept
    Ether funds from investors and convert them into crowdsale tokens. These tokens
    won’t be released to their respective owners, though, until the crowdsale has
    completed successfully.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see in the following implementation, you’ve declared the `invest()`
    function as `payable` and placed validation logic and token conversion logic in
    three internal functions. You’ve also declared a couple of events that these functions
    raise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **Declares the invest() function as payable to accept Ether**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **Checks if the investment is valid**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **Records the investment that each investor contributes and the total
    investment**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***4*** **Converts the Ether investment into crowdsale tokens**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***5*** **Logs the investment event**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***6*** **Validates the investment**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***7*** **Checks that this is a meaningful investment**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***8*** **Checks that this is taking place during the crowdsale funding stage**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***9*** **Calculates the number of tokens corresponding to the investment**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***10*** **Generates the tokens in the investor account**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***11*** **Calculates the number of tokens**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 6.1.4\. Implementing finalize()
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The purpose of the `finalize()` function is to execute the closing actions of
    a crowdsale. If the crowdsale has met its minimum investment objective, the contract
    releases the tokens to the investors so they can be used. Additionally, a token
    bonus that depends on the total investment collected could be assigned and released
    to the development team. On the other hand, if the crowdsale is unsuccessful,
    it moves to a refunding state, and the investors are allowed to get their investments
    refunded to their accounts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before tokens are released to the investors, they should stay locked down,
    in an unusable state: token owners shouldn’t be able to perform any operations
    on them, such as transferring them to other accounts. The contract should only
    release the initially locked tokens if the crowdsale is successful.'
  prefs: []
  type: TYPE_NORMAL
- en: As you know, SimpleCoin operations (apart from `minting()`, which is restricted
    to the contract owner) aren’t constrained in any way and don’t depend on the contract
    owner unlocking any functionality. Consequently, SimpleCoin, as it stands, isn’t
    suitable for a crowdsale. It seems you must create a modified version of `SimpleCoin`—say,
    `ReleasableSimpleCoin`—whose operations, such as `transfer()` and `transferFrom()`,
    aren’t allowed to work unless the token has been released, as shown in the following
    listing.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 6.2\. `ReleasableSimpleCoin`, with locked `transfer()` and `transferFrom()`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **Flag determining whether the token is released**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **Same SimpleCoin code as before, omitted for brevity. (In case you’re
    expecting inheritance..., it hasn’t come yet.)**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **New function to release the coin. (Only the contract owner can call
    it.)**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***4*** **Now the transfer logic can be executed only if the token has been
    released.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***5*** **If the token hasn’t been released, the state is reverted.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '6.1.5\. Small detour: Introducing inheritance'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `ReleasableSimpleCoin` implementation in [listing 6.2](#ch06ex02) works
    but has a major problem: it’s duplicating most of `SimpleCoin`’s code, with obvious
    maintenance disadvantages. If you decide to make a change in `SimpleCoin`, you
    must remember to replicate the same change in `ReleasableSimpleCoin`, which is
    time-consuming and error-prone. A way to avoid this is to *derive* `ReleasableSimpleCoin`
    from `SimpleCoin` through single inheritance and introduce the `isReleased` modifier,
    as shown in the following listing.'
  prefs: []
  type: TYPE_NORMAL
- en: Listing 6.3\. `ReleasableSimpleCoin` inherited from `SimpleCoin`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **Directive to reference the file where SimpleCoin is defined ([listing
    5.8](kindle_split_017.xhtml#ch05ex08) downloadable from the book website)**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **Makes ReleasableSimpleCoin inherited from SimpleCoin**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **Flag determining whether the token is released**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***4*** **Modifier encapsulating check on released flag**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***5*** **Calls the base constructor to initialize the initialSupply state
    variable in SimpleCoin**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***6*** **New function to release the coin. (Only the contract owner can call
    it.)**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***7*** **Overrides the original implementation. (Thanks to the isReleased
    modifier, this can be called successfully only if the token has been released.)**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***8*** **You call the original SimpleCoin implementation through super. The
    original implementation is now constrained by the isReleased modifier, though.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `ReleasableSimpleCoin` contract has given you a concrete example of single
    inheritance in Solidity. Let’s summarize the main Solidity keywords involved in
    inheritance:'
  prefs: []
  type: TYPE_NORMAL
- en: A contract is *derived* from another contract with the `is` keyword, as in
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The constructor of the derived contract must feed the *base constructor* all
    the necessary parameters, as shown here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: A derived contract inherits all the public and internal functions from the parent
    contract. It’s possible to *override* a function by reimplementing it in the child
    contract, as in
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: An overridden function can *call the original implementation* from the base
    contract using the `super` keyword, as in
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you’re not entirely familiar with object-oriented terminology, [table 6.1](#ch06table01)
    can help you understand it.
  prefs: []
  type: TYPE_NORMAL
- en: Table 6.1\. Inheritance terminology
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Definition | Explanation |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| To derive a contract | To inherit a contract—Acquire public and internal
    state variables and functions from the parent contract. |'
  prefs: []
  type: TYPE_TB
- en: '| Derived contract | Inherited contract, subcontract, or child contract. |'
  prefs: []
  type: TYPE_TB
- en: '| Base contract | Parent contract. |'
  prefs: []
  type: TYPE_TB
- en: '| Overridden function | Function reimplemented in a derived contract—The overridden
    function is used instead of the parent one when the derived contract calls the
    function. |'
  prefs: []
  type: TYPE_TB
- en: You can see the inheritance relationship between `ReleasableSimpleCoin` and
    `Simple-Coin` in the contract diagram in [figure 6.2](#ch06fig02). I’ve used the
    same drawing convention used in UML class diagrams. Although you may be able to
    understand UML class diagrams intuitively, if you’re not familiar with them and
    want to learn more, check out the related sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.2\. Contract diagram illustrating the token contract hierarchy: `SimpleCoin`
    is a base contract, and `ReleasableSimpleCoin` has been inherited from it.'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig06-02_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: '**UML class diagrams**'
  prefs: []
  type: TYPE_NORMAL
- en: The Unified Modeling Language (UML) is a general-purpose modeling language that
    aims at standardizing the visualization of the design of a software system. It
    was developed in the 1990s by Grady Booch, Ivar Jacobson, and James Rumbaugh at
    Rational Software. It became an ISO standard in 2005.
  prefs: []
  type: TYPE_NORMAL
- en: 'UML covers a wide range of diagrams, including these categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Behavior diagrams*—Describe how a system works (how the components of the
    system interact with each other and with external agents)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Structure diagrams*—Describe the structure of the system at different levels
    (packages to be deployed, components within a package, and object-oriented classes
    within a component)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this book, I’ll only show you *contract diagrams*, which, given the similarity
    between the concepts of contract and class, are based on UML *class diagrams*,
    the lowest-level structure diagrams.
  prefs: []
  type: TYPE_NORMAL
- en: 'A contract diagram describes the content of a contract (state variables and
    functions) and the two main relationships between contracts:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Generalization*—A contract is inherited from a more general contract (its
    base or parent contract) or, as you’ll learn later, from an interface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Dependency*—One of the state variables is an instance of another contract.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I’ve annotated every section of text and every symbol in the sample contract
    diagram you see here, so you can refer back to it if you have any trouble understanding
    the contract diagrams that follow in the coming pages. I’ll explain new symbols
    as I introduce them in the coming sections.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/f0176-01_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Contract diagram, with symbols and conventions adapted from the UML class diagram
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to learn more about UML diagrams, I encourage you to look up the
    *UML Quick Reference Card*, at [http://tnerual.eriogerg.free.fr/umlqrc.pdf](http://tnerual.eriogerg.free.fr/umlqrc.pdf),
    or this convenient *UML Cheatsheet*: [http://mng.bz/jO5p](http://mng.bz/jO5p).
    The best book on UML is The Unified Modeling Language User Guide, by Grady Booch,
    et al, published by Addison-Wesley.'
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: 6.1.6\. Implementing finalize(), take 2
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that you’ve implemented a token suitable for a crowdsale, you can go back
    to the state variables section and replace the definition of `crowdsaleToken`
    with
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: and amend the token instantiation in the crowdsale constructor with
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Now I can show you a possible implementation for the `finalize()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **Allows only the crowdsale contract owner to call finalize()**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **Prevents calling finalize() on a finalized contract**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **Conditions determining if a crowdsale has been successful**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***4*** **Releases crowdsale tokens so investors can use them**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***5*** **Allows investors to get refunded if the funding objective hasn’t
    been met**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As I mentioned earlier, `onlyOwner` is the same modifier I introduced in SimpleCoin
    at the end of [chapter 5](kindle_split_017.xhtml#ch05) to restrict the execution
    of some functions only to the contract owner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 6.1.7\. Implementing refund()
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last function you must implement to complete the first version of your
    crowdsale contract is `refund()`, which investors would call after an unsuccessful
    crowdsale:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **Only allows refunding if this has been allowed at the crowdsale finalization**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **Only allows refunding if the investor has contributed a meaningful
    amount**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **Keeps a record of all refunds**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***4*** **Transfers Ether back to the investor and handles possible transfer
    error**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: I’ve decided to refund investors through `send()` rather than `transfer()`,
    only because `transfer()` has some quirks in Remix (at the time of writing) and
    might generate unwanted error messages that would slow down your learning experience.
    In a production environment, `transfer()` is recommended.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: 6.1.8\. Eliminating code duplication with inheritance
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As I noted, `SimpleCoin` and `SimpleCrowdsale` use the same `onlyOwner` modifier
    to restrict access to some operations to only the contract owner. The advantage
    is that you’re using `onlyOwner` consistently across the two contracts. The downside
    is that you had to introduce the `owner` state variable and implement the `onlyOwner`
    modifier in both contracts. Wouldn’t it be nice to place this modifier somewhere
    so you could then drop it into both `SimpleCoin` and `SimpleCrowdsale` without
    introducing code duplication? Fortunately, you can by encapsulating the ownership
    state and `onlyOwner` modifier into a separate contract, called `Ownable`, as
    shown in the following listing.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 6.4\. `Ownable` contract extracted from `SimpleCrowdsale` and `SimpleCoin`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **Keeps the address of the contract owner in a state variable**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **Assigns the contract owner at construction**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **Checks if the function caller using this modifier is the owner**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now you can remove the owner state variable and the `onlyOwner()` modifier
    from both `SimpleCoin` and `SimpleCrowdsale` and inherit both contracts from `Ownable`,
    as shown in the contract diagram in [figure 6.3](#ch06fig03) and in this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Figure 6.3\. After moving ownership functionality into the `Ownable` contract,
    both `SimpleCoin` and `Simple-Crowdsale` can still use the `onlyOwner` modifier
    by inheriting it from `Ownable`.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig06-03_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can see the refactored `SimpleCoin` contract inheriting from `Ownable` in
    [appendix A](kindle_split_030.xhtml#app01). Congratulations! You’ve completed
    your first implementation of a crowdsale contract, which you can fully appreciate
    in the contract diagram in [figure 6.4](#ch06fig04) and in [listing 6.5](#ch06ex05).
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The arrow between `SimpleCrowdsale` and `ReleasableSimpleCoin` in [figure 6.4](#ch06fig04)
    is a UML symbol that stands for *depends on*. I’ve included the arrow because
    the `SimpleCrowdsale` contract has a state variable of type `Releasable-SimpleCoin`,
    so it depends on `ReleasableSimpleCoin`.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Figure 6.4\. Crowdsale’s contract diagram, including `Ownable` contract and
    token contract. Both `SimpleCrowdsale` and `SimpleCoin` are inherited from `Ownable`.
    `SimpleCrowdsale` has a `ReleasableSimpleCoin` state variable, so it depends on
    `ReleasableSimpleCoin`. (If you’re unfamiliar with objectoriented class diagrams,
    the hollow-headed arrow means “inherited from,” and the filled arrow means “depends
    on.”)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig06-04_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Listing 6.5\. Initial implementation of a crowdsale contract
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **References Solidity code from other files or from other Remix code
    tabs**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 6.1.9\. Running SimpleCrowdsale
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You’ve just started implementing `SimpleCrowdsale`, but if you want to see
    what you’ve built so far in action, copy [listing 6.5](#ch06ex05) into a new Remix
    code tab (perhaps named Listing6_5_SimpleCrowdsale.sol). Make sure you’ve placed
    the dependent code specified in the import directives in related code tabs named
    appropriately:'
  prefs: []
  type: TYPE_NORMAL
- en: Listing5_8_SimpleCoin.sol (needed for Listing6_3_ReleasableSimpleCoin.sol)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listing6_3_ReleasableSimpleCoin.sol
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listing6_4_Ownable.sol
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (You can find these files in the code downloadable from the book website.)
  prefs: []
  type: TYPE_NORMAL
- en: Disabling date checks temporarily
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Before instantiating `SimpleCrowdsale`, I recommend you pick version 0.4.24
    in the Remix Compiler tab because this is the Solidity version I’ve used. I also
    suggest you temporarily disable checks on `startDate` and `endDate` to make your
    interaction with Remix easier. Modify this line in `isValidInvestment()`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: to read
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: and this line in `finalize()`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: to read
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: Instantiating the contract
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Now you can feed `SimpleCrowdsale`’s constructor parameters in the text box
    next to the Deploy button. For example, I’ll set a token price of 2,000,000,000,000,000
    Wei and a funding objective of 15,000 Ether as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: Because of your earlier modification, the 2003526559 and 2003526600 start and
    end dates will be ignored.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now pick `SimpleCrowdsale` from the contract drop-down list and click Deploy.
    If `SimpleCrowdsale` doesn’t appear, click the Compile tab and then Start to Compile.
    Take a note of which account is currently selected in the Account drop-down list
    at the top of the screen: this will be the contract owner of both `SimpleCrowdsale`
    and `ReleasableSimpleCoin`. `SimpleCrowdsale` will be activated, and a number
    of buttons corresponding to its state variables and functions will appear at the
    bottom of the screen.'
  prefs: []
  type: TYPE_NORMAL
- en: Investing into the crowdsale
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'You can simulate investors’ activity by calling the `invest()` function as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Click the SimpleCrowdsale drop-down in the Deployed Contracts bottom section
    generated after you clicked Deploy earlier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pick an Account from the drop-down list—perhaps the one starting with 0x147.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter an amount in the Value box at the top of the screen, specify the unit
    (100 Ether, for example), and click the invest button in the SimpleCrowdsale panel
    within the Deployed Contract bottom section. (You can see this button in [figure
    6.5](#ch06fig05).)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the total investment received by clicking investmentReceived.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat these three steps with different accounts and investment amounts.
  prefs: []
  type: TYPE_NORMAL
- en: Checking that tokens have been assigned to investors
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Although investors at this point have received a number of tokens corresponding
    to the amount of Ether contributed, they aren’t able to transfer them yet because
    the owner hasn’t finalized the crowdsale. If you want to check that tokens have
    been assigned to each investor, you must activate the `ReleasableSimpleCoin` contract
    instance referenced in `SimpleCrowdsale`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, get its address by clicking crowdsaleToken. Copy this address
    and paste it in the textbox next to the Activate button (*not wrapped* with double
    quotes), as shown in [figure 6.5](#ch06fig05) (but your address will be different):'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.5\. Place in Releasable-SimpleCoin’s At Address text box the address
    from `SimpleCrowdsale's crowdsaleToken` state variable.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig06-05_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now click At Address, and a new panel showing `ReleasableSimpleCoin`’s functionality,
    mostly inherited from SimpleCoin, will appear at the bottom part of the screen,
    as shown in [figure 6.6](#ch06fig06). You must click ReleasableSimpleCoin to expand
    the panel.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now check the number of tokens assigned to each investor in the following
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: Pick the address from the Account drop-down corresponding to an investor you
    want to check, copy it by clicking the copy icon next to it, and paste it into
    the text box next to the coinBalance button. (Remember to wrap it with double
    quotes.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click coinBalance, and the expected number of tokens will appear next to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat this for all accounts in the drop-down. In my case, I have the token
    breakdown shown in [table 6.2](#ch06table02).
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.6\. `ReleasableSimpleCoin's` state variables and functions
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig06-06_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Table 6.2\. Number of tokens assigned to each investor
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Investor account | Number of tokens |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0xca35b7d915458ef540ade6068dfe2f44e8fa733c | 10,100,000 |'
  prefs: []
  type: TYPE_TB
- en: '| 0x14723a09acff6d2a60dcdf7aa4aff308fddc160c | 150,000 |'
  prefs: []
  type: TYPE_TB
- en: '| 0x4b0897b0513fdc7c541b6d9d7e929c4e5364d2db | 653,500 |'
  prefs: []
  type: TYPE_TB
- en: '| 0x583031d1113ad414f02576bd6afabfb302140225 | 284,000 |'
  prefs: []
  type: TYPE_TB
- en: '| 0xdd870fa1b7c4700f2bd7f44238821c26f7392148 | 56,000 |'
  prefs: []
  type: TYPE_TB
- en: Checking that tokens are still locked
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As I explained, tokens that get assigned to investors during the crowdsale are
    unusable until it’s been finalized successfully. This means an investor won’t
    be able to transfer tokens to another account. Let’s check that this is the case
    by trying to transfer some tokens from one account to another.
  prefs: []
  type: TYPE_NORMAL
- en: Pick an account from the Account drop-down, copy its address, and paste it into
    the transfer text box (wrapped, as usual, with double quotes). This will be the
    destination account for the token transfer. Then pick a different account from
    the Account drop-down. This will be the source of the token transfer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click Transfer. Now check the number of tokens associated with the source and
    destination account again, as you did earlier. You’ll notice they haven’t changed.
    Because the value of `released` is still `false` (the crowdsale hasn’t been finalized
    yet), the transfer won’t take place (but no error will be thrown), as you can
    see in the code extract from `transfer()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **The value of released is still false, so the token transfer isn’t
    executed.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finalizing a successful crowdsale
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If you want to test a successful crowdsale, make sure the amount of investment
    is above the investment objective (15,000 Ether in my example, equivalent to 15,000,000,000,000,000,000,000
    Wei). Bear in mind, the amount shown next to the `investmentReceived` button is
    expressed in Wei. You can reach it quickly by making a few large Ether investments.
    Once the investment received is higher than the funding objective, select the
    `SimpleCrowdsale` contract owner account (the account you used to instantiate
    `SimpleCrowdsale`) and click Finalize.
  prefs: []
  type: TYPE_NORMAL
- en: Verify the crowdsale has been finalized by clicking isFinalized. The value displayed
    should be `true`. Verify `ReleasableSimpleCoin` has been released by clicking
    Released. The value displayed again should be `true`.
  prefs: []
  type: TYPE_NORMAL
- en: Now you can try to make a token transfer, as you did earlier. This time, though,
    the transfer will work because the value of `released` is now `true` and the transfer
    logic can get executed. You can verify that the number of tokens associated with
    the source and destination accounts have changed accordingly. In my case, I moved
    three coins from the account starting with 0x1472 to the account starting with
    0x4b089\. You can see their amended balances in [table 6.3](#ch06table03).
  prefs: []
  type: TYPE_NORMAL
- en: Table 6.3\. Amended `ReleasableSimpleCoin` token balance after a token transfer
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Investor account | Number of tokens |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0xca35b7d915458ef540ade6068dfe2f44e8fa733c | 10,100,000 |'
  prefs: []
  type: TYPE_TB
- en: '| 0x14723a09acff6d2a60dcdf7aa4aff308fddc160c | 149,997 |'
  prefs: []
  type: TYPE_TB
- en: '| 0x4b0897b0513fdc7c541b6d9d7e929c4e5364d2db | 653,503 |'
  prefs: []
  type: TYPE_TB
- en: '| 0x583031d1113ad414f02576bd6afabfb302140225 | 284,000 |'
  prefs: []
  type: TYPE_TB
- en: '| 0xdd870fa1b7c4700f2bd7f44238821c26f7392148 | 56,000 |'
  prefs: []
  type: TYPE_TB
- en: Finalizing an unsuccessful crowdsale
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If you’re up for it, you can also test the scenario of an unsuccessful crowdsale.
    I recommend you restart from scratch and go through all the steps you took earlier
    up to the point you contribute Ether to the crowdsale through the `invest()` function
    from various investor accounts. This time, though, don’t reach the funding objective.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, when you call `finalize()` by clicking the related button, `fundingObjectiveMet`
    is `false`. Consequently, the `isRefundingAllowed` gets enabled, as you can see
    in this extract from the `finalize()` code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: You can double-check this is the case by clicking isRefundingAllowed. With that
    enabled, you’ll be able to successfully call the `refund()` function, as you’ll
    see next. But before doing so, as an exercise I invite you to test that tokens
    haven’t been released and it isn’t possible to transfer them from one account
    to another, as you saw earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Getting a refund
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Following unsuccessful finalization, investors are allowed to get refunded.
    Pick an address from the Account drop-down, check the amount of Ether associated
    with it (shown next to the address), and click Refund. You’ll see that the Ether
    value next to the account address will increase because it has been transferred
    from the crowdsale contract back to the investor.
  prefs: []
  type: TYPE_NORMAL
- en: In the next few sections, you’ll improve the functionality of the crowdsale
    contract by taking advantage of Solidity object-oriented features, such as single
    inheritance, which you’ve already used in the `ReleasableSimpleCoin` contract,
    multiple inheritance, and abstract classes.
  prefs: []
  type: TYPE_NORMAL
- en: 6.2\. Extending functionality with inheritance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The current crowdsale implementation assumes the price of the token being bought
    by the investors is fixed throughout the crowdsale, from start to end. A way to
    incentivize and reward early investors is to provide tranche-based pricing.
  prefs: []
  type: TYPE_NORMAL
- en: 6.2.1\. Implementing a new token pricing contract with inheritance
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A *tranche* is a certain amount of total investment received. A different token
    price applies to each tranche, as shown in [figure 6.7](#ch06fig07), so that early
    investors are attracted with a lower initial price. As the sale progresses, the
    token price rises when moving from one tranche to the next and eventually becomes
    constant after the minimum funding target has been met.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.7\. Tranche-based token pricing. The total investment up to the minimum
    funding objective is divided into several tranches, each with a different token
    price. The token price rises as the total investment received moves from one tranche
    to the next.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig06-07_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the example shown in [figure 6.7](#ch06fig07), the minimum funding target
    has been set at 15,000 Ether, and the organizers have decided to create four tranches,
    as defined in [table 6.4](#ch06table04).
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 6.4\. Token-based pricing: example of different prices at different points
    in the funding process'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Total investment received (in Ether) | Token price (in Ether) |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Above 15,000 | 0.005 |'
  prefs: []
  type: TYPE_TB
- en: '| From 10,000 to 15,000 | 0.004 |'
  prefs: []
  type: TYPE_TB
- en: '| From 3,000 to 10,000 | 0.003 |'
  prefs: []
  type: TYPE_TB
- en: '| From 0 to 3,000 | 0.002 |'
  prefs: []
  type: TYPE_TB
- en: Tranche-based token pricing logic
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Now that you understand the principle of tranche-based pricing, let’s see how
    you can implement it in Solidity. If you look back at [listing 6.5](#ch06ex05),
    you’ll notice that the only function that’s directly accessing the token price
    is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **weiTokenPrice is fixed because it isn’t modified during the crowdsale.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You’ll also notice that the value of `weiTokenPrice` is never modified from
    within the crowdsale contract, so you can consider it fixed throughout the whole
    crowdsale.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a small challenge: How would you modify the implementation of `calculate-NumberOfTokens()`
    so the pricing becomes tranche-based according to the tranches defined in [table
    6.4](#ch06table04)? Here are some hints you could consider before attempting a
    solution:'
  prefs: []
  type: TYPE_NORMAL
- en: You could configure the tranches with a `struct` type, such as
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '***1*** **Higher funding limit of the tranche**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **Token price associated with the tranche**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You could store the entire tranche structure in a state variable defined with
    the following mapping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: and initialize the state variable in the contract constructor as follows
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: with the tranche limits and token price defined in Ether.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You could maintain the current active tranche in a state variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'and you’d initialize this state variable in the constructor as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You could update `currentTrancheLevel` and `weiTokenPrice` within `calculate-NumberOfTokens()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I strongly encourage you to give tranche-based pricing a try! Finished? You
    can compare your modified `calculateNumberOfTokens()` with that in the following
    listing.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 6.6\. `calculateNumberOfTokens()` based on tranche-based pricing
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **The only change to calculateNumberOfTokens()**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **Updates the current tranche and, consequently, the current token
    price**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **Tests tranches to identify where investmentReceived falls**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***4*** **Updates weiTokenPrice with the value from the current tranche-based
    pricing crowdsale contract**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see in [listing 6.6](#ch06ex06), only one extra function is necessary
    to calculate the token price based on a tranche basis. The rest of the code stays
    unaltered. I’m sure you might be wondering where you should place the amended
    `calculateNumberOfTokens()` and new `updateCurrentTrancheAndPrice()` functions.
    The simple answer is in a new crowdsale contract called `TranchePricingCrowdsale`,
    because you might still want to use the flat token pricing in other crowdsales.
    The next question is should I copy `Simple-Crowdsale`’s code, paste it into `TranchePricingCrowdsale`,
    and apply in it the modifications from [listing 6.6](#ch06ex06)? The answer is
    no, you shouldn’t! As I explained when you created `ReleasableSimpleCoin` based
    on SimpleCoin, you’ll be *inheriting* `TranchePricingCrowdsale` from `SimpleCrowdsale`,
    as shown in the following listing.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 6.7\. `TranchePricingCrowdsale` derived from `SimpleCrowdsale`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **TranchePricingCrowdsale is inherited from SimpleCrowdsale.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **Configuration of tranche structure**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **Current tranche level with respect to the investment received so
    far**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***4*** **Calling constructor on base contractor to complete the contract initialization**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***5*** **Initialization of tranche structure. (I’ve hardcoded this for simplicity,
    but it could be fed through constructor parameters.)**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***6*** **Overrides the original calculateNumberOfTokens() implementation present
    in SimpleCrowdsale**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***7*** **New function to update the token price based on the current tranche**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By inheriting `TranchePricingCrowdsale` from `SimpleCrowdsale`, I’ve shown
    you another example of single inheritance. I’ll give you a quick summary of the
    inheritance features of Solidity you can appreciate in `TranchePricingCrowdsale`.
    This is almost a repeat of what you’ve already seen in `ReleasableSimpleCoin`,
    and hopefully it will help you consolidate the concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: '`TranchePricingCrowdsale` is *inherited* from `SimpleCrowdsale` with the `is`
    keyword:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You’ve added *additional state variables* `trancheStructure` and `currentTranche-Level`
    to the inherited contract to handle tranche-specific functionality.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TranchePricingCrowdsale`’s constructor sets tranche-related state but also
    feeds the *base* `SimpleCrowdsale` constructor with the required parameters:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You’ve *overridden* `calculateNumberOfTokens()`in `TranchePricingCrowdsale`
    by providing a new implementation. Contrary to other languages, no special keywords
    are necessary to override a function in Solidity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can see the inheritance relationship between `TranchePricingCrowdsale` and
    `SimpleCrowdsale` in the contract diagram in [figure 6.8](#ch06fig08).
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.8\. Contract diagram illustrating the crowdsale contract hierarchy,
    with the latest addition of `TranchePricing-Crowdsale`, derived from `SimpleCrowdsale`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig06-08_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: I invite you to copy `TranchePricingCrowdsale`’s code from [listing 6.7](#ch06ex07)
    into a new code tab of Remix and instantiate this contract. Then you can check
    how the token price rises when the tranche thresholds are hit.
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed I’ve used the expression single inheritance a few times.
    The reason I’ve done so is because Solidity also supports *multiple inheritance*.
    We’ll explore this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 6.2.2\. Composing functionality with multiple inheritance
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Solidity is a young language that’s still in the early stages of its development.
    Its syntax is continuously improving, and consequently best practice recommendations
    change frequently. Even the most experienced Solidity developers, who might have
    a length of experience that would make them barely junior developers in more established
    languages, have to continuously keep up with learning the latest techniques and
    recommendations, especially around security.
  prefs: []
  type: TYPE_NORMAL
- en: Realistically, once a contract has been deployed into the public production
    Ethereum network, it’s unlikely to be modified on a regular basis. But a security
    flaw might be discovered, either because its developers weren’t aware of a recent
    recommendation on safer syntax or because someone finds the flaw at the community,
    node client, or language level.
  prefs: []
  type: TYPE_NORMAL
- en: Given that the possibility of things going wrong is real and the consequent
    risk of Ether being lost or stolen isn’t negligible, it has become common practice
    to include various forms of panic buttons in contracts. These range from a pause
    or halt function, which freezes the state and functionality of the contract until
    the contract owner decides to switch it on again, to a complete self-destruct
    function, which transfers the Ether stored in the contract to a safe account before
    making the contract permanently unusable.
  prefs: []
  type: TYPE_NORMAL
- en: Making a token contract pausable
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Enough talking! The following listing shows how to add pausing functionality
    to `ReleasableSimpleCoin`, assuming you don’t want to add it to `SimpleCoin` as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 6.8\. Adding pausable functionality to `ReleasableSimpleCoin`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **Same code as before**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **Flag holding the paused state**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **Modifiers holding the paused state**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***4*** **Same code as before**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***5*** **Guarantees a transfer can only take place when the token contract
    hasn’t been paused**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extracting pausability functionality
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: After making `ReleasableSimpleCoin` pausable, you might want to do the same
    with `SimpleCrowdsale`. You might be tempted to duplicate the pausing functionality
    code you’ve written into `SimpleCrowdsale`. A smarter way to make both `ReleasableSimple-Coin`
    and `SimpleCrowdsale` pausable—without introducing code duplication—is to extract
    the pausable functionality from `ReleasableSimpleCoin` into a separate contract
    (called `Pausable`, for example) and then inherit both `ReleasableSimpleCoin`
    and `SimpleCrowdsale` from `Pausable`.
  prefs: []
  type: TYPE_NORMAL
- en: You can see the new Pausable contract extracted from `ReleasableSimpleCoin`
    in the following listing.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 6.9\. Pausable contract extracted from `ReleasableSimpleCoin`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **State variable holding paused state**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **Modifier allowing function to run depending on paused state**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **Functions changing paused state**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composing base contracts with multiple inheritance
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Now you can reapply pausability to `ReleasableSimpleCoin` by inheriting `Releasable-SimpleCoin`
    from `Pausable`, which, by the way, I’ve inherited from `Ownable` so it can use
    the `onlyOwner` modifier. But, hold on, as you’ll remember, you’re already inheriting
    `ReleasableSimpleCoin` from `SimpleCoin`. Is that a problem? The answer is no.
    Solidity supports *multiple inheritance*, so you can inherit a contract from several
    contracts, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **ReleasableSimpleCoin is inherited from SimpleCoin and Pausable.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple inheritance can make your code composable because you can create more
    complex contracts by inheriting from multiple simpler contracts. On the other
    hand, you should try to compose your contracts so they have only minimal cross
    dependencies, to avoid circular reference issues.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A circular reference happens when contract C is inherited from contract P, which
    in turn is inherited indirectly from contract C.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: You can see the multiple inheritance relationships present in `ReleasableSimpleCoin`
    in [figure 6.9](#ch06fig09).
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.9\. `Releasable-SimpleCoin` is inherited both from `SimpleCoin` and
    `Pausable`, which is in turn inherited from Ownable.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig06-09_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Making a crowdsale contract pausable
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'After extracting the pausable functionality into a standalone contract, it’s
    easy to apply it to other contracts. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: By inheriting `SimpleCrowdsale` from `Pausable`, you’ve also made `TranchePricingCrowdsale`
    pausable. You can see the amended crowdsale contract structure in [figure 6.10](#ch06fig10).
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.10\. Amended crowdsale contract structure including `Pausable` contract
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig06-10_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Making a contract destructible
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If you’re not comfortable with the `Pausable` functionality, and you prefer,
    in case of emergency, to immediately transfer the Ether stored in the contract
    to a safe address and then destroy the contract so that malicious attackers can
    no longer manipulate it, you can encapsulate this functionality in a `Destructible`
    contract, as shown in the following listing.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 6.10\. A `Destructible` contract
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **Destroys the contract after having transferred Ether to a safe specified
    account using the implicitly declared function selfdestruct() (as explained in
    5.3.3)**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can now also make both `ReleasableSimpleCoin` and `SimpleCrowdsale` destructible
    by inheriting them from `Destructible`, as shown in [figure 6.11](#ch06fig11)
    and the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **ReleasableSimpleCoin and SimpleCrowdsale inheriting from Destructible**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Figure 6.11\. `ReleasableSimpleCoin` and `SimpleCrowdsale` are now also `Destructible`.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig06-11_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So far, you’ve learned how to take advantage of single and multiple inheritance
    to implement contracts with increasing functionality while avoiding code duplication.
    In the next chapter, you’ll see how abstract classes and interfaces can help you
    further toward the maintainability of your contract code base.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The contract side of real-world Ethereum Dapps is generally made of many contracts
    that interact with each other.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A crowdsale management application is an example of a multicontract Dapp.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can extend contract functionality while avoiding code duplication by using
    inheritance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple inheritance allows you to compose a complex contract from several simpler
    contracts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chapter 7\. Generalizing functionality with abstract contracts and interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: '**This chapter covers**'
  prefs: []
  type: TYPE_NORMAL
- en: Generalizing contracts by making them abstract
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving contract extensibility through interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A summary of Solidity object-oriented features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving maintainability of utility code using libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: The previous chapter introduced `SimpleCrowdsale`, which presented an example
    of a multicontract decentralized application, with a crowdsale management contract
    (`SimpleCrowdsale`) interacting with a token contract (`ReleasableSimpleCoin`).
  prefs: []
  type: TYPE_NORMAL
- en: You started to extend the functionality of `SimpleCrowdsale` by adding a new,
    more complex pricing strategy, and took advantage of contract inheritance to do
    so. You further extended the functionality by implementing pausability and destructibility
    as separate contracts and composing them into `SimpleCrowdsale` through multiple
    inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll keep extending `SimpleCrowdsale`’s functionality by
    using other object-oriented features, such as abstract contracts and interfaces.
    I’ll show you how an abstract contract can help you generalize a contract while
    avoiding code duplication. I’ll also demonstrate how interfaces can add flexibility
    to the design of your contract so you can choose to plug in one of many possible
    implementations of a specific aspect of the contract functionality.
  prefs: []
  type: TYPE_NORMAL
- en: As with most languages, you achieve code reuse in Solidity by grouping and organizing
    functions you use often into shared libraries. I’ll give you an idea of what Solidity
    libraries look like, and I’ll explain how to call their functions.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll close this chapter by making further improvements to SimpleCoin using
    some of the object-oriented techniques you’ll have learned in this chapter and
    the previous chapter. Specifically, I’ll show you how to refactor SimpleCoin so
    it can comply with the Ethereum ERC20 token standard.
  prefs: []
  type: TYPE_NORMAL
- en: 7.1\. Making a contract abstract
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At the moment, your crowdsale contracts can handle different pricing strategies.
    You derived `TranchedSimpleCrowdsale` from `SimpleCrowdsale` to provide specific
    (tranche-based) token pricing not available in the parent contract.
  prefs: []
  type: TYPE_NORMAL
- en: 7.1.1\. Implementing funding limit with inheritance
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s imagine a client is interested in your crowdsale contracts, but they’d
    like a new feature: the ability to cap the crowdsale funding at a maximum total
    amount above which no further investments are accepted. A quick way to implement
    this would be to derive a new contract called `CappedCrowdsale` from `SimpleCrowdsale`,
    as shown in the following listing.'
  prefs: []
  type: TYPE_NORMAL
- en: Listing 7.1\. First implementation of `CappedCrowdsale`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **State variable for configuring funding cap**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **Configures the rest of the state variables through the base constructor**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **Overrides isValidInvestment()**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***4*** **Copies validations from SimpleCrowdsale.isValidInvestment()**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***5*** **Checks that the cap limit hasn’t been breached**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Issues with the current implementation
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'This implementation might feel simple and satisfactory at first, but at closer
    look it has a couple of issues:'
  prefs: []
  type: TYPE_NORMAL
- en: The implementation of `isValidInvestment()` has been partially copied from `SimpleCrowdsale.isValidInvestment()`,
    creating some code duplication.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The current implementation of `CappedCrowdsale` is inheriting the default token
    pricing code from `SimpleCrowdsale`, so you can’t use it as it stands for a capped
    crowdsale with tranche-based token pricing (because `TranchePricingCrowdsale`
    is a child of `SimpleCrowdsale`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing duplication with a template method
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s try to tackle these issues one by one. First, you can avoid the partial
    code duplication within `isValidInvestment()`by reimplementing `SimpleCrowdsale.isValid-Investment()`
    as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **Previous checks on investment validity**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **Generic check against full investment received so far**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **The default implementation doesn’t perform any check at all; overridden
    implementations in inherited classes will do, as you’ll see later.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Following this change, `CappedCrowdsale` no longer needs to override `isValid-Investment()`,
    but only `isFullInvestmentWithinLimit()`, as shown in the following listing.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 7.2\. Refactored `CappedCrowdsale`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **References a modified version of SimpleCrowdsale implementing isFull-InvestmentWithinLimit**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **This is the check that was being performed previously in the overridden
    isValidInvestment() function.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `isValidInvestment()` function has now become a *template method*: it’s
    a high-level function that dictates high-level steps whose logic is delegated
    to lower level functions, such as `isFullInvestmentWithinLimit()`, which you override
    with specific implementations in each derived contract.'
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A template method is a classic design pattern that appeared in the so-called
    *Gang of Four* book: *Design Patterns: Elements of Reusable Object-Oriented Software*,
    published by Addison-Wesley.'
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Limitations of the current funding limit strategy implementation
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As I hinted previously, the current functionality to check the cap limit isn’t
    composable as it stands. If you wanted to cap funding on a crowdsale with tranche-based
    token pricing, you’d have to implement the `CappedTranchePricingCrowdsale` contract,
    as shown in the next listing.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 7.3\. Capped funding and tranche-based pricing
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **The same state variable introduced in CappedCrowdsale**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **The same implementation written for CappedCrowdsale**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, I’ve copied the code entirely from `CappedCrowdsale`. This is
    far from an ideal solution from a maintenance point of view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Aside from duplication, the current crowdsale contract hierarchy shows another
    subtler issue: as you can see in [figure 7.1](#ch07fig01), the hierarchy is asymmetrical,
    and not all contract names tell explicitly what token pricing strategy or funding
    limit strategy they’re employing. For example, `CappedCrowdsale`, whose name doesn’t
    make any reference to any token pricing strategy, inherits from `SimpleCrowdsale`,
    which implements fixed token pricing. A more precise name for this contract probably
    would be `CappedFixedPricingCrowdsale`. Equally, `TranchePricingCrowdsale`, whose
    name doesn’t make any reference to any funding strategy, also inherits from `SimpleCrowdsale`,
    which implements an unlimited funding strategy. A more precise name for this contract
    probably would be `UncappedTranchePricingCrowdsale`.'
  prefs: []
  type: TYPE_NORMAL
- en: 7.1.2\. Generalizing funding limit strategy with an abstract contract
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now I’ll show you a better solution for implementing `CappedCrowdsale` and `CappedTranchePricingCrowdsale`
    based on the concept of abstract classes. I’ll also show you how abstract classes
    can make the crowdsale contract hierarchy you saw in [figure 7.1](#ch07fig01)
    symmetric and more explicit. This involves first encapsulating the funding limit
    strategy functionality into a completely separate contract, which I’ll sketch
    for the moment as
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.1\. A UML contract diagram showing asymmetry in the crowdsale contract
    hierarchy and ambiguity regarding token pricing strategy or funding limit strategy
    in the name of some contracts. For clarity's sake, I’ve omitted ownable, pausable,
    and destructible base contracts.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig07-01_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **This is the function that performs the check on the funding cap,
    although it’s not yet implemented at this stage.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can imagine this is a base contract for all possible funding limit strategies.
    Here are two possible funding limit strategies:'
  prefs: []
  type: TYPE_NORMAL
- en: '*CappedFundingStrategy*—Crowdsale with funding capped by `fundingCap` limit,
    as seen earlier in the `CappedTranchePricingCrowdsale` contract'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*UnlimitedFundingStrategy*—Crowdsale with unlimited (or uncapped) funding'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can derive the implementation for a capped crowdsale from `FundingLimitStrategy`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **Funding cap limit**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **This is the same implementation you saw earlier in CappedTranche-PricingCrowdsale.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The implementation for an unlimited funding strategy is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **No check is performed because the funding is unlimited.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Obviously, you can derive other funding limit strategies from `FundingLimitStrategy`.
    For example, you could implement a strategy with a dynamic funding limit, readjusted
    depending on various factors that might change during the crowdsale.
  prefs: []
  type: TYPE_NORMAL
- en: '`FundingLimitStrategy` is considered an *abstract contract* because you’ve
    declared its `isFullInvestmentWithinLimit()` function but haven’t implemented
    it. On the other hand, `CappedFundingStrategy` and `UnlimitedFundingStrategy`
    are considered *concrete contracts* because all of their functions have been implemented.'
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Definition
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A contract is considered *abstract* if it contains at least one declared but
    unimplemented function. An abstract contract is used as a base class for other
    contracts, but it can’t be instantiated. A contract whose functions have all been
    implemented is considered a *concrete* contract.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: The UML contract diagram in [figure 7.2](#ch07fig02) shows the inheritance hierarchy
    of funding limit strategy contracts.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You might have noticed that the name of *FundingLimitStrategy* in [figure 7.2](#ch07fig02)
    is in italic. This is the UML convention for writing the name of abstract classes.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Figure 7.2\. Funding limit strategy contract hierarchy, including an abstract
    base contract and two concrete child contracts
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig07-02_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 7.1.3\. Improving the token pricing strategy with an abstract contract
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can apply the approach you took to make the funding limit base strategy
    contract abstract to tidy up the crowdsale contract hierarchy and make the token
    pricing strategy used by each contract more explicit, as shown in [figure 7.3](#ch07fig03).
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.3\. Making the crowdsale contract hierarchy symmetrical and more explicit.
    `SimpleCrowdsale` has been made abstract by pushing the implementation of fixed
    token pricing down to a new `FixedPricingCrowdsale` contract.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig07-03_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This is the main change taking place in `SimpleCrowdsale`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **This function has become abstract and has made SimpleCrowdsale abstract.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The fixed token pricing strategy previously in `SimpleCrowdsale` has been pushed
    down to the new `FixedPricingCrowdsale` contract:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **This formula was in SimpleCrowdsale, and now it has been moved here.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Meanwhile, `TranchePricingCrowdsale` is unaltered from the previous implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 7.1.4\. Reimplementing capped crowdsales with no duplication
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After having encapsulated the crowdsale funding limit strategy in the `FundingLimitStrategy`
    contract hierarchy, and having slightly refactored the crowdsale contract hierarchy,
    you can attempt to reimplement `CappedCrowdsale` and `CappedTranchePricingCrowdsale`,
    this time avoiding duplication.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you have to add the funding limit strategy to `SimpleCrowdsale` as a
    state variable: `fundingLimitStrategy`. You can instantiate a specific funding
    limit strategy in the constructor through a new function called `createFundingLimitStrategy()`,
    which here is declared as abstract and you must implement in the inherited contracts.
    Then you can use `fundingLimitStrategy` in the `isValidInvestment()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **State variable holding the funding limit strategy**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **A specific funding limit strategy is instantiated through createFundingLimitStrategy(),
    which is declared here as abstract.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **Instantiates a specific FundingLimitStrategy. It’s abstract, and
    you must implement it in inherited contracts.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***4*** **The check against the funding limit is performed through the appropriate
    FundingLimitStrategy contract.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It’s now possible to implement the four concrete crowdsale contracts that result
    from combining the token pricing strategy and the funding limit strategy in different
    ways, as shown in the amended crowdsale contract hierarchy in [figure 7.4](#ch07fig04):'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.4\. Reorganized crowdsale contract hierarchy, with two layers of abstract
    contracts at the top and a bottom layer of concrete contracts encapsulating all
    combinations of the contract pricing and funding limit options. The `FundingLimitStrategy`
    contract hierarchy now encapsulates the checks on the funding limit in an efficient
    way that avoids code duplication.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig07-04_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '`UnlimitedFixedPricingCrowdsale`—Derived from `FixedPricingCrowdsale`, with
    `UnlimitedFundingStrategy` instance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CappedFixedPricingCrowdsale`—Derived from `FixedPricingCrowdsale`, with `CappedFundingStrategy`
    instance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UnlimitedTranchePricingCrowdsale`—Derived from `TranchePricingCrowdsale`,
    with `UnlimitedFundingStrategy` instance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CappedTranchePricingCrowdsale`—Derived from `TranchePricingCrowdsale`, with
    `CappedFundingStrategy` instance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The two intermediate `FixedPricingCrowdsale` and `TranchePricingCrowdsale` contracts
    have become abstract because they don’t implement `createFundingLimitStrategy()`.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: The implementation of these four concrete contracts, which you can appreciate
    in [listing 7.4](#ch07ex04), is succinct. These contracts derive from the abstract
    crowdsale contract with the relevant token pricing strategy (either `FixedPricingCrowdsale`
    or `TranchePricingCrowdsale`) and implement `createFundingLimitStrategy()` by
    returning a specific funding limit strategy. All the work is then delegated to
    the abstract contracts they derive from.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 7.4\. Crowdsale contracts combining different pricing and funding limit
    options
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **Only feeds the parent contract**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **The only function implemented; overrides the abstract one in SimpleCrowdsale
    and provides a specific funding limit strategy**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.2\. Allowing multiple contract implementations with interfaces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before we leave `SimpleCrowdsale`, I’d like to show you one last object-oriented
    feature: interfaces. If you’re familiar with other OO languages, you’ll understand
    immediately how interfaces work in Solidity. If not, I’ll explain them through
    an example, so you should still be able to pick up the concept quickly.'
  prefs: []
  type: TYPE_NORMAL
- en: 7.2.1\. Setting functional requirements with interfaces
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Imagine the client who asked you to customize the crowdsale with the capped
    funding strategy now wants another change. They’re happy about your crowdsale
    contract, but they want to support other tokens, not necessarily your `ReleasableSimpleCoin`.
    You think this is a fair request that will also provide flexibility to new clients.
    After analyzing your current code, you realize your crowdsale contracts have only
    minimal interaction with `ReleasableSimpleCoin`. The only references to it are
    in `SimpleCrowdsale`, the base contract of the hierarchy, as highlighted here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **Defines crowdsaleToken as a state variable**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **Initializes crowdsaleToken in the SimpleCrowdsale constructor**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **Mints tokens bought from the investor into their account**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***4*** **Releases (unlocks) the token contract so investors can transfer their
    tokens**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'From your point of view, as the crowdsale contract developer, you only care
    that the token used in the crowdsale supports the following two functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'Obviously, to be useful to the investor, the token contract should also support
    at least the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'The syntax construct that defines the minimum set of functions the token contract
    should support is called an *interface*. The token interface that `SimpleCrowdsale`
    would reference would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 7.2.2\. Referencing a contract through an interface
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can define a contract that implements this interface by inheriting from
    it. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **ReleasableSimpleCoin already implements ReleasableToken as it stands.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You also can create other implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 7.5](#ch07fig05) shows the relationship between an interface and its
    implementations. As you can see, you can represent in two ways how a concrete
    contract implements an interface.'
  prefs: []
  type: TYPE_NORMAL
- en: Now you can modify `SimpleCrowdsale` so that it references the `ReleasableToken`
    interface rather than a concrete token contract. You should also instantiate the
    token contract in an overridden internal function rather than directly in the
    constructor, as you can see in the following listing.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.5\. Relationships between an interface and its concrete implementations.
    You can represent this relationship in two ways. The first one resembles inheritance,
    with the interface being the parent of its implementations. The second one uses
    an explicit interface symbol that’s useful if you don’t want to show all the interface
    implementations.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig07-05_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Listing 7.5\. `SimpleCrowdsale` referencing `ReleasableToken`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **Now the crowdsale contract can be any token implementing ReleasableToken.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **Instantiates the token contract in a function that can be overridden**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **The default implementation that the SimpleCrowdsale abstract contract
    offers still instantiates ReleasableSimpleCoin.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You also could have declared `createToken()` as an abstract function within
    `SimpleCrowdsale`. This would have been the purest approach, but it would have
    forced you to implement `createToken()` in all concrete contracts (such as `UnlimitedFixedPricingCrowdsale`).
    The individual implementation of `createToken()` in each concrete contract would
    have been the same as in [listing 7.5](#ch07ex05). This duplication might seem
    unnecessary, though, given that in most cases you’d want to reference `ReleasableSimpleCoin`
    anyway. There’s no right or wrong design in this regard, and the solution you
    choose depends on how you want to balance requirements and technical tradeoffs.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: So far, nothing seems to have changed. You start enjoying the benefit of referencing
    an interface rather than a concrete contract when you implement a crowdsale contract
    that needs a custom token. Imagine your client wants to use a different token
    contract, such as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'You can easily implement a new crowdsale contract that supports this token
    by overriding the `createToken()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **To support a different token contract, you need to override this
    function.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can see `UnlimitedFixedPricingCrowdsaleWithComplexCoin`’s contract diagram
    in [figure 7.6](#ch07fig06).
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.6\. A contract diagram of `UnlimitedFixedPricingCrowdsaleWithComplexCoin`.
    You can appreciate the relationships between the abstract `SimpleCrowdsale` contract
    and the `ReleasableToken` token interface and between the concrete `UnlimitedFixedPricing-CrowdsaleWithComplexCoin`
    crowdsale contract and the concrete `ReleasableComplexCoin` token contract.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig07-06_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, an interface is a useful construct that increases the flexibility
    of one element or aspect of your contract (for example, the specific token used
    in your crowdsale). By referencing an interface rather than a concrete contract
    (`ReleasableToken` rather than `ReleasableSimpleCoin` in our example), your main
    contract (`Simple-Crowdsale`) can work seamlessly with any implementation of the
    interface (`ReleasableSimpleCoin` or `ReleasableComplexCoin,` for example). As
    a result, you’re free to change the behavior of one element of your main contract
    (in the case we’ve been reviewing, the behavior of the crowdsale token used) without
    requiring any changes to the contract itself. This ability to switch seamlessly
    between different implementations of an interface is called *polymorphism*, and
    it’s one of the main principles of object-oriented programming.
  prefs: []
  type: TYPE_NORMAL
- en: I’m sure you’re wondering whether you could have achieved the same by making
    `ReleasableToken` an abstract contract rather than an interface. You’re right;
    it would have worked equally well, but by doing so you’d introduce in your code
    base a contract you don’t fully need yet. What you need at this stage is only
    the definition of the minimum functionality that `SimpleCrowdsale` requires to
    interact with a token. That’s exactly the purpose of an interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before leaving interfaces, let me quickly summarize how they work:'
  prefs: []
  type: TYPE_NORMAL
- en: 'An interface defines the set of functions that must be implemented; you must
    declare them with `external` visibility:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A contract implements an interface by inheriting from it:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: A contract must implement all the functions present in the interface it inherits
    from.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Congratulations! You’ve now completed a full implementation of a crowdsale contract
    hierarchy. This allows you to set up crowdsales with different token contracts,
    token pricing strategies, or funding limit strategies. The fruits of your hard
    work are shown in [appendix B](kindle_split_031.xhtml#app02). I encourage you
    to take a break, browse through the code, and try to digest it slowly. You’ll
    appreciate how all the pieces of the puzzle you’ve built in the last two chapters
    have come together. I’m sure that by looking at the entire code all the concepts
    you’ve learned will settle further into your head.
  prefs: []
  type: TYPE_NORMAL
- en: 7.3\. Real-world crowdsale contracts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Although `SimpleCrowdsale` is a good starting point, real-world crowdsale contracts
    can get much more complex because they offer much more functionality, such as
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A prefunding stage, during which early investors provide initial funding, which
    gets converted into tokens, possibly at a special price, at the beginning of the
    public crowdsale
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More sophisticated token pricing strategies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A funding limit based on the number of tokens purchased
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finalization strategies, including the possibility of distributing additional
    tokens to the development team, the organizers, or the legal and advisory team
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tokens with various characteristics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Warning
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In these two introductory chapters on Solidity, I haven’t touched on security
    aspects you must be aware of before deploying a contract onto the public Ethereum
    network. I’ll cover them in [chapter 14](kindle_split_028.xhtml#ch14).
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: The main objective of `SimpleCrowdsale` was to teach you inheritance, abstract
    classes, and interfaces in Solidity through a realistic use case, as well as to
    give you some technical details of how a crowdsale works. If you’re interested
    in learning more about how to build a decentralized crowdsale management application,
    or you’re curious to see how complex a real-world Dapp can be, I strongly encourage
    you to study the code of the TokenMarketNet ICO^([[1](#ch07fn01)]) GitHub repository,
    one of the best open source Ethereum crowdsale implementations, at [https://github.com/TokenMarketNet/ico](https://github.com/TokenMarketNet/ico).
  prefs: []
  type: TYPE_NORMAL
- en: ¹
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Copyright © 2017 TokenMarket Ltd., Gibraltar, [https://tokenmarket.net](https://tokenmarket.net).
    Licensed under the Apache License, V2.0.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: I encourage you to quickly review the contracts in this repository and compare
    them with the respective `SimpleCrowdsale` ones you saw earlier. You’ll realize
    how complex a real-world Dapp can become both in size (number of contracts) and
    implementation.
  prefs: []
  type: TYPE_NORMAL
- en: A little challenge
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As an exercise, I now leave you to try on your own to implement different finalization
    strategies, which you could encapsulate in yet another contract hierarchy with
    a base abstract contract, such as `FinalizationStrategy`. You could then create
    a new set of concrete contracts in which you inject such strategy at construction,
    as you’ve done when injecting the funding strategy.
  prefs: []
  type: TYPE_NORMAL
- en: 7.4\. Recap of Solidity’s object-oriented features
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you’re still alive after the hard work you’ve done so far in this chapter,
    I’m going to give you a break now. I’ll summarize and generalize all you’ve learned
    through `Simple-Crowdsale`. In case you forget some details, you won’t have to
    dig through the previous code listings and snippets to find the syntax associated
    with object-oriented features such as inheritance, abstract classes, and interfaces.
    Sit back and relax.
  prefs: []
  type: TYPE_NORMAL
- en: 7.4.1\. Inheritance
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Solidity supports multiple inheritance, so a derived contract can inherit state
    variables and functions from one or more contracts, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **Child inherits the state variables stateVar1, stateVar2, stateVarA,
    and stateVarB, and the functions operation1() and operationA() from its parent
    contracts, Parent1 and ParentA**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling base constructors
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The constructor of a derived contract must call all the parent constructors
    (in the order you want them to be called):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: Overriding functions
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A derived contract can override any function inherited from its parent contracts
    by reimplementing it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **New implementation that replaces ParentA.operationA()**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a function is called on a contract, its most overridden implementation,
    at the bottom of the inheritance hierarchy, will get executed.
  prefs: []
  type: TYPE_NORMAL
- en: Calling base functions
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'An overridden function can call a function located in a base contract, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **Calls ParentA.operationA()**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In some cases, you might want to make sure all the base implementations of
    a function are called. In those cases, you can call all of them implicitly with
    the `super` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **Calls Parent1.initialize() followed by ParentA.initialize()**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.4.2\. Abstract contracts
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A contract is considered *abstract*, rather than concrete, if at least one
    of its functions is abstract, which means it has been declared but not implemented,
    as is the case with `operationA()` in this contract:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **This is an abstract function, which makes AbstractContract abstract.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As in other statically typed languages, Solidity abstract contracts can’t be
    instantiated; they can only be used as base contracts for other abstract or concrete
    contracts.
  prefs: []
  type: TYPE_NORMAL
- en: 7.4.3\. Interfaces
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Interfaces in Solidity are similar to those offered in Java and C#. An interface
    defines the set of functions and events that must be implemented in their derived
    contracts, but it doesn’t provide any implementation. All the functions declared
    on an interface are abstract, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: 'A contract derived from an interface must implement all of its functions, as
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **Implementation of operation1**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **Constructor definition**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You can’t define any variables, structs, or enums on an interface. Also, you
    can’t derive an interface from other interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Although you can avoid code duplication by factoring a good class hierarchy
    where contracts at the bottom reuse function implementations located in their
    base classes, often common shareable logic isn’t specific to the domain of a contract
    hierarchy and has a more generic purpose. For example, functions that manipulate
    low-level data structures, such as arrays, byte arrays, or strings, in a generic
    way might be useful in any contract. The naive way to import such functionality
    is to copy and paste the required functions from a function repository into the
    contracts that need them. But there’s a much smarter way. Enter libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 7.4.4\. A word of caution
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'I’ve presented in this chapter all of Solidity’s object-oriented features,
    and I’ve shown you how real-world Dapps, such as TokenMarketNet, have been designed
    using advanced object-oriented principles. But remember that Solidity is meant
    to be used only to implement smart contracts and not rich general-purpose applications,
    so in most cases, you might not need a complex OO design after all. People fall
    into different schools of thought when it comes to designing smart contracts:
    whereas some are comfortable with taking advantage of Solidity’s rich OO feature
    set, most Ethereum developers prioritize simplicity and security and are willing
    to sacrifice long-term maintainability to gain short-term predictability. I believe
    the latter approach is sensible, especially while you’re still learning this new
    technology.'
  prefs: []
  type: TYPE_NORMAL
- en: 7.5\. Libraries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A Solidity library is a shared function repository similar in purpose to a Java
    class package or a .NET class library. The code of a library looks like that of
    a C# or C++ static class, and it contains a collection of stateless functions.
    It can also include struct and enum definitions. You can get an idea of what a
    library looks like in [listing 7.6](#ch07ex06), which shows SafeMath, a collection
    of functions to execute math operations that include safety checks around incorrect
    input or overflows. This library is part of OpenZeppelin,^([[2](#ch07fn02)]) an
    open source framework to build secure smart contracts in Solidity, which aims
    at standardizing common functionality required by most Solidity developers.
  prefs: []
  type: TYPE_NORMAL
- en: ²
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Copyright © 2016 Smart Contract Solutions, Inc., [http://mng.bz/oNPv](http://mng.bz/oNPv),
    under The MIT License (MIT).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Listing 7.6\. SafeMath library for performing checked math operations
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **Uses the library keyword instead of the contract keyword**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **Functions in a library are defined exactly as in contracts.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **Checks on the input or on the result of the arithmetic operation**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***4*** **Functions in a library are defined exactly as in contracts.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***5*** **Checks on the input or on the result of the arithmetic operation**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A library has the following limitations, compared to a contract:'
  prefs: []
  type: TYPE_NORMAL
- en: It can’t have state variables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It doesn’t support inheritance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can’t receive Ether. (You can’t decorate a function with the `payable` keyword
    and send Ether to it while invoking it.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.5.1\. Library function invocation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A contract can reference a local copy of a library (located in the same `.sol`
    code file) directly by its name, as shown in [listing 7.7](#ch07ex07). As you
    can see, you invoke library functions by prefixing them with the library name,
    like you invoke static functions in other languages. You also have to prefix library
    structs and enums with the library name.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 7.7\. How to call library functions
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **SafeMath library functions are all prefixed with SafeMath.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.5.2\. Deployed libraries
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: True code reuse takes place when only one instance of the library is deployed
    on the network and all contracts accessing it reference it through its deployment
    address (conceptually the same as a contract address). Once deployed, the functions
    of a library are exposed with implicit *external* visibility to all the contracts
    referencing it. The usual way of calling a deployed library from a contract is
    to define a local abstract contract that matches the signature of the deployed
    library. Then you communicate with the library through this local abstract contract,
    which acts as a strongly typed proxy to the library, as shown in the following
    listing. The alternative would be to invoke the library functions directly through
    `call()`, but by doing so, you wouldn’t guarantee type safety.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 7.8\. How to call library functions from a contract
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **This local abstract contract emulates the functionality offered by
    the library.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **These are the same function declarations present in the SafeMath
    library.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **SafeMath library address (copied from Remix, as show in [figure 7.8](#ch07fig08))**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***4*** **References the SafeMath library deployed at the specified address
    through an implicit constructor available for all contracts that takes the contract
    address as a parameter**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***5*** **Calls to the deployed SafeMath library**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before trying this code, put the [listing 7.6](#ch07ex06) code into a Remix
    code tab and instantiate the SafeMath library (by clicking Deploy, as for contracts).
    Copy the address by clicking the copy icon next to the contract instance panel,
    as shown in [figure 7.7](#ch07fig07).
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.7\. Get the SafeMath library address from Remix by clicking the copy
    icon.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig07-07_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now enter the code from [listing 7.7](#ch07ex07) into a new Remix code tab.
    Then paste the SafeMath library address you copied earlier into the Calculator
    constructor text box next to the Deploy button, as show in [figure 7.8](#ch07fig08).
    (Remember to wrap it with double quotes.) Click Deploy, and the `Calculator` contract
    gets instantiated. Now you can call `calculate-Theta()` by entering a couple of
    values into its input parameters text box—for example, 200, 33—and clicking calculateTheta.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.8\. Copy the SafeMath library address into the Calculator constructor
    text box.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig07-08_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'After you click calculateTheta, various calls to remote `SafeMath` functions
    are performed through the `safeMath` proxy instance: `sub()`, `add()`, `mul()`,
    and `div()` are executed in sequence and `result` is calculated. The output panel
    on the bottom left of the screen shows that `calculateTheta()`’s function completed
    successfully. You can then see the result by clicking the arrow next to the Debug
    button and checking the Decoded Output field, as shown in [figure 7.9](#ch07fig09).'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.9\. After the call to `calculateTheta()` completes, you can click Details
    and check the result in the Decoded Output field.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig07-09_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 7.5.3\. Library function execution
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When a library function is called, its code is executed within the context of
    the calling contract. For example, if the code of a function library references
    `msg`, this isn’t the message sent by the contract to the library, but the message
    received by the contract from its caller. Also, during a library function invocation,
    only the calling contract, not the library itself, accesses storage directly.
    This means library functions manipulate the value of any reference type variables
    with storage data locations passed to the functions. As mentioned earlier, libraries
    don’t permanently hold any objects at all.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A library function is executed in the context of the calling contract because
    it’s invoked through the `DELEGATECALL` opcode rather than the `CALL` opcode.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: In the previous chapter, I introduced a small improvement to `SimpleCoin` by
    extracting the ownership functionality out to the `Ownable` contract. In this
    chapter, I’ll present a new enhancement related to token standardization.
  prefs: []
  type: TYPE_NORMAL
- en: 7.6\. Making SimpleCoin ERC20 compliant
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Creating a custom cryptocurrency or token contract has become such a common
    requirement for most decentralized applications that a standard token interface
    has been proposed. Such an interface would allow any contract (such as your `Simple-Crowdsale`
    contract) to interact with a token contract in a predictable way. The standard
    Ethereum token contract is called `ERC20`. The following listing shows the standard
    token functionality every `ERC20`-compliant token is expected to provide, expressed
    as an abstract contract.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 7.9\. `ERC20` abstract contract, defining the Ethereum standard token
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: If you compare this with your latest implementation of `SimpleCoin`, shown in
    [appendix A](kindle_split_030.xhtml#app01), which includes the modifications around
    contract ownership I introduced in [chapter 5](kindle_split_017.xhtml#ch05), you’ll
    notice your token is almost `ERC20`-compliant. [Table 7.1](#ch07table01) summarizes
    the main differences between `SimpleCoin` and the `ERC20` specification.
  prefs: []
  type: TYPE_NORMAL
- en: Table 7.1\. Differences between the `ERC20` specification and `SimpleCoin`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| ERC20 specification | SimpleCoin equivalent |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| totalSupply | Not available |'
  prefs: []
  type: TYPE_TB
- en: '| balanceOf() | coinBalance() |'
  prefs: []
  type: TYPE_TB
- en: '| approve() | authorize() |'
  prefs: []
  type: TYPE_TB
- en: '| allowance() | Not available (direct use of allowance state variable) |'
  prefs: []
  type: TYPE_TB
- en: '| Approval | Not available |'
  prefs: []
  type: TYPE_TB
- en: You can use [table 7.1](#ch07table01) to refactor `SimpleCoin` into a fully
    compliant ERC20 token. The following listing shows what such an implementation
    would look like, also taking into account the standard parameter names of functions
    and events.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 7.10\. `SimpleCoin` refactored to an `ERC20` token
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **These state variables have become internal. They’re now exposed externally
    through dedicated functions.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **New event associated with approving an allowance**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **Allows you to check coinBalance externally**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***4*** **Raises an event when a balance is approved**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***5*** **Allows you to check allowances externally**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Although the token constructor isn’t part of the interface and consequently
    isn’t included in the standard, ERC20 recommends initializing a token with the
    following useful information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **Number of decimal digits to consider in fractional token amounts**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ERC20` wiki ([http://mng.bz/5NaD](http://mng.bz/5NaD)) also shows a recommended
    implementation. Although this is similar to `SimpleCoin`, I still encourage you
    to review it. I suggest you also have a look at the OpenZeppelin section on tokens
    at [http://mng.bz/6jQ6](http://mng.bz/6jQ6).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Abstract contracts generalize contract functionality and help minimize code
    duplication by providing default function implementations when appropriate.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An interface provides the declaration of the minimum set of functions a contract
    should provide.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can seamlessly change the behavior of one element or aspect of a contract
    by modeling it with an interface. By doing so, you can instantiate a different
    implementation of the interface without having to alter the code of the contract
    using it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can organize general purpose Solidity functions in libraries, which you
    can share across different contracts or applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a custom cryptocurrency or token contract is such a common requirement
    for most decentralized applications that a standard token interface called `ERC20`
    has been proposed. Any decentralized application can use a token contract that
    follows the `ERC20` standard in a predictable way.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chapter 8\. Managing smart contracts with Web3.js
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: '**This chapter covers**'
  prefs: []
  type: TYPE_NORMAL
- en: Deploying contracts and interacting with them through geth’s console
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simplifying console-based deployment with Node.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying on a private network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying on a mock network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: In [chapter 4](kindle_split_015.xhtml#ch04), you had a first taste of deploying
    a smart contract on the Ethereum network. You did so through the Ethereum wallet
    and through Remix (with MetaMask). It looked relatively easy, as it involved only
    a few clicks on a well-designed screen. On the other hand, the convenience and
    simplicity of the user interface hid from you the key steps that take place on
    the network when contract deployment is in progress. Did you ask yourself, for
    example, how the code you entered on the code editor (of the wallet or Remix)
    got compiled, packaged, and sent to the Ethereum network, and how it finally got
    installed on each node?
  prefs: []
  type: TYPE_NORMAL
- en: In the last three chapters, you learned in depth how to develop a smart contract
    with Solidity. It’s time to learn the deployment process in depth as well. It’s
    important knowledge to have if you want to truly understand how decentralized
    applications work under the hood, and if you want to be able to troubleshoot postdeployment
    issues you might experience.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll learn how to deploy and communicate with a smart contract
    through the geth console, using explicit Web3.js instructions. By doing so, you’ll
    perform all the commands and operations the wallet UI did magically for you while
    deploying the contract or moving tokens between accounts. Not only will you deploy
    a contract the hard way on a public test network, but you’ll go the extra mile
    and even set up a full private network and redeploy the contract on it. All of
    this will take much more effort than clicking a few buttons on the wallet UI,
    but you’ll be rewarded by gaining a much deeper knowledge of how an Ethereum network
    and related blockchain are set up and configured, as well as firsthand insight
    into the deployment process and client-to-network interaction. Along the way,
    I’ll also show you how to simplify the deployment process a little by running
    operations on Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after you’ve deployed a contract on a public test network and a private
    test network, you’ll also learn how to deploy a contract on Ganache, a special
    client that emulates (or mocks) a full Ethereum network on a single host. This
    is a convenient environment for developing and system-testing your contracts without
    having to pay for the latency of operations that take place on a real network,
    such as waiting for transactions to be mined and added on a new block, especially
    through times of network instability.
  prefs: []
  type: TYPE_NORMAL
- en: Before leaving the chapter, we’ll revisit `SimpleCoin`. This time, I’ll take
    advantage of the fact that you’ll have already learned how to deploy it on the
    network and communicate with it through Web3.js commands on the geth console.
    I’ll be able to show you how to build a simple UI that uses the same Web3 commands,
    but from within an HTML page.
  prefs: []
  type: TYPE_NORMAL
- en: 8.1\. Revisiting deployment through geth’s interactive console
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you installed geth, in [chapter 3](kindle_split_014.xhtml#ch03), you were
    pointing to MAINNET, the production Ethereum network. During development, I strongly
    advise you to point your tools, including your Ethereum client, to a test network
    instead, at least to avoid spending any real Ether directly or indirectly through
    accidental transactions or gas consumption. Various test networks are available
    at any given time, with a couple current examples being Ropsten and Rinkeby. Each
    test network is related to a slightly different version of the Ethereum platform,
    and you might find you have to upgrade geth to be able to run on a specific network.
    For the purposes of this chapter, I’ll refer to a test network as TESTNET.
  prefs: []
  type: TYPE_NORMAL
- en: 'To point geth to TESTNET, you must shut down any instance running against MAINNET
    (if you have any) and restart geth from a new command shell with the `--testnet`
    option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: Geth will start synchronizing to the test network in exactly the same way it
    did when you started it in MAINNET.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In case you want to experiment and point to the Rinkeby test network based on
    the Proof of Stake consensus algorithm, use the `--rinkeby` option instead of
    `–-testnet` by typing `C:\Program Files\geth>geth –-rinkeby`. The rest of the
    chapter assumes you’re using `––testnet`.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: '**Using bootnodes to connect to specific peers**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Occasionally your geth client might take a long time to discover peers that
    can send you the blockchain blocks. In that case, try using the `--bootnodes`
    option, which will force geth to access the network by connecting to specific
    peers, rather than discovering all peers by itself. I’ve found these nodes to
    be up most of the time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to sync up your blockchain more quickly, you can also add these
    options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: 'From a separate command shell, you can now start an interactive console pointing
    to the test network exactly as you did when you were pointing to the main network:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: (Note that since geth 1.8.0, you have to specify the IPC path.) When the console
    starts up, it shows environmental information about the network it’s pointing
    to. As you can see in [figure 8.1](#ch08fig01), `datadir` is pointing to `testnet`,
    which confirms you’re now in TESTNET.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.1\. The geth interactive console showing it’s connected to TESTNET
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig08-01_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Deploying a contract through geth’s console for the first time is slightly more
    involved than doing it with a few clicks on Ethereum’s wallet. The wallet hides
    some of the steps that happen under the hood. By performing those steps explicitly,
    you’ll learn how the contract build and deployment process works in detail. Also,
    once you’ve scripted the entire process, future redeployment will become much
    quicker and less error-prone.
  prefs: []
  type: TYPE_NORMAL
- en: 8.1.1\. Contract build and deployment process
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The diagram in [figure 8.2](#ch08fig02) shows all the main steps required to
    build and deploy the contract through the interactive console:'
  prefs: []
  type: TYPE_NORMAL
- en: Compile the contract with the Solidity compiler.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Push the contract’s *binary interface* (`abi`) and *bytecode* (`bin`) from the
    compiler to an output file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run a Web3.js command that creates a *contract factory* of the contract from
    its binary interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run a Web3.js command that instantiates the contract by invoking the `new()`
    method of the contract factory and feeding it the bytecode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 8.2\. The contract build and deployment process: 1\. the contract is
    compiled with the Solidity compiler; 2\. the contract binary interface and bytecode
    are pushed to an output file; and 3\. a JavaScript using Web3 is created. This
    does three things: a. creates a contract factory of the contract from its binary
    interface (ABI); b. instantiates the contract by invoking `new()` on the contract
    factory; and c. feeds the bytecode to it.'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig08-02_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 8.1.2\. Deploying SimpleCoin through geth’s console
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s go through the steps from [figure 8.2](#ch08fig02) in detail by redeploying
    `SimpleCoin` to the test network. Following the build and deployment diagram,
    you must first compile the contract using solc.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling a contract using solc
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'You can download the solc compiler from this GitHub page: [https://github.com/ethereum/solidity/releases](https://github.com/ethereum/solidity/releases).
    (I’ve downloaded solidity-windows.zip from the Version 0.4.24 section—please download
    an equivalent or later.) After downloading it, copy the executable into a folder;
    for example, C:\Ethereum\solidity-windows. (Feel free to name the folder after
    your OS.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new folder for your `SimpleCoin` code: C:\Ethereum\SimpleCoin. Then
    create a new text file called SimpleCoin.sol and, for simplicity, paste in it
    one of the early versions of the contract code you wrote, like the one shown in
    the following listing.'
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.1\. SimpleCoin.sol, containing an early version of `SimpleCoin`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: 'Place this file in the `SimpleCoin` code folder you created. Then open a command-line
    shell and move to the `SimpleCoin` code folder. From there, invoke the compiler
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: '[Table 8.1](#ch08table01) explains the compiler options you’ve used.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 8.1\. The solc compiler options used to compile `SimpleCoin`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Compiler option | Purpose |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| --bin | Produces the binary of the contract in hex format |'
  prefs: []
  type: TYPE_TB
- en: '| -o bin | Creates the binary output in the bin folder |'
  prefs: []
  type: TYPE_TB
- en: '| --combined-json abi,bin | Produces JSON output, including the ABI interface
    and the binary |'
  prefs: []
  type: TYPE_TB
- en: 'The JSON output shown here will be redirected to the bin\combined.json file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: 'The JSON output includes two members:'
  prefs: []
  type: TYPE_NORMAL
- en: '`abi`—This is the contract application binary interface (ABI). It shows the
    API that your contract exposes and that client applications that interact with
    the contract should use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bin`—This is the contract bytecode in hex format. You’ll need the contract’s
    ABI and bytecode to deploy it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying a contract through the interactive console
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Open geth’s interactive console, which is pointing to TESTNET, and enter the
    code in [listing 8.2](#ch08ex02). (Please make sure you use the code from the
    [listing 8.2](#ch08ex02) file downloaded from the book website, as I’ve shortened
    it for brevity here.) You might have noticed that `simpleCoinAbi` has been assigned
    to the content of `abi` from combined.json, and `data` has been assigned to the
    content of `bin`, prefixed by `0x`.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.2\. The geth interactive JavaScript instructions to deploy a contract
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **SimpleCoin constructor input**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **Contract ABI, copied from the abi member of the SimpleCoin.out compilation
    output file**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **Initializes contract factory with the contract ABI**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***4*** **Instantiates the contract**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***5*** **The contract bytecode, copied from the bin member of the SimpleCoin.out
    compilation output file**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***6*** **Triggers registration of callback at completion of the deployment
    process**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After executing these instructions, you’ll get the following error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: To deploy the contract, you have to unlock the account it’s being deployed through,
    `web3.eth.accounts[0]` (specified in the `from` property in [listing 8.2](#ch08ex02)).
    This will become the account owner.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don’t remember what `accounts[0]` refers to, you can list on the interactive
    console the TESTNET accounts you created from the Ethereum wallet in the previous
    chapters. The first one in the results list is `accounts[0]`, and it’s named in
    the wallet as Main Account. This is what I got:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: 'Enter the following command to unlock the account:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: '**Secure account unlocking**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The most secure way of unlocking an account is through a geth command in the
    operating system shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: This avoids potential security concerns due to the interactive console recording
    a history of all the operations that have taken place on it.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: 'Try to re-execute the script in [listing 8.2](#ch08ex02). This time, you won’t
    get any error message. Wait for a few seconds, and the geth console will show
    a message similar to the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: 'Well done! You’ve deployed `SimpleCoin` on TESTNET through the geth interactive
    console. You can now examine the content of `simpleCoinInstance`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: 'An important property of the `simpleCoinInstance` object, which you’ll reference
    later, is its blockchain address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: For now, let’s start interacting with `SimpleCoin` through `simpleCoinInstance`.
  prefs: []
  type: TYPE_NORMAL
- en: 8.2\. Interacting with SimpleCoin through geth’s console
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once you’ve deployed `SimpleCoin` on TESTNET, you can perform the same operations
    you did manually through the wallet in [chapter 4](kindle_split_015.xhtml#ch04),
    [section 4.2](kindle_split_015.xhtml#ch04lev1sec2), but this time through the
    console.
  prefs: []
  type: TYPE_NORMAL
- en: 8.2.1\. Checking coin balances
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First of all, check the balance of `accounts[0]` (or Main Account), which you
    used to deploy the contract, using the `coinBalance` getter property, as seen
    in the previous sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: Then check the balance of all the other accounts in the same way. You’ll get,
    as expected, the balances shown in [table 8.2](#ch08table02).
  prefs: []
  type: TYPE_NORMAL
- en: Table 8.2\. Expected account balances
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Account address | Account balance |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0xedDE06bC0e45645e2f105972BDefC220ED37Ae10 | 10,000 |'
  prefs: []
  type: TYPE_TB
- en: '| 0x4e6C30154768b6bc3Da693b1B28C6bd14302b578 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 0x70e36bE8AB8f6Cf66C0C953cF9c63aB63f3FeF02 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 0xc99048E9B98D3FcF8b5f0D5644794B562f9A2ea4 | 0 |'
  prefs: []
  type: TYPE_TB
- en: 'Try to check, as you did in the wallet, the balance of an invalid address,
    again obtained by modifying the last digit of the Main Account address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: In this case, you won’t get the validation error that the wallet returned—it
    doesn’t allow you to enter invalid addresses—you’ll get a zero balance. This is
    because the `coin-Balance()` getter doesn’t perform any validation on the input
    address. (The wallet performs that validation instead.) It returns a valid balance
    for valid addresses contained in the `coinBalance` mapping, and the default `int256`
    value (`0`) for anything else.
  prefs: []
  type: TYPE_NORMAL
- en: 8.2.2\. Transferring coins
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The next operation you’ll perform is a coin transfer. Try moving 150 coins
    from the Main Account to `accounts[2]` through `SimpleCoin`’s `transfer()` function.
    To execute this, you also have to specify the maximum gas amount allowed for the
    operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: 'When you attempt this operation, you’ll get the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: 'You must unlock the Main Account to digitally sign the transaction, as you
    did earlier (replace, as usual, your `accounts[0]` password):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Warning
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Although I’m showing you how to unlock an account through the geth console,
    this isn’t entirely safe because the password is in clear text (it’s not encrypted)
    and each operation is logged in the console history. See the “Secure account unlocking”
    sidebar earlier in this chapter for more information.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: When you retry the transfer, the transaction will be successful, and you’ll
    get the transaction hash. In my case, I got
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: Recheck the balances of all of your accounts. You’ll get, as expected, the balances
    shown in [table 8.3](#ch08table03).
  prefs: []
  type: TYPE_NORMAL
- en: Table 8.3\. Expected new account balances
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Account address | Account balance |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0xedDE06bC0e45645e2f105972BDefC220ED37Ae10 | 9,850 |'
  prefs: []
  type: TYPE_TB
- en: '| 0x4e6C30154768b6bc3Da693b1B28C6bd14302b578 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 0x70e36bE8AB8f6Cf66C0C953cF9c63aB63f3FeF02 | 150 |'
  prefs: []
  type: TYPE_TB
- en: '| 0xc99048E9B98D3FcF8b5f0D5644794B562f9A2ea4 | 0 |'
  prefs: []
  type: TYPE_TB
- en: 'Now move 50 coins from `accounts[2]` to `accounts[1]` after unlocking `accounts[2]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: After getting the transaction hash, you can recheck the balances. You’ll get
    the balances shown in [table 8.4](#ch08table04).
  prefs: []
  type: TYPE_NORMAL
- en: Table 8.4\. Expected account balances
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Account address | Account balance |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0xedDE06bC0e45645e 2f105972BDefC220ED37Ae10 | 9,850 |'
  prefs: []
  type: TYPE_TB
- en: '| 0x4e6C30154768b6bc3Da693b1B28C6bd14302b578 | 50 |'
  prefs: []
  type: TYPE_TB
- en: '| 0x70e36bE8AB8f6Cf66C0C953cF9c63aB63f3FeF02 | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| 0xc99048E9B98D3FcF8b5f0D5644794B562f9A2ea4 | 0 |'
  prefs: []
  type: TYPE_TB
- en: Before we close this section, you’ll learn how to reference a contract that
    has already been deployed, such as `SimpleCoin`. First you’ll close the geth console
    and reattach it.
  prefs: []
  type: TYPE_NORMAL
- en: 8.2.3\. Referencing a running contract
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Close the interactive geth console and reattach it from the operating system
    command-line shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: 'As you’ll remember from the end of [section 8.1.2](#ch08lev2sec2), when you
    deployed `SimpleCoin` on TESTNET from the geth console, the console returned the
    contract address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: 'If you now want to interact with that deployed instance of `SimpleCoin` from
    the geth console, you must create a proxy to contract from its ABI and connect
    to the remote instance by feeding the address of the deployed contract to the
    `at()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **The abi interface from solc SimpleCoin output**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **Creates a proxy to the SimpleCoin contract**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **Connects to the instance of SimpleCoin deployed earlier**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting to a deployed contract from another contract is slightly different
    and is explained in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: '**Referencing a deployed contract from another contract**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re focusing on the interaction between a Web3.js client
    (such as the geth console or, as you’ll see later, the Node.js console or an HTML
    + JS web page) and a deployed Solidity contract. If you want to interact with
    a deployed Solidity contract from another Solidity contract, you’ll use a technique
    similar to the one you saw in the previous chapter for connecting to a deployed
    library from a contract:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: In this case, you define a local proxy contract as an abstract contract mirroring
    the public interface of the remote contract. Then you instantiate the proxy by
    feeding the address of the deployed remote contract to its constructor.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: 'To double-check that you’re truly connected to the previously deployed `SimpleCoin`
    instance, recheck the value of the `coinBalance` property against all accounts,
    starting from:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: You’ll get the balances shown in [table 8.5](#ch08table05).
  prefs: []
  type: TYPE_NORMAL
- en: Table 8.5\. Expected account balances
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Account address | Account balance |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0xedDE06bC0e45645e2f105972BDefC220ED37Ae10 | 9,850 |'
  prefs: []
  type: TYPE_TB
- en: '| 0x4e6C30154768b6bc3Da693b1B28C6bd14302b578 | 50 |'
  prefs: []
  type: TYPE_TB
- en: '| 0x70e36bE8AB8f6Cf66C0C953cF9c63aB63f3FeF02 | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| 0xc99048E9B98D3FcF8b5f0D5644794B562f9A2ea4 | 0 |'
  prefs: []
  type: TYPE_TB
- en: At this point, you can perform a new transfer operation; for example, move some
    coins from `accounts[2]` to `accounts[3]`. I leave it to you as an exercise.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ve learned how to deploy a contract on TESTNET from geth’s
    interactive console. Deploying on MAINNET, the production Ethereum network, is
    identical to deploying on TESTNET, except for needing real Ether to run transactions
    (to fund the gas consumed) on MAINNET.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have found command-based deployment through geth’s console inefficient
    and manually intensive: you had to compile the contract separately with the solc
    compiler, copy the ABI and bytecode manually from the compiler’s output, and paste
    them into some Web3 instructions. It’s possible to simplify deployment if you’re
    willing to change the toolset and start using Node.js instead of the geth interactive
    console. This is what we’ll explore in the next section.'
  prefs: []
  type: TYPE_NORMAL
- en: 8.3\. Simplifying command-based deployment with Node.js
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Node.js is a cross-platform runtime for developing server-side applications
    in Java-Script. If you’re not familiar with Node.js, the sidebar tells a little
    more about it. You might be wondering why Node.js is relevant for Ethereum development.
    It’s relevant because it can serve as an enhanced geth console that you can use
    to connect to the geth client and import many packages that will help improve
    and simplify your development efforts.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: '**Node.js**'
  prefs: []
  type: TYPE_NORMAL
- en: Node.js is a server-side runtime environment for JavaScript. It’s based on an
    event-driven architecture capable of handling asynchronous I/O. It includes a
    set of standard modules that are libraries of functions for networking (including
    TCP/IP, HTTP), binary data, file system I/O operations, data streams, and many
    others. You can create and distribute custom modules through the node package
    manager, also known as *npm*.
  prefs: []
  type: TYPE_NORMAL
- en: The platform has two main objectives. The first is to allow JavaScript developers
    to write server-side applications using their favorite language. The second is
    to provide a server-side web scripting environment with increased scalability
    through asynchronous programming rather than explicit multithreading.
  prefs: []
  type: TYPE_NORMAL
- en: You can download Node.js from [https://nodejs.org/](https://nodejs.org/).
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: If you haven’t already, I recommend you install the latest version of Node.js,
    if you can, or at least version 8.0 or higher. Once you’ve installed Node.js,
    it’s a good idea to install the Web3 module through the node package manager (npm),
    so you can reference it from any JavaScript code you run on Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: 8.3.1\. Installing Web3 and solc on Node.js
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before installing Web3, create a new folder, and initialize it for npm as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll be asked to set up various properties of the package.json file that
    the initialization command (`npm init`) is going to create. Set the name as simple_coin
    and the version as 1.0.0 and leave all the other fields blank:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: 'When asked to confirm whether the file being created is correct, type yes and
    press Enter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: 'Then you can install Web3 (version 0.20.4, as I have done), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll get output like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: 'To test that Web3 is working as expected, you can try to retrieve a list of
    your TESTNET accounts through the Node.js console. Before doing so, you must have
    a geth instance running. You have to open a separate OS console, start geth on
    TESTNET, and expose RPC and various RPC interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: Remember to also use the `–-bootnodes` option from earlier if the geth console
    seems stale.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now go back to the console you used to install the Web3 node package and start
    the interactive node console, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll see a node console prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: 'Then you can retrieve your TESTNET account addresses, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll get output like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: 'This confirms that Web3 is working as expected. Get out of the node console
    as follows (note the dot before `exit`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the OS prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: 'Then you can install the Solidity compiler solc (version 0.4.24, as I have
    done):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: Now you’re ready to create a deployment script to simplify the build and deployment
    process.
  prefs: []
  type: TYPE_NORMAL
- en: 8.3.2\. Building and deploying interactively through the Node.js console
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The best way to create a build and deployment script is to try to compile and
    deploy a contract interactively on the Node.js shell and then place the sequence
    of commands you’ve proved to work in a file. You can later execute this file as
    a single task.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, place SimpleCoin’s code from [listing 8.1](#ch08ex01) in the
    following file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: 'Now start the node console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: 'Then you can reference the node JavaScript packages you’ll be using, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **File system package**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **Solidity compiler package**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **Web3 package**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following command creates an instance of the web3 object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: 'Set the initial SimpleCoin supply that will be fed to the `SimpleCoin` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: 'Then you can set `account2` as the sender of the deployment transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: 'Load the source code of `SimpleCoin` and assign it to the `source` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: 'Then you can compile the contract and assign it to `compiledContract`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: 'Extract the ABI and bytecode from the compiled contract and assign them to
    two new variables (note that you must place `''0x''` before the bytecode):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: 'Assign the gas estimate to a variable after having increased it, so you make
    sure the transaction runs to completion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can create a contract factory (or generator) initialized with `SimpleCoin`’s
    ABI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: 'Before deploying the contract, unlock the account that will sign and send the
    deployment transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: 'You’re now ready to deploy the contract and instantiate it in a single operation
    with the `new()` function, which also takes two callbacks: one called after successful
    deployment, the other one in case of errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: 'In the meantime, observe the geth console (not the Node.js console!). You should
    see output similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, after a few seconds, in the Node.js console you should see something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: Well done! Now that you’ve managed to deploy the `SimpleCoin` contract through
    the node console, you can automate all the steps you performed interactively.
  prefs: []
  type: TYPE_NORMAL
- en: 8.3.3\. Creating a build and deployment script
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Copy all the commands you entered previously, collected in [listing 8.3](#ch08ex03),
    into the following file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: (Make sure you replace the password of your account 2 in the `senderPassword`
    assignment.)
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.3\. `SimpleCoin` Node.js deployment script
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can redeploy (and reinstantiate) `SimpleCoin` by running the script
    you’ve created from the OS command shell, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the same output as before on both the geth and Node.js consoles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: You can adapt this script easily to compile other contracts, or multiple contracts,
    as required.
  prefs: []
  type: TYPE_NORMAL
- en: 8.3.4\. Interacting with a contract from Node.js
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Once you’ve deployed the contract, you can interact with it through `simpleCoin-Instance`.
    For example, you can move some tokens from one account to another. Try to do this
    first interactively, so you can produce a script, as you did earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, reference the necessary JavaScript packages, as you did earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: 'Then also create a contract factory, as you did earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: 'Now assign the address of the `SimpleCoin` instance that you deployed interactively
    to an address variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: 'Then you can connect to that SimpleCoin instance with the `at()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: 'Now assign `accounts[1]` and `accounts[2]` to two variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: 'Then do the same for the related balances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: 'You can display these balances as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, unlock `account2` so you can sign and execute the transfer transaction
    from it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: 'Then you can execute the transfer transaction and assign its hash to a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: 'Poll the status of the transaction until completion as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: 'Then display information on the completed transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now update the values of the account balance variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you can display the new balances after the transfer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: Having proven that the commands you’ve entered work correctly, you can move
    them into a file called transferTokens.js. The code appears in the following listing.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.4\. transferTokens.js script, which transfers coins between two accounts
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: 'Run it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: Before I close the topic of deployment, in the next section you’ll learn how
    to deploy a contract on a private network. A private network is an Ethereum environment
    completely under your control.
  prefs: []
  type: TYPE_NORMAL
- en: 8.4\. Deploying on a private network
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A private network can be useful if, during development, you don’t want to deal
    with the delays involved in working with a public test network. For example, on
    the public test network, you generally have to wait a number of
  prefs: []
  type: TYPE_NORMAL
- en: minutes to mine Ether through CPU mining
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: minutes to resynchronize to the network, if you’ve disconnected and then reconnected
    after a few hours or days
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: seconds for contract deployment or transactions confirmation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Occasionally, when you reconnect after a few days, TESTNET doesn’t sync correctly
    due to major development or a fork that has happened in the meantime. In that
    case, you have to restart from scratch by deleting the whole blockchain stored
    on your node.
  prefs: []
  type: TYPE_NORMAL
- en: Another benefit of running against a private network is that you can efficiently
    test contracts whose logic depends on time-based expiration. Because contracts
    are isolated from external services, such as external clocks, you’ll commonly
    emulate time with a number of blocks, under the assumption that it takes around
    14 seconds to generate a new block.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a private network means starting up a custom blockchain, disconnected
    from the official Ethereum TESTNET or MAINNET blockchains. Before doing so, you
    should learn how geth manages the blockchain—how it records its history and what
    happens during synchronization.
  prefs: []
  type: TYPE_NORMAL
- en: 8.4.1\. How geth accesses the blockchain
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you start it up, geth looks at your Ethereum data folder before connecting
    to the network. As you know from [chapter 3](kindle_split_014.xhtml#ch03), when
    I presented the keystore, the Ethereum data folder is located in one of the following
    directories:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Windows: C:\Users\username\%appdata%\Roaming\Ethereum\'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Linux: ~/.ethereum/'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Mac: ~/Library/Ethereum/'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This folder contains the following folders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **The geth data folder for public production network**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **The keystore folder for public production network**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **Folder for the Ropsten public test network**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***4*** **Each test folder contains a geth data folder and a keystore folder.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***6*** **Folder for the Rinkeby public test network**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You already examined the content of the keystore back in [chapter 3](kindle_split_014.xhtml#ch03).
    Let’s have a look at the content of each geth folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **The chaindata folder contains the blockchain data files.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **The ethash folder contains data structure files necessary for mining.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **The nodes folder contains data about discovered network nodes.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As for the keystore, each geth folder is specific to a single network, so ethereum/geth
    and ethereum/testnet/geth contain completely different data. As a result, if you
    want to back up the blockchain and keystore for a specific environment, you need
    to take a copy of only the relevant geth and keystore folders.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: 8.4.2\. Setting up a private test network
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that you’ve learned where the public (test or main) blockchain is stored
    on your geth node, you’ll be able to understand more easily the steps needed to
    set up a test network. We’ll go through each of these steps in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a custom genesis file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a custom blockchain data folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose a name to identify your node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Launch geth with a custom configuration to generate the genesis block.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Launch geth with a custom configuration to run a private network node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the Etherbase account.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start mining to get Ether on the Etherbase account.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating a custom genesis file
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A blockchain starts from a master or *genesis* block that has no parent and
    seeds the chain. All nodes in your private network will have to reference the
    same genesis block to agree with each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new folder—for example, called C:\privatenetdev—and create within
    it a file called genesis.json. Then paste into it the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **Parameters to configure a specific Ethereum protocol version (Homestead,
    for example)**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **Identifier of the network being created**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **Protocol-specific parameters**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***4*** **Difficulty: how easy it is for a miner to find a valid nonce; the
    lower, the easier**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***5*** **Maximum gas limit allowed; the lower the limit, the more likely transactions
    can fail**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***6*** **You can preallocate Ether to specific addresses in this section.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The most important settings are explained in [table 8.6](#ch08table06).
  prefs: []
  type: TYPE_NORMAL
- en: Table 8.6\. Genesis file settings
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Setting | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| chainId | After you create this identifier, you can connect to the private
    network through it. |'
  prefs: []
  type: TYPE_TB
- en: '| difficulty | A higher value increases the number of attempts a mining node
    needs to perform before finding a valid nonce so it can add a new block to the
    blockchain. To give you an idea, a value of 4000, for example, makes mining easy
    because it allows any miner to generate a new block roughly every five seconds.
    You’d have to increment the difficulty value exponentially if you wanted a node
    to be able to generate a new block only every few minutes or hours. |'
  prefs: []
  type: TYPE_TB
- en: '| gasLimit | This is the maximum limit allowed for a transaction, regardless
    of the limit set on the transaction itself. The higher it is, the less likely
    it is that transactions will fail with the following error: “Error: exceeds block
    gas limit.” |'
  prefs: []
  type: TYPE_TB
- en: Creating a custom blockchain data folder
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Create a folder in a different area with respect to the standard Ethereum data.
    An example would be C:\privatenet.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing a name for the test node
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Assigning a name to the first node of your private network makes it easy to
    identify if you decide to add more nodes later on. For this example, try `PrivateNetMaster`.
  prefs: []
  type: TYPE_NORMAL
- en: Launching geth with custom configuration to generate the genesis block
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: So far, you’ve always started geth with the default configuration. At most,
    you’ve specified whether to start it against testnet, with the `--testnet` option,
    or in console mode, by specifying the `console` or `attach` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'To generate the custom genesis block of your private network, launch geth with
    the `init` command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: '[Table 8.7](#ch08table07) describes every option this geth launch command used.
    After launching geth, you should see output similar to that in the screenshot
    in [figure 8.3](#ch08fig03).'
  prefs: []
  type: TYPE_NORMAL
- en: Table 8.7\. The options used to start geth against a private network
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| geth option | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| --networkid | This identifies a specific Ethereum network. For example, TESTNET
    and MAINNET have their own networkid (default: 1, which is MAINNET). |'
  prefs: []
  type: TYPE_TB
- en: '| --identity | This is useful to identify a specific node of the private network.
    |'
  prefs: []
  type: TYPE_TB
- en: '| --rpc | This enables the JSON-RPC interface on the node (default: enabled).
    |'
  prefs: []
  type: TYPE_TB
- en: '| --rpcapi | You enable the API over RPC (default: web3). |'
  prefs: []
  type: TYPE_TB
- en: '| --datadir | The blockchain data folder |'
  prefs: []
  type: TYPE_TB
- en: '| --port | The network listening port other peers of the same network use to
    connect to this node |'
  prefs: []
  type: TYPE_TB
- en: '| --nodiscover | This disables discovery of the node by clients that are pointing
    to the same networkid and are referencing the same genesis block. You must add
    other nodes to this network manually. |'
  prefs: []
  type: TYPE_TB
- en: '| --maxpeers | The maximum number of peers allowed from this node. By setting
    it to zero, you explicitly state you’ll have only one node. If you need to add
    more network nodes, you must change this setting later. |'
  prefs: []
  type: TYPE_TB
- en: Figure 8.3\. The output from geth after generating the genesis block of your
    private network
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig08-03_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Launching geth with custom configuration to run a private network node
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Now that you’ve generated the genesis block, you can launch geth using the
    same parameters as before, except from the `init` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Tip
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You might have to close down any running geth instances pointing to MAINNET
    or TESTNET and/or any running wallet instance, depending on how you’ve configured
    port numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: If geth starts successfully, you should see a screen similar to the screenshot
    in [figure 8.4](#ch08fig04). You’ll notice the screen doesn’t show any progress—no
    blocks are being generated. I’m sure you know why. It’s because yours is the only
    node of the private network, and it’s not mining!
  prefs: []
  type: TYPE_NORMAL
- en: You don’t have any new accounts yet on your brand new blockchain. Before starting
    mining, you must create at least the Etherbase (or coinbase) account.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.4\. The output from geth after launching it against the private network
    you’ve created
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig08-04_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating the Etherbase account
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Attach to the private network node by opening a new command-line console and
    then launching geth attach as usual. When the geth console opens, it will display
    the name and data directory of your private network, respectively, in the `instance`
    and `datadir` output, which confirms you’re attached to the private network node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now create an account as you saw in [chapter 3](kindle_split_014.xhtml#ch03),
    [section 3.4.3](kindle_split_014.xhtml#ch03lev2sec15) (entering your own password
    in place of the text “PASSWORD OF ETHERBASE ACCOUNT”):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: 'You can set this account as an Etherbase account with the `setEtherbase` method
    of the `miner` object. Pass the address of the account you’ve created as an input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: 'Before starting to mine, you can create additional accounts. For the moment,
    create one more account. You’ll use it to interact with `SimpleCoin` on the private
    network (also here entering your own password instead of the text “PASSWORD OF
    ACCOUNT 2”):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: Start mining to get Ether on the Etherbase account
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'You can now start mining as you saw in the CPU mining section of [chapter 3](kindle_split_014.xhtml#ch03):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: Let the miner run for a few seconds and check the output from the main geth
    shell. You’ll see the DAG gets generated (see [chapter 3](kindle_split_014.xhtml#ch03),
    [section 3.3.4](kindle_split_014.xhtml#ch03lev2sec11) to refresh your memory on
    the DAG, if needed), as shown in the screenshot in [figure 8.5](#ch08fig05).
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.5\. As soon as you launch mining for the first time, the DAG gets generated.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig08-05_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you check the balance of the Etherbase account in the interactive shell,
    it will still be zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: After a few seconds you should see the first blocks being mined in the main
    geth shell, as shown in the screenshot in [figure 8.6](#ch08fig06).
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You might wonder where these initial blocks are coming from, as you haven’t
    submitted any transactions yet. A miner will always try to create a block even
    if no transaction is available in its memory pool. Creating an empty block is
    perfectly legal and can happen in periods of low transaction activity. As you
    know, though, a miner is encouraged to include in a block as many transactions
    as possible through the collection of transaction fees, so empty blocks are rare
    in practice and tend to appear mainly in private networks.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Figure 8.6\. After the DAG has been generated and the first blocks get created
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig08-06_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Etherbase balance will now show Ether (expressed in Wei)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: 'and you can stop the mining, if you want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: You’ve created your local private network. Now you can try to deploy `SimpleCoin`
    on it.
  prefs: []
  type: TYPE_NORMAL
- en: 8.4.3\. Deploying SimpleCoin on the private network
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Working on a private network is identical to working on a public network, so
    you should be able to deploy the contract by yourself. But you should check to
    make sure everything goes as expected. [Table 8.8](#ch08table08) shows the accounts
    you have in the private network.
  prefs: []
  type: TYPE_NORMAL
- en: Table 8.8\. Accounts in the private network
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Account | Address |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Main account | 0x3f9e54337cce348607b76200fc19f3f6e3e8e358 |'
  prefs: []
  type: TYPE_TB
- en: '| Account 2 | 0x336a008e3a3b099bcd125cd54fc193070fe1d177 |'
  prefs: []
  type: TYPE_TB
- en: 'Make sure account 2 has some Ether, so you can deploy from it. You can get
    some from the Main account, which has acquired Ether through mining:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now deploy from account 2 by running the script you created in [section
    8.3.3](#ch08lev2sec8) from the OS command shell, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: 'Although you don’t get any error messages, something seems to have gone wrong:
    the contract address appears as undefined. Remember, when you deployed on TESTNET,
    after a few seconds you got this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: But now you haven’t received confirmation of the contract address. If you check
    on the output of the main geth shell, you’ll see the screen hanging on
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: 'Think about what might be causing this problem. Yes, you’re right: no mining
    is taking place! To complete the deployment transaction, this needs to get mined.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go back to the geth interactive console and restart mining:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: '(Remember, earlier you stopped mining through `miner.stop().`) The expected
    completion message will appear immediately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: 'If you now inspect `simpleCoinInstance`, it contains the contract address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: Now that you’ve deployed the contract, if you want to save on electricity and
    keep your CPU cool, you can stop mining. Remember, though, that to interact with
    the contract, mining must be on; otherwise, transactions will never complete.
  prefs: []
  type: TYPE_NORMAL
- en: As an exercise, try to move some SimpleCoins from the Main Account to Account
    `2` while no mining is taking place, then check the coin balance of your two accounts.
    You’ll prove that the transaction will get completed only when you switch mining
    back on.
  prefs: []
  type: TYPE_NORMAL
- en: 8.5\. Making development more efficient by deploying on mock networks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although running a contract on a private network makes development relatively
    faster, especially if you configure the mining difficulty level appropriately,
    you still need to manage the private network correctly. For example, accounts
    you’re using for development or testing must have some Ether, even if only test
    Ether, to make sure you can execute transactions to completion. Also, at least
    one node of the test network must perform some mining continuously.
  prefs: []
  type: TYPE_NORMAL
- en: One way to improve the efficiency of your development cycle is to deploy your
    contract on a mock network. A mock network, such as Ganache, runs in-memory, generally
    on the developer computer, and emulates or bypasses, where applicable, all infrastructural
    aspects of an Ethereum network, such as account management, transaction costs,
    mining, and connectivity. By deploying your contract on Ganache, you can focus
    only on the development and testing of the functionality of your contract, and
    by doing so you can speed up your development cycle considerably. But once the
    contract is working as expected from a functional point of view, you still need
    to retest it within a private network and ultimately, on the public test network,
    to make sure the contract is also sound from an infrastructural point of view.
  prefs: []
  type: TYPE_NORMAL
- en: 8.5.1\. Installing and starting up Ganache
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'It turns out that installing and setting up Ganache is easier than setting
    up a private network: Ganache is written in JavaScript, it uses `Ethereumjs` to
    emulate client behavior, and it’s distributed as a Node.js package, which makes
    its installation easy.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming you have an instance of Node.js (you must have at least version 6.9.1
    at the time of writing), you can install Ganache with the Node.js console, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s it! Now you should stop geth if it’s running, and you can start Ganache
    from a new OS console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: On start-up, Ganache will list the accounts it’s going to support, as shown
    in the screenshot in [figure 8.7](#ch08fig07).
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.7\. Ganache accounts and related private keys, shown at startup
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig08-07_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 8.5.2\. Deploying SimpleCoin on Ganache
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Because Ganache is emulating the Ethereum network, you can’t use the geth console
    to deploy `SimpleCoin`’s contract on it. Your new console to the (mocked) Ethereum
    network is now the Node.js console.
  prefs: []
  type: TYPE_NORMAL
- en: Now you can deploy `SimpleCoin` exactly as you did when deploying on a public
    or private test network, as shown in the following listing, which has been adapted
    slightly for Ganache from [listing 8.3](#ch08ex03).
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.5\. Deploying SimpleCoinOnGanache.js
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: If you have a running geth instance, stop it. Make sure Ganache is running in
    a separate OS shell. Otherwise, start it again with
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: 'Then run the deployment script in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: 'In the meantime, observe the OS shell running Ganache. You should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: 'Then you should see this in the Node.js console almost immediately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: 'Can you spot the differences between deploying a contract on a public or private
    network and deploying it on Ganache? Yes, you’re right:'
  prefs: []
  type: TYPE_NORMAL
- en: Deployment on Ganache was instantaneous, whereas deployment on a network was
    performed with some latency.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You didn’t need to unlock the account deploying the contract, contrary to what
    you did when deploying on a public or private network.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here’s an exercise for you before we continue. Try transferring coins between
    two accounts on Ganache, either interactively or through a script.
  prefs: []
  type: TYPE_NORMAL
- en: 8.6\. Smoother interaction with SimpleCoin through a web UI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So far, you’ve been interacting with deployed Ethereum smart contracts through
    various development tools, as shown in [figure 8.8](#ch08fig08): manually through
    the Ethereum wallet and Remix (with the injected Web3 option) and through explicit
    Web3.js instructions from a geth console or a Node.js console. An end user can
    also interact with an Ethereum contract through Web3.js indirectly from a web
    UI. In this section, you’ll build a web UI for `SimpleCoin` and, as a result,
    complete a minimal end-to-end decentralized application for the first time.'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.8\. It’s possible to interact with Ethereum smart contracts through
    development tools such as the Ethereum wallet and Remix. Alternatively, you can
    perform contract operations through explicit Web3.js instructions issued from
    the geth console or the Node.js console. You can execute the same Web3.js instructions
    implicitly from an HTML web UI.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig08-08_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 8.6.1\. Building a minimalistic web UI for SimpleCoin
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To keep things simple, you’ll initially connect the web UI to an instance of
    `SimpleCoin` deployed on Ganache. If you’ve shut down Ganache, please start it
    up again and redeploy `SimpleCoin` on it, following the steps described in [section
    8.4.3](#ch08lev2sec12).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once `SimpleCoin` gets deployed, you should see, as before, a confirmation
    message similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Take a note of the contract address. You’ll need to place it in the JavaScript
    code you’ll be writing shortly.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: 'You can build a minimalistic web UI with a small piece of HTML referencing
    a Java-Script script that handles coin transfers between accounts. In short, you
    need to implement two files:'
  prefs: []
  type: TYPE_NORMAL
- en: simplecoin.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: simplecoin.html
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simplecoin.js
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The JavaScript code required to handle the coin transfers between accounts,
    shown in [listing 8.6](#ch08ex06), is similar to what you’ve already executed
    several times in this chapter—for example, what you saw earlier in [listing 8.2](#ch08ex02).
    Make sure you replace the address of the contract in [listing 8.6](#ch08ex06)
    with the one from the contract you deployed earlier on Ganache.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.6\. simplecoin.js
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: '***1*** **Replace this with the address of the SimpleCoin contract you just
    deployed on Ganache.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***2*** **Reports an updated account balance**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***3*** **Builds the HTML account balance table dynamically**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***4*** **All accounts are iterated to build the account balance HTML.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***5*** **Calls the coin balance getter**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***6*** **Gets the input from the UI and feeds it to the coin transfer contract
    function**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***7*** **Invokes the coin transfer contract function**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***8*** **The callback associated with a successful transfer refreshes the
    account balance table.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***9*** **Renders the account balance table on opening the page**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a folder on your machine, for example named C:\Ethereum\SimpleCoinWebUI.
    Within this folder, create a file called simplecoin.js and copy into it the code
    from [listing 8.6](#ch08ex06).
  prefs: []
  type: TYPE_NORMAL
- en: Simplecoin.html
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The HTML page required to collect the input and show the outcome of coin transfer
    operations is basic. It contains a few text boxes to gather the input and a button
    to trigger the transfer. Apart from the basic HTML, you need to reference the
    Web3.js and jQuery JavaScript libraries and the simplecoin.js script you just
    created. You can import Web3.js and jQuery locally with Bower ([https://bower.io/](https://bower.io/)),
    a package manager for building websites. Install Bower with npm as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: 'Now import the Web3.js and JQuery libraries in the current directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, Bower will have downloaded Web3 and jQuery into respective directories
    within the bower_components folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: You can now reference the JavaScript libraries as shown at the top of the following
    listing, which contains the entire HTML code you need.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.7\. simplecoin.html
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: Within the SimpleCoinWebUI folder, create a file called simplecoin.html. Copy
    into it the code from [listing 8.7](#ch08ex07).
  prefs: []
  type: TYPE_NORMAL
- en: 8.6.2\. Running the SimpleCoin web UI
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Open simplecoin.html with your browser. You’ll see the screen shown in [figure
    8.9](#ch08fig09).
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.9\. SimpleCoin web UI
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig08-09_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The screen shows the balance of all the accounts Ganache supports. As specified
    on the deployment script shown in [listing 8.5](#ch08ex05), `accounts[1]`, which
    is the contract owner, has 10,000 SimpleCoin tokens, and the other accounts have
    a nil balance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Performing a transfer through the UI is simple. Specify the source and destination
    address, respectively, in the From and To text boxes and the number of tokens
    you want to transfer in the Amount text box. Then click the Transfer button. As
    an exercise, perform this transfer:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From: 0xbb6ae4d3af3112374f570509347dd470866c1495'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To: 0x495961050c21bb2511f0550315aa9b070e90fa4e'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Amount: 150'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After you click Transfer, the `transfer()` contract function is invoked and,
    if the operation completes successfully, the associated callback (mapped to the
    local `refresh-AccountsTable()` JavaScript function) updates the account balances
    table, as you can see in [figure 8.10](#ch08fig10).
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.10\. The balance of the source and destination accounts have changed
    following a successful coin transfer.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![](Images/fig08-10_alt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Tools such as the Ethereum wallet and Remix allow you to deploy contracts and
    perform operations on them, but they hide the communication between the client
    and the Ethereum network.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can deploy contracts with explicit Web3.js instructions from geth’s console.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You also can execute contract operations through Web3.js instructions from geth’s
    console.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because of the limitations of geth’s console, deploying contracts and performing
    operations on them from it is a manually intensive and time-consuming process
    that isn’t easy to automate.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s easier to compile and deploy contracts from Node.js, which also allows
    you to completely automate build and deployment Web3.js scripts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can improve the development cycle by deploying contracts on a private Ethereum
    network completely under the control of the development team.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can further improve the development cycle by deploying contracts on a mock
    network, such as Ganache, which emulates accounts and bypasses high-latency operations
    such as mining.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s possible to execute contract operations from an HTML UI, through the same
    Web3.js instructions performed using a geth or Node.js console.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
