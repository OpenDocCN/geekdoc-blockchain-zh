- en: 1 Distributed ledger technologies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Distributed Ledger Technologies (DLTs) enable an innovative special form of
    electronic data processing and its memorizing. As the main part, a distributed
    ledger is a decentralized database that allows all the members of a concerned
    network to read and write data in it. Unlike centralized databases, no central
    instance allowing data writing and reading is needed here. Instead of having a
    centralized control, any network member can add data anytime, after which a process
    of data actualization follows. Each network member is provided with the newest
    up-to-date state of a database.
  prefs: []
  type: TYPE_NORMAL
- en: As DLTs reduce the cost of trust and revolutionize transactions between individuals,
    companies, and governments and minimize successful frauds, error possibility,
    and paper-intensive processes, they are considered a progressive technology of
    the future. They can have a crucial impact on society in every respect, especially
    in machine-to-machine (M2M) communications, one of the basic technologies for
    the Internet of Things (IoT). Besides providing security, privacy, and decentralized
    operation, DLTs stand for reliable, autonomous, and trusted IoT platforms now
    and in the future.
  prefs: []
  type: TYPE_NORMAL
- en: DLT follows a new data recording, sharing, and synchronizing method across multiple
    ledgers (data stores). A distributed ledger (DL) is a database that is independently
    created, maintained, and updated by each node (or participant) in a large network.
    All the records of a distributed ledger are shared and synchronized by consensus
    between nodes across the network. This happens without the help of any central
    authority. Consequently, each network node has its ledger copy, identical to others.
    Every time the ledger has to be updated with the new record(s), reaching a consensus
    results in getting identical copies on all nodes. This synchronization process
    is very fast, so that changes in a node’s ledger are copied into the ledgers on
    other nodes in just a few seconds (or perhaps minutes).
  prefs: []
  type: TYPE_NORMAL
- en: Cryptographic signatures are used to secure access to the ledger’s content,
    so that all DL data is accurate and safe. In many cases, to succeed in a cyberattack,
    an attacker has to target most DL copies simultaneously. Besides, if one or few
    copies are corrupted, the system as a whole will not be compromised.
  prefs: []
  type: TYPE_NORMAL
- en: Any node may create a data block with which the actual will be updated. Then,
    the information (created block) is broadcast across the network, after which other
    nodes check its validity through a consensus mechanism, that is, pre-defined validation
    method. After the community (i.e., a valid majority of network nodes) has validated
    a new block, each node, that is, participant, adds it to its copy of the ledger.
  prefs: []
  type: TYPE_NORMAL
- en: As for consensus mechanisms, there are several of them, such as a Proof of Work
    (PoW), Proof of Stake (PoS), Proof of Space (PoSpace), and so on. PoW can be the
    solution to a mathematical problem or puzzle or a suitable hash value found through
    the iterative execution of the appropriate hash function.
  prefs: []
  type: TYPE_NORMAL
- en: A consensus accomplished by PoS is a process in which a new block is validated
    only by the participants having enough high stakes, that is, by the rich members.
    They have many native tokens (cryptocurrency) of a concrete DL on their accounts.
    The PoS concept is based on the idea that the trustworthiness in the network (and
    in the value of token) decreases if everyone could perform block validations,
    which consequently increases the possibility of validation of illegitimate blocks.
    Hence, the only way of keeping the system’s trust is by leaving the block validation
    to in the members who might lose much money if acting in irresponsible ways. Regarding
    energy consumption, PoS is faster and more efficient than PoW (but less proven).
  prefs: []
  type: TYPE_NORMAL
- en: In the PoSpace concept, the available space (memory) on hard discs of the miners’
    computers is the resource used for mining (instead of computational power used
    with PoW). It is also called Proof of Capacity (PoC). Compared to PoW, this concept
    also saves time and energy. PoSpace is a good solution for anti-spam measures
    and the prevention of DoS attacks. It could also be useful in preventing the centralization
    of mining power in mining pools.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two types of DLs: public and private, depending on the peer-to-peer
    (P2P) network they rely on. Based on control by certain entities, there are also
    two types of DLs: permissionless and permissioned. In a permissionless DL, each
    node of the network hosts the full and freshest copy of the complete ledger. Every
    ledger update (addition of a new block) is communicated to all nodes in the network,
    which then collectively validate the new block by obeying a consensus mechanism.
    Having accepted the validation, a new block is added to each node’s copy of the
    ledger. Data consistency across the network is assured in that way. This means
    that a permissionless DL is fully democratic and with no central control, provided
    each participant follows the predefined rules. In a permissioned DL, however,
    a central entity grants the permissions to nodes for accessing the network and
    making changes to the ledger. At the same time, the central entity can also verify
    the identity of the participants who try to access the network.'
  prefs: []
  type: TYPE_NORMAL
- en: As there are a number of DLT applications that boost autonomous driving, this
    chapter will consider basic DLT architectures and their properties and several
    use cases of these technologies in the concept of autonomous vehicles.
  prefs: []
  type: TYPE_NORMAL
- en: 'Three basic DLT architectures will be considered for comparing DLT characteristics
    in the remaining part of the paper: chain or list, Directed Acyclic Graph (DAG)
    as a tangle, and DAG as a tree. A typical representative of the chain or list
    is a blockchain, which is the basis for the oldest and most widely used cryptocurrency
    – the Bitcoin (BTC), invented in 2008 by Satoshi Nakamoto [[1](9783110681123_008192.xhtml#b_9783110681130-005_ref_001)].
    DAG is a finite directed graph with no directed cycles and consists of many finite
    vertices and edges. Each edge is directed from one vertex to another but with
    no back loops. Tangle is a basis for IOTA, a cryptocurrency that is one of the
    main concurrences of the BTC, especially in the field of M2M communications. IOTA
    was founded in 2015 by David Sonstebo, Sergey Ivancheglo, Dominik Schiener, and
    Serguei Popov [[2](9783110681123_008192.xhtml#b_9783110681130-005_ref_002)] and
    has worked formally as IOTA Foundation since 2017\. DAG as a tree is the newest
    DLT architecture, which is the basis for the so-called hashgraph. Hashgraph is
    a data structure that records the data about who gossiped with whom and in which
    order. US professor Leemon Baird invented hashgraph in 2016 [[3](9783110681123_008192.xhtml#b_9783110681130-005_ref_003)].'
  prefs: []
  type: TYPE_NORMAL
- en: 1.1 Digital money – cryptocurrencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'DLTs are widely used in the financial sector as cryptocurrencies or crypto
    money. These days, the world is witnessing the true gold rush for cryptocurrencies.
    Many of those involved in the so-called easy money business related to DLTs understand
    how cryptocurrencies work. Still, others ask a simple question: “How is it possible
    to make real money from nothing?” Jokes are made comparing cryptocurrencies with
    some modern physicists’ hypothesis that the whole universe came from nothing.
    So, if this applies to the universe, why could it not be applied to cryptocurrencies,
    too?'
  prefs: []
  type: TYPE_NORMAL
- en: 'These are other most often asked questions: “How come the whole system is still
    functioning?,” “Is it a kind of fraud?,” “How long will it last?,” “Why do people
    believe in digital money when there is no supreme authority to guarantee it?,”
    “Is the whole thing and the euphoria related to this only one of the numerous
    economic bubbles with the growing mechanism based on human greed, with the inevitable
    final collapse?,” and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: And yet, many financial experts foresee a bright future of cryptocurrencies
    and a further evolution of DLTs. They say that they will enable numerous services
    such as absolute trust, security, and transparency, showing the way to the societies
    that have a high level of justice, without criminal and corruption, that is, to
    the societies that many utopists had only been dreaming of.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us remember some of the facts about money: the first forms of human transactions
    were in pieces of a material (e.g., copper, silver, or gold) which had a value
    by itself. For example, gold was (and still is) a precious metal due to its characteristics
    that make it suitable for various applications. For this reason, people believed
    (and they still do) that the value of gold can be exchanged for other goods, that
    is, used for trading, while being aware that it could be turned into a useful
    or a beautiful and valuable object. The keyword here is trust, that is, the faith
    in the value of the objects named coins or money.'
  prefs: []
  type: TYPE_NORMAL
- en: This faith in coins can be (and many times in history was) jeopardized by making
    coins with a certain (often unknown) percentage of other materials of lesser worth,
    making unfair trade and fraudulent behavior quite possible in that manner. The
    natural evolutionary step was to ensure a community where each used coin is worth
    the labeled value. Only a few powerful central authorities could have obtained
    such an assurance (e.g., emperors, kings, governments, and other community rulers).
    The guarantee mechanism was based on the monopoly of money production, the power
    and reputation of the authority, and the insurance measures (using advanced technology
    of the time) taken to make money difficult to forge by common people. Suppose
    the aforementioned conditions are fulfilled to some extent, it can be said that
    there is an informal agreement in the community that a given currency can be used
    for trading. The key terms related to real money that should be remembered, here,
    are central authority and its reputation.
  prefs: []
  type: TYPE_NORMAL
- en: Money is a dynamic category whose value can vary very much, depending on many
    factors (e.g., inflation). All conditions are not always needed for general consent
    on the money value. There were some specific circumstances (in history) in some
    places where central authority had not guaranteed the value of money. Still, the
    trust in the means of payment had been achieved due to the peculiarities or rareness
    of the things and objects found in nature, which had been used then for trading,
    for example, bear claws or shells.
  prefs: []
  type: TYPE_NORMAL
- en: An interesting example is the use of huge and immovable sacred stones as money
    in a few isolated Pacific islands. The stones had been changing hands after each
    transaction between tribe members. The ownership of each stone was carved on it
    as in a ledger (wordings show similarity with today’s ledgers).
  prefs: []
  type: TYPE_NORMAL
- en: It is useful to draw a parallel and note a distinction between cryptocurrency
    and paper money. Taken by itself, a piece of paper almost has no value. Yet, banknotes,
    pieces of paper have definite values as the central bank of a country, the authority
    which issued them, guarantees (by its assets or by the reserves in gold, or even
    by the reputation of their country), that each banknote can be changed for a piece
    of gold or another thing of a certain value. Each banknote should represent a
    certain amount of gold that the bank has saved in its vaults, and it was the case
    from the very beginning. But it is known that for a long time, many currencies
    (including the US Dollar, the British Pound, and the Euro) have no gold coverage
    – they are called fiat currencies. Despite this fact, these currencies are (more
    or less) concurrent and worthy at their markets. The trust in a currency generally
    depends on the strength of the country’s economy, reputation, and many other factors.
    The similarity between a cryptocurrency and a fiat currency is that their value
    is based on the trust in the system, while the mechanisms which keep that trust
    differ.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another new phenomenon has emerged in recent years: paper money and coins are
    not being used in many countries. Plastic or virtual money (through debit/credit
    cards and gadgets) is broadly adopted instead, now, and real money has its material
    representative, no more. Still, it is stored as information in the computer systems
    of banks holding the customers’ accounts. From their side, banks guarantee (with
    their reputation, as the recognized authorities) that the stored information on
    the account states of their customers are true.'
  prefs: []
  type: TYPE_NORMAL
- en: Taking into consideration all the above-exposed facts, we could think of cryptocurrencies
    as not so strange. Even more – they may look like the next natural evolutionary
    step in the story of money.
  prefs: []
  type: TYPE_NORMAL
- en: 1.2 Blockchain
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Blockchain is a reliable transaction register (or ledger) containing all transactions
    up to this very moment. It is a big and continuously growing file comprising a
    list of records called blocks (or blocks of transactions) where each block in
    the list is linked (i.e., chained) with the previous and the next block, using
    cryptography (see Fig. 1.1). The key conditions are that besides transaction data,
    each block has a header that contains a cryptographic hash of the previous block’s
    header, a timestamp that transactions relate to, and six other fields (if the
    Bitcoin blockchain [[1](9783110681123_008192.xhtml#b_9783110681130-005_ref_001)]
    is concerned; see [Fig. 1.2](#b_9783110681130-001_fig_002)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../graphic/converted/b_9783110681130-001_fig_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Fig. 1.1: BTC blockchain – line topology.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../graphic/converted/b_9783110681130-001_fig_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Fig. 1.2: Structure of a block and connection with the next block in the BTC
    blockchain.'
  prefs: []
  type: TYPE_NORMAL
- en: Let us suppose that a BTC blockchain (just one of the cryptocurrencies using
    blockchain technology) records all BTC transactions that people have ever made.
    In other words, blockchain is a financial book with precise and reliable data
    on all past transactions of money (between community members) from the very beginning.
    Or even simpler said – blockchain is a reliable transaction register (or ledger)
    that contains all transactions up to this very moment. It is a big and continuously
    growing file. For example, a BTC blockchain (each cryptocurrency has its blockchain,
    just like Bitcoin), now, has a few hundreds of GB and records all BTC transactions
    between people.
  prefs: []
  type: TYPE_NORMAL
- en: 'The key point of the whole system is that no one can ever delete or modify
    any of these transactions, and this is the main reason why blockchain has become
    a hot topic. It offers absolute permanency and reliability of the recorded data,
    so that no hacker can get into this blockchain database and change the fact that,
    for instance, John Smith possesses 20 BTCs. Such properties of BTC are accomplished
    by two most significant factors:'
  prefs: []
  type: TYPE_NORMAL
- en: Decentralization
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The algorithm for the verification of transactions, which is closely related
    to the blockchain structure
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The concept of decentralization is achieved when the list of all transactions
    (blockchain) is stored in many computers worldwide, where each of these computers
    (called nodes) contains a file of the complete blockchain (which should be identical
    to the blockchain file of any other node). Unlike centralized banking systems
    where each bank keeps customers’ transaction data on its servers (well protected
    and backed up), the nodes keeping a blockchain belong to ordinary people all over
    the world, who have accepted to take part in this DL voluntarily. There is neither
    a central authority nor a central register to keep data. People with node computers
    are mutually independent, except that their computers host the nodes that maintain
    a blockchain. Nodes are always connected using a protocol for inter-node communication,
    thus creating a global peer-to-peer (P2P) network. However, this network is like
    any other P2P network running over the Internet.
  prefs: []
  type: TYPE_NORMAL
- en: A fresh copy of the file of blockchain is kept on the disk of each node. Besides,
    some nodes (miners) can also verify the newest transactions (e.g., in BTCs) between
    any two people in the world. Furthermore, there are many other computers with
    only a transaction verification function. They are also called miners, although
    they are not nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us take the following example: A wants to send 100 EUR (in BTCs) to B:
    in the beginning, a computer (or a smartphone) of A announces to all miners in
    the network that A wants to transfer 100 EUR to B. At that moment, this is called
    an invalidated transaction, and it is not written into the register yet.'
  prefs: []
  type: TYPE_NORMAL
- en: The first thing for a miner to do next is check if A has enough money (at least
    100 EUR and something more for the provision). Now, the miner checks this by passing
    through the complete blockchain, seeing all transactions that person A has ever
    had, and calculating if there is enough money available. As there is no such category
    as the account state, the amount of money A possesses is always counted again,
    based on all the transactions A has ever had up to that moment. That is a very
    favorable trait, making the blockchain additionally safe. If one wanted to manipulate
    another person’s account, one would have to change the transactions from the past,
    which is impossible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having finished this (easier) first step, that is, the confirmation of A’s
    solvency, the second and more difficult step follows. There, miners compete with
    each other: the winner is the first one managing to embed the new transaction;
    that is, to append it to the end of the blockchain.'
  prefs: []
  type: TYPE_NORMAL
- en: Only one particular transaction has been mentioned so far (between person A
    and person B) as the single one, which should be validated and added to the blockchain.
    In reality, a block that is to be appended to the end of the BTC blockchain contains,
    on average, 1,500 transactions accumulated from around the world in ten minutes.
    In general, for different types of the blockchain (other than BTC blockchain),
    the frequency of appearance of new blocks is different, so there are blockchains
    where one block of transactions appears even every five seconds.
  prefs: []
  type: TYPE_NORMAL
- en: The transaction data of each block (of the BTC blockchain) consists of the latest
    valid transactions, whereby the size of the block is limited to 1 MB (although
    with the use of Segregated Witness protocol upgrade [[4](9783110681123_008192.xhtml#b_9783110681130-005_ref_004)]
    from August 2017, block limit has been extended to 4 MB, for practical purposes).
    The participants’ identities in a transaction are encrypted prior, using their
    private keys. All transactions in a block are hashed through a cryptographic scheme
    known as a hash tree or Merkle tree [[5](9783110681123_008192.xhtml#b_9783110681130-005_ref_005)].
    The 256-bit long result of hashing, that is, the root of the Merkle tree, is put
    into the block header as well.
  prefs: []
  type: TYPE_NORMAL
- en: The links between blocks make a blockchain practically unbreakable, as each
    block contains the hash value of the previous block’s header. The catch is in
    the 32-bit block header field named nonce (from number-used-once), the value of
    which all the miners in the world are trying to guess every ten minutes, to append
    a new block to the blockchain (and, consequently, to get a reward for the invested
    work, if successful). Once a new block is put to the blockchain, all the transactions
    from that block are considered verified, and miners immediately go on finding
    new nonce for the next block of transactions. The first miner who verifies these
    transactions by guessing the right value of nonce (in the previous block) gets
    a reward. With a BTC blockchain, the reward consists of two parts – the first
    is a transaction fee, paid in BTCs by money-transaction senders from the just
    verified block, and the second part is a certain amount of new BTCs generated
    from nothing.
  prefs: []
  type: TYPE_NORMAL
- en: What is the right value of nonce? There is no such value, that is, no tangible
    value has been set in advance. More specifically, the algorithm is designed, so
    that the goal to be achieved is to adjust the hash value of the last verified
    block header in blockchain to be small enough, that is, to be less than or equal
    to a given number (target). This practically means that this hash value, which
    is to be put in the header of the next (i.e., of the newest) block, begins with
    several zeros. The adjustment of the hash value is performed through an iterative
    process of incrementing the value of nonce and computing a new hash (of the complete
    block header) for each new nonce. The process stops when the currently computed
    hash satisfies the given condition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Knowing the properties of the cryptographic hash functions (in the case of
    BTC, SHA-256 algorithm is used, i.e., the hash is 256 bits long), it is obvious
    that the probability of guessing a hash with a given number of leading zeros is
    extremely small (in one attempt). If the goal (for a given level of difficulty)
    is to compute a hash where, for example, the first 72 bits are zeros (or in hexadecimal
    notation: hash = 00000000 00000000 00xxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx
    xxxxxxxx), and assuming a uniform distribution of hash values, the probability
    of success in one attempt would be 2^(−72) = 1/4,722,000,000,000,000,000,000\.
    With such a small probability, the time needed for a specialized mining computer
    (e.g., with the processing power of 16 Thash/s) to solely find the winning combination
    of nonce and hash would be more than nine years, by a rough estimate! Still, on
    average, a new block is being added to the blockchain every ten minutes. How is
    it achieved?'
  prefs: []
  type: TYPE_NORMAL
- en: The answer is in the enormous processing power obtained by the combined effort
    of the computers of all miners in the world. The precise number of BTC miners
    is difficult to be determined, as it is always changing, with a growing trend.
    When they are not mining BTCs, many of them use their computers for mining other
    cryptocurrencies as well, and a few are mining from time to time, for example,
    during the time intervals when a miner’s computer is not used for playing games.
    Eventually, the exact number of miners is not very important, as the processing
    powers of their computers are different. On the other hand, however, it all depends
    on the miners’ readiness to invest in hardware, together with all expenses for
    electric power, among others.
  prefs: []
  type: TYPE_NORMAL
- en: These days, a great number of miners are gathered in mining pools, as they are
    aware that mining solely is not profitable, because a block’s verification process
    would take an unacceptably long time. Mining pools are joint groups of miners
    that acquire advantages such as much more frequent verifications of transaction
    blocks. Miners from a pool share the rewards for successful verifications, proportional
    to the miners’ mining powers contributed to the pool. Apart from that, most BTC
    mining is done on the Application Specific Integrated Circuits (ASICs) in large,
    thermally-regulated data centers and warehouses with low-cost electricity. The
    owners of such warehouses rent the processing resources to miners.
  prefs: []
  type: TYPE_NORMAL
- en: As the world’s mining power is increasingly growing, the same is expected from
    the frequency of block verifications and the acceleration of BTCs’ issuance. But
    these have not happened yet, due to the applied algorithm known as Difficulty,
    which adjusts the difficulty level for solving the verification problem. The algorithm
    keeps the average block verification frequency almost constant. A new block is
    added to the blockchain every 10 min approximately, or more precisely – within
    two weeks, 2016 blocks should be added to the blockchain. Every two weeks, the
    algorithm changes the value of the block header field named Difficulty target
    ([Fig. 1.2](#b_9783110681130-001_fig_002)), according to the statistics of the
    total mining power and the number of transactions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The value of the 32-bit Difficulty target field corresponds (in a bit more
    complex way) to the difficulty of finding the hash, which is small enough to satisfy
    the condition for block verification. It has been mentioned earlier that the hash
    value written in the verified block must be less than or equal to a given value,
    called target_value (in [Fig. 1.3](#b_9783110681130-001_fig_003) named X). A reference
    value called difficulty_1_target is also defined to represent the 256-bit number,
    where the leading 32 bits are zero, the next 16 bits are one, and the rest are
    zero, or in hexadecimal notation:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="" altimg="../graphic/b_9783110681130-001_ineq_001.png"><mtable
    columnalign="right left" rowspacing=".5em" columnspacing="thickmathspace" displaystyle="true"><mtr><mtd><mi
    mathvariant="normal">d</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">f</mi><mi
    mathvariant="normal">f</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">c</mi><mi
    mathvariant="normal">u</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">t</mi><mi
    mathvariant="normal">y</mi><mi mathvariant="normal">_</mi><mn>1</mn><mi mathvariant="normal">_</mi><mi
    mathvariant="normal">t</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">r</mi><mi
    mathvariant="normal">g</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">t</mi><mo>=</mo></mtd><mtd><mn>00000000</mn><mi>f</mi><mi>f</mi><mi>f</mi><mi>f</mi><mn>0000</mn><mn>00000000</mn><mn>00000000</mn><mn>00000000</mn></mtd></mtr><mtr><mtd><mn>00000000</mn><mn>00000000</mn><mn>00000000</mn></mtd></mtr></mtable></math>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../graphic/converted/b_9783110681130-001_fig_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Fig. 1.3: Adding of a new block at the end of the BTC blockchain.'
  prefs: []
  type: TYPE_NORMAL
- en: (1.1)<math alttext="" altimg="../graphic/b_9783110681130-001_eq_001.png"><mo>=</mo><mi>f</mi><mi>f</mi><mi>f</mi><mrow><msub><mi>f</mi><mrow><mo
    stretchy="false">(</mo><mrow><mrow><mi mathvariant="normal">h</mi><mi mathvariant="normal">e</mi><mi
    mathvariant="normal">x</mi></mrow></mrow><mo stretchy="false">)</mo></mrow></msub></mrow><mo>×</mo><msub><mrow><msup><mn>2</mn><mrow><mn>208</mn></mrow></msup></mrow><mrow><mo
    stretchy="false">(</mo><mrow><mrow><mi mathvariant="normal">d</mi><mi mathvariant="normal">e</mi><mi
    mathvariant="normal">c</mi></mrow></mrow><mo stretchy="false">)</mo></mrow></msub><mo>=</mo><mrow><msup><mn>2</mn><mrow><mn>16</mn></mrow></msup></mrow><mo>×</mo><mrow><msup><mn>2</mn><mrow><mn>208</mn></mrow></msup></mrow><mo>=</mo><mrow><msup><mn>2</mn><mrow><mn>224</mn></mrow></msup></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'A parameter known as Difficulty is defined as:'
  prefs: []
  type: TYPE_NORMAL
- en: (1.2)<math alttext="Difficulty=difficulty_1_target∕target_value" altimg="../graphic/b_9783110681130-001_eq_002.png"><mrow><mrow><mi
    mathvariant="normal">D</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">f</mi><mi
    mathvariant="normal">f</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">c</mi><mi
    mathvariant="normal">u</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">t</mi><mi
    mathvariant="normal">y</mi><mo>=</mo><mi mathvariant="normal">d</mi><mi mathvariant="normal">i</mi><mi
    mathvariant="normal">f</mi><mi mathvariant="normal">f</mi><mi mathvariant="normal">i</mi><mi
    mathvariant="normal">c</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">l</mi><mi
    mathvariant="normal">t</mi><mi mathvariant="normal">y</mi><mi mathvariant="normal">_</mi><mn>1</mn><mi
    mathvariant="normal">_</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">a</mi><mi
    mathvariant="normal">r</mi><mi mathvariant="normal">g</mi><mi mathvariant="normal">e</mi><mi
    mathvariant="normal">t</mi><mrow><mo>/</mo></mrow><mi mathvariant="normal">t</mi><mi
    mathvariant="normal">a</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">g</mi><mi
    mathvariant="normal">e</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">_</mi><mi
    mathvariant="normal">v</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">l</mi><mi
    mathvariant="normal">u</mi><mi mathvariant="normal">e</mi></mrow></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, it shows how many times it is more difficult to find a hash below the
    current target value than to find a hash below difficulty_1_target. The Difficulty
    is a floating-point value, and in the Difficulty target field of the block header,
    it is represented by exponent and mantissa of the target_value, where the first
    8 bits are exponent. The rest of the 24 bits are mantissa. If, for example, target_value
    (in hexadecimal notation) is “17**2*f*4*f*7*b***”, the following predefined formula
    should be used to calculate the target_value of hash:'
  prefs: []
  type: TYPE_NORMAL
- en: target_value = <math alttext="" altimg="../graphic/b_9783110681130-001_ingr_002.png"><mrow><mn
    mathvariant="bold">2</mn><mi mathvariant="bold">f</mi><mn mathvariant="bold">4</mn><mi
    mathvariant="bold">f</mi><mn mathvariant="bold">7</mn><mi mathvariant="bold">b</mi></mrow><mo>⋅</mo><msub><mrow><msup><mn>2</mn><mrow><mn>8</mn><mo>⋅</mo><mfenced
    open="(" close=")"><mrow><mn>17</mn><mo>−</mo><mn>3</mn></mrow></mfenced></mrow></msup></mrow><mrow><mfenced
    open="(" close=")"><mrow><mi>h</mi><mi>e</mi><mi>x</mi></mrow></mfenced></mrow></msub><mo>=</mo></math>
  prefs: []
  type: TYPE_NORMAL
- en: (1.3)<math alttext="" altimg="../graphic/b_9783110681130-001_eq_003.png"><mtable
    columnalign="right left" rowspacing=".5em" columnspacing="thickmathspace" displaystyle="true"><mtr><mtd><mn>00000000</mn><mn>00000000</mn><mn>00</mn><mrow><mn
    mathvariant="bold">2</mn><mi mathvariant="bold">f</mi><mn mathvariant="bold">4</mn><mi
    mathvariant="bold">f</mi><mn mathvariant="bold">7</mn><mi mathvariant="bold">b</mi></mrow><mn>00000000</mn><mn>00000000</mn></mtd></mtr><mtr><mtd><mn>00000000</mn><mn>00000000</mn><mn>00000000</mn></mtd></mtr></mtable></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'and using (1) and (2) we have the result for Difficulty (in decimals):'
  prefs: []
  type: TYPE_NORMAL
- en: (1.4)<math alttext="" altimg="../graphic/b_9783110681130-001_eq_004.png"><mrow><mrow><mi
    mathvariant="normal">D</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">f</mi><mi
    mathvariant="normal">f</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">c</mi><mi
    mathvariant="normal">u</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">t</mi><mi
    mathvariant="normal">y</mi><mo>=</mo><mn>5</mn><mo>,</mo><mn>949</mn><mo>,</mo><mn>437</mn><mo>,</mo><mn>371</mn><mo>,</mo><mn>609</mn></mrow></mrow><mrow><mrow><mn>.53</mn></mrow></mrow><mo>≈</mo><mrow><mrow><mn>5</mn></mrow></mrow><mrow><mrow><mn>.95</mn><mo>×</mo><mn>1</mn></mrow></mrow><mrow><msup><mrow><mrow><mn>0</mn></mrow></mrow><mrow><mrow><mrow><mn>12</mn></mrow></mrow></mrow></msup></mrow><mfenced
    open="(" close=")"><mrow><mrow><mrow><mi mathvariant="normal">o</mi><mi mathvariant="normal">r</mi><mn>5</mn></mrow></mrow><mrow><mrow><mn>.95</mn><mi
    mathvariant="normal">T</mi></mrow></mrow></mrow></mfenced></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'The number of leading binary zeros in the target_value of hash can be calculated
    from Difficulty as:'
  prefs: []
  type: TYPE_NORMAL
- en: (1.5)<math alttext="Numberofleadingzeros=log2(Difficulty)+32" altimg="../graphic/b_9783110681130-001_eq_005.png"><mrow><mtext>Number</mtext><mtext>of</mtext><mtext>leading</mtext><mtext>zeros</mtext><mo>=</mo><msub><mrow><mi>log</mi></mrow><mn>2</mn></msub><mrow><mo>(</mo><mrow><mtext>Difficulty</mtext></mrow><mo>)</mo></mrow><mo>+</mo><mn>32</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the result is 74.44\. This can also be seen from the hexadecimal
    representation of target_value in (3), where the first 18 nibbles (4-bit blocks)
    represent 72 binary zeros, and the next nibble 2[(hex)] = 0010[(bin)] adds two
    more zeros, which, on the whole, gives 74 leading zeros.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we want to assure that a block is verified every 10 min. In that case,
    Difficulty should be tuned relative to the computational power of the entire Bitcoin
    network, so that it can make a targeted number of calculations per second needed
    for achieving of the goal that average time for finding a hash below or equal
    to target_value is ten minutes. This number of hash operations per second (known
    as hash power or hash rate) can be derived and calculated from Difficulty as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: (1.6)<math alttext="" altimg="../graphic/b_9783110681130-001_eq_006.png"><mrow><mrow><mi
    mathvariant="normal">H</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">s</mi><mi
    mathvariant="normal">h</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">a</mi><mi
    mathvariant="normal">t</mi><mi mathvariant="normal">e</mi></mrow></mrow><mo>=</mo><mrow><mfrac><mrow><mfenced
    open="{" close="}"><mrow><mi>N</mi><mfenced open="(" close=")"><mrow><mrow><mrow><mi
    mathvariant="normal">D</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">f</mi><mi
    mathvariant="normal">f</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">c</mi><mi
    mathvariant="normal">u</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">t</mi><mi
    mathvariant="normal">y</mi></mrow></mrow></mrow></mfenced></mrow></mfenced></mrow><mrow><mn>10</mn><mi>m</mi><mi>i</mi><mi>n</mi></mrow></mfrac></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'where {*N*(Difficulty)} is the expected number of hash attempts (for a given
    Difficulty) before finding a valid hash:'
  prefs: []
  type: TYPE_NORMAL
- en: (1.7)<math alttext="" altimg="../graphic/b_9783110681130-001_eq_007.png"><mfenced
    open="{" close="}"><mrow><mi>N</mi><mfenced open="(" close=")"><mrow><mrow><mrow><mi
    mathvariant="normal">D</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">f</mi><mi
    mathvariant="normal">f</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">c</mi><mi
    mathvariant="normal">u</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">t</mi><mi
    mathvariant="normal">y</mi></mrow></mrow></mrow></mfenced></mrow></mfenced><mo>=</mo><mrow><mfrac><mrow><mrow><msup><mn>2</mn><mrow><mn>256</mn></mrow></msup></mrow></mrow><mrow><mrow><mrow><mi
    mathvariant="normal">t</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">r</mi><mi
    mathvariant="normal">g</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">t</mi></mrow></mrow><mi
    mathvariant="normal">_</mi><mrow><mrow><mi mathvariant="normal">v</mi><mi mathvariant="normal">a</mi><mi
    mathvariant="normal">l</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">e</mi></mrow></mrow></mrow></mfrac></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'By combining (2), (6), and (7), we have:'
  prefs: []
  type: TYPE_NORMAL
- en: (1.8)<math alttext="" altimg="../graphic/b_9783110681130-001_eq_008.png"><mrow><mrow><mi
    mathvariant="normal">H</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">s</mi><mi
    mathvariant="normal">h</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">a</mi><mi
    mathvariant="normal">t</mi><mi mathvariant="normal">e</mi></mrow></mrow><mo>=</mo><mrow><mfrac><mn>1</mn><mrow><mn>10</mn><mi>m</mi><mi>i</mi><mi>n</mi></mrow></mfrac></mrow><mo>⋅</mo><mrow><mfrac><mrow><mrow><msup><mn>2</mn><mrow><mn>256</mn></mrow></msup></mrow></mrow><mstyle
    displaystyle="true"><mrow><mrow><mfrac><mrow><mrow><mrow><mi mathvariant="normal">d</mi><mi
    mathvariant="normal">i</mi><mi mathvariant="normal">f</mi><mi mathvariant="normal">f</mi><mi
    mathvariant="normal">i</mi><mi mathvariant="normal">c</mi><mi mathvariant="normal">u</mi><mi
    mathvariant="normal">l</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">y</mi></mrow></mrow><mi
    mathvariant="normal">_</mi><mn>1</mn><mi mathvariant="normal">_</mi><mrow><mrow><mi
    mathvariant="normal">t</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">r</mi><mi
    mathvariant="normal">g</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">t</mi></mrow></mrow></mrow><mrow><mrow><mrow><mi
    mathvariant="normal">D</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">f</mi><mi
    mathvariant="normal">f</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">c</mi><mi
    mathvariant="normal">u</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">t</mi><mi
    mathvariant="normal">y</mi></mrow></mrow></mrow></mfrac></mrow></mrow></mstyle></mfrac></mrow><mo>=</mo><mrow><mfrac><mn>1</mn><mrow><mn>600</mn><mi>s</mi></mrow></mfrac></mrow><mo>⋅</mo><mrow><mfrac><mrow><mrow><msup><mn>2</mn><mrow><mn>256</mn></mrow></msup></mrow></mrow><mrow><mrow><msup><mn>2</mn><mrow><mn>224</mn></mrow></msup></mrow></mrow></mfrac></mrow><mo>⋅</mo><mrow><mrow><mi
    mathvariant="normal">D</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">f</mi><mi
    mathvariant="normal">f</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">c</mi><mi
    mathvariant="normal">u</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">t</mi><mi
    mathvariant="normal">y</mi></mrow></mrow><mo>=</mo><mrow><mrow><mi mathvariant="normal">D</mi><mi
    mathvariant="normal">i</mi><mi mathvariant="normal">f</mi><mi mathvariant="normal">f</mi><mi
    mathvariant="normal">i</mi><mi mathvariant="normal">c</mi><mi mathvariant="normal">u</mi><mi
    mathvariant="normal">l</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">y</mi></mrow></mrow><mo>⋅</mo><mrow><msup><mn>2</mn><mrow><mn>32</mn></mrow></msup></mrow><mrow><mo>/</mo></mrow><mn>600</mn><mi>s</mi></math>
  prefs: []
  type: TYPE_NORMAL
- en: For example, if Difficulty = 5.95 T, using (1.8), the hash rate is 42,587,731,567,771,
    900,000 hashes/s, that is, 42.6 Exahash per second (42.6 EH/s). With the same
    Difficulty, a computer with 16 TH/s processing power should be mining for around
    50 years to find a solution (time = 600s × 42.6EH/s / 16TH/s).
  prefs: []
  type: TYPE_NORMAL
- en: 'This huge Difficulty makes it easier to find a particular sand grain among
    all of Earth’s sand grains than to find a successful hash. Mining pools can find
    a solution in about ten minutes due to their appropriate hash power. However,
    the disadvantage is the enormous consumption of (electric) energy. Currently,
    the total power spent by all Bitcoin miners in the world equals the energy consumption
    of a developed country. So, a logical question comes up: Why is it all necessary?
    Why the mining algorithm is designed that way, that is, with the artificially
    added computational difficulty?'
  prefs: []
  type: TYPE_NORMAL
- en: 1.2.1 Concept of proof of work
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The answer to the previous questions and to how new BTCs are issued can be found
    in the applied concept, PoW. The PoW concept is used for maintaining blockchain
    (DL) consistent, strong and unbreakable, which are key factors that create trustworthiness
    of the whole system and consensus in the community about the real value of cryptocurrency.
  prefs: []
  type: TYPE_NORMAL
- en: The concept of PoW is not new. It has been used in computer networks with client–server
    mechanisms as a measure to discourage Denial of Service (DoS) attacks and other
    abuses such as spam. The main property of PoW is its asymmetry – a client’s relatively
    hard work when compared to the ease with which the result can be checked by a
    server. In the case of a BTC blockchain, the result of the very difficult job
    of finding a valid nonce-hash pair by a successful miner (i.e., mining pool) is
    very easily confirmed by other miners.
  prefs: []
  type: TYPE_NORMAL
- en: It has already been mentioned that the trustworthiness of the BTC also contributed
    to the decentralization of the blockchain. Let us remember that the BTC blockchain,
    as a DL of transaction blocks is realized using nodes, that is the computers connected
    to the BTC P2P network. BTC full nodes are the computers running the BTC Core
    client with the complete blockchain. A transaction is a process of sending BTCs
    from the BTC wallet (i.e., address) of a sender to the BTC wallet of a person
    who receives money. Money senders broadcast transactions to the network. Full
    nodes validate transactions and relay them to other nodes by broadcasting messages
    across the network. Within this decentralized infrastructure (P2P network), a
    set of miners collect transaction records, verify that each transaction is signed
    correctly and is not in conflict with previous transactions. They also check that
    the sender (whose identity is hidden behind an address) does not move more BTCs
    than is contained in the address (passing through the entire blockchain) and perform
    other functions.
  prefs: []
  type: TYPE_NORMAL
- en: Each miner independently collects valid transactions and aggregates them into
    a candidate block. Then, a miner attempts to solve his candidate block through
    the PoW, that is, through the process of finding a valid hash (as described in
    Section 1.2). The first miner who successfully solves a candidate block broadcasts
    his solution to the network (including other miners) to be added to the blockchain.
    The key thing here is that the new block will be added to the blockchain only
    if more than 50% of miners say it has been solved correctly. And before saying
    that, miners have to make their calculations on the solved block, comparing their
    results to the solution that was broadcast. Two different candidate blocks may
    be solved at about the same time. In that situation, two solutions will propagate
    through the network (this situation is known as a blockchain fork). Still, eventually,
    only one will win, that is, it will be added to the blockchain (the first accepted
    by most miners). At the same time, the other solved block (the orphan) will stale,
    and the transactions from this block (the ones which are not included in the winning
    block) will wait for the next round, to be collected and verified within some
    of the forthcoming candidate blocks. The triggering moment for the decision of
    which of two solutions will win is after about 10 min, when the next block is
    added the first time (somewhere in the network) on top of the winning block. Then,
    the newly added block will be broadcast as the solution (where the previous winning
    block is included in the blockchain). The community will quickly accept it, assuming
    that the last added block was the only offered solution at the moment, which is
    the most common case.
  prefs: []
  type: TYPE_NORMAL
- en: Having received the news that the candidate block has been solved, a miner should
    only verify that the solution is correct, as the solution is already known. However,
    although a solved block can be added to the blockchain only if it is verified
    by at least 50% of miners, they do not have to verify it. A miner first decides
    whether it should wait to verify the block before starting on the next block or
    start immediately with solving the next block, assuming the previous block was
    correct. The benefit of making the assumption is that there will not be any wasted
    time spent on verification, which increases the profit by about 10%. As a result,
    many large mining pools skip this verification process and, just using the newly
    appended blockchain, immediately start working on the next block.
  prefs: []
  type: TYPE_NORMAL
- en: Using a procedure involving PoW and the consensus of more than half of the participants,
    the so-called trustless truth is accomplished. Trustless truth is a term that
    denotes the state of a community where there is a consensus about something (here,
    about the trust in the BTC), whereby no one trusts anyone. Nevertheless, just
    because of this overall distrust, a set of rules (or a mechanism like PoW) is
    imposed on all participants. Eventually, everyone is confident about some common
    thing of interest.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the BTC blockchain is such a giant and reliable data structure,
    just because of the huge amount of computational work needed for its growth. This
    work (due to general distrust) must be proven through PoW and verified by the
    majority of miners. If someone tried to change (i.e., forge) some of the previous
    transactions, just to change the state of someone’s digital wallet, he would have
    to create a new consistent version of the blockchain (with one changed block).
    It would have to pass the verification process by the miners’ community. Changing
    a block inside the blockchain (which can only be done by making a new block containing
    the same predecessor) requires regenerating all successor blocks and redoing all
    the work they contain. This is practically impossible due to the tremendous work
    the forger would have to do, on its own. The more blocks in the blockchain after
    the targeted block there are, the more difficult it is to create some other version
    of the blockchain, which the targeted block tampers with. In this way, a decentralized
    system with incorporated trustless truth mechanisms gains the reputation of the
    monetary authority that only some centralized monetary institutions, for example,
    central banks in various countries enjoy,. Furthermore, the BTC has become a global
    monetary system that is not under the control of any government or any central
    authority.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from decentralization and PoW mechanism, the reason for such a sustainable
    development and value for the BTC also lies in the monetary policy, that is, in
    the policy of BTC issuance. It is the main motivating factor (the incentive) for
    the army of miners worldwide to do the transaction verification job. Although
    it seems now that every 10 min, a new number of BTCs appears out of thin air in
    the ever continuing process of block solving, the BTC, still, has no inflationary
    character – that is, the total amount of BTCs is limited by its design, which
    is why it is often called digital gold.
  prefs: []
  type: TYPE_NORMAL
- en: 'BTC is the oldest and most known digital currency launched on the Internet
    in 2009\. Now, it cannot exceed a total amount of 21 million (precisely: 20,999,999.9769
    BTC). In the beginning, the reward for solving the block was 50 BTC, and the Difficulty
    of the opening blocks in the blockchain was 1, that is, the hashes were with only
    8 leading binary zeros. As said before, the Difficulty of block solving adjusts
    every 2016 blocks, that is, about every 14 days, depending on the miners’ total
    computation power. The BTC block reward halves every 210,000 blocks. Currently,
    the reward is 6.25 BTC and was last halved from 12.5 BTC with block 630,000 on
    May 27, 2020\. Many miners may leave the job after that because of their reduced
    profit, but on the other hand, with miners’ reduced power, the Difficulty will
    be reduced accordingly. Consequently, less electricity will be required to mine
    each new BTC.'
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, let us point out that by the year 2032, almost all BTCs will have been
    mined when the reward would drop below 1 BTC, and the only incentive of the miners
    (if anyone remains) will be the transaction fees. But it is not possible to have
    precise predictions about the BTC’s future and survival by that time, after all.
  prefs: []
  type: TYPE_NORMAL
- en: 1.2.2 Vulnerabilities of the BTC and issues handling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Even before the BTC, there had been attempts to create sustainable digital money.
    All the attempts had failed because there were no reliable mechanisms to successfully
    prevent scenarios in which transactions are copied and spent (i.e., realized)
    twice. It is good to know that the BTC successfully solves this double-spending
    problem through the blockchain concept with PoW, where each transaction is time-stamped.
  prefs: []
  type: TYPE_NORMAL
- en: A double-spending problem appears if two transactions (one of which is tricky)
    are sent into the network using the same private key (of a fraudulent money sender)
    to different receiving addresses. As these two transactions propagate through
    the network, one part of the network will accept one transaction and the other
    part, another. The defense mechanism inherent in the BTC blockchain is that only
    the transaction that miners first resolve into the next block (by any of two network
    parties) will be verified. The other one will be rejected as invalid. Such a confirmation
    mechanism through which the BTC manages the double-spending problem is enabled
    by a chronologically ordered, time-stamped transaction ledger, that is, by the
    blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: The other breakthrough incorporated in the BTC is the use of PoW as a probabilistic
    solution to the class of failures known as the Byzantine Generals Problem [[6](9783110681123_008192.xhtml#b_9783110681130-005_ref_006)],
    which is a generalized version of the Two Generals’ Problem. It can be said that
    the BTC P2P network as a distributed system is Byzantine fault-tolerant (BFT).
  prefs: []
  type: TYPE_NORMAL
- en: The Byzantine Generals Problem can be presented, in a nutshell, through the
    situation in which more generals (each with his army) have to reach a consensus
    about the time of the attack in the forthcoming battle against the surrounded
    enemy. If they don’t attack all together simultaneously, that is, if a few generals
    issue the order for attack and other generals do not, the enemy will overcome
    the armies that have attacked, gain strategic advantage, and eventually win the
    battle. Generals communicate to one another via messengers, that is, each general
    forwards a received message to the nearest few generals, depending on their spatial
    positions on terrain. The initial message with the information on the time of
    the attack is sent from the chief general to the few nearest generals and then
    relayed to the others. The problem occurs if some of the generals (the traitors)
    alter the received message and forward the messages with a different time of attack
    to other generals. This will lead to an unsynchronized attack and, eventually,
    to defeat in the battle. Since loyal generals do not know who the possible traitors
    are, they must create a communication protocol and the decision rules. These must
    ensure that, in a situation where some generals have received two or more messages
    with different times of attack, only the right message is accepted by all, and
    the false ones are rejected. It is shown [[7](9783110681123_008192.xhtml#b_9783110681130-005_ref_007)]
    that this problem can only be solved if the number of traitorous generals does
    not exceed one-third of all generals.
  prefs: []
  type: TYPE_NORMAL
- en: When talking about the Byzantine Generals Problem in the context of distributed
    systems (such as the BTC P2P network), this problem concerns the corrupted components
    of the system having the symptoms that prevent other system’s components from
    reaching an agreement among them (i.e., consensus). Such an agreement is needed
    for the correct operation of the system. Byzantine fault assumes any fault that
    causes a component to present different symptoms to different parts of the system.
    A Byzantine fault tolerance (BFT) system can accomplish its correct functioning
    if there are not too many faulty components, that is, if, at most, one-third of
    all components are faulty. BFT systems often include PoW as the mechanism to combat
    false pieces of information from corrupted components.
  prefs: []
  type: TYPE_NORMAL
- en: If we want to translate the Byzantine Generals Problem into a BTC environment,
    we can have a situation with a solved candidate block. Having found the solution,
    the miner adds the block to the blockchain (say, the *n*-th block) and broadcasts
    it to other nodes. Then, other nodes check the received blockchain with the added
    *n*-th block. Having done it and confirming the nonce, each miner adds this new
    block to the top of its copy of the blockchain. When the other miners continue
    adding the next solved blocks about every 10 min (i.e., blocks *n *+ 1, *n *+ 2,
    … ) on top of block *n*, that block becomes solidified. The latest block on the
    top of the blockchain is usually unstable, but once there are more blocks on top
    of it, it is said to be more guaranteed. As each new block is difficult to add
    (because of PoW), a block within the blockchain is said to be secure after one
    hour approximately, that is, when six blocks are added after it. This is why most
    cryptocurrency exchanges and other services that accept Bitcoin usually wait for
    the so-called six blocks confirmation.
  prefs: []
  type: TYPE_NORMAL
- en: The last added block in the blockchain is considered unstable because it is
    quite possible (but not very often) that at that time, some other miner can find
    another solution and thus cause a fork in the blockchain. In this situation, the
    blockchain is split into two competing paths forward. Forks in a BTC blockchain
    appear regularly, and so far, each fork has been quickly resolved when an additional
    block was added to one of these two arms of the blockchain (which was lucky to
    be first prolonged). At the same time, the entire network abandons the block from
    the other arm (the orphan) since the winning arm contains more PoW. Hypothetically,
    if a fork remains unresolved, two competing blockchain histories would co-exist,
    compromising the whole system.
  prefs: []
  type: TYPE_NORMAL
- en: Theoretically, the Byzantine Generals Problem could appear if several miners
    or a mining pool do not follow the generally accepted rules when new blocks are
    added – namely, a very powerful attacker could try to troll the BTC community
    by adding enough hash power and outperforming the entire hash power of the network
    (the so-called “51% attack” [[8](9783110681123_008192.xhtml#b_9783110681130-005_ref_008)]).
    One could try to impose their version of a blockchain, that is, initiate forking
    so that the last few (still unsolidified) blocks in the blockchain are replaced
    by some other blocks (in the new branch of the blockchain). These blocks might
    contain false transactions that nullify the transactions from the regular blockchain
    branch (causing double-spending) or corrupt the blockchain in another way. The
    attacker’s version of the blockchain will be propagated through the network and
    accepted by the rest of the miners’ community only if it contains more PoW than
    the regular version. This could happen only if the attacker owns a computing power
    sufficient to solve six consecutive blocks in a row (i.e., faster than the rest
    of miners). The probability of such an event in a given time becomes almost 100%,
    as the attacker’s hash power comes closer to 50% of the total mining power [[9](9783110681123_008192.xhtml#b_9783110681130-005_ref_009)].
    In 2014, six blocks were solved in a row by the same mining pool, which concentrated
    more than 40% of the total hash power owned by the entire mining community. But
    then, some of the miners from that mining pool voluntarily moved to other pools
    trying to prevent unwanted effects.
  prefs: []
  type: TYPE_NORMAL
- en: An attacker might have significant hash power in a grey situation (somewhere
    between 30 and 50%), where there may be two or more different versions of a blockchain
    in the network. Consequently, it would lead to the crash of the BTC. But this
    will not happen due to the introduced PoW, which significantly reduces the probability
    of solving six consecutive blocks by the same entity. Besides, one may think that
    even with such a reduced probability, the attacker would have enough time to crash
    the system eventually. However, it is practically impossible, just due to the
    hash power added by the attacker. This is because, due to the increased overall
    computational power, the Difficulty of the involved PoW will also increase (after
    a maximum of two weeks). As a result, the attacker’s hash power will still not
    be large enough to achieve his intention. So, it can be said that the BTC blockchain
    is a BFT system.
  prefs: []
  type: TYPE_NORMAL
- en: BTC’s market value has reached several peaks so far. On the other hand, this
    increase in value motivated many attackers to try to hack or manipulate the BTC
    system, and a similar situation arose with a few other cryptocurrencies. Among
    many network-based types of attacks, two might disrupt the operation of the BTC
    network – partition attack and Delay Attack. Both attacks exploit some weaknesses
    of the Border Gateway Protocol (BGP) – not to confuse with the Byzantine Generals
    Problem – a broadly used routing protocol by the routers on the Internet.
  prefs: []
  type: TYPE_NORMAL
- en: These and other network-based attacks are possible since the BTC network is
    highly centralized, as seen from the Internet protocol routing perspective, –
    namely the three most significant Tier-1 Internet providers can intercept more
    than 60% of connections in the BTC network [[10](9783110681123_008192.xhtml#b_9783110681130-005_ref_010)].
    Apart from that, more than 60% of all BTC nodes are concentrated in five countries,
    led by the USA with around one-quarter of all nodes. On the other hand, mining
    power is concentrated in only one country – Chinese mining pools control approximately
    80% of total hash power. The largest five mining pools are located in China, which
    mines approximately 70% of all new BTCs [[11](9783110681123_008192.xhtml#b_9783110681130-005_ref_011)].
    As a result, the centralization of mining power in a single country is one of
    the biggest issues for the BTC community, at the moment.
  prefs: []
  type: TYPE_NORMAL
- en: The precondition of a partition attack is the isolation of a group of victim
    nodes from the BTC network, where an attacker deliberately voids Internet traffic
    from/to the attacked nodes. In this way, the BTC network is split into two parts
    by the attacker (the smaller and the bigger), with no communication between them.
    Consequently, the block is solved in both network parts, and then each solved
    block is broadcast within its part. When the attacker stops the attack and establishes
    the communication between these parts again, all blocks mined within the smaller
    part (with less mining power) will be discarded, as will all the transactions
    and the miners’ revenue.
  prefs: []
  type: TYPE_NORMAL
- en: The Delay Attack effectively slows down the propagation of blocks towards a
    victim. The main goal is to keep the victim node uninformed about a new block
    for almost 20 min. Unlike a partition attack where the victim’s connection is
    voided, in a delay attack, the attacker conducts a Man-in-the-Middle attack between
    a victim and its peer node, modifying BTC messages sent from the victim. Due to
    the manipulation, a victim node (i.e., the miner) gets a different piece of information
    from the requested as the answer, that is, it gets what it did not ask for – that
    is, after mining a new block somewhere in the network, the new block’s hash is
    announced and propagated through the network, reaching the victim node via its
    peer and via the attacker who intercepts the communication between the victim
    and its peer. Then, through the same channel (TCP connection with the peer node),
    the victim requests the solved block that matches the received hash. Nevertheless,
    the attacker alters this request to the peer (on behalf of the victim) by requesting
    the previously solved block that matches the other (i.e., the earlier) hash. After
    that, the victim’s peer node sends the requested older block to the victim, and
    upon receipt, the victim ignores that block (as outdated) but still waits for
    the next 20 min to repeat the request. Eventually, the victim receives the right
    block from the same peer (while TCP connection with the peer is still alive).
    When the victim finally gets the asked block, it is too late then, as a new block
    is (most probably) solved and added to the blockchain. In this way, the victim
    wastes its computing power and time instead of solving the next block. The possible
    profit is lost as well.
  prefs: []
  type: TYPE_NORMAL
- en: Various measures can be used to combat or prevent both partition and Delay Attacks.
    They may include multi-homing [[10](9783110681123_008192.xhtml#b_9783110681130-005_ref_010)]
    of a mining pool (to prevent Delay Attack), various filtering techniques applied
    by Internet service providers (against partition attack), BGP traffic monitoring,
    or upgrades of the BGP protocol (on appropriate routers) with security patches.
  prefs: []
  type: TYPE_NORMAL
- en: 'Numerous threats to different entities of the BTC system can also appear, which
    might cause problems if not treated properly. Without going into details, let
    us just name some of them: theft vulnerability of digital wallets, Sybil attack
    [[12](9783110681123_008192.xhtml#b_9783110681130-005_ref_012)] (through creation
    of pseudo-identities of nodes), Denial of Service (DoS) attacks, energy consumption,
    tracing a coin’s history (connecting identity with address), clock drift on a
    victim node (time jacking), illegal content in the blockchain, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 1.2.3 Alternative platforms and cryptocurrencies based on blockchain
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous sections, the focus was on the BTC as the oldest and most prominent
    cryptocurrency. Besides, it served as a suitable example to explain the blockchain
    concept and mechanisms such as DL, PoW, community consensus, trustless truth,
    or incentive mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: The success of the BTC paved the way for many alternate cryptocurrencies, known
    as altcoins. Among hundreds of altcoins, many are based on the same framework
    as the BTC, that is, they too include P2P network, blockchain, and a mining process
    with a kind of PoW to verify transactions on the web. On the other hand, altcoins
    differ among themselves and differ from the BTC in many ways – such as in PoW
    algorithms, procedural variations, different ways of spending energy for block
    mining, or the improvements taken for achieving better anonymity of users. After
    the BTC, the new alternate cryptocurrencies that emerged were created with the
    main goal of replacing the BTC, or, at least, repeat its success. Many altcoins
    are targeting the perceived constraints and shortcomings of the BTC and aim to
    achieve a few competitive advantages.
  prefs: []
  type: TYPE_NORMAL
- en: More than 1,500 altcoins have been created and launched on the Internet until
    now, and the new ones can show up at any time. However, many older cryptocurrencies
    are no longer present on the market. Currently, some of the altcoins with the
    largest market capitalizations are Ether (ETH), Cardano (ADA), Ripple (XRP), Litecoin
    (LTC), Zcash (ZEC), Dash (DASH), and Monero (XMR).
  prefs: []
  type: TYPE_NORMAL
- en: LTC, often mentioned as the silver to the BTC’s gold, is very similar to the
    BTC in terms of functionality. The main differences are the average time needed
    for block solving of 150 s (four times shorter than the BTC’s 10 min), the total
    amount of coins that can be mined (84 million LTCs compared to 21 million BTCs),
    and the applied PoW algorithm – LTC runs a script. This sequential function also
    involves SHA-256 [[13](9783110681123_008192.xhtml#b_9783110681130-005_ref_013)]
    computations of hash but requires much more memory than the BTC’s hash computations
    (known as double hash or hash-hash algorithm).
  prefs: []
  type: TYPE_NORMAL
- en: ETH is a bit more specific since it is not a digital currency – it, is not meant
    to be used for online payment of goods and services but as the incentive mechanism
    to power the Ethereum blockchain. In other words, ETH is the native digital currency
    (token) of the Ethereum network, based on which the Ethereum blockchain is designed
    for various decentralized applications using smart contracts (see Section 2).
    With the public Ethereum network’s mining process, about every 12–15 s, a new
    block is verified, and the reward for this is 5 ETH. The PoW algorithm (called
    ethash) requires more memory than the one in the BTC. And also, for running various
    DApps, universal computing hardware is needed (like CPUs), so the expensive ASIC
    chips specialized in BTC mining, are not suitable for Ethereum mining.
  prefs: []
  type: TYPE_NORMAL
- en: The Ethereum DLT was the pioneer of the second generation of blockchain systems.
    Unlike the BTC, they are capable of smart contacts and decentralized applications.
    For a long time, Ethereum has been the only viable choice for DL platform selection
    for DApps. The possible alternatives were immature or had lacking DL ecosystems
    (see Section 2.7.1). The Ethereum technology is implemented in a large public
    network, with important crypto-market capitalization. In addition, the Ethereum
    ecosystem (see Section 2.7.1.1.) provides efficient community support, development
    tools, and libraries. Alternatives to PoW consensus have been supported in the
    Ethereum clients before, and one can use them in private or consortium networks.
    In 2021, the Ethereum Foundation also marked a clear migration path from the PoW
    consensus in the public network to the PoS. The Ethereum technology is, therefore,
    always an option for most advanced DApp designs. For the same reasons, many examples
    in this book refer to the Ethereum network, nodes, and applications.
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, other viable DLTs and ecosystems are emerging. Some of them are
    presented in Section 2.7.1\. They might differ from Ethereum in some of the approaches
    taken but share many of the common principles related to DL networks, performance,
    decentralized applications, and security, covered in Sections 2\. and 3.
  prefs: []
  type: TYPE_NORMAL
- en: 1.3 IOTA project – tangle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Internet of Things (IoT) is becoming a reality with the expectation of deploying
    billions of IoT devices (shortly). Many of them are to be involved in different
    kinds of money transactions and micropayments. Therefore, there appeared a need
    for providing a universal platform that would support a huge number of transactions
    efficiently. This support should be much better than what the existing blockchain
    platforms can provide. A solution that should obtain key support to the IoT is
    offered by the IOTA project [[14](9783110681123_008192.xhtml#b_9783110681130-005_ref_014)].
    It is a new distributed ledger technology significantly different than the blockchain.
    IOTA is based on a specific DAG structure known as tangle.
  prefs: []
  type: TYPE_NORMAL
- en: The IOTA project began in 2015, intending to provide a more suitable cryptocurrency
    for payments (transactions) between billions of future IoT devices and obtain
    a reliable platform for many other applications, which might include M2M communication
    between those devices. As such, the implementation of the IOTA protocol had to
    be cheap, fast, and scalable, which was the key explanation for developing the
    tangle, instead of using already mature blockchain technology. The rapid growth
    of IoT significantly increased the demand for micropayments between IoT devices.
    At first, the BTC was seen to solve the needs of micropayments. However, it did
    not prove to be a good choice for two reasons. The first r is the relatively high
    fees as the amounts of money included in transactions reduce with micropayments,
    and the other reason is the roles of participants. – some miners verify transactions
    and “normal users” who issue transactions in the BTC society; hence, miners may
    be issuers, too. With this ambiguity, the probability of possible conflicts stays
    high, and conflict resolution wastes everyone’s resources.
  prefs: []
  type: TYPE_NORMAL
- en: The key differences between IOTA and other blockchain-based systems such as
    the BTC or Ethereum are that IOTA’s DLT includes no miners, no transaction blocks,
    no transaction fees or rewards paid in IOTA tokens, and no difficult PoW. Instead,
    when a participant broadcasts a transaction, the first thing to be done is to
    validate, that is, approve two (randomly chosen) previous transactions and perform
    a small amount of PoW. As a reward, the transaction is allowed to be attached
    to those two previous ones. After that, the attached transaction (called a tip)
    waits to be approved by a new transaction (of another participant), which then
    waits for its approval, later on. This pay-it-forward verification system makes
    financial rewards unnecessary.
  prefs: []
  type: TYPE_NORMAL
- en: Besides, the whole amount of the cryptocurrency (the IOTA tokens or IOTAs, in
    short) has already been created at the beginning of the tangle (i.e., at the genesis
    moment) and distributed to the project founders. After different transactions
    between participants (the founders and the new participants), IOTAs change hands.
    The smallest amount of IOTAs is one token (unlike the BTC, it is not divisible),
    while the total amount created in the genesis is (3^(33)−1)/2 ≈ 2.779 × 10^(15)
    IOTAs.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned before, a tangle is a DAG, where each point represents an individual
    transaction (and not a transaction block), while arrows represent approvals. On
    a graph representing the tangle, each transaction points to the two previous transactions
    (the so-called parents) approved by that transaction (the so-called child). To
    clarify, the approvals (arrows on the graph) are in the opposite direction of
    the timeline’s direction ([Fig. 1.4](#b_9783110681130-001_fig_004)). A transaction
    can be approved many times directly (by the transactions that directly point to
    it) or indirectly (by all further transactions that may indirectly point to it,
    following the arrows on the graph).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../graphic/converted/b_9783110681130-001_fig_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Fig. 1.4: Tangle – graph representation.'
  prefs: []
  type: TYPE_NORMAL
- en: The first transaction in the tangle is called genesis. All IOTAs were created
    in the genesis, and there is no mechanism ever to create new ones. All transactions
    in the tangle approve the genesis directly or indirectly.
  prefs: []
  type: TYPE_NORMAL
- en: Having been approved by a large number of newer transactions, a transaction
    becomes a part of the consensus that is practically impossible to be changed.
    The consistency of a tangle is accomplished through a small PoW computation that
    has to be done by each transaction, making it too difficult for an attacker to
    fork or spam the tangle after consensus has been achieved. The consensus about
    a valid transaction is reached by applying the Random Walk Monte Carlo (RWMC)
    Algorithm [[15](9783110681123_008192.xhtml#b_9783110681130-005_ref_015)]. This
    algorithm has to do with the way a new transaction selects two parent transactions
    to approve. The algorithm practically guides the transaction towards the tips
    (the not-approved transactions, yet) that have parents as young as possible. However,
    it is possible (but with a small probability) to select lazy tips, that is, tips
    that directly approve some older transactions (already verified by some earlier
    transactions in the past).
  prefs: []
  type: TYPE_NORMAL
- en: The mechanism of selection of a tip from the set of actual tips at the moment
    (in which it is also possible to be selected a lazy tip) is based on a random
    walk through the graph from the genesis towards the tangle’s end (along the timeline),
    that is, towards the tips. When a particular tip is reached (i.e., selected),
    the walk stops. The walk is performed one more time, so that two tips are chosen
    first for validation. If the chosen tips are successfully validated (i.e., checked
    for inconsistency), they become parent transactions of the new transaction (which,
    practically, directly approves its parents). The cumulative weight of a transaction
    in the tangle is the total number of all transactions that came after, and at
    the same time, approved that transaction directly or indirectly (more precisely,
    this total number is additionally increased by 1). During the walk, at each branching
    point, the branch that will be chosen is the one that leads towards the next child
    transaction and that has the largest cumulative weight. Nevertheless, a certain
    amount of randomness will be introduced in the walk, that is, the transactions
    with the biggest cumulative weights at each branching point may not always be
    included in the path. It can be said that the walk is guided towards the heaviest
    branch. As new transactions come up, the tangle is forced to grow fastest in the
    directions that follow the paths with the heaviest transactions (in the sense
    of the cumulative weight). In contrast, the transactions appended to the lightest
    branches are orphaned, that is, it is most likely that they will never become
    a part of the consensus (since the probability of their approval by any new transaction
    is small). The growth of the tangle reminds one of the forced growth of a tree
    in one direction (e.g., where the tree receives the most light), while the growth
    in other directions is also possible but significantly reduced.
  prefs: []
  type: TYPE_NORMAL
- en: In the description given so far, the transactions in the tangle’s interior are
    indirectly approved by all or by the majority of tips (~ 95% of tips). For that
    reason, they are considered confident and are expected to be present in the tangle
    forever, that is, there is a consensus on their immutability as parts of the ledger.
    The cumulative weight of a transaction is the measure of PoW performed after it,
    which secures the transaction’s consistency and immutability in the same way that
    a block in a blockchain is secured and consolidated by PoW of later blocks. Larger
    cumulative weight of a transaction indicates that the transaction is more confident.
    When a transaction in the tangle reaches enough cumulative weight, it is safely
    included in the consensus. This is equivalent to the claim that the transaction
    becomes a part of the consensus if it is validated (mostly indirectly) by the
    majority of tips.
  prefs: []
  type: TYPE_NORMAL
- en: A common characteristic of blockchain-based systems and IOTA/tangle platform
    is that the IOTA network is also a P2P network of nodes (i.e., users, entities,
    and participants). But unlike, for instance, the BTC, nodes are entities, which,
    by design, both validate and issue transactions, since before issuing a transaction,
    a node must approve two earlier transactions issued by other nodes. Furthermore,
    each node is incentivized to remain active in propagating new transactions from
    other nodes through the network, although a node may not have other new transactions
    to issue. We need to avoid terminology confusion between nodes in the IOTA P2P
    network and sites in the tangle. A site is a transaction (issued by a node) in
    a tangle graph representation. Additionally, the tangle (as a representative of
    DLs) is the ledger for storing transactions that consist of a set of sites issued
    by nodes.
  prefs: []
  type: TYPE_NORMAL
- en: As for matters of timing, it can be said that the IOTA network is asynchronous,
    where a transaction may be issued at any moment by some node, and, after propagation
    through the network, it reaches different nodes at different time instances. This
    means that any other node, at the moment when it issues its transaction, does
    not operate with the actual state of a tangle but with the state from a few moments
    ago. Consequently, a node, while running a tip selection algorithm, is unaware
    of the hidden tips that the node would be informed of shortly after that moment.
    Each node keeps (i.e., refreshes) its version of the tangle. In general, the versions
    on different nodes are not the same. Different nodes may see (more or less) different
    sets of transactions at any moment. However, these differences relate, at the
    most, to hidden tips, the newest tips, and recently verified transactions. In
    contrast, older transactions as a part of the consensus are common (i.e., the
    same) for a great majority of nodes.
  prefs: []
  type: TYPE_NORMAL
- en: A node does not always necessarily contain the latest version of the ledger
    or continuously forwards received updates (the new received tips) to its neighbors
    (peers) in the network. It is quite possible that when a node has a new transaction
    to issue, it can choose to verify two parent transactions from an older state
    of the tangle (when the node may work offline and is not always connected to the
    Internet). After verification, the node broadcasts its new transaction (which
    is appended to the verified parent transactions) through the network. The node
    does not help the community as it does not approve any new transaction.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, such lazy behavior is punished by the protocol in two ways.
    Firstly, the issued transaction will probably be considered by the remaining part
    of the network as a lazy tip, because other active nodes have fresher versions
    of the tangle. Since the lazy tips will be most probably orphaned, it is unlikely
    that such transactions will ever become a part of the consensus. Nodes are motivated
    to maintain their ledger versions as fresh as possible. Secondly, nodes are directly
    motivated to share new transactions from other nodes, as they increase the probability
    of verifying their recently issued transactions in that way. When verified, they
    also increase their cumulative weights, which enlarge the chances of becoming
    part of the consensus, finally. However even in a case when a node has no transactions
    for issuing, it is incentivized to propagate transactions from other nodes. According
    to the protocol, the mechanism that forces nodes to propagate transactions is
    that every node calculates the statistics about the number of new transactions
    received from each peer. If a node does not share new transactions, it will be
    dropped by its peers. So, next time the node has a transaction to issue, it will
    not be able do it.
  prefs: []
  type: TYPE_NORMAL
- en: With the above-described incentive mechanisms, which do not include any transaction
    fee, the tangle is getting cheap – one of the desired features in IoT applications
    (which is not the case with Ethereum and other blockchains). Tangle is seen as
    a good IoT support, as it is also fast and scalable. Unlike blockchain, tangle
    does not assume transaction blocks, so the number of transactions per second is
    measured in thousands, that is, it is much higher than in a BTC blockchain. And
    also, the tangle is scalable by design, since the more transactions are created,
    the more transactions are validated and confirmed.
  prefs: []
  type: TYPE_NORMAL
- en: The participants issuing transactions also contribute to the tangle’s security
    through resolving possible conflicts – namely, during the verification of two
    parent transactions, a node checks if the verified transactions are conflicting.
    A transaction may be conflicting with some other transaction (i.e., with the tangle
    history) in different ways. For example, an entity (a person or an IoT device)
    purchasing some goods or service and sending IOTA tokens to the other entity (seller)
    in a transaction, may have a negative account balance calculated from all previous
    transactions in the tangle (beginning from the genesis event). The negative balance
    can be a result of conflict between earlier transactions. Also, even with a positive
    account state, a dishonest entity might spend its money twice by issuing two different
    transactions to different sellers in a short period (double-spending problem),
    resulting in two conflicting transactions. As there is no conflict prevention
    mechanism, the tangle may contain pairs of conflicting transactions for a while.
  prefs: []
  type: TYPE_NORMAL
- en: When a node selects two tips for its child transaction to be appended to them,
    it has to validate those tips first. The validation of a tip includes checking
    the tip’s signature and its PoW, as well as making sure that the tip is not in
    conflict with any of the transactions in its validation path, that is, with the
    transactions which are directly and indirectly referenced (i.e., validated) by
    this tip. Suppose the node finds that the selected tip conflicts. The node leaves
    that tip and chooses another one, while the previously selected tip is forgotten.
    In that way, a node resolves conflicts directly. The same happens if the node
    finds a conflict between any two transactions in the validation path of the selected
    tip. In that case, the conflict is said to have been resolved indirectly. If a
    node issues a new transaction that indirectly approves conflicting transactions,
    it risks that other nodes will not approve its new transaction.
  prefs: []
  type: TYPE_NORMAL
- en: Another situation in which the tangle performs self-purification through resolving
    conflicts is when a node selects two tips where the validation path of the first
    tip contains a transaction that conflicts with a transaction in the validation
    path of the second selected tip. This is when none of the two transactions in
    the conflict belongs to the intersection of validation paths of these two tips.
    In such a case, the node does not see the conflict. Therefore, both of the two
    conflicting transactions are indirectly approved by the node by appending its
    transaction to the selected tips. Furthermore, a few new transactions might be
    appended to it without seeing the conflict.
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, a new transaction will select a tip with the validation path containing
    both conflicted transactions sooner or later. Then, the conflict will be registered
    and resolved by abandoning that tip. That tip will be orphaned together with several
    previous transactions that the tip has directly or indirectly validated. These
    orphaned transactions will include only one of the conflicting transactions (and
    a few subsequent transactions which have approved it). In contrast, the branch
    that contains the second conflicting transaction (the one with a higher cumulative
    weight) will survive. Hence, the conflict is resolved, and only one of the two
    conflicting transactions stays in the ledger. Several innocent transactions, which
    have approved the other conflicting transaction (because they had not been in
    a position to detect the conflict), will be orphaned as collateral damage. However,
    most probably, they will be picked up and reissued by the participants (nodes)
    involved in these transactions as sellers (payment recipients).
  prefs: []
  type: TYPE_NORMAL
- en: As already pointed out, a tangle began in the genesis event, where the very
    first transaction started distributing a predefined total amount of IOTA tokens.
    As the tangle grows and the total number of transactions increases, the size of
    the ledger is continually getting bigger, which may be a problem, especially for
    IoT applications. To reduce the size of a tangle, the IOTA Foundation makes snapshots
    of the full network from time to time. A snapshot contains states on the accounts
    of all users (wallets’ balances), but it does not contain transaction history,
    that is, all previous transactions are erased. Such a snapshot represents a new
    genesis state of a tangle (like a new beginning), but with the difference that
    the total amount of 2.779 × 1015 tokens has already been distributed to all existing
    users at that moment.
  prefs: []
  type: TYPE_NORMAL
- en: Currently, the IOTA network is not fully developed, and the number of users
    is far beyond the number for which the tangle was initially designed. As a result,
    the community’s total computing power (hash rate) is still relatively low. Consequently,
    the current tangle is vulnerable to double-spending attacks, which would be possible
    if an attacker owned more than one-third of the total network hash rate. To prevent
    attacks of this kind and for security reasons, IOTA users apply (voluntarily and
    temporarily) a different consensus mechanism through the so-called Coordinator.
    This mechanism assumes that the IOTA Foundation issues a milestone transaction
    every two minutes. All transactions approved directly or indirectly by a milestone
    transaction are immediately considered part of consensus (i.e., with the confirmation
    confidence of 100%). In the future, when the IOTA network reaches a large enough
    computing power, the Coordinator will not be necessary, that is, IOTA Foundation
    will shut it down and let the tangle evolve entirely on its own.
  prefs: []
  type: TYPE_NORMAL
- en: A special characteristic of the tangle is that all processing and software calculations
    are run in ternary logic, or more precisely, in the balanced ternary logic. Unlike
    binary computing, where a binary digit (bit) can take one of two values (0 and
    1), a digit in a balanced ternary, called Tritt, can be –1, 0, or + 1\. A word
    of three Tritts is called Tryte (analogously to byte), and it can have 3³ = 27
    different states (values). Each of Tryte states is designated in IOTA with one
    of the 26 uppercase letters “A”, “B”, “C”, …, “X”, “Y”, “Z” and the number “9”
    as a symbol (symbol “9” in balanced ternary logic represents value + 1).
  prefs: []
  type: TYPE_NORMAL
- en: Computer theory defines a measure for the efficiency of a hypothetical computer
    with the radix (base) *R*, called radix economy, as the product of *R* and the
    number of digits in that base. Theoretically, base *e* = 2.71 (Euler’s number,
    i.e., the base of natural logarithm) would be maximally efficient in storing information.
    Still, for a real computer, radix *R* = 3 is the best choice, since this is the
    integer closest to *e*. Furthermore, balanced ternary has an advantage over positive
    ternary (also called vanilla ternary, where digits can have values 0, 1, and 2)
    in allowing the encoding of positive and negative numbers in the same way. There
    is no such thing as the binary representation of negative numbers in the 2’s complement,
    so no-sign Tritt is needed. Also, there are other advantages, for example, simpler
    truth tables for digit addition, subtraction, multiplication, and division.
  prefs: []
  type: TYPE_NORMAL
- en: The rationale for involving ternary computing in IOTA is also based on research
    in this area, whereby ternary and quantum computing are seen as the near future.
    Ternary computers (except a few experimental ones) do not exist. Therefore, the
    whole ternary logic (including computing of cryptographic hash function, like
    SHA-3) is emulated and run by conventional binary computers in IOTA.
  prefs: []
  type: TYPE_NORMAL
- en: 1.3.1 IOTA bundle
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we have already previously explained, a new transaction’s first step is to
    select two tips (using the random walk) that are to be approved by that transaction.
    And yet, the real implementation is a bit more complicated since, most commonly,
    a common transaction is issued through the so-called bundle of several individual
    transactions ([Fig. 1.5](#b_9783110681130-001_fig_005)), where each transaction
    has the same value as its internal field named Bundle Hash. In other words, for
    each real transfer of IOTAs from one participant to another, the appropriate software
    client issues not only one transaction but a chain of *N* individual transactions
    related to that transfer (which are indexed in reversed order from *N *– 1 to
    0). All transactions in a bundle together approve the two selected tips according
    to a specific scheme (this will be explained in the following chapters).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../graphic/converted/b_9783110681130-001_fig_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Fig. 1.5: Transactions bundling in a tangle – an example of a bundle with six
    transactions.'
  prefs: []
  type: TYPE_NORMAL
- en: The selected tip chosen after the first random walk is called the trunk tip.
    The other tip, which is chosen after the second random walk, is called the branch
    tip. The first individual transaction in the bundle (with index *N *– 1) approves,
    that is, points to both trunk and branch tip, while the remaining *N *– 1 individual
    transactions (with indices from *N *– 2 to 0) all together point to the trunk
    tip. Each of these *N *– 1 transactions, besides the trunk tip, also approves
    the previous transaction in the bundle (with the index higher by 1) through the
    internal field Trunk Transaction (which contains the hash value of the previous
    transaction in the bundle), see [Fig. 1.6](#b_9783110681130-001_fig_006). This
    means that the value written in the Trunk Transaction field is equal to the value
    written in the Transaction Hash field of the previous transaction in the bundle.
    In contrast, the value of the Branch Transaction field is equal to the hash of
    the trunk tip (written in the Transaction Hash field of the trunk tip). As already
    explained, the first transaction in the bundle approves both selected tips, but
    in a slightly different way – its Trunk Transaction field now points to the trunk
    tip, and the Branch Transaction field points to the branch tip.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../graphic/converted/b_9783110681130-001_fig_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Fig. 1.6: Way of transactions bundling in a tangle.'
  prefs: []
  type: TYPE_NORMAL
- en: In the end, each tip belongs to its bundle as the last (not approved) individual
    transaction of the bundle, since the random walk algorithm selects only those
    not-yet-approved transactions (each of the earlier transactions in a bundle is
    already approved by the last one, i.e., by the tip).
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three types of individual transactions in an IOTA bundle: input,
    output, and meta transaction. The type of a transaction depends on the sign of
    the number written in the internal field, Value, representing the amount of IOTA
    tokens (IOTAs) that are to be added (through this individual transaction) to the
    account specified by the field, Address. As a result, the content of the field,
    Value, in an input transaction is a negative number, which means that the given
    address is charged for the specified amount of IOTAs. An output transaction adds
    IOTAs to the given address since the written value is positive, while a Meta transaction
    is neutral as the value written in it equals 0\. Meta transactions are used as
    extensions of input transactions, usually having the tail parts of the input transactions’
    signatures.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us explain it with the following example: if client A wants to make a purchase
    and transfer, for example, 700 IOTAs to client B, the client software on A’s side
    will create a bundle of input, output, and (probably) meta transactions which
    are to be integrated into the tangle. Thereby, either all transactions inside
    the bundle will be accepted by the nodes in the IOTA network or none of them.
    In the process of bundle creation, at first, the output transaction containing
    the address *b* of client B in the Address field and the positive value of 700
    in the Value field is prepared. This transaction gets assigned index 0 (this transaction
    is indexed as the beginning of the bundle of *N* transactions, but it will be
    issued last in time, in the burst of *N* bundled transactions).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the input and meta transactions are prepared. If client A has, for example,
    three addresses (i.e., three accounts) *a*[1], *a*[2], and *a*[3] generated from
    the same private keys seed, with the account states of 200, 600, and 350 IOTAs
    on them, respectively, the three corresponding input transactions will have the
    following values written in the Index, Address and Value fields: {1, *a*[1], –200},
    {3, *a*[2], –600} and {5, *a*[3], –350}. Since input transactions need to contain
    transaction signatures where the address security level is two by default, a meta
    transaction is added after each input transaction to carry the second part of
    the signature of the preceding input transaction. These three meta transactions
    will have the following indices, addresses, and values: {2, *a*[1], 0}, {4, *a*[2], 0}
    and {6, *a*[3], 0}.'
  prefs: []
  type: TYPE_NORMAL
- en: An output transaction is prepared as the last one to balance the transfer (the
    so-called remaining transaction). Since client A spent 200 + 600 + 350 = 1,150 tokens
    through the three input transactions, and client B received 700 tokens through
    the first output transaction, a new output transaction is created, which returns
    the difference of 1,150 – 700 = 450 tokens to client A. This transaction has index
    7 (the biggest in the bundle), value 450 (positive), and address *a*[4] (created
    from the same seed as the addresses *a*[1], *a*[2], and *a*[3] of client A).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the end, the complete bundle in a given example contains eight individual
    transactions with the following {“Index”, “Address”, “Value”} triplets: {0, *b*, 700},
    {1, *a*[1], –200}, {2, *a*[1], 0}, {3, *a*[2], –600}, {4, *a*[2], 0}, {5, *a*[3], –350},
    {6, *a*[3], 0}, and {7, *a*[4], 450}. The first and last transactions in this
    example are of the output type, while the transactions in the middle are of input
    or meta-type. In general, the total number of transactions in a bundle is not
    limited, but practically, under given network constraints and limitations of the
    PoW difficulty, the issuance of bundles with over 30 transactions is discouraged.
    A typical bundle for a transfer between two clients (sender and receiver of tokens)
    consists of four transactions: one output (to receiving client), one input (from
    sender), one meta-transaction, and the balancing transaction.'
  prefs: []
  type: TYPE_NORMAL
- en: 1.4 Hashgraph
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Led by the BTC development so far, blockchain technology has made a significant
    breakthrough in the DL area and has opened up the opportunity for creating numerous
    decentralized applications, apart from cryptocurrency (which is only one of them,
    but the most popular one). Several DL systems based on DAGs have also emerged,
    aiming to develop new technologies with the best possible and most desirable features.
    However, these features are often in opposition to one another. Hence, the existing
    systems such as BTC, Ethereum, or IOTA/Tangle are just the trade-offs based on
    the level of their realization. An ideal DLT should certainly have the following
    properties: immutability, low latency, security, scalability, low computing difficulty,
    DDoS resistance, as well as modesty in Internet bandwidth requirements. It is
    also important that such a system should not require any expensive server. It
    should be fair, fast, cheap, and Byzantine fault-tolerant. Finally, it should
    have the ability to achieve a consensus under circumstances of the absolute trustless
    truth, that is, enforce the community’s rules, even when nobody trusts anyone.
    A good candidate that fulfills all these requirements is a DL platform known as
    hashgraph.'
  prefs: []
  type: TYPE_NORMAL
- en: Hashgraph [[3](9783110681123_008192.xhtml#b_9783110681130-005_ref_003)] is a
    new DAG-based consensus alternative to the blockchain. Simply put, a DAG is a
    finite directed graph without loops between any two elements. In graph theory,
    a graph is a structure consisting of a set of points (vertices, elements, squares)
    where any two points can be in relation, that is, connected by a line (edge, arc).
    A directed graph means that each line between two points is directed, that is,
    has an arrow. Thus, a DAG can be considered to be a finite set of points connected
    by arrows, so that there is no way to start at any point X and follow a sequence
    of arrows that eventually loops back to X again, that is, that there are no directed
    cycles. A DAG can have a tree topology (as a special case), but generally, DAGs
    have no regular topology. Blockchain could be considered as the simplest DAG with
    the points (blocks) connected in a chain, that is, one where each point (except
    the first and the last one) has one predecessor (parent) and one successor (child).
  prefs: []
  type: TYPE_NORMAL
- en: 'There are similarities between graph representations of hashgraph and IOTA/tangle:
    both have topologies of a DAG where each element (event, i.e., site) has exactly
    two direct ancestors (parents). However, this is their only similarity. It can
    be concluded that the DAG of a hashgraph represents the history of all communications
    (the so-called gossips) between a community (population) members.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Hashgraph runs a gossip protocol, which, in brief, can be described as follows:
    in the hashgraph’s P2P network of nodes, at any moment, every node, X (member
    of the population, participant) can synchronize with its randomly chosen neighbor,
    Y (peer), where X sends a sync message to Y, containing information about new
    transaction(s), about previous sync messages (gossips) between nodes in the population,
    or both. Thereby, node X sends everything it knows so far and what node Y does
    not know, that is, X sends everything to Y, except the pieces of information that
    X is sure that Y has already learned.'
  prefs: []
  type: TYPE_NORMAL
- en: When a node receives a sync message, it creates a data structure called an event.
    In general, an event contains (as payload) a set of the most recent transactions
    learned from the node’s clients, that is, from users (digital wallets), and the
    timestamp representing the moment at which the node claims to have received the
    sync. A sync message from node X to node Y consists of all the events known to
    X and unknown to Y (i.e., for which X supposes that they are unknown to Y). On
    the other hand, node Y extracts only (to its own) unknown events until that moment
    (since Y may have already learned some of the received events from other nodes’
    syncs, which node X was unaware of). Node Y uses the new information to update
    its copy of the hashgraph ledger as the overall picture of all events and syncs
    in the population, from the beginning.
  prefs: []
  type: TYPE_NORMAL
- en: In the graph representation, for example, when a node A receives a gossip (sync)
    from a node B, that gossip event is shown on the graph as a circle (vertex) in
    column A, with two lines (edges) going down to the immediately preceding gossip
    events by nodes A and B ([Fig. 1.7](#b_9783110681130-001_fig_007)). The hashgraph
    diagram (such as the one in [Fig. 1.7c](#b_9783110681130-001_fig_007)) is used
    only for its presentation and explanation, that is, there is no actual graph stored
    in memory anywhere.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../graphic/converted/b_9783110681130-001_fig_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Fig. 1.7: Structure of hashgraph.'
  prefs: []
  type: TYPE_NORMAL
- en: For sharing of transactions, each node runs two endless parallel program loops
    in its software. It asynchronously receives and collects new transactions from
    its clients (wallets) and the sync messages from other nodes (thereby creating
    events) in the first loop. In the second program loop, the node occasionally sends
    syncs to its neighbor nodes. This process of gossip spreading, that is, sharing
    the existing and creating the new events, should stop when each node collects
    every piece of information (on all transactions) created or received at the beginning,
    that is, when a consensus about all transactions and about the timeline of their
    occurrences is reached. However, as new transactions appear all the time, the
    process practically never stops, since there is always something new to gossip
    about. At the same time, nodes are continuously reaching the consensus on the
    previous events and fast. Practically, at any moment, every node can see almost
    the same picture (i.e., the history) of all events as the other nodes are seeing.
    In contrast, the differences (between nodes’ views on overall gossip history)
    are only related to the latest events (which may be old a few seconds, maximally).
  prefs: []
  type: TYPE_NORMAL
- en: Knowing that sync messages include information not only on the events’ transactions
    but information on the events per se, as well, it can be said that hashgraph represents
    gossip about transactions, as well as gossip about gossip. This is important because,
    from the history of gossips, a node can conclude which information other nodes
    know and which they do not.
  prefs: []
  type: TYPE_NORMAL
- en: Let us conclude, in short, that hashgraph is a hybrid data structure – the combination
    of a hash and a graph, which keeps records about who gossiped to whom and in what
    order. Hashgraph does not require any PoW (so there is no mining), since reaching
    the consensus relies on a procedure known as virtual voting. Unlike blockchain,
    where transaction data is stored in blocks, hashgraph stores data in events, so
    an event can be comprehended as a container of transactions, although an event
    may be empty. In the hashgraph, an event and all the transactions contained in
    it almost immediately become part of a permanent record, that is, of the copy
    of a ledger on every node. This is performed as soon as the node gossips that
    event and all other nodes hear about it. Also, in only a few seconds, every node
    will know, with 100% certainty, about the event’s position in the hashgraph’s
    history, and every node will know that every other node knows this (which is of
    even greater importance).
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, unlike the BTC blockchain, where a block and the whole PoW invested
    in its solving might be sometimes wasted (e.g., in the case of a blockchain forking,
    when two candidate blocks are solved at about the same time, after which only
    one block survives), with hashgraph, no event is ever sacrificed, so hashgraph’s
    efficiency is 100%, as well. Finally, hashgraph is a Byzantine fault-tolerant
    system, where the BFT property is absolute, that is, mathematically proven (the
    case will be discussed later).
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 1.7a](#b_9783110681130-001_fig_007) shows the beginning of a hashgraph
    for the population with five members (participants, nodes) in the network, named
    from A to E. Over time, as new events are created, the hashgraph grows upwards.
    Grey circles at the bottom of [Fig. 1.7a](#b_9783110681130-001_fig_007) represent
    events created by each member, at the start. Every new event created by a member
    will be added above the last event on the vertical line that belongs to that member.'
  prefs: []
  type: TYPE_NORMAL
- en: 'An event is a small data structure, which can contain zero or more transactions.
    Every event has two parent events below it (except the start events): one, which
    is called self-parent, and the other one, which is called other-parent. A vertical
    line connects an event and its self-parent event (they are in the same column
    since the same node creates both), while an angled line connects the event with
    its other-parent event (earlier created by another node). Besides the field for
    transactions (if they exist), there are three more fields in the data structure
    of an event: two fields containing hashes of two parent events and the field for
    the timestamp of the event’s creation ([Fig. 1.7b](#b_9783110681130-001_fig_007)).'
  prefs: []
  type: TYPE_NORMAL
- en: A node that has created an event also signs it digitally. When the node gossips
    that event to another node, the signature is sent together with the gossiped event(s).
    The whole hashgraph structure is firmly bonded and protected, that is, made cryptographically
    immutable, since each event contains hashes of its parents – that is, after each
    received sync message and creating a new event, a node can pass through the hashgraph
    from the starting (or from some later) event/s and calculate by itself, the hashes
    of the events below the other parent, as well as the other parent’s hash. In that
    way, the node can check the correctness of the other-parent event (and the events
    below) and validate it, which it certainly does. After sync is received, only
    validated events are included in the node’s copy of the hashgraph. Furthermore,
    nodes in the hashgraph’s P2P network communicate to each other using TLS encryption
    protocol (on top of TCP), which additionally protects the exchange of sync messages.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 1.7c](#b_9783110681130-001_fig_007) shows an example of a hashgraph
    (with five nodes/participants) for the first few events, where it can be seen
    who gossiped which events to whom and in what order. For example, participant
    (node) C first gossips (sends sync) event C1 to participant A which, upon the
    receipt of C1, creates event A2\. Node A saves events C1 and A2 in its file system
    and the transactions that might be contained in them. Event A2 as payload contains
    only new transactions (if any collected in the meantime) with the timestamp of
    the event’s creation and the hashes of its parents A1 and C1 as overhead. Then,
    participant E gossips event E1 to D, after which participant D creates event D2\.
    In the next step, A synchronizes with B, so A gossips everything he knows (events
    A1 and C1) to B, who then creates event B2\. The gossip from [Fig. 1.7c](#b_9783110681130-001_fig_007)
    is then spread as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'SYNC (B→E): B gossips events B2, B1, A2, A1, and C1; node E creates event E2'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'SYNC (D→C): D gossips events D2, D1, and E1; node C creates event C2'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'SYNC (C→A): C gossips events C2, D2, D1, and E1 (C does not send C1 since C
    knows that A has already learned of C1 in the previous C→A sync); node A creates
    event A3'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'SYNC (C→B): C gossips events C2, C1, D2, D1, and E1 (at that moment, C does
    not know that B has already learned of C1 in A→B sync, since node C is yet unaware
    of that sync, so the event C1 was not excluded from this gossip); from this moment,
    node B knows of all starting events A1–E1; node B creates event B3'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'SYNC (B→E): B gossips events B3, C2, D2, and D1 (now, B knows that E has learned
    of B2, B1, A2, A1, and C1, so these events are not gossiped about, neither is
    E1, since it was created by E); from this moment, node E knows of all starting
    events A1–E1; node E creates event E3'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'SYNC (B→A): B gossips events B2, B1, C2, D2, D1, and E1 (at that moment, B
    does not know that A has learned of C2, so C2 was not excluded from the gossip;
    on the other hand, B knows that A knows of C1, so C1 is not sent); from this moment
    node, C knows of all starting events A1–E1; node A creates event A4'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'SYNC (E→C): E gossips events E2, B3, B2, B1, A2, and A1 (now E sees C2 via
    B3\. Hence, E knows that C knows of D2, D1, and E1, so these events are not gossiped
    about); from this moment, node C knows of all starting events A1–E1; node C creates
    event C3'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'SYNC (A→D): A gossips events A4, A3, A2, A1, B3, B2, B1, C2, and C1; finally,
    from this moment, node D knows of all starting events A1–E1; node D creates event
    D3'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This process occurs very fast, so every node in the community learns of all
    starting events (A1–E1) and their transactions in a very short time (~ a second).
    The same also applies to any new transaction/event that appears later. At every
    moment, all nodes reach a full consensus on the transactions’ and events’ existence
    from the start and up to very close to the actual moment. However, for hashgraph
    applications (cryptocurrency, smart contracts, file storage), to be resistant
    to double-spending, Byzantine Generals Problem, Sybil attacks, and other types
    of misuses, this kind of consensus is not enough. The community must also achieve
    the consensus on the exact order in time of all events, and for that purpose,
    the virtual voting consensus algorithm is used.
  prefs: []
  type: TYPE_NORMAL
- en: Virtual voting is a voting process in which the community of nodes collectively
    and democratically establishes the consensus on the transactions’ order in time,
    that is, on the transactions’ timestamps. It is called virtual because nodes do
    not send their votes over the Internet (the Yes/No decisions regarding famous
    witnesses, which will be explained later). Instead, each node calculates what
    votes other nodes would have sent, based on its knowledge of what other nodes
    know. Each transaction’s timestamp adopted by consensus represents the moment
    when the majority (more than 50%) of the network members (nodes) learned of that
    transaction. The consensus timestamp of a transaction is determined as the median
    value in a set of timestamps that pick the moments when each node says that it,
    for the first time, received an event (through gossip) having this transaction.
    In other words, timestamps written in events created upon each node’s first reception
    of gossip with the given transaction are seen as elements of the set of timestamps,
    whereby the set’s median value is declared as the transaction’s consensus timestamp.
  prefs: []
  type: TYPE_NORMAL
- en: And yet, every node is not allowed by default to delegate its event, that is,
    the event’s timestamp to be an element of the mentioned set of timestamps. To
    get this allowance, each node must create, a bit later, an event that is elected
    as the famous witness, that is, as the event, which the hashgraph shows that most
    nodes have learned of, fairly soon after it was created. Generally speaking, virtual
    voting is the Byzantine agreement mechanism that determines which nodes may delegate
    (and which may not) the timestamps for calculation of the events’ median (i.e.,
    consensus) timestamps.
  prefs: []
  type: TYPE_NORMAL
- en: In a population of members (nodes), any group that gathers more than two-thirds
    of the total number of nodes represents the so-called supermajority (while for
    a simple majority, only more than 50% of nodes are needed). The term supermajority
    can also refer to events, that is, to the witnesses of a round (explained below),
    in which case, it represents a group that counts at least 2/3 of witnesses.
  prefs: []
  type: TYPE_NORMAL
- en: If, in a hashgraph diagram, there is at least one path between any two events
    X and Y, that connects them directly or via other events (e.g., assuming that
    X is older than Y), it is said that Y sees X and that event X is an ancestor of
    event Y, that is, Y is a descendant of X. If X and Y are linked via only one path,
    which includes events Z and W, it is said that Y sees X through Z and W. In general,
    Y can see X via more paths and each path can include more events, whereby different
    paths may partly overlap (i.e., may have common events). The union of all events
    belonging to all paths between X and Y represents the set of events through which
    Y sees X. If the supermajority of nodes creates such a set of events, it is said
    that Y strongly sees X.
  prefs: []
  type: TYPE_NORMAL
- en: 'The hashgraph is divided into the portions of events called rounds (see [Fig.
    1.8](#b_9783110681130-001_fig_008)). It starts with round 1, and the starting
    events (from each node) are called witnesses of round 1\. As the hashgraph grows,
    an event will appear at one moment, which strongly sees a supermajority of the
    round 1 witnesses. Round 2 begins from that moment, while this event becomes a
    witness of round 2\. The division of rounds is based on a rule that each next
    round begins with the first event, which strongly sees a supermajority of the
    witnesses in the last round (the event does not have to see all the witnesses
    from the last round). This event becomes the first witness of the next round.
    Each node may have created at most one witness in a round implying that some nodes
    may have created no witness in the round. Also, when an event is first gossiped
    to a node, that node can immediately calculate the round created of the event,
    that is, the serial number of the round the event belongs to. The round created
    of an event is calculated as follows: if the event sees strongly a supermajority
    of witnesses of round *r*, where *r* is the max of the round created of the event’s
    parents, then the round created of the event is *r *+ 1; otherwise, the round
    created of the event is *r*.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../graphic/converted/b_9783110681130-001_fig_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Fig. 1.8: Example of seeing strongly and illustration of division on rounds.'
  prefs: []
  type: TYPE_NORMAL
- en: The following step is used to determine which of the witnesses in a given round
    will be (virtually) elected as the famous witnesses. Every witness in a round
    can become famous if some conditions are satisfied. Whether the *i*-th witness,
    W*[n,i]* from round *n* will be famous or not is up to the witnesses from upper
    rounds, *n *+ 1 and *n *+ 2 (in most cases). Firstly, each witness, W*[n ]*[+1]*[,j]*
    from round *n *+ 1 gives his virtual vote, that is, answers “Yes” if he can see
    W*[n,i]* (strongly seeing is not mandatory here) or the answer “No” in the opposite
    case. Next, these votes are counted by witnesses from round *n *+ 2.
  prefs: []
  type: TYPE_NORMAL
- en: As a result of this, a witness, W*[n ]*[+2]*[,k]* from round *n *+ 2 takes into
    account (i.e., collects) only the votes from round *n *+ 1 witnesses, which he
    strongly sees. The votes from other round *n *+ 1 witnesses, not strongly seen
    by W*[n ]*[+2]*[,k]* (if any of them exist), are not considered. If the number
    of collected “Yes” votes is greater than or equal to 2/3 of the total number of
    nodes (a supermajority), then it is decided that witness, W*[n,i]* is famous.
  prefs: []
  type: TYPE_NORMAL
- en: The same virtual voting procedure is performed for each round *n* witnesses,
    so eventually a group of the famous witnesses of round *n* will be formed, the
    fame of which was finally decided by only one witness from round *n *+ 2, that
    is by a witness who counted the votes of round *n *+ 1 witnesses. It was mathematically
    proven that the same result of the election of the round *n* famous witnesses
    would be obtained if any other round *n *+ 2 witness counts the votes of round
    *n *+ 1 witnesses.
  prefs: []
  type: TYPE_NORMAL
- en: The nodes that have created famous witnesses of round *n* are given the allowance
    to make decisions on consensus timestamps of some events (i.e., transactions)
    from round *n *– 1\. More precisely said, the creator nodes of the round *n* famous
    witnesses are qualified to determine the consensus timestamps of the events from
    round *n *– 1, which are seen by all famous witnesses of round *n*. If an event
    is seen by all the round *n* famous witnesses, this event is said to be received
    (by the community of nodes) in round *n*, that is, that it has round received
    of *n.* For example, to determine the consensus timestamp of a round *n – *1 event,
    X*[n]*[–1] which has round received of *n*, each node A*[i]* from this privileged
    group (of the creators of the round *n* famous witnesses) first picks the event,
    Y*[i],* which was created by that node when it first received a gossip with given
    event, X*[n]*[–1] (it may often happen that Y*[i]* is just the famous witness
    of round *n*, created by that node). In the next phase, the timestamp of event
    Y*[i]* is delegated as one of the candidates for the consensus timestamp of event,
    X*[n]*[–1]. Lastly, the candidate timestamps delegated by all qualified (i.e.,
    privileged) nodes are sorted into an array of timestamps beginning from the oldest
    one, and the timestamp in the middle (the median value) is declared as the consensus
    timestamp of event, X*[n]*[–1]. In case there are two middle timestamps in the
    array (i.e., when the number of candidates is even), the latter is chosen.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the timestamp consensus (see [Fig. 1.9](#b_9783110681130-001_fig_009))
    of event X*[n]*[–1] is repeated for every event from round *n *– 1 having round
    received of *n*, while other round *n *– 1 events wait to be seen by all famous
    witnesses from round *n *+ 1 (or higher). As the hashgraph grows with time, the
    consensus timestamps of the events, which belong to rounds *n*, *n *+ 1, *n *+ 2,
    … (having round received of *n *+ 1, *n *+ 2, *n *+ 3 … respectively) are determined
    by following the same virtual voting procedure on the upper rounds’ witnesses.
    In this way, the consensus timestamps of events (and of the transactions contained)
    begin being determined after practically two rounds, that is, in only a few seconds
    after the given event’s creation. The consensus on the existence of an event is
    achieved even faster. Of course, the virtual voting process may encounter ties
    regarding the election of the round *n* famous witnesses. The witnesses from round
    *n *+ 3 (and even from higher rounds) are engaged in resolving the voting ties.
    This certainly prolongs the time of reaching the timestamp consensus, that is,
    the consensus on the time order of the round *n *– 1 events, but, even then, the
    whole process is very fast.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../graphic/converted/b_9783110681130-001_fig_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Fig. 1.9: Illustration of procedure of finding famous witnesses and consensus
    order of events.'
  prefs: []
  type: TYPE_NORMAL
- en: After determining consensus timestamps of all events in a round, the consensus
    on their time order is automatically achieved, which was the aim of the whole
    procedure. The consensus timestamps of events are assigned to the transactions
    they contain, so the consensus on the order of transactions is determined too.
    The consensus timestamp of a transaction is fair, since it reflects the moment
    when the majority of nodes received that transaction, as this timestamp cannot
    be corrupted or significantly changed by a malicious node. In case some malicious
    nodes try to delay or stop a transaction and thus exclude it from gossips, the
    transaction will bypass that obstacle due to the random nature of the gossip protocol.
  prefs: []
  type: TYPE_NORMAL
- en: The whole idea of splitting into rounds, elections of famous witnesses, etc.,
    might seem too complicated. But this is not an issue, since the software that
    implements the hashgraph on a node does not require any special hardware – it
    requires nothing more than an average computer with a CPU for universal purposes.
    It does require an Internet connection with the bandwidth necessary for downloading
    and uploading a given number of transactions per second and exchanging syncs with
    other nodes in the hashgraph’s P2P network. Thus, the amount of gossiped data
    between two nodes is minimal. As mentioned earlier, within a sync message, a node
    sends only the events it supposes to be unknown to its peer/neighbor node. Moreover,
    some events are sent without hashes of the events’ parents (when sending node
    can conclude that the receiving node can calculate those hashes). Besides, the
    hashgraph’s virtual voting algorithm does not require any additional bandwidth.
    As a reference to be noted, a fast home Internet connection (of each node) would
    be fast enough to support the same number of transactions per second as the entire
    VISA card network can handle worldwide. Another indicator of the hashgraph’s speed
    is the test results for the network of 32 computers (nodes) spread across eight
    regions around the globe. Namely, when this network runs at 50,000 transactions
    per second, the consensus on the time order of transactions is reached in 3 s.
    If the whole network is concentrated in a single region, the time needed for consensus
    is 0.75 s. Also, the same number of computers (spread in eight regions worldwide)
    can provide the performances required by credit cards – the latency of fewer than
    7 s to handle up to 200,000 transactions per second.
  prefs: []
  type: TYPE_NORMAL
- en: There are other advantages of the described concept of virtual voting. The most
    important one is the hashgraph’s BFT property, achieved in the strict sense of
    the BFT definition (and mathematically proven), unlike blockchain or tangle technologies
    where BFT is accomplished only as a possibility. To be specific, the hashgraph’s
    honest members will be able to keep running a given application (e.g., cryptocurrency)
    correctly, even where the number of fraudulent members/nodes is very close to
    1/3 of the whole population. The BFT property of a hashgraph is a direct consequence
    of the implemented rules (i.e., of the Byzantine protocols) within virtual voting.
    The strongly seeing and the supermajorities of nodes and witnesses are required.
  prefs: []
  type: TYPE_NORMAL
- en: The second advantage is that all voting processes and getting consensus timestamps
    are performed virtually and independently by each node. Every member/node does
    everything on its own, as if it was alone on a desert island and without the need
    for any additional communication with anyone (except the regular gossip). Besides
    a reduced demand for Internet bandwidth, the benefit of this is also an increased
    speed of realization and verification of transactions. To be specific, an alternative
    consensus algorithm that would obtain BFT property certainly should be running
    separate Byzantine protocols, including a large amount of communication between
    all members. Thus, if the aim is to determine the consensus order of all events
    in time, each separate communication between two nodes would contain several Yes/No
    questions (in both directions), where each question would have the form, “did
    event X come before event Y?” However, such an algorithm would be very slow due
    to the delays in communication between nodes over the Internet, and perhaps due
    to its complexity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of all mentioned so far, by applying the virtual voting algorithm,
    the Byzantine agreement protocol is run only for witnesses, whereby famous witnesses
    are chosen as a result of a small number of questions, such as: “Is this witness
    famous?” In this way, the process of time event ordering (through performing some
    sorting algorithm) is avoided. As already explained, the time order of events
    is (automatically) determined as soon as their consensus timestamps are found,
    as the median values of the candidate timestamps delegated by the nodes that have
    created the famous witnesses.'
  prefs: []
  type: TYPE_NORMAL
- en: In the previous paragraphs, some of the factors for realizing an application
    based on hashgraph are that it should be fast, cheap, Byzantine fault-tolerant,
    resistant to double-spending and DDoS attacks, and modest in the bandwidth demands.
    Other desirable features of hashgraph are related to its organizational structure
    designed to make these features real. For the time being, Hashgraph is a project
    in its developing phase. It is led by Hedera Hashgraph, LLC – the company which
    also provides a public ledger platform for this project. It was mentioned earlier
    that a DL could be permissionless or permissioned, depending on whether a central
    entity grants the permissions to nodes for accessing the network or not. Also,
    it was mentioned that a DL network could be private or public based on the P2P
    network used. The Hedera hashgraph platform is designed to be public and to have
    permissionless (i.e., open) consensus with a permissioned (closed) governance.
  prefs: []
  type: TYPE_NORMAL
- en: The closed governance model is based on the idea that the platform will be governed
    by a council of up to 39 reputable organizations and enterprises from different
    industries and regions worldwide, with highly respected brands. The Hedera Hashgraph
    Council (HHC) is a governing body aiming at supporting the evolution of a stable
    and decentralized public ledger infrastructure based on the hashgraph consensus
    algorithm. HHC will follow the rules to ensure that no single member or a small
    group of members will have control over the body as a whole. On behalf of the
    council, the elected Governing Board will establish the council membership policy,
    then regulate the network rules and token issuance, and approve changes to the
    platform codebase. The governance rules foster the philosophy of decentralization
    and prevent the concentration of power over the process of reaching the consensus
    on the transaction order in the platform. Such a governing model will also eliminate
    the risk of ledger splitting, guarantee the codebase integrity, and provide open
    access to the protected core. Protected core means that the hashgraph consensus
    algorithm is not license-free. Specifically, the intellectual property rights
    in the algorithm are held by Swirlds, Inc. (the company founded by the inventors
    of the algorithm). At the same time, the HHC has a license from Swirlds to use
    it for the Hedera public DL platform. On the other hand, neither license nor Hedera’s
    approval will be required to use the Hedera hashgraph platform or write software
    that uses the platform services. In contrast, the applications built upon the
    platform can be open source or proprietary.
  prefs: []
  type: TYPE_NORMAL
- en: Properties necessary for the broad adoption of a DL platform are trust and stability.
    Hedera’s governance model (with its governing rules) and the implemented strong
    security mechanisms are just the key factors for a stable decentralized platform
    that creates trust. Apart from that, the HHC’s policies and structure are intended
    to guarantee a wide and fair distribution of native cryptocurrency of the Hedera
    DL platform and to ensure a full network nodes’ application. As a result, the
    nodes will be compensated for the services in maintaining the Hashgraph platform
    through the specially designed incentive model. And consequently, at the same
    time, the new nodes (i.e., new node operators) will be able to join the network.
  prefs: []
  type: TYPE_NORMAL
- en: 'The entire system of payments (incentives) and fees introduced by Hedera significantly
    differs from the incentive mechanism of the BTC (or other altcoins), where the
    clients (i.e., digital wallets) pay a fee for each verified transaction. At the
    same time, nodes earn money through mining if they are successful in solving the
    PoW tasks. As explained, the Hashgraph is not based on PoW, so there is no mining
    that would motivate nodes to perform transaction verification. Instead, Hedera
    hashgraph’s paying model is based on three types of fees to nodes or to Hedera
    paid by clients, and on two types of payments which Hedera pays to nodes or governing
    members:'
  prefs: []
  type: TYPE_NORMAL
- en: Node fee – a client pays this fee to a node for a provided service. Suppose
    the client wants to transfer cryptocurrency from his to another’s account. In
    that case, he contacts a node that submits the transaction to the network (on
    the client’s behalf), that is, the node puts that transaction into the next event
    it creates and gossips it to a neighbor node to be put into consensus through
    the hashgraph consensus mechanism. Node fee is not determined in advance, but
    it is negotiated between node and client.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service fee – a client pays this fee to Hedera for the service provided by the
    platform. The fee is calculated based on the service provided (transaction, file
    storage, or smart contract) and the quantity of the service (e.g., in the case
    of file storage, the service fee depends on the number and sizes of stored files).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network fee – with this fee, a client compensates the node for the network costs,
    that is, for the cost of gossiping the client’s transaction, the cost of temporarily
    storing the transaction in memory, and the cost of calculating the timestamp consensus
    of the event containing the transaction. The fee for each transaction has a fixed
    part and a variable part, which depends on the number of bytes in the transaction.
    The network fee is paid to the node, but then, it is forwarded to Hedera.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Incentive payment – to incentivize nodes to maintain the Hashgraph, Hedera makes
    payments to nodes once a day. This money is taken from the amount that Hedera
    collects from the service and network fees. The amount paid to a node is proportional
    to the stake the node owns, but to be paid, the node must be online and active
    the whole day (e.g., it may be that during 24-h period, the node contributes with
    a minimum of one event each, to at least 90% of rounds)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dividend payments – Hedera may make these payments periodically to the governing
    members as a reward for their role in governance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Through the combination of open (permissionless) consensus and closed (permissioned)
    governance, the Hedera hashgraph platform aims to build more public trust than
    an entirely closed system, which is the key factor for a cryptocurrency to achieve
    global acceptance. The open consensus model assumes a process where nodes join
    the network and (in the way explained earlier) reach the transaction timestamp
    consensus, that is, the consensus in the time order of transactions. In order
    to ensure transparency, this process enables the possibility of anonymous individuals
    joining the network as node operators. On the other hand, it opens the door for
    various misuses of the Hashgraph. These include Sybil attacks or the cases of
    the concentration of power over consensus by a few dishonest members, who could
    use their power to, for instance, modify the ledger inappropriately, counterfeit
    the cryptocurrency, or influence the consensus order of transactions, among others.
    Nevertheless, these threats are prevented by designing a consensus model that
    encourages the emergence of a decentralized network with many thousands of nodes.
    Weighting votes inhibit the conspiracies of groups of nodes and Sybil attacks
    in the hashgraph virtual voting algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: The virtual voting algorithm described earlier in this section assumed that
    the votes of all relevant nodes in the hashgraph were equal. Hedera introduced
    a modification in the algorithm to eliminate collisions – the weighting of nodes’
    votes based on the nodes’ stakes. In other words, each node casts one vote for
    each coin (of Hedera native cryptocurrency) the node owns, so the influence of
    a node on the consensus process is proportional to the amount of cryptocurrency
    in the node’s possession. This type of consensus is known as the Proof of Stake
    (PoS), the idea of which is explained in Section 1\. When a node joins the network,
    it must declare accounts that it can control, while the amount of cryptocurrency
    in those accounts is used as the stake that weights the node’s votes in the hashgraph
    virtual voting algorithm. As mentioned, each node is paid by Hedera on a daily
    basis (for serving as a node) – the payments are proportional to its stake, so
    the stake of a node is effectively earning interest.
  prefs: []
  type: TYPE_NORMAL
- en: The vote weighting in the virtual voting algorithm is relatively easy to implement
    – it can be done through a simple redefinition of the notions of the majority,
    supermajority, and the median value. Instead of at least 2/3 of the number of
    nodes in the community, the term supermajority now represents a group of nodes
    whose stakes in the sum have at least 2/3 of the total amount of money on the
    accounts of all nodes in the community. Similarly, the term majority is redefined,
    and it now means more than 50% of the total amount of stakes. The median of the
    timestamps in a set S of the events’ timestamps now becomes the weighted median,
    which can be considered as the median value of the new enlarged set, *S[enlarged]*
    of the timestamps, where each timestamp *t[i]* from *S* is, in *S[enlarged]*,
    represented by *n[i]* identical copies of itself, assuming that *n[i]* is equal
    to the stake of the node that has created the event with timestamp *t[i]*.
  prefs: []
  type: TYPE_NORMAL
- en: The new meaning of supermajority implicitly changes the definition of strong
    seeing of events in the Hashgraph. Together with the new meaning of the median
    (i.e., weighted median), it influences the order of the consensus transactions,
    so that the wealthier (hence, the more trusted) nodes have more power to reach
    the consensus than some group of new nodes with insincere intentions.
  prefs: []
  type: TYPE_NORMAL
- en: Besides the described mechanisms incorporated in the Hashgraph, such as the
    fee and payment model aimed at incentivizing node operators to participate, or
    the PoS model for inhibition of Sybil attacks and other malicious behaviors, Hedera
    introduces the so-called sharding architecture to ensure future scalability of
    the platform, which is also necessary for the success of a public permissionless
    ledger. This architecture comes from the separation of governance from consensus.
    As the network is expected to expand over time to millions of nodes (all voting
    on distributed consensus), the sharding architecture enables continuous platform
    decentralization.
  prefs: []
  type: TYPE_NORMAL
- en: In its initial phase, the Hedera network will certainly have a relatively small
    number of nodes belonging to a single shard (partition, group). With the expected
    increase of their number in the network, nodes will randomly be grouped in different
    shards. The entity in charge of allocating nodes to shards is called the master
    shard, which randomly assigns new nodes to different shards, once a day. At the
    same time, the master shard moves some nodes between shards to ensure that the
    total amount of cryptocurrency staked in a shard is large enough and that no node
    in a shard owns a large fraction of that amount. All nodes in a shard establish
    consensus on the transactions they collected from their clients and gossiped among
    themselves, that is, they share the same state of their client’s accounts, which
    is a subset of the state of the entire ledger.
  prefs: []
  type: TYPE_NORMAL
- en: Shards are not mutually isolated – occasionally, any member in a shard can send
    a message to a randomly chosen member in some other shard. Each shard maintains
    outgoing message queues for all other shards. Suppose client, *C[a]* of node A
    in the shard *α* wants to send some amount of cryptocurrency to client, *C[b]*
    of node B in the shard *β*. This transaction is first gossiped by node A to the
    nodes in the shard *α*. After reaching the consensus on the order in the shard
    *α*, the account state of client, *C[a]* is decreased by the amount being sent.
  prefs: []
  type: TYPE_NORMAL
- en: An inter-shard message is also created and put in the outgoing queue for the
    shard *β.* Subsequently, at one moment, some node, X, from the shard *α* will
    check that queue and, seeing that it is not empty, X will send this inter-shard
    message (which contains transaction *C[a]*→*C[b]*) together with other messages
    (with other transactions from the shard *α* to *β*, if any) to a randomly chosen
    node, Y, in the shard *β.* When Y receives that list of messages, it creates an
    event containing all the transactions from the received messages and submits this
    event to the nodes in the shard *β* through gossip. When a transaction, *C[a]*→*C[b]*
    reaches consensus in the shard *β* (and if the sequence number of the assigned
    inter-shard message is correct), the effect of the transaction will be applied
    on all nodes in *β*, and the account balance of *C[b]* will be increased by the
    amount being sent.
  prefs: []
  type: TYPE_NORMAL
- en: The positive effects of the sharding architecture can be seen from the above
    described (and simplified) example of the communication between shards in a situation
    when the number of nodes in the network is very large. The number of gossips between
    nodes in the entire network would be many times greater without it, consensus
    and transactions delay would be much longer, and the nodes’ ledger files would
    be much bigger. The separation on shards minimizes the total amount of gossip
    messages in the network, since each transaction is gossiped only within shards
    relevant for that transaction.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Hedera hashgraph platform comprises three layers: the Internet layer, hashgraph
    consensus layer, and service layer. The Internet layer provides a basic communication
    infrastructure for the nodes, that is, for the computers connected to a P2P network,
    communicating by TCP/IP connections with applied TLS encryption. The hashgraph
    consensus layer represents the described process in which nodes take transactions
    from their clients. They share them throughout the network using gossip protocol
    and run the hashgraph consensus algorithm to reach the consensus in time transaction
    order. Then, each node applies the transactions’ effects in consensus order, that
    is, modifies its copy of the shared state (of the clients’ accounts), which is
    identical with the copies on all other nodes of a given shard.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A service layer provides three initial services, relying on the two lower layers:'
  prefs: []
  type: TYPE_NORMAL
- en: Cryptocurrency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: File storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Smart contracts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By offering these services, Hedera intends to realize the idea similar to one
    of the Ethereum networks, where its native cryptocurrency (ETH) is primarily used
    as the incentive tool to power the Ethereum blockchain, primarily designed to
    support different decentralized applications (e.g., in the form of smart contracts).
    Hedera also uses its native cryptocurrency to incentivize nodes (to serve as nodes)
    through its payment model. However, unlike Ethereum, this is not the only (i.e.,
    primary) role of the Hedera cryptocurrency, as the service of processing transactions
    between clients is also important. The developers of decentralized applications
    on the Hedera platform will use its initial services and pay for them in Hedera
    tokens (native cryptocurrency) through the service fees. The Hedera cryptocurrency
    is expected to have a high transaction rate as well, due to the very fast hashgraph
    consensus algorithm. This leads to low network fees, making small, micro transactions
    practical. Therefore, the Hedera cryptocurrency should be suitable for IoT applications,
    too.
  prefs: []
  type: TYPE_NORMAL
- en: Hedera tokens are also used as the means of weighting the virtual voting mechanism
    within Hedera’s staking model – as mentioned. In contrast, PoS contributes to
    network security, for example, to inhibit Sybil attacks. On that aspect, tokens
    should act as the motivating factor for the responsible use and governance of
    the Hedera platform. The total amount of cryptocurrency that Hedera plans to issue
    is 50 billion tokens; thus, the token release schedule will be very slow in the
    beginning. In the first year, the expected distribution of tokens is that about
    65% of the total amount will be held by Hedera Treasury and the rest by trusted
    nodes, that is, the nodes hosted by Hedera management, employees, investors, developers,
    and Swirlds, Inc. Thus, only 10% of the total amount should be circulating among
    clients through transactions, and this amount is expected to increase slowly.
    To be specific, the amount of circulating tokens should not exceed the threshold
    of 33% for at least five years from the initial release. The goal of these precautions
    is to prevent situations in which an attacker (or group of attackers), who owns
    one-third of the tokens, could disrupt the network (since in the Hedera’s PoS
    model, a transaction becomes final when validated by the nodes that hold at least
    two-thirds of tokens in the sum).
  prefs: []
  type: TYPE_NORMAL
- en: Using the second initial service of Hedera – the file storage, users will be
    able to store decentralized files or pointers to files on the Hedera hashgraph
    platform, reliably and transparently. This means that the copy of each added file
    is stored on every node with 100% availability and with the consensus on the exact
    content of the file. The consensus is reached in the same way as for transactions,
    that is, by using a hashgraph consensus algorithm. The concerning events in the
    hashgraph now contain another type of data (instead of transactions). As every
    node in a shard holds an identical copy of the file, it will not be lost if one
    or a few more nodes are corrupted or out of service. A stored file can be deleted
    from the platform only by the entities with a given consent. Decentralized applications
    could use this service to realize different types of registers (such as land ownership
    registers, property title registers, movable asset registries, etc.).
  prefs: []
  type: TYPE_NORMAL
- en: The third initial service of Hedera – smart contracts, is enabled through the
    possibility of containing short computer programs (i.e., code) instead of transactions
    within hashgraph’s events. The execution of these programs, which are written
    in Solidity programming language, is guaranteed on all (honest) nodes as soon
    as the consensus on the events is reached. It is done in the same way the effects
    of a transaction are guaranteed to be applied to the account states of the relevant
    clients on each node’s copy of the ledger, at the moment when the community validates
    the transaction and reaches the timestamp consensus on that transaction. The smart
    contract service allows developers to easily build a broad spectrum of decentralized
    applications on top of the Hedera platform. Smart contracts practically open up
    the possibility of signing the contracts between people, organizations, entities,
    and so on, where it is guaranteed (with 100% confidence) that each clause of a
    signed contract will be executed precisely and at the exact moment as has been
    agreed (i.e., written in the program code). Currently, large libraries of the
    code written in Solidity can be run on the Hedera platform (although the Solidity
    programming language was initially developed to execute smart contracts on Ethereum’s
    platform). More about smart contracts and decentralized applications are covered
    in Section 2.4.
  prefs: []
  type: TYPE_NORMAL
- en: It is clear now that hashgraph technology comprises all the characteristics
    needed to overcome today’s gap between cryptocurrency and the real world. The
    hashgraph’s inventors aimed to create a part of the current cyberspace that can
    be shared among members, who have agreed to act upon the predefined rules. This
    space will be independent, with no negative effects on the members (based on monopoly)
    or the security issues that big technology companies may have, hosting large amounts
    of confidential data. During the testing phase, there will be a small number of
    nodes within the Hedera network, after which the trusted nodes (all run by the
    HHC members) will join the network. In the next phase, other participants will
    be gradually included until the moment of allowed membership to anyone ready to
    host the node, provided they meet the necessary technical requirements of bandwidth,
    computing power, and storage. In the final stage, the Hedera network is expected
    to have millions of nodes worldwide and that many of them will be run by ordinary
    people who want to stay anonymous.
  prefs: []
  type: TYPE_NORMAL
