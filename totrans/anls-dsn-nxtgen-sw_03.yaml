- en: © Springer Nature Switzerland AG 2020A. M. LangerAnalysis and Design of Next-Generation
    Software Architectures[https://doi.org/10.1007/978-3-030-36899-9_3](https://doi.org/10.1007/978-3-030-36899-9_3)
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: © 2020斯普林格自然瑞士公司A. M. 兰格下一代软件架构的分析与设计[https://doi.org/10.1007/978-3-030-36899-9_3](https://doi.org/10.1007/978-3-030-36899-9_3)
- en: 3. Reviewing the Object Paradigm
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3. **复习对象范例**
- en: 'Arthur M. Langer^([1](#Aff2) [ ](#ContactOfAuthor2))(1)Center for Technology
    Management, Columbia University, New York, NY, USAArthur M. LangerEmail: [al261@columbia.edu](mailto:al261@columbia.edu)'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 阿瑟·M·兰格^([1](#Aff2) [ ](#ContactOfAuthor2))(1)哥伦比亚大学技术管理中心，美国纽约阿瑟·M·兰格电子邮件：[al261@columbia.edu](mailto:al261@columbia.edu)
- en: This chapter will provide the historical structured analysis and design methodology
    that led to the object paradigm. At the core of an evolutionary approach are a
    set of traditional tools that need to be extended to meet the needs of an agile
    architecture in a mobile IoT market.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将提供导致对象范例的历史结构化分析和设计方法论。在演进方法的核心是一组传统工具，需要扩展以满足移动物联网市场中敏捷架构的需求。
- en: 3.1 The Concept of the Logical Equivalent
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1 **逻辑等价的概念**
- en: The primary mission of an analyst or systems designer is to extract the physical
    requirements of the users and convert them to software. All software can trace
    its roots to a physical act or a physical requirement. A physical act can be defined
    as something that occurs in the interaction of people, that is, people create
    the root requirements of most systems, especially those in business. For example,
    when Mary tells us that she receives invoices from vendors and pays them thirty
    days later, she is explaining her physical activities during the process of receiving
    and paying invoices. When the analyst creates a technical specification, which
    represent Mary’s physical requirements, the specification is designed to allow
    for the translation of her physical needs into an automated environment. We know
    that software must operate within the confines of a computer, and such systems
    must function on the basis of logic. The logical solution does not always treat
    the process using the same procedures employed in the physical world. In other
    words, the software system implemented to provide the functions which Mary does
    physically will probably work differently and more efficiently than Mary herself.
    Software, therefore, can be thought of as a logical equivalent of the physical
    world. This abstraction, which I call the concept of the Logical Equivalent(LE),
    is a process that analysts must use to create effective requirements of the needs
    of a system. The LE can be compared to a schematic of a plan or a diagram of how
    a technical device works.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 分析员或系统设计师的主要任务是提取用户的物理需求并将其转换为软件。所有软件都可以追溯到一个物理行为或一个物理需求。物理行为可以定义为发生在人们互动中的事情，也就是说，人们创造了大多数系统的根需求，尤其是商业系统。例如，当玛丽告诉我们她从供应商那里收到发票并在三十天后支付时，她正在解释她在接收和支付发票过程中的物理活动。当分析员创建代表玛丽物理需求的技术规范时，规范被设计为允许将她的物理需求转化为自动化环境中的需求。我们知道软件必须在计算机的限制内运行，并且这种系统必须根据逻辑运行。逻辑解决方案并不总是使用与物理世界中使用的相同程序来处理过程。换句话说，实施用于提供玛丽物理所做功能的软件系统可能与玛丽本人的操作方式不同且更有效。因此，软件可以被看作是物理世界的逻辑等价物。我称之为逻辑等价（LE）的抽象概念是分析员必须使用的一种过程，用于创建系统需求的有效性。LE可以类比为计划的原理图或技术设备工作原理的图表。
- en: Any success in creating a concise and accurate schematic of software that needs
    to be developed by a programmer will be directly proportional to how well the
    analyst masters Langer’s ([1997](#CR2)) Concept of the Logical Equivalent. Very
    often requirements are developed by analysts using various methods that do not
    always contain a basis for consistency, reconciliation and maintenance. There
    is usually far too much prose used as opposed to specific diagramming standards
    that are employed by engineers. After all, we are engineering a system through
    the development of software applications. The most critical step in obtaining
    the LE is the understanding of the process of Functional Decomposition. Functional
    Decomposition is the process for finding the most basic parts of a system, like
    defining all the parts of a car so that it can be built. It would be possible
    not from looking at a picture of the car, but rather at a schematic of all the
    functionally decomposed parts. Developing and engineering software is no different
    and essential to create reusable component applications that operate in the IoT
    environment.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 任何在创建一个需要程序员开发的简洁准确的软件示意图方面取得的成功，都将与分析员掌握 Langer（[1997](#CR2)）的逻辑等价概念的程度成正比。通常情况下，需求是由分析员使用各种方法开发的，这些方法并不总是包含一致性、协调和维护的基础。通常使用太多的散文，而不是工程师所采用的具体的图表化标准。毕竟，我们是通过软件应用程序的开发来设计一个系统。获取
    LE 的最关键步骤是理解功能分解的过程。功能分解是找到系统最基本部分的过程，就像定义汽车的所有部分一样，以便能够构建它。可以不从看汽车的图片，而是从所有功能分解部分的图表来看。开发和设计软件并没有什么不同，必须创建可重用的组件应用程序，以在物联网环境中运行。
- en: Below is an example of an analogous process using functional decomposition,
    with its application to the LE.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用功能分解的类似过程的示例，以及其应用于 LE。
- en: In obtaining the physical information from the user, there are a number of modeling
    tools that can be used. Each tool provides a specific function to derive the LE.
    The word “derive” has special meaning here. It relates to the process of Long
    Division, or the process or formula we apply when dividing one number by another.
    Consider the following example:![../images/480347_1_En_3_Chapter/480347_1_En_3_Figa_HTML.png](../images/480347_1_En_3_Chapter/480347_1_En_3_Figa_HTML.png)
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在从用户那里获取物理信息时，可以使用许多建模工具。每个工具都提供了一个特定的函数来推导 LE。这里的“推导”一词具有特殊的含义。它与长除法的过程有关，或者我们在将一个数字除以另一个数字时应用的过程或公式。考虑以下示例：![../images/480347_1_En_3_Chapter/480347_1_En_3_Figa_HTML.png](../images/480347_1_En_3_Chapter/480347_1_En_3_Figa_HTML.png)
- en: The above example shows the formula that is applied to a division problem. We
    call this formula long division. It provides the answer, and if we change any
    portion of the problem, we simply re-apply the formula and generate a new result.
    Most important, once we have obtained the answer, the value of the formula steps
    is only one of documentation. That is, if someone questioned the validity of the
    result, we could show them the formula to prove that the answer was correct (based
    on the input).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的示例展示了应用于除法问题的公式。我们称这个公式为长除法。它提供了答案，如果我们改变问题的任何部分，我们只需重新应用公式并生成一个新的结果。最重要的是，一旦我们得到了答案，公式步骤的价值只是文档中的一部分。也就是说，如果有人质疑结果的有效性，我们可以向他们展示公式以证明答案是正确的（基于输入）。
- en: Now let us apply long division to obtaining the LE via functional decomposition.
    The following is a result of an interview with Joe, a bookkeeper, about his physical
    procedure for handling bounced checks.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们通过功能分解应用长除法来获取 LE。以下是对乔（一位记账员）关于处理退票的物理程序的采访结果。
- en: Joe the bookkeeper receives bounced checks from the bank. He fills out a Balance
    Correction Form and forwards it to the Correction Department so that the outstanding
    balance can be corrected. Joe sends a bounced check letter to the customer requesting
    a replacement check plus a $15.00 penalty (this is now included as part of the
    outstanding balance). Bounced checks are never re-deposited.
  id: totrans-11
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 记账员乔从银行收到了退票支票。他填写了一个余额更正表格，并将其转发给更正部门，以便更正未清余额。乔给客户发送了一封退票信，要求换发支票并支付15.00美元的罚款（这现在包括在未清余额的一部分中）。退票支票永远不会重新存入。
- en: 'The appropriate modeling tool to use in this situation is a Data Flow Diagram
    (DFD). A DFD is a tool that shows how data enters and leaves a particular process.
    The process we are looking at with Joe is the handling of the bounced check. A
    DFD has four possible components:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下使用的适当建模工具是数据流程图（DFD）。DFD是一种显示数据如何进入和离开特定流程的工具。我们要研究的流程是处理退票。DFD有四个可能的组成部分：
- en: '![../images/480347_1_En_3_Chapter/480347_1_En_3_Figb_HTML.png](../images/480347_1_En_3_Chapter/480347_1_En_3_Figb_HTML.png)
    Process:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '![../images/480347_1_En_3_Chapter/480347_1_En_3_Figb_HTML.png](../images/480347_1_En_3_Chapter/480347_1_En_3_Figb_HTML.png)
    流程：'
- en: This denotes the name of the actual function being performed. A valid process
    is one in which data is transformed from one form to another.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这表示正在执行的实际功能的名称。有效的流程是其中数据从一种形式转换为另一种形式的流程。
- en: '![../images/480347_1_En_3_Chapter/480347_1_En_3_Figc_HTML.png](../images/480347_1_En_3_Chapter/480347_1_En_3_Figc_HTML.png)
    Data Flow:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '![../images/480347_1_En_3_Chapter/480347_1_En_3_Figc_HTML.png](../images/480347_1_En_3_Chapter/480347_1_En_3_Figc_HTML.png)
    数据流：'
- en: This represents data entering or leaving a Process, External or Data Store.
    The arrow denotes direction of the flow. A data flow is sometimes called “data-in-motion.”
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这表示进入或离开一个流程、外部或数据存储的数据。箭头表示流动的方向。数据流有时被称为“运动中的数据”。
- en: '![../images/480347_1_En_3_Chapter/480347_1_En_3_Figd_HTML.png](../images/480347_1_En_3_Chapter/480347_1_En_3_Figd_HTML.png)
    Data Store:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '![../images/480347_1_En_3_Chapter/480347_1_En_3_Figd_HTML.png](../images/480347_1_En_3_Chapter/480347_1_En_3_Figd_HTML.png)
    数据存储：'
- en: Stored data usually kept in a file. It represents data that can be accessed
    from a specific area. A data store is sometimes called “data-at-rest.”
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 通常保存在文件中的存储数据。它代表可以从特定区域访问的数据。数据存储有时被称为“静止的数据”。
- en: '![../images/480347_1_En_3_Chapter/480347_1_En_3_Fige_HTML.png](../images/480347_1_En_3_Chapter/480347_1_En_3_Fige_HTML.png)
    External:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '![../images/480347_1_En_3_Chapter/480347_1_En_3_Fige_HTML.png](../images/480347_1_En_3_Chapter/480347_1_En_3_Fige_HTML.png)
    外部：'
- en: A provider or user of the data that is not part of the system. It therefore
    represents a boundary.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 不属于系统的数据提供者或用户。因此，它代表了一个边界。
- en: Now let us draw the LE of Joe’s procedure using DFD tools as shown in Fig. [3.1](#Fig1).![../images/480347_1_En_3_Chapter/480347_1_En_3_Fig1_HTML.png](../images/480347_1_En_3_Chapter/480347_1_En_3_Fig1_HTML.png)
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用DFD工具绘制Joe过程的LE，如图 [3.1](#Fig1)所示。![../images/480347_1_En_3_Chapter/480347_1_En_3_Fig1_HTML.png](../images/480347_1_En_3_Chapter/480347_1_En_3_Fig1_HTML.png)
- en: Fig. 3.1
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1
- en: Data flow diagram for handling bounced checks
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 处理退票的数据流程图
- en: The above DFD shows that bounced checks arrive from the bank, the Account Master
    file is updated, the Correction Department is informed and Customers receive a
    letter. The Bank, Correction Department and Customers are considered “outside”
    the system and are therefore represented logically as Externals. This diagram
    is considered to be at the first level or “Level 1” of functional decomposition.
    You will find that all modeling tools employ a method to functionally decompose.
    DFDs use a method called “Leveling.”
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 上述DFD显示了退票从银行到达，更新账户主文件，通知更正部门和客户收到一封信。银行、更正部门和客户被视为“系统外部”，因此在逻辑上表示为外部。该图被认为是功能分解的第一级或“Level
    1”。您将发现所有建模工具都采用一种功能分解方法。DFD使用一种称为“分层”的方法。
- en: The question is whether we have reached the most basic parts of this process
    or should we level further. Many analysts suggest that a fully decomposed DFD
    should have only one data flow input and one data flow output. Our diagram currently
    has many inputs and outputs and therefore it can be leveled further. The result
    of functionally decomposing to the second level (Level 2) is as shown in Fig. [3.2](#Fig2).![../images/480347_1_En_3_Chapter/480347_1_En_3_Fig2_HTML.png](../images/480347_1_En_3_Chapter/480347_1_En_3_Fig2_HTML.png)
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是我们是否已经达到了这个过程的最基本部分，或者我们应该进一步分层。许多分析人员认为，完全分解的DFD应该只有一个数据流输入和一个数据流输出。我们的图当前有许多输入和输出，因此可以进一步分层。将功能分解到第二级（Level
    2）的结果如图 [3.2](#Fig2)所示。![../images/480347_1_En_3_Chapter/480347_1_En_3_Fig2_HTML.png](../images/480347_1_En_3_Chapter/480347_1_En_3_Fig2_HTML.png)
- en: Fig. 3.2
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2
- en: Level 2 data flow diagram for handling bounced checks
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 用于处理退票的二级数据流程图
- en: 'Notice that the functional decomposition shows us that Process 1: Handling
    Bounced Checks is really made up of two sub-processes called 1.1 Update Balance
    and 1.2 Send Letter. The box surrounding the two processes within the Externals
    reflects them as components of the previous or parent level. The double-sided
    arrow in Level 1 is now broken down to two separate arrows going in different
    directions because it is used to connect Processes 1.1 and 1.2\. The new level
    is more functionally decomposed and a better representation of the LE.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，功能分解向我们展示了 Process 1：Handling Bounced Checks 实际上由两个名为 1.1 Update Balance
    和 1.2 Send Letter 的子过程组成。Externals 中包围两个过程的框反映它们作为前一级或父级的组件。Level 1 中的双向箭头现在被分解为两个分别指向不同方向的箭头，因为它用于连接
    Process 1.1 和 1.2。新的级别更加功能分解，更好地表示了 LE。
- en: Once again, we must ask ourselves whether Level 2 can be further decomposed.
    The answer is yes. Process 1.1 has two outputs to one input. On the other hand,
    Process 1.2 has one input and one output and is therefore complete. 1.2 is said
    to be at the Functional Primitive, a DFD that cannot be decomposed further. Therefore,
    only 1.1 will be decomposed.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们必须问自己，Level 2 是否可以进一步分解。答案是肯定的。Process 1.1 有两个输出到一个输入。另一方面，Process 1.2
    有一个输入和一个输出，因此是完整的。1.2 被称为 Functional Primitive，一个不能进一步分解的 DFD。因此，只有 1.1 将被分解。
- en: Let us decompose 1.1 as depicted in Fig. [3.3](#Fig3).![../images/480347_1_En_3_Chapter/480347_1_En_3_Fig3_HTML.png](../images/480347_1_En_3_Chapter/480347_1_En_3_Fig3_HTML.png)
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照[3.3](#Fig3)中描述的方式分解 1.1。![../images/480347_1_En_3_Chapter/480347_1_En_3_Fig3_HTML.png](../images/480347_1_En_3_Chapter/480347_1_En_3_Fig3_HTML.png)
- en: Fig. 3.3
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3
- en: Level 3 data flow diagram for handling bounced checks
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 处理退票的 Level 3 数据流程图
- en: 'Process 1.1 is now broken down into two sub processes: 1.1.1 Update Account
    Master and 1.1.2 Inform Correction Department. Process 1.1.2 is a Functional Primitive
    since it has one input and one output. Process 1.1.1 is also considered a Functional
    Primitive because the “Bounced Check Packet” flow is between the two processes
    and is used to show connectivity only. functional decomposition is at Level-3
    and is now complete.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Process 1.1 被分解为两个子过程：1.1.1 更新账户主文件 和 1.1.2 通知更正部门。Process 1.1.2 是一个 Functional
    Primitive，因为它有一个输入和一个输出。Process 1.1.1 也被认为是 Functional Primitive，因为“Bounced Check
    Packet” 流是两个过程之间的流，并且仅用于显示连通性。功能分解处于 Level-3，现在已经完成。
- en: The result of functional decomposition is the following DFD (Fig. [3.4](#Fig4)).![../images/480347_1_En_3_Chapter/480347_1_En_3_Fig4_HTML.png](../images/480347_1_En_3_Chapter/480347_1_En_3_Fig4_HTML.png)
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 功能分解的结果是以下 DFD（图见[3.4](#Fig4)）。![../images/480347_1_En_3_Chapter/480347_1_En_3_Fig4_HTML.png](../images/480347_1_En_3_Chapter/480347_1_En_3_Fig4_HTML.png)
- en: Fig. 3.4
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4
- en: Functionally decomposed level 3 data flow diagram for handling bounced checks
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 处理退票的功能分解的 Level 3 数据流程图
- en: As in long division, only the complete result, represented above, is used as
    the answer. The preceding steps are formulas that we use to get to the lowest,
    simplest representation of the logical equivalent. Levels 1, 2 and 3 are used
    only for documentation of how the final DFD was determined.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 就像长除法一样，只有上面表示的完整结果被用作答案。前面的步骤是我们用来得到逻辑等效的最低、最简单表示的公式。Level 1、2 和 3 仅用于记录最终
    DFD 的确定方式。
- en: The logical equivalent is an excellent method that allows analysts and systems
    designers to organize information obtained from users and to systematically derive
    the most fundamental representation of their process. It also alleviates unnecessary
    pressure to immediately understand the detailed flows and provides documentation
    of how the final schematic was developed.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑等效是一种出色的方法，允许分析员和系统设计师组织从用户获取的信息，并系统地推导出其过程的最基本表示。它还减轻了立即理解详细流程的不必要压力，并提供了最终原理图的开发文档。
- en: 3.2 Tools of Structured Analysis
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2 结构化分析工具
- en: Now that we have established the importance and goals of the logical equivalent,
    we can turn to a discussion of the methods available to assist the analyst. These
    methods serve as the tools to create the best models in any given situation, and
    thus the most exact logical equivalent. The tools of the analyst are something
    like those of a surgeon, who uses only the most appropriate instruments during
    an operation. It is important to understand that the surgeon is sometimes faced
    with choices about which surgical instruments to use; particularly with new procedures,
    there is sometimes disagreement among surgeons about which instruments are the
    most effective. The choice of tools for analysis and data processing is no different;
    indeed, it can vary more and be more confusing. The medical profession, like many
    others, is governed by its own ruling bodies. The American Medical Association
    and the American College of Physicians and Surgeons, as well as state and federal
    regulators, represent a source of standards for surgeons. Such a controlling body
    does not exist in the data processing industry, nor does it appear likely that
    one will arise in the near future. Thus, the industry has tried to standardize
    among its own leaders. The result of such efforts has usually been that the most
    dominant companies and organizations create standards to which others are forced
    to comply. For example, Microsoft has established itself as an industry leader
    by virtue of its software domination. Here, Might is Right!
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经确定了逻辑等效性的重要性和目标，我们可以转而讨论可用于协助分析人员的方法。这些方法就像外科医生的工具一样，外科医生在手术过程中只使用最合适的工具。重要的是要了解，外科医生有时会面临关于使用哪种外科手术器械的选择；特别是对于新的程序，有时外科医生之间对哪种器械最有效存在分歧。对于分析和数据处理的工具的选择也是如此；事实上，它可能变化更大，更加混乱。医学行业和许多其他行业一样，都受到其自身管理机构的管辖。美国医学协会和美国内科医师和外科医师学会，以及州和联邦监管机构，代表了外科医生的标准来源。数据处理行业没有这样的控制机构，也不太可能在不久的将来出现这样的机构。因此，该行业试图在自己的领导者中间建立标准。这样做的结果通常是，最具主导地位的公司和组织制定了其他公司不得不遵守的标准。例如，微软凭借其软件的统治地位确立了自己作为行业领导者的地位。在这里，权利即是权力！
- en: Since there are no real formal standards in the industry, the analysis tools
    discussed here will be presented on the basis of both their advantages and their
    shortcomings. It is important then to recognize that no analysis tool (or methodology
    for that matter) can do the entire job, nor is any perfect at what it does. To
    determine the appropriate tool, analysts must fully understand the environment,
    the technical expertise of users and the time constraints imposed on the project.
    By “environment” we mean the existing system and technology, computer operations,
    and the logistics–both technically and geographically–of the new system. The treatment
    of the user interface should remain consistent with the guidelines discussed in
    Chap. [2](480347_1_En_2_Chapter.xhtml).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 由于行业中没有真正的正式标准，因此本文讨论的分析工具将基于它们的优点和缺点来介绍。因此，重要的是要认识到，没有任何分析工具（或方法论）能够完成整个工作，也没有任何一个在其所做的事情上是完美的。为了确定合适的工具，分析人员必须充分了解环境、用户的技术专长和项目所施加的时间限制。所谓“环境”，是指现有系统和技术、计算机操作以及新系统的技术和地理逻辑，包括技术和地理逻辑。用户界面的处理应与第[2](480347_1_En_2_Chapter.xhtml)章讨论的指南保持一致。
- en: The problem of time constraints is perhaps the most critical of all. The tools
    you would ideally like to apply to a project may not fit the time frame allotted.
    What happens, then, if there is not enough time? The analyst is now faced with
    selecting a second-choice tool that undoubtedly will not be as effective as the
    first one would have been. There is also the question of how tools are implemented,
    that is, can a hybrid of a tool be used when time constraints prevent full implementation
    of the desired tool?
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 时间限制问题也许是最关键的问题。你理想情况下想应用于项目的工具可能不符合规定的时间框架。那么，如果时间不够，会发生什么？分析人员现在面临的是选择第二选择工具的问题，毫无疑问，这个工具将不会像第一个工具那样有效。还有一个问题是工具的实施方式，也就是说，当时间限制阻止了所需工具的完全实施时，是否可以使用工具的混合体？
- en: 3.3 Making Changes and Modifications
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3 进行变更和修改
- en: 'Within the subject of analysis tools is the component of maintenance modeling,
    or how to apply modeling tools when making changes or enhancements to an existing
    product. Maintenance modeling falls into two categories:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '1.'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Pre-modeled: where the existing system already has models that can be used
    to effect the new changes to the software.'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Legacy System: where the existing system has never been modeled; any new modeling
    will therefore be incorporating analysis tools for the first time.'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Pre*-*modeled*:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Simply put, a Pre-Modeled product is already in a structured format. A structured
    format is one that employs a specific format and methodology such as the data
    flow diagram.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'The most challenging aspects of changing Pre-Modeled tools are:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '1.'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: keeping them consistent with their prior versions, and
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: implementing a version control system that provides an audit-trail of the analysis
    changes and how they differ from the previous versions. Many professionals in
    the industry call this Version Control; however, care should be taken in specifying
    whether the version control is used for the maintenance of analysis tools. Unfortunately,
    Version Control can be used in other contexts, most notably in the tracking of
    program versions and software documentation. For these cases, special products
    exist in the market which provide special automated “version control” features.
    We are not concerned here with these products but rather with the procedures and
    processes that allow us to incorporate changes without losing the prior analysis
    documentation. This kind of procedure can be considered consistent with the long
    division example in which each time the values change, we simply re-apply the
    formula (methodology) to calculate the new answer. Analysis version control must
    therefore have the ability to take the modifications made to the software and
    integrate them with all the existing models as necessary.
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Being Consistent*:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: 'It is difficult to change modeling methods and/or CASE tools in the middle
    of the life cycle of a software product. One of our main objectives then is to
    try avoid doing so. How? Of course, the simple answer is to select the right tools
    and CASE software the first time. However, we all make mistakes, and more importantly,
    there are new developments in systems architecture that may make a new CASE product
    attractive. You would be wise to foresee this possibility and prepare for inconsistent
    tools implementation. The best offense here is to:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: ensure that your CASE product has the ability to transport models through an
    ASCII file or cut/paste method. Many have interfaces via an “export” function.
    Here, at least, the analyst can possibly convert the diagrams and data elements
    to another product.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: keep a set of diagrams and elements that can be used to establish a link going
    forward, that is, a set of manual information that can be re-input to another
    tool. This may be accomplished by simply having printed documentation of the diagrams;
    however, experience has shown that it is difficult to keep such information up
    to date. Therefore, the analyst should ensure that there is a procedure for printing
    the most current diagrams and data elements.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保留一组图表和元素，可以用于建立将来的链接，即，可以重新输入到另一个工具中的一组手动信息。这可以通过简单地打印图表的文档来完成；然而，经验表明，难以保持此类信息的最新性。因此，分析师应确保有一个打印最新图表和数据元素的程序。
- en: Should the organization decide to use different tools, e.g., process-dependency
    diagrams instead of data flow diagrams, or a different methodology such as crows-foot
    method in Entity Relational Diagramming, then the analyst must implement a certain
    amount of re-engineering. This means mapping the new modeling tools to the existing
    ones to ensure consistency and accuracy. This is no easy task, and it is strongly
    suggested that you document the diagrams so you can reconcile them.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果组织决定使用不同的工具，例如流程依赖图而不是数据流图，或者使用实体关系图中的不同方法，比如“鸟脚法”，那么分析师必须进行一定程度的重新工程。这意味着将新的建模工具映射到现有工具，以确保一致性和准确性。这绝非易事，强烈建议您记录这些图表，以便进行对比调和。
- en: '*Version Control*:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*版本控制*：'
- en: 'This book is not intended to focus on the generic aspects of version control;
    however, structured methods must have audit trail. When a new process is changed,
    a directory should be created for the previous version. The directory name typically
    consists of the version and date such as: xyz1.21295, where xyz is the name of
    the product or program, 1.2 the version and 1295 the version date. In this way
    previous versions can be easily re-created or viewed. Of course, saving a complete
    set of each version may not be feasible or may be too expensive (in terms of disk
    space, etc.). In these situations, it is advisable to back up the previous version
    in such a manner as to allow for easy restoration. In any case, a process must
    exist, and it is crucial that there be a procedure to do backups periodically.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 本书并不打算重点讨论版本控制的通用方面；但是，结构化方法必须具有审计跟踪。当新流程更改时，应为以前的版本创建一个目录。目录名称通常由版本和日期组成，例如：xyz1.21295，其中xyz是产品或程序的名称，1.2是版本，1295是版本日期。通过这种方式，以前的版本可以很容易地重新创建或查看。当然，保存每个版本的完整集可能不可行，或者可能过于昂贵（以磁盘空间等方面计算）。在这些情况下，建议以允许轻松恢复的方式备份以前的版本。无论如何，必须存在一个流程，并且非常重要的是必须有一个定期进行备份的过程。
- en: 3.4 What is Object-Oriented Analysis?
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.4 什么是面向对象分析？
- en: Object-Oriented Analysis is the key analysis tool in the design of successful
    mobile applications. It is without question the most important element of creating
    what may be called the “complete” requirement agile system. There are a number
    of approaches used by the industry and perhaps controversy about the best approach
    and tools that should be used to create mobile-object systems. This chapter will
    focus on developing the requirements for object systems and the challenges of
    converting legacy systems. Therefore, many of the terms will be defined based
    on their fundamental capabilities and how they can be used by a practicing analyst
    (as opposed to a theorist!).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象分析是设计成功移动应用程序的关键分析工具。毫无疑问，它是创建所谓的“完整”需求敏捷系统的最重要因素。行业中使用了许多方法，可能存在关于应该使用哪种方法和工具来创建移动对象系统的争议。本章将重点讨论开发对象系统的需求以及将遗留系统转换的挑战。因此，许多术语将基于它们的基本功能以及实践分析员如何使用它们来定义（而不是理论家！）。
- en: 'Object Orientation (OO) is based on the concept that every requirement ultimately
    must belong to an object. It is therefore critical that we first define what is
    meant by an object. In the context of OO analysis, an object is any cohesive whole
    made up of two essential components: data and processes (Fig. [3.5](#Fig5)).![../images/480347_1_En_3_Chapter/480347_1_En_3_Fig5_HTML.png](../images/480347_1_En_3_Chapter/480347_1_En_3_Fig5_HTML.png)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象（OO）基于一个概念，即每个需求最终必须属于一个对象。因此，首先定义什么是对象非常重要。在面向对象分析的上下文中，对象是由两个基本组件构成的任何具有内聚性的整体：数据和过程（图 [3.5](#Fig5)）。![../images/480347_1_En_3_Chapter/480347_1_En_3_Fig5_HTML.png](../images/480347_1_En_3_Chapter/480347_1_En_3_Fig5_HTML.png)
- en: Fig. 3.5
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5
- en: A car is an example of a physical object
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 汽车是物理对象的一个示例
- en: Traditional analysis approaches were traditionally based on the examination
    of a series of events. We translated these events from the physical world by first
    interviewing users and then developing what was introduced as the concept of the
    logical equivalent. Although we are by no means abandoning this necessity, the
    OO paradigm requires that these events belong to an identifiable object. Let us
    expand on this difference using the object shown below, an object we commonly
    call a “car.”
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的分析方法通常基于一系列事件的审查。我们通过首先与用户进行访谈，然后开发所介绍的逻辑等价概念，将这些事件从物理世界翻译过来。尽管我们绝不放弃这种必要性，但面向对象的范式要求这些事件属于可识别的对象。让我们利用下面所示的对象，一个我们通常称之为“汽车”的对象，来扩展一下这种差异。
- en: The above car may represent a certain make and model, but it also contains common
    components that are contained in all cars (e.g., an engine). If we were to look
    upon the car as a business entity of an organization, we might find that the following
    three systems were developed over the years.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 上述汽车可能代表某种品牌和型号，但它也包含所有汽车都含有的常见组件（例如发动机）。如果我们将汽车视为组织的业务实体，我们可能会发现以下三个系统是多年来开发的。
- en: 'The above diagram shows us that the three systems were built over a period
    of 21 years. Each system was designed to provide service to a group of users responsible
    for particular tasks. The diagram shows that the requirements for System 1 were
    based on the engine and front-end of the car. The users for this project had no
    interest in or need for any other portions of the car. System 2, on the other
    hand, focused on the lower center and rear of the car. Notice, however, that System
    2 and System 1 have an overlap. This means that there are parts and procedures
    common to both systems. Finally, System 3 reflects the upper center and rear of
    the car and has an overlap with System 2\. It is also important to note that there
    are components of the car that have not yet been defined, probably because no
    user has had a need for them. We can look at the car as an object and Systems
    1–3 as the software which has so far been defined about that object. Our observations
    should also tell us that the entire object is not defined and more important,
    that there is probable overlap of data and functionality among the systems that
    have been developed. This case exemplifies the history of most development systems.
    It should be clear that the users who stated their requirements never had any
    understanding that their own situation belonged to a larger composite object.
    Internal users tend to establish requirements based on their own job functions
    and their own experiences in those functions. Therefore, the analyst who interviews
    users about their events is exposed to a number of risks:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图表告诉我们，这三个系统是在21年的时间内构建的。每个系统都设计为为负责特定任务的一组用户提供服务。图表显示，系统1的需求基于汽车的发动机和前端。这个项目的用户对汽车的其他部分没有兴趣或需求。另一方面，系统2着重于汽车的下部中心和后部。然而，请注意，系统2和系统1存在重叠。这意味着两个系统都有共同的部件和程序。最后，系统3反映了汽车的上部中心和后部，并且与系统2存在重叠。还值得注意的是，汽车的某些组件尚未定义，可能是因为没有用户需要它们。我们可以将汽车视为一个对象，将系统1-3视为围绕该对象定义的软件。我们的观察还应该告诉我们，整个对象尚未定义，并且更重要的是，已经开发的系统之间可能存在数据和功能的重叠。这种情况是大多数开发系统的历史的典型例子。应该清楚的是，陈述其需求的用户从未意识到自己的情况属于一个更大的复合对象。内部用户往往根据自己的工作职能和在这些职能中的经验来建立需求。因此，对用户事件进行访谈的分析人员面临着一些风险：
- en: Users tend to identify only what they have experienced, rather than speculating
    about other events that could occur. This is a significant limitation in the mobile
    world and in attempting to understand what consumer *may* want in the future.
    We know that such events can take place, although they have not yet occurred (you
    should recall the discussion of using STDs as a modeling tool to identify unforeseen
    possibilities). Consider, for example, an analysis situation in which $50,000
    must be approved by the firm’s Controller. This event might show only the approval,
    not the rejection. The user’s response is that the Controller, while examining
    the invoices, has never rejected one and therefore no rejection procedure exists.
    You might ask why. Well, in this case the Controller was not reviewing the invoices
    for rejection but rather holding them until he/she was confident that the company’s
    cash flow could support the issuance of these invoices. Obviously, the Controller
    could decide to reject an invoice. In such a case, the software would require
    a change to accommodate this new procedure. From a software perspective we call
    this a system enhancement, and it would result in a modification to the existing
    system.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other parts of the company may be affected by the Controller’s review of the
    invoices. Furthermore, are we sure that no one else has automated this process
    before? One might think such prior automation could never be overlooked, especially
    in a small company, but when users have different names for the same thing (remember
    Customer and Client!) it is very likely that such things will occur. In this example
    there were two situations where different systems overlapped in functionality.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There will be conflicts between the systems with respect to differences in data
    and process definitions. Worst of all, these discrepancies may not be discovered
    until years after the system is delivered.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The above example shows us that requirements obtained based on an individual’s
    events require another level of reconciliation to ensure they are accurate. Requirements
    are said to be “complete” when they define the whole object. The more incomplete
    they are, the more modifications likely will be required later. The more modifications
    in a system, the higher the likelihood that data and processes across applications
    may conflict with each other. Ultimately this results in a less dependable, lower
    quality system. Most of all, event analysis alone is prone to missing events that
    users have never experienced. This situation is represented in the car example
    by the portions of the car not included in any of the three systems. System functions
    and components may also be missed because users are absent or unavailable at the
    time of the interviews, or because no one felt the need to automate a certain
    aspect of the object. In either case, the situation should be clear. We need to
    establish objects prior to doing event analysis.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Before we discuss the procedures for identifying an object, it is worth looking
    at the significant differences between the object approach and earlier approaches.
    The first major systems were developed in the 1960s and were called Batch, meaning
    that they typically operated on a transaction basis. Transactions were collected
    and then used to update a master file. Batch systems were very useful in the financial
    industries, including banks. We might remember having to wait until the morning
    after a banking transaction to see our account balance because a batch process
    updated the master account files overnight. These systems were built based on
    event interviewing, where programmer/analysts met with users and designed the
    system. Most of these business systems were developed and maintained using COBOL.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论识别对象的程序之前，值得看看对象方法与早期方法之间的重大差异。最初的主要系统是在60年代开发的，被称为批处理，意味着它们通常按事务处理。事务被收集，然后用于更新主文件。批处理系统在金融行业，包括银行，非常有用。我们可能还记得在银行交易后等待到第二天早上才能看到我们的账户余额，因为批处理过程在夜间更新主账户文件。这些系统是基于事件访谈构建的，程序员/分析员与用户会面并设计系统。大多数这些业务系统都是使用COBOL开发和维护的。
- en: In the early seventies, the new buzz word was “on-line, real-time” meaning that
    many processes could now update data immediately or on a “real-time” basis. Although
    systems were modified to provide these services, it is important to understand
    that they were not re-engineered. That is, the existing systems, which were based
    on event interviews, were modified, but not redesigned.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在70年代初，新的热词是“在线，实时”，意味着许多过程现在可以立即更新数据或根据“实时”更新。尽管系统已经修改以提供这些服务，但重要的是要理解它们没有重新设计。也就是说，现有系统是基于事件访谈构建的，经过修改但没有重新设计。
- en: In the late 80s and early 90s the hot term became “Client/Server.” These systems,
    which will be discussed later, are based on sophisticated distributed systems
    concepts. Information and processes are distributed among many Local and Wide
    Area Networks. Many of these client/server systems are re-constructions of the
    on-line real-time systems which in turn were developed from the 1960s batch systems.
    The point here is that we have been applying new technology to systems that were
    designed over 30 years ago without considering the obsolescence of the design.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在80年代末和90年代初，热门术语变成了“客户端/服务器”。这些系统，稍后将讨论，基于复杂的分布式系统概念。信息和流程分布在许多本地和广域网络之间。许多这些客户端/服务器系统是从60年代的批处理系统发展而来的在线实时系统的重建。关键在于，我们一直在将新技术应用于设计已有30多年的系统，而没有考虑设计的过时性。
- en: Through these three generations of systems, the analyst has essentially been
    on the outside looking in (see Fig. [3.6](#Fig6)). The completeness of the analysis
    was dependent upon–and effectively dictated by–the way the inside users defined
    their business needs.![../images/480347_1_En_3_Chapter/480347_1_En_3_Fig6_HTML.png](../images/480347_1_En_3_Chapter/480347_1_En_3_Fig6_HTML.png)
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这三代系统，分析员基本上是从外部看向内部（见图 [3.6](#Fig6)）。分析的完整性取决于——并且实际上是由——内部用户定义其业务需求的方式所决定的。![../images/480347_1_En_3_Chapter/480347_1_En_3_Fig6_HTML.png](../images/480347_1_En_3_Chapter/480347_1_En_3_Fig6_HTML.png)
- en: Fig. 3.6
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6
- en: Requirements are often developed by analysts from an outside view. The specifications
    are therefore dependent on the completeness of the user’s view
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 需求通常由分析员从外部视角开发。因此，规范取决于用户视角的完整性。
- en: '![../images/480347_1_En_3_Chapter/480347_1_En_3_Fig7_HTML.png](../images/480347_1_En_3_Chapter/480347_1_En_3_Fig7_HTML.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![../images/480347_1_En_3_Chapter/480347_1_En_3_Fig7_HTML.png](../images/480347_1_En_3_Chapter/480347_1_En_3_Fig7_HTML.png)'
- en: Fig. 3.7
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7
- en: This diagram reflects the three systems developed to support the car object
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 此图反映了为支持汽车对象开发的三个系统
- en: OO, on the other hand, requires that the analyst have a view from the inside
    looking out. What we mean here is that the analyst first needs to define the generic
    aspects of the object and then map the user views to the particular components
    that exist within the object itself (Fig. [3.7](#Fig7)). The diagram below shows
    a conceptual view of the generic components that could be part of a bank.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，面向对象要求分析员从内部向外部看。我们在这里的意思是，分析员首先需要定义对象的通用方面，然后将用户视图映射到对象本身存在的特定组件（图 [3.7](#Fig7)）。下面的图示显示了可能成为银行的通用组件的概念视图。
- en: Figure [3.8](#Fig8) shows the essential functions of the bank. The analyst is
    on the inside of the organization when interviewing users and therefore will have
    the ability to map a particular requirement to one or more of its essential functions.
    In this approach, any user requirement must fit into at least one of the essential
    components. If a user has a requirement that is not part of an essential component,
    then it must be either qualified as missing (and thus added as an essential component)
    or rejected as inappropriate.![../images/480347_1_En_3_Chapter/480347_1_En_3_Fig8_HTML.png](../images/480347_1_En_3_Chapter/480347_1_En_3_Fig8_HTML.png)
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图[3.8](#Fig8)展示了银行的基本功能。分析师在与用户进行访谈时处于组织内部，因此将能够将特定需求映射到一个或多个基本功能上。在这种方法中，任何用户需求都必须至少符合一个基本组件。如果用户有一个不属于基本组件的需求，则必须将其标记为缺失（因此将其添加为基本组件）或将其视为不适当。![../images/480347_1_En_3_Chapter/480347_1_En_3_Fig8_HTML.png](../images/480347_1_En_3_Chapter/480347_1_En_3_Fig8_HTML.png)
- en: Fig. 3.8
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8
- en: Using the object approach, the analyst interviews users from the inside looking
    out
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 使用对象方法，分析师从内部向外部访问用户进行访谈
- en: 'The process of taking user requirements and placing each of their functions
    into the appropriate essential component can be called mapping. The importance
    of mapping is that functions of requirements are logically placed where they generically
    belong, rather than according to how they are physically implemented. For example,
    suppose Joseph, who works for a bank, needed to provide information to a customer
    about the bank’s investment offerings. Joseph would need to access investment
    information from the system. If OO methods were used to design the system, all
    information about banking investments would be grouped together generically. Doing
    it this way allows authorized personnel to access investment information regardless
    of what they do in the bank. If event analysis alone was used, Joseph would probably
    have his own subsystem that defines his particular requirements for accessing
    investment information. The problem here is twofold: first, the subsystem does
    not contain all of the functions relating to investments. Should Joseph need additional
    information, he may need an enhancement or need to use someone else’s system at
    the bank. Second, Joseph’s subsystem may define functions that have already been
    defined elsewhere in another subsystem. The advantage of OO is that it centralizes
    all of the functions of an essential component and allows these functions to be
    “reused” by all processes that require its information. The computer industry
    calls this capability Reusable Objects.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 将用户需求并将其功能放置到适当的基本组件中的过程称为映射。映射的重要性在于，需求的功能被逻辑地放置在它们通常属于的位置，而不是根据它们如何物理实现。例如，假设约瑟夫在一家银行工作，需要向客户提供有关银行投资产品的信息。约瑟夫需要从系统中获取投资信息。如果使用OO方法来设计系统，所有与银行投资相关的信息都将被通用地分组在一起。以这种方式进行允许授权人员访问投资信息，而不管他们在银行做什么。如果仅使用事件分析，约瑟夫可能会拥有自己的子系统，用于定义访问投资信息的特定需求。问题在于，首先，该子系统不包含与投资相关的所有功能。如果约瑟夫需要额外的信息，则可能需要增强或需要在银行使用其他人的系统。其次，约瑟夫的子系统可能会定义已在另一个子系统中定义的功能。OO的优势在于，它将一个基本组件的所有功能集中在一起，并允许这些功能被所有需要其信息的过程“重用”。计算机行业称这种能力为可重用对象。
- en: 3.5 Identifying Objects and Classes
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.5 识别对象和类
- en: 'The most important challenge of successfully implementing OO is the ability
    to understand and select Objects. We have already used an example which identified
    a car as an object. This example is what can be called the tangible object, or
    as the industry calls them “physical objects.” Unfortunately, there is another
    type of object called an “abstract” or intangible object. An intangible object
    is one that you cannot touch or as Grady Booch originally described: “something
    that may be apprehended intellectually…Something towards which thought or action
    is directed.”^([1](#Fn1)) An example of an intangible object is the security component
    of the essentials of the bank. In many instances OO analysis will begin with identifying
    tangible objects which will in turn make it easier to discover the intangible
    ones.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 成功实现OO的最重要挑战是理解和选择对象的能力。我们已经使用了一个将汽车识别为对象的示例。这个示例是可以称为有形对象或行业称之为“物理对象”的东西。不幸的是，还有另一种类型的对象，称为“抽象”或无形对象。无形对象是你无法触摸的对象，或者正如Grady
    Booch最初描述的：“可以在智力上理解的…朝向思想或行动的东西。”^([1](#Fn1)) 无形对象的一个示例是银行基本要素中的安全组件。在许多情况下，OO分析将从识别有形对象开始，这将进而更容易地发现无形对象。
- en: OO is somewhat consistent with the architecture of process and data in that
    all objects contain their own data and processes, called attributes and services,
    respectively. Attributes are effectively a list of data elements which are permanent
    components of the object. For example, a steering wheel is a data element that
    is a permanent attribute of the object “Car.” The services (or operations), on
    the other hand, define all of the processes that are permanently part or “owned”
    by the object. “Starting the Car” is a service that is defined within the object
    car. This service contains the algorithms necessary to start a car. Services are
    defined and invoked through a method. A method is a process specification for
    an operation (service).^([2](#Fn2)) For example, “Driving the Car” could be a
    method for the car object. The Driving the Car” method would invoke a service
    called “Starting the Car” as well as other services until the entire method requirement
    is satisfied. Although a service and method can have a one-to-one relationship,
    it is more likely that a service will be a subset or be one of the operations
    that make up a method.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: OO 在某种程度上与过程和数据的架构一致，因为所有对象都包含它们自己的数据和进程，分别称为属性和服务。属性实际上是数据元素的列表，它们是对象的永久组成部分。例如，方向盘是对象“汽车”的永久属性的数据元素。而服务（或操作）则定义了所有永久地属于对象或“拥有”的进程。“启动汽车”是在对象汽车中定义的服务。该服务包含启动汽车所需的算法。服务是通过方法定义和调用的。方法是操作（服务）的过程规范。^([2](#Fn2))
    例如，“驾驶汽车”可以是汽车对象的一个方法。 “驾驶汽车”的方法将调用一个名为“启动汽车”的服务以及其他服务，直到满足整个方法的要求。虽然服务和方法可能具有一对一的关系，但更可能的是一个服务将是一个方法的子集或构成方法的操作之一。
- en: Objects have the ability to inherit attributes and methods from other objects
    when they are placed within the same class. A class is a group of objects that
    have similar attributes and methods and typically have been put together to perform
    a specific task. To further understand these concepts, we will establish the object
    for “Car” and place it in a class of objects that focuses on the use of transmissions
    in cars.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当对象放置在同一个类中时，它们有能力从其他对象那里继承属性和方法。类是具有相似属性和方法的对象的组合，通常被放在一起执行特定任务。为了进一步理解这些概念，我们将建立“汽车”的对象，并将其放置在专注于汽车变速器使用的对象类中。
- en: 'Figure [3.9](#Fig9) represents an object class called Car Transmissions. It
    has three component objects: cars, automatic trans, and standard trans. The car
    object is said to be the parent object. Automatic trans and standard trans are
    object types. Both automatic trans and standard trans will inherit all attributes
    and services from their parent object cars. Inheritance in object technology means
    that the children effectively contain all of the capabilities of their parents.
    Inheritance is implemented as a tree structure^([3](#Fn3)); however, instead of
    information flowing upward (as is the case in tree structures), the data flows
    downward to the lowest level children. Therefore, an object inheritance diagram
    is said to be an inverted tree. Because the lowest level of the tree inherits
    from everyone’s of its parents, only the lowest level object need be executed,
    that is, executing the lowest level will automatically allow the application to
    inherit all of the parent information and applications as needed. We call the
    lowest level objects concrete, while all others in the class are called abstract.
    Objects within classes can change simply by the addition of a new object. Let
    us assume that there is another level added to our example. The new level contains
    objects for the specific types of automatic and standard transmissions.![../images/480347_1_En_3_Chapter/480347_1_En_3_Fig9_HTML.png](../images/480347_1_En_3_Chapter/480347_1_En_3_Fig9_HTML.png)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图 [3.9](#Fig9)表示一个名为车辆传输的对象类。它有三个组件对象：车辆、自动传输和标准传输。车辆对象被称为父对象。自动传输和标准传输是对象类型。自动传输和标准传输将继承其父对象车辆的所有属性和服务。对象技术中的继承意味着子对象实际上包含了父对象的所有功能。继承被实现为树结构^([3](#Fn3))；然而，与树结构中信息向上流动的情况不同，数据向下流向最低级别的子对象。因此，对象继承图被称为倒置树。因为树的最低级别继承了其所有父级别的信息，只需执行最低级别即可，也就是说，执行最低级别将自动允许应用程序根据需要继承所有的父级别信息和应用程序。我们称最低级别的对象为具体对象，而类中的所有其他对象都称为抽象对象。类内的对象可以通过简单地添加一个新对象而改变。假设我们的例子增加了另一个级别。新级别包含了特定类型的自动和标准传输对象。![../images/480347_1_En_3_Chapter/480347_1_En_3_Fig9_HTML.png](../images/480347_1_En_3_Chapter/480347_1_En_3_Fig9_HTML.png)
- en: Fig. 3.9
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.9
- en: Class car transmissions
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 车辆传输类
- en: 'The class in Fig. [3.10](#Fig10) has been modified to include a new concrete
    layer. Therefore, the automatic trans object and standard trans object are now
    abstract. The new four concrete objects not only inherit from their respective
    parent objects, but also from their common grandparent, cars. It is also important
    to recognize that classes can inherit from other classes. Therefore, the same
    example could show each object as a class: that is, cars would represent a class
    of car objects and automatic trans another class of objects. Therefore, the class
    automatic trans would inherit from the cars class in the same manner described
    above. We call this “class inheritance.”![../images/480347_1_En_3_Chapter/480347_1_En_3_Fig10_HTML.png](../images/480347_1_En_3_Chapter/480347_1_En_3_Fig10_HTML.png)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图 [3.10](#Fig10)中的类已经修改，包括了一个新的具体层。因此，自动传输对象和标准传输对象现在是抽象的。四个新的具体对象不仅继承了各自父对象，还继承了它们的共同祖先车辆。同时，重要的是要认识到类可以继承自其他类。因此，同样的例子可以展示每个对象都是一个类：也就是说，车辆代表着一类车辆对象，而自动传输代表另一类对象。因此，自动传输类将以上述相同方式继承车辆类。我们称之为“类继承”。![../images/480347_1_En_3_Chapter/480347_1_En_3_Fig10_HTML.png](../images/480347_1_En_3_Chapter/480347_1_En_3_Fig10_HTML.png)
- en: Fig. 3.10
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.10
- en: Class car transmission types
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 车辆传输类型类
- en: I mentioned before the capability of OO objects to be reusable (Re-usable Objects).
    This is very significant in that it allows a defined object to become part of
    another class, while still keeping its own original identity and independence.
    The example below demonstrates how Cars can be reused in another class (Fig. [3.11](#Fig11)).![../images/480347_1_En_3_Chapter/480347_1_En_3_Fig11_HTML.png](../images/480347_1_En_3_Chapter/480347_1_En_3_Fig11_HTML.png)
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前提到了 OO 对象可重用（可重用对象）的能力。这在于它允许一个定义好的对象成为另一个类的一部分，同时保持其自身的原始身份和独立性。下面的示例演示了如何在另一个类中重用车辆（图 [3.11](#Fig11)）。![../images/480347_1_En_3_Chapter/480347_1_En_3_Fig11_HTML.png](../images/480347_1_En_3_Chapter/480347_1_En_3_Fig11_HTML.png)
- en: Fig. 3.11
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.11
- en: Class transportation vehicles
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 车辆运输类
- en: Notice that the object Car is now part of another class called Transportation
    Vehicles. However, Car, instead of being an abstract object within its class,
    has become concrete and thus inherits from its parent, Transportation Vehicles.
    The object Cars has methods that may execute differently depending on the class
    it is in. Therefore, Cars in the Transportation Vehicle class might interpret
    a request for “driving the car” as it relates to general transportation vehicles.
    Specifically, it might invoke a service that shows how to maneuver a car while
    it is moving. On the other hand, Cars in the Transmission class might interpret
    the same message coming from one of its children objects as meaning how the transmission
    shifts when a person is driving. This phenomenon is called polymorphism. Polymorphism
    allows an object to change its behavior within the same methods under different
    circumstances. What is more important is that polymorphism is dynamic in behavior
    so its changes in operation are determined when the object is executed or during
    run-time.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，对象Car现在已成为另一个称为Transportation Vehicles的类的一部分。但是，Car不再是其类中的抽象对象，而是具体的，因此从其父类Transportation
    Vehicles继承。对象Cars具有的方法可能会根据它所在的类而执行不同。因此，在Transportation Vehicle类中的Cars可能会将对“驾驶汽车”的请求解释为与一般交通工具相关。具体地说，它可能会调用一个显示如何在汽车行驶时操纵汽车的服务。另一方面，在Transmission类中的Cars可能会将来自其子对象之一的相同消息解释为当人们驾驶时变速器如何换档。这种现象称为多态性。多态性允许对象在不同情况下在相同的方法中改变其行为。更重要的是，多态性是动态的行为，因此它的操作变化是在对象执行或运行时确定的。
- en: Because objects can be reused, keeping the same version current in every copy
    of the same object in different classes is important. Fortunately, objects are
    typically stored in Dynamic Link Libraries (DLL). The significance of a DLL is
    that it always stores the current version of an object. Because objects are linked
    dynamically before each execution, you are ensured that the current version is
    always the one used. The DLL facility therefore avoids the maintenance nightmares
    of remembering which applications contain the same sub-programs. Legacy systems
    often need to re-link every copy of the subprogram in each module where a change
    occurs. This problem continues to haunt the COBOL application community.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 因为对象可以被重用，保持在不同类中相同对象的每个副本中的相同版本是很重要的。幸运的是，对象通常存储在动态链接库（DLL）中。DLL的重要性在于它始终存储对象的当前版本。因为对象在每次执行之前都是动态链接的，所以确保当前版本始终是使用的版本。因此，DLL工具避免了记住哪些应用程序包含相同子程序的维护噩梦。遗留系统通常需要重新链接发生更改的每个模块中子程序的每个副本。这个问题继续困扰着COBOL应用程序社区。
- en: Another important feature in object systems is Instantiation and Persistence.
    Instantiation allows multiple executions of the same class to occur independent
    of another execution. This means that the there are multiple copies of the same
    class executing concurrently. The significance of these executions is that they
    are mutually exclusive and can be executing different concrete objects within
    that class. Because of this capability, we say that objects can have multiple
    *instances* within each executing copy of a class it belongs to. Sometimes, although
    class executions are finished, a component object continues to operate or *persist*.
    Persistence is therefore an object that continues to operate after the class or
    operation that invoked it has finished. The system must keep track of each of
    these object instances.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 对象系统中的另一个重要特性是实例化和持久性。实例化允许同一类的多个执行独立于另一个执行发生。这意味着同一类的多个副本正在同时执行。这些执行的重要性在于它们是互斥的，并且可以在该类中执行不同的具体对象。由于这种能力，我们说对象可以在其所属类的每个执行副本中具有多个*实例*。有时，尽管类的执行已经完成，但组件对象继续运行或*持久化*。因此，持久性是在调用它的类或操作完成后继续运行的对象。系统必须跟踪每个这样的对象实例。
- en: The abilities of objects and classes to have inheritance, polymorphic behavior,
    instantiation and persistence are just some of the new mechanisms that developers
    can take advantage of when building OO systems.^([4](#Fn4)) Because of this, the
    analyst must not only understand the OO methodology, but must also apply new approaches
    and tools that will allow an appropriate schematic to be produced for system developers.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 3.6 Object Modeling
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another analysis modeling tool is called a State Transition Diagram (STD) and
    useful for modeling event driven and time dependent systems. A state very closely
    resembles an object/class and therefore can be used with little modification to
    depict the flow and relationships of objects. The major difference between an
    object and a state is that an object is responsible for its own data (which we
    call an attribute in OO). An object’s attributes are said to be *encapsulated*
    behind its methods, that is, a user cannot ask for data directly. The concept
    of encapsulation is that access to an object is allowed only for a purpose rather
    than for obtaining specific data elements. It is the responsibility of the method
    and its component services to determine the appropriate attributes that are required
    to service the request of the object. An object diagram, regardless of whose methodology
    is used, is essentially a hybrid of an STD and an Entity Relational Diagram (ERD).
    The STD represents the object’s methods and the criteria for moving from one object
    to another. The ERD , on the other hand, defines the relationship of the attributes
    between the stored data models. The result is best shown using the order processing
    example below.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Figure [3.12](#Fig12) reflects that a customer object submits a purchase order
    for items to the order object. The relationship between customer and order reflects
    both STD and ERD characteristics. The “submits purchase order” specifies the condition
    to change the state of or move to the order object. The direction arrow also tells
    us that the order object cannot send a purchase order to the customer object.
    The crow’s foot cardinality shows us that a customer object must have at least
    one order to create a relationship with the order object. After an order is processed,
    it is prepared for shipment. Notice that each order has one related shipment object;
    however multiple warehouse items can be part of a shipment. The objects depicted
    above can also represent classes suggesting that they are comprised of many component
    objects. These component objects might in turn be further decomposed into other
    primitive objects. This is consistent with the concept of the logical equivalent
    and with functional decomposition (Fig. [3.13](#Fig13)).![../images/480347_1_En_3_Chapter/480347_1_En_3_Fig12_HTML.png](../images/480347_1_En_3_Chapter/480347_1_En_3_Fig12_HTML.png)
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 3.12
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: An object/class diagram
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '![../images/480347_1_En_3_Chapter/480347_1_En_3_Fig13_HTML.png](../images/480347_1_En_3_Chapter/480347_1_En_3_Fig13_HTML.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![../images/480347_1_En_3_Chapter/480347_1_En_3_Fig13_HTML.png](../images/480347_1_En_3_Chapter/480347_1_En_3_Fig13_HTML.png)'
- en: Fig. 3.13
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.13
- en: The component objects of the warehouse class
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库类的组件对象
- en: It is important that the analyst specify whether classes or objects are depicted
    in the modeling diagrams. It is not advisable to mix classes and objects at the
    same level. Obviously, the class levels can be effective for user verification,
    but objects will be inevitably required for final analysis and engineering.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 分析人员必须明确指定建模图中是表示类还是对象。不建议在同一级别混合类和对象。显然，类级别可以用于用户验证，但最终的分析和工程需要对象。
- en: 3.7 Relationship to Structured Analysis
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.7 与结构化分析的关系
- en: 'Many analysts make the assumption that the traditional structured tools are
    not required in OO analysis. This simply is not true, as we have shown in the
    previous examples. To further emphasize the need to continue using structured
    techniques, we need to understand the underlying benefit of the OO paradigm and
    how structured tools are necessary to map to the creation of objects and classes.
    It is easy to say: “find all the objects in the essential components”; actually,
    to have a process to do so is another story. Before providing an approach to determine
    objects, let us first understand the problem.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 许多分析人士假设在面向对象分析中不需要传统的结构化工具。这简直是不正确的，正如我们在前面的例子中所展示的那样。为了进一步强调继续使用结构化技术的必要性，我们需要理解面向对象范式的基本好处，以及结构化工具如何必要来映射到对象和类的创建。轻易地说：“找到所有基本组件中的对象”;
    实际上，有一个流程来做到这一点是另一回事。在提供确定对象的方法之前，让我们首先了解问题。
- en: 3.7.1 Application Coupling
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.7.1 应用耦合
- en: Coupling can be defined as the measurement of an application’s dependency on
    another. Simply put, does a change in an application program necessitate a change
    to another application program? Many known system malfunctions have resulted from
    highly coupled systems. The problem, as you might have anticipated, relates back
    to the analysis function, where decisions could be made as to what services should
    be joined to form one single application program. Coupling is never something
    that we want to do, but no system can be made up of just one program. Therefore,
    coupling is a reality and one that analysts must focus on. Let us elaborate on
    the coupling problem through the following example (Fig. [3.14](#Fig14)).![../images/480347_1_En_3_Chapter/480347_1_En_3_Fig14_HTML.png](../images/480347_1_En_3_Chapter/480347_1_En_3_Fig14_HTML.png)
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 耦合可以被定义为应用程序对另一个应用程序的依赖性的度量。简单地说，一个应用程序的更改是否需要另一个应用程序的更改？许多已知的系统故障都是由高度耦合的系统引起的。问题归结到分析功能，决定应该连接哪些服务以形成一个单一的应用程序。耦合绝不是我们想做的事情，但没有一个系统可以仅由一个程序组成。因此，耦合是现实，分析人员必须专注于此。让我们通过以下示例详细说明耦合问题（图 [3.14](#Fig14)）。![../images/480347_1_En_3_Chapter/480347_1_En_3_Fig14_HTML.png](../images/480347_1_En_3_Chapter/480347_1_En_3_Fig14_HTML.png)
- en: Fig. 3.14
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.14
- en: Application coupling
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 应用耦合
- en: The two programs A and B are coupled via the passing of the variable Y. Y is
    subsequently used in B to calculate R. Should the variable Y change in A, it will
    not necessitate a change in B. This is considered good coupling. However, let
    us now examine X. We see that X is defined in both A and B. Although the value
    of X does not cause a problem in the current versions of A and B, a subsequent
    change of X will cause a programmer to remember to change the value in B. This
    is a maintenance nightmare. In large enterprise level systems, analysts and programmers
    cannot “remember” where all of these couples have occurred, especially when the
    original developers are no longer with the organization. The solution to this
    problem is also to pass X from program A as shown in Fig. [3.15](#Fig15).![../images/480347_1_En_3_Chapter/480347_1_En_3_Fig15_HTML.png](../images/480347_1_En_3_Chapter/480347_1_En_3_Fig15_HTML.png)
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 通过变量 Y 的传递，程序 A 和 B 相互耦合。随后，在 B 中使用 Y 来计算 R。如果 A 中的变量 Y 发生变化，不会强制要求 B 中也要做出改变。这被认为是良好的耦合。然而，现在让我们来看看
    X。我们发现 X 在 A 和 B 中都有定义。尽管 X 的值在当前版本的 A 和 B 中不会引起问题，但后续更改 X 的值将导致程序员需要记住在 B 中更改该值。这是一个维护的噩梦。在大型企业级系统中，分析人员和程序员无法“记住”所有这些耦合发生的地方，特别是当原始开发人员已不再与组织合作时。解决这个问题的方法也是从程序
    A 中传递 X，如图 [3.15](#Fig15) 所示。![../images/480347_1_En_3_Chapter/480347_1_En_3_Fig15_HTML.png](../images/480347_1_En_3_Chapter/480347_1_En_3_Fig15_HTML.png)
- en: Fig. 3.15
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.15
- en: Application coupling using variables X and Y
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: We now see that both X and Y are passed and programs A and B are said to have
    low coupling. In addition, program A is said to be more *cohesive.*
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 3.7.2 Application Cohesion
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Cohesion is the measurement of how independent a program is on its own processing.
    That is, a cohesive program contains all of the necessary data and logic to complete
    its applications without being directly affected by another program; a change
    in another program should not require a change to a cohesive one. Furthermore,
    a cohesive program should not cause a change to be made in another program. Therefore,
    cohesive programs are independent programs that react to messages to determine
    what they need to do; however, they remain self-contained. When program A also
    passed X it became more cohesive because a change in X no longer required a change
    to be made to another program. In addition, B is more cohesive because it gets
    the change of X automatically from A. Systems that are designed more cohesively
    are said to be more maintainable. Their codes can also be reused or retrofitted
    into other applications as components because they are wholly independent. A cohesive
    program can be compared to an interchangeable standard part of a car. For example,
    if a car requires a standard 14-in. tire, typically any tire that meets the specification
    can be used. The tire, therefore, is not married to the particular car, but rather
    is a cohesive component for many cars.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Cohesion is in many ways is the opposite of coupling. The higher the cohesion,
    the lower the coupling. Analysts must understand that an extreme of either cohesion
    or coupling cannot exist. This is shown in the graph below (Fig. [3.16](#Fig16)).![../images/480347_1_En_3_Chapter/480347_1_En_3_Fig16_HTML.png](../images/480347_1_En_3_Chapter/480347_1_En_3_Fig16_HTML.png)
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 3.16
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Coupling and cohesion relationships
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: The graph shows that we can never reach 100% cohesion; that would mean there
    is only one program in the entire system, a situation that is unlikely. However,
    it is possible to have a system where a 75% cohesion ratio is obtained.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: We now need to relate this discussion to OO. Obviously OO is based very much
    on the concept of cohesion. Objects are independent reusable modules that control
    their own attributes and services. Object coupling is based entirely on message
    processing via inheritance or collaboration.^([5](#Fn5)) Therefore, once an object
    is identified, the analyst must define all of its processes in a cohesive manner.
    Once the cohesive processes are defined, the required attributes of the object
    are then added to the object. Below is a table which shows how processes can be
    combined to create the best cohesion (Fig. [3.17](#Fig17)).![../images/480347_1_En_3_Chapter/480347_1_En_3_Fig17_HTML.png](../images/480347_1_En_3_Chapter/480347_1_En_3_Fig17_HTML.png)
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 3.17
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Methods of selecting cohesive objects
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: The tiers above are based on best to worst, where By Function is the most desirable
    and By Lines of Code the least desirable. Tiers 1 and 2 will render the best object
    cohesiveness. This can be seen with the following example.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Figure [3.18](#Fig18) depicts a four-screen system that includes four objects,
    that is, each screen is a separate object. The Transaction Processing object has
    been designed using Tier 2, By Same Data since it deals only with the Transaction
    File. The object is cohesive because it does not depend on or affect another module
    in its processing. It provides all of the methods required for transaction data.![../images/480347_1_En_3_Chapter/480347_1_En_3_Fig18_HTML.png](../images/480347_1_En_3_Chapter/480347_1_En_3_Fig18_HTML.png)
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 3.18
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Applications with varying types of object cohesion
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: The Financials object is an example of Tier 1, By Function since a Balance Sheet
    is dependent on the Income Statement and the Income Statement is dependent on
    the Trial Balance. The object therefore is self-contained within all the functions
    necessary to produce financial information (in this example).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: The System Editor, on the other hand, being an example of Tier 3, shows that
    it handles all of the editing (verification of the quality of data) for the system.
    Although there appears to be some benefit to having similar code in one object,
    we can see that it affects many different components. It is therefore considered
    a highly coupled object and not necessarily the easiest to maintain.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: We can conclude that Tiers 1 and 2 provide analysts with the most attractive
    way for determining an object’s attributes and services. Tiers 3 and 4, although
    practiced, do not provide any real benefits in OO and should be avoided as much
    as possible. The question now is what technique do we follow to start providing
    the services and attributes necessary when developing logical objects?
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: The structured tools discussed in Chap. [3](480347_1_En_3_Chapter.xhtml) provide
    us with the essential capabilities to work with OO analysis and design. The STD
    can be used to determine the initial objects and the conditions of how one object
    couples or relates to another. Once the STD is prepared it can be matured into
    the object model discussed earlier in this chapter. The object model can be decomposed
    to its lowest level; the attributes and services of each object must then be defined.
    All of the DFD functional primitives can now be mapped to their respective objects
    as services within their methods. It is also a way of determining whether an object
    is missing (should there be a DFD that does not have a related object). The analyst
    should try to combine each DFD using the Tier 1 By Function approach. This can
    sometimes be very difficult depending on the size of the system. If the Tier 1
    approach is too difficult, the analyst should try Tier 2 by combining DFDs based
    on their similar data stores. This is a very effective approach; since Tier 1
    implies Tier 2,^([6](#Fn6)) it is a very productive way to determine how processes
    should be mapped to their appropriate objects. This does not suggest that the
    analyst should not try Tier 1 first.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: The next activity is to determine the object’s attributes or data elements.
    The ERD serves as the link between an attribute in an object and its actual storage
    in a database. It is important to note that the attribute setting in an object
    may have no resemblance to its setting in the logical and physical data entity.
    The data entity is focused on the efficient storage of the elements and its integrity,
    whereas the attribute data in an object is based on its cohesiveness with the
    object’s services.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: The mapping of the object to the DFD and ERD can be best shown graphically below
    (Fig. [3.19](#Fig19)).![../images/480347_1_En_3_Chapter/480347_1_En_3_Fig19_HTML.png](../images/480347_1_En_3_Chapter/480347_1_En_3_Fig19_HTML.png)
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 3.19
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: The relationships between an object and the ERD and DFD
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Thus, the functional primitive DFDs and the ERD resulting from the normalization
    process provide the vehicles for providing an object’s attributes and services.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 3.8 Object-Oriented Databases
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There was a movement in the industry to replace the traditional Relational Database
    Management Systems (RDBMS) with the Object-Oriented Database Management System
    (OODBMS). Object databases differ greatly from the relational model in that the
    object’s attributes and services are stored together. Therefore, the concept of
    columns and rows of normalized data becomes extinct. The proponents of OODBMS
    saw a major advantage in that object databases could also keep graphical and multimedia
    information about the object, something that relational databases cannot do. The
    result has been the ultimate creation of different data storages, many of which
    do not require row and column architecture, but it is expected that the relational
    model will continue to be used for some time. However, most RDBMS products will
    become more OO. This means they will use the relational engine but employ more
    OO capabilities, that is, build a relational hybrid model. In either case, analysts
    should continue to focus on the logical aspects of capturing the requirements.
    Changes in the OO methodologies are expected to continue with the evolution of
    block chain architectures as well as the use of unformatted data using Natural
    Language methodologies.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: 3.9 Designing Distributed Objects Using Use-Case Analysis and Design
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use-Cases were first proposed in 1986 as a result of the popularity of the object-oriented
    paradigm. Use-Case today is widely used in the development of web-based systems
    and is the appropriate methodology to use for mobile IoT application development.
    Use-Case was designed to be very effective when defining current and potential
    actions of a product. That is, Use-Case can be used to model activities that may
    never have occurred in a system, but are technically possible. Indeed, many system
    deficiencies occur because a user tried to perform something for the first time.
    These types of situations are sometimes referred to as supplementary specifications.
    In many ways, Use-Case methodology represented the next generation of the State
    Transition Diagrams (STD) discussed earlier in this chapter.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 3.9.1 Use-Case Model
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A Use-Case model contains three essential components: use-cases, actors, and
    relationships (Bittner and Spence [2003](#CR1)).'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 3.9.2 Actors
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An Actor represents a user of the system. When interfacing with the system,
    an “user” can be internal (traditional), consumer, or another system. They are
    notated using the symbol in Fig. [3.20](#Fig20).![../images/480347_1_En_3_Chapter/480347_1_En_3_Fig20_HTML.png](../images/480347_1_En_3_Chapter/480347_1_En_3_Fig20_HTML.png)
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 3.20
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Use-case actor symbol
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 3.10 Use Case
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A Use Case identifies a particular interface or “use” that an Actor does with
    the system to achieve a need. In many ways, the sum of all use cases represents
    an inventory of all possible transactions and events that can be accomplished
    with the system. It, in effect, replicates all possible permutations that can
    occur. In its most decomposed form, each use case defines one transaction. A use
    case must result in some form of output. Obviously, use cases may have restrictions;
    certain possible actor requests may require certain authorizations. A use case
    is denoted by a sphere symbol as shown in Fig. [3.21](#Fig21) (note its similarity
    with a DFD process).![../images/480347_1_En_3_Chapter/480347_1_En_3_Fig21_HTML.png](../images/480347_1_En_3_Chapter/480347_1_En_3_Fig21_HTML.png)
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 3.21
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Use case symbol
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Figure [3.22](#Fig22) shows a basic Actor/Use Case diagram.![../images/480347_1_En_3_Chapter/480347_1_En_3_Fig22_HTML.png](../images/480347_1_En_3_Chapter/480347_1_En_3_Fig22_HTML.png)
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 3.22
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Actor/use case flow
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Note that the Use Case model in Fig. [3.22](#Fig22) actually contains two transactions.
    It could be decomposed to two separate Use Case models as shown in Fig. [3.23](#Fig23).![../images/480347_1_En_3_Chapter/480347_1_En_3_Fig23_HTML.png](../images/480347_1_En_3_Chapter/480347_1_En_3_Fig23_HTML.png)
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 3.23
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Use case as functional primitives
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: The third component of the Use-Case modeling is the relationship specified by
    a data flow line, which often has an arrow to depict directionality. Similar to
    a DFD, a data flow carries data that will be transformed by the use case process
    sphere. Directionality depicts whether the data is being supplied by the Actor
    or received by the Actor from the use case process, or both! These relationship
    data flows are shown in Figs. [3.22](#Fig21) and [3.23](#Fig22).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'While a use-case model has three essential symbols, there is another component
    that is critical. Some analysts call this the description, however, the concept
    again originated from the DFD in which the actual algorithm inside the process
    is called a process specification. Process specifications typically contained
    two forms of description: (1) the actual algorithm in a form of pseudocode, or
    (2) Pre–Post Conditions. Both can be used together depending on the complexity
    of the process. Many analysts define a process specification as everything else
    about the process not already included in the other modeling tools. Indeed, it
    must contain the remaining information that normally consists of business rules
    and application logic. DeMarco suggested that every functional primitive DFD point
    to a “Minispec” which would contain that process’ application logic.^([7](#Fn7))
    We will follow this rule and expand on the importance of writing good application
    logic even in a Use Case. There are, of course, different styles, and few textbooks
    that explain the importance to the analyst of understanding how these need to
    be developed and presented. Like other modeling tools, each process specification
    style has its good, bad and ugly.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 3.11 Pseudocode
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The most detailed and regimented process specification is pseudocode or “Structured
    English”. Its format is designed to require the analysts to have a solid understanding
    of how to write algorithms. The format is very “COBOL-like” and was initially
    designed as a way of writing functional COBOL programming specifications. The
    rules governing pseudocode are as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Use the Do While with an Enddo to show iteration
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use If-Then-Else to show conditions and ensure each If has an End-If
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be specific about initializing variables and other detail processing requirements.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Pseudocode is designed to give the analyst tremendous control over the design
    of the code. Take the following example:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: There is a requirement to calculate a 5% bonus for employees who work on the
    1st shift and a 10% bonus for workers on the 2nd or 3rd shift. Management is interested
    in a report listing the number of employees who receive a 10% bonus. The process
    also produces the bonus checks.
  id: totrans-175
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The pseudocode would be:![../images/480347_1_En_3_Chapter/480347_1_En_3_Figg_HTML.png](../images/480347_1_En_3_Chapter/480347_1_En_3_Figg_HTML.png)The
    above algorithm gives the analyst great control over how the program should be
    designed. For example, note that the pseudocode requires that the programmer have
    an error condition should a situation occur where a record does not contain a
    1st, 2nd or 3rd shift employee. This might occur should there be a new shift that
    was not communicated to the information systems department. Many programmers might
    have omitted the last “If” check as follows:![../images/480347_1_En_3_Chapter/480347_1_En_3_Figh_HTML.png](../images/480347_1_En_3_Chapter/480347_1_En_3_Figh_HTML.png)
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: The above algorithm simply assumes that if the employee is not on the 1st shift
    then they must be either a 2nd or 3rd shift employee. Without this being specified
    by the analyst, the programmer may have omitted this critical logic which could
    have resulted in a 4th shift worker receiving a 10% bonus! As mentioned earlier,
    each style of process specification has its advantages and disadvantages, in other
    words, the good, the bad, and the ugly.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '*The Good*:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: The analyst who uses this approach has practically written the program, and
    thus the programmer will have very little to do with regards to figuring out the
    logic design.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '*The Bad*:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'The algorithm is very detailed and could take a long time for the analyst to
    develop. Many professionals raise an interesting point: Do we need analysts to
    be writing process specifications to this level of detail? In addition, many programmers
    may be insulted and feel that an analyst does not possess the skill-set to design
    such logic.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '*The Ugly*:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: The analyst spends the time, the programmers are not supportive and the logic
    is incorrect. The result here will be the “*I told you so*” remarks from programmers,
    and hostilities may grow over time.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 3.11.1 Case
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Case^([8](#Fn8)) is another method of communicating application logic. Although
    the technique does not require as much technical format as pseudocode, it still
    requires the analyst to provide a detailed structure to the algorithm. Using the
    same example as in the pseudocode discussion, we can see the differences in format:![../images/480347_1_En_3_Chapter/480347_1_En_3_Figi_HTML.png](../images/480347_1_En_3_Chapter/480347_1_En_3_Figi_HTML.png)
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: 'The above format provides control as it still allows the analyst to specify
    the need for error checking; however, the exact format and order of the logic
    is more in the hands of the programmer. Let’s now see the good, bad and ugly of
    this approach:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '*The Good*:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: The analyst has provided a detailed description of the algorithm without having
    to know the format of logic in programming. Because of this advantage, CASE takes
    less time than pseudocode.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '*The Bad*:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Although this may be difficult to imagine, the analyst may miss some of the
    possible conditions in the algorithm, such as forgetting a shift! This happens
    because the analyst is just listing conditions as opposed to writing a specification.
    Without formulating the logic as we did in pseudocode, the likelihood of forgetting
    or overlooking a condition check is increased.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '*The Ugly*:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Case logic can be designed without concern for the sequence of the logic, that
    is, the actual progression of the logic as opposed to just the possibilities.
    Thus the logic can become more confusing because it lacks actual progressive structure.
    As stated previously, the possibility of missing a condition is greater because
    the analyst is not actually following the progression of the testing of each condition.
    There is thus a higher risk of the specification being incomplete.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 3.12 Pre–Post Conditions
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Pre-Post is based on the belief that analysts should not be responsible for
    the details of the logic, but rather for the overall highlights of what is needed.
    Therefore, the pre-post method lacks detail and expects that the programmers will
    provide the necessary details when developing the application software. The method
    has two components: Pre-Conditions and Post-Conditions. Pre-conditions represent
    things that are assumed true or that must exist for the algorithm to work. For
    example, a pre-condition might specify that the user must input the value of the
    variable X. On the other hand, the post-condition must define the required outputs
    as well as the relationships between calculated output values and their mathematical
    components. Suppose the algorithm calculated an output value called Total_Amount.
    The post-condition would state that Total_Amount is produced by multiplying Quantity
    times Price. Below is the pre-post equivalent of the Bonus algorithm:![../images/480347_1_En_3_Chapter/480347_1_En_3_Figj_HTML.png](../images/480347_1_En_3_Chapter/480347_1_En_3_Figj_HTML.png)'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, the above specification does not show how the actual algorithm
    should be designed or written. It requires the programmer or development team
    to find these details and implement the appropriate logic to handle it. Therefore,
    the analyst has no real input into the way the application will be designed or
    the way it functions.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '*The Good*:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: The analyst need not have technical knowledge to write an algorithm and does
    not need to spend an inordinate amount of time to develop what is deemed a programming
    responsibility. Therefore, less technically oriented analysts can be involved
    in specification development.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '*The Bad*:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: There is no control over the design of the logic, and thus the opportunity for
    misunderstandings and errors is much greater. The analyst and the project are
    much more dependent on the talent of the development staff.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '*The Ugly*:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps we misunderstand the specification. Since the format of pre-post conditions
    is less specific, there is more room for ambiguity.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: 3.13 Matrix
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A matrix or table approach is one that shows the application logic in tabular
    form. Each row reflects a result of a condition, with each column representing
    the components of the condition to be tested. The best way to explain a matrix
    specification is to show an example as shown in Fig. [3.24](#Fig24).![../images/480347_1_En_3_Chapter/480347_1_En_3_Fig24_HTML.png](../images/480347_1_En_3_Chapter/480347_1_En_3_Fig24_HTML.png)
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 3.24
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Sample matrix specification
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Although this is a simple example that uses the same algorithm as the other
    specification styles, it does show how a matrix can describe the requirements
    of an application without the use of sentences and pseudocode.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '*The Good*:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: The analyst can use a matrix to show complex conditions in a tabular format.
    The tabular format is preferred by many programmers because it is easy to read,
    organized and often easy to maintain. Very often the matrix resembles the array
    and table formats used by many programming languages.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '*The Bad*:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: It is difficult, if not impossible, to show a complete specification in matrices.
    The above example supports this, in that the remaining logic of the bonus application
    is not shown. Therefore, the analyst must integrate one of the other specification
    styles to complete the specification.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '*The Ugly*:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'Matrices are used to describe complex condition levels, where there are many
    “If” conditions to be tested. These complex conditions often require much more
    detailed analysis than shown in a matrix. The problem occurs when the analyst,
    feeling the matrix may suffice, does not provide enough detail. The result: conditions
    may be misunderstood by the programmer during development.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '*Conclusion*:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 'The question must be asked again: What is a good specification? We will continue
    to explore this question. In this chapter we have examined the logic alternatives.
    Which logic method is best? It depends! We have seen from the examples that each
    method has its advantages and shortcomings. The best approach is to be able to
    use them all, and to select the most appropriate one for the task at hand. To
    do this effectively means clearly recognizing where each style provides a benefit
    for the part of the system you are working with, and who will be doing the development
    work. The table below attempts to put the advantages and shortcomings into perspective.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: 3.14 Problems and Exercises
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '1.'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is an Object?
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Describe the relationship between a Method and a Service.
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '3.'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a Class?
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '4.'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does the Object Paradigm change the approach of the analyst?
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '5.'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Describe the two types of objects and provide examples of each type.
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '6.'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are Essential Functions?
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '7.'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is an Object Type and how is it used to develop specific type of classes?
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '8.'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is meant by Object and Class Inheritance?
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '9.'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the association differences between an ERD and an Object diagram?
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '10.'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does functional decomposition operate with respect to classes and objects?
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '11.'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is Coupling and Cohesion? What is their relationship with each other?
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '12.'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does the concept of cohesion relate the structured approach to the object
    model?
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '13.'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What four methods can be used to design a cohesive object?
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '14.'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are Object Databases?
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '15.'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is Client/Server?
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '16.'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do objects relate to Client/Server design?
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '17.'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is there a need for a hybrid object in Client/Server design?
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '18.'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is Use Case analysis and design?
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '19.'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is meant by distributed objects?
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 3.15 Mini-project
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You have been asked to automate the Accounts Payable process. During your interviews
    with users you identify four major events as follows:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: I.*Purchase Order Flow*
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '1.'
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The Marketing Department sends a Purchase Order (P.O.) form for books to the
    Accounts Payable System (APS).
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.'
  id: totrans-259
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'APS assigns a P.O. # and sends the P.O.-White copy to the Vendor and files
    the P.O.-Pink copy in a file cabinet in P.O.#.sequence.'
  id: totrans-260
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: II.*Invoice Receipt*
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '1.'
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A vendor sends an invoice for payment for books purchased by APS.
  id: totrans-263
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.'
  id: totrans-264
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: APS sends invoice to Marketing Department for authorization.
  id: totrans-265
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '3.'
  id: totrans-266
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Marketing either returns invoice to APS approved or back to the vendor if not
    authorized.
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '4.'
  id: totrans-268
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If the invoice is returned to APS it is matched up against the original P.O.-Pink.
    The PO and vendor invoice are then combined into a packet and prepared for the
    voucher process.
  id: totrans-269
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: III.*Voucher Initiation*
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '1.'
  id: totrans-271
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: APS receives the packet for vouchering. It begins this process by assigning
    a voucher number.
  id: totrans-272
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.'
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The Chief Accountant must approve vouchers > $5,000.
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '3.'
  id: totrans-275
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: APS prepares another packet from the approved vouchers. This packet includes
    the P.O.-Pink, authorized invoice and approved voucher.
  id: totrans-276
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: IV.*Check Preparation*
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '1.'
  id: totrans-278
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Typist receives the approved voucher packet and retrieves a numbered blank check
    to pay the vendor.
  id: totrans-279
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.'
  id: totrans-280
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Typist types a two-part check (blue, green) using data from the approved voucher
    and enters invoice number on the check stub.
  id: totrans-281
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '3.'
  id: totrans-282
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: APS files the approved packet with the Check–green in the permanent paid file.
  id: totrans-283
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '4.'
  id: totrans-284
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The check is either picked up or mailed directly to the vendor.
  id: totrans-285
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Assignment:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '1.'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provide the DFDs for the four events. Each event should be shown as a single
    DFD on a separate piece of paper.
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Level each event to its functional primitives.
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '3.'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Develop the Process Specifications for each functional primitive DFD.
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
