- en: © The Author(s), under exclusive license to Springer Nature Switzerland AG 2022X.
    Yi et al.Blockchain Foundations and ApplicationsSpringerBriefs in Applied Sciences
    and Technology[https://doi.org/10.1007/978-3-031-09670-9_2](https://doi.org/10.1007/978-3-031-09670-9_2)
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: © 作者（们），经Springer Nature Switzerland AG 2022独家授权X. Yi 等。区块链基础与应用Springer Briefs
    in Applied Sciences and Technology[https://doi.org/10.1007/978-3-031-09670-9_2](https://doi.org/10.1007/978-3-031-09670-9_2)
- en: 2. Bitcoin, Ethereum, Smart Contracts and Blockchain Types
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2. 比特币、以太坊、智能合约与区块链类型
- en: 'Xun Yi^([1](#Aff6) [ ](#ContactOfAuthor6)), Xuechao Yang^([1](#Aff6) [ ](#ContactOfAuthor7)),
    Andrei Kelarev^([1](#Aff6) [ ](#ContactOfAuthor8)), Kwok Yan Lam^([2](#Aff7) [ ](#ContactOfAuthor9))
    and Zahir Tari^([1](#Aff6) [ ](#ContactOfAuthor10))(1)School of Computing Technologies,
    RMIT University, Melbourne, VIC, Australia(2)School of Computer Science and Engineering,
    Nanyang Technological University, Singapore, SingaporeXun Yi (Corresponding author)Email:
    [xun.yi@rmit.edu.au](mailto:xun.yi@rmit.edu.au)Xuechao YangEmail: [xuechao.yang@rmit.edu.au](mailto:xuechao.yang@rmit.edu.au)Andrei KelarevEmail:
    [andrei.kelarev@gmail.com](mailto:andrei.kelarev@gmail.com)Kwok Yan LamEmail:
    [kwokyan.lam@ntu.edu.sg](mailto:kwokyan.lam@ntu.edu.sg)Zahir TariEmail: [zahir.tari@rmit.edu.au](mailto:zahir.tari@rmit.edu.au)'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '许云^([1](#Aff6) [ ](#ContactOfAuthor6))，杨学超^([1](#Aff6) [ ](#ContactOfAuthor7))，安德烈·凯拉雷夫^([1](#Aff6)
    [ ](#ContactOfAuthor8))，林国尧^([2](#Aff7) [ ](#ContactOfAuthor9)) 和 塔里·扎希尔^([1](#Aff6)
    [ ](#ContactOfAuthor10))（1）澳大利亚皇家墨尔本理工大学计算技术学院（2）新加坡南洋理工大学计算机科学与工程学院许云（通讯作者）电子邮件:
    [xun.yi@rmit.edu.au](mailto:xun.yi@rmit.edu.au)杨学超电子邮件: [xuechao.yang@rmit.edu.au](mailto:xuechao.yang@rmit.edu.au)安德烈·凯拉雷夫电子邮件:
    [andrei.kelarev@gmail.com](mailto:andrei.kelarev@gmail.com)林国尧电子邮件: [kwokyan.lam@ntu.edu.sg](mailto:kwokyan.lam@ntu.edu.sg)塔里·扎希尔电子邮件:
    [zahir.tari@rmit.edu.au](mailto:zahir.tari@rmit.edu.au)'
- en: 2.1 Bitcoin
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1 比特币
- en: Bitcoin is a decentralized digital currency without a central administrative
    authority or a single manager. Bitcoins can be sent from user to user on the peer-to-peer
    Bitcoin network without the need for intermediaries. Bitcoin transactions are
    verified by the network nodes using cryptography and are recorded in a public
    distributed ledger called a *blockchain*.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币是一种去中心化的数字货币，没有中央行政权威或单一管理者。比特币可以由用户间通过点对点的比特币网络发送，无需中介。比特币交易通过网络节点使用密码学进行验证，并记录在一个名为区块链的公共分布式账本中。
- en: Bitcoin was invented in 2008 by an unknown person or group of people using the
    name Satoshi Nakamoto. The cryptocurrency began being used in 2009 when its implementation
    was released as an open-source software.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币是在2008年由一个未知个人或团体以中本聪（Satoshi Nakamoto）的名字发明的。这种加密货币在2009年开始被使用，当时它的实现作为开源软件发布。
- en: 2.1.1 Bitcoin Network
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.1 比特币网络
- en: The Bitcoin network, illustrated in Fig. [2.1](#Fig1), is a peer-to-peer (P2P)
    decentralised network. A P2P network is created when two or more computers are
    connected directly and share resources without going through a separate server
    station. It can be an ad hoc connection, for example, a couple of computers connected
    via a Universal Serial Bus to transfer files. It also can be a permanent infrastructure
    linking a number of computers in a company using copper wire or optical cables.
    It can also be larger and can use special protocols and applications to establish
    direct relationships among users over the Internet.![](../images/516136_1_En_2_Chapter/516136_1_En_2_Fig1_HTML.png)
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如图[2.1](#Fig1)所示，比特币网络是一个点对点（P2P）的去中心化网络。P2P网络是由两台或更多直接相连并共享资源而无需经过单独的服务器站的计算机创建的。它可能是一个临时连接，例如，通过通用串行总线连接的两台计算机来传输文件。它也可以是一个永久的架构，将一家公司中的多台计算机通过铜线或光纤连接起来。它还可以更大，并使用特殊的协议和应用程序在互联网上建立用户间的直接关系。![](../images/516136_1_En_2_Chapter/516136_1_En_2_Fig1_HTML.png)
- en: An illustration depicts the Bitcoin network. It has six Bitcoin Nodes which
    are connected to each other with a double-headed arrow.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 一幅插图展示了比特币网络。它有六个比特币节点，它们之间用双箭头连接。
- en: Fig. 2.1
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1
- en: The bitcoin network
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币网络
- en: The Bitcoin network uses special cryptographic protocols and software applications
    to connect the nodes over the Internet. The units of currency in the network are
    called *Bitcoins*. The users can send and receive Bitcoins over the network by
    broadcasting their digitally signed messages to other nodes of the network using
    Bitcoin cryptocurrency wallet software. These transactions of the currency are
    then recorded in a distributed, replicated public database or ledger known as
    the *blockchain* or *blockchain ledger*, with consensus achieved by a proof-of-work
    mechanism called *mining*.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币网络使用特殊的加密协议和软件应用程序通过互联网连接节点。网络中的货币单位被称为*比特币*。用户可以通过使用比特币加密货币钱包软件，将他们签名的消息广播到网络的其他节点，从而在网络上发送和接收比特币。这些货币交易随后记录在一个分布式、复制的公共数据库或账本中，该数据库或账本被称为*区块链*或*区块链账本*，通过一种名为*挖矿*的证明工作机制来实现共识。
- en: The designer of Bitcoin Satoshi Nakamoto wrote that the design and coding of
    the Bitcoin software began in 2007\. The project was released in 2009 as an open
    source software.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币的创造者中本聪（Satoshi Nakamoto）写道，比特币软件的设计和编码始于2007年。该项目于2009年作为开源软件发布。
- en: The Bitcoin network requires a minimal infrastructure to share transactions.
    An ad hoc decentralized network of volunteer participants or nodes is sufficient.
    Messages are broadcast on a best-effort basis, and nodes can leave and re-join
    the network at their discretion. Reconnecting to the network, each node downloads
    and verifies new blocks from other nodes to maintain its local copy of the blockchain
    ledger.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币网络需要最基本的基础设施来共享交易。一个自发的去中心化网络，由志愿者参与或节点构成，就足够了。消息是以最佳努力的方式广播的，节点可以自行决定离开和重新加入网络。重新连接到网络，每个节点都会从其他节点下载并验证新区块，以维护其本地区块链账本。
- en: 2.1.2 Bitcoin Transactions
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.2 比特币交易
- en: A Bitcoin transaction is a transfer of Bitcoin value. It is broadcast to the
    network and is recorded in blocks stored in the ledger. A transaction typically
    references previous transaction outputs as new transaction inputs and dedicates
    all input Bitcoin values to new outputs. Transactions are stores as unencrypted
    plaintext. Therefore it is easy to view every transaction ever recorded in a block
    in the ledger, browse blocks and search for transactions of interest. Once transactions
    are appended with a sufficient number of confirmations they can be considered
    irreversible.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币交易是比特币价值的转移。它被广播到网络，并记录在账本中的区块中。一个交易通常引用先前的交易输出作为新的交易输入，并将所有的输入比特币值 dedication
    to新的输出。交易以未加密的纯文本形式存储。因此，很容易查看账本中每个区块记录的每一笔交易，浏览区块并搜索感兴趣的交易。一旦交易获得足够数量的确认，它们就可以被认为是不可撤销的。
- en: All transactions are recorded in hexadecimal format and are visible in the blockchain
    so that everyone can use a hex editor to view or edit them. A blockchain browser
    is a site where every transaction included within the blockchain can be viewed
    in a human-readable form. This is useful for investigating the technical details
    of transactions in operation and for verifying correctness of the payments.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 所有交易都以十六进制格式记录，并可在区块链中查看，以便每个人都可以使用十六进制编辑器查看或编辑它们。区块链浏览器是一个网站，可以查看区块链中的每笔交易，并以人类可读的形式显示。这对于调查交易的运行技术细节和验证支付的正确性非常有用。
- en: Figure [2.2](#Fig2) demonstrates the main parts of a Bitcoin transaction.![](../images/516136_1_En_2_Chapter/516136_1_En_2_Fig2_HTML.png)
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2（[2.2](#Fig2)）展示了比特币交易的主要部分。![](../images/516136_1_En_2_Chapter/516136_1_En_2_Fig2_HTML.png)
- en: An illustration depicts bitcoin transactions. It has two main components namely,
    New Transaction and Previous transaction. Both have sub-components of version,
    input, output, and lock time. The input of the first transaction and output of
    the previous transaction are connected by an arrow.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一个插图展示了比特币交易。它有两个主要组成部分，分别是新交易和先前的交易。两者都包含版本、输入、输出和锁定时间等子组件。第一个交易的输入和先前交易的输出通过箭头连接。
- en: Fig. 2.2
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2
- en: Format of a bitcoin transaction
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币交易的格式
- en: Every transaction begins with a four-byte transaction version number which tells
    the Bitcoin peers and miners which set of rules to use to validate it.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 每个交易都以一个四字节的交易版本号开始，它告诉比特币对等体和矿工使用哪一套规则来验证它。
- en: Every transaction has one or more inputs and one or morn outputs. Each input
    spends the Bitcoins paid by a previous output. Each output then waits as an Unspent
    Transaction Output (UTXO) until a later input spends it. When your Bitcoin wallet
    informs you that there is a 10,000 Bitcoin balance, in fact this means that there
    are 10,000 Bitcoins waiting in one or more UTXOs. The Locktime sets the earliest
    time a transaction can be added to a block in the blockchain.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 每个交易都有一个或多个输入和一个或多个输出。每个输入花费由先前输出支付的比特币。每个输出然后作为未花费交易输出（UTXO）等待，直到后来的输入花费它。当你的比特币钱包告诉你有10,000比特币余额时，实际上这意味着有10,000比特币在一个或多个UTXO中等待。Locktime设置了将交易添加到区块链块中的最早时间。
- en: Each output has an index number determined by its location in the transaction.
    The index of the first output is zero. The output also has an amount in Bitcoins
    which it pays to a receiver with a conditional pubkey script (i.e., a hash of
    the public key of the receiver), for example,![](../images/516136_1_En_2_Chapter/516136_1_En_2_Figa_HTML.png)
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 每个输出都有一个由其在交易中的位置确定的索引号。第一个输出的索引为零。输出还具有以比特币支付给接收者的金额，它带有条件的pubkey脚本（即接收者公钥的哈希），例如，![](../images/516136_1_En_2_Chapter/516136_1_En_2_Figa_HTML.png)
- en: A set of random alphabets and numbers.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一组随机的字母和数字。
- en: The Bitcoin unit is satoshi, which is the smallest denomination of Bitcoin,
    equivalent to 100 millionth of a Bitcoin.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币单位是聪，这是比特币的最小币值，相当于比特币的百万分之一。
- en: Anyone who can satisfy the conditions of that pubkey script, i.e., knowing the
    corresponding private key, is able to spend up to the amount of Bitcoins in the
    future.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 能够满足那个pubkey脚本条件的人，即知道相应的私钥，能够花费未来比特币的最大金额。
- en: Every input uses a transaction identifier (TXID) (i.e., a hash of the previous
    transaction) and an output index number to identify a particular output to be
    spent. Besides, it has a signature script which provides parameters satisfying
    the conditions in the pubkey script, i.e., the signature of the sender (on the
    new output) and the public key of the sender, for example,![](../images/516136_1_En_2_Chapter/516136_1_En_2_Figb_HTML.png)
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 每个输入都使用一个交易标识符（TXID）（即前一个交易的哈希）和一个输出索引号来标识一个特定的输出以供消费。此外，它还有一个签名脚本，该脚本提供了满足pubkey脚本中条件的参数，即发送者的签名（在新输出上）和发送者的公钥，例如，![](../images/516136_1_En_2_Chapter/516136_1_En_2_Figb_HTML.png)
- en: A set of random alphabets and numbers.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一组随机的字母和数字。
- en: The process of spending an output can be illustrated in Fig. [2.3](#Fig3), where
    the sequence number is the input sequence number because there may be more than
    one inputs.![](../images/516136_1_En_2_Chapter/516136_1_En_2_Fig3_HTML.png)
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 花费输出的过程可以在图[2.3](#Fig3)中说明，其中序列号是输入序列号，因为可能有一个以上的输入。![](../images/516136_1_En_2_Chapter/516136_1_En_2_Fig3_HTML.png)
- en: An illustration has three layers. Layer 1 is new transaction with version, input,
    output and lock time. Layer 2 is Transaction identifier with output index, sequence
    number, signature script, amount, and pub-key script. Layer 3 is Previous transaction
    with version, input, output, and lock time.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图有三个层次。第一层是带有版本、输入、输出和锁定时间的新的交易。第二层是带有输出索引、序列号、签名脚本、金额和pub-key脚本的交易标识符。第三层是带有版本、输入、输出和锁定时间的先前交易。
- en: Fig. 2.3
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3
- en: Spending an output
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 花费输出
- en: A new transaction is valid if (1) the signature of the sender on the output
    is genuine on the basis of the public key of the sender, and (2) the public key
    of the sender can be hashed to the pubkey script of the output in the previous
    valid transaction.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个新交易有效（1）基于发送者的公钥，输出上的签名是真实的，（2）发送者的公钥可以哈希到先前有效交易中的输出的pubkey脚本。
- en: A 160-bit hash of the public portion of a public/private keypair of the receiver
    is called a *Bitcoin address*. The standard format of a Bitcoin address is P2PKH
    (Pay to Public Key Hash). Figure [2.4](#Fig4) demonstrates how to create a P2PKH
    public key hash to receive payment.![](../images/516136_1_En_2_Chapter/516136_1_En_2_Fig4_HTML.png)
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 接收者公/私钥对的公钥部分的160位哈希称为一个*比特币地址*。比特币地址的标准格式是P2PKH（支付到公钥哈希）。图[2.4](#Fig4)展示了如何创建P2PKH公钥哈希以接收付款。![](../images/516136_1_En_2_Chapter/516136_1_En_2_Fig4_HTML.png)
- en: A flow chain has private key, full public key and public key hash under Bob’s
    computer, copy of public key hash under Alice’s computer, and copy of public key
    hash under new transaction, all connected by arrows.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个流水链中，在鲍勃的计算机上有私钥、完整的公钥和公钥哈希，在爱丽丝的计算机上有公钥哈希的副本，在新交易中有公钥哈希的副本，所有这些都由箭头连接。
- en: Fig. 2.4
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4
- en: Creating a P2PKH public key hash to receive payment
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个P2PKH公钥哈希以接收付款
- en: Next, let us see the workflow of Alice sending Bob a transaction and Bob later
    spending that transaction in detail. Both Alice and Bob use the most common form
    of the standard P2PKH transaction type. P2PKH allows Alice to spend Bitcoins to
    a typical Bitcoin address, and then lets Bob to spend the same Bitcoins using
    a cryptographic key pair.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们详细看看爱丽丝发送给鲍勃的交易的工作流程，以及鲍勃稍后如何花费这笔交易。爱丽丝和鲍勃都使用标准P2PKH交易类型的最常见形式。P2PKH允许爱丽丝将比特币发送到典型的比特币地址，然后让鲍勃使用加密密钥对花费相同的比特币。
- en: First, Bob has to generate private and public keys forming a key pair. Then
    Alice can implement the transaction. Bitcoin uses the Elliptic Curve Digital Signature
    Algorithm (ECDSA) with the secp256k1 curve.^([1](#Fn1)) The secp256k1 private
    keys are represented by 256 bits of random data. A copy of that data is deterministically
    transformed into an secp256k1 public key. Because the transformation can be reliably
    repeated later, the public key does not have to be stored.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，鲍勃必须生成一个私钥和公钥组成的密钥对。然后爱丽丝可以实施交易。比特币使用secp256k1曲线的椭圆曲线数字签名算法（ECDSA）。^([1](#Fn1))secp256k1私钥由256位随机数据表示。这部分数据的一个副本通过确定性转换为secp256k1公钥。因为该转换可以可靠地稍后重复，所以不需要存储公钥。
- en: Then, the public key (pubkey) is cryptographically hashed. The hash shortens
    and obfuscates the public key, making a manual transcription easier and providing
    security against unanticipated problems which might allow the reconstruction of
    private keys from public key data later on.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，公钥（pubkey）通过加密哈希进行处理。哈希缩短并混淆了公钥，使得手动转录变得更容易，并为防止后来从公钥数据中重建私钥提供了安全保护，防止了无法预见的问题。
- en: Bob supplies the pubkey hash to Alice. Pubkey hashes are almost always sent
    encoded as Bitcoin addresses, which are base58-encoded strings containing an address
    version number, the hash, and an error-detection checksum to catch typos.^([2](#Fn2))
    The address can be transmitted through any medium, including one-way mediums which
    prevent the spender from communicating with the receiver.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 鲍勃向爱丽丝提供公钥哈希。公钥哈希几乎总是以比特币地址的形式发送，这是包含地址版本号、哈希和错误检测校验和的base58编码字符串。^([2](#Fn2))地址可以通过任何介质传输，包括防止花费者与接收者通信的一方向性介质。
- en: When Alice receives the address and decodes it back into a standard hash, she
    can generate the first transaction. Alice creates a standard P2PKH transaction
    output containing instructions which permit anyone to spend that output if they
    can prove that they control the private key corresponding to Bob’s hashed public
    key. These instructions are called the pubkey script or scriptPubKey.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当爱丽丝收到地址并将其解码回标准哈希时，她可以生成第一个交易。爱丽丝创建一个包含允许任何人花费该输出的指令的标准P2PKH交易输出，如果他们能证明他们控制着与鲍勃哈希的公钥对应的私钥。这些指令称为公钥脚本或脚本公钥。
- en: After signing the output, Alice broadcasts the transaction to all nodes and
    it is added to the blockchain. The network categorizes it as an Unspent Transaction
    Output (UTXO). The software of the Bob’s wallet displays it as a spendable balance.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在签署输出后，爱丽丝将交易广播给所有节点，并将其添加到区块链中。网络将其归类为未花费交易输出（UTXO）。鲍勃的钱包软件将其显示为可花费的余额。
- en: When Bob decides to spend the UTXO, he can create an input referring to the
    transaction that Alice created by the hash of the transaction, which is also called
    a Transaction Identifier (TXID), and the specific output Alice used referred to
    by its index number, i.e., the output index. Then Bob must create a signature
    script—a collection of data parameters satisfying the conditions Alice placed
    in the previous output’s pubkey script. Signature scripts are also called scriptSigs.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当鲍勃决定花费UTXO时，他可以创建一个输入，引用爱丽丝通过交易哈希创建的交易，这也称为交易标识符（TXID），以及爱丽丝使用的特定输出，通过其索引号码来引用，即输出索引。然后鲍勃必须创建一个签名脚本——满足爱丽丝在先前输出的公钥脚本中放置的条件的一组数据参数。签名脚本也称为脚本签名。
- en: Pubkey scripts and signature scripts combine secp256k1 pubkeys and signatures
    with conditional logic. This creates a programmable authorization mechanism as
    shown in Fig. [2.5](#Fig5).![](../images/516136_1_En_2_Chapter/516136_1_En_2_Fig5_HTML.png)
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 公钥脚本和签名脚本结合了secp256k1公钥和签名以及条件逻辑。这创建了一个可编程的授权机制，如图[2.5](#Fig5)所示。![](../images/516136_1_En_2_Chapter/516136_1_En_2_Fig5_HTML.png)
- en: An illustration depicts a P 2 P K H output. The components are previous transactions
    with version, input, output, and lock time, then public key hash, followed by
    Signature script with signature, full public key, pub-key script, public key hash,
    and then Bob’s computer with a private key and full public key, connected by arrows.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 插图描绘了一个P 2 P K H输出。组件包括先前交易的版本、输入、输出和锁定时间，然后是公钥哈希，接着是包含签名、完整公钥、公钥脚本、公钥哈希的签名脚本，最后是鲍勃的计算机，带有私钥和完整公钥，由箭头连接。
- en: Fig. 2.5
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5
- en: Spending a P2PKH output
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 花费P2PKH输出
- en: For a P2PKH-style output, Bob’s signature script contains the following two
    data items.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 对于P2PKH风格的输出，鲍勃的签名脚本包含以下两个数据项。
- en: Bob’s full unhashed public key, so the pubkey script can check that it hashes
    to the same value as the pubkey hash provided by Alice.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 鲍勃的未哈希完整公钥，以便公钥脚本可以检查它哈希到的值与爱丽丝提供的公钥哈希相同。
- en: A secp256k1 signature made by using the ECDSA cryptographic formula to combine
    certain transaction data (described below) with Bob’s private key. This lets the
    pubkey script verify that Bob owns the private key which corresponds to the public
    key.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个使用ECDSA加密公式结合特定交易数据（如下所述）和鲍勃的私钥生成的secp256k1签名。这使得公钥脚本能够验证鲍勃拥有与公钥对应的私钥。
- en: Bob’s secp256k1 signature proves that Bob controls his private key, and makes
    the non-signature-script parts of his transaction tamper-proof. Bob can safely
    broadcast them over the peer-to-peer network.![](../images/516136_1_En_2_Chapter/516136_1_En_2_Fig6_HTML.png)
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 鲍勃的secp256k1签名证明鲍勃控制着他的私钥，并使他的交易的非签名脚本部分不可篡改。鲍勃可以安全地在点对点网络上广播它们。![](../images/516136_1_En_2_Chapter/516136_1_En_2_Fig6_HTML.png)
- en: A flow diagram has previous transaction with Transaction I D, output index number,
    and pub-key script, then Bob’s computer with Private key, new transaction, pub-key
    script, and amount, then Signed data, and finally New Transaction with Transaction
    I D, output index, full public key, signature, pub-key script, and amount.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一个流程图具有带有交易ID I D、输出索引号和公钥脚本的先前交易，然后是鲍勃的计算机、私钥、新交易、公钥脚本和金额，接着是已签名数据，最后是新交易，带有交易ID
    I D、输出索引、完整公钥、签名、公钥脚本和金额。
- en: Fig. 2.6
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6
- en: Data items signed when spending an output
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 花费输出时签署的数据项
- en: As illustrated in Fig. [2.6](#Fig6), the data signed by Bob include the TXID
    and the output index of the previous transaction, the pubkey script Bob creates
    which will let the next recipient spend this transaction’s output, and the amount
    of Bitcoins to spend to the next recipient. Thus, the entire transaction is signed
    with the exception of all signature scripts holding the full public keys and secp256k1
    signatures.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如图[2.6](#Fig6)所示，鲍勃签署的数据包括先前交易的TXID和输出索引、鲍勃创建的将允许下一个接收者花费这笔交易输出的公钥脚本，以及要花费给下一个接收者的比特币金额。因此，整个交易除了所有包含完整公钥和secp256k1签名的签名脚本外都被签署了。
- en: Next, Bob appends his signature and the public key to the signature script in
    the input of the new transaction, and broadcasts the transaction to all Bitcoin
    miners through the peer-to-peer network. Every peer and miner independently validates
    the transaction before broadcasting it further or attempting to include it in
    a new block of transactions.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，鲍勃将他的签名和公钥附加到新交易的输入中的签名脚本，并通过点对点网络将交易广播给所有比特币矿工。每个节点和矿工在进一步传播交易或尝试将其包含在新的交易区块之前，独立验证交易。
- en: In a P2PKH output, the pubkey script has the following form:![](../images/516136_1_En_2_Chapter/516136_1_En_2_Figc_HTML.png)
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在P2PKH输出中，公钥脚本具有以下形式：![](../images/516136_1_En_2_Chapter/516136_1_En_2_Figc_HTML.png)
- en: A set of random alphabets and numbers.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一组随机的字母和数字。
- en: In an input of the new transaction, the signature script contains an secp256k1
    signature (sig) and the full public key (pubkey). The signature can be verified
    in the following sequence:![](../images/516136_1_En_2_Chapter/516136_1_En_2_Figd_HTML.png)
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在新交易的输入中，签名脚本包含一个secp256k1签名（sig）和完整的公钥（pubkey）。签名可以按照以下顺序进行验证：![](../images/516136_1_En_2_Chapter/516136_1_En_2_Figd_HTML.png)
- en: A set of random alphabets and numbers.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 一组随机的字母和数字。
- en: In order to test whether the transaction is valid, the signature script and
    pubkey script operations are executed one item at a time, starting with Bob’s
    signature script and continuing to Bob’s pubkey script from Alice’s output. The
    process of the evaluation of a standard P2PKH pubkey script is described as follows.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试交易是否有效，逐个执行签名脚本和公钥脚本操作，从Bob的签名脚本开始，继续执行Alice输出中的Bob的公钥脚本。标准P2PKH公钥脚本的评估过程如下所述。
- en: The signature from Bob’s signature script is added to an empty stack. There
    is no need to encrypt it, and so it is pushed to the stack as plaintext. The public
    key from the signature script is pushed on top of the signature.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从Bob的签名脚本中添加签名到空栈。不需要加密它，因此它以明文形式推送到栈中。签名脚本中的公钥推到签名上面。
- en: The OP_DUP operation on Bob’s pubkey is executed. It pushes onto the stack a
    copy of the data currently at the top of it. This creates a copy of the public
    key supplied by Bob.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对Bob的公钥执行了OP_DUP操作。它将当前位于栈顶的数据推入栈中。这创建了Bob提供的公钥的一个副本。
- en: Next, the operation OP_HASH160 is executed. It adds to the stack a hash of the
    data currently on top of it—in this case, Bob’s public key. This creates a hash
    of Bob’s public key.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，执行OP_HASH160操作。它将当前位于栈顶的数据的哈希值压入栈中——在这个例子中，是Bob的公钥。这创建了Bob的公钥的哈希值。
- en: Then, Bob’s pubkey script from Alice’s output pushes the pubkey hash that Bob
    provided for the previous transaction. At this point, there should be two copies
    of Bob’s pubkey hash at the top of the stack.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，Bob从Alice的输出中推送的公钥脚本将Bob为先前交易提供的公钥哈希值压入栈中。此时，栈顶应该有两个Bob的公钥哈希值。
- en: Further, it executes the operation OP_EQUALVERIFY. It is equivalent to executing
    the operation OP_EQUAL followed by OP_VERIFY as follows.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，执行OP_EQUALVERIFY操作。它等效于先执行OP_EQUAL操作，然后执行OP_VERIFY操作，如下所示。
- en: 'OP_EQUAL checks whether two values at the top of the stack are equal. In our
    case, it checks whether the pubkey hash generated from the full public key supplied
    by Bob is equal to the pubkey hash Alice included in her output when she created
    the previous transaction. The operation OP_EQUAL pops (i.e., removes from the
    top of the stack) the two values it compared, and replaces them with the result
    of the comparison: zero (false) or one (true).'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OP_EQUAL检查栈顶的两个值是否相等。在我们的案例中，它检查Bob提供的完整公钥生成的公钥哈希是否等于Alice在创建先前交易时包含在她输出中的公钥哈希。OP_EQUAL操作比较了两个值，并替换它们为比较的结果：零（false）或一（true）。
- en: OP_VERIFY checks the value at the top of the stack. If the value is false it
    immediately terminates the evaluation and the transaction validation fails. Otherwise,
    it pops the true value off the stack.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OP_VERIFY检查栈顶的值。如果值为false，它将立即终止评估，交易验证失败。否则，它将真值从栈中弹出。
- en: Finally, it executes the operation OP_CHECKSIG, which verifies the signature
    supplied by Bob comparing it with the now-authenticated public key he also provided.
    If the signature matches the public key and was generated using all the data required
    to be signed, then OP_CHECKSIG pushes the value ‘true’ onto the top of the stack.
    If false is not at the top of the stack after the pubkey script has been evaluated,
    the transaction is valid provided there are no other semantic problems with it.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，执行OP_CHECKSIG操作，该操作验证Bob提供的签名，将其与他也提供的已认证的公钥进行比较。如果签名与公钥匹配，并且使用所有需要签名的数据生成了签名，那么OP_CHECKSIG将真值‘true’推送到栈顶。如果在公钥脚本评估完毕后栈顶不是false，则只要交易没有其他语义问题，交易就是有效的。
- en: 2.1.3 Blockchain and Bitcoin’s Proof-of-Work
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.3 区块链与比特币的工作量证明
- en: Bitcoin uses a blockchain public ledger as an ordered and timestamped record
    of transactions. This system is applied to protect against double spending and
    prevent modifications of previous transaction records.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币使用区块链公共账本作为按顺序和时间戳记录交易的系统。这个系统应用于防止双重花费，并防止修改以前的事务记录。
- en: Each full node in the Bitcoin network independently stores a chain of blocks
    containing only blocks validated by that node. When several nodes all have the
    same blocks in their copies of the blockchain ledger, they are considered to be
    in consensus. To maintain consensus these nodes follow the validation rules called
    consensus rules.![](../images/516136_1_En_2_Chapter/516136_1_En_2_Fig7_HTML.png)
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币网络中的每个完整节点独立地存储包含仅由该节点验证的区块的区块链。当几个节点在他们区块链账本的副本中都有相同的区块时，它们被认为是达成共识的。为了维护共识，这些节点遵循称为共识规则的验证规则。![](../images/516136_1_En_2_Chapter/516136_1_En_2_Fig7_HTML.png)
- en: An illustration depicts the blockchain data structure and block format. It has
    three blocks, Block N minus 1, Block N, and Block N plus 1\. The right of the
    image depicts the hash block N plus 1 equal to the hash (block header). It has
    a hash (block N minus 1), market root hash, version, timestamp, nonce, and target
    difficulty.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 插图展示了区块链数据结构和区块格式。它包含了三个区块，区块 N-1，区块 N 和区块 N+1。图片的右侧展示了区块 N+1 的哈希等于区块头（block
    header）的哈希。它有一个区块 N-1 的哈希、市场根哈希、版本、时间戳、随机数（nonce）和目标难度。
- en: Fig. 2.7
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.7
- en: Blockchain data structure and block format
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链数据结构和区块格式
- en: Figure [2.7](#Fig7) displays a simplified version of a blockchain. A group of
    one or more new transactions is collected into the transaction data part of a
    block. Copies of each transaction are hashed, and the hashes are then paired,
    hashed, paired again, and hashed again until a single hash remains, the Merkle
    root of a Merkle tree.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.7 展示了一个简化版的区块链。一组一个或多个新的交易被收集到一个块的交易数据部分。每个交易的副本被哈希处理，然后将这些哈希值配对，再次哈希，再次配对，直到剩下一个哈希值，这就是梅克尔树（Merkle
    tree）的根哈希。
- en: The Merkle root is stored in the block header. Each block also stores the hash
    of the previous block’s header. This chains the blocks together and ensures that
    a transaction cannot be modified without modifying the block that records it and
    all the following blocks.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 梅克尔根哈希存储在区块头中。每个区块还存储前一个区块头的哈希。这使得区块连锁在一起，确保了一个交易不能被修改，而不修改记录它的区块和所有后续的区块。
- en: Transactions are also chained together. Bitcoin’s wallet software gives the
    impression that Bitcoins are sent from and to wallets, but in reality Bitcoins
    move from transaction to transaction. Each transaction spends the Bitcoins previously
    received in one or more earlier transactions. This means that the input of one
    transaction is the output of a previous transaction.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 交易也被连锁在一起。比特币的钱包软件给人一种比特币是从一个钱包发送到另一个钱包的错觉，但事实上比特币是从一个交易转移到另一个交易。每个交易花费之前在一个或多个早期交易中接收的比特币。这意味着一个交易的输入是之前交易的输出。
- en: The blockchain is collaboratively maintained by anonymous peers on the network.
    Bitcoin requires every block to contain a proof that a significant amount of work
    was invested in its creation. This ensures that untrustworthy peers who want to
    modify past blocks are faced with a prohibitively hard amount of work.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链是由网络上的匿名对等节点协作维护的。比特币要求每个区块包含证明在其创建中投入了大量工作的证明。这确保了那些想要修改过去区块的不信守承诺的对等节点面临一个劳动量过大的工作。
- en: Chaining blocks together makes it impossible to modify transactions included
    in any block without modifying all subsequent blocks. As a result, the cost of
    modifying a particular block increases with every new block added to the blockchain
    ledger, increasing the effect of the proof-of-work mechanism.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 连锁区块会使修改任何区块中包含的交易变得不可能，除非也修改所有后续的区块。因此，修改特定区块的成本会随着区块链账本上新增的区块而增加，从而增加了工作量证明机制的效果。
- en: The proof-of-work used in Bitcoin takes advantage of the apparently random nature
    of cryptographic hashes. A good cryptographic hash algorithm converts arbitrary
    data into a hash value that looks like a random number unrelated to the data.
    If the data is modified in any way and the hash algorithm is run again, a new
    hash value that looks like a new random number is generated, so that it is impossible
    to modify the data creating a predictable hash value.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币中使用的工作量证明利用了加密哈希的看似随机性质。一个好的加密哈希算法将任意数据转换成一个看起来像随机数的哈希值，与数据无关。如果以任何方式修改数据，并再次运行哈希算法，将生成一个新的看起来像新随机数的哈希值，因此不可能通过修改数据来创建一个可预测的哈希值。
- en: To prove that a miner completed a substantial work to create a block, the miner
    is required to randomly choose a nonce to create a hash of the block header which
    does not exceed a certain threshold value. For example, if the maximum possible
    hash value is ![$$2^{256}-1$$](../images/516136_1_En_2_Chapter/516136_1_En_2_Chapter_TeX_IEq1.png),
    then the miner can prove that at least two tests were performed by producing a
    hash value less than ![$$2^{255}$$](../images/516136_1_En_2_Chapter/516136_1_En_2_Chapter_TeX_IEq2.png).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明矿工完成了创建区块的大量工作，矿工需要随机选择一个nonce来创建一个不超过一定阈值的区块头哈希。例如，如果最大可能的哈希值是![$$2^{256}-1$$](../images/516136_1_En_2_Chapter/516136_1_En_2_Chapter_TeX_IEq1.png)，那么矿工可以通过产生小于![$$2^{255}$$](../images/516136_1_En_2_Chapter/516136_1_En_2_Chapter_TeX_IEq2.png)的哈希值来证明至少进行了两次测试。
- en: In the simplified example given above, the miner produces a successful hash
    on average every second attempt. The miner can estimate the probability that one
    hash attempt generates a number below the target threshold. Bitcoin assumes a
    linear correlation of the probability and the threshold value. The lower the target
    threshold is made, the more hash attempts are needed on the average to find the
    hash satisfying this condition.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的简化示例中，矿工平均每两次尝试就能产生一个成功的哈希。矿工可以估计一次哈希尝试生成的数值低于目标阈值的概率。比特币假设概率与阈值值呈线性相关。目标阈值设置得越低，平均来说找到满足此条件的哈希所需的哈希尝试次数就越多。
- en: New blocks are added to the chain of blocks only if their hash satisfies the
    condition in the difficulty level specified by the current target threshold in
    the consensus protocol. After every portion of 2016 blocks are added to the ledger,
    the network uses timestamps stored in the headers of all these blocks to compute
    the number of seconds elapsed from the generation of the first until the last
    of these 2016 blocks. The ideal value is 1,209,600 s or two weeks.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当区块的哈希满足共识协议中当前目标阈值指定的难度级别条件时，才会将新区块添加到区块链中。在每次向账本添加2016个区块的一部分后，网络会使用这些区块头部中存储的时间戳来计算从第一个到最后一个2016个区块生成的秒数。理想值是1,209,600秒，即两周。
- en: If it is discovered that less than two weeks were spent on generating the last
    2016 blocks, then the expected difficulty value is increased proportionally (by
    up to 300%) so that the next 2016 blocks should take exactly two weeks to generate
    if the required hashes continue being found at the same rate as before.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果发现最后2016个区块的生成时间少于两周，那么预期的难度值将相应地增加（最多增加300%），以确保如果所需的哈希值以之前的相同速率被发现，下一个2016个区块的生成正好需要两周时间。
- en: If it is discovered that more than two weeks elapsed when the last portion of
    blocks were generated, then the expected difficulty value is decreased proportionally
    (by up to 75%) to speed up the process so that again the next 2016 blocks would
    take exactly two weeks to generate if the required hashes continue being found
    at the same rate as before.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果发现最后一批区块的生成时间超过两周，那么预期的难度值将相应地减少（最多减少75%），以加快进程，使得如果所需的哈希值继续以之前的相同速率被发现，再次下一个2016个区块的生成正好需要两周时间。
- en: Since every block header must hash to a value below the target threshold, and
    because each block is linked to the block that precedes it, it requires on average
    as much hashing power to propagate a modified block as the entire Bitcoin network
    expended between the time the original block was created and the present time.
    Only if you acquired a majority of the network’s hashing power, you could reliably
    execute such a 51% attack against transaction history. However, in terms of probability,
    it should be noted that even a group with less than 50% of the hashing power still
    has a certain chance of performing attacks of this type.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个区块头必须哈希到一个低于目标阈值的值，并且因为每个区块都链接到它前面的区块，所以传播一个修改过的区块平均需要与整个比特币网络在原始区块创建至今的时间内向外耗散的哈希力量一样多。只有当你获得了网络大多数的哈希力量，你才能可靠地对交易历史执行此类51%攻击。然而，从概率上讲，需要注意的是，即使一个拥有不到50%哈希力量的群体仍然有一定的机会进行此类攻击。
- en: The block header includes several easily modifiable fields, such as a dedicated
    nonce field. Therefore, to generate new hashes the miners don’t have to wait for
    new transactions. Besides, only the 80-byte block header is hashed for the proof-of-work.
    The inclusion of a large volume of transaction data in a block does not slow down
    hashing with extra input and output. The addition of transaction data only requires
    to recompute the hashes of the ancestors in the Merkle tree.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 区块头部包括几个容易修改的字段，如专用的 nonce 字段。因此，矿工无需等待新交易即可生成新散列。此外，只有 80 字节的区块头部需要进行工作量证明。在区块中包含大量交易数据不会因为额外的输入输出而减慢散列速度。仅需要重新计算
    Merkle 树中祖先的散列值来添加交易数据。
- en: 2.1.4 Bitcoin Mining
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.4 比特币挖矿
- en: The process of Bitcoin mining is a vitally important component of the maintenance
    and development of the blockchain ledger. It is used to add new Bitcoins into
    circulation. It is also applied to confirm new transactions by the network nodes.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币挖矿是维护和发展区块链账本的关键组成部分。它用于将新的比特币投入流通。它还用于通过网络节点确认新交易。
- en: Bitcoin mining is carried out by applying sophisticated hardware to solve extremely
    complex computational problems. Every solution to the problem can serve as a proof
    that difficult work has been performed. The first computer to find a solution
    to the problem is awarded the right to add the next block of Bitcoins and the
    process of mining continues.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币挖矿是通过应用复杂的硬件来解决极其复杂的计算问题。问题的每一个解决方案都可以作为完成困难工作的证明。首先解决这个问题的计算机将被授予添加下一个比特币块的权利，挖矿过程继续进行。
- en: A Bitcoin miner who successfully hashes a block header to a value below the
    target threshold can add the corresponding block to the blockchain ledger provided
    that the block is valid in other respects. The blocks are commonly referred to
    by their block height—the number of blocks between them and the first Bitcoin
    block (block 0, most commonly known as the genesis block). For example, block
    2016 may be the block where the difficulty level determined by the target threshold
    can be adjusted the first time.![](../images/516136_1_En_2_Chapter/516136_1_En_2_Fig8_HTML.png)
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 成功将区块头部散列到一个低于目标阈值的比特币矿工可以添加相应的区块到区块链账本，前提是该区块在其他方面是有效的。区块通常按它们的区块高度来称呼——它们之间和第一个比特币块（块
    0，通常被称为创世块）之间的区块数量。例如，区块 2016 可能是首次可以根据目标阈值调整难度级别的区块。![](../images/516136_1_En_2_Chapter/516136_1_En_2_Fig8_HTML.png)
- en: An illustration depicts the common and uncommon blockchain forks. It has two
    categories namely, Normal occasional forking and the Rare extended forking.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 插图展示了常见的和不常见的区块链分叉。它分为两类，分别是正常偶尔分叉和罕见延长分叉。
- en: Fig. 2.8
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.8
- en: Common and uncommon blockchain forks
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的和不常见的区块链分叉
- en: Multiple blocks can all have the same block height, since two or more miners
    may happen to produce their blocks at approximately the same time. This creates
    a conflicting fork in the blockchain ledger, as shown in Fig. [2.8](#Fig8).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 多个区块都可以有相同的区块高度，因为两个或更多的矿工可能恰好在他们大约相同的时间内产生区块。这会在区块链账本中创建一个冲突的分叉，如图 [2.8](#Fig8)
    所示。
- en: When two miners produce their blocks simultaneously and add them to the end
    of the blockchain ledger, each node of the network individually chooses which
    block to accept. Typically, many nodes can use the first block they see added.
    Other considerations that may be taken into account are discussed below.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个矿工同时产生他们的区块并将它们添加到区块链账本的末尾时，网络上的每个节点都会单独选择接受哪个区块。通常，许多节点可以使用他们看到的第一个被添加的区块。其他可能考虑的因素如下所述。
- en: Eventually a miner produces another block which is attached to only one of the
    competing simultaneously-mined blocks. This makes the corresponding side of the
    fork stronger than the other side. Assuming that a fork contains only valid blocks,
    normal peers always follow the longest chain of the ledger since it is more reliable
    being confirmed by more difficult set of proofs. The blocks belonging to the shorter
    fork are called *stale blocks*. They have to be thrown away and recreated. Stale
    blocks are also sometimes called *orphans* or *orphan blocks*, but these terms
    are also used for blocks without a known parent block.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，矿工产生了另一个区块，这个区块只附着在同时挖出的竞争区块中的一个。这使得分叉的对应侧面比另一侧面更强。假设分叉中只包含有效的区块，普通节点总是跟随最长的账本链，因为它是通过更多困难的证明确认的更可靠的。属于较短分叉的区块被称为*陈旧区块*。它们必须被丢弃并重新创建。陈旧区块有时也被称为*孤儿区块*或*孤儿块*，但这些术语也用于没有已知父块的区块。
- en: Long-term forks are possible if different miners work at cross-purposes, such
    as some miners diligently working to extend the blockchain ledger at the same
    time other miners are attempting a 51% attack to revise transaction history.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不同的矿工工作目的相反，例如一些矿工勤奋地延长区块链账本的同时，其他矿工试图进行51%攻击来修订交易历史，则可能会出现长期分叉。
- en: Miners are getting paid for their work as auditors. They are doing the work
    of verifying the legitimacy of Bitcoin transactions. This convention is meant
    to keep Bitcoin users honest and was conceived by Bitcoin’s founder, Satoshi Nakamoto.
    By verifying transactions, miners are helping to prevent the “double-spending
    problem.”
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 矿工因为他们的工作（审计）而得到报酬。他们正在做验证比特币交易合法性的工作。这种习俗旨在保持比特币用户的诚实，由比特币创始人中本聪提出。通过验证交易，矿工有助于防止“双重花费”问题。
- en: 'Double spending is a scenario in which a Bitcoin owner illicitly spends the
    same Bitcoin twice. With physical currency, this isn’t an issue: once you hand
    someone a $20 bill to buy something, you no longer have it, so there’s no danger
    you could use that same $20 bill to buy lotto tickets next door. While there is
    the possibility of counterfeit cash being made, it is not exactly the same as
    literally spending the same dollar twice. With digital currency, however, there
    is a risk that the holder could make a copy of the digital token and send it to
    a merchant or another party while retaining the original.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 双重花费是指比特币所有者非法地将同一个比特币花两次的情况。对于纸币来说，这并不是一个问题：一旦你给某人一张20美元的钞票去买东西，你就不再拥有它，所以你不可能用那张同样的20美元钞票去隔壁买彩票。虽然存在伪造现金的可能性，但这并不完全等同于字面上将同一美元花两次。然而，对于数字货币来说，持有可能制作该数字货币的副本并发送给商家或其他方，同时保留原币。
- en: Bitcoin miners are rewarded by receiving Bitcoins for completing blocks of verified
    transactions, which are added to the blockchain. Mining rewards are paid to the
    miner who discovers a solution to the complex hashing puzzle first. The probability
    that a participant discovers a solution is related to the amount of the total
    mining power on the network.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币矿工通过完成验证交易的区块获得比特币作为奖励，这些区块被添加到区块链中。挖矿奖励支付给第一个发现解决复杂散列谜题的矿工。发现解决方案的概率与网络上的总挖矿力量有关。
- en: The rewards for Bitcoin mining are reduced by half approximately every four
    years as shown in Fig. [2.9](#Fig9).![](../images/516136_1_En_2_Chapter/516136_1_En_2_Fig9_HTML.png)
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币挖矿的奖励大约每四年减半，如图[2.9](#Fig9)所示。![](../images/516136_1_En_2_Chapter/516136_1_En_2_Fig9_HTML.png)
- en: A bar graph depicts the miner’s reward for successfully completing 1 block.
    The graph denotes on halve every 210,000 blocks, or an average of every 4 years
    in the categories of from 2009 50 B T C per block, from 2012 25 B T C per block,
    2016 12.5 B T C per block, and from 2020 6.25 B T C per block.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 条形图展示了矿工成功完成1个区块所获得的奖励。该图表示每210,000个区块减半一次，或者平均每4年在2009年每个区块奖励50 BTC，2012年每个区块奖励25
    BTC，2016年每个区块奖励12.5 BTC，以及从2020年开始每个区块奖励6.25 BTC。
- en: Fig. 2.9
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9
- en: Miner’s reward
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 矿工的奖励
- en: When Bitcoin started its operation in 2009, mining one block earned the miner
    50 BTC. In 2012, this amount was reduced to 25 BTC. By 2016, it was reduced again
    to 12.5 BTC. In 2020, the reward was reduced again to 6.25 BTC.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当比特币在2009年开始运营时，挖出一个区块矿工可以获得50 BTC。到了2012年，这个数额减少到了25 BTC。到了2016年，再次减少到12.5
    BTC。2020年，奖励再次减少到6.25 BTC。
- en: In September 2021, the price of Bitcoin was about $45,000 per Bitcoin, which
    means that each miner earned $281,250 (6.25 ![$$\times $$](../images/516136_1_En_2_Chapter/516136_1_En_2_Chapter_TeX_IEq3.png)
    45,000) for completing a block.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 2021年9月，比特币的价格大约为每比特币45,000美元，这意味着每位矿工完成一个区块可以获得281,250美元（6.25*45,000）的奖励。
- en: The first transaction in a block is a *coinbase transaction*. It is a unique
    type of Bitcoin transaction that can be created by a miner. The miners use it
    to collect the block reward for their work and any other transaction fees collected
    by the miner are also sent in this transaction.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一个区块中的第一条交易是一个币基交易。这是一种独特的比特币交易，只能由矿工创建。矿工使用它来收集他们工作的区块奖励以及矿工收集的任何其他交易费用也在此交易中发送。
- en: A coinbase transaction must have exactly one input, which is called a *coinbase*.
    The coinbase input format can be illustrated as Fig. [2.10](#Fig10).![](../images/516136_1_En_2_Chapter/516136_1_En_2_Fig10_HTML.png)
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 币基交易必须恰好有一个输入，这被称为币基。币基输入格式可以如图[2.10](#Fig10)所示说明。![](../images/516136_1_En_2_Chapter/516136_1_En_2_Fig10_HTML.png)
- en: A table has four columns and six rows. The columns have Bytes, Name, Data type,
    and description, respectively.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 一个表格有四列和六行。这些列分别有字节、名称、数据类型和描述。
- en: Fig. 2.10
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.10
- en: Coinbase input format
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 币基输入格式
- en: Coinbase transactions are always constructed by a miner.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 币基交易总是由矿工构造。
- en: They contain a reward for the work spent during the proof-of-work mining process.
    The total amount of reward that a miner receives is equal to the sum of the block
    reward and the transaction fees taken from all the transactions that have been
    included in the block. To create a coinbase transaction, the miner calculates
    the total amount of transaction fees for transactions that are included in a block.
    It is calculated as follows:![](../images/516136_1_En_2_Chapter/516136_1_En_2_Fige_HTML.png)
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 它们包含在工作量证明挖矿过程中花费工作的奖励。矿工收到的奖励总额等于区块奖励和从所有包含在区块中的交易中收取的交易费用的总和。为了创建一个币基交易，矿工计算包含在区块中的交易的交易费用总额。计算方法如下：![](../images/516136_1_En_2_Chapter/516136_1_En_2_Fige_HTML.png)
- en: Total fees equals the sum of inputs plus the sum of outputs
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 总费用等于输入之和加上输出之和
- en: The genesis block, i.e., Block 0, and some initial blocks, contains Coinbase
    transactions only because no other transactions happened in the initialisation
    of Bitcoins.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 创世区块，即区块0，以及一些初始区块，只包含币基交易，因为在比特币的初始化中没有发生其他交易。
- en: It is safe for a miner directly to announce in the Bitcoin network his new discovery
    block which contains his nonce making the hash of his block below a given threshold,
    because his Coinbase transactions (for rewarding) have been included in his block.
    It is difficult for anyone to replace his Coinbase transactions with other transactions
    without changing the hash of the block (i.e., below a given threshold). This is
    one of the smartest ideas in the design of Bitcoin.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 矿工可以直接在比特币网络上宣布他的新发现区块，该区块包含他的随机数，使得他的区块散列值低于给定阈值，因为他的币基交易（作为奖励）已经包含在他的区块中。任何人想要替换他的币基交易而不改变区块散列值（即低于给定阈值）是非常困难的。这是比特币设计中最聪明的想法之一。
- en: 2.2 Ethereum
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2 以太坊
- en: Shortly after Bitcoin’s release, Ethereum looked at the way they were using
    blockchain technology and imagined how it could be used beyond just as a currency.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币发布后不久，以太坊查看了他们使用区块链技术的方式，并想象如何将其用于不仅仅是货币。
- en: Every blockchain is a public database that is updated and shared across many
    computers in a network. The word “block” refers to data and state being stored
    in consecutive groups known as blocks.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 每一个区块链都是一个公共数据库，它通过网络中的许多计算机进行更新和共享。这里的“区块”指的是以块的形式存储的数据和状态。
- en: '*Ether* (ETH) is the cryptocurrency used on the Ethereum network. If you send
    an Ether to someone else, the transaction data needs to be added to a block to
    be successful. The smallest denomination of Ether available in Ethereum is denoted
    by WEI. One Ether is equal to a quintillion WEI, i.e., ![$$10^{18}$$](../images/516136_1_En_2_Chapter/516136_1_En_2_Chapter_TeX_IEq4.png)
    WEI. The most commonly used Ether unit is GWEI. One Ether is equal to a billion
    GWEI, i.e., ![$$10^{9}$$](../images/516136_1_En_2_Chapter/516136_1_En_2_Chapter_TeX_IEq5.png)
    GWEI.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊网络上使用的加密货币称为以太币（ETH）。如果你向他人发送以太币，交易的数据显示需要添加到一个区块才能成功。以太坊中可用的以太币的最小单位由WEI表示。一个以太币等于一万亿WEI，即![$$10^{18}$$](../images/516136_1_En_2_Chapter/516136_1_En_2_Chapter_TeX_IEq4.png)
    WEI。最常使用的以太币单位是GWEI。一个以太币等于十亿GWEI，即![$$10^{9}$$](../images/516136_1_En_2_Chapter/516136_1_En_2_Chapter_TeX_IEq5.png)
    GWEI。
- en: The word “chain” is explained by the fact that each block is linked to its previous
    block cryptographically. In this way, blocks are organised into a consecutive
    chain. The data in a block cannot be modified without altering all the subsequent
    blocks, which would require the consensus of the entire network.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: “链”这个词的解释是因为每个区块通过加密方式与其前一个区块链接在一起。这样，区块被组织成一个连续的链。一个区块中的数据在没有改变所有后续区块的情况下无法被修改，这需要整个网络的共识。
- en: Every participant or computer in the network must agree upon each new block
    and the chain as a whole. These participants or computers are known as “nodes”
    of the network. Nodes ensure that everyone interacting with the blockchain has
    the same data. To accomplish this distributed agreement, blockchain employs a
    consensus mechanism.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 网络中的每个参与者或计算机都必须就每个新区块及整个链达成一致。这些参与者或计算机被称为网络的“节点”。节点确保与区块链互动的每个人都拥有相同的数据。为了实现这种分布式共识，区块链采用了一种共识机制。
- en: Ethereum currently uses a proof-of-work consensus mechanism. It means that anyone
    aiming to add new blocks to the chain must solve a difficult puzzle that requires
    a lot of computing work to be carried out. Solving the puzzle proves that you
    have done the work by using computational resources. Doing this is known as *mining*.
    Typically, mining uses brute force trial and error. Each success in adding a block
    is rewarded in Ethers.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊目前使用工作量证明（Proof of Work，PoW）共识机制。这意味着任何想要向链中添加新区块的人都必须解决一个难题，这个问题需要大量的计算工作。解决难题证明了您使用计算资源完成了工作。这样做被称为*挖矿*。通常，挖矿使用暴力尝试和错误。每次成功添加区块都会以以太币作为奖励。
- en: New blocks are broadcast to the nodes in the network and are verified to update
    the state of the blockchain ledger for everyone. To summarize, when you send an
    Ether to someone, the transaction must be mined and included in a new block. The
    updated state is then shared with the entire network.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 新区块广播给网络中的节点，并通过验证来更新区块链账本的状态，以便让所有人都能获得更新。总结来说，当你向某人发送以太币时，这笔交易必须经过挖掘并包含在新区块中。然后将更新后的状态分享给整个网络。
- en: 2.2.1 Ethereum Network
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.1 以太坊网络
- en: In the Ethereum community, there is a single canonical computer called the *Ethereum
    Virtual Machine* or EVM. Every Ethereum node keeps a copy of the state of the
    EVM. An agreement of all participants on the Ethereum network on the current state
    of the EVM has to be achieved. Besides, any participant can broadcast a request
    for the EVM to perform a requested computation. Whenever such a request is broadcast,
    other participants on the network verify, validate, and execute the computation
    in their copy of the state of the EVM. This execution causes a state change in
    the EVM, which is committed and distributed throughout the entire network.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在以太坊社区中，有一个称为*以太坊虚拟机*或EVM的单一标准计算机。每个以太坊节点都保留EVM状态的一个副本。需要达到以太坊网络上所有参与者的共识，才能确定EVM的当前状态。此外，任何参与者都可以广播一个请求，要求EVM执行某个计算。每当这种请求被广播时，网络上的其他参与者都会在他们EVM状态的副本上进行验证、验证和执行计算。这种执行导致EVM状态发生变化，这种变化被提交并在整个网络上分布。
- en: These requests for computation are called *transaction requests*. The record
    of all transactions and the EVM’s present state is stored on the blockchain ledger,
    which in turn is recorded and agreed upon by all nodes.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这些计算请求称为*交易请求*。所有交易记录以及EVM当前状态都存储在区块链账本上，而账本则由所有节点记录和达成共识。
- en: The network uses cryptographic mechanisms to guarantee that when transactions
    are verified as valid and added to the blockchain, they cannot be tampered with
    later. The same mechanisms also ensure that all transactions are signed and executed
    with appropriate “permissions”. Therefore nobody can send digital assets from
    a network account, except for the owner of the account.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 网络使用加密机制来确保当交易被验证为有效并添加到区块链时，它们以后不能被篡改。同样的机制还确保了所有交易都经过签名并以适当的“权限”执行。因此，除了账户所有者外，没有人能从网络账户发送数字资产。
- en: 2.2.1.1 Ether (ETH)
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.2.1.1 以太（ETH）
- en: '*Ether* (ETH) is the cryptocurrency used for many things on the Ethereum network.
    It is the only acceptable form of payment for transaction fees, as a payment of
    benefit for mining, and other payments.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '*以太*（ETH）是用于以太坊网络上许多事物的加密货币。它是支付交易费用、挖矿收益和其他支付的唯一接受形式。'
- en: Ethereum allows developers to create decentralized applications or dapps, which
    all share a common pool of computing resources. This shared pool is finite and
    Ethereum applies a mechanism determining who can use the resources and when. Otherwise,
    a dapp could accidentally or maliciously consume all network resources, which
    would block others from accessing it.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊允许开发者创建去中心化应用程序或 dapps，它们都共享一个计算资源池。这个共享池是有限的，以太坊应用了一种机制来确定谁可以使用资源以及何时使用。否则，dapp
    可能会意外或恶意地消耗所有网络资源，这将阻止其他人访问它。
- en: The Ether cryptocurrency supports a pricing mechanism for Ethereum’s computing
    power. When users want to make a transaction, they must contribute Ethers to have
    their transaction recognized on the blockchain. These usage costs are known as
    *gas fees*. The gas fee depends on the amount of computing power required to execute
    the transaction and the network-wide demand for computing power at the time.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊加密货币支持以太坊计算力的定价机制。当用户想要进行交易时，他们必须贡献以太币，以便他们的交易被区块链认可。这些使用成本被称为*燃料费*。燃料费取决于执行交易所需的计算力和当时网络对计算力的需求。
- en: Therefore, even if a malicious dapp submitted an infinite loop, the transaction
    would eventually run out of Ethers and terminate, allowing the network to return
    to normal.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，即使恶意 dapp 提交了一个无限循环，交易最终也会用完以太币并终止，使网络恢复正常。
- en: The words ‘Ethereum’ and ‘Ether’ are often used interchangeably. For example,
    the ‘price of Ethereum’ means the same as the price of Ether.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: “以太坊”和“以太”这两个词经常可以互换使用。例如，“以太坊的价格”与“以太的价格”意思相同。
- en: 2.2.1.2 Ethereum Accounts
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.2.1.2 以太坊账户
- en: The current state of the Ethereum is made up from objects called *accounts*.
    Each account has a 20-byte address and state transitions, which are direct transfers
    of value and information between accounts. An Ethereum account contains the following
    four fields.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊的当前状态由称为*账户*的对象组成。每个账户都有一个 20 字节的地址和状态转换，即账户之间的直接价值和安全信息转移。以太坊账户包含以下四个字段。
- en: The **nonce**, a counter used to make sure each transaction can only be processed
    once.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**nonce**，一个用于确保每笔交易只能处理一次的计数器。'
- en: The account’s current **Ether balance**.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 账户当前的**以太币余额**。
- en: The account’s **contract code**, if present.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 账户的**合约代码**（如果有）。
- en: The account’s **storage**, which is empty by default.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 账户的**存储空间**，默认是空的。
- en: 'Ether is used to pay transaction fees. In general, there are two types of accounts:
    **externally owned accounts**, controlled by private keys, and **contract accounts**,
    controlled by their contract code. An externally owned account has no code, and
    one can send messages from an externally owned account by creating and signing
    a transaction. Every time a contract account receives a message its code activates,
    allowing it to read and write to internal storage and send other messages or create
    new contracts.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 以太币用于支付交易费用。通常，账户分为两种：**外部所有账户**，由私钥控制，和**合约账户**，由合约代码控制。外部所有账户没有代码，可以通过创建并签署交易从外部所有账户发送消息。每次合约账户接收到消息时，其代码都会激活，允许它读写内部存储并发送其他消息或创建新合约。
- en: Ethereum contracts do not require something to be implemented or complied with.
    Instead, they act as autonomous agents inside the Ethereum environment. Each contract
    always executes a specific piece of code when prompted by a message or a transaction.
    Contracts have a direct control over their own Ether balance and their own key/value
    store to keep track of persistent variables.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊合约不需要实现或遵守某些东西。相反，它们作为以太坊环境中的自主代理。每个合约在接收到消息或交易请求时总是执行特定的代码。合约直接控制自己的以太币余额和自己的键/值存储，以跟踪持久变量。
- en: '**Example of account creation.** To create an account in Ethereum, most libraries
    can generate a random private key for you. A private key is a sequence of 64 hexadecimal
    characters, which may be encrypted with a password. Here is an example of a private
    key:![](../images/516136_1_En_2_Chapter/516136_1_En_2_Figf_HTML.png)'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**账户创建示例。** 要在以太坊中创建账户，大多数库可以为您生成一个随机的私钥。私钥是64个十六进制字符的序列，可能用密码加密。以下是一个私钥的示例：![](../images/516136_1_En_2_Chapter/516136_1_En_2_Figf_HTML.png)'
- en: a set of random alphabets and numbers.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 一串随机的字母和数字。
- en: A public key is generated from the private key using the Elliptic Curve Digital
    Signature Algorithm. The user can obtain a public address for the account by taking
    the last 20 bytes of the Keccak-256 hash of the public key and adding 0x to the
    beginning.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 公钥是由私钥使用椭圆曲线数字签名算法生成的。用户可以通过取公钥的Keccak-256哈希的最后20个字节并在前面加上0x来获得账户的公地址。
- en: Next, we give an example of creating an account in the console using GETH’s
    personal_newAccount.![](../images/516136_1_En_2_Chapter/516136_1_En_2_Figg_HTML.png)
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们给出使用GETH的personal_newAccount在控制台创建账户的示例。![](../images/516136_1_En_2_Chapter/516136_1_En_2_Figg_HTML.png)
- en: An algorithm
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 一个算法
- en: It is possible for the users to derive new public keys from the private key
    but nobody can derive a private key from the public keys. Therefore, it is vital
    to keep the private key safe and secret.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以从私钥派生出新的公钥，但没有人能从公钥派生出私钥。因此，保护私钥的安全和保密至关重要。
- en: A private key is needed to sign messages and transactions which output a signature.
    Others can then take the signature to derive your public key, proving the author
    of the message. In the Ethereum application, the nodes can use a JavaScript library
    to send transactions to the network.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 私钥用于签署消息和交易，输出签名。其他人可以然后用签名派生出你的公钥，证明消息的作者。在以太坊应用中，节点可以使用JavaScript库向网络发送交易。
- en: Every contract account has a 42 character hexadecimal address, for example,![](../images/516136_1_En_2_Chapter/516136_1_En_2_Figh_HTML.png)
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 每个合约账户都有一个42个字符的十六进制地址，例如，![](../images/516136_1_En_2_Chapter/516136_1_En_2_Figh_HTML.png)
- en: a set of random alphabets and numbers.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 一串随机的字母和数字。
- en: The contract address is usually given when a contract is deployed to the Ethereum
    blockchain.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 合约地址通常在合约部署到以太坊区块链时给出。
- en: 2.2.2 Ethereum Transactions
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.2 以太坊交易
- en: Ethereum transactions are cryptographically signed instructions from accounts.
    An account can initiate a transaction to update the state of the Ethereum network.
    The simplest transaction is transferring ETH from one account to another.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊交易是从账户发出的加密签名指令。账户可以发起交易来更新以太坊网络的状态。最简单的交易是将ETH从一个账户转移到另一个账户。
- en: An Ethereum transaction refers to an action initiated by an externally-owned
    account, that is an account managed by a human, not a contract. For example, if
    Bob sends Alice 1 ETH, Bob’s account must be debited and Alice’s must be credited.
    This state-changing action takes place within a transaction.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊交易指的是由外部所有账户发起的动作，即由人类管理而非合约的账户。例如，如果鲍勃向爱丽丝发送1个ETH，鲍勃的账户必须被借记，爱丽丝的账户必须被贷记。这个改变状态的动作在交易中进行。
- en: Transactions which change the state of the EVM, need to be broadcast to the
    whole network. Every node can broadcast a request for a transaction to be executed
    on the EVM. After this broadcast, a miner executes the transaction and propagates
    the resulting state change to the rest of the network.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 改变EVM状态的交易需要广播到整个网络。每个节点可以将交易执行请求广播到EVM。广播后，矿工执行交易并将结果状态更改传播到网络的其他部分。
- en: Transactions require a fee and must be mined to become valid. In addition to
    the gas fees and details related to the mining process discussed above, every
    submitted transaction must include the following information.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 交易需要费用，并且必须被挖矿才能生效。除了上述讨论的气体费用和与挖矿过程相关的细节外，每个提交的交易都必须包括以下信息。
- en: recipient is the receiving address. (For an externally-owned account, the transaction
    transfers cryptocurrency. For a contract account, the transaction executes the
    contract code.)
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: recipient 是接收地址。（对于外部所有权的账户，交易转移加密货币。对于合约账户，交易执行合约代码。）
- en: signature is the identifier of the sender. The identifier is generated when
    the sender’s private key signs the transaction and confirms that the sender has
    authorized this transaction.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: signature 是发送者的标识符。当发送者的私钥签署交易并确认发送者已经授权此交易时，生成此标识符。
- en: value is the amount of ETH to transfer from sender to recipient.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: value 是从发送者转移到接收者的 ETH 数量。
- en: data is an optional field to include arbitrary data.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: data 是一个可选字段，用于包含任意数据。
- en: gasLimit is the maximum amount of gas units that can be consumed by the transaction.
    Units of gas represent computational steps.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: gasLimit 是交易可以消耗的最大气体单位数。气体单位代表计算步骤。
- en: maxPriorityFeePerGas is the maximum amount of gas to be included as a tip to
    the miner.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: maxPriorityFeePerGas 是作为矿工小费的最大气体量。
- en: maxFeePerGas is the maximum amount of gas willing to be paid for the transaction
    (inclusive of baseFeePerGas and maxPriorityFeePerGas).
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: maxFeePerGas 是愿意为交易支付的最大气体量（包括 baseFeePerGas 和 maxPriorityFeePerGas）。
- en: The term *gas* refers to the computation required to process the transaction
    by a miner. Users have to pay a fee for this computation. The gasLimit, and maxPriorityFeePerGas
    determine the maximum transaction fee paid to the miner. Here is an example of
    the corresponding transaction object.![](../images/516136_1_En_2_Chapter/516136_1_En_2_Figi_HTML.png)
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 术语 *gas* 指的是矿工处理交易所需的计算量。用户必须为此计算支付费用。gasLimit 和 maxPriorityFeePerGas 决定了支付给矿工的最大交易费用。以下是一个相应交易对象的示例。![](../images/516136_1_En_2_Chapter/516136_1_En_2_Figi_HTML.png)
- en: An algorithm
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: An algorithm
- en: Each transaction object needs to be signed using the sender’s private key. This
    proves that the transaction could only have come from the sender and was not sent
    fraudulently. This signing process is handled by an Ethereum client like Geth.
    An example of call is![](../images/516136_1_En_2_Chapter/516136_1_En_2_Figj_HTML.png)
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 每个交易对象需要使用发送者的私钥进行签名。这证明交易只可能来自发送者并且没有被欺诈发送。这个签名过程由像 Geth 这样的以太坊客户端处理。一个调用示例是![](../images/516136_1_En_2_Chapter/516136_1_En_2_Figj_HTML.png)
- en: An algorithm
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: An algorithm
- en: Next, we give an example of a possible response.![](../images/516136_1_En_2_Chapter/516136_1_En_2_Figk_HTML.png)
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们给出一个可能响应的示例。![](../images/516136_1_En_2_Chapter/516136_1_En_2_Figk_HTML.png)
- en: An algorithm
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: An algorithm
- en: raw is the signed transaction in Recursive Length Prefix (RLP) encoded form.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: raw 是使用递归长度前缀 (RLP) 编码的已签名交易。
- en: tx is the signed transaction in JSON form.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: tx 是 JSON 格式的已签名交易。
- en: With the signature hash, transaction can be cryptographically authenticated
    using signed hash submitted to the network to prove that it came from the sender.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 使用签名哈希，交易可以使用提交到网络的已签名哈希进行加密验证，以证明它来自发送者。
- en: Once the transaction has been submitted the following steps follow.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦交易被提交，以下步骤将会进行。
- en: 1.Once you send a transaction, cryptography generates a transaction hash, for
    example,![](../images/516136_1_En_2_Chapter/516136_1_En_2_Figl_HTML.png)
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1. 一旦你发送了一个交易，加密学就会生成一个交易哈希，例如，![](../images/516136_1_En_2_Chapter/516136_1_En_2_Figl_HTML.png)
- en: a set of random alphabets and numbers.
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一组随机字母和数字。
- en: '2.'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '2.'
- en: The transaction is then broadcast to the network and included in a pool with
    other transactions.
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，交易会被广播到网络并包含在其他交易池中。
- en: '3.'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '3.'
- en: A miner must pick your transaction and include it in a block in order to verify
    the transaction and consider it successful.
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 矿工必须选择你的交易并将其包含在一个区块中，以便验证交易并认为它成功。
- en: '4.'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '4.'
- en: Your transaction will receive confirmations. The number of confirmations is
    the number of blocks created since the block that included your transaction. The
    higher the number, the greater the certainty that the network processed and recognized
    the transaction.
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你的交易将会收到确认。确认数是自包含你交易的区块以来创建的区块数。数字越高，网络处理并认可交易的确信度就越高。
- en: Recent blocks may be re-organized, giving the impression the transaction was
    unsuccessful; however, the transaction may still be valid but included in a different
    block.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最近的区块可能会被重新组织，给人一种交易失败的印象；然而，交易可能仍然有效，但包含在不同的区块中。
- en: The probability of a re-organization diminishes with every subsequent block
    added, i.e., the greater the number of confirmations, the more immutable the transaction
    becomes.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着后续区块的增加，重组的概率逐渐减小，即确认次数越多，交易越不可变。
- en: Transactions cost gas to execute. Simple transfer transactions require 21,000
    units of gas.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 交易需要消耗燃料来执行。简单的转账交易需要 21,000 个单位的燃料。
- en: For Bob to send Alice 1 ETH at a baseFeePerGas of 190 GWEI and maxPriorityFeePerGas
    of 10 GWEI, Bob will need to pay the following fee.![](../images/516136_1_En_2_Chapter/516136_1_En_2_Figm_HTML.png)
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，为了在 baseFeePerGas 为 190 GWEI 和 maxPriorityFeePerGas 为 10 GWEI 的条件下，Bob 需要支付以下费用。![](../images/516136_1_En_2_Chapter/516136_1_En_2_Figm_HTML.png)
- en: a set of random alphabets and numbers.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 一组随机字母和数字。
- en: Bob’s account will be debited −1.0042 ETH
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bob 的账户将被扣减-1.0042 ETH
- en: Alice’s account will be credited +1.0 ETH
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Alice 的账户将被增加+1.0 ETH
- en: The base fee will be burned −0.00399 ETH
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基础费用将燃烧-0.00399 ETH
- en: Miner keeps the tip +0.000210 ETH
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矿工保留小费+0.000210 ETH
- en: Gas is required for any smart contract interaction too.![](../images/516136_1_En_2_Chapter/516136_1_En_2_Fig11_HTML.png)
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约交互也需要燃料。![](../images/516136_1_En_2_Chapter/516136_1_En_2_Fig11_HTML.png)
- en: A flow diagram of the Ethereum state transition has three components namely
    Current state, New transaction and Current state.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: Ethereum 状态转换的流程图有三个组成部分，分别是当前状态、新交易和当前状态。
- en: Fig. 2.11
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Fig. 2.11
- en: Ethereum state transition
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Ethereum 状态转换
- en: 2.2.2.1 Ethereum State Transition Function
  id: totrans-199
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.2.2.1 Ethereum 状态转换函数
- en: The Ethereum state transition function APPLY(S, TX), -> S’ is illustrated in
    Fig. [2.11](#Fig11) and is defined as follows.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Ethereum 状态转换函数 APPLY(S, TX)，-> S’ 如图 [2.11](#Fig11) 所示，定义如下。
- en: '1.'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '1.'
- en: Check if the transaction is well-formed (i.e., has the right number of values),
    the signature is valid, and the nonce matches the nonce in the sender’s account.
    If not, then return an error.
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 检查交易是否格式正确（即，具有正确的值数量），签名是否有效，发送者账户中的 nonce 是否匹配。如果不正确，则返回错误。
- en: '2.'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '2.'
- en: Calculate the transaction fee as STARTGAS * GASPRICE, and determine the sending
    address from the signature. Subtract the fee from the sender’s account balance
    and increment the sender’s nonce. If there is not enough balance to spend, return
    an error.
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 计算交易费用为 STARTGAS * GASPRICE，并通过签名确定发送地址。从发送者账户余额中减去费用，并增加发送者的 nonce。如果余额不足，则返回错误。
- en: '3.'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '3.'
- en: Initialize GAS = STARTGAS, and take off a certain quantity of gas per byte to
    pay for the bytes in the transaction.
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 初始化 GAS = STARTGAS，并从中扣除一定数量的燃料费用来支付交易中的字节。
- en: '4.'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '4.'
- en: If the receiving account does not yet exist, then create it. Transfer the transaction
    value from the sender’s account to the receiving account. If the receiving account
    is a contract, then run the contract’s code either to completion or until the
    execution runs out of gas.
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果接收账户尚不存在，则创建它。将从发送者账户转账交易价值到接收账户。如果接收账户是合约，则运行合约代码，要么运行完成，要么执行耗尽燃料。
- en: '5.'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '5.'
- en: If the value transfer failed because the sender did not have enough money or
    the code execution ran out of gas, revert all state changes except the payment
    of the fees, and add the fees to the miner’s account.
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果因为发送者钱不够或代码执行耗尽燃料而导致价值转移失败，除了支付费用外，回滚所有状态更改，并将费用添加到矿工账户。
- en: '6.'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '6.'
- en: Otherwise, refund the fees for all remaining gas to the sender, and send the
    fees paid for gas consumed to the miner.
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 否则，将所有剩余燃料的费用退还给发送者，并将消耗燃料的费用发送给矿工。
- en: For example, suppose that the contract’s code is![](../images/516136_1_En_2_Chapter/516136_1_En_2_Fign_HTML.png)
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设合约的代码是![](../images/516136_1_En_2_Chapter/516136_1_En_2_Fign_HTML.png)
- en: Self storage calldataload (0) it equals calldataload (32)
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 自存储 calldataload (0) 等于 calldataload (32)
- en: Note that in reality the contract code is written in the low-level EVM code.
    This example is written in Serpent, one of our high-level languages, for clarity,
    and can be compiled down to EVM code. Suppose that the contract’s storage starts
    off empty, and a transaction is sent with 10 Ethers, 2000 gas, 0.001 Ether gas
    price, and 64 bytes of data, with bytes 0–31 representing the number 2 and bytes
    32–63 representing the string CHARLIE. In this case, the state transition function
    operates as follows.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，实际上合同代码是以太坊虚拟机（EVM）的低级代码编写的。为了清晰起见，本例使用我们的一种高级语言Serpent编写，并可以编译成EVM代码。假设合同的存储最初为空，发送一个带有10个以太币、2000个燃料、0.001个以太币的燃料价格和64个字节数据的交易，其中字节0-31表示数字2，字节32-63表示字符串CHARLIE。在这种情况下，状态转换函数按如下方式操作。
- en: '1.'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '1.'
- en: Check that the transaction is valid and well formed.
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 检查交易是否有效且格式正确。
- en: '2.'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '2.'
- en: Check that the transaction sender has at least 2000 * 0.001 = 2 Ether. If so,
    then subtract 2 Ether from the sender’s account.
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 检查交易发送者至少有2000 * 0.001 = 2个以太币。如果是，那么从发送者的账户中减去2个以太币。
- en: '3.'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '3.'
- en: Initialize gas = 2000, assuming the transaction is 170 bytes long and the byte-fee
    is 5\. Subtract 850 from the account so that there is 1150 gas left.
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 初始化燃料=2000，假设交易为170个字节长，每个字节的费用为5。从账户中减去850，以便剩下1150个燃料。
- en: '4.'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '4.'
- en: Subtract 10 more Ether from the sender’s account, and add it to the contract’s
    account.
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从发送者的账户中再减去10个以太币，并添加到合同的账户中。
- en: '5.'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '5.'
- en: Run the code. In this case, the code checks whether the contract’s storage at
    index 2 is used, notices that it is not, and so it sets the storage at index 2
    to the value CHARLIE. Suppose that this takes 187 gas. Then the remaining amount
    of gas is ![$$1150 - 187 = 963.$$](../images/516136_1_En_2_Chapter/516136_1_En_2_Chapter_TeX_IEq6.png)
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行代码。在此案例中，代码检查合同存储中的索引2是否被使用，发现未被使用，因此将索引2的存储设置为值CHARLIE。假设这需要187个燃料。那么剩余的燃料量为！[$$1150
    - 187 = 963.$$](../images/516136_1_En_2_Chapter/516136_1_En_2_Chapter_TeX_IEq6.png)
- en: '6.'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '6.'
- en: Add 963 * 0.001 = 0.963 Ether back to the sender’s account and return the resulting
    state.
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 向发送者的账户中添加963 * 0.001 = 0.963个以太币，并返回结果状态。
- en: If there was no contract at the receiving end of the transaction, then the total
    transaction fee would be equal to GASPRICE multiplied by the length of the transaction
    in bytes, and the data sent alongside the transaction would be irrelevant.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果交易接收端没有合同，那么总交易费用将等于GASPRICE乘以交易的字节长度，与交易一起发送的数据将无关。
- en: Note that processing of messages operates in the same way as in the case of
    transactions in terms of handling reversals. If a message execution runs out of
    gas, then the execution and all other executions triggered by that execution,
    revert, but parent executions do not need to revert. This means that it is safe
    for a contract to call another contract, since if A calls B with G gas then A’s
    execution is guaranteed to lose at most G gas. Finally, note that there is an
    opcode CREATE that creates a contract. Its execution mechanics are generally similar
    to CALL with the exception that the output of the execution determines the code
    of a newly created contract.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，消息的处理方式与交易的处理方式相同，都可以逆转。如果消息执行耗尽了燃料，那么执行以及由该执行触发的所有其他执行都将回滚，但父执行不需要回滚。这意味着合同调用另一个合同是安全的，因为如果A用G个燃料调用B，那么A的执行最多会损失G个燃料。最后，请注意存在一个操作码CREATE，用于创建合同。它的执行机制与CALL类似，不同之处在于执行的输出确定了新创建合同的代码。
- en: 2.2.3 Ethereum’s Proof-of-Work
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.3 以太坊的工作量证明
- en: Ethereum, like Bitcoin, currently uses a consensus protocol called proof-of-work
    (PoW). This allows the nodes of the Ethereum network to agree on the state of
    all information recorded on the Ethereum blockchain and prevents various economic
    attacks.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊，像比特币一样，目前使用一种名为工作量证明（PoW）的共识协议。这使得以太坊网络的节点能够就以太坊区块链上记录的所有信息的状态达成一致，并防止各种经济攻击。
- en: Proof-of-work is the underlying algorithm that sets the difficulty and rules
    for the work miners do. Mining is the “work” itself. It’s the act of adding valid
    blocks to the chain. This is important because the chain’s length helps the network
    follow the correct Ethereum chain and understand Ethereum’s current state. The
    more work is done, the longer the chain, and the higher the block number, the
    more certain the network can be of the current state of the ledger.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 工作量证明是设置难度和工作矿工规则的底层算法。挖矿本身就是“工作”。它是向链中添加有效块的行为。这很重要，因为链的长度帮助网络跟随正确的以太坊链并理解以太坊的当前状态。完成的工作越多，链越长，块数越高，网络对账本当前状态的确定性就越高。
- en: 2.2.3.1 How Does Ethereum’s Proof-of-Work Work?
  id: totrans-233
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.2.3.1以太坊的工作量证明是如何工作的？
- en: Proof-of-work is performed by miners, who compete to create new blocks full
    of processed transactions. The winner shares the new block with the rest of the
    network and earns some freshly minted ETH. The race is won by the computer that
    manages to solve a math puzzle first. This produces the cryptographic link between
    the current block and the preceding block in the chain. Solving the puzzle is
    the work required to establish proof-of-work.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 工作量证明由矿工执行，他们竞争创建充满处理交易的新块。胜者将新块与其他网络分享，并获得一些新铸造的ETH。比赛由第一个解决数学难题的计算机赢得。这产生了当前块与链中前一个块之间的加密链接。解决难题是建立工作量证明的工作。
- en: Ethereum transactions are processed into blocks. Each block has a
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊交易被处理成区块。每个区块都有一个
- en: 'block difficulty—for example: 3,324,092,183,262,715'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: block难度—例如：3,324,092,183,262,715
- en: 'mixHash, for example: 0x44bca881b07a6a09f83b130798072441705d9a6...'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: mixHash，例如：0x44bca881b07a6a09f83b130798072441705d9a6...
- en: 'nonce, for example: 0xd3ee432b4fb3d26b'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: nonce，例如：0xd3ee432b4fb3d26b
- en: The proof-of-work protocol Ethash requires miners to go through an intense race
    of trial and error to find the nonce for a block. Only blocks with a valid nonce
    can be added to the chain. When racing to create a block, a miner repeatedly puts
    a dataset, that you can only get from downloading and running the full chain (as
    a miner does), through a mathematical function. The dataset gets used to generate
    a mixHash below a target nonce, as dictated by the block difficulty. The best
    way to do this is through trial and error.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 工作量证明协议Ethash要求矿工进行一场激烈的试错赛，以找到一个块的非ce。只有具有有效nonce的块才能添加到链中。当创建块时，矿工反复将一个数据集（只有通过下载并运行完整链（矿工这样做）才能获得）通过一个数学函数。数据集用于生成一个低于目标nonce的mixHash，如难度所规定。最好的方法是通过试错。
- en: The difficulty determines the target for the hash. The lower the target, the
    smaller the set of valid hashes. Once generated, this is incredibly easy for other
    miners and clients to verify. Even if one transaction were to change, the hash
    would be completely different, signalling fraud.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 难度决定了哈希的目标。目标越低，有效的哈希集合越小。一旦生成，这对于其他矿工和客户端来说验证起来非常容易。即使有一个交易发生变化，哈希也会完全不同，表示欺诈。
- en: Hashing makes fraud easy to spot. Proof-of-work as a process is also a big deterrent
    preventing attacks.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希使得欺诈变得容易识别。作为一种过程，工作量证明也是防止攻击的一大威慑。
- en: 2.2.3.2 Proof-of-Work and Security
  id: totrans-242
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.2.3.2工作量证明与安全性
- en: Miners are incentivised to do their work on the main Ethereum chain. There is
    little incentive for a subset of miners to start their own chain. Blockchains
    rely on having a single state as a source of truth. The users always choose the
    longest or “heaviest” chain.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 矿工被激励在以太坊主链上进行工作。在主链之外开始自己的链对矿工的激励很小。区块链依赖于拥有单一状态作为真实来源。用户总是选择最长或“最重”的链。
- en: The objective of the proof-of-work is to extend the chain. The longest chain
    is most believable as the valid one because it’s had the most computational work
    done. Within Ethereum’s PoW system, it’s nearly impossible to create new blocks
    that erase transactions, create fake ones, or maintain a second chain. That’s
    because a malicious miner would need to always solve the block nonce faster than
    everyone else.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 工作量证明的目标是延伸链。最长的链因为进行了最多的计算工作而被认为是最可信的。在以太坊的PoW系统中，几乎不可能创建新的块来删除交易，创建假交易或维护第二条链。这是因为恶意矿工需要始终比其他人更快地解决块nonce。
- en: To consistently create malicious yet valid blocks, an attacker would need over
    51% of the network mining power to beat everyone else. The energy spent might
    even outweigh the gains the attacker could make in an attack.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 要持续创建恶意但有效的区块，攻击者需要超过51%的网络挖矿功率来打败其他人。攻击者可能需要花费的能源甚至可能超过攻击中能获得的收益。
- en: 2.2.3.3 Finality
  id: totrans-246
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.2.3 最终性
- en: A transaction in Ethereum achieves *finality* when it is included in a block
    and the block can no longer change. Since the work of the miners of Ethereum is
    decentralized, it is possible that two valid blocks can be generated at the same
    time. This creates a temporary fork. Eventually, one of these chains grows and
    becomes the accepted chain after a subsequent block has been mined and added making
    it longer.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在以太坊中，当交易包含在区块中且区块不能再更改时，交易达到*最终性*。由于以太坊矿工的工作是去中心化的，可能会同时生成两个有效的区块。这创建了一个临时分叉。最终，这些链中的一个会增长并成为后续区块被挖掘并添加后变得更长的接受链。
- en: To complicate things further, transactions rejected on the temporary fork may
    have been included in the accepted chain. This means it could get reversed. Ethereum’s
    *finality* is a reference to the time when the users do not have to wait and can
    consider a transaction immutable and irreversible. For Ethereum, the recommended
    waiting time is to wait for six blocks to be added, or just over 1 min. After
    six blocks, the users can assume with high level of confidence that the transaction
    was successful and cannot be reversed. Cautious users may decide to wait longer
    for achieving greater level of certainty.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步复杂化问题，临时分叉上被拒绝的交易可能已经被包含在接受的链中。这意味着它可能会被撤销。以太坊的*最终性*指的是用户不必等待并且可以认为交易是不可变和不可撤销的时间。对于以太坊，建议的等待时间是等待六个区块被添加，或者超过1分钟。六个区块之后，用户可以高度自信地认为交易成功并且不能被撤销。谨慎的用户可能会决定等待更长时间以获得更高的确定性。
- en: Finality has to be taken into account in the process of designing dapps. It
    would be misleading for the users to misrepresent transaction information and
    allow the users to rely on a transaction too early, especially if the transaction
    is of high value. The finality waiting time doesn’t include the time that has
    to elapse before the transaction is chosen by a miner and is included in a block.![](../images/516136_1_En_2_Chapter/516136_1_En_2_Fig12_HTML.png)
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计dapps的过程中必须考虑到最终性。如果用户误报交易信息并允许用户过早地依赖交易，尤其是如果交易价值很高，这将误导用户。最终性等待时间不包括交易被矿工选择并包含在区块之前必须经过的时间。![](../images/516136_1_En_2_Chapter/516136_1_En_2_Fig12_HTML.png)
- en: A chain diagram on Ethereum applications and workflow.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊应用和工作流程的链式图。
- en: Fig. 2.12
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.12
- en: Ethereum blockchain and mining
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊区块链和挖矿
- en: 2.2.4 Ethereum Mining
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.4 以太坊挖矿
- en: The Ethereum blockchain and mining are illustrated in Fig. [2.12](#Fig12). They
    are similar to the Bitcoin blockchain. However, there are also several differences.
    The main difference between Ethereum and Bitcoin with regard to the blockchain
    architecture is that, unlike Bitcoin, Ethereum blocks contain a copy of both the
    transaction list and the most recent state. Two other values, the block number
    and the difficulty, are also stored in the block. The basic block validation algorithm
    in Ethereum proceeds as follows.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊区块链和挖矿如图[2.12](#Fig12)所示。它们与比特币区块链相似。然而，也有一些不同之处。以太坊与比特币在区块链架构方面的主要区别在于，与比特币不同，以太坊区块包含交易列表和最新状态的副本。区块还存储了另外两个值，即区块号码和难度。以太坊的基本区块验证算法如下进行。
- en: '1.'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '1.'
- en: Check if the previous block referenced exists and is valid.
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 检查前一个区块是否引用存在且有效。
- en: '2.'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '2.'
- en: Check that the timestamp of the block is greater than that of the referenced
    previous block and less than 15 min into the future.
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 检查区块的时间戳是否大于引用的前一个区块的时间戳且小于15分钟的未来时间。
- en: '3.'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '3.'
- en: Check that the block number, difficulty, transaction root, uncle root and gas
    limit (various low-level Ethereum-specific concepts) are valid.
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 检查区块号码、难度、交易根、叔块根和燃料限制（各种低级以太坊特定概念）是否有效。
- en: '4.'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '4.'
- en: Check that the proof-of-work on the block is valid.
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 检查区块上的工作量证明是否有效。
- en: '5.'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '5.'
- en: Let S[0] be the state at the end of the previous block.
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 设S[0]为前一个区块结束时的状态。
- en: '6.'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '6.'
- en: Let TX be the block’s transaction list, with n transactions. For all i in 0...n-1,
    set S[i+1] = APPLY(S[i],TX[i]). If any applications returns an error, or if the
    total gas consumed in the block up until this point exceeds the GASLIMIT, return
    an error.
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 设TX为一个区块的交易列表，包含n笔交易。对于所有i在0...n-1，设置S[i+1] = APPLY(S[i],TX[i])。如果任何应用返回错误，或者如果区块到目前为止消耗的总燃料气体超过GASLIMIT，返回一个错误。
- en: '7.'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '7.'
- en: Let S_FINAL be S[n], but adding the block reward paid to the miner.
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 设S_FINAL为S[n]，但添加了矿工的区块奖励。
- en: '8.'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '8.'
- en: Check if the Merkle tree root of the state S_FINAL is equal to the final state
    root provided in the block header. If it is, the block is valid; otherwise, it
    is not valid.
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 检查状态S_FINAL的Merkle树根是否等于区块头中提供的最终状态根。如果是，区块有效；否则，区块无效。
- en: The approach may seem inefficient, because it needs to store a copy of the entire
    state within every block. However, in practice the Ethereum efficiency turns out
    comparable to that of Bitcoin. The reason is that the state is stored in a tree
    structure, and after every new block only a small part of the tree needs to be
    adjusted. Thus, in general, the vast majority of the tree remains unchanged between
    two adjacent blocks. Therefore the data can be stored once and referenced twice
    using pointers (i.e., hashes of subtrees). A special type of tree known as a *Patricia
    tree* is used to accomplish this. It includes a modification of the Merkle tree
    concept that allows for nodes to be inserted and deleted, not only changed, efficiently.
    Besides, since all the state information is a part of the last block, there is
    no need to store the entire blockchain history—a strategy which, if it could be
    applied to Bitcoin, can be demonstrated to lead to 5–20 times saving in the storage
    space.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法可能看起来效率不高，因为它需要在每个区块中存储整个状态的副本。然而，实际上以太坊的效率与比特币相当。原因是状态是以树结构存储的，在每一个新块之后只需要调整树的小部分。因此，在一般情况下，相邻两个区块之间的树的大部分保持不变。因此，数据可以一次存储，并使用指针（即子树的哈希值）引用两次。一种特殊的树结构，称为*Patricia树*，被用来实现这一点。它包括对Merkle树概念的一种修改，允许节点被有效地插入和删除，而不仅仅是更改。此外，由于所有状态信息都是上一个块的一部分，因此无需存储整个区块链历史——这种策略，如果应用于比特币，可以证明可以节省5-20倍的存储空间。
- en: The process of executing contract code is a part of the definition of the state
    transition function. The latter is a part of the block validation algorithm, so
    if a transaction is added into block B the code execution spawned by that transaction
    is executed by all nodes now, and in the future, the download and validate block
    B.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 执行合约代码的过程是状态转换函数定义的一部分。后者是区块验证算法的一部分，所以如果将交易添加到区块B中，现在以及未来的所有节点都会执行由该交易触发的代码，下载并验证区块B。
- en: 2.3 Smart Contracts
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3 智能合约
- en: The notion of a *smart contract* was first proposed by Nick Szabo [[30](#CR30)].
    Szabo is a legal scholar and cryptographer known for ground-breaking work on the
    foundations of digital currencies. The idea of being able to record contracts
    in the form of computer code was proposed in [[30](#CR30)]. The proposed contract
    is activated automatically when certain conditions are met. This idea could potentially
    remove the need for trusted third-party companies.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: “智能合约”这一概念最早是由Nick Szabo提出的[[30](#CR30)]。Szabo是一位法律学者和密码学家，以在数字货币基础方面的开创性工作而闻名。将合同以计算机代码的形式记录下来的想法是在[[30](#CR30)]中提出的。提议的合约在满足某些条件时会自动激活。这个想法可能会消除需要信任的第三方公司。
- en: In 2008, the Bitcoin cryptocurrency was developed on a blockchain network [[25](#CR25)].
    This technology enabled the development of smart contract code used to enter the
    terms of the contract into the blockchain.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 2008年，基于区块链网络的比特币加密货币被开发出来[[25](#CR25)]。这项技术使得可以开发智能合约代码，用于将合同条款输入区块链。
- en: In this format, contracts are converted to computer code, are stored and replicated
    on the system and supervised by the network of computers that run the blockchain.
    This results in ledger feedback such as transferring money and receiving the product
    or service.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种格式下，合约被转换成计算机代码，存储并在系统上复制，并由运行区块链的计算机网络监督。这导致了诸如转账货币和接收产品或服务之类的账本反馈。
- en: In 2015, Ethereum was founded by Buterin [[10](#CR10)] introducing the first
    working smart contracts.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 2015年，以太坊由Buterin创立，引入了第一个可工作的智能合约[[10](#CR10)]。
- en: A *smart contract* is a computer program consisting of a set of rules running
    on the blockchain. The integration of blockchain technology and smart contract
    gives flexibility for developing and designing as well as implementing some of
    the real world problems.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*智能合约*是一组在区块链上运行的规则组成的计算机程序。区块链技术与智能合约的整合为开发和设计以及实现一些现实世界问题提供了灵活性。
- en: Current smart contracts used in blockchain resemble scripts that implement conventional
    pen and paper contracts with code lines. Smart contracts execute the code when
    certain conditions are met.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 目前区块链中使用的智能合约类似于实现传统纸质合同的脚本，通过代码行来实现。当满足某些条件时，智能合约执行代码。
- en: Smart contracts allow new contracts to be created between two parties completely
    unknown to each other. The contract takes effect only if certain conditions are
    met. It follows that one of the main characteristics of smart contracts is that
    they facilitate the signing and execution of contracts without participation of
    middlemen.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约允许两个彼此完全陌生的双方创建新的合同。只有在满足某些条件时，合同才生效。因此，智能合约的一个主要特征是它们能够无需中间人参与就签署和执行合同。
- en: Smart contracts are implemented on many blockchain platforms, not only on Ethereum.
    Blockchains were an ideal environment to test the idea of smart contracts.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约在许多区块链平台上实施，不仅在以太坊上。区块链是一个测试智能合约想法的理想环境。
- en: Every smart contract is a decentralized application that executes business logic
    in response to events. Smart contract execution can result in the exchange of
    money, delivery of services, unlocking of content protected by digital rights
    management or other types of data manipulation such as changing the name on a
    land title. Smart contracts can also be used to enforce privacy protection by,
    for example, facilitating the selective release of privacy-protected data for
    specific requests.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 每一个智能合约都是一个去中心化应用，它根据事件执行商业逻辑。智能合约的执行可能导致货币的交换、服务的交付、数字版权管理保护的内容的解锁或其他类型的数据操作，例如更改土地登记上的名字。智能合约还可以用于通过例如促进针对特定请求的隐私保护数据的的选择性释放来执行隐私保护。
- en: A variety of architectures can be used for developing, distributing, managing
    and updating smart contracts. The contracts can be stored on a blockchain or other
    distributed ledger technology, and can be integrated into various payment mechanisms
    and digital exchanges that rely on Bitcoin or other cryptocurrencies.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 可以采用多种架构用于开发、分发、管理和更新智能合约。合约可以存储在区块链或其他分布式账本技术上，并且可以集成到依赖比特币或其他加密货币的各种支付机制和数字交易所中。
- en: Smart contracts are not legally binding. Their main function is to programmatically
    execute business logic that performs various tasks, processes or transactions
    that have been programmed into them to respond to a given set of conditions. Legal
    steps must be undertaken to link this execution to legally binding agreements
    between parties.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约并不是具有法律约束力的。它们的主要功能是按照预设的条件，程序化地执行包含在其中的各种任务、流程或交易。必须采取法律步骤将这种执行与各方之间的具有法律约束力的协议相链接。
- en: A smart contract is a computer program having self-verifying, self-executing,
    tamper-resistant properties. Smart contracts help you exchange money, property,
    shares, or anything of value in a transparent, conflict-free way while avoiding
    the services of a middleman.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约是一种具有自我验证、自我执行、防篡改特性的计算机程序。智能合约帮助你以透明、无冲突的方式交换货币、财产、股份或任何有价值的东西，同时避免使用中间人服务。
- en: Smart contracts can define the rules and penalties in an agreement in the same
    way that traditional contracts do, and also envisage actions that help to automatically
    enforce these obligations. The operations of smart contracts is more comparable
    to that of vending machine rather than legal entities. With smart contracts, you
    simply drop a Bitcoin into the vending machine (i.e., ledger) and supply your
    driver’s license, or password, or another identification for access to your account.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约可以像传统合同一样定义协议中的规则和处罚，并设想有助于自动执行这些义务的行动。智能合约的操作更像自动售货机，而不是法律实体。通过智能合约，你只需将比特币投入自动售货机（即账本）中，并提供你的驾照、密码或其他用于访问账户的身份证明。
- en: 2.3.1 The Definition of a Smart Contract
  id: totrans-287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.1 智能合约的定义
- en: A *smart contract* is a program that runs on the Ethereum blockchain. It’s a
    collection of code (its functions) and data (its state) that resides at a specific
    address on the Ethereum blockchain.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约是运行在以太坊区块链上的程序。它是一系列代码（其功能）和数据（其状态）的集合，位于以太坊区块链上的特定地址。
- en: Smart contracts are a type of Ethereum account. This means that they have a
    balance and they can send transactions over the network. However, they are not
    controlled by a user, instead they are deployed to the network and run as programmed.
    User accounts can then interact with a smart contract by submitting transactions
    that execute a function defined on the smart contract. Smart contracts can define
    rules, like a regular contract, and automatically enforce them via the code. Smart
    contracts cannot be deleted by default, and interactions with them are irreversible.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约是以太坊的一种账户类型。这意味着它们有余额，并且可以在网络上发送交易。然而，它们不由用户控制，而是部署到网络上并按编程方式运行。用户账户可以通过提交执行智能合约上定义的功能的交易与智能合约互动。智能合约可以定义规则，就像普通的合同一样，并通过代码自动执行它们。智能合约默认情况下不能被删除，与它们的互动是不可逆的。
- en: To illustrate the operation of a smart contract it may be useful to compare
    it to a vending machine. As a vending machine, the smart contract also receives
    appropriate inputs and generates certain outputs.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明智能合约的操作，将其与自动售货机进行比较可能是有用的。像自动售货机一样，智能合约也接收适当的输入并生成某些输出。
- en: For example, the process of getting a snack from a vending machine can be described
    symbolically as follows![](../images/516136_1_En_2_Chapter/516136_1_En_2_Figo_HTML.png)
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，从自动售货机获取小吃的过程可以符号化为以下形式![](../images/516136_1_En_2_Chapter/516136_1_En_2_Figo_HTML.png)
- en: money Plus snack selection Equals to snack dispensed
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 金钱加上小吃选择等于分发小吃
- en: A smart contract, like a vending machine, has logic programmed into it. Here’s
    an example of how the same vending machine can be represented as a smart contract.![](../images/516136_1_En_2_Chapter/516136_1_En_2_Figp_HTML.png)
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约就像自动售货机一样，其中包含逻辑代码。以下是一个将同样的自动售货机表示为智能合约的示例。![](../images/516136_1_En_2_Chapter/516136_1_En_2_Figp_HTML.png)
- en: An algorithm
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 算法
- en: Vending machines remove the need for vendor employees. Likewise, smart contracts
    can replace intermediaries in many industries.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 自动售货机消除了售货员的需求。同样，智能合约可以在许多行业中取代中介。
- en: Everyone can write a smart contract and deploy it to the network. It suffices
    to learn how to code in a smart contract language and have enough ETHs to deploy
    the contract. Deploying a smart contract is technically a transaction, and so
    everyone has to pay gas for deploying smart contracts in the same way as gas is
    paid for simple ETH transfers. In practice, gas costs for contract deployment
    are much higher.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 每个人都可以编写智能合约并将其部署到网络上。只要学会用智能合约语言编程，并拥有足够的ETH来部署合约即可。部署智能合约技术上是一种交易，因此每个人都必须为部署智能合约支付燃料费，就像为简单的ETH转账支付燃料费一样。实际上，部署智能合约的燃料成本要高得多。
- en: 'Ethereum has the following developer-friendly languages for writing smart contracts:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 以太坊有以下几种对开发者友好的语言用于编写智能合约：
- en: Solidity (the vending machine example above is written in Solidity).
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Solidity（上述自动售货机示例是用Solidity编写的）。
- en: Vyper
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vyper
- en: Programs written in these languages must be compiled before they can be deployed
    so that Ethereum’s virtual machine can interpret and store the contract.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 用这些语言编写的程序在部署之前必须编译，以便以太坊虚拟机可以解释并存储合约。
- en: 2.3.2 How Does a Smart Contract Work?
  id: totrans-301
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.2 智能合约是如何工作的？
- en: The process of creating a smart contract starts with business teams working
    with developers to describe their requirements for the desired behaviour of the
    smart contract in response to various events or circumstances. Simple events could
    be conditions such as payment authorized, shipment received or a utility meter
    reading threshold. More sophisticated logic might encode more complex events such
    as calculating the value of a derivative financial instrument and processing a
    trade of the derivative, or automatically releasing an insurance payment in the
    event of a person’s death or a natural disaster.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 创建智能合约的过程从业务团队与开发者合作描述智能合约在应对各种事件或情况时的预期行为开始。简单的事件可能是诸如支付授权、收到货物或公用事业表读数阈值等条件。更复杂的逻辑可能会编码更复杂的事件，如计算衍生金融工具的价值并处理衍生品的交易，或在人员死亡或自然灾害事件自动释放保险赔偿。
- en: The developers then work in a smart contract-writing platform to develop the
    logic and test it to ensure that it works as intended. After the application is
    written, it is handed over to another team for a security review. This could be
    an internal expert or a firm that specializes in verifying smart contract security.
    Once the contract has been approved, it is deployed on an existing blockchain
    or other distributed ledger infrastructure.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 然后开发者在智能合约编写平台上工作，开发逻辑并测试它，以确保它按预期工作。应用程序编写完成后，它被交给另一支团队进行安全审查。这可能是一个内部专家或一家专门验证智能合约安全的公司。一旦合同获得批准，它将被部署在现有的区块链或其他分布式账本基础设施上。
- en: Every deployed contract is configured to listen to event updates from an oracle,
    which is a cryptographically secured streaming data source. The smart contract
    executes once it receives an appropriate mix of events from one or more oracles.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 每个部署的合同都被配置为监听来自预言机的事件更新，预言机是一个经过加密保护的流数据源。一旦智能合约从一台或多台预言机接收到适当的事件组合，它就会执行。
- en: First, the parties of the contract should determine the terms of the contract.
    After the contractual terms are completed, they are translated into programming
    code as shown in Fig. [2.13](#Fig13). The code represents a number of different
    conditional statements that describe possible scenarios for future transactions
    to occur [[11](#CR11)].![](../images/516136_1_En_2_Chapter/516136_1_En_2_Fig13_HTML.png)
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，合同的各方应该确定合同的条款。合同条款完成后，它们被转换成编程代码，如图[2.13](#Fig13)所示。该代码表示了许多不同的条件语句，描述了未来交易可能发生的各种场景 [[11](#CR11)]。![](../images/516136_1_En_2_Chapter/516136_1_En_2_Fig13_HTML.png)
- en: An illustration depicts how the text-based normal contract is converted to the
    code-based smart contract.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 插图描述如何将基于文本的正常合同转换为基于代码的智能合同。
- en: Fig. 2.13
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.13
- en: Step 1\. Transfer contract terms into code
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步. 将合同条款转换成代码
- en: When the code has been created, it is stored in the blockchain network and is
    replicated among the participants in the blockchain as shown in Fig. [2.14](#Fig14).![](../images/516136_1_En_2_Chapter/516136_1_En_2_Fig14_HTML.png)
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 当代码已经被创建时，它被存储在区块链网络中，并且如 图[2.14](#Fig14)所示，在区块链的参与者之间复制。![](../images/516136_1_En_2_Chapter/516136_1_En_2_Fig14_HTML.png)
- en: An illustration depicts how the code stored in the blockchain is copied by all
    participants in their replica. The contract is connected to three network images.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 插图描述了存储在区块链中的代码如何被所有参与者复制到他们的副本中。合同连接到三个网络图像。
- en: Fig. 2.14
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.14
- en: Step 2\. The code is stored in a blockchain and is copied by all participants
    in their replicas
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步. 代码存储在区块链中，并由所有参与者在他们的副本中复制
- en: The code is run and executed by all computers in the network. If a condition
    of the contract is satisfied and this is verified by all participants of the blockchain
    network, then the relevant transaction is executed, as shown in Fig. [2.15](#Fig15).![](../images/516136_1_En_2_Chapter/516136_1_En_2_Fig15_HTML.png)
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码由网络中的所有计算机运行和执行。如果合同的条件被满足，并且这一点被区块链网络的所有参与者验证，那么将执行相关交易，如图[2.15](#Fig15)所示。![](../images/516136_1_En_2_Chapter/516136_1_En_2_Fig15_HTML.png)
- en: An illustration depicts when the term is satisfied, the computer in the network
    verifies its correctness. Three networks, along with contact images, are connected
    by arrows.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 插图描述当条款被满足时，网络中的计算机验证其正确性。三个网络以及联系图像由箭头连接。
- en: Fig. 2.15
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.15
- en: Step 3\. When a term is satisfied, computers in the network verify its correctness
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 第三步. 当一个条款被满足时，网络中的计算机验证其正确性
- en: For example, suppose that a user is going to rent an apartment from a landlord.
    The user can do this via blockchain by paying in cryptocurrency. The user gets
    a receipt which is held in our virtual contract. The landlord gives the user a
    digital entry key which arrives to the user by a specified date. If the key doesn’t
    arrive on time, then the smart contract can be programmed to release a refund.
    If the landlord sends the key before the rental date, the smart contract can be
    programmed to release both the fee to the landlord and the key to the user when
    the date arrives. The system can work as a collection of If-Then operators. The
    operation is observed by hundreds of people on the blockchain network. Therefore,
    all participants can expect delivery without fault. If the landlord gives the
    user a key, the landlord must be paid. If the user sends a certain amount in Bitcoins,
    then the user receives the key. The smart contract can be programmed to be cancelled
    automatically after the deadline passes. The contract code cannot be interfered
    with either by the user of by the landlord without the knowledge of other network
    nodes, since all participants in the blockchain are alerted simultaneously.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设一个用户打算从一个房东那里租一套公寓。用户可以通过区块链支付加密货币来完成这一过程。用户会收到一份收据，这份收据保存在我们的虚拟合约中。房东会给用户一个数字化的入门钥匙，钥匙会在指定日期前发送给用户。如果钥匙没有按时到达，智能合约可以被编程为退款。如果房东在租赁日期前发送钥匙，智能合约可以在日期到达时同时释放费用给房东和钥匙给用户。该系统可以作为一系列If-Then操作符的集合来运行。操作会被区块链网络上的数百人观察到。因此，所有参与者都可以期待无误的交货。如果房东给用户钥匙，房东必须得到支付。如果用户发送一定数量的比特币，那么用户就会收到钥匙。智能合约可以被编程在截止日期过后自动取消。由于区块链上的所有参与者在同一时间收到警报，因此房东或用户无法在未经其他网络节点知情的情况下干扰合约代码。
- en: There are four basics steps in the smart contract process.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约过程中有四个基本步骤。
- en: '**Coded Agreement**. Blockchain uses layers of computer coding in lieu of traditional
    paper documentation. The lines of code represent the terms of the contract and
    dictate how it will take place. This process guarantees a specific outcome dependant
    on pre-programmed conditions. Subsequently, no individual or organisation can
    change or manipulate the contract.'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编码协议**。区块链使用计算机代码层代替传统的纸质文件。代码行代表合同条款并指示如何执行。这个过程保证了根据预编程条件特定结果的产生。随后，任何个人或组织都无法更改或操纵合同。'
- en: '**Events**. An event refers to a transaction taking place. Once the terms and
    conditions of an agreement have been met, the code automatically executes the
    smart contract. Smart contracts are executed by the blockchain nodes.'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件**。事件指的是交易的发生。一旦满足了协议的条款和条件，代码就会自动执行智能合约。智能合约是由区块链节点执行的。'
- en: '**Value Exchange**. Following the execution of the smart contract, there is
    an exchange of value. The ‘value’ is pre-determined and dependant on the use.
    This process is also automated with no human intervention necessary.'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**价值交换**。在智能合约执行后，将进行价值交换。所谓的“价值”是预先确定的，并取决于使用情况。这个过程也是自动化的，无需人工干预。'
- en: '**Settlement**. Once the transaction or exchange has taken place, the record
    is stored on the blockchain. Due to the nature of blockchain, the transaction
    is communicated to all nodes on the peer to peer network. Therefore, the information
    cannot be tampered with or falsified.'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结算**。一旦交易或交换完成，记录就会被存储在区块链上。由于区块链的特性，交易会被传播到对等网络上的所有节点。因此，信息无法被篡改或伪造。'
- en: Next, we illustrate the smart contract process with the example of a vending
    machine. The vending machine contains a variety of pre-selected products and a
    source of input for money. Operating on an algorithm, the machine is coded so
    that it will automatically produce an outcome based on a pre-programmed set of
    rules. When money is deposited and a selection is made, an item is released. For
    example, suppose that Larry inserts $1.50 into the vending machine. He selects
    B4 on the keypad, which is the number representation for a specific can of soft
    drink. The machine checks that the $1.50 matches the price of the can of soft
    drink and releases the item.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们用自动售货机为例说明智能合约的过程。自动售货机内有许多预选的产品和货币输入源。基于算法运行，机器被编码为根据预先编程的一组规则自动产生结果。当投入货币并做出选择时，会释放一个物品。例如，假设拉里向售货机投入了1.50美元。他在键盘上选择了B4，这是特定软饮料的数字表示。机器检查1.50美元是否与软饮料的价格相匹配并释放该物品。
- en: As long as the pre-specified terms are met, the contractual obligations between
    the user and the machine are fulfilled and the required operation follows.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 只要满足预先指定的条件，用户与机器之间的合同义务得到履行，所需的操作随之进行。
- en: 2.3.3 How to Write a Smart Contract?
  id: totrans-325
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.3 如何编写智能合约？
- en: A smart contract is a program that runs at an address on Ethereum. These programs
    comprise data and functions that can execute upon receiving a transaction. Here’s
    an overview of smart contract ingredients.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约是在以太坊上的地址上运行的程序。这些程序由数据和函数组成，可以在接收到交易时执行。以下是智能合约的组成部分概述。
- en: 2.3.3.1 Data
  id: totrans-327
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.3.1 数据
- en: 'The contract data must be assigned to a location: either to storage or memory.
    It’s costly to modify storage in a smart contract so you need to consider where
    your data should live.'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 合约数据必须分配给一个位置：要么是存储，要么是内存。在智能合约中修改存储的成本很高，所以你需要考虑你的数据应该存放在哪里。
- en: 2.3.3.2 Storage
  id: totrans-329
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.3.2 存储
- en: '*Persistent data* in a contract is referred to as *storage* and is represented
    by state variables. These values are stored permanently on the blockchain ledger.
    The users need to declare the type of variables so that the contract can determine
    how much storage on the blockchain ledger is required for each of the state variables
    during the compilation of the contract.![](../images/516136_1_En_2_Chapter/516136_1_En_2_Figq_HTML.png)'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在合约中的*持久数据*被称为*存储*，由状态变量表示。这些值永久存储在区块链账本上。用户需要声明变量的类型，以便在编译合约时，合约可以确定每个状态变量在区块链账本上所需的存储空间。![](../images/516136_1_En_2_Chapter/516136_1_En_2_Figq_HTML.png)
- en: Solidity example contract Simple Storage unit stored Data State variable
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: Solidity示例合约Simple Storage单元存储Data状态变量
- en: 'An address type can hold an Ethereum address which is equal to 20 bytes or
    160 bits. In hexadecimal notation its value begins with a leading 0x. Other types
    include:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 地址类型可以包含以太坊地址，等于20个字节或160位。在十六进制表示法中，其值以引导的0x开头。其他类型包括：
- en: boolean
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔值
- en: integer
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整数
- en: fixed point numbers
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 固定小数点数
- en: fixed-size byte arrays
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 固定大小的字节数组
- en: dynamically-sized byte arrays
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态大小的字节数组
- en: Rational and integer literals
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理性数和整数字面量
- en: String literals
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串字面量
- en: Hexadecimal literals
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 十六进制字面量
- en: Enums
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 枚举
- en: 2.3.3.3 Memory
  id: totrans-342
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.3.3 内存
- en: Values that are only stored for the duration of a contract function’s execution
    are called *memory variables*. They are not stored permanently on the blockchain
    and are much cheaper to use.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 仅在合约函数执行期间存储的值称为*内存变量*。它们不会永久存储在区块链上，使用起来要便宜得多。
- en: 2.3.3.4 Environment Variables
  id: totrans-344
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.3.4 环境变量
- en: In addition to the variables defined in a contract, there also exist special
    global variables. They are mainly used to provide information about the blockchain
    or current transaction.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在合约中定义的变量外，还存在特殊的全局变量。它们主要用于提供关于区块链或当前交易的信息。
- en: '| Prop | State variable | Description |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 状态变量 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| block.timestamp | uint256 | Current block epoch timestamp |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '| block.timestamp | uint256 | 当前区块的时间戳 |'
- en: '| msg.sender | address | Sender of the message (current call) |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '| msg.sender | 地址 | 消息发送者（当前调用） |'
- en: 2.3.3.5 Functions
  id: totrans-350
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.3.5 函数
- en: Functions can get information or set information in response to incoming transactions.
    There are two types of function calls.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以获取信息或设置信息以响应传入的交易。有两种类型的函数调用。
- en: internal—these don’t create an EVM call
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: internal—这些不会创建EVM调用
- en: Internal functions and state variables can only be accessed internally (i.e.
    from within the current contract or contracts deriving from it.)
  id: totrans-353
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内部函数和状态变量只能内部访问（即在当前合约或派生自它的合约内访问）。
- en: external—these do create an EVM call
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部—这些会创建 EVM 调用
- en: External functions are part of the contract interface, which means they can
    be called from other contracts and via transactions. An external function f cannot
    be called internally (i.e. f() does not work, but this.f() works).
  id: totrans-355
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部函数是合约接口的一部分，这意味着它们可以从其他合约和交易中调用。外部函数 f 不能内部调用（即 f() 不工作，但 this.f() 工作）。
- en: Functions can also be classified as public or private.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 函数也可以被分类为公共或私有。
- en: public functions can be called internally from within the contract or externally
    via messages.
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公共函数可以通过消息在合约内部或外部调用。
- en: private functions are only visible for the contract they are defined in and
    not in derived contracts.
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 私有函数仅对定义它们的合约可见，而在派生合约中不可见。
- en: Both functions and state variables can be made public or private.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 函数和状态变量都可以设置为公共或私有。
- en: Here’s a function for updating a state variable on a contract.![](../images/516136_1_En_2_Chapter/516136_1_En_2_Figr_HTML.png)
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个用于在合约上更新状态变量的函数。![](../images/516136_1_En_2_Chapter/516136_1_En_2_Figr_HTML.png)
- en: Solidity example function update name( string value )public dapp name equals
    to value
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: Solidity 示例函数 updateName(string value)public dapp name等于value
- en: 'The parameter value of type string is passed into the function: update_name.'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型为字符串的参数值传递给函数：update_name。
- en: It’s declared public, meaning anyone can access it.
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它被声明为公共的，意味着任何人都可以访问它。
- en: It’s not declared view, so it can modify the contract state.
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它没有被声明为视图，所以它可以修改合约状态。
- en: '**View functions**: view functions promise not to modify the state of the contract’s
    data. Common examples are the “getter” functions. For example, you can use the
    following function to receive the balance of a user.![](../images/516136_1_En_2_Chapter/516136_1_En_2_Figs_HTML.png)'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '**视图函数**：视图函数承诺不修改合约数据的状态。常见的例子是“获取器”函数。例如，您可以使用以下函数来接收用户的余额。![](../images/516136_1_En_2_Chapter/516136_1_En_2_Figs_HTML.png)'
- en: Solidity example function balance Of ( address owner )public view returns( unit
    256 balance ) return owner Pizza Count [owner]
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: Solidity 示例函数 balanceOf(address owner)public view returns(uint256 balance) return
    owner Pizza Count [owner]
- en: 'Here is a list of events regarded as modifications of state:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一份被视为状态修改的事件列表：
- en: '1.'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '1.'
- en: writing to state variables,
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 写入状态变量，
- en: '2.'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '2.'
- en: emitting events,
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 发射事件，
- en: '3.'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '3.'
- en: creating other contracts,
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 创建其他合约，
- en: '4.'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '4.'
- en: using selfdestruct,
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用 selfdestruct，
- en: '5.'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '5.'
- en: sending Ether via calls,
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过调用发送以太币，
- en: '6.'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '6.'
- en: calling any function not marked view or pure,
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 调用任何未标记为 view 或 pure 的函数，
- en: '7.'
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '7.'
- en: using low-level calls,
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用低级调用，
- en: '8.'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '8.'
- en: using inline assembly that contains certain opcodes.
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用包含某些操作码的内联汇编。
- en: '**Constructor functions** are only executed once when the contract is first
    deployed. Like a constructor in many class-based programming languages, these
    functions often initialize state variables to their specified values.![](../images/516136_1_En_2_Chapter/516136_1_En_2_Figt_HTML.png)'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '**构造函数** 在合约首次部署时只执行一次。与许多基于类的编程语言中的构造函数类似，这些函数通常将状态变量初始化为它们的指定值。![](../images/516136_1_En_2_Chapter/516136_1_En_2_Figt_HTML.png)'
- en: An algorithm
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 一个算法
- en: '**Built-in functions**. In addition to the variables and functions you define
    on your contract, there are some special built-in functions. The most obvious
    example is: address.send() in Solidity, which allows contracts to send ETH to
    other accounts.'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '**内置函数**。除了在您的合约上定义的变量和函数外，还有一些特殊的内置函数。最明显的例子是在 Solidity 中：address.send()，它允许合约将
    ETH 发送到其他账户。'
- en: '**A smart contract with line-by-line explanations**. A programming language
    is required to write smart contracts. Ethereum core contributors invented a programming
    language called Solidity to write smart contracts, which can be regarded as computer
    programs running on the blockchain. Solidity is a high-level object-oriented language
    inspired by JavaScript, C++, and Python. Solidity’s syntax is quite similar to
    JavaScript. There are other blockchains and Ethereum forks that support Solidity.
    An example of such blockchains is Tron. Solidity is not the only language that
    programmers can use to write smart contracts, but at present it is the most popular
    one.'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '**带有逐行解释的智能合约**。编写智能合约需要一种编程语言。以太坊核心贡献者发明了一种名为Solidity的编程语言来编写智能合约，可以将其视为在区块链上运行的计算机程序。Solidity是一种高级面向对象的编程语言，灵感来自JavaScript、C++和Python。Solidity的语法与JavaScript非常相似。还有其他区块链和以太坊分叉支持Solidity。此类区块链的一个示例是Tron。程序员不仅可以使用Solidity编写智能合约，但现在它是最受欢迎的一种。'
- en: To write a smart contract function, the following information concerning the
    function has to be specified
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写智能合约函数，需要指定与函数相关的以下信息
- en: parameter variables and their type, if the function accepts parameters,
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数变量及其类型，如果函数接受参数，
- en: declaration of internal/external variables,
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内部/外部变量的声明，
- en: declaration of pure/view/payable,
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纯/视图/可支付的声明，
- en: returns type, if the function returns a value.
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果函数返回一个值，返回类型，
- en: A simple example of Solidity smart contract is presented below.![](../images/516136_1_En_2_Chapter/516136_1_En_2_Figu_HTML.png)
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个solidity智能合约的简单示例！[](../images/516136_1_En_2_Chapter/516136_1_En_2_Figu_HTML.png)
- en: An algorithm
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 算法
- en: The code above is a smart contract written in Solidity language. Next, we describe
    the action of each line of the code in this example of a smart contract.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码是一个用Solidity语言编写的智能合约。接下来，我们将描述这个智能合约示例中每行代码的动作。
- en: Line 1 declares which version of the Solidity compiler can be used to compile
    the contract. In our example, any version between ![$$\ge $$](../images/516136_1_En_2_Chapter/516136_1_En_2_Chapter_TeX_IEq7.png)0.4.0
    and ![$$\le $$](../images/516136_1_En_2_Chapter/516136_1_En_2_Chapter_TeX_IEq8.png)0.7.0
    is suitable.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行声明了可以用来编译合约的Solidity编译器的版本。在我们的示例中，任何介于![$$\ge $$](../images/516136_1_En_2_Chapter/516136_1_En_2_Chapter_TeX_IEq7.png)0.4.0和![$$\le
    $$](../images/516136_1_En_2_Chapter/516136_1_En_2_Chapter_TeX_IEq8.png)0.7.0之间的版本都是合适的。
- en: Line 2 declares the contract and names it as inventoryInfo. It is a normal practice
    to use the same filename as the contract name. For example, this contract will
    be saved in a file inventoryInfo.sol (.sol is the file extension for solidity
    smart contracts).
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行声明了合约，并将其命名为inventoryInfo。通常做法是使用与合约名称相同的文件名。例如，这个合约将保存在一个名为inventoryInfo.sol的文件中（.sol是solidity智能合约的文件扩展名）。
- en: Line 3 declares a uint (unsigned integer) variable named numberInStock. This
    variable is used to store data.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 第三行声明了一个名为numberInStock的uint（无符号整数）变量。这个变量用于存储数据。
- en: Lines 4–6 add a set function, using which the value of variable numberInStock
    can be changed. Here the set function accepts a parameter *x* and stores its value
    in numberInStock. The function is marked as public, which means that it can be
    invoked by anyone.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 第4至6行添加了一个设置函数，使用该函数可以更改变量numberInStock的值。在此，设置函数接受一个参数*x*，并将其值存储在numberInStock中。该函数被标记为public，这意味着任何人都可以调用它。
- en: Lines 7–9 add a get function to retrieve the value of numberInStock. This function
    is marked as a view function, which tells Solidity compiler that this is a read-only
    function. The get function also has uint returns, which means that the function
    will return a uint.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 第7至9行添加了一个获取函数，用于检索numberInStock的值。这个函数被标记为视图函数，告诉solidity编译器这是一个只读函数。获取函数还有uint返回类型，这意味着函数将返回一个uint。
- en: 2.3.4 What Is a Decentralized Application (DApp)?
  id: totrans-401
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.4 去中心化应用（DApp）是什么？
- en: A decentralized application (dapp) is an application built on a decentralized
    network. Dapps combine smart contracts and frontend user interfaces. Ethereum
    smart contracts are accessible and transparent like open application programming
    interfaces. Therefore, dapps can include smart contracts written by other programmers
    too. Every dapp has its backend code running on a decentralized peer-to-peer network.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 去中心化应用（dapp）是建立在去中心化网络上的应用。dapp将智能合约和前端用户界面结合在一起。以太坊智能合约像开放的应用程序编程接口一样可访问和透明。因此，dapp也可以包括其他程序员编写的智能合约。每个dapp都有其后端代码在去中心化的点对点网络上运行。
- en: A dapp can have frontend code and user interfaces written in any language (just
    like an app) to make calls to its backend. Furthermore, its frontend can be hosted
    on decentralized storage such as IPFS.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 一个DApp可以有使用任何语言编写的前端代码和用户界面（就像一个应用程序一样）来调用其后端。此外，它的前端可以托管在如IPFS的去中心化存储上。
- en: '**Decentralized** dapps operate on Ethereum, an open public decentralized platform
    where no one person or group has control.'
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**去中心化**的DApp运行在以太坊上，这是一个开放的公共去中心化平台，没有人或团体能够掌控。'
- en: '**Deterministic** dapps perform the same function irrespective of the environment
    in which they get executed.'
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**确定性**。无论在何种环境中执行，确定性的DApp都会执行相同的功能。'
- en: '**Turing complete** dapps can perform any action given the required resources.'
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图灵完备**的DApp可以提供所需的资源执行任何动作。'
- en: '**Isolated** dapps are executed in a virtual environment known as Ethereum
    Virtual Machine so that if the smart contract has a bug, it won’t hamper the normal
    functioning of the blockchain network.'
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隔离性**。DApp在称为以太坊虚拟机（EVM）的虚拟环境中执行，这样如果智能合约有漏洞，它不会阻碍区块链网络的正常运行。'
- en: 2.3.4.1 Benefits of DApp Development
  id: totrans-408
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.4.1 DApp开发的优点
- en: '**Zero downtime**. Once the smart contract is deployed on the blockchain, the
    network as a whole will always be able to serve clients looking to interact with
    the contract. Malicious actors, therefore, cannot launch denial-of-service attacks
    targeted towards individual dapps.'
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**零停机时间**。一旦智能合约部署在区块链上，整个网络总能服务于希望与合约互动的客户。因此，恶意行为者无法针对个别DApp发起拒绝服务攻击。'
- en: '**Privacy**. You don’t need to provide real-world identity to deploy or interact
    with a dapp.'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隐私保护**。您无需提供现实世界的身份信息即可部署或与去中心化应用（DApp）互动。'
- en: '**Resistance to censorship**. No single entity on the network can block users
    from submitting transactions, deploying dapps, or reading data from the blockchain.'
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**抵抗审查**。网络上的任何单一实体都无法阻止用户提交交易、部署DApp或从区块链读取数据。'
- en: '**Complete data integrity**. Data stored on the blockchain is immutable and
    indisputable, thanks to cryptographic primitives. Malicious actors cannot forge
    transactions or other data that has already been made public.'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**完全的数据完整性**。存储在区块链上的数据由于加密原语的支持而不可篡改且不容争议。恶意行为者无法伪造已经公开的交易或其他数据。'
- en: '**Trustless computation/verifiable behaviour**. Smart contracts can be analysed
    and are guaranteed to execute in predictable ways, without the need to trust a
    central authority. This is not true in traditional models; for example, when we
    use online banking systems, we must trust that financial institutions will not
    misuse our financial data, tamper with records, or get hacked.'
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无需信任的计算/可验证行为**。智能合约可以被分析，并保证以可预测的方式执行，无需信任中央权威。这在传统模型中是不成立的；例如，当我们使用在线银行系统时，我们必须信任金融机构不会误用我们的财务数据、篡改记录或遭受黑客攻击。'
- en: 2.3.4.2 Drawbacks of DApp Development
  id: totrans-414
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.4.2 DApp开发的缺点
- en: '**Maintenance**. DApps can be harder to maintain because the code and data
    published to the blockchain ledger are harder to modify. It is difficult for developers
    to make updates to their dapps or to the underlying data stored by their dapps
    after they are deployed, even if bugs or security risks are identified in a previous
    version.'
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**维护**。DApp的维护可能更加困难，因为发布到区块链账本上的代码和数据更难以修改。即使在新版本中发现漏洞或安全风险，开发者也很难对其DApp或其DApp存储的基础数据进行更新。'
- en: '**Performance overhead**. There is a huge performance overhead and scaling
    up is really difficult. To achieve the level of security, integrity, transparency,
    and reliability that Ethereum aspires to, every node runs and stores every transaction.
    On top of this, proof-of-work takes time as well. Therefore, many dapp calculations
    impose an overhead of approximately ![$$10^6\times $$](../images/516136_1_En_2_Chapter/516136_1_En_2_Chapter_TeX_IEq9.png)
    that of a standard computation in ordinary apps.'
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能开销**。存在巨大的性能开销，并且扩展非常困难。为了达到以太坊所追求的安全性、完整性、透明性和可靠性，每个节点都运行并存储每一笔交易。此外，工作量证明也需要时间。因此，许多DApp计算的开销大约是普通应用程序标准计算的![$$10^6\times
    $$](../images/516136_1_En_2_Chapter/516136_1_En_2_Chapter_TeX_IEq9.png)。'
- en: '**Network congestion**. When one dapp uses too many computational resources,
    the entire network gets backed up. Currently, the network can only process about
    10–15 transactions per second; if transactions are being sent in faster than this,
    the pool of unconfirmed transactions can quickly balloon.'
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络拥堵**。当一个dapp使用过多的计算资源时，整个网络都会出现拥堵。目前，网络每秒只能处理大约10-15笔交易；如果交易发送速度超过这个限制，未确认交易池会迅速膨胀。'
- en: '**User experience**. It may be harder to engineer user-friendly experiences
    because the average end-user might find it too difficult to set up a tool stack
    necessary to interact with the blockchain in a truly secure fashion.'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户体验**。由于普通最终用户可能发现设置与区块链安全互动所需的工具堆栈过于困难，因此可能更难工程化用户友好的体验。'
- en: '**Centralization**. User-friendly and developer-friendly solutions built on
    top of the base layer of Ethereum might end up looking like centralized services
    anyway. For example, such services may store keys or other sensitive information
    server-side, serve a frontend using a centralized server, or run important business
    logic on a centralized server before writing to the blockchain. The resulting
    centralization can eliminate many if not all of the advantages of blockchain over
    traditional models.'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**中心化**。建立在以太坊基础层之上的用户友好和开发者友好的解决方案可能会最终看起来像中心化服务。例如，这类服务可能会在服务器端存储密钥或其他敏感信息，使用中心化服务器提供前端，或在向区块链写入数据之前在中心化服务器上运行重要的业务逻辑。这种中心化可能会消除区块链相对于传统模型的许多甚至所有优势。'
- en: 2.3.5 Limitations and Future Developments
  id: totrans-420
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.5 局限性和未来发展趋势
- en: 'Smart contracts do not perfectly solve all problems of the conventional contracts.
    In particular, they cannot retrieve current information from outside of the blockchain
    ledger. Therefore, the users might encounter problems when certain information
    is necessary during the process of verifying whether smart contract conditions
    are met. For example, suppose that there is a contract with the following condition:
    “If the price of ETH rises above $1000, A provides B with 1 ETH.” Here, the smart
    contract only functions if the information on whether the price of Ethereum is
    over $1000 or is below. Therefore, the contract is only executable when the cryptocurrency
    exchange’s accurate Ethereum price data is retrieved, which lies outside the blockchain
    ledger.'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约并不能完美解决传统合同的所有问题。特别是，它们无法从区块链账本外部获取当前信息。因此，用户在验证智能合约条件是否满足的过程中可能遇到问题。例如，假设有一个以下条件的合同：“如果ETH的价格超过1000美元，A向B提供1
    ETH。”在这里，智能合约只有在以太坊价格超过1000美元或低于1000美元的信息可用时才能运行。因此，只有在从加密货币交易所获取准确的以太坊价格数据时，合同才能执行，而这份数据位于区块链账本外部。
- en: During the retrieval process, wrong data may be retrieved or the data may be
    intentionally altered. In other words, specific information about a specific condition
    needs to be retrieved, and if this information is dependent on a third party,
    this inevitably leads to a credibility issue. To resolve this inherent issue,
    many start-ups are striving to provide accurate information necessary for generating
    and executing smart contracts.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 在检索过程中，可能会检索到错误的数据，或者数据可能被故意篡改。换句话说，需要检索有关特定条件的特定信息，如果这份信息依赖于第三方，这不可避免地导致信誉问题。为了解决这一固有问题，许多初创公司正在努力提供生成和执行智能合约所需的准确信息。
- en: Another inherent limitation of smart contracts is that they are not editable
    once they have been distributed. On the one hand, it is this rigidity that makes
    the smart contracts safe and reliable. On the other hand, this can turn into a
    potential weakness that can be exploited. There have been cases where smart contracts
    have been hacked or become permanently dysfunctional because of this characteristic,
    the most prominent case being SmartMesh. The smart contract distributed by the
    SmartMesh team contained a security flaw, and the hacker used it to issue/sell
    additional tokens. Also, there was a case where the security flaw resulted in
    513.774.16ETH contained in wallets became permanently non-withdrawable.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约的另一个固有限制是，一旦部署，它们就无法编辑。一方面，这种僵化正是使智能合约安全可靠的原因。另一方面，这也可能变成可以被利用的潜在弱点。有案例中，智能合约因为这一特性被黑客攻击或永久性功能失效，最突出的案例是SmartMesh。SmartMesh团队分发的智能合约包含一个安全漏洞，黑客利用它发行/出售额外的代币。还有案例中，由于这个安全漏洞，包含在钱包中的513.774.16ETH变得永久无法提取。
- en: Smart contracts handle digital currencies directly. Therefore, safety is paramount
    when developing smart contracts. In the blockchain industry, it is becoming a
    standard procedure to conduct a security audit before distribution. Special security
    audits may need to be carried out in order to ensure security guarantees provided
    by the smart contracts.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约直接处理数字货币。因此，在开发智能合约时，安全性是首要考虑的。在区块链行业中，分发前进行安全审计已成为一项标准程序。可能需要进行特殊的网络安全审计，以确保智能合约提供的安全保证。
- en: The potential of smart contracts extends beyond the simple transfers of cryptocurrencies,
    since smart contracts are much more complex. They can execute transactions in
    a wide range of fields, from legal processes to insurance premiums to crowdfunding
    agreements to financial derivatives. Smart contracts have the potential to disintermediate
    the legal and financial fields by simplifying and automating routine and repetitive
    processes for which people currently pay banks and lawyers sizable fees.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约的潜力远不止于加密货币的简单转移，因为智能合约要复杂得多。它们可以在广泛领域执行交易，从法律程序到保险费到众筹协议，再到金融衍生品。智能合约有可能通过简化并自动化目前人们支付银行和律师巨额费用处理的常规和重复性流程，中介法律和金融领域。
- en: The role of lawyers could also be adapted in the future as smart contracts gain
    extensive capabilities and can contribute to the functioning of traditional legal
    agreements and customizable smart contract templates. In addition, smart contracts’
    ability not only to automate processes, but also to control behaviour, as well
    as their potential for real-time auditing and risk assessments, can be beneficial
    for compliance.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 随着智能合约获得广泛的能力，律师的角色也可能会在未来得到调整，他们可以贡献于传统法律协议和可定制的智能合约模板的功能。此外，智能合约不仅能自动化流程，还能控制行为，以及它们实时审计和风险评估的潜力，对合规性有益。
- en: Smart contracts also show promise in automating processes that run on IoT and
    edge computing devices. For example, a utility company might offer a service in
    which smart contracts execute in response to changes in power rates in coordination
    with devices built into power meters. For example, when prices reach a given threshold,
    a smart contract might automatically turn off or turn down power-hungry appliances
    such as air conditioners using a specially controlled IoT controller.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 智能合约在自动化物联网和边缘计算设备上运行的流程也显示出潜力。例如，一家公用事业公司可能会提供一项服务，智能合约根据电价的变化与内置在电表中的设备协同执行。例如，当价格达到某个阈值时，智能合约可能会自动关闭或降低空调等耗电设备的电力，使用专门的物联网控制器进行控制。
- en: It may be also possible to integrate smart contracts into vending machines that
    could release goods in response to cryptocurrency payments.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 将来也有可能将智能合约集成到能够响应加密货币支付释放商品的自动售货机中。
- en: In a supply chain scenario, smart contracts might unlock funds once a cargo
    container has arrived at its destination and IoT sensors indicate that it has
    remained unopened and the contents have been kept at the right temperature and
    appropriate humidity.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 在供应链场景中，智能合约可能在货物集装箱到达目的地并且物联网传感器表明它保持未开启状态，以及内容保持正确的温度和适当的湿度时解锁资金。
- en: 2.4 Blockchain Types
  id: totrans-430
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.4 区块链类型
- en: There exist various and sometimes conflicting categorisations of blockchain
    types. This section concentrates on the classification of blockchain systems according
    to their type of authorisation required for the network nodes acting as verifiers.
    Blockchain systems can be divided into three main categories represented in Fig. [2.16](#Fig16).![](../images/516136_1_En_2_Chapter/516136_1_En_2_Fig16_HTML.png)
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 存在对区块链类型进行各种分类，有时这些分类是冲突的。本节重点介绍根据网络节点作为验证者所需的授权类型对区块链系统进行分类。区块链系统可以分为三大类，如图
    [2.16](#Fig16) 所示。![](../images/516136_1_En_2_Chapter/516136_1_En_2_Fig16_HTML.png)
- en: A Venn diagram has public in circle one, and private and consortium in circle
    two. The intersection has Hybrid. The first circle is titled permissionless and
    the second one as permissioned.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 一个维恩图将公共置于第一圈，私有和联盟置于第二圈。交集处是混合型。第一圈标题为无需许可，第二圈为需要许可。
- en: Fig. 2.16
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.16
- en: Three main blockchain types
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 三种主要的区块链类型
- en: '**Permissionless blockchains**, where anyone can participate in the verification
    process, i.e., no prior authorisation is required. All users can participate in
    the consensus procedure, for example, by contributing their computational resources,
    usually in return for a monetary reward.'
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无许可区块链**，任何人都可以参与验证过程，也就是说，不需要事先授权。所有用户都可以参与共识过程，例如，通过贡献他们的计算资源，通常会得到货币奖励。'
- en: '**Permissioned blockchains**, where verification nodes are preselected by a
    central authority or consortium.'
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**许可区块链**，验证节点由中心机构或联盟预先选择。'
- en: '**Hybrid blockchains**, which combine certain features of permissionless and
    permissioned blockchains.'
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**混合区块链**，结合了无许可和许可区块链的某些特性。'
- en: In reality, most permissionless blockchains offer facilities for a public access,
    while the intention of most permissioned blockchains is to restrict data access
    to the company or consortium of companies operating the blockchain. For this reason,
    next we look at the major categories of blockchains, permissioned and permissionless
    blockchains, and elaborate on the distinctions between them in the following sections.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，大多数无许可区块链提供了公共访问设施，而大多数许可区块链的意图是将数据访问限制在运行区块链的公司或公司联盟内。为此原因，接下来我们将查看区块链的主要类别，无许可和许可区块链，并在以下章节中详细阐述它们之间的区别。
- en: 2.4.1 Permissionless Blockchains
  id: totrans-439
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.1 无许可区块链
- en: The original instance of a cryptocurrency, the Bitcoin network, achieved high
    popularity by using a permissionless blockchain. The word ‘permission’ refers
    to the authorisation of nodes for verification. In a permissionless blockchain,
    everyone is permitted to join the network to be a verifier without obtaining any
    prior permission for performing such network tasks. The actions of verifiers are
    vitally important to the operation of the network, and so their participation
    is encouraged by issuing new currency which is paid to their accounts when the
    verifiers complete their confirmation of blocks with transactions.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 加密货币的原始实例，比特币网络，通过使用无许可区块链实现了高度流行。"许可"这个词指的是节点的授权验证。在无许可的区块链中，每个人都被允许加入网络成为验证者，而无需为执行此类网络任务获得任何事先的许可。验证者的行为对网络的运行至关重要，因此，通过发行新货币并将其支付给验证者完成交易块的确认来鼓励他们的参与。
- en: The advantage of a permissionless blockchain [[29](#CR29)] is that it can accommodate
    anonymous or pseudonymous actors and protect against a Sybil (i.e., identity-forging)
    attack [[13](#CR13)]. On the other hand, the incentive mechanism has to be carefully
    developed in order to ensure that verifiers are properly stimulated to participate
    in the work of the system. For example, in Bitcoin the verifiers receive an amount
    for verifying each transaction, as well as for publishing a block of transactions.
    However, the latter incentive is two orders of magnitude higher than the former
    reward. Since the incentive for publishing transactions of blocks decreases according
    to a predefined schedule, it follows that the verifiers after a period of time
    have to increase the amount they charge for processing individual transactions.
    This makes the Bitcoin transactions more costly.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 无许可区块链的优势[[29](#CR29)]在于它可以容纳匿名或伪匿名参与者，并保护免受Sybil（即身份伪造）攻击[[13](#CR13)]。另一方面，必须仔细开发激励机制，以确保验证者被适当地激励参与系统的工作。例如，在比特币中，验证者会收到一笔费用用于验证每笔交易，以及发布一个交易块。然而，后者的激励比前者奖励高两个数量级。由于发布交易块的激励根据预定义的计划减少，因此可以推断，经过一段时间后，验证者必须提高他们为处理个别交易收取的费用。这使得比特币交易更加昂贵。
- en: In addition to Bitcoin, there are many other examples of permissionless blockchains
    including Ethereum. The Ethereum platform offers blockchain as a service and provides
    access to smart contracts on its blockchain. Other examples of permissionless
    blockchains are presented in [[3](#CR3), [7](#CR7), [22](#CR22)]. Novel results
    on permissionless blockchains have also appeared, for instance, in [[17](#CR17)–[19](#CR19)].
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 除了比特币，还有很多其他无许可区块链的例子，包括以太坊。以太坊平台提供区块链即服务，并为其区块链提供对智能合约的访问。其他无许可区块链的例子在[[3](#CR3),
    [7](#CR7), [22](#CR22)]中提出。关于无许可区块链的新结果也出现了，例如在[[17](#CR17)–[19](#CR19)]中。
- en: 2.4.2 Permissioned Blockchains
  id: totrans-443
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.2 许可区块链
- en: Even though permissionless blockchains are highly popular, they are not the
    only possible configuration for a blockchain system. Permissioned blockchains
    engage a set of trusted parties to carry out verification. Additional verifiers
    can be added only after their approval based on the agreement of the current members
    or a central authority. This configuration with centralised permissions is more
    similar to a traditional finance setting, which operates a Know Your Business
    (KYB) or Know Your Client (KYC) procedure to whitelist users that are allowed
    to undertake operations in a particular space. The paper [[29](#CR29)] explains
    that permissionless and permissioned blockchains are fundamentally different in
    both their operation and the range of activities that they enable. Next, we review
    their major differences.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管非许可区块链非常流行，但它们并不是区块链系统可能配置的唯一选项。许可区块链让一组可信的各方执行验证工作。只有在现有成员或中央权威的同意下，基于协议才能添加额外的验证者。这种具有集中权限的配置与传统金融设置更为相似，后者运行了解你的业务（KYB）或了解你的客户（KYC）程序，以将允许在特定空间进行操作的用户列入白名单。论文[[29](#CR29)]解释了非许可和许可区块链在操作和它们所启用的活动范围上根本不同。接下来，我们回顾它们的主要区别。
- en: Permissioned blockchains are intended to be built for specific purposes. They
    can be created to maintain compatibility with already existing applications, for
    example, financial applications. Permissioned blockchains can be fully *private*,
    where permissions to write data belong to the owner or the managing organisation.
    Alternatively, they can be consortium blockchains, where the consensus process
    is controlled by a pre-selected set of nodes in a consortium.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 许可区块链旨在为特定目的而建立。它们可以创建以与现有应用程序保持兼容，例如，财务应用程序。许可区块链可以是完全私有的，写入数据的权限属于所有者或管理组织。或者，它们可以是联盟链，共识过程由联盟中预选的一组节点控制。
- en: Since all the acting nodes in a permissioned blockchain are pre-approved and
    are known, it is natural to expect that they are personally accountable for their
    activity and behaviour on the network. As far as the transactions handled by these
    blockchains are concerned, usually they mainly deal with off-chain assets such
    as digital representations of securities, fiat currencies and titles of ownership,
    rather than on-chain assets, such as virtual currency tokens [[29](#CR29)].
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 由于许可区块链中的所有行动节点都是预先批准并知的，自然可以期待他们对网络上的活动和行为个人承担责任。就这些区块链处理的交易而言，通常它们主要处理链下资产，如证券的数字表示、法定货币和所有权证明，而不是链上资产，如虚拟货币代币[[29](#CR29)]。
- en: An advantage of a permissioned blockchain is its scalability. In a permissionless
    blockchain, the data is stored on every computer in the network, and all nodes
    verify all transactions. It is obvious that once the number of transactions increases
    substantially, the ability of the users to perform this type of processing and
    verification decreases. This may lead to a higher degree of centralisation, since
    the verification process becomes more challenging. In a permissioned blockchain,
    only a smaller number of preselected participants need to function as verifiers.
    Even in the case where the verifiers are chosen in a large institution, they can
    upgrade their computing power to comply with the increasing requirements that
    depend on in the number of transactions.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 许可区块链的一个优势是其可扩展性。在非许可区块链中，数据存储在网络中的每一台计算机上，所有节点都要验证所有交易。很明显，一旦交易数量显著增加，用户进行这种处理和验证的能力就会下降。这可能导致更高的集中度，因为验证过程变得更加困难。在许可区块链中，只有少量预先选定的参与者需要充当验证者。即使验证者在大型机构中选出，他们也可以升级计算能力以满足随着交易数量增加而增加的要求。
- en: In a permissioned blockchain, the number of potential verifiers and possible
    participants is smaller. Therefore, it is much easier for a group of the users
    to collaborate and alter the rules or revert transactions as required. In addition,
    it is easy for them to reject transactions. This means that permissioned blockchains
    cannot resist censorship as well as permissionless blockchains can do.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 在许可区块链中，潜在的验证者和可能参与者数量较少。因此，一组用户更容易协作，根据需要更改规则或撤销交易。此外，他们很容易拒绝交易。这意味着许可区块链不能像非许可区块链那样有效地抵抗审查。
- en: 2.4.2.1 Private Blockchains
  id: totrans-449
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.4.2.1 私有区块链
- en: Private blockchains can also be referred to as managed blockchains. They are
    permissioned blockchains controlled by a single owner or organization. Every private
    blockchain has a central authority determining who is allowed to join as a node.
    The central authority also does not necessarily grant each node equal rights for
    performing the blockchain functions. Private blockchains are only partially decentralized
    because public access to these blockchains is restricted. Examples of private
    blockchains include the business-to-business virtual currency exchange network
    Ripple and Hyperledger, an umbrella project of open-source blockchain applications.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 私有链也可以被称为受管理的链。它们是由单个所有者或组织控制的权限链。每个私有链都有一个中心权威决定谁被允许加入作为一个节点。中心权威也不一定授予每个节点执行区块链功能的平等权利。私有链只是部分去中心化，因为这些链的公共访问是受限的。私有链的例子包括企业对企业虚拟货币交换网络Ripple和Hyperledger，一个开源区块链应用的伞形项目。
- en: The characteristics of private blockchain imply that the owner of the blockchain
    has the highest authority and may have the ability to change information stored
    in the ledger. Private blockchain is applied to more closed networks such as the
    intranet of an organisation. New contributions developing private blockchains
    have appeared, for example, in [[4](#CR4), [5](#CR5), [8](#CR8)].
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 私有链的特点意味着区块链的所有者具有最高的权威，可能有能力更改账本中存储的信息。私有链应用于更封闭的网络，例如一个组织的内部网。开发私有链的新贡献已经出现，例如[[4](#CR4),
    [5](#CR5), [8](#CR8)]。
- en: Both private and public blockchains have their drawbacks. Public blockchains
    tend to have longer validation times for new data items in comparison to private
    blockchains. Private blockchains are more vulnerable to data censorship and potential
    attacks from misbehaving administrative actors. Consortium and hybrid blockchains
    were developed to address these shortcomings.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 私有链和公链都有其缺点。与私有链相比，公链对于新数据项的验证时间更长。私有链更容易受到数据审查和潜在的来自行为不当的管理角色的攻击。联盟链和混合链是为了克服这些缺点而开发的。
- en: 2.4.2.2 Consortium Blockchains
  id: totrans-453
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.4.2.2 联盟链
- en: Consortium blockchains are permissioned blockchains governed by a group of organizations,
    rather than one entity, as in the case of the private blockchains. Therefore,
    consortium blockchains enjoy broader decentralization as compared to private blockchains.
    This results in higher levels of security. However, the process of setting up
    a consortium blockchain can be fraught with difficulties, since it requires the
    cooperation of a number of organizations, which may present logistical challenges
    as well as a potential risk of creating an antitrust.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 联盟链是由一组组织管理的权限链，而不是一个实体，这与私有链的情况不同。因此，与私有链相比，联盟链享有更广泛的去中心化。这导致了更高的安全性。然而，建立联盟链的过程可能充满困难，因为它需要多个组织的合作，这可能带来后勤挑战以及创建反垄断风险的潜在风险。
- en: Further, some members of a consortium blockchain may not possess the required
    technology or infrastructure to implement essential blockchain tools. Other members
    may decide that the upfront costs are too expensive for attempting to digitize
    their data and connect to other members of the blockchain.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，联盟链的一些成员可能没有实施基本区块链工具所需的必要技术或基础设施。其他成员可能决定，试图数字化他们的数据并连接到区块链的其他成员的前期成本过高。
- en: Consortium blockchains can be used, for example, for managing e-learning educational
    records [[2](#CR2)], agricultural supply chains [[15](#CR15)], medical information
    sharing [[14](#CR14)], anonymous handover authentication in wireless networks [[23](#CR23)],
    protected data sharing in health information systems [[27](#CR27)] and General
    Data Protection Regulation compliance data sharing [[26](#CR26)]. New investigations
    of consortium blockchains and their applications have been conducted, for example,
    in [[1](#CR1), [20](#CR20), [21](#CR21)].
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 联盟链可以用于管理电子学习教育记录，例如[[2](#CR2)]，农业供应链[[15](#CR15)]，医疗信息共享[[14](#CR14)]，无线网络中的匿名交接认证[[23](#CR23)]，健康信息系统中的受保护数据共享[[27](#CR27)]以及符合通用数据保护条例的数据共享[[26](#CR26)]。对联盟链及其应用的新研究已经进行，例如[[1](#CR1),
    [20](#CR20), [21](#CR21)]。
- en: 2.4.3 Hybrid Blockchains
  id: totrans-457
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.3 混合链
- en: Hybrid blockchains are blockchains that combine several features of different
    categories of blockchains. They may be controlled by a single organization, but
    with a level of oversight undertaken by a typical public blockchain, which is
    required to perform certain transaction validations. An example of a hybrid blockchain
    is the IBM Food Trust, which was developed to improve the efficiency and throughout
    of a whole food supply chain.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 混合型区块链结合了不同类别区块链的多种特性。它们可能由一个单一组织控制，但同时具有由典型公共区块链承担的监督级别，后者需要执行某些交易验证。混合型区块链的一个例子是IBM食品信任网络，该网络旨在提高整个食品供应链的效率和吞吐量。
- en: Recently, hybrid blockchains have been used, for example, for healthcare monitoring
    and recommendation systems [[28](#CR28)], organising auctions [[9](#CR9)], identity
    management [[6](#CR6)], accountable federated learning [[12](#CR12)], energy applications
    [[16](#CR16)], separation of basic data and business data [[24](#CR24)].
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，混合型区块链已经被用于例如医疗监控和推荐系统[[28](#CR28)]、组织拍卖[[9](#CR9)]、身份管理[[6](#CR6)]、可追溯的联邦学习[[12](#CR12)]、能源应用[[16](#CR16)]、基本数据与业务数据的分离[[24](#CR24)]等领域。
