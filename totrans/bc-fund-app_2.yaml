- en: © The Author(s), under exclusive license to Springer Nature Switzerland AG 2022X.
    Yi et al.Blockchain Foundations and ApplicationsSpringerBriefs in Applied Sciences
    and Technology[https://doi.org/10.1007/978-3-031-09670-9_2](https://doi.org/10.1007/978-3-031-09670-9_2)
  prefs: []
  type: TYPE_NORMAL
- en: 2. Bitcoin, Ethereum, Smart Contracts and Blockchain Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Xun Yi^([1](#Aff6) [ ](#ContactOfAuthor6)), Xuechao Yang^([1](#Aff6) [ ](#ContactOfAuthor7)),
    Andrei Kelarev^([1](#Aff6) [ ](#ContactOfAuthor8)), Kwok Yan Lam^([2](#Aff7) [ ](#ContactOfAuthor9))
    and Zahir Tari^([1](#Aff6) [ ](#ContactOfAuthor10))(1)School of Computing Technologies,
    RMIT University, Melbourne, VIC, Australia(2)School of Computer Science and Engineering,
    Nanyang Technological University, Singapore, SingaporeXun Yi (Corresponding author)Email:
    [xun.yi@rmit.edu.au](mailto:xun.yi@rmit.edu.au)Xuechao YangEmail: [xuechao.yang@rmit.edu.au](mailto:xuechao.yang@rmit.edu.au)Andrei KelarevEmail:
    [andrei.kelarev@gmail.com](mailto:andrei.kelarev@gmail.com)Kwok Yan LamEmail:
    [kwokyan.lam@ntu.edu.sg](mailto:kwokyan.lam@ntu.edu.sg)Zahir TariEmail: [zahir.tari@rmit.edu.au](mailto:zahir.tari@rmit.edu.au)'
  prefs: []
  type: TYPE_NORMAL
- en: 2.1 Bitcoin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Bitcoin is a decentralized digital currency without a central administrative
    authority or a single manager. Bitcoins can be sent from user to user on the peer-to-peer
    Bitcoin network without the need for intermediaries. Bitcoin transactions are
    verified by the network nodes using cryptography and are recorded in a public
    distributed ledger called a *blockchain*.
  prefs: []
  type: TYPE_NORMAL
- en: Bitcoin was invented in 2008 by an unknown person or group of people using the
    name Satoshi Nakamoto. The cryptocurrency began being used in 2009 when its implementation
    was released as an open-source software.
  prefs: []
  type: TYPE_NORMAL
- en: 2.1.1 Bitcoin Network
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Bitcoin network, illustrated in Fig. [2.1](#Fig1), is a peer-to-peer (P2P)
    decentralised network. A P2P network is created when two or more computers are
    connected directly and share resources without going through a separate server
    station. It can be an ad hoc connection, for example, a couple of computers connected
    via a Universal Serial Bus to transfer files. It also can be a permanent infrastructure
    linking a number of computers in a company using copper wire or optical cables.
    It can also be larger and can use special protocols and applications to establish
    direct relationships among users over the Internet.![](../images/516136_1_En_2_Chapter/516136_1_En_2_Fig1_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: An illustration depicts the Bitcoin network. It has six Bitcoin Nodes which
    are connected to each other with a double-headed arrow.
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 2.1
  prefs: []
  type: TYPE_NORMAL
- en: The bitcoin network
  prefs: []
  type: TYPE_NORMAL
- en: The Bitcoin network uses special cryptographic protocols and software applications
    to connect the nodes over the Internet. The units of currency in the network are
    called *Bitcoins*. The users can send and receive Bitcoins over the network by
    broadcasting their digitally signed messages to other nodes of the network using
    Bitcoin cryptocurrency wallet software. These transactions of the currency are
    then recorded in a distributed, replicated public database or ledger known as
    the *blockchain* or *blockchain ledger*, with consensus achieved by a proof-of-work
    mechanism called *mining*.
  prefs: []
  type: TYPE_NORMAL
- en: The designer of Bitcoin Satoshi Nakamoto wrote that the design and coding of
    the Bitcoin software began in 2007\. The project was released in 2009 as an open
    source software.
  prefs: []
  type: TYPE_NORMAL
- en: The Bitcoin network requires a minimal infrastructure to share transactions.
    An ad hoc decentralized network of volunteer participants or nodes is sufficient.
    Messages are broadcast on a best-effort basis, and nodes can leave and re-join
    the network at their discretion. Reconnecting to the network, each node downloads
    and verifies new blocks from other nodes to maintain its local copy of the blockchain
    ledger.
  prefs: []
  type: TYPE_NORMAL
- en: 2.1.2 Bitcoin Transactions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A Bitcoin transaction is a transfer of Bitcoin value. It is broadcast to the
    network and is recorded in blocks stored in the ledger. A transaction typically
    references previous transaction outputs as new transaction inputs and dedicates
    all input Bitcoin values to new outputs. Transactions are stores as unencrypted
    plaintext. Therefore it is easy to view every transaction ever recorded in a block
    in the ledger, browse blocks and search for transactions of interest. Once transactions
    are appended with a sufficient number of confirmations they can be considered
    irreversible.
  prefs: []
  type: TYPE_NORMAL
- en: All transactions are recorded in hexadecimal format and are visible in the blockchain
    so that everyone can use a hex editor to view or edit them. A blockchain browser
    is a site where every transaction included within the blockchain can be viewed
    in a human-readable form. This is useful for investigating the technical details
    of transactions in operation and for verifying correctness of the payments.
  prefs: []
  type: TYPE_NORMAL
- en: Figure [2.2](#Fig2) demonstrates the main parts of a Bitcoin transaction.![](../images/516136_1_En_2_Chapter/516136_1_En_2_Fig2_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: An illustration depicts bitcoin transactions. It has two main components namely,
    New Transaction and Previous transaction. Both have sub-components of version,
    input, output, and lock time. The input of the first transaction and output of
    the previous transaction are connected by an arrow.
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 2.2
  prefs: []
  type: TYPE_NORMAL
- en: Format of a bitcoin transaction
  prefs: []
  type: TYPE_NORMAL
- en: Every transaction begins with a four-byte transaction version number which tells
    the Bitcoin peers and miners which set of rules to use to validate it.
  prefs: []
  type: TYPE_NORMAL
- en: Every transaction has one or more inputs and one or morn outputs. Each input
    spends the Bitcoins paid by a previous output. Each output then waits as an Unspent
    Transaction Output (UTXO) until a later input spends it. When your Bitcoin wallet
    informs you that there is a 10,000 Bitcoin balance, in fact this means that there
    are 10,000 Bitcoins waiting in one or more UTXOs. The Locktime sets the earliest
    time a transaction can be added to a block in the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: Each output has an index number determined by its location in the transaction.
    The index of the first output is zero. The output also has an amount in Bitcoins
    which it pays to a receiver with a conditional pubkey script (i.e., a hash of
    the public key of the receiver), for example,![](../images/516136_1_En_2_Chapter/516136_1_En_2_Figa_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: A set of random alphabets and numbers.
  prefs: []
  type: TYPE_NORMAL
- en: The Bitcoin unit is satoshi, which is the smallest denomination of Bitcoin,
    equivalent to 100 millionth of a Bitcoin.
  prefs: []
  type: TYPE_NORMAL
- en: Anyone who can satisfy the conditions of that pubkey script, i.e., knowing the
    corresponding private key, is able to spend up to the amount of Bitcoins in the
    future.
  prefs: []
  type: TYPE_NORMAL
- en: Every input uses a transaction identifier (TXID) (i.e., a hash of the previous
    transaction) and an output index number to identify a particular output to be
    spent. Besides, it has a signature script which provides parameters satisfying
    the conditions in the pubkey script, i.e., the signature of the sender (on the
    new output) and the public key of the sender, for example,![](../images/516136_1_En_2_Chapter/516136_1_En_2_Figb_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: A set of random alphabets and numbers.
  prefs: []
  type: TYPE_NORMAL
- en: The process of spending an output can be illustrated in Fig. [2.3](#Fig3), where
    the sequence number is the input sequence number because there may be more than
    one inputs.![](../images/516136_1_En_2_Chapter/516136_1_En_2_Fig3_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: An illustration has three layers. Layer 1 is new transaction with version, input,
    output and lock time. Layer 2 is Transaction identifier with output index, sequence
    number, signature script, amount, and pub-key script. Layer 3 is Previous transaction
    with version, input, output, and lock time.
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 2.3
  prefs: []
  type: TYPE_NORMAL
- en: Spending an output
  prefs: []
  type: TYPE_NORMAL
- en: A new transaction is valid if (1) the signature of the sender on the output
    is genuine on the basis of the public key of the sender, and (2) the public key
    of the sender can be hashed to the pubkey script of the output in the previous
    valid transaction.
  prefs: []
  type: TYPE_NORMAL
- en: A 160-bit hash of the public portion of a public/private keypair of the receiver
    is called a *Bitcoin address*. The standard format of a Bitcoin address is P2PKH
    (Pay to Public Key Hash). Figure [2.4](#Fig4) demonstrates how to create a P2PKH
    public key hash to receive payment.![](../images/516136_1_En_2_Chapter/516136_1_En_2_Fig4_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: A flow chain has private key, full public key and public key hash under Bob’s
    computer, copy of public key hash under Alice’s computer, and copy of public key
    hash under new transaction, all connected by arrows.
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 2.4
  prefs: []
  type: TYPE_NORMAL
- en: Creating a P2PKH public key hash to receive payment
  prefs: []
  type: TYPE_NORMAL
- en: Next, let us see the workflow of Alice sending Bob a transaction and Bob later
    spending that transaction in detail. Both Alice and Bob use the most common form
    of the standard P2PKH transaction type. P2PKH allows Alice to spend Bitcoins to
    a typical Bitcoin address, and then lets Bob to spend the same Bitcoins using
    a cryptographic key pair.
  prefs: []
  type: TYPE_NORMAL
- en: First, Bob has to generate private and public keys forming a key pair. Then
    Alice can implement the transaction. Bitcoin uses the Elliptic Curve Digital Signature
    Algorithm (ECDSA) with the secp256k1 curve.^([1](#Fn1)) The secp256k1 private
    keys are represented by 256 bits of random data. A copy of that data is deterministically
    transformed into an secp256k1 public key. Because the transformation can be reliably
    repeated later, the public key does not have to be stored.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the public key (pubkey) is cryptographically hashed. The hash shortens
    and obfuscates the public key, making a manual transcription easier and providing
    security against unanticipated problems which might allow the reconstruction of
    private keys from public key data later on.
  prefs: []
  type: TYPE_NORMAL
- en: Bob supplies the pubkey hash to Alice. Pubkey hashes are almost always sent
    encoded as Bitcoin addresses, which are base58-encoded strings containing an address
    version number, the hash, and an error-detection checksum to catch typos.^([2](#Fn2))
    The address can be transmitted through any medium, including one-way mediums which
    prevent the spender from communicating with the receiver.
  prefs: []
  type: TYPE_NORMAL
- en: When Alice receives the address and decodes it back into a standard hash, she
    can generate the first transaction. Alice creates a standard P2PKH transaction
    output containing instructions which permit anyone to spend that output if they
    can prove that they control the private key corresponding to Bob’s hashed public
    key. These instructions are called the pubkey script or scriptPubKey.
  prefs: []
  type: TYPE_NORMAL
- en: After signing the output, Alice broadcasts the transaction to all nodes and
    it is added to the blockchain. The network categorizes it as an Unspent Transaction
    Output (UTXO). The software of the Bob’s wallet displays it as a spendable balance.
  prefs: []
  type: TYPE_NORMAL
- en: When Bob decides to spend the UTXO, he can create an input referring to the
    transaction that Alice created by the hash of the transaction, which is also called
    a Transaction Identifier (TXID), and the specific output Alice used referred to
    by its index number, i.e., the output index. Then Bob must create a signature
    script—a collection of data parameters satisfying the conditions Alice placed
    in the previous output’s pubkey script. Signature scripts are also called scriptSigs.
  prefs: []
  type: TYPE_NORMAL
- en: Pubkey scripts and signature scripts combine secp256k1 pubkeys and signatures
    with conditional logic. This creates a programmable authorization mechanism as
    shown in Fig. [2.5](#Fig5).![](../images/516136_1_En_2_Chapter/516136_1_En_2_Fig5_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: An illustration depicts a P 2 P K H output. The components are previous transactions
    with version, input, output, and lock time, then public key hash, followed by
    Signature script with signature, full public key, pub-key script, public key hash,
    and then Bob’s computer with a private key and full public key, connected by arrows.
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 2.5
  prefs: []
  type: TYPE_NORMAL
- en: Spending a P2PKH output
  prefs: []
  type: TYPE_NORMAL
- en: For a P2PKH-style output, Bob’s signature script contains the following two
    data items.
  prefs: []
  type: TYPE_NORMAL
- en: Bob’s full unhashed public key, so the pubkey script can check that it hashes
    to the same value as the pubkey hash provided by Alice.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A secp256k1 signature made by using the ECDSA cryptographic formula to combine
    certain transaction data (described below) with Bob’s private key. This lets the
    pubkey script verify that Bob owns the private key which corresponds to the public
    key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bob’s secp256k1 signature proves that Bob controls his private key, and makes
    the non-signature-script parts of his transaction tamper-proof. Bob can safely
    broadcast them over the peer-to-peer network.![](../images/516136_1_En_2_Chapter/516136_1_En_2_Fig6_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: A flow diagram has previous transaction with Transaction I D, output index number,
    and pub-key script, then Bob’s computer with Private key, new transaction, pub-key
    script, and amount, then Signed data, and finally New Transaction with Transaction
    I D, output index, full public key, signature, pub-key script, and amount.
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 2.6
  prefs: []
  type: TYPE_NORMAL
- en: Data items signed when spending an output
  prefs: []
  type: TYPE_NORMAL
- en: As illustrated in Fig. [2.6](#Fig6), the data signed by Bob include the TXID
    and the output index of the previous transaction, the pubkey script Bob creates
    which will let the next recipient spend this transaction’s output, and the amount
    of Bitcoins to spend to the next recipient. Thus, the entire transaction is signed
    with the exception of all signature scripts holding the full public keys and secp256k1
    signatures.
  prefs: []
  type: TYPE_NORMAL
- en: Next, Bob appends his signature and the public key to the signature script in
    the input of the new transaction, and broadcasts the transaction to all Bitcoin
    miners through the peer-to-peer network. Every peer and miner independently validates
    the transaction before broadcasting it further or attempting to include it in
    a new block of transactions.
  prefs: []
  type: TYPE_NORMAL
- en: In a P2PKH output, the pubkey script has the following form:![](../images/516136_1_En_2_Chapter/516136_1_En_2_Figc_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: A set of random alphabets and numbers.
  prefs: []
  type: TYPE_NORMAL
- en: In an input of the new transaction, the signature script contains an secp256k1
    signature (sig) and the full public key (pubkey). The signature can be verified
    in the following sequence:![](../images/516136_1_En_2_Chapter/516136_1_En_2_Figd_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: A set of random alphabets and numbers.
  prefs: []
  type: TYPE_NORMAL
- en: In order to test whether the transaction is valid, the signature script and
    pubkey script operations are executed one item at a time, starting with Bob’s
    signature script and continuing to Bob’s pubkey script from Alice’s output. The
    process of the evaluation of a standard P2PKH pubkey script is described as follows.
  prefs: []
  type: TYPE_NORMAL
- en: The signature from Bob’s signature script is added to an empty stack. There
    is no need to encrypt it, and so it is pushed to the stack as plaintext. The public
    key from the signature script is pushed on top of the signature.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The OP_DUP operation on Bob’s pubkey is executed. It pushes onto the stack a
    copy of the data currently at the top of it. This creates a copy of the public
    key supplied by Bob.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, the operation OP_HASH160 is executed. It adds to the stack a hash of the
    data currently on top of it—in this case, Bob’s public key. This creates a hash
    of Bob’s public key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, Bob’s pubkey script from Alice’s output pushes the pubkey hash that Bob
    provided for the previous transaction. At this point, there should be two copies
    of Bob’s pubkey hash at the top of the stack.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further, it executes the operation OP_EQUALVERIFY. It is equivalent to executing
    the operation OP_EQUAL followed by OP_VERIFY as follows.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'OP_EQUAL checks whether two values at the top of the stack are equal. In our
    case, it checks whether the pubkey hash generated from the full public key supplied
    by Bob is equal to the pubkey hash Alice included in her output when she created
    the previous transaction. The operation OP_EQUAL pops (i.e., removes from the
    top of the stack) the two values it compared, and replaces them with the result
    of the comparison: zero (false) or one (true).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OP_VERIFY checks the value at the top of the stack. If the value is false it
    immediately terminates the evaluation and the transaction validation fails. Otherwise,
    it pops the true value off the stack.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, it executes the operation OP_CHECKSIG, which verifies the signature
    supplied by Bob comparing it with the now-authenticated public key he also provided.
    If the signature matches the public key and was generated using all the data required
    to be signed, then OP_CHECKSIG pushes the value ‘true’ onto the top of the stack.
    If false is not at the top of the stack after the pubkey script has been evaluated,
    the transaction is valid provided there are no other semantic problems with it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2.1.3 Blockchain and Bitcoin’s Proof-of-Work
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Bitcoin uses a blockchain public ledger as an ordered and timestamped record
    of transactions. This system is applied to protect against double spending and
    prevent modifications of previous transaction records.
  prefs: []
  type: TYPE_NORMAL
- en: Each full node in the Bitcoin network independently stores a chain of blocks
    containing only blocks validated by that node. When several nodes all have the
    same blocks in their copies of the blockchain ledger, they are considered to be
    in consensus. To maintain consensus these nodes follow the validation rules called
    consensus rules.![](../images/516136_1_En_2_Chapter/516136_1_En_2_Fig7_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: An illustration depicts the blockchain data structure and block format. It has
    three blocks, Block N minus 1, Block N, and Block N plus 1\. The right of the
    image depicts the hash block N plus 1 equal to the hash (block header). It has
    a hash (block N minus 1), market root hash, version, timestamp, nonce, and target
    difficulty.
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 2.7
  prefs: []
  type: TYPE_NORMAL
- en: Blockchain data structure and block format
  prefs: []
  type: TYPE_NORMAL
- en: Figure [2.7](#Fig7) displays a simplified version of a blockchain. A group of
    one or more new transactions is collected into the transaction data part of a
    block. Copies of each transaction are hashed, and the hashes are then paired,
    hashed, paired again, and hashed again until a single hash remains, the Merkle
    root of a Merkle tree.
  prefs: []
  type: TYPE_NORMAL
- en: The Merkle root is stored in the block header. Each block also stores the hash
    of the previous block’s header. This chains the blocks together and ensures that
    a transaction cannot be modified without modifying the block that records it and
    all the following blocks.
  prefs: []
  type: TYPE_NORMAL
- en: Transactions are also chained together. Bitcoin’s wallet software gives the
    impression that Bitcoins are sent from and to wallets, but in reality Bitcoins
    move from transaction to transaction. Each transaction spends the Bitcoins previously
    received in one or more earlier transactions. This means that the input of one
    transaction is the output of a previous transaction.
  prefs: []
  type: TYPE_NORMAL
- en: The blockchain is collaboratively maintained by anonymous peers on the network.
    Bitcoin requires every block to contain a proof that a significant amount of work
    was invested in its creation. This ensures that untrustworthy peers who want to
    modify past blocks are faced with a prohibitively hard amount of work.
  prefs: []
  type: TYPE_NORMAL
- en: Chaining blocks together makes it impossible to modify transactions included
    in any block without modifying all subsequent blocks. As a result, the cost of
    modifying a particular block increases with every new block added to the blockchain
    ledger, increasing the effect of the proof-of-work mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: The proof-of-work used in Bitcoin takes advantage of the apparently random nature
    of cryptographic hashes. A good cryptographic hash algorithm converts arbitrary
    data into a hash value that looks like a random number unrelated to the data.
    If the data is modified in any way and the hash algorithm is run again, a new
    hash value that looks like a new random number is generated, so that it is impossible
    to modify the data creating a predictable hash value.
  prefs: []
  type: TYPE_NORMAL
- en: To prove that a miner completed a substantial work to create a block, the miner
    is required to randomly choose a nonce to create a hash of the block header which
    does not exceed a certain threshold value. For example, if the maximum possible
    hash value is ![$$2^{256}-1$$](../images/516136_1_En_2_Chapter/516136_1_En_2_Chapter_TeX_IEq1.png),
    then the miner can prove that at least two tests were performed by producing a
    hash value less than ![$$2^{255}$$](../images/516136_1_En_2_Chapter/516136_1_En_2_Chapter_TeX_IEq2.png).
  prefs: []
  type: TYPE_NORMAL
- en: In the simplified example given above, the miner produces a successful hash
    on average every second attempt. The miner can estimate the probability that one
    hash attempt generates a number below the target threshold. Bitcoin assumes a
    linear correlation of the probability and the threshold value. The lower the target
    threshold is made, the more hash attempts are needed on the average to find the
    hash satisfying this condition.
  prefs: []
  type: TYPE_NORMAL
- en: New blocks are added to the chain of blocks only if their hash satisfies the
    condition in the difficulty level specified by the current target threshold in
    the consensus protocol. After every portion of 2016 blocks are added to the ledger,
    the network uses timestamps stored in the headers of all these blocks to compute
    the number of seconds elapsed from the generation of the first until the last
    of these 2016 blocks. The ideal value is 1,209,600 s or two weeks.
  prefs: []
  type: TYPE_NORMAL
- en: If it is discovered that less than two weeks were spent on generating the last
    2016 blocks, then the expected difficulty value is increased proportionally (by
    up to 300%) so that the next 2016 blocks should take exactly two weeks to generate
    if the required hashes continue being found at the same rate as before.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If it is discovered that more than two weeks elapsed when the last portion of
    blocks were generated, then the expected difficulty value is decreased proportionally
    (by up to 75%) to speed up the process so that again the next 2016 blocks would
    take exactly two weeks to generate if the required hashes continue being found
    at the same rate as before.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since every block header must hash to a value below the target threshold, and
    because each block is linked to the block that precedes it, it requires on average
    as much hashing power to propagate a modified block as the entire Bitcoin network
    expended between the time the original block was created and the present time.
    Only if you acquired a majority of the network’s hashing power, you could reliably
    execute such a 51% attack against transaction history. However, in terms of probability,
    it should be noted that even a group with less than 50% of the hashing power still
    has a certain chance of performing attacks of this type.
  prefs: []
  type: TYPE_NORMAL
- en: The block header includes several easily modifiable fields, such as a dedicated
    nonce field. Therefore, to generate new hashes the miners don’t have to wait for
    new transactions. Besides, only the 80-byte block header is hashed for the proof-of-work.
    The inclusion of a large volume of transaction data in a block does not slow down
    hashing with extra input and output. The addition of transaction data only requires
    to recompute the hashes of the ancestors in the Merkle tree.
  prefs: []
  type: TYPE_NORMAL
- en: 2.1.4 Bitcoin Mining
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The process of Bitcoin mining is a vitally important component of the maintenance
    and development of the blockchain ledger. It is used to add new Bitcoins into
    circulation. It is also applied to confirm new transactions by the network nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Bitcoin mining is carried out by applying sophisticated hardware to solve extremely
    complex computational problems. Every solution to the problem can serve as a proof
    that difficult work has been performed. The first computer to find a solution
    to the problem is awarded the right to add the next block of Bitcoins and the
    process of mining continues.
  prefs: []
  type: TYPE_NORMAL
- en: A Bitcoin miner who successfully hashes a block header to a value below the
    target threshold can add the corresponding block to the blockchain ledger provided
    that the block is valid in other respects. The blocks are commonly referred to
    by their block height—the number of blocks between them and the first Bitcoin
    block (block 0, most commonly known as the genesis block). For example, block
    2016 may be the block where the difficulty level determined by the target threshold
    can be adjusted the first time.![](../images/516136_1_En_2_Chapter/516136_1_En_2_Fig8_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: An illustration depicts the common and uncommon blockchain forks. It has two
    categories namely, Normal occasional forking and the Rare extended forking.
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 2.8
  prefs: []
  type: TYPE_NORMAL
- en: Common and uncommon blockchain forks
  prefs: []
  type: TYPE_NORMAL
- en: Multiple blocks can all have the same block height, since two or more miners
    may happen to produce their blocks at approximately the same time. This creates
    a conflicting fork in the blockchain ledger, as shown in Fig. [2.8](#Fig8).
  prefs: []
  type: TYPE_NORMAL
- en: When two miners produce their blocks simultaneously and add them to the end
    of the blockchain ledger, each node of the network individually chooses which
    block to accept. Typically, many nodes can use the first block they see added.
    Other considerations that may be taken into account are discussed below.
  prefs: []
  type: TYPE_NORMAL
- en: Eventually a miner produces another block which is attached to only one of the
    competing simultaneously-mined blocks. This makes the corresponding side of the
    fork stronger than the other side. Assuming that a fork contains only valid blocks,
    normal peers always follow the longest chain of the ledger since it is more reliable
    being confirmed by more difficult set of proofs. The blocks belonging to the shorter
    fork are called *stale blocks*. They have to be thrown away and recreated. Stale
    blocks are also sometimes called *orphans* or *orphan blocks*, but these terms
    are also used for blocks without a known parent block.
  prefs: []
  type: TYPE_NORMAL
- en: Long-term forks are possible if different miners work at cross-purposes, such
    as some miners diligently working to extend the blockchain ledger at the same
    time other miners are attempting a 51% attack to revise transaction history.
  prefs: []
  type: TYPE_NORMAL
- en: Miners are getting paid for their work as auditors. They are doing the work
    of verifying the legitimacy of Bitcoin transactions. This convention is meant
    to keep Bitcoin users honest and was conceived by Bitcoin’s founder, Satoshi Nakamoto.
    By verifying transactions, miners are helping to prevent the “double-spending
    problem.”
  prefs: []
  type: TYPE_NORMAL
- en: 'Double spending is a scenario in which a Bitcoin owner illicitly spends the
    same Bitcoin twice. With physical currency, this isn’t an issue: once you hand
    someone a $20 bill to buy something, you no longer have it, so there’s no danger
    you could use that same $20 bill to buy lotto tickets next door. While there is
    the possibility of counterfeit cash being made, it is not exactly the same as
    literally spending the same dollar twice. With digital currency, however, there
    is a risk that the holder could make a copy of the digital token and send it to
    a merchant or another party while retaining the original.'
  prefs: []
  type: TYPE_NORMAL
- en: Bitcoin miners are rewarded by receiving Bitcoins for completing blocks of verified
    transactions, which are added to the blockchain. Mining rewards are paid to the
    miner who discovers a solution to the complex hashing puzzle first. The probability
    that a participant discovers a solution is related to the amount of the total
    mining power on the network.
  prefs: []
  type: TYPE_NORMAL
- en: The rewards for Bitcoin mining are reduced by half approximately every four
    years as shown in Fig. [2.9](#Fig9).![](../images/516136_1_En_2_Chapter/516136_1_En_2_Fig9_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: A bar graph depicts the miner’s reward for successfully completing 1 block.
    The graph denotes on halve every 210,000 blocks, or an average of every 4 years
    in the categories of from 2009 50 B T C per block, from 2012 25 B T C per block,
    2016 12.5 B T C per block, and from 2020 6.25 B T C per block.
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 2.9
  prefs: []
  type: TYPE_NORMAL
- en: Miner’s reward
  prefs: []
  type: TYPE_NORMAL
- en: When Bitcoin started its operation in 2009, mining one block earned the miner
    50 BTC. In 2012, this amount was reduced to 25 BTC. By 2016, it was reduced again
    to 12.5 BTC. In 2020, the reward was reduced again to 6.25 BTC.
  prefs: []
  type: TYPE_NORMAL
- en: In September 2021, the price of Bitcoin was about $45,000 per Bitcoin, which
    means that each miner earned $281,250 (6.25 ![$$\times $$](../images/516136_1_En_2_Chapter/516136_1_En_2_Chapter_TeX_IEq3.png)
    45,000) for completing a block.
  prefs: []
  type: TYPE_NORMAL
- en: The first transaction in a block is a *coinbase transaction*. It is a unique
    type of Bitcoin transaction that can be created by a miner. The miners use it
    to collect the block reward for their work and any other transaction fees collected
    by the miner are also sent in this transaction.
  prefs: []
  type: TYPE_NORMAL
- en: A coinbase transaction must have exactly one input, which is called a *coinbase*.
    The coinbase input format can be illustrated as Fig. [2.10](#Fig10).![](../images/516136_1_En_2_Chapter/516136_1_En_2_Fig10_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: A table has four columns and six rows. The columns have Bytes, Name, Data type,
    and description, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 2.10
  prefs: []
  type: TYPE_NORMAL
- en: Coinbase input format
  prefs: []
  type: TYPE_NORMAL
- en: Coinbase transactions are always constructed by a miner.
  prefs: []
  type: TYPE_NORMAL
- en: They contain a reward for the work spent during the proof-of-work mining process.
    The total amount of reward that a miner receives is equal to the sum of the block
    reward and the transaction fees taken from all the transactions that have been
    included in the block. To create a coinbase transaction, the miner calculates
    the total amount of transaction fees for transactions that are included in a block.
    It is calculated as follows:![](../images/516136_1_En_2_Chapter/516136_1_En_2_Fige_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Total fees equals the sum of inputs plus the sum of outputs
  prefs: []
  type: TYPE_NORMAL
- en: The genesis block, i.e., Block 0, and some initial blocks, contains Coinbase
    transactions only because no other transactions happened in the initialisation
    of Bitcoins.
  prefs: []
  type: TYPE_NORMAL
- en: It is safe for a miner directly to announce in the Bitcoin network his new discovery
    block which contains his nonce making the hash of his block below a given threshold,
    because his Coinbase transactions (for rewarding) have been included in his block.
    It is difficult for anyone to replace his Coinbase transactions with other transactions
    without changing the hash of the block (i.e., below a given threshold). This is
    one of the smartest ideas in the design of Bitcoin.
  prefs: []
  type: TYPE_NORMAL
- en: 2.2 Ethereum
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Shortly after Bitcoin’s release, Ethereum looked at the way they were using
    blockchain technology and imagined how it could be used beyond just as a currency.
  prefs: []
  type: TYPE_NORMAL
- en: Every blockchain is a public database that is updated and shared across many
    computers in a network. The word “block” refers to data and state being stored
    in consecutive groups known as blocks.
  prefs: []
  type: TYPE_NORMAL
- en: '*Ether* (ETH) is the cryptocurrency used on the Ethereum network. If you send
    an Ether to someone else, the transaction data needs to be added to a block to
    be successful. The smallest denomination of Ether available in Ethereum is denoted
    by WEI. One Ether is equal to a quintillion WEI, i.e., ![$$10^{18}$$](../images/516136_1_En_2_Chapter/516136_1_En_2_Chapter_TeX_IEq4.png)
    WEI. The most commonly used Ether unit is GWEI. One Ether is equal to a billion
    GWEI, i.e., ![$$10^{9}$$](../images/516136_1_En_2_Chapter/516136_1_En_2_Chapter_TeX_IEq5.png)
    GWEI.'
  prefs: []
  type: TYPE_NORMAL
- en: The word “chain” is explained by the fact that each block is linked to its previous
    block cryptographically. In this way, blocks are organised into a consecutive
    chain. The data in a block cannot be modified without altering all the subsequent
    blocks, which would require the consensus of the entire network.
  prefs: []
  type: TYPE_NORMAL
- en: Every participant or computer in the network must agree upon each new block
    and the chain as a whole. These participants or computers are known as “nodes”
    of the network. Nodes ensure that everyone interacting with the blockchain has
    the same data. To accomplish this distributed agreement, blockchain employs a
    consensus mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum currently uses a proof-of-work consensus mechanism. It means that anyone
    aiming to add new blocks to the chain must solve a difficult puzzle that requires
    a lot of computing work to be carried out. Solving the puzzle proves that you
    have done the work by using computational resources. Doing this is known as *mining*.
    Typically, mining uses brute force trial and error. Each success in adding a block
    is rewarded in Ethers.
  prefs: []
  type: TYPE_NORMAL
- en: New blocks are broadcast to the nodes in the network and are verified to update
    the state of the blockchain ledger for everyone. To summarize, when you send an
    Ether to someone, the transaction must be mined and included in a new block. The
    updated state is then shared with the entire network.
  prefs: []
  type: TYPE_NORMAL
- en: 2.2.1 Ethereum Network
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the Ethereum community, there is a single canonical computer called the *Ethereum
    Virtual Machine* or EVM. Every Ethereum node keeps a copy of the state of the
    EVM. An agreement of all participants on the Ethereum network on the current state
    of the EVM has to be achieved. Besides, any participant can broadcast a request
    for the EVM to perform a requested computation. Whenever such a request is broadcast,
    other participants on the network verify, validate, and execute the computation
    in their copy of the state of the EVM. This execution causes a state change in
    the EVM, which is committed and distributed throughout the entire network.
  prefs: []
  type: TYPE_NORMAL
- en: These requests for computation are called *transaction requests*. The record
    of all transactions and the EVM’s present state is stored on the blockchain ledger,
    which in turn is recorded and agreed upon by all nodes.
  prefs: []
  type: TYPE_NORMAL
- en: The network uses cryptographic mechanisms to guarantee that when transactions
    are verified as valid and added to the blockchain, they cannot be tampered with
    later. The same mechanisms also ensure that all transactions are signed and executed
    with appropriate “permissions”. Therefore nobody can send digital assets from
    a network account, except for the owner of the account.
  prefs: []
  type: TYPE_NORMAL
- en: 2.2.1.1 Ether (ETH)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Ether* (ETH) is the cryptocurrency used for many things on the Ethereum network.
    It is the only acceptable form of payment for transaction fees, as a payment of
    benefit for mining, and other payments.'
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum allows developers to create decentralized applications or dapps, which
    all share a common pool of computing resources. This shared pool is finite and
    Ethereum applies a mechanism determining who can use the resources and when. Otherwise,
    a dapp could accidentally or maliciously consume all network resources, which
    would block others from accessing it.
  prefs: []
  type: TYPE_NORMAL
- en: The Ether cryptocurrency supports a pricing mechanism for Ethereum’s computing
    power. When users want to make a transaction, they must contribute Ethers to have
    their transaction recognized on the blockchain. These usage costs are known as
    *gas fees*. The gas fee depends on the amount of computing power required to execute
    the transaction and the network-wide demand for computing power at the time.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, even if a malicious dapp submitted an infinite loop, the transaction
    would eventually run out of Ethers and terminate, allowing the network to return
    to normal.
  prefs: []
  type: TYPE_NORMAL
- en: The words ‘Ethereum’ and ‘Ether’ are often used interchangeably. For example,
    the ‘price of Ethereum’ means the same as the price of Ether.
  prefs: []
  type: TYPE_NORMAL
- en: 2.2.1.2 Ethereum Accounts
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The current state of the Ethereum is made up from objects called *accounts*.
    Each account has a 20-byte address and state transitions, which are direct transfers
    of value and information between accounts. An Ethereum account contains the following
    four fields.
  prefs: []
  type: TYPE_NORMAL
- en: The **nonce**, a counter used to make sure each transaction can only be processed
    once.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The account’s current **Ether balance**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The account’s **contract code**, if present.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The account’s **storage**, which is empty by default.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ether is used to pay transaction fees. In general, there are two types of accounts:
    **externally owned accounts**, controlled by private keys, and **contract accounts**,
    controlled by their contract code. An externally owned account has no code, and
    one can send messages from an externally owned account by creating and signing
    a transaction. Every time a contract account receives a message its code activates,
    allowing it to read and write to internal storage and send other messages or create
    new contracts.'
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum contracts do not require something to be implemented or complied with.
    Instead, they act as autonomous agents inside the Ethereum environment. Each contract
    always executes a specific piece of code when prompted by a message or a transaction.
    Contracts have a direct control over their own Ether balance and their own key/value
    store to keep track of persistent variables.
  prefs: []
  type: TYPE_NORMAL
- en: '**Example of account creation.** To create an account in Ethereum, most libraries
    can generate a random private key for you. A private key is a sequence of 64 hexadecimal
    characters, which may be encrypted with a password. Here is an example of a private
    key:![](../images/516136_1_En_2_Chapter/516136_1_En_2_Figf_HTML.png)'
  prefs: []
  type: TYPE_NORMAL
- en: a set of random alphabets and numbers.
  prefs: []
  type: TYPE_NORMAL
- en: A public key is generated from the private key using the Elliptic Curve Digital
    Signature Algorithm. The user can obtain a public address for the account by taking
    the last 20 bytes of the Keccak-256 hash of the public key and adding 0x to the
    beginning.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we give an example of creating an account in the console using GETH’s
    personal_newAccount.![](../images/516136_1_En_2_Chapter/516136_1_En_2_Figg_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: An algorithm
  prefs: []
  type: TYPE_NORMAL
- en: It is possible for the users to derive new public keys from the private key
    but nobody can derive a private key from the public keys. Therefore, it is vital
    to keep the private key safe and secret.
  prefs: []
  type: TYPE_NORMAL
- en: A private key is needed to sign messages and transactions which output a signature.
    Others can then take the signature to derive your public key, proving the author
    of the message. In the Ethereum application, the nodes can use a JavaScript library
    to send transactions to the network.
  prefs: []
  type: TYPE_NORMAL
- en: Every contract account has a 42 character hexadecimal address, for example,![](../images/516136_1_En_2_Chapter/516136_1_En_2_Figh_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: a set of random alphabets and numbers.
  prefs: []
  type: TYPE_NORMAL
- en: The contract address is usually given when a contract is deployed to the Ethereum
    blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: 2.2.2 Ethereum Transactions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ethereum transactions are cryptographically signed instructions from accounts.
    An account can initiate a transaction to update the state of the Ethereum network.
    The simplest transaction is transferring ETH from one account to another.
  prefs: []
  type: TYPE_NORMAL
- en: An Ethereum transaction refers to an action initiated by an externally-owned
    account, that is an account managed by a human, not a contract. For example, if
    Bob sends Alice 1 ETH, Bob’s account must be debited and Alice’s must be credited.
    This state-changing action takes place within a transaction.
  prefs: []
  type: TYPE_NORMAL
- en: Transactions which change the state of the EVM, need to be broadcast to the
    whole network. Every node can broadcast a request for a transaction to be executed
    on the EVM. After this broadcast, a miner executes the transaction and propagates
    the resulting state change to the rest of the network.
  prefs: []
  type: TYPE_NORMAL
- en: Transactions require a fee and must be mined to become valid. In addition to
    the gas fees and details related to the mining process discussed above, every
    submitted transaction must include the following information.
  prefs: []
  type: TYPE_NORMAL
- en: recipient is the receiving address. (For an externally-owned account, the transaction
    transfers cryptocurrency. For a contract account, the transaction executes the
    contract code.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: signature is the identifier of the sender. The identifier is generated when
    the sender’s private key signs the transaction and confirms that the sender has
    authorized this transaction.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: value is the amount of ETH to transfer from sender to recipient.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: data is an optional field to include arbitrary data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: gasLimit is the maximum amount of gas units that can be consumed by the transaction.
    Units of gas represent computational steps.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: maxPriorityFeePerGas is the maximum amount of gas to be included as a tip to
    the miner.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: maxFeePerGas is the maximum amount of gas willing to be paid for the transaction
    (inclusive of baseFeePerGas and maxPriorityFeePerGas).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The term *gas* refers to the computation required to process the transaction
    by a miner. Users have to pay a fee for this computation. The gasLimit, and maxPriorityFeePerGas
    determine the maximum transaction fee paid to the miner. Here is an example of
    the corresponding transaction object.![](../images/516136_1_En_2_Chapter/516136_1_En_2_Figi_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: An algorithm
  prefs: []
  type: TYPE_NORMAL
- en: Each transaction object needs to be signed using the sender’s private key. This
    proves that the transaction could only have come from the sender and was not sent
    fraudulently. This signing process is handled by an Ethereum client like Geth.
    An example of call is![](../images/516136_1_En_2_Chapter/516136_1_En_2_Figj_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: An algorithm
  prefs: []
  type: TYPE_NORMAL
- en: Next, we give an example of a possible response.![](../images/516136_1_En_2_Chapter/516136_1_En_2_Figk_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: An algorithm
  prefs: []
  type: TYPE_NORMAL
- en: raw is the signed transaction in Recursive Length Prefix (RLP) encoded form.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: tx is the signed transaction in JSON form.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the signature hash, transaction can be cryptographically authenticated
    using signed hash submitted to the network to prove that it came from the sender.
  prefs: []
  type: TYPE_NORMAL
- en: Once the transaction has been submitted the following steps follow.
  prefs: []
  type: TYPE_NORMAL
- en: 1.Once you send a transaction, cryptography generates a transaction hash, for
    example,![](../images/516136_1_En_2_Chapter/516136_1_En_2_Figl_HTML.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a set of random alphabets and numbers.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The transaction is then broadcast to the network and included in a pool with
    other transactions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '3.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A miner must pick your transaction and include it in a block in order to verify
    the transaction and consider it successful.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '4.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Your transaction will receive confirmations. The number of confirmations is
    the number of blocks created since the block that included your transaction. The
    higher the number, the greater the certainty that the network processed and recognized
    the transaction.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Recent blocks may be re-organized, giving the impression the transaction was
    unsuccessful; however, the transaction may still be valid but included in a different
    block.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The probability of a re-organization diminishes with every subsequent block
    added, i.e., the greater the number of confirmations, the more immutable the transaction
    becomes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transactions cost gas to execute. Simple transfer transactions require 21,000
    units of gas.
  prefs: []
  type: TYPE_NORMAL
- en: For Bob to send Alice 1 ETH at a baseFeePerGas of 190 GWEI and maxPriorityFeePerGas
    of 10 GWEI, Bob will need to pay the following fee.![](../images/516136_1_En_2_Chapter/516136_1_En_2_Figm_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: a set of random alphabets and numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Bob’s account will be debited −1.0042 ETH
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alice’s account will be credited +1.0 ETH
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The base fee will be burned −0.00399 ETH
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Miner keeps the tip +0.000210 ETH
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gas is required for any smart contract interaction too.![](../images/516136_1_En_2_Chapter/516136_1_En_2_Fig11_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: A flow diagram of the Ethereum state transition has three components namely
    Current state, New transaction and Current state.
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 2.11
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum state transition
  prefs: []
  type: TYPE_NORMAL
- en: 2.2.2.1 Ethereum State Transition Function
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Ethereum state transition function APPLY(S, TX), -> S’ is illustrated in
    Fig. [2.11](#Fig11) and is defined as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check if the transaction is well-formed (i.e., has the right number of values),
    the signature is valid, and the nonce matches the nonce in the sender’s account.
    If not, then return an error.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calculate the transaction fee as STARTGAS * GASPRICE, and determine the sending
    address from the signature. Subtract the fee from the sender’s account balance
    and increment the sender’s nonce. If there is not enough balance to spend, return
    an error.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '3.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Initialize GAS = STARTGAS, and take off a certain quantity of gas per byte to
    pay for the bytes in the transaction.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '4.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the receiving account does not yet exist, then create it. Transfer the transaction
    value from the sender’s account to the receiving account. If the receiving account
    is a contract, then run the contract’s code either to completion or until the
    execution runs out of gas.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '5.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the value transfer failed because the sender did not have enough money or
    the code execution ran out of gas, revert all state changes except the payment
    of the fees, and add the fees to the miner’s account.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '6.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Otherwise, refund the fees for all remaining gas to the sender, and send the
    fees paid for gas consumed to the miner.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For example, suppose that the contract’s code is![](../images/516136_1_En_2_Chapter/516136_1_En_2_Fign_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Self storage calldataload (0) it equals calldataload (32)
  prefs: []
  type: TYPE_NORMAL
- en: Note that in reality the contract code is written in the low-level EVM code.
    This example is written in Serpent, one of our high-level languages, for clarity,
    and can be compiled down to EVM code. Suppose that the contract’s storage starts
    off empty, and a transaction is sent with 10 Ethers, 2000 gas, 0.001 Ether gas
    price, and 64 bytes of data, with bytes 0–31 representing the number 2 and bytes
    32–63 representing the string CHARLIE. In this case, the state transition function
    operates as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check that the transaction is valid and well formed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check that the transaction sender has at least 2000 * 0.001 = 2 Ether. If so,
    then subtract 2 Ether from the sender’s account.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '3.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Initialize gas = 2000, assuming the transaction is 170 bytes long and the byte-fee
    is 5\. Subtract 850 from the account so that there is 1150 gas left.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '4.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Subtract 10 more Ether from the sender’s account, and add it to the contract’s
    account.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '5.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the code. In this case, the code checks whether the contract’s storage at
    index 2 is used, notices that it is not, and so it sets the storage at index 2
    to the value CHARLIE. Suppose that this takes 187 gas. Then the remaining amount
    of gas is ![$$1150 - 187 = 963.$$](../images/516136_1_En_2_Chapter/516136_1_En_2_Chapter_TeX_IEq6.png)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '6.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add 963 * 0.001 = 0.963 Ether back to the sender’s account and return the resulting
    state.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If there was no contract at the receiving end of the transaction, then the total
    transaction fee would be equal to GASPRICE multiplied by the length of the transaction
    in bytes, and the data sent alongside the transaction would be irrelevant.
  prefs: []
  type: TYPE_NORMAL
- en: Note that processing of messages operates in the same way as in the case of
    transactions in terms of handling reversals. If a message execution runs out of
    gas, then the execution and all other executions triggered by that execution,
    revert, but parent executions do not need to revert. This means that it is safe
    for a contract to call another contract, since if A calls B with G gas then A’s
    execution is guaranteed to lose at most G gas. Finally, note that there is an
    opcode CREATE that creates a contract. Its execution mechanics are generally similar
    to CALL with the exception that the output of the execution determines the code
    of a newly created contract.
  prefs: []
  type: TYPE_NORMAL
- en: 2.2.3 Ethereum’s Proof-of-Work
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ethereum, like Bitcoin, currently uses a consensus protocol called proof-of-work
    (PoW). This allows the nodes of the Ethereum network to agree on the state of
    all information recorded on the Ethereum blockchain and prevents various economic
    attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Proof-of-work is the underlying algorithm that sets the difficulty and rules
    for the work miners do. Mining is the “work” itself. It’s the act of adding valid
    blocks to the chain. This is important because the chain’s length helps the network
    follow the correct Ethereum chain and understand Ethereum’s current state. The
    more work is done, the longer the chain, and the higher the block number, the
    more certain the network can be of the current state of the ledger.
  prefs: []
  type: TYPE_NORMAL
- en: 2.2.3.1 How Does Ethereum’s Proof-of-Work Work?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Proof-of-work is performed by miners, who compete to create new blocks full
    of processed transactions. The winner shares the new block with the rest of the
    network and earns some freshly minted ETH. The race is won by the computer that
    manages to solve a math puzzle first. This produces the cryptographic link between
    the current block and the preceding block in the chain. Solving the puzzle is
    the work required to establish proof-of-work.
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum transactions are processed into blocks. Each block has a
  prefs: []
  type: TYPE_NORMAL
- en: 'block difficulty—for example: 3,324,092,183,262,715'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'mixHash, for example: 0x44bca881b07a6a09f83b130798072441705d9a6...'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'nonce, for example: 0xd3ee432b4fb3d26b'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The proof-of-work protocol Ethash requires miners to go through an intense race
    of trial and error to find the nonce for a block. Only blocks with a valid nonce
    can be added to the chain. When racing to create a block, a miner repeatedly puts
    a dataset, that you can only get from downloading and running the full chain (as
    a miner does), through a mathematical function. The dataset gets used to generate
    a mixHash below a target nonce, as dictated by the block difficulty. The best
    way to do this is through trial and error.
  prefs: []
  type: TYPE_NORMAL
- en: The difficulty determines the target for the hash. The lower the target, the
    smaller the set of valid hashes. Once generated, this is incredibly easy for other
    miners and clients to verify. Even if one transaction were to change, the hash
    would be completely different, signalling fraud.
  prefs: []
  type: TYPE_NORMAL
- en: Hashing makes fraud easy to spot. Proof-of-work as a process is also a big deterrent
    preventing attacks.
  prefs: []
  type: TYPE_NORMAL
- en: 2.2.3.2 Proof-of-Work and Security
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Miners are incentivised to do their work on the main Ethereum chain. There is
    little incentive for a subset of miners to start their own chain. Blockchains
    rely on having a single state as a source of truth. The users always choose the
    longest or “heaviest” chain.
  prefs: []
  type: TYPE_NORMAL
- en: The objective of the proof-of-work is to extend the chain. The longest chain
    is most believable as the valid one because it’s had the most computational work
    done. Within Ethereum’s PoW system, it’s nearly impossible to create new blocks
    that erase transactions, create fake ones, or maintain a second chain. That’s
    because a malicious miner would need to always solve the block nonce faster than
    everyone else.
  prefs: []
  type: TYPE_NORMAL
- en: To consistently create malicious yet valid blocks, an attacker would need over
    51% of the network mining power to beat everyone else. The energy spent might
    even outweigh the gains the attacker could make in an attack.
  prefs: []
  type: TYPE_NORMAL
- en: 2.2.3.3 Finality
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A transaction in Ethereum achieves *finality* when it is included in a block
    and the block can no longer change. Since the work of the miners of Ethereum is
    decentralized, it is possible that two valid blocks can be generated at the same
    time. This creates a temporary fork. Eventually, one of these chains grows and
    becomes the accepted chain after a subsequent block has been mined and added making
    it longer.
  prefs: []
  type: TYPE_NORMAL
- en: To complicate things further, transactions rejected on the temporary fork may
    have been included in the accepted chain. This means it could get reversed. Ethereum’s
    *finality* is a reference to the time when the users do not have to wait and can
    consider a transaction immutable and irreversible. For Ethereum, the recommended
    waiting time is to wait for six blocks to be added, or just over 1 min. After
    six blocks, the users can assume with high level of confidence that the transaction
    was successful and cannot be reversed. Cautious users may decide to wait longer
    for achieving greater level of certainty.
  prefs: []
  type: TYPE_NORMAL
- en: Finality has to be taken into account in the process of designing dapps. It
    would be misleading for the users to misrepresent transaction information and
    allow the users to rely on a transaction too early, especially if the transaction
    is of high value. The finality waiting time doesn’t include the time that has
    to elapse before the transaction is chosen by a miner and is included in a block.![](../images/516136_1_En_2_Chapter/516136_1_En_2_Fig12_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: A chain diagram on Ethereum applications and workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 2.12
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum blockchain and mining
  prefs: []
  type: TYPE_NORMAL
- en: 2.2.4 Ethereum Mining
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Ethereum blockchain and mining are illustrated in Fig. [2.12](#Fig12). They
    are similar to the Bitcoin blockchain. However, there are also several differences.
    The main difference between Ethereum and Bitcoin with regard to the blockchain
    architecture is that, unlike Bitcoin, Ethereum blocks contain a copy of both the
    transaction list and the most recent state. Two other values, the block number
    and the difficulty, are also stored in the block. The basic block validation algorithm
    in Ethereum proceeds as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check if the previous block referenced exists and is valid.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check that the timestamp of the block is greater than that of the referenced
    previous block and less than 15 min into the future.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '3.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check that the block number, difficulty, transaction root, uncle root and gas
    limit (various low-level Ethereum-specific concepts) are valid.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '4.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check that the proof-of-work on the block is valid.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '5.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let S[0] be the state at the end of the previous block.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '6.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let TX be the block’s transaction list, with n transactions. For all i in 0...n-1,
    set S[i+1] = APPLY(S[i],TX[i]). If any applications returns an error, or if the
    total gas consumed in the block up until this point exceeds the GASLIMIT, return
    an error.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '7.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let S_FINAL be S[n], but adding the block reward paid to the miner.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '8.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check if the Merkle tree root of the state S_FINAL is equal to the final state
    root provided in the block header. If it is, the block is valid; otherwise, it
    is not valid.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The approach may seem inefficient, because it needs to store a copy of the entire
    state within every block. However, in practice the Ethereum efficiency turns out
    comparable to that of Bitcoin. The reason is that the state is stored in a tree
    structure, and after every new block only a small part of the tree needs to be
    adjusted. Thus, in general, the vast majority of the tree remains unchanged between
    two adjacent blocks. Therefore the data can be stored once and referenced twice
    using pointers (i.e., hashes of subtrees). A special type of tree known as a *Patricia
    tree* is used to accomplish this. It includes a modification of the Merkle tree
    concept that allows for nodes to be inserted and deleted, not only changed, efficiently.
    Besides, since all the state information is a part of the last block, there is
    no need to store the entire blockchain history—a strategy which, if it could be
    applied to Bitcoin, can be demonstrated to lead to 5–20 times saving in the storage
    space.
  prefs: []
  type: TYPE_NORMAL
- en: The process of executing contract code is a part of the definition of the state
    transition function. The latter is a part of the block validation algorithm, so
    if a transaction is added into block B the code execution spawned by that transaction
    is executed by all nodes now, and in the future, the download and validate block
    B.
  prefs: []
  type: TYPE_NORMAL
- en: 2.3 Smart Contracts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The notion of a *smart contract* was first proposed by Nick Szabo [[30](#CR30)].
    Szabo is a legal scholar and cryptographer known for ground-breaking work on the
    foundations of digital currencies. The idea of being able to record contracts
    in the form of computer code was proposed in [[30](#CR30)]. The proposed contract
    is activated automatically when certain conditions are met. This idea could potentially
    remove the need for trusted third-party companies.
  prefs: []
  type: TYPE_NORMAL
- en: In 2008, the Bitcoin cryptocurrency was developed on a blockchain network [[25](#CR25)].
    This technology enabled the development of smart contract code used to enter the
    terms of the contract into the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: In this format, contracts are converted to computer code, are stored and replicated
    on the system and supervised by the network of computers that run the blockchain.
    This results in ledger feedback such as transferring money and receiving the product
    or service.
  prefs: []
  type: TYPE_NORMAL
- en: In 2015, Ethereum was founded by Buterin [[10](#CR10)] introducing the first
    working smart contracts.
  prefs: []
  type: TYPE_NORMAL
- en: A *smart contract* is a computer program consisting of a set of rules running
    on the blockchain. The integration of blockchain technology and smart contract
    gives flexibility for developing and designing as well as implementing some of
    the real world problems.
  prefs: []
  type: TYPE_NORMAL
- en: Current smart contracts used in blockchain resemble scripts that implement conventional
    pen and paper contracts with code lines. Smart contracts execute the code when
    certain conditions are met.
  prefs: []
  type: TYPE_NORMAL
- en: Smart contracts allow new contracts to be created between two parties completely
    unknown to each other. The contract takes effect only if certain conditions are
    met. It follows that one of the main characteristics of smart contracts is that
    they facilitate the signing and execution of contracts without participation of
    middlemen.
  prefs: []
  type: TYPE_NORMAL
- en: Smart contracts are implemented on many blockchain platforms, not only on Ethereum.
    Blockchains were an ideal environment to test the idea of smart contracts.
  prefs: []
  type: TYPE_NORMAL
- en: Every smart contract is a decentralized application that executes business logic
    in response to events. Smart contract execution can result in the exchange of
    money, delivery of services, unlocking of content protected by digital rights
    management or other types of data manipulation such as changing the name on a
    land title. Smart contracts can also be used to enforce privacy protection by,
    for example, facilitating the selective release of privacy-protected data for
    specific requests.
  prefs: []
  type: TYPE_NORMAL
- en: A variety of architectures can be used for developing, distributing, managing
    and updating smart contracts. The contracts can be stored on a blockchain or other
    distributed ledger technology, and can be integrated into various payment mechanisms
    and digital exchanges that rely on Bitcoin or other cryptocurrencies.
  prefs: []
  type: TYPE_NORMAL
- en: Smart contracts are not legally binding. Their main function is to programmatically
    execute business logic that performs various tasks, processes or transactions
    that have been programmed into them to respond to a given set of conditions. Legal
    steps must be undertaken to link this execution to legally binding agreements
    between parties.
  prefs: []
  type: TYPE_NORMAL
- en: A smart contract is a computer program having self-verifying, self-executing,
    tamper-resistant properties. Smart contracts help you exchange money, property,
    shares, or anything of value in a transparent, conflict-free way while avoiding
    the services of a middleman.
  prefs: []
  type: TYPE_NORMAL
- en: Smart contracts can define the rules and penalties in an agreement in the same
    way that traditional contracts do, and also envisage actions that help to automatically
    enforce these obligations. The operations of smart contracts is more comparable
    to that of vending machine rather than legal entities. With smart contracts, you
    simply drop a Bitcoin into the vending machine (i.e., ledger) and supply your
    driver’s license, or password, or another identification for access to your account.
  prefs: []
  type: TYPE_NORMAL
- en: 2.3.1 The Definition of a Smart Contract
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *smart contract* is a program that runs on the Ethereum blockchain. It’s a
    collection of code (its functions) and data (its state) that resides at a specific
    address on the Ethereum blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: Smart contracts are a type of Ethereum account. This means that they have a
    balance and they can send transactions over the network. However, they are not
    controlled by a user, instead they are deployed to the network and run as programmed.
    User accounts can then interact with a smart contract by submitting transactions
    that execute a function defined on the smart contract. Smart contracts can define
    rules, like a regular contract, and automatically enforce them via the code. Smart
    contracts cannot be deleted by default, and interactions with them are irreversible.
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate the operation of a smart contract it may be useful to compare
    it to a vending machine. As a vending machine, the smart contract also receives
    appropriate inputs and generates certain outputs.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the process of getting a snack from a vending machine can be described
    symbolically as follows![](../images/516136_1_En_2_Chapter/516136_1_En_2_Figo_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: money Plus snack selection Equals to snack dispensed
  prefs: []
  type: TYPE_NORMAL
- en: A smart contract, like a vending machine, has logic programmed into it. Here’s
    an example of how the same vending machine can be represented as a smart contract.![](../images/516136_1_En_2_Chapter/516136_1_En_2_Figp_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: An algorithm
  prefs: []
  type: TYPE_NORMAL
- en: Vending machines remove the need for vendor employees. Likewise, smart contracts
    can replace intermediaries in many industries.
  prefs: []
  type: TYPE_NORMAL
- en: Everyone can write a smart contract and deploy it to the network. It suffices
    to learn how to code in a smart contract language and have enough ETHs to deploy
    the contract. Deploying a smart contract is technically a transaction, and so
    everyone has to pay gas for deploying smart contracts in the same way as gas is
    paid for simple ETH transfers. In practice, gas costs for contract deployment
    are much higher.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ethereum has the following developer-friendly languages for writing smart contracts:'
  prefs: []
  type: TYPE_NORMAL
- en: Solidity (the vending machine example above is written in Solidity).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vyper
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programs written in these languages must be compiled before they can be deployed
    so that Ethereum’s virtual machine can interpret and store the contract.
  prefs: []
  type: TYPE_NORMAL
- en: 2.3.2 How Does a Smart Contract Work?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The process of creating a smart contract starts with business teams working
    with developers to describe their requirements for the desired behaviour of the
    smart contract in response to various events or circumstances. Simple events could
    be conditions such as payment authorized, shipment received or a utility meter
    reading threshold. More sophisticated logic might encode more complex events such
    as calculating the value of a derivative financial instrument and processing a
    trade of the derivative, or automatically releasing an insurance payment in the
    event of a person’s death or a natural disaster.
  prefs: []
  type: TYPE_NORMAL
- en: The developers then work in a smart contract-writing platform to develop the
    logic and test it to ensure that it works as intended. After the application is
    written, it is handed over to another team for a security review. This could be
    an internal expert or a firm that specializes in verifying smart contract security.
    Once the contract has been approved, it is deployed on an existing blockchain
    or other distributed ledger infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Every deployed contract is configured to listen to event updates from an oracle,
    which is a cryptographically secured streaming data source. The smart contract
    executes once it receives an appropriate mix of events from one or more oracles.
  prefs: []
  type: TYPE_NORMAL
- en: First, the parties of the contract should determine the terms of the contract.
    After the contractual terms are completed, they are translated into programming
    code as shown in Fig. [2.13](#Fig13). The code represents a number of different
    conditional statements that describe possible scenarios for future transactions
    to occur [[11](#CR11)].![](../images/516136_1_En_2_Chapter/516136_1_En_2_Fig13_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: An illustration depicts how the text-based normal contract is converted to the
    code-based smart contract.
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 2.13
  prefs: []
  type: TYPE_NORMAL
- en: Step 1\. Transfer contract terms into code
  prefs: []
  type: TYPE_NORMAL
- en: When the code has been created, it is stored in the blockchain network and is
    replicated among the participants in the blockchain as shown in Fig. [2.14](#Fig14).![](../images/516136_1_En_2_Chapter/516136_1_En_2_Fig14_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: An illustration depicts how the code stored in the blockchain is copied by all
    participants in their replica. The contract is connected to three network images.
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 2.14
  prefs: []
  type: TYPE_NORMAL
- en: Step 2\. The code is stored in a blockchain and is copied by all participants
    in their replicas
  prefs: []
  type: TYPE_NORMAL
- en: The code is run and executed by all computers in the network. If a condition
    of the contract is satisfied and this is verified by all participants of the blockchain
    network, then the relevant transaction is executed, as shown in Fig. [2.15](#Fig15).![](../images/516136_1_En_2_Chapter/516136_1_En_2_Fig15_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: An illustration depicts when the term is satisfied, the computer in the network
    verifies its correctness. Three networks, along with contact images, are connected
    by arrows.
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 2.15
  prefs: []
  type: TYPE_NORMAL
- en: Step 3\. When a term is satisfied, computers in the network verify its correctness
  prefs: []
  type: TYPE_NORMAL
- en: For example, suppose that a user is going to rent an apartment from a landlord.
    The user can do this via blockchain by paying in cryptocurrency. The user gets
    a receipt which is held in our virtual contract. The landlord gives the user a
    digital entry key which arrives to the user by a specified date. If the key doesn’t
    arrive on time, then the smart contract can be programmed to release a refund.
    If the landlord sends the key before the rental date, the smart contract can be
    programmed to release both the fee to the landlord and the key to the user when
    the date arrives. The system can work as a collection of If-Then operators. The
    operation is observed by hundreds of people on the blockchain network. Therefore,
    all participants can expect delivery without fault. If the landlord gives the
    user a key, the landlord must be paid. If the user sends a certain amount in Bitcoins,
    then the user receives the key. The smart contract can be programmed to be cancelled
    automatically after the deadline passes. The contract code cannot be interfered
    with either by the user of by the landlord without the knowledge of other network
    nodes, since all participants in the blockchain are alerted simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: There are four basics steps in the smart contract process.
  prefs: []
  type: TYPE_NORMAL
- en: '**Coded Agreement**. Blockchain uses layers of computer coding in lieu of traditional
    paper documentation. The lines of code represent the terms of the contract and
    dictate how it will take place. This process guarantees a specific outcome dependant
    on pre-programmed conditions. Subsequently, no individual or organisation can
    change or manipulate the contract.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Events**. An event refers to a transaction taking place. Once the terms and
    conditions of an agreement have been met, the code automatically executes the
    smart contract. Smart contracts are executed by the blockchain nodes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Value Exchange**. Following the execution of the smart contract, there is
    an exchange of value. The ‘value’ is pre-determined and dependant on the use.
    This process is also automated with no human intervention necessary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Settlement**. Once the transaction or exchange has taken place, the record
    is stored on the blockchain. Due to the nature of blockchain, the transaction
    is communicated to all nodes on the peer to peer network. Therefore, the information
    cannot be tampered with or falsified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we illustrate the smart contract process with the example of a vending
    machine. The vending machine contains a variety of pre-selected products and a
    source of input for money. Operating on an algorithm, the machine is coded so
    that it will automatically produce an outcome based on a pre-programmed set of
    rules. When money is deposited and a selection is made, an item is released. For
    example, suppose that Larry inserts $1.50 into the vending machine. He selects
    B4 on the keypad, which is the number representation for a specific can of soft
    drink. The machine checks that the $1.50 matches the price of the can of soft
    drink and releases the item.
  prefs: []
  type: TYPE_NORMAL
- en: As long as the pre-specified terms are met, the contractual obligations between
    the user and the machine are fulfilled and the required operation follows.
  prefs: []
  type: TYPE_NORMAL
- en: 2.3.3 How to Write a Smart Contract?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A smart contract is a program that runs at an address on Ethereum. These programs
    comprise data and functions that can execute upon receiving a transaction. Here’s
    an overview of smart contract ingredients.
  prefs: []
  type: TYPE_NORMAL
- en: 2.3.3.1 Data
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The contract data must be assigned to a location: either to storage or memory.
    It’s costly to modify storage in a smart contract so you need to consider where
    your data should live.'
  prefs: []
  type: TYPE_NORMAL
- en: 2.3.3.2 Storage
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Persistent data* in a contract is referred to as *storage* and is represented
    by state variables. These values are stored permanently on the blockchain ledger.
    The users need to declare the type of variables so that the contract can determine
    how much storage on the blockchain ledger is required for each of the state variables
    during the compilation of the contract.![](../images/516136_1_En_2_Chapter/516136_1_En_2_Figq_HTML.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Solidity example contract Simple Storage unit stored Data State variable
  prefs: []
  type: TYPE_NORMAL
- en: 'An address type can hold an Ethereum address which is equal to 20 bytes or
    160 bits. In hexadecimal notation its value begins with a leading 0x. Other types
    include:'
  prefs: []
  type: TYPE_NORMAL
- en: boolean
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: integer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: fixed point numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: fixed-size byte arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: dynamically-sized byte arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rational and integer literals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: String literals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hexadecimal literals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enums
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2.3.3.3 Memory
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Values that are only stored for the duration of a contract function’s execution
    are called *memory variables*. They are not stored permanently on the blockchain
    and are much cheaper to use.
  prefs: []
  type: TYPE_NORMAL
- en: 2.3.3.4 Environment Variables
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In addition to the variables defined in a contract, there also exist special
    global variables. They are mainly used to provide information about the blockchain
    or current transaction.
  prefs: []
  type: TYPE_NORMAL
- en: '| Prop | State variable | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| block.timestamp | uint256 | Current block epoch timestamp |'
  prefs: []
  type: TYPE_TB
- en: '| msg.sender | address | Sender of the message (current call) |'
  prefs: []
  type: TYPE_TB
- en: 2.3.3.5 Functions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Functions can get information or set information in response to incoming transactions.
    There are two types of function calls.
  prefs: []
  type: TYPE_NORMAL
- en: internal—these don’t create an EVM call
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internal functions and state variables can only be accessed internally (i.e.
    from within the current contract or contracts deriving from it.)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: external—these do create an EVM call
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: External functions are part of the contract interface, which means they can
    be called from other contracts and via transactions. An external function f cannot
    be called internally (i.e. f() does not work, but this.f() works).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions can also be classified as public or private.
  prefs: []
  type: TYPE_NORMAL
- en: public functions can be called internally from within the contract or externally
    via messages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: private functions are only visible for the contract they are defined in and
    not in derived contracts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both functions and state variables can be made public or private.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s a function for updating a state variable on a contract.![](../images/516136_1_En_2_Chapter/516136_1_En_2_Figr_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: Solidity example function update name( string value )public dapp name equals
    to value
  prefs: []
  type: TYPE_NORMAL
- en: 'The parameter value of type string is passed into the function: update_name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s declared public, meaning anyone can access it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s not declared view, so it can modify the contract state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**View functions**: view functions promise not to modify the state of the contract’s
    data. Common examples are the “getter” functions. For example, you can use the
    following function to receive the balance of a user.![](../images/516136_1_En_2_Chapter/516136_1_En_2_Figs_HTML.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Solidity example function balance Of ( address owner )public view returns( unit
    256 balance ) return owner Pizza Count [owner]
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a list of events regarded as modifications of state:'
  prefs: []
  type: TYPE_NORMAL
- en: '1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: writing to state variables,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: emitting events,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '3.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: creating other contracts,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '4.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: using selfdestruct,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '5.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: sending Ether via calls,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '6.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: calling any function not marked view or pure,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '7.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: using low-level calls,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '8.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: using inline assembly that contains certain opcodes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Constructor functions** are only executed once when the contract is first
    deployed. Like a constructor in many class-based programming languages, these
    functions often initialize state variables to their specified values.![](../images/516136_1_En_2_Chapter/516136_1_En_2_Figt_HTML.png)'
  prefs: []
  type: TYPE_NORMAL
- en: An algorithm
  prefs: []
  type: TYPE_NORMAL
- en: '**Built-in functions**. In addition to the variables and functions you define
    on your contract, there are some special built-in functions. The most obvious
    example is: address.send() in Solidity, which allows contracts to send ETH to
    other accounts.'
  prefs: []
  type: TYPE_NORMAL
- en: '**A smart contract with line-by-line explanations**. A programming language
    is required to write smart contracts. Ethereum core contributors invented a programming
    language called Solidity to write smart contracts, which can be regarded as computer
    programs running on the blockchain. Solidity is a high-level object-oriented language
    inspired by JavaScript, C++, and Python. Solidity’s syntax is quite similar to
    JavaScript. There are other blockchains and Ethereum forks that support Solidity.
    An example of such blockchains is Tron. Solidity is not the only language that
    programmers can use to write smart contracts, but at present it is the most popular
    one.'
  prefs: []
  type: TYPE_NORMAL
- en: To write a smart contract function, the following information concerning the
    function has to be specified
  prefs: []
  type: TYPE_NORMAL
- en: parameter variables and their type, if the function accepts parameters,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: declaration of internal/external variables,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: declaration of pure/view/payable,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: returns type, if the function returns a value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A simple example of Solidity smart contract is presented below.![](../images/516136_1_En_2_Chapter/516136_1_En_2_Figu_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: An algorithm
  prefs: []
  type: TYPE_NORMAL
- en: The code above is a smart contract written in Solidity language. Next, we describe
    the action of each line of the code in this example of a smart contract.
  prefs: []
  type: TYPE_NORMAL
- en: Line 1 declares which version of the Solidity compiler can be used to compile
    the contract. In our example, any version between ![$$\ge $$](../images/516136_1_En_2_Chapter/516136_1_En_2_Chapter_TeX_IEq7.png)0.4.0
    and ![$$\le $$](../images/516136_1_En_2_Chapter/516136_1_En_2_Chapter_TeX_IEq8.png)0.7.0
    is suitable.
  prefs: []
  type: TYPE_NORMAL
- en: Line 2 declares the contract and names it as inventoryInfo. It is a normal practice
    to use the same filename as the contract name. For example, this contract will
    be saved in a file inventoryInfo.sol (.sol is the file extension for solidity
    smart contracts).
  prefs: []
  type: TYPE_NORMAL
- en: Line 3 declares a uint (unsigned integer) variable named numberInStock. This
    variable is used to store data.
  prefs: []
  type: TYPE_NORMAL
- en: Lines 4–6 add a set function, using which the value of variable numberInStock
    can be changed. Here the set function accepts a parameter *x* and stores its value
    in numberInStock. The function is marked as public, which means that it can be
    invoked by anyone.
  prefs: []
  type: TYPE_NORMAL
- en: Lines 7–9 add a get function to retrieve the value of numberInStock. This function
    is marked as a view function, which tells Solidity compiler that this is a read-only
    function. The get function also has uint returns, which means that the function
    will return a uint.
  prefs: []
  type: TYPE_NORMAL
- en: 2.3.4 What Is a Decentralized Application (DApp)?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A decentralized application (dapp) is an application built on a decentralized
    network. Dapps combine smart contracts and frontend user interfaces. Ethereum
    smart contracts are accessible and transparent like open application programming
    interfaces. Therefore, dapps can include smart contracts written by other programmers
    too. Every dapp has its backend code running on a decentralized peer-to-peer network.
  prefs: []
  type: TYPE_NORMAL
- en: A dapp can have frontend code and user interfaces written in any language (just
    like an app) to make calls to its backend. Furthermore, its frontend can be hosted
    on decentralized storage such as IPFS.
  prefs: []
  type: TYPE_NORMAL
- en: '**Decentralized** dapps operate on Ethereum, an open public decentralized platform
    where no one person or group has control.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deterministic** dapps perform the same function irrespective of the environment
    in which they get executed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Turing complete** dapps can perform any action given the required resources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Isolated** dapps are executed in a virtual environment known as Ethereum
    Virtual Machine so that if the smart contract has a bug, it won’t hamper the normal
    functioning of the blockchain network.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2.3.4.1 Benefits of DApp Development
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Zero downtime**. Once the smart contract is deployed on the blockchain, the
    network as a whole will always be able to serve clients looking to interact with
    the contract. Malicious actors, therefore, cannot launch denial-of-service attacks
    targeted towards individual dapps.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Privacy**. You don’t need to provide real-world identity to deploy or interact
    with a dapp.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resistance to censorship**. No single entity on the network can block users
    from submitting transactions, deploying dapps, or reading data from the blockchain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complete data integrity**. Data stored on the blockchain is immutable and
    indisputable, thanks to cryptographic primitives. Malicious actors cannot forge
    transactions or other data that has already been made public.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Trustless computation/verifiable behaviour**. Smart contracts can be analysed
    and are guaranteed to execute in predictable ways, without the need to trust a
    central authority. This is not true in traditional models; for example, when we
    use online banking systems, we must trust that financial institutions will not
    misuse our financial data, tamper with records, or get hacked.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2.3.4.2 Drawbacks of DApp Development
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Maintenance**. DApps can be harder to maintain because the code and data
    published to the blockchain ledger are harder to modify. It is difficult for developers
    to make updates to their dapps or to the underlying data stored by their dapps
    after they are deployed, even if bugs or security risks are identified in a previous
    version.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance overhead**. There is a huge performance overhead and scaling
    up is really difficult. To achieve the level of security, integrity, transparency,
    and reliability that Ethereum aspires to, every node runs and stores every transaction.
    On top of this, proof-of-work takes time as well. Therefore, many dapp calculations
    impose an overhead of approximately ![$$10^6\times $$](../images/516136_1_En_2_Chapter/516136_1_En_2_Chapter_TeX_IEq9.png)
    that of a standard computation in ordinary apps.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Network congestion**. When one dapp uses too many computational resources,
    the entire network gets backed up. Currently, the network can only process about
    10–15 transactions per second; if transactions are being sent in faster than this,
    the pool of unconfirmed transactions can quickly balloon.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User experience**. It may be harder to engineer user-friendly experiences
    because the average end-user might find it too difficult to set up a tool stack
    necessary to interact with the blockchain in a truly secure fashion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Centralization**. User-friendly and developer-friendly solutions built on
    top of the base layer of Ethereum might end up looking like centralized services
    anyway. For example, such services may store keys or other sensitive information
    server-side, serve a frontend using a centralized server, or run important business
    logic on a centralized server before writing to the blockchain. The resulting
    centralization can eliminate many if not all of the advantages of blockchain over
    traditional models.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2.3.5 Limitations and Future Developments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Smart contracts do not perfectly solve all problems of the conventional contracts.
    In particular, they cannot retrieve current information from outside of the blockchain
    ledger. Therefore, the users might encounter problems when certain information
    is necessary during the process of verifying whether smart contract conditions
    are met. For example, suppose that there is a contract with the following condition:
    “If the price of ETH rises above $1000, A provides B with 1 ETH.” Here, the smart
    contract only functions if the information on whether the price of Ethereum is
    over $1000 or is below. Therefore, the contract is only executable when the cryptocurrency
    exchange’s accurate Ethereum price data is retrieved, which lies outside the blockchain
    ledger.'
  prefs: []
  type: TYPE_NORMAL
- en: During the retrieval process, wrong data may be retrieved or the data may be
    intentionally altered. In other words, specific information about a specific condition
    needs to be retrieved, and if this information is dependent on a third party,
    this inevitably leads to a credibility issue. To resolve this inherent issue,
    many start-ups are striving to provide accurate information necessary for generating
    and executing smart contracts.
  prefs: []
  type: TYPE_NORMAL
- en: Another inherent limitation of smart contracts is that they are not editable
    once they have been distributed. On the one hand, it is this rigidity that makes
    the smart contracts safe and reliable. On the other hand, this can turn into a
    potential weakness that can be exploited. There have been cases where smart contracts
    have been hacked or become permanently dysfunctional because of this characteristic,
    the most prominent case being SmartMesh. The smart contract distributed by the
    SmartMesh team contained a security flaw, and the hacker used it to issue/sell
    additional tokens. Also, there was a case where the security flaw resulted in
    513.774.16ETH contained in wallets became permanently non-withdrawable.
  prefs: []
  type: TYPE_NORMAL
- en: Smart contracts handle digital currencies directly. Therefore, safety is paramount
    when developing smart contracts. In the blockchain industry, it is becoming a
    standard procedure to conduct a security audit before distribution. Special security
    audits may need to be carried out in order to ensure security guarantees provided
    by the smart contracts.
  prefs: []
  type: TYPE_NORMAL
- en: The potential of smart contracts extends beyond the simple transfers of cryptocurrencies,
    since smart contracts are much more complex. They can execute transactions in
    a wide range of fields, from legal processes to insurance premiums to crowdfunding
    agreements to financial derivatives. Smart contracts have the potential to disintermediate
    the legal and financial fields by simplifying and automating routine and repetitive
    processes for which people currently pay banks and lawyers sizable fees.
  prefs: []
  type: TYPE_NORMAL
- en: The role of lawyers could also be adapted in the future as smart contracts gain
    extensive capabilities and can contribute to the functioning of traditional legal
    agreements and customizable smart contract templates. In addition, smart contracts’
    ability not only to automate processes, but also to control behaviour, as well
    as their potential for real-time auditing and risk assessments, can be beneficial
    for compliance.
  prefs: []
  type: TYPE_NORMAL
- en: Smart contracts also show promise in automating processes that run on IoT and
    edge computing devices. For example, a utility company might offer a service in
    which smart contracts execute in response to changes in power rates in coordination
    with devices built into power meters. For example, when prices reach a given threshold,
    a smart contract might automatically turn off or turn down power-hungry appliances
    such as air conditioners using a specially controlled IoT controller.
  prefs: []
  type: TYPE_NORMAL
- en: It may be also possible to integrate smart contracts into vending machines that
    could release goods in response to cryptocurrency payments.
  prefs: []
  type: TYPE_NORMAL
- en: In a supply chain scenario, smart contracts might unlock funds once a cargo
    container has arrived at its destination and IoT sensors indicate that it has
    remained unopened and the contents have been kept at the right temperature and
    appropriate humidity.
  prefs: []
  type: TYPE_NORMAL
- en: 2.4 Blockchain Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There exist various and sometimes conflicting categorisations of blockchain
    types. This section concentrates on the classification of blockchain systems according
    to their type of authorisation required for the network nodes acting as verifiers.
    Blockchain systems can be divided into three main categories represented in Fig. [2.16](#Fig16).![](../images/516136_1_En_2_Chapter/516136_1_En_2_Fig16_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: A Venn diagram has public in circle one, and private and consortium in circle
    two. The intersection has Hybrid. The first circle is titled permissionless and
    the second one as permissioned.
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 2.16
  prefs: []
  type: TYPE_NORMAL
- en: Three main blockchain types
  prefs: []
  type: TYPE_NORMAL
- en: '**Permissionless blockchains**, where anyone can participate in the verification
    process, i.e., no prior authorisation is required. All users can participate in
    the consensus procedure, for example, by contributing their computational resources,
    usually in return for a monetary reward.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Permissioned blockchains**, where verification nodes are preselected by a
    central authority or consortium.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hybrid blockchains**, which combine certain features of permissionless and
    permissioned blockchains.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In reality, most permissionless blockchains offer facilities for a public access,
    while the intention of most permissioned blockchains is to restrict data access
    to the company or consortium of companies operating the blockchain. For this reason,
    next we look at the major categories of blockchains, permissioned and permissionless
    blockchains, and elaborate on the distinctions between them in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: 2.4.1 Permissionless Blockchains
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The original instance of a cryptocurrency, the Bitcoin network, achieved high
    popularity by using a permissionless blockchain. The word ‘permission’ refers
    to the authorisation of nodes for verification. In a permissionless blockchain,
    everyone is permitted to join the network to be a verifier without obtaining any
    prior permission for performing such network tasks. The actions of verifiers are
    vitally important to the operation of the network, and so their participation
    is encouraged by issuing new currency which is paid to their accounts when the
    verifiers complete their confirmation of blocks with transactions.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of a permissionless blockchain [[29](#CR29)] is that it can accommodate
    anonymous or pseudonymous actors and protect against a Sybil (i.e., identity-forging)
    attack [[13](#CR13)]. On the other hand, the incentive mechanism has to be carefully
    developed in order to ensure that verifiers are properly stimulated to participate
    in the work of the system. For example, in Bitcoin the verifiers receive an amount
    for verifying each transaction, as well as for publishing a block of transactions.
    However, the latter incentive is two orders of magnitude higher than the former
    reward. Since the incentive for publishing transactions of blocks decreases according
    to a predefined schedule, it follows that the verifiers after a period of time
    have to increase the amount they charge for processing individual transactions.
    This makes the Bitcoin transactions more costly.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to Bitcoin, there are many other examples of permissionless blockchains
    including Ethereum. The Ethereum platform offers blockchain as a service and provides
    access to smart contracts on its blockchain. Other examples of permissionless
    blockchains are presented in [[3](#CR3), [7](#CR7), [22](#CR22)]. Novel results
    on permissionless blockchains have also appeared, for instance, in [[17](#CR17)–[19](#CR19)].
  prefs: []
  type: TYPE_NORMAL
- en: 2.4.2 Permissioned Blockchains
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Even though permissionless blockchains are highly popular, they are not the
    only possible configuration for a blockchain system. Permissioned blockchains
    engage a set of trusted parties to carry out verification. Additional verifiers
    can be added only after their approval based on the agreement of the current members
    or a central authority. This configuration with centralised permissions is more
    similar to a traditional finance setting, which operates a Know Your Business
    (KYB) or Know Your Client (KYC) procedure to whitelist users that are allowed
    to undertake operations in a particular space. The paper [[29](#CR29)] explains
    that permissionless and permissioned blockchains are fundamentally different in
    both their operation and the range of activities that they enable. Next, we review
    their major differences.
  prefs: []
  type: TYPE_NORMAL
- en: Permissioned blockchains are intended to be built for specific purposes. They
    can be created to maintain compatibility with already existing applications, for
    example, financial applications. Permissioned blockchains can be fully *private*,
    where permissions to write data belong to the owner or the managing organisation.
    Alternatively, they can be consortium blockchains, where the consensus process
    is controlled by a pre-selected set of nodes in a consortium.
  prefs: []
  type: TYPE_NORMAL
- en: Since all the acting nodes in a permissioned blockchain are pre-approved and
    are known, it is natural to expect that they are personally accountable for their
    activity and behaviour on the network. As far as the transactions handled by these
    blockchains are concerned, usually they mainly deal with off-chain assets such
    as digital representations of securities, fiat currencies and titles of ownership,
    rather than on-chain assets, such as virtual currency tokens [[29](#CR29)].
  prefs: []
  type: TYPE_NORMAL
- en: An advantage of a permissioned blockchain is its scalability. In a permissionless
    blockchain, the data is stored on every computer in the network, and all nodes
    verify all transactions. It is obvious that once the number of transactions increases
    substantially, the ability of the users to perform this type of processing and
    verification decreases. This may lead to a higher degree of centralisation, since
    the verification process becomes more challenging. In a permissioned blockchain,
    only a smaller number of preselected participants need to function as verifiers.
    Even in the case where the verifiers are chosen in a large institution, they can
    upgrade their computing power to comply with the increasing requirements that
    depend on in the number of transactions.
  prefs: []
  type: TYPE_NORMAL
- en: In a permissioned blockchain, the number of potential verifiers and possible
    participants is smaller. Therefore, it is much easier for a group of the users
    to collaborate and alter the rules or revert transactions as required. In addition,
    it is easy for them to reject transactions. This means that permissioned blockchains
    cannot resist censorship as well as permissionless blockchains can do.
  prefs: []
  type: TYPE_NORMAL
- en: 2.4.2.1 Private Blockchains
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Private blockchains can also be referred to as managed blockchains. They are
    permissioned blockchains controlled by a single owner or organization. Every private
    blockchain has a central authority determining who is allowed to join as a node.
    The central authority also does not necessarily grant each node equal rights for
    performing the blockchain functions. Private blockchains are only partially decentralized
    because public access to these blockchains is restricted. Examples of private
    blockchains include the business-to-business virtual currency exchange network
    Ripple and Hyperledger, an umbrella project of open-source blockchain applications.
  prefs: []
  type: TYPE_NORMAL
- en: The characteristics of private blockchain imply that the owner of the blockchain
    has the highest authority and may have the ability to change information stored
    in the ledger. Private blockchain is applied to more closed networks such as the
    intranet of an organisation. New contributions developing private blockchains
    have appeared, for example, in [[4](#CR4), [5](#CR5), [8](#CR8)].
  prefs: []
  type: TYPE_NORMAL
- en: Both private and public blockchains have their drawbacks. Public blockchains
    tend to have longer validation times for new data items in comparison to private
    blockchains. Private blockchains are more vulnerable to data censorship and potential
    attacks from misbehaving administrative actors. Consortium and hybrid blockchains
    were developed to address these shortcomings.
  prefs: []
  type: TYPE_NORMAL
- en: 2.4.2.2 Consortium Blockchains
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Consortium blockchains are permissioned blockchains governed by a group of organizations,
    rather than one entity, as in the case of the private blockchains. Therefore,
    consortium blockchains enjoy broader decentralization as compared to private blockchains.
    This results in higher levels of security. However, the process of setting up
    a consortium blockchain can be fraught with difficulties, since it requires the
    cooperation of a number of organizations, which may present logistical challenges
    as well as a potential risk of creating an antitrust.
  prefs: []
  type: TYPE_NORMAL
- en: Further, some members of a consortium blockchain may not possess the required
    technology or infrastructure to implement essential blockchain tools. Other members
    may decide that the upfront costs are too expensive for attempting to digitize
    their data and connect to other members of the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: Consortium blockchains can be used, for example, for managing e-learning educational
    records [[2](#CR2)], agricultural supply chains [[15](#CR15)], medical information
    sharing [[14](#CR14)], anonymous handover authentication in wireless networks [[23](#CR23)],
    protected data sharing in health information systems [[27](#CR27)] and General
    Data Protection Regulation compliance data sharing [[26](#CR26)]. New investigations
    of consortium blockchains and their applications have been conducted, for example,
    in [[1](#CR1), [20](#CR20), [21](#CR21)].
  prefs: []
  type: TYPE_NORMAL
- en: 2.4.3 Hybrid Blockchains
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Hybrid blockchains are blockchains that combine several features of different
    categories of blockchains. They may be controlled by a single organization, but
    with a level of oversight undertaken by a typical public blockchain, which is
    required to perform certain transaction validations. An example of a hybrid blockchain
    is the IBM Food Trust, which was developed to improve the efficiency and throughout
    of a whole food supply chain.
  prefs: []
  type: TYPE_NORMAL
- en: Recently, hybrid blockchains have been used, for example, for healthcare monitoring
    and recommendation systems [[28](#CR28)], organising auctions [[9](#CR9)], identity
    management [[6](#CR6)], accountable federated learning [[12](#CR12)], energy applications
    [[16](#CR16)], separation of basic data and business data [[24](#CR24)].
  prefs: []
  type: TYPE_NORMAL
