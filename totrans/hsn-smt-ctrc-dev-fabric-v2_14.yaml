- en: Chapter 9\. Hyperledger Fabric V2 Integration
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第九章 Hyperledger Fabric V2 集成
- en: Since Hyperledger Fabric v1.0.0 released in 2017, many minor versions have been
    rolled out for Fabric v1.*x* (1.1, 1.2, 1.3, 1.4). As an open source, permissioned
    distributed ledger, Hyperledger Fabric has quickly become one of the most popular
    enterprise blockchain frameworks, adopted by many organizations from small businesses
    to enterprises worldwide. The major cloud vendors—including AWS, IBM, and Oracle—have
    included Fabric in their blockchain cloud services, as you saw in [Chapter 8](ch08.xhtml#deploying_hyperledger_fabric_on_the_clo).
    Fabric’s benefits and popularity stem from its powerful architecture for building
    enterprise blockchain applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 自 2017 年发布 Hyperledger Fabric v1.0.0 以来，Fabric v1.*x*（1.1、1.2、1.3、1.4）已经推出了许多次小版本。作为一个开源的、具有权限的分布式账本，Hyperledger
    Fabric 迅速成为了最受欢迎的企业级区块链框架之一，被从小型企业到全球企业的许多组织所采用。主要的云服务供应商——包括 AWS、IBM 和 Oracle——已经将
    Fabric 纳入了他们的区块链云服务中，就像你在[第 8 章](ch08.xhtml#deploying_hyperledger_fabric_on_the_clo)中所看到的那样。Fabric
    的益处和受欢迎程度源于其强大的企业级区块链应用架构。
- en: In 2020, the Hyperledger Community released Hyperledger Fabric v2, bringing
    many improvements over v1\. This significant milestone has boosted the adoption
    of enterprise blockchains and enhanced the efficiency and security of production
    deployments.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在 2020 年，Hyperledger 社区发布了 Hyperledger Fabric v2，带来了许多改进，超越了 v1。这个重要的里程碑推动了企业区块链的采用，并增强了生产部署的效率和安全性。
- en: 'This chapter will help you understand the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将帮助您了解以下内容：
- en: New features of Hyperledger Fabric v2
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hyperledger Fabric v2 的新功能
- en: Updating the capability level of a channel
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新通道的能力级别
- en: Upgrading components
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件升级
- en: Considerations for getting to v2
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进入 v2 的考虑因素
- en: New Features of Hyperledger Fabric V2
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Hyperledger Fabric V2 的新特性
- en: Hyperledger Fabric version 2, or v2, builds on what the community has learned
    in the past four years, delivering several new features and improvements that
    have made v2 shine as a production-ready enterprise blockchain. The new features
    of Hyperledger Fabric 2.0 include support for enhanced governance around smart
    contracts, improvements in chaincode life cycle management, introduction of a
    new raft consensus mechanism, new patterns for working with and sharing private
    data, and stronger token support. Let’s explore these features.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Hyperledger Fabric 版本 2，或者简称 v2，建立在社区在过去四年中所学到的基础之上，提供了几项新功能和改进，使得 v2 成为了一个可用于生产环境的企业级区块链。Hyperledger
    Fabric 2.0 的新功能包括增强的智能合约治理支持、链码生命周期管理的改进、引入了新的 raft 共识机制、处理和共享私有数据的新模式，以及更强大的令牌支持。让我们来探索这些特性。
- en: Decentralized Governance for Smart Contracts
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 智能合约的去中心化治理
- en: 'Prior to v2, the chaincode life cycle process was composed of these steps:
    package, install, and instantiate. If multiple organization participants own the
    same chaincode, the packaging step is needed. Only one organization is required
    to install chaincode, with an optional instantiation policy. The chaincode is
    installed on endorsing peer nodes of chaincode owners. With signed packaged chaincode,
    chaincode can be instantiated and sent to other owners for inspection and signing.
    When other peers refuse to install the chaincode, the original owner will not
    be able to execute the chaincode, but still can validate and commit the transactions.
    Once chaincode gets installed, chaincode is not yet in the channel since it is
    not instantiated to the channel. When the selected peer performs chaincode instantiation,
    the instantiate transaction invokes the life cycle system chaincode (LCSC). The
    chaincode enters the active state and can be executed on the channel.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在 v2 之前，链码生命周期流程包括以下步骤：打包、安装和实例化。如果多个组织参与拥有相同的链码，就需要进行打包步骤。只需要一个组织安装链码，并可选地指定实例化策略。链码安装在链码所有者的背书节点上。通过签名的打包链码，可以实例化链码并发送给其他所有者进行检查和签名。当其他节点拒绝安装链码时，原始所有者将无法执行链码，但仍可验证和提交交易。一旦链码安装完成，链码尚未进入通道，因为尚未实例化到通道中。当选定的节点执行链码实例化时，实例化交易将调用生命周期系统链码（LCSC）。链码进入活动状态，可以在通道上执行。
- en: '[Figure 9-1](#hyperledger_fabric_onedotfour_chaincode) shows the Hyperledger
    Fabric 1.4 chaincode life-cycle operation.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 9-1](#hyperledger_fabric_onedotfour_chaincode) 展示了 Hyperledger Fabric 1.4
    链码的生命周期操作。'
- en: '![Hyperledger Fabric 1.4 chaincode life cycle operation](Images/HLF_0901.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![Hyperledger Fabric 1.4 链码生命周期操作](Images/HLF_0901.png)'
- en: Figure 9-1\. Hyperledger Fabric 1.4 chaincode life cycle operation
  id: totrans-14
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 9-1\. Hyperledger Fabric 1.4 链码生命周期操作
- en: 'One major drawback in this chaincode life cycle operation was chaincode governance:
    only one organization had to instantiate, write, deploy, and update chaincode
    for all the peers in the network. This centralized process limits other organizations
    from participating in chaincode governance.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在此链码生命周期操作中的一个主要缺点是链码治理：只有一个组织需要实例化、编写、部署和更新所有网络中的链码。这一中心化的过程限制了其他组织参与链码治理。
- en: Hyperledger Fabric v2 introduces decentralized governance for the chaincode
    life cycle. Instead of instantiating by one organization, the new process requires
    multiple organizations to agree to the parameters of a chaincode and approve how
    it will be operated on the channel. This more democratic process has significantly
    improved security across the network. For example, approval of the chaincode definition
    in a two-organization network is required for both channel members before chaincode
    can be committed to the channel.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Hyperledger Fabric v2为链码生命周期引入了分散治理。新流程要求多个组织同意链码的参数，并批准它在通道上的操作方式，而不是由单一组织实例化。这一更为民主的流程显著提高了网络安全性。例如，在一个由两个组织组成的网络中，需要所有通道成员批准链码定义后，才能将链码提交到通道。
- en: '[Figure 9-2](#hyperledger_fabric_two_chaincode_life_c) shows the Hyperledger
    Fabric v2 chaincode life-cycle operation.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '[图9-2](#hyperledger_fabric_two_chaincode_life_c)展示了Hyperledger Fabric v2链码生命周期操作。'
- en: '![Hyperledger Fabric 2 chaincode life-cycle operation](Images/HLF_0902.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![Hyperledger Fabric 2 chaincode life-cycle operation](Images/HLF_0902.png)'
- en: Figure 9-2\. Hyperledger Fabric 2 chaincode life-cycle operation
  id: totrans-19
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9-2\. Hyperledger Fabric 2链码生命周期操作
- en: 'In comparison with 1.4, the new life cycle eliminates the instantiate step
    and replaces it with two new steps: approving the chaincode (which is done by
    all organization members) and committing the chaincode definition.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 与1.4版本相比，新的生命周期取消了实例化步骤，并用两个新步骤替换：批准链码（由所有组织成员执行）和提交链码定义。
- en: 'Here is a list of `peer` commands for chaincode initialization:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是用于链码初始化的`peer`命令列表：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In [Chapter 7](ch07.xhtml#building_supply_chain_dapps_with_hyperl), we walked
    through the entire chaincode operation process; let’s quickly review how the chaincode
    life-cycle endorsement policy is defined in the configuration.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](ch07.xhtml#building_supply_chain_dapps_with_hyperl)中，我们详细介绍了整个链码操作过程；让我们快速回顾一下如何在配置中定义链码生命周期背书策略。
- en: 'Open *configtx.yaml* under the project *configtx* folder. The `Application`
    section defines the values to encode into a config transaction or block for application-related
    parameters:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 打开项目*configtx*文件夹下的*configtx.yaml*。`Application`部分定义了用于将值编码为配置交易或区块以用于应用相关参数的值：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here you can define the types of life-cycle endorsement policies. In our case,
    we define governance as `MAJORITY Endorsement`. This `MAJORITY Endorsement` policy
    will be used as the default if an endorsement policy is not explicitly specified.
    It requires a majority of peers to participate in the chaincode transaction validation
    and execution in the channel and to commit the transaction to the ledger.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以定义生命周期背书策略的类型。在我们的案例中，我们将治理定义为`MAJORITY Endorsement`。如果未明确指定背书策略，则将使用此`MAJORITY
    Endorsement`策略作为默认策略。它要求大多数对等节点参与通道中的链码交易验证和执行，并将交易提交到账本。
- en: 'We use the channel configuration to define our supply chain endorsement policy.
    You can also explicitly specify a signature policy for the endorsement; for example,
    the following command will require that a member of both `Org1` and `Org2` sign
    the transaction:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用通道配置来定义我们的供应链认可策略。您还可以明确指定认可的签名策略；例如，以下命令将要求 `Org1` 和 `Org2` 的成员签署交易：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Channel configuration policies in *configtx.yaml* can be customized or overridden
    by editing the file *configtx.yaml* for a specific channel. Channel configuration
    policies in *configtx.yaml* can be customized or overridden by editing the file
    for a specific channel when we need to update the config value.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *configtx.yaml* 中的通道配置策略可以通过编辑特定通道的文件 *configtx.yaml* 进行自定义或覆盖。在需要更新配置值时，可以通过编辑特定通道的文件来自定义或覆盖
    *configtx.yaml* 中的通道配置策略。
- en: New Chaincode Application Patterns
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新的链码应用模式
- en: 'As discussed in the previous section, the new chaincode decentralized life-cycle
    management will apply in chaincode operation. This will ensure that multiple organizations
    must agree to the parameters of a chaincode and approve how it will be operated
    on the channel. The new chaincode application patterns will allow the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，新的链码去中心化生命周期管理将应用于链码操作。这将确保多个组织必须同意链码的参数并批准它将如何在通道上运行。新的链码应用模式将允许以下操作：
- en: Automated checks
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化检查
- en: Organizations can automate checks and validate additional chaincode information
    before submitting a transaction proposal request to the orderer service.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 组织可以自动化检查并在向订购服务提交交易提案请求之前验证附加的链码信息。
- en: Decentralized agreement
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 去中心化协议
- en: Personal decisions can be modeled on a chaincode process that requires several
    transactions. Based on the defined ledger transaction policy, the chaincode may
    need different organizations to agree to process the transaction. Once all the
    individual transactors are met and verified by a final chaincode proposal, the
    business transaction is finalized across all channel members.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 个人决策可以建模为一个需要多个交易的链码过程。根据定义的分类账交易策略，链码可能需要不同的组织同意处理该交易。一旦所有个体交易者都得到满足，并由最终的链码提案验证通过，业务交易就会在所有通道成员之间最终确定。
- en: Private Data Enhancements
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 私密数据增强
- en: In a centralized application, the superuser can view all the database data and
    grant selected members permission to access it. In the blockchain network, the
    transaction data is stored in the ledger, which is shared with all participants.
    Prior to v2, in order to keep data private from other organizations on the channel,
    we had to create a new channel that consisted of the organizations requiring data
    access.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在集中式应用程序中，超级用户可以查看所有数据库数据，并授予选定的成员访问权限。在区块链网络中，交易数据存储在分类账中，该分类账与所有参与者共享。在 v2
    之前，为了使数据免受通道上其他组织的影响，我们必须创建一个新的通道，其中包含需要访问数据的组织。
- en: 'Today, Hyperledger Fabric MSP will ensure the privacy of all members of the
    network. MSP provides an abstraction of membership operations and defines the
    rules of how memberships are governed and authenticated. Fabric has three types
    of MSPs:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，Hyperledger Fabric MSP 将确保网络中所有成员的隐私。MSP 提供了成员操作的抽象，并定义了成员资格如何受到管理和认证的规则。Fabric
    有三种类型的 MSP：
- en: Network MSP
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 网络 MSP
- en: Defines members in the network
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 定义网络中的成员
- en: Channel MSP
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 通道 MSP
- en: Defines who can participate in certain actions on a given channel according
    to channel policies
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 根据通道策略定义谁可以参与给定通道上的某些操作
- en: Peer/orderer MSP
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 对等方/订购者 MSP
- en: The local MSP for a single peer or orderer, for identifying members of the same
    organization
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对于单个对等方或订购者的本地 MSP，用于识别同一组织的成员
- en: In building our supply chain DApps example, we have manufacturer, wholesaler,
    and pharmacy organizations in the blockchain. They share all device ownership
    transition data in the ledger by creating a channel from the manufacturer to the
    pharmacy. In [Figure 9-3](#channel_one_ledger_data_for_three_organ), we can see
    that all three organizations can view that channel 1 ledger data.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建我们的供应链 DApps 示例中，我们在区块链中有制造商、批发商和药房组织。它们通过创建从制造商到药房的通道来共享所有设备所有权转移数据。在 [图
    9-3](#channel_one_ledger_data_for_three_organ) 中，我们可以看到所有三个组织都可以查看该通道 1 的账本数据。
- en: '![Channel 1 ledger data for three organizations](Images/HLF_0903.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![三个组织的通道 1 账本数据](Images/HLF_0903.png)'
- en: Figure 9-3\. Channel 1 ledger data for three organizations
  id: totrans-47
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 9-3。三个组织的通道 1 账本数据
- en: After completing a trade with the manufacturer, the wholesaler may also want
    to keep the trade’s confidential data from the pharmacy. They can create channel
    2, in which the pharmacy can’t see transactions.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 与制造商完成交易后，批发商还可能希望向药房保留交易的机密数据。他们可以创建通道 2，在该通道中药房无法看到交易。
- en: The wholesaler may also want to have a private data relationship with the pharmacy,
    so they create channel 3\. Similarly, the manufacturer can’t see transactions
    in channel 3.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 批发商可能还想与药房建立私密数据关系，因此他们创建了通道 3。同样，制造商无法看到通道 3 中的交易。
- en: The channel design is elegant, providing a subnetwork to keep all transactions
    confidential within a set of organizations. However, this design has some downsides.
    First, it requires additional administrative overhead (to create a channel, deploy
    chaincode, update policies and MSPs, etc.). Second, it doesn’t allow all channel
    participants to see the transaction data, but keeps partial data privacy for selected
    members. Third, when many members (hundreds) participate in the consortium network,
    those members could create a large number of channels in the network. This will
    make the network become very complex and hard to maintain, and tracking communications
    will be difficult.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 通道设计非常优雅，提供了一个子网络，可以在一组组织内保持所有交易的机密性。然而，这种设计也有一些缺点。首先，它需要额外的管理开销（创建通道、部署链码、更新策略和
    MSPs 等）。其次，它不允许所有通道参与者看到交易数据，而是为选定的成员保留了部分数据隐私。第三，当许多成员（数百人）参与联盟网络时，这些成员可能在网络中创建大量的通道。这将使网络变得非常复杂和难以维护，并且跟踪通信将变得困难。
- en: 'Instead of creating many multiple channels, Hyperledger Fabric v2 offers enhanced
    private data collection or policy configuration by introducing a new endorsement
    policy. Fabric can create private data collections on a peer node, sometimes called
    a *SideDB*, which can be shared with selected peers. Private data collections
    have two elements: the actual private data and a hash of private data.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Hyperledger Fabric v2 不是创建多个频道，而是通过引入新的背书策略提供增强的私有数据集或策略配置。Fabric 可以在对等节点上创建私有数据集，有时称为*SideDB*，可以与选定的对等方共享。私有数据集有两个元素：实际的私有数据和私有数据的哈希值。
- en: The *actual private data* is sent between authorized peers through the gossip
    data dissemination protocol. Each gossiped message is signed, and other unauthorized
    peers will be prevented from seeing the message. The data is stored in a SideDB.
    This process does not involve an ordering service, which may be controlled by
    an unauthorized organization.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*实际的私有数据*通过允许的对等方之间通过八卦数据传播协议发送。每个传播的消息都经过签名，其他未经授权的对等方将被阻止看到该消息。数据存储在一个 SideDB
    中。这个过程不涉及排序服务，该服务可能由一个未经授权的组织控制。'
- en: '[Figure 9-4](#how_public_data_and_a_private_data_coll) shows how public data
    and a private data collection are stored in a peer node.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 9-4](#how_public_data_and_a_private_data_coll) 展示了公共数据和私有数据集如何存储在对等节点中。'
- en: '![How public data and a private data collection are stored in a peer node](Images/HLF_0904.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![公共数据和私有数据集如何存储在对等节点中](Images/HLF_0904.png)'
- en: Figure 9-4\. How public data and a private data collection are stored in a peer
    node
  id: totrans-55
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 9-4\. 公共数据和私有数据集如何存储在对等节点中
- en: Public block storage contains transaction logs for each channel and public world-state
    data. The world state keeps the current state of data. Channel members can view
    this data. The endorsed transaction logs are stored in blocks linked in sequence
    with the hashing mechanism.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 公共块存储包含每个通道的交易日志和公共世界状态数据。世界状态保持数据的当前状态。通道成员可以查看此数据。背书交易日志存储在通过哈希机制按顺序链接的块中。
- en: Private block storage consists of private `writeSet` storage, a private state
    database, and a transient store. Private `writeSet` stores a number of private
    data collections, and all private historical transactions for each private data
    collection. A private state database is world-state storage that keeps the current
    state of private data collections. The transient store is used to store temporally
    private data during a transaction invocation process. The transient data is used
    to determine whether a peer has already received the private data at chaincode
    endorsement time.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 私有块存储由私有`writeSet`存储、私有状态数据库和临时存储组成。私有`writeSet`存储了许多私有数据收集以及每个私有数据收集的所有私有历史交易。私有状态数据库是保存私有数据收集当前状态的全球状态存储。临时存储用于在事务调用过程中存储临时私有数据。临时数据用于确定对等方在链码背书时间是否已经接收到私有数据。
- en: After the orderer validates the transactions, the *hash of private data* is
    packaged into blocks and written to the ledger. The cryptographic hash serves
    as evidence of the transaction and allows authorized organizations in the channel
    to endorse, commit, or query private data.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 订单者验证交易后，私有数据的*哈希值*被打包进块并写入总账。密码哈希作为交易的证据，并允许通道中的授权组织背书、提交或查询私有数据。
- en: In our supply chain example, all the three peers have the private state database
    instance for each related private collection. The private data between manufacturer
    and wholesaler is privately managed by `Org1`’s peer and `Org2`’s peer only. Similarly,
    `Org2`’s peer and `Org3`’s peer will maintain wholesaler and pharmacy private
    data collections. [Figure 9-5](#three_peers_with_two_collections_of_pri) illustrates
    these three peers with two collections of private data on the same channel.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的供应链示例中，所有三个对等方都为每个相关的私有收集拥有私有状态数据库实例。制造商和批发商之间的私有数据仅由`Org1`的对等方和`Org2`的对等方私下管理。同样，`Org2`的对等方和`Org3`的对等方将维护批发商和药店的私有数据收集。[图9-5](#three_peers_with_two_collections_of_pri)展示了这三个对等方在同一通道上具有两个私有数据收集的情况。
- en: '![Three peers with two collections of private data on the same channel](Images/HLF_0905.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![同一通道上具有两个私有数据收集的三个对等方](Images/HLF_0905.png)'
- en: Figure 9-5\. Three peers with two collections of private data on the same channel
  id: totrans-61
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9-5\. 同一通道上具有两个私有数据收集的三个对等方
- en: To understand how Fabric private data works, let’s look at how a transaction
    flow gets performed in the transaction life cycle. [Figure 9-6](#the_end_to_end_system_flow_for_processi)
    depicts the end-to-end system flow for processing a private data transaction in
    Hyperledger Fabric v2.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解 Fabric 私有数据的工作原理，让我们看看事务周期中如何执行事务流程。[图 9-6](#the_end_to_end_system_flow_for_processi)
    描述了在 Hyperledger Fabric v2 中处理私有数据交易的端到端系统流程。
- en: '![The end-to-end system flow for processing a private data transaction in Hyperledger
    Fabric v2](Images/HLF_0906.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![在 Hyperledger Fabric v2 中处理私有数据交易的端到端系统流程](Images/HLF_0906.png)'
- en: Figure 9-6\. The end-to-end system flow for processing a private data transaction
    in Hyperledger Fabric v2
  id: totrans-64
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 9-6。在 Hyperledger Fabric v2 中处理私有数据交易的端到端系统流程
- en: 'Here are the steps of the flow:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是流程的步骤：
- en: The client initiates a transaction by sending a transaction proposal request
    with private data to endorsing peers. Those endorsing peers are authorized organizations
    for private data collections.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端通过向背书节点发送带有私有数据的交易提案请求来启动交易。这些背书节点是私有数据集的授权组织。
- en: The endorsing peers simulate the transaction by using a local copy of private
    data in a transient data store to execute the chaincode. This chaincode execution
    distributes the private data to authorized peers via gossip and sends back the
    results to the application.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 背书节点通过使用暂时数据存储中的私有数据的本地副本来模拟交易，以执行链码。此链码执行通过八卦协议将私有数据分发给授权节点，并将结果发送回应用程序。
- en: At this point, the client application combines the transaction along with the
    endorsements (including the proposal response with the private data hashes) and
    broadcasts it to the ordering service. The private data hashes are distributed
    to all peers. Without knowing the actual private data, all peers on the channel
    can be involved in transaction validation in a consistent way.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此时，客户端应用程序将交易与背书（包括带有私有数据哈希的提案响应）组合起来，并将其广播到排序服务。私有数据哈希将分发给所有节点。在不知道实际私有数据的情况下，通道上的所有节点可以以一致的方式参与交易验证。
- en: Finally, authorized peers check the collection policy to make sure the client
    has permission to access the private data. If authorized peers don’t have private
    data in the local transient data store, they will pull data from other authorized
    peers to get the private data.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，授权节点检查收集策略，以确保客户端有权限访问私有数据。如果授权节点在本地暂时数据存储中没有私有数据，则它们将从其他授权节点拉取数据以获取私有数据。
- en: Once the private data is validated against the hashes in the public block, the
    transaction will be committed in the block. The private state database and private
    `writeSet` storage in authorized peers will get updated. The private data in the
    transient data store then gets deleted.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦私有数据与公共区块中的哈希相匹配，交易将在区块中得到确认。授权节点中的私有状态数据库和私有`writeSet`存储将被更新。然后，暂时数据存储中的私有数据将被删除。
- en: 'You now understand how private data works. Before moving to the next new v2
    features, let’s quickly review how private data collection is defined. Here is
    a sample collection definition JSON file:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你了解了私有数据是如何工作的。在转移到下一个新的 v2 特性之前，让我们快速回顾一下私有数据集是如何定义的。以下是一个示例集合定义 JSON 文件：
- en: '[PRE3]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The file contains two private data collection definitions. In each one, we need
    to specify the collection name. [Table 9-1](#keywords_in_a_private_data_configuratio)
    shows the keyword definitions of the JSON configuration.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 文件包含两个私有数据集合定义。在每一个中，我们需要指定集合名称。[表 9-1](#keywords_in_a_private_data_configuratio)
    显示了 JSON 配置的关键字定义。
- en: Table 9-1\. Keywords in a private data configuration
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 表 9-1\. 私有数据配置中的关键字
- en: '| Keyword | Definition |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| 关键字 | 定义 |'
- en: '| --- | --- |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `name` | The name of the collection |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `name` | 集合的名称 |'
- en: '| `policy` | Defines which organizations’ peers are authorized to operate on
    collection data |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `policy` | 定义哪些组织的对等体有权操作集合数据 |'
- en: '| `requiredPeerCount` | A minimum number of peers must successfully disseminate
    private data. |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `requiredPeerCount` | 必须有最少数量的对等体成功传播私有数据。 |'
- en: '| `maxPeerCount` | For data redundancy purposes, when `maxPeerCount` is larger
    than `requiredPeerCount`, and an endorsing peer becomes unavailable between endorsement
    time and commit time, any peers that haven’t received private data yet can pull
    it from other peers that are participating in the process. |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `maxPeerCount` | 为了数据冗余，当 `maxPeerCount` 大于 `requiredPeerCount` 时，如果一个背书对等体在背书时间和提交时间之间不可用，则尚未收到私有数据的任何对等体可以从其他参与过程的对等体中获取它。
    |'
- en: '| `blockToLive` | Defines how long the data should live on the private database
    in terms of blocks. |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `blockToLive` | 定义数据在私有数据库中以区块为单位存活多长时间。 |'
- en: '| `memberOnlyRead` | Defines how long the data should live on the private database
    in terms of blocks; `memberOnlyRead` defines the client |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `memberOnlyRead` | 定义数据在私有数据库中以区块为单位存活多长时间； `memberOnlyRead` 定义客户端 |'
- en: 'When using the peer CLI to approve and commit the chaincode definition, you
    can use the `--collections-config` flag with a collection definition file similar
    to the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用对等体 CLI 来批准和提交链码定义时，您可以使用与以下类似的集合定义文件的 `--collections-config` 标志：
- en: '[PRE4]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: To read or write private data, we can use a shim API. For example, we can use
    `PutPrivateData(*collection*,*key*,*value*)` to store private data in private
    `writeSet` storage and `GetPrivateData(*collection*,*key*)` to query private data.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要读取或写入私有数据，我们可以使用一个垫片 API。例如，我们可以使用 `PutPrivateData(*collection*,*key*,*value*)`
    来将私有数据存储在私有的 `writeSet` 存储中，以及使用 `GetPrivateData(*collection*,*key*)` 来查询私有数据。
- en: External Chaincode Launcher
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 外部链码启动器
- en: Prior to Hyperledger Fabric v2, the process of chaincode maintenance was quite
    complex and cumbersome. Being in a decentralized environment, maintenance is a
    real challenge. In most cases, the code is required to be installed by a number
    of peers in the multi-organizations consortium network.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在Hyperledger Fabric v2之前，链码维护过程相当复杂和繁琐。在分散环境中，维护是一个真正的挑战。在大多数情况下，需要多个对等方安装代码在多组织联盟网络中。
- en: 'Here’s a rundown of some of the Hyperledger v1 limitations:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这里简要介绍了一些Hyperledger v1的限制：
- en: The process used to build and launch chaincode was part of the peer implementation.
    To customize the process, you had to change the source code and rebuild the chaincode.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于构建和启动链码的过程是对等方实现的一部分。要自定义此过程，您必须更改源代码并重新构建链码。
- en: 'All chaincode installed on the peer was built by passing a hardcoded language-specific
    logic. For example:'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有安装在对等方上的链码都是通过传递硬编码的特定语言逻辑构建的。例如：
- en: '[PRE5]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This build process required Docker as the part of the deployment environment.
    The process would generate a Docker container image for executing chaincode in
    a Docker container. The client can connect to the peer through the container.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此构建过程需要Docker作为部署环境的一部分。该过程会为在Docker容器中执行链码生成Docker容器映像。客户端可以通过容器连接到对等方。
- en: To build and launch a chaincode, peers need the privileges to access a Docker
    daemon, which can cause issues in production environments.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要构建和启动链码，对等方需要访问Docker守护程序的权限，这可能会在生产环境中造成问题。
- en: To enhance the development and deployment process, v2 comes with external builders
    and launchers whose functions are to empower operators to optimally customize
    the building process in such a way that chaincode can be deployed and executed
    independently (outside the Fabric system). This opens up further opportunities
    to deploy other popular container systems like Kubernetes pods.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了增强开发和部署过程，v2配备了外部构建器和启动器，它们的功能是赋予运营商在构建过程中进行最佳自定义，使得链码可以独立部署和执行（在Fabric系统之外）。这进一步提供了部署其他流行容器系统（如Kubernetes
    pods）的机会。
- en: Before this update, the chaincode in different languages like Java and Node.js
    needed to be compiled and built into a chaincode binary, then packaged with the
    Go shim libraries for creating a chaincode server. Now the Go shim API can be
    packaged to become independent of a chaincode server. The user chaincode can be
    packaged independently and run as an external service and connected to the chaincode
    server through the chaincode ID, server endpoint address, TLS information, and
    so forth.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在此更新之前，不同语言（如Java和Node.js）的链码需要编译并构建为链码二进制文件，然后与Go shim库一起打包，以创建链码服务器。现在，Go
    shim API可以打包成独立于链码服务器的形式。用户链码可以独立打包并作为外部服务运行，并通过链码ID、服务器端点地址、TLS信息等连接到链码服务器。
- en: This loose coupling module design provides a flexible way to run in a cloud
    service-based environment like Kubernetes. The Hyperledger Fabric external builders
    and launchers are loosely based on Heroku buildpacks. To leverage external builders
    and launchers, you will need to create your own buildpack and then modify the
    `externalBuilder` configuration in the peer *core.yaml*. If no configured external
    builder is specified, Fabric will use the standard Fabric packaging tools, such
    as the peer CLI or node SDK. Let’s explore this in more detail.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这种松散耦合模块设计提供了一种灵活的方式在类似 Kubernetes 的云服务环境中运行。Hyperledger Fabric 外部构建器和启动器在很大程度上基于
    Heroku buildpacks。要利用外部构建器和启动器，您需要创建自己的 buildpack，然后修改 peer 的 *core.yaml* 中的 `externalBuilder`
    配置。如果未指定任何配置的外部构建器，则 Fabric 将使用标准 Fabric 打包工具，如 peer CLI 或 node SDK。让我们更详细地探讨一下这个问题。
- en: '*Buildpacks* are sets of open source scripts that are responsible for transforming
    deployed code into the target environment. Depending on the programming language
    chosen, the scripts will examine your apps, download related dependencies, and
    determine how to configure the application chaincode to communicate with the bound
    chaincode server.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*Buildpacks* 是一组开源脚本，负责将部署的代码转换为目标环境。根据所选的编程语言，这些脚本将检查您的应用程序，下载相关依赖项，并确定如何配置应用程序
    chaincode 以与绑定的 chaincode 服务器通信。'
- en: 'An external builder and launcher repository contains the following four scripts
    in the *bin* directory:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一个外部构建器和启动器存储库在 *bin* 目录中包含以下四个脚本：
- en: 'The first script is the *detect* script. This script determines whether the
    buildpack should apply to build the chaincode package and launch it. The peer
    invokes *detect* with two arguments: `CHAINCODE_SOURCE_DIR` is the location for
    the chaincode source, and `CHAINCODE_METADATA_DIR` is the directory for the *metadata.json*
    file from the chaincode package installed to the peer.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个脚本是 *detect* 脚本。此脚本确定是否应该应用 buildpack 来构建 chaincode 包并启动它。peer 使用两个参数调用 *detect*：`CHAINCODE_SOURCE_DIR`
    是 chaincode 源的位置，`CHAINCODE_METADATA_DIR` 是安装到 peer 的 chaincode 包的 *metadata.json*
    文件的目录。
- en: Fabric runs the *detect* script to determine whether the chaincode source package
    should be applied based on return values. So if the script returns a value of
    0, it should apply the chaincode source package; conversely, it takes no action
    when the script returns nonzero values.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Fabric 运行 *detect* 脚本来确定是否应该应用 chaincode 源包，根据返回值。因此，如果脚本返回值为 0，则应该应用 chaincode
    源包；相反，当脚本返回非零值时，它不会采取任何操作。
- en: 'Here is an example of a simple *detect* script for Go chaincode:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个简单的*检测* Go chaincode 脚本的示例：
- en: '[PRE6]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This script uses `jq`, a lightweight command-line JSON processor, to check whether
    the chaincode language is Go and that at least two arguments are passed when running
    the script.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本使用 `jq`，一个轻量级命令行 JSON 处理器，来检查 chaincode 语言是否为 Go，以及在运行脚本时是否传递了至少两个参数。
- en: The second script is *build*. This script executes the buildpack logic and converts
    the chaincode package into executable chaincode.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个脚本是 *build*。此脚本执行构建包逻辑，并将链码包转换为可执行链码。
- en: 'The peer invokes *build* with three arguments:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 对等体使用三个参数调用 *build*：
- en: '[PRE7]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following is an example of a simple *build* script for Go chaincode:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个简单的用于 Go 链码的 *build* 脚本示例：
- en: '[PRE8]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Fabric runs the *build* script. If the script returns the success code 0, the
    contents of `BUILD_OUTPUT_DIR` will copy to peer persistent storage; otherwise,
    the build step should be considered a failure.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Fabric 运行 *build* 脚本。如果脚本返回成功代码 0，则将 `BUILD_OUTPUT_DIR` 的内容复制到对等持久存储；否则，构建步骤应视为失败。
- en: The third script is *release*. This script provides metadata to the peer, indicating
    how the chaincode should be executed.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个脚本是 *release*。此脚本向对等体提供元数据，指示如何执行链码。
- en: The fourth script is *run*. This script runs the chaincode.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 第四个脚本是 *run*。此脚本运行链码。
- en: 'To implement the external builder, you can create your own external builder
    directory within the *bin* subfolder. Then create all four scripts under that
    directory:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现外部构建器，您可以在 *bin* 子文件夹内创建自己的外部构建器目录。然后在该目录下创建所有四个脚本：
- en: '[PRE9]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To ensure that the peer picks up the external builder, you need to add `externalBuilder`
    information at the peer’s *core.yaml*. We can check the *fabric-samples* folder
    *(/path/fabric-samples/config*) to see *core.yaml*. The default `externalBuilders`
    section is an empty array []. You can update the `externalBuilders` section with
    the required information. The following example defines one external builder:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 要确保对等体选择外部构建器，您需要在对等体的 *core.yaml* 中添加 `externalBuilder` 信息。我们可以检查 *fabric-samples*
    文件夹 *(/path/fabric-samples/config*) 中的 *core.yaml*。默认的 `externalBuilders` 部分是一个空数组
    []。您可以使用所需信息更新 `externalBuilders` 部分。以下示例定义了一个外部构建器：
- en: '[PRE10]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this example, we define `externalBuilders-sample`, which has an *external-builder*
    script under */path-to-external-builder/external-builder*.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们定义了 `externalBuilders-sample`，该示例在 */path-to-external-builder/external-builder*
    下有一个 *external-builder* 脚本。
- en: The environment allow list contains the values that will propagate only when
    the peer invokes the build scripts.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 环境允许列表包含仅在对等体调用构建脚本时传播的值。
- en: If the external builder scripts contain commands that are not included under
    the *hyperledger/fabric-peer* Docker image (for example, the *jq* library in our
    example), then you need to build your own peer image.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果外部构建器脚本包含未包含在 *hyperledger/fabric-peer* Docker 镜像下的命令（例如，我们示例中的 *jq* 库），则需要构建自己的对等体镜像。
- en: 'The Fabric Docker images are available at [*https://github.com/hyperledger/fabric.git*](https://github.com/hyperledger/fabric.git),
    so you can clone and modify the Docker image in your own environment. Under the
    *fabric/images/peer* folder, you can update the peer Dockerfile. For example,
    you can add the `jq` command as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Fabric Docker 镜像可在 [*https://github.com/hyperledger/fabric.git*](https://github.com/hyperledger/fabric.git)
    上获得，因此您可以在自己的环境中克隆并修改 Docker 镜像。在 *fabric/images/peer* 文件夹下，您可以更新对等 Dockerfile。例如，您可以添加`jq`命令，如下所示：
- en: '[PRE11]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Once you update the Dockerfile, you can build a new peer image with a new name—for
    example:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦更新了 Dockerfile，就可以使用新名称构建一个新的对等体镜像，例如：
- en: '[PRE12]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Once an image is built successfully, it will include *jq*.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦成功构建了镜像，它将包含 *jq*。
- en: 'Since the peer Docker image has been updated, you need to update the related
    peer Docker Compose file. The following example shows the peer section in this
    file:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 由于对等 Docker 镜像已更新，您需要更新相关的对等 Docker Compose 文件。以下示例显示了此文件中的对等部分：
- en: '[PRE13]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: After this step, you can start a Fabric network with new peer images. You can
    run external builders and launchers.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此步骤后，您可以使用新的对等体镜像启动一个 Fabric 网络。您可以运行外部构建器和启动器。
- en: State Database Cache for CouchDB
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CouchDB 的状态数据库缓存
- en: 'Fabric supports two peer state databases: LevelDB and CouchDB. The default
    state database embedded in the peer node is LevelDB.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Fabric 支持两种对等状态数据库：LevelDB 和 CouchDB。对等节点中嵌入的默认状态数据库是 LevelDB。
- en: '*LevelDB* is an open source, on-disk, fast key-value store. *CouchDB* is a
    document storage NoSQL database. It can store data in the flexible document-based
    struct (JSON format) and supports powerful data mapping that allows rich queries,
    combining, and filtering the information. You can create indexes to support rich
    queries.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*LevelDB* 是一个开源的、基于磁盘的、快速的键值存储系统。*CouchDB* 是一个文档存储的 NoSQL 数据库。它可以以灵活的基于文档的结构（JSON
    格式）存储数据，并支持强大的数据映射，允许丰富的查询、组合和过滤信息。你可以创建索引来支持丰富的查询。'
- en: Prior to Fabric v2, when using the external CouchDB state database, the query
    would cross-network to get results during the endorsement and validation phases.
    This caused a performance bottleneck. With Fabric v2, the state data caches in
    peers. Instead of expensive lookups, Fabric queries and reads the state data from
    the local cache to fetch results. This can greatly improve the performance of
    your network.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Fabric v2 之前，使用外部 CouchDB 状态数据库时，查询会在背书和验证阶段跨网络获取结果。这造成了性能瓶颈。使用 Fabric v2
    后，状态数据缓存在对等节点中。Fabric 不再进行昂贵的查找，而是从本地缓存中查询状态数据以获取结果。这可以极大地提高网络性能。
- en: 'To set up cache size, update the peer *core.yaml* `cacheSize` property. The
    following is an example of a *core.yaml* CouchDB configuration under the `ledger
    -> state` section:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置缓存大小，请更新对等 *core.yaml* 的 `cacheSize` 属性。以下是 `ledger -> state` 部分的 *core.yaml*
    CouchDB 配置示例：
- en: '[PRE14]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We first define the database as CouchDB. The default `totalQueryLimit` is `100000`,
    regardless of whether the pagination APIs are utilized. `couchDBConfig` specifies
    a CouchDB-related configuration. When setting the optional `createGlobalChangesDB`
    flag to `true`, Fabric will synchronize the network state data changes and maintain
    the database, which requires additional system resources. The default is `false`.
    The `cacheSize` setting defines how state data will be allocated for in-memory
    storage, expressed in megabytes (MB). The `cacheSize` value needs to be a multiple
    of 32 MB, or Fabric will round the size to the next multiple of 32 MB. We can
    define 0 MB to disable the cache.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将数据库定义为 CouchDB。默认的 `totalQueryLimit` 是 `100000`，无论是否使用分页 API。`couchDBConfig`
    指定了 CouchDB 相关的配置。当将可选的 `createGlobalChangesDB` 标志设置为 `true` 时，Fabric 将同步网络状态数据更改并维护数据库，这需要额外的系统资源。默认值为
    `false`。`cacheSize` 设置定义了如何为内存存储分配状态数据，以兆字节（MB）表示。`cacheSize` 的值需要是 32 MB 的倍数，否则
    Fabric 将其舍入为下一个 32 MB 的倍数。我们可以定义 0 MB 来禁用缓存。
- en: Alpine-Based Docker Images
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于 Alpine 的 Docker 镜像
- en: Starting from release 2.0, the Hyperledger Fabric Docker image now builds based
    on security-oriented, lightweight *Alpine Linux*. This community-developed operating
    system is built around the *musl* libc and BusyBox. It is widely adopted in cloud,
    microservices, and container environments because of its small image size.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本 2.0 开始，Hyperledger Fabric Docker 镜像现在基于面向安全、轻量级的 *Alpine Linux* 构建。这个由社区开发的操作系统围绕
    *musl* libc 和 BusyBox 构建。由于其小的镜像大小，在云、微服务和容器环境中被广泛采用。
- en: '*BusyBox* is a single executable file that provides many tiny versions of common
    Unix utilities. It runs in a variety of Portable Operating System Interface (POSIX
    ) environments such as Linux, Android, and FreeBSD. With modular, size-optimized,
    and limited resources design, BusyBox is fairly easy to customize for any small
    or embedded system.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*BusyBox* 是一个单一的可执行文件，提供了许多常见 Unix 实用程序的微型版本。它可以在各种可移植操作系统接口（POSIX）环境中运行，如
    Linux、Android 和 FreeBSD。BusyBox 采用模块化、大小优化和资源有限的设计，因此非常容易定制为任何小型或嵌入式系统。'
- en: '*musl* is a C implementation for standard library functionality described in
    the ISO C and POSIX standards. By using static linking in *musl*, applications
    would be able to fetch essential code or data to operate, which in turn leads
    to more efficient application deployment. *Musl* integrates the entire standard
    library implementation, including threads, math, dynamic linker itself into a
    single shared object. This eliminated most of the startup time and memory overhead
    of dynamic linking.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*musl* 是一个用于 ISO C 和 POSIX 标准描述的标准库功能的 C 实现。通过在 *musl* 中使用静态链接，应用程序能够获取运行所需的基本代码或数据，从而实现更高效的应用程序部署。*Musl*
    将整个标准库实现，包括线程、数学、动态链接器本身整合到一个共享对象中。这消除了动态链接的大部分启动时间和内存开销。'
- en: With the *musl* libc and BusyBox, Alpine size is typically around 8 MB; it is
    quite small compared to a minimal disk installation, which might be around 130
    MB. This results in a faster boot time for the operating system that is heavily
    used in containers. All Userland (user space) binaries are compiled as Position
    Independent Executables (PIE) with stack smashing protection in Alpine Linux,
    making it very secure.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 *musl* libc 和 BusyBox，Alpine 大小通常约为 8 MB；与最小磁盘安装相比，这相当小，后者可能约为 130 MB。这导致在容器中大量使用的操作系统的启动时间更快。在
    Alpine Linux 中，所有用户空间（Userland）二进制文件都被编译为具有堆栈破坏保护的位置无关可执行文件（PIE），这使其非常安全。
- en: Let’s take a look at the Docker images in Hyperledger Fabric 1.3 and 2.0—the
    Docker images with the latest tag and also different tagged versions of Docker
    images that will get downloaded as part of the Fabric binaries download. [Table 9-2](Images/#docker_images_in_hyperledger_fabric_one)
    shows the size of Docker images in Hyperledger Fabric 1.3.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下 Hyperledger Fabric 1.3 和 2.0 中的 Docker 镜像 —— 具有最新标签的 Docker 镜像以及作为 Fabric
    二进制文件下载的一部分将下载的不同标记版本的 Docker 镜像。[Table 9-2](Images/#docker_images_in_hyperledger_fabric_one)
    展示了 Hyperledger Fabric 1.3 中 Docker 镜像的大小。
- en: Table 9-2\. Docker images in Hyperledger Fabric 1.3
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Table 9-2\. Hyperledger Fabric 1.3 中的 Docker 镜像
- en: '| Package | Version | Size |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| 包 | 版本 | 大小 |'
- en: '| --- | --- | --- |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| *Inyperledger/fabric-ca* | 1.3.0-rel | 244 MB |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| *Inyperledger/fabric-ca* | 1.3.0-rel | 244 MB |'
- en: '| *Inyperledger/fabric-ca* | Latest | 244 MB |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| *Inyperledger/fabric-ca* | 最新 | 244 MB |'
- en: '| *Inyperledger/fabric-tools* | 1.3.0-rel | 1.5 GB |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| *Inyperledger/fabric-tools* | 1.3.0-rel | 1.5 GB |'
- en: '| *Inyperledger/fabric-tools* | Latest | 1.5 GB |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| *Inyperledger/fabric-tools* | 最新 | 1.5 GB |'
- en: '| *Inyperledger/fabric-ccenv* | 1.3.0-rel | 1.38 GB |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| *Inyperledger/fabric-ccenv* | 1.3.0-rel | 1.38 GB |'
- en: '| *inyperledger/fabric-ccenv* | Latest | 1.38 GB |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| *inyperledger/fabric-ccenv* | 最新 | 1.38 GB |'
- en: '| *Inyperledger/fabric-orderer* | 1.3.0-rel | 145 GB |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| *Inyperledger/fabric-orderer* | 1.3.0-rel | 145 GB |'
- en: '| *Inyperledger/fabric-orderer* | Latest | 145 GB |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| *Inyperledger/fabric-orderer* | 最新 | 145 GB |'
- en: '| *Inyperledger/fabric-peer* | 1.3.0-rel | 151 MB |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| *Inyperledger/fabric-peer* | 1.3.0-rel | 151 MB |'
- en: '| *Inyperledger/fabric-peer* | Latest | 151 MB |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| *Inyperledger/fabric-peer* | 最新 | 151 MB |'
- en: '| *Inyperledger/fabric-zookeeper* | 0.4.12 | 1.39 GB |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| *Inyperledger/fabric-zookeeper* | 0.4.12 | 1.39 GB |'
- en: '| *Inyperledger/fabric-zookeeper* | Latest | 1.39 GB |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| *Inyperledger/fabric-zookeeper* | 最新 | 1.39 GB |'
- en: '| *ihyperledger/fabric-kafka* | 0.4.12 | 1.4 GB |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| *ihyperledger/fabric-kafka* | 0.4.12 | 1.4 GB |'
- en: '| *ihyperledger/fabric-kafka* | Latest | 1.4 GB |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| *ihyperledger/fabric-kafka* | 最新 | 1.4 GB |'
- en: '| *Inyper ledger/fabric-—couchdb* | 0.4.12 | 1.45 GB |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| *Inyper ledger/fabric-—couchdb* | 0.4.12 | 1.45 GB |'
- en: '| *Inyper ledger/fabric-—couchdb* | Latest | 1.45 GB |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '|   | *Inyper ledger/fabric-—couchdb* | 最新 | 1.45 GB |'
- en: Next, let’s take a look at Docker image sizes in Hyperledger Fabric v2, which
    are listed in [Table 9-3](Images/#docker_images_in_hyperledger_fabric_vtw).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看一下 Hyperledger Fabric v2 中的 Docker 镜像大小，这些镜像在 [Table 9-3](Images/#docker_images_in_hyperledger_fabric_vtw)
    中列出。
- en: Table 9-3\. Docker images in Hyperledger Fabric v2
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Table 9-3\. Hyperledger Fabric v2 中的 Docker 镜像
- en: '| Package | Version | Size |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: 包 | 版本 | 大小 |
- en: '| --- | --- | --- |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| *hyperledger/fabric-—javaenv* | 2.1.0-external-builder | 56.9 MB |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| *hyperledger/fabric-—javaenv* | 2.1.0-external-builder | 56.9 MB |'
- en: '| *hyperledger/fabric—javaenv* | None | 895 MB |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| *hyperledger/fabric—javaenv* | None | 895 MB |'
- en: '| *hyperledger/fabric-javaenv* | None | 1.12 GB |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| *hyperledger/fabric-javaenv* | None | 1.12 GB |'
- en: '| *hyperledger/fabric-tools* | 3.10 | 5.58 MB |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| *hyperledger/fabric-tools* | 3.10 | 5.58 MB |'
- en: '| *hyperledger/fabric-tools* | 2.0 | 505 MB |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| *hyperledger/fabric-tools* | 2.0 | 505 MB |'
- en: '| *hyperledger/fabric-tools* | 2.0.1 | 505 MB |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| *hyperledger/fabric-tools* | 2.0.1 | 505 MB |'
- en: '| *hyperledger/fabric-peer* | Latest | 505 MB |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| *hyperledger/fabric-peer* | Latest | 505 MB |'
- en: '| *hyperledger/fabric-—peer* | 2.0 | 512 MB |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| *hyperledger/fabric-—peer* | 2.0 | 512 MB |'
- en: '| *hyperledger/fabric-peer* | 2.0.1 | 512 MB |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| *hyperledger/fabric-peer* | 2.0.1 | 512 MB |'
- en: '| *hyperledger/fabric-orderer* | Latest | 512 MB |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| *hyperledger/fabric-orderer* | Latest | 512 MB |'
- en: '| *hyperledger/fabric-orderer* | 2.0 | 57.2 MB |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| *hyperledger/fabric-orderer* | 2.0 | 57.2 MB |'
- en: '| *hyperledger/fabric-orderer* | 2.0.1 | 57.2 MB |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| *hyperledger/fabric-orderer* | 2.0.1 | 57.2 MB |'
- en: '| *hyperledger/fabric-ccenv* | Latest | 57.2 MB |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| *hyperledger/fabric-ccenv* | Latest | 57.2 MB |'
- en: '| *hyperledger/fabric-ccenv* | 2.0 | 39.7 MB |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| *hyperledger/fabric-ccenv* | 2.0 | 39.7 MB |'
- en: '| *hyperledger/fabric-ccenv* | 2.0.1 | 39.7 MB |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| *hyperledger/fabric-ccenv* | 2.0.1 | 39.7 MB |'
- en: '| *hyperledger/fabric-baseos* | Latest | 39.7 MB |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| *hyperledger/fabric-baseos* | Latest | 39.7 MB |'
- en: '| *hyperledger/fabric-baseos* | 2.0 | 529 MB |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| *hyperledger/fabric-baseos* | 2.0 | 529 MB |'
- en: '| *hyperledger/fabric-baseos* | 2.0.1 | 529 MB |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| *hyperledger/fabric-baseos* | 2.0.1 | 529 MB |'
- en: '| *hyperledger/fabric-ca* | Latest | 529 MB |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| *hyperledger/fabric-ca* | Latest | 529 MB |'
- en: '| *hyperledger/fabric-ca* | 2.0 | 6.9 MB |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| *hyperledger/fabric-ca* | 2.0 | 6.9 MB |'
- en: '| *hyperledger/fabric-ca* | 2.0.1 | 6.9 MB |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| *hyperledger/fabric-ca* | 2.0.1 | 6.9 MB |'
- en: We can see that the image size is significantly reduced in v2—for example, that
    *fabric-tools* in v1.3 is 1.5 GB, but only 512 MB in v2.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，在 v2 版本中，图像大小显著减小了，例如，v1.3 中的 *fabric-tools* 为 1.5 GB，而在 v2 版本中仅为 512
    MB。
- en: Sample Test Network
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 样本测试网络
- en: Prior to v2, *first-network* was the most common example used to demonstrate
    how Hyperledger Fabric works. In v2, a new Fabric test network is included in
    the *fabric-samples* repository, as the long-term replacement of the *first-network*
    sample.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在 v2 版本之前，*first-network* 是用来演示 Hyperledger Fabric 工作原理的最常见示例。在 v2 版本中，*fabric-samples*
    存储库中包含了一个新的 Fabric 测试网络，作为 *first-network* 示例的长期替代品。
- en: Project structure
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 项目结构
- en: The v2 test network project structure is more organized. For instance, all Docker
    files are placed under the *docker* folder, and organization-related configuration
    is put under the *organizations* folder. The *scripts* folder contains smart contract
    installation- and deployment-related scripts. This makes the test network easy
    for testing applications and smart contracts. We have built a similar project
    structure in the [Chapter 7](ch07.xhtml#building_supply_chain_dapps_with_hyperl)
    supply chain project. In the first network, most Docker files are under the root
    project folder, so there is no organization folder.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: v2 测试网络项目结构更加有条理。例如，所有 Docker 文件都放置在 *docker* 文件夹下，与组织相关的配置放置在 *organizations*
    文件夹下。*scripts* 文件夹包含智能合约安装和部署相关的脚本。这使得测试网络易于测试应用程序和智能合约。我们在[第 7 章](ch07.xhtml#building_supply_chain_dapps_with_hyperl)的供应链项目中构建了类似的项目结构。在第一个网络中，大多数
    Docker 文件都在根项目文件夹下，因此没有组织文件夹。
- en: Peers and orgs
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Peers 和组织
- en: The test network defines one peer as two organizations, while the first network
    comes with two peers, and each peer has two organizations. [Table 9-4](#peers_and_organizations_in_the_test_and)
    shows the peers and organizations in these two sample networks.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 测试网络将一个 peer 定义为两个组织，而第一个网络则带有两个 peers，每个 peer 都有两个组织。[表 9-4](#peers_and_organizations_in_the_test_and)展示了这两个示例网络中的
    peers 和组织。
- en: Table 9-4\. Peers and organizations in the test and first networks
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 表 9-4\. 测试网络和第一个网络中的 peers 和组织
- en: '| Test network | First network |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| 测试网络 | 第一个网络 |'
- en: '| --- | --- |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| *peer0.org1.example.com peer0.org2.example.com* | *peer0.org1.example.com*
    *peer1.org1.example.com*'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '| *peer0.org1.example.com peer0.org2.example.com* | *peer0.org1.example.com*
    *peer1.org1.example.com*'
- en: '*peer0.org2.example.com*'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '*peer0.org2.example.com*'
- en: '*peer1.org2.example.com* |'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '*peer1.org2.example.com* |'
- en: Generating crypto material
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成加密材料
- en: 'In the first network, only Cryptogen is supported for generating crypto material.
    However, in the test network, crypto material can be generated either through
    Cryptogen or by the organization CA. Here is the script in the test network to
    handle these two types of crypto material:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个网络中，只支持 Cryptogen 用于生成加密材料。然而，在测试网络中，加密材料可以通过 Cryptogen 或组织 CA 生成。以下是测试网络中处理这两种类型加密材料的脚本：
- en: '[PRE15]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Since the test network supports using CAs for crypto material, this makes enrolling
    application users into the network easier.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 由于测试网络支持使用 CA 来进行加密材料，这使得将应用用户注册到网络中变得更加容易。
- en: Updating the Capability Level of a Channel
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新通道的功能级别
- en: When upgrading to the latest 2.*x* release, we need to upgrade the Fabric channel
    and components in the channel—for example, orderer and peers. In this section,
    we discuss how to update the capability level of a channel.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 当升级到最新的 2.*x* 版本时，我们需要升级 Fabric 通道以及通道中的组件，例如 orderer 和 peers。在本节中，我们将讨论如何更新通道的功能级别。
- en: Fabric enables capability levels in the configuration of each channel. These
    version capabilities need to be closely related to node binary versions. When
    it is defined, it must be present in a Fabric binary. For example, when a new
    MSP type is added, newer binaries (v2) can validate those signatures of transactions,
    while older binaries (v1.*x*) may fail. This could lead to multiple versions of
    the Fabric binaries with different world states.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Fabric 在每个通道的配置中启用功能级别。这些版本功能需要与节点二进制版本密切相关。当定义时，它必须存在于 Fabric 二进制文件中。例如，当添加新的
    MSP 类型时，新的二进制文件（v2）可以验证这些交易的签名，而旧的二进制文件（v1.*x*）可能会失败。这可能导致具有不同世界状态的 Fabric 二进制文件的多个版本。
- en: Three capabilities for an entire channel can be configured in the `capabilities`
    section of *configtx.yaml*.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 整个通道的三个功能可以在 *configtx.yaml* 的 `capabilities` 部分中配置。
- en: 'The following is a sample configuration for capabilities for 2.*x* and 1.*x*:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是针对 2.*x* 和 1.*x* 的功能的示例配置：
- en: '| 2.*x* | 1.*x* |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| 2.*x* | 1.*x* |'
- en: '| --- | --- |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Capabilities:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '| 功能：'
- en: 'Channel: &ChannelCapabilities'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通道：&ChannelCapabilities
- en: 'V2_0: true'
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'V2_0: true'
- en: 'Orderer: &OrdererCapabilities'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订购方：&OrdererCapabilities
- en: 'V2_0: true'
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'V2_0: true'
- en: 'Application: &ApplicationCapabilities'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序：&ApplicationCapabilities
- en: 'V2_0: true'
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'V2_0: true'
- en: '| Capabilities:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '| 功能：'
- en: 'Channel: &ChannelCapabilities'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通道：&ChannelCapabilities
- en: 'V1_4_3: true'
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'V1_4_3: true'
- en: 'V1_3: false'
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'V1_3: false'
- en: 'V1_1: false'
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'V1_1: false'
- en: 'Orderer: &OrdererCapabilities'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订购方：&OrdererCapabilities
- en: 'V1_4_2: true'
  id: totrans-221
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'V1_4_2: true'
- en: 'V1_1: false'
  id: totrans-222
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'V1_1: false'
- en: 'Application: &ApplicationCapabilities'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序：&ApplicationCapabilities
- en: 'V1_4_2: true'
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'V1_4_2: true'
- en: 'V1_3: false'
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'V1_3: false'
- en: 'V1_2: false'
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'V1_2: false'
- en: 'V1_1: false'
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'V1_1: false'
- en: '|'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Channel capabilities apply to both the peer organizations and the ordering service.
    The binary level of the ordering service and peers need to be at least the defined
    minimum level in order to process the capability. When `ChannelCapabilities V2_0`
    is set to `true`, it expects that all orderers and peers on a channel need to
    be at v2.0.0 or later.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 通道功能适用于对等方组织和订购服务。订购服务和对等方的二进制级别至少需要达到定义的最低级别，以便处理该功能。当 `ChannelCapabilities
    V2_0` 设置为 `true` 时，它期望通道上的所有订购方和对等方都需要达到 v2.0.0 或更高版本。
- en: Orderer capabilities apply only to the ordering service. Orderer capabilities
    don’t involve peers or transaction processes, so when the ordererer fails, only
    the ordering service admins get impacted.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 订购方功能仅适用于订购服务。订购方功能不涉及对等方或交易流程，因此当订购方失败时，只有订购服务管理员会受到影响。
- en: Application capabilities apply only to peers. In the case of private data, ordering
    service admins and channel administration are not involved in setting up private
    data between peer organizations, so we can enable these capabilities for only
    private data.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 应用功能仅适用于对等方。在私有数据的情况下，订购服务管理员和通道管理不涉及对等组织之间私有数据的设置，因此我们只能为私有数据启用这些功能。
- en: While defining the capability level in *configtx.yaml*, we also need to upgrade
    binaries to at least the level of the relevant capabilities; otherwise, binaries
    will crash, which may cause a ledger fork. Once a capability has been enabled,
    it is permanent and not reversible. Even after rolling back the configuration
    changes, the old binaries will not be able to participate in transactions of the
    channel.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *configtx.yaml* 中定义能力级别时，我们还需要将二进制文件升级到至少与相关能力级别相对应的水平；否则，二进制文件将崩溃，这可能会导致账本分叉。一旦启用了某个功能，它就是永久的，不可逆转的。即使回滚配置更改，旧的二进制文件也无法参与通道的交易。
- en: Warning
  id: totrans-233
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Prior to enabling capabilities in production, we recommend trying the new capabilities
    in a test environment to ensure the expected result.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产中启用功能之前，我们建议在测试环境中尝试新功能，以确保预期的结果。
- en: Update to the Newest Capability Levels
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新到最新的功能级别
- en: 'When we start upgrading to v2, it becomes necessary to update to the newest
    capability depending on your own use case or requirement. Note that it may be
    necessary to update to the newest capability levels before using the features
    in the latest release, and it is considered a best practice to always be at the
    latest binary versions and capability levels. At a high level, this process has
    three steps (for each channel):'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始升级到 v2 时，根据您自己的用例或要求更新到最新的功能变得必要。请注意，在使用最新版本的功能之前，可能需要更新到最新的功能级别，始终处于最新的二进制版本和功能级别被认为是最佳做法。在高层次上，这个过程有三个步骤（针对每个通道）：
- en: Retrieve the latest channel configuration.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检索最新的通道配置。
- en: Modify the necessary channel configuration.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改必要的通道配置。
- en: Create a config update transaction.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建配置更新交易。
- en: Retrieve the latest channel config
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检索最新的通道配置
- en: 'Before you start to retrieve the channel config, you need to set up environment
    variables for your config update. The following variables need to be exported
    as environment variables:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始检索通道配置之前，您需要为您的配置更新设置环境变量。以下变量需要导出为环境变量：
- en: '`CH_NAME`'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`CH_NAME`'
- en: The name of the system channel for updating
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 用于更新系统通道的名称
- en: '`CORE_PEER_LOCALMSPID`'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`CORE_PEER_LOCALMSPID`'
- en: ID of orderer organization that proposes the channel update
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 提议通道更新的订单组织的 ID
- en: '`TLS_ROOT_CA`'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`TLS_ROOT_CA`'
- en: The absolute path to the TLS certificate of your orderer node(s)
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '您的订单节点 TLS 证书的绝对路径（S）  '
- en: '`CORE_PEER_MSPCONFIGPATH`'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`CORE_PEER_MSPCONFIGPATH`'
- en: The absolute path to the MSP representing your organization
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 代表您的组织的 MSP 的绝对路径
- en: '`ORDERER_CONTAINER`'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`ORDERER_CONTAINER`'
- en: The name of an orderer node container
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 订单节点容器的名称
- en: Once we set up environment variables, we can pull the channel configuration
    in Protocol Buffers format, which is a method of serializing structured data,
    and create a file called *config_block.pb*.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们设置了环境变量，我们可以使用 Protocol Buffers 格式拉取通道配置，这是一种序列化结构化数据的方法，并创建一个名为 *config_block.pb*
    的文件。
- en: 'In the peer container, you can issue the following command:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在对等节点容器中，您可以发出以下命令：
- en: '[PRE16]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, we’ll convert the Protobuf file to a human-readable JSON file called
    *config_block.json*:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将 Protobuf 文件转换为一个可读的 JSON 文件，称为*config_block.json*：
- en: '[PRE17]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, use the `jq` command to remove all unnecessary metadata, and generate
    a new file (in this example, we’ll call it *config.json*):'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用`jq`命令删除所有不必要的元数据，并生成一个新文件（在本例中，我们将其称为*config.json*）：
- en: '[PRE18]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Before starting to modify the JSON config file, we need to copy *config.json*
    as a new JSON file called *modified_config.json*. In a later step, we need to
    compare the differences between these two files and submit the changed configuration.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始修改 JSON 配置文件之前，我们需要将*config.json*复制为一个名为*modified_config.json*的新 JSON 文件。在稍后的步骤中，我们需要比较这两个文件之间的差异，并提交更改后的配置。
- en: 'Run this command to copy *config.json*:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以复制*config.json*：
- en: '[PRE19]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Modify the necessary channel config
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修改必要的通道配置
- en: 'In this step, you can open a text editor or other JSON tool like *jq* to modify
    the channel configuration to make all necessary changes. We define *capabilities.json*
    as a sample config and then add the capabilities to the `orderer` or `application`
    channel sections. Here is the *capabilities* config file:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在此步骤中，您可以打开文本编辑器或其他 JSON 工具，如*jq*，以修改通道配置以进行所有必要的更改。我们将*capabilities.json*定义为一个示例配置，然后将这些能力添加到`orderer`或`application`通道部分。这是*capabilities*配置文件：
- en: '[PRE20]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To add the orderer group capabilities to *modified_config.json*, issue this
    command:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 要将排序器组能力添加到*modified_config.json*中，请发出此命令：
- en: '[PRE21]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Similarly, to add the channel group capabilities to *modified_config.json*,
    issue this command:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，要将通道组能力添加到*modified_config.json*中，请发出此命令：
- en: '[PRE22]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Three parts of the channel capability configurations can be updated:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 通道能力配置的三个部分可以更新：
- en: Orderer group
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排序组
- en: Channel group
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通道组
- en: Application group
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用组
- en: 'The orderer group and channel group are similar to the orderer system channel.
    To add the application group capability, issue this command:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 排序组和通道组与排序器系统通道类似。要添加应用组能力，请发出此命令：
- en: '[PRE23]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note
  id: totrans-275
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: For incremental change, you need to repeat the three-step process per change.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 对于增量更改，您需要每次更改重复执行三步流程。
- en: Create a config update transaction
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建配置更新事务
- en: 'To update the JSON configuration file, we first need to run the `configtxlator`
    tool and submit a modified configuration. Then we convert the configuration from
    JSON format back to Protobuf format:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新 JSON 配置文件，我们首先需要运行`configtxlator`工具并提交修改后的配置。然后我们将配置从 JSON 格式转换回 Protobuf
    格式：
- en: '[PRE24]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'With the `compute_update` command from the `configtxlator` tool, we get the
    calculated difference between the old config and the modified one. Next, we apply
    the changes to the config:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`configtxlator`工具中的`compute_update`命令，我们可以得到旧配置和修改后配置之间的计算差异。接下来，我们将这些更改应用到配置中：
- en: '[PRE25]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Finally, we submit the config update transaction. The ordering service will
    convert it to a full channel configuration:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们提交配置更新事务。排序服务将其转换为完整的通道配置：
- en: '[PRE26]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Tip
  id: totrans-284
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: To enable channel and application capabilities, you can either bundle all changes
    at the same time or do it incrementally.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用通道和应用程序功能，您可以同时捆绑所有更改，也可以逐步进行。
- en: Upgrade Components
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 升级组件
- en: 'Upgrading a component to a newer version (including v2) in Hyperledger Fabric
    typically is a four-step process:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Hyperledger Fabric 中的组件升级到较新版本（包括 v2）通常是一个四步过程：
- en: Back up the ledger and MSPs.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 备份账本和MSP。
- en: Upgrade the orderer binaries in a rolling fashion to the latest Fabric version.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以滚动方式升级对最新Fabric版本的订购者二进制文件。
- en: Upgrade the peer binaries in a rolling fashion to the latest Fabric version.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以滚动方式升级对最新Fabric版本的对等二进制文件。
- en: Update the orderer system channel and any application channels to the latest
    capability levels.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新订购者系统通道和任何应用程序通道到最新的功能水平。
- en: For native deployments, you will also need to back up the *orderer.yaml* or
    the *core.yaml* file and update the content with release artifacts including new
    port changes if required.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本地部署，您还需要备份*orderer.yaml*或*core.yaml*文件，并根据需要更新内容，包括新端口更改。
- en: Set Environment Variables for the Binaries
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为二进制文件设置环境变量
- en: 'To run a peer or an orderer node operation, you typically need to set environment
    variables relevant to Fabric CLI commands on each upgraded node. Here’s a list
    of some of the peer environment variables; based on actual need; some of the variables
    are optional:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行对等或订购者节点操作，通常需要在每个升级的节点上设置与Fabric CLI命令相关的环境变量。以下是一些对等环境变量的列表；根据实际需要；一些变量是可选的：
- en: '[PRE27]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here’s a list of some of the orderer environment variables. Again, some of
    the variables are optional:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些orderer环境变量的列表。同样，一些变量是可选的：
- en: '[PRE28]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Back Up and Restore the Ledger
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 备份和恢复账本
- en: A ledger backup can reduce time and computational costs when restarting nodes
    and bootstrapping from the genesis block and reprocessing all transactions. The
    process may take quite a long time if the size of the ledger is large.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 当重新启动节点并从创世区块引导并重新处理所有事务时，账本备份可以减少时间和计算成本。如果账本的大小很大，该过程可能需要相当长的时间。
- en: 'We can back up ledger data in two ways:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过两种方式备份账本数据：
- en: Create a new peer to join the same channel. The new node will synchronize with
    the network and rebuild its ledger by initiating the genesis block and state DB
    for all joined channels.
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的对等体以加入相同的通道。新节点将与网络同步，并通过初始化所有已加入通道的创世区块和状态DB来重建其账本。
- en: Log in to the peer node as the peer admin, stop the peer, and then go to the
    peer data folder. By default, peer data is stored under */var/hyperledger/production/*.
    Back up folders such as *chaincodes*, *ledgersData*, and *transientStore*. Some
    subfolders under *ledgersData* (including *stateLeveldb*, *historyLeveldb*, and
    *chains/index*) can be ignored to reduce the storage demand for the backup, but
    reconstructing them will take more time when peer starts.
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以对等节点管理员身份登录到对等节点，停止对等节点，然后转到对等数据文件夹。默认情况下，对等数据存储在*/var/hyperledger/production/*下。备份诸如*chaincodes*、*ledgersData*和*transientStore*等文件夹。一些*ledgersData*下的子文件夹（包括*stateLeveldb*、*historyLeveldb*和*chains/index*）可以忽略，以减少备份的存储需求，但在对等节点启动时，重建它们会花费更多时间。
- en: Upgrade the Orderer Nodes
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 升级订购节点
- en: 'You should upgrade orderer nodes in a rolling fashion (one at a time). Before
    upgrading orderer nodes, we need to set up the following environment variables:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 应以滚动方式（一个接一个地）升级订购节点。在升级订购节点之前，我们需要设置以下环境变量：
- en: '`ORDERER_CONTAINER`'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ORDERER_CONTAINER`'
- en: '`LEDGERS_BACKUP`: The location of the local filesystem where the ledger data
    will be backed up'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LEDGERS_BACKUP`：本地文件系统中存储账本数据的位置'
- en: '`IMAGE_TAG`: The Fabric version you are upgrading to'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IMAGE_TAG`：您要升级到的Fabric版本'
- en: 'The process to upgrade the orderer node typically follows these steps:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 升级订购节点的过程通常遵循以下步骤：
- en: 'Stop the orderer node and run this `docker` CLI command:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 停止订购节点并运行以下`docker` CLI命令：
- en: '[PRE29]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Back up the ledger and MSP in the orderer node. Remember that the default orderer
    nodes data is located under */var/hyperledger/production/orderer*:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在订购节点中备份账本和MSP。请记住，默认订购节点数据位于*/var/hyperledger/production/orderer*下：
- en: '[PRE30]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Delete the orderer node container:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除订购节点容器：
- en: '[PRE31]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Start a new orderer node container with the newer version image tag:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用更新的版本镜像标签启动一个新的订购节点容器：
- en: '[PRE32]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Repeat this process for each node of the ordering service until the entire ordering
    service has been upgraded.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对订购服务的每个节点重复此过程，直到整个订购服务都已升级完毕。
- en: Upgrade the Peers
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 升级对等节点
- en: 'Similar to upgrading the orderer nodes, peer upgrading should be done in a
    rolling fashion. Before upgrading the peer nodes, we need to set up the following
    environment variables:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于升级订购节点，对等节点的升级应该以滚动方式进行。在升级对等节点之前，我们需要设置以下环境变量：
- en: '`PEER_CONTAINER`'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PEER_CONTAINER`'
- en: '`LEDGERS_BACKUP`'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LEDGERS_BACKUP`'
- en: '`IMAGE_TAG`'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IMAGE_TAG`'
- en: 'The process to upgrade the peer node is as follows:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 升级对等节点的过程如下：
- en: 'Stop the peer with the following command and then bring down the peer:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令停止对等节点，然后关闭对等节点：
- en: '[PRE33]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Back up the peer’s ledger and MSP:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 备份对等节点的账本和MSP：
- en: '[PRE34]'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Remove the chaincode containers and images:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除链码容器和镜像：
- en: '[PRE35]'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Remove the peer container:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除对等容器：
- en: '[PRE36]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Start a new peer container by using the relevant image tag and issuing the
    following command:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用相关的镜像标签启动一个新的对等容器，并发出以下命令：
- en: '[PRE37]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Once the peer node starts, you can issue the chaincode invocation and query
    to verify that the peer functions upgraded normally.
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦对等节点启动，您可以发出链码调用和查询以验证对等函数是否正常升级。
- en: Upgrade the Node SDK Clients
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 升级 Node SDK 客户端
- en: 'Upgrading the node SDK client follows a regular npm upgrade; you issue a Node.js
    `npm install` command under the project root directory containing the *package.json*
    file. Issue this command to upgrade to the latest Fabric client and Fabric CA
    client:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 升级 node SDK 客户端遵循常规的 npm 升级；你需要在包含 *package.json* 文件的项目根目录下执行 Node.js 的 `npm
    install` 命令。执行此命令以升级到最新的 Fabric 客户端和 Fabric CA 客户端：
- en: '[PRE38]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Considerations for Moving to V2
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 考虑迁移到 V2 的注意事项
- en: We have reviewed new features in v2; Hyperledger Fabric supports rolling upgrades
    from v1.4.*x* to v2.0 without downtime. When upgrading from v1.4.*x* to v2.2,
    we need to consider many factors.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经审查了 v2 中的新功能；Hyperledger Fabric 支持从 v1.4.*x* 到 v2.0 的滚动升级，无需停机。在从 v1.4.*x*
    升级到 v2.2 时，我们需要考虑许多因素。
- en: Chaincode Life Cycle
  id: totrans-340
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 链码生命周期
- en: As you learned earlier, Hyperledger Fabric v2 decentralized governance for the
    chaincode life cycle requires that multiple organizations agree to the parameters
    of the chaincode and approve how it will be operated on the channel. When peers
    participate in the new chaincode process, the peers and orderer nodes must be
    at v2.*x*; otherwise, the peer will crash after the channel capability has been
    enabled. This requires that all peers first be upgraded on the channel before
    enabling channel capability. Once channel capability is enabled, we enable application
    capability to `V2_0` on a channel.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您之前了解的那样，Hyperledger Fabric v2 链码生命周期的分散式治理要求多个组织同意链码的参数，并批准其在通道上的操作方式。当对等方参与新的链码流程时，对等方和排序节点必须处于
    v2.*x*；否则，在启用通道能力后，对等方将会崩溃。这要求所有对等方在启用通道能力之前首先在通道上进行升级。一旦启用了通道能力，我们在通道上启用应用程序能力为
    `V2_0`。
- en: To package, install, approve, and commit new chaincodes on the channel, we must
    use the Hyperledger Fabric v2 chaincode life-cycle operation. Since the release
    of the new decentralized governance chaincode life cycle, the endorsement policy
    needs to be updated in the channel configuration (e.g., a `MAJORITY` of organizations).
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 要在通道上打包、安装、批准和提交新的链码，我们必须使用 Hyperledger Fabric v2 链码生命周期操作。自新的分散式治理链码生命周期发布以来，通道配置中的背书策略需要更新（例如，`多数机构`）。
- en: Chaincode Shim Changes (Go Chaincode Only)
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Chaincode Shim Changes (Go Chaincode Only)
- en: If your chaincode is written in Go, the *fabric-chaincode-go/shim* libraries
    need an upgrade to the 2.*x* version before making upgrades to the peers and channels.
    The best practice approach is to vendor (or manage) the shim in your v1.4 Go chaincode.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的链码是用 Go 编写的，则在对等方和通道进行升级之前，*fabric-chaincode-go/shim* 库需要升级到 2.*x* 版本。最佳实践是在您的
    v1.4 Go 链码中管理（或管理）shim。
- en: 'Many tools are available for vendoring shim dependencies. One of the popular
    tools is `govendor`, a Go package dependency management command-line tool. This
    tool will flatten out all the project dependencies and import dependencies from
    your `GOPATH`. The following demonstrates how to use `govendor`:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多工具可用于供应 shim 依赖项。其中一个流行的工具是`govendor`，一个 Go 包依赖管理命令行工具。此工具将展开所有项目依赖项，并从您的`GOPATH`导入依赖项。以下演示如何使用`govendor`：
- en: '[PRE39]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This imports the external dependencies into a local vendor directory.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 这将外部依赖项导入到本地 vendor 目录中。
- en: 'If you do not want to vendor the shim in your v1.4 chaincode, you have two
    options:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想在您的 v1.4 链码中供应 shim，则有两个选项：
- en: Upgrade the chaincode on all peers and on the channel.
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 升级所有对等节点和通道上的链码。
- en: Set up peer environment variables to specify the v1.4 chaincode, including new
    packages in chaincode. Use v1.4 *ccenv* to rebuild the chaincode images; the v1.4
    *ccenv* should still work with a v2.*x* peer.
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置对等环境变量以指定 v1.4 链码，包括链码中的新包。使用 v1.4 *ccenv* 重新构建链码映像；v1.4 *ccenv* 应仍与 v2.*x*
    对等节点配合使用。
- en: Chaincode Logger (Go Chaincode Only)
  id: totrans-351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 链码记录器（仅限 Go 链码）
- en: 'In v1.4, the shim provides logging objects for the chaincode to use via the
    `NewLogger` API, which allows the chaincode to control the severity level; this
    has been removed in v2\. The chaincode logs in the peer and orderer use the log
    API library under *common/flogging*. This package supports the following:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在 v1.4 中，shim 通过`NewLogger` API 为链码提供日志对象，该 API 允许链码控制严重级别；这在 v2 中已被移除。对等节点和排序器中的链码日志使用*common/flogging*下的日志
    API 库。此包支持以下内容：
- en: Various levels of control for logging, based on the severity of the message
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于消息严重程度的各种日志控制级别
- en: Logging control based on the application logger generating the message
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于应用程序日志生成消息的日志控制
- en: Various log message formatting options, including pretty-printing format message
    support
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种日志消息格式选项，包括漂亮打印格式消息支持
- en: You can set up the `FABRIC_LOGGING_SPEC` environment variable to specify the
    logging levels.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以设置`FABRIC_LOGGING_SPEC`环境变量以指定日志级别。
- en: 'The full logging-level specification is of the following form:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的日志级别规范形式如下：
- en: '[PRE40]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Peer Databases Upgrade
  id: totrans-359
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对等数据库升级
- en: When upgrading peer components to 2.*x*, you should also upgrade the peer database
    to the new version. The data format in the v2.*x* is different from the earlier
    format. The databases of all peers including state database, historical database,
    and other internal databases for the peer must be rebuilt.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 当将对等组件升级到 2.*x* 时，还应将对等数据库升级到新版本。v2.*x* 中的数据格式与之前的格式不同。所有对等节点的数据库，包括状态数据库、历史数据库和对等节点的其他内部数据库，都必须重新构建。
- en: 'For the peer database upgrading process, you can perform the `peer node upgrade-dbs`
    command to drop the local database volume directory. Before doing it, you should
    back up the peer data. Set up the peer container and ledger environment first;
    then run the following Docker command:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 对于同行数据库升级过程，您可以执行`peer node upgrade-dbs`命令以删除本地数据库卷目录。在执行此操作之前，您应备份同行数据。首先设置同行容器和分类账环境；然后运行以下Docker命令：
- en: '[PRE41]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The peer node will rebuild the databases by using the v2.*x* data format after
    it restarts. Rebuilding the database could take a while, depending on the data
    volumes of your databases.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 同行节点将在重新启动后使用v2.*x*数据格式重新构建数据库。重新构建数据库可能需要一段时间，具体取决于数据库的数据量。
- en: Capabilities
  id: totrans-364
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 能力
- en: 'In [“Updating the Capability Level of a Channel”](#updating_the_capability_level_of_a_chan),
    we noted that three new capabilities are introduced in the v2 release:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在[“更新通道的能力级别”](#updating_the_capability_level_of_a_chan)中，我们注意到在v2版本中引入了三个新的功能：
- en: Channel capabilities
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通道功能
- en: Application capabilities
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序功能
- en: Orderer capabilities
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排序节点功能
- en: Before updating the application and channel capabilities, you need to upgrade
    your peer binaries to newer binaries (v2). Also, upgrade your orderer binaries
    before updating the orderer and channel capabilities; otherwise, the old binaries
    (v1.*x*) may fail. The failure could lead to multiple versions of the Fabric binaries
    with different world states.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新应用程序和通道功能之前，您需要将同行节点二进制文件升级到新版本的二进制文件（v2）。在更新排序节点和通道功能之前，也要升级排序节点二进制文件；否则，旧的二进制文件（v1.*x*）可能会失败。失败可能导致具有不同世界状态的多个版本的Fabric二进制文件。
- en: Define orderer node endpoint per organization
  id: totrans-370
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 每个组织定义排序节点端点
- en: It is a best practice to define the orderer endpoints in both the system channel
    and in all application channels by adding new `OrdererEndpoint`s.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加新的`OrdererEndpoint`，在系统通道和所有应用通道中定义排序节点端点是一种最佳实践。
- en: 'If you haven’t included `OrdererEndpoint`s per organization, you can create
    an endpoints config JSON file. The process to define and update orderer node endpoints
    per organization is as follows:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尚未为每个组织包含`OrdererEndpoint`，则可以创建一个端点配置JSON文件。定义和更新每个组织的排序节点端点的过程如下：
- en: 'Create an orderer endpoint config JSON file (for example, *newOrdererEndpoinConf.json*):'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个排序节点端点配置JSON文件（例如，*newOrdererEndpoinConf.json*）：
- en: '[PRE42]'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Export the environment variables. Once you create an `OrdererEndpoint` JSON
    file, you can start using the command line to update the orderer endpoint configuration.
    Before doing that, as usual, we need to set up environment variables as follows:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导出环境变量。一旦创建了`OrdererEndpoint` JSON文件，您就可以开始使用命令行更新排序节点端点配置。在此之前，通常需要设置环境变量如下：
- en: '`CH_NAME`'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`CH_NAME`'
- en: The updated name of the system channel
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 系统通道的更新名称
- en: '`CORE_PEER_LOCALMSPID`'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`CORE_PEER_LOCALMSPID`'
- en: ID of one of the orderer organizations that proposes the channel update
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 提议通道更新的一个排序组织的ID
- en: '`TLS_ROOT_CA`'
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`TLS_ROOT_CA`'
- en: The absolute path to the TLS certificate of your orderer node(s)
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您的orderer节点TLS证书的绝对路径
- en: '`CORE_PEER_MSPCONFIGPATH`'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`CORE_PEER_MSPCONFIGPATH`'
- en: The absolute path to the MSP representing your organization
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 代表您的组织的MSP的绝对路径
- en: '`ORDERER_CONTAINER`'
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`ORDERER_CONTAINER`'
- en: The name of an orderer node container
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个orderer节点容器的名称
- en: '`ORGNAME`'
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`ORGNAME`'
- en: The name of the organization you are currently updating
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您当前正在更新的组织的名称
- en: 'Pull and translate the config and add the life-cycle organization policy (as
    listed in *orglevelEndpoints.json*) to *modified_config.json* by issuing the following
    command:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过以下命令拉取并翻译配置，并将生命周期组织策略（如*orglevelEndpoints.json*所列）添加到*modified_config.json*中：
- en: '[PRE43]'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Finally, submit the config. This will define the orderer endpoints in your system
    channel and application channels.
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，提交配置。这将定义您系统通道和应用通道中的orderer节点端点。
- en: Summary
  id: totrans-391
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we discussed the important new features of Hyperledger Fabric
    v2\. We explored how to upgrade the components and the capability level of a channel.
    By showing the detailed upgrading steps, you have a better understanding of the
    upgrading process of the peer and orderer services.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了Hyperledger Fabric v2的重要新功能。我们探讨了如何升级通道的组件和能力级别。通过展示详细的升级步骤，您对peer和orderer服务的升级过程有了更好的理解。
- en: It is a best practice to consider upgrading to a newer major release version
    and reap the benefits of important new features. We discussed the many significant
    factors you need to consider when changing to the v2 release from 1.*x*. Throughout
    this chapter, you gained lots of practical knowledge for smart contract development
    with Hyperledger Fabric v2\. The next chapter provides an overview of other new
    Hyperledger projects.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 将升级到新的主要版本，并获得重要新功能的好处是最佳实践。我们讨论了从1.*x*的版本升级到v2版本时您需要考虑的许多重要因素。在本章中，您获得了关于Hyperledger
    Fabric v2智能合约开发的许多实用知识。下一章将概述其他新的Hyperledger项目。
