- en: © The Author(s), under exclusive license to Springer Nature Switzerland AG 2022X.
    Yi et al.Blockchain Foundations and ApplicationsSpringerBriefs in Applied Sciences
    and Technology[https://doi.org/10.1007/978-3-031-09670-9_3](https://doi.org/10.1007/978-3-031-09670-9_3)
  prefs: []
  type: TYPE_NORMAL
- en: 3. Distributed Consensus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Xun Yi^([1](#Aff6) [ ](#ContactOfAuthor6)), Xuechao Yang^([1](#Aff6) [ ](#ContactOfAuthor7)),
    Andrei Kelarev^([1](#Aff6) [ ](#ContactOfAuthor8)), Kwok Yan Lam^([2](#Aff7) [ ](#ContactOfAuthor9))
    and Zahir Tari^([1](#Aff6) [ ](#ContactOfAuthor10))(1)School of Computing Technologies,
    RMIT University, Melbourne, VIC, Australia(2)School of Computer Science and Engineering,
    Nanyang Technological University, Singapore, SingaporeXun Yi (Corresponding author)Email:
    [xun.yi@rmit.edu.au](mailto:xun.yi@rmit.edu.au)Xuechao YangEmail: [xuechao.yang@rmit.edu.au](mailto:xuechao.yang@rmit.edu.au)Andrei KelarevEmail:
    [andrei.kelarev@gmail.com](mailto:andrei.kelarev@gmail.com)Kwok Yan LamEmail:
    [kwokyan.lam@ntu.edu.sg](mailto:kwokyan.lam@ntu.edu.sg)Zahir TariEmail: [zahir.tari@rmit.edu.au](mailto:zahir.tari@rmit.edu.au)'
  prefs: []
  type: TYPE_NORMAL
- en: 3.1 Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Blockchain technology relies on several technical ingredients. Distributed consensus
    protocol is the key building block enabling blockchain’s decentralization. It
    allows all participants to establish agreement on the current state of the common
    ledger keeping a record of all transactions of the system without the assistance
    of any trusted central authority. A distributed consensus protocol determines
    conditions for communication of messages among the nodes and the decision-making
    process in blockchain community. The performance of the consensus protocol being
    employed is crucial for the effectiveness of the whole blockchain system, as it
    influences the communication capability, reliability, and scalability.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Bitcoin network applies the original Nakamoto consensus procedure, which
    relies on its *proof-of-work* (PoW) mining algorithm. This protocol helped Bitcoin
    to be established as a reliable digital currency effectively resisting the so-called
    double-spending attacks in a peer-to-peer decentralized network. The exponential
    growth of the Bitcoin network has led to the realization of several bottlenecks
    hindering the performance of the Bitcoin consensus and creating significant sustainability
    problems. In a large-scale cryptocurrency network, the Nakamoto consensus and
    its reliance on PoW mining inevitably lead to the following problems:'
  prefs: []
  type: TYPE_NORMAL
- en: (1) unsustainable energy consumption,
  prefs: []
  type: TYPE_NORMAL
- en: (2) poor scalability and low throughput,
  prefs: []
  type: TYPE_NORMAL
- en: (3) security weaknesses that may grow with the decreasing mining rewards.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the transaction capacity of Bitcoin is approximately 7 transactions
    per second (TPS) and can be increased to at most 25 TPS by adjusting parameters
    without jeopardizing security [[13](#CR13)]. The Bitcoin network currently comprises
    approximately 10,000 nodes [[7](#CR7)]. If we compare these data to other financial
    networks, we see that, for example, the VISA network consists of over 50 million
    participants and processes up to 65,000 TPS [[36](#CR36)]. In 2019, it was noted
    that a single Bitcoin transaction consumed the amount of electricity equivalent
    to the daily power consumption of 21 average U.S. households [[15](#CR15)].
  prefs: []
  type: TYPE_NORMAL
- en: In order to tackle these problems intrinsic in the PoW mining, the researchers
    have been investigating ways to reduce energy consumption by applying numerous
    alternative distributed consensus techniques such as proof-of-stake (PoS), proof-of-authority
    (PoA), and proof-of-elapsed-time (PoET), to name just of few examples. Cryptographic
    methods can be applied to achieve trust among the participants, enable more robust
    schemes for handling new blocks such as round-robin and committee-based block
    generation.
  prefs: []
  type: TYPE_NORMAL
- en: Appropriate incentives that encourage honest participation in the blockchain
    network are another key components of a consensus protocol. Novel block processing
    schemes often encompass new incentive mechanisms promoting fairness for all participants
    and increasing the sustainability of the whole system. Examples of popular blockchain
    consensus protocols include Peercoin [[20](#CR20)], Bitcoin-NG [[17](#CR17)],
    Ouroboros (Cardano) [[19](#CR19)], Snow White [[14](#CR14)], EOSIO [[16](#CR16)],
    POA Network [[30](#CR30)], etc.
  prefs: []
  type: TYPE_NORMAL
- en: 3.2 History of Consensus
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Fault-tolerant (FT) distributed consensus algorithms have been actively investigated
    for a long time. A consensus in a distributed system corresponds to a situation
    where all participants agree on the same current values of a collection of variables.
  prefs: []
  type: TYPE_NORMAL
- en: 3.2.1 Byzantine Fault-Tolerant Consensus
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The concept of a Byzantine fault tolerance is central to the blockchain technology,
    since every blockchain must be protected against the broadest type of malicious
    behaviour and faults of the nodes. Recall that a *crash* of a network node occurs,
    when the node stops operating and fails to respond to the network messages. A
    *Byzantine fault* is a broad term describing a node, which is trying to conceal
    its malicious behaviour and may be carrying out some of the required step correctly,
    but at the same time and on its own discretion it can also exhibit any imaginable
    type of incorrect responses or malicious behaviour. It may be quite difficult
    for the honest participants in a consensus protocol to identify the Byzantine
    nodes and exclude their input from the outcomes, since these faulty nodes are
    doing their best to remain undetected and at the same time to subvert the outcomes
    of the protocol.
  prefs: []
  type: TYPE_NORMAL
- en: A consensus protocol is said to be *crash fault tolerant* (CFT) if it can tolerate
    a certain number of crash failures and achieve correct outcome despite these failures.
    Likewise, a consensus protocol is *Byzantine fault tolerant* (BFT) if it can remain
    resilient against a certain number of Byzantine failures and can continue normal
    operation achieving correct consensus outcome. Every BFT consensus protocol is
    also CFT, since the Byzantine nodes can imitate crashes at these nodes too.
  prefs: []
  type: TYPE_NORMAL
- en: In order for a consensus protocol to be a BFT consensus, the inequality ![$$N
    \ge 3f + 1$$](../images/516136_1_En_3_Chapter/516136_1_En_3_Chapter_TeX_IEq1.png)
    has to be satisfied in the corresponding network, where *N* is the number of the
    nodes in the network, and *f* is the number of the Byzantine nodes. This fundamental
    theorem was first proved by Pease et al. [[29](#CR29)] in 1980 and was later adapted
    to the BFT consensus framework. The proof uses induction starting with the induction
    base ![$$N = 3$$](../images/516136_1_En_3_Chapter/516136_1_En_3_Chapter_TeX_IEq2.png).
    In the proof, one or two nodes are left aside to make the number *N* divisible
    by 3, and then all the remaining nodes are partitioned into three groups of equal
    size so that all faulty nodes belong to one of the three groups. The readers are
    referred to [[4](#CR4), [29](#CR29)] for a complete proof.
  prefs: []
  type: TYPE_NORMAL
- en: 3.2.2 Practical Byzantine Fault Tolerance (PBFT)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Practical Byzantine fault tolerance (PBFT) was proposed by Castro and Liskov [[9](#CR9)]
    in the context of general distributed systems. Previous BFT consensus algorithms
    did not scale up well. The PBFT was the first BFT consensus protocol that was
    recognized for its practicality and has become broadly adopted. It applies state
    machine replication. The algorithm for processing messages is represented as a
    finite state machine, and all the nodes keep identical copies or replicas of the
    state machine. One node is chosen as a primary, and other nodes are called clients.
    The PBFT includes three subprotocols:'
  prefs: []
  type: TYPE_NORMAL
- en: (1) Normal operation,
  prefs: []
  type: TYPE_NORMAL
- en: (2) Checkpoint,
  prefs: []
  type: TYPE_NORMAL
- en: (3) View change.
  prefs: []
  type: TYPE_NORMAL
- en: The normal-operation protocol is shown in Algorithm 3.1\. If there are no faulty
    nodes, then all values in the messages received by the node as responses are equal.
    Otherwise, the nodes choose the value that occurs in the majority of the responses,
    since this value corresponds to the replies from the honest nodes.
  prefs: []
  type: TYPE_NORMAL
- en: The checkpoint protocol serves as a logging tool that keeps a sliding window
    to track active operation requests. The latest stable checkpoint is used for safely
    discarding older requests in the operation log and facilitating the view-change
    protocol.
  prefs: []
  type: TYPE_NORMAL
- en: View-change messages are used to identify if the primary node is Byzantine,
    in which case the view-change protocol is activated. In the case of a primary
    failure, the view-change protocol is triggered at every replica that detects the
    timeout of the primary’s message. They expel the current primary and broadcast
    view-change messages to each other and count receptions. After receiving view-change
    messages from 2*f* peers, the next replica becomes the new primary and informs
    the rest to resume the normal operation.![](../images/516136_1_En_3_Chapter/516136_1_En_3_Figa_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: An algorithm depicts the operational protocol, with a request phase, pre-preparation
    phase, the preparation phase, the commit phase, and the reply phase.
  prefs: []
  type: TYPE_NORMAL
- en: The message complexity of PBFT normal operation is ![$$O(N^2)$$](../images/516136_1_En_3_Chapter/516136_1_En_3_Chapter_TeX_IEq3.png)
    because of the messages in the prepare and commit phases. Every node requires
    receiving more than ![$$2f + 1$$](../images/516136_1_En_3_Chapter/516136_1_En_3_Chapter_TeX_IEq4.png)
    prepare or commit messages in the prepare or commit phase in order to process
    the next requested operation. This relies on at least ![$$2f + 1$$](../images/516136_1_En_3_Chapter/516136_1_En_3_Chapter_TeX_IEq5.png)
    honest nodes in the same state, in view of the assumption that ![$$N \ge 3f +
    1$$](../images/516136_1_En_3_Chapter/516136_1_En_3_Chapter_TeX_IEq6.png). Therefore,
    the remaining *f* Byzantine nodes cannot change the value accepted by the consensus
    of the majority. It follows that PBFT can tolerate *f* Byzantine faults when the
    inequality ![$$N \ge 3f + 1$$](../images/516136_1_En_3_Chapter/516136_1_En_3_Chapter_TeX_IEq7.png)
    holds. According to the fundamental 1/3 BFT threshold, this is the very best BFT
    performance that can be achieved. The readers are referred to [[9](#CR9), [37](#CR37)]
    for more details and rigorous proofs.
  prefs: []
  type: TYPE_NORMAL
- en: PBFT has inspired the development of various other consensus protocols enhancing
    the performance and security. The well-known examples of such protocols include
    Quorum/Update (QU) [[1](#CR1)], Hybrid Quorum (HQ) [[12](#CR12)], Zyzzyva (using
    speculative execution) [[21](#CR21)], FaB [[25](#CR25)], Spinning [[35](#CR35)],
    Robust BFT SMR [[10](#CR10)], and Aliph [[5](#CR5)]. The readers are referred
    to the tutorial [[6](#CR6)] for an overview of these protocols.
  prefs: []
  type: TYPE_NORMAL
- en: 3.3 An Overview of Blockchain Consensus
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A blockchain network allows every participant to be both a client issuing transactions
    and a server validating and finalizing transactions. The data structure of the
    ledger in the blockchain consists of chronologically ordered and hash-chained
    blocks, each of which requires consensus to be included in the ledger. Each block
    contains a collection of valid transactions. The transactions across the blockchain
    should be consistent with each other to prevent double spending, overspending,
    and misappropriation.
  prefs: []
  type: TYPE_NORMAL
- en: Blockchain systems are often associated with financial applications responsible
    for transaction processing and validating. Therefore, the objectives and responsibilities
    of a blockchain consensus protocol may be more enhanced that those of the traditional
    distributed consensus protocols.
  prefs: []
  type: TYPE_NORMAL
- en: 3.3.1 The Objective of Blockchain Consensus
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The objective of a blockchain consensus protocol is to ensure that all participating
    nodes agree on a common network transaction history, which is serialized in the
    form of a ledger. Based on the previous discussion on BFT consensus and the consensus
    goal abstraction provided in [[37](#CR37)], we define the following requirements
    for blockchain consensus.
  prefs: []
  type: TYPE_NORMAL
- en: '**Termination.** At every honest node, a new transaction is either discarded
    or accepted into the blockchain within the content of a block.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Agreement**. Every new transaction and its holding block should be either
    accepted or discarded by all honest nodes. An accepted block should be assigned
    the same sequence number by every honest node.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Validity**. If every node receives the same valid transaction/block, it should
    be accepted into the blockchain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integrity**. At every honest node, all accepted transactions should be consistent
    with each other and should prevent double spending. All accepted blocks should
    be correctly generated and hash-chained in chronological order.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3.3.2 Components of Blockchain Consensus Protocol
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The five key components of a blockchain consensus protocol correspond to the
    main requirements of the preceding subsection as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '**Block Proposal**. Generating blocks and attaching generation proofs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Information Propagation**. Disseminating blocks and transactions across network.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Block Validation**. Checking blocks for generation proofs and transaction
    validity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Block Finalization**. Reaching agreement on the acceptance of validated blocks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Incentive Mechanism**. Promoting honest participation and creating network
    tokens.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These five ingredients provide essential functionality for the blockchain consensus.
    Nevertheless, some of the new blockchain consensus algorithms do not include all
    of these components. For example, the incentive mechanism is absolutely necessary
    for permissionless blockchains. However, permissioned blockchains, where all participation
    are identified and are officially authorized to participate, the incentive mechanisms
    are not necessary, since the administrator may simply require all participants
    to operate correctly without an additional incentive. Many new public blockchain
    proposals only cover the process of block proposal and included the remaining
    components from the Nakamoto consensus algorithm. This is explained by the fact
    that the PoW block proposal is so computationally intensive that it is paramount
    to improve it for sustainability.
  prefs: []
  type: TYPE_NORMAL
- en: 3.4 Proof-of-Work Consensus Protocol
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Nakamoto proof-of-work (PoW) [[28](#CR28)] consensus protocol is the key
    innovation that made Bitcoin possible. It can be summarized as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '**Proof-of-Work (PoW)**. Block generation requires finding a preimage to a
    hash function so that the hash result satisfies a difficulty target, which is
    dynamically adjusted to maintain an average block generation interval.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Gossiping Rule**. Every new received or generated transaction or block should
    be advertised and broadcast to all peers immediately.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Validation Rule**. A block or transaction needs to be validated before being
    broadcast to peers or appended to the blockchain. The validation includes the
    verification that there is no double spending in the transactions and the validity
    of the condition of the proof-of-work in the block header.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Longest-Chain Rule**. The longest chain represents the network consensus,
    which should be accepted by any node who sees it. Mining should always extend
    the longest chain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Block Rewards and Transaction Fees**. The generator of a block can claim
    a certain amount of new tokens plus fees collected from all the enclosed transactions,
    in the form of a coin transaction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The computationally intensive PoW procedure is designed for mitigating the Sybil
    attacks. Bitcoin’s network is permissionless with all participants allowed to
    join in a pseudonymous fashion. The Sybil attack occurs when one member creates
    multiple identities and several accounts. The PoW procedure requires solving difficult
    tasks using real hardware and cannot be forged.
  prefs: []
  type: TYPE_NORMAL
- en: The longest-chain rule ensures that the longest chain of the ledger remains
    stable with possible modifications allowed only to a few last items. Therefore,
    the longest chain can serve as a commonly accepted record of the system history.
    The Bitcoin community does not envisage any authoritative entities and is decentralized.
    Block rewards and transaction fees are used as incentives for the miners to participate
    and create new Bitcoins.
  prefs: []
  type: TYPE_NORMAL
- en: A high-level version of the Nakamoto protocol is presented in Algorithm 3.2\.
    During block generation, more stringent level of the mining difficulty demands
    more brute force trials in order to find a nonce fulfilling the requirements.
    To ensure that every block is sufficiently propagated before the next block comes
    out, the mining difficulty is adjusted every 2016 blocks so that the expected
    block interval remains a constant value (10 min in Bitcoin) no matter how the
    gross hashing power of the miners fluctuates.![](../images/516136_1_En_3_Chapter/516136_1_En_3_Figb_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: An algorithm on Nakamoto Consensus protocol general procedure, with the network
    joining phase, the main loop phase, the gossiping rule phase, the longest-chain
    validation phase, P o W-based block generation phase, P o W hashing puzzle phase,
    and the final condition.
  prefs: []
  type: TYPE_NORMAL
- en: 3.5 Proof-of-Stake Consensus Protocols
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Proof-of-stake (PoS) is an energy efficient alternative to PoW mining. The stake
    of a participant is the set of the coins or network tokens which are owned by
    the node and can be invested to support the blockchain consensus process. Thereby
    token ownership is applied in PoS in order to prevent Sybil attacks. It follows
    that the probability of a PoS miner to propose a block for the ledger is proportional
    to the value of the stake owned by the miner, whereas the chances of a PoW miner
    proposing a block are proportional to the brute force computational power of the
    equipment owned by the miner. From the point of view of sustainability, PoS eliminates
    the waste of computational power and electricity and instead required the miners
    to invest or deposit their stake [[31](#CR31)]. Since PoW consensus does not require
    real mining work and is more similar to investing in capital markets, PoS miners
    are also often called the *validators*, *minters*, or *stakeholders*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We identify four classes of PoS protocols: chain-based PoS, committee-based
    PoS, BFT-based PoS, and delegated PoS (DPoS). Chain-based PoS inherits many of
    the components of the Nakamoto consensus protocol such as information propagation,
    block validation, and block finalization (i.e. longest-chain rule). The difference
    is that the block generation mechanism is replaced with PoS. Committee-based PoS
    leverages a multiparty computation (MPC) scheme to enable a committee to generate
    blocks in unison. BFT-based PoS combines staking with BFT consensus which guarantees
    deterministic finality of blocks. DPoS employs a social voting mechanism that
    elects a fixed-size group of delegates for transaction validation and blockchain
    consensus on behalf of the voters.'
  prefs: []
  type: TYPE_NORMAL
- en: 3.5.1 Chain-Based PoS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Chain-based PoS is an early PoS scheme proposed as an alternative block generation
    mechanism. The gossiping rule of the message passing, the block validation rule,
    the longest-chain rule, and the probabilistic finality remain the same as in the
    Nakamoto consensus framework. Early chain-based PoS blockchain systems include
    Peercoin and Nxt.
  prefs: []
  type: TYPE_NORMAL
- en: The general procedure of a chain-based PoS minter is summarized in Algorithm 3.3\.
    A PoS minter can solve the hashing puzzle only once for a clock tick. Since the
    role of the minter increases with the growth of the minter’s stake value, the
    expected number of hashing attempts for a minter can be reduced in order to prevent
    one minter from dominating the system. In this way PoS avoids the brute force
    competition of the miners and reduces energy usage.![](../images/516136_1_En_3_Chapter/516136_1_En_3_Figc_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: An algorithm on the chain-based general procedure, with joining network phase,
    the main loop segment, the PoS-based block generation, PoS hashing puzzle phase,
    and the final condition.
  prefs: []
  type: TYPE_NORMAL
- en: 3.5.2 Committee-Based PoS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A committee-based PoS determines a committee of stakeholders based on their
    stakes and allows the committee members to take turns and generate blocks. A secure
    multiparty computation (MPC) technique is often used to derive such a committee
    in the distributed network. MPC is a genre of distributed computing in which multiple
    parties with individual inputs compute the outcome securely without revealing
    the values of their individual entries [[32](#CR32)]. The MPC process in the committee-based
    PoS essentially realizes the functionality that takes in the current blockchain
    state with the stake values from all stakeholders, and outputs a pseudo-random
    sequence of stakeholders called the *leader sequence*. The leaders then populate
    the committee according to their order in the sequence. The same leader sequence
    is known to all nodes. The participants with higher stakes are allowed to occupy
    earlier places and can occur more frequently in the sequence. A general procedure
    for a node of a committee-based PoS is shown in Algorithm 3.4\. In this algorithm,
    the CommitteeElect() function can also be implemented in a privacy-preserving
    way with a verifiable random function (VRF) [[26](#CR26)] so that only the nodes
    themselves know whether they are elected into the committee.![](../images/516136_1_En_3_Chapter/516136_1_En_3_Figd_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: An algorithm on the committee-based P o S general procedure, with the phase
    of joining network and stalking, the main loop phase, the committee election phase,
    the phase to block proposing and broadcast, the longest-chain and validation rule
    phase, the PoS-based committee selection phase, and the final condition.
  prefs: []
  type: TYPE_NORMAL
- en: 3.5.3 BFT-Based PoS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Chain-based PoS and committee-based PoS largely follow the Nakamoto consensus
    framework in that the longest-chain rule is still used to provide probabilistic
    finality of blocks. In comparison, BFT-based PoS (or hybrid PoS-BFT) incorporates
    an extra layer of BFT consensus that provides fast and deterministic block finalization.
    Algorithm 3.5 shows the general procedure of a BFT-based PoS for every participant.
    The process of proposing blocks can be organized using any PoS mechanism: round-robin,
    committee-based, or other methods. The only requirement is for the process to
    guarantee a stable flow of new blocks into the ledger.'
  prefs: []
  type: TYPE_NORMAL
- en: A verification mechanism can be used to confirm the finality of the blockchain
    ledger. This option is not included in Algorithm 3.5\. Then, the longest-chain
    rule can be replaced by the most-recent-verification rule for determining the
    stable main chain. Popular BFT-based PoS blockchain protocols include Tendermint,
    Algorand, and Casper FFG. DPoS protocols such as EOSIO also use BFT consensus
    for block finalization among the delegates.![](../images/516136_1_En_3_Chapter/516136_1_En_3_Fige_HTML.png)
  prefs: []
  type: TYPE_NORMAL
- en: An algorithm on the B F T based PoS general procedure, with joining network
    and stalking, the main loop segment, block proposing and broadcast, block validation
    phase, the consensus layer of B F T, PoS-based block generation, B F T-based block
    finalization, and the final condition.
  prefs: []
  type: TYPE_NORMAL
- en: 3.5.4 Delegated PoS (DPoS)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Delegated PoS (DPoS) employs a democratic form of creating committees for PoS.
    The consensus committee is chosen via stake delegation made publicly. The DPoS
    is used by BitShares 2.0 [[8](#CR8)], Lisk [[24](#CR24)], EOSIO [[16](#CR16)],
    and Cosmos [[33](#CR33)]. DPoS is designed to control the size of the consensus
    group so that the messaging overhead of the consensus protocol remains manageable.
    Members of the consensus group are also called *delegates*. The election of delegates
    is also called the delegation process.
  prefs: []
  type: TYPE_NORMAL
- en: In order to be elected as a delegate, each candidate has to attract enough votes
    from the token holders. This is often accomplished by offering a popular application
    and building up reputation through propaganda campaigns. By casting a vote to
    a delegate via a blockchain transaction, a token holder entrusts the delegate
    with the holder’s own stake. As a result, the delegate amalgamates the stake voting
    power from the voters and acts as their proxy in the consensus process. A token
    holder can switch vote to another delegate via a new delegation transaction. For
    example, the EOSIO protocol mandates that anyone can be a delegate and solicit
    votes, but only those rising to top 21 join the consensus group, among whom the
    right of block proposal is equally shared. EOSIO employs a pipelined PBFT-style
    consensus scheme to finalize the proposed blocks across the 21 delegates [[22](#CR22)].
    Specially, the physical time is divided into slots and the 21 delegates take turns
    to propose a block in a round-robin fashion. At each slot when a delegate proposes
    a block, the consensus scheme goes through pre-commitment and commitment phases
    and declares a decision on the proposed block. Because of the small size of the
    consensus group and the well-ordered PBFT-style process, every new valid transaction
    can be promoted to the consensus group and finalized in the blockchain almost
    instantly.
  prefs: []
  type: TYPE_NORMAL
- en: To enforce transaction validation and consensus safety, the DPoS’s incentive
    mechanism is designed to encourage honest delegation and consensus participation.
    Every delegate receives a daily reward proportional to the votes the delegate
    has. After rising to the consensus group, delegates also receive rewards for the
    validation of every block.
  prefs: []
  type: TYPE_NORMAL
- en: 3.6 Other Blockchain Consensus Protocols
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The majority of the modern blockchain consensus procedures apply the established
    techniques such as PoW, PoS, and BFT with only minor modifications and improvements.
    However, there are also numerous other promising proposals of novel blockchain
    consensus algorithms investigated in the academic literature addressing the needs
    of various application domains. Many of these novel schemes remain conceptual
    and describe only one or two of the five blockchain consensus protocol components.
    Next, we review the proof-of-authority (PoA), proof-of-elapsed-time (PoET), proof-of-TEE-stake
    (PoTS), and proof-of-retrievability (PoR).
  prefs: []
  type: TYPE_NORMAL
- en: 3.6.1 Proof-of-Authority (PoA)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The term proof-of-authority (PoA) was introduced by the Ethereum co-founder
    Gavin Wood as an replacement for PoW and PoS. It is currently deployed in Ethereum’s
    Rinkeby (2017) and Kovan (2017) testnets, and POA Network (2018) [[30](#CR30)].
    The PoA protocol is a modification of PoS. The validators use their authorized
    identities as stakes instead of tokens of monetary value. In order to be accepted
    as a PoA validator in the consensus team, each candidate has to pass a mandatory
    certification procedure that assigns an approved value of the authority to the
    candidate. During the process, the identity of the candidate may be verified,
    and previous history of operation may be taken into account since it demonstrates
    the ability to contribute to the operation of the consensus team. The official
    certification document can then be made publicly available. The consensus team
    should be stable and relatively small in size. It is reviewed publicly by all
    participants ensuring that the users can trust the team with reliable transaction
    processing and blockchain management. The validators who show incompetence or
    misbehaviour in these tasks are to be vetted and excluded by the users and peer
    validators.
  prefs: []
  type: TYPE_NORMAL
- en: 3.6.2 Proof-of-Elapsed-Time (PoET)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: PoET was proposed by Intel as an alternative mining mechanism in 2016 and subsequently
    used in the Hyperledger Sawtooth family [[34](#CR34)]. Instead of undergoing the
    hashing-intensive mining, PoET simulates the time that would be consumed by PoW
    mining. That is, every node randomly backs off for an exponentially distributed
    period of time before announcing its block. To ensure that the local time truly
    elapses, PoET requires the back-off mechanism to be carried out in a trusted execution
    environment (TEE), which is an isolated area of memory providing confidentiality
    and integrity to the program running inside, against a compromised hosting platform.
    The program included in a TEE is called an *enclave*. Intel SGX [[11](#CR11)]
    and Arm TrustZone [[3](#CR3)] are the two major TEE solutions. Along with a number
    of other facilities, TEE provides a proof of integrity of the enclave program
    via remote attestation, which helps the network to establish trust in the consensus
    nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 3.6.3 Proof-of-TEE-Stake (PoTS)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Proof-of-TEE-Stake (PoTS) is one more protocol relying on TEE for blockchain
    consensus. It was proposed by Li et al. [[23](#CR23)] and was formalized by Andreina
    et al. [[2](#CR2)]. Every PoTS node *i* follows the same setup procedure as in
    PoET to set up a TEE enclave, generate the signing key pair ![$$\langle SK_i,
    PK_i \rangle $$](../images/516136_1_En_3_Chapter/516136_1_En_3_Chapter_TeX_IEq8.png),
    and communicate the setup to the network. Instead of simulating the elapsed time
    of the PoW mining, the enclave program of PoTS is analogous to the Algorand’s
    cryptographic scheme that randomly selects a committee according to the stake
    distribution. Every node in the committee is eligible to propose a new block for
    the coming block cycle. To prove that the block proposal is eligible, the block
    includes the eligibility proof signature ![$$\sigma ^{ep}_{SK_i}$$](../images/516136_1_En_3_Chapter/516136_1_En_3_Chapter_TeX_IEq9.png),
    which is produced by the enclave program of the block generating node *i*. Once
    other nodes receive this block, they validate the block content as well as its
    signature ![$$\sigma ^{ep}_{SK_i}$$](../images/516136_1_En_3_Chapter/516136_1_En_3_Chapter_TeX_IEq10.png)
    using the node’s public key ![$$PK_i$$](../images/516136_1_En_3_Chapter/516136_1_En_3_Chapter_TeX_IEq11.png).
    The longest-chain rule is then used to determine whether to accept this block
    into the ledger.
  prefs: []
  type: TYPE_NORMAL
- en: 3.6.4 Proof-of-Retrievability (PoR)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Proof-of-Retrievability (PoR) was originally proposed by Juels and Kaliski [[18](#CR18)]
    as a cryptographic cornerstone for a semi-trusted distributed archive. The key
    facility of PoR allows file owners to verify whether their online files or file
    fragments are stored securely and are retrievable by applying a special challenge-response
    protocol. The retrievability of a file *F* at a remote node ![$$n_i$$](../images/516136_1_En_3_Chapter/516136_1_En_3_Chapter_TeX_IEq12.png)
    can prove ![$$n_i$$](../images/516136_1_En_3_Chapter/516136_1_En_3_Chapter_TeX_IEq13.png)
    indeed spends the required amount of storage resources on *F*. Because of the
    space requirement inherent in the retrievability, the PoR is also known as a *proof-of-space*.
  prefs: []
  type: TYPE_NORMAL
- en: As a distributed consensus protocol, PoR was first used by the cryptocurrency
    Permacoin proposed by Miller et al. [[27](#CR27)]. It was invented as another
    alternative to PoW eliminating the mining work. In the algorithm, a central administrator
    publishes a target dataset *F* and computes the digest of *F* (the Merkle hash
    tree root of all segments of *F*). Then each participant stores some random segments
    of *F* per its storage capability and computes the digest of these segments. For
    every block cycle, the dealer initiates a lottery game with a random puzzle. Then
    every participant derives a lottery ticket consisting of a fixed number of PoR
    challenges from its locally stored segments, public key, and the puzzle.
  prefs: []
  type: TYPE_NORMAL
- en: Participants with more data stored have higher probability of winning the lottery
    and thus being eligible to generate a block. All PoR challenges are stored in
    the new block and verified by the whole network. Permacoin also implements a signature
    scheme to discourage participants from outsourcing the storage task. Apart from
    employing PoR, the Permacoin inherits the methods of Bitcoin for other components
    of the consensus mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: The PoR is more economical that PoW and has advantages. First, the file storage
    of PoR consumes less energy than the brute force mining of PoW. Second, the storage
    space as a resource can be recycled. Third, the PoR can be reprogrammed to perform
    useful and meaningful storage tasks, which are not wasteful but bring other benefits.
    For example, the dataset used in the procedure can be some large but useful public
    dataset, which has to be stored for the benefit of many users.
  prefs: []
  type: TYPE_NORMAL
